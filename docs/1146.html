<html>
<head>
<title>Evolution of PaaSes to Platform-as-Code in Kubernetes world</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes世界中，从PaaSes到平台即代码的演变</h1>
<blockquote>原文：<a href="https://itnext.io/evolution-of-paases-to-platform-as-code-in-kubernetes-world-74464b0013ca?source=collection_archive---------1-----------------------#2018-07-30">https://itnext.io/evolution-of-paases-to-platform-as-code-in-kubernetes-world-74464b0013ca?source=collection_archive---------1-----------------------#2018-07-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3cca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">典型的应用程序堆栈可以描述如下，其中基础架构是构建应用程序平台的基础，然后在此堆栈上部署应用程序。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/6c77d0b7e258643119db772e70dc39a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Nm1-prKZaZ6VQCjDx4Y5A.jpeg"/></div></div></figure><p id="e3cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">云计算的发展带来了简化这些应用程序堆栈构建的机会。云计算始于“<strong class="jp ir">即服务</strong>”的概念，在这一概念中，您可以承诺按需提供此应用程序堆栈“<strong class="jp ir">”的元素</strong>。这种“即服务”模式始于AWS EC2等“基础设施即服务(IaaS)”，然后慢慢发展为Heroku、Amazon Beanstalk、Google App Engine等“平台即服务(PaaS)”。</p><p id="f6c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与“<strong class="jp ir">作为代码</strong>的概念并行，它主要在“基础设施作为代码”系统中流行，如AWS Cloud Formation和Terraform。“基础设施即代码”系统在提供基础设施元素方面带来了“<strong class="jp ir">可重复性和可共享性</strong>”的承诺。您可以声明性地编写基础结构元素，并使用该声明/代码重复提供它们。AWS Cloud Formation等“基础设施即代码”系统在单个云上重复创建相同的基础设施元素，而Terraform等系统在多云环境中跨多个云创建这些元素。这些系统依赖于抽象IaaS APIs，并以公共声明性语言捕获这些API。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kx"><img src="../Images/106190ef5ce79b581dc9499d4cd05502.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R8aLK3XOF-aPZ_TIDGGbwA.jpeg"/></div></div></figure><p id="ad04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">容器化的浪潮模糊了基础设施层和平台层之间的界限，并带来了通常被称为“容器即服务”(CaaS)的新系统。容器展示了在不同基础设施层之间移动相同应用程序堆栈的前景。这改变了“多云”的概念，从仅仅在不同的云中提供元素，到能够在云之间移动整个应用程序堆栈。</p><p id="15dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes以其声明性的YAML格式帮助实现了容器化应用平台栈的可重复性和可共享性。这样的YAML声明可以用于你的应用程序代码，也可以用于容器化的平台元素，比如MySQL、RabbitMQ等。</p><p id="1da7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上，Kubernetes和它的YAML声明可以被认为是一个系统，它提供了以代码形式创建应用程序平台的能力。将基础设施作为代码，Kubernetes YAMLs易于共享，并且可以在任何云上的任何Kubernetes集群上以重复的方式创建应用程序堆栈。它们之间的区别在于，平台即代码系统为<a class="ae ky" href="https://medium.com/@cloudark/microservices-and-relational-data-stores-in-public-clouds-7c7949d29ae1" rel="noopener">应用程序及其与所提供的平台元素</a>的绑定提供了一流的支持。相比之下，作为代码系统的基础设施只关注基础设施元素的供应和管理。</p><p id="6a31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">深入思考后，我们意识到，基于应用平台堆栈需求的复杂程度，存在一系列“平台即代码”系统。一端是库贝内特斯基地。使用它，您可以创建/重新创建使用基本Kubernetes构造定义的应用程序平台，其中所有平台元素都被定义为容器。</p><p id="a4d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，如果应用程序想要绑定和使用特定云上作为托管服务提供的平台元素(例如:Amazon RDS、Google CloudSQL等),基本的Kubernetes是不够的。).为了解决此类用例，我们创建了一个名为“<a class="ae ky" href="https://github.com/cloud-ark/caastle" rel="noopener ugc nofollow" target="_blank"> CaaStle </a>的工具，该工具将托管托管服务的供应与CaaS的声明式定义格式相集成，从而提供全栈微服务开发&amp;部署体验。CaaStle是“平台即代码”系统的一个例子，它专注于解决容器化应用程序与基于云的托管服务的集成。这种系统的另一个例子是安装了<a class="ae ky" href="https://github.com/kubernetes-incubator/service-catalog" rel="noopener ugc nofollow" target="_blank">服务目录服务器</a>的Kubernetes集群。</p><p id="98a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您决定不使用托管服务，而是坚持使用容器化的平台元素来避免供应商锁定，则会出现另一种复杂性。在这种情况下，如果您需要容器化平台元素的高级功能，例如执行特定于应用程序的生命周期操作(例如:定期备份MySQL容器或更新MySQL实例的用户密码)，那么基本的Kubernetes YAMLs是不够的。</p><p id="84aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是<a class="ae ky" href="https://coreos.com/operators/" rel="noopener ugc nofollow" target="_blank"> Kubernetes操作符</a>概念的由来。Kubernetes操作符允许您使用定制资源和定制控制器来扩展Kubernetes。使用Kubernetes Operator，可以为所需的平台元素定义定制资源，如MySQL、Nginx，类似于任何其他本地Kubernetes资源，如Pods、服务等。您的平台元素成为Kubernetes声明性YAML定义的组成部分。所需的特定于应用的生命周期动作被编码在管理这些定制资源的定制控制器中。用操作符扩展的Kubernetes集群成为另一种“平台即代码”系统。</p><p id="1af2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在正在开发名为'<a class="ae ky" href="https://github.com/cloud-ark/kubeplus" rel="noopener ugc nofollow" target="_blank"> KubePlus </a>'的框架，该框架遵循了这种平台作为代码的方法，通过运营商来扩展Kubernetes。我们正在标准化一些开源的Kubernetes操作者，这样他们就可以互相协作，形成一个完整的应用堆栈。</p><p id="caa5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像KubePlus这样的系统的一个显著特点是，它们关注于扩展基础CaaS层(在这里是Kubernetes)而不是抽象它。这与传统的平台即服务系统形成了鲜明的对比，后者倾向于将底层CaaS系统抽象化。关于Kubernetes，抽象之上的扩展允许用户利用Kubernetes的全部功能。此外，他们可以根据自己的需求定制自己的平台，而不会拘泥于固执己见地选择预构建的平台。因此，在某种程度上，KubePlus的“平台即代码”方法可以被认为是为Kubernetes提供了“构建您自己的PaaS”体验。</p><p id="396b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们相信“平台即代码”是为Kubernetes构建下一代定制平台和平台即服务系统的基础原则。它们将提供在任何Kubernetes集群上创建定制平台栈的可重复性。平台工件，如Kubernetes YAML文件，舵图，运营商清单等。将在团队之间共享。如果需要托管服务，它们将直接集成到应用程序编排模板中。如果避免厂商锁定至关重要，那么嵌入定制生命周期操作的Kubernetes运营商将是最佳选择。</p><p id="4db0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae ky" href="https://cloudark.io/" rel="noopener ugc nofollow" target="_blank"> www.cloudark.io </a></p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="3f9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:如果你喜欢这篇文章，你可能也想看看【Kubernetes API扩展如何实现平台即代码体验</p></div></div>    
</body>
</html>