<html>
<head>
<title>Webpack explained simply — plugins, loaders and Babel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Webpack解释得很简单——插件、加载器和巴别塔</h1>
<blockquote>原文：<a href="https://itnext.io/webpack-explained-simply-plugins-loaders-and-babel-6d6dce6933c4?source=collection_archive---------0-----------------------#2019-06-22">https://itnext.io/webpack-explained-simply-plugins-loaders-and-babel-6d6dce6933c4?source=collection_archive---------0-----------------------#2019-06-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/bb357494be2dd795bc419a76bdf07330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QCTr2gJDh8RbM27lFG0HAQ.jpeg"/></div></div></figure><p id="dbce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Webpack席卷了web开发世界。自发布以来，它被Airbnb和脸书等大公司以及Angular和React等web开发框架所采用。虽然很明显Webpack在当今的web开发中起着重要的作用，但是直到最近我才弄清楚Webpack的确切特性和功能。所以在这篇文章中，我尽可能用最简单的方式来解释Webpack。</p><h1 id="3b0e" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">什么是webpack？</h1><p id="caf5" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">简单地说，Webpack是一个工具，用于将您的代码放入处理管道，并将其打包成一个JavaScript文件。</p><p id="0400" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么我们在谈论什么样的处理呢？为了解释这一点，我们需要回到长期存在的JavaScript模块冲突问题。在Node.js之前，开发人员必须使用不同的技巧来避免JavaScript中的变量名冲突。Node.js推出了一个很棒的解决方案——CommonJS模块化系统。不幸的是，浏览器本身并不支持CommonJS。这就是Webpack的用武之地。我们可以使用Node.js模块化系统和类似<code class="fe mc md me mf b">require()</code>和<code class="fe mc md me mf b">module.exports</code>的东西来编写我们的应用程序，并使用Webpack将其捆绑到一个与所有浏览器兼容的JavaScript文件中。让我们看一个简单的例子，以便更好地理解:</p><p id="6c5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">想象一下，您有一个包含两个文件<code class="fe mc md me mf b">greet.js</code>和<code class="fe mc md me mf b">main.js</code>的项目。下面是<code class="fe mc md me mf b">greet.js</code>的内容:</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="8b74" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该模块使用<code class="fe mc md me mf b">module.exports</code>公开一个函数。该函数简单地返回带有问候字符串的<code class="fe mc md me mf b">h2</code>标签。现在让我们来看看<code class="fe mc md me mf b">main.js</code>:</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="869a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的<code class="fe mc md me mf b">main.js</code>脚本使用<code class="fe mc md me mf b">require</code>导入<code class="fe mc md me mf b">greet.js</code>，这也是特定于Node.js模块化系统的。然后，这个脚本调用我们的greet函数，并将结果存储在当前html页面的<code class="fe mc md me mf b">body</code>标签中。</p><p id="7839" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您试图在浏览器中运行这段代码，它肯定会失败。这就是为什么我们需要使用Webpack。在你的项目文件夹中运行这个命令:<code class="fe mc md me mf b">webpack main.js -o bundle.js</code>，它将捆绑<code class="fe mc md me mf b">main.js</code>及其所有依赖项。</p><p id="4519" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后一步，让我们创建一个简单的html页面，并将我们的包插入其中:</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="21c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你打开我们的html页面，你应该会看到问候。使用Node.js系统导出和导入模块不是很容易吗？我们不必担心管理依赖项或配置路径，我们所要做的就是导出我们的<code class="fe mc md me mf b">greet</code>模块并使用<code class="fe mc md me mf b">require</code>导入它。</p><h1 id="f8d1" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">加载程序和插件</h1><p id="2b08" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">因为CommonsJS可以说是JavaScript世界目前提供的最好的模块化系统，仅此一点就足以开始使用Webpack。然而，Webpack是一个非常灵活和强大的工具，可以提供更多的功能。Webpack最突出的功能之一是插件和加载器。</p><p id="1dd3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Webpack中的加载器和插件允许在捆绑过程中添加更多的规则或处理管道。内置和第三方加载器是Webpack如此强大和流行的主要原因之一。</p><p id="2fa2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然乍一看，它们似乎是用来完成相同的事情，但在Webpack中，加载器和插件是不同的:</p><p id="261e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">装载机</strong>:</p><ul class=""><li id="8e4b" class="mm mn it kd b ke kf ki kj km mo kq mp ku mq ky mr ms mt mu bi translated">在包生成之前或开始时工作</li><li id="3a65" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">加载器在单个文件级别工作</li></ul><p id="3af3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">插件</strong>:</p><ul class=""><li id="88d8" class="mm mn it kd b ke kf ki kj km mo kq mp ku mq ky mr ms mt mu bi translated">在包生成结束时或之后工作</li><li id="3086" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">插件在包级别工作</li><li id="fcb7" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">插件对捆绑包有更多的控制</li></ul><h2 id="1c76" class="na la it bd lb nb nc dn lf nd ne dp lj km nf ng ln kq nh ni lr ku nj nk lv nl bi translated">巴贝尔装载机</h2><p id="6052" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">Babel loader用于将以现代风格和JavaScript超集编写的代码转换为受旧浏览器支持的普通旧JavaScript代码。由于Babel loader，我们可以享受新的JavaScript语法，并使用EcmaScript 2015甚至JSX (React)编写我们的代码。让我们来看一个示例<code class="fe mc md me mf b">webpack.config.js</code>文件，它是一个配置文件，用于声明Webpack在您的项目中使用的所有插件和加载器:</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="b17a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如您所看到的，这个模块所做的只是导出一个配置文件，当您运行命令行来传输您的代码时，Webpack将使用这个文件。这个文件有<code class="fe mc md me mf b">entry</code>和<code class="fe mc md me mf b">output</code>字段，它们决定了传输器的输入和输出文件的位置。很简单。</p><p id="cce6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mc md me mf b">loaders</code>子字段是我们定义Webpack使用的加载器的地方。这里我们只定义<code class="fe mc md me mf b">babel-loader</code>。<code class="fe mc md me mf b">test</code>字段接受正则表达式模式或目录位置，它决定哪些文件将受到加载程序的影响。在这种情况下，位于<code class="fe mc md me mf b">src</code>文件夹中的所有文件都会受到我们的加载程序的影响。</p><p id="b063" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Babel loader使用预设来处理不同的JavaScript风格和超集。Babel有很多不同的预设。在这种情况下，我们使用<code class="fe mc md me mf b">es2015</code>预设将任何EcmaScript 2015代码转换成普通JavaScript。<code class="fe mc md me mf b">presets</code>数组可以包含不止一个预置，例如我们可以添加<code class="fe mc md me mf b">react</code>预置来在我们的项目中编写JSX代码。</p><h2 id="0914" class="na la it bd lb nb nc dn lf nd ne dp lj km nf ng ln kq nh ni lr ku nj nk lv nl bi translated"><strong class="ak">丑陋插件</strong></h2><p id="0c67" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">如前所述，插件通常在transpiling过程的末尾执行，并在包级别工作。</p><p id="017a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看看<a class="ae nm" href="https://www.npmjs.com/package/uglifyjs-webpack-plugin/v/1.3.0" rel="noopener ugc nofollow" target="_blank">丑陋的</a>插件。这个插件用来混淆你的代码和缩小生成的包。它通过将变量的名称改为较短的名称并从代码中删除空格来实现这一点。下面是你如何在你的<code class="fe mc md me mf b">webpack.config.js</code>中定义一个插件:</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="b1b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的代码中，我们声明了用于定义插件设置的<code class="fe mc md me mf b">uglifyJSPlugin</code>对象。我们设置了<code class="fe mc md me mf b">beautify: false</code>,这样我们生成的包的代码就不会被格式化，这使得恶意用户更难阅读。我们还指定了<code class="fe mc md me mf b">dead_code: true</code>，它将从捆绑包中删除所有的死代码，这在设置动态代码分支时非常有用，也有助于减少捆绑包的大小。</p><p id="85d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">注意:</strong>为了让上面的代码工作，你需要使用npm在你的项目中单独安装巴别塔加载器、预置和丑陋插件。</p><h1 id="3037" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Webpack的其他优势</h1><p id="59fe" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我们已经看到了足够多的东西来说服我们Webpack是多么有用。然而，以下是Webpack成为如此伟大的工具的几个原因:</p><ul class=""><li id="9709" class="mm mn it kd b ke kf ki kj km mo kq mp ku mq ky mr ms mt mu bi translated">Webpack为许多核心Node.js模块提供了浏览器兼容版本。这意味着我们可以使用以前只有Node.js才有的模块，比如<code class="fe mc md me mf b">http</code>或者<code class="fe mc md me mf b">events</code>。</li><li id="8104" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">我们可以从构建中排除不兼容的模块，或者用兼容的模块替换它们。Webpack可以配置为在构建期间交换模块。</li><li id="4807" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">您可以从任务管理工具(如Gulp和Grunt)调用web pack。</li><li id="a2cd" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">Webpack可以用来捆绑不同种类的文件，而不仅仅是JavaScript。</li></ul></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="7f75" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇短文中，我们讨论了Webpack的主要职责和特性。我们学习了Webpack中加载器和插件的基本知识以及它们的区别。我们还讨论了为什么Webpack对于web开发来说是如此重要的工具。</p><p id="a6e3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然还有其他的transpiling工具，如<a class="ae nm" href="http://browserify.org/" rel="noopener ugc nofollow" target="_blank"> Browserfy </a>和<a class="ae nm" href="https://rollupjs.org/guide/en/" rel="noopener ugc nofollow" target="_blank"> RollupJS </a>，但由于其强大的功能，Webpack是当今最广泛采用的transpilers之一。</p><p id="23b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢您的阅读！</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="5e4d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nu">原载于2019年6月22日</em><a class="ae nm" href="https://isamatov.com/webpack-explained-simply-plugins-loaders-and-babel/" rel="noopener ugc nofollow" target="_blank"><em class="nu">https://isamatov.com</em></a><em class="nu">。</em></p></div></div>    
</body>
</html>