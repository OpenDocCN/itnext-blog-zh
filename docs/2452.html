<html>
<head>
<title>Understanding Angular Interceptors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解角度拦截器</h1>
<blockquote>原文：<a href="https://itnext.io/understanding-angular-interceptors-405b84d7ad69?source=collection_archive---------2-----------------------#2019-05-27">https://itnext.io/understanding-angular-interceptors-405b84d7ad69?source=collection_archive---------2-----------------------#2019-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="58c6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有了实际例子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/71769890cdcd482feb63bdf9eab99a87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O4CWo9XMYYHtIKb6tAWUDQ.png"/></div></div></figure><p id="2774" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">顾名思义，Angular中的拦截器是框架提供的一种简单方法，在应用程序的http请求被发送到服务器之前，<strong class="kw iu">全局拦截和修改应用程序的http请求。这真的很方便，允许我们配置应用程序可能需要的<em class="lq">认证令牌</em>、<strong class="kw iu">、</strong>添加请求的<em class="lq">日志</em>、<strong class="kw iu">、</strong>添加自定义头<em class="lq">、</em>、<strong class="kw iu">、</strong>等等。</strong></p><blockquote class="lr ls lt"><p id="56cc" class="ku kv lq kw b kx ky ju kz la lb jx lc lu le lf lg lv li lj lk lw lm ln lo lp im bi translated"><em class="it"> " </em>拦截器可以为每个HTTP请求/响应执行各种各样的<em class="it">隐式</em>任务，从身份验证到日志记录，以一种常规、标准的方式进行。如果没有拦截，开发人员将不得不为每个HttpClient方法调用显式地实现这些任务</p></blockquote><h2 id="9e13" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">实现拦截器</h2><p id="4be5" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">为了实现拦截器，您需要创建一个类，让<strong class="kw iu">实现<em class="lq"> HttpInterceptor </em>接口的<em class="lq">拦截</em>方法。</strong></p><p id="2a44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，让我们假设您希望<strong class="kw iu">在控制台中记录应用程序发出的每个http请求</strong>。下面，我创建了一个简单的拦截器，它将实现以下功能。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="e3c7" class="lx ly it mw b gy na nb l nc nd">@Injectable()<br/>export class RequestLogInterceptor implements HttpInterceptor {</span><span id="ab57" class="lx ly it mw b gy ne nb l nc nd">  intercept(<br/>    request: HttpRequest&lt;any&gt;, next: HttpHandler<br/>  ) : Observable&lt;HttpEvent&lt;any&gt;&gt; {</span><span id="0025" class="lx ly it mw b gy ne nb l nc nd">    console.log(request.url);<br/>    return next.handle(request);</span><span id="36d3" class="lx ly it mw b gy ne nb l nc nd">  }<br/>}</span></pre><p id="834a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq"> intercept </em>方法将每个请求转换为<em class="lq">Observables，</em>observable，稍后将通过调用<em class="lq"> next.handle() </em>来解析observable。因此，对于我们的实现来说非常简单:您接受请求，记录它的<em class="lq"> url </em>并调用<em class="lq"> next.handle() </em>将其发送到服务器，而不对其进行任何更改。</p><p id="6cd1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq"> next </em>对象表示拦截器链中的下一个拦截器，因为<strong class="kw iu">您的应用程序中可以有多个拦截器。</strong>然后，链中的最后一个<em class="lq">下一个</em>实际上是<em class="lq"> HttpClient后端处理程序，</em>实际上将请求发送到服务器。</p><h2 id="1b1e" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">提供拦截器</h2><p id="1fbf" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">因为拦截器是<em class="lq"> HttpClient </em>的依赖项，所以您必须将它们添加到提供<em class="lq"> HttpClient </em>的同一个注入器(或父注入器)中的提供者。例如，假设您将<em class="lq"> HttpClientModule </em>导入到<em class="lq"> AppModule中，</em>您也必须将拦截器添加到<em class="lq">提供者</em>中。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="1f89" class="lx ly it mw b gy na nb l nc nd">...<br/>import { <a class="ae nf" href="https://angular.io/api/common/http/HTTP_INTERCEPTORS" rel="noopener ugc nofollow" target="_blank">HTTP_INTERCEPTORS</a> } from '@angular/common/<a class="ae nf" href="https://angular.io/api/common/http" rel="noopener ugc nofollow" target="_blank">http</a>';<br/>import { RequestLogInterceptor } from '...';</span><span id="4fcf" class="lx ly it mw b gy ne nb l nc nd">@NgModule({<br/>  ...<br/>  imports: [<br/>    HttpClientModule,<br/>    ...<br/>  ],<br/>  providers: [<br/>    {<br/>      provide: HTTP_INTERCEPTORS,<br/>      useClass: RequestLogInterceptor,<br/>      multi: true<br/>    },<br/>   ...<br/>  ],<br/>  ...<br/>})</span><span id="260e" class="lx ly it mw b gy ne nb l nc nd">export class AppModule { }</span></pre><p id="1f3c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">提供的<em class="lq"> multi: true </em>选项告诉Angular，你正在提供<strong class="kw iu">多个拦截器</strong>，如果是这种情况，这是必需的。在我们的示例场景中，这是不必要的，因为我们只实现了一个拦截器，所以我应用它只是为了突出这一点信息。</p><p id="5387" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">记住Angular <strong class="kw iu">按照您在模块的提供者中提供给它们</strong>的顺序来应用拦截器也很重要。</p><h2 id="8343" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">处理认证</h2><p id="f8c6" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">好了，现在让我们深入了解拦截器最常见的用法之一，即处理应用程序的认证。这一次，我们将使用拦截器实际更改http请求，以便<strong class="kw iu">向它添加授权头</strong>。</p><p id="9dbd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们的应用程序正在我们的<em class="lq">本地存储器</em>上设置登录的用户信息，我们将读取它以便检查是否有人登录。在现实世界的应用程序中，我们会有一个服务来处理所有的认证流，但是出于学习的目的，我将简化并直接从<em class="lq"> localstorage </em>中获取信息。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="8d05" class="lx ly it mw b gy na nb l nc nd">@Injectable()<br/>export class AuthenticationInterceptor implements HttpInterceptor {</span><span id="7600" class="lx ly it mw b gy ne nb l nc nd">  intercept(<br/>    request: HttpRequest&lt;any&gt;, next: HttpHandler<br/>  ) : Observable&lt;HttpEvent&lt;any&gt;&gt; {</span><span id="ab95" class="lx ly it mw b gy ne nb l nc nd">    const storageUser = localStorage.getItem('LoggedUser');</span><span id="f0fa" class="lx ly it mw b gy ne nb l nc nd">    const loggedUser = jsonInfo ? JSON.parse(jsonInfo) : null;</span><span id="58aa" class="lx ly it mw b gy ne nb l nc nd">    if (loggedUser) {<br/>      request = request.clone({<br/>          headers: req.headers.set(<br/>            'Authorization',<br/>            loggedUser.authToken<br/>          )<br/>      });<br/>    }</span><span id="472f" class="lx ly it mw b gy ne nb l nc nd">    return next.handle(request);<br/>  }<br/>}</span></pre><p id="11fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们的应用程序中可能有打开的请求——这意味着不是所有的请求都需要认证——所以如果用户没有登录到应用程序中，我们不会默认抛出任何类型的错误。然而，如果是，我们将<strong class="kw iu">发送它的认证令牌给服务器。</strong></p><p id="42d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一方面，通过发送错误的令牌或过期的令牌，我们仍然可能收到来自服务器的身份验证错误。因此，我们也可以在我们的<em class="lq">认证处理器</em>上解决这个问题。</p><p id="e0b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们要做的是:如果请求不成功，检查它是否是一个认证错误(401未授权)。如果是，我们将把用户从应用程序中注销，并把他重定向到登录页面，告诉他访问被拒绝。</p><p id="058b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面，我们将把这个处理添加到我们的<em class="lq">AnthenticationInterceptor</em>中。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="6a9d" class="lx ly it mw b gy na nb l nc nd">@Injectable()<br/>export class AuthenticationInterceptor implements HttpInterceptor {</span><span id="490f" class="lx ly it mw b gy ne nb l nc nd">  constructor(<br/>    private _router: Router<br/>  ) { }</span><span id="e7fb" class="lx ly it mw b gy ne nb l nc nd">  intercept(<br/>    request: HttpRequest&lt;any&gt;, next: HttpHandler<br/>  ) : Observable&lt;HttpEvent&lt;any&gt;&gt; {</span><span id="5e90" class="lx ly it mw b gy ne nb l nc nd">    const storageUser = localStorage.getItem('LoggedUser');<br/>    const loggedUser = jsonInfo ? JSON.parse(jsonInfo) : null;</span><span id="a0a2" class="lx ly it mw b gy ne nb l nc nd">    if (loggedUser) {<br/>      request = request.clone({<br/>          headers: req.headers.set(<br/>            'Authorization',<br/>            loggedUser.authToken<br/>          )<br/>      });<br/>    }</span><span id="a462" class="lx ly it mw b gy ne nb l nc nd">    return next.handle(request).pipe(<br/>      catchError(error =&gt; {</span><span id="91fe" class="lx ly it mw b gy ne nb l nc nd">        // Checking if it is an Authentication Error (401)<br/>        if (error.status === 401) {<br/>          alert('Access Denied');<br/>          // &lt;Log the user out of your application code&gt;<br/>          this.router.navigate([ 'login-page-route' ]);<br/>          return throwError(error);<br/>        }</span><span id="881f" class="lx ly it mw b gy ne nb l nc nd">        // If it is not an authentication error, just throw it<br/>        return throwError(error);<br/>      })<br/>    );<br/>  }<br/>}</span></pre><p id="c01c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过管道调用<em class="lq"> catchError </em>，我们能够处理来自服务器的请求响应错误。因此，我们被允许验证其状态，并按照前面提到的方法进行治疗。</p><p id="1a6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">顺便说一下，这是我为学习目的而设置的处理方法，但是在您的现实世界中，这里的应用程序适合任何类型的处理方法。如果发生401错误，您可能不想重定向用户，或者您可能打算尝试一个<em class="lq">刷新令牌</em> api调用。无论什么对你的应用是必要的。</p><p id="e844" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们不要忘记将它提供给我们的模块。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="a807" class="lx ly it mw b gy na nb l nc nd">...<br/>import { <a class="ae nf" href="https://angular.io/api/common/http/HTTP_INTERCEPTORS" rel="noopener ugc nofollow" target="_blank">HTTP_INTERCEPTORS</a> } from '@angular/common/<a class="ae nf" href="https://angular.io/api/common/http" rel="noopener ugc nofollow" target="_blank">http</a>';<br/>import { AuthenticationInterceptor } from '...';</span><span id="f08d" class="lx ly it mw b gy ne nb l nc nd">@NgModule({<br/>  ...<br/>  providers: [<br/>    {<br/>      provide: HTTP_INTERCEPTORS,<br/>      useClass: AuthenticationInterceptor<br/>    },<br/>   ...<br/>  ],<br/>  ...<br/>})</span><span id="7275" class="lx ly it mw b gy ne nb l nc nd">export class AppModule { }</span></pre><h2 id="5a46" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">处理模拟</h2><p id="0070" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">现在让我们看看另一种拦截方式；假设你将在你的应用程序中使用某种类型的<em class="lq">模仿</em>。我的意思是，在应用程序的某个地方，你希望允许一个用户(比如系统管理员)“假装”成另一个用户来执行服务器请求。</p><p id="441b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将假设我们的应用程序中有一个<em class="lq"> ImpersonationService </em>,它将处理所有的模拟逻辑，对此我不会深入探讨。从那个<em class="lq">服务</em>中，我们将检索该请求是否应该被模拟的信息；在这种情况下，服务器需要的信息，比如冒充的<em class="lq">用户id </em>。</p><p id="34e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，在我们的拦截器中，想法很简单:<br/> -检查请求是否应该被模拟；<br/> -如果是模仿，在请求中发送适当的<em class="lq">报头</em>。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="3f8d" class="lx ly it mw b gy na nb l nc nd">@Injectable()<br/>export class ImpersonationInterceptor implements HttpInterceptor {</span><span id="31db" class="lx ly it mw b gy ne nb l nc nd">  constructor(<br/>    private _impersonationService: ImpersonationService<br/>  ) { }</span><span id="195b" class="lx ly it mw b gy ne nb l nc nd">  intercept(<br/>    request: HttpRequest&lt;any&gt;, next: HttpHandler<br/>  ) : Observable&lt;HttpEvent&lt;any&gt;&gt; {</span><span id="c858" class="lx ly it mw b gy ne nb l nc nd">  const impersonatedUser: User | null =<br/>    this._impersonationService.getImpersonatedUser();</span><span id="6623" class="lx ly it mw b gy ne nb l nc nd">  if (impersonatedUser &amp;&amp; impersonatedUser.id) {<br/>    request = request.clone({<br/>      setHeaders: {<br/>        'ImpersonatedUserId': impersonatedUser.id<br/>      }<br/>    });<br/>  }<br/>}</span></pre><p id="139d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，再一次，让我们不要忘记在我们的模块中添加新的拦截器，加入我们之前创建的先前的<em class="lq">AuthenticationInterceptor</em>。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="809f" class="lx ly it mw b gy na nb l nc nd">...<br/>import { <a class="ae nf" href="https://angular.io/api/common/http/HTTP_INTERCEPTORS" rel="noopener ugc nofollow" target="_blank">HTTP_INTERCEPTORS</a> } from '@angular/common/<a class="ae nf" href="https://angular.io/api/common/http" rel="noopener ugc nofollow" target="_blank">http</a>';<br/>import { AuthenticationInterceptor } from '...';<br/>import { ImpersonationInterceptor } from '...';</span><span id="a2c5" class="lx ly it mw b gy ne nb l nc nd">@NgModule({<br/>  ...<br/>  providers: [<br/>    {<br/>      provide: HTTP_INTERCEPTORS,<br/>      useClass: AuthenticationInterceptor,<br/>      multi: true<br/>    }, <br/>    {<br/>      provide: HTTP_INTERCEPTORS,<br/>      useClass: ImpersonationInterceptor,<br/>      multi: true<br/>    },<br/>   ...<br/>  ],<br/>  ...<br/>})</span><span id="a8a3" class="lx ly it mw b gy ne nb l nc nd">export class AppModule { }</span></pre></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="62e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用拦截器对于各种应用程序的多种用途都非常有用。因此，重要的是要知道它是如何工作的，你可以用它来实现什么，以便能够在你可能需要它的时候应用它。</p><p id="4770" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">希望有帮助！😉</p><h2 id="8577" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated"><strong class="ak">参考文献:</strong></h2><p id="d78a" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated"><a class="ae nf" href="https://angular.io/guide/http#intercepting-requests-and-responses" rel="noopener ugc nofollow" target="_blank">https://angular . io/guide/http #截取请求和响应</a></p></div></div>    
</body>
</html>