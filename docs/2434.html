<html>
<head>
<title>React: Understanding State &amp; Lifecycle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应:理解状态和生命周期</h1>
<blockquote>原文：<a href="https://itnext.io/react-understanding-state-lifecycle-d45df5d2cf3f?source=collection_archive---------2-----------------------#2019-05-23">https://itnext.io/react-understanding-state-lifecycle-d45df5d2cf3f?source=collection_archive---------2-----------------------#2019-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/06a6deb05b86b53ec44502231ed685f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TbIOYXZmhRWphY7NfVZYAw.png"/></div></div></figure><p id="e2ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我们将了解状态和生命周期在React中是如何工作的。这些知识非常强大，因为它帮助我们分离关注点，增加动态性，并构建真正可重用的组件。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="c494" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">🤓<em class="lg">想跟上网络发展的步伐吗？</em> <br/>🚀<em class="lg">想要将最新消息直接发送到您的收件箱？<br/>🎉加入一个不断壮大的设计师&amp;开发者社区！</em></p><p id="9aa1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">在这里订阅我的简讯→</strong><a class="ae lh" href="https://easeout.eo.page/" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">https://ease out . EO . page</strong></a></p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="c204" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">什么是状态？</h1><p id="59c3" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">状态与React组件类一起使用，使它们成为动态的。它使组件能够跟踪呈现之间不断变化的信息。更具体地说，组件的状态是一个对象，它保存的信息可能会在组件的生命周期内发生变化。</p><p id="dd8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">状态v道具</strong></p><p id="a943" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可能想知道这和道具有什么区别？我们看了我上一篇文章里的道具:<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/react-components-props-db1db95c04c8"> React: Components &amp;道具</a>。回想一下，props是一个保存信息以控制组件行为的对象。这听起来非常类似于state，但是让我们看看它们有什么不同:</p><ul class=""><li id="e4e7" class="ml mm it kd b ke kf ki kj km mn kq mo ku mp ky mq mr ms mt bi translated">道具是不可变的。一旦设定，就无法更改</li><li id="c808" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">状态是可观察的。它可以保存可能随时间变化的数据</li><li id="fc0b" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">Props可以用在函数或类组件中</li><li id="1e3f" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">状态仅限于类组件</li><li id="c661" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">道具由父组件设置</li><li id="38a7" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">状态由事件处理程序更新</li></ul><h1 id="92d0" class="li lj it bd lk ll mz ln lo lp na lr ls lt nb lv lw lx nc lz ma mb nd md me mf bi translated">使用状态</h1><p id="ca56" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">当使用状态时，我们需要组件的状态总是存在——所以我们需要设置一个初始状态。我们可以通过在组件类的<strong class="kd iu">构造函数</strong>中定义我们的状态来实现，就像这样:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="944e" class="nn lj it nj b gy no np l nq nr">class MyClass extends React.Component {<br/>  <strong class="nj iu">constructor</strong>(props){<br/>    <strong class="nj iu">super</strong>(props);<br/>    <strong class="nj iu">this</strong>.state = { attribute : "value"<!-- --> <!-- -->};<br/>  }<br/>}<!-- --> </span></pre><p id="a1d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lg">注意:</em>我们将在本文后面的生命周期方法中详细研究这些代码。现在，很高兴知道我们如何介绍状态！</p><h2 id="8235" class="nn lj it bd lk ns nt dn lo nu nv dp ls km nw nx lw kq ny nz ma ku oa ob me oc bi translated">更新状态</h2><p id="526d" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">关于state，接下来要知道的是它不应该<strong class="kd iu">被显式更新</strong>。React将使用一个可观察对象作为状态，这允许组件做出相应的行为。</p><p id="547c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，如果我们要像这样更新一个组件的状态:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="fcc1" class="nn lj it nj b gy no np l nq nr">this.state.attribute = "changed-value";</span></pre><p id="d64e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们会有一个渲染错误！因为国务院无法察觉这些变化。</p><p id="f6ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> setState() </strong></p><p id="57ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这也是我们使用<code class="fe od oe of nj b">setState()</code>内置React方法的原因。它接受一个参数，并期望一个包含我们的值集的对象被更新。</p><p id="5cb3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该方法将更新我们的状态，然后调用<code class="fe od oe of nj b">render()</code>方法来重新呈现页面。因此，更新我们状态的正确方法是这样的:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="bc9e" class="nn lj it nj b gy no np l nq nr">this.setState({attribute: “changed-value”});</span></pre><p id="6d23" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">记住，我们只允许在构造函数中显式定义我们的状态——当我们提供初始状态时。</p><h2 id="28a5" class="nn lj it bd lk ns nt dn lo nu nv dp ls km nw nx lw kq ny nz ma ku oa ob me oc bi translated">设置多个状态</h2><p id="f818" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">我们还可以通过在一个<code class="fe od oe of nj b">setState()</code>方法中设置多个状态来利用React的异步能力。这方面的一个用例可能是当我们想要保持计数时(例如，跟踪帖子或照片之类的内容)。</p><p id="45cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以使用ES6箭头函数来实现，如下所示:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="4065" class="nn lj it nj b gy no np l nq nr">this.setState((prevState, props) =&gt; ({<br/>  total: prevState.count + props.diff <br/>}));</span></pre><p id="4fdc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里，我们将之前的组件状态和道具作为参数，然后更新总数。同样也可以写成这样的常规函数:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="747c" class="nn lj it nj b gy no np l nq nr">this.setState(function(prevState, props){ <br/>  return {total: prevState.count + props.diff}; <br/>});</span></pre><h1 id="124c" class="li lj it bd lk ll mz ln lo lp na lr ls lt nb lv lw lx nc lz ma mb nd md me mf bi translated">生命周期</h1><p id="38bb" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">在下一节中，我们将了解React生命周期。让我们从定义开始..</p><h2 id="71c5" class="nn lj it bd lk ns nt dn lo nu nv dp ls km nw nx lw kq ny nz ma ku oa ob me oc bi translated">生命周期是什么？</h2><p id="c575" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">一般来说，我们可以将生命周期定义为出生、成长和死亡。我们的React组件也遵循这个循环:它们被创建(安装在DOM上)，它们经历增长(通过更新)和死亡(从DOM中卸载)。这就是组件生命周期！</p><p id="238b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在组件的生命周期中，有不同的阶段。这些阶段都有自己的生命周期方法。现在让我们来看看这些方法。</p><h1 id="6c18" class="li lj it bd lk ll mz ln lo lp na lr ls lt nb lv lw lx nc lz ma mb nd md me mf bi translated">生命周期方法</h1><p id="d5f1" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">组件的生命周期可以分为四个部分:</p><ul class=""><li id="520e" class="ml mm it kd b ke kf ki kj km mn kq mo ku mp ky mq mr ms mt bi translated">初始化</li><li id="d434" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">增加</li><li id="b4e2" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">更新</li><li id="1c6f" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">卸载</li></ul><p id="42fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们详细看看每一个..</p><h2 id="fcc5" class="nn lj it bd lk ns nt dn lo nu nv dp ls km nw nx lw kq ny nz ma ku oa ob me oc bi translated">初始化</h2><p id="67d2" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">在这个阶段，我们的组件将设置它的状态&amp;道具。这通常在构造函数方法中完成，如下所示:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="f103" class="nn lj it nj b gy no np l nq nr">class Initialize extends React.Component {<br/>  constructor(props){</span><span id="be90" class="nn lj it nj b gy og np l nq nr">    // calling the constructor of its parent<br/>    super(props);</span><span id="fa0f" class="nn lj it nj b gy og np l nq nr">    // initialization process<br/>    this.state = {<br/>      time: new<!-- --> <!-- -->Date(),<br/>      selectedStatus: false<br/>    };<br/>  }<br/>}</span></pre><h2 id="20a7" class="nn lj it bd lk ns nt dn lo nu nv dp ls km nw nx lw kq ny nz ma ku oa ob me oc bi translated">增加</h2><p id="01d2" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">初始化阶段完成后，我们进入安装阶段。这是我们的React组件“安装”在DOM上的时候(它被创建并插入到DOM中)。这是我们的组件第一次呈现。该阶段可用的方法有<code class="fe od oe of nj b">componentWillMount()</code>和<code class="fe od oe of nj b">componentDidMount()</code>。</p><p id="3d62" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> componentWillMount() </strong></p><p id="160b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个方法在组件挂载到DOM之前被调用(或者当render方法被调用时)。然后安装我们的组件。</p><p id="ab1d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">componentidmount()</strong></p><p id="4c9d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个方法在组件被装载到DOM上之后被调用。像<code class="fe od oe of nj b">componentWillMount()</code>一样，在一个生命周期中只调用一次。在执行之前，会调用render方法。我们可以进行API调用，并用API响应更新状态。</p><p id="0682" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们通过一个例子来看看这些方法的作用:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="58ac" class="nn lj it nj b gy no np l nq nr">class LifeCycle extends React.Component {<br/>  componentWillMount() {<br/>      console.log('Component will mount!')<br/>   }<br/>  componentDidMount() {<br/>      console.log('Component did mount!')<br/>      this.getData();<br/>  }<br/>  getData=()=&gt;{<br/>   /* method to make an api call for data */<br/>  }</span><span id="66dd" class="nn lj it nj b gy og np l nq nr">render() {<br/>      return (<br/>         &lt;div&gt;<br/>            &lt;h1&gt;Mounting methods in action!&lt;/h1&gt;<br/>         &lt;/div&gt;<br/>      );<br/>   }<br/>}</span></pre><h2 id="d91e" class="nn lj it bd lk ns nt dn lo nu nv dp ls km nw nx lw kq ny nz ma ku oa ob me oc bi translated">更新</h2><p id="f1d1" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">在创建组件的安装阶段之后，我们进入更新阶段。这是组件状态改变的地方，因此，重新渲染发生。</p><p id="9270" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">组件的数据(它的状态和属性)将会更新以响应用户事件，比如点击、输入等。这将导致组件的重新呈现。我们在这里使用的方法是:</p><p id="5b3a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">shouldcomponentdupdate()</strong></p><p id="3c1d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此方法确定组件是否应该更新。默认情况下，它将返回true。如果在某个时候，如果你想重新渲染某个条件下的组件，那么<code class="fe od oe of nj b">shouldComponentUpdate()</code>方法将是正确的选择。</p><p id="78c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，如果您只想在属性发生变化时重新渲染组件，那么就应该使用这种方法。它接收像<em class="lg"> nextProps </em>和<em class="lg"> nextState </em>这样的参数，通过与当前的属性值进行比较来帮助我们决定是否重新渲染。</p><p id="6654" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> componentWillUpdate() </strong></p><p id="f66c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在重新呈现组件之前调用这个方法。如果您想在更新状态和属性后重新渲染组件&amp;之前执行计算，则在<code class="fe od oe of nj b">shouldComponentUpdate().</code>之后调用一次，然后您将使用此方法。像<code class="fe od oe of nj b">shouldComponentUpdate()</code>一样，它也接收像<em class="lg"> nextProps </em>和<em class="lg"> nextState </em>这样的参数。</p><p id="d584" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> componentDidUpdate() </strong></p><p id="df6b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在重新呈现组件后调用这个方法。在更新的组件在DOM上得到更新后，执行<code class="fe od oe of nj b">componentDidUpdate()</code>方法。这个方法将接收像<em class="lg"> prevProps </em>和<em class="lg"> prevState </em>这样的参数。</p><p id="7443" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们扩展一下之前的例子:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="999b" class="nn lj it nj b gy no np l nq nr">class LifeCycle extends React.Component {<br/>  <!-- -->constructor(props){<br/>    super(props);<br/>    this.state = {<br/>      time: new<!-- --> <!-- -->Date(),<br/>      selectedStatus: false,<br/>      list:[]<br/>    };<br/>  }</span><span id="153a" class="nn lj it nj b gy og np l nq nr">  componentWillMount() {<br/>    console.log('Component will mount!')<br/>  }<br/>  componentDidMount() {<br/>    console.log('Component did mount!')<br/>    this.getList();<br/>  }</span><span id="8eb7" class="nn lj it nj b gy og np l nq nr">  getList=()=&gt; {<br/>    /* method to make an api call for data */<br/>    <!-- -->fetch('<a class="ae lh" href="https://api.mydomain.com/" rel="noopener ugc nofollow" target="_blank">https://api.mydomain.com</a>')<br/>      .then(response =&gt; response.json())<br/>      .then(data =&gt; this.setState({ list:data }));<br/>  <!-- -->}</span><span id="f20b" class="nn lj it nj b gy og np l nq nr">  shouldComponentUpdate(nextProps, nextState) {<br/>    return this.state.list!==nextState.list<br/>  }<br/>  componentWillUpdate(nextProps, nextState) {<br/>    console.log('Component will update!');<br/>  }<br/>  componentDidUpdate(prevProps, prevState) {<br/>    console.log('Component did update!')<br/>  }</span><span id="d9ed" class="nn lj it nj b gy og np l nq nr"> render() {<br/>   return (<br/>     &lt;div&gt;<br/>       &lt;h1&gt;Mounting methods in action!&lt;/h1&gt;<br/>     &lt;/div&gt;<br/>   );<br/> }<br/>}</span></pre><h2 id="12a6" class="nn lj it bd lk ns nt dn lo nu nv dp ls km nw nx lw kq ny nz ma ku oa ob me oc bi translated">卸载</h2><p id="1d39" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">最后一个阶段是卸载。我们的组件从DOM中卸载。我们在这里可以使用的方法是:</p><p id="ba0a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> componentWillUnmount() </strong></p><p id="9fd9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在卸载发生之前调用这个方法。在从DOM中移除组件之前，<code class="fe od oe of nj b">componentWillUnMount()</code>将会执行。这个方法是组件生命周期的终点！</p><p id="ad7c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是一个流程图，清晰地展示了所有的生命周期方法:</p><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/ffa79060510df1df092adf9da64eb128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hSO--5BPT1K_YK6VqRy4vg.png"/></div></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="548e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lg">你准备好让你的JavaScript技能更上一层楼了吗？今天就开始用我的新电子书吧！无论你是想学习你的第一行代码，还是想扩展你的知识面并真正学习基础知识..</em><a class="ae lh" href="https://gum.co/mastering-javascript" rel="noopener ugc nofollow" target="_blank"><em class="lg">JavaScript精通完全指南</em> </a> <em class="lg">带你从零到英雄！</em></strong></p><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/dde515044536421c6c999650977f80c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1fUokZkbKj-qlRPVN_Txrg.png"/></div></div><figcaption class="oj ok gj gh gi ol om bd b be z dk translated"><em class="on">现已上市！👉</em><a class="ae lh" href="https://gum.co/mastering-javascript" rel="noopener ugc nofollow" target="_blank">https://gum.co/mastering-javascript</a></figcaption></figure><h1 id="5b9f" class="li lj it bd lk ll mz ln lo lp na lr ls lt nb lv lw lx nc lz ma mb nd md me mf bi translated">结论</h1><p id="85bd" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">就是这样！我们已经介绍了一些重要的概念，它们是反应的基础。首先我们看了状态，我们将状态与道具进行了比较，并且我们看了如何更新和设置多个状态。然后我们转到React组件生命周期，涵盖了各个阶段(初始化、安装、更新和卸载)以及每个阶段可用的方法。</p><p id="a79d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望这篇文章对你有用！你可以在媒体上关注我。我也在<a class="ae lh" href="https://twitter.com/easeoutco" rel="noopener ugc nofollow" target="_blank">推特</a>上。欢迎在下面的评论中留下任何问题。我很乐意帮忙！</p><h1 id="d6a8" class="li lj it bd lk ll mz ln lo lp na lr ls lt nb lv lw lx nc lz ma mb nd md me mf bi translated">关于我的一点点..</h1><p id="72d3" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">嘿，我是提姆！👋我是一名开发人员、技术作家和作家。如果你想看我所有的教程，可以在<a class="ae lh" href="http://www.easeout.co" rel="noopener ugc nofollow" target="_blank">我的个人博客</a>上找到。</p><p id="50a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我目前正在构建我的<a class="ae lh" href="http://www.easeout.co/freelance" rel="noopener ugc nofollow" target="_blank">自由职业者完整指南</a>。坏消息是它还不可用！但是如果这是你可能感兴趣的东西，你可以<a class="ae lh" href="https://easeout.eo.page/news" rel="noopener ugc nofollow" target="_blank">注册，当它可用的时候会通知你</a>👍</p><p id="71dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读🎉</p></div></div>    
</body>
</html>