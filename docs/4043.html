<html>
<head>
<title>Cypress + Storybook. Keeping test scenario, data and component rendering in one place</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">柏树+故事书。将测试场景、数据和组件呈现保存在一个地方</h1>
<blockquote>原文：<a href="https://itnext.io/cypress-storybook-keeping-test-scenario-data-and-component-rendering-in-one-place-c57b23cc1640?source=collection_archive---------2-----------------------#2020-04-15">https://itnext.io/cypress-storybook-keeping-test-scenario-data-and-component-rendering-in-one-place-c57b23cc1640?source=collection_archive---------2-----------------------#2020-04-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/266ac69b4a31d8b1926e72934562c31b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9fmrO19f4HRIAcPzvPaiXw.png"/></div></div></figure><p id="b523" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文的RU版本可在<a class="ae kw" href="https://habr.com/ru/post/497544/" rel="noopener ugc nofollow" target="_blank">此处</a>获得。</p><p id="26c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">重要更新#1 </strong> <br/>故事书只是一个主机组件。您可以按照自己喜欢的任何方式捆绑和托管您的组件。例如，您可以在一个JavaScript文件中导入所有组件，并在测试期间通过webpack-dev-server提供服务。</p><p id="ce91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更重要的更新#2 </strong> <br/>本文是Cypress 4.5版本以下的时候写的。<br/>今天，我们对Cypress和<a class="ae kw" href="https://github.com/bahmutov/cypress-react-unit-test" rel="noopener ugc nofollow" target="_blank"> cypress-react-unit-test插件</a>进行了惊人的更新，让一切变得更简单。它不需要主机(故事书)来存放你的组件，因为它在Cypress内部运行它们。</p><p id="b134" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">设置如下所述的唯一原因是速度或一些偶然的错误。首先尝试<a class="ae kw" href="https://github.com/bahmutov/cypress-react-unit-test" rel="noopener ugc nofollow" target="_blank">cypress-react-unit-test</a>。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="0a7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一开始，塞浦瑞斯感觉像是e2e的测试工具。令人好奇的是，前端工程师对Selenium在何处发挥作用的话题越来越感兴趣。在那个时候，任何关于Cypress能力的典型视频或文章都被随意选择的网站所限制，并赞扬所提供的输入API。</p><p id="e2ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们中的许多人选择Cypress作为工具来测试通过Storybook/Styleguidist/Docz托管的组件。一个很好的例子——<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/testing-a-virtual-list-component-with-cypress-and-storybook-494dc2d1d26b">斯特凡诺·马尼的文章</a>。他建议创建故事书故事，将组件放在那里，并将重要数据暴露给全局变量，以便在测试中访问它。实际上，这是一个很好的方法，但是测试变成了故事书和Cypress之间的碎片。</p><p id="3a55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我想进一步展示如何在Cypress中最大限度地执行JavaScript。要查看它的运行，<a class="ae kw" href="https://github.com/daedalius/article-exposing-component-from-storybook-to-handle-them-in-cypress" rel="noopener ugc nofollow" target="_blank">您可以从我的Github </a>下载源代码，然后在控制台中执行<strong class="ka ir"> npm i </strong>和<strong class="ka ir"> npm运行测试</strong>。</p><p id="16bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">TL；博士:</p><ul class=""><li id="9425" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">您可以公开Storybook Story中的组件引用，以便在Cypress中测试它(无需将测试逻辑分成几部分)。</li><li id="0d8c" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">Cypress对我们的团队来说非常强大，所以我们没有另一个使用js-dom测试UI组件的工具。</li></ul><h1 id="378f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">任务</h1><p id="4400" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">假设我们正在为现有的Datepicker组件编写一个适配器，以便在所有公司网站上使用它。我们不想意外打破任何东西，所以我们必须通过测试来覆盖它。</p><h1 id="c012" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">故事书</h1><p id="c780" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">我们从Storybook中所需要的——一个在全局变量中保存对测试组件的引用的空故事。为了不那么没用，这个故事呈现了单个DOM节点。这个节点将是我们在测试中的战区。</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="8293" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，我们已经看完了故事书。让我们来看看柏树。</p><h1 id="6f20" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">柏树</h1><p id="5075" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">就个人而言，我喜欢从测试用例枚举开始。似乎我们有下一个测试结构:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="4942" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧。我们必须在任何环境下进行这项测试。打开故事书，点击侧边栏中的<em class="nb">“在新标签中打开画布”</em>按钮，直接进入空故事。复制URL并让Cypress访问它:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9531" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你可能猜到的，为了进行测试，我们将使用<em class="nb">id = component-test-mount-point</em>在同一个<em class="nb"> &lt; div &gt; </em>中呈现所有组件状态。为了使测试不会相互影响，我们必须在下一次测试执行之前卸载这里的任何组件。让我们添加一些清理代码:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6e71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们准备完成测试。检索组件引用，呈现组件并做出一些断言:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="f7fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你看到了吗？没有什么可以阻止我们将任何道具或数据直接传递给组件！这一切都在一个地方——在赛普拉斯！</p><h1 id="89da" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">用包装器分几步测试</h1><p id="b41a" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">有时我们想要测试组件根据变化的道具的可预测的行为。</p><p id="0c8a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检视<em class="nb"> &lt;弹出&gt; </em>组件与“显示”道具。当【显示】为<em class="nb">真</em>时，<em class="nb">弹出&lt;可见&gt;弹出</em>。之后，将“显示”改为<em class="nb">假</em>，<em class="nb">，&lt;弹出&gt;，</em>应变为隐藏。如何测试这种转变？</p><p id="3cd9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些问题很容易以命令的方式处理，但是在声明式反应的情况下，我们需要想出一些东西。</p><p id="ea98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的团队中，我们使用一个附加的带状态的包装组件来处理它。这里的状态是布尔型的，它响应“显示”的道具。</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="430e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们即将完成测试:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="96a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">提示:如果这样的钩子不起作用或者你不喜欢在组件之外调用钩子——通过简单类重写包装器。</p><h1 id="b331" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">测试组件方法</h1><p id="5557" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">其实我从来没写过这样的测试。写这篇文章的时候有了这个想法。用单元测试的方式来测试一个组件可能是有用的。</p><p id="6959" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，你可以很容易地做到这一点。只需在渲染之前创建一个对组件的引用。值得一提的是，ref提供了对组件的状态和其他元素的访问。</p><p id="d35c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在<em class="nb"> &lt;弹出框&gt; </em>中添加了“hide”方法，使其被强制隐藏(为了举例而举例)。以下测试如下所示:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="2d6c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">总结一下:每个参与者的角色</h1><p id="0fed" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">故事书:</p><ul class=""><li id="a19e" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">托管包含用于测试目的的捆绑React组件的故事书故事。</li><li id="2998" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">提供一个真正的非合成环境来运行测试。</li><li id="1205" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">每个故事在全局变量中公开一个组件(稍后在Cypress中检索它)。</li><li id="94c0" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">每个故事都公开了一个组件挂载点(在测试中挂载一个组件)。</li><li id="d54d" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">能够在新标签中单独打开每个组件。</li></ul><p id="5f8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">提示:请为您的组件库或页面运行Storybook的另一个实例。</p><p id="fad9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">柏树:</p><ul class=""><li id="4450" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">包含并运行测试和Javascript。</li><li id="b3b8" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">访问孤立的组件故事，从全局变量中检索组件引用。</li><li id="70ee" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">根据测试需要呈现组件(使用任何数据或测试条件，如移动分辨率)。</li><li id="16f1" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">为您提供UI，以便您可以看到您的测试进展如何。</li></ul><h1 id="069f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">结论</h1><p id="c3c2" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">在这里，我想就阅读过程中可能出现的问题表达我个人的观点和我同事的立场。下面写的不冒充真实，可能与现实有出入，含有坚果。</p><p id="1d78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的测试工具在幕后使用js-dom。我限制自己了吗？</p><ul class=""><li id="19bc" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">Js-dom是一个合成环境。分离的DOM不是真正的浏览器。</li><li id="d528" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">它实际上并不像用户那样使用js-dom。尤其是在模拟输入事件时。</li><li id="1562" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">如果CSS中的一个组件由于一个不正确的z-index而被破坏，那么您能从编写的单元测试中获得多少信心？如果组件由Cypress测试，您将看到一个错误。</li><li id="86db" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">你盲目地编写单元测试。但是为什么呢？</li></ul><p id="8c46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">我应该选择建议的方法吗？</strong></p><ul class=""><li id="3dd3" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">如果你使用测试作为开发环境——当然，是的！</li><li id="2a0f" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">如果你看看在<strong class="ka ir"> live </strong>文档中的测试——是的。</li><li id="8f3d" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">如果你真的编写单元测试来覆盖那些太接近实现和反应生命周期的东西，我不知道。好久没写这样的测试了。你确定覆盖的逻辑是组件责任吗？也许这种逻辑应该被提取出来并进行相应的测试？</li></ul><p id="516c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那为什么不使用cypress-react-unit-test呢？我们为什么需要故事书？</p><p id="b44d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我毫不怀疑——测试组件是我们的未来。不需要维护故事书的一个单独的实例，所有的测试将完全由Cypress负责，配置将被简化，等等。</p><p id="d73a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">̶b̶u̶t̶̶n̶o̶w̶̶t̶h̶e̶̶t̶o̶o̶l̶̶h̶a̶s̶̶<a class="ae kw" href="https://github.com/bahmutov/cypress-react-unit-test/issues/34" rel="noopener ugc nofollow" target="_blank">s̶o̶m̶e̶̶</a>T10】p̶r̶o̶b̶l̶e̶m̶s̶̶t̶h̶a̶t̶̶m̶a̶k̶e̶̶t̶h̶e̶̶e̶n̶v̶i̶r̶o̶n̶m̶e̶n̶t̶̶p̶r̶o̶v̶i̶d̶e̶d̶̶i̶n̶c̶o̶m̶p̶l̶e̶t̶e̶̶f̶o̶r̶̶r̶u̶n̶n̶i̶n̶g̶̶t̶e̶s̶t̶s̶.̶̶h̶o̶p̶e̶̶t̶h̶a̶t̶̶<a class="ae kw" href="https://github.com/bahmutov" rel="noopener ugc nofollow" target="_blank">g̶l̶e̶b̶̶b̶a̶h̶m̶u̶t̶o̶v̶</a>̶a̶n̶d̶̶t̶h̶e̶̶c̶y̶p̶r̶e̶s̶s̶̶t̶e̶a̶m̶̶w̶i̶l̶l̶̶m̶a̶k̶e̶̶i̶t̶̶w̶o̶r̶k̶e̶d̶̶🤞</p><p id="4489" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">PS:我们团队的意见是建议的方法允许我们回顾使用js-dom的工具垄断。你怎么想？</p></div></div>    
</body>
</html>