<html>
<head>
<title>Functional Reactive Programming in Scala from Scratch (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala中的函数式反应式编程(第3部分)</h1>
<blockquote>原文：<a href="https://itnext.io/functional-reactive-programming-in-scala-from-scratch-part-3-d999dca5fa69?source=collection_archive---------3-----------------------#2019-05-03">https://itnext.io/functional-reactive-programming-in-scala-from-scratch-part-3-d999dca5fa69?source=collection_archive---------3-----------------------#2019-05-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="8a76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这一系列的文章中，我们想从头开始为Scala中的函数式反应式编程开发一个小框架。如果你还没有阅读该系列的前两部分，请务必在此查看:<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/functional-reactive-programming-in-scala-from-scratch-part-1-9f9db0c47478">第1部分</a>、<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/functional-reactive-programming-in-scala-from-scratch-part-2-3d1559a11629">第2部分</a>。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/143288294ac5769c04fb3608374d3dc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nvS2M4cCo-rSoL34"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated"><a class="ae ko" href="https://unsplash.com/@bertsz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> bert sz </a>在<a class="ae ko" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="82ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf">注:你可以在</em> <a class="ae ko" href="https://github.com/timo-stoettner/frp-scala" rel="noopener ugc nofollow" target="_blank"> <em class="lf">这个GitHub资源库</em> </a> <em class="lf">中找到有完整代码的笔记本。</em></p></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><p id="6988" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上一篇文章中，我们设法编写了一个小框架的工作示例，使我们能够做我们想要做的事情:用一个合并器跟踪几个银行账户的余额。合并器利用了我们的小框架来处理所有更新合并余额的复杂性。</p><p id="8227" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，这个API还没有我们想要的那么优雅。我们需要将观察到的信号显式地传递给合并器，这样它就知道需要观察哪些其他信号的变化。这是重复且容易出错的。提醒一下，这是我们的函数<code class="fe ln lo lp lq b">consolidated</code>的样子:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="10e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ln lo lp lq b">Signal</code>的第一个参数构成了计算我们的<code class="fe ln lo lp lq b">Signal</code>值的函数。第二个参数指的是我们新定义的<code class="fe ln lo lp lq b">Signal</code>所依赖的其他<code class="fe ln lo lp lq b">Signal</code>,因此必须观察它们的变化。</p><p id="d410" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我们想要的样子:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="e61c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">换句话说，我们想摆脱第二个论点。因此，新的<code class="fe ln lo lp lq b">Signal</code>必须自己弄清楚，它依赖于其他哪些<code class="fe ln lo lp lq b">Signal</code>。</p><p id="2502" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了解决这个问题，我们将利用<code class="fe ln lo lp lq b">DynamicVariable</code> s。我将不得不绕一点弯子来解释它们，所以跟我说吧。(如果你知道如何使用<code class="fe ln lo lp lq b">DynamicVariable</code> s或者它的Java对应物<code class="fe ln lo lp lq b">ThreadLocal</code>，可以随意跳过这一部分。)</p><h1 id="bb7e" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">使用DynamicVariable跟踪依赖性</h1><p id="8152" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">Scala的<code class="fe ln lo lp lq b">DynamicVariable</code>是动态范围模式的一个实现(因此也被称为“动态”变量)。不必深入，计算机程序的作用域指的是程序中可以使用标识符(如变量名)的区域。作用域有两种方式:<em class="lf">词法(或静态)作用域</em>和<em class="lf">动态作用域</em>。</p><p id="7d6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">标准是词法范围，这是您最可能习惯的。这里，范围取决于源代码中的位置。例如，如果在类方法中使用变量名，编译器首先在方法本身中查找该名称，然后在类级别上查找。</p><p id="3d33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看一个小例子来说明这一点:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="2ee1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里大概没有什么大的惊喜。在<code class="fe ln lo lp lq b">print_class_value</code>中没有定义<code class="fe ln lo lp lq b">value</code>，所以使用在类级别定义的那个。在<code class="fe ln lo lp lq b">print_method_value</code>中，<code class="fe ln lo lp lq b">value</code>是在方法本身中定义的，它比类级别上的定义具有更高的优先级。</p><p id="f4be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，动态范围取决于<em class="lf">执行上下文</em>。这里，当您在类方法中使用变量名时，编译器将首先在方法本身中查找该名称，然后在调用方法的方法中查找<em class="lf">(依此类推)。有一些编程语言实现了动态范围，但是大多数(比如scala)默认使用静态范围。</em></p><p id="046c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">动态范围会使理解变量值的来源变得非常困难。然而，如果你想根据谁调用了一个方法来跟踪一个值，动态范围是一个好办法。</p><p id="8012" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您回想一下我们的银行帐户示例，这就是我们在这里所追求的。如果我们知道一个<code class="fe ln lo lp lq b">Signal</code>被另一个<code class="fe ln lo lp lq b">Signal</code>调用，我们可以将它添加到一组观察器中，并在发生变化时更新这些观察器。幸运的是，我们实现了这样一种模式。</p><p id="d1ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在回到银行账户之前，让我们先看一个简单的例子来说明<code class="fe ln lo lp lq b">DynamicVariable</code>是如何工作的:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="fb5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里需要注意一些事情:</p><ul class=""><li id="c8b8" class="mw mx it js b jt ju jx jy kb my kf mz kj na kn nb nc nd ne bi translated">在定义DynamicVariable时，我们需要传递一个默认值。这里我们将默认值设置为1。除非我们明确指定该值为其他值，否则将使用该值。</li><li id="5c61" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">我们可以通过调用<code class="fe ln lo lp lq b">value</code>来访问动态变量的值。</li><li id="7a0c" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">DynamicVariable有一个方法<code class="fe ln lo lp lq b">whithValue</code>，它接受一个新值和一些任意表达式作为参数。如果表达式访问<code class="fe ln lo lp lq b">DynamicVariable</code>的当前值，它将接收已经传递给<code class="fe ln lo lp lq b">withValue</code>的值。<em class="lf">变量的值因此依赖于执行上下文</em>(与动态范围一样)。</li><li id="20ee" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">如果我们在没有事先调用<code class="fe ln lo lp lq b">withValue</code>的情况下访问变量值，我们将简单地获得默认值。</li></ul><p id="0269" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你也可以像这样对<code class="fe ln lo lp lq b">withValue</code>进行嵌套调用:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="6797" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于动态变量的几点进一步说明:</p><ul class=""><li id="fd98" class="mw mx it js b jt ju jx jy kb my kf mz kj na kn nb nc nd ne bi translated">那些来自Java的人可能已经注意到<code class="fe ln lo lp lq b">DynamicVariable</code>和Java的<code class="fe ln lo lp lq b">ThreadLocal</code>非常相似。当查看<a class="ae ko" href="https://github.com/scala/scala/blob/v2.12.8/src/library/scala/util/DynamicVariable.scala#L1" rel="noopener ugc nofollow" target="_blank">源代码</a>时，你可以看到<code class="fe ln lo lp lq b">DynamicVariable</code>实际上使用了Java的<code class="fe ln lo lp lq b">InheritableThreadLocal</code></li><li id="9f0b" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">正如其Java对应物的名字所暗示的那样，<code class="fe ln lo lp lq b">DynamicVariable</code>非常适合在线程中使用。然而，在这个例子中，这与我们无关</li><li id="1fdd" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">如果你想了解更多关于静态和动态范围的知识，请查看维基百科关于范围的页面。</li></ul><h1 id="e2b6" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">回到我们的银行账户例子</h1><p id="5f32" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">那么，在我们的<code class="fe ln lo lp lq b">BankAccount</code>示例中，我们如何使用动态变量来跟踪被依赖的<code class="fe ln lo lp lq b">Signal</code>呢？我们将使用它们通过使用<code class="fe ln lo lp lq b">withValue</code>方法跟踪当前调用者来跟踪谁在调用<code class="fe ln lo lp lq b">Signal</code>。每当一个<code class="fe ln lo lp lq b">Signal</code>调用另一个<code class="fe ln lo lp lq b">Signal</code>时，我们将把它添加到一组观察者中。如果我们程序的另一部分调用了<code class="fe ln lo lp lq b">Signal</code>，我们的DynamicVariable将返回到它的默认值，没有任何效果。</p><p id="c2ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们提醒自己到目前为止我们的代码是什么样子的:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="0ec1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我只是对上一篇文章末尾的代码做了一些小的改动:我去掉了<code class="fe ln lo lp lq b">Signal</code>构造函数的第二个参数<code class="fe ln lo lp lq b">observed</code>以及对它的所有引用。一旦我们引入一个<code class="fe ln lo lp lq b">DynamicVariable</code>来跟踪呼叫者，我们就不再需要它了。注意，我保留了变量<code class="fe ln lo lp lq b">observers</code>。</p><p id="86e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了合并<code class="fe ln lo lp lq b">DynamicVariable</code>，我们需要一个默认值。因为我们的调用者将是类型<code class="fe ln lo lp lq b">Signal</code>，缺省值也必须是类型<code class="fe ln lo lp lq b">Signal</code>:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="86cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这只是一个没有实现的<code class="fe ln lo lp lq b">Nothing</code>类型的伪信号。我们还覆盖了方法<code class="fe ln lo lp lq b">computeValue</code>,以免陷入无限循环。</p><p id="401e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们将在伴随对象<code class="fe ln lo lp lq b">Signal</code>中定义一个动态变量，因此完整的伴随对象如下所示:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="b80f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将<code class="fe ln lo lp lq b">caller</code>定义为一个<code class="fe ln lo lp lq b">DynamicVariable</code>，其值属于类型<code class="fe ln lo lp lq b">Signal</code>，默认值为<code class="fe ln lo lp lq b">NoSignal</code>。(类型声明<code class="fe ln lo lp lq b">Signal[_]</code>引用了一个存在类型。这基本上意味着我们不关心类型。)</p><p id="3d16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，我们在伴随对象中定义了<code class="fe ln lo lp lq b">caller</code>，而不是在类本身中，因为我们只希望它的一个实例跟踪当前调用的<code class="fe ln lo lp lq b">Signal</code>，而不是每个<code class="fe ln lo lp lq b">Signal</code>一个实例。</p><p id="f80e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将在两个地方使用<code class="fe ln lo lp lq b">caller</code>。首先，我们将在每次调用<code class="fe ln lo lp lq b">apply</code>时将当前调用者添加到观察者集合中:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="e7bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，每次我们访问<code class="fe ln lo lp lq b">Signal</code>的值时，它的调用者都会被添加到观察者列表中。如果我们在没有指定<code class="fe ln lo lp lq b">caller</code>的值的情况下从类外的某个地方调用，添加的观察者将只是<code class="fe ln lo lp lq b">NoSignal</code>，这没有任何效果。如果我们从另一个<code class="fe ln lo lp lq b">Signal</code>接收到<code class="fe ln lo lp lq b">Signal</code>的值，我们需要确保我们指定了当前调用者。我们将在<code class="fe ln lo lp lq b">computeValue</code>这样做:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="35f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样！综上所述，我们的代码如下所示:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="af9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我只做了一个小改动:我没有直接为<code class="fe ln lo lp lq b">curVal</code>和<code class="fe ln lo lp lq b">curExpr</code>设置值，而是在之后调用<code class="fe ln lo lp lq b">update</code>。这确保了两件事:首先，我们不必以这种方式重复<code class="fe ln lo lp lq b">computeValue</code>中的代码。第二，当初始化<code class="fe ln lo lp lq b">NoSignal</code>时，构造函数不试图评估任何东西，因为它的方法<code class="fe ln lo lp lq b">computeValue</code>被一个空方法覆盖了。</p><p id="b806" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">来测试一下吧！</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="90aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看起来不错！我希望你同意这个解决方案比我们在<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/functional-reactive-programming-in-scala-from-scratch-part-2-3d1559a11629">上一篇文章</a>中提出的方案更好。都是拜<code class="fe ln lo lp lq b">DynamicVariabe</code> s所赐。</p><p id="ca4f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你真的想使用这段代码，你还需要注意两件小事。我们去看看。</p><h1 id="9524" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">更多的改进</h1><p id="a2cc" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">我还想写两个小的改进:</p><ul class=""><li id="9b7e" class="mw mx it js b jt ju jx jy kb my kf mz kj na kn nb nc nd ne bi translated">目前，一旦观察者被添加到观察者集合中，它们将永远不会被移除。当给一个<code class="fe ln lo lp lq b">Signal</code>分配一个新的表达式时，它可能会停止依赖它之前依赖的其他<code class="fe ln lo lp lq b">Signal</code>。我们应该考虑到这一点。</li><li id="3b65" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">目前可以定义相互依赖的<code class="fe ln lo lp lq b">Signal</code>。如果处理不当，这种循环依赖将导致无限循环。例如，看看下面的代码，其中<code class="fe ln lo lp lq b">b</code>是<code class="fe ln lo lp lq b">a</code>的函数，而<code class="fe ln lo lp lq b">a</code>是<code class="fe ln lo lp lq b">b</code>的函数:</li></ul><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="50e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">幸运的是，这两个问题都很容易解决。为了在必要时更新观察器，我们只需要在每次执行<code class="fe ln lo lp lq b">computeValue</code>时重置观察器:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="6744" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为所有仍然依赖于<code class="fe ln lo lp lq b">Signal</code>的观察点都将调用<code class="fe ln lo lp lq b">Signal</code>的apply方法，所以它们将在被移除后不久被重新添加到观察点集合中。所有不再依赖于<code class="fe ln lo lp lq b">Signal</code>的观察者都不会。</p><p id="1be8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其次，为了防止循环的<code class="fe ln lo lp lq b">Signal</code>定义，我们只需要在apply方法中添加一点点<code class="fe ln lo lp lq b">assert</code>语句:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="43c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果调用的<code class="fe ln lo lp lq b">Signal</code>观察到它检索其值的<code class="fe ln lo lp lq b">Signal</code>，assert语句将抛出一个错误。</p></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><p id="15bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样！感谢您耐心听我解释如何从头开始在Scala中实现一个函数式反应式编程的小框架。我希望你从中学到了一些东西。</p><h1 id="81d3" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">从这里去哪里</h1><ul class=""><li id="f1b4" class="mw mx it js b jt mr jx ms kb nk kf nl kj nm kn nb nc nd ne bi translated">Scala的实际实现。React还有很多我在这里没有提到的特性。如果你有兴趣深入了解，可以看看这篇文章<a class="ae ko" href="https://infoscience.epfl.ch/record/176887/files/DeprecatingObservers2012.pdf" rel="noopener ugc nofollow" target="_blank">用Scala反对观察者模式。反应</a>或者GitHub 上的<a class="ae ko" href="https://github.com/ingoem/scala-react" rel="noopener ugc nofollow" target="_blank">源代码。</a></li><li id="eeb0" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">Scala中还有一些其他的函数式反应式编程框架。我知道<a class="ae ko" href="https://github.com/lihaoyi/scala.rx" rel="noopener ugc nofollow" target="_blank"> scala.rx </a>和<a class="ae ko" href="https://index.scala-lang.org/outr/reactify/reactify/3.0.3?target=_2.12" rel="noopener ugc nofollow" target="_blank"> reactify </a>。(至少第一个也大量基于scala.react)</li><li id="a5df" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">一个相关的、更受欢迎的框架是<a class="ae ko" href="http://reactivex.io/rxscala/" rel="noopener ugc nofollow" target="_blank"> RxScala </a>。然而，RxScala更多的是一种反应式编程的实现，而不是<em class="lf">功能性</em>反应式编程。(如果你对这些区别感到困惑，可以看看我的文章<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/demystifying-functional-reactive-programming-67767dbe520b">揭开函数式反应式编程的神秘面纱</a>)。不过，根据您的需求，RxScala可能是解决您的问题的一个非常好的、有据可查的解决方案。</li></ul></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><p id="aeb4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我计划在以后的文章中研究其中的一些库，所以一定要回来看看。此外，我计划研究如何将这一系列文章中的代码翻译成Python。</p><p id="6234" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如有意见，请留言！</p></div></div>    
</body>
</html>