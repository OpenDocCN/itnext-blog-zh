<html>
<head>
<title>Testing React 16.3+ Components with react-test-renderer (without Enzyme)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用react-test-renderer测试React 16.3+组分(无酶)</h1>
<blockquote>原文：<a href="https://itnext.io/testing-react-16-3-components-with-react-test-renderer-without-enzyme-d9c65d689e88?source=collection_archive---------1-----------------------#2018-07-12">https://itnext.io/testing-react-16-3-components-with-react-test-renderer-without-enzyme-d9c65d689e88?source=collection_archive---------1-----------------------#2018-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0e25a1e3629868d21b77c02eb07ffd63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PDeEZW6eUSBL2GQ1H1XTLg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">无耻地从<a class="ae kc" href="https://blog.algolia.com/how-we-unit-test-react-components-using-expect-jsx/" rel="noopener ugc nofollow" target="_blank">Algolia 2015年同一主题的文章</a>中窃取:)</figcaption></figure><p id="ac46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我最近开始了一个新的React前端项目，并一直在充分利用新的React 16.3上下文API，使数据的深度共享更加干净。然而，在使用我的go-to-react测试库<a class="ae kc" href="https://github.com/airbnb/enzyme" rel="noopener ugc nofollow" target="_blank"> Enzyme </a>编写测试时，我遇到了<a class="ae kc" href="https://github.com/airbnb/enzyme/issues/1598" rel="noopener ugc nofollow" target="_blank">这个问题</a>，它对我来说是一个阻碍！</p><p id="44d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">遗憾的是，已经有6个月没有任何新的Enzyme版本了，他们<a class="ae kc" href="https://github.com/airbnb/enzyme/issues/1705" rel="noopener ugc nofollow" target="_blank">也无法告诉我下一个版本将会是什么时候</a>，所以我决定试用标准的<a class="ae kc" href="https://reactjs.org/docs/test-renderer.html" rel="noopener ugc nofollow" target="_blank"> React测试渲染器</a>，它是库自带的(所以应该总是最新的！)</p><p id="4a7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React测试渲染器的文档没有多少有用的例子，所以我想在这里记录我的发现！</p><h1 id="154f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">安装组件进行测试</h1><p id="5cd0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">与Enzyme类似，您使用一个<code class="fe me mf mg mh b">TestRenderer.create()</code>方法来创建一个组件树以备测试，如下例所示:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9221" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您会注意到我们在测试渲染器中使用了两种主要类型的对象:</p><p id="088e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">renderer</code>顾名思义，指的是你的组件周围的“包装”。对于这个对象，我发现只有几个有用的方法:</p><ol class=""><li id="924c" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated"><code class="fe me mf mg mh b">renderer.toJSON()</code> —这将返回一个JavaScript对象，代表组件的HTML(或react native)输出。</li><li id="ad01" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated"><code class="fe me mf mg mh b">renderer.toTree()</code> —这将返回一个表示组件结构和HTML输出的JavaScript对象</li></ol><p id="2e1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在NodeJS中运行的测试中，您将希望JSON.stringify()能够看到完整的深度！</p><p id="e0a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">instance</code>是对react组件树的根组件<strong class="kf ir">的引用。您将使用这个对象来进行断言，例如<code class="fe me mf mg mh b">instance.findAll()</code>。请参见下面的示例:)</strong></p><h1 id="61dd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在树中定位组件</h1><p id="850d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">与Enzyme不同，react-test-renderer中没有CSS选择器。基本上有三种方法可以找到组件</p><ol class=""><li id="ac20" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">使用<code class="fe me mf mg mh b">instance.find()</code>或<code class="fe me mf mg mh b">instance.findAll()</code>方法，采用一个“谓词”函数(例如<code class="fe me mf mg mh b">(el) =&gt; el.type == 'span'</code>)并对树中的每个组件运行它。</li><li id="0d3e" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">使用<code class="fe me mf mg mh b">instance.findByType</code>或<code class="fe me mf mg mh b">instance.findAllByType()</code>方法，这些方法接受<strong class="kf ir">组件构造器</strong>并返回匹配的组件。</li><li id="620a" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">使用<code class="fe me mf mg mh b">instance.findByProps</code>或<code class="fe me mf mg mh b">instance.findAllByProps()</code>，根据您指定的属性搜索组件。</li></ol><h1 id="1d10" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">示例:搜索带有特定文本的<button/></h1><p id="7e31" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">下面的断言将找到一个<code class="fe me mf mg mh b">&lt;button&gt;Save Changes&lt;/button&gt;</code>标签，并检查它是否被禁用。</p><pre class="mi mj mk ml gt nc mh nd ne aw nf bi"><span id="9baa" class="ng lc iq mh b gy nh ni l nj nk">const saveButton = instance.find(<br/>    (el) =&gt; el.type == 'button'<br/>        &amp;&amp; el.children<br/>        &amp;&amp; el.children[0] == 'Save Changes'<br/>);<br/>expect(button.props.disabled).toEqual(true);</span></pre><p id="9278" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">值得注意的是<code class="fe me mf mg mh b">find()</code>将<strong class="kf ir">精确匹配一个组件</strong>。如果它不匹配任何一个，或者匹配多个，那么它<strong class="kf ir">抛出一个异常</strong>。</p><h1 id="5de6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">按属性查找标签</h1><p id="edd1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">下面的断言找到了一个<code class="fe me mf mg mh b">&lt;input type="radio" /&gt;</code>标签</p><pre class="mi mj mk ml gt nc mh nd ne aw nf bi"><span id="8c77" class="ng lc iq mh b gy nh ni l nj nk">const radio = instance.find(<br/>    (el) =&gt; el.type == 'input'<br/>        &amp;&amp; el.props.type == 'radio'<br/>);</span></pre><h1 id="27fc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">测试组件的缺失</h1><p id="ced5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">因为<code class="fe me mf mg mh b">find()</code>函数<strong class="kf ir">必须</strong>匹配一个组件，所以我们不能用它来测试组件的缺失，但是我们可以用<code class="fe me mf mg mh b">findAll()</code>来测试:)</p><pre class="mi mj mk ml gt nc mh nd ne aw nf bi"><span id="0802" class="ng lc iq mh b gy nh ni l nj nk">const checkedBoxes = instance.findAll(<br/>    (el) =&gt; el.type == 'input'<br/>        &amp;&amp; el.props.type == 'checkbox'<br/>        &amp;&amp; el.props.checked == true<br/>);<br/>expect(checkedBoxes).toHaveLength(0);</span></pre><h1 id="0e00" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在其他组件中搜索组件</h1><p id="4a0c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">像酶一样，您可以搜索组件的子树。在下面的例子中，我们寻找特定<code class="fe me mf mg mh b">&lt;select&gt;</code>中的所有<code class="fe me mf mg mh b">&lt;option&gt;</code>标签</p><pre class="mi mj mk ml gt nc mh nd ne aw nf bi"><span id="9ce2" class="ng lc iq mh b gy nh ni l nj nk">const select = instance.find(<br/>    (el) =&gt; el.type == 'select'<br/>        &amp;&amp; el.props.name == 'regions');</span><span id="9788" class="ng lc iq mh b gy nl ni l nj nk">const options = select.findAll(<br/>    (el) =&gt; el.type == 'option');</span><span id="9bf9" class="ng lc iq mh b gy nl ni l nj nk">expect(options.length).toEqual(regionData.length);</span></pre><h1 id="a85d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">通过构造函数搜索组件并读取属性</h1><p id="350a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果您想基于React组件属性而不是它们的输出来编写您的断言，您可以通过使用<strong class="kf ir">组件构造函数进行搜索来实现。</strong></p><p id="d49b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的断言将匹配一个<code class="fe me mf mg mh b">&lt;CardHeader /&gt;</code> react组件，并检查它的<code class="fe me mf mg mh b">title</code>属性。</p><pre class="mi mj mk ml gt nc mh nd ne aw nf bi"><span id="da87" class="ng lc iq mh b gy nh ni l nj nk">import CardHeader from '@material-ui/core/CardHeader';</span><span id="6d53" class="ng lc iq mh b gy nl ni l nj nk">const cardHeader = instance.findByType(CardHeader);</span><span id="b6f6" class="ng lc iq mh b gy nl ni l nj nk">expect(cardHeader.props.title).toEqual('My awesome app');</span></pre><h1 id="ecb8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">测试事件处理程序</h1><p id="c701" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">幸运的是，使用React测试呈现器测试事件处理程序及其结果非常简单。它的工作原理和酶差不多。</p><p id="038f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你所需要做的就是获得一个对组件的引用(例如使用<code class="fe me mf mg mh b">find()</code>，然后通过<code class="fe me mf mg mh b">props</code>直接触发事件处理程序，例如:</p><pre class="mi mj mk ml gt nc mh nd ne aw nf bi"><span id="3806" class="ng lc iq mh b gy nh ni l nj nk">const select = instance.find(<br/>    (el) =&gt; el.type == 'select');</span><span id="349c" class="ng lc iq mh b gy nl ni l nj nk">// trigger the onChange event for the select box<br/>select.props.onChange({<br/>    target: { value: 'blue' }<br/>});</span><span id="eeef" class="ng lc iq mh b gy nl ni l nj nk">expect(colourChangerMock).toHaveBeenCalledWith('blue');</span></pre><p id="f741" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意—根据事件处理程序的需要，您负责创建合适的事件对象。上面的onChange示例应该适用于大多数输入字段。</p><p id="192a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样值得注意的是，呈现的组件树似乎会像在浏览器中一样得到更新，所以如果您的事件处理程序触发了组件更新，那么您应该能够立即检查它们。我不需要像过去用Enzyme那样用React Test Render调用任何<code class="fe me mf mg mh b">updade()</code>方法。</p><h1 id="1c77" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="7f38" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">幸运的是，react测试渲染器似乎支持测试React组件所需的所有基本功能，其优势在于它与主React包位于同一个存储库中，因此它更有可能与最新版本一起工作！<em class="nm">(我看到他们正在增加异步渲染支持:)</em></p><p id="177e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望这篇文章能帮助像我一样苦于缺乏全面的测试渲染器文档的人:)</p></div></div>    
</body>
</html>