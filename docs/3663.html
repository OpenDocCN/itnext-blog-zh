<html>
<head>
<title>Angular Testing Tips and Tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度测试技巧和窍门</h1>
<blockquote>原文：<a href="https://itnext.io/angular-testing-tips-and-tricks-6c1e21a7cf65?source=collection_archive---------1-----------------------#2020-01-27">https://itnext.io/angular-testing-tips-and-tricks-6c1e21a7cf65?source=collection_archive---------1-----------------------#2020-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a57e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">帮助您充分利用测试的提示和技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/76b42b0cd50963581b91260658eb0744.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YayObskHgB9y7f-pWu4daQ.png"/></div></div></figure><p id="2ba2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我将探索一些我每天在用Angular编写单元测试时使用的简单技巧和窍门。实施这些提示将帮助您:</p><ul class=""><li id="dcda" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">编写对变更和重构更健壮的测试</li><li id="f255" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">简化编写测试的过程</li><li id="5d54" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">让测试更有用，确保测试不会在不应该通过的时候通过</li><li id="d699" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">让运行测试更高效</li></ul><h2 id="14bf" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated"><strong class="ak">提示1。使用jasmine . createspyobj&lt;T&gt;T8】</strong></h2><p id="86ec" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">使用通用版本的<code class="fe nc nd ne nf b">jasmine.createSpyObj</code>。这确保了间谍的类型安全，允许编译器验证被模仿的方法确实存在。让我们假设我们意外地创建了如下间谍(将<code class="fe nc nd ne nf b">delete</code>拼错为<code class="fe nc nd ne nf b">dlete</code>):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/1ab469a3f2d062154a37f2c14bb2f0e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jCdGzmwcdjmYFJ9lBb11cA.png"/></div></div></figure><p id="bb92" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于泛型调用，编译器将抛出以下错误:<code class="fe nc nd ne nf b">error TS2345: Argument of type ‘(“dlete” | “tggl”)[]’ is not assignable to parameter of type ...</code></p><p id="de51" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们使用非通用版本(<code class="fe nc nd ne nf b">jasmine.createSpyObj(‘TodoService’, [‘dlete’, ‘tggl’]);</code>)，编译器就不会抛出错误。享受花15分钟思考为什么你的测试总是失败(这是我的经验之谈😥).</p><h2 id="db85" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated"><strong class="ak">提示2。在beforeEach区块中创建你的间谍</strong></h2><p id="78ee" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">你可能想保存一行并在声明它时初始化spy:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/0a2be4f38d7e49c4dfbb5235356e7b38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qw6zuDJhlKkaNiGvVMhLwQ.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">在describe块中初始化todoService意味着相同的实例将在所有测试中使用</figcaption></figure><p id="b24b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不要这样。这将在测试之间保持相同的间谍，导致测试在不应该通过的时候通过，并随机失败(取决于执行顺序)。</p><p id="10e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为一个例子，让我们假设你有一个测试检查<code class="fe nc nd ne nf b">delete</code>是否被调用，然后下一个测试期望它没有被调用:</p><pre class="kj kk kl km gt nm nf nn no aw np bi"><span id="49d5" class="me mf it nf b gy nq nr l ns nt">it('should call delete', () =&gt; { <br/>  // do some stuff<br/>  expect(todoService.delete).toHaveBeenCalled();<br/>});</span><span id="3e47" class="me mf it nf b gy nu nr l ns nt">it('should not call delete', () =&gt; { <br/>  // do other stuff<br/>  expect(todoService.delete).not.toHaveBeenCalled();<br/>});</span></pre><p id="7daa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第二次测试将会失败，因为在第一次测试中已经调用了<code class="fe nc nd ne nf b">delete</code>。在beforeEach块中创建spy将确保每个测试接收到一个新的实例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/e8635f20b7a1cd0808f803c00fdb3fa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tvDcnDAsk9FpU94ECHDd_w.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">在describe块中声明todoService，但在beforeEach中初始化它，以确保每个测试都有一个新的实例</figcaption></figure><h2 id="8928" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">技巧三。对共享服务使用模拟服务</h2><p id="4a3e" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">如果一个服务在多个地方被使用，将它提取到自己的模拟类中。您可以定义一次，只在需要的地方注入模拟版本，而不是在每个使用服务的地方都创建一个spy。这是我们采取的方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/9b0ee86dcccb01572b5931eb404ee08c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQze5FetViY4Pmn-EB8x_A.png"/></div></div></figure><p id="bda7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，我们为我们的服务之一创建了一个模拟。由于这个服务通过<code class="fe nc nd ne nf b">getState$</code>提供了一个可观察对象，我们在这个类中实例化了这个可观察对象。我们还创建了一些助手方法来改变控制室的状态。这确保了如果<code class="fe nc nd ne nf b">ControlRoomStateService</code>的实现发生变化，我们只需要在一个地方改变它。</p><p id="4a4b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是我们如何设置组件测试来使用这个模拟服务:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/7680bfd7967730bfed961e76da85a34d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bYNiyVFVmIP1vxPIp8nDLQ.png"/></div></div></figure><p id="040a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并使用模拟服务来简化我们的测试:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/1558f688f8a143695b1c7fbeec8e12d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XRLKn1C3KTdZjqLWaaBCpw.png"/></div></div></figure><h2 id="674e" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated"><strong class="ak">提示4。将元素查询代码提取到函数中。</strong></h2><p id="c444" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">通过将查询代码提取到它们自己的函数中，使得以后重构测试更加容易。举一个例子，如下:</p><pre class="kj kk kl km gt nm nf nn no aw np bi"><span id="619e" class="me mf it nf b gy nq nr l ns nt">it('should show error', () =&gt; {<br/>  // setup error state<br/>  expect(fixture.nativeElement.querySelector('.error')).toBeFalsy();<br/>});</span><span id="30e9" class="me mf it nf b gy nu nr l ns nt">it('should not show error', () =&gt; {<br/>  // setup good state<br/> expect(fixture.nativeElement.querySelector('.error')).toBeTruthy();<br/>});</span></pre><p id="8290" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，如果我们后来将类从<code class="fe nc nd ne nf b">error</code>改为<code class="fe nc nd ne nf b">invalid-title</code>，只有第二个测试会失败。开发人员可能会进行以下更改:</p><pre class="kj kk kl km gt nm nf nn no aw np bi"><span id="43d7" class="me mf it nf b gy nq nr l ns nt">it('should show error', () =&gt; {<br/>  // setup error state<br/>  expect(fixture.nativeElement.querySelector('.error')).toBeFalsy();<br/>});</span><span id="f118" class="me mf it nf b gy nu nr l ns nt">it('should not show error', () =&gt; {<br/>  // setup good state<br/>  expect(fixture.nativeElement.querySelector('<strong class="nf iu">.invalid-title</strong>')).toBeTruthy();<br/>});</span></pre><p id="35d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这两个测试现在都通过了，但是第一个测试现在没有用了——我们永远不会显示<code class="fe nc nd ne nf b">error</code>类(然而，有可能<code class="fe nc nd ne nf b">invalid-title</code>会一直显示，因为我们没有测试来检查它)。请考虑以下实现:</p><pre class="kj kk kl km gt nm nf nn no aw np bi"><span id="235d" class="me mf it nf b gy nq nr l ns nt">it('should show error', () =&gt; {<br/>  // setup error state<br/>  expect(getErrorEl()).toBeFalsy();<br/>});</span><span id="8a42" class="me mf it nf b gy nu nr l ns nt">it('should not show error', () =&gt; {<br/>  // setup good state<br/> expect(getErrorEl()).toBeTruthy();<br/>});</span><span id="bd78" class="me mf it nf b gy nu nr l ns nt">function getErrorEl(): HTMLElement {<br/> return fixture.nativeElement.querySelector('.error');<br/>}</span></pre><p id="98e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这一次，修复第二个单元测试将确保第一个单元测试也被更新。</p><h2 id="ec65" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">技巧五。使用NgMocks轻松地与子组件交互</h2><p id="ade5" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated"><a class="ae ny" href="https://medium.com/@abdul_74410/towards-better-testing-in-angular-part-1-mocking-child-components-b51e1fd571da" rel="noopener"> <em class="nz">要深入了解测试子组件，请参阅本文。</em>T15】</a></p><p id="f2be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae ny" href="https://github.com/ike18t/ng-mocks" rel="noopener ugc nofollow" target="_blank"> NgMocks </a>让测试子组件变得超级简单。不使用<code class="fe nc nd ne nf b">NO_ERRORS_SCHEMA</code>或<code class="fe nc nd ne nf b">CUSTOM_ERRORS_SCHEMA</code>，我们可以简单地用<code class="fe nc nd ne nf b">MockComponent</code>声明一个组件。这个:</p><ul class=""><li id="4d81" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">确保组件输入和输出的类型安全</li><li id="2037" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">允许我们验证输入设置是否正确</li><li id="a9e5" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">帮助测试我们的被测组件是否正确响应子组件的输出事件。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/0356fe51b79a94198246879ed6421f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Czf-wL69AK7r4mK2WqfJnQ.png"/></div></div></figure><h2 id="81b4" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">提示6。将测试集中在您正在测试的组件/服务上</h2><p id="ce78" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">随着应用程序的增长，每次进行更改时运行所有的单元测试将会非常慢。当测试一个组件或服务时，您可以通过将<code class="fe nc nd ne nf b">describe</code>更改为<code class="fe nc nd ne nf b">fdescribe</code>，在特定的<code class="fe nc nd ne nf b">describe</code>块中运行测试。类似地，要运行单个单元测试，将<code class="fe nc nd ne nf b">it(...)</code>改为<code class="fe nc nd ne nf b">fit(...)</code>。只要确保在将代码提交给master之前将它们还原就行了！</p><h2 id="705f" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">技巧7。禁用sourceMaps以加快单元测试</h2><p id="6a7b" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">当您的应用程序仍然很小的时候，这不是问题，但是随着它的增长，源映射会大大降低测试运行的速度。当我在开发时，我总是在禁用源地图的情况下运行:</p><pre class="kj kk kl km gt nm nf nn no aw np bi"><span id="6fc0" class="me mf it nf b gy nq nr l ns nt">ng test --sourceMap=false</span></pre><p id="7c0a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的应用程序中，有大约1200个测试，在禁用源代码映射的情况下，关注单个组件来运行15个测试大约需要4秒钟。启用源地图后，需要24秒的时间😱。这是生产率的巨大差异。</p><p id="471e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，您可能希望启用源映射是有原因的(通过浏览器调试测试)。实际上，只要测试被适当地隔离，我很少通过浏览器进行调试。在极少数情况下，我只是启用源地图，直到解决问题，然后关闭它继续测试和开发。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="4951" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nz">对这篇文章有什么问题或反馈，或者你希望我接下来写什么？请在下面给我留言或在twitter上联系我，</em><a class="ae ny" href="https://twitter.com/abdul_rafehi" rel="noopener ugc nofollow" target="_blank"><em class="nz">@ Abdul _ Rafe hi</em></a></p></div></div>    
</body>
</html>