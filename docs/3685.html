<html>
<head>
<title>Increasing kubeval linting speeds 🚀</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高库贝瓦尔林挺速度🚀</h1>
<blockquote>原文：<a href="https://itnext.io/increasing-kubeval-linting-speeds-9607d1141c6a?source=collection_archive---------2-----------------------#2020-02-02">https://itnext.io/increasing-kubeval-linting-speeds-9607d1141c6a?source=collection_archive---------2-----------------------#2020-02-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3000fe62cc6ed47280b63b0794a32adc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cLTdgPhKMhLKy48t.png"/></div></div></figure><p id="48e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Mettle，我们所有的工作负载都在Kubernetes上运行，它们是使用名为Flux(<a class="ae kw" href="https://github.com/fluxcd/flux" rel="noopener ugc nofollow" target="_blank">https://github.com/fluxcd/flux</a>)的GitOps运营商部署的。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="aa66" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是GitOps？</h1><p id="81dd" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">那么什么是GitOps呢？从表面上看，这很简单。GitOps的核心是使用一个版本控制系统(比如Git)来存放Kubernetes部署的所有信息、文档和代码，然后使用自动化控制器将更改部署到集群。GitOps为开发人员提供了一种使用Git和他们自己的版本控制系统来管理操作工作流的方法，特别是对于Kubernetes。</p><p id="7395" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简而言之，使用pull请求合并代码的过程也用于将工作负载部署到Kubernetes。</p><h1 id="0f6c" class="le lf iq bd lg lh mh lj lk ll mi ln lo lp mj lr ls lt mk lv lw lx ml lz ma mb bi translated">连续累计</h1><p id="2229" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">像任何好的拉式请求(PR)工作流一样，我们需要运行持续的集成测试，以验证我们的更改可合并到我们的代码库中。这与我们在源代码控制中维护的Kubernetes清单没有什么不同。</p><p id="79af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在Mettle的所有定制头盔图表都存储在一个名为<strong class="ka ir"> mettle/k8s-helm-charts的集中存储库中。</strong>然后使用Flux HelmReleases将这些图表部署到我们的Kubernetes集群中，要了解更多信息，请参见<a class="ae kw" href="https://docs.fluxcd.io/projects/helm-operator/en/latest/references/helmrelease-custom-resource.html" rel="noopener ugc nofollow" target="_blank">https://docs . Flux CD . io/projects/helm-operator/en/latest/references/helm release-custom-resource . html</a></p><h1 id="e336" class="le lf iq bd lg lh mh lj lk ll mi ln lo lp mj lr ls lt mk lv lw lx ml lz ma mb bi translated">CI问题</h1><p id="5338" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">我们通过执行<code class="fe mm mn mo mp b">helm template</code>来验证我们的helm图表，然后将每个图表的输出依次传送到<code class="fe mm mn mo mp b">kubeval</code>(<a class="ae kw" href="https://github.com/instrumenta/kubeval" rel="noopener ugc nofollow" target="_blank">https://github.com/instrumenta/kubeval</a>)(见下文)，以验证清单与特定版本的Kubernetes的模式定义一致。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="8d57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题是每次执行<code class="fe mm mn mo mp b">kubeval</code>似乎都要花费很长时间，我们意识到这是因为kubeval每次都必须拉下所有的模式来验证舵图。这意味着，如果我们向存储库添加更多的图表，只会混淆问题。</p><p id="45cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">图式:</strong><a class="ae kw" href="https://github.com/instrumenta/kubernetes-json-schema" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">https://github.com/instrumenta/kubernetes-json-schema</strong></a></p><h1 id="3df6" class="le lf iq bd lg lh mh lj lk ll mi ln lo lp mj lr ls lt mk lv lw lx ml lz ma mb bi translated">竞争情报解决方案</h1><p id="4483" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">在查看Kubeval可用的旗帜时，我注意到以下一个:</p><pre class="mq mr ms mt gt mw mp mx my aw mz bi"><span id="7149" class="na lf iq mp b gy nb nc l nd ne">-s, --schema-location string                </span><span id="faef" class="na lf iq mp b gy nf nc l nd ne">Base URL used to download schemas. Can also be specified with the environment variable KUBEVAL_SCHEMA_LOCATION.</span></pre><p id="e01f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们可以在本地下载必要的模式，然后将kubeval指向它们，这将大大减少显示我们的舵图所需的时间。</p><p id="52dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我着手创建了一个名为<code class="fe mm mn mo mp b">kubernetes-toolkit</code>的容器，其中包含了我们用来验证kubernetes清单的所有包和二进制文件(例如kubectl、helm，当然还有kubeval)。</p><p id="6772" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，也是最重要的一点，我会在构建时在容器中下载特定版本的kubectl的模式。这方面的bash脚本如下所示</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="6027" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kubernetes的版本在构建时作为参数传递给<code class="fe mm mn mo mp b">Dockerfile</code>，以确保安装了正确的<code class="fe mm mn mo mp b">kubectl</code>版本，最重要的是<strong class="ka ir">容器中只存储了该版本的模式定义。</strong></p><p id="75f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">维护特定模式集的逻辑如下所示:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="3388" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，我们需要将运行<code class="fe mm mn mo mp b">kubeval</code>的bash脚本调整为:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="6a6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在设置<code class="fe mm mn mo mp b">KUBEVAL_SCHEMA_LOCATION</code>环境变量，以确保使用容器内的模式。此外，我们使用<br/> <code class="fe mm mn mo mp b">—- kubernetes-version</code>标志明确告诉kubeval要验证哪个版本的Kubernetes，这是必需的，因为容器只包含1.17版本的模式。</p><p id="e86a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们需要在CircleCI配置文件(如下)中将这一切联系起来</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="c956" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的目标是为kubernetes的每个版本构建一个新版本的<code class="fe mm mn mo mp b">kubernetes-toolkit</code>容器，并相应地更新我们相应的CI作业。</p><h1 id="8123" class="le lf iq bd lg lh mh lj lk ll mi ln lo lp mj lr ls lt mk lv lw lx ml lz ma mb bi translated">退关货物</h1><p id="50b3" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">我想为这个想法大声喊出来<a class="ae kw" href="https://twitter.com/karlstoney" rel="noopener ugc nofollow" target="_blank">https://twitter.com/karlstoney</a>它以最小的改变将我们的构建时间从20分钟减少到大约5秒。</p></div></div>    
</body>
</html>