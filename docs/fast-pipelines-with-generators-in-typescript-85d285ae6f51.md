# TypeScript 中带有生成器的惰性管道

> 原文：<https://itnext.io/fast-pipelines-with-generators-in-typescript-85d285ae6f51?source=collection_archive---------0----------------------->

![](img/a412fd60689eb49d0e7056ab4d93e2ca.png)

照片由[昆腾·德格拉夫](https://unsplash.com/@quinten149?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

近年来，JavaScript 社区已经接受了像`map`和`filter`这样的函数数组方法。编写 for-loops 已经成为与 2015 和 JQuery 联系在一起的东西。但是当我们谈论性能时，JavaScript 中的数组方法远非理想。让我们看一个例子来阐明这些问题:

该代码将执行以下步骤:

*   创建包含 5 个项目的数组
*   创建一个所有数字都加倍的新数组
*   创建一个过滤了数字的新数组
*   拿第一个项目

这涉及到比实际需要更多的事情发生。唯一要发生的事情是，第一个通过`x > 5`的项目被处理并返回。在其他语言(如 Python)中，迭代器被用来解决这个问题。那些迭代器是一个懒惰的集合，只在被请求时处理数据。如果 JavaScript 将惰性迭代器用于其数组方法，则会发生以下情况:

*   `[0]`向`filter`请求第一个项目
*   `filter`请求来自`map`的项目，直到找到一个通过谓词的项目并产生(“返回”)它
*   `map`每次处理`filter`请求的项目

这里我们只做了数组中的第一个树条目`map`和`filter`，因为迭代器不再请求更多的条目。这里也没有构造额外的数组或迭代器，因为每一项都一个接一个地通过整个管道。这是一个概念，当处理大量数据时,*可以*产生巨大的性能增益。

# JavaScript 中的生成器和迭代器

幸运的是，JavaScript 实际上支持迭代器的概念。它们可以用生成集合项目的[生成器](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)函数来创建。生成器函数如下所示:

这里 for 循环将为每个循环请求一个迭代器项。generator 函数使用`yield`关键字返回集合中的下一项。如你所见，我们可以多次生成包含多项的迭代器。永远不会在内存中构造任何数组。当我们去掉一些语法糖时，我们可以更好地理解这一点:

这里可以看到迭代器有一个用于请求下一项的`next`方法。这个方法的结果有一个值和一个布尔值，表明迭代器中还有更多结果。虽然这非常有趣，但如果我们想用迭代器构建合适的数据管道，我们还需要更多的东西:

*   从数组到迭代器的转换
*   操作其他迭代器的迭代器，比如`map`和`filter`(也称为‘高阶迭代器’)
*   一个合适的接口，以优雅和实用的方式将所有这些链接在一起

在本文的其余部分，我将展示如何做这些事情。最后，我加入了一个链接，指向我创建的包含更多特性的库。遗憾的是，这不是惰性迭代器的本机实现。这意味着有开销，在很多情况下这个库不值得。但是我仍然想向您展示这个概念，并讨论它的利弊。

# 迭代器构造函数

我们希望能够从多个数据源创建迭代器。最容易忘记的是数组。这个很简单，我们遍历数组，得到所有的条目:

转动数组中的迭代器需要我们调用`next`,直到我们得到所有的元素。在此之后，我们可以返回我们的数组。当然，你只希望在绝对需要的时候把迭代器变成数组，因为这个函数会导致一次完整的迭代。

从迭代器读取数据的另一种方法是`first`。它的实现如下所示。注意，它只从迭代器中请求第一项！这意味着下面所有的潜在值将永远不会被计算，从而减少数据管道中的资源浪费。

在完整的库中，也有从[函数](https://github.com/WimJongeneel/ts-lazy-collections/blob/master/src/main.ts#L65-L74)或[范围](https://github.com/WimJongeneel/ts-lazy-collections/blob/master/src/main.ts#L57-L63)创建迭代器的构造函数。

# 高阶迭代器

高阶迭代器将现有迭代器转换成新的迭代器。这些迭代器构成了管道中的操作。众所周知的转换函数`map`如下所示。它接受一个迭代器和一个函数，并返回一个新的迭代器，其中函数应用于原始迭代器中的所有项。注意，在转换迭代器时，我们仍然是逐项生成，并保留了迭代器的惰性。如果我们真的想达到我在本文介绍中提到的更高的效率，这是非常重要的！

过滤可以以类似方式实现。当请求下一个条目时，它将继续从内部迭代器请求条目，直到找到一个通过谓词的条目。该项将被放弃，执行将暂停，直到下一项的请求到来。

更多的高阶迭代器可以用我上面展示的相同概念来构造。完整的图书馆里有很多，点击[这里](https://github.com/WimJongeneel/ts-lazy-collections#collection-methods)查看。

# 构建器界面

库的最后一部分是面向公众的 API。该库使用 builder 模式来允许您像在数组上一样链接方法。这是通过创建一个函数来实现的，该函数接受一个迭代器并返回一个包含方法的对象。这些方法可以使用更新的迭代器再次调用构造函数进行链接:

本文开头的例子可以写成如下。在这个实现中，我们不创建额外的数组，只处理实际使用的数据！

# 结论

在本文中，我向您展示了如何使用生成器和迭代器来创建一个强大且非常高效的库，以处理大量数据。当然，迭代器并不是解决所有问题的灵丹妙药。效率的提高是因为节省了不必要的计算。这在实数中意味着什么完全取决于有多少计算可以优化，这些计算有多重，以及你要处理多少数据。当没有要保存的计算或者集合相对较小时，您可能会因为库的开销而损失性能。

完整的源代码可以在 [Github](https://github.com/WimJongeneel/ts-lazy-collections#collection-methods) 上找到，包含了更多适合本文的特性。我很想听听你对此的看法。你认为 JavaScript 没有对数组方法使用惰性迭代是一个遗憾吗？你认为使用生成器是 JavaScript 集合的发展方向吗？如果 JavaScript 在默认情况下使用惰性迭代器，它们应该能够优化开销(就像其他语言所做的那样)，同时仍然有效地保持潜在的优势。