<html>
<head>
<title>Debugging Functional Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">调试功能Javascript</h1>
<blockquote>原文：<a href="https://itnext.io/debugging-functional-javascript-545b6ea59660?source=collection_archive---------1-----------------------#2018-04-03">https://itnext.io/debugging-functional-javascript-545b6ea59660?source=collection_archive---------1-----------------------#2018-04-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ddc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在探索了Javascript中的函数式编程之后，我想写一些调试时值得考虑的权衡。这篇文章相当固执己见，但是提供了一些技巧来使事情变得简单。</p><p id="f80d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将假设您熟悉基本的函数式编程概念。我提出的一些问题并不特定于功能模式本身。</p><p id="2734" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你一直写100%没有错别字的完美代码，你可能会觉得有点枯燥。或者，如果你认为苹果可以像取消escape键一样取消退格键，你应该继续:/</p><p id="5518" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样做的目的不是阻止任何人用更实用的风格写作。这也不是要阻止使用像<a class="ae kl" href="http://ramdajs.com/" rel="noopener ugc nofollow" target="_blank">拉姆达</a>、<a class="ae kl" href="https://github.com/lodash/lodash/wiki/FP-Guide" rel="noopener ugc nofollow" target="_blank">洛达什_fp </a>或<a class="ae kl" href="https://sanctuary.js.org/" rel="noopener ugc nofollow" target="_blank">避难所</a>这样的高质量功能库。我喜欢用功能性更强的风格编写代码，并且理解许多使用和推广它的好理由。</p><p id="7a8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">免责声明已经够多了</em>。</p><p id="8ef8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我发现在某些情况下，特别是在Javascript中使用<a class="ae kl" href="https://en.wikipedia.org/wiki/Tacit_programming" rel="noopener ugc nofollow" target="_blank">默认/无点</a>编程风格时，会导致堆栈跟踪混乱和调试障碍。</p><p id="9173" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从查看一些函数式代码中意外错误的堆栈跟踪开始。这可能只是一些愚蠢的打字错误，在这种情况下，它来自一些使用<a class="ae kl" href="http://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> Ramda </a>库的相当“简单”的东西:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/3e8510bd1299e1fc32e793d303021d82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vnHOQ0jsdF4-rZ1E.png"/></div></div></figure><p id="328b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看到这种事情，不禁想起自己在编写调试<code class="fe kz la lb lc b">Angularjs 1.x</code>控制台错误时看到和经历的挫败感。</p><p id="61a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，人们很容易天真地认为:</p><blockquote class="ld le lf"><p id="0174" class="jn jo km jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated"><em class="iq">“如果一个错误的调用栈只显示了依赖关系中的行，那么这个错误一定是依赖关系中的一个bug！”</em></p><p id="0cb1" class="jn jo km jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">没有一个程序员有过这样的想法←讽刺</p></blockquote><p id="ed29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你在github等网站上看到过多少期被人评论为:</p><blockquote class="ld le lf"><p id="dc6e" class="jn jo km jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated"><em class="iq">“呜呜对不起我的错，我没看到…”</em></p></blockquote><p id="fa36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">抛开一厢情愿的想法，您需要解决这个错误，不管它是否是您的代码。从消息中可能很难看出在代码中的什么地方引用了一般称为“name”的东西。众所周知，可能是一些聪明人使用了<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name" rel="noopener ugc nofollow" target="_blank">函数原型</a>的name属性。</p><p id="b352" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在调用栈中看到的是非常常见的函数模式中的函数名，如<code class="fe kz la lb lc b">pipe</code>、<code class="fe kz la lb lc b">curry</code>和<code class="fe kz la lb lc b">map</code>。问题是，你可能会在你的代码库中使用这些。所以这就相当于知道代码路径使用了<code class="fe kz la lb lc b">if</code>和<code class="fe kz la lb lc b">else</code>语句。没用，如果这来自生产，祝你好运知道从哪里开始有效地调试问题。</p><p id="aa8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，为什么更函数式的编程风格会导致这样混乱的堆栈跟踪呢？</p><p id="75cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它是以下各项的组合:</p><ul class=""><li id="d45d" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated"><a class="ae kl" href="https://en.wikipedia.org/wiki/Currying" rel="noopener ugc nofollow" target="_blank">功能驱动</a></li><li id="95c6" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><a class="ae kl" href="https://en.wikipedia.org/wiki/Tacit_programming" rel="noopener ugc nofollow" target="_blank">心照不宣/免分</a>风格</li><li id="9fb7" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">Javascript的动态特性</li><li id="f8ec" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">异步方法</li><li id="ec78" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">大量的库代码</li></ul><p id="b827" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有这些都有一个副作用，就是用函数名填充调用堆栈，这些函数名通常是匿名的，或者来自一个依赖项，如果它们没有被完全放大的话。现在浏览器的调用栈大小毕竟是有限的。我将向您展示如何进一步增加它。</p><h1 id="2097" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">比较命令式和函数式示例</h1><p id="d5b7" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">通过一个简单的代码示例，这一点更容易理解。来自不太琐碎和较大的代码库的代码很可能有更长的堆栈跟踪，如果你只是走进来，可能会更难推理。</p><p id="1653" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，假设我们从一个服务中得到以下对象。</p><pre class="ko kp kq kr gt na lc nb nc aw nd bi"><span id="d42b" class="ne ly iq lc b gy nf ng l nh ni">const response = {<br/>  messages: [<br/>    {<br/>      user: {<br/>        role: 'The first ones',<br/>        name: 'Kosh',<br/>        species: 'Vorlon'<br/>      },<br/>      text: 'Who are you?'<br/>    }<br/>  ]<br/>}</span></pre><p id="8c56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要在视图中显示一些逗号分隔的文本。文本必须包含所有用户名及其种类的列表。每个用户需要采用以下格式:</p><pre class="ko kp kq kr gt na lc nb nc aw nd bi"><span id="4f1a" class="ne ly iq lc b gy nf ng l nh ni">`${userName} is a ${species}`</span><span id="3d6d" class="ne ly iq lc b gy nj ng l nh ni"><em class="km">// Eg =&gt;  Kosh is a Vorlon, ...</em></span></pre><p id="e5d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了举例说明，让我们用几种不同的风格来实现它。</p><h2 id="662f" class="ne ly iq bd lz nk nl dn md nm nn dp mh jy no np ml kc nq nr mp kg ns nt mt nu bi translated">无功能点</h2><pre class="ko kp kq kr gt na lc nb nc aw nd bi"><span id="154f" class="ne ly iq lc b gy nf ng l nh ni">const userDisplayText = R.pipe(<br/>  R.prop(['user']),<br/>  R.props(['name', 'species']),<br/>  R.intersperse('is a'),<br/>  R.join(' ')<br/>)</span><span id="0dc3" class="ne ly iq lc b gy nj ng l nh ni">const messagesDisplayText = R.pipe(<br/>  R.prop('messages'),<br/>  R.map(userDisplayText),<br/>  R.join(', ')<br/>)</span></pre><h2 id="c6c3" class="ne ly iq bd lz nk nl dn md nm nn dp mh jy no np ml kc nq nr mp kg ns nt mt nu bi translated">必要的</h2><pre class="ko kp kq kr gt na lc nb nc aw nd bi"><span id="eefd" class="ne ly iq lc b gy nf ng l nh ni">function messagesDisplayText(response) {<br/>  var users = []<br/>  for (var i = 0; i &lt; response.messages.length; i++) {<br/>    var user = response.messages[i].user<br/>    var details = [<br/>      user.name,<br/>      'is a',<br/>      user.species<br/>    ]<br/>    users.push(details.join(' '))<br/>  }<br/>  return users.join(', ');<br/>}</span></pre><p id="c47d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，这些都是奇怪且不完美的实现方式，它只是用来描述不同之处。然而，它们都输出相同的所需字符串。现在的<em class="km">因为发生了错误，显然用户在响应中的有效值也是null:</em></p><pre class="ko kp kq kr gt na lc nb nc aw nd bi"><span id="ac86" class="ne ly iq lc b gy nf ng l nh ni">const response = {<br/>  messages: [<br/>    {<br/>      user: {<br/>        name: 'Kosh',<br/>        species: 'Vorlon'<br/>      },<br/>      text: 'Who are you?'<br/>    },<br/>    {<br/>      user: null,<br/>      text: 'What do you want?',<br/>    },<br/>  ]<br/>}</span></pre><p id="4dc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们怎么知道？:(</p><p id="8c74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你猜对了，是的，这就是你在文章开头看到的错误的原因。</p><p id="4f8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在Chromium中使用“异常暂停”时看到这一点，并并排比较这两种风格:</p><p id="099e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">功能性:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/4fc5df96ea67c3ae46ed40d9dca17e5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5T96xNlqEmOWf4Ai.png"/></div></div></figure><p id="a52a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">命令式:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nv"><img src="../Images/6804eca9aec1083ae0ea82af392901c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4q5fo7KoNJ_n5_Ke.png"/></div></div></figure><p id="a137" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个特定的场景中，它几乎就像是黑白的。命令式调用堆栈显示了理解问题所需的确切函数名和行号。</p><h1 id="37fa" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">为什么继续使用功能性风格？</h1><p id="f03b" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">具有讽刺意味的是，人们对函数式编程感兴趣的一个原因是代码更容易推理。在这种情况下，一些在命令式风格下可以阅读的东西，现在会产生一些在函数式风格下看起来更复杂的错误。</p><p id="d2e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了这个示例之外，问题的原因可能不像服务器响应返回意外的有效负载签名那样简单或不可能。知道这个值为什么是<code class="fe kz la lb lc b">null</code>远不是一件小事。</p><p id="cc63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据我目前所知，我将尝试描述一个函数式程序员最糟糕的噩梦。考虑错误发生在具有深度继承的类内部，在具有命令式代码的属性上。这段代码改变了一个复杂的本地状态，也可能受到未记录的、难以推断和预测的副作用的影响。在这种情况下，通常很难跟踪和再现对象状态。尤其是在qa或生产中开发之后才第一次看到的状态。更糟糕的是，除了您自己的机器之外，其他机器上似乎只发生这种情况。</p><p id="dadc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于<code class="fe kz la lb lc b">Functional vs Imperative</code>的讨论超出了本文的范围。所以收起你的战斗手套吧，大概之前都说过了；)</p><p id="1d01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无论如何，不要因为理解这样的错误而失去希望，让我们通过一些技术来进行调试。</p><h1 id="5dcf" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">Devtools黑盒</h1><p id="328e" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">就像任何其他有很多依赖项的Javascript项目一样，我们可以使用大多数主流浏览器的devtools提供的<a class="ae kl" href="https://developer.chrome.com/devtools/docs/blackboxing" rel="noopener ugc nofollow" target="_blank">黑盒</a>特性。实际上，我们可以从视图堆栈行中过滤出我们当前不关心的依赖项。</p><p id="4c96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用上面的例子，这里是功能性例子的“在未捕获的异常上暂停”,所有的Ramda行都是黑色的:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/3ea19ba47dd95a775bd3a68dea0cf18f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/0*nzZzh0lvSBhIpecV.png"/></div></figure><p id="99bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，在这种情况下，在隐藏了20帧Ramda之后，你现在可以看到我在<code class="fe kz la lb lc b">main.tsx:24</code>上写代码的地方了。这正是我调用导致异常的自由点方法的地方。</p><p id="0e6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">知道这些过滤器可以在重新加载时保持持久是很有用的，如果您需要过滤掉一些更具体的东西，它们还支持正则表达式。黑盒还有<a class="ae kl" href="https://developer.chrome.com/devtools/docs/blackboxing#what-happens" rel="noopener ugc nofollow" target="_blank">这些效果</a>需要注意:</p><ul class=""><li id="ccce" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">从库代码抛出的异常不会暂停(如果启用了异常暂停)，</li><li id="a842" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">步入/退出/跳过库代码，</li><li id="427d" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">事件侦听器断点不会在库代码中中断，</li><li id="d103" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">调试器不会在库代码中设置的任何断点上暂停。</li></ul><h1 id="feea" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">堆栈跟踪限制</h1><p id="6b04" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">如果您正在编写大量函数式代码，堆栈跟踪通常会非常大。出于明显的性能原因，浏览器设置了限制。因此，如果您真的遇到困难，一些浏览器(如Chromium)允许您通过这个全局api增加堆栈跟踪限制:</p><pre class="ko kp kq kr gt na lc nb nc aw nd bi"><span id="3009" class="ne ly iq lc b gy nf ng l nh ni">Error.stackTraceLimit = number</span></pre><p id="553b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，这个api不是为生产环境设计的。</p><h1 id="5d51" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">包装命名函数</h1><p id="bc95" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">在意外错误的堆栈跟踪中知道函数名的好处显而易见。最好的情况是，如果您熟悉函数名，您可能会立即猜到给定特定的错误消息会发生什么。</p><p id="a742" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您正在使用一些高级的错误日志记录工具，那么Stacktraces本身也很有用。也许您想通过特定的函数名来分组或搜索特定的错误。这可能显示出其他的见解，如发生时间的相关性。</p><p id="e913" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以将命名函数添加到无指针样式函数的堆栈跟踪中，只需将它包装在一个:</p><pre class="ko kp kq kr gt na lc nb nc aw nd bi"><span id="5e07" class="ne ly iq lc b gy nf ng l nh ni">function namedMessagesDisplayText(response) {<br/>  <em class="km">// the point-free style function</em><br/>  return messagesDisplayText(response)<br/>}</span></pre><p id="ea05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在检查调用堆栈，您应该看到函数名<code class="fe kz la lb lc b">namedMessagesDisplayText</code>:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/76e86ff2a28caeb2c22c94a5bd2b2e3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/0*G0SmZB3bEXakSBV4.png"/></div></figure><p id="b32c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑到这一点，您可以通过保留纯粹的<code class="fe kz la lb lc b">point-free</code>样式来避免多余的函数，并改为编写以下代码:</p><pre class="ko kp kq kr gt na lc nb nc aw nd bi"><span id="dc45" class="ne ly iq lc b gy nf ng l nh ni">function messagesDisplayText (response) {<br/>  return R.pipe(<br/>    R.prop('messages'),<br/>    R.map(userDisplayText),<br/>    R.join(', ')<br/>  )(response)<br/>}</span></pre><h1 id="6722" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">日志助手</h1><p id="e1f7" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">它不会帮助您改进堆栈跟踪，但在理解错误或跟踪函数式控制流中的数据方面，它是一个非常有价值的工具。</p><p id="284d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要点是简单地创建可以插入到作品中的日志记录函数:</p><pre class="ko kp kq kr gt na lc nb nc aw nd bi"><span id="c0a0" class="ne ly iq lc b gy nf ng l nh ni">const traceUser = (data) =&gt; {<br/>  console.log('the user', data)<br/>  return data<br/>}</span><span id="971b" class="ne ly iq lc b gy nj ng l nh ni">const userLabelText = R.pipe(<br/>  R.prop(['user']),<br/>  traceUser, <em class="km">// &lt;-- just another part of the pipe :)</em><br/>  R.props(['name', 'species']),<br/>  R.intersperse('is a'),<br/>  R.join(' ')<br/>)</span></pre><p id="849c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在您的控制台或日志记录实用程序中，您可以看到发生了什么:</p><pre class="ko kp kq kr gt na lc nb nc aw nd bi"><span id="fae9" class="ne ly iq lc b gy nf ng l nh ni">// the user {role: "The first ones", name: "Kosh", species: "Vorlon"}<br/>// main.tsx:26 the user null</span></pre><h1 id="309c" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">断点</h1><p id="73dd" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">如果你想在功能组合中使用一个断点，在这个例子中，我认为与命令式代码相比，它不那么直接。</p><p id="fbe6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你试图在一根管子的一条线上放一个断点或者作曲，那是行不通的。或者，如果您试图“步入”一个函数模式，如本质上封装了一个<code class="fe kz la lb lc b">if/else, if/else</code>的<a class="ae kl" href="http://ramdajs.com/docs/#cond" rel="noopener ugc nofollow" target="_blank"> R.cond </a>，您将不得不逐句通过库代码，从而增加调用堆栈的大小。如果它只是一个<code class="fe kz la lb lc b">if {} else ..</code>或者一个<code class="fe kz la lb lc b">switch</code>语句，调试器将只会单步调试你的代码。</p><p id="1b80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，如上所示，devtools中的黑盒可以通过自动告诉调试器跳过黑盒行来帮助避免这种情况。</p><p id="9f9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，为了在合成中更加精确，您总是可以使用<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger" rel="noopener ugc nofollow" target="_blank">调试器</a>语句。因此，扩展日志记录函数的概念，只需将它添加到一个助手函数中:</p><pre class="ko kp kq kr gt na lc nb nc aw nd bi"><span id="275e" class="ne ly iq lc b gy nf ng l nh ni">const debug = item =&gt; {<br/>  debugger <em class="km">// &lt;-- break here</em><br/>  return item<br/>}</span><span id="7651" class="ne ly iq lc b gy nj ng l nh ni">const userLabelText = R.pipe(<br/>  R.prop(['user']),<br/>  debug, <em class="km">// &lt;-- put this wherever in the pipe you need to</em><br/>  R.props(['name', 'species']),<br/>  R.intersperse('is a'),<br/>  R.join(' ')<br/>)</span></pre><p id="6672" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我发现这在学习API和用函数式风格思考时特别有用。</p><p id="0dde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你以前没用过，<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger" rel="noopener ugc nofollow" target="_blank">调试器语句</a>指示devtools中断。只有在打开并连接了devtools窗口的情况下，才会发生这种情况。使用它的最大好处是，不需要手动找到该行并手动将其插入断点。像热重装这样的事情，通常你只需要点击键盘上的save，然后等待一个devtools窗口，把焦点放在你想要的地方。</p><p id="8235" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为这就像代码中的任何其他语句一样，所以您也可以将其包装在任何表达式中，以获得条件断点:</p><pre class="ko kp kq kr gt na lc nb nc aw nd bi"><span id="ee5e" class="ne ly iq lc b gy nf ng l nh ni">const debug = item =&gt; {<br/>  if (item === null) debugger<br/>  return item<br/>}</span></pre><h1 id="4ef4" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">猴子补丁</h1><p id="3a63" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">一种仅用于开发的有趣方法是包装一个高阶函数，通过抛出和捕获错误来捕获上下文，如函数名和自定义堆栈跟踪。<code class="fe kz la lb lc b">@jacobp100</code>有一个使用Ramda pipe 的<a class="ae kl" href="https://medium.com/@jacobp100/debugging-functional-libraries-in-javascript-f586cdf8ea4" rel="noopener">很酷的例子，值得一试。我想这个想法在其他创造性的方面也是有用的。</a></p><h1 id="2420" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">运行时类型系统</h1><p id="cdf6" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">为了提供一些更有用的错误消息，来自运行时的额外上下文会有所帮助。<a class="ae kl" href="https://github.com/sanctuary-js/sanctuary#type-checking" rel="noopener ugc nofollow" target="_blank">避难所</a>允许消息和文档就位。它们类似于<a class="ae kl" href="https://github.com/power-assert-js/power-assert" rel="noopener ugc nofollow" target="_blank">功率断言，如</a>错误消息:</p><pre class="ko kp kq kr gt na lc nb nc aw nd bi"><span id="82f3" class="ne ly iq lc b gy nf ng l nh ni">S.add(2, true);<br/>// ! TypeError: Invalid value<br/>//<br/>//   add :: FiniteNumber -&gt; FiniteNumber -&gt; FiniteNumber<br/>//                          ^^^^^^^^^^^^<br/>//                               1<br/>//<br/>//   1)  true :: Boolean<br/>//<br/>//   The value at position 1 is not a member of ‘FiniteNumber’.<br/>//<br/>//   See https://github.com/sanctuary-js/sanctuary-def/tree/v0.14.0#FiniteNumber for information about the sanctuary-def/FiniteNumber type.</span></pre><h1 id="6065" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">编译时类型检查</h1><p id="f10a" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">对于在编译时或在ide中捕捉错误的函数式风格来说，Typescript 有很大的好处。Typescript不能真正帮助您处理运行时错误。</p><p id="37a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应该说，错误键入的代码会导致引入只在运行时出现的错误。例如，如果您将某些内容强制转换为<code class="fe kz la lb lc b">any</code>，这将告诉Typescript忽略该类型。现在，如果你通过<code class="fe kz la lb lc b">any</code>传递一些无效的东西，你只会在运行时看到一个错误。请记住，盲目信任复杂类型或者将函数参数保留为<code class="fe kz la lb lc b">any</code>会导致错误的安全感和运行时错误。</p><p id="3010" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在一些场景中，我发现严格地键入每件事可能会很麻烦，而且回报很少。例如，考虑从Ramda <a class="ae kl" href="https://github.com/types/npm-ramda" rel="noopener ugc nofollow" target="_blank"> @types/ramda </a>定义中用<a class="ae kl" href="https://www.typescriptlang.org/docs/handbook/generics.html" rel="noopener ugc nofollow" target="_blank">泛型</a>严格键入一个大的<a class="ae kl" href="http://ramdajs.com/docs/#pipe" rel="noopener ugc nofollow" target="_blank">管道</a>或<a class="ae kl" href="http://ramdajs.com/docs/#compose" rel="noopener ugc nofollow" target="_blank">组合</a>。</p><p id="75de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于相当大的管道，考虑严格遵守以下接口:</p><pre class="ko kp kq kr gt na lc nb nc aw nd bi"><span id="5440" class="ne ly iq lc b gy nf ng l nh ni">pipe&lt;V0, T1, T2, T3, T4, T5, T6, T7, T8, T9&gt;(<br/>    fn0: (x0: V0) =&gt; T1,<br/>    fn1: (x: T1) =&gt; T2,<br/>    fn2: (x: T2) =&gt; T3,<br/>    fn3: (x: T3) =&gt; T4,<br/>    fn4: (x: T4) =&gt; T5,<br/>    fn5: (x: T5) =&gt; T6,<br/>    fn6: (x: T6) =&gt; T7,<br/>    fn7: (x: T7) =&gt; T8,<br/>    fn8: (x: T8) =&gt; T9): (x0: V0) =&gt; T9;</span></pre><p id="aba8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个较小的例子，没有换行符:</p><pre class="ko kp kq kr gt na lc nb nc aw nd bi"><span id="c5fa" class="ne ly iq lc b gy nf ng l nh ni">compose&lt;V0, T1, T2, T3, T4, T5, T6&gt;(fn5: (x: T5) =&gt; T6, fn4: (x: T4) =&gt; T5, fn3: (x: T3) =&gt; T4, fn2: (x: T2) =&gt; T3, fn1: (x: T1) =&gt; T2, fn0: (x: V0) =&gt; T1): (x: V0) =&gt; T6</span></pre><p id="7242" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我认为这很容易让用户出错和沮丧。您的类型的名称很可能超过两个字符，因此您可能需要打开文本换行。我发现编写泛型比编写组合本身要花更长的时间。</p><p id="d847" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与其键入整个compose，我建议更重要的是将它包装在一个命名函数中，严格键入所有的输入和输出，并添加合理数量的测试覆盖。</p><p id="5026" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不过，不要让这吓到你。我可能在挑最坏的情况。实际上，它非常好用，在你需要重构代码的时候非常有价值。</p><h1 id="98f9" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">最后的想法</h1><p id="6b4e" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">虽然错误堆栈跟踪可能不总是理解错误的唯一方式，也不是最有帮助的方式，但它们在开发、qa和生产中仍然是有用的。我认为，为运行在跨平台和多厂商web浏览器中的Javascript做好处理错误的准备是必须的。考虑到其他外部因素，如冲突的浏览器扩展、本地网络拓扑和连接性，很难不将其描述为一个不稳定的环境。</p><p id="7c03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑到这一点，现在有一个完整的工具行业可以提供一些强大的方法来捕获错误、用户痕迹和发生时的错误堆栈跟踪。如果你不使用任何东西，一个很好的解决方案是<a class="ae kl" href="https://github.com/getsentry/sentry" rel="noopener ugc nofollow" target="_blank"> sentry </a>，它也是BSD3许可的。</p><p id="7211" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">函数式编程风格不是万能的，尤其是当你在浏览器和Javascript中使用它的时候。如果您在一个大型复杂的代码库中编写大量的功能代码。我的建议是不要一开始就使用完全没有点的风格。相反，要确保在主要业务逻辑和公共API上健康地使用命名函数。也要考虑用<a class="ae kl" href="http://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> Typescript </a>或<a class="ae kl" href="https://flow.org/" rel="noopener ugc nofollow" target="_blank"> Flow </a>正确地输入那些函数，这样更容易维护和重构。</p><p id="8702" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我找不到太多关于这类事情的其他文章。所以我鼓励其他人。除非你建议人们购买支持纵向模式的显示器支架。这样，所有的调用栈都可以适合视图；)</p><p id="5f8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想归功于一本关于函数式编程的极好的书<a class="ae kl" href="https://mostly-adequate.gitbooks.io/mostly-adequate-guide/ch05.html#debugging" rel="noopener ugc nofollow" target="_blank">非常合适的指南</a>，日志技术也在调试部分提到。</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="00c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">交叉发布自:<a class="ae kl" href="https://christopherdecoster.com/posts/debugging-fp-js/" rel="noopener ugc nofollow" target="_blank">https://christopherdecoster.com/posts/debugging-fp-js/</a></p></div></div>    
</body>
</html>