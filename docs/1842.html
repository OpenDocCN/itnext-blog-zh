<html>
<head>
<title>Manage React state without redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">管理无冗余的反应状态</h1>
<blockquote>原文：<a href="https://itnext.io/manage-react-state-without-redux-a1d03403d360?source=collection_archive---------0-----------------------#2019-02-10">https://itnext.io/manage-react-state-without-redux-a1d03403d360?source=collection_archive---------0-----------------------#2019-02-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fa98" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何更容易更漂亮地使用React Context API？</h2></div><p id="558b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">免责声明</em>:我在制作中使用<em class="lb"> Redux </em>和<em class="lb"> React </em>，我对此相当满意。</p><h2 id="4806" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">TL；DR；</h2><p id="5a36" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">你真差劲！你只是想要代码，但是如果你很着急，下载<a class="ae ma" href="https://github.com/Spyna/react-store" rel="noopener ugc nofollow" target="_blank"> repo </a>或者在你的项目中安装<a class="ae ma" href="https://www.npmjs.com/package/@spyna/react-store" rel="noopener ugc nofollow" target="_blank"> npm库</a>。</p><p id="8154" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到本文结束时，您将学会如何以一种快速简单的方式在React应用程序的一个组件和另一个组件之间读取、写入和删除数据。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mb"><img src="../Images/106557e75f4a0a4c199dd2e5e531be17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*c6sWuadNJ10W2w4X"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">如果你的应用程序存储像这样混乱，请继续阅读。每篇文章都有一张照片，所以我需要用<a class="ae ma" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> chuttersnap </a>在<a class="ae ma" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上添加这张照片</figcaption></figure><blockquote class="mr ms mt"><p id="61b4" class="kf kg lb kh b ki kj jr kk kl km ju kn mu kp kq kr mv kt ku kv mw kx ky kz la ij bi translated">编辑2019年11月</p><p id="82ac" class="kf kg lb kh b ki kj jr kk kl km ju kn mu kp kq kr mv kt ku kv mw kx ky kz la ij bi translated">我用React Hooks发布了这个故事的一个版本，它更加现代和更新。请点击此链接阅读:</p></blockquote><div class="mx my gp gr mz na"><a href="https://medium.com/swlh/react-global-state-with-hooks-f163e49f90f9" rel="noopener follow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd ir gy z fp nf fr fs ng fu fw ip bi translated">用钩子和上下文反应全局状态</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">使用钩子和上下文API管理React应用程序全局状态的解决方案。</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">medium.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no ml na"/></div></div></a></div></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="8d4f" class="nw ld iq bd le nx ny nz lh oa ob oc lk jw od jx ln jz oe ka lq kc of kd lt og bi translated">介绍</h1><p id="6e16" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">几周前我用React启动了一个项目，我不想用Redux，因为这个项目很小。如果你想知道我不想使用redux的原因，让我们看看它的架构和流程。</p><h2 id="b2f1" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">Redux</h2><p id="0dbb" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">如果你熟悉redux，就跳过这一节，那个a对你来说可能听起来有点枯燥。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/c829684c902c5cb1188f37a1049828b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*gwiKZyQ81T7wfBcdGVjRgg.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">冗余组件</figcaption></figure><p id="37e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在redux中，您必须设置和维护:</p><ul class=""><li id="d33b" class="oi oj iq kh b ki kj kl km ko ok ks ol kw om la on oo op oq bi translated"><a class="ae ma" href="https://github.com/reduxjs/react-redux/blob/master/docs/api/Provider.md#overview" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">提供者</strong></a>:<code class="fe or os ot ou b">&lt;Provider /&gt;</code>使Redux <code class="fe or os ot ou b">store</code>对任何已经被包装在<code class="fe or os ot ou b">connect()</code>函数中的嵌套组件可用。</li><li id="c3a7" class="oi oj iq kh b ki ov kl ow ko ox ks oy kw oz la on oo op oq bi translated"><a class="ae ma" href="https://github.com/reduxjs/react-redux/blob/master/docs/api/connect.md#overview" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">连接</strong> </a>:函数<code class="fe or os ot ou b">connect()</code>将一个React组件连接到一个Redux存储。</li><li id="a3a5" class="oi oj iq kh b ki ov kl ow ko ox ks oy kw oz la on oo op oq bi translated"><a class="ae ma" href="https://redux.js.org/advanced/middleware#middleware" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">中间件</strong> </a>:中间件提供了一个第三方的扩展点，从调度一个动作，到它到达reducer的时刻。</li><li id="3c79" class="oi oj iq kh b ki ov kl ow ko ox ks oy kw oz la on oo op oq bi translated"><a class="ae ma" href="https://redux.js.org/basics/actions#actions" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">动作</strong> </a> <strong class="kh ir"> : </strong>动作是将数据从应用程序发送到商店的有效信息负载。他们是商店唯一的信息来源。您使用<code class="fe or os ot ou b"><a class="ae ma" href="https://redux.js.org/api/store#dispatch" rel="noopener ugc nofollow" target="_blank">store.dispatch()</a></code>将它们发送到商店。</li><li id="2a70" class="oi oj iq kh b ki ov kl ow ko ox ks oy kw oz la on oo op oq bi translated"><a class="ae ma" href="https://redux.js.org/basics/reducers#reducers" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir">reducer</strong></a>:reducer指定应用程序的状态如何变化，以响应<a class="ae ma" href="https://redux.js.org/basics/actions" rel="noopener ugc nofollow" target="_blank">发送到商店的</a>动作。记住动作只描述了发生了什么，而没有描述应用程序的状态是如何变化的。</li></ul><p id="7c2f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更不用说你还得用<code class="fe or os ot ou b"><a class="ae ma" href="https://redux.js.org/api/createstore#createstorereducer-preloadedstate-enhancer" rel="noopener ugc nofollow" target="_blank">createStore</a></code>创建redux Store，用<code class="fe or os ot ou b"><a class="ae ma" href="https://redux.js.org/api/combinereducers#combinereducersreducers" rel="noopener ugc nofollow" target="_blank">combineReducers</a></code>、<code class="fe or os ot ou b">applyMiddlewares</code>串联redux，比如<em class="lb"> redux-thunk。</em>然后你必须<code class="fe or os ot ou b">connect</code>你的<em class="lb">组件</em>与状态和动作，使用<code class="fe or os ot ou b">mapStateToProps</code>、<code class="fe or os ot ou b">mapActionsToProps</code>，有时使用<code class="fe or os ot ou b">mapDispatchToProps</code>。</p><p id="ce71" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着，如果你决定在周二早上在你的项目中使用redux，你将会花一上午的时间来设置它。如果您已经在另一个项目中使用了redux，也许您可以节省一些复制/粘贴代码的时间，并在几个小时内开始工作。</p><p id="2194" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，您必须决定哪个是放置业务逻辑的最佳位置:组件？行动？减速器？中间件？</p><p id="7052" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">三个月后，当你发现应用程序中的一个bug并重新打开代码库时，你必须记住那个缩减器做了什么，以及为什么状态没有像预期的那样改变。</p><p id="0708" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这不是吓唬你，只是我的经验😃。</p><h1 id="466f" class="nw ld iq bd le nx pa nz lh oa pb oc lk jw pc jx ln jz pd ka lq kc pe kd lt og bi translated">我们想做什么</h1><p id="ef89" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">本文的目标是找到一种方法来降低(双关语)我们的应用程序的复杂性。下图是我们想要实现的最终架构的剧透。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/8337619f945e66cc90a4df82a5891684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*i-BeBX6LiIADuwWmwRMTvQ.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">一种更简洁的管理应用状态的方式</figcaption></figure></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h2 id="4b0f" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">回到介绍</h2><p id="33f5" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">经过以上考虑，我想到了使用<a class="ae ma" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> <em class="lb"> React上下文API </em> </a>的决定。</p><blockquote class="mr ms mt"><p id="8db2" class="kf kg lb kh b ki kj jr kk kl km ju kn mu kp kq kr mv kt ku kv mw kx ky kz la ij bi translated">上下文提供了一种通过组件树传递数据的方式，而不必在每一层手动向下传递属性。</p></blockquote><p id="38e9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它实现了共享一个全局<em class="lb">状态</em>(或<em class="lb">存储</em>)或任何你想叫它的东西的目标，但是我发现它非常冗长，并且不容易使用。</p><p id="ad2f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文的目标是使<em class="lb">全局应用</em> <em class="lb">状态</em>管理易于使用(对于开发者而言)。您将在一个<em class="lb">组件</em>中使用<code class="fe or os ot ou b">store.set(’a_key’, 'a value’)</code>访问全局存储，并在另一个<em class="lb">组件</em>中使用<code class="fe or os ot ou b">store.get(’a_key’)</code>读取该值。</p><p id="dbe4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">换句话说，我们将创建一个全局<em class="lb">键/值映射</em>来存储数据，当它的值改变时，它将重新呈现您的<em class="lb">组件</em>。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="8028" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先要做的是创建一个<code class="fe or os ot ou b">Context</code>、<code class="fe or os ot ou b">Context.Provider</code>和一个<code class="fe or os ot ou b">Context.Consumer</code>。代码是:</p><pre class="mc md me mf gt pf ou pg ph aw pi bi"><span id="d818" class="lc ld iq ou b gy pj pk l pl pm">import React, { Component } from 'react'</span><span id="d043" class="lc ld iq ou b gy pn pk l pl pm">const <strong class="ou ir">StoreContext = React.createContext()</strong></span><span id="a841" class="lc ld iq ou b gy pn pk l pl pm">class MyComponent extends Component {<br/> <strong class="ou ir"> static contextType = StoreContext<br/>  </strong>//this line does the magic, binding this.context to the value of the Provider</span><span id="25bd" class="lc ld iq ou b gy pn pk l pl pm">   render() {<br/>    return &lt;div&gt;Hello {this.context.name}&lt;/div&gt;<br/>  }<br/>}</span><span id="2d46" class="lc ld iq ou b gy pn pk l pl pm">const MyApp = props =&gt; (<br/>  &lt;div&gt;<br/>    &lt;MyComponent /&gt;<br/>  &lt;/div&gt;<br/>)</span><span id="afc6" class="lc ld iq ou b gy pn pk l pl pm">class <strong class="ou ir">AppWithContext</strong> extends Component {<br/>  state = { name: 'Spyna' }</span><span id="9edd" class="lc ld iq ou b gy pn pk l pl pm">  render() {<br/>    return (<br/>      <strong class="ou ir">&lt;StoreContext.Provider</strong> <strong class="ou ir"><em class="lb">value</em></strong>={<strong class="ou ir">this.state</strong>}&gt;<br/>        &lt;MyApp /&gt;<br/>      &lt;/StoreContext.Provider&gt;<br/>    )<br/>  }<br/>}</span><span id="78fd" class="lc ld iq ou b gy pn pk l pl pm">export default AppWithContext</span></pre><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="po pp l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">CodeSandbox上的工作代码</figcaption></figure><p id="96f7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这段代码中，您创建了一个React <code class="fe or os ot ou b">Context</code>，然后将<em class="lb"> MyApp组件</em>包装到上下文<code class="fe or os ot ou b">Provider</code>中，最后，您使用 <code class="fe or os ot ou b">static contextType = StoreContext</code>将<em class="lb"> MyComponent </em> <a class="ae ma" href="https://reactjs.org/docs/context.html#classcontexttype" rel="noopener ugc nofollow" target="_blank">与上下文绑定。</a></p><p id="329d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我们将<code class="fe or os ot ou b">StoreContext.Provider</code>的<em class="lb">值</em>属性设置为<code class="fe or os ot ou b">this.state</code>(即<code class="fe or os ot ou b">AppWithContext</code>的状态)，当该状态发生变化时，<code class="fe or os ot ou b">AppWithContext</code>会更新，导致其子节点的重新渲染。</p><p id="15a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了实现这些变化，您需要一些上下文(没有双关语)方法来:<em class="lb">状态</em>中的<code class="fe or os ot ou b">set</code>、<code class="fe or os ot ou b">get</code>和<code class="fe or os ot ou b">remove</code>数据。我们使用了<em class="lb">AppWithContext</em>T15】作为提供者值，所以我们要给它添加这些方法，这翻译成代码的意思是:</p><pre class="mc md me mf gt pf ou pg ph aw pi bi"><span id="4d71" class="lc ld iq ou b gy pj pk l pl pm">class AppWithContext extends Component {<br/>  state = {<br/>    <strong class="ou ir">get</strong>: (key) =&gt; {<br/>      return this.state[key]<br/>    },<br/>    <strong class="ou ir">set</strong>: (key, value) =&gt; {<br/>      const state = this.state<br/>      state[key] = value<br/>      this.setState(state)<br/>    },<br/>    <strong class="ou ir">remove</strong>: key =&gt; {<br/>      const state = this.state<br/>      delete state[key]<br/>      this.setState(state)<br/>    }<br/>  }</span><span id="8a03" class="lc ld iq ou b gy pn pk l pl pm">...</span><span id="7bd0" class="lc ld iq ou b gy pn pk l pl pm">}</span></pre><p id="408d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">提供者<em class="lb">值</em>是<code class="fe or os ot ou b">this.state</code>，所以我们在那里添加了我们的方法<em class="lb">。</em>您肯定注意到属性<code class="fe or os ot ou b">name</code>不再存在于<em class="lb"> AppWithContext </em> <code class="fe or os ot ou b">state</code>中，我们需要使用我们刚刚创建并添加到<em class="lb">状态</em>中的新鲜、新且精彩的方法来添加它。为了测试这是否有效，我们将使用<code class="fe or os ot ou b">set</code>方法在<em class="lb"> MyComponent </em>中设置<code class="fe or os ot ou b">name</code>属性，并使用<code class="fe or os ot ou b">get</code>在render方法中读取它。</p><pre class="mc md me mf gt pf ou pg ph aw pi bi"><span id="0a9f" class="lc ld iq ou b gy pj pk l pl pm">class MyComponent extends Component {<br/>  static contextType = StoreContext<br/>  componentDidMount() {<br/>    let context = this.context<br/>    <strong class="ou ir">context.set('name', 'Spyna')<br/>    </strong>//sets the property 'name' with the value 'Spyna'<br/>  }<br/>  <br/>  render() {<br/>    return &lt;div&gt;Hello {<strong class="ou ir">this.context.get('name')</strong>}&lt;/div&gt;<br/>    //reads the property 'name' from the context<br/>  }<br/>}</span></pre><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="po pp l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">CodeSandbox上的工作代码</figcaption></figure><p id="e688" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是的，有效！</p><p id="57c6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<em class="lb">组件</em><em class="lb">【did mount】</em>时，我们调用<code class="fe or os ot ou b">context.set(’name’, ‘Spyna’)</code>来设置<em class="lb">上下文</em>中的属性<em class="lb">name】</em>。由于<em class="lb">上下文</em>被修改，所以<em class="lb">组件</em>更新，并且当<em class="lb">渲染</em>方法被调用时，打印<em class="lb">【name】</em>的值。如果你运行这段代码，你会在屏幕上看到“<em class="lb">Hello Spyna”</em>。</p><p id="8e5c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这段代码看起来不像我喜欢的那样漂亮。我们想做的是让它更具有声明性，更易于使用。为了实现这个目标，我们将创建两个<em class="lb">高阶组件</em>:一个用于<em class="lb">上下文</em> <code class="fe or os ot ou b"><em class="lb">Provider</em></code>，另一个用于<em class="lb">上下文</em> <code class="fe or os ot ou b">Consumer</code>。</p><p id="88c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据React文档，一个<a class="ae ma" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank"> <em class="lb">高阶组件</em> </a>是:</p><blockquote class="mr ms mt"><p id="a92f" class="kf kg lb kh b ki kj jr kk kl km ju kn mu kp kq kr mv kt ku kv mw kx ky kz la ij bi translated">高阶组件(HOC)是React中重用组件逻辑的一种高级技术。本质上，hoc不是React API的一部分。它们是从React的组合性质中出现的一种模式。</p><p id="b48b" class="kf kg lb kh b ki kj jr kk kl km ju kn mu kp kq kr mv kt ku kv mw kx ky kz la ij bi translated">具体地说，<strong class="kh ir">高阶分量是取一个分量并返回一个新分量的函数。</strong></p><p id="3e77" class="kf kg lb kh b ki kj jr kk kl km ju kn mu kp kq kr mv kt ku kv mw kx ky kz la ij bi translated"><code class="fe or os ot ou b"><em class="iq">const EnhancedComponent = higherOrderComponent(WrappedComponent);</em></code></p></blockquote><p id="7ffc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想了解更多关于HOC的信息，请看这里。</p><h2 id="e5f6" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">商店提供者特设</h2><pre class="mc md me mf gt pf ou pg ph aw pi bi"><span id="0d1f" class="lc ld iq ou b gy pj pk l pl pm">const createStore = WrappedComponent =&gt; {<br/>  return class extends React.Component {<br/>    state = {<br/>      get: key =&gt; {<br/>        return this.state[key]<br/>      },<br/>      set: (key, value) =&gt; {<br/>        const state = this.state<br/>        state[key] = value<br/>        this.setState(state)<br/>      },<br/>      remove: key =&gt; {<br/>        const state = this.state<br/>        delete state[key]<br/>        this.setState(state)<br/>      }<br/>    }<br/>    render() {<br/>      return (<br/>        <strong class="ou ir">&lt;StoreContext.Provider value={this.state}&gt;</strong><br/>          &lt;WrappedComponent {...this.props} /&gt;<br/>        &lt;/StoreContext.Provider&gt;<br/>      )<br/>    }<br/>  }<br/>}</span></pre><p id="5990" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果这段代码对你来说看起来很奇怪，看看没有箭头功能的版本<code class="fe or os ot ou b">=&gt;</code>:<a class="ae ma" href="https://codesandbox.io/s/l21x87543z?autoresize=1&amp;hidenavigation=1&amp;module=%2Fsrc%2Fstore.js" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/l21x87543z?autoresize=1&amp;hide navigation = 1&amp;module = % 2 fsrc % 2f store . js</a></p><p id="1bdf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">函数</em> <code class="fe or os ot ou b">createStore</code>返回一个组件，<em class="lb">呈现</em>在<em class="lb">上下文</em> <strong class="kh ir"> <em class="lb">提供者</em> </strong>中作为<em class="lb">参数</em>传递的任何组件。</p><p id="1c05" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用这个特设，你所要做的只是:</p><pre class="mc md me mf gt pf ou pg ph aw pi bi"><span id="d297" class="lc ld iq ou b gy pj pk l pl pm">export default createStore(MyApp);</span></pre><h2 id="26c4" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">商店消费者特设</h2><pre class="mc md me mf gt pf ou pg ph aw pi bi"><span id="9c55" class="lc ld iq ou b gy pj pk l pl pm">const withStore = WrappedComponent =&gt; {<br/>  return class extends React.Component {<br/>    render() {<br/>      return (<br/>        <strong class="ou ir">&lt;StoreContext.Consumer&gt;</strong><br/>          {context =&gt; &lt;WrappedComponent <strong class="ou ir">store</strong>={context} {...this.props} /&gt;}<br/>        &lt;StoreContext.Consumer&gt;<br/>      )<br/>    }<br/>  }<br/>}</span></pre><p id="ff86" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">函数</em> <code class="fe or os ot ou b">withStore</code>返回一个组件，<em class="lb">呈现</em>您在<em class="lb">上下文</em> <strong class="kh ir"> <em class="lb">消费者</em> </strong>中作为参数传递的任何组件。另外，它将一个名为<code class="fe or os ot ou b">store</code>的道具注入到你的组件中，这就是<em class="lb">上下文</em>值。</p><p id="90a3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您可以访问上下文，执行以下操作:</p><pre class="mc md me mf gt pf ou pg ph aw pi bi"><span id="d083" class="lc ld iq ou b gy pj pk l pl pm">const MyComponent = (props) =&gt; &lt;div&gt;{props.store.get('data')}&lt;/div&gt;</span><span id="0b15" class="lc ld iq ou b gy pn pk l pl pm">export default withStore(MyComponent)</span></pre><h2 id="1bf0" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">把所有的放在一起</h2><p id="ee55" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">让我们创建一个名为<code class="fe or os ot ou b">store.js</code>的文件，添加两个HOC并导出它们。</p><pre class="mc md me mf gt pf ou pg ph aw pi bi"><span id="baab" class="lc ld iq ou b gy pj pk l pl pm">import React from 'react'</span><span id="474f" class="lc ld iq ou b gy pn pk l pl pm">const StoreContext = React.createContext()</span><span id="9474" class="lc ld iq ou b gy pn pk l pl pm">const <strong class="ou ir">createStore</strong> = WrappedComponent =&gt; {<br/>  return class extends React.Component {<br/>    state = {<br/>      get: key =&gt; {<br/>        return this.state[key]<br/>      },<br/>      set: (key, value) =&gt; {<br/>        const state = this.state<br/>        state[key] = value<br/>        this.setState(state)<br/>      },<br/>      remove: key =&gt; {<br/>        const state = this.state<br/>        delete state[key]<br/>        this.setState(state)<br/>      }<br/>    }<br/>    render() {<br/>      return (<br/>        &lt;StoreContext.Provider value={this.state}&gt;<br/>          &lt;WrappedComponent {...this.props} /&gt;<br/>        &lt;/StoreContext.Provider&gt;<br/>      )<br/>    }<br/>  }<br/>}</span><span id="f08b" class="lc ld iq ou b gy pn pk l pl pm">const <strong class="ou ir">withStore</strong> = WrappedComponent =&gt; {<br/>  return class extends React.Component {<br/>    render() {<br/>      return (<br/>        &lt;StoreContext.Consumer&gt;<br/>          {context =&gt; &lt;WrappedComponent store={context} {...this.props} /&gt;}<br/>        &lt;/StoreContext.Consumer&gt;<br/>      )<br/>    }<br/>  }<br/>}</span><span id="fdd9" class="lc ld iq ou b gy pn pk l pl pm">export { <strong class="ou ir">createStore, withStore</strong> }</span></pre><p id="099f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，用下面的代码使用HOCs，它看起来比开始时漂亮多了:</p><pre class="mc md me mf gt pf ou pg ph aw pi bi"><span id="f204" class="lc ld iq ou b gy pj pk l pl pm">// MyComponent.js<br/>import React, { Component } from 'react'<br/>import { <strong class="ou ir">withStore</strong>} from './store';</span><span id="520a" class="lc ld iq ou b gy pn pk l pl pm">class MyComponent extends Component {<br/>  componentDidMount() {<br/>    this.props.store.set('name', 'Spyna')<br/>  }</span><span id="c342" class="lc ld iq ou b gy pn pk l pl pm">render() {<br/>    return &lt;div&gt;Hello {this.props.store.name}&lt;/div&gt;<br/>  }<br/>}</span><span id="4b27" class="lc ld iq ou b gy pn pk l pl pm">export default <strong class="ou ir">withStore</strong>(MyComponent)</span><span id="dc3e" class="lc ld iq ou b gy pn pk l pl pm">// App.js<br/>import React, { Component } from 'react'<br/>import { <strong class="ou ir">createStore</strong>} from './store'<br/>import MyComponent from './MyComponent'<br/>//import MyOtherWithStoreComponent from './MyOtherComponent'</span><span id="da82" class="lc ld iq ou b gy pn pk l pl pm">const MyApp = props =&gt; (<br/>  &lt;div&gt;<br/>    &lt;MyComponent /&gt;<br/>    {/*&lt;MyOtherWithStoreComponent /&gt;*/}<br/>  &lt;/div&gt;<br/>)</span><span id="d412" class="lc ld iq ou b gy pn pk l pl pm">export default <strong class="ou ir">createStore</strong>(MyApp)</span></pre><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="po pp l"/></div></figure><h2 id="dac6" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">考虑</h2><p id="92a6" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">你所做的只是管理你的应用程序状态之旅的开始。你可能想给你已经创建的<code class="fe or os ot ou b">store</code>添加一些特性。例如，您想要:</p><ul class=""><li id="14e7" class="oi oj iq kh b ki kj kl km ko ok ks ol kw om la on oo op oq bi translated">设置一个<strong class="kh ir">初始值</strong>，可能是从本地存储器读取，也可能是从API: <code class="fe or os ot ou b">createStore(MyApp, initialValue)</code>读取。</li><li id="6bd0" class="oi oj iq kh b ki ov kl ow ko ox ks oy kw oz la on oo op oq bi translated">如果存储中没有数据，则获取一个<strong class="kh ir">默认值</strong>:<code class="fe or os ot ou b">store.get('my_key', defaultValue)</code>。</li><li id="f138" class="oi oj iq kh b ki ov kl ow ko ox ks oy kw oz la on oo op oq bi translated">为存储方法提供<strong class="kh ir">不变性</strong>，以避免由于错误造成任何损害，例如，如果调用<code class="fe or os ot ou b">store.get = () =&gt; 'hey I just broke everything'</code>就会破坏<code class="fe or os ot ou b">get</code>方法。</li><li id="f6d0" class="oi oj iq kh b ki ov kl ow ko ox ks oy kw oz la on oo op oq bi translated"><strong class="kh ir">将</strong>存储方法从它的值中分离出来:现在你可以通过<code class="fe or os ot ou b">store.get(’my_key’)</code>或<code class="fe or os ot ou b">store.my_key</code>从存储中访问一个值。这一点也不差，也许你想让这个行为可配置。</li><li id="5419" class="oi oj iq kh b ki ov kl ow ko ox ks oy kw oz la on oo op oq bi translated">make store方法返回一个<strong class="kh ir">承诺</strong>以便您可以使用:<code class="fe or os ot ou b">store.remove(’my_key’).then(() =&gt;{ doSomething() })</code>。</li></ul><p id="55ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有这些想法都很棒，你可能认为实现它们需要很多时间，这就是为什么我创建了项目<a class="ae ma" href="https://www.npmjs.com/package/@spyna/react-store" rel="noopener ugc nofollow" target="_blank"><em class="lb">react-store</em></a><em class="lb"/>它已经为你做了所有这些事情。<em class="lb"> </em>代码库很小，如果想复制，可以看看下面链接的回购。</p><div class="mx my gp gr mz na"><a href="https://github.com/Spyna/react-store" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd ir gy z fp nf fr fs ng fu fw ip bi translated">Spyna/react-store</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">轻松管理React应用的状态。通过在…上创建帐户，为Spyna/react-store的发展做出贡献</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">github.com</p></div></div><div class="nj l"><div class="pq l nl nm nn nj no ml na"/></div></div></a></div><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="0c41" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我在开始时所说的，我是Redux的粉丝，并且认为它非常有用，尤其是在处理大项目的时候。但是，我觉得在小项目里设置有点矫枉过正，不舒服。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="7b7c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我发现使用这个库的一个问题是，除非你定义一些模式或规则，否则事情会变得有点混乱。一个例子可以更好地解释这一点:我们的状态(或存储)可以从项目中的任何<em class="lb">组件</em>修改。这意味着您可以在多个地方使用<code class="fe or os ot ou b">store.set('<strong class="kh ir">logged_user</strong>', user)</code>或<code class="fe or os ot ou b">store.get('<strong class="kh ir">logged_user</strong>')</code>(您也可以使用redux来实现这一点，只是稍微冗长一点)。让我们以这个项目结构为例:</p><pre class="mc md me mf gt pf ou pg ph aw pi bi"><span id="290e" class="lc ld iq ou b gy pj pk l pl pm">└── src<br/>    └── features<br/>        ├── gallery<br/>        ├── layout<br/>        │   ├── footer<br/>        │   └── <strong class="ou ir">header</strong><br/>        ├── <strong class="ou ir">login</strong><br/>        ├── navigation<br/>        │   ├── menu<br/>        │   └── <strong class="ou ir">sideNavigation</strong><br/>        └── search</span></pre><p id="1040" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe or os ot ou b">features</code>下的每个文件夹都包含了该项目的一个特性:</p><ul class=""><li id="adad" class="oi oj iq kh b ki kj kl km ko ok ks ol kw om la on oo op oq bi translated"><em class="lb">头组件</em>(显示用户名)使用<code class="fe or os ot ou b">store.get('logged_user').</code></li><li id="8d5a" class="oi oj iq kh b ki ov kl ow ko ox ks oy kw oz la on oo op oq bi translated"><em class="lb">侧边导航组件</em>(当你登录/退出时改变菜单项)使用<code class="fe or os ot ou b">store.get('logged_user')</code>。</li><li id="5a03" class="oi oj iq kh b ki ov kl ow ko ox ks oy kw oz la on oo op oq bi translated">登录组件(让用户登录/退出)使用<code class="fe or os ot ou b">store.set('logged_user')</code>。</li></ul><p id="34bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重点是你必须在每个<em class="lb">组件</em>中记住你用键“<code class="fe or os ot ou b">logged_user</code>”在商店中保存了登录的用户信息。</p><p id="0d75" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个问题的解决方案是集中这些信息，要做到这一点，你可以创建一个<code class="fe or os ot ou b">storeMap.js</code>文件，在这里为你在<em class="lb">商店</em>中使用的每个<em class="lb">键</em>放置一个映射。该文件将如下所示:</p><pre class="mc md me mf gt pf ou pg ph aw pi bi"><span id="f46e" class="lc ld iq ou b gy pj pk l pl pm">export default {<br/>  LOGIN : {<br/>    LOGGED_USER : 'login/logged_user', //who is logged<br/>    ACCESS_TOKEN : 'login/access_token' //user token to call our API<br/>  },<br/>  SEARCH : {<br/>    SEARCH_TERM : 'search/search_term', //the term you searched<br/>    SEARCH_RESULTS : 'search/search_result', //search results<br/>    CURRENT_PAGE : 'search/current_page' // the current page<br/>  }<br/>}</span></pre><p id="7297" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">组件现在将使用<code class="fe or os ot ou b">store.get(StoreMap.LOGIN.LOGGED_USER)</code>而不是<code class="fe or os ot ou b">store.get('logged_user')</code>，即:</p><ul class=""><li id="2333" class="oi oj iq kh b ki kj kl km ko ok ks ol kw om la on oo op oq bi translated">不容易出错:你不必写一个字符串</li><li id="3e40" class="oi oj iq kh b ki ov kl ow ko ox ks oy kw oz la on oo op oq bi translated"><strong class="kh ir">集中式</strong>:整个应用程序状态被映射到一个文件中(如果需要，可以使用导入/导出将其拆分成更多文件)</li><li id="64a0" class="oi oj iq kh b ki ov kl ow ko ox ks oy kw oz la on oo op oq bi translated">易于重构:只需从你的超级IDE中重命名一个键或一个值。</li><li id="1534" class="oi oj iq kh b ki ov kl ow ko ox ks oy kw oz la on oo op oq bi translated">不言自明的:当查看这个文件时，你可以对整个应用程序的状态有一个概念</li></ul><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/7b1ebf006d85acd83a5555160954dda9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/1*3P3CI1EJv1neFifF_KB9sQ.gif"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">redux和react-store的复杂度比较</figcaption></figure></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="325f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">恭喜你！！😎你坚持到了最后。如果你喜欢👌这篇文章，点击下面按钮👏。这对我意义重大，也有助于其他人了解这个故事。</p><p id="9f74" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">更多帖子由</em><a class="ae ma" href="https://medium.com/@spyna" rel="noopener"><em class="lb">spyna</em></a><em class="lb">发布。</em></p><div class="mx my gp gr mz na"><a href="https://medium.com/swlh/react-global-state-with-hooks-f163e49f90f9" rel="noopener follow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd ir gy z fp nf fr fs ng fu fw ip bi translated">用钩子和上下文反应全局状态</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">使用钩子和上下文API管理React应用程序全局状态的解决方案。</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">medium.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no ml na"/></div></div></a></div><div class="mx my gp gr mz na"><a rel="noopener  ugc nofollow" target="_blank" href="/react-svg-radar-chart-a89d15760e8"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd ir gy z fp nf fr fs ng fu fw ip bi translated">反应SVG雷达图</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">周围有很多库，用来创建图表，但是很多都很重。让我们看看如何建立一个…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">itnext.io</p></div></div><div class="nj l"><div class="pr l nl nm nn nj no ml na"/></div></div></a></div></div></div>    
</body>
</html>