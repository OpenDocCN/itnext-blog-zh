<html>
<head>
<title>Build the future of web development with Next.js Edge Rendering and globally distributed database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Next.js Edge渲染和全球分布式数据库构建web开发的未来</h1>
<blockquote>原文：<a href="https://itnext.io/build-the-future-of-web-development-with-next-js-3f6414f93b25?source=collection_archive---------3-----------------------#2022-10-05">https://itnext.io/build-the-future-of-web-development-with-next-js-3f6414f93b25?source=collection_archive---------3-----------------------#2022-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="63dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Next.js允许您构建React应用程序。最近，由于出色的开发人员体验和许多其他使其使用起来充满乐趣的特性，它获得了很大的人气。</p><p id="f1e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将使用Next.js Edge和<a class="ae kl" href="https://upstash.com/?utm_source=remi1" rel="noopener ugc nofollow" target="_blank">upshredis</a>构建一个最先进的web应用程序。随着边缘计算的最新发展，我们将使用Next.js的最新功能(Edge SSR和Edge API Routes)来构建一个速度极快、完全分布式和可扩展的应用程序。好消息是，它是100%无服务器的，没有服务器管理。</p><p id="b0de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了展示边缘计算的威力，我们将创建一个简单的URL shortener应用程序。URL缩短器是一种接受URL并将其转换为更短的URL的服务。当你想在Twitter或其他社交媒体平台上分享网址时，这很有用。当您想要对用户隐藏实际的URL时，它也很有用。</p><h1 id="f584" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">边缘计算</strong></h1><p id="0b53" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">过去，Next.js中的静态站点生成(SSG)是在CDN的帮助下从边缘提供的。静态HTML内容部署在世界各地，用户从最近的边缘位置获取内容。这是减少延迟和提高应用程序性能的好方法。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/172df7bab42e5ec61bc089053c90a9b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*5w05NPJME_EChQNTZ8uDcQ.png"/></div></figure><p id="8306" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于动态内容，Next.js提供了服务器端呈现(SSR)。内容在服务器上生成，并发送给客户端。过去，与SSG相比，SSR仅部署在一个位置，便于设置。</p><p id="91b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了最新版本的Next.js (Next.js 12.2)，我们就可以访问边缘渲染了。该功能仍处于实验模式，但您已经可以试用了。这允许在边缘部署SSR和API路由。因此，现在可以在一个配置中从多个位置提供动态内容。</p><p id="68ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">移动到边缘后，数据库会出现瓶颈。由于复杂性和运营成本，很难在多个位置部署数据库。但是，有了像Upstash这样的现代数据库提供商，我们现在可以一键部署一个全球Redis数据库。边缘渲染/计算的完美匹配。最重要的是，Upstash是一个无服务器的数据库，所以你不必担心基础设施。</p><h1 id="718b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">边缘服务器渲染</strong></h1><p id="9bf5" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们将使用Next.js样板文件作为起点。使用TypeScript和Tailwind CSS从Next.js开始是一个很好的方法。还配置了ESLint，beauty，Husky，Jest，Cypress。你可以在GitHub的<a class="ae kl" href="https://github.com/ixartz/Next-js-Boilerplate" rel="noopener ugc nofollow" target="_blank"> Next.js样板</a>找到源代码。</p><p id="ba3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们创建一个名为`<em class="lx">src/pages/admin/index . tsx</em>的新页面的新`<em class="lx"> admin </em>文件夹:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="4a1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您想要在边缘部署时，可以在所有页面上设置“<em class="lx">运行时</em>”配置。默认情况下,<em class="lx">运行时间</em>被设置为“<em class="lx">节点</em>”。但是，对于边缘渲染，我们需要将其设置为“<em class="lx">实验边缘</em>”。</p><p id="4dc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">部署应用程序后，您可以看到页面在边缘呈现。您可以通过在浏览器中打开页面来检查它，服务器应该会返回`<em class="lx"> edge </em>`。</p><h1 id="6ab1" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">边缘API路由</strong></h1><p id="0e98" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">您不局限于渲染，您还可以在边缘部署您的API路由。让我们创建一个新的API路由`<em class="lx">src/pages/API/create-redirection . ts</em>`:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="bdac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与边缘渲染相同，我们需要将`<em class="lx">运行时</em>配置设置为`<em class="lx">实验边缘</em>'。</p><p id="f45e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用您的浏览器或您喜欢的HTTP客户端来测试API路由。它应该返回`<em class="lx"> {"runtime":"edge"} </em>`。</p><h1 id="ddfc" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">全局启用Edge</strong></h1><p id="9b2b" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">您可以全局启用它，而不是在每个Next.js页面上设置`<em class="lx">运行时</em>`配置(它对API路由无效)。为此，您需要在项目的根目录下创建一个新文件“<em class="lx"> next.config.js </em>”:</p><pre class="lq lr ls lt gt ma mb mc md aw me bi"><span id="7d16" class="mf kn iq mb b gy mg mh l mi mj">module.exports = {<br/>  experimental: {<br/>    runtime: 'experimental-edge',<br/>  },<br/>};</span></pre><h1 id="7c2a" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">无服务器分布式全局数据库</strong></h1><p id="3a11" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在确保应用程序部署在边缘之后，我们现在可以关注数据库部分。我们将使用一个无服务器的Redis数据库提供者。</p><p id="0f78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将使用免费计划。首先，我们需要在Upstash上创建一个帐户。然后，创建一个新的全局Redis数据库:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/836e76bd38bb00d006cdc8bc9978bb06.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*NKYRE6KGsKth2EtGsUsKwA.png"/></div></figure><p id="ef3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要忘记在“<em class="lx">类型</em>部分选择“<em class="lx">全局</em>”。</p><h1 id="2efe" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">连接到Redis数据库</strong></h1><p id="0ff3" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们将使用`<em class="lx">@ upstresh/Redis dis</em>`包来连接Upstash Redis数据库。您可以使用以下命令安装它:</p><pre class="lq lr ls lt gt ma mb mc md aw me bi"><span id="82ff" class="mf kn iq mb b gy mg mh l mi mj">npm install @upstash/redis</span></pre><p id="bc2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，创建一个新文件“<em class="lx"> src/utils/redis.ts </em>”:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="4532" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在您的upsh仪表板上，您可以复制`<em class="lx">upsh _ REDIS _ REST _ URL</em>`值。然后，您可以粘贴到` . env '文件中:</p><pre class="lq lr ls lt gt ma mb mc md aw me bi"><span id="87c5" class="mf kn iq mb b gy mg mh l mi mj">UPSTASH_REDIS_REST_URL=https://XXXXXXXX.upstash.io</span></pre><p id="90f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还需要复制`<em class="lx">UPSTASH _ REDIS _ REST _ TOKEN</em>值。这一次，您需要将它粘贴到` . env.local `文件中:</p><pre class="lq lr ls lt gt ma mb mc md aw me bi"><span id="7978" class="mf kn iq mb b gy mg mh l mi mj">UPSTASH_REDIS_REST_TOKEN=XXXXXXXX</span></pre><p id="4688" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们正在使用`<em class="lx"> .env.local </em>`文件，所以它不会被提交给Git存储库。将秘密值存储在这个文件中是一个很好的做法。</p><p id="120f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还需要在您的Vercel仪表板中添加“<em class="lx">UPSTASH _ REDIS _ REST _ TOKEN</em>”。转到`<em class="lx">设置</em> ` &gt; ` <em class="lx">环境变量</em>并定义`<em class="lx">UPSTASH _ REDIS _ REST _ TOKEN</em>变量。</p><h1 id="8305" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">向数据库添加数据</strong></h1><p id="70e2" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在将数据添加到数据库之前，我们需要通过创建一个新文件`<em class="lx"> src/types/redirection.ts </em>来定义数据结构:</p><pre class="lq lr ls lt gt ma mb mc md aw me bi"><span id="e19d" class="mf kn iq mb b gy mg mh l mi mj">export type IRedirection = {<br/>  id: string;<br/>  url: string;<br/>};</span></pre><p id="3251" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用之前创建的API路由向数据库添加数据。让我们更新`<em class="lx">src/pages/API/create-redirection . ts</em>`文件:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="1dc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用`<em class="lx"> hset </em> ` Redis方法向数据库添加数据。</p><p id="0c50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">部署后，您可以通过发送具有以下正文的POST请求来测试API路由:</p><pre class="lq lr ls lt gt ma mb mc md aw me bi"><span id="a61f" class="mf kn iq mb b gy mg mh l mi mj">{<br/>  "id": "magic",<br/>  "url": "https://google.com"<br/>}</span></pre><p id="2f13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过发送这个请求，它将向数据库添加一个新条目。然后，这个想法是当用户输入“<em class="lx"> magic </em>”作为ID时，将用户重定向到Google网站。</p><h1 id="7507" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">使用中间件在边缘上重定向</strong></h1><p id="40de" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">Next.js中的一个中间件允许您在完成请求之前运行一个函数。默认情况下，所有中间件都在边缘执行。所以，不需要设置任何配置。</p><p id="21ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在Next.js中间件中添加重定向逻辑。让我们创建一个名为`<em class="lx">src/middle ware . ts</em>的新文件:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="3e60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在文件的底部，我们使用`<em class="lx"> config </em>对象来定义`<em class="lx"> matcher </em>配置。因此，只有当路径名以`/ <em class="lx"> r </em> /'开头时，中间件才会被执行。</p><p id="5319" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用`<em class="lx"> hget </em> ` Redis方法从数据库中获取URL。如果条目存在，它会将用户重定向到URL。否则，它会重定向到主页。</p><h1 id="1118" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">列出所有的重定向</h1><p id="1a29" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们将使用之前创建的`<em class="lx"> admin </em>`文件夹中的索引页面来列出数据库中存储的所有重定向。让我们更新“<em class="lx">src/pages/admin/index . tsx</em>”文件:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="bc3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还使用`<em class="lx"> getServerSideProps </em>`函数通过SSR获取服务器端的数据。并且，我们已经在`<em class="lx"> next.config.js </em>文件中设置了`<em class="lx">运行时</em>配置。因此，页面将在每个请求的边缘呈现。</p><p id="186a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于数据库，我们使用`<em class="lx"> hgetall </em> ` Redis方法来获取所有条目。然后，我们在Next.js页面上显示列表。</p><h1 id="5a5a" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结论</h1><p id="abbf" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">学习完本教程后，您应该能够使用Vercel和<a class="ae kl" href="https://upstash.com/?utm_source=remi1" rel="noopener ugc nofollow" target="_blank"> Upstash </a>在生产环境中部署URL shortener。好消息是一切都在边缘:API路由、中间件和渲染都在边缘发生。我们不仅使用了边缘计算，还使用了全球分布式数据库Upstash。所以，一切都贴近用户，快捷。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ml"><img src="../Images/149c3f491525e4ec46b3bc47fe0db68e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pPIxAatv67uJKqrVUrptZg.png"/></div></div></figure><p id="4b06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有基础架构都是100%无服务器的，您无需担心服务器管理和扩展。您可以专注于业务逻辑和用户体验。</p></div></div>    
</body>
</html>