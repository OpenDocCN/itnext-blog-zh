<html>
<head>
<title>Why the concept of immutability is so awfully important for a beginner front-end developer?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么不变性的概念对于初学前端开发的人如此重要？</h1>
<blockquote>原文：<a href="https://itnext.io/why-concept-of-immutability-is-so-damn-important-for-a-beginner-front-end-developer-8da85b565c8e?source=collection_archive---------1-----------------------#2018-11-19">https://itnext.io/why-concept-of-immutability-is-so-damn-important-for-a-beginner-front-end-developer-8da85b565c8e?source=collection_archive---------1-----------------------#2018-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4824" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">AKA:JavaScript中不变性的完整介绍(还有一个关于socks的故事)。</h2></div><p id="b31f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">写这篇文章的时候是仲秋，这让我想起了即将到来的年底。谁喜欢收到圣诞礼物？</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/17b496a10dbb4e750099819a3e5b4b4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z-tvgEOjcxAcR5vKO9DN7g.png"/></div></div></figure><p id="5e33" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，这很简单。收到礼物很酷，而且永远都是。那么，每年都收到同样的礼物会怎么样呢——例如，袜子？</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/405bac591b7234e11ec2f3dfc6ce0182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WJaLWnum4H0AyFGKU7_1KQ.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">我敢打赌，你们很多人都认识一个可爱的阿姨，她每年都给你同样的一双袜子。</figcaption></figure><p id="7178" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于这种礼物的问题是:几年后，你不需要为了知道里面是什么而打开它们。你知道，如果礼物是你的阿姨送的，并且用精致的纸轻轻地包装着，藏在里面的东西肯定是一双闪亮的新袜子。与过去两年、三年或四年前几乎一样。爱你，阿姨。</p><p id="85a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个转折:如果下一次你姑姑的礼物真的是用坚固结实的包装送来的——和平时完全不同——会怎么样？或者如果软包装是别人给的呢？你会怎么想？你会再次怀疑里面的内容，或者更确切地说，假设包含的对象是完全不同的东西吗？</p><p id="2129" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们把袜子塞进JavaScript。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h2 id="493c" class="ly lz iq bd ma mb mc dn md me mf dp mg ko mh mi mj ks mk ml mm kw mn mo mp mq bi translated">JavaScript变量类型背后的魔法</h2><p id="ed77" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">在我们深入探讨不变性的概念之前，让我们追根溯源，弄清楚JavaScript中关于类型的一些事情。</p><p id="ea7e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你可能在无数的教程和书籍中读到的，它们被分为两类:</p><ul class=""><li id="012e" class="mw mx iq kh b ki kj kl km ko my ks mz kw na la nb nc nd ne bi translated">原始类型，例如数字、字符串、布尔型</li><li id="71cd" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated">引用类型，例如对象、数组、函数</li></ul><blockquote class="nk nl nm"><p id="6ea8" class="kf kg nn kh b ki kj jr kk kl km ju kn no kp kq kr np kt ku kv nq kx ky kz la ij bi translated">(事实上，数组和函数也是对象——但是让我们暂时把这个怪癖放在一边，反正JavaScript从来就不是一个普通的家伙。)</p></blockquote><p id="9c0c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在真正重要的问题是:提到的两种变量有什么区别？先说清楚，一步一步来。</p><p id="4c10" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们给一些变量赋值。例如:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nr"><img src="../Images/8f8445a2e74f3731e27a7ca63c516457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Fa_-fmAA9g6iW8IQXpe4A.png"/></div></div></figure><p id="412c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为宇宙是一个非常动态的概念——编程也是如此——通常我们的目标是将这些值转换成其他值。最好，我们有一个函数为我们做这件事:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ns"><img src="../Images/eada412645333845315f06550e6bd77a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uYf-gKwVUVGz-CR9lJvxmQ.png"/></div></div></figure><p id="e5e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们从一个字符串变量开始，试着写一个函数来转换它。我们先从哑吧和幼稚的做法开始:<em class="nn">(警告，前方白痴且明显无效的代码！)</em></p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nr"><img src="../Images/a1e4aff4daaff81565a6afa7f46a7d4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PKhDSsA9rim1ledt1MaikA.png"/></div></div></figure><p id="f985" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显然，这段代码看起来并不精彩(坦白说，很白痴)。该函数尝试将参数变量的值更改为其他值—但是在调用时，将变量注销到控制台仍然会显示原始值。</p><p id="5e51" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">能正常工作吗？傻，当然不是。如你所知，我们的函数体在它的参数中收到了变量<code class="fe nt nu nv nw b">someString</code>的<strong class="kh ir">副本</strong>，所以任何更改都将只针对复制的字符串——原始字符串将保持不变。如果我们真的想实现我们的目标，我们需要从函数中返回一个值。大概是这样的:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nx"><img src="../Images/bf8e2adf6723f2a6354710f1fc8a2f1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5i-CORNau2aAQHUVzrp7XQ.png"/></div></div></figure><p id="8769" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一个如预期的那样工作——我们的函数设法处理并返回数据，尽管有我们函数的副本。但是<strong class="kh ir"> copy </strong>这个概念在JavaScript中是什么意思呢？</p><p id="2a89" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们试着对这个对象做同样的事情。类似地，就像我们处理字符串一样，我们将从简单的方法开始。看，据说是愚蠢的代码:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ny"><img src="../Images/06565c46a7ebc11e9a6c4c3abffc986f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Isn-upryz11hAq-9PRI1PQ.png"/></div></div></figure><p id="31b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好，我们跑吧。啊哦。成功了吗？</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ns"><img src="../Images/f83ab0fc73e1c4b1ad601ef0c459a3b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WQeO1IeVCs5I70xjGlz6AQ.png"/></div></div></figure><p id="a0de" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">真扫兴。它起作用了——但是意想不到的奇迹般的作用很少是好现象。</p><p id="0cfa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来分析一下:如果我们遵循与<code class="fe nt nu nv nw b">string</code>相同的逻辑，我们会预期对象将被复制。然后，我们所有的更改将在<strong class="kh ir">副本</strong>上执行，而不是在<strong class="kh ir">原件</strong>上执行。相反，我们设法就地修改了对象。为什么会这样？</p><p id="3c65" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实是，我们的函数<strong class="kh ir">复制了</strong> <strong class="kh ir">的参数——但是两个变量名(<code class="fe nt nu nv nw b">someObject</code>和<code class="fe nt nu nv nw b">input</code>)都引用了<strong class="kh ir">的同一个对象</strong>。确切地说，两者拥有相同的<strong class="kh ir">引用</strong>——它们与计算机内存中的相同位置相关。我们甚至可以通过简单的分配来模仿这种行为:</strong></p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nz"><img src="../Images/29a6f8e8d62eb7306725d14f77e500e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*68a1qaonm21ehRQA1vIMqQ.png"/></div></div></figure><p id="804e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类似地，这里的两个变量都保存了对同一个对象的引用。当使用“<code class="fe nt nu nv nw b">=</code>”操作符时，我们并不复制对象——我们只是给内存中的位置分配一个地址。如果您想在处理对象分配时更加自信，您可以随时查找对象创建的次数。</p><p id="3130" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个新对象的创建:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oa"><img src="../Images/78ab9a752dd96e66b08128994f3fb865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qpxe-j3UJ-A5UcUHQ2WXYw.png"/></div></div></figure><p id="a65f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个<strong class="kh ir">不是</strong>:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oa"><img src="../Images/4ae9a6dff62010966f963c26e7d9cb9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s2NGN6bwd0jMQ9-_2GXExw.png"/></div></div></figure><p id="a029" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现代人只知道用JavaScript创建对象的三种方法:</p><ul class=""><li id="44b3" class="mw mx iq kh b ki kj kl km ko my ks mz kw na la nb nc nd ne bi translated">使用花括号<code class="fe nt nu nv nw b">{</code>和<code class="fe nt nu nv nw b">}</code>立即创建(就像上面的例子)</li><li id="a726" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated">使用<code class="fe nt nu nv nw b">Object.create()</code></li><li id="ef47" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated">使用<code class="fe nt nu nv nw b">new</code>操作器</li></ul><p id="28d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任何其他操作:赋值、作为参数传递、从函数返回某个东西——将<strong class="kh ir">而不是</strong>以创建一个新对象结束(至少在传统的JavaScript中)。</p><blockquote class="nk nl nm"><p id="39dc" class="kf kg nn kh b ki kj jr kk kl km ju kn no kp kq kr np kt ku kv nq kx ky kz la ij bi translated">请记住，我们在本文中讨论的是对象，但基本上所有这些原则也适用于数组。<a class="ae ob" href="https://jsbin.com/nubeguluni/edit?js" rel="noopener ugc nofollow" target="_blank">毕竟，它们也是物品。</a></p></blockquote><p id="c54e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，那它要去哪里？显然，对相同对象进行赋值引用还有另外一面——而且相当糟糕。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><p id="8876" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用上面例子中的逻辑，我们可以创建一个对象，并通过将它的引用赋给另一个变量来记住它。然后，我们可以执行一些修改，并检查原件是否仍然与副本匹配。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oc"><img src="../Images/aaba81bb583458d58e7eaf607c88b57a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B0F-xfcp8qLS8MgnrvF-FQ.png"/></div></div></figure><p id="b15d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显然，这些物体还是一样的。而且，我们已经把之前的版本(带<code class="fe nt nu nv nw b">alpha</code>的那个)弄丢了。无论我们做多少修改，无论我们创建多少引用同一个对象的变量——它们都将指向同一个对象，我们将无法察觉任何差异。毕竟，对象只被创建一次——我们只有一组<code class="fe nt nu nv nw b">{</code>和<code class="fe nt nu nv nw b">}</code>。</p><p id="b2f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们暂时回到我们的圣诞礼物。你可以把一个JavaScript对象想象成你阿姨送给你的礼物:保存对象引用的变量是<strong class="kh ir">包装、</strong>对象的字段(及其值)是你礼物的<strong class="kh ir">内容</strong>。问题来了:如果包装总是一样的，你怎么知道里面的东西变了呢？换句话说:如果包装没有变化，如何在不打开包装的情况下检查里面的东西？</p><p id="e9da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管听起来很傻，但这是一个非常重要的概念，影响着编程的许多方面。<em class="nn">为什么？</em></p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><p id="b23b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想象一下<em class="nn">一个对象</em>被分配给<em class="nn">应用程序中多个地方的多个</em>变量。它们分散在许多代码文件中，并采取各种形式:函数参数、限定范围的变量，甚至是另一个对象的字段。现在，因为只有<em class="nn">一个对象</em>，我们代码的多个部分能够改变(突变)它的内容。这听起来不太好，但还不是最灾难性的部分。</p><p id="4d01" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更糟糕的是，我们无法跟踪这些变化。由于所有变量共享相同的引用，我们无法通过比较来区分它们。为什么我们需要它？例如，为了刷新用户界面或以某种其他方式对变化做出反应。</p><p id="b3fd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我换一种说法:如果在任何给定的时间点，您想检查对象的内容自创建以来是否发生了更改，那么您注定要失败。您需要遍历它的所有字段，并以某种方式将它们的值与一些记忆的模式进行比较——但是从计算的角度来看，这种方法非常昂贵(记住，对象是可以嵌套的！).当然，您可能会发明一个系统来记录所有执行的更改——但是与我们理论上的单个对象相反，现实世界的应用程序包含多个对象，这些对象具有包含数组或函数的深度嵌套结构。维持这样的历史书写机制将很快成为一场令人不快的噩梦。</p><p id="d4af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是的，JavaScript的变化过程是艰难的。或者更确切地说，检测它。那么，如果我们<strong class="kh ir"> <em class="nn">禁止一切变化</em></strong>——或者换句话说，让突变成为非法，会发生什么？</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ns"><img src="../Images/964347386c7b5bf7e402ec0cdebf5b22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nNApx1UKWskgMUM8ZPrmww.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">职位:变革预防干事</figcaption></figure><h2 id="02ed" class="ly lz iq bd ma mb mc dn md me mf dp mg ko mh mi mj ks mk ml mm kw mn mo mp mq bi translated">欢迎来到永恒的世界</h2><p id="d2d7" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">让我们从基本概念开始:我们想要<a class="ae ob" href="https://www.youtube.com/watch?v=eiyfwZVAzGw&amp;feature=youtu.be&amp;t=10" rel="noopener ugc nofollow" target="_blank">非法化</a>对象中的所有直接变化。我们还有什么选择？不多——事实证明，只有一条出路:</p><p id="4dc8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想象一下在我们的编程游戏中引入一个疯狂的规则:<strong class="kh ir">每次我们想要修改一个对象的内容，我们</strong> <strong class="kh ir">用更新的内容</strong>创建一个新的对象。一直都是。没有借口。</p><p id="7d62" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">听起来很奇怪？是的。尽管看起来很疯狂，但这可能是非常可行。让我们用这个想法写一个代码，通过创建一个新的对象来“更新”一个对象。假设一个简单的场景:我们需要在一个已经存在的对象中更改一些字段的值:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi od"><img src="../Images/c818657676713de11258dc67f780acbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jNlkVmG13WAGPwVBaFxx6A.png"/></div></div></figure><p id="728c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们编写将“重新创建”我们的对象的代码，然后更改一些字段:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oe"><img src="../Images/6ec52dcb85c3a3dd856903288df05fe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Du6WkOrHIOQJwqJnb_rl9w.png"/></div></div></figure><p id="8a13" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们妄下结论之前，让我们试着用<code class="fe nt nu nv nw b">Object.assign</code>来解释hassle，并尝试改进它。一般来说，它是一种将一个对象的所有属性(字段)分配给另一个对象的方法——第一个参数是接收对象，下一个参数是提供者。但由于在撰写本文时是2018年，我们可以利用<a class="ae ob" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#Spread_in_object_literals" rel="noopener ugc nofollow" target="_blank">对象传播运算符</a>的使用:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi of"><img src="../Images/d9374bf1ae7b3f9d65a4ec4897fdedcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vrL8QD11L1qSGxcfJ-aQMQ.png"/></div></div></figure><p id="3286" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以更进一步—记住，使用这种符号，我们可以通过重新分配现有字段来覆盖它们，如下所示:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi og"><img src="../Images/1acb5367ec9e3c2b286425545a43cd4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SFEc1fDgIEGOgagUgmmO_Q.png"/></div></div></figure><p id="e1b0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的最终代码像以前一样工作，现在看起来像这样:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oh"><img src="../Images/d359258bb371d687fffbb7fc6ef1ace4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gfHqJH9j3yCOH95yShcFZA.png"/></div></div></figure><p id="d389" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">抛开语法不谈，代码是有效的。我们不是直接修改对象，而是创建一个副本并重新分配所有内容——最后，我们只剩下原始未动对象和一个包含更新内容的新对象。</p><p id="3add" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好处在哪里？<em class="nn">有什么好的部分？</em></p><p id="91b0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">答案就在代码的最后一行。控制台将显示<code class="fe nt nu nv nw b">false</code>，这意味着对象有不同的引用——如果我们能够区分它们，这表明我们<strong class="kh ir">已经获得了跟踪我们的对象</strong>中的变化的方法。虽然这听起来微不足道，但事实证明这是至关重要的，尤其是在前端(或面向界面的)应用中。为什么？</p><p id="bf4f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们获得了:</p><ul class=""><li id="3316" class="mw mx iq kh b ki kj kl km ko my ks mz kw na la nb nc nd ne bi translated"><strong class="kh ir">预见性。</strong>规则很简单。如果引用不同，则表明已经做了一些更改。如果我们仍然使用旧的引用(我们可以通过使用与<code class="fe nt nu nv nw b">===</code>的简单比较来确保这一点)，我们可以确定什么都没有改变。明确程序。不多不少。</li><li id="ca68" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated"><strong class="kh ir">变更追踪。</strong>想象一下在应用程序的不同模块中使用单个数据对象——或者甚至将它发送到某个第三方库。过了一会儿，你能确定这个对象的内容没有改变吗？你能确定它和之前是同一个物体吗？使用不变性，您可以比较操作前后的引用(<code class="fe nt nu nv nw b">===</code>)——如果有些事情已经改变，而我们仍然在玩规则，我们可以预期它们会有所不同。</li><li id="817e" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated"><strong class="kh ir">实现反应式接口的容易程度。</strong>我们可以从UI内部观察数据对象，并且<em class="nn">仅在数据发生变化时做出反应</em>,而不是显式地重新呈现UI的各个部分(并跟踪应该刷新哪个部分)。我们可以非常快速地检查它，因为它只是一次引用的比较(一次<code class="fe nt nu nv nw b">===</code>)，而不是遍历所有内部字段的昂贵的迭代。哦，我用了“反应”这个词吗？没错——著名的<a class="ae ob" href="https://github.com/facebook/react" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> react </strong> </a>库利用了不变性的概念来优化UI刷新过程。在<strong class="kh ir"> Vue </strong>和<strong class="kh ir"> Angular </strong>中也有类似的用例/机制。</li><li id="3106" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated"><strong class="kh ir">改变历史。假设你需要在应用程序中实现撤销和重做功能。首先想到的是一个可怕的、复杂的系统，它跟踪所有的动作，并有可能在应用程序的数据对象上回放(和重放)它们。使用本文描述的方法，你可以以独立的(不可变的)对象的形式保存和保留任意数量的历史条目，并用它们替换当前状态。需要撤销吗？只需带着整个数据集返回之前的整个对象，瞧，这就完成了。需要重做吗？同样，恢复撤消时保存的状态。太简单了。</strong></li><li id="c8a2" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated"><strong class="kh ir">更多的</strong>——可测试性、酷、有单一的真实来源、更性感等等。</li></ul><p id="c643" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个崭新的充满可能性的闪亮世界就这样出现在我们面前。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ns"><img src="../Images/f5d6f9a41147f946c620115f179adeb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DX05YOZ6oc2NnW-o2HI9Fg.png"/></div></div></figure><p id="916e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是没有不带刺的玫瑰，可能会有什么缺点呢？</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><p id="e961" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先想到的可能是内存消耗增加。如果每次有变化时，我们都不断地重新创建我们的对象，我们不是像一只饥饿的獾一样大嚼RAM吗？</p><p id="1c7d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯，没看上去那么糟。显然，JavaScript执行环境在回收内存方面非常出色。一个名为<a class="ae ob" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management" rel="noopener ugc nofollow" target="_blank">垃圾收集器</a>的机制有效地寻找所有不再使用的对象，然后处理它们。因此，在创建了不可变对象的新版本之后——一旦它意识到我们的代码不再需要旧版本，内存就会被快速释放。</p><p id="b645" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有第二个不用担心内存的原因——它被称为结构共享，这是在不变性世界中需要掌握的另一个重要概念。</p><p id="518c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们建立了一个规则:任何时候我们需要<strong class="kh ir">改变</strong>对象的内容，我们必须<strong class="kh ir">创建一个新的</strong>。顺着这个逻辑，我们可以提取另一个语句:只要一个对象<strong class="kh ir">不改变</strong>，那么<strong class="kh ir">就会保留它的旧引用</strong>。为了节省大量内存，我们可以将该语句作为对象的嵌套字段。</p><p id="64dd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑以下不可变对象:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oi"><img src="../Images/4b936465080f386cd97411b26ba44633.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TUG2ATRQ_nPoc3z7WAgZSg.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">事实上，我有一辆这样的车。</figcaption></figure><p id="073f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，我们已经有了一个很好的车门，一个司机和一些引擎。干净利落。现在，让我们编写一个函数来修改我们的汽车，并将其从紧凑型车更改为5门全尺寸版:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oj"><img src="../Images/32f0bb7b115cc5b01c7faa17d89cbf6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*phjLUej1TByTB60mL_M16Q.png"/></div></div></figure><p id="2b51" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的新车(<code class="fe nt nu nv nw b">improvedCar</code>)有5扇门，而老款(<code class="fe nt nu nv nw b">car</code>)只剩下3扇门。当然，调用<code class="fe nt nu nv nw b">car === improvedCar</code>会产生<code class="fe nt nu nv nw b">false</code>。但是对比司机呢？</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ok"><img src="../Images/3919151d0001c5a93abb808bcdce5323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A_FTmXEPPTEBCKWVmiXzoA.png"/></div></div></figure><p id="f781" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯，我们在控制台接收到了<code class="fe nt nu nv nw b">true</code>。据说，整个<code class="fe nt nu nv nw b">car</code>都被替换了——但是<code class="fe nt nu nv nw b">driver</code>对象保持不变。这是为什么呢？<strong class="kh ir"> <em class="nn">因为驱动对象不需要变异。</em> </strong>这是一件好事——想象一下我们应用程序中的某个实体正在观察<code class="fe nt nu nv nw b">car.driver</code>对象，等待发生变化。在这种情况下不会发生这种情况——在比较引用后不会记录任何差异，因为不应该。毕竟，<em class="nn">驱动程序没有任何改动，保持不变。</em></p><p id="88c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们真的想改变任何嵌套字段，我们该怎么做呢？让我们编写一个函数来完成这项工作，但这次我们将尝试调整我们的引擎:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ol"><img src="../Images/632b3d7f1beff9da905de1997732ac87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gy8FtaxouE7UAjFuzQ6JRw.png"/></div></div></figure><p id="1c68" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码开始看起来有点混乱(但不像使用<code class="fe nt nu nv nw b">Object.assign</code>时那么混乱！).循序渐进:</p><ul class=""><li id="a5f3" class="mw mx iq kh b ki kj kl km ko my ks mz kw na la nb nc nd ne bi translated">首先，我们将返回一个新对象，它将代表一辆全新的汽车。在下一行中，我们将在那里展开所有的旧车领域。</li><li id="e275" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated">接下来，我们通过提供另一个新的(！)对象。同样，我们在那里传播旧汽车的引擎特性。</li><li id="ea92" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated">最后，我们更改所需的字段。</li></ul><p id="d213" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们最终得到了<strong class="kh ir">新车</strong>，它拥有<strong class="kh ir">新发动机</strong>。</p><p id="f069" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如果我们只是换一个引擎，为什么我们需要一个新的汽车对象呢？直截了当地说:因为我们还没有淘汰旧引擎，我们还需要一些车来支持它。</p><p id="5b7e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们在控制台中看到的那样，汽车和引擎都不同于它们原来的对应物——一切都在适当的位置，并有适当的名称。就像在一些哲学流派中一样:静止最终导致内心的平静。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ns"><img src="../Images/f757d28be6149ff306452c5a4ef09b87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RxkciPHQuFv-zcWMGImtsw.png"/></div></div></figure><p id="5bfb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是不可变编程的本质:代码是可预测的。另外，只要我们需要，数据就会自动保留。此外，我们只重新创建被改变的部分，所以内存不会被浪费(当然，它仍然需要深思熟虑的数据结构规划)。</p><p id="fc69" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">反应式界面框架也利用了这一思想——它们只能观察深层嵌套对象的变化，因此如果“根”对象的另一个子部分被完全修改，它们不需要更新自己。通常，整个应用程序状态(每一段可显示的数据)是一个大的JavaScript对象，它被分成嵌套的结构。听说过<strong class="kh ir"> redux </strong>吗？是的，它利用了这个想法。而且非常酷。</p><p id="bd84" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在那里我们可以回答我们的主要问题。</p><p id="3d35" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">为什么不变性的概念对初学前端开发的人如此重要？</strong></p><blockquote class="om"><p id="846a" class="on oo iq bd op oq or os ot ou ov la dk translated">因为不可变对象教会我们以可预测的方式控制接口和数据流，同时有效地观察变化。</p></blockquote></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><p id="ef1b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后值得一提的是处理数组。原理是非常相似的— <strong class="kh ir">如果我们想要改变数组中的任何条目，我们也应该重新创建整个数组。</strong>如果我们想改变一个数组元素的对象，<strong class="kh ir">我们应该重新创建数组和里面的对象。</strong>考虑以下例子:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ow"><img src="../Images/4ebe216cd3484afc4f2ceb51bf70f756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7bkAvq14e4N-q-dCmEf0Vg.png"/></div></div></figure><p id="a71f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，假设我们需要纠正“数据库”中的错误，将John的名字改为Andrew。根据不变性原则，我们应该重新创建<code class="fe nt nu nv nw b">dataObject</code>、<code class="fe nt nu nv nw b">dataObject.people</code>和<code class="fe nt nu nv nw b">dataObject.people[0]</code>实体。让我们将它分成三个步骤，并使用以下代码来完成:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ox"><img src="../Images/83fd99f9c31237e87e398abfb25f2b49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iBrD2nxYkCQSD3AW1Dz6Tw.png"/></div></div></figure><p id="ce9e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显然，这很有效。我们最终得到了两个对象:约翰的原始对象(<code class="fe nt nu nv nw b">dataObject</code>)和安德鲁的新对象(<code class="fe nt nu nv nw b">newDataObject</code>)。如果我们不使用旧对象，它将导致垃圾收集器清理它的内存。请注意，在这个场景中，包含两个剩余人物(<code class="fe nt nu nv nw b">Maria</code>和<code class="fe nt nu nv nw b">Rokita</code>)的对象保持不变，在第二步中被简单地复制——没有使用额外的内存。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><p id="a868" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，我们到了。您已经学习了JavaScript中不可变编程的基础知识，我们可以就此结束。真的。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/134cd0d999e3cfd38defc86d937ad8c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wZHHCqIbkGheMV9mxsUKuA.png"/></div></div></figure><p id="9c3c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">叹气，好吧。既然圣诞节就要到了，让我们用额外的东西招待我们吧。</p><h2 id="9116" class="ly lz iq bd ma mb mc dn md me mf dp mg ko mh mi mj ks mk ml mm kw mn mo mp mq bi translated">加分篇！</h2><p id="09bc" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">如果你想学习如何更快更干净地处理不可变对象，你可以试试<code class="fe nt nu nv nw b">immer</code>——一个让你在尝试之后不会回头的库。这篇文章将向你介绍它的用法！</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><p id="d1fd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，我们刚刚到达真正的终点。那么，底线是什么？</p><p id="c88d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在处理数据结构时，不可变方法无疑是一个强大的工具。但它是治疗一切的良方吗？<strong class="kh ir">肯定不是。像往常一样，我强烈反对任何人盲目追随任何一种技术，并试图将它应用到任何地方。</strong></p><blockquote class="nk nl nm"><p id="6e71" class="kf kg nn kh b ki kj jr kk kl km ju kn no kp kq kr np kt ku kv nq kx ky kz la ij bi translated">作为开发人员，您的第一个角色是了解各种工具，但第二个角色是知道何时何地应用它们。</p></blockquote><p id="8fe6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有各种各样的问题，在这些问题中不可变的方法会带来麻烦——例如实时、CPU关键的计算，在这些计算中杀手级性能的优先级高于代码可读性。但是由于我们在这里主要讨论的是前端开发，所以在很多情况下，代码可读性和可预测的开发更加重要。此外，在使用流行的<strong class="kh ir"> react </strong>或<strong class="kh ir"> redux </strong>开发应用程序时，你将被强烈鼓励以一种“不变的”方式思考。</p><p id="628b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您仍然感到饥饿，并且希望看到不可变数据结构的运行，请继续关注——很快我们将在一篇专门的文章中尝试创建我们自己的类似react的UI库。</p><p id="2be5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为什么？因为我们可以。还有，好玩又有教育意义。</p><p id="05a8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天就到这里，感谢阅读和<a class="ae ob" href="https://medium.com/@hubert.zub" rel="noopener">保持联系</a>！</p></div></div>    
</body>
</html>