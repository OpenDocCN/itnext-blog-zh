<html>
<head>
<title>How we avoided if/else and wrote extendable code with Strategy Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何避免if/else并使用策略模式编写可扩展的代码</h1>
<blockquote>原文：<a href="https://itnext.io/how-we-avoided-if-else-and-wrote-extendable-code-with-strategy-pattern-256e34b90caf?source=collection_archive---------0-----------------------#2018-08-09">https://itnext.io/how-we-avoided-if-else-and-wrote-extendable-code-with-strategy-pattern-256e34b90caf?source=collection_archive---------0-----------------------#2018-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7da4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们为一家电信客户工作，在那里我们为客户推出了<code class="fe kl km kn ko b">offers</code>。他们有大量的业务逻辑，基于这些逻辑，用户将获得一个<code class="fe kl km kn ko b">offer</code>。除此之外，他们还将在2010年前创建更多类别的<code class="fe kl km kn ko b">offer</code>久而久之。我们看到了类似这样的代码</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ku kv l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">策略模式:不使用策略模式</figcaption></figure><p id="cf39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每当一个新的<code class="fe kl km kn ko b">offer</code>类型被引入，或者现有的规则需要修改，我们需要改变<code class="fe kl km kn ko b">User</code>类。</p><p id="b45d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">调用这个类看起来像这样</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="de81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们对代码有以下问题:</p><ul class=""><li id="3bbc" class="la lb iq jp b jq jr ju jv jy lc kc ld kg le kk lf lg lh li bi translated">违反了<a class="ae lj" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">中的“O”固体原理</a>:根据固体原理</li></ul><blockquote class="lk ll lm"><p id="99d3" class="jn jo ln jp b jq jr js jt ju jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj kk ij bi translated">"软件实体…应该对扩展开放，但对修改关闭."</p></blockquote><p id="f94c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，每当我们必须生成新的报价类别时，我们就必须更改一个<code class="fe kl km kn ko b">User</code>类。</p><ul class=""><li id="000d" class="la lb iq jp b jq jr ju jv jy lc kc ld kg le kk lf lg lh li bi translated">多重<code class="fe kl km kn ko b">if/else</code>使得代码难以测试和维护</li><li id="0fdf" class="la lb iq jp b jq lr ju ls jy lt kc lu kg lv kk lf lg lh li bi translated"><code class="fe kl km kn ko b">offer</code>和<code class="fe kl km kn ko b">User</code>紧密耦合</li></ul><h1 id="a50e" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">拯救的策略模式</h1><p id="770f" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">策略模式允许我们独立于使用它的客户端来改变算法。在我们的例子中，我们希望独立于<code class="fe kl km kn ko b">User</code>来修改<code class="fe kl km kn ko b">offer</code>的算法。</p><p id="b6c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们创建一个名为<code class="fe kl km kn ko b">UserOffer</code>的新类</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ku kv l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">策略模式:报价的新类别</figcaption></figure><p id="8958" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要注意的重要事项:</p><ul class=""><li id="b86b" class="la lb iq jp b jq jr ju jv jy lc kc ld kg le kk lf lg lh li bi translated">在<code class="fe kl km kn ko b">line 3</code>，它是一个函数引用，而不是一个实际的调用。</li><li id="3a3b" class="la lb iq jp b jq lr ju ls jy lt kc lu kg lv kk lf lg lh li bi translated">从<code class="fe kl km kn ko b">line 11</code>开始，我们可以创建新的优惠</li></ul><p id="3538" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的<code class="fe kl km kn ko b">User</code>类现在变得简单多了</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ku kv l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">策略模式:具有策略模式的用户类</figcaption></figure><p id="de1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码中，我们已经引入了与<code class="fe kl km kn ko b">setType</code>类似的<code class="fe kl km kn ko b">setOffer</code>。<code class="fe kl km kn ko b">getOffer</code>现在只需调用<code class="fe kl km kn ko b">offer.getOffer</code>，它将返回相关报价。</p><ul class=""><li id="ab8a" class="la lb iq jp b jq jr ju jv jy lc kc ld kg le kk lf lg lh li bi translated">这种方法使我们能够灵活地修改/创建新的报价，而无需更改<code class="fe kl km kn ko b">User</code>类别。</li><li id="768c" class="la lb iq jp b jq lr ju ls jy lt kc lu kg lv kk lf lg lh li bi translated">我们已经避免了<code class="fe kl km kn ko b">if/else</code>的编码风格</li><li id="883a" class="la lb iq jp b jq lr ju ls jy lt kc lu kg lv kk lf lg lh li bi translated">我们的代码更容易扩展和测试。</li></ul></div></div>    
</body>
</html>