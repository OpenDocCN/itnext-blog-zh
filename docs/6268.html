<html>
<head>
<title>Rust Iterators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust迭代器</h1>
<blockquote>原文：<a href="https://itnext.io/rust-iterators-2f0bb958aa08?source=collection_archive---------3-----------------------#2021-10-04">https://itnext.io/rust-iterators-2f0bb958aa08?source=collection_archive---------3-----------------------#2021-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1833" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你好</p><p id="8626" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我们将讨论rust中的迭代器。</p><p id="ca9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你喜欢视频，这篇文章也有视频解释。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="kq kr l"/></div></figure><p id="a4a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">迭代器，正如你可能在其他语言中看到的，是一种告诉我们的语言我们想要对一些数据进行某种循环的方式。</p><p id="e4b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在rust中，像几乎所有其他语言特性一样，对于迭代器，你需要知道两个特性,“迭代器”和“IntoIterator”。</p><p id="b082" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看一些代码</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="ks kr l"/></div></figure><p id="5f02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个示例代码中，我们可以看到如何在rust中迭代数组，这里没有什么特别的，几乎每种编程语言的开发人员都很熟悉</p><p id="0b5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看第二个样本。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="ks kr l"/></div></figure><p id="e78c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，我们迭代一个向量，它基本上是一个动态大小的数组，看起来很像数组一。</p><p id="af57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，在我们深入研究这个特性如何在rust中实现的细节之前，让我们看一下另一个例子。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="ks kr l"/></div></figure><p id="e388" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，我们迭代了一个hashmap，我想你可以看到这里的模式，hashmap和arrays是完全不同的，但两者都可以迭代，我们可以使用相同的语法在rust中很容易地表达这一点，但所有这些能力来自哪里呢？</p><p id="beff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像Rust的大多数特性一样，答案是相同的，这种能力和表现力来自于特征，更具体地说是“迭代器”特征。</p><p id="09c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看‘迭代器’特征的定义。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="ks kr l"/></div></figure><p id="c2dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个特征有一个与之相关的类型，基本上就是我们正在迭代的类型，我们有许多方法，但是如果你仔细看看，它们都有一个默认的实现，除了一个“next”方法。每次调用“next”方法时，都会返回一个新值，该值将在循环的迭代中使用。</p><p id="c932" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们知道rust中的数组、向量、hashmaps和许多其他类型都实现了“迭代器”特性，因此它们可以在for-in循环中使用，但是我们可以扩展这种功能供我们自己使用吗？</p><p id="249d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">答案是肯定的，这正是我们接下来要做的，我们要为自定义结构实现“迭代器”。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="ks kr l"/></div></figure><p id="e719" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个迭代器相当简单，只是一个简单的向量包装器，让我们看看这个类型的迭代器impl，你可以看到我们刚刚指定了类型关联和下一个方法，下一个方法相当简单，它只是从向量中获取下一个值，如果没有，它就返回它。</p><p id="86fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你在下面的测试中看到的，这种类型的用法与标准库向量和数组或hashmap没有什么不同，它们的用法完全相同，因为它们都实现了相同的东西。</p><p id="cc58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，有时就像我们在CustomIterator中的例子一样，我们只是在我们的类型中包装另一个迭代器，所以也许有一种方法可以告诉rust我们的类型迭代逻辑与底层类型相同，所以只需将该迭代器用于循环，这可以通过使用“IntoIterator”特征来实现，</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="ks kr l"/></div></figure><p id="cfc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个文件中，我们有完全相同的代码，除了不是实现‘iterator’特征，而是实现‘into iterator’特征。这个特性告诉编译器如何将一个类型转换成迭代器，这样它就可以用于for-in循环。如你所见，它有一个消耗自身(获取所有权)并返回迭代器的“into_iter”方法。(在我们的例子中，它是矢量的标准iter类型)。</p><p id="cb89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kt ku kv kw b">Iterator</code>和<code class="fe kt ku kv kw b">IntoIterator</code>特征之间的区别在于<code class="fe kt ku kv kw b">Iterator</code>特征完全实现了迭代逻辑，而<code class="fe kt ku kv kw b">IntoIterator</code>只是创建了一个新的迭代器并将其返回给for循环，所以在我们的例子中，我们的结构中已经有了一个迭代器，只实现<code class="fe kt ku kv kw b">IntoIterator</code>更符合逻辑。</p><p id="a014" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后的话:</p><p id="8cc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">特征是rust语言的核心部分，是大多数语言特性的组成部分，理解它们将有助于我们更好地理解这种语言。</p></div></div>    
</body>
</html>