<html>
<head>
<title>Web sockets with Vert.x and SockJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带Vert.x和SockJS的网络插座</h1>
<blockquote>原文：<a href="https://itnext.io/web-sockets-with-vert-x-and-sockjs-1f0710264eea?source=collection_archive---------5-----------------------#2018-03-04">https://itnext.io/web-sockets-with-vert-x-and-sockjs-1f0710264eea?source=collection_archive---------5-----------------------#2018-03-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/50909f032df2f209368a4d130833c20f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lfn4Nj0pts9cIuGSeIRpDQ.png"/></div></div></figure><p id="53b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fweb-sockets-with-vert-x-and-sockjs-1f0710264eea" rel="noopener ugc nofollow" target="_blank"> <em class="kx">点击这里在LinkedIn </em>上分享这篇文章</a></p><p id="ec97" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Vert.x是Netty之上的可插拔模块的工具包和生态系统，用于在JVM之上构建反应式应用程序。</p><p id="84fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们使用标准的基于线程的方法来处理服务器上的请求时，每个请求都由一个单独的线程来处理。这就限制了一台服务器可以处理多少个并发请求。如果线程池中没有可用的线程，服务器将无法处理更多的请求。<br/>我们可能会将线程数量增加到一个非常大的数字。但是这样做的问题是太多的线程会导致各种类型的资源问题。</p><p id="33ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管如此，线程是利用多核CPU的好方法，但如果使用不当，它会导致许多问题。</p><p id="01a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基于线程的方法的替代方法是事件循环。事件循环使得使用单线程处理多个请求成为可能。事件循环使得vert.x非常实用。有一件非常重要的事情要记住，没有什么可以阻止事件循环。例如，我们不能使用同步的标准JDBC。为了通过JDBC与数据库对话，我们需要使用<a class="ae kw" href="http://vertx.io/docs/vertx-jdbc-client/java/" rel="noopener ugc nofollow" target="_blank"> vert.x-jdbc-library </a>。</p><p id="29cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">SockJS提供了web socket的抽象。如果浏览器支持web套接字，SockJS将使用web套接字。但是如果浏览器不支持web套接字，SockJS会使用特定于浏览器的传输协议在客户机和服务器之间建立连接。</p><h2 id="2955" class="ky kz iq bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">示例应用程序</h2><p id="c70c" class="pw-post-body-paragraph jy jz iq ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">我们将实现一个可以在多个浏览器中使用的计数器。每点击一次<em class="kx">增量</em>按钮将增加值，且该变化将被传播到其他浏览器。</p><p id="fe18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当用户点击<em class="kx"> Increment </em>按钮时，客户端与服务器对话，服务器递增该值，并使用web套接字将更改推送到所有连接的浏览器。然后客户端显示更新后的号码。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><h2 id="fdf4" class="ky kz iq bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">客户端</h2><p id="de93" class="pw-post-body-paragraph jy jz iq ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">让我们首先创建客户端HTML和JavaScript。HTML文件需要包含对SockJS的引用，这是<a class="ae kw" href="https://github.com/ondrej-kvasnovsky/vertx-sockjs-counter/blob/master/webroot/js/vertx-eventbus.js" rel="noopener ugc nofollow" target="_blank"> vertx-eventbus </a>所需要的。事件总线用于简化SockJS和Vert.x服务器之间的交互。</p><blockquote class="mc md me"><p id="e030" class="jy jz kx ka b kb kc kd ke kf kg kh ki mf kk kl km mg ko kp kq mh ks kt ku kv ij bi translated">我们<!-- -->可以把HTML和JavaScript文件放到项目目录下的webroot中。Vertx服务器会将这些提供给浏览器。</p></blockquote><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mi mb l"/></div></figure><p id="9d3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的客户端应用程序应该运行在web浏览器中。所以我们需要用JavaScript实现应用程序逻辑。加载HTML页面时，调用<em class="kx"> init() </em>函数。</p><p id="544a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">init函数创建新的事件总线。在后台，事件总线将使用SockJS创建一个与使用web套接字的服务器的连接。如果web套接字不可用，SockJS将使用浏览器协议来创建连接。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mi mb l"/></div></figure><p id="f155" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当用户点击<em class="kx"> Increment </em>按钮时，<em class="kx"> increment() </em>方法被执行，一条新消息被推送到服务器。我们已经在服务器上的地址中定义了<em class="kx">，它将用于接收来自客户端的消息。<em class="kx"> out </em>地址将用于相反的用途，即从服务器向客户端发送消息。</em></p><blockquote class="mc md me"><p id="6022" class="jy jz kx ka b kb kc kd ke kf kg kh ki mf kk kl km mg ko kp kq mh ks kt ku kv ij bi translated">地址可以包含动态值，如ID。然后我们在服务器上使用正则表达式匹配这个地址。</p></blockquote><h2 id="2837" class="ky kz iq bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">服务器端</h2><p id="70b0" class="pw-post-body-paragraph jy jz iq ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">我们将创建一个HTTP服务器，它将能够通过web浏览器打开web套接字连接。</p><p id="9d10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将创建一个可在vert.x上部署的vertice。vertice类似于servlets，但它们的工作方式<a class="ae kw" href="http://tutorials.jenkov.com/vert.x/verticles.html" rel="noopener ugc nofollow" target="_blank">不同</a>。</p><p id="f7db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当创建一个verticle时，我们将启动HTTP服务器和创建路由器映射的代码放到<em class="kx"> start() </em>方法中。</p><p id="b962" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们得到与顶点服务器相关联的路由器。我们定义了URL映射以及什么处理程序应该与该路由相关联。然后我们添加staticHandler，它将提供在<em class="kx"> webroot </em>目录中定义的任何内容。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mi mb l"/></div></figure><p id="2e6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们需要一个地方来存储服务器上的数据。我们将使用<em class="kx"> SharedData </em>在已部署的垂直市场上可用。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mi mb l"/></div></figure><p id="b585" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让这个应用程序工作所需的最后一个类是一个将监听和产生消息的处理程序。每当客户端向服务器发送消息时，调用<em class="kx"> handle </em>方法，事件类型设置为<em class="kx"> SEND </em>。然后，我们从vertx提供的共享数据中获取当前值。我们递增该值，然后将其保存回共享数据实例。值更新后，我们<em class="kx">为客户端发布</em>一条新消息。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mi mb l"/></div></figure><p id="e7b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用Gradle进行依赖和构建管理。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mi mb l"/></div></figure><p id="0939" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以运行一个Gradle任务来从控制台启动服务器。</p><pre class="lw lx ly lz gt mj mk ml mm aw mn bi"><span id="beb6" class="ky kz iq mk b gy mo mp l mq mr">$ gradle run</span></pre><p id="5fda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们可以在几个web浏览器中打开<a class="ae kw" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>，尝试单击按钮，看看计数器值是如何递增的，然后被推送到所有客户端。</p><h2 id="f686" class="ky kz iq bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">发展</h2><p id="d22e" class="pw-post-body-paragraph jy jz iq ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">我们可以用<em class="kx"> main </em>方法创建一个类，用我们的verticle启动Vert.x服务器。从IDE中运行这个类可能比运行Gradle任务更方便一些。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mi mb l"/></div></figure><p id="2ca7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章中使用的源代码可以在<a class="ae kw" href="https://github.com/ondrej-kvasnovsky/vertx-sockjs-counter" rel="noopener ugc nofollow" target="_blank"> github </a>上获得。</p></div></div>    
</body>
</html>