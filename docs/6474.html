<html>
<head>
<title>Easy Modular Monolith — Part 6 — Synchronous communication between modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简易模块化整体结构—第6部分—模块间的同步通信</h1>
<blockquote>原文：<a href="https://itnext.io/easy-modular-monolith-part-5-synchronous-communication-between-modules-7af876f06c16?source=collection_archive---------0-----------------------#2021-11-28">https://itnext.io/easy-modular-monolith-part-5-synchronous-communication-between-modules-7af876f06c16?source=collection_archive---------0-----------------------#2021-11-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1a2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kl translated">你的模块有时不得不相互交流。<br/>本文将使用直接引用和RESTFull风格展示模块间同步通信的两种方式。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ku"><img src="../Images/7f7b32854b323fe5feff05fb47c14be5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-b1tCgh8OUX3ScM-s7kL4A.jpeg"/></div></div></figure><blockquote class="lg lh li"><p id="a2c4" class="jn jo lj jp b jq jr js jt ju jv jw jx lk jz ka kb ll kd ke kf lm kh ki kj kk ij bi translated">同步通信是一种实时通信，意味着我们必须等待响应，直到走得更远。</p></blockquote><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/c91d6c83efe7f90af08b189d15149fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*y881-2uWGaYr_EDZoVOs0w.jpeg"/></div></figure><p id="288d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果没有响应或发送响应有任何问题，调用者将引发一个异常。这种类型的通信是典型的客户端-服务器应用程序。</p><p id="b19e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于复杂的架构，如微服务或模块化整体架构，尽管这种通信是最简单、最容易实现的，但它也有其缺点，如潜在的性能问题，或者最关键的问题是级联故障(环境中一个模块故障会导致所有其他模块死亡)。尽管如此，它仍被广泛使用，所以今天，我们将在ModularMonolith中实现两个可能的变体。</p><h1 id="2cab" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">背景:</h1><p id="fb49" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">在上一篇文章中，我们添加了一个存储用户信息的用户模块。让我们想象一下，每次我们想在<strong class="jp ir"> ProductModule，</strong>中保存一个新产品时，我们也想保存是谁做的信息。</p><ul class=""><li id="b7e4" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated">这里需要注意的是，我们不想在每次保存新产品时都复制并保存完整的用户信息。(如果有人在UserModule中更新用户的数据，将很难保持数据的一致性)。</li><li id="e763" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">出于同样的原因，我们不想从UserModule复制用户表。</li></ul><p id="8062" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，我们将——在<strong class="jp ir"> ProductModule </strong>中——只保存执行某个方法的用户的全局id；因此，我们稍后将能够获取详细信息。</p><h1 id="e1f8" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">改进:</h1><p id="6051" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">首先，让我们通过用两个新字段扩展用户类来改进用户模块。为此，我们需要从<strong class="jp ir"> IdentityUser </strong> (ASP核心身份用户类)继承，然后注册我们的新类而不是IdentityUser。看一看:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="9f10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们应该用一个新的AppUser类替换所有IdentityUser实例。(我已经帮你做了:)。</p><p id="44ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们向我们的JWT令牌添加一个新字段—它将存储全局用户Id — UserId变量(<strong class="jp ir">第36行</strong>)。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="ac30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至此，让我们创建一个用户上下文类，它将允许从JWT令牌中提取UserId。此类将在根基础结构项目中注册；因此将在每个模块中提供。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="6b50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第19行</strong> —从HtppContext的用户上下文中，我们提取一个在登录到应用程序时添加的声明。</p><p id="21f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的——让我们看看如何使用它:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5400" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们注入<strong class="jp ir">iuser context</strong>——然后调用一个getter UserId。<br/>非常简单——现在我们有了关于调用<strong class="jp ir"> AddProductCommand </strong>的UserId的信息。有了变量，我们可以把它传递给<strong class="jp ir">产品。新的</strong>方法。</p><p id="8f18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们很好——关于用户的信息片段已经被保存。</p><h1 id="80dd" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">沟通</h1><p id="411a" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">现在，由于我们在<strong class="jp ir"> ProductModule </strong>中保存了关于用户的信息，所以在查询产品时，我们必须获取保存的用户的详细信息。</p><p id="302d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们创建一个名为<strong class="jp ir">modularmonolith . user . contracts .<br/></strong>的新项目。该项目将为UserModule希望与其他模块共享的方法存储接口。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/37abc24089507e8befb1df0abd48cf61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*qaikYMtAGWw5jhutwa_pLw.png"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">契约</figcaption></figure><p id="e70e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，UserModule将实现一个契约的接口(<strong class="jp ir"> IUserService或IUserApi </strong>)，并将其注册到<strong class="jp ir"> WebApi </strong>(应用程序入口点)中的实现中。然后将它注入ProductModule将允许我们访问来自<strong class="jp ir"> UserModule </strong>的数据。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi nm"><img src="../Images/f4fad2be1dffa06d8b786de518cb1027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SrChDk845CkYn1akt76m4w.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">模块间的通信</figcaption></figure><h1 id="87f7" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">两种交流方式</h1><h2 id="7e47" class="nn lp iq bd lq no np dn lu nq nr dp ly jy ns nt mc kc nu nv mg kg nw nx mk ny bi translated">通过引用直接通信</h2><p id="3c88" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">直接沟通是通过引用一个项目到另一个项目来进行的沟通。在我们的例子中，我们将使用运行时引用。</p><p id="08ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">编译时引用</strong>表示用户模块。应用程序项目必须由ProductModule引用。应用程序项目能够获取数据。这个引用将创建一个非常难看的耦合，并增加对UserModule查询/命令的访问。我们不会走这条路。</p><p id="6f53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">运行时引用</strong>是我们一直在<strong class="jp ir">modular mono with</strong>中使用的东西。<strong class="jp ir">生产模块</strong>不会引用整个<strong class="jp ir">用户模块</strong>，只会引用一个小而整洁的<strong class="jp ir">用户模块。合同</strong>项目。<strong class="jp ir">用户模块。项目只包含对实现的抽象。当我们运行一个应用入口点项目(<strong class="jp ir"> WebApi项目</strong>)时，它会注册实现；因此，它被称为运行时引用—直到应用程序运行时，实现才为人所知。这要干净得多，因为我们只共享这种情况下必需的方法和dto。</strong></p><p id="6dcc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="986f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir">用户模块中。我们将创建一个返回用户详细信息的新查询。重要的是(<strong class="jp ir">第14行)</strong>这个查询处理程序实现了我们的契约接口<strong class="jp ir"> IUserService。<br/> </strong>我们有我们的方法，让我们看看如何使用它:</strong></p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/34b22182634fc3f1113a005a2eaece30.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*3ICrfJ8cqPUny0Qy3Pg_yg.png"/></div></figure><p id="81b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们引用一个用户模块。ProductModule中的合同。应用项目。<br/>然后让我们在<strong class="jp ir">GetProductQueryHandler:</strong>中使用我们的新接口</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5889" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将<strong class="jp ir"> IUserService </strong>注入到构造函数中，然后在<strong class="jp ir">第31行，</strong>我们所做的就是调用一个方法GetUserDetails，传递一个我们之前保存的UserId。</p><h2 id="ad58" class="nn lp iq bd lq no np dn lu nq nr dp ly jy ns nt mc kc nu nv mg kg nw nx mk ny bi translated">宁静的交流</h2><p id="30dc" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">如果我们想为迁移到微服务准备ModularMonolith，我们想使用HTTP请求，而不是使用直接通信。类似于我们在用户模块中实现的直接通信。契约让我们创建一个契约接口:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="ee76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个和<strong class="jp ir"> IUserService </strong>最大的区别在于:</p><ul class=""><li id="51a1" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated">它定义了一个带有资源路由的REST方法。</li><li id="6092" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">它使用了一个Refit，一个伟大的RESTFull库，允许定义强类型的、基于接口的契约。</li></ul><p id="d99e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们声明了一个将用于交付数据的端点，所以让我们在UserController中创建它。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="0247" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第36行——如您所见，它类似于Controller中的所有其他方法。重要的是，该方法执行GetUserDetailsQuery的<strong class="jp ir">和GetUserDetailsQueryHandler将处理的</strong>。相同的一个返回数据用于直接通信。<br/>如果我们向上滚动一会儿到GetProductQueryHandler，我们会注意到我们在那里注入了一个<strong class="jp ir"> IUserApi </strong>接口，然后像调用<strong class="jp ir"> IUserService </strong>一样调用它。</p><h2 id="ede1" class="nn lp iq bd lq no np dn lu nq nr dp ly jy ns nt mc kc nu nv mg kg nw nx mk ny bi translated">用户模块启动</h2><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5b55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第31行</strong> —我们所做的就是将一个基本URL指向我们的ModularMonolith实例，并注册<strong class="jp ir"> IUserApi </strong>以在每次执行来自它的方法时请求这个基本URL。</p><p id="18c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第39行</strong>—<strong class="jp ir">iuserserieve</strong>实施登记。这一行简单的代码注册了一个将在运行时为GetUserDetails方法执行的处理程序。如果我们在<strong class="jp ir"> IUserServcie </strong>契约中有更多的方法(因为现在只有GetUserDetails)，而不是在处理程序级别实现它，我们将创建一个单独的UserService类来处理我们的案例。</p><h1 id="f2a2" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">摘要</h1><p id="9def" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">在本文中，我展示了在模块化整体架构中实现模块间同步通信的两种方法。</p><p id="2ba9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们应该记住，每次我们需要与另一个模块通信时，我们都会创建一个耦合，如果没有理由地引入并且设计正确，将来会带来很多麻烦。这样，如果您注意到一个模块必须与另一个模块共享大量数据，您应该考虑将其合并为一个模块。</p><h2 id="a4df" class="nn lp iq bd lq no np dn lu nq nr dp ly jy ns nt mc kc nu nv mg kg nw nx mk ny bi translated">主要区别:</h2><p id="c2c8" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">IUserService 将执行一个进程内调用并返回数据。<br/> <strong class="jp ir"> IUserApi </strong>将对用户控制器执行HTTP Get请求并执行。</p><h2 id="c5b9" class="nn lp iq bd lq no np dn lu nq nr dp ly jy ns nt mc kc nu nv mg kg nw nx mk ny bi translated">选哪个？</h2><p id="930d" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">如果您不准备迁移到微服务，我建议坚持直接沟通，因为这样更直接。作为迁移到微服务的中间阶段，我会使用基于HTTP的通信。</p><p id="57b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有一种沟通方式涉及到我们对数据一致性看法的改变。在以后的文章中，我们将研究异步通信，何时以及为什么使用它。</p><h1 id="20c2" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">完整代码可在此处获得:</h1><div class="oa ob gp gr oc od"><a href="https://github.com/Ridikk12/ModularMonolith/tree/modules_communication" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">GitHub-ridikk 12/ModularMonolith at模块_通信</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">模块化整体建筑风格的一步一步的方法。第一部分…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">github.com</p></div></div><div class="om l"><div class="on l oo op oq om or le od"/></div></div></a></div><h1 id="2076" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">上一个:</h1><div class="oa ob gp gr oc od"><a rel="noopener  ugc nofollow" target="_blank" href="/easy-modular-monolith-part-5-jwt-authentication-authorization-f7a0a275226f"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">简易模块化整体结构—第5部分— JWT认证/授权</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">在ModularMonolith中，我们将使用JSON Web令牌和Asp核心身份实现身份验证和授权。</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">itnext.io</p></div></div><div class="om l"><div class="os l oo op oq om or le od"/></div></div></a></div><h1 id="9628" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">在下一部分:</h1><ul class=""><li id="7fb3" class="mr ms iq jp b jq mm ju mn jy ot kc ou kg ov kk mw mx my mz bi translated">域事件。</li></ul><h1 id="163d" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">将来(此列表可能会更改):</h1><ul class=""><li id="2304" class="mr ms iq jp b jq mm ju mn jy ot kc ou kg ov kk mw mx my mz bi translated">异步通信。</li><li id="016c" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">发件箱改进。</li><li id="4494" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">单元/集成测试。</li><li id="8b4d" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">存储配置。</li><li id="d734" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">数据库方法(多个数据源)。</li><li id="08e5" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">准备微服务(用RabbitMq代替MediatR)。</li><li id="2df3" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">迁移到微服务。</li></ul><h1 id="34d4" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">参考资料:</h1><div class="oa ob gp gr oc od"><a href="https://github.com/reactiveui/refit" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">GitHub - reactiveui/refit:的自动类型安全REST库。NET Core、Xamarin和。网络…</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">的自动类型安全REST库。NET Core、Xamarin和. NET。深受Square的改造库的启发…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">github.com</p></div></div><div class="om l"><div class="ow l oo op oq om or le od"/></div></div></a></div></div></div>    
</body>
</html>