<html>
<head>
<title>Monitoring Secure Coroutines and WebFlux Reactive applications with Prometheus, Grafana, and InfluxDB — A webcams example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Prometheus、Grafana和InfluxDB监控安全协同程序和WebFlux反应式应用程序—网络摄像头示例</h1>
<blockquote>原文：<a href="https://itnext.io/monitoring-secure-coroutines-and-webflux-reactive-applications-with-prometheus-grafana-and-b99dafb59a4b?source=collection_archive---------2-----------------------#2022-09-03">https://itnext.io/monitoring-secure-coroutines-and-webflux-reactive-applications-with-prometheus-grafana-and-b99dafb59a4b?source=collection_archive---------2-----------------------#2022-09-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/></div><div class="ab cl jq jr hx js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="im in io ip iq"><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi jx"><img src="../Images/007909b6037737a9240062f8d600cdd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kvwiqe7l4U_9cMlV4ZGDsQ.png"/></div></div></figure><p id="b614" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">在过去的几年里，我们已经看到人们对使用安全的应用程序越来越感兴趣，并让它们变得像T2一样反应迅速。为此，多年来开发了许多技术，今天最流行的似乎是<strong class="kl iu">Spring<em class="lh"/>web flux<em class="lh"/></strong>和<strong class="kl iu"><em class="lh">kot Lin</em>Coroutines</strong>。正如我将在本文中展示的，这两种技术互为补充，可以在同一个<strong class="kl iu"> JVM生态系统</strong>中生存。正如你可能已经注意到的，关于哪一个提供最佳性能的讨论已经有很多次了，但是本质上它们都假定了相同的原则，那就是尽可能地避免任何阻碍<strong class="kl iu">的东西。</strong> <strong class="kl iu"> WebFlux </strong>利用<strong class="kl iu">观察器模式</strong>使用<strong class="kl iu"> Flux </strong>和<strong class="kl iu"> Mono </strong>来交付<strong class="kl iu">集合</strong>和<strong class="kl iu">单个对象</strong>和<strong class="kl iu">协程</strong>使用<strong class="kl iu">流</strong>和<strong class="kl iu">暂停</strong> <strong class="kl iu">函数</strong>来分别交付完全相同的内容。</p><p id="ae3f" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">在这篇文章中，我们将研究密切监视应用程序行为的许多方法之一，并使用<strong class="kl iu"> Prometheus </strong>作为数据收集器，使用<strong class="kl iu"> InfluxDB </strong>作为持久性机制，使用<strong class="kl iu"> Grafana </strong>来可视化我们的数据。本文的<a class="ae li" href="https://github.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank">项目</a>位于<a class="ae li" href="https://github.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank"> <strong class="kl iu"> GitHub </strong> </a>上。</p><p id="2995" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">当开发一个应用程序时，假设我们可以直接进入生产环境，因为单元测试(<strong class="kl iu"> TDD </strong> — <strong class="kl iu">测试驱动开发</strong>)和集成测试没有检测到任何问题仍然是非常危险的。即使一个有经验的测试人员已经尽了最大努力来测试应用程序，并且已经做了所有必要的业务逻辑检查，我们仍然依赖于人的因素，我们仍然没有考虑系统或网络问题。<strong class="kl iu"> BDD </strong> ( <strong class="kl iu">行为驱动开发</strong>)作为一种防止生产中错误的手段，多次出现在等式中。鉴于<strong class="kl iu"> BDD </strong>检查运行环境的行为，总是有额外的可靠性元素。用于实现这一点的典型已知框架是黄瓜。</p><p id="9760" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">在一个案例场景中，仅考虑数字，这给了企业一种我们投入生产有多安全的感觉，就是我们有大约90%的代码覆盖率，我们覆盖了IDE(集成开发环境)没有检测到的逻辑，BDD测试很好，我们有一个高超和超专业的<strong class="kl iu"> DDD </strong> ( <strong class="kl iu">域驱动设计</strong>)专家，他向我们保证所有的架构和边界都符合<strong class="kl iu"> PO </strong> ( <strong class="kl iu">产品所有者的所有期望我们也很自豪有这样一个团队，每个人都熟记所有的软件设计模式</strong>，并在他们的日常开发中使用和思考它们。此外，每个人都知道如何实现和使用<strong class="kl iu">固体</strong> ( <strong class="kl iu">单责任、开-闭、利斯科夫-替换、接口隔离、依赖注入)和酸(原子性、一致性、隔离性、持久性</strong>)原则。</p><p id="df74" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">一切似乎都很好，我们进入生产，然后我们意识到应用程序并没有真正做它应该做的事情。此外，它似乎显示了各种意想不到的行为。在这些场景中，问题很可能是我们对<strong class="kl iu"> CPU </strong>、<strong class="kl iu"> GPU </strong>、内存使用、<strong class="kl iu"> GC(垃圾收集)</strong>、<strong class="kl iu">安全性</strong>没有任何顾虑，这样的例子不胜枚举。我们没有检查应用程序的停机时间，没有检查应用程序的弹性、可用性和健壮性。我们也不知道在并发、多用户以及实际需要多少数据流入和流出我们的应用程序的情况下该怎么办。</p><p id="8803" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated"><strong class="kl iu">监控</strong>可以为预防这些情况提供很多帮助。</p><h1 id="8ddf" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">1.技术要求</h1><p id="480c" class="pw-post-body-paragraph kj kk it kl b km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc ml le lf lg im bi translated">对于本文来说，如果您对Spring和Spring Boot有一些经验和了解，将会很有帮助，尽管这不是必需的。我们将检查实现的完整细节，所以如果你不知道一些基础知识，那么不要担心，因为我会尽力保持简单。真正重要的是在您的计算机上安装以下软件:</p><ul class=""><li id="f599" class="mm mn it kl b km kn kq kr ku mo ky mp lc mq lg mr ms mt mu bi translated">Java 17 (任何java <strong class="kl iu"> 17 </strong>发行版都可以。我最好的建议是用<a class="ae li" href="https://sdkman.io/usage" rel="noopener ugc nofollow" target="_blank"> SDK Man </a>来实现这个，用<strong class="kl iu"> 17开。</strong></li><li id="eda3" class="mm mn it kl b km mv kq mw ku mx ky my lc mz lg mr ms mt mu bi translated"><strong class="kl iu">最新</strong> <a class="ae li" href="https://gradle.org/install/" rel="noopener ugc nofollow" target="_blank"> <strong class="kl iu">最新</strong> </a>(至少7.5版本才能兼容Java 17)</li><li id="dbf0" class="mm mn it kl b km mv kq mw ku mx ky my lc mz lg mr ms mt mu bi translated">一个好的<strong class="kl iu">IDE</strong>(<a class="ae li" href="https://www.jetbrains.com/idea/download/" rel="noopener ugc nofollow" target="_blank"><strong class="kl iu">IntelliJ</strong></a><strong class="kl iu">或</strong> <a class="ae li" href="https://www.eclipse.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kl iu">月食</strong> </a>为例)</li><li id="cfa3" class="mm mn it kl b km mv kq mw ku mx ky my lc mz lg mr ms mt mu bi translated"><a class="ae li" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank"> <strong class="kl iu"> Docker桌面</strong> </a> <strong class="kl iu"> </strong>，但前提是你用的是面向办公的机器，用的是类似<strong class="kl iu"> MAC-OS </strong>或者<strong class="kl iu"> Windows </strong>这样的系统。我最好的建议是，如果可能的话，就用一台12核的Linux机器。</li></ul><h1 id="7d8b" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">2.文章目标</h1><p id="a310" class="pw-post-body-paragraph kj kk it kl b km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc ml le lf lg im bi na translated">谈到监控，我们通常会做一些假设。这很简单，不需要太多的时间来设置，我们只是想检查系统是否正常。此外，还有一个普遍的假设，那就是我们不应该把它弄得太复杂。的确，在某种程度上，这些都是有道理的。另一方面，如果我们考虑在我们的环境中实现监控实际需要做些什么，那么我们很快就会意识到，要实现监控，有相当多的活动部件。让我们从更高的层面来思考我们需要什么:</p><ol class=""><li id="5411" class="mm mn it kl b km kn kq kr ku mo ky mp lc mq lg nj ms mt mu bi translated">我们需要度量标准</li><li id="e7da" class="mm mn it kl b km mv kq mw ku mx ky my lc mz lg nj ms mt mu bi translated">我们希望在我们的系统中有这些指标</li><li id="5ae1" class="mm mn it kl b km mv kq mw ku mx ky my lc mz lg nj ms mt mu bi translated">我们需要获取指标</li><li id="2dd2" class="mm mn it kl b km mv kq mw ku mx ky my lc mz lg nj ms mt mu bi translated">我们需要存储指标</li><li id="b9f1" class="mm mn it kl b km mv kq mw ku mx ky my lc mz lg nj ms mt mu bi translated">我们需要将这些指标可视化</li><li id="9220" class="mm mn it kl b km mv kq mw ku mx ky my lc mz lg nj ms mt mu bi translated">我们需要一个警报系统</li><li id="05aa" class="mm mn it kl b km mv kq mw ku mx ky my lc mz lg nj ms mt mu bi translated">我们的系统不应该在性能方面受到任何损害</li></ol><p id="4f65" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">看一下第1点，大多数情况下，我们<strong class="kl iu">确定我们需要指标</strong> s。现在我们需要努力思考<strong class="kl iu"> <em class="lh">“我们需要哪些指标】</em> </strong>？我们需要监控<strong class="kl iu">垃圾收集</strong>吗？我们需要<strong class="kl iu">监控资源</strong>吗？我们需要监控<strong class="kl iu">内存使用情况</strong>吗？也许我们需要所有这些指标，或者也许我们已经直接知道我们想要监控什么。事先知道我们想要什么是好的。对于第2点和第3点，我们需要确保我们已经考虑了使用推或拉机制的<strong class="kl iu">。在本文中，我们将看看<strong class="kl iu">拉动机制</strong>。我们将在普罗米修斯和InfluxDB中看到这一点。拉机制的最大优点是，一旦我们的应用程序开始运行，我们就可以通过在特定的可配置时间点<strong class="kl iu">废弃</strong>数据，随时控制我们想要接收的内容。推送机制意味着应用程序不断地通过网络发送指标，即使我们想要缩减我们的指标获取机制。在其他订单中，监控总是会对<strong class="kl iu">应用程序性能</strong>产生一个小的<strong class="kl iu">凹痕</strong>，但是如果我们使用拉动机制，我们可以缩小这个凹痕。重要的是使性能的下降完全可以忽略不计。接下来，在第4点，我们需要存储我们的数据。<strong class="kl iu">抓取</strong> <strong class="kl iu">机制</strong>，多次与<strong class="kl iu">短命存储引擎</strong>一起到来。这些引擎之所以如此命名，是因为它们可以通过重新启动来重置，它们只保存在内存中，它们有一个滚动日志，或者仅仅是因为它们没有很好地设计来保存数据。这就是普罗米修斯的故事。虽然它确实有持久化数据的规定，但它仍然是非常基础的，并且在他们自己的话<a class="ae li" href="https://prometheus.io/docs/prometheus/latest/storage/" rel="noopener ugc nofollow" target="_blank"><strong class="kl iu"/></a><strong class="kl iu">:</strong>中有一些限制</strong></p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi nk"><img src="../Images/43f5a8354a0661e9779a4d5c158fa1ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RYTRDhnAYlG65MChh8AqBw.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">普罗米修斯语录</figcaption></figure><p id="9a79" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">出于这些原因，我们需要系统中的另一个元素来确保我们的数据的<strong class="kl iu">寿命</strong> <strong class="kl iu">是由我们而不是系统决定的。在我们的例子中，我们将通过<strong class="kl iu"> InfluxDB </strong>来实现这一点。一旦我们的数据被存储，我们现在需要一个干净简单的方法来可视化数据。这是第五点。在许多系统中，可视化软件还允许我们配置第6点的需求。警报系统通常与我们正在使用的可视化界面密切相关。这就是我们将看到Grafana </strong>行动的地方。就第7点而言，这本身就是一种谬误。性能总会有很小的下降<strong class="kl iu">,正如我们上面讨论的那样，这应该是可以忽略的。我们也可以说，如果这种减少是不可察觉的，那是因为它不存在。这是一个公平的观点，完全有道理，但思考这个问题很重要。错误配置的监控解决方案会导致<strong class="kl iu">延迟问题</strong>和<strong class="kl iu">使应用程序无响应</strong>或者甚至导致<strong class="kl iu">系统关闭</strong>。</strong></p><h1 id="5cf8" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">3.领域</h1><p id="6da5" class="pw-post-body-paragraph kj kk it kl b km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc ml le lf lg im bi na translated">我们的服务是真实系统的模拟。理想情况下，我们会监视博物馆里的物品。我们可以监控经过河流的船只的位置，检查机场的天气，音乐会上人们的富裕程度，等等。如果我们有一台相机，我们可以想象成千上万的情况下，我们可以用它们做什么。在这个<a class="ae li" href="https://github.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank">项目</a>中，我们会让它变得非常简单。我们将在木地板上监视蔬菜！这样，除了我们项目的目标之外，其他什么都不重要。</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div class="gh gi np"><img src="../Images/0917412700cdad312d1ef0cdd875e99d.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*uTTkWKyYWYK7XYiKP2CKrA.jpeg"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">半路上的一个南瓜</figcaption></figure><p id="cc9e" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">一个服务将提供两个资源端点。一个端点将为您提供某个相机在给定时间拍摄的图像。另一个端点提供我们正在拍摄的对象的信息。对于我们的应用程序，我们对分离这些信息不感兴趣。相反，我们希望以聚合的方式访问这些信息。我们也不希望前端做所有的硬聚合工作。这个处理应该留给一个新的服务来完成，这个新的服务将包装这个“原始数据”服务并提供所需的聚合信息。一旦我们有了这项服务，我们希望能够用前端应用程序来可视化我们的数据。</p><p id="1b74" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">所以现在我们知道我们至少需要三种服务。一个用于原始数据，一个用于聚合数据，另一个用于向用户提供GUI(图形用户界面)。因此，我们还需要能够监控这些服务。这意味着我们将需要至少三个不同的度量提供者作为这三个服务的助手。</p><p id="da5b" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">我们为3家指标提供商提供3项服务，因此我们需要一台刮刀来可视化这些数据。一旦我们有了scrapper，我们还希望能够可视化这些数据，我们还希望能够存储这些数据。所以这意味着我们将需要另外3个服务。一个scrapper、一个visualizer和一个持久性服务。下面是这种工作方式的粗略示意图:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi nq"><img src="../Images/a26271c26e91dbef578ea424862653d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rmo9gFAh1o0MDQGlixuy4Q.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><a class="ae li" href="https://github.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank">移动物体项目</a>的DDD设计</figcaption></figure><h1 id="8602" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">4.履行</h1><p id="e753" class="pw-post-body-paragraph kj kk it kl b km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc ml le lf lg im bi na translated"><span class="l nb nc nd bm ne nf ng nh ni di"> L </span> et开始制作我们的<a class="ae li" href="https://gitlab.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank">应用</a>！我们要看的案例是一个监视物体运动的系统。</p><blockquote class="nr ns nt"><p id="546c" class="kj kk lh kl b km kn ko kp kq kr ks kt nu kv kw kx nv kz la lb nw ld le lf lg im bi translated">在本文的<strong class="kl iu">上一个</strong> <strong class="kl iu">版本</strong>中，摄像机由<strong class="kl iu"/><a class="ae li" href="https://rapidapi.com/" rel="noopener ugc nofollow" target="_blank"><strong class="kl iu">RapidAPI</strong></a>的两个<strong class="kl iu">其余</strong>接口提供。一个提供了机场列表，另一个提供了机场周围的公共摄像头。这些是<a class="ae li" href="https://rapidapi.com/cometari/api/airportsfinder" rel="noopener ugc nofollow" target="_blank"> <strong class="kl iu">机场搜索器</strong> </a> <strong class="kl iu"> API </strong>和<a class="ae li" href="https://rapidapi.com/webcams.travel/api/webcams-travel" rel="noopener ugc nofollow" target="_blank"> <strong class="kl iu">网络摄像头旅游</strong> </a> <strong class="kl iu"> API </strong>。然而，由于这些应用程序是外部的，我无法控制它们。我也无法控制模型中的任何变化，或者应用程序是否会因为这样或那样的原因变成私有的、订阅的、试用的或任何其他形式的非公开访问。在某个时间点，这篇文章的<strong class="kl iu"> </strong> <a class="ae li" href="https://gitlab.com/jesperancinha/moving-objects-service-root/-/tree/rapid-api-eol" rel="noopener ugc nofollow" target="_blank"> <strong class="kl iu">原示例</strong> </a>实际上变成了<strong class="kl iu">不可用、</strong> <strong class="kl iu">不可编译</strong>，当然<strong class="kl iu">也不可能制作演示</strong>了。</p></blockquote><p id="1237" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">这意味着，现在，我们有了一个<strong class="kl iu">在<strong class="kl iu">位置网格</strong>上监视移动物体</strong>的例子，而不是监视机场周围的<strong class="kl iu">位置。我简单地给这些<strong class="kl iu">蔬菜</strong>拍了几张照片，来创造一个<strong class="kl iu">运动的想法</strong>。</strong></p><p id="4b63" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">为了让事情变得更有趣，我创建了两个rest应用程序:</p><ul class=""><li id="c002" class="mm mn it kl b km kn kq kr ku mo ky mp lc mq lg mr ms mt mu bi translated"><code class="fe nx ny nz oa b"><strong class="kl iu">moving-objects-jwt-service</strong></code> —安全应用，<strong class="kl iu">支持JWT </strong>，提供两个独立的端点。一个传送物体/蔬菜<strong class="kl iu">信息</strong>，另一个传送二维网格中的<strong class="kl iu">摄像机位置</strong>。该应用程序在端口<strong class="kl iu"> 8081 </strong>打开。这个应用已经用<a class="ae li" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"><strong class="kl iu"/></a>和<strong class="kl iu"> Kotlin Webflow协同程序</strong>实现了。它使用一个<strong class="kl iu">r2dbc</strong>T28】连接来对抗端口<strong class="kl iu"> 5432 </strong>上的<strong class="kl iu"> PostgreSQL </strong>数据库。</li><li id="b97c" class="mm mn it kl b km mv kq mw ku mx ky my lc mz lg mr ms mt mu bi translated"><code class="fe nx ny nz oa b"><strong class="kl iu">moving-objects-rest-service</strong></code> —这个服务于<strong class="kl iu">前端</strong>应用，面向用户。我们可以选择用<strong class="kl iu"> OAuth2 </strong> <strong class="kl iu"> Okta </strong>认证能力来启动它。它将进行身份验证，以便与JWT服务进行通信。它在端口<strong class="kl iu"> 8082 </strong>上运行。这个应用已经用<a class="ae li" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>和<a class="ae li" href="https://docs.spring.io/spring-framework/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/html/web-reactive.html" rel="noopener ugc nofollow" target="_blank"> WebFlux </a>实现了。</li></ul><p id="f25b" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">我还创建了一个<strong class="kl iu">图形用户界面</strong>。在这种情况下，我使用<a class="ae li" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kl iu"/></a>和<strong class="kl iu">【UX】</strong>(<strong class="kl iu">用户</strong> <strong class="kl iu">经验</strong>)设计实现我使用<a class="ae li" href="https://material.angular.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kl iu">有角度的材料</strong> </a>。</p><p id="6544" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">创建这两个rest服务的原因是因为我发现这是一种很好的展示监控活动的方式。我们让一个服务依赖于另一个，边缘服务的目标是聚合两个信息源。因此，我们可以分析更多不同的数据行为案例。出于同样的原因，我也实现了<a class="ae li" href="https://oauth.net/2/" rel="noopener ugc nofollow" target="_blank"> <strong class="kl iu"> OAUTH2 </strong> </a>。换句话说，我希望一个服务有不同于另一个服务的行为。我们将在本文的结尾看到这一点。</p><h1 id="be24" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">5.应用程序设置</h1><p id="2fdd" class="pw-post-body-paragraph kj kk it kl b km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc ml le lf lg im bi na translated"><span class="l nb nc nd bm ne nf ng nh ni di">在</span>这一节中，我们将了解应用概述、所有内容的设置以及容器化的环境。</p><p id="3a93" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">让我们从应用概述开始。</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi ob"><img src="../Images/557865c06bff5ed984c9574a71f535b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B4vlbTFzxmBQhOdWmHHjGQ.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">系统概述草图</figcaption></figure><p id="7b6d" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">在这个简化的概述中，我们可以看到，在我们获得任何数据之前，我们要经历3个服务。我们有一个<strong class="kl iu"> angular服务</strong>运行在<strong class="kl iu"> NGINX </strong>上，提供前端，一个rest服务器提供<strong class="kl iu"> okta认证</strong>以提供对<strong class="kl iu">聚合</strong>数据的访问，最后，一个服务使用<strong class="kl iu"> JWT </strong>提供<strong class="kl iu">原始数据</strong>以安全地访问它。</p><p id="af5c" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">让我们仔细看看容器化的环境是什么样的。在我们之前的需求列举中，我们看到我们至少需要4样东西。我们需要三个应用程序环境、一个数据资源、一个永久的持久化机制和一个用于监控数据的可视化环境。在我们的案例中，这些是:</p><ul class=""><li id="f3bd" class="mm mn it kl b km kn kq kr ku mo ky mp lc mq lg mr ms mt mu bi translated"><a class="ae li" href="https://www.oracle.com/java/technologies/downloads/" rel="noopener ugc nofollow" target="_blank"><strong class="kl iu">JRE 17</strong></a><strong class="kl iu">—</strong>我们将在两个服务中使用这个运行时。正如我们之前看到的，一个在数据源域中运行，另一个在聚合器域中运行。在每个环境中，我们不仅要运行应用程序，还要运行指标服务，作为spring-boot应用程序的辅助工具。Spring boot可以打包像Prometheus提供的外部库，并在它的执行器端点中使用它们。</li><li id="a95a" class="mm mn it kl b km mv kq mw ku mx ky my lc mz lg mr ms mt mu bi translated"><a class="ae li" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"><strong class="kl iu">NGINX</strong></a><strong class="kl iu">—</strong>有了NGINX，我们可以将我们的前端部署为一个静态可交付产品。它在UX领域运行。</li><li id="be53" class="mm mn it kl b km mv kq mw ku mx ky my lc mz lg mr ms mt mu bi translated"><a class="ae li" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> <strong class="kl iu">节点</strong></a><strong class="kl iu">——</strong>节点JS使我们能够运行Prometheus服务，为Prometheus scrapper提供指标。它在度量领域中运行。运行时不必与运行它的机器共享同一个域。有了Node，我们可以启动一个服务，不一定要获得NGINX的指标，而是它运行的机器。</li><li id="c1f9" class="mm mn it kl b km mv kq mw ku mx ky my lc mz lg mr ms mt mu bi translated"><a class="ae li" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kl iu">普罗米修斯</strong></a><strong class="kl iu">——</strong>这就是格斗家。在这种情况下，scrapper只是一个以固定时间间隔运行的进程，一个从目标机器检索重要指标的报废进程。它在度量领域中运行。</li><li id="4908" class="mm mn it kl b km mv kq mw ku mx ky my lc mz lg mr ms mt mu bi translated"><a class="ae li" href="https://docs.influxdata.com/" rel="noopener ugc nofollow" target="_blank"><strong class="kl iu">influx db</strong></a><strong class="kl iu">——</strong>这是我们的坚持机制。InfluxDB也有能力配置废料。它们的运行方式和普罗米修斯一样，但是我们可以存储数据。它包括自己的指标可视化应用程序。它既在度量领域也在UX领域运行</li><li id="ddd0" class="mm mn it kl b km mv kq mw ku mx ky my lc mz lg mr ms mt mu bi translated"><a class="ae li" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank"><strong class="kl iu"/></a><strong class="kl iu">——</strong>这是我们的可视化工具。我们可以可视化所有被普罗米修斯抛弃的需要的度量。它运行，当然在UX领域。</li></ul><p id="cb87" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">我们可以让所有东西分别在我们的本地机器上运行，但是我们也可以通过使用<a class="ae li" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kl iu"> Docker </strong> </a>映像和<a class="ae li" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"><strong class="kl iu">Docker</strong><strong class="kl iu">compose</strong></a>来加快开发过程。除了速度之外，另一大优势是我们可以在单个<strong class="kl iu"> docker机器</strong>中用一个命令运行整个环境。</p><p id="6ae8" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">让我们来看看我们系统的更详细版本:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi oc"><img src="../Images/b7d49c373dd572afaa9a5aa5efc2a287.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cvJeVNJaCxh5GDHFLo_rVg.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll">使用Docker进行本地主机配置</strong></figcaption></figure><p id="a712" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">如图所示，我们所有的移动部件都装在<strong class="kl iu">本地主机</strong>上的一台机器中。使用<strong class="kl iu"> Docker </strong>时无需额外配置。从图中可以注意到，应该属于公共域的端口只有<strong class="kl iu"> 3000、9090、</strong>和<strong class="kl iu"> 8080 </strong>。在本地环境中，我们将公开所有端口。在本文的后面，我们将看到这个<a class="ae li" href="https://github.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank">项目</a>的安全版本是如何工作的。为此，我们还需要端口<strong class="kl iu"> 8082 </strong>。所有其他端口都在<strong class="kl iu"> docker </strong>域<strong class="kl iu">内</strong>。每个容器通过我们给它们起的名字来识别彼此。我们将在文章的后面看到如何将这个系统翻译成docker-compose。</p><h1 id="2a0d" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">6.数据模型</h1><p id="a19a" class="pw-post-body-paragraph kj kk it kl b km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc ml le lf lg im bi na translated">我们的数据模型非常简单。我们只有两张桌子。一个包含对象信息，另一个包含移动对象信息:</p><pre class="jy jz ka kb gt od oa oe bn of og bi"><span id="c966" class="oh lk it oa b be oi oj l ok ol">create schema if not exists mos;<br/><br/>drop table if exists mos.moving_object;<br/>drop table if exists mos.info_object;<br/><br/>create table if not exists mos.moving_object(<br/>    id UUID,<br/>    code VARCHAR ( 50 ) NOT NULL,<br/>    folder VARCHAR ( 255 ) UNIQUE NOT NULL,<br/>    uri VARCHAR(255 ) UNIQUE NOT NULL,<br/>    x INT,<br/>    y INT,<br/>    PRIMARY KEY (id)<br/>);<br/><br/>create table if not exists mos.info_object(<br/>    id UUID,<br/>    "name" VARCHAR(50) UNIQUE NOT NULL,<br/>    "size" INT,<br/>    color VARCHAR ( 255 ) NOT NULL,<br/>    code VARCHAR ( 50 ) NOT NULL,<br/>    x INT,<br/>    y INT,<br/>    PRIMARY KEY (id)<br/>);</span></pre><p id="377c" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">两个<strong class="kl iu">表</strong>共享一个代码。这些代码将数据统一在一起。然而，这个数据t不是一起提供给前端的。相反，我们单独提供这些数据。表<code class="fe nx ny nz oa b"><strong class="kl iu">moving_object</strong></code> <strong class="kl iu">，</strong>可以解释为位置，在此处具有某个<code class="fe nx ny nz oa b"><strong class="kl iu">code</strong></code> <strong class="kl iu"> </strong>的对象正在被拍摄。<code class="fe nx ny nz oa b"><strong class="kl iu">uri</strong></code>是提供正在拍摄的最新<strong class="kl iu">快照</strong>的相机的<code class="fe nx ny nz oa b"><strong class="kl iu">location</strong></code>。参数<code class="fe nx ny nz oa b"><strong class="kl iu">folder</strong></code> <strong class="kl iu"> </strong>是保存图像的实际位置。这个最新的<strong class="kl iu">快照</strong>将通过一个流端点传送到客户端。显然，<code class="fe nx ny nz oa b"><strong class="kl iu">x</strong></code>和<code class="fe nx ny nz oa b"><strong class="kl iu">y</strong></code>是物体的坐标。表格<code class="fe nx ny nz oa b"><strong class="kl iu">info_object</strong></code>仅仅包含了被拍摄物体的额外信息。对于这个<a class="ae li" href="https://github.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank">项目</a>的一个对象，有关于其<strong class="kl iu">名称</strong>、<strong class="kl iu">大小</strong>、<strong class="kl iu">颜色、</strong>和<strong class="kl iu">位置</strong>的特殊信息。该位置在这里也用坐标<strong class="kl iu"> x </strong>和<strong class="kl iu"> y </strong>表示。这样做的原因是为了区分相机的位置和物体的位置。话虽如此，我们也可以说我们拍摄的物体的坐标并不那么重要。</p><p id="f82f" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated"><a class="ae li" href="https://github.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank">项目的开始</a>将在数据库中加载以下数据:</p><pre class="jy jz ka kb gt od oa oe bn of og bi"><span id="dca3" class="oh lk it oa b be oi oj l ok ol">truncate mos.mos.moving_object;<br/><br/>insert into mos.mos.moving_object (id,  code, folder, uri,x,y)<br/>values (gen_random_uuid(), 'GAR', 'garlic', '/aggregator/webcams/camera/GAR',1,2);<br/>insert into mos.mos.moving_object (id,  code, folder, uri,x,y)<br/>values (gen_random_uuid(), 'LAU', 'laurel', '/aggregator/webcams/camera/LAU',2,2);<br/>insert into mos.mos.moving_object (id,  code, folder, uri,x,y)<br/>values (gen_random_uuid(), 'LEM', 'lemon', '/aggregator/webcams/camera/LEM',3,4);<br/>insert into mos.mos.moving_object (id,  code, folder, uri,x,y)<br/>values (gen_random_uuid(), 'ONI', 'onion', '/aggregator/webcams/camera/ONI',7,2);<br/>insert into mos.mos.moving_object (id,  code, folder, uri,x,y)<br/>values (gen_random_uuid(), 'PUM', 'pumpkin', '/aggregator/webcams/camera/PUM',8,1);<br/>insert into mos.mos.moving_object (id,  code, folder, uri,x,y)<br/>values (gen_random_uuid(), 'RED', 'red-onion', '/aggregator/webcams/camera/RED',3,6);<br/>insert into mos.mos.moving_object (id,  code, folder, uri,x,y)<br/>values (gen_random_uuid(), 'SNA', 'snail', '/aggregator/webcams/camera/SNA',1,7);<br/>insert into mos.mos.moving_object (id,  code, folder, uri,x,y)<br/>values (gen_random_uuid(), 'TOM', 'tomato', '/aggregator/webcams/camera/TOM',0,1);<br/><br/>insert into mos.mos.info_object(id, "name", size, color, code,x,y)<br/>values (gen_random_uuid(), 'Garlic', 2, 'white', 'GAR', 1, 2);<br/>insert into mos.mos.info_object(id, "name", size, color, code,x,y)<br/>values (gen_random_uuid(), 'Laurel', 4, 'green', 'LAU', 2, 2);<br/>insert into mos.mos.info_object(id, "name", size, color, code,x,y)<br/>values (gen_random_uuid(), 'Lemon', 2, 'lemon', 'LEM', 3, 4);<br/>insert into mos.mos.info_object(id, "name", size, color, code,x,y)<br/>values (gen_random_uuid(), 'Onion', 4, 'gold', 'ONI', 7, 2);<br/>insert into mos.mos.info_object(id, "name", size, color, code,x,y)<br/>values (gen_random_uuid(), 'Pumpkin', 10, 'orange', 'PUM', 8, 1);<br/>insert into mos.mos.info_object(id, "name", size, color, code,x,y)<br/>values (gen_random_uuid(), 'Red Onion', 5, 'purple', 'RED', 3, 6);<br/>insert into mos.mos.info_object(id, "name", size, color, code,x,y)<br/>values (gen_random_uuid(), 'Snail', 1, 'brown', 'SNA', 1, 7);<br/>insert into mos.mos.info_object(id, "name", size, color, code,x,y)<br/>values (gen_random_uuid(), 'Tomato', 2, 'red','TOM', 0, 1);</span></pre><h1 id="aa2e" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">7.密码</h1><p id="e707" class="pw-post-body-paragraph kj kk it kl b km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc ml le lf lg im bi translated">如果你已经在<a class="ae li" href="https://github.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上瞥过<a class="ae li" href="https://gitlab.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank"> <strong class="kl iu">代码</strong> </a>，你可能已经看到每个模块的代码库相当小，但是所有代码的连接可能有点复杂难以理解。这一部分在这里，以便我们可以一起看到代码是如何构建的，以及我们想要实现什么。也许最好的办法是，首先看看<code class="fe nx ny nz oa b"><strong class="kl iu">moving-objects-jwt-service</strong></code> <strong class="kl iu"> </strong>中的数据域:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi om"><img src="../Images/ec53547b30b3d8e91d5fe8ca48b02199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9F-4qvz2_lPTRJ8QH1gbiQ.jpeg"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll">Dao UML for</strong>T1】</figcaption></figure><p id="bcef" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">在这个<strong class="kl iu"> UML </strong>图中并没有太多的特别之处。本质上我们只有两种不同的类型，我们称它们为<strong class="kl iu">移动对象</strong>和<strong class="kl iu">信息对象</strong>。摄像机在一个<strong class="kl iu"> x </strong>，<strong class="kl iu"> y </strong>网格中以与物体相同的方式获得一个位置。我们认为<strong class="kl iu">移动物体</strong>就是<strong class="kl iu">摄像机</strong>正在拍摄的。我们可以也将会互换使用这些术语来指代同一事物。<strong class="kl iu"> InfoObject </strong>只是关于对象的一些信息。在这种情况下，它只是对象的大小、颜色和最新位置。在这个<a class="ae li" href="https://github.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank">项目</a>中，最新位置从不改变。虽然<strong class="kl iu"> JWT </strong>服务大部分是使用协程数据<strong class="kl iu">流</strong>实现的，但是我想在同一个<a class="ae li" href="https://github.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank">项目</a>中使用<strong class="kl iu"> WebFlux </strong>来展示两者可以以同样的方式协同工作。尽管它们的反应式实现不同，但它们可以协同工作，我们可以利用它们提供的不同特性。在我的例子中，我真的想利用<strong class="kl iu"><em class="lh">collectsorted list</em></strong>函数从一个类型为<strong class="kl iu"> <em class="lh"> MovingObject </em> </strong>的对象列表中创建一个反应性的<strong class="kl iu"> <em class="lh"> Mono </em> </strong>。许多人喜欢使用<strong class="kl iu"><em class="lh">JpaSpecificationExecutor</em></strong>来一口气获得一整页。不幸的是，如果我们这样做，那么我们得到的是一个非反应性的页面。这可能最终并不重要，因为实际上一个<strong class="kl iu">页面</strong>只是返回给客户端的一条记录。然而，我希望这个应用程序服务无论如何都是完全反应式的。因此，我没有返回一个<strong class="kl iu">页面，而是返回了一个<strong class="kl iu"> Mono &lt;页面&gt; </strong>，它使得应用程序的使用可能是完全反应式的。</strong></p><p id="439a" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">既然我们已经看了模型，现在让我们看看控制器部分:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi on"><img src="../Images/7bb6b809fe8ae343b4b5ea15cd12c010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NyrnCpf90In6_otck3YjWg.jpeg"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll"> REST UML for </strong> <code class="fe nx ny nz oa b"><strong class="bd ll">moving-objects-jwt-service</strong></code></figcaption></figure><p id="b362" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">我们以非常特殊的方式将数据转换成dto，但从未将物体信息与相机联系起来。在我们的例子中，我们将一个位置与包含在其特定半径内的所有摄像机相关联。这将为我们提供特定搜索的所有相机的完整列表，但不是与它们的大小和颜色相关的对象信息。这是针对一个端点。对于另一个端点，我们可以获得对象的信息。有了这个，我们就能知道物体的位置、颜色和大小。这个rest服务不提供相机和对象信息的聚合。</p><p id="b1da" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">这项服务也需要通过安全访问。对于这个<a class="ae li" href="https://github.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank">项目</a>，我们让它变得非常简单，当我们运行它时，我们会得到一个警告，我们正在使用一个在<code class="fe nx ny nz oa b">application.properties</code>中明文配置的用户/密码组合。通常，安全服务提供安全的方式要复杂得多。让我们快速看一下代码:</p><pre class="jy jz ka kb gt od oa oe bn of og bi"><span id="b6fd" class="oh lk it oa b be oi oj l ok ol">@Bean<br/>fun securityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain =<br/>    http<br/>        .logout { logout -&gt;<br/>            logout<br/>                .requiresLogout(ServerWebExchangeMatchers.pathMatchers(HttpMethod.GET, "/logoff"))<br/>        }<br/>        .authorizeExchange { authorize -&gt;<br/>            authorize<br/>                .pathMatchers("/webjars/**")<br/>                .permitAll()<br/>                .pathMatchers("/info/jwt/open/**")<br/>                .permitAll()<br/>                .pathMatchers("/webcams/jwt/open/**")<br/>                .permitAll()<br/>                .pathMatchers("/v3/**")<br/>                .permitAll()<br/>                .pathMatchers("/actuator/**")<br/>                .permitAll()<br/>                .anyExchange()<br/>                .authenticated()<br/>        }<br/>        .csrf().disable()<br/>        .httpBasic(Customizer.withDefaults())<br/>        .oauth2ResourceServer { oAuth2ResourceServerSpec -&gt; oAuth2ResourceServerSpec.jwt() }<br/>        .build()</span></pre><p id="0d63" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">我们在这里所做的是首先允许所有匹配模式公开。这些模式涉及应用程序的3个重要方面:Swagger、Actuator和测试端点。<strong class="kl iu"> Swagger </strong>允许我们通过一个GUI与应用程序交互，这个GUI允许我们执行请求，而不需要使用<code class="fe nx ny nz oa b"><strong class="kl iu">curl</strong></code>或任何其他命令行指令，如<code class="fe nx ny nz oa b"><strong class="kl iu">wget</strong></code>。<strong class="kl iu">致动器</strong>端点对我们的<a class="ae li" href="https://github.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank">项目</a>至关重要，因为它提供了包括普罗米修斯理解和使用的指标在内的指标。<strong class="kl iu"> CSRF </strong>在我们的应用中必须禁用。Spring文档非常清楚为什么大多数情况下都是这样:</p><blockquote class="nr ns nt"><p id="093e" class="kj kk lh kl b km kn ko kp kq kr ks kt nu kv kw kx nv kz la lb nw ld le lf lg im bi translated"><a class="ae li" href="https://docs.spring.io/spring-security/site/docs/5.0.x/reference/html/csrf.html" rel="noopener ugc nofollow" target="_blank">如果您仅创建非浏览器客户端使用的服务，您可能需要禁用CSRF防护。</a></p></blockquote><p id="066f" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">我们的令牌的身份验证将通过一个特定的端点来请求，我们将在后面看到。现在，我只是想让你明白，通过我们的配置，我们可以使用<strong class="kl iu">用户名/密码</strong>组合或<strong class="kl iu"> JWT </strong>令牌来访问我们的任何端点。然而，<strong class="kl iu"> JWT </strong>令牌将仅通过令牌端点给出。不过，我们用<strong class="kl iu"><em class="lh">OAuthResourceServerSpec</em></strong>来保护我们的应用程序。这允许我们配置几种类型的安全设置，但是为了本文的目的，我们只创建标准的<strong class="kl iu"> JWT </strong>支持。</p><p id="8d00" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">反应式编程还意味着反应式安全性，因为安全性是与我们对服务的任何请求固有地绑定在一起的。其原理与非反应式应用完全相同。我们首先配置我们的<strong class="kl iu"><em class="lh">AuthenticationManager</em></strong>:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi oo"><img src="../Images/fc9c947958df5514ff4e030d728f7299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CXGNsOsd4cVDXcl_LDrqVA.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">被动身份验证管理器</figcaption></figure><p id="1bd0" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">然后，我们需要为JWT令牌本身以及我们用来获取应用程序的初始JWT请求的密码配置编码器和解码器:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi nk"><img src="../Images/d3f7acae9cd9c9d9cdbe1ca88048efa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H5qQzLJtHoxstb10BsX05g.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll">JWT休息服务的编解码器</strong></figcaption></figure><p id="930f" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">一旦我们有了代码，我们现在就可以配置我们的用户详细信息服务:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi op"><img src="../Images/2b391ddacf6b23b9d6340d14e0281843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pubU1bvTwfIPJsaXLW1KyA.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll">用户详细信息服务</strong></figcaption></figure><p id="acc2" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">我们已经可以看到，这个UserDetailsService与它的<strong class="kl iu"> Servlet </strong>对应物有所不同(我们也用街头语言MVC做了这些)。不同之处在于，这种服务是以一种被动的方式实现的。我们在这里使用Netty而不是Tomcat作为嵌入式服务。这意味着<strong class="kl iu"> Netty </strong>以一种被动的方式工作，这意味着我们可以以一种被动的方式实现对服务的调用。这反过来又提高了我们机器的能力，因为它将能够同时处理更多的请求，即使涉及到安全性。在我们的例子中，我们的服务由用户名/密码保护。提醒自己此时可以更好地实现安全性总是好的。我们非常不安全的<strong class="kl iu"> admin/admin </strong>组合足以满足这个练习的目的。</p><p id="f4c1" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">现在让我们来看看我们将面向前端的<strong class="kl iu">服务</strong>。在这个服务的全功能版本中，我们将使用<strong class="kl iu"> Okta </strong>来执行<strong class="kl iu"> OAuth </strong>认证。对于端到端测试，<strong class="kl iu"> Okta </strong>将被禁用，但是我们将检查整个应用程序。我们的应用程序叫做<code class="fe nx ny nz oa b"><strong class="kl iu">moving-objects-rest-service</strong></code> <strong class="kl iu"> </strong>。与前一个应用程序的第一次接触显然是从数据层开始的:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi oq"><img src="../Images/502cec2eb32d2aab722fd134fa099b14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EllmUpIpAzCLLF406xLd0w.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><a class="ae li" href="https://github.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank"> <strong class="bd ll">道层的秋田项目</strong> </a></figcaption></figure><p id="d4cd" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">仔细观察这些类型，我们可以看到它们与在<a class="ae li" href="https://github.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank"> <strong class="kl iu"> JWT </strong> <strong class="kl iu">项目</strong>中创建的Dto有多么直接的关系。</a></p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi or"><img src="../Images/c9bd030d5db332291ea497bf1a7b5ee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b-Yaaiu6tmL_h2r4Ssu2pA.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><a class="ae li" href="https://github.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank"> <strong class="bd ll">秋田项目服务层</strong> </a></figcaption></figure><p id="245f" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">在上面的服务层中，我们看到每个端点都有专用的服务，在它旁边，我们使用了一个<strong class="kl iu"><em class="lh">objectaggregaterservice</em></strong>。该服务将创建我们感兴趣的有效负载。聚合遵循了一些与<strong class="kl iu">反应式编程</strong>相关的有趣实现。让我们来看看几种方法:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi nk"><img src="../Images/20bd8e06d34136052064bae7758a4ba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NzBh0AGEUC1xjA1Xg18tww.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll">创建移动对象到</strong></figcaption></figure><p id="e1ea" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">在本例中，我们使用的是纯粹的<strong class="kl iu"> Spring </strong> <strong class="kl iu"> WebFlux </strong>。我们首先通过搜索词来搜索对象信息。第二步，我们通过半径搜索与之相关的位置。因此，换句话说，我们将检索我们通过<strong class="kl iu">搜索词</strong>搜索的<strong class="kl iu">对象</strong>的特定半径内包含的所有摄像机。我们必须永远不要忘记，当使用<strong class="kl iu">协程</strong> <strong class="kl iu">流</strong>或<strong class="kl iu"> WebFlux </strong>时，我们不是在进行命令式编程，也不是在进行<strong class="kl iu"> OOP </strong>(面向对象编程)。我们正在使用<strong class="kl iu">功能编程</strong>，实现<strong class="kl iu">可观察模式、</strong>并使用<strong class="kl iu">反应原则</strong>。这意味着代码不会立即执行，而是在<strong class="kl iu"> Netty </strong>空闲时执行。在这一点上，提醒我们自己，通过在我们的依赖项中只使用Spring WebFlux库，我们在默认情况下不再使用Tomcat，这可能是很好的。我们在这一点上使用Netty。我想在这里发表声明的原因是，我们经常看到人们将Tomcat与Spring Boot互换使用。然而，SpringBoot不一定是由<strong class="kl iu"> Tomcat </strong>运行的。可以用<strong class="kl iu">逆流</strong>和<strong class="kl iu">突堤</strong>运行，在<strong class="kl iu">无功服务的情况下，</strong>可以用<strong class="kl iu"> Netty </strong>运行。在高级类型的服务实现中进行这种区分是很重要的。</p><p id="588c" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">我们现在可以快速看一下控制器层的样子:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi os"><img src="../Images/03fea38488e77ad6074fbe115d038831.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EHGOwvLGV1Axhn6Hxdz0Lw.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll">Okta服务的控制器层</strong></figcaption></figure><p id="e0a6" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">这一层允许我们使用具有以下形式的有效载荷:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi ot"><img src="../Images/3f107e207a0907b227c02d8c5266c7a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z1qEwuHFu4dG1XGjIUs6Rw.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll">为前端应用服务的有效载荷示例</strong></figcaption></figure><p id="714c" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">正如我们所看到的，我们提供了对象的细节，也提供了相机的细节。因此，我们以一种反应式的方式将两个端点聚合成一个，由<strong class="kl iu"> Netty </strong>管理。</p><p id="658f" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">最后，我们可以看看可选安全性是如何用okta实现的。我们唯一需要做的就是首先添加okta库和一些额外有用的库:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi ou"><img src="../Images/428fa36b42cd76d35ec916fea9000df1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-roG-mAFhF6VaFkFEJV7ew.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll">用于提供安全的依赖关系</strong></figcaption></figure><p id="3c29" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">实际相关的依赖项当然是<strong class="kl iu"> okta-spring-boot-starter </strong>库。其他的很重要，因为它们提供支持。它们本身是不必要的。然而，它们对于<a class="ae li" href="https://gitlab.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank">项目</a>的当前<a class="ae li" href="https://gitlab.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank">版本</a>及其库版本是必要的。最后一个库，<code class="fe nx ny nz oa b"><strong class="kl iu">moving-objects-security-dsl</strong></code>，是我创建的一个非常小的库，只允许<strong class="kl iu"> Okta </strong>安全配置在库存在时发生。试图通过spring profiles禁用okta被认为是一件奇怪的事情，而且对这个<a class="ae li" href="https://gitlab.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank">项目</a>做这样的事情没有帮助。所以这个库只包含一个类:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi nk"><img src="../Images/f0a2001dfc7f4f39494564264bec9632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g-lqRzT0mRVMRSHIUnzYuw.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll">安全端点配置</strong></figcaption></figure><p id="9f65" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">还可以制作一个配置文件为<strong class="kl iu"> prod </strong>的<strong class="kl iu"> Bean </strong>和另一个配置文件为<strong class="kl iu"> test </strong>的Bean，然后让<strong class="kl iu"> test </strong> bean成为一个完全开放的网站，类似于<code class="fe nx ny nz oa b"><strong class="kl iu"><em class="lh">pathMatchers(“/**”).permitAll()</em></strong></code>。然而，这样做仍然意味着<strong class="kl iu"> okta </strong> <strong class="kl iu">初始化</strong>无论如何，以及某种程度的<strong class="kl iu">不可预测性</strong>我发现对于这个<a class="ae li" href="https://gitlab.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank">项目</a>的目的来说是不合理的，并且由于<strong class="kl iu"> Gradle </strong>在以我们想要的方式配置程序集方面是惊人的，因此我创建了一个参数可配置的构建，使用:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi ov"><img src="../Images/49f03ffe6fa1073563f8614ea6da374c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t77j30yjB0Nxp5r437JiYw.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll">带梯度的可配置构建</strong></figcaption></figure><p id="e50e" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">SpringBoot中的配置非常简单:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi ov"><img src="../Images/55de40fd86e9ff9783f7afcbbfc8af47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fQ3qchdS82cFfNuyjfEdjA.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll"> Okta配置</strong></figcaption></figure><p id="083d" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">有了这个，如果我们想运行应用程序的安全版本，我们可以用下面的命令行创建我们的构建:</p><pre class="jy jz ka kb gt od oa ow ox aw oy bi"><span id="60ff" class="oz lk it oa b gy pa pb l pc ol"><strong class="oa iu">gradle -Pprod clean build</strong></span></pre><p id="b119" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">最后，模块<code class="fe nx ny nz oa b"><strong class="kl iu">moving-objects-gui</strong></code>为我们提供了一个图形用户界面，在这里我们可以可视化我们的应用程序。我们不会详细讨论它，但重要的是要理解我们将把它部署在<strong class="kl iu"> NGINX，</strong>中，并且我们还想监控那台机器。</p><h1 id="7eb7" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">8.监控端点</h1><p id="52aa" class="pw-post-body-paragraph kj kk it kl b km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc ml le lf lg im bi na translated"><span class="l nb nc nd bm ne nf ng nh ni di">在</span>的前几个步骤中，我们已经了解了架构是如何设计的，也了解了我们的领域。我们还看了一下代码，深入了解了<strong class="kl iu">实现</strong>的一些有趣的方面。我们应该对<strong class="kl iu">系统</strong>此刻正在做什么以及所有的<strong class="kl iu">运动部件</strong>是如何工作的有一个非常清楚的了解。我们现在将逐步了解监控系统的所有要素。在本文的这一部分，记住这个系统可以在本地机器上运行是很重要的。所有移动部件都是<strong class="kl iu"/><a class="ae li" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"><strong class="kl iu">docker-compose</strong></a>设置的一部分。</p><p id="3154" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">在这篇文章中，我想做一个易于理解和修改的例子，这就是为什么每个组件都有自己的自定义图像。</p><p id="7eb2" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">同样，让我们记住，我展示的例子发生在我们成功运行<strong class="kl iu"> docker-compose </strong>之后。在本文的后面，我们将讨论细节。现在，让我们记住我们可以运行两个版本的系统。对于安全版本，我们可以运行:</p><pre class="jy jz ka kb gt od oa ow ox aw oy bi"><span id="51bd" class="oz lk it oa b gy pa pb l pc ol"><strong class="oa iu">make dcup-full-action-secure</strong></span></pre><p id="8ccb" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">或者，如果我们想在没有okta的情况下运行它，我们可以运行:</p><pre class="jy jz ka kb gt od oa ow ox aw oy bi"><span id="9dc9" class="oz lk it oa b gy pa pb l pc ol"><strong class="oa iu">make dcup-full-action</strong></span></pre><p id="dba1" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">现在，让我们看看如何在不同的容器中配置指标。对于我们的例子，我们有3个具有重要指标配置需求的容器。他们是<code class="fe nx ny nz oa b"><strong class="kl iu">moving-objects-jwt-service</strong></code>、<code class="fe nx ny nz oa b"><strong class="kl iu">moving-objects-rest-service</strong></code>和<code class="fe nx ny nz oa b"><strong class="kl iu">moving-objects-gui</strong></code>、<strong class="kl iu">、T22。对于前两个服务，我们需要为<strong class="kl iu"> Spring Boot </strong>配置<strong class="kl iu">普罗米修斯</strong>:</strong></p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi ou"><img src="../Images/1eae5f2b120800cfd81355d91debf55f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J6uzoR_BQSt4ECy7miXmEw.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll">千分尺依赖性</strong></figcaption></figure><p id="0e54" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">这是在<a class="ae li" href="https://www.timescale.com/blog/four-types-prometheus-metrics-to-collect/" rel="noopener ugc nofollow" target="_blank"> <strong class="kl iu">普罗米修斯格式</strong> </a>中写入和显示所有指标所需的千分尺相关性。为了激活它，我们还需要激活<strong class="kl iu"> Spring Boot的致动器</strong>。尽管如此，这仍然不会打开<strong class="kl iu">端点</strong>。这些实际上只是允许生成<strong class="kl iu">端点</strong>的库。</p><p id="73a0" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">为了打开我们的<a class="ae li" href="https://gitlab.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank">项目</a>中的<strong class="kl iu">端点</strong>，我们需要为此显式配置<strong class="kl iu"> Spring Boot </strong>:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi pd"><img src="../Images/85a394004081e63f2c1b7bf6a4626ee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eybOPr0vjiB3-W05PmqbHw.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll">启用包括普罗米修斯在内的指标</strong></figcaption></figure><p id="c3dc" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">两个rest服务包含相同的配置。需要<strong class="kl iu">致动器</strong>是因为它提供了重要的<strong class="kl iu">度量</strong>，这些度量来自<strong class="kl iu"> Spring Boot </strong>中的框，并且已经可以被普罗米修斯<strong class="kl iu"> <em class="lh">间接</em> </strong>读取。来自<code class="fe nx ny nz oa b"><strong class="kl iu">io.micrometer</strong></code>内核和<code class="fe nx ny nz oa b"><strong class="kl iu">prometheus</strong></code>库的千分尺属性使用与<strong class="kl iu"> Prometheus </strong>相同的<strong class="kl iu">格式</strong>提供度量。这使得在<strong class="kl iu"> Prometheus </strong>流程中从指标端点读取数据更加容易。</p><p id="af4f" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">有了这些简单的配置行，我们就可以<strong class="kl iu">创建</strong> <strong class="kl iu">端点</strong>，并且<strong class="kl iu">激活</strong>其他跟踪机制。所有这些管理点都是<strong class="kl iu"> Spring Boot致动器</strong>的一部分。然而，<strong class="kl iu">普罗米修斯执行机构</strong>的端点只有在<strong class="kl iu"> Spring Boot执行机构</strong>存在的情况下<strong class="kl iu">才会自动配置</strong>。这就是同时需要测微计库和致动器库的原因。</p><p id="5738" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">普罗米修斯有自己的刮刀。他们将针对Spring Boot应用程序运行流程，并定期收集所有这些指标。我们也可以制定自己的指标，并通过<strong class="kl iu">致动器</strong>使其可用。有许多不同的方法可以做到这一点，其中一个例子就是使用trace。在我们的指标中，我们可以找到这个端点:</p><ul class=""><li id="903d" class="mm mn it kl b km kn kq kr ku mo ky mp lc mq lg mr ms mt mu bi translated"><a class="ae li" href="http://localhost:8080/objects/actuator/metrics/http.server.requests" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/objects/actuator/metrics/http . server . requests</a></li></ul><p id="4d8f" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">观察结果我们发现:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi pe"><img src="../Images/76543dc76d3677e41e42e14837206f51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xe4peYrzMuzjZnn2o55U1Q.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll">未更改跟踪请求的有效负载</strong></figcaption></figure><p id="089b" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">这里我们有<strong class="kl iu"> COUNT </strong>，<strong class="kl iu"> TOTAL_TIME，</strong>和<strong class="kl iu"> MAX </strong>。本质上，这些是对应用程序发出的请求数<strong class="kl iu">，它们响应的总时间<strong class="kl iu"/>，以及从请求得到响应的最大时间<strong class="kl iu"/><strong class="kl iu"/>。这些都是重要的指标。有了这些指标，我们可以知道有多少人在关注我们的web应用程序。对于收视率，这是一个非常方便的指标。我们想要监控我们的应用程序的性能。使用<strong class="kl iu">总时间</strong>可以是一个选项。有了<strong class="kl iu">普罗米修斯</strong>，我们有了比这更好的选择，但是因为我们有了<strong class="kl iu">计数</strong>和<strong class="kl iu">总时间</strong>，我们实际上可以得到某个端点的<strong class="kl iu">平均响应时间</strong>。如图所示，我们还可以读取端点响应的最长时间<strong class="kl iu"/>。当注意到如果一个<strong class="kl iu">端点超过</strong>一个<strong class="kl iu">特定时间</strong>来响应，那么该端点可能有延迟问题时，这可能是重要的。因此，必须采取某种措施来改善它。</strong></p><p id="02e3" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">在这些指标中，我们没有的是端点回复所需的<strong class="kl iu">最短时间</strong>。我们只是没有这方面的数据。在任何时候，我们都没有记录每个请求的时间。另一种方法是实现我们自己的<code class="fe nx ny nz oa b"><strong class="kl iu"><em class="lh">HttpTraceRepository</em></strong></code>:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi nk"><img src="../Images/3919e62c867e79e497f48c22b158fabb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LQVo6sa2MW1TIj4QYCo-Ag.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll">customtracepository</strong></figcaption></figure><p id="06a6" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">这创建了一个HTTP跟踪的实现，这是由HTTP跟踪标志启用的，正如我们之前看到的:<code class="fe nx ny nz oa b"><strong class="kl iu">management.trace.http.enabled=true</strong></code>。我们已经注意到，这个实现还带有一个存储库。简单来说，我只是创建了一个<strong class="kl iu"> FIFO(先进先出)队列</strong>。换句话说，当时我只是将<strong class="kl iu"> 10个元素</strong>保存在<strong class="kl iu">库</strong>中。这段代码只负责记录<code class="fe nx ny nz oa b"><strong class="kl iu">GET</strong></code> <strong class="kl iu"> </strong>的请求。我们可以改变这一点，对其他请求执行其他或相同的操作。</p><p id="55e2" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">这里的重点是，我们可以<strong class="kl iu">以我们喜欢的方式</strong>改变指标<strong class="kl iu">并</strong>重新编程其中一些指标<strong class="kl iu">以将<strong class="kl iu">定制的</strong>数据直接报告到<strong class="kl iu"> Prometheus </strong>或任何其他<strong class="kl iu">监控</strong>获取工具中。<strong class="kl iu">痕迹</strong>将以格式后的<a class="ae li" href="http://localhost:8080/aggregator/actuator/httptrace" rel="noopener ugc nofollow" target="_blank">为例:</a></strong></p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi nk"><img src="../Images/89a199e631900318cebdec77a1fce2f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Arqdm0DVnlt0BXr_D6p-Ew.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll">更新跟踪指标请求</strong></figcaption></figure><p id="e1fa" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">如果我们查看这个请求的最后一个元素，我们会发现<strong class="kl iu"> timeTaken </strong>。这是每个<code class="fe nx ny nz oa b"><strong class="kl iu">GET</strong></code>请求的响应时间。在这种情况下，我们的<strong class="kl iu">最小值</strong>可以是这个数组中最小值<code class="fe nx ny nz oa b"><strong class="kl iu">timeTaken</strong></code>的实现。重要的是要注意，在这种情况下，我们测量的是<strong class="kl iu">毫秒</strong>。为什么需要的时间最少？也许我们的目的是找到性能的峰值，而不是内存使用或CPU的峰值。也许，如果我们知道我们的请求什么时候更快，我们就可以识别出我们潜在的更好的代码或系统。在端点<a class="ae li" href="http://localhost:8080/aggregator/actuator/httptrace" rel="noopener ugc nofollow" target="_blank"><strong class="kl iu">http://localhost:8080/aggregator/actuator/http trace</strong></a><strong class="kl iu">上的这个<a class="ae li" href="https://gitlab.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank">项目</a>中可以访问这个端点。</strong></p><p id="0dc4" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">我们刚刚经历了<strong class="kl iu"> Spring Boot </strong>后端支持<strong class="kl iu">普罗米修斯</strong>的要点。</p><p id="f2fe" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">让我们看看<strong class="kl iu"> NodeJS </strong>如何为<strong class="kl iu">普罗米修斯</strong>提供相同的端点。在我们的例子中，我们在<strong class="kl iu"> Angular </strong>中有一个完全开发的应用程序。我们可以使用<strong class="kl iu"> NGINX </strong>直接部署它。然而，在这种情况下，<strong class="kl iu"> NGINX </strong>本身必须进行配置，以便为Prometheus提供端点。然而，<strong class="kl iu"> NodeJS </strong>通过库<code class="fe nx ny nz oa b"><a class="ae li" href="https://www.npmjs.com/package/prometheus-api-metrics" rel="noopener ugc nofollow" target="_blank"><strong class="kl iu">prometheus-api-metrics</strong></a></code>和<code class="fe nx ny nz oa b"><a class="ae li" href="https://www.npmjs.com/package/prom-client" rel="noopener ugc nofollow" target="_blank"><strong class="kl iu">prom-client</strong></a></code>提供了一个非常有趣的解决方案。</p><p id="8f67" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">代码中有一个<strong class="kl iu"> server.ts </strong>的例子，但是我们在这里只关注代码中的两个关键行:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi nk"><img src="../Images/ad6e61d74f548af12949c2c6f407f525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I5B89sLr_zCUPVQ7tu8vng.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll"> server.ts度量供应商</strong></figcaption></figure><p id="aae6" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">我们感兴趣的台词，或者我应该只说我们关心的<strong class="kl iu">一林</strong> e是:<code class="fe nx ny nz oa b"><strong class="kl iu">this.app.use(apiMetrics());</strong></code></p><p id="5104" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">整个<strong class="kl iu"> server.ts </strong>是一个运行在<a class="ae li" href="https://www.npmjs.com/package/express-serve-static-core" rel="noopener ugc nofollow" target="_blank"> <strong class="kl iu"> express </strong> </a>上的简单<strong class="kl iu"> NodeJS </strong>服务的实现。</p><p id="912b" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">我们的<strong class="kl iu"> Prometheus </strong>指标的端点可以在我们的端点运行示例中看到:</p><ul class=""><li id="b849" class="mm mn it kl b km kn kq kr ku mo ky mp lc mq lg mr ms mt mu bi translated"><a class="ae li" href="http://localhost:8080/objects/actuator/prometheus" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/objects/actuator/Prometheus</a>—<strong class="kl iu">JWT服务</strong></li><li id="2358" class="mm mn it kl b km mv kq mw ku mx ky my lc mz lg mr ms mt mu bi translated"><a class="ae li" href="http://localhost:8080/aggregator/actuator/prometheus]" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/aggregator/actuator/Prometheus</a>—<strong class="kl iu">Okta服务</strong></li><li id="f70c" class="mm mn it kl b km mv kq mw ku mx ky my lc mz lg mr ms mt mu bi translated"><a class="ae li" href="http://localhost:8080/metrics" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/metrics</a>—<strong class="kl iu">NGINX服务</strong></li></ul><p id="603f" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">度量格式如下所示:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi nk"><img src="../Images/70b9385f4d059b27b3b20b6ae7177541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XjF_TuAHDRy20mgUJPx07A.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll">Prometheus enabled披露的指标示例</strong></figcaption></figure><h1 id="37b9" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">10.设置普罗米修斯</h1><p id="a1ab" class="pw-post-body-paragraph kj kk it kl b km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc ml le lf lg im bi translated">为了让Prometheus运行起来，我们最终需要将我们讨论的所有内容配置到一个<code class="fe nx ny nz oa b"><strong class="kl iu">prometheus.yml</strong></code>文件中。我们的文件如下所示:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi pf"><img src="../Images/3f2c44bd339c3fb61599e4ce37a2afe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R0P_tF3FJV41Qst1kN7j9g.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll">完整的普罗米修斯配置文件</strong></figcaption></figure><p id="3606" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">注意，在最后，配置指向我们的<strong class="kl iu"> InfluxDB </strong>。我们会将<strong class="kl iu">报废间隔</strong>设置为15秒，并且我们会评估<strong class="kl iu">在过去30秒内的每次报废</strong>。然而，这两条线不再可用。InfluxDB 已经成长为自己的scrapper框架，开启了<strong class="kl iu">的辩论，普罗米修斯</strong>仍然是一个必要的东西。然而，在这里，我们只是看看如何配置我们的监控应用程序。重要的是，我们看到我们可以用属性<strong class="kl iu"> static_configs </strong>以YAML的方式配置我们的路由。在这三个版本中，我们配置了三个不同的作业来收集我们需要的数据。在这种情况下，废弃意味着数据可以被任何外部可视化工具访问，比如我们将在后面看到的<strong class="kl iu"> Grafana </strong>框架。</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi pg"><img src="../Images/b71d5d5d78ca618c72e92ffb823cdc88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t0tk4Wh5u41NHHvNxtvGng.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll">普罗米修斯仪表盘</strong></figcaption></figure><h1 id="319c" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">11.设置InfluxDB</h1><p id="b912" class="pw-post-body-paragraph kj kk it kl b km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc ml le lf lg im bi na translated"><span class="l nb nc nd bm ne nf ng nh ni di"> O </span>使用任何架构的最大障碍之一是持久层。Prometheus 没有提供易于配置的持久存储系统。鉴于普罗米修斯<strong class="kl iu">主要用作废品，并且正如我们之前所见，将它从短暂的数据存储系统转变为持久的数据存储系统并不容易，这是对普罗米修斯</strong>的期望。这就是为什么我们有<a class="ae li" href="https://www.influxdata.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kl iu"> InfluxDB </strong> </a>这样的数据库。这是一个专门设计用于存储指标的存储系统。目前，它提供了更多的功能，并且有自己的数据收集器，其工作方式与普罗米修斯非常相似。让我们看看如何连接到它。</p><p id="499b" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated"><strong class="kl iu"> InfluxDB </strong>不再需要连接到<strong class="kl iu"> Prometheus </strong>来存储指标。以前我们会配置<strong class="kl iu"> Prometheus </strong>通过作业的方式将数据推送到<strong class="kl iu"> InfluxDB </strong>。如今，我们只需要指标端点。然后<strong class="kl iu"> InfluxDB </strong>可以收集这些指标，甚至可以提供可视化图形和仪表板，就像<strong class="kl iu"> Grafana </strong>所做的那样。我们可以让它运行，并在我们的系统中使用它。要检查它是否真正启动并运行，我们只需运行以下命令:</p><pre class="jy jz ka kb gt od oa ow ox aw oy bi"><span id="e3d1" class="oz lk it oa b gy pa pb l pc ol"><strong class="oa iu">influx ping</strong></span></pre><p id="c335" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">为此，我们需要安装<code class="fe nx ny nz oa b"><a class="ae li" href="https://docs.influxdata.com/influxdb/v1.7/tools/shell/" rel="noopener ugc nofollow" target="_blank"><strong class="kl iu">influx client</strong></a></code>。</p><p id="827b" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">在本地启动演示时，<strong class="kl iu"> Cypress </strong>将运行当前的<strong class="kl iu"> InfluxDB </strong>安装，并创建<strong class="kl iu">铲斗和刮刀</strong>。这些将被配置为在不同端点的不同存储桶中存储数据。<strong class="kl iu"> InfluxDB </strong>自带<strong class="kl iu">普罗米修斯</strong>指标端点。从<strong class="kl iu"> GUI </strong>配置<strong class="kl iu"> InfluxDB </strong>非常容易，我认为展示这些<strong class="kl iu">桶</strong>和<strong class="kl iu">刮削器</strong>如何配置是不相关的。然而，在运行成功完成后，想象我们得到了什么是很重要的。这是我们配置存储桶后得到的结果。当我们运行<strong class="kl iu"> Cypress </strong>时，它创建的第一件事就是为我们的清除程序保存数据的桶:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi ph"><img src="../Images/997bda026f42d6f24d1006df24b8fb3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I9DHxq8f3fL0DVyPUkVK_g.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">流入DB的铲斗配置</figcaption></figure><p id="259c" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">创建铲斗后，我们现在可以创建<strong class="kl iu">刮刀</strong>:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi pi"><img src="../Images/a8bad2e5ef4b04e7530e15453265ee52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UDx3HUfP_-NEZIRAQUF0DQ.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll">涌入的废品DB </strong></figcaption></figure><p id="fd3a" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">最后，我们可以创建一个<strong class="kl iu">应用程序令牌</strong>:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi pj"><img src="../Images/8627ec6555ef3cf3064684448d81903d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O0DSZl30zH90MFe_G_Q59w.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll">流入数据库中的应用令牌</strong></figcaption></figure><p id="a82f" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">这个应用程序令牌对于<strong class="kl iu"> InfluxDB </strong>中一些非常有趣的东西是需要的，这使得它成为一个更加独立的平台。正如我们从上面看到的，<strong class="kl iu"> InfluxDB </strong>允许从我们的应用程序中主动抓取指标。这一切都很好，但我们可能想反过来。如果我们想被动地在<strong class="kl iu"> InfluxDB </strong>中接收数据，那么我们需要一个外部工具来做这件事。Prometheus 仍然有那个功能，但是，由于安全需求，实现它相当麻烦。然而，InfluxDB 允许外部引擎很容易地与其连接，包括由<strong class="kl iu"> Prometheus提供的引擎。</strong>他们都这个概念<strong class="kl iu"> Telegraf </strong>。Telegraf本质上是一种工具，它加载这些引擎，并开始主动从<strong class="kl iu">普罗米修斯</strong>有效载荷收集数据，然后<strong class="kl iu">将</strong>数据推送到<strong class="kl iu"> InfluxDB。</strong>除了<strong class="kl iu"> Telegraf </strong>之外，我们不需要下载或安装任何其他东西。为此，我们可以编辑<strong class="kl iu"> telegraf.conf </strong>文件。对于我们的<a class="ae li" href="https://gitlab.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank">项目</a>，看起来是这样的:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi pk"><img src="../Images/ed8fd4f5a31fd424d261c03a5f4b0747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9IgX4WzLBBAy8k15LzH77A.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll"> InfluxDB </strong>的Telegraf配置文件</figcaption></figure><p id="483a" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">现在最重要的事情是稍微关注一下这个文件的不言自明的参数。本质上，我们需要<strong class="kl iu">URL</strong>来让<strong class="kl iu"> telegraf </strong>知道从哪里获取我们的指标，并且我们需要指定这些指标的目的地。对于目的地，我们需要提供带有<strong class="kl iu">URL</strong>的<strong class="kl iu"> InfluxDB </strong>的位置、我们之前生成的<strong class="kl iu">令牌</strong>、组织<strong class="kl iu">和桶</strong>。了解我们在<strong class="kl iu"> InfluxDB </strong>中的位置的唯一标识符是<strong class="kl iu">组织</strong>和<strong class="kl iu">桶</strong>是很重要的。这些是强制性的。在这些参数的顶部，我们用<strong class="kl iu">输入. prometheus </strong>指定指标源端点的类型，用<strong class="kl iu">输出. influxdb_v2 </strong>指定目标类型。</p><p id="5f24" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">当运行演示时，构建将开始，然后cypress将运行并在<strong class="kl iu"> /docker-files/telegraf </strong>创建<strong class="kl iu">令牌</strong>，最后它将在<strong class="kl iu"> docker-compose </strong>的同一个网络中启动<strong class="kl iu"> telegraf </strong>容器。换句话说，这一切都将自动完成，这样我们就可以专注于如何进行设置。</p><p id="cba8" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">如果我们成功地获得了演示，并且脚本<strong class="kl iu"> make start-demo </strong>正在运行，那么我们将能够创建如下图表:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi pl"><img src="../Images/2607a44222d2c7b6cb654ce7336798b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ypPQeKeCsmPDKAYK6PN_9g.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll">influx db的仪表板可视化</strong></figcaption></figure><p id="a5ee" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">如果你注意到数据没有进来，可能是因为<strong class="kl iu"> telegraf </strong>还没有开始。我们可以通过运行以下命令再次启动<strong class="kl iu"> telegraf </strong>:</p><pre class="jy jz ka kb gt od oa ow ox aw oy bi"><span id="01c8" class="oz lk it oa b gy pa pb l pc ol"><strong class="oa iu">make start-telegraf-container</strong></span></pre><h1 id="da3d" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">12.设置Grafana</h1><p id="8d9d" class="pw-post-body-paragraph kj kk it kl b km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc ml le lf lg im bi na translated">rafana的配置方式与普罗米修斯不同。这里我们不需要任何代码。<strong class="kl iu"> Grafana </strong>纯粹是基于它与<strong class="kl iu"> Prometheus </strong>的合同。在继续之前，让我们回顾一下到目前为止我们所知道:</p><ul class=""><li id="aaf8" class="mm mn it kl b km kn kq kr ku mo ky mp lc mq lg mr ms mt mu bi translated">2个Spring Boot <strong class="kl iu">应用</strong>和1个NodeJS应用</li><li id="9ce5" class="mm mn it kl b km mv kq mw ku mx ky my lc mz lg mr ms mt mu bi translated">持久性<strong class="kl iu">指标数据库流入数据库</strong></li><li id="ee15" class="mm mn it kl b km mv kq mw ku mx ky my lc mz lg mr ms mt mu bi translated"><strong class="kl iu">Metrics scraper和管理用普罗米修斯</strong></li></ul><p id="05b7" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">我们将使用<strong class="kl iu"> Prometheus </strong>和<strong class="kl iu"> Grafana </strong>仅从Prometheus生成图形。关于如何用Grafana构建图形的详细讨论是一个独立的主题，并转移了本文的重点。重要的是要理解我们如何让我们的<strong class="kl iu"> Grafana </strong>配置也<strong class="kl iu">持久</strong>。我们希望保持图形配置的持久性，这样我们就可以在任何Grafana环境中使用它们。</p><p id="fd8e" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">当我们第一次看到Grafana时，我们立即意识到我们必须创建一个数据源。通过这个操作，我们还创建了一个<strong class="kl iu">仪表板提供者</strong>。仪表板提供商保存在位于格拉夫纳<code class="fe nx ny nz oa b"><strong class="kl iu">/etc/grafana/provisioning/dashboards/</strong></code> <strong class="kl iu"> </strong>的YAML文件中。让我们看看<strong class="kl iu"> dashboard.yml </strong>上的例子:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi pm"><img src="../Images/f8dbea33673e93b6e18e7262b03e9af5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KTwP6d91whAqzjeQwtBzdw.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll"> Grafana缓冲板配置</strong></figcaption></figure><p id="945d" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">通过这种配置，我们告诉<strong class="kl iu">Grafana</strong><strong class="kl iu">Prometheus</strong>是其第一个仪表板提供商的名称。同时，我们让Grafana知道我们将加载位于<code class="fe nx ny nz oa b"><strong class="kl iu">/etc/grafana/provisioning/dashboards</strong></code>的所有仪表板。尽管我们已经为我们的仪表板建立了一个数据提供者，但是我们仍然需要真正的端点用于<strong class="kl iu"> Prometheus </strong>。这是在我们的<strong class="kl iu"> datasource.yml </strong>文件中完成的:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi pn"><img src="../Images/64fc408d234e156f5192313ce2e9af43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RMFvqgUP9jwPzc-xTl9lSw.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">普罗米修斯<strong class="bd ll"> datasource.yml </strong></figcaption></figure><p id="a778" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">在定义了数据源和仪表板数据提供者之后，我们最终需要将所有的仪表板放在<code class="fe nx ny nz oa b"><strong class="kl iu">/etc/grafana/provisioning/dashboards</strong></code>中。Grafana提供了以<strong class="kl iu"> JSON </strong>格式保存这些仪表板的方法。它们不需要被<strong class="kl iu"> Grafana </strong>引用。只要它们还在那个文件夹中，我们就会看到<strong class="kl iu"> Grafana </strong>会读取它们。</p><p id="01e3" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">仪表板本身是相当大的文件，它们可以在文件夹<code class="fe nx ny nz oa b"><strong class="kl iu">/docker-files/grafana</strong></code>的<a class="ae li" href="https://gitlab.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank">项目</a>中找到。这两个<strong class="kl iu"> JSON </strong>文件分别是<strong class="kl iu"> NGINX </strong>机器的安装文件(<strong class="kl iu"> node-grafana.json </strong>)和<strong class="kl iu"> JVM的</strong> ( <strong class="kl iu"> jvm-grafana.json </strong>)。</p><p id="cd78" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">Grafana似乎与<strong class="kl iu"> Firefox </strong>有一些兼容性问题。我不认为它们是关键的，它们是我在<strong class="kl iu"> UX(用户体验)</strong>方面永远无法复制的东西。然而，它们确实存在，cypress测试能够检测到其中的许多错误，这就是为什么，如果我们看一下<strong class="kl iu"> commands.ts </strong>，我们将看到一些针对某些抛出错误的异常规则:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi nk"><img src="../Images/1f5e6457e6d1d8f61608db0a63ec8c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eyYUl0R21ktlpt7GYCN3cw.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">Cypress运行期间针对Firefox浏览器生成的异常</figcaption></figure><p id="bc7c" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">运行Grafana后，我们应该会得到如下图形:</p><div class="jy jz ka kb gt ab cb"><figure class="po kc pp pq pr ps pt paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><img src="../Images/8aac3a902c4dd20b4819903be227a411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*V9M5iL55rClRAW8mOZ4L2w.png"/></div></figure><figure class="po kc pu pq pr ps pt paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><img src="../Images/15217e3dfe39959316a83e2e0ab3427b.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*_cbquvc9UitAesK8X4bIIQ.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk pv di pw px translated"><strong class="bd ll">Grafana的Dasboards示例</strong></figcaption></figure></div><h1 id="f1be" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">13.Docker composer编排</h1><p id="902d" class="pw-post-body-paragraph kj kk it kl b km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc ml le lf lg im bi na translated">位于<a class="ae li" href="https://gitlab.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank">项目</a>根目录下的<strong class="kl iu"> docker-compose </strong>文件包含启动应用程序的主设置。这就是我们如何实现我们的<strong class="kl iu"> docker-compose </strong>编排，如我们的第一张图所示。</p><p id="5025" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">我之前提到了几种在本地启动这个应用程序的方法。我们可以试着一次完成。可用于此目的的脚本是开始演示<strong class="kl iu"> : </strong></p><pre class="jy jz ka kb gt od oa ow ox aw oy bi"><span id="3f63" class="oz lk it oa b gy pa pb l pc ol"><strong class="oa iu">make start-demo</strong></span></pre><p id="297d" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">如果成功，我们将启动应用程序的不安全版本。我们希望启动安全应用程序，然后可以运行:</p><pre class="jy jz ka kb gt od oa ow ox aw oy bi"><span id="44a4" class="oz lk it oa b gy pa pb l pc ol"><strong class="oa iu">make start-demo-secure</strong></span></pre><p id="0d9e" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">这是我们页面在<strong class="kl iu"> 8080 </strong>港口的样子:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi py"><img src="../Images/aa1d3447ce154d83eeb29503af46774a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*87CZIgUvWPK0XStj2WWpCg.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd ll">移动物体应用</strong></figcaption></figure><h1 id="3058" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">14.结论</h1><p id="0867" class="pw-post-body-paragraph kj kk it kl b km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc ml le lf lg im bi na translated"><span class="l nb nc nd bm ne nf ng nh ni di">我们</span>终于到了本文的结尾。它很长，但我希望能够传达我发现的对这种<strong class="kl iu">监控</strong>架构有启发的要点。我不想让它变得太复杂，但我也想让它成为一篇有趣的文章，有一些惊喜。</p><p id="7520" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">在本文中，我们已经看到了如何设置一个非常基本的配置<strong class="kl iu"> Prometheus、Grafana和InfluxDB </strong>应用于<strong class="kl iu"> Spring Boot和NodeJS </strong>应用程序。</p><p id="4905" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">我们已经看到了关于<strong class="kl iu">仪表盘</strong>外观和感觉的示例图片。</p><p id="4082" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">回顾所有三种类型的仪表板和三种不同的品牌，我们可以立即得出这样的想法:这些本质上只是不同的监控工具，它们都可以基于简单的<strong class="kl iu"> Prometheus </strong>指标端点。我们还可以看到，我们可以制定自己的指标，并且可以在代码中对这些指标进行编程。使用这些机制时，做出一个决定可能是压倒性的。例如，<strong class="kl iu"> Grafana </strong>，似乎是一个可视化数据的伟大工具，尽管我们已经在本文中看到了如何将其与<strong class="kl iu"> Prometheus </strong>服务集成，我们也可以将其与<strong class="kl iu"> InfluxDB </strong>集成。但是现在我们可能会有点吃惊，因为<strong class="kl iu"> InfluxDB </strong>本身也有<strong class="kl iu">仪表盘</strong>，那么我们为什么还需要<strong class="kl iu"> Grafana </strong>呢？也许<strong class="kl iu"> Grafana </strong>中有你在<strong class="kl iu"> InfluxDB中找不到的功能。</strong>或者也许，以同样的方式，<strong class="kl iu"> Telegraf </strong>可以降低<strong class="kl iu"> InfluxDB的CPU使用率，</strong>Grafana也可以。事实上，<strong class="kl iu"> Grafana </strong>可以认为只是一个可视化框架，<strong class="kl iu"> Prometheus </strong>所有度量的来源，<strong class="kl iu"> InfluxDB </strong>持久性数据库，以及<strong class="kl iu"> Telegraf，</strong>我们需要的scrapper。如果我们这样做，那么我们会得到一个完全解耦的系统，其中每个部分都有自己的职责。因此，我们尽量减少性能问题和<strong class="kl iu">指标</strong>对<strong class="kl iu">应用</strong>的影响。</p><p id="294d" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">因此，在安全性方面，使用<strong class="kl iu"> JWT </strong>和<strong class="kl iu">奥克塔</strong>作为认证/授权机制，我们可以看到，为了能够进行监控，我们可以开放端点。但是我们应该吗？我们也许不应该让它们<strong class="kl iu">开着</strong>，但是它们经常开着。通常情况下，它们对内部网络保持开放，但对外部世界保持私有。这意味着，即使是拥有完全访问权限的人也无法访问这些端点。实现这一点的技术超出了本文的范围，但是像<strong class="kl iu"> NGINX、Kong、</strong>和其他网关这样的解决方案可以提供功能，它们通常提供与<strong class="kl iu">云</strong>提供商的集成。</p><p id="e57a" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">我已经把这个应用程序的所有源代码放到了<a class="ae li" href="https://github.com/jesperancinha/moving-objects-service-root" rel="noopener ugc nofollow" target="_blank"> <strong class="kl iu"> GitHub </strong> </a>上</p><p id="5d44" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">我希望你能像我喜欢写这篇文章一样喜欢它。</p><p id="67b1" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">我很想听听你的想法，所以请在下面留下你的评论。</p><p id="4abd" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">提前感谢您的帮助，感谢您的阅读！</p><p id="d6ca" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">保重，保持兴趣，保持逻辑，保持安全！</p><h1 id="59c2" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">6.参考</h1><div class="pz qa gp gr qb qc"><a href="https://micrometer.io/docs/registry/prometheus" rel="noopener  ugc nofollow" target="_blank"><div class="qd ab fo"><div class="qe ab qf cl cj qg"><h2 class="bd iu gy z fp qh fr fs qi fu fw is bi translated">千分尺应用监控</h2><div class="qj l"><h3 class="bd b gy z fp qh fr fs qi fu fw dk translated">编辑描述</h3></div><div class="qk l"><p class="bd b dl z fp qh fr fs qi fu fw dk translated">千分尺io</p></div></div></div></a></div><div class="pz qa gp gr qb qc"><a href="https://dzone.com/articles/how-to-configure-an-oauth2-authentication-with-spr" rel="noopener  ugc nofollow" target="_blank"><div class="qd ab fo"><div class="qe ab qf cl cj qg"><h2 class="bd iu gy z fp qh fr fs qi fu fw is bi translated">如何用Spring Security配置OAuth2身份验证(第1部分)——DZone Security</h2><div class="qj l"><h3 class="bd b gy z fp qh fr fs qi fu fw dk translated">正如你可能在我之前的博客文章中注意到的，我是Spring + Java和Spring + Kotlin的忠实粉丝。因此…</h3></div><div class="qk l"><p class="bd b dl z fp qh fr fs qi fu fw dk translated">dzone.com</p></div></div><div class="ql l"><div class="qm l qn qo qp ql qq kh qc"/></div></div></a></div><div class="pz qa gp gr qb qc"><a href="https://grafana.com/docs/grafana/latest/installation/docker/" rel="noopener  ugc nofollow" target="_blank"><div class="qd ab fo"><div class="qe ab qf cl cj qg"><h2 class="bd iu gy z fp qh fr fs qi fu fw is bi translated">运行Grafana Docker图像</h2><div class="qj l"><h3 class="bd b gy z fp qh fr fs qi fu fw dk translated">运行Grafana Docker镜像您可以使用官方Docker容器安装和运行Grafana。官方的Grafana…</h3></div><div class="qk l"><p class="bd b dl z fp qh fr fs qi fu fw dk translated">grafana.com</p></div></div><div class="ql l"><div class="qr l qn qo qp ql qq kh qc"/></div></div></a></div><div class="pz qa gp gr qb qc"><a href="https://prometheus.io/" rel="noopener  ugc nofollow" target="_blank"><div class="qd ab fo"><div class="qe ab qf cl cj qg"><h2 class="bd iu gy z fp qh fr fs qi fu fw is bi translated">普罗米修斯——监测系统和时间序列数据库</h2><div class="qj l"><h3 class="bd b gy z fp qh fr fs qi fu fw dk translated">利用领先的开源监控解决方案增强您的指标和警报能力。普罗米修斯作者2014–2020 |…</h3></div><div class="qk l"><p class="bd b dl z fp qh fr fs qi fu fw dk translated">普罗米修斯</p></div></div><div class="ql l"><div class="qs l qn qo qp ql qq kh qc"/></div></div></a></div><div class="pz qa gp gr qb qc"><a href="https://rapidapi.com/" rel="noopener  ugc nofollow" target="_blank"><div class="qd ab fo"><div class="qe ab qf cl cj qg"><h2 class="bd iu gy z fp qh fr fs qi fu fw is bi translated">API市场—免费公共和开放Rest APIs | RapidAPI</h2><div class="qj l"><h3 class="bd b gy z fp qh fr fs qi fu fw dk translated">在RapidAPI的API Marketplace(全球最大的API目录)上浏览、测试和连接1000个公共Rest APIs</h3></div><div class="qk l"><p class="bd b dl z fp qh fr fs qi fu fw dk translated">rapidapi.com</p></div></div><div class="ql l"><div class="qt l qn qo qp ql qq kh qc"/></div></div></a></div><div class="pz qa gp gr qb qc"><a href="https://docs.influxdata.com/influxdb/v1.7/query_language/data_exploration/" rel="noopener  ugc nofollow" target="_blank"><div class="qd ab fo"><div class="qe ab qf cl cj qg"><h2 class="bd iu gy z fp qh fr fs qi fu fw is bi translated">使用InfluxQL | InfluxData文档的数据探索</h2><div class="qj l"><h3 class="bd b gy z fp qh fr fs qi fu fw dk translated">InfluxQL是一种类似SQL的查询语言，用于与InfluxDB中的数据进行交互。以下部分详细介绍了InfluxQL的…</h3></div><div class="qk l"><p class="bd b dl z fp qh fr fs qi fu fw dk translated">docs.influxdata.com</p></div></div><div class="ql l"><div class="qu l qn qo qp ql qq kh qc"/></div></div></a></div></div></div>    
</body>
</html>