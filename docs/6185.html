<html>
<head>
<title>Refreshing Your Swift and Cocoa Programming Skills</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">刷新您的Swift和Cocoa编程技能</h1>
<blockquote>原文：<a href="https://itnext.io/refreshing-your-swift-and-cocoa-programming-skills-f80b041fd24a?source=collection_archive---------1-----------------------#2021-09-10">https://itnext.io/refreshing-your-swift-and-cocoa-programming-skills-f80b041fd24a?source=collection_archive---------1-----------------------#2021-09-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bc41" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">远离了Cocoa和Swift编程，感觉自己忘记了很多细节？这是Swift 5和Xcode 12的复习资料。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/40fa0777b08e9cb23b215ae3aece0783.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KKS5N9tPH-gKZfUVg3orOw.png"/></div></div></figure><p id="71ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">他的故事不会试图教你斯威夫特或可可。取而代之的假设是，你在某个时候知道这两者，但只是忘记了一大堆东西。</p><p id="05f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是试图涵盖最容易忘记的东西。以下是我将涉及的主题:</p><ul class=""><li id="c690" class="lz ma it kw b kx ky la lb ld mb lh mc ll md lp me mf mg mh bi translated"><strong class="kw iu"> XIB的出路和陷阱</strong>——使用<code class="fe mi mj mk ml b">.xib</code>文件设计用户界面时，很容易忘记东西。尤其是忘记连接正确的插座。</li><li id="7750" class="lz ma it kw b kx mm la mn ld mo lh mp ll mq lp me mf mg mh bi translated"><strong class="kw iu">添加GUI控件</strong>——这看起来很可笑，但实际上我在Xcode 12中努力找出GUI控件的位置。</li><li id="5017" class="lz ma it kw b kx mm la mn ld mo lh mp ll mq lp me mf mg mh bi translated"><strong class="kw iu">功能和签名</strong> —你可能会不明白为什么你的相机、视频或麦克风不工作。想知道你的代码有什么问题。但也许您只是忘记了在您的项目中启用使用这些设备的权限。</li><li id="dc4b" class="lz ma it kw b kx mm la mn ld mo lh mp ll mq lp me mf mg mh bi translated"><strong class="kw iu">Swift中的错误处理</strong> —虽然您知道基础知识，但可能很难记住最佳实践。我在这里告诉你怎么做。</li><li id="0930" class="lz ma it kw b kx mm la mn ld mo lh mp ll mq lp me mf mg mh bi translated"><strong class="kw iu">绑定</strong>——一项真正强大的技术，但容易出错。我涵盖了一些常见的错误，并解释了这个概念。</li><li id="9a3c" class="lz ma it kw b kx mm la mn ld mo lh mp ll mq lp me mf mg mh bi translated">willSet和didSet  —你为什么需要这些？</li><li id="20b5" class="lz ma it kw b kx mm la mn ld mo lh mp ll mq lp me mf mg mh bi translated">字符串标识符的类型安全版本 —有像<code class="fe mi mj mk ml b">NSUserInterfaceItemIdentifier</code>和<code class="fe mi mj mk ml b">Notification.Name</code>这样的类型，它们实际上是字符串，但是可以用类型安全的方式处理。</li><li id="271b" class="lz ma it kw b kx mm la mn ld mo lh mp ll mq lp me mf mg mh bi translated"><strong class="kw iu">通知和通知中心</strong> —在您的应用程序中发送和接收通知的目的和最佳实践。</li><li id="e6f3" class="lz ma it kw b kx mm la mn ld mo lh mp ll mq lp me mf mg mh bi translated"><strong class="kw iu"> Swift字符串混淆</strong> —在Swift中使用字符串可能会造成混淆，尤其是索引访问。我澄清了这个谜。</li></ul><h1 id="cef3" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">XIB网点和陷阱</h1><p id="14bd" class="pw-post-body-paragraph ku kv it kw b kx nj ju kz la nk jx lc ld nl lf lg lh nm lj lk ll nn ln lo lp im bi translated">在Xcode中使用<code class="fe mi mj mk ml b">.xib</code>文件时，您很容易忘记很多事情。文件的所有者是人们一直纠结的概念之一。</p><p id="9495" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一种方式来考虑它:想象你在内存中有一堆对象，它们被组合起来创建一个GUI。然后这些对象被存储到磁盘上。那是你的<code class="fe mi mj mk ml b">.xib</code>文件。当你加载<code class="fe mi mj mk ml b">.xib</code>时，你把所有这些对象都带回内存。</p><p id="55ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您希望按钮被点击时发生一些事情，这意味着您希望您的一些代码运行。为了做到这一点，当我们使用界面设计器时，我们将GUI组件的动作连接到控制器对象中的方法。</p><p id="379d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当Cocoa框架从磁盘加载一个<code class="fe mi mj mk ml b">.xib</code>文件时，它将与您的控制器对象建立这些连接。</p><h2 id="5e1e" class="np ms it bd mt nq nr dn mx ns nt dp nb ld nu nv nd lh nw nx nf ll ny nz nh oa bi translated">连接文件所有者的窗口出口</h2><p id="4968" class="pw-post-body-paragraph ku kv it kw b kx nj ju kz la nk jx lc ld nl lf lg lh nm lj lk ll nn ln lo lp im bi translated">记住将你的<code class="fe mi mj mk ml b">NSWindowController</code>子类的<code class="fe mi mj mk ml b">window</code>出口连接到你的实际窗口。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/46ed66f802bfff6b3612b5e832370809.png" data-original-src="https://miro.medium.com/v2/format:webp/1*_E9bEEg_S_wAIVe8dHw0nw.png"/></div></figure><h2 id="d8b7" class="np ms it bd mt nq nr dn mx ns nt dp nb ld nu nv nd lh nw nx nf ll ny nz nh oa bi translated">为什么我的出口和行动不起作用？</h2><p id="d222" class="pw-post-body-paragraph ku kv it kw b kx nj ju kz la nk jx lc ld nl lf lg lh nm lj lk ll nn ln lo lp im bi translated">也许你忘记了将你的<code class="fe mi mj mk ml b">.xib</code>文件的所有者设置为你的<code class="fe mi mj mk ml b">NSWindowController</code>子类的名字。如果你不这样做，那么拖动出口和行动将无法正常工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/85573713d3472afd0d02052a8e9e18f1.png" data-original-src="https://miro.medium.com/v2/format:webp/1*4sTXadBq-_c85iNNtDsVbQ.png"/></div></figure><p id="e47d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个例子中，我的<code class="fe mi mj mk ml b">.xib</code>文件由一个名为<code class="fe mi mj mk ml b">MainWindowController</code>的控制器加载。当我忘记这样做的时候，我很紧张，试图找出为什么我的工具栏项目不起作用。为什么他们连接到<a class="ae no" href="https://developer.apple.com/documentation/appkit/nswindow/1419440-firstresponder" rel="noopener ugc nofollow" target="_blank">第一响应者</a>而不是<a class="ae no" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html" rel="noopener ugc nofollow" target="_blank">文件的所有者</a>？当您没有正确连接到<code class="fe mi mj mk ml b">IBAction</code>时，工具栏项目也不会被启用。</p><h1 id="d912" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">如何添加GUI控件？</h1><p id="df6b" class="pw-post-body-paragraph ku kv it kw b kx nj ju kz la nk jx lc ld nl lf lg lh nm lj lk ll nn ln lo lp im bi translated">令人惊讶的是，我在Xcode 12中很难搞清楚这一点，因为自从我上次使用Xcode以来，这已经发生了很大的变化。现在，GUI控件来自一个弹出窗口，您可以通过单击GUI设计窗口右上角的加号按钮调出该窗口。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/4119838096714303575aa29d22f8907a.png" data-original-src="https://miro.medium.com/v2/format:webp/1*hyc2BF691_g30yfaKnso0A.png"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">按下用橙色圈起来的加号按钮</figcaption></figure><h1 id="1ab2" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">功能—为什么我的麦克风不工作？</h1><p id="071a" class="pw-post-body-paragraph ku kv it kw b kx nj ju kz la nk jx lc ld nl lf lg lh nm lj lk ll nn ln lo lp im bi translated">在我的应用程序中，我录制音频进行转录。为此，我使用了<code class="fe mi mj mk ml b">AVAudioRecorder</code>类，代码如下所示:</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="a7a4" class="np ms it ml b gy ok ol l om on">let rec = try AVAudioRecorder(url: audioFile,<br/>                         settings: settings)<br/>var ok = rec.prepareToRecord()<br/>if !ok {<br/>    throw AudioError.unableToPrepareRecording<br/>}<br/><br/>ok = rec.record()<br/>if !ok {<br/>    throw AudioError.failedToStartRecording<br/>}</span></pre><p id="b88f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我不明白为什么这一直失败。<code class="fe mi mj mk ml b">rec.record()</code>和<code class="fe mi mj mk ml b">rec.prepareToRecord()</code>调用会失败，没有任何合理的消息(<code class="fe mi mj mk ml b">AudioError</code>是我自己定制的错误类型)。</p><p id="80a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">原因是我忘记了在我的应用程序的<em class="oo">签名&amp;功能</em>设置中指定我的应用程序将会录制音频。什么！？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/a5dae26f795b0514c2941dc85fe33bf6.png" data-original-src="https://miro.medium.com/v2/format:webp/1*DKC6VJ8mAy60ttpBNI-ndw.png"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">要启用录音，您需要选中两个蓝色框。</figcaption></figure><p id="7f32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">原因是苹果有安全意识，不会让你的API使用任何可能侵犯用户隐私的功能，除非事先明确宣布。这意味着您必须配置您的应用程序才能使用这些功能。不仅如此，你还必须提供一个用户可读的字符串来解释<em class="oo">为什么</em>你需要使用它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/7655dc83b04f515851c274c250082e60.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Nx4DEtqMQDP9kWV47t89IA.png"/></div></figure><p id="df99" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，我在这里提供了文本，说明我正在使用录制的音频来提供转录服务。然而，举例来说，如果你下载了一个电子邮件应用程序，它开始使用你的摄像机，那么这将是非常可疑的。你会想知道为什么。因此，苹果公司将给出一个许可框，解释或为什么要求你许可使用这项功能。</p></div><div class="ab cl op oq hx or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="im in io ip iq"><p id="7480" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我向你保证，这东西很容易忘记。我用不同的应用程序连续两次忘记这一点。每次我都浪费时间排除代码故障，而不是检查我的权限。不要和我犯同样的错误。</p><h1 id="67cc" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">我忘记了错误是如何发生的！</h1><p id="4a1b" class="pw-post-body-paragraph ku kv it kw b kx nj ju kz la nk jx lc ld nl lf lg lh nm lj lk ll nn ln lo lp im bi translated">Swift中的错误可以是类，也可以是枚举。你可以谷歌一下这个。我将会给你一个快速和最实用的处理错误的方法。</p><p id="3b3d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以创建自己的自定义错误，如下所示:</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="d1a9" class="np ms it ml b gy ok ol l om on">enum AudioError: Error {<br/>    case invalidFilePath(URL)<br/>    case unableToPrepareRecording<br/>}</span></pre><p id="df90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以看到其中一个错误带有一个参数，即没有找到的文件路径的<code class="fe mi mj mk ml b">URL</code>。</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="1a8a" class="np ms it ml b gy ok ol l om on">init(audioFile : URL) throws {<br/>        guard audioFile.isFileURL else {<br/>            throw AudioError.invalidFilePath(audioFile)<br/>        }<br/>        let player = try AVAudioPlayer(contentsOf: audioFile)<br/>        var ok = player.prepareToPlay()<br/>        if !ok {<br/>            throw AudioError.unableToPreparePlaying<br/>        }</span></pre><p id="4779" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以看到这个类的<code class="fe mi mj mk ml b">init</code>函数标有<code class="fe mi mj mk ml b">throws</code>。如果你在里面使用了<code class="fe mi mj mk ml b">throw</code>关键字或者你的一个调用需要在前面有一个<code class="fe mi mj mk ml b">try</code>，你就需要这个。<code class="fe mi mj mk ml b">AVAudioPlayer(contentsOf: audioFile)</code>前面需要一个<code class="fe mi mj mk ml b">try</code>，因为它是一个可能抛出错误的调用。</p><h2 id="8d14" class="np ms it bd mt nq nr dn mx ns nt dp nb ld nu nv nd lh nw nx nf ll ny nz nh oa bi translated">如何捕捉错误</h2><p id="8803" class="pw-post-body-paragraph ku kv it kw b kx nj ju kz la nk jx lc ld nl lf lg lh nm lj lk ll nn ln lo lp im bi translated">早先的<code class="fe mi mj mk ml b">init</code>是给<code class="fe mi mj mk ml b">AudioPlayer</code>级的。为了能够捕捉错误，使用<code class="fe mi mj mk ml b">do</code>和<code class="fe mi mj mk ml b">catch</code>。Catch自动给你一个名为<code class="fe mi mj mk ml b">error</code>的错误对象，我们在这里使用它。</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="a446" class="np ms it ml b gy ok ol l om on">do {<br/>    let audioDev = try AudioPlayer(audioFile: url)<br/>    audioDev.player.delegate = self<br/>} catch {<br/>    NSAlert(error: error).runModal()<br/>}</span></pre><p id="6151" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，您可以像这样明确地做:</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="a1b5" class="np ms it ml b gy ok ol l om on">catch let err {<br/>    NSAlert(error: err).alert.runModal()<br/>}</span></pre><h2 id="258d" class="np ms it bd mt nq nr dn mx ns nt dp nb ld nu nv nd lh nw nx nf ll ny nz nh oa bi translated">自定义错误消息</h2><p id="9328" class="pw-post-body-paragraph ku kv it kw b kx nj ju kz la nk jx lc ld nl lf lg lh nm lj lk ll nn ln lo lp im bi translated">但是<code class="fe mi mj mk ml b">NSAlert</code>面板如何知道要写出什么样的错误信息呢？它检查你的错误对象是否有一个可以询问的<code class="fe mi mj mk ml b">errorDescription</code>属性。或者更具体地说，它检查您的<code class="fe mi mj mk ml b">Error</code>对象是否实现了具有<code class="fe mi mj mk ml b">errorDescription</code>属性的<code class="fe mi mj mk ml b">LocalizedError</code>协议。在这种情况下我们当然不会。</p><p id="acb5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是在Swift中，我们可以为任何类添加协议遵守，甚至是使用类扩展的另一个库中的类:</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="972d" class="np ms it ml b gy ok ol l om on">extension AudioError : LocalizedError {<br/>    var errorDescription: String? {<br/>        switch self {<br/>        case .invalidFilePath(let url):<br/>            return "\(url.path) is not a valid path to an audio file"<br/>        case .unableToPreparePlaying:<br/>            return "Could not prepare the audio player for playing"</span></pre><p id="e384" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，在这种情况下，您并不一定需要使用类扩展，因为我们有<code class="fe mi mj mk ml b">AudioError</code> enum实现的源代码。</p><p id="b812" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，我没有使用<code class="fe mi mj mk ml b">NSLocalString</code>，这将允许错误消息的本地化，是一个坏的Cocoa公民。</p><h1 id="71b8" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">我的绑定不同步也不更新！</h1><p id="89ee" class="pw-post-body-paragraph ku kv it kw b kx nj ju kz la nk jx lc ld nl lf lg lh nm lj lk ll nn ln lo lp im bi translated">通过绑定，您可以将多个GUI控件连接到同一个变量，并让Cocoa自动同步它们。下图显示了我如何将一个<code class="fe mi mj mk ml b">NSStepper</code>绑定到我的<code class="fe mi mj mk ml b">SpokenController</code>对象中的一个值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/232cd225e61732ba5b75d8c903e64dff.png" data-original-src="https://miro.medium.com/v2/format:webp/1*PNHWw0yRi9GA813BfjSIlg.png"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated"><code class="fe mi mj mk ml b">NSStepper</code>控制器的<code class="fe mi mj mk ml b">maxValue</code>绑定到<code class="fe mi mj mk ml b">maxTranscriptIndex</code></figcaption></figure><p id="4e7b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是容易出错的地方。为了使更新机制能够工作，您的变量需要用<code class="fe mi mj mk ml b">@objc</code>和<code class="fe mi mj mk ml b">dynamic</code>来修饰。这很容易出错，因为Swift在这方面已经做了很多改变。这是截至2021年的Swift 5的做法。</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="a7eb" class="np ms it ml b gy ok ol l om on">@objc dynamic var maxTranscriptIndex : Int = -1</span></pre><p id="465d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">需要<code class="fe mi mj mk ml b">@objc</code>部分来使setter和getter函数对Objective-C可见，这是因为整个绑定系统都是用Objective-C代码编写的。或者说，它必须能够与Objective-C一起工作。</p><p id="aab1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">阅读更多:<a class="ae no" href="https://swiftunboxed.com/interop/objc-dynamic/" rel="noopener ugc nofollow" target="_blank"> objc vs动态</a></p><p id="bce7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mi mj mk ml b">dynamic</code>支持动态分派，这是动态语言和Objective-C中常见的。这是基于消息传递，而不是C++风格的方法调用，后者要么直接跳转到地址，要么通过进入<code class="fe mi mj mk ml b">vtable</code>的偏移量来找到函数指针。动态分派更加复杂，因为您实际上发送的是文本字符串的等价物，并且您使用该字符串在哈希表中查找正确的函数指针。</p><p id="bb96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这显然要慢得多，但也灵活得多。这是绑定成为可能的首要原因。</p><h1 id="e795" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">willSet和didSet的目的是什么？</h1><p id="8772" class="pw-post-body-paragraph ku kv it kw b kx nj ju kz la nk jx lc ld nl lf lg lh nm lj lk ll nn ln lo lp im bi translated">为什么不能只使用setters和getters？实际上，在Swift代码中几乎不需要setters和getters。也许有些getters，但是setters很少。它们也更难使用，因为你需要指定一个私有变量，你可以从你的setter和getter中访问它。</p><p id="4728" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，当变量发生变化时，需要进行某种更新是很常见的。这就是为什么<code class="fe mi mj mk ml b">didSet</code>被如此频繁地使用。例如，这里每当我改变一个表中显示的值时，我就重新加载那个表。</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="c2a3" class="np ms it ml b gy ok ol l om on">var alignedDoc : AlignedDoc? {<br/>    didSet {<br/>        self.alignedWordsTable.reloadData()<br/>    }<br/>}</span></pre><p id="8f27" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与setters相比有其他优势。它不会在初始化器中被调用，这是你通常不希望发生的事情。</p><p id="7ea3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，<code class="fe mi mj mk ml b">willSet</code>和<code class="fe mi mj mk ml b">didSet</code>与绑定无关。您可能也不这么认为，但是由于某种原因，当我重新开始使用Swift和Cocoa编程时，我错误地记住了这一点。</p><h1 id="12a2" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">如何处理NSUserInterfaceItemIdentifier</h1><p id="82cb" class="pw-post-body-paragraph ku kv it kw b kx nj ju kz la nk jx lc ld nl lf lg lh nm lj lk ll nn ln lo lp im bi translated">当您处理<code class="fe mi mj mk ml b">NSTableView</code>的数据源时，您必须实现这样的方法:</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="87c5" class="np ms it ml b gy ok ol l om on">func tableView(_ tableView: NSTableView,<br/>               objectValueFor column: NSTableColumn?,<br/>               row: Int) -&gt; Any? {<br/>    guard let col = column else {<br/>        return nil<br/>    }<br/><br/>    switch col.identifier {<br/>    case .name:<br/>        return "hello Joe"</span></pre><p id="b3ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意我在<code class="fe mi mj mk ml b">switch</code>语句中使用的列标识符。这在用户界面中被指定为字符串。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/8aa69af84159429f6f725c4b0649ef2e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*KC7o2ee67D0bBzWqxhuezQ.png"/></div></figure><p id="2549" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，如果您查找<code class="fe mi mj mk ml b">NSTableColumn</code>的<code class="fe mi mj mk ml b">identifier</code>属性，您会看到它是这样定义的:</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="a8c7" class="np ms it ml b gy ok ol l om on">var identifier: NSUserInterfaceItemIdentifier</span></pre><p id="60c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但这不是一个字符串。这是怎么回事，你是怎么处理的？嗯，您可以通过在代码中执行以下操作来解开字符串值:</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="3660" class="np ms it ml b gy ok ol l om on">switch col.identifier.rawValue {<br/>case "name":<br/>    return "hello Joe"</span></pre><p id="26e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但这显然不是Cocoa和Swift的设计师想要你做的，否则他们不会用<code class="fe mi mj mk ml b">NSUserInterfaceItemIdentifier</code>把字符串包起来。</p><p id="ff7c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是Swift和Objective-C扩展已经存在的类(甚至来自库)的能力发挥作用的地方。我们在<code class="fe mi mj mk ml b">NSUserInterfaceItemIdentifier</code>上使用了一个类扩展:</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="fb2d" class="np ms it ml b gy ok ol l om on">extension NSUserInterfaceItemIdentifier {<br/>    static let name = NSUserInterfaceItemIdentifier(rawValue: "name")<br/>    static let time = NSUserInterfaceItemIdentifier(rawValue: "time")<br/>}</span></pre><p id="be9f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这允许您在关于<code class="fe mi mj mk ml b">NSUserInterfaceItemIdentifier</code>值的<code class="fe mi mj mk ml b">switch</code>语句中写入<code class="fe mi mj mk ml b">.name</code>和<code class="fe mi mj mk ml b">.time</code>。可可中的许多地方都使用了这种模式。接下来我们将看到它的<code class="fe mi mj mk ml b">NotificationCenter</code>和通知。</p><h1 id="22cb" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">使用通知中心和方法选择器</h1><p id="40c1" class="pw-post-body-paragraph ku kv it kw b kx nj ju kz la nk jx lc ld nl lf lg lh nm lj lk ll nn ln lo lp im bi translated">有时Cocoa方法会将其他方法的名称作为参数。我们称之为选择器。选择器基本上是您发送给一个对象的消息，然后该对象选择正确的方法来执行。</p><p id="2e3b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我有一个这样的方法，我想调用它。</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="7aac" class="np ms it ml b gy ok ol l om on">@objc func updateRecordingTable(notif: Notification) {<br/><br/>}</span></pre><p id="8aff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意<code class="fe mi mj mk ml b">@objc</code>插件——如果不将方法标记为<code class="fe mi mj mk ml b">@objc</code>，就不能通过选择器调用方法。如何为这个方法编写选择器？</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="ca08" class="np ms it ml b gy ok ol l om on">#selector(updateSpokenTextView(notif:))</span></pre><p id="d891" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您会看到命名参数只是被列出，而没有给出完整名称的实际参数。</p><h2 id="863b" class="np ms it bd mt nq nr dn mx ns nt dp nb ld nu nv nd lh nw nx nf ll ny nz nh oa bi translated">注册和注销通知</h2><p id="212b" class="pw-post-body-paragraph ku kv it kw b kx nj ju kz la nk jx lc ld nl lf lg lh nm lj lk ll nn ln lo lp im bi translated">是一种让你分离程序各部分的方法。例如，我的程序中有各种GUI元素，它们都修改和显示相同的数据对象。然而，我不想在这些类之间建立太多的指针，这样它们就互相知道了，因为这将会产生一堆依赖关系。这就是<code class="fe mi mj mk ml b">NotificationCenter</code>帮助你的地方。如果你在一个地方做了修改，你可以通过通知把这个事实传播给程序的其他部分。程序的其他部分可以监听特定的通知，并根据它们进行更新。</p><p id="620e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是一个例子，说明如何在你的课堂上设置观察:</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="7ad5" class="np ms it ml b gy ok ol l om on">override init() {<br/>    super.init()<br/>    let center = NotificationCenter.default<br/>    center.addObserver(self,<br/>                       selector: #selector(updateSpokenTextView(notif:)),<br/>                       name: .SpokenTextViewChanged,<br/>                       object: nil)<br/>    <br/>    center.addObserver(self,<br/>                       selector: #selector(updateRecordingTable(notif:)),<br/>                       name: .RecordingTableChanged,<br/>                       object: nil)<br/>}<br/><br/>deinit {<br/>    let center = NotificationCenter.default<br/>    center.removeObserver(self)<br/>}</span></pre><p id="f18b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意一旦对象死亡，取消注册的重要性。否则，通知中心将尝试向不再存在的对象发送消息。</p><p id="bec0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以随意调用您的方法，只要它将单个<code class="fe mi mj mk ml b">Notification</code>对象作为唯一的参数。因此<code class="fe mi mj mk ml b">notif:</code>不是必需的名称。只是我给它的。</p><p id="5168" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">进一步注意<code class="fe mi mj mk ml b">.SpokenTextViewChanged</code>和<code class="fe mi mj mk ml b">.RecordingTableChanged</code>的使用，它们用于命名我们连接到方法调用的通知。其设置与<code class="fe mi mj mk ml b">NSUserInterfaceItemIdentifier</code>的设置完全相同。这里Cocoa期望类型为<code class="fe mi mj mk ml b">NSNotification.Name</code>的参数。我们可以扩展这个类:</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="9d59" class="np ms it ml b gy ok ol l om on">extension Notification.Name {<br/>    static let SpokenTextViewChanged = Notification.Name(rawValue: "SpokenTextViewChanged")<br/>}</span></pre><p id="7971" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是你可以把它分散在不同的文件中。因此，您可以将另一个通知名称放在另一个文件中:</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="0f77" class="np ms it ml b gy ok ol l om on">extension Notification.Name {<br/>    static let RecordingTableChanged = Notification.Name(rawValue: "RecordingTableChanged")<br/>}</span></pre><h2 id="d386" class="np ms it bd mt nq nr dn mx ns nt dp nb ld nu nv nd lh nw nx nf ll ny nz nh oa bi translated">发送通知</h2><p id="32cd" class="pw-post-body-paragraph ku kv it kw b kx nj ju kz la nk jx lc ld nl lf lg lh nm lj lk ll nn ln lo lp im bi translated">那么我们如何发送通知呢？每当我更新特定表中的值时，我都调用这个方法:</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="b4e5" class="np ms it ml b gy ok ol l om on">func updateViews() {<br/>    let center = NotificationCenter.default<br/>    center.post(name: .RecordingTableChanged, <br/>                object: self)<br/>}</span></pre><h1 id="38b3" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">向自定义对象添加基于索引的访问</h1><p id="aa3d" class="pw-post-body-paragraph ku kv it kw b kx nj ju kz la nk jx lc ld nl lf lg lh nm lj lk ll nn ln lo lp im bi translated">在我的例子中，假设您有一个类<code class="fe mi mj mk ml b">WrittenDoc</code>，并且您想要支持基于索引的访问，那么您可以编写类似<code class="fe mi mj mk ml b">doc[4]</code>的东西来访问文档中的元素。下面是一个如何做到这一点的示例:</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="5b7e" class="np ms it ml b gy ok ol l om on">class WrittenDoc {<br/>    var words : [WrittenWord]<br/>    subscript(index: Int) -&gt; WrittenWord {<br/>        get {<br/>            return self.words[index]<br/>        }<br/>        set {<br/>            self.words[index] = newValue<br/>        }<br/>    }<br/>}</span></pre><p id="2efe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意<code class="fe mi mj mk ml b">get</code>和<code class="fe mi mj mk ml b">set</code>的使用，就像其他属性一样。<code class="fe mi mj mk ml b">newValue</code>是一个神奇地存在于<code class="fe mi mj mk ml b">set</code>中的值，它代表你试图赋值的值。</p><h1 id="f9b4" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">理解字符串</h1><p id="0319" class="pw-post-body-paragraph ku kv it kw b kx nj ju kz la nk jx lc ld nl lf lg lh nm lj lk ll nn ln lo lp im bi translated">Swift中字符串的工作方式是我最不喜欢的事情之一。但是比处理它们更糟糕的是，许多人不明白为什么string接口如此奇怪。理解这一点很重要，这样你就不会走愚蠢的捷径。有很多人给<code class="fe mi mj mk ml b">String</code>类添加了类扩展，这使得他们可以基于整数访问字符。</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="991e" class="np ms it ml b gy ok ol l om on">let s = "hello world"<br/>s[6] // This is what people want to get to the 'w' char</span></pre><p id="1ded" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">抵制诱惑。In可能会使您的代码看起来更整洁、更简洁，但它也制造了一个定时炸弹。你看，Swift字符串的行为几乎有点像链表。到达第5个字符需要遍历5个元素，除非已经有一个指向该字符的字符串迭代器。因此，如果你使用基于整数的索引访问，你将在你的代码中结束大量的<code class="fe mi mj mk ml b">O(n)</code>操作，而不是人们习惯的字符串访问的<code class="fe mi mj mk ml b">O(1)</code>。</p><p id="889d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，只要有字符串迭代器，就保留它们是很重要的，因为它们为它们所指向的元素提供了<code class="fe mi mj mk ml b">O(1)</code>(常量)访问时间。相反，基于整数索引的访问总是以<code class="fe mi mj mk ml b">O(n)</code>结束。</p><p id="f791" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是你如何得到，比如说，<code class="fe mi mj mk ml b">s</code>字符串中的第6个字符。</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="de4a" class="np ms it ml b gy ok ol l om on">let s = "hello world"<br/>let i = s.index(s.startIndex, offsetBy: 6)<br/>s[i] // Access 'w' at 6th character</span></pre><p id="df7e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然这看起来很麻烦，但它允许您更有效地使用字符串。下面是一个<code class="fe mi mj mk ml b">O(1)</code>操作:</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="2dda" class="np ms it ml b gy ok ol l om on">let j = s.index(after: i)<br/>s[j]</span></pre><p id="c43e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你专门处理整数，那么<code class="fe mi mj mk ml b">s[i+1]</code>就是一个<code class="fe mi mj mk ml b">O(n)</code>操作。</p><h2 id="55b8" class="np ms it bd mt nq nr dn mx ns nt dp nb ld nu nv nd lh nw nx nf ll ny nz nh oa bi translated">但是为什么在其他语言中却不是这样呢？</h2><p id="89bc" class="pw-post-body-paragraph ku kv it kw b kx nj ju kz la nk jx lc ld nl lf lg lh nm lj lk ll nn ln lo lp im bi translated">我另外两个喜欢的语言，Julia和Go，不是这样的。您可以直接使用整数索引。但这意味着你可能会不小心做一些违法的事情。下面是朱莉娅·REPL尝试获取unicode字符串中的第5个(“v”)字符的示例:</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="5e3b" class="np ms it ml b gy ok ol l om on">julia&gt; s = "Þrúðvangar"<br/>"Þrúðvangar"<br/><br/>julia&gt; s[5]<br/>ERROR: StringIndexError: invalid index [5], valid nearby indices [4]=&gt;'ú', [6]=&gt;'ð</span></pre><p id="f06e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Swift中，你不能导致这样的非法访问。</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="a086" class="np ms it ml b gy ok ol l om on">let s = "Þrúðvangar"<br/>let i = s.index(s.startIndex, offsetBy: 4)<br/>s[i]</span></pre><p id="207f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，许多其他语言(如Python)没有这样的问题，但他们通过将每个字符存储为32位元素来解决这个问题，这意味着平均而言，文本占用的空间是Swift、Julia或Go的4倍。这可能会降低性能敏感的面向字符串的应用程序的性能。对于主要卖点是便利性而非性能的Python来说，这可能无关紧要。</p><p id="6048" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，Swift、Go和Julia都以高性能为目标，因此需要紧凑的字符串表示。</p><h2 id="d3de" class="np ms it bd mt nq nr dn mx ns nt dp nb ld nu nv nd lh nw nx nf ll ny nz nh oa bi translated">从字符串转换。整数索引</h2><p id="2a13" class="pw-post-body-paragraph ku kv it kw b kx nj ju kz la nk jx lc ld nl lf lg lh nm lj lk ll nn ln lo lp im bi translated">在Cocoa中，并不是所有的API都适用于<code class="fe mi mj mk ml b">String.Index</code>类型。如果你使用<code class="fe mi mj mk ml b">NSAttributedString</code>，你必须使用字符的整数索引。因此，我们需要一种在整数和<code class="fe mi mj mk ml b">String.Index</code>索引之间来回转换的方法。</p><pre class="kj kk kl km gt og ml oh oi aw oj bi"><span id="2422" class="np ms it ml b gy ok ol l om on">let i : String.Index = s.index(s.startIndex, offsetBy: 6)<br/>let j : Int = s.distance(from: s.startIndex, to: i)</span></pre><p id="6d32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，<code class="fe mi mj mk ml b">j</code>将是一个整数索引，您可以将它与<code class="fe mi mj mk ml b">NSRange</code>一起使用，这也是您与<code class="fe mi mj mk ml b">NSAttributedString</code>一起使用的内容。</p></div></div>    
</body>
</html>