<html>
<head>
<title>Docker 102: Docker-Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker 102:Docker-撰写</h1>
<blockquote>原文：<a href="https://itnext.io/docker-102-docker-compose-6bec46f18a0e?source=collection_archive---------0-----------------------#2018-07-07">https://itnext.io/docker-102-docker-compose-6bec46f18a0e?source=collection_archive---------0-----------------------#2018-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8539f89565026310014dda291e608767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1BDUXmg5bkrr2WaiTHEB_w.png"/></div></div></figure><p id="d3b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated"><span class="l kx ky kz bm la lb lc ld le di">如果</span>你不熟悉容器化平台Docker，你可能想看看我的第一篇博客<a class="ae lf" href="https://medium.com/@paigen11/docker-101-fundamentals-the-dockerfile-b33b59d0f14b" rel="noopener"/>，在开始了解Docker-Compose之前，先了解一下它是什么以及它背后发生了什么。</p><p id="27a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你确实了解Docker，请继续阅读，我将尝试向你展示一个单独的<code class="fe lg lh li lj b">docker-compose.yml</code>相对于最初的<code class="fe lg lh li lj b">Dockerfile</code>所能提供的能力和好处。</p><p id="1256" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很好地延续了我将讨论的第一点:为什么使用Docker Compose而不是Docker CLI命令？</p><h2 id="3517" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">为什么Docker作曲？</h2><p id="6a84" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">在开发的所有阶段，Docker Compose都比Docker CLI提供了许多好处。在这里，我会给你一些细节，告诉你在每一个阶段的什么地方可以最好地利用它。</p><ul class=""><li id="b828" class="mi mj iq ka b kb kc kf kg kj mk kn ml kr mm kv mn mo mp mq bi translated"><strong class="ka ir">较低的生命周期</strong></li></ul><p id="d2a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于生命周期较低的环境，Docker Compose能够快速、轻松地模拟生产环境。</p><p id="2131" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它可以加速运行应用程序所需的所有微服务(和数据库),并且可以在隔离的Docker环境中无缝地将它们相互连接起来，而开发人员只需付出很少的努力。甚至不需要在内部指定不同的端口来避免冲突——一下子让整个系统运行起来非常容易。</p><p id="5901" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后就是测试。Docker擅长许多类型的应用程序测试:</p><ul class=""><li id="066c" class="mi mj iq ka b kb kc kf kg kj mk kn ml kr mm kv mn mo mp mq bi translated">破坏性测试</li><li id="3491" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">性能试验</li><li id="782f" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">集成测试</li><li id="09d3" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">端到端测试</li></ul><p id="917d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Docker在测试方面表现如此之好，是因为它创建了自己的隔离环境，启动了自己的数据库，并根据指示设置了数据，当它完成了运行测试和处理数据后，它可以关闭并重新开始备份，原始数据与之前相同。当您的多个开发人员正在处理不同的特性，并且只在干净的端到端测试运行之后才提交PRs时，这有多方便？</p><ul class=""><li id="cee1" class="mi mj iq ka b kb kc kf kg kj mk kn ml kr mm kv mn mo mp mq bi translated"><strong class="ka ir">生产</strong></li></ul><p id="018e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您足够幸运，能够在生产中使用Docker容器，那么一个<code class="fe lg lh li lj b">docker-compose.yml</code>文件就可以部署一个完整的系统，该系统可以完全像在生命周期较低的环境中测试时那样运行。这种情况之所以会发生，是因为使用Docker Compose可以在生产中完成开发中完成的完全相同的步骤，这很棒，有助于消除一些总是会导致出错的恐惧部署。</p><ul class=""><li id="d58f" class="mi mj iq ka b kb kc kf kg kj mk kn ml kr mm kv mn mo mp mq bi translated"><strong class="ka ir"> Docker群体测试</strong></li></ul><p id="3751" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Docker Compose使部署前的Docker群体测试更加容易。我暂时就说到这里，因为本系列的下一篇博客《Docker 103》将详细介绍Docker Swarm。只要知道这是测试蜂群的方法。</p><p id="1c9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，依我拙见，一个<code class="fe lg lh li lj b">docker-compose.yml</code>文件比Docker CLI更容易阅读、理解和实现。不过，这纯粹是我的看法。</p><p id="3e5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我已经给了你使用Docker Compose的理由，下一个问题是:一个<code class="fe lg lh li lj b">docker-compose.yml</code>看起来像什么？我该怎么写呢？请继续阅读。</p><h2 id="fd08" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">什么是Docker Compose？</h2><p id="c51f" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">本质上，Docker Compose是一张配方卡——它是组成应用程序的服务的配方，而<code class="fe lg lh li lj b">docker-compose.yml</code>决定了服务如何混合在一起。</p><p id="3c85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用更专业的术语来说:</p><blockquote class="mw mx my"><p id="8691" class="jy jz mz ka b kb kc kd ke kf kg kh ki na kk kl km nb ko kp kq nc ks kt ku kv ij bi translated">Docker-Compose定义了一个完整的系统，在这个系统中，服务可以在一个隔离的网络上相互通信，与用户定义的外部资源进行交互。</p></blockquote><p id="353c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Docker Compose是建立在Docker引擎之上的，这个引擎运行Dockerfiles和Docker CLI，但是关于Compose要记住的最重要的一点是把它想象成一个菜谱。</p><p id="47bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下图很好地说明了这一点。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/ae98634e012d2c3bf224d2b48afee499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6fRugPB9AEYWNga6Jg2_dg.png"/></div></div></figure><p id="bfde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以上是Docker编写环境运行时的样子。应用A是后端微服务，可以和App B、App C自由通信但仅此而已，根本不能和外界的主机通信。这是因为它的<code class="fe lg lh li lj b">docker-compose.yml</code>是如何设置的，我将在下面展示。</p><p id="5082" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应用程序B是一个数据库，它在<code class="fe lg lh li lj b">docker-compose.yml</code>中构建，带有一个外部挂载卷<code class="fe lg lh li lj b">volumes: — opt/app:/opt/appB/app</code>，允许它向外界写入一个持久数据层。有了应用程序中的这个数据层，即使整个Docker环境由于某种原因被破坏，当它恢复时，数据库将看到以前写入其中的数据，并替换它，以便您可以从以前的地方开始。</p><p id="4ecb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，应用程序C是应用程序的用户界面部分。此外，由于<code class="fe lg lh li lj b">docker-compose.yml</code>，这个应用程序可以在一个已经暴露的端口上与主机对话:<code class="fe lg lh li lj b">ports="8080:8080"</code>。这意味着，用户可以在其机器上打开<a class="ae lf" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>并访问正在运行的应用程序。</p><p id="42a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是环境的样子。这是一个非常简单的表示，但根据您的需要，它可以如此简单，也可以复杂得多。现在，让我们看看Docker Compose YAML文件是什么样子的，并了解它可能带来的一些细微差别。</p><h2 id="4fb8" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">Docker怎么作曲？</h2><p id="d442" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">最后一个大问题是:如何写一个<code class="fe lg lh li lj b">docker-compose.yml</code>，其实很简单，遵循一个标准的公式。</p><p id="f5c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是任何<code class="fe lg lh li lj b">docker-compose.yml</code>的模板。</p><ul class=""><li id="4a40" class="mi mj iq ka b kb kc kf kg kj mk kn ml kr mm kv mn mo mp mq bi translated"><strong class="ka ir">样本Docker撰写模板</strong></li></ul><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/c60cf0e701044367765a36a9ceb167f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*aoqVz3DDSJ7JR0qUp05pcA.png"/></div></figure><p id="5021" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个<code class="fe lg lh li lj b">docker-compose</code>文件将以最小的<code class="fe lg lh li lj b">version: "2"</code>开始，如果你正在做一个Docker Swarm文件，它将需要<code class="fe lg lh li lj b">version: "3"</code>，但是对于一个单独的<code class="fe lg lh li lj b">docker-compose.yml</code>，你将需要v2。</p><p id="858e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，你将列出你所有的服务(在<code class="fe lg lh li lj b">docker-compose</code>中运行的每个应用都有自己的名字，你需要从Docker注册表中提供<strong class="ka ir"><em class="mz"/></strong><code class="fe lg lh li lj b">build</code>或<code class="fe lg lh li lj b">image</code>。你<strong class="ka ir"> <em class="mz">不能</em> </strong> <em class="mz"> </em>兼得。</p><ul class=""><li id="3edf" class="mi mj iq ka b kb kc kf kg kj mk kn ml kr mm kv mn mo mp mq bi translated">自定义Docker映像将基于构建路径提供的Docker文件构建，或者</li><li id="a321" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">Docker hub将提供所有必要的命令和设置，以使映像成功构建和运行。</li></ul><p id="3695" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在此之下，设置环境变量，暴露端口，并装载外部卷。所有这些事情都可以用Docker CLI来完成，但这是一个更干净、更容易阅读的文件，当在终端中执行命令时，不需要记住(并正确键入)它们。</p><p id="92ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个样本<code class="fe lg lh li lj b">docker-compose.yml</code>可能的样子。</p><ul class=""><li id="afee" class="mi mj iq ka b kb kc kf kg kj mk kn ml kr mm kv mn mo mp mq bi translated"><strong class="ka ir">样本Docker编写Yaml </strong></li></ul><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/61b1a51c2f63a19ceafb8b9ab68f3dac.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*qv-9s_lV5F5Pi6231eYruw.png"/></div></figure><p id="fb66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个<code class="fe lg lh li lj b">docker-compose.yml</code>以<code class="fe lg lh li lj b">version: "2"</code>开始(Docker Compose需要的)，然后我们有下面列出的三个服务:<code class="fe lg lh li lj b">appA</code>、<code class="fe lg lh li lj b">appB</code>、<code class="fe lg lh li lj b">appC</code>。因为<code class="fe lg lh li lj b">appA</code>是从自定义<code class="fe lg lh li lj b">Dockerfile</code>构建的UI，并且需要向主机公开，所以它有一个到所述<code class="fe lg lh li lj b">Dockerfile</code>的<code class="fe lg lh li lj b">build:</code>路径和一个将UI的内部运行端口(端口80)映射到主机上的相同端口(也是80)的<code class="fe lg lh li lj b">ports:</code>。</p><p id="1630" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lg lh li lj b">appB</code>是一个mongo数据库，所以当需要启动应用程序时，可以从Docker注册表中取出它。不需要提前构建，只需要声明映像，对于数据持久化，添加一个<code class="fe lg lh li lj b">volumes:</code>规范，说明数据库数据可以持久化到主机的什么地方，这样就可以了。</p><p id="76e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而且<code class="fe lg lh li lj b">appC</code>也是一个定制的Docker映像，所以它有一个到自己Dockerfile的<code class="fe lg lh li lj b">build:</code>路径，一个为后端指定配置文件的<code class="fe lg lh li lj b">environment:</code>变量，还有两个<code class="fe lg lh li lj b">instances:</code>。这个应用程序尤其可以有两个实例，因为它没有以任何方式向主机公开。如果正在打开一个端口(或者它是某种类型的数据库)，它将只能有一个实例，以避免主机上的端口冲突，或者避免写入Docker环境中的两个单独的数据库。但是由于这是一个纯粹的后端服务，它可以有任意多的实例(有利于负载平衡大量的流量)，所有这些实例都可以在Docker环境中作为单独的容器运行，并在需要时相互通信。</p><p id="957c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我推荐阅读<a class="ae lf" href="https://docs.docker.com/compose/overview/" rel="noopener ugc nofollow" target="_blank"> Docker Compose文档</a>,获得更多的例子和你可以在<code class="fe lg lh li lj b">docker-compose.yml</code>中做的所有事情的描述。</p><p id="52da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，<code class="fe lg lh li lj b">docker-compose.yml</code>已经写好了，让我们看看让这个系统启动并运行所需的Docker Compose命令。别担心，它们不是很复杂。</p><h2 id="4901" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">Docker编写命令</h2><p id="ae02" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">在我继续下去之前，我必须发布以下免责声明。</p><p id="6a75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">免责声明:在这篇博文中，假设所有docker-compose命令都将在与</strong> <code class="fe lg lh li lj b"><strong class="ka ir">docker-compose.yml</strong></code> <strong class="ka ir">相同的目录中执行。是的，从目录的不同级别执行命令是可能的，但是这超出了这篇关于Docker Compose的博客的范围。</strong></p><p id="e6ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然已经说清楚了，我可以继续了。您只需要在终端中键入一些Docker命令，就可以让这些神奇的文件完成它们的工作。在我描述了它们之后，我提供了另一个方便的图形来说明Docker Compose环境可以存在的三个不同阶段。</p><ul class=""><li id="84ba" class="mi mj iq ka b kb kc kf kg kj mk kn ml kr mm kv mn mo mp mq bi translated"><code class="fe lg lh li lj b"><strong class="ka ir">docker-compose ps </strong></code> <strong class="ka ir"> — </strong>列出网络中的所有服务。这在对服务进行故障排除时特别有用，因为它会给你容器ID，然后你可以运行<code class="fe lg lh li lj b">docker -it exec &lt;ID&gt; bash</code>进入容器并根据需要进行调试。</li><li id="3606" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated"><code class="fe lg lh li lj b"><strong class="ka ir">docker-compose build</strong></code> <strong class="ka ir"> — </strong>从自定义<code class="fe lg lh li lj b">Dockerfiles</code>生成任何需要的图像。它不会从Docker hub中提取图像，只会生成自定义图像。</li><li id="6099" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated"><code class="fe lg lh li lj b"><strong class="ka ir">docker-compose up </strong></code> <strong class="ka ir"> — </strong>调出服务运行的网络</li><li id="80ea" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated"><code class="fe lg lh li lj b"><strong class="ka ir">docker-compose stop</strong></code> <strong class="ka ir"> — </strong>停止网络并保存所有服务的状态</li><li id="f3eb" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated"><code class="fe lg lh li lj b"><strong class="ka ir">docker-compose start </strong></code> <strong class="ka ir"> — </strong>重新启动服务，并将其恢复到停止时的状态</li><li id="129c" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated"><code class="fe lg lh li lj b"><strong class="ka ir">docker-compose down</strong></code><strong class="ka ir">——</strong>用火焚烧整个Docker网络。网络和其中包含的所有服务被完全破坏。</li></ul><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/81a5eb9377f7a1d825ff39fbbd59e4e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X98d4dsk_ymmjqnM0ne4Xg.png"/></div></div></figure><p id="683e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是Docker编写环境存在的各种状态，具体取决于您运行的命令。</p><p id="54cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lg lh li lj b">docker-compose build</code>和<code class="fe lg lh li lj b">docker-compose down</code>表示Docker环境<strong class="ka ir"> <em class="mz">不在</em> </strong>运行，网络<strong class="ka ir"> <em class="mz">不存在</em> </strong>。</p><p id="3d1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lg lh li lj b">docker-compose up</code>和<code class="fe lg lh li lj b">docker-compose start</code>表示Docker环境<strong class="ka ir"> <em class="mz">正在</em> </strong>运行，网络<strong class="ka ir"><em class="mz"/></strong>是否存在。</p><p id="d512" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lg lh li lj b">docker-compose stop</code>表示Docker环境<strong class="ka ir"> <em class="mz">未</em> </strong>运行，但网络仍<strong class="ka ir"><em class="mz"/></strong>存在。</p><p id="9dac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样。使用<code class="fe lg lh li lj b">docker-compose.yml</code>构建和运行所有连接的微服务所需的所有命令。</p><h2 id="7ab8" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">Docker编写示例</h2><p id="25d4" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">如果你想看看Docker Compose是如何构建的，你可以在这里下载我整理的一个回购:<a class="ae lf" href="https://github.com/paigen11/docker-compose-example" rel="noopener ugc nofollow" target="_blank">https://github.com/paigen11/docker-compose-example</a></p><p id="0709" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个示例都有一个说明如何运行它的<code class="fe lg lh li lj b">README</code>，它说明了Docker Compose提供的灵活性。</p><p id="f52b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">例1 </strong></p><p id="ba44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个示例包含一个Node.js和一个Spring Boot Java应用程序，这两个应用程序都有Dockerfiles，但没有<code class="fe lg lh li lj b">docker-compose.yml</code>，它有基本的Docker CLI命令来分别在端口3003和3004上运行它们。这是为了说明与<code class="fe lg lh li lj b">docker-compose.yml</code>包含的指令完全相同的指令也可以从命令行执行，但是要让它们运行起来，用户需要付出更多的努力。此外，两个服务都不知道另一个服务，它们通过<code class="fe lg lh li lj b">docker-compose.yml</code>连接的方式。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/9eef17a6d85847c1db17fff981b72012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pARr1nbXmrDe8jSToApOFA.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">Node.js示例:在端口3003上运行</figcaption></figure><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/050864958694833e20e894e0ed69cf27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*-mCx9YU7JzklGXzjXFj12A.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">Java Spring Boot示例:在端口3004上运行并显示其主机名</figcaption></figure><p id="ee78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">例二</strong></p><p id="293f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个例子部署了同样的两个应用程序，但是使用了一个<code class="fe lg lh li lj b">docker-compose.yml</code>文件。这次Java app运行在3001上，Node app运行在3002上。如果您愿意，您可以让示例1和示例2同时运行，因为它们都不共享主机端口号。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/636abdc829303675344546528cc43dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*--1Z6rrT_bq4tUFbLhTiuA.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">节点示例2:在端口3002上运行</figcaption></figure><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/032039c9d2412ebba1c4926967772fb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*T3t_37WfNmwUO8LCRymMwQ.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">Java示例2:使用不同的主机名在端口3001上运行</figcaption></figure><p id="6bf9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">例3 </strong></p><p id="7f66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">示例3通过使用一个简单的<a class="ae lf" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> Nginx </a>前端将请求路由到Java或在其网络中运行的节点服务，从而更上一层楼。Nginx不在本博客的讨论范围之内，但是就我们的目的而言，它是作为一个代理工作的，并且根据传递给它的路径，它要么提供一个应用，要么提供另一个应用。这意味着只有一个端口对外界开放(80是Nginx的默认端口，所以我使用这个端口)，但是Docker环境中的两个应用程序都可以访问，这些服务不需要端口。请看下面的截图来帮助澄清一下。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/786e867010df9f0044440461834040c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*BDMOUdHxV87r8XrNWzRGvQ.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">仔细查看URL，它只是<a class="ae lf" href="http://localhost/node/," rel="noopener ugc nofollow" target="_blank"> http://localhost/node/，</a>并且它路由到节点示例</figcaption></figure><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/89cc2a329416c21719315e5968414cb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*KLhF-6nW08P_MhiWjIW7zg.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">同样，带有/java/ route的同一个端口路由到java示例</figcaption></figure><p id="6898" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">例4 </strong></p><p id="863a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是迄今为止我最喜欢的例子，因为它确实有助于说明Docker Compose的强大功能。在示例目录的根级别，这个特定的<code class="fe lg lh li lj b">docker-compose.yml</code>一次访问所有的Java和节点示例，从它们各自的<code class="fe lg lh li lj b">Dockerfiles</code>构建它们的映像，并旋转所有的六个示例加上两个带有图像标签<code class="fe lg lh li lj b">latest</code>的应用程序。所有这些容器都是通过一个Nginx代理来访问的。这是一个非常非常酷的例子，展示了如何使用版本控制来实现<a class="ae lf" href="https://docs.cloudfoundry.org/devguide/deploy-apps/blue-green.html" rel="noopener ugc nofollow" target="_blank">蓝绿生产部署</a>、<a class="ae lf" href="https://octopus.com/docs/deployment-patterns/canary-deployments" rel="noopener ugc nofollow" target="_blank">金丝雀部署</a>，或者甚至是一种支持同一应用程序多个版本的方式，如果不同的外部团队依赖于某个版本的功能。</p><p id="6568" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里只是版本化路径的几个示例，请注意URL。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/9905747dd7bf3be5f3975ab663e4c326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*t-Oj1xkXU0_Fh_6bWiBYvQ.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">应用程序的示例3，在v3路线上提供</figcaption></figure><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/6aed56ddf8116509cd287c8facf2a30f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*9WwGYxKBiSbKnM3bqbMvJQ.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">v1路线上的示例1</figcaption></figure><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/8ee2c760975253a391da872664c173b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*B0Q7Q2n-pgmLVlrZbVsq9Q.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">还是示例1，但这次是在最新的路由标记上。尼斯（法国城市名）</figcaption></figure><h2 id="955d" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">结论</h2><p id="b985" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">这就是Docker的简单结构。请稍后回来查看该系列的第三部分，在那里我将回顾Docker Swarm的神奇之处，它构建在Docker Compose之上。想象一下，在多台服务器上运行多个应用程序，只需几个配置文件，这些应用程序就能感知并相互交互。这真的很酷。</p><p id="95f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您的阅读，我希望您能像我一样有机会在自己的开发中使用Docker Compose。掌声非常感谢！</p><p id="8af5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢读这篇文章，你可能也会喜欢我的其他博客:</p><ul class=""><li id="0386" class="mi mj iq ka b kb kc kf kg kj mk kn ml kr mm kv mn mo mp mq bi translated"><a class="ae lf" href="https://medium.com/@paigen11/docker-101-fundamentals-the-dockerfile-b33b59d0f14b" rel="noopener"> Docker 101:基本面&amp;Docker file</a></li><li id="1b5a" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated"><a class="ae lf" href="https://medium.com/@paigen11/react-svg-images-and-the-webpack-loader-to-make-them-play-nice-2d177ae34d2b" rel="noopener"> React、SVG图像和Webpack加载器，使它们播放起来更好</a></li><li id="7392" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated"><a class="ae lf" href="https://medium.com/@paigen11/what-is-graphql-really-76c48e720202" rel="noopener">graph QL到底是什么？</a></li></ul></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="8702" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">参考资料和更多资源:</strong></p><ul class=""><li id="ec32" class="mi mj iq ka b kb kc kf kg kj mk kn ml kr mm kv mn mo mp mq bi translated">https://www.docker.com/what-docker</li><li id="6a3a" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">Docker撰写文档:<a class="ae lf" href="https://docs.docker.com/compose/overview/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/compose/overview/</a></li><li id="37e0" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">码头工人撰写示例报告:<a class="ae lf" href="https://github.com/paigen11/docker-compose-example" rel="noopener ugc nofollow" target="_blank">https://github.com/paigen11/docker-compose-example</a></li><li id="81ca" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">https://www.nginx.com/<a class="ae lf" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank">nginx</a></li><li id="bcae" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">蓝绿色部署，Cloud Foundry文档:<a class="ae lf" href="https://docs.cloudfoundry.org/devguide/deploy-apps/blue-green.html" rel="noopener ugc nofollow" target="_blank">https://docs . Cloud Foundry . org/dev guide/deploy-apps/blue-Green . html</a></li><li id="86c0" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">Canary部署，Octopus部署:<a class="ae lf" href="https://octopus.com/docs/deployment-patterns/canary-deployments" rel="noopener ugc nofollow" target="_blank">https://Octopus . com/docs/deployment-patterns/canary-Deployments</a></li></ul></div></div>    
</body>
</html>