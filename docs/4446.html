<html>
<head>
<title>Learn Golang by building a fintech banking app — Lesson6: DB connection Pool and Transaction History</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过构建金融科技银行应用了解Golang第6课:数据库连接池和交易历史</h1>
<blockquote>原文：<a href="https://itnext.io/learn-golang-by-building-a-fintech-banking-app-lesson6-db-connection-pool-and-transaction-740010e410b2?source=collection_archive---------2-----------------------#2020-07-02">https://itnext.io/learn-golang-by-building-a-fintech-banking-app-lesson6-db-connection-pool-and-transaction-740010e410b2?source=collection_archive---------2-----------------------#2020-07-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/bbcf8827d771e640bffd5378caa9adc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1cdxEBIet2waM_CuNHwZGw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://www.blog.duomly.com/golang-course-with-building-fintech-banking-app-lesson-6-db-connection-pool-and-transactions-history/" rel="noopener ugc nofollow" target="_blank"> Golang DB连接池</a></figcaption></figure><p id="e10a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文原载:<br/><a class="ae kf" href="https://www.blog.duomly.com/golang-course-with-building-fintech-banking-app-lesson-6-db-connection-pool-and-transactions-history/" rel="noopener ugc nofollow" target="_blank">https://www . blog . duomly . com/golang-course-with-building-fin tech-banking-app-lesson-6-d b-connection-pool-and-transactions-history/</a></p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="f27f" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">介绍</h1><p id="bf55" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在golang课程的第6课中，我们将讨论数据库连接池和事务历史。</p><p id="0ed5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在前面的课程中，我们构建了一些使项目更大的功能。</p><p id="8cd5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，您可以找到之前的五课:</p><p id="a951" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本课程的前几集，我们学习了如何进行迁移:</p><p id="16c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://www.blog.duomly.com/golang-course-with-building-a-fintech-banking-app-lesson-1-start-the-project/" rel="noopener ugc nofollow" target="_blank">构建金融科技银行应用的Golang课程——第1课:启动项目</a></p><p id="04ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们学习了如何进行用户登录:</p><p id="aa59" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://www.blog.duomly.com/golang-course-with-building-a-fintech-banking-app-lesson-2-login-and-rest-api/" rel="noopener ugc nofollow" target="_blank">构建金融科技银行应用的Golang课程——第2课:登录和REST API </a></p><p id="5f52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们学习了如何进行用户注册:</p><p id="d8a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://www.blog.duomly.com/golang-course-with-building-a-fintech-banking-app-lesson-3-user-registration/" rel="noopener ugc nofollow" target="_blank">构建金融科技银行应用的Golang课程——第3课:用户注册</a></p><p id="1ac7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们建立了用户认证，并从交易开始:</p><p id="ca8f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://www.blog.duomly.com/golang-course-with-building-a-fintech-banking-app-lesson-4-user-authentication-and-bank-transactions-part-1/" rel="noopener ugc nofollow" target="_blank">构建金融科技银行应用的Golang课程——第4课:用户认证和银行交易第1部分</a></p><p id="acfb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们完成了银行转账的可能性:</p><p id="c9be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://www.blog.duomly.com/golang-course-with-building-a-fintech-banking-app-lesson-5-bank-transactions-part-2/" rel="noopener ugc nofollow" target="_blank">构建金融科技银行应用的Golang课程——第5课:银行交易第2部分</a></p><p id="dbe9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你还需要记住我的朋友安娜创建的Angular 9球场:</p><p id="11ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://www.blog.duomly.com/angular-course-building-a-banking-application-with-tailwind-css-lesson-1-start-the-project/" rel="noopener ugc nofollow" target="_blank">使用Tailwind CSS构建银行应用程序的角度课程—第1课:启动项目</a></p><p id="f700" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天，我们可以关注事务历史和数据库连接池。</p><p id="9a31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将有助于我们避免当太多的请求进入游戏时出现DB-kills。</p><p id="8f7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">开始吧！</p><p id="0c17" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你喜欢视频，这是youtube的版本:</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Golang数据库连接池</figcaption></figure><h1 id="a28e" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">创建数据库包</h1><p id="5d76" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">作为第一步，我们需要创建一个新的包来处理所有的数据库逻辑。</p><p id="6421" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们需要创建一个名为“database”的目录，进入该目录后，我们需要创建一个名为“database.go”的文件，并进入该文件。</p><p id="bdd5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在文件内部，我们需要声明一个名为“database”的包。</p><pre class="mo mp mq mr gt mz na nb nc aw nd bi"><span id="5057" class="ne lm it na b gy nf ng l nh ni">package database</span></pre><h1 id="6bff" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">创建全局变量数据库</h1><p id="a03b" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">接下来，我们需要声明一个名为“DB”的变量，我们将用它来访问其他文件中的DB。</p><pre class="mo mp mq mr gt mz na nb nc aw nd bi"><span id="4178" class="ne lm it na b gy nf ng l nh ni">var DB *gorm.DB</span></pre><h1 id="d85e" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">创建函数InitDatabase</h1><p id="1d7b" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在第三步中，我们需要创建一个名为“InitDatabase”的函数，它将让我们与DB连接，并返回DB连接对象。</p><pre class="mo mp mq mr gt mz na nb nc aw nd bi"><span id="eca8" class="ne lm it na b gy nf ng l nh ni">func InitDatabase() {<br/>    database, err := gorm.Open("postgres", "host=127.0.0.1 port=5432 user=postgres dbname=bankapp password=postgres sslmode=disable")<br/>    helpers.HandleErr(err)<br/>    DB = database<br/>}</span></pre><h1 id="3298" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">设置连接池</h1><p id="d3c2" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">今天课程的主要内容之一是设置适当的连接池。</p><p id="7ac6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将在这一步中完成它。</p><p id="8654" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在“InitDatabase”函数中添加连接池，然后设置空闲连接数为20，最大连接数为200。</p><pre class="mo mp mq mr gt mz na nb nc aw nd bi"><span id="15cd" class="ne lm it na b gy nf ng l nh ni">func InitDatabase() {<br/>    database, err := gorm.Open("postgres", "host=127.0.0.1 port=5432 user=postgres dbname=bankapp password=postgres sslmode=disable")<br/>    helpers.HandleErr(err)<br/>    database.DB().SetMaxIdleConns(20)<br/>    database.DB().SetMaxOpenConns(200)<br/>    DB = database<br/>}</span></pre><h1 id="e813" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">在main.go中初始化数据库</h1><p id="9a5a" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我们已经创建了一个数据库包和数据库连接池。</p><p id="a146" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们需要通过在文件“main.go”和函数“main”中调用InitDatabase来开始使用它。</p><pre class="mo mp mq mr gt mz na nb nc aw nd bi"><span id="8183" class="ne lm it na b gy nf ng l nh ni">func main() {<br/>    database.InitDatabase()<br/>    api.StartApi()<br/>}</span></pre><h1 id="3871" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">从助手包中删除ConnectDB</h1><p id="362a" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">好了，当我们完成新的数据库设置后，我们可以进入helpers.go并删除函数“ConnectDB”。</p><h1 id="2ebe" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">在迁移中重构create accounts . go并记住始终删除关闭的数据库</h1><p id="0ec2" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">现在，我们可以开始重构使用DB连接的逻辑了。</p><p id="82d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们需要做的第一件事是migrations.go. <br/>中的函数“createAccounts ”,所以在重构数据库连接的每个地方，都需要记住删除数据库。Close()，否则每次调用后都会关闭DB，应用程序将停止工作。</p><pre class="mo mp mq mr gt mz na nb nc aw nd bi"><span id="c90b" class="ne lm it na b gy nf ng l nh ni">func createAccounts() {<br/>    users := &amp;[2]interfaces.User{<br/>        {Username: "Martin", Email: "martin@martin.com"},<br/>        {Username: "Michael", Email: "michael@michael.com"},<br/>    }<br/>    for i := 0; i &lt; len(users); i++ {<br/>        generatedPassword := helpers.HashAndSalt([]byte(users[i].Username))<br/>        user := &amp;interfaces.User{Username: users[i].Username, Email: users[i].Email, Password: generatedPassword}<br/>        database.DB.Create(&amp;user)</span><span id="15b7" class="ne lm it na b gy nj ng l nh ni">        account := &amp;interfaces.Account{Type: "Daily Account", Name: string(users[i].Username + "'s" + " account"), Balance: uint(10000 * int(i+1)), UserID: user.ID}<br/>        database.DB.Create(&amp;account)<br/>    }<br/>}</span></pre><h1 id="2ace" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">重构迁移</h1><p id="530c" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">下一步，我们需要重构函数“Migrate”。</p><p id="e776" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完成这一步后，我们将在一个函数中拥有所有与迁移相关的逻辑。</p><pre class="mo mp mq mr gt mz na nb nc aw nd bi"><span id="8fed" class="ne lm it na b gy nf ng l nh ni">func Migrate() {<br/>    User := &amp;interfaces.User{}<br/>    Account := &amp;interfaces.Account{}<br/>    Transactions := &amp;interfaces.Transaction{}<br/>    database.DB.AutoMigrate(&amp;User, &amp;Account, &amp;Transactions)</span><span id="de31" class="ne lm it na b gy nj ng l nh ni">    createAccounts()<br/>}</span></pre><h1 id="8f35" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">删除功能迁移事务</h1><p id="5242" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">现在，我们不再需要“MigrateTransactions”函数。</p><p id="861e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以删除。</p><h1 id="5524" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">transactions.go中的重构函数CreateTransaction</h1><p id="37e5" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在第四步中，我们需要重构“transactions.go”文件中的“CreateTransaction”函数，以开始使用新的数据库包。</p><pre class="mo mp mq mr gt mz na nb nc aw nd bi"><span id="6ddb" class="ne lm it na b gy nf ng l nh ni">func CreateTransaction(From uint, To uint, Amount int) {<br/>    transaction := &amp;interfaces.Transaction{From: From, To: To}<br/>    database.DB.Create(&amp;transaction)<br/>}</span></pre><h1 id="8470" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">重构函数updateAccount以使用数据库包</h1><p id="e9f5" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">接下来，进入“updateAccount”函数，像我们之前做的一样进行重构。</p><pre class="mo mp mq mr gt mz na nb nc aw nd bi"><span id="3f75" class="ne lm it na b gy nf ng l nh ni">func updateAccount(id uint, amount int) interfaces.ResponseAccount {<br/>    account := interfaces.Account{}<br/>    responseAcc := interfaces.ResponseAccount{}</span><span id="c455" class="ne lm it na b gy nj ng l nh ni">    database.DB.Where("id = ? ", id).First(&amp;account)<br/>    account.Balance = uint(amount)<br/>    database.DB.Save(&amp;account)</span><span id="4544" class="ne lm it na b gy nj ng l nh ni">    responseAcc.ID = account.ID<br/>    responseAcc.Name = account.Name<br/>    responseAcc.Balance = int(account.Balance)<br/>    return responseAcc<br/>}</span></pre><h1 id="3778" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">重构函数getAccount以使用数据库包</h1><p id="3101" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">对于新的数据库包，我们还有一些地方需要重构。</p><p id="617c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这一步中，我们将更新“useraccounts.go”文件中的“GetAccount”。</p><pre class="mo mp mq mr gt mz na nb nc aw nd bi"><span id="63fe" class="ne lm it na b gy nf ng l nh ni">func getAccount(id uint) *interfaces.Account{<br/>    account := &amp;interfaces.Account{}<br/>    if database.DB.Where("id = ? ", id).First(&amp;account).RecordNotFound() {<br/>        return nil<br/>    }<br/>    return account<br/>}</span></pre><h1 id="f434" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">重构函数登录以使用数据库包</h1><p id="ab42" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">接下来，我们可以进入文件“users.go”，重构函数“Login”。</p><pre class="mo mp mq mr gt mz na nb nc aw nd bi"><span id="e271" class="ne lm it na b gy nf ng l nh ni">func Login(username string, pass string) map[string]interface{} {<br/>    // Add validation to login<br/>    valid := helpers.Validation(<br/>        []interfaces.Validation{<br/>            {Value: username, Valid: "username"},<br/>            {Value: pass, Valid: "password"},<br/>        })<br/>    if valid {<br/>        user := &amp;interfaces.User{}<br/>        if database.DB.Where("username = ? ", username).First(&amp;user).RecordNotFound() {<br/>            return map[string]interface{}{"message": "User not found"}<br/>        }<br/>        // Verify password<br/>        passErr := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(pass))</span><span id="e707" class="ne lm it na b gy nj ng l nh ni">        if passErr == bcrypt.ErrMismatchedHashAndPassword &amp;&amp; passErr != nil {<br/>            return map[string]interface{}{"message": "Wrong password"}<br/>        }<br/>        // Find accounts for the user<br/>        accounts := []interfaces.ResponseAccount{}<br/>        database.DB.Table("accounts").Select("id, name, balance").Where("user_id = ? ", user.ID).Scan(&amp;accounts)<br/></span><span id="4f79" class="ne lm it na b gy nj ng l nh ni">        var response = prepareResponse(user, accounts, true);</span><span id="7379" class="ne lm it na b gy nj ng l nh ni">        return response<br/>    } else {<br/>        return map[string]interface{}{"message": "not valid values"}<br/>    }<br/>}</span></pre><h1 id="f48c" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">重构函数寄存器以使用数据库包</h1><p id="b712" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">这几乎是我们需要重构函数来使用新数据库包的最后一个地方。</p><p id="76e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在同一个文件“users.go”中，我们需要重构名为“Register”的函数。</p><pre class="mo mp mq mr gt mz na nb nc aw nd bi"><span id="1002" class="ne lm it na b gy nf ng l nh ni">func Register(username string, email string, pass string) map[string]interface{} {<br/>    // Add validation to registration<br/>    valid := helpers.Validation(<br/>        []interfaces.Validation{<br/>            {Value: username, Valid: "username"},<br/>            {Value: email, Valid: "email"},<br/>            {Value: pass, Valid: "password"},<br/>        })<br/>    if valid {<br/>        generatedPassword := helpers.HashAndSalt([]byte(pass))<br/>        user := &amp;interfaces.User{Username: username, Email: email, Password: generatedPassword}<br/>        database.DB.Create(&amp;user)</span><span id="df5e" class="ne lm it na b gy nj ng l nh ni">        account := &amp;interfaces.Account{Type: "Daily Account", Name: string(username + "'s" + " account"), Balance: 0, UserID: user.ID}<br/>        database.DB.Create(&amp;account)</span><span id="a634" class="ne lm it na b gy nj ng l nh ni">        accounts := []interfaces.ResponseAccount{}<br/>        respAccount := interfaces.ResponseAccount{ID: account.ID, Name: account.Name, Balance: int(account.Balance)}<br/>        accounts = append(accounts, respAccount)<br/>        var response = prepareResponse(user, accounts, true)</span><span id="bc60" class="ne lm it na b gy nj ng l nh ni">        return response<br/>    } else {<br/>        return map[string]interface{}{"message": "not valid values"}<br/>    }</span><span id="dc36" class="ne lm it na b gy nj ng l nh ni">}</span></pre><h1 id="9662" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">重构函数GetUser</h1><p id="ad77" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">呜哇！这是我们需要为数据库包替换db连接的最后一个地方。</p><p id="cf71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以类似的方式重构名为“GetUser”的函数，互为补充。</p><pre class="mo mp mq mr gt mz na nb nc aw nd bi"><span id="3ca8" class="ne lm it na b gy nf ng l nh ni">func GetUser(id string, jwt string) map[string]interface{} {<br/>    isValid := helpers.ValidateToken(id, jwt)<br/>    // Find and return user<br/>    if isValid {<br/>        user := &amp;interfaces.User{}<br/>        if database.DB.Where("id = ? ", id).First(&amp;user).RecordNotFound() {<br/>            return map[string]interface{}{"message": "User not found"}<br/>        }<br/>        accounts := []interfaces.ResponseAccount{}<br/>        database.DB.Table("accounts").Select("id, name, balance").Where("user_id = ? ", user.ID).Scan(&amp;accounts)</span><span id="333f" class="ne lm it na b gy nj ng l nh ni">        var response = prepareResponse(user, accounts, false);<br/>        return response<br/>    } else {<br/>        return map[string]interface{}{"message": "Not valid token"}<br/>     }<br/>}</span></pre><h1 id="d05a" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">创建接口响应事务</h1><p id="bfc9" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">恭喜，所有的数据库重构都完成了！</p><p id="c0ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们可以进入交易历史。</p><p id="7581" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，作为第一步，您需要进入interfaces.go并创建结构“ResponseTransaction”。</p><p id="1799" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它应该有四个属性，ID为uint，From为uint，To为uint，Amount为int。</p><pre class="mo mp mq mr gt mz na nb nc aw nd bi"><span id="8265" class="ne lm it na b gy nf ng l nh ni">type ResponseTransaction struct {<br/>    ID uint<br/>    From uint<br/>    To uint<br/>    Amount int<br/>}</span></pre><h1 id="697f" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">创建函数GetTransationsByAccount</h1><p id="7c9d" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">下一步，我们可以进入文件“transactions.go ”,开始创建与获取事务相关的逻辑。</p><p id="3e8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">和第一个一样，我们需要创建一个函数“GetTransactionsByAccount”。</p><p id="ff68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该函数将id作为uint，并返回“ResponseTransaction”的数组。</p><p id="f4f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该逻辑将查找prop“from”或“to”等于我们作为参数传递的帐户id的交易。</p><pre class="mo mp mq mr gt mz na nb nc aw nd bi"><span id="ee0e" class="ne lm it na b gy nf ng l nh ni">func GetTransactionsByAccount(id uint) []interfaces.ResponseTransaction{<br/>    transactions := []interfaces.ResponseTransaction{}<br/>    database.DB.Table("transactions").Select("id, transactions.from, transactions.to, amount").Where(interfaces.Transaction{From: id}).Or(interfaces.Transaction{To: id}).Scan(&amp;transactions)<br/>    return transactions<br/>}</span></pre><h1 id="09e5" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">创建函数GetMyTransactions</h1><p id="2593" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我们需要创建的下一个函数应该命名为“GetMyTransactions ”,并将id和jwt作为参数，两者都是字符串。</p><p id="f028" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数应返回“map[string]interface{}”。</p><pre class="mo mp mq mr gt mz na nb nc aw nd bi"><span id="abb8" class="ne lm it na b gy nf ng l nh ni">func GetMyTransactions(id string, jwt string) map[string]interface{} {</span><span id="c4e6" class="ne lm it na b gy nj ng l nh ni">}</span></pre><h1 id="b356" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">验证JWT</h1><p id="3e7a" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在函数“GetMyTransactions”中，我们应该验证JWT令牌。</p><p id="ff9d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果令牌没问题，我们可以进入逻辑。如果不是，我们应该返回消息“无效令牌”的响应。</p><pre class="mo mp mq mr gt mz na nb nc aw nd bi"><span id="0c29" class="ne lm it na b gy nf ng l nh ni">func GetMyTransactions(id string, jwt string) map[string]interface{} {<br/>  isValid := helpers.ValidateToken(id, jwt)<br/>    if isValid {</span><span id="6834" class="ne lm it na b gy nj ng l nh ni">  } else {<br/>        return map[string]interface{}{"message": "Not valid token"}<br/>    }<br/>}</span></pre><h1 id="dc63" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">查找并返回交易记录</h1><p id="07c1" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">好了，现在我们可以进入“GetMyTransactions”的逻辑了。</p><p id="e12c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为第一步，我们应该寻找与我们的用户相关的所有帐户。</p><p id="0cb1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们应该遍历所有的帐户，并开始查找与该帐户相关的交易，我们将把这些交易添加到“transactions”数组中。</p><p id="4715" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为最后一步，我们应该将它们返回给用户。</p><pre class="mo mp mq mr gt mz na nb nc aw nd bi"><span id="7cc1" class="ne lm it na b gy nf ng l nh ni">func GetMyTransactions(id string, jwt string) map[string]interface{} {<br/>  isValid := helpers.ValidateToken(id, jwt)<br/>    if isValid {<br/>        accounts := []interfaces.ResponseAccount{}<br/>        database.DB.Table("accounts").Select("id, name, balance").Where("user_id = ? ", id).Scan(&amp;accounts)</span><span id="968b" class="ne lm it na b gy nj ng l nh ni">        transactions := []interfaces.ResponseTransaction{}<br/>        for i := 0; i &lt; len(accounts); i++ {<br/>            accTransactions := GetTransactionsByAccount(accounts[i].ID)<br/>            transactions = append(transactions, accTransactions...)<br/>        }</span><span id="041e" class="ne lm it na b gy nj ng l nh ni">        var response = map[string]interface{}{"message": "all is fine"}<br/>        response["data"] = transactions<br/>        return response<br/>  } else {<br/>        return map[string]interface{}{"message": "Not valid token"}<br/>    }<br/>}</span></pre><h1 id="fb43" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">在api.go中创建函数getMyTransactions</h1><p id="798c" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我们几乎准备好了！</p><p id="d95a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们可以进入文件“api.go ”,并创建函数“getMyTransactions”。</p><p id="12ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似于“getUser”的函数应该处理“userID”和授权。</p><p id="2820" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们应该将它传递给“GetMyTransactions”函数，并将所有内容返回给用户。</p><pre class="mo mp mq mr gt mz na nb nc aw nd bi"><span id="375d" class="ne lm it na b gy nf ng l nh ni">func getMyTransactions(w http.ResponseWriter, r *http.Request) {<br/>    vars := mux.Vars(r)<br/>    userId := vars["userID"]<br/>    auth := r.Header.Get("Authorization")</span><span id="93cb" class="ne lm it na b gy nj ng l nh ni">    transactions := transactions.GetMyTransactions(userId, auth)<br/>    apiResponse(transactions, w)<br/>}</span></pre><h1 id="4e5a" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">处理API端点</h1><p id="12d8" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">最后一步，我们只需要处理路由中的API端点。</p><pre class="mo mp mq mr gt mz na nb nc aw nd bi"><span id="b339" class="ne lm it na b gy nf ng l nh ni">func StartApi() {<br/>    router := mux.NewRouter()<br/>    // Add panic handler middleware<br/>    router.Use(helpers.PanicHandler)<br/>    router.HandleFunc("/login", login).Methods("POST")<br/>    router.HandleFunc("/register", register).Methods("POST")<br/>    router.HandleFunc("/transaction", transaction).Methods("POST")<br/>    router.HandleFunc("/transactions/{userID}", getMyTransactions).Methods("GET")<br/>    router.HandleFunc("/user/{id}", getUser).Methods("GET")<br/>    fmt.Println("App is working on port :8888")<br/>    log.Fatal(http.ListenAndServe(":8888", router))<br/>}</span></pre><h1 id="5c67" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">结论</h1><p id="62bd" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">恭喜你，你的代码现在看起来好多了！</p><p id="a710" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望今天的重构教会了你项目的开始，新功能的开发很容易，但如果项目增长，维护可能会有问题。</p><p id="f485" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们构建了一些新的功能，比如事务历史，并修复了一些大代码问题，但这并不是应该修复的全部。</p><p id="7b6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在接下来的几集里，我们将讨论使用SQL关系，这将帮助我们避免许多我们需要做的调用，只要使用Golang关联。</p><p id="0bb5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将教会你如何在项目开始时实施一些好的实践来节省我们大量的时间和工作。</p><p id="4d7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天课程的代码可以在这里找到:<br/><a class="ae kf" href="https://github.com/Duomly/go-bank-backend/tree/Golang-course-Lesson-6" rel="noopener ugc nofollow" target="_blank">https://github . com/Duomly/go-bank-back end/tree/Golang-course-Lesson-6</a></p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/03d18bac6abce30b3e43642dbc2e8504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fkPMC44a-mwUTL1FE_VBlw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://www.duomly.com?code=lifetime-80" rel="noopener ugc nofollow" target="_blank">多美滋促销代码</a></figcaption></figure><p id="b6dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读，<br/>来自Duomly的Radek</p></div></div>    
</body>
</html>