<html>
<head>
<title>Getting Started with .NET Core</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开始使用。网络核心</h1>
<blockquote>原文：<a href="https://itnext.io/getting-started-with-net-core-9b26a096fa7f?source=collection_archive---------1-----------------------#2019-08-28">https://itnext.io/getting-started-with-net-core-9b26a096fa7f?source=collection_archive---------1-----------------------#2019-08-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="29d5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何用？网络核心</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/80b9d7580ebded18cc5ed39b2a121eba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZWfdBVyNFODSviNqsjbMog.png"/></div></div></figure><h2 id="a281" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">介绍</h2><p id="9bf7" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi mj translated">随着开源软件的兴起和每年涌现的强大新技术，微软越来越多地参与到开源项目中，其中之一就是。网芯。</p><p id="9444" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly ld mu ma mb lh mv md me ll mw mg mh mi im bi translated">这个框架为支持微软技术的开发人员和组织提供了一个开始迁移到开源模型的机会，也为那些主要在开源技术方面有经验的人提供了一个开始使用微软工具和框架的机会。</p><p id="8d91" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly ld mu ma mb lh mv md me ll mw mg mh mi im bi translated">这种高价值的技术交叉为将遗留系统迁移到现代体系结构、桥接通常难以连接的系统以及与来自整个行业的在各种工具和方法方面受过交叉培训的团队一起开发新软件开辟了新的可能性。</p><p id="a846" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly ld mu ma mb lh mv md me ll mw mg mh mi im bi translated">在本文中，我们将看看如何用基本的CRUD实现为具有属性<em class="mx">名称</em>和<em class="mx">描述</em>的模拟项构建一个简单的REST API。</p><p id="a266" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly ld mu ma mb lh mv md me ll mw mg mh mi im bi translated">本文使用的源代码副本可以在GitHub 上的<a class="ae my" href="https://github.com/kenreilly/dotnet-core-example" rel="noopener ugc nofollow" target="_blank">处获得。</a></p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h2 id="9eeb" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><strong class="ak">项目设置</strong></h2><p id="f89e" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">如果你还没有。NET代码，<a class="ae my" href="https://dotnet.microsoft.com/download" rel="noopener ugc nofollow" target="_blank">在这里为你的操作系统抓取一个副本</a>。</p><p id="7533" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly ld mu ma mb lh mv md me ll mw mg mh mi im bi translated">这个项目是用<code class="fe ng nh ni nj b">dotnet new webapi -o ItemsAPI</code>初始化的。NET Core样板文件放在<code class="fe ng nh ni nj b">ItemsAPI</code> <em class="mx"> </em>文件夹中。该应用程序的项目配置文件创建于<strong class="ls iu"> ItemsAPI.csproj </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8344" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly ld mu ma mb lh mv md me ll mw mg mh mi im bi translated">该文件定义了项目本身的配置细节，例如。应用程序所需的. NET Framework版本和包。这个项目不使用任何额外的包，但是如果添加的话，它们会作为另一个<code class="fe ng nh ni nj b">&lt;PackageReference&gt;</code>条目附加到<code class="fe ng nh ni nj b">&lt;ItemGroup&gt;</code>中。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h2 id="4b51" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">应用程序入口点</h2><p id="7261" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">定义这个服务器应用程序入口点的文件是<strong class="ls iu"> Program.cs </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="528d" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly ld mu ma mb lh mv md me ll mw mg mh mi im bi translated">当使用命令<code class="fe ng nh ni nj b">dotnet run</code>启动该应用时，调用<em class="mx"> Main </em>方法，然后调用<em class="mx"> CreateWebHostBuilder </em>，使用<strong class="ls iu"> Startup </strong>类(包含应用启动配置)创建一个构建器。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h2 id="1bfa" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">启动配置</h2><p id="ccea" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">接下来是前面提到的<strong class="ls iu"> Startup </strong>类，在<strong class="ls iu"> Startup.cs </strong>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8cab" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly ld mu ma mb lh mv md me ll mw mg mh mi im bi translated">在该类中，定义了以下启动配置:</p><ul class=""><li id="955f" class="nm nn it ls b lt ms lw mt ld no lh np ll nq mi nr ns nt nu bi translated">服务，在<em class="mx"> ConfigureServices方法</em>中</li><li id="0212" class="nm nn it ls b lt nv lw nw ld nx lh ny ll nz mi nr ns nt nu bi translated">HTTP请求管道，在<em class="mx">中配置</em>方法</li></ul><p id="4c7f" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly ld mu ma mb lh mv md me ll mw mg mh mi im bi translated">在<em class="mx">配置</em>中，还有一个检查来确定应用程序当前是否在开发模式下运行。这当然是特定于开发、测试、生产或其他的配置例程运行的地方。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h2 id="0ce9" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><strong class="ak">items controller类</strong></h2><p id="3166" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">接下来是控制器文件<strong class="ls iu">Controllers/items controller . cs</strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="61b3" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly ld mu ma mb lh mv md me ll mw mg mh mi im bi translated"><strong class="ls iu"> ItemsController </strong>类具有属性<code class="fe ng nh ni nj b">Route</code>和<code class="fe ng nh ni nj b">ApiController</code>，这两个属性将控制器配置为在定义的路由上的API上使用。</p><p id="b526" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly ld mu ma mb lh mv md me ll mw mg mh mi im bi translated">属性<em class="mx"> items </em>是一个<strong class="ls iu">列表&lt;Item&gt;T24】，它保存了一个<strong class="ls iu"> Item </strong>对象列表，作为该应用程序的数据存储。在实践中，任何合适的存储或消息传递解决方案都可以用于任何必要的目的，但这是在搭建项目时保持设计简单的一个好例子，因为这种临时模拟解决方案只需要几秒钟就可以实现，并且具有静态、内部和易于恢复到干净状态(通过简单地重新启动服务器)的优点，所有这些都非常适合快速设置和测试概念或想法(因为出错的地方更少)。</strong></p><p id="de84" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly ld mu ma mb lh mv md me ll mw mg mh mi im bi translated">除了<code class="fe ng nh ni nj b">Post()</code>、<code class="fe ng nh ni nj b">Put()</code>和<code class="fe ng nh ni nj b">Delete()</code>之外，这个类中还定义了几个<code class="fe ng nh ni nj b">Get()</code>方法，它们构成了一组基本的<a class="ae my" href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" rel="noopener ugc nofollow" target="_blank"> CRUD </a>操作。每一个都有一个装饰符作为前缀，比如<code class="fe ng nh ni nj b">[HttpGet]</code>等等，它向框架指示除了(可选的)REST端点将被服务的路径之外，还将实现什么HTTP方法。</p><p id="c5eb" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly ld mu ma mb lh mv md me ll mw mg mh mi im bi translated">此示例API实现了以下HTTP方法:</p><ul class=""><li id="b64e" class="nm nn it ls b lt ms lw mt ld no lh np ll nq mi nr ns nt nu bi translated"><code class="fe ng nh ni nj b">[HttpGet]</code> <em class="mx">(返回存储项目列表)</em></li><li id="547a" class="nm nn it ls b lt nv lw nw ld nx lh ny ll nz mi nr ns nt nu bi translated"><code class="fe ng nh ni nj b">[HttpGet("{index}")]</code> <em class="mx">(返回列表项的</em> <strong class="ls iu"> <em class="mx">索引</em> </strong> <em class="mx"> ) </em></li><li id="dda8" class="nm nn it ls b lt nv lw nw ld nx lh ny ll nz mi nr ns nt nu bi translated"><code class="fe ng nh ni nj b">[HttpGet("/range/{a}/to/{b}")]</code> <em class="mx">(返回列表项</em> <strong class="ls iu"> <em class="mx"> a </em> </strong> <em class="mx">到</em><strong class="ls iu"><em class="mx">b</em></strong><em class="mx">)</em></li><li id="39df" class="nm nn it ls b lt nv lw nw ld nx lh ny ll nz mi nr ns nt nu bi translated"><code class="fe ng nh ni nj b">[HttpPost]</code> <em class="mx">(在JSON主体的列表中追加一个</em> <strong class="ls iu"> <em class="mx">项</em></strong><em class="mx">)</em></li><li id="7d84" class="nm nn it ls b lt nv lw nw ld nx lh ny ll nz mi nr ns nt nu bi translated"><code class="fe ng nh ni nj b">[HttpPut("{index}")]</code> <em class="mx">(替换</em> <strong class="ls iu"> <em class="mx">索引</em> </strong> <em class="mx"> ) </em></li><li id="49e0" class="nm nn it ls b lt nv lw nw ld nx lh ny ll nz mi nr ns nt nu bi translated"><code class="fe ng nh ni nj b">[HttpDelete("{index}")]</code> <em class="mx">(删除</em> <strong class="ls iu"> <em class="mx">索引</em> </strong> <em class="mx"> ) </em></li></ul><p id="448e" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly ld mu ma mb lh mv md me ll mw mg mh mi im bi translated">这里使用的<strong class="ls iu"> Item </strong>类定义了每个端点应该从传入的JSON数据和临时数据存储(条目列表)中获得哪些属性。这允许框架拒绝不适当的请求，并且除了代码完成和其他好处之外，还通过提供编辑时和编译时错误检查来帮助开发。接下来我们将看看Item类。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h2 id="7369" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">项目分类</h2><p id="1a24" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">最后一个是<strong class="ls iu"> Item </strong>类，在<strong class="ls iu"> Models/Items.cs </strong>中定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="83b0" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly ld mu ma mb lh mv md me ll mw mg mh mi im bi translated">这个文件非常简单明了，它定义了属性<em class="mx">名称</em>和<em class="mx">描述</em>来为一个项目创建一个标准的数据结构。这里，为每个属性定义了默认的<em class="mx"> get </em>和<em class="mx"> set </em>访问器，但是这些访问器可以进一步详细定义，以提供更大程度的控制和数据验证。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h2 id="5cfb" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">测试</h2><p id="40fc" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">要启动服务器，在终端中运行命令<code class="fe ng nh ni nj b">$ ./api-start.sh</code>(或者从VS代码中启动)。接下来，打开一个新的终端会话，并运行这些命令来执行它们各自命名的操作:</p><pre class="kj kk kl km gt oa nj ob oc aw od bi"><span id="0476" class="ku kv it nj b gy oe of l og oh">$ ./api-add-item.sh "Item Name" "Some item description text"</span></pre><p id="62a0" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly ld mu ma mb lh mv md me ll mw mg mh mi im bi translated"><code class="fe ng nh ni nj b">./api-add-item.sh</code>脚本向API发送<code class="fe ng nh ni nj b">HTTP POST</code>请求，传递与<strong class="ls iu">项目</strong>的结构匹配的JSON请求对象中的数据，该对象向列表中添加一个新项目，并返回该项目的<strong class="ls iu"> <em class="mx">索引</em> </strong>。</p><pre class="kj kk kl km gt oa nj ob oc aw od bi"><span id="d675" class="ku kv it nj b gy oe of l og oh">$ ./api-list-items.sh</span></pre><p id="732b" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly ld mu ma mb lh mv md me ll mw mg mh mi im bi translated">这个脚本向API发送一个<code class="fe ng nh ni nj b">HTTP GET</code>，它只是以序列化JSON响应字符串的形式返回一个先前添加的项目列表。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h2 id="e2ec" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">结论</h2><p id="8279" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">这篇文章展示了进入。NET核心开发，它提供了强大而富于表现力的<a class="ae my" href="https://docs.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/" rel="noopener ugc nofollow" target="_blank"> C#语言</a>本身以及。NET框架和<a class="ae my" href="https://www.nuget.org/packages" rel="noopener ugc nofollow" target="_blank"> NuGet包</a>库，使开发人员能够快速利用和构建开发人员社区的经验。</p><p id="6969" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly ld mu ma mb lh mv md me ll mw mg mh mi im bi translated">这个示例API应用程序是作为GitHub 上的一个开源项目<a class="ae my" href="https://github.com/kenreilly/dotnet-core-example" rel="noopener ugc nofollow" target="_blank">提供的，可以派生出一个新的API服务器来服务于任何目的。</a></p><p id="4174" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly ld mu ma mb lh mv md me ll mw mg mh mi im bi translated">感谢你的阅读，祝你下次好运。网芯工程！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/adcffba36ba9b9fa58cf689414c9c330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*URI8TYidHyZSD7zLzRx6bA.gif"/></div></div><figcaption class="oj ok gj gh gi ol om bd b be z dk translated">运行中的API的屏幕截图</figcaption></figure></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><blockquote class="on"><p id="2994" class="oo op it bd oq or os ot ou ov ow mi dk translated">肯尼斯·雷利(<a class="ae my" href="https://twitter.com/8_bit_hacker" rel="noopener ugc nofollow" target="_blank"> 8_bit_hacker </a>)是<a class="ae my" href="https://lvl-up.tech/" rel="noopener ugc nofollow" target="_blank"> LevelUP </a>的CTO</p></blockquote></div></div>    
</body>
</html>