<html>
<head>
<title>Docker, Kaniko, Buildah</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker，Kaniko，Buildah</h1>
<blockquote>原文：<a href="https://itnext.io/docker-kaniko-buildah-209abdde5f94?source=collection_archive---------1-----------------------#2021-05-03">https://itnext.io/docker-kaniko-buildah-209abdde5f94?source=collection_archive---------1-----------------------#2021-05-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="86c8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建容器映像的不同方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/36d19594be9d0b767030e107e9eefbc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DKGDvJbFJ-5dWVV3OqhmeA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@hudsoncrafted?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">王思然·哈德森</a>在<a class="ae ky" href="https://unsplash.com/s/photos/build?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a92e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2015年，Docker和其他一些容器技术领导者创建了OCI <a class="ae ky" href="https://opencontainers.org/" rel="noopener ugc nofollow" target="_blank">(开放容器倡议)</a>来定义:</p><ul class=""><li id="4d51" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">图像规范:容器图像必须如何构造</li><li id="931f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">运行时规范:容器必须如何根据映像规范运行</li></ul><p id="a21a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命令<code class="fe mj mk ml mm b">docker image build</code>可能是最著名的创建容器映像的命令。然而，在Docker之上，还有其他工具知道如何构建一个映像(如何构建其文件系统并提供相关的元数据),以便它符合映像规范。</p><p id="b213" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将在GitLab CI管道环境中说明其中3种工具的用法:</p><ul class=""><li id="a50d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://docker.com" rel="noopener ugc nofollow" target="_blank">码头工人</a></li><li id="63ee" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/GoogleContainerTools/kaniko" rel="noopener ugc nofollow" target="_blank"> Kaniko </a></li><li id="9720" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://buildah.io/" rel="noopener ugc nofollow" target="_blank"> Buildah </a></li></ul><p id="7773" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，我们将在VotingApp的上下文中说明这一点，这是一个示例微服务应用程序，我经常使用它来说明各种技术。</p><p id="e8e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ℹ️:如果你不知道VotingApp，请查看这篇介绍该应用程序、其架构和不同版本的短文。</p><p id="e94c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">额外的上下文:</p><ul class=""><li id="27d2" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">VotingApp的每个微服务都有自己在<em class="mn">中定义的GitLab CI管道。gitlab-ci.yaml </em>文件(每个存储库中一个)</li><li id="cde5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">vote-ui</code>、<code class="fe mj mk ml mm b">vote</code>、<code class="fe mj mk ml mm b">result-ui</code>的管道使用Docker构建映像，<code class="fe mj mk ml mm b">result</code>使用Kaniko，<code class="fe mj mk ml mm b">worker</code>使用Buildah，所以这三种技术在VotingApp中有说明</li><li id="6027" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">当源代码被推入存储库时，CI被触发，命令在<em class="mn">中指定。gitlab-ci.yaml </em>被执行。这将为当前微服务构建一个映像，并将该映像推送到GitLab注册表中</li></ul><p id="cfd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看一个使用Docker从GitLab CI管道构建映像的例子。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/68e94421f1d705420781307597dec91f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*rekIjfYBRiS4G5pboW4wgg.png"/></div></figure><p id="1182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">微服务(以及其他一些服务)使用Docker构建一个图像，并将其推送到GitLab注册表。下面是<em class="mn">的部分。gitlab-ci.yaml </em>定义此步骤:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/a7c3f1165b8df4b6730da51c6f6c5283.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sSJw86rHVcBNRMX35C3h-g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用Docker构建容器映像</figcaption></figure><p id="b7cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，容器映像是基于<strong class="lb iu"> docker:19-dind </strong>，<strong class="lb iu"> </strong>安装了docker守护程序的映像在容器内构建的。</p><p id="d22a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ℹ️·丁德代表Docker中的Docker，Docker中的Docker running</p><p id="0581" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回顾一下<code class="fe mj mk ml mm b">script</code>属性中的每个命令(每行一个):</p><ul class=""><li id="83a3" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第一个命令仅用于根据已经提交的git分支的名称来设置TAG环境变量:如果<code class="fe mj mk ml mm b">master</code>那么我们将使用tag <code class="fe mj mk ml mm b">latest</code>在任何其他情况下我们将使用分支的名称</li><li id="3339" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用第二个命令是为了让Docker守护进程可以登录GitLab注册表。在GitLab CI作业中，我们可以使用CI_JOB_TOKEN，这是一个仅在作业期间可用的临时令牌(顺便说一下，这非常方便，因此我们不必提供凭据)</li><li id="7c2d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第三个命令是一个常规的<code class="fe mj mk ml mm b">docker image build</code>，它创建一个名为<code class="fe mj mk ml mm b">$CI_REGISTRY_IMAGE:$TAG</code>的图像。如果我们推动掌握这个名称将因此成为<code class="fe mj mk ml mm b">registry.gitlab.com/voting-application/vote:latest</code></li><li id="3cbc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">最后一个命令是常规的<code class="fe mj mk ml mm b">docker image push</code>，它将之前创建的图像发送到GitLab注册表中</li></ul><p id="c61f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们查看一下<code class="fe mj mk ml mm b">vote</code>微服务的容器注册表，我们可以看到有4个图像标签。每一个都是在相应的git分支(主分支、v1、v2和v3)被推送之后创建的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/2222b1dd55e4a1949ff2b5e6bf2f836f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GJmGmlAlx1uAB8kstk_v3w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">投票微服务的容器注册表中的现有图像标签</figcaption></figure><p id="edb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我猜你们中的许多人已经习惯了这些步骤，并且可能已经通过命令行运行了数百次。现在让我们看看另一个可以构建容器图像的工具:<a class="ae ky" href="https://github.com/GoogleContainerTools/kaniko" rel="noopener ugc nofollow" target="_blank"> Kaniko </a>。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/6c70fc4d43a1af34f2dfbd95e37b23f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VKL-Byx-GSAOl82ytNe8RQ.png"/></div></div></figure><p id="eb44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kaniko是一个在容器或Kubernetes集群中从docker文件构建容器映像的工具。Kaniko不依赖Docker守护进程，完全在用户空间执行Docker文件中的每个命令，不需要运行守护进程。</p><p id="83ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">result</code>微服务使用Kaniko构建映像并将其推送到GitLab注册表。下面是<em class="mn">的部分。gitlab-ci.yaml </em>定义这一步。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/a97b1798e914fb774ed1d39a9844b8fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zBSOtFZiGfaSAtg08Z7w2w.png"/></div></div></figure><p id="a2e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，图像是在一个基于<code class="fe mj mk ml mm b">gcr.io/kaniko-project/executor</code>(以其<code class="fe mj mk ml mm b">debug</code>风格)的容器中构建的。</p><p id="b79d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ℹ️一个以<code class="fe mj mk ml mm b">gcr.io</code>开头的图片存放在<a class="ae ky" href="https://cloud.google.com/container-registry/" rel="noopener ugc nofollow" target="_blank">谷歌容器注册表</a>中</p><p id="4feb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回顾一下<code class="fe mj mk ml mm b">script</code>属性中的每个命令:</p><ul class=""><li id="dda1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第一个命令用于设置TAG环境变量，正如我们在前面的例子中看到的那样</li><li id="fa85" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第二个命令创建了<em class="mn"> /kaniko/。kaniko稍后将使用的docker </em>文件夹</li><li id="9a73" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第三个命令创建一个<em class="mn"> config.json </em>文件，其中包含Kaniko用来连接GitLab注册表的凭证。这个<em class="mn"> config.json </em>文件位于上一步创建的文件夹中</li><li id="5a0c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">最后一个命令是对Kaniko executor的调用，它创建并推送图像</li></ul><p id="cd60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们查看一下<code class="fe mj mk ml mm b">result</code>微服务的容器注册表，我们可以看到有4个图像标签。每一个都是在相应的git分支(主分支、v1、v2和v3)被推送之后创建的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/6d697b536f932456fc9a698e9cb7db64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N4Ttep_idPWgc3Nm0iZOlA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">结果微服务的容器注册表中的现有图像标签</figcaption></figure></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/4dd49841e562ddd67efa7a1eaa48f11e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bc7mHFdsodZOP8ULfXaRHA.png"/></div></div></figure><p id="b0fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://buildah.io/" rel="noopener ugc nofollow" target="_blank"> Buildah </a>是一个基于Linux的开源工具，它可以构建开放容器倡议(OCI)容器映像，而无需安装完整的容器运行时或守护程序。可以从docker文件或以交互方式构建图像。如果你想知道更多，这篇<a class="ae ky" href="https://developers.redhat.com/blog/2021/01/11/getting-started-with-buildah/" rel="noopener ugc nofollow" target="_blank">伟大的文章</a>将帮助你开始使用<a class="ae ky" href="https://buildah.io/" rel="noopener ugc nofollow" target="_blank"> Buildah </a>。</p><p id="ba30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">worker</code>微服务使用Buildah构建映像并将其推送到GitLab注册表。下面是<em class="mn">的部分。gitlab-ci.yaml </em>定义这个步骤，在这个例子中我们将只考虑<strong class="lb iu"> Go </strong>版本，但是这个方法对于其他语言是相同的。</p><p id="b6e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ℹ️<code class="fe mj mk ml mm b">worker</code>与我们看到的第一批微服务不同。每个版本的worker都有一个构建块(意味着每种语言)，以确保如果只修改Go源代码，不会重新构建所有映像。可能有另一种(更干净的)方法可以做到这一点:)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/73e7c0396e3b470374e8272ee65bb9eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7af3cqmQOfYhM1hHP97j8g.png"/></div></div></figure><p id="a2fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，图像是在基于<code class="fe mj mk ml mm b">ubuntu:20.10</code>的容器中构建的。</p><p id="8a32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回顾一下<code class="fe mj mk ml mm b">script</code>属性中的每个命令:</p><ul class=""><li id="3cd9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第一个命令安装buildah和runc</li><li id="374b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用第二个命令是为了让Docker守护进程可以登录GitLab注册表，就像我们在第一个例子中看到的那样</li><li id="ef94" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第三个命令从与Go版本相关的Dockerfile构建映像(<em class="mn"> Dockerfile.go </em>)。</li><li id="ec23" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">最后一个命令将图像推送到注册表</li></ul><p id="c4f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，本例中使用的命令与第一个使用DinD方法的例子中使用的命令非常接近。</p><p id="4e80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们查看一下<code class="fe mj mk ml mm b">worker</code>微服务的容器注册表，我们可以看到有4个图像标签，每个标签对应一个工人的磁偏角。NET，Java，Go，Rust)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/75417f276b942ce9321b2caa17031926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nsjY9BkzzWuY_tVlJYto5A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">worker微服务的容器注册表中的现有图像标签</figcaption></figure></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="d261" class="nd ne it bd nf ng nh dn ni nj nk dp nl li nm nn no lm np nq nr lq ns nt nu nv bi translated">关键外卖</h2><p id="f0aa" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">在这篇短文中，我们展示了几个工具的用法，这些工具知道如何构建容器映像(因此遵守了OCI映像规范)。</p><p id="3e46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从应用程序的角度来看，如果图像是用Docker、Kaniko或Buildah构建的，它不会改变任何东西，因为图像格式是标准化的。</p><p id="1693" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一篇文章中，我们将确保所有图像都为多拱做好准备，这样VotingApp也可以在ARM设备上运行。</p></div></div>    
</body>
</html>