<html>
<head>
<title>Serverless framework’s resource hell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器框架的资源地狱</h1>
<blockquote>原文：<a href="https://itnext.io/serverless-frameworks-resource-hell-44cd4293b027?source=collection_archive---------4-----------------------#2019-05-30">https://itnext.io/serverless-frameworks-resource-hell-44cd4293b027?source=collection_archive---------4-----------------------#2019-05-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/deba1cfd0f499a379337dc035476a2e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Wp8avo74S8M39H5mIiHWg@2x.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">全栈狗破坏了这个博客的主旨🙁</figcaption></figure><p id="7943" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"><em class="ld">(2019年7月24日更新—增加了关于AWS CDK的信息)</em> </strong></p><p id="e5fa" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你好，又见面了。这次让我们来谈谈我非常喜欢的无服务器框架。完全免责声明:我下面说的一切都是我的个人意见，基于我在这个了不起的工具的帮助下管理一堆lambda函数的经验。</p><p id="2c4c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">首先，对于那些不知道的人来说，无服务器框架是一个软件套件，它极大地简化了基于FaaS的系统的组成和部署。在AWS世界中，这意味着框架上传您的代码并为您的项目创建一个CloudFormation堆栈，该堆栈由一个或多个lambda函数和其他所需的AWS资源组成——lambda触发器、数据库、IAM角色等等。你可以在这里了解更多关于<a class="ae le" href="https://serverless.com" rel="noopener ugc nofollow" target="_blank">的信息。从现在开始，我假设你对它很熟悉，并且对它的能力有非常清楚的了解。</a></p><h2 id="a2dc" class="lf lg it bd lh li lj dn lk ll lm dp ln kq lo lp lq ku lr ls lt ky lu lv lw lx bi translated">那么什么不好呢</h2><p id="e470" class="pw-post-body-paragraph kf kg it kh b ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky mc la lb lc im bi translated">正如我上面提到的，无服务器主要做两件事:</p><ol class=""><li id="1df6" class="md me it kh b ki kj km kn kq mf ku mg ky mh lc mi mj mk ml bi translated">上传你的应用程序代码到S3。</li><li id="5e98" class="md me it kh b ki mm km mn kq mo ku mp ky mq lc mi mj mk ml bi translated">创建以您想要的方式运行代码所需的AWS资源。</li></ol><p id="eaf2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因此，虽然上传部分简单明了，但资源创建部分实际上可以分为四类:</p><ol class=""><li id="7a1c" class="md me it kh b ki kj km kn kq mf ku mg ky mh lc mi mj mk ml bi translated">Lambda函数——非常明显。</li><li id="d2b7" class="md me it kh b ki mm km mn kq mo ku mp ky mq lc mi mj mk ml bi translated">与函数触发器相关的资源，例如API端点。</li><li id="b490" class="md me it kh b ki mm km mn kq mo ku mp ky mq lc mi mj mk ml bi translated">我的角色。</li><li id="1c40" class="md me it kh b ki mm km mn kq mo ku mp ky mq lc mi mj mk ml bi translated">无服务器配置文件的“资源”部分中描述的其他AWS资源。</li></ol><p id="53ff" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您曾经看过这个文件，您可能已经注意到它的resource部分实际上只不过是CloudFormation(有时简称为CF)模板的一部分。前提是你知道CloudFormation模板是什么样子，否则你可能不会注意到这一点。无论如何，您可以使用这一部分来创建和配置AWS资源。举个例子，如果你在无服务器网站上看一些例子，你会发现一个<a class="ae le" href="https://serverless.com/examples/aws-python-rest-api-with-dynamodb/" rel="noopener ugc nofollow" target="_blank">示例应用配置</a>，它创建了一个函数和一个DynamoDB表，并设置了函数角色在表上的权限。多么方便快捷啊！只不过这不是。</p><p id="8298" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你看，<strong class="kh iu">第一个问题</strong>来自于这样一个事实，即无服务器框架将你的整个应用部署为一个单一的<a class="ae le" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacks.html" rel="noopener ugc nofollow" target="_blank">云架构栈</a>。这意味着DynamoDB表的生命周期与应用程序的生命周期绑定在一起。现在，如果您想删除并重新创建您的表，您需要重新部署您的无服务器项目。这并不理想，因为在某些情况下，您希望独立于依赖它的函数删除并重新创建表。</p><p id="c2ab" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最明显的场景是从本地备份中恢复表的过程。如果是DynamoDB，您的本地备份只能恢复到一个新表中。因此，您应该将函数重定向到一个恢复的表，或者删除一个原始的损坏的表，并从备份中创建一个同名的新表。无论哪种方式，你最终都会得到一个新的表，不同于你的CloudFormation堆栈中添加的表，它可能属于也可能不属于这个堆栈，这取决于你如何命名它。此外，这个新恢复的表将缺少一些设置，如<a class="ae le" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/TTL.html" rel="noopener ugc nofollow" target="_blank"> TTL </a>，以及一个包含所有订阅的<a class="ae le" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html" rel="noopener ugc nofollow" target="_blank">流</a>。这些东西你必须单独重新配置。稍后我们将讨论如何在没有人工干预的情况下实现这一点。</p><p id="f360" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最终，这意味着，作为无服务器项目的一部分，您将能够成功地维护DynamoDB表，只有在一个完美的世界里才不会出错。</p><p id="559e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">另一个让我们避免使用CloudFormation部署一些资源的问题</strong>是，CF语法有时需要一段时间才能跟上新的AWS功能。AWS发布的某些东西您可能想立即使用，但需要几个月才能在CloudFormation中使用。情况并不总是如此，但是当这种情况发生时，您可能会决定好好研究一下管理AWS资源的替代方法。</p><h2 id="a2bf" class="lf lg it bd lh li lj dn lk ll lm dp ln kq lo lp lq ku lr ls lt ky lu lv lw lx bi translated">让我们把事情变得更好！</h2><p id="3a2b" class="pw-post-body-paragraph kf kg it kh b ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky mc la lb lc im bi translated">好了，最后让我们来谈谈我们公司用来解决管理DynamoDB表问题的一种替代方法。该解决方案的名称是AWS CLI。</p><p id="89cd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于那些不知道的人(在这篇博文的这个时候，我希望有绝对的少数人)，AWS CLI是AWS提供的命令行工具，因此他们的用户可以从终端管理他们的云。它实际上是AWS控制台的命令行版本，这太棒了，因为控制台意味着脚本，而脚本意味着我们都想要的自动化。否则我们就不会把基础设施当作代码来做，不是吗？下面是DynamoDB btw的CLI参考:<a class="ae le" href="https://docs.aws.amazon.com/cli/latest/reference/dynamodb/index.html" rel="noopener ugc nofollow" target="_blank">参考</a></p><p id="97eb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">表格创建</strong></p><p id="a8d9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您可能想做的第一件事是编写表创建脚本。这是一项简单的任务(不像其他任务那样困难)，因为您只需要一个CLI命令和一个表的JSON定义。请，请看看下面的例子。</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">部署脚本和定义文件</figcaption></figure><p id="3a00" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请注意，还有一个选项可以将您的表细节作为CLI参数传递，尽管这将大大降低您的脚本的可读性。我看不出有什么理由要用一个单独的JSON文件来做这件事。除了个人喜好，我不做判断。通常我不会。</p><p id="e640" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">表格设置</strong></p><p id="7df9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，第二个CloudFormation问题有了一个解决方案——有些设置不能使用CF模板来设置。有时它们可以在模板中设置，但不能从备份中恢复，所以我们需要能够将它们应用到现有的表中。然而，我们很幸运，因为我们已经决定切换到ol' good终端命令。</p><p id="e5aa" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">以<a class="ae le" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/TTL.html" rel="noopener ugc nofollow" target="_blank"> TTL(生存时间)</a>为例。这个设置并不作为本机DynamoDB备份的一部分保存，这意味着我们需要在恢复后将它应用到一个表中。既然我们已经有了一个应用这个设置的脚本，为什么不把它作为真实的唯一来源呢？</p><p id="d878" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这里，我们来看一个shell脚本，它使用AWS CLI对上一个示例中的表的“created”字段设置TTL:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">这就是我们在现有表上启用TTL的方法</figcaption></figure><p id="82f5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">流订阅</strong></p><p id="2ac3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">从备份中恢复表后会丢失的另一个东西是它的流和流订阅。如果你不知道什么是DynamoDB流，请停止你正在做的任何事情，让自己熟悉<a class="ae le" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html" rel="noopener ugc nofollow" target="_blank">这个概念</a>。</p><p id="f458" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们可以再次使用AWS CLI的强大功能来扭转局面。下面的一个脚本👇在我们在前面的一个例子中创建的表上启用一个流，并为它订阅一个lambda函数。太棒了。</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">λ函数+ DynamoDB流= ❤️</figcaption></figure><p id="2fcf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，既然我们有了这三个脚本，我们可以随意使用它们。例如，可以将这三者结合起来，在部署管道中执行它们。还可以选择将脚本二和脚本三结合起来，作为灾难恢复工具的一部分。只要有意义，你高兴做什么就做什么。重点是——shell脚本让我们非常灵活地自动化资源的生命周期。</p><p id="5adc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于好奇的人，我还提供了一个<em class="ld"> serverless.yml </em>，如果你决定忽略我的建议，你可以使用它:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="e6c8" class="lf lg it bd lh li lj dn lk ll lm dp ln kq lo lp lq ku lr ls lt ky lu lv lw lx bi translated">哇，太酷了，这大概是<em class="mx">唯一的</em>处理事情的正确方式吧！</h2><p id="592e" class="pw-post-body-paragraph kf kg it kh b ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky mc la lb lc im bi translated">是也不是，但基本上不是。绝对不是，而且是个大胖子<strong class="kh iu">【N】</strong>。</p><p id="64e5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一件好的(或坏的)事情是，总是有不止一种方法来实现某事。我也是。除了我出色的shell脚本之外，我还想提到另外两种克服无服务器框架和CloudFormation局限性的方法。这些不是我走过的路，但它们可能是更好的。</p><p id="7480" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">地形</strong></p><p id="7569" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Terraform 是一个作为代码管理工具的云无关基础设施。我从来没用过，但是我听说它很好。它有很好的模块化——至少我是这么听说的，而且它是由社区驱动的。它的语法主观上也比CF更好。在功能方面，它也领先于亚马逊的产品。例如，您可以配置一个Kibana实例，仅使用Terraform使用Cognito进行身份验证——这是我以前做过的，只使用了两个CF模板和三个shell脚本。</p><p id="e31a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">与CloudFormation不同，Terraform是一个工具，而不是原生的AWS服务，这意味着您必须自己设置它。例如，您需要决定在哪里存储您的状态文件。</p><p id="8e6e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">云形成宏</strong></p><p id="b38e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">CF中有一个名为<a class="ae le" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-macros.html" rel="noopener ugc nofollow" target="_blank">宏</a>的功能，允许开发人员在部署堆栈时执行自定义模板转换。这里最酷的一点是，你还可以运行自己的lambda函数来执行转换，或者做任何你想让它做的事情。我的意思是它只是一个λ函数。这里有一篇关于如何使用无服务器框架实现这一点的文章。</p><p id="8628" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我自己从未尝试过，但我觉得我绝对应该试一试。</p><p id="6dc2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> AWS CDK </strong></p><p id="df07" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">AWS CDK是亚马逊的SDK，它可以帮助你使用你选择的编程语言轻松地创建和管理你的AWS基础设施。因此，与依赖声明性模板的CloudFormation不同，AWS CDK允许您将基础设施作为代码来管理。字面上。你可以在这里了解更多信息。听起来对我很有吸引力。</p><h1 id="6daf" class="my lg it bd lh mz na nb lk nc nd ne ln nf ng nh lq ni nj nk lt nl nm nn lw no bi translated">就这些吗？</h1><p id="7c5d" class="pw-post-body-paragraph kf kg it kh b ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky mc la lb lc im bi translated">今天——是的。</p><p id="5859" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">作为代码的基础设施很酷等等。然而，它也很容易搞砸，如果你这样做，它会毁了你的生活。或者你生命中的一小部分，比如某一天。不管怎样，你不会高兴的。因此，负责任地编码，永远不要停止寻找更好的解决方案。我的意思是，比你现在拥有的更好，也比我在这篇文章中向你展示的更好。</p><p id="bb48" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">和平。</p></div></div>    
</body>
</html>