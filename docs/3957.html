<html>
<head>
<title>Testing a Virtual List component with Cypress and Storybook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Cypress和Storybook测试虚拟列表组件</h1>
<blockquote>原文：<a href="https://itnext.io/testing-a-virtual-list-component-with-cypress-and-storybook-494dc2d1d26b?source=collection_archive---------2-----------------------#2020-04-01">https://itnext.io/testing-a-virtual-list-component-with-cypress-and-storybook-494dc2d1d26b?source=collection_archive---------2-----------------------#2020-04-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c19c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">来自集成工具的挑战、集成的当前状态以及正确测试呈现组件的一些最佳实践。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/4e3889edb3d9accfe584e2a2f549ddc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oyLjaXq5UXMLZ0upJl5r0Q.jpeg"/></div></div></figure><p id="afaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我正在GitHub上做一个大的<a class="ae kx" href="https://github.com/NoriSte/ui-testing-best-practices?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> UI测试最佳实践</a>项目，我分享这个帖子来传播它并有直接的反馈。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="6f42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="lf">更新</em> </strong> <em class="lf">:在这个实验方法之后，看看我的“</em> <a class="ae kx" href="https://medium.com/@NoriSte/unit-testing-react-components-with-cypress-4d4cf8cd59a0" rel="noopener"> <em class="lf">单元测试用Cypress的React组件</em> </a> <em class="lf">”的文章，在Cypress 4.5.0版本中事情得到了简化和更有效的处理！</em></p><p id="8a78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="lf">更新2</em></strong><em class="lf">:</em><a class="ae kx" href="https://docs.cypress.io/guides/component-testing/introduction#What-is-Component-Testing" rel="noopener ugc nofollow" target="_blank"><em class="lf">柏树7出带全新组件测试</em> </a> <em class="lf">支持，看看吧！其他激动人心的消息正在路上感谢</em> <a class="ae kx" href="https://twitter.com/NoriSte/status/1378204109841571840" rel="noopener ugc nofollow" target="_blank"> <em class="lf">故事书6.2版</em> </a> <em class="lf">！</em></p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h2 id="5ed1" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">TL；速度三角形定位法(dead reckoning)</h2><ul class=""><li id="ee7c" class="lz ma iq jp b jq mb ju mc jy md kc me kg mf kk mg mh mi mj bi translated">杠杆<a class="ae kx" href="https://github.com/NicholasBoll/cypress-storybook" rel="noopener ugc nofollow" target="_blank">柏树故事书</a>允许柏树在故事之间快速切换</li><li id="cfdb" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">这些故事应该暴露一些全局变量，允许Cypress断言数据</li><li id="5168" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">尽可能加快测试速度，由于Cypress的时钟控制，示例中的惯性滚动不会被等待</li><li id="b5c4" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">想一想，如果您想要测试呈现的组件、故事代码，或者两者都要测试</li><li id="62f2" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">工具将更加集成，组件测试是当前的热门话题</li></ul></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h2 id="5b2b" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">为什么要隔离测试元件？</h2><p id="d078" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">组件是你的应用程序的构建模块，Storybook允许你单独构建它们，<strong class="jp ir">检查</strong>它们是否正常工作，它们是否与图形布局一致，是否与团队的其他成员共享，等等。Storybook主要执行两种组件检查:</p><ul class=""><li id="aa87" class="lz ma iq jp b jq jr ju jv jy ms kc mt kg mu kk mg mh mi mj bi translated">视觉测试:使用<a class="ae kx" href="https://percy.io/" rel="noopener ugc nofollow" target="_blank"> Percy </a>或<a class="ae kx" href="https://applitools.com/" rel="noopener ugc nofollow" target="_blank"> Applitools </a>运行，这两个工具都可以很容易地与Storybook集成在一起，以自动化这种检查</li><li id="788a" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">功能测试:在组件故事中手工执行，为什么不将它们自动化呢？这篇文章谈到了这一点！</li></ul><h2 id="4ca9" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">组件测试工具</h2><p id="4f2f" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">当前的前端测试趋势有两个赢家:<a class="ae kx" href="https://testing-library.com" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> DOM测试库</strong> </a>和<a class="ae kx" href="https://www.cypress.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">柏树</strong> </a>。它们是两种完全不同的工具，但在某些方面它们有所重叠。DOM测试库明确地测试组件(通过像<a class="ae kx" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>这样的第三方测试运行器)是正确和快速的方式，这是非常好的。Cypress以一种简单可靠的方式实现了浏览器的自动化。</p><p id="1453" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么它们会重叠？因为从技术上来说，你可以通过DOM测试库测试整个应用程序，也可以用Cypress测试单个组件。</p><p id="d213" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<strong class="jp ir"> DOM测试库</strong>测试整个应用程序:</p><ul class=""><li id="753e" class="lz ma iq jp b jq jr ju jv jy ms kc mt kg mu kk mg mh mi mj bi translated">利:它正在燃烧<strong class="jp ir">快</strong></li><li id="2c1a" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">缺点:它呈现HTML，但是HTML不是由真正的浏览器呈现的，所以<strong class="jp ir">CSS部分不起作用</strong></li><li id="cb9b" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">缺点:阅读一个巨大的HTML而不是在浏览器中阅读结果很麻烦</li><li id="cac4" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">缺点:第三方组件不能完全与<a class="ae kx" href="https://github.com/jsdom/jsdom" rel="noopener ugc nofollow" target="_blank"> jsdom </a>环境兼容，或者在dom测试库渲染时不能按预期工作</li></ul><p id="4102" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<strong class="jp ir">柏树</strong>测试组件:</p><ul class=""><li id="7044" class="lz ma iq jp b jq jr ju jv jy ms kc mt kg mu kk mg mh mi mj bi translated">利:它自动化了一个真正的浏览器，组件在他们将要使用的相同环境中被测试</li><li id="fcab" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">利:你可以用用户将要看到/消费组件的方式来测试组件</li><li id="0268" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">教授:你可以检查一下你的故事书是否也很好用。你的故事的代码可能被窃听，所以拥有一些工作组件并不能保证你有一本工作故事书。团队的其他成员可以依赖Storybook作为团队/公司的组件库。</li><li id="534d" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">缺点:它需要一个运行的主机/网站，允许你与组件本身进行交互(就像故事书一样)</li><li id="83fb" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">缺点:测试数百个组件可能会很慢</li></ul><p id="c768" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意:对于Cypress，有一个<a class="ae kx" href="https://testing-library.com/docs/cypress-testing-library/intro" rel="noopener ugc nofollow" target="_blank"> Cypress测试库</a>插件，允许您利用相同的<em class="lf"> findByText </em>、<em class="lf"> findByPlaceholderText、findByTestId </em>等。DOM测试库的API。我喜欢它，我总是使用它，但他们在柏树里面工作，而不是在其他测试跑步者身上</p><h2 id="818f" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">时下热门话题</h2><p id="656b" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">用Cypress和Storybook进行组件测试是当前的一个热门话题，这里有一些证明:</p><ul class=""><li id="6439" class="lz ma iq jp b jq jr ju jv jy ms kc mt kg mu kk mg mh mi mj bi translated">看看故事书里的这条推文</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mv"><img src="../Images/f4d043cbc05132c6d77da5905edd57f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nVf6ruvdwgm2yHvwxY-Yjg.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">故事书和赛普拉斯会更融合吗？大概…</figcaption></figure><ul class=""><li id="513f" class="lz ma iq jp b jq jr ju jv jy ms kc mt kg mu kk mg mh mi mj bi translated">看看<a class="na nb ep" href="https://medium.com/u/111a108c5d58?source=post_page-----494dc2d1d26b--------------------------------" rel="noopener" target="_blank">艾萨克·曼</a>的文章《<a class="ae kx" href="https://blog.nrwl.io/ui-testing-with-storybook-and-nx-4b86975224c" rel="noopener ugc nofollow" target="_blank"> Nx 8.8:现在你可以用故事书和柏树</a>编写UI测试》</li><li id="09e7" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">对于Cypress，有一个<a class="ae kx" href="https://github.com/bahmutov/cypress-react-unit-test" rel="noopener ugc nofollow" target="_blank"> cypress-react-unit-test </a>库，它允许你在没有运行网站的情况下测试组件。我在这里玩了一下<a class="ae kx" href="https://github.com/NoriSte/react-crypto-compare" rel="noopener ugc nofollow" target="_blank"/>但是，尽管有<a class="ae kx" href="https://github.com/bahmutov" rel="noopener ugc nofollow" target="_blank"> Gleb </a>和<a class="ae kx" href="https://github.com/dmtrKovalenko" rel="noopener ugc nofollow" target="_blank"> Dmitry </a>惊人的工作(❤️)，它还没有准备好成为你的生产测试的基础。但是请继续关注，事情可能会很快改变！看看<a class="ae kx" href="https://twitter.com/bahmutov/status/1240385030461034502" rel="noopener ugc nofollow" target="_blank">这个Gleb的推文</a></li><li id="6ff5" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">利用自动化浏览器来测试故事书组件的想法在我脑海中已经存在很长时间了…但是第一个向我展示真实案例的是<a class="ae kx" href="https://github.com/MakhBeth" rel="noopener ugc nofollow" target="_blank"> Davide Di Pumpo </a>和他的TestCafè+Storybook automation👏</li><li id="ef76" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">Dmitriy Tishin利用Storybook就像一个“组件暴露者”从故事中分离组件测试，看看他的“<a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/cypress-storybook-keeping-test-scenario-data-and-component-rendering-in-one-place-c57b23cc1640"> Cypress + Storybook”。将测试场景、数据和组件呈现放在一个地方</a>文章</li></ul><h1 id="0e10" class="nc lh iq bd li nd ne nf ll ng nh ni lo nj nk nl lr nm nn no lu np nq nr lx ns bi translated">一个真实的例子:虚拟列表</h1><p id="c2ff" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">最近，我开发了一个VirtualList组件，并使用它来检查Storybook和Cypress如何协同工作。VirtualList是一个只呈现可见项目的列表，以保证最高的性能。看一看<a class="ae kx" href="https://bvaughn.github.io/react-virtualized/#/components/List" rel="noopener ugc nofollow" target="_blank"> React虚拟化</a>来了解它是如何工作的。除了虚拟化，我的虚拟列表管理项目点击和项目多选。</p><p id="4f0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了许多单元测试之外，我想运行一些组件测试，但是如上所述，第三方库(比如我们使用的:<a class="ae kx" href="https://www.npmjs.com/package/react-smooth-scrollbar" rel="noopener ugc nofollow" target="_blank"> React Smooth Scrollbar </a>)不能很好地与<a class="ae kx" href="https://testing-library.com/docs/react-testing-library/intro" rel="noopener ugc nofollow" target="_blank"> React测试库</a>(DOM测试库的React版本)一起工作，所以Cypress是唯一的选择。</p><h1 id="319a" class="nc lh iq bd li nd ne nf ll ng nh ni lo nj nk nl lr nm nn no lu np nq nr lx ns bi translated">测试挑战</h1><p id="f521" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">使用Cypress测试Storybook中的组件，而不是运行标准的E2E测试，最大的挑战是什么？与使用<a class="ae kx" href="https://testing-library.com/docs/react-testing-library/intro" rel="noopener ugc nofollow" target="_blank"> React测试库</a>(DOM测试库的React版本)的标准组件测试相比，有什么挑战？</p><h2 id="a7a8" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">数据源控件</h2><p id="3f20" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">使用Cypress，我们习惯于加载整个应用程序，通过静态fixtures(在<a class="ae kx" href="https://medium.com/@NoriSte/component-vs-ui-integration-vs-e2e-tests-f02b575339dc" rel="noopener"> UI集成测试</a>的情况下)控制数据，或者读取/截取后端数据(在<a class="ae kx" href="https://medium.com/@NoriSte/component-vs-ui-integration-vs-e2e-tests-f02b575339dc" rel="noopener"> E2E测试</a>的情况下)，并使用这些数据来断言UI正常工作。所以我们可以控制，或者至少知道，UI将要使用的数据。<strong class="jp ir">不知道数据就意味着没有断言</strong>。<br/>但是在(无状态)组件故事中，数据是由表示故事的组件直接传递给组件，并呈现组件的。为了了解数据并对故事组件显示的内容做出正确的断言，<strong class="jp ir">数据需要由故事公开，并由Cypress </strong>读取。</p><p id="4eb0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意:如果Cypress测试在故事组件的同一个存储库中，您可以从故事文件中导入数据，但是下面显示的例子来自不在故事的同一个存储库中的测试。</p><h2 id="08ec" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">隐藏内容</h2><p id="57c0" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">虚拟列表从DOM中删除不可见的组件。这对测试意味着什么？我们不能指望所有的元素都存在于HTML中。React测试库和Cypress都不能完全理解虚拟列表是如何工作的，因为一旦你需要断言一个可见区域之外的项目的存在，你就不能利用通常的<em class="lf">cy . contains</em>/<em class="lf">findByText等。</em>效用:因为物品根本不存在。</p><p id="9cba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">VirtualList是一个受控组件，因此它通知父组件哪些是呈现的项目，哪些是选择的项目。在标准的<a class="ae kx" href="https://medium.com/@NoriSte/component-vs-ui-integration-vs-e2e-tests-f02b575339dc" rel="noopener">组件测试</a>中，我们可以断言上下传递给VirtualList组件的道具，故事直接控制这些道具，但是，同样，Cypress需要读取这些数据，所以故事必须公开它。</p><h2 id="c1d8" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">我们是在测试故事还是组件？</h2><p id="d57f" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">差别可能很微妙。因为VirtualList是一个受控组件，所以story组件控制它。故事组件内部的控制逻辑是要测试的东西的一部分？控制部件和被控制部件是可分离的吗？大概不会。</p><p id="32e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个标准测试有两个参与者——测试运行者和受控组件——而使用带有Storybook的Cypress有三个参与者——测试运行者、故事和受控组件。因此，如果一个组件测试控制了组件，并且可以直接访问回调数据，Cypress需要story的组件才能正常工作。</p><h2 id="1920" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">滚动和呈现项目控件</h2><p id="cb15" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">VirtualList组件利用了一个惯性滚动条，并且由于story添加了数千个要呈现的项目来充分展示VirtualList的潜力，因此它只有一个很小的滚动条句柄。滚动虚拟列表可能会导致测试和下一个测试之间呈现的项目略有不同。所以我想当然地认为，一旦列表滚动，我们无法预先知道哪些条目将被呈现(例如从第100到第110或从第101到第111)。</p><p id="3347" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么？因为我讨厌基于脆弱假设的脆弱测试。测试不应该被设计成抵抗每一个可能的变化，但是它们必须足够健壮以经受住小的变化。对于VirtualList测试，这意味着一旦滚动，呈现的项目将直接从HTML项目中检索。我们稍后将深化它。</p><h1 id="a413" class="nc lh iq bd li nd ne nf ll ng nh ni lo nj nk nl lr nm nn no lu np nq nr lx ns bi translated">请说密码</h1><p id="ad70" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">我们要编写的第一个测试需要检查列表是否收到了10000个条目，是否只呈现了其中的一部分。这是虚拟列表的基本特性。</p><p id="3bb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，RenderItem组件，它只是交替使用颜色来直观地标识行</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="a659" class="lg lh iq nu b gy ny nz l oa ob">// every `item` is an { id: string, name: string}</span><span id="ef63" class="lg lh iq nu b gy oc nz l oa ob">const getItemText = item =&gt; `id: ${item.id} - ${item.name}`</span><span id="f5f1" class="lg lh iq nu b gy oc nz l oa ob">const RenderItem = ({ item }) =&gt; {<br/>  return (<br/>    &lt;div<br/>      style={{<br/>        height: '30px',<br/>        backgroundColor: parseInt(item.id) % 2 ? '#FAFAFA' : '#EEE',<br/>      }}<br/>    &gt;<br/>      {getItemText(item)}<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="6bb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们要研究的原始故事如下</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="f2c8" class="lg lh iq nu b gy ny nz l oa ob">// `getStoryItems` allows to create a high amount of items, it's used by every story</span><span id="bf06" class="lg lh iq nu b gy oc nz l oa ob">export const With10000Items = () =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;h4&gt;The scroll must be fluid&lt;/h4&gt;<br/>      &lt;VirtualList<br/>        items={getStoryItems({ amount: 10000 })}<br/>        getItemHeights={() =&gt; 30}<br/>        RenderItem={RenderItem}<br/>        listHeight={300}<br/>      /&gt;<br/>    &lt;/&gt;<br/>  )<br/>}<br/>With10000Items.story = {<br/>  name: 'With 10000 items',<br/>}</span></pre><p id="f124" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要改编这个故事，在全球范围内曝光:</p><ul class=""><li id="c43c" class="lz ma iq jp b jq jr ju jv jy ms kc mt kg mu kk mg mh mi mj bi translated"><code class="fe od oe of nu b">items</code>数组:Cypress测试需要知道用来填充列表的数据</li><li id="5849" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated"><code class="fe od oe of nu b">getItemText</code>函数:因此Cypress测试避免了关心如何从一个项目中获得呈现的文本。Cypress需要将项目转换为文本来从文本中检索渲染项目，避免使用<code class="fe od oe of nu b">data-test</code>属性</li><li id="2f11" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">可见项的数量:Cypress测试需要断言哪些项被呈现，哪些项没有被呈现</li></ul><p id="c776" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是更新后的故事，它通过一个全局<code class="fe od oe of nu b">storyData</code>变量来公开变量，这个变量将被Cypress测试收集和使用:</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="1b76" class="lg lh iq nu b gy ny nz l oa ob">export const With10000Items = () =&gt; {<br/>  const itemHeight = 30<br/>  const listHeight = 300<br/>  const items = React.useMemo(<br/>    () =&gt; getStoryItems({ amount: 10000 }),<br/>    [],<br/>  )<br/>  <br/>  // exposing data for Cypress<br/>  React.useEffect(() =&gt; {<br/>    // global is `window`<br/>    global.storyData = {<br/>      items,<br/>      visibleItemsAmount: Math.ceil(listHeight / itemHeight),<br/>      getItemText,<br/>    }<br/>  }, [items])</span><span id="9e51" class="lg lh iq nu b gy oc nz l oa ob">return (<br/>    &lt;&gt;<br/>      &lt;h4&gt;The scroll must be fluid&lt;/h4&gt;<br/>      &lt;VirtualList<br/>        items={items}<br/>        getItemHeights={() =&gt; itemHeight}<br/>        RenderItem={RenderItem}<br/>        listHeight={listHeight}<br/>      /&gt;<br/>    &lt;/&gt;<br/>  )<br/>}<br/>With10000Items.story = {<br/>  name: 'With 10000 items',<br/>}</span></pre><h2 id="db32" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">柏树试验</h2><p id="a474" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">测试将会:</p><ul class=""><li id="6294" class="lz ma iq jp b jq jr ju jv jy ms kc mt kg mu kk mg mh mi mj bi translated">访问故事书页面</li><li id="d6f7" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">收集暴露的数据</li><li id="faa8" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">检查渲染的项目</li></ul><p id="accf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前两点的代码</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="25f3" class="lg lh iq nu b gy ny nz l oa ob">it('When the component receives 10000 items, then only the minimum number of items are rendered', () =&gt; {<br/>  cy.visit('/iframe.html?id=virtuallist--with-10000-items')</span><span id="a264" class="lg lh iq nu b gy oc nz l oa ob">  cy.window()<br/>    .its('storyData')<br/>    .should(storyData =&gt; {<br/>      // the story must expose some variables<br/>      expect(storyData.items).to.be.to.have.length(10000)<br/>      expect(storyData.visibleItemsAmount).to.be.greaterThan(0)<br/>      expect(storyData.getItemText).to.be.a('function')<br/>    })<br/>    .then(() =&gt; {<br/>      // the test code<br/>    })<br/>})</span></pre><p id="0a0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么对曝光的<code class="fe od oe of nu b">storyData</code>断言？因为一个错误的<code class="fe od oe of nu b">storyData</code>会让测试失败，如果一个测试失败了，它一定会直接把我们推向问题。如果组件渲染由于错误的<code class="fe od oe of nu b">storyData</code>而失败，我们的测试根本就不应该运行。这可被视为<strong class="jp ir">与数据相关的冒烟测试</strong>。</p><p id="39fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，测试缺少的部分:检查哪些项目被渲染，哪些没有</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="11a4" class="lg lh iq nu b gy ny nz l oa ob">it('When the component receives 10000 items, then only the minimum number of items are rendered', () =&gt; {<br/>  cy.visit('/iframe.html?id=virtuallist--with-10000-items')</span><span id="f879" class="lg lh iq nu b gy oc nz l oa ob">cy.window()<br/>    .its('storyData')<br/>    .should(storyData =&gt; {<br/>      // the story must expose some variables<br/>      expect(storyData.items).to.be.to.have.length(10000)<br/>      expect(storyData.visibleItemsAmount).to.be.greaterThan(0)<br/>      expect(storyData.getItemText).to.be.a('function')<br/>    })<br/>    .then(({ visibleItemsAmount, getItemText, items }) =&gt; {<br/>      // items visibility check<br/>      const visibleItems = items.slice(0, visibleItemsAmount - 1)<br/>      visibleItems.forEach(item =&gt; {<br/>        cy.findByText(getItemText(item)).should('be.visible')<br/>      })</span><span id="a75a" class="lg lh iq nu b gy oc nz l oa ob">      // first not-rendered item check<br/>      cy.findByText(getItemText(items[visibleItemsAmount]))<br/>        .should('not.exist')<br/>    })<br/>})</span></pre><ul class=""><li id="6458" class="lz ma iq jp b jq jr ju jv jy ms kc mt kg mu kk mg mh mi mj bi translated">我们使用暴露的<code class="fe od oe of nu b">visibleItemsAmount</code>变量来检索呈现的项目</li></ul><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="0c3d" class="lg lh iq nu b gy ny nz l oa ob">const visibleItems = items.slice(0, visibleItemsAmount - 1)</span></pre><ul class=""><li id="334d" class="lz ma iq jp b jq jr ju jv jy ms kc mt kg mu kk mg mh mi mj bi translated">我们使用公开的<code class="fe od oe of nu b">getItemText</code>函数从页面中检索每一项</li></ul><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="b470" class="lg lh iq nu b gy ny nz l oa ob">cy.findByText(getItemText(item))</span></pre><ul class=""><li id="ae7d" class="lz ma iq jp b jq jr ju jv jy ms kc mt kg mu kk mg mh mi mj bi translated">我们断言所有预期可见的项目</li></ul><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="1a0e" class="lg lh iq nu b gy ny nz l oa ob">cy.findByText(getItemText(item)).should('be.visible')</span></pre><ul class=""><li id="a475" class="lz ma iq jp b jq jr ju jv jy ms kc mt kg mu kk mg mh mi mj bi translated">我们断言页面中不存在下一项</li></ul><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="798b" class="lg lh iq nu b gy ny nz l oa ob">cy.findByText(getItemText(items[visibleItemsAmount]))<br/>  .should('not.exist')</span></pre><p id="50a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意<code class="fe od oe of nu b">cy.findByText</code> Cypress命令来自… <a class="ae kx" href="https://testing-library.com/docs/cypress-testing-library/intro" rel="noopener ugc nofollow" target="_blank"> Cypress测试库</a>😊这是我最喜欢的从页面中检索元素的方法，因为它像用户一样:从文本内容中读取/检索元素。我用它来代替<code class="fe od oe of nu b">cy.contains</code>，但它们做的是同样的事情。</p><p id="e832" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是结果:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi og"><img src="../Images/874f2a87227d6788318d7d5117540b3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*48QqeCsFnky5obJKZ0on1w.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">第一个测试的结果:加载的故事和所有断言的结果。</figcaption></figure><p id="9fe2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个测试足以检查虚拟列表只呈现最少数量的项目。</p><p id="1acb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最初，我试图检查虚拟列表滚动时浏览器是否以60 FPS的速度运行。为什么？因为<strong class="jp ir">UI测试必须检查用户看到了什么，使用与用户相同的UI</strong>。从用户的角度来看，虚拟列表的唯一目标是它必须流畅地运行，不管列表中有多少项。但是可靠地测量FPS是困难的，因为测量会受到以下因素的影响:</p><ul class=""><li id="b9e3" class="lz ma iq jp b jq jr ju jv jy ms kc mt kg mu kk mg mh mi mj bi translated">你使用的Cypress命令:每个Cypress的动作都会降低浏览器的速度</li><li id="c7c4" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">机器(或Docker映像)可用于运行测试的资源数量</li></ul><p id="2ae0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为不可能有可靠的计数—一些初始值将被丢弃，等等。—我移动以检查渲染项目的数量，仅此而已。如果我能确定10000个条目中只有10个被渲染，我就能确定这个列表运行流畅。更一般的:记住<strong class="jp ir">一个脆弱的测试比一个缺失的测试更糟糕</strong>。</p><h1 id="9086" class="nc lh iq bd li nd ne nf ll ng nh ni lo nj nk nl lr nm nn no lu np nq nr lx ns bi translated">第二个测试:滚动</h1><p id="38c2" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">首先:VirtualList组件利用了<a class="ae kx" href="https://idiotwu.github.io/smooth-scrollbar/" rel="noopener ugc nofollow" target="_blank">平滑滚动条</a>，平滑滚动条有自己的测试，所以我们将检查我们的VirtualList组件如何对滚动做出反应，但我们认为平滑滚动条是理所当然的。当使用第三方库时，你不需要测试库是否工作。库<strong class="jp ir">应该有自己的测试</strong>，如果没有，就换库！永远不要为第三方库编写测试。</p><p id="97ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">滚动测试将:</p><ul class=""><li id="bcba" class="lz ma iq jp b jq jr ju jv jy ms kc mt kg mu kk mg mh mi mj bi translated">触发滚动</li><li id="5cf1" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">等到滚动结束</li><li id="f720" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">检查渲染的项目</li></ul><p id="ea0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，触发滚动的测试代码如下</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="c3ba" class="lg lh iq nu b gy ny nz l oa ob">// triggers the wheel event<br/>cy.findByTestId('VirtualList').trigger('wheel', {<br/>  deltaX: 0,<br/>  deltaY: 1000,<br/>})</span></pre><p id="694b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，VirtusList组件应该呈现一个带有<code class="fe od oe of nu b">data-test="VirtualList"</code>属性的DOM元素。其余的由Cypress管理，<code class="fe od oe of nu b">trigger</code>是对<a class="ae kx" href="https://api.jquery.com/trigger/" rel="noopener ugc nofollow" target="_blank"> jQuery触发器API </a>的直接映射(Cypress利用jQuery尽可能缩短测试代码)。再说一次:柏树在当地相当于<code class="fe od oe of nu b">cy.findByTestId('VirtualList')</code>的是<code class="fe od oe of nu b">cy.get('[data-testid=VirtualList]')</code>。</p><p id="65c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于“等到滚动结束”部分，我们将利用<a class="ae kx" href="https://github.com/NoriSte/cypress-wait-until" rel="noopener ugc nofollow" target="_blank"> Cypress waitUntil </a>插件。为什么我们应该使用waitUntil插件而不是等待一段固定的时间在<a class="ae kx" href="https://medium.com/@NoriSte/await-do-not-sleep-your-e2e-tests-df67e051b409" rel="noopener"> Await，do not make your E2E测试睡眠</a>一文中有详细的解释。<br/>定制等待的代码是</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="9ecf" class="lg lh iq nu b gy ny nz l oa ob">// waits until the scrollbar handle stops<br/>let scrollbarHandleY = Number.NEGATIVE_INFINITY<br/>cy.get('.scrollbar-thumb-y')<br/>  .waitUntil(<br/>    $scrollbarHandle =&gt; {<br/>      const [newY, previousY] = [<br/>        $scrollbarHandle.offset().top,<br/>        scrollbarHandleY,<br/>      ]<br/>      scrollbarHandleY = newY<br/>      return previousY === newY<br/>    },<br/>    {<br/>      customMessage: 'The inertial scroll ends',<br/>    },<br/>  )</span></pre><p id="5ff0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们确信测试会等待适当的时间。</p><h2 id="b511" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">检查渲染的项目</h2><p id="bb05" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">这是什么意思？意思是:</p><ul class=""><li id="16dd" class="lz ma iq jp b jq jr ju jv jy ms kc mt kg mu kk mg mh mi mj bi translated">查找第一个渲染项目</li><li id="08a7" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">检查第一个呈现的项目不是第一个。虚拟列表开始呈现0到10个项目。一旦滚动，它必须呈现第x到第x+10项。我们不知道X的值，我们也不关心这个，否则，我们将把测试与呈现的项目联系起来。如果第一个渲染的项目是第60个或第61个并不重要。检查准确呈现的项目超出了这个通用滚动测试的范围。测试稳定性感谢我们。</li><li id="ad92" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">一旦检索到第一个呈现的项目，我们检查接下来的十个项目是否都被呈现了</li></ul><p id="1fdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将仔细检查每一个步骤，测试的最终代码如下(请继续查看可读性更好的版本)</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="135d" class="lg lh iq nu b gy ny nz l oa ob">it('When the component is scrolled, then the rendered items are not the first ones', () =&gt; {<br/>  cy.visit('/iframe.html?id=virtuallist--with-10000-items')</span><span id="e643" class="lg lh iq nu b gy oc nz l oa ob">  cy.window()<br/>    .its('storyData')<br/>    .should(storyData =&gt; {<br/>      // the story must expose some variables<br/>      expect(storyData.items).to.be.to.have.length(10000)<br/>      expect(storyData.visibleItemsAmount).to.be.greaterThan(0)<br/>      expect(storyData.getItemText).to.be.a('function')<br/>    })<br/>    .then(({ visibleItemsAmount, getItemText, items }) =&gt; {<br/>      // triggers the wheel event<br/>      cy.findByTestId('VirtualList').trigger('wheel', {<br/>        deltaX: 0,<br/>        deltaY: 1000,<br/>      })</span><span id="6b94" class="lg lh iq nu b gy oc nz l oa ob">      // waits until the scrollbar handle stops<br/>      let scrollbarHandleY = Number.NEGATIVE_INFINITY<br/>      cy.get('.scrollbar-thumb-y')<br/>        .waitUntil(<br/>          $scrollbarHandle =&gt; {<br/>            const [newY, previousY] = [<br/>              $scrollbarHandle.offset().top,<br/>              scrollbarHandleY,<br/>            ]<br/>            scrollbarHandleY = newY<br/>            return previousY === newY<br/>          },<br/>          {<br/>            customMessage: 'The inertial scroll ends',<br/>          },<br/>        )<br/>        // (manually) looks for the first rendered element<br/>        .then(() =&gt;<br/>          items.findIndex(<br/>            item =&gt; !!Cypress.$(`*:contains("${getItemText(item)}")`).length,<br/>          ),<br/>        )<br/>        // checks that the rendered items are not the initially rendered ones<br/>        .should('be.greaterThan', 10)<br/>        // checks the rendered items<br/>        .then(firstVisibleItemIndex =&gt; {<br/>          const visibleItems = items.slice(<br/>            firstVisibleItemIndex,<br/>            firstVisibleItemIndex + visibleItemsAmount - 1,<br/>          )<br/>          visibleItems.forEach(item =&gt;<br/>            cy.findByText(getItemText(item)).should('be.visible'),<br/>          )<br/>        })<br/>    })<br/>})</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oh"><img src="../Images/86625799bb0f2a3a37b62374a768ed12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D3v4NTubPVrbaVEsCMeuVQ.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">由于Medium不管理代码格式的方式和使用GitHub Gists是不实际的，这里有一个<a class="ae kx" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank"> Carbon </a>版本的相同代码。</figcaption></figure><p id="b354" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">逐步:检索第一个呈现项目的代码是</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="917c" class="lg lh iq nu b gy ny nz l oa ob">items.findIndex(<br/>  item =&gt; !!Cypress.$(`*:contains("${getItemText(item)}")`).length,<br/>)</span></pre><p id="9d5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么不利用<code class="fe od oe of nu b">cy.findByText</code>命令来检索它呢？因为在Cypress中，每个<code class="fe od oe of nu b">cy.get</code>命令(这是<code class="fe od oe of nu b">cy.findByText</code>命令的核心)都有内置断言，<a class="ae kx" href="https://docs.cypress.io/api/commands/get.html#Assertions" rel="noopener ugc nofollow" target="_blank">在官方文档中检查它们</a>。实质上，如果页面上不存在该元素，<code class="fe od oe of nu b">cy.get</code>会使测试失败。但是因为我们需要遍历未渲染的项目，直到找到第一个渲染的项目，所以我们应该手动进行。<code class="fe od oe of nu b">Cypress.$</code>是jQuery的一个全局实例，一个jQuery版本的<code class="fe od oe of nu b">cy.findByText("XXX")</code>是<code class="fe od oe of nu b">Cypress.$(`*:contains("XXX")`)</code>并且，jQuery版本的</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="df32" class="lg lh iq nu b gy ny nz l oa ob">cy.findByText("XXX").should("exist")</span></pre><p id="b049" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="2119" class="lg lh iq nu b gy ny nz l oa ob">!!Cypress.$(`*:contains("XXX")`).length</span></pre><p id="858e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">唯一的区别是，如果元素不存在，它不会失败。如前所述:我习惯于利用<code class="fe od oe of nu b">cy.getByText</code>，但原生<code class="fe od oe of nu b">cy.contains</code>做同样的事情！</p><p id="3436" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦找到第一个呈现项目的索引，我们只需要检查接下来的呈现项目。</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="39bb" class="lg lh iq nu b gy ny nz l oa ob">.then(() =&gt;<br/>  items.findIndex(<br/>    item =&gt; !!Cypress.$(`*:contains("${getItemText(item)}")`).length,<br/>  )<br/>)<br/>// checks that the rendered items are not the initially rendered ones<br/>.should('be.greaterThan', 10)<br/>// checks the rendered items<br/>.then(firstVisibleItemIndex =&gt; {<br/>  const visibleItems = items.slice(<br/>    firstVisibleItemIndex,<br/>    firstVisibleItemIndex + visibleItemsAmount - 1,<br/>  )<br/>  visibleItems.forEach(item =&gt;<br/>    cy.findByText(getItemText(item)).should('be.visible'),<br/>  )<br/>})</span></pre><p id="1e47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是测试的录音</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="919d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我们不关心最后半可见的项目。测试的范围是检查呈现的项目不是第一个，并且至少呈现了10个项目，第11个项目不需要检查。</p><p id="2ce1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以将测试的滚动部分转移到一个独立的工具中，类似于</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="b69f" class="lg lh iq nu b gy ny nz l oa ob">const scrollVirtualList = ($list, deltaY = 1000) =&gt; {<br/>  cy.wrap($list)<br/>    .trigger('wheel', {<br/>      deltaX: 0,<br/>      deltaY,<br/>    })<br/>    .within(() =&gt; {<br/>      // waits for the inertial scroll end<br/>      let scrollbarY = Number.NEGATIVE_INFINITY<br/>      getScrollbar().waitUntil(<br/>        $scrollbar =&gt; {<br/>          const newY = $scrollbar.offset().top<br/>          const previousY = scrollbarY<br/>          scrollbarY = newY<br/>          return previousY === newY<br/>        },<br/>        {<br/>          customMessage: 'The inertial scroll end',<br/>        },<br/>      )<br/>    })<br/>}</span></pre><p id="d0fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以用同样的方法找到第一个渲染的项目</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="5d96" class="lg lh iq nu b gy ny nz l oa ob">const getFirstRenderedItemIndex = (items, getItemText) =&gt; {<br/>  return items.findIndex(<br/>    item =&gt; !!Cypress.$(`*:contains("${getItemText(item)}")`).length,<br/>  )<br/>}</span></pre><p id="aad0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试的可读性得益于这种分离，请看一下</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="ef90" class="lg lh iq nu b gy ny nz l oa ob">it('When the component is scrolled, then the rendered items are not the first ones', () =&gt; {<br/>  cy.visit('/iframe.html?id=virtuallist--with-10000-items')</span><span id="9b84" class="lg lh iq nu b gy oc nz l oa ob">cy.window()<br/>    .its('storyData')<br/>    .should(storyData =&gt; {<br/>      // the story must expose some variables<br/>      expect(storyData.items).to.be.to.have.length(10000)<br/>      expect(storyData.visibleItemsAmount).to.be.greaterThan(0)<br/>      expect(storyData.getItemText).to.be.a('function')<br/>    })<br/>    .then(({ visibleItemsAmount, getItemText, items }) =&gt; {<br/>      cy.findByTestId('VirtualList')<br/>        // we leverage the new `scrollVirtualList` function<br/>        .then(scrollVirtualList)<br/>        .then(() =&gt; getFirstRenderedItemIndex(items, getItemText))<br/>        .should('be.greaterThan', 10)<br/>        .then(firstVisibleItemIndex =&gt; {<br/>          const visibleItems = items.slice(<br/>            firstVisibleItemIndex,<br/>            firstVisibleItemIndex + visibleItemsAmount - 1,<br/>          )<br/>          visibleItems.forEach(item =&gt;<br/>            cy.findByText(getItemText(item)).should('be.visible'),<br/>          )<br/>        })<br/>    })<br/>})</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oh"><img src="../Images/a760d942531e545d6b093b71b156dfe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WjRKt1oLT2zd6QY4shX_dg.png"/></div></div></figure><h1 id="f94a" class="nc lh iq bd li nd ne nf ll ng nh ni lo nj nk nl lr nm nn no lu np nq nr lx ns bi translated">第三项测试:选择</h1><p id="abe3" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">VirtualList组件通过按键修饰符支持选择和<strong class="jp ir">多项选择。我们只需要单击项目，单击带有按键修饰符的项目，并检查哪些是选中的项目。是什么让这些操作变得困难？</strong></p><ul class=""><li id="609a" class="lz ma iq jp b jq jr ju jv jy ms kc mt kg mu kk mg mh mi mj bi translated">首先:“选中”是什么意思？从用户的角度来看，一个选中的项目是一个“突出显示”的项目，但检查元素的样式是薄弱的。我们可以给组件添加一个<code class="fe od oe of nu b">data-selected</code>属性…</li><li id="1b75" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">…但是有一个结构问题:这些项目根本无法呈现！如果我们单击第一个项目(从第1个到第10个项目)，然后我们滚动大约20个项目(从第21个到第30个项目)，我们单击中间的项目(第25个项目)并按SHIFT，选择的项目应该是从第1个到第25个，但是前20个没有被渲染，所以我们不能通过渲染的项目来检索选择的项目。同样，<strong class="jp ir">我们将使用故事</strong>所揭示的变量</li></ul><p id="fec4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是故事的代码</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="680b" class="lg lh iq nu b gy ny nz l oa ob">export const WithSelectionManagement = () =&gt; {<br/>  const items = getStoryItems({ amount: 10000 })</span><span id="ef0b" class="lg lh iq nu b gy oc nz l oa ob">const [selectedItems, setSelectedItems] = React.useState(<br/>    [],<br/>  )</span><span id="106a" class="lg lh iq nu b gy oc nz l oa ob">const handleSelect = React.useCallback(<br/>    ({ newSelectedIds }) =&gt; setSelectedItems(newSelectedIds),<br/>    [setSelectedItems],<br/>  )<br/>  <br/>  // exposing data for Cypress<br/>  React.useEffect(() =&gt; {<br/>    global.storyData = {<br/>      items,<br/>      getItemText,<br/>      selectedItems,<br/>    }<br/>  }, [items, selectedItems])</span><span id="0e5e" class="lg lh iq nu b gy oc nz l oa ob">  return (<br/>    &lt;&gt;<br/>      &lt;h4&gt;<br/>        The buttons must be clickable, the CTRL/CMD, ALT, SHIFT                  <br/>        keyboard modifiers must work<br/>      &lt;/h4&gt;<br/>      &lt;VirtualList<br/>        items={items}<br/>        selectedItemIds={selectedItems}<br/>        getItemHeights={() =&gt; 30}<br/>        RenderItem={createSelectableRenderItem({ height: 30 })}<br/>        listHeight={300}<br/>        onSelect={handleSelect}<br/>      /&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><p id="d7cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为VirtualList组件是受控的，所以它向上传递所选项的列表——<code class="fe od oe of nu b">selectedItems</code>数组。父组件——story——公开Cypress的数组，以允许断言选定的项目。<br/>请注意:带有点击管理的组件创建已被移至专用的高阶功能:<code class="fe od oe of nu b">createSelectableRenderdItem</code>。</p><p id="5289" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">选择单个项目的测试如下</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="0ff1" class="lg lh iq nu b gy ny nz l oa ob">it('When the items are clicked, then they are selected', () =&gt; {<br/>  cy.visit('/iframe.html?id=virtuallist--with-selection-management')</span><span id="f372" class="lg lh iq nu b gy oc nz l oa ob">  cy.window()<br/>    .its('storyData')<br/>    .should(storyData =&gt; {<br/>      // the story must expose some variables<br/>      expect(storyData.items).to.be.to.have.length.of.at.least(3)<br/>      expect(storyData.getItemText).to.be.a('function')<br/>      expect(storyData.selectedItems).to.be.an('array')<br/>    })<br/>    .then(({ getItemText, items }) =&gt; {<br/>      cy.findByText(getItemText(items[0]))<br/>        .click()<br/>        .window()<br/>        .its('storyData.selectedItems')<br/>        .should('eql', [items[0].id])</span><span id="baef" class="lg lh iq nu b gy oc nz l oa ob">      cy.findByText(getItemText(items[1]))<br/>        .click()<br/>        .window()<br/>        .its('storyData.selectedItems')<br/>        .should('eql', [items[1].id])<br/>    })<br/>})</span></pre><p id="942f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有的断言都在暴露的<code class="fe od oe of nu b">selectedItems</code>数组本身上。我们不检查渲染的项目是否高亮显示(高亮显示项目是由故事创建的组件负责的)，而只检查VirtualList组件是否正确地管理项目点击。</p><p id="d50c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe od oe of nu b">selectedItems</code>数组不是在开始时读取，而是在每次点击后读取，因为我们需要检查的总是更新的数组，而不是对初始数组的引用(<code class="fe od oe of nu b">React.useState</code>返回<code class="fe od oe of nu b">selectedItems</code>，所以每次选择更新后它都是新的)。</p><h2 id="a949" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">多选断言</h2><p id="34a1" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">下一步是检查VirtualList组件是否正确地管理了元键的使用。在按下meta键的同时单击另一个项目应该会产生两个选定的项目。</p><p id="f6d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们如何保持元键与柏树按下？这是公正的</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="04b4" class="lg lh iq nu b gy ny nz l oa ob">cy.get('body')<br/>  // keeping pressed the meta (CMD) key<br/>  .type('{meta}', { release: false })</span><span id="412d" class="lg lh iq nu b gy oc nz l oa ob">// ...your test code...</span><span id="bd43" class="lg lh iq nu b gy oc nz l oa ob">cy.get('body')<br/>  // releasing the meta (CMD) key<br/>  .type('{meta}', { release: true })</span></pre><p id="519e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">添加项click将导致</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="ae6e" class="lg lh iq nu b gy ny nz l oa ob">cy.get('body')<br/>  // keeping pressed the meta (CMD) key<br/>  .type('{meta}', { release: false })<br/>  .findByText(getItemText(items[2]))<br/>  .click()<br/>  .window()<br/>  .its('storyData.selectedItems')<br/>  .should('eql', [items[1].id, items[2].id])<br/>  .get('body')<br/>  // releasing the meta (CMD) key<br/>  .type('{meta}', { release: true })</span><span id="9c04" class="lg lh iq nu b gy oc nz l oa ob">  cy.get('body')<br/>      .type('{shift}', { release: false })<br/>      .findByText(getItemText(firstRenderedItem))<br/>      .click()<br/>      .window()<br/>      .its('storyData.selectedItems')<br/>      .should('eql', expectedSelectedItemIds)<br/>      .get('body')<br/>      .type('{shift}', { release: true })<br/>  })</span></pre><p id="7f71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是结果的截图</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi og"><img src="../Images/9bd64d885e4f35a878b1efa923efdf8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qM1lpjVFqwjMqffo0A8yFA.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">测试的第一个结果:加载的故事和所有断言的结果。</figcaption></figure><h2 id="2890" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">滚动和选择</h2><p id="0c63" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">由于有了<code class="fe od oe of nu b">scrollVirtualList</code>工具，滚动列表变得很容易，找到第一个呈现的项目是由<code class="fe od oe of nu b">getFirstRenderedItemIndex</code>工具完成的，我们知道如何保持一个键被按下…因此，测试滚动和用Shift修饰符单击(这意味着从上一个被单击的元素和最后一个元素中选择所有内容)应该只是计算所有(预期)被选择的项目的问题。下一段代码只做这些，继续测试完整的代码</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="3f5a" class="lg lh iq nu b gy ny nz l oa ob">cy.findAllByTestId('VirtualList')<br/>  // scrolls the list<br/>  .then(scrollVirtualList)<br/>  .then(() =&gt; {<br/>    // identifies the first rendered item (unknown in advance)<br/>    const firstRenderedItemIndex = getFirstRenderedItemIndex(<br/>      items,<br/>      getItemText,<br/>    )<br/>    const firstRenderedItem = items[firstRenderedItemIndex]</span><span id="6926" class="lg lh iq nu b gy oc nz l oa ob">    // the tests is going to click on the first rendered item<br/>    // keeping the SHIFT key pressed. All the items up to the first<br/>    // rendered one should be selected<br/>    const expectedSelectedItemIds = items<br/>      .slice(0, firstRenderedItemIndex + 1)<br/>      .map(item =&gt; item.id)</span><span id="6397" class="lg lh iq nu b gy oc nz l oa ob">    cy.get('body')<br/>      .type('{shift}', { release: false })<br/>      .findByText(getItemText(firstRenderedItem))<br/>      .click()<br/>      .window()<br/>      .its('storyData.selectedItems')<br/>      .should('eql', expectedSelectedItemIds)<br/>      .get('body')<br/>      .type('{shift}', { release: true })<br/>  })</span></pre><p id="4af5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试的完整代码，检查每一个按键修饰符，很长，但是相当重复</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="31b8" class="lg lh iq nu b gy ny nz l oa ob">it('When the items are clicked, then they are selected', () =&gt; {<br/>  cy.visit('/iframe.html?id=virtuallist--with-selection-management')</span><span id="2968" class="lg lh iq nu b gy oc nz l oa ob">  cy.window()<br/>    .its('storyData')<br/>    .should(storyData =&gt; {<br/>      // the story must expose some variables<br/>      expect(storyData.items).to.be.to.have.length.of.at.least(3)<br/>      expect(storyData.getItemText).to.be.a('function')<br/>      expect(storyData.selectedItems).to.be.an('array')<br/>    })<br/>    .then(({ getItemText, items }) =&gt; {<br/>      // first item click<br/>      cy.findByText(getItemText(items[0]))<br/>        .click()<br/>        .window()<br/>        .its('storyData.selectedItems')<br/>        .should('eql', [items[0].id])</span><span id="4ae8" class="lg lh iq nu b gy oc nz l oa ob">      // second item click<br/>      cy.findByText(getItemText(items[1]))<br/>        .click()<br/>        .window()<br/>        .its('storyData.selectedItems')<br/>        .should('eql', [items[1].id])</span><span id="fab1" class="lg lh iq nu b gy oc nz l oa ob">      // third item click with Meta modifier<br/>      cy.get('body')<br/>        .type('{meta}', { release: false })<br/>        .findByText(getItemText(items[2]))<br/>        .click()<br/>        .window()<br/>        .its('storyData.selectedItems')<br/>        .should('eql', [items[1].id, items[2].id])<br/>        .get('body')<br/>        .type('{meta}', { release: true })</span><span id="4c0c" class="lg lh iq nu b gy oc nz l oa ob">      // first item click with Shift modifier<br/>      cy.get('body')<br/>        .type('{shift}', { release: false })<br/>        .findByText(getItemText(items[0]))<br/>        .click()<br/>        .window()<br/>        .its('storyData.selectedItems')<br/>        .should('eql', [items[2].id, items[1].id, items[0].id])<br/>        .get('body')<br/>        .type('{shift}', { release: true })</span><span id="3dd3" class="lg lh iq nu b gy oc nz l oa ob">      // second item click with Alt modifier<br/>      cy.get('body')<br/>        .type('{alt}', { release: false })<br/>        .findByText(getItemText(items[1]))<br/>        .click()<br/>        .window()<br/>        .its('storyData.selectedItems')<br/>        .should('eql', [items[2].id, items[0].id])<br/>        .get('body')<br/>        .type('{alt}', { release: true })</span><span id="b9cf" class="lg lh iq nu b gy oc nz l oa ob">      // scrolling<br/>      cy.findAllByTestId('VirtualList')<br/>        .then(scrollVirtualList)<br/>        .then(() =&gt; {<br/>          const firstRenderedItemIndex = getFirstRenderedItemIndex(<br/>            items,<br/>            getItemText,<br/>          )<br/>          const firstRenderedItem = items[firstRenderedItemIndex]<br/>          const expectedSelectedItemIds = items<br/>            .slice(0, firstRenderedItemIndex + 1)<br/>            .map(item =&gt; item.id)</span><span id="32c4" class="lg lh iq nu b gy oc nz l oa ob">          // x-th item click with Shift modifier<br/>          cy.get('body')<br/>            .type('{shift}', { release: false })<br/>            .findByText(getItemText(firstRenderedItem))<br/>            .click()<br/>            .window()<br/>            .its('storyData.selectedItems')<br/>            .should('eql', expectedSelectedItemIds)<br/>            .get('body')<br/>            .type('{shift}', { release: true })<br/>        })<br/>    })<br/>})</span></pre><p id="0558" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试结果如下</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ok oj l"/></div></figure><p id="9cf6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您所看到的，左边的命令日志没有清楚地说明发生了什么。我们可以通过添加一些<code class="fe od oe of nu b">cy.log</code>调用来提高测试的口语水平，或者更好地利用<a class="ae kx" href="https://medium.com/slido-dev-blog/cypress-tips-3-improve-your-error-screenshots-in-cypress-b3675968a190" rel="noopener"> Filip的解决方案</a>来充分利用Cypress日志记录。</p><h1 id="9ae3" class="nc lh iq bd li nd ne nf ll ng nh ni lo nj nk nl lr nm nn no lu np nq nr lx ns bi translated">最佳化</h1><p id="9aff" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">测试越快越好。我最初的测试套件花了将近16秒才完全运行。下面是录音(请注意，这是第一个测试套件，测试速度为60 FPS)</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="4435" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有两个主要的改进领域:</p><ul class=""><li id="5fe0" class="lz ma iq jp b jq jr ju jv jy ms kc mt kg mu kk mg mh mi mj bi translated">更快地在故事之间切换(而不是在测试之间重新加载页面)</li><li id="9bc5" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">加速滚动迫使浏览器时钟与柏树</li></ul><h2 id="f383" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">更快地在故事之间切换</h2><p id="9acc" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">感谢Nicholas Boll和他的<a class="ae kx" href="https://github.com/NicholasBoll/cypress-storybook" rel="noopener ugc nofollow" target="_blank"> cypress-storybook </a>插件，它利用storybook APIs加载想要的故事，而无需重新加载整个页面。</p><p id="f1a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在写的时候，我们需要做的就是:</p><ul class=""><li id="c9f8" class="lz ma iq jp b jq jr ju jv jy ms kc mt kg mu kk mg mh mi mj bi translated">将<code class="fe od oe of nu b">import 'cypress-storybook/react'</code>添加到故事书配置中</li><li id="60ac" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">将<code class="fe od oe of nu b">import 'cypress-storybook/cypress'</code>添加到Cypress的support/index.js文件</li><li id="1b14" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">向测试文件添加一个<code class="fe od oe of nu b">before</code>钩子</li></ul><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="13ee" class="lg lh iq nu b gy ny nz l oa ob">before(() =&gt; {<br/>  // Visit the storybook iframe page once per file<br/>  cy.visitStorybook()<br/>})</span></pre><ul class=""><li id="fd08" class="lz ma iq jp b jq jr ju jv jy ms kc mt kg mu kk mg mh mi mj bi translated">通过<code class="fe od oe of nu b">cy.loadStory('VirtualList', 'With 10000 items')</code>加载故事，而不是使用<code class="fe od oe of nu b">cy.visit</code></li><li id="8f84" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">更新暴露的变量，在视频之后解释</li></ul><p id="36ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样做，页面不会在每次测试时都重新加载，整个套件节省了3秒钟，请看</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="d8b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么我们需要通过故事来更新变量？嗯，如果页面没有重新加载，我们就不能确定暴露的变量是我们想要的，特别是因为几乎每个故事都暴露了一个<code class="fe od oe of nu b">items</code>变量，但是变量的内容是不同的。</p><p id="49f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们如何区分故事暴露的变量？嗯，把故事的名字也曝光了！</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="1e66" class="lg lh iq nu b gy ny nz l oa ob">React.useEffect(() =&gt; {<br/>  global.storyData = {<br/>    // the name of the story is exposed too<br/>    storyName: 'With 10000 items',<br/>    items,<br/>    visibleItemsAmount: Math.ceil(listHeight / itemHeight),<br/>    getItemText,<br/>  }<br/>}, [items])</span></pre><p id="2be3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，每个测试都可以检查等待的名字</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="b2af" class="lg lh iq nu b gy ny nz l oa ob">it('When the component receives 10000 items, then only the minimum number of items are rendered', () =&gt; {<br/>  const story = 'With 10000 items'<br/>  cy.loadStory('VirtualList', story)</span><span id="8361" class="lg lh iq nu b gy oc nz l oa ob">  cy.window()<br/>    .its('storyData')<br/>    .should(storyData =&gt; {<br/>      <br/>      // caring about the story name<br/>      expect(storyData.storyName).to.eq(story)</span><span id="6db1" class="lg lh iq nu b gy oc nz l oa ob">      expect(storyData.items).to.be.to.have.length(10000)<br/>      expect(storyData.visibleItemsAmount).to.be.greaterThan(0)<br/>      expect(storyData.getItemText).to.be.a('function')<br/>    })<br/>    .then(({ visibleItemsAmount, getItemText, items }) =&gt; {<br/>      // ... test code...<br/>    })<br/>})</span></pre><p id="578d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">利用<a class="ae kx" href="https://docs.cypress.io/guides/core-concepts/retry-ability.html" rel="noopener ugc nofollow" target="_blank"> Cypress重试能力</a>等待直到所有断言通过。通过这种方式，我们可以确保公开的变量是正确的。</p><p id="651b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与最初的16秒相比，13秒听起来不像是一个巨大的进步…但它是！因为如果我们测试一个没有惯性滚动的组件(例如一个表单)，增益不会从16 "到13 "，而可能从9 "到6 "秒！相信我，<strong class="jp ir">永远不要低估测试速度</strong> …</p><h2 id="1247" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">通过控制时钟来加速滚动</h2><p id="c86c" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">视频强调了大部分测试时间都花在了等待惯性滚动完成上。这没有错，但是一些测试跑步者允许你控制时间，赛普拉斯就是其中之一。当你需要测试<code class="fe od oe of nu b">setTimeout</code>或<code class="fe od oe of nu b">setInterval</code>相关的东西或像惯性滚动这样的动画时，把时间向前推是基本的。</p><p id="393e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="https://docs.cypress.io/api/commands/clock.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>有很多例子，但基本用法足以满足我们的需求。我们需要调用<code class="fe od oe of nu b">cy.clock()</code>，然后用<code class="fe od oe of nu b">cy.tick(&lt;milliseconds&gt;)</code>计时。</p><p id="d564" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个测试对新的时钟控件进行了评论</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="9555" class="lg lh iq nu b gy ny nz l oa ob">it('When the component is scrolled, then the rendered items are not the first ones', () =&gt; {<br/>  const story = 'With 10000 items'<br/>  cy.loadStory('VirtualList', story)</span><span id="3275" class="lg lh iq nu b gy oc nz l oa ob">  // take control of the browser clock<br/>  cy.clock()</span><span id="7c65" class="lg lh iq nu b gy oc nz l oa ob">  cy.window()<br/>    .its('storyData')<br/>    .should(storyData =&gt; {<br/>      expect(storyData.storyName).to.eq(story)<br/>      expect(storyData.items).to.be.to.have.length(10000)<br/>      expect(storyData.visibleItemsAmount).to.be.greaterThan(0)<br/>      expect(storyData.getItemText).to.be.a('function')<br/>    })<br/>    .then(({ visibleItemsAmount, getItemText, items }) =&gt; {<br/>      // this test does not need the `scrollVirtualList` utility anymore<br/>      cy.findByTestId('VirtualList')<br/>        .trigger('wheel', {<br/>          deltaX: 0,<br/>          deltaY: 1000,<br/>        })</span><span id="ec68" class="lg lh iq nu b gy oc nz l oa ob">        // ticking the clock by one second.<br/>        // It jumps to the inertial scroll end.<br/>        .tick(1000)</span><span id="63e9" class="lg lh iq nu b gy oc nz l oa ob">        .then(() =&gt; getFirstRenderedItemIndex(items, getItemText))<br/>        .should('be.greaterThan', 10)<br/>        .then(firstVisibleItemIndex =&gt; {<br/>          const visibleItems = items.slice(<br/>            firstVisibleItemIndex,<br/>            firstVisibleItemIndex + visibleItemsAmount - 1,<br/>          )<br/>          visibleItems.forEach(item =&gt;<br/>            cy.findByText(getItemText(item)).should('be.visible'),<br/>          )<br/>        })<br/>    })<br/>})</span></pre><p id="8cf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是结果</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="aaf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，我们在惯性卷轴的末端跳跃，没有等待它的完成。请注意:整个测试持续时间被屏幕记录篡改，没有记录的测试运行花费的时间更少。</p><p id="e671" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">记住，如果你使用<code class="fe od oe of nu b">cy.clock</code>，使用<code class="fe od oe of nu b">cy.tick</code>不是可选的！如果您不手动勾选时间，列表根本不会滚动，因为时钟被冻结了！看看如果你不计时会发生什么</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi og"><img src="../Images/a6ade89b1131f7c28688f1c586339299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6tqXuqDhWgiWjL5bBYbDFg.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">列表停留在初始滚动级别，它没有滚动，因为我们没有打勾时钟。</figcaption></figure><p id="e820" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe od oe of nu b">.should('be.greaterThan', 10)</code>断言不满足，因为列表根本不滚动。</p><p id="e30b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用于几乎所有测试的时钟控制将它们的持续时间减少了9秒。下一个视频的最终结果</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="1633" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终结果:<strong class="jp ir">从最初的16秒到9秒</strong>，太棒了！测试越快，你就越能利用它们！</p><h2 id="3c8a" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">“无预览”错误</h2><p id="a346" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">如果您遇到此错误</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi og"><img src="../Images/10b5859c7672444227f3f2c489ea76ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d3nfA1zj25it17ppXGRekA.png"/></div></div></figure><p id="703c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重新推出Cypress应该够了。否则，重新启动故事书。这在几个小时内只发生过两次，所以我还没有深入了解它。</p><h1 id="7c37" class="nc lh iq bd li nd ne nf ll ng nh ni lo nj nk nl lr nm nn no lu np nq nr lx ns bi translated">结论</h1><p id="eefb" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">测试就是了解最佳实践，了解测试方法，了解可用的工具，并决定如何混合它们来建立你自己的信心。使用像Cypress这样的浏览器自动化工具可以保证您的组件像您的消费者所期望的那样工作。</p><p id="ba62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你的代码库中有数千个故事，由于工具本身的缓慢(与<a class="ae kx" href="https://testing-library.com/docs/react-testing-library/intro" rel="noopener ugc nofollow" target="_blank"> React测试库</a>相比)，它可能不是最佳选择，但是对于中小型代码库，由于测试时间较少，Cypress可以作为一个一体化的测试工具。</p><p id="0c0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你创造性地测试过你的组件吗？有反馈吗？请留下评论😉</p><p id="b641" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更一般地说:用浏览器自动化工具测试组件是一个热门话题，看看Storybook的这篇推文<a class="ae kx" href="https://twitter.com/storybookjs/status/1183344512787238912" rel="noopener ugc nofollow" target="_blank">和Gleb的这篇推文</a>。</p><h2 id="b809" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">相关文章</h2><p id="95a3" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">你可能会对我的其他文章感兴趣:</p><ul class=""><li id="ed16" class="lz ma iq jp b jq jr ju jv jy ms kc mt kg mu kk mg mh mi mj bi translated">你想提高你的前端生产力吗？Cypress不仅仅是一个测试工具！阅读<a class="ae kx" href="https://medium.com/@NoriSte/front-end-productivity-boost-cypress-as-your-main-development-browser-f08721123498" rel="noopener">前端生产力提升:Cypress作为您的主要开发浏览器</a></li><li id="f476" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">避免用不必要的和不可预知的等待来减缓你的测试:<a class="ae kx" href="https://medium.com/@NoriSte/await-do-not-sleep-your-e2e-tests-df67e051b409" rel="noopener">等待，不要让你的E2E测试休眠</a></li><li id="8379" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">UI测试分类:<a class="ae kx" href="https://medium.com/@NoriSte/component-vs-ui-integration-vs-e2e-tests-f02b575339dc" rel="noopener">组件vs (UI)集成vs E2E测试</a></li></ul></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="8df3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你好👋我是Stefano Magni，我是一名充满激情的<strong class="jp ir"> JavaScript开发人员</strong>，一名<strong class="jp ir"> Cypress大使、</strong>和一名<strong class="jp ir">讲师</strong>。我是WorkWave 的高级前端工程师。<br/>我喜欢创造高质量的产品，测试和自动化一切，学习和分享我的知识，帮助他人，在会议上发言和面对新的挑战。<br/>你可以在<a class="ae kx" href="https://twitter.com/NoriSte?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae kx" href="https://github.com/NoriSte?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> GitHub </a>、<a class="ae kx" href="https://www.linkedin.com/in/noriste/?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到我。你可以找到我最近所有的文章/演讲等等。这里。</p></div></div>    
</body>
</html>