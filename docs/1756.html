<html>
<head>
<title>Entity Framework Core: SQL Server Concurrency Checks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实体框架核心:SQL Server并发检查</h1>
<blockquote>原文：<a href="https://itnext.io/entity-framework-core-sql-server-concurrency-checks-fea21ac7b1b8?source=collection_archive---------1-----------------------#2019-01-20">https://itnext.io/entity-framework-core-sql-server-concurrency-checks-fea21ac7b1b8?source=collection_archive---------1-----------------------#2019-01-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b276c592a22d7ad11bf38692a644a2a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q3bdSn-8QJofN4s2u46S8Q.png"/></div></div></figure><p id="64ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在过去的几周里，我在<a class="ae kw" href="https://elanderson.net/2018/12/entity-framework-core-sqlite-concurrency-checks/" rel="noopener ugc nofollow" target="_blank"> SQLite </a>和<a class="ae kw" href="https://elanderson.net/2019/01/entity-framework-core-postgres-concurrency-checks/" rel="noopener ugc nofollow" target="_blank"> Postgres </a>中介绍了并发检查。本周，我将扩展我的实体框架示例repo，以包括一个基于SQL Server的示例项目，从而演示并发检查。对于SQL Server。添加了SQL Server项目的repo，但是在并发检查之前可以在这里找到<a class="ae kw" href="https://github.com/elanderson/ASP.NET-Core-Entity-Framework/tree/bb5d569123e2dbff42d1622ffd0afc3d20e3d734" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="dd5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，这篇文章中的所有更改都将在SqlServer文件夹下进行。</p><h2 id="0d44" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">上下文变化和数据迁移</h2><p id="7217" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">SQL Server有一个内置的列类型<a class="ae kw" href="https://docs.microsoft.com/en-us/sql/t-sql/data-types/rowversion-transact-sql" rel="noopener ugc nofollow" target="_blank"> rowversion </a>，当插入或更新行时，它会自动生成一个唯一的二进制数。为了通过实体框架利用rowversion列类型，我们需要向我们的模型添加一个新列，该列具有<strong class="ka ir">时间戳</strong>属性，如下所示，来自<strong class="ka ir">联系人</strong>模型中的示例代码。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="772b" class="kx ky iq ma b gy me mf l mg mh">[Timestamp] <br/>public byte[] Timestamp { get; set; }</span></pre><p id="b634" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，在与项目文件位于同一目录的命令提示符下，使用以下命令。NET CLI命令为上述更改生成迁移。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="46f5" class="kx ky iq ma b gy me mf l mg mh">dotnet ef migrations add ContactTimestamp --context ContactsDbContext</span></pre><p id="9ba9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，使用以下命令将迁移应用到您的数据库。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="dc2f" class="kx ky iq ma b gy me mf l mg mh">dotnet ef database update --context ContactsDbContext</span></pre><h2 id="5c0a" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">测试它</h2><p id="6da4" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">为了快速测试，在<strong class="ka ir">联系人</strong>目录下添加一个<strong class="ka ir">并发测试</strong> razor页面。这个函数将确保特定的contact存在，然后从两个不同的DBContexts中提取contact，对产生的contact对象进行变异，然后尝试保存。第一次保存会成功，第二次应该会失败。请注意，这个函数不是一个应该如何做的例子，只是一个快速和肮脏的方法来证明并发检查正在发生。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="1429" class="kx ky iq ma b gy me mf l mg mh">public void OnGet()<br/>{<br/>    var context1 = new ContactsDbContext(new DbContextOptionsBuilder&lt;ContactsDbContext&gt;()<br/>                                         .UseSqlServer("yourConnectionString")<br/>                                         .Options);<br/>    var contactFromContext1 = context1.Contacts<br/>                              .FirstOrDefault(c =&gt; c.Name == "Test");<br/><br/>    if (contactFromContext1 == null)<br/>    {<br/>        contactFromContext1 = new Contact<br/>                              {<br/>                                  Name = "Test"<br/>                              };<br/><br/>        context1.Add(contactFromContext1);<br/>        context1.SaveChanges();<br/>    }<br/><br/>    var context2 = new ContactsDbContext(new DbContextOptionsBuilder&lt;ContactsDbContext&gt;()<br/>                                         .UseSqlServer("yourConnectionString")<br/>                                         .Options);<br/>    var contactFromContext2 = context2.Contacts<br/>                              .FirstOrDefault(c =&gt; c.Name == "Test");<br/><br/>    contactFromContext1.Address = DateTime.Now.ToString();<br/>    contactFromContext2.Address = DateTime.UtcNow.ToString();<br/><br/>    context1.SaveChanges();<br/>    context2.SaveChanges();<br/>}</span></pre><p id="76fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行应用程序并点击<strong class="ka ir">concurrency test</strong>路径，对于我的测试来说是<a class="ae kw" href="https://localhost:44324/Contacts/ConcurrencyTest" rel="noopener ugc nofollow" target="_blank">https://localhost:44324/Contacts/concurrency test</a>。下面是产生的异常。</p><h1 id="0cc5" class="mi ky iq bd kz mj mk ml lc mm mn mo lf mp mq mr li ms mt mu ll mv mw mx lo my bi translated">处理请求时出现未处理的异常。</h1><blockquote class="mz na nb"><p id="1807" class="jy jz nc ka b kb kc kd ke kf kg kh ki nd kk kl km ne ko kp kq nf ks kt ku kv ij bi translated">DbUpdateConcurrencyException:数据库操作预期影响1行，但实际影响了0行。自实体加载后，数据可能已被修改或删除。有关理解和处理乐观并发异常的信息，请参见<a class="ae kw" href="http://go.microsoft.com/fwlink/?LinkId=527962" rel="noopener ugc nofollow" target="_blank">http://go.microsoft.com/fwlink/?LinkId=527962</a>。</p></blockquote><h2 id="ee2b" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">包扎</h2><p id="85ed" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">在这三个提供者中，Postgres似乎具有最简单的实现，并不是说并发将成为您选择数据库提供者的方式。我目前不打算添加任何更多的提供者，但是如果你正在使用，请留下评论，我会考虑添加另一个例子。</p><p id="6559" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最终状态的代码可以在<a class="ae kw" href="https://github.com/elanderson/ASP.NET-Core-Entity-Framework/tree/bd4cd1dedaa50d5949a852b2fdb44135ea62077a" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="6814" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nc">原载于</em><a class="ae kw" href="https://elanderson.net/2019/01/entity-framework-core-sql-server-concurrency-checks/" rel="noopener ugc nofollow" target="_blank"><em class="nc"/></a><em class="nc">。</em></p></div></div>    
</body>
</html>