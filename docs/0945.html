<html>
<head>
<title>Using API Gateways to Facilitate Your Transition from Monolith to Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用API网关帮助您从整体服务过渡到微服务</h1>
<blockquote>原文：<a href="https://itnext.io/using-api-gateways-to-facilitate-your-transition-from-monolith-to-microservices-c08fe3489237?source=collection_archive---------2-----------------------#2018-06-23">https://itnext.io/using-api-gateways-to-facilitate-your-transition-from-monolith-to-microservices-c08fe3489237?source=collection_archive---------2-----------------------#2018-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a471" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的咨询工作中，我遇到了许多从单一应用程序迁移到基于微服务的应用程序的工程团队。“那又怎么样？”你可能会说，“天空是蓝色的”，是的，虽然我知道这种迁移模式几乎成为老生常谈，但迁移的一些方面经常被遗忘。今天我很想谈谈其中的一个话题——边缘网关或API网关的角色。</p><h1 id="1da6" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">迁移到微服务</h1><p id="6a58" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">通常在迁移开始时，显而易见的主题会受到大量关注:通过定义<a class="ae lo" href="https://www.infoq.com/articles/ddd-contextmapping" rel="noopener ugc nofollow" target="_blank">领域驱动的设计</a>激发的<a class="ae lo" href="https://martinfowler.com/bliki/BoundedContext.html" rel="noopener ugc nofollow" target="_blank">有界上下文</a>进行领域建模，创建<a class="ae lo" href="https://continuousdelivery.com/" rel="noopener ugc nofollow" target="_blank">连续交付</a>管道，自动化<a class="ae lo" href="http://amzn.to/2Iq1HlU" rel="noopener ugc nofollow" target="_blank">基础设施供应</a>，增强的<a class="ae lo" href="http://amzn.to/2IlxHr8" rel="noopener ugc nofollow" target="_blank">监控和日志记录</a>，以及加入一些闪亮的新技术(<a class="ae lo" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>，<a class="ae lo" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>，可能还有当前的<a class="ae lo" href="https://buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/" rel="noopener ugc nofollow" target="_blank">服务网格</a>或<a class="ae lo" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank">).然而，不太明显的方面如果被忽视，会造成很多痛苦。一个恰当的例子是如何协调系统的发展和现有用户流量的迁移。虽然您希望重构现有的应用程序架构，并可能引入一些新技术，但是您不希望中断您的最终用户。</a></p><p id="2cf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我在以前的文章“持续交付:API网关如何帮助(或阻碍)中所写的那样，像“跳舞的骨架”这样的模式可以极大地帮助证明新应用程序和基础设施的端到端可行性。然而，绝大多数潜在的客户交互都是通过系统内的单点(入口或边缘网关)进行的，因此，要对现有系统进行试验和改进，您需要在这方面投入大量的时间和精力。</p><h1 id="1935" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">每个(用户)旅程都从边缘开始</h1><p id="5134" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我显然不是第一个谈论在转向基于微服务的应用时需要有效的边缘解决方案的人。事实上，在菲尔·卡尔卡多(Phil Calcado)提出的对马丁·福勒(Martin Fowler)最初的<a class="ae lo" href="https://martinfowler.com/bliki/MicroservicePrerequisites.html" rel="noopener ugc nofollow" target="_blank">微服务先决条件</a>的扩展文章中——<a class="ae lo" href="http://philcalcado.com/2017/06/11/calcados_microservices_prerequisites.html" rel="noopener ugc nofollow" target="_blank">卡尔卡多的微服务先决条件</a>——他的第五个先决条件是“<a class="ae lo" href="http://philcalcado.com/2017/06/11/calcados_microservices_prerequisites.html#5-easy-access-to-the-edge" rel="noopener ugc nofollow" target="_blank">轻松到达边缘</a>”。Phil根据他的经验谈到，许多组织第一次尝试在他们的monolith上部署新的微服务时，只是简单地将服务直接暴露在互联网上。这对于单个(简单的)服务来说可以很好地工作，但是这种方法往往不具有可伸缩性，并且还会迫使调用客户端在授权或数据聚合方面经历重重困难。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/016258e71737559caa909c67fe0f421c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8gJ0imO9IXdidzb7h4QL9Q.png"/></div></div></figure><p id="b837" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以使用现有的整体应用程序作为网关，如果您有复杂且高度耦合的授权和身份验证代码，那么这可能是唯一可行的解决方案，直到安全组件被重构为新的模块或服务。这种方法有明显的缺点，包括要求您必须用任何新的路由信息“更新”monolith(这可能涉及完全重新部署)，以及所有流量必须通过monolith的事实。如果您将微服务部署到单独的新架构或平台(如Kubernetes ),后一个问题的成本可能会特别高，因为现在进入您应用程序的任何请求都必须在接触新堆栈之前通过旧堆栈进行路由。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/2db537766caa9278e353b311f3b417c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IjQyv_orZeYqvtxv33S-RA.png"/></div></div></figure><p id="9949" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能已经在使用边缘网关或反向代理——例如NGINX或ha proxy——因为在使用任何类型的后端架构时，这些都可以提供许多优势。提供的特性通常包括到多个后端组件的透明路由、头重写、TLS终止等，以及横切关注点，而不管请求最终是如何被服务的。在这种情况下，要问的问题是，您是否希望继续将该网关用于您的微服务实现，如果您希望，是否应该以同样的方式使用它？</p><h1 id="dd2b" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">从虚拟机到容器(通过编排)</h1><p id="682e" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">正如我在本文介绍中提到的，许多工程团队在改变应用程序架构的同时，也做出了迁移到新基础设施的决定。这样做的好处和挑战在很大程度上取决于环境，但我看到许多团队从虚拟机和纯基础设施即服务(IaaS)迁移到容器和Kubernetes。</p><p id="cd63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设您决定将全新的微服务打包到容器中，并部署到Kubernetes中，您在处理边缘流量方面面临哪些挑战？本质上有三种选择，其中一种你已经读过了:</p><ul class=""><li id="3048" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">使用现有的整体式应用程序作为边缘网关，将流量路由到整体式应用程序或新服务。这里可以实现任何类型的路由逻辑(因为所有请求都通过monolith传输),并且可以在进程中调用authn/authz</li><li id="03ac" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">在您现有的基础设施中部署和运行一个边缘网关，根据URIs和报头将流量路由到monolith或新服务。Authn和authz通常通过调用monolith或重构的安全服务来完成。</li><li id="a4cd" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">在您的新Kubernetes基础设施中部署和运行一个边缘网关，该网关基于URIs和报头将流量路由到monolith或新服务。Authn和authz通常是通过调用Kubernetes中运行的重构安全服务来完成的。</li></ul><p id="705a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">选择在哪里部署和运行您的边缘网关需要权衡:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mp"><img src="../Images/104ade2c36a627c879c4844777a88e65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mioM6QEThogmQjwfkfBNiQ.png"/></div></div></figure><p id="1ef1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦你选择了如何实现边缘网关，下一个决定就是如何改进你的系统。概括地说，你可以尝试“扼杀”整块石头，或者你把“整块石头放在一个盒子里”并从这里开始凿掉。</p><h1 id="ee32" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">扼杀巨石</h1><p id="2808" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">Martin Fowler写了一篇关于<a class="ae lo" href="https://www.martinfowler.com/bliki/StranglerApplication.html" rel="noopener ugc nofollow" target="_blank">stranger应用程序模式</a>的很棒的文章，尽管这篇文章已经写了十多年了，但是当试图将功能从一个整体迁移到更小的服务中时，同样的指导方针也适用。该模式的核心描述了功能应该以服务的形式从整体中提取出来，这些服务通过RPC或类似REST的“<a class="ae lo" href="http://amzn.to/2pdQCvc" rel="noopener ugc nofollow" target="_blank">接缝</a>”或通过<a class="ae lo" href="https://www.infoq.com/news/2018/03/asynchronous-event-architectures" rel="noopener ugc nofollow" target="_blank">消息和事件</a>与整体进行交互。随着时间的推移，monolith中的功能(和相关代码)被淘汰，这导致新的微服务“扼杀”现有的代码库。这种模式的主要缺点是，只要monolith仍然在使用，您就必须维护现有的基础设施以及您正在部署微服务的任何新平台。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/a300419418d2a9dbe55d44b6e7f9d833.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ifdA0aqe2seM_1DcpEkBQ.png"/></div></div></figure><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/47344cb877ce363f61870721c3669c3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F0f-vipeVyOqs33fFtGgNw.png"/></div></div></figure><p id="d9b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Groupon是第一批深入讨论在微服务中使用这种模式的公司之一，早在2013年，它就发布了“<a class="ae lo" href="https://engineering.groupon.com/2013/misc/i-tier-dismantling-the-monoliths/" rel="noopener ugc nofollow" target="_blank"> I-Tier:拆除整体</a>”。从他们的工作中可以学到很多东西，但我们绝对不需要在2018年编写一个定制的NGINX模块，就像Groupon最初对“Grout”所做的那样。现在现代开源API网关，如<a class="ae lo" href="https://www.getambassador.io/" rel="noopener ugc nofollow" target="_blank">大使</a>和<a class="ae lo" href="https://traefik.io/" rel="noopener ugc nofollow" target="_blank"> Traefik </a>已经存在，它们使用简单的声明式配置来提供这种功能。</p><h1 id="46fe" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">整体盒:简化连续交付</h1><p id="9de1" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我在迁移到微服务并部署到Kubernetes的团队中看到的一个越来越常见的模式是我所称的“盒子里的整体”。当我们在2015年的ContainerSched会议上分享将notonthehighstreet.com的单片Ruby on Rails应用程序(被亲切地称为<a class="ae lo" href="https://www.slideshare.net/dbryant_uk/containersched-2015-our-journey-to-world-gifting-domination-how-notonthehighstreetcom-embraced-docker/10" rel="noopener ugc nofollow" target="_blank"> MonoNOTH </a>)迁移到基于微服务的架构的故事时，我和<a class="ae lo" href="https://twitter.com/sheriffjackson?lang=en" rel="noopener ugc nofollow" target="_blank"> Nic Jackson </a>谈到了这一点。</p><p id="5d3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，这种迁移模式包括将现有的整体应用程序打包到一个容器中，并像运行任何其他新服务一样运行它。如果您正在实现一个新的部署平台，比如Kubernetes，那么您也将在这里运行monolith。这种模式的主要好处是您的连续交付管道的均质化——每个应用程序和服务可能需要定制的构建步骤(或构建容器),以便正确编译和打包代码，但是在创建运行时容器之后，管道中的所有其他步骤都可以使用容器抽象作为部署工件。</p><p id="fc10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">盒中独石模式的最终目标是将您的独石部署到您的新基础设施，并逐渐将您的所有流量转移到这个新平台上。这允许您在完成整体结构的完全分解之前退役旧的基础设施。如果你遵循这种模式，那么我认为在Kubernetes中运行你的边缘网关更有意义，因为这是所有流量最终将被路由的地方。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/9118b156d0bd5b436ecbdb09a9bc774e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fobilwK9fJRNSoIflWIuTQ.png"/></div></div></figure><h1 id="ce25" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">离别的思绪</h1><p id="5de0" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">当从基于虚拟机(VM)的基础架构迁移到像Kubernetes这样的云原生平台时，投入时间来实施有效的边缘/入口解决方案以帮助迁移是非常值得的。您有多种选择来实现这一点:使用现有的单片应用程序作为网关；在现有基础设施中部署或使用边缘网关，在当前服务和新服务之间路由流量；或者在您的新Kubernetes平台中部署一个边缘网关。</p><p id="0082" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Kubernetes中部署边缘网关可以在实施“一体化”等迁移模式时提供更大的灵活性，并且可以更快地过渡到完全基于微服务的应用。</p><p id="54a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mq">本文原载于</em> <a class="ae lo" href="https://blog.getambassador.io/using-api-gateways-to-facilitate-your-transition-from-monolith-to-microservices-5e630da24717" rel="noopener ugc nofollow" target="_blank"> <em class="mq"> getambassador.io博客</em> </a> <em class="mq">。</em></p></div></div>    
</body>
</html>