<html>
<head>
<title>Extracting decorated properties from classes in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从TypeScript中的类提取修饰属性</h1>
<blockquote>原文：<a href="https://itnext.io/extracting-decorated-properties-from-classes-in-typescript-caf24aabcb59?source=collection_archive---------2-----------------------#2019-05-20">https://itnext.io/extracting-decorated-properties-from-classes-in-typescript-caf24aabcb59?source=collection_archive---------2-----------------------#2019-05-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/40e5b9fd111191511eecb59ed2e15d42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tf_R6rG2LbDnNA1OUyhpZQ.png"/></div></div></figure><div class=""/><p id="1e39" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一篇关于我对一个有趣的打字稿问题的复杂而粗糙的答案的旅程的帖子。我不确定这是不是你应该使用的方法，但我认为这是一个有趣的方法。如果有一个更简单的解决方案，我确信(正如坎宁安定律所建议的)它会出现在评论中👇</p><p id="7d03" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意:这个故事进入了一些高级打字稿。我假设你知道什么是装饰器、类型别名和泛型。</p><h1 id="e905" class="ky kz jb bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">这个问题</h1><blockquote class="lw lx ly"><p id="a543" class="jy jz kx ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated">如何创建一个映射类型，只提取已经被我的属性装饰器注释的属性？</p></blockquote><p id="11cc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个问题有点抽象，让我们通过一个例子来看一下。</p><h2 id="6e4f" class="mc kz jb bd la md me dn le mf mg dp li kj mh mi lm kn mj mk lq kr ml mm lu mn bi translated">我们的特别装潢师🐟</h2><p id="b4f1" class="pw-post-body-paragraph jy jz jb ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">让我们想象一下，我们有一个非常重要的名为“特殊”的装饰者:</p><pre class="mt mu mv mw gt mx my mz bn na nb bi"><span id="2618" class="nc kz jb my b be nd ne l nf ng">/* special.ts */<br/><br/>function special(target: Object, propertyName: string) {<br/>  🐟(target)(🚀, 💯, 🙌, propertyName);<br/>}<br/>// I have no clue what this does, but it looks very important.</span></pre><p id="14fa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有一些使用装饰器的类:</p><pre class="mt mu mv mw gt mx my mz bn na nb bi"><span id="ef06" class="nc kz jb my b be nd ne l nf ng">/* SomeModel.ts */<br/><br/>import special from "./special";<br/><br/>export default class SomeModel {<br/>  @special foo: number;<br/>  @special bar: Array&lt;string&gt;;<br/><br/>  baz: number;<br/>  qux: string;<br/>}<br/><br/>export const model = new SomeModel();</span></pre><blockquote class="lw lx ly"><p id="2fe9" class="jy jz kx ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated"><strong class="ka jc">关于代码片段的说明</strong>:本文中曾经嵌入了CodeSandbox，允许你查看来自TypeScript编译器的反馈。不幸的是，由于中等嵌入的问题，我不得不暂时用简单的代码片段替换它们。不过，你仍然可以通过<a class="ae kw" href="https://codesandbox.io/s/tspropertydecorators-0ht2s?file=/src/SomeModel.ts" rel="noopener ugc nofollow" target="_blank">这个链接</a>在沙盒里摆弄代码。</p></blockquote><h2 id="1ae1" class="mc kz jb bd la md me dn le mf mg dp li kj mh mi lm kn mj mk lq kr ml mm lu mn bi translated">getSpecialProperty实用程序</h2><p id="ed5a" class="pw-post-body-paragraph jy jz jb ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">现在我们想创建一个实用函数，从一个对象中获取这些@special属性之一:</p><pre class="mt mu mv mw gt mx my mz bn na nb bi"><span id="ea8a" class="nc kz jb my b be nd ne l nf ng">/* getSpecialProperty.ts */<br/><br/>import { model } from "./SomeModel";<br/><br/>function getSpecialProperty&lt;TModel, TKey extends keyof TModel&gt;(<br/>  model: TModel,<br/>  key: TKey<br/>) {<br/>  return model[key];<br/>}<br/><br/>/* TESTING */<br/>// ✅ works! it even correctly infers type 'number'<br/>const fooValue = getSpecialProperty(model, "foo");<br/><br/>// ❌ this gives an error, as we expected<br/>const imaginaryValue = getSpecialProperty(<br/>  model,<br/>  "imaginary" /* ERROR: Argument of type '"imaginary"' is not assignable to parameter of type '"foo" | "bar" | "baz" | "qux"'. */<br/>);<br/><br/>// 👎 whoops. it allows 'qux', even though it's not special<br/>getSpecialProperty(model, "qux");</span></pre><p id="6f29" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你在最后一行看到的，我们的函数有问题。它还将接受一个没有用我们的特殊装饰器注释的<code class="fe nh ni nj my b">key</code>。这就是我们试图解决的问题:以这样一种方式定义<code class="fe nh ni nj my b">TKey</code>,它只匹配我们特殊的修饰属性。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h1 id="b52f" class="ky kz jb bd la lb nr ld le lf ns lh li lj nt ll lm ln nu lp lq lr nv lt lu lv bi translated">第1部分:非解决方案</h1><p id="0741" class="pw-post-body-paragraph jy jz jb ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">让我们快速地认识到，有一个简单的方法可以将这些@special属性分离出来。只是把他们放在一个单独的类上:</p><pre class="mt mu mv mw gt mx my mz bn na nb bi"><span id="c60b" class="nc kz jb my b be nd ne l nf ng">/* SomeModel.easy.ts */<br/><br/>import special from "./special";<br/><br/>class Special {<br/>  @special foo: number;<br/>  @special bar: Array&lt;string&gt;;<br/>}<br/><br/>class SomeModel {<br/>  special = new Special();<br/><br/>  baz: number;<br/>  qux: string;<br/>}<br/><br/>function getSpecialProperty&lt;TSpecial, TKey extends keyof TSpecial&gt;(<br/>  model: { special: TSpecial },<br/>  key: TKey<br/>) {<br/>  return model.special[key];<br/>}</span></pre><p id="c5e8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，这不是我试图解决的问题的解决方案。我想把我的“@special”属性和其他属性放在同一个对象上。毕竟，如果我也必须将我所有的属性移动到一个单独的对象中，那么使用decorators还有什么意义呢？</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h1 id="a36f" class="ky kz jb bd la lb nr ld le lf ns lh li lj nt ll lm ln nu lp lq lr nv lt lu lv bi translated">第2部分:通过值类型获取键</h1><h2 id="eced" class="mc kz jb bd la md me dn le mf mg dp li kj mh mi lm kn mj mk lq kr ml mm lu mn bi translated">查找所有数字</h2><p id="fa02" class="pw-post-body-paragraph jy jz jb ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">让我们先解决一个“更简单”的问题:从我们的类<code class="fe nh ni nj my b">TModel</code>中获取所有值为类型<code class="fe nh ni nj my b">number</code>的键。我在这里将“更容易”放在引号中，因为这样做的类型别名看起来仍然有点令人生畏:</p><pre class="mt mu mv mw gt mx my mz bn na nb bi"><span id="3acd" class="nc kz jb my b be nd ne l nf ng">/* SomeModel.easy.ts */<br/><br/>/* THIS IS THE TYPE ALIAS */<br/>type NumberKeys&lt;T&gt; = {<br/>  [K in keyof T]: T[K] extends number ? K : never<br/>}[keyof T];<br/><br/>/* BROKEN DOWN EXPLANATION + EXAMPLE */<br/>type ExampleInput = { a: number; b: string; c: number };<br/><br/>// this will convert key-value pairs into key-key pairs<br/>type MapValuesToKeys&lt;T&gt; = { [K in keyof T]: K };<br/>// MapValuesToKeys&lt;ExampleInput&gt; = { a: "a"; b: "b"; c: "c"; }<br/><br/>// this will do the same, but map non-numbers to 'never'<br/>type MapNumbersToKeys&lt;T&gt; = {<br/>  [K in keyof T]: T[K] extends number ? K : never<br/>};<br/>// MapNumbersToKeys&lt;ExampleInput&gt; = { a: "a"; b: never; c: "c"; }<br/><br/>// the last step is to take the above, and get a union of the values<br/>// (note that 'never' gets stripped from union types)<br/>type FinalStep&lt;T&gt; = MapNumbersToKeys&lt;T&gt;[keyof T];<br/>// FinalStep&lt;ExampleInput&gt; = "a" | "c"</span></pre><h2 id="debe" class="mc kz jb bd la md me dn le mf mg dp li kj mh mi lm kn mj mk lq kr ml mm lu mn bi translated">使其更加通用</h2><p id="6057" class="pw-post-body-paragraph jy jz jb ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">我们可以一般化我们的<code class="fe nh ni nj my b">NumberKeys</code>类型别名来获得任何给定类型的键:</p><pre class="mt mu mv mw gt mx my mz bn na nb bi"><span id="bbcc" class="nc kz jb my b be nd ne l nf ng">type KeysOfType&lt;TTarget, TValue&gt; = {<br/>  [K in keyof TTarget]: TTarget[K] extends TValue ? K : never<br/>}[keyof TTarget];</span></pre><p id="88d9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了！所以现在我们所需要的就是使用这个类型别名来过滤我们特殊属性的类型，我们就完成了！🥳</p><p id="3889" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯……这就是问题所在😟。我们的属性<code class="fe nh ni nj my b">foo</code>和<code class="fe nh ni nj my b">bar</code>可能有<code class="fe nh ni nj my b">special</code>装饰器，但是它们的类型只是普通的<code class="fe nh ni nj my b">number</code>和<code class="fe nh ni nj my b">Array&lt;string&gt;</code>。而且(在编写的时候)TypeScript不允许你用装饰器改变某些东西的类型。它在Github上有一个<a class="ae kw" href="https://github.com/Microsoft/TypeScript/issues/4881" rel="noopener ugc nofollow" target="_blank">冗长的问题</a>，看起来这个问题不会很快得到解决。这让我们别无选择，只能显式地改变我们的修饰属性的类型。</p><h1 id="0ea6" class="ky kz jb bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第3部分:创建“特殊”类型</h1><p id="cb0e" class="pw-post-body-paragraph jy jz jb ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">让我们创建一个新的类型<code class="fe nh ni nj my b">Special</code>,它具有一些属性，可以与其他类型区分开来。我们可以编造一些东西，因为我们在运行时并不真的要使用它🤷‍♂️.让我们也修改一下我们的@special装饰器，这样它就不能再用于不是<code class="fe nh ni nj my b">Special</code>的属性</p><pre class="mt mu mv mw gt mx my mz bn na nb bi"><span id="fc19" class="nc kz jb my b be nd ne l nf ng">/* SpecialType.ts */<br/><br/>export interface IsSpecial {<br/>  __imAUniqueSnowflake: true;<br/>}<br/><br/>// I guess you could say this is my specialty<br/>export type Special&lt;T&gt; = T &amp; IsSpecial;<br/><br/>// By typing our @special decorator like this,<br/>// decorated property need type 'IsSpecial'<br/>export function special&lt;<br/>  TKey extends string,<br/>  TTarget extends { [K in TKey]: IsSpecial }<br/>&gt;(target: TTarget, propertyName: TKey) {<br/>  // implementation here<br/>}</span></pre><p id="23d3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个使用我们新类型的模型:</p><pre class="mt mu mv mw gt mx my mz bn na nb bi"><span id="8ce4" class="nc kz jb my b be nd ne l nf ng">/* SpecialTypeClass.ts */<br/><br/>import { special, Special } from "./SpecialType";<br/><br/>class SomeModel {<br/>  @special foo: Special&lt;number&gt;;<br/>  @special bar: Special&lt;Array&lt;string&gt;&gt;;<br/><br/>  baz: number;<br/>  qux: string;<br/>}<br/><br/>/* TESTING */<br/>const model = new SomeModel();<br/><br/>logNumber(model.foo); // ✅ OK<br/>model.foo = 5; // ❌ ERROR: Type '5' is not assignable to type 'Special&lt;number&gt;'. Type '5' is not assignable to type 'IsSpecial'.ts(2322)<br/>model.bar = ["abc"]; // ❌ ERROR Type 'string[]' is not assignable to type 'Special&lt;string[]&gt;'. Property '__imAUniqueSnowflake' is missing in type 'string[]' but required in type 'IsSpecial'.<br/><br/>function logNumber(n: number) {<br/>  console.log(n);<br/>}</span></pre><p id="3c84" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是，我们引入了一个新问题😩。我们仍然可以将<code class="fe nh ni nj my b">model.foo</code>和<code class="fe nh ni nj my b">model.bar</code>传递给需要<code class="fe nh ni nj my b">number</code>和<code class="fe nh ni nj my b">Array&lt;string&gt;</code>的函数，但是我们不能再用没有被转换为<code class="fe nh ni nj my b">Special</code>的值来更新<code class="fe nh ni nj my b">foo</code>和<code class="fe nh ni nj my b">bar</code>。当您在类上定义初始值时，这可能是一个可接受的折衷，但是当在整个应用程序中使用该模型时，这就不太实际了。</p><blockquote class="ny"><p id="9b67" class="nz oa jb bd ob oc od oe of og oh kv dk translated">这看起来像是一个第22条军规:我们想要改变@special修饰属性的类型，这样我们就可以提取它们，但是每一次改变都会使它们与我们的原始类型不兼容。</p></blockquote><h1 id="1b3a" class="ky kz jb bd la lb lc ld le lf lg lh li lj oi ll lm ln oj lp lq lr ok lt lu lv bi translated">第4部分:回到绘图板</h1><h2 id="042c" class="mc kz jb bd la md me dn le mf mg dp li kj mh mi lm kn mj mk lq kr ml mm lu mn bi translated">无法接受？</h2><p id="46bb" class="pw-post-body-paragraph jy jz jb ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">因此，我们从一个不合适的方法开始:将属性放在一个单独的对象上。然后我们开始尝试使用特殊类型提取我们的属性。这似乎使我们的课变得毫无用处。但是，如果我们把这些方法组合成一个弗兰肯斯坦式的黑客大师会怎么样呢？🤔当然，这将解决我们的问题。</p><p id="fdb8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">🦹‍♂ ️Here是我们邪恶的总计划:</p><ol class=""><li id="3033" class="ol om jb ka b kb kc kf kg kj on kn oo kr op kv oq or os ot bi translated">用一个<code class="fe nh ni nj my b">Special</code>类型定义我们类的<code class="fe nh ni nj my b">@special</code>修饰属性</li><li id="91e1" class="ol om jb ka b kb ou kf ov kj ow kn ox kr oy kv oq or os ot bi translated">使用<code class="fe nh ni nj my b">Special</code>类型提取类的修饰属性</li><li id="daa6" class="ol om jb ka b kb ou kf ov kj ow kn ox kr oy kv oq or os ot bi translated">创建一个<strong class="ka jc">新类型</strong>，它将所有的修饰属性转换回它们的原始类型<em class="kx">，而且</em>还添加了一个单独的对象，只包含修饰属性</li><li id="af7f" class="ol om jb ka b kb ou kf ov kj ow kn ox kr oy kv oq or os ot bi translated">欺骗typescript认为我们的原始类实际上是这种新类型👌</li></ol><h2 id="7312" class="mc kz jb bd la md me dn le mf mg dp li kj mh mi lm kn mj mk lq kr ml mm lu mn bi translated">我们的最终模型</h2><p id="dc3a" class="pw-post-body-paragraph jy jz jb ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">这是我们最终模型的样子:</p><pre class="mt mu mv mw gt mx my mz bn na nb bi"><span id="2f3c" class="nc kz jb my b be nd ne l nf ng">/* FinalModel.ts */<br/><br/>import { special, Special } from "./SpecialType";<br/>import WithSpecial from "./WithSpecial";<br/><br/>class FinalModel {<br/>  @special foo: Special&lt;number&gt;;<br/>  @special bar: Special&lt;Array&lt;string&gt;&gt;;<br/><br/>  baz: number;<br/>  qux: string;<br/>}<br/><br/>export default (FinalModel as unknown) as WithSpecial&lt;<br/>  typeof FinalModel<br/>&gt;;</span></pre><p id="51b4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，最后一行已经包含了我们邪恶计划的4️⃣步骤。它导出了<code class="fe nh ni nj my b">FinalModel</code>，但稍加修改。首先，它通过将TypeScript强制转换为未知的类型来忘记它所知道的关于这个类的一切。🕶</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="oz nx l"/></div><figcaption class="pa pb gj gh gi pc pd bd b be z dk translated">"未知"</figcaption></figure><p id="0625" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二，我们用自己的解释替换类型。这就是<code class="fe nh ni nj my b">as WithSpecial&lt;typeof FinalModel&gt;</code>的作用。我喜欢这个最终解决方案的原因是，我们的模型看起来非常清晰易读。当然，我们必须在类声明中加入一些<code class="fe nh ni nj my b">Special</code>类型，但是我们的decorator签名将确保我们不会忘记这一点。尽管如此，我们仍然必须写<code class="fe nh ni nj my b">WithSpecial</code>，这是所有肮脏的黑客攻击发生的地方。所以让我们把它藏在一个单独的模块里，这样就没人会发现它了。🤫</p><h2 id="4195" class="mc kz jb bd la md me dn le mf mg dp li kj mh mi lm kn mj mk lq kr ml mm lu mn bi translated">转换类定义</h2><p id="83a3" class="pw-post-body-paragraph jy jz jb ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">那么我们如何转换一个类定义呢？这归结为两件事:映射静态属性并转换构造函数以使它返回我们修改过的实例类型:</p><pre class="mt mu mv mw gt mx my mz bn na nb bi"><span id="3d66" class="nc kz jb my b be nd ne l nf ng">/* WithSpecial.ts */<br/><br/>import TransformSpecial from "./TransformSpecial";<br/><br/>// type that will match any class (constructor)<br/>type AnyConstructor = new (...args: Array&lt;any&gt;) =&gt; any;<br/><br/>// extract the type of the arguments of a constructor function<br/>type ConstructorArgs&lt;T&gt; = T extends new (...args: infer A) =&gt; any<br/>  ? A<br/>  : never;<br/><br/>type WithSpecial&lt;T extends AnyConstructor&gt; = {<br/>  // include any static properties on the class<br/>  [K in keyof T]: T[K]<br/>} &amp; {<br/>  // type a constructor with the original arguments,<br/>  // but return a transformed instance<br/>  new (...args: ConstructorArgs&lt;T&gt;): TransformSpecial&lt;<br/>    InstanceType&lt;T&gt;<br/>  &gt;;<br/>};<br/><br/>export default WithSpecial;</span></pre><h2 id="8913" class="mc kz jb bd la md me dn le mf mg dp li kj mh mi lm kn mj mk lq kr ml mm lu mn bi translated">转换类实例</h2><p id="bbc2" class="pw-post-body-paragraph jy jz jb ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">现在让我们定义新的实例类型。所有的<code class="fe nh ni nj my b">Special</code>属性将被映射回它们原来的类型。此外，我们创建了一个名为<code class="fe nh ni nj my b">__special</code>的新属性。这在运行时并不真正存在，但TypeScript会认为它存在。我们可以利用这一点来访问所有的<code class="fe nh ni nj my b">Special</code>属性名称，即使属性本身现在恢复正常。</p><pre class="mt mu mv mw gt mx my mz bn na nb bi"><span id="a3c4" class="nc kz jb my b be nd ne l nf ng">/* TransformSpecial.ts */<br/><br/>import { Special } from "./SpecialType";<br/><br/>// leftover from previous experiment<br/>// gets all keys of 'TTarget' where the value has type 'TValue'<br/>type KeysOfType&lt;TTarget extends object, TValue&gt; = {<br/>  [K in keyof TTarget]: TTarget[K] extends TValue ? K : never<br/>}[keyof TTarget];<br/><br/>type TransformSpecial&lt;T extends object&gt; = {<br/>  // map over all properties. If they are special, transform them back<br/>  [P in keyof T]: T[P] extends Special&lt;infer A&gt; ? A : T[P]<br/>} &amp; {<br/>  // define a new property, __special<br/>  // this will only contain all the Special properties<br/>  __special: Pick&lt;T, KeysOfType&lt;T, Special&lt;unknown&gt;&gt;&gt;;<br/>};<br/><br/>// we can use this to extract Special properties from our transformed class<br/>export type HasSpecial = { __special: object };<br/>export type SpecialKeys&lt;T extends HasSpecial&gt; = keyof T["__special"];<br/><br/>export default TransformSpecial;</span></pre><h2 id="6394" class="mc kz jb bd la md me dn le mf mg dp li kj mh mi lm kn mj mk lq kr ml mm lu mn bi translated">新的和改进的getSpecialProperty</h2><p id="0fa0" class="pw-post-body-paragraph jy jz jb ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">现在我们有了一个类，其中我们的属性有普通类型，我们有一个util来提取所有修饰属性，我们最终可以创建我们的改进版本的<code class="fe nh ni nj my b">getSpecialProperty</code>😀</p><pre class="mt mu mv mw gt mx my mz bn na nb bi"><span id="a2da" class="nc kz jb my b be nd ne l nf ng">/* getSpecialProperty.fixed.ts */<br/><br/>import FinalModel from "./FinalModel";<br/>import { SpecialKeys, HasSpecial } from "./TransformSpecial";<br/><br/>function getSpecialProperty&lt;<br/>  TModel extends HasSpecial,<br/>  TKey extends SpecialKeys&lt;TModel&gt;<br/>&gt;(model: TModel, key: TKey): TModel[TKey] {<br/>  return model[key];<br/>}<br/><br/>/* TESTING */<br/>const model = new FinalModel();<br/><br/>// ✅ still works<br/>const fooValue = getSpecialProperty(model, "foo");<br/>// ❌ Gives an error now, because "qux" is not special!<br/>const quxValue = getSpecialProperty(<br/>  model,<br/>  "qux" /* Argument of type '"qux"' is not assignable to parameter of type '"foo" | "bar"'. */<br/>);</span></pre><p id="ca3f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而随着<code class="fe nh ni nj my b">qux</code>上的那个错误，我们的寻找也走到了尽头。🎉🎈🎊👯‍♂️</p><p id="77f1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经实现了对修饰属性进行类型检查的目标，现在终于可以休息了。😴</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h1 id="c667" class="ky kz jb bd la lb nr ld le lf ns lh li lj nt ll lm ln nu lp lq lr nv lt lu lv bi translated">问与答(Question and Answer)</h1><blockquote class="lw lx ly"><p id="2584" class="jy jz kx ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated">有没有更简单的方法来实现这一点？</p></blockquote><p id="a7f4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可能</p><blockquote class="lw lx ly"><p id="dc9c" class="jy jz kx ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated">我应该用这个黑客吗？</p></blockquote><p id="f64a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可能不会</p><blockquote class="lw lx ly"><p id="1c06" class="jy jz kx ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated">我能组织我的代码，这样我就不会遇到这个问题了吗？</p></blockquote><p id="3e92" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">明确地</p><blockquote class="lw lx ly"><p id="5fc3" class="jy jz kx ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated">这值得吗？</p></blockquote><p id="33eb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">绝对</strong></p><blockquote class="lw lx ly"><p id="8631" class="jy jz kx ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated">我只是滚动到底部，因为我不想阅读你的长篇大论。我可以有一个复制粘贴通用版本，能够注释和提取任何一组属性吗？就算我不用装修工？</p></blockquote><p id="8e51" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">给你:</p><pre class="mt mu mv mw gt mx my mz bn na nb bi"><span id="bafb" class="nc kz jb my b be nd ne l nf ng">/* generic.ts */<br/><br/>// use this to test if a class is transformed or if a property is a special attribute<br/>type WithAttribute&lt;TAttr extends string&gt; = { [K in TAttr]: object };<br/>// a generic version of the special attribute type<br/>type AttributeType&lt;TAttr extends string = string, TVal = unknown&gt; = {<br/>  value: TVal;<br/>} &amp; WithAttribute&lt;TAttr&gt;;<br/>// extract all the special attributes of a transformed class<br/>type AttributeKeysOf&lt;<br/>  TAttr extends string,<br/>  TModel extends WithAttribute&lt;TAttr&gt;<br/>&gt; = keyof TModel[TAttr];<br/><br/>// transform a class with typed attributes<br/><br/>// prettier-ignore<br/>type WithAttributes&lt;TModel extends new (...args: Array&lt;any&gt;) =&gt; any, TAttr extends string&gt; = {<br/>  [K in keyof TModel]: TModel[K] <br/>} &amp; {<br/>  new (...args: TModel extends new (...args: infer A) =&gt; any ? A : never): {<br/>    [P in keyof InstanceType&lt;TModel&gt;]: InstanceType&lt;TModel&gt;[P] extends AttributeType&lt;TAttr, infer A&gt; ? A : InstanceType&lt;TModel&gt;[P]<br/>  } &amp; {<br/>    [K in TAttr]: Pick&lt;InstanceType&lt;TModel&gt;, {<br/>      [K in keyof InstanceType&lt;TModel&gt;]: InstanceType&lt;TModel&gt;[K] extends AttributeType&lt;TAttr, any&gt; ? K : never<br/>    }[keyof InstanceType&lt;TModel&gt;]&gt;<br/>  };<br/>};<br/><br/>/* EXAMPLE USAGE -- creating an Ultra special attribtue */<br/><br/>// create our special attribute type 'Ultra'<br/>// it doesn't really matter what string you put here, as long as it's unique<br/>type UltraId = "__ultra";<br/>type Ultra&lt;T&gt; = AttributeType&lt;UltraId, T&gt;;<br/>type UltraKeysOf&lt;T extends WithAttribute&lt;UltraId&gt;&gt; = AttributeKeysOf&lt;<br/>  UltraId,<br/>  T<br/>&gt;;<br/><br/>/* EXAMPLE USAGE -- create a setter to set Ultra special attributes */<br/>function setSpecialProperty&lt;<br/>  TModel extends WithAttribute&lt;UltraId&gt;,<br/>  TKey extends UltraKeysOf&lt;TModel&gt;<br/>&gt;(model: TModel, key: TKey, value: TModel[TKey]) {<br/>  model[key] = value;<br/>}<br/><br/>/* EXAMPLE USAGE -- creating a model with Ultra special attributes */<br/>// don't use this one -- this is the base model<br/>class BaseModel {<br/>  ultraNumber: Ultra&lt;number&gt;;<br/>  ultraString: Ultra&lt;string&gt;;<br/><br/>  regularNumber: number;<br/>  someArray: Array&lt;string&gt;;<br/>}<br/>// use this one<br/>const Model = (BaseModel as unknown) as WithAttributes&lt;<br/>  typeof BaseModel,<br/>  UltraId<br/>&gt;;<br/>type Model = InstanceType&lt;typeof Model&gt;;<br/><br/>/* TESTING THE EXAMPLE */<br/>const model: Model = new Model();<br/><br/>setSpecialProperty(model, "ultraNumber", 5); // ✅ compiles<br/>setSpecialProperty(model, "ultraNumber", "5"); // ❌ Error, value should be number<br/>setSpecialProperty(model, "ultraString", "5"); // ✅ compiles<br/>setSpecialProperty(model, "ultraString", 5); // ❌ Error, value should be string<br/>setSpecialProperty(model, "regularNumber", 5); // ❌ Error, regularNumber is not Ultra<br/>setSpecialProperty(model, "someArray", ["abc"]); // ❌ Error, someArray is not Ultra<br/><br/>const logNumber = (n: number) =&gt; console.log(n);<br/>logNumber(model.ultraNumber); // ✅ ultraNumber is still of type number<br/>model.ultraNumber = 5; // ✅ still able to assign numbers to ultraNumber<br/><br/>/* EXAMPLE USAGE - limiting a decorator to Ultra typings */<br/>function ultra&lt;<br/>  TKey extends string,<br/>  TTarget extends { [K in TKey]: Ultra&lt;unknown&gt; }<br/>&gt;(target: TTarget, propertyName: TKey) {<br/>  // decorator implementation here<br/>}<br/><br/>class DecoratedModel {<br/>  @ultra someProperty: number; // ❌ Error, property has to have Ultra type<br/>  @ultra anotherOne: Ultra&lt;number&gt;; // ✅ compiles<br/>}</span></pre></div></div>    
</body>
</html>