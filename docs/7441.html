<html>
<head>
<title>Google Firebase with dotnet6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google Firebase with dotnet6</h1>
<blockquote>原文：<a href="https://itnext.io/google-firebase-with-dotnet-6-f8a4a62db0b1?source=collection_archive---------0-----------------------#2022-09-25">https://itnext.io/google-firebase-with-dotnet-6-f8a4a62db0b1?source=collection_archive---------0-----------------------#2022-09-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/56d3e81fc5ea6ba1b27464caedc6c3fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*deRjNf8pU9_mxdjH5QWDJw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用带有dotnet6和Vue的本地仿真器开始使用Google Cloud Firebase</figcaption></figure><p id="c631" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">谷歌<strong class="ke ir"> <em class="la"> Firestore </em> </strong>是一个面向文档的数据库，作为<strong class="ke ir"> <em class="la"> Firebase </em> </strong>产品的一部分，它具有一些用于构建现代应用的简洁功能。</p><p id="4917" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你以前没有使用过<a class="ae lb" href="https://firebase.google.com/" rel="noopener ugc nofollow" target="_blank"> Google Firebase </a>，它是一个品牌下的一套PaaS工具，包括:</p><ul class=""><li id="b7b8" class="lc ld iq ke b kf kg kj kk kn le kr lf kv lg kz lh li lj lk bi translated">类似于AWS Cognito或Azure AD B2C的身份管理服务</li><li id="7eac" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated">类似于AWS DocumentDB或Azure CosmosDB的文档数据库</li><li id="599d" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated">与数据库的实时同步类似于AWS AppSync和DynamoDB(除了没有GraphQL)</li><li id="f67a" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated">与谷歌云功能运行时的集成</li><li id="efb5" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated">与谷歌云存储集成</li></ul><p id="7e5e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在大多数方面，我发现它在表面上与<a class="ae lb" href="https://docs.amplify.aws/" rel="noopener ugc nofollow" target="_blank"> AWS Amplify </a>在概念上相似。现在与两者都合作过，他们在实践中感觉非常不同。</p><p id="ed5b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Supabase 是另一个具有免费层的替代方案，它标榜自己是“开源Firebase替代方案”,但却用NoSQL数据库替换Postgres。如果您更喜欢使用关系数据，那么可以看一看。(<a class="ae lb" href="https://github.com/supabase/realtime" rel="noopener ugc nofollow" target="_blank">注意，实时代理还没有准备好生产</a>)。</p><p id="1e9c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此图显示了Firebase本地仿真器的各个部分，提供了主要体系结构组件的高级视图:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lq"><img src="../Images/5c07cc014eb547ec8d07cb3efe7b9334.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1Oa-SlLZxRpr5dlL.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">谷歌Firebase仿真器套件组件。</figcaption></figure><p id="26b9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae lb" href="https://firebase.google.com/pricing" rel="noopener ugc nofollow" target="_blank">Firebase的免费层非常慷慨</a>，在你需要的时候仍然能够扩展的同时，提供了很多构建辅助项目的空间。值得注意的是，它不包括计算(函数)，但根据CloudSQL的定价，使用函数或云运行的计算可能是构建云应用程序的较小部分。</p><p id="8a00" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将通过一个具有实时订阅、身份验证和后端API调用的端到端示例来了解如何使用Google Firebase和dotnet6构建实时web应用程序，包括设置和与本地仿真器的集成。</p><p id="4c83" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你想直接跳到工作代码，完整的回购可以在这里找到:</p><div class="lv lw gp gr lx ly"><a href="https://github.com/CharlieDigital/dn6-firebase" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd ir gy z fp md fr fs me fu fw ip bi translated">GitHub-Charlie digital/dn6-firebase:一个展示如何将dotnet6与Google整合的知识库…</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">此repo提供了使用的快速入门:如果您想自己设置，请按照以下步骤操作。💡这些…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">github.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm jw ly"/></div></div></a></div><p id="941c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">先决条件:</p><ul class=""><li id="ef42" class="lc ld iq ke b kf kg kj kk kn le kr lf kv lg kz lh li lj lk bi translated">设置Google云帐户</li><li id="6ff8" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated"><a class="ae lb" href="https://dotnet.microsoft.com/en-us/download" rel="noopener ugc nofollow" target="_blank">为您的操作系统下载并安装dot net SDK</a></li><li id="08d2" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated">下载并安装<a class="ae lb" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank">节点</a>和<a class="ae lb" href="https://classic.yarnpkg.com/lang/en/docs/install/#mac-stable" rel="noopener ugc nofollow" target="_blank">纱线</a></li></ul><p id="5890" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们还需要下载并安装<a class="ae lb" href="https://firebase.google.com/docs/cli#install_the_firebase_cli" rel="noopener ugc nofollow" target="_blank">Firebase CLI</a>和<a class="ae lb" href="https://firebase.google.com/docs/emulator-suite/connect_and_prototype" rel="noopener ugc nofollow" target="_blank"> Firebase模拟器</a> (macOS说明如下；请参见上面的Windows链接):</p><pre class="lr ls lt lu gt mn mo mp mq aw mr bi"><span id="155c" class="ms mt iq mo b gy mu mv l mw mx">curl -sL https://firebase.tools | bash<br/>firebase --version                    <em class="la"><br/></em>firebase login</span></pre></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="cb71" class="nf mt iq bd ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob bi translated">工作空间设置</h1><p id="9306" class="pw-post-body-paragraph kc kd iq ke b kf oc kh ki kj od kl km kn oe kp kq kr of kt ku kv og kx ky kz ij bi translated">我们将首先通过为后端API和前端应用程序创建目录来设置我们的工作区:</p><pre class="lr ls lt lu gt mn mo mp mq aw mr bi"><span id="c932" class="ms mt iq mo b gy mu mv l mw mx">mkdir dn6-firebase      <strong class="mo ir"># Create our working directory</strong><br/>cd dn6-firebase<br/>mkdir api               <strong class="mo ir"># Create a directory for our dotnet6 api</strong><br/>mkdir web-vue           <strong class="mo ir"># Create a directory for our Vue front-end.</strong><br/>dotnet new gitignore    <strong class="mo ir"># Create a gitignore file at the root</strong><br/>git init                <strong class="mo ir"># Initialize git at the root</strong></span><span id="b0e7" class="ms mt iq mo b gy oh mv l mw mx"><strong class="mo ir"># Initialize a minimal dotnet6 web API in C#<br/></strong>cd api<br/>dotnet new webapi -minimal</span><span id="cb5e" class="ms mt iq mo b gy oh mv l mw mx"><strong class="mo ir"># Create a new Vue application with TypeScript</strong><br/>cd ../web-vue<br/>yarn create vite . --template vue-ts</span></pre><p id="e9ab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">设置好目录后，从工作区的根目录运行<code class="fe oi oj ok mo b">firebase init</code>,并按照提示进行操作:</p><pre class="lr ls lt lu gt mn mo mp mq aw mr bi"><span id="13a5" class="ms mt iq mo b gy mu mv l mw mx"># <strong class="mo ir">? Which Firebase features do you want to set up for this directory?</strong><br/>Emulators: Set up local emulators for Firebase products</span><span id="f626" class="ms mt iq mo b gy oh mv l mw mx"># <strong class="mo ir">? Please select an option</strong><br/>Create a new project</span><span id="5991" class="ms mt iq mo b gy oh mv l mw mx"># <strong class="mo ir">? Please specify a unique project id</strong><br/>dn6-firebase-demo</span></pre><p id="93ea" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您<strong class="ke ir"> <em class="la">必须</em> </strong>创建一个项目；否则，应用程序初始化将会失败。不用担心，在  Google Cloud中，你不用调配任何服务<strong class="ke ir"><em class="la">；你只需要创建项目(我还不知道这是否是硬性要求，因为我们只使用模拟器，但一个小时的折腾也不能解决它！).</em></strong></p><p id="9f62" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">继续模拟器的设置，现在只选择<strong class="ke ir">认证</strong>和<strong class="ke ir"> Firestore </strong>:</p><pre class="lr ls lt lu gt mn mo mp mq aw mr bi"><span id="f4f2" class="ms mt iq mo b gy mu mv l mw mx"># <strong class="mo ir">? Which Firebase emulators do you want to set up?</strong><br/>Authentication Emulator<br/>Firestore Emulator</span><span id="7b51" class="ms mt iq mo b gy oh mv l mw mx"># Accept the defaults or enter custom ports and enable the admin UI<br/># I'm using <strong class="mo ir">8181</strong> for the Firestore port and <strong class="mo ir">10099</strong> for Authentication<br/># The defaults are <strong class="mo ir">8080</strong> and <strong class="mo ir">9099</strong><br/># Select a port for the admin UI like <strong class="mo ir">9898</strong><br/># When prompted, download the emulators</span></pre><p id="cdff" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，我们可以使用以下命令启动模拟器:</p><pre class="lr ls lt lu gt mn mo mp mq aw mr bi"><span id="50c2" class="ms mt iq mo b gy mu mv l mw mx">firebase emulators:start</span></pre><p id="37e3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果一切顺利，模拟器的管理用户界面可从以下网址获得:</p><pre class="lr ls lt lu gt mn mo mp mq aw mr bi"><span id="c076" class="ms mt iq mo b gy mu mv l mw mx"><a class="ae lb" href="http://localhost:9898" rel="noopener ugc nofollow" target="_blank">http://localhost:<strong class="mo ir">9898</strong></a></span></pre><h1 id="3a79" class="nf mt iq bd ng nh ol nj nk nl om nn no np on nr ns nt oo nv nw nx op nz oa ob bi translated"><strong class="ak">c#中的后端API</strong></h1><p id="c84a" class="pw-post-body-paragraph kc kd iq ke b kf oc kh ki kj od kl km kn oe kp kq kr of kt ku kv og kx ky kz ij bi translated">让我们从构建后端API开始。我们的应用程序将简单地捕获一个城市列表。</p><blockquote class="oq or os"><p id="4008" class="kc kd la ke b kf kg kh ki kj kk kl km ot ko kp kq ou ks kt ku ov kw kx ky kz ij bi translated">你可能会问为什么要用Firebase构建后端？毕竟，你可以从前端直接与Firestore交互。然而，有几个很好的理由:</p><p id="ae3d" class="kc kd la ke b kf kg kh ki kj kk kl km ot ko kp kq ou ks kt ku ov kw kx ky kz ij bi translated">-如果您需要或期望与外部API交互，或者利用发布/订阅队列来管理并发性，或者使用任务队列来调度工作，您将需要一个后端API。</p><p id="3485" class="kc kd la ke b kf kg kh ki kj kk kl km ot ko kp kq ou ks kt ku ov kw kx ky kz ij bi translated">-如果您的数据模型中有复杂的业务逻辑或规则，很难或不可能在Firestore规则文件中表达。</p><p id="0d70" class="kc kd la ke b kf kg kh ki kj kk kl km ot ko kp kq ou ks kt ku ov kw kx ky kz ij bi translated">-如果您的数据模型包含您想要控制写入的信息(在规则文件中也是可能的，但是在代码中更容易管理)。</p><p id="397b" class="kc kd la ke b kf kg kh ki kj kk kl km ot ko kp kq ou ks kt ku ov kw kx ky kz ij bi translated">此外，使用管理SDK绕过了安全规则，这是有好处的，因为Firestore安全策略文件可以只关注读取场景。这可以被认为是<a class="ae lb" href="https://martinfowler.com/bliki/CQRS.html" rel="noopener ugc nofollow" target="_blank">命令查询责任分离或CQRS </a>。将更新逻辑放在后端API上还允许更好地记录突变，而不必引入前端记录库。</p><p id="2892" class="kc kd la ke b kf kg kh ki kj kk kl km ot ko kp kq ou ks kt ku ov kw kx ky kz ij bi translated">这个例子当然可以在没有后端API的情况下完成，但是这个练习的一部分是证明如何与后端API交互的auth模型。但是也要记住，这打破了Firebase的离线用例。</p></blockquote><p id="bde3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，我们需要添加Firestore包:</p><pre class="lr ls lt lu gt mn mo mp mq aw mr bi"><span id="c52c" class="ms mt iq mo b gy mu mv l mw mx">cd api<br/>dotnet add package Google.Cloud.Firestore</span></pre><p id="31f0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将从创建代表城市的C#记录类开始。</p><figure class="lr ls lt lu gt jr"><div class="bz fp l di"><div class="ow ox l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">注意Google Firestore SDK要求我们提供一个无参数的构造函数:(当然你也可以使用一个普通的类。</figcaption></figure><p id="beeb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，我们可以使用dotnet 6的最小API样式添加我们唯一的路由:</p><figure class="lr ls lt lu gt jr"><div class="bz fp l di"><div class="ow ox l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在第8行，我们指定数据库连接构建器应该使用模拟器。</figcaption></figure><p id="8521" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您以前没有使用过dotnet，或者已经有几年没有使用过了。NET”，一定要看看dotnet 6。如果你想了解更多关于dotnet 6 minimal web APIs的信息，<a class="ae lb" href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis?view=aspnetcore-6.0" rel="noopener ugc nofollow" target="_blank">请访问文档</a>。</p><p id="5cbe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在要运行它，我们需要确保向运行时发出信号，表明我们正在使用仿真(参见上面的<strong class="ke ir">第8行</strong>):</p><pre class="lr ls lt lu gt mn mo mp mq aw mr bi"><span id="4fc7" class="ms mt iq mo b gy mu mv l mw mx"><strong class="mo ir">FIRESTORE_EMULATOR_HOST="localhost:8181"</strong> dotnet run</span></pre><p id="33cc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在Windows上，设置环境变量或使用启动配置文件。</p><p id="b93e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">随着模拟器的启动和API的运行，我们现在可以测试它了:</p><pre class="lr ls lt lu gt mn mo mp mq aw mr bi"><span id="bb47" class="ms mt iq mo b gy mu mv l mw mx">curl -v http://localhost:20080/city/add/CA/Los<strong class="mo ir">%20</strong>Angeles</span></pre><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oy"><img src="../Images/ca43b2844d69d297feeb63d05dcd11e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uEFMzU2C_-GaBrfbntI8zg.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在模拟器的管理界面中检查我们的第一条记录</figcaption></figure><h1 id="05e6" class="nf mt iq bd ng nh ol nj nk nl om nn no np on nr ns nt oo nv nw nx op nz oa ob bi translated">Vue + TypeScript中的前端</h1><p id="d3f0" class="pw-post-body-paragraph kc kd iq ke b kf oc kh ki kj od kl km kn oe kp kq kr of kt ku kv og kx ky kz ij bi translated">对于前端，我们将构建一个简单的Vue应用程序，我们在前面用Vite初始化了它(repo中还包含一个React应用程序)。</p><p id="572b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">替换<code class="fe oi oj ok mo b">App.vue</code>的内容:</p><figure class="lr ls lt lu gt jr"><div class="bz fp l di"><div class="ow ox l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">一个简单的，有两个输入和一个按钮的准系统UI</figcaption></figure><p id="e6a8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们可以输入一个城市名、一个州名，然后点击按钮来调用我们的API:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oz"><img src="../Images/a92ffdcd5b496ee6c3be27a023dd98ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*gjBHVevtyJM0VhH1fWftEg.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">通过调用我们的dotnet web API，通过我们的简单UI添加一条新记录。</figcaption></figure><p id="d09a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi">🎉</p><h1 id="60a9" class="nf mt iq bd ng nh ol nj nk nl om nn no np on nr ns nt oo nv nw nx op nz oa ob bi translated">添加身份验证</h1><p id="6a16" class="pw-post-body-paragraph kc kd iq ke b kf oc kh ki kj od kl km kn oe kp kq kr of kt ku kv og kx ky kz ij bi translated">Firebase支持各种身份验证来源，包括:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pa"><img src="../Images/b067340520a1e2deea2c1fb0870ac765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*06YTCSgKwvKF3EWr4tXirQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">支持的身份验证提供程序</figcaption></figure><p id="31f3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我使用过的SSO联合网关中，包括AWS Cognito和Azure AD B2C，Firebase的体验是迄今为止最流畅的。</p><p id="1f26" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，我们需要将Firebase包添加到我们的前端:</p><pre class="lr ls lt lu gt mn mo mp mq aw mr bi"><span id="8e17" class="ms mt iq mo b gy mu mv l mw mx">cd web-vue<br/>yarn add firebase</span></pre><p id="75a2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此时，我们必须用上游(云托管)运行时初始化应用程序。否则，我们会遇到以下错误:</p><pre class="lr ls lt lu gt mn mo mp mq aw mr bi"><span id="ecbf" class="ms mt iq mo b gy mu mv l mw mx">No Firebase App '[DEFAULT]' has been created - call Firebase App.initializeApp() (app/no-app).</span></pre><p id="be87" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">登录<a class="ae lb" href="https://console.firebase.google.com" rel="noopener ugc nofollow" target="_blank"> Firebase控制台UI </a>，点击<strong class="ke ir">项目设置</strong>(cog图标)注册一个应用，在底部找到<strong class="ke ir">你的应用</strong>部分。您可以将客户端应用程序命名为您想要的任何名称(现在这并不重要)，您将得到如下内容:</p><pre class="lr ls lt lu gt mn mo mp mq aw mr bi"><span id="c1e7" class="ms mt iq mo b gy mu mv l mw mx"># None of these values are secret; they end up compiled into the<br/># output package.<br/>const firebaseConfig = {<br/>  apiKey: "AIzaSyBa_VDckwNQ2OaooVRoSJY",<br/>  authDomain: "dn6-firebase-demo.firebaseapp.com",<br/>  projectId: "dn6-firebase-demo",  <br/>  storageBucket: "dn6-firebase-demo.appspot.com",<br/>  messagingSenderId: "87796597610",<br/>  appId: "1:87796597610:web:c8d363161b2ead61811b13"<br/>};</span></pre><p id="a905" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在更新app代码，添加一个按钮来触发我们的<code class="fe oi oj ok mo b">firebaseLogin</code>功能:</p><figure class="lr ls lt lu gt jr"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="b5ba" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">查看Google身份验证流程可爱模拟:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pb"><img src="../Images/de7ca5175ed3f9d331134e12e7f6ea37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jIxbIER1nwY2_bkQrewDKg.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">模拟器允许我们创建新的帐户或使用以前创建的帐户。</figcaption></figure><p id="8de2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此时，我们在前端有了一个JWT令牌，我们可以通过<code class="fe oi oj ok mo b">Authorization</code>头将它发送给我们的后端API:</p><figure class="lr ls lt lu gt jr"><div class="bz fp l di"><div class="ow ox l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在第9行，我们使用前面捕获的authToken。</figcaption></figure><h1 id="3fba" class="nf mt iq bd ng nh ol nj nk nl om nn no np on nr ns nt oo nv nw nx op nz oa ob bi translated">后端验证</h1><p id="f707" class="pw-post-body-paragraph kc kd iq ke b kf oc kh ki kj od kl km kn oe kp kq kr of kt ku kv og kx ky kz ij bi translated">当我们现在进行API调用时，它将包含<code class="fe oi oj ok mo b">Authorization</code>头，我们现在可以通过验证令牌在后端验证请求。</p><p id="5043" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先添加一个用于JWT处理的包:</p><pre class="lr ls lt lu gt mn mo mp mq aw mr bi"><span id="dbef" class="ms mt iq mo b gy mu mv l mw mx">cd api<br/>dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer</span></pre><p id="7112" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">接下来，我们在路由处理程序中添加了<code class="fe oi oj ok mo b">[Authorize]</code>属性:</p><figure class="lr ls lt lu gt jr"><div class="bz fp l di"><div class="ow ox l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">参见第2行，我们在其中添加了授权指令。</figcaption></figure><p id="aeec" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我们在添加了默认的身份验证和授权中间件之后现在进行API调用，调用将会失败，并出现一个<code class="fe oi oj ok mo b">401 Unauthorized</code>。</p><p id="d423" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下一步是配置中间件来处理管道中的JWT令牌验证。</p><figure class="lr ls lt lu gt jr"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="330b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请特别注意第<strong class="ke ir">行第12 </strong>行的语句，在这里我们在开发中将<code class="fe oi oj ok mo b">RequireSignedTokens</code>设置为<code class="fe oi oj ok mo b">false</code>，因为我们从仿真器获得的令牌没有经过签名。</p><p id="eb13" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的API调用又一次像预期的那样工作了！</p><h1 id="8b59" class="nf mt iq bd ng nh ol nj nk nl om nn no np on nr ns nt oo nv nw nx op nz oa ob bi translated">实时订阅</h1><p id="cc1e" class="pw-post-body-paragraph kc kd iq ke b kf oc kh ki kj od kl km kn oe kp kq kr of kt ku kv og kx ky kz ij bi translated">将Firebase与Firestore结合使用的一个好处是支持数据库外的实时订阅。用过AWS Amplify (AppSync + DynamoDB)和Firestore之后，我更喜欢Firestore而不是Amplify。</p><p id="37c2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于Amplify，实时更新是通过为订阅构建GraphQL查询来完成的，而对于Firestore，这是一个简单的基于路径的条件查询。我不是GraphQL冗长的超级粉丝，所以Firestore的简单方法是受欢迎的！</p><p id="efac" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">应该注意的是<a class="ae lb" href="https://github.com/aws-amplify/amplify-category-api/issues/389#issuecomment-1216720699" rel="noopener ugc nofollow" target="_blank"> AppSync在订阅的动态授权方面还有一些差距</a>，而<a class="ae lb" href="https://firebase.google.com/docs/firestore/security/rules-conditions" rel="noopener ugc nofollow" target="_blank"> Firestore的基于路径的策略</a>在我看来更容易推理和使用。(更不用说AppSync中更高级的场景需要使用Apache Velocity模板语言)。</p><p id="a225" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们看看我们的Firestore订阅活动:</p><figure class="lr ls lt lu gt jr"><div class="bz fp l di"><div class="ow ox l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我们App.vue的一个片段；我们将通过点击按钮开始订阅，因为我们需要先进行身份验证。</figcaption></figure><p id="36ce" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先为<code class="fe oi oj ok mo b">City</code>添加一个接口，我们将使用它来输入我们的后端数据。</p><p id="b597" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">(在<strong class="ke ir">第9行</strong>上)，我们再次将我们的客户端指向模拟器(在实际代码中，您会希望在这行代码周围添加一个条件)。</p><p id="8750" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，我们创建函数来开始订阅并更新模板:</p><figure class="lr ls lt lu gt jr"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="1551" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="la">轰</em> </strong>🤯：</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pc"><img src="../Images/1edb7816746860c1a2f1185028b17ee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*4dtuuEMGaj982BltBZMBtw.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Auth first获得一个令牌来进行订阅API调用。注意数据库和前端之间的实时交互。</figcaption></figure><p id="0f24" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请注意，一旦我们连接了订阅，它也会自动执行指定的查询并初始化我们的视图。</p><p id="6e6a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过对我们的dotnet 6 web API的API调用在前端添加一个新的城市会使它立即出现在数据库中，从而将更新推送到我们的前端。同样，在后端删除一个城市会立即反映在我们的UI中。</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/68cd411d5922679008779918be6a2eed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/1*fqkfvwNn4chLlLS70p_WXA.gif"/></div></figure></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="2fcb" class="nf mt iq bd ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob bi translated">包裹</h1><p id="2a3e" class="pw-post-body-paragraph kc kd iq ke b kf oc kh ki kj od kl km kn oe kp kq kr of kt ku kv og kx ky kz ij bi translated">网上有大量的旧文档和示例，但很少有真正的使用前端和后端API从端到端使用仿真器的示例。老实说，Google docs for Firebase在这方面也有所欠缺，尤其是在如何连接模拟器方面提供了非常糟糕和不完整的指导。</p><p id="b83c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">也就是说，与我使用AWS Amplify的体验相比，模拟器本身的完整性和易用性令人惊叹；我根本没有<strong class="ke ir"><em class="la"/></strong>期望<em class="la">认证</em>也能与仿真一起工作。非常聪明的模仿完整流程的方法，谷歌。</p><p id="f9b0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">同时，<a class="ae lb" href="https://github.com/Azure/azure-cosmos-db-emulator-docker/issues/17#issuecomment-1064292225" rel="noopener ugc nofollow" target="_blank">我仍然在等待一个可以在M1 </a> 🫤上运行的CosmosDB模拟器(给我一些爱，微软；我好想用CosmosDB！).</p><p id="5812" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">谷歌Firebase是门票吗？被Amplify烧过一次之后，我有点厌倦了不做更多的实验就一头扎进去。有一些关于操作<a class="ae lb" href="https://firebase.google.com/docs/firestore/manage-data/delete-data#node.js_2" rel="noopener ugc nofollow" target="_blank">的问题需要注意，比如批量删除</a>。</p><p id="1e3b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这方面，Supabase值得一看，因为它提供了一个免费的、经过验证的关系Postgres后端，但其中的一些文档似乎也不可靠，而且明显不够成熟。</p><p id="9507" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在Azure上，我需要使用SignalR hubs，它对前端websocket信令提供了更多的控制(与Socket.io相同的范例)，但很快就会变得昂贵，并且缺乏CosmosDB emulator for M1令人恼火。</p><p id="ca47" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个实验还有趣的是Vue实现比React实现干净多少(也许有人能告诉我哪里做错了！)</p><p id="7f71" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">TBD现在，但我非常喜欢看到这一点，我希望你会发现它有用！</p><p id="4c8c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="la">在Twitter上标记我</em></strong><a class="ae lb" href="https://twitter.com/chrlschn" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="la">@ chrlschn</em></strong></a></p></div></div>    
</body>
</html>