<html>
<head>
<title>JavaScript Closures, Memoization and Factories</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript闭包、记忆化和工厂</h1>
<blockquote>原文：<a href="https://itnext.io/why-you-need-to-understand-javascript-closures-53efa66ae11a?source=collection_archive---------1-----------------------#2018-06-28">https://itnext.io/why-you-need-to-understand-javascript-closures-53efa66ae11a?source=collection_archive---------1-----------------------#2018-06-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cd731d929bd594d412cbc27594a03d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ed-a1BvB7R2aHxCDZL68ew.jpeg"/></div></div></figure><blockquote class="jy"><p id="7f09" class="jz ka iq bd kb kc kd ke kf kg kh ki dk translated">闭包是函数和词法环境的组合，函数在词法环境中被声明<a class="ae kj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank"> </a>。</p></blockquote><figure class="kk kl km kn ko jr"><div class="bz fp l di"><div class="kp kq l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">我能想到的最简单的结尾</figcaption></figure><h1 id="4562" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">那里发生了什么？</h1><p id="4b5d" class="pw-post-body-paragraph lt lu iq lv b lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp ki ij bi translated">如果你像其他人一样，认为第12行将返回3，那么这篇文章可能会对你有一点帮助。发生的情况是，每次我们调用<code class="fe mq mr ms mt b">count()</code>时，我们都返回一个新的<code class="fe mq mr ms mt b">innerCount</code>函数副本，而每个<code class="fe mq mr ms mt b">innerCount</code>副本都依赖于它自身之外的数据，在它自己的作用域之外。</p><p id="d823" class="pw-post-body-paragraph lt lu iq lv b lw mu ly lz ma mv mc md me mw mg mh mi mx mk ml mm my mo mp ki ij bi translated">这个<em class="mz">环境</em>数据对于函数本身的执行是至关重要的。我们可以说，它依靠它来工作。如果，当我们运行<code class="fe mq mr ms mt b">innerCount</code>时，我们不能访问<code class="fe mq mr ms mt b">counter</code>，那么整个功能将被破坏！但是到了执行<code class="fe mq mr ms mt b">innerCount</code>的时候，<code class="fe mq mr ms mt b">counter</code>就不再是外界可以访问的了！</p><p id="3ce3" class="pw-post-body-paragraph lt lu iq lv b lw mu ly lz ma mv mc md me mw mg mh mi mx mk ml mm my mo mp ki ij bi translated">JavaScript来帮忙了，它包装、分组，或者，如果你想说对的话，围绕函数和它需要访问的所有数据创建一个闭包，它的<a class="ae kj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">词法环境</a>。</p><p id="8f7e" class="pw-post-body-paragraph lt lu iq lv b lw mu ly lz ma mv mc md me mw mg mh mi mx mk ml mm my mo mp ki ij bi translated">如果<code class="fe mq mr ms mt b">counter</code>是全局范围内的一个变量，那么所有的计数器将增加同一个变量，而不是一个闭包内的一个。将<code class="fe mq mr ms mt b">counter</code>提取到1号线以上，随意尝试</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="8c4e" class="kv kw iq bd kx ky nh la lb lc ni le lf lg nj li lj lk nk lm ln lo nl lq lr ls bi translated">创建一个函数工厂作为真实世界的例子</h1><p id="fb00" class="pw-post-body-paragraph lt lu iq lv b lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp ki ij bi translated">我们可以通过创建一个函数来利用闭包行为，该函数根据传递的参数返回一个具有不同执行逻辑的函数。我能想到的最简单的例子是一个将返回给定数字的<em class="mz"> n </em>的幂的工厂。结果将与调用<code class="fe mq mr ms mt b">Math.pow(subject, power)</code>相同</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="kp kq l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">最简单的功能工厂</figcaption></figure><p id="1168" class="pw-post-body-paragraph lt lu iq lv b lw mu ly lz ma mv mc md me mw mg mh mi mx mk ml mm my mo mp ki ij bi translated">这个代码片段所做的是创建一个动态函数<em class="mz"/>，本质上这个函数的算法不是在代码本身中显式定义的，而是在运行时使用传递给工厂的参数创建的。当然，对于前面的例子，你可能会认为它毫无用处，你是对的，但是你需要抓住的是这个功能的潜力。</p><p id="e87b" class="pw-post-body-paragraph lt lu iq lv b lw mu ly lz ma mv mc md me mw mg mh mi mx mk ml mm my mo mp ki ij bi translated">我们现在可以通过简单地调用<code class="fe mq mr ms mt b">var powerOf2 = powerOfNFactory(2)</code>来定义一个函数，该函数给出2的幂。内部<code class="fe mq mr ms mt b">generatedFunction</code> <strong class="lv ir">将保持对</strong> <code class="fe mq mr ms mt b"><strong class="lv ir">power</strong></code> <strong class="lv ir">变量</strong>的封闭，并将完全独立于对<code class="fe mq mr ms mt b">powerOfNFactory</code>的其他调用。这意味着我们可以<strong class="lv ir">扩展功能</strong>并做一些事情，例如跟踪我们的动态函数被调用的次数，添加<em class="mz">内存化</em>(缓存结果以防止用相同的参数调用时重复执行)等等。</p><h2 id="1bf4" class="nq kw iq bd kx nr ns dn lb nt nu dp lf me nv nw lj mi nx ny ln mm nz oa lr ob bi translated">添加计数器</h2><p id="9c78" class="pw-post-body-paragraph lt lu iq lv b lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp ki ij bi translated">就像我们的动态函数可以访问传递给工厂函数的参数一样，它也可以访问内部定义的任何东西，就像第一个例子中的计数器一样，允许我们定义一个简单的计数器，这样就可以跟踪我们调用它的次数。也许您希望这样做是为了记录日志，也许您希望在做其他事情之前限制某个功能的执行次数，这取决于您。</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="kp kq l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">我们为动态函数保留了一个内部计数器</figcaption></figure><h2 id="defc" class="nq kw iq bd kx nr ns dn lb nt nu dp lf me nv nw lj mi nx ny ln mm nz oa lr ob bi translated">记忆化</h2><p id="b8fd" class="pw-post-body-paragraph lt lu iq lv b lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp ki ij bi translated">由于在我们的函数中执行的代码在时间上并不昂贵，我们不应该担心缓存它的执行，但在这里更容易显示它，这将是一个更广泛的例子，对我来说如此赤裸。这对于用相同的参数调用时总是返回相同的值，但在执行时间方面占用更多资源的操作非常有用</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="kp kq l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">我们保留一个内部对象作为字典缓存</figcaption></figure><p id="72fd" class="pw-post-body-paragraph lt lu iq lv b lw mu ly lz ma mv mc md me mw mg mh mi mx mk ml mm my mo mp ki ij bi translated">注意，我们在动态函数定义之外定义了一个<code class="fe mq mr ms mt b">cache</code>变量，就像我们对<code class="fe mq mr ms mt b">counter</code>所做的一样。当调用动态函数并存储值时，我们将使用作为参数接收的键填充该对象，以便跳过执行<code class="fe mq mr ms mt b">Math.pow(subject, power)</code>。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="ed65" class="kv kw iq bd kx ky nh la lb lc ni le lf lg nj li lj lk nk lm ln lo nl lq lr ls bi translated">摘要</h1><p id="6618" class="pw-post-body-paragraph lt lu iq lv b lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp ki ij bi translated">我确信，到现在为止，或者至少我希望如此，您已经对闭包有了更好的理解，以及它们有什么用处。这是我们不应该害怕的事情，一旦你理解了它们，以及它们为什么以这种方式工作，你就可以开始利用它们带来的全部潜力。</p></div></div>    
</body>
</html>