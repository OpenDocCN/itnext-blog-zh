<html>
<head>
<title>Lightweight MVI architecture on iOS with UIKit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有UIKit的iOS上的轻量级MVI架构</h1>
<blockquote>原文：<a href="https://itnext.io/lightweight-mvi-architecture-on-ios-with-uikit-ef75e4797eeb?source=collection_archive---------1-----------------------#2022-06-25">https://itnext.io/lightweight-mvi-architecture-on-ios-with-uikit-ef75e4797eeb?source=collection_archive---------1-----------------------#2022-06-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/cdac85d92957a6e220ae3bcf219d99d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*5c3Z3gyqqm4235rbh_F1EA.jpeg"/></div></figure><h1 id="469f" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">语境</h1><p id="7caf" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在我做iOS工程师的整个过程中，我几乎处理过所有类型的架构模式，从<strong class="ku ir"> <em class="lq">香草MVC到所有MV&lt;&gt;中间</em> </strong>的VIPER。随着时间的推移，我们大多数人意识到，在选择这样的模式时，没有正确或错误的答案，只是随着时间的推移使它适应项目和团队的需要。</p><p id="22f9" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">也就是说，在与React Native一起工作了一段时间，并对Flutter和SwiftUI进行了修改后，前端行业作为一个整体正在向这些可以说是更“现代”的概念发展，即<strong class="ku ir">单向数据流</strong>和<strong class="ku ir">声明式</strong> UI。</p><p id="2db1" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">尽管UIKit很快就要寿终正寝了，我还是想尝试最后一种模式，看看我们是否可以在一个真正的产品应用程序中加入这些概念的一些外观。这就是我如何发现MVI模式的。这里已经有一篇关于它的很棒的文章<a class="ae lw" href="https://broken-bytes.medium.com/using-the-mvi-pattern-in-swift-ios-app-development-72d7881d0dc2" rel="noopener"/>，从中我受到了很大的启发。然而，我想试着简化一下。因此，这是我自己在iOS上使用UIKit 的<em class="lq"> MVI模式。</em></p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/b500be0cfd824acc058b858e62074722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*Uf8UINWTgkh2nde3uFz5EQ.jpeg"/></div></figure><h2 id="db09" class="mc jv iq bd jw md me dn ka mf mg dp ke ld mh mi ki lh mj mk km ll ml mm kq mn bi translated">考虑</h2><ul class=""><li id="6f1e" class="mo mp iq ku b kv kw kz la ld mq lh mr ll ms lp mt mu mv mw bi translated">必须使用UIKit(因为我们仍然针对iOS 11用户<a class="ae lw" href="https://emojipedia.org/smiling-face-with-tear/" rel="noopener ugc nofollow" target="_blank"> 🥲 </a></li><li id="02ae" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">适合中型团队(类似于MVVM用例)</li><li id="e581" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">最少样板文件(如VIPER或RIB)</li><li id="cbe9" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">易于升级(要求对RxSwift或反应性概念有最低限度的了解)</li><li id="00bc" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">单向数据流和(几乎)基于状态的声明式UI</li><li id="b0af" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">可扩展性(它应该能够适应不断增长的团队和产品需求)</li></ul><h1 id="c31c" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">什么是MVI？</h1><p id="df8f" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">MVI是模型视图意图。虽然它被称为MVI，但更恰当的名称应该是状态视图意图。它与其他常见模式的关键区别之一是它非常严格地使用单向数据流。</p><ul class=""><li id="1556" class="mo mp iq ku b kv lr kz ls ld nc lh nd ll ne lp mt mu mv mw bi translated">状态(型号)</li><li id="71b6" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">视角</li><li id="f478" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">目的</li></ul><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nf"><img src="../Images/c12f5027e7860bd784d392309ac786ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qgowmyrucsnPbnn2B6r3_Q.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">MVI图</figcaption></figure><h2 id="2677" class="mc jv iq bd jw md me dn ka mf mg dp ke ld mh mi ki lh mj mk km ll ml mm kq mn bi translated">状态</h2><ul class=""><li id="cc60" class="mo mp iq ku b kv kw kz la ld mq lh mr ll ms lp mt mu mv mw bi translated">虽然类似，但不应该与传统MV <x>架构中的模型相混淆</x></li><li id="a507" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">它是一个<strong class="ku ir">不可变的</strong>数据结构，表示应用程序这一部分在任何时刻的状态，就像快照一样</li><li id="0466" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">包含业务逻辑的结果(即来自服务请求的响应)以及表示UI的状态(加载、文本字段值等)</li></ul><h2 id="a611" class="mc jv iq bd jw md me dn ka mf mg dp ke ld mh mi ki lh mj mk km ll ml mm kq mn bi translated">视角</h2><ul class=""><li id="7ac5" class="mo mp iq ku b kv kw kz la ld mq lh mr ll ms lp mt mu mv mw bi translated">从概念上讲，它与其他常见的MV <x>架构相同</x></li><li id="d99e" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">它可能是UIView或UIViewController</li><li id="9f49" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">与MV <x>的一个很大的区别是，它有一个单独暴露的<em class="lq">update(with State:State)</em>函数。这是一个纯函数，它接收新状态和以前的状态作为输入。</x></li><li id="1c13" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">给定相同的输入，视图的输出应该总是相同的。因此，视图可以被认为是状态函数的产物<strong class="ku ir"> f(状态)=视图</strong></li></ul><h2 id="096e" class="mc jv iq bd jw md me dn ka mf mg dp ke ld mh mi ki lh mj mk km ll ml mm kq mn bi translated">目的</h2><ul class=""><li id="f728" class="mo mp iq ku b kv kw kz la ld mq lh mr ll ms lp mt mu mv mw bi translated">从概念上讲，它类似于MVVM的视图模型或RIB/Viper的交互器</li><li id="bc46" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">它可以访问所有需要的服务和其他依赖项</li><li id="0432" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">它处理视图中的所有用户交互</li><li id="8f20" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">它处理所有业务逻辑</li><li id="4d56" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">它处理所有的状态变化</li><li id="105a" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">与MVVM/RIB/Viper的一个很大的区别是，新的状态是通过一个单独的状态流发送给视图的</li><li id="9593" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">因此，数据流是单向的<strong class="ku ir"/></li></ul><h1 id="5217" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">例子</h1><p id="4add" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">让我们考虑一个简单的例子，一个有两个输入和一个保存按钮的表单屏幕，在这个例子中输入一个地址。</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/53a32929fdaf6149989e0fc587c70c8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*JtY8cPTFbrHYwOihJQUmKw.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">示例屏幕</figcaption></figure><h2 id="d2bb" class="mc jv iq bd jw md me dn ka mf mg dp ke ld mh mi ki lh mj mk km ll ml mm kq mn bi translated">状态</h2><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">陈述例子</figcaption></figure><p id="7f61" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated"><em class="lq"> AddressState </em>是一个具有3个属性的简单结构。它符合<em class="lq">状态</em>协议，该协议要求静态<em class="lq">初始状态</em>，这将在以后发挥作用。它还有一个特殊的<em class="lq"> init </em>来从先前的状态生成一个新状态，并带有所需的修改值。</p><h2 id="83bb" class="mc jv iq bd jw md me dn ka mf mg dp ke ld mh mi ki lh mj mk km ll ml mm kq mn bi translated">视角</h2><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="6b94" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">在这种情况下，我们的<em class="lq">视图</em>是一个简单的<em class="lq"> UIViewController </em>。它符合<em class="lq">视图</em>，因此具有<em class="lq">更新(带状态)</em>功能。该函数负责根据所有状态值更新UI。</p><p id="171a" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">请注意我们是如何将状态与之前的状态进行比较的，并在更新UI之前确保它们是不同的。在这种情况下，这似乎微不足道，但你可以想象更复杂的情况，我们希望避免任何不必要的UI更新。视图还负责接收用户输入并将它们发送给Intent，在这种情况下，更新输入字段并点击save按钮。</p><p id="28d4" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">请注意<em class="lq">视图</em>实际上没有任何反应代码，比如订阅<em class="lq"> Observables。它只是接收状态(从哪里接收并不重要)并更新UI。</em></p><h2 id="99f0" class="mc jv iq bd jw md me dn ka mf mg dp ke ld mh mi ki lh mj mk km ll ml mm kq mn bi translated">目的</h2><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a413" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated"><em class="lq"> AddressIntent </em>与您期望的<em class="lq">视图模型</em>或<em class="lq">交互器</em>没有太大的不同。它处理一些输入并发出状态变化。注意，除了绑定<em class="lq">状态驱动</em>之外，还有最小的反应代码。这就是主要魔力的来源。你可以认为它与<em class="lq"> React </em>中的<em class="lq"> setState() </em>非常相似。</p><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="8528" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">我们可以看到<em class="lq"> stateDriver </em>只是一个包装好的<em class="lq"> BehaviorRelay </em>，它将通过总是发出新状态和先前状态来驱动它所绑定的视图。注意，我们在这里使用了<em class="lq"> RxSwift </em>来实现<em class="lq"> StateDriver </em>，但它也可以很容易地用<em class="lq"> Combine </em>或任何其他反应式概念来实现。</p><p id="cd6b" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">仅此而已。我们现在有了一个充分发挥作用的MVI。对于一个只有3个输入的简单形式的屏幕来说，代码是不是太多了？也许吧。然而，对于具有许多状态的复杂用例，我发现它实际上大大简化了代码量。</p><h1 id="2d12" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">航行</h1><p id="e1d9" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">可能马上想到的一个问题是如何处理导航。像大多数其他MVx模式一样，MVI没有规定一个关于导航的特定模式。在我们的特定项目中，我们简单地决定采用<em class="lq">协调者</em>模式。所以技术上我们可以称之为<strong class="ku ir"> MVI+C </strong></p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nr"><img src="../Images/df51d81b4c20c9c21c8336b16e2a04d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_7uiCwxEyeLnqPCbmHIJog.png"/></div></div></figure><h1 id="bc59" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">增量采用</h1><p id="258e" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">你也可以想象，如果你正在处理一个使用<em class="lq"> MVVM+C </em>之类的现有项目，那么这个架构可以被逐步采用，因为只有<em class="lq">协调器</em>内的内容可以从<em class="lq"> MVVM </em>更改为<em class="lq"> MVI </em>。类似地，如果您正在处理一个VIPER代码库，那么<em class="lq">交互器+实体</em>可以替换为<em class="lq">意图+状态</em>。</p><h1 id="d1ad" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">展开性</h1><p id="214b" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">反过来，随着代码库的增长，人们可以看到这种模式可能开始出现裂缝。然而，它可以根据需要发展。如上所述，我们可以采用<em class="lq">协调器</em>或<em class="lq">路由器</em>模式来处理导航。我们可以引入一个<em class="lq">构建器</em>模式来处理依赖注入。如果我们发现这样做的目的是为了将业务数据转换成视图数据，我们可以考虑引入一个<em class="lq"> Presenter </em>模式。</p><h1 id="f60e" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">测试</h1><p id="7077" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这种模式特别适合快照测试。每个<em class="lq">视图</em>可以用<em class="lq">状态</em>对象的所有组合进行测试，以生成该视图的所有可能状态。</p><h1 id="18ea" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">逮到你了</h1><p id="2ca6" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">UIKit的命令性质有时确实违背了这种模式。</p><ul class=""><li id="3405" class="mo mp iq ku b kv lr kz ls ld nc lh nd ll ne lp mt mu mv mw bi translated"><strong class="ku ir">table view/collection view</strong>:UICollectionView/UITableView API(委托)的异步设计使得在没有“临时”保持状态的情况下很难进行更新。</li><li id="6854" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated"><strong class="ku ir">文本输入:</strong>文本值应该由输入状态设置，而不是由用户直接输入。这需要对<em class="lq"> UITextField </em>或<em class="lq"> UITextView </em>委托的工作方式进行一些操作。</li><li id="4bbd" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated"><strong class="ku ir">高效更新</strong>:通过与之前的状态不同，避免不必要的UI更新</li></ul><h1 id="416d" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="6228" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">总的来说，我对结果很满意。我们在中型/大型应用程序中使用了这种模式，它为我们提供了很好的服务。它确实满足了我们前面提到的所有考虑因素。这也让UI编码变得更加有趣。这确实需要一点心态上的转变，尤其是对于那些习惯于命令式方式，并且从未处理过声明式UI(比如React/Flutter/swift UI/Compose/等)的人来说。然而，一旦它“咔嚓”一声，就一帆风顺了。<a class="ae lw" href="https://emojipedia.org/smiling-face-with-sunglasses/" rel="noopener ugc nofollow" target="_blank">😎</a></p></div></div>    
</body>
</html>