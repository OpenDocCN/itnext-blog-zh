<html>
<head>
<title>Native-image with Quarkus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带夸库的原生图像</h1>
<blockquote>原文：<a href="https://itnext.io/native-image-with-quarkus-aa3cbee997f8?source=collection_archive---------6-----------------------#2021-12-12">https://itnext.io/native-image-with-quarkus-aa3cbee997f8?source=collection_archive---------6-----------------------#2021-12-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/3a259a823073094ac7419930981038a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*yQQM1_sK2Io5nlPa4vYYBQ.png"/></div></figure><p id="7beb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">到目前为止，我们已经了解了<a class="ae ks" href="https://blog.frankel.ch/native/spring-boot/" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>和<a class="ae ks" href="https://blog.frankel.ch/native/micronaut/" rel="noopener ugc nofollow" target="_blank"> Micronaut </a>集成GraalVM本地映像扩展的情况。在这篇文章中，我将重点关注<a class="ae ks" href="https://quarkus.io/" rel="noopener ugc nofollow" target="_blank">夸库</a>:</p><blockquote class="kt ku kv"><p id="73cb" class="ju jv kw jw b jx jy jz ka kb kc kd ke kx kg kh ki ky kk kl km kz ko kp kq kr ij bi translated"><em class="iq">为OpenJDK HotSpot和GraalVM量身定制的Kubernetes原生Java堆栈，采用了同类最佳的Java库和标准。</em></p></blockquote><h1 id="c37d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">创建新项目</h1><p id="0e9e" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">正如Spring Boot和Micronaut一样，Quarkus提供了创建新项目的选项:</p><ol class=""><li id="b36e" class="md me iq jw b jx jy kb kc kf mf kj mg kn mh kr mi mj mk ml bi translated">专用的<code class="fe mm mn mo mp b">quarkus</code> <a class="ae ks" href="https://quarkus.io/guides/cli-tooling" rel="noopener ugc nofollow" target="_blank"> CLI </a></li><li id="81cb" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr mi mj mk ml bi translated">一个<a class="ae ks" href="https://code.quarkus.io/" rel="noopener ugc nofollow" target="_blank">网络用户界面</a></li></ol><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi mv"><img src="../Images/e17e9d449c2b73819b20f3a1364ba634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jJDx0D7KqzeVAtmN.jpg"/></div></div></figure><p id="8cdb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Quarkus相对于其竞争对手有明显的改进。每个依赖项都有一个详细的上下文菜单，允许:</p><ul class=""><li id="edb3" class="md me iq jw b jx jy kb kc kf mf kj mg kn mh kr ne mj mk ml bi translated">通过<code class="fe mm mn mo mp b">quarkus</code>复制添加依赖关系的命令</li><li id="a73d" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr ne mj mk ml bi translated">通过Maven复制添加依赖项的命令</li><li id="f966" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr ne mj mk ml bi translated">复制Maven POM依赖项片段</li><li id="fac3" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr ne mj mk ml bi translated">复制Maven BOM依赖关系片段</li><li id="1f18" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr ne mj mk ml bi translated">复制Maven BOM依赖关系片段</li><li id="8fae" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr ne mj mk ml bi translated">打开相关依赖项的指南</li></ul><p id="5aea" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请注意，如果您选择Gradle作为构建工具，菜单会显示与Gradle相关的命令。</p><p id="0774" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">3.一个Maven插件:我喜欢除了自己选择的构建工具之外，不需要任何外部依赖。</p><h1 id="0828" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Bean配置</h1><p id="dca5" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">夸库斯依靠<a class="ae ks" href="http://javax-inject.github.io/javax-inject/" rel="noopener ugc nofollow" target="_blank"> JSR 330 </a>。然而，它偏离了规范:它列出了<a class="ae ks" href="https://quarkus.io/guides/cdi-reference#limitations" rel="noopener ugc nofollow" target="_blank">限制</a>和<a class="ae ks" href="https://quarkus.io/guides/cdi-reference#nonstandard_features" rel="noopener ugc nofollow" target="_blank">非标准特征</a>。</p><p id="33f5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">例如，使用Quarkus，如果生产者方法已经用范围注释之一<em class="kw">进行了注释，例如</em>、<code class="fe mm mn mo mp b">@Singleton</code>，那么您可以跳过生产者方法上的<code class="fe mm mn mo mp b">@Produces</code>注释。下面是创建消息摘要的代码:</p><pre class="mw mx my mz gt nf mp ng nh aw ni bi"><span id="578a" class="nj lb iq mp b gy nk nl l nm nn">class MarvelFactory {</span><span id="aa1f" class="nj lb iq mp b gy no nl l nm nn">    @Singleton<br/>    fun digest(): MessageDigest = MessageDigest.getInstance("MD5")<br/>}</span></pre><h1 id="30e6" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">控制器配置</h1><p id="ae9a" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">很多夸库依赖于雅加达EE规范。因此，创建控制器最直接的途径就是JAX-RS。我们可以用下面的代码创建一个“控制器”:</p><pre class="mw mx my mz gt nf mp ng nh aw ni bi"><span id="9561" class="nj lb iq mp b gy nk nl l nm nn">@Path("/")<br/>class MarvelController {</span><span id="90fc" class="nj lb iq mp b gy no nl l nm nn">    @GET<br/>    fun characters() = Response.accepted()<br/>}</span></pre><p id="b8b1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因为Quarkus的开发者也在<a class="ae ks" href="https://vertx.io/" rel="noopener ugc nofollow" target="_blank"> Vert.x </a>上工作，所以前者也提供了集成后者的插件。Vert.x是全<em class="kw">反应式</em>并提供<em class="kw">路线</em>的概念。使用Quarkus，您可以注释方法，将它们标记为路径。可以将上述代码迁移到routes:</p><pre class="mw mx my mz gt nf mp ng nh aw ni bi"><span id="bb46" class="nj lb iq mp b gy nk nl l nm nn">@Singleton<br/>class MarvelController {</span><span id="2fbd" class="nj lb iq mp b gy no nl l nm nn">     @Routes<br/>     fun characters() = Response.accepted()<br/>}</span></pre><p id="591b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">可替换地，人们可以更喜欢编程路由注册:</p><pre class="mw mx my mz gt nf mp ng nh aw ni bi"><span id="443c" class="nj lb iq mp b gy nk nl l nm nn">@Singleton<br/>class MarvelRoutes {</span><span id="95d9" class="nj lb iq mp b gy no nl l nm nn">    fun get(@Observes router: Router) {       // 1<br/>        router.get("/").handler {<br/>            it.response()<br/>                .setStatusCode(200)<br/>                .send()                       // 2<br/>        }<br/>    }<br/>}</span></pre><ol class=""><li id="b851" class="md me iq jw b jx jy kb kc kf mf kj mg kn mh kr mi mj mk ml bi translated">观察<code class="fe mm mn mo mp b">Router</code>“事件”:启动时触发一次。</li><li id="bb5b" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr mi mj mk ml bi translated">发送空响应；返回一个<code class="fe mm mn mo mp b">Future&lt;Void&gt;</code></li></ol><p id="fbc9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请注意，在这种特殊情况下，编程方式需要与注释方式一样多的注释。但是，前者需要两个注释，而后者需要每个路线一个加一个。</p><h1 id="4d6b" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">非阻塞HTTP客户端</h1><p id="53ca" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">Micronaut通过插件集成了许多HTTP客户端风格。在这个项目中，我选择了使用<a class="ae ks" href="https://smallrye.io/smallrye-mutiny/" rel="noopener ugc nofollow" target="_blank">兵变</a>。</p><blockquote class="kt ku kv"><p id="06bf" class="ju jv kw jw b jx jy jz ka kb kc kd ke kx kg kh ki ky kk kl km kz ko kp kq kr ij bi translated"><em class="iq">还有其他的反应式编程库。在Java世界里，我们可以提到Project Reactor和Rx Java。</em></p><p id="7c18" class="ju jv kw jw b jx jy jz ka kb kc kd ke kx kg kh ki ky kk kl km kz ko kp kq kr ij bi translated"><em class="iq">那么，《兵变》和这两个知名的库有什么不同呢？API！</em></p><p id="1bda" class="ju jv kw jw b jx jy jz ka kb kc kd ke kx kg kh ki ky kk kl km kz ko kp kq kr ij bi translated">如上所述，对于大多数开发人员来说，异步是很难掌握的，这是有充分理由的。因此，API不能要求高深的知识或增加认知负荷。它应该可以帮助你设计你的逻辑，并且在6个月内仍然可以理解。</p><p id="699a" class="ju jv kw jw b jx jy jz ka kb kc kd ke kx kg kh ki ky kk kl km kz ko kp kq kr ij bi translated"><em class="iq">—</em><a class="ae ks" href="https://smallrye.io/smallrye-mutiny/pages/philosophy#what-makes-mutiny-different" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://small rye . io/small rye-mutate/pages/philosophy # what-makes-mutate-different</em></a></p></blockquote><p id="65c8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以下是兵变API的一个子集:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi np"><img src="../Images/110af3656f632b0395e48bc0988242e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*61M1-3x-OISz_Un5aBbhQA.png"/></div></div></figure><p id="ab8a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">起初，我不喜欢叛变。我的意思是，我们已经有足够多的反应式客户:Project Reactor、RxJava2等。</p><p id="3918" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，我意识到了它的做法的独特性。反应式编程是相当棘手的，因为所有可用的选项。但哗变是围绕一个流畅的API设计的，它利用类型系统在编译时缩小兼容选项的范围。它温和地帮助你写出你想要的结果，即使只是简单的API知识。</p><p id="02d0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我现在被说服给它一个机会。<br/>让我们用哗变来提出一个请求:</p><pre class="mw mx my mz gt nf mp ng nh aw ni bi"><span id="58a6" class="nj lb iq mp b gy nk nl l nm nn">val client = WebClient.create(vertx)                      // 1<br/>client.getAbs("https://gateway.marvel.com:443/v1/public/characters")  // 2<br/>      .send()                                             // 3<br/>      .onItem()                                           // 4<br/>      .transform { it.bodyAsString() }                    // 5<br/>      .await()                                            // 6<br/>      .indefinitely()                                      // 7</span></pre><ol class=""><li id="0f66" class="md me iq jw b jx jy kb kc kf mf kj mg kn mh kr mi mj mk ml bi translated">通过包装一个<code class="fe mm mn mo mp b">Vertx</code>实例来创建客户端。夸库斯提供了一个，可以给你注射</li><li id="2461" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr mi mj mk ml bi translated">创建一个<code class="fe mm mn mo mp b">GET</code> HTTP请求的新实例</li><li id="97cb" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr mi mj mk ml bi translated">异步发送请求<em class="kw"/>。目前还没有发生任何事情。</li><li id="19b2" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr mi mj mk ml bi translated">当它收到响应时…</li><li id="fa97" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr mi mj mk ml bi translated">…把它的身体变成一个<code class="fe mm mn mo mp b">String</code></li><li id="a21a" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr mi mj mk ml bi translated">等等…</li><li id="f904" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr mi mj mk ml bi translated">…永远，直到它得到响应。</li></ol><p id="1061" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">利用路由上下文，从到来的请求中获取参数并转发它们是很简单的:</p><pre class="mw mx my mz gt nf mp ng nh aw ni bi"><span id="594a" class="nj lb iq mp b gy nk nl l nm nn">router.get("/").handler { rc -&gt;<br/>    client.getAbs("https://gateway.marvel.com:443/v1/public/characters")<br/>        .queryParamsWith(rc.request())<br/>        .send()<br/>        .onItem()<br/>        .transform { it.bodyAsString()) }<br/>        .await()<br/>        .indefinitely()</span><span id="f208" class="nj lb iq mp b gy no nl l nm nn">fun HttpRequest&lt;Buffer&gt;.queryParamsWith(req: HttpServerRequest) =<br/>    apply {<br/>        arrayOf("limit", "offset", "orderBy").forEach { param -&gt;<br/>            req.getParam(param)?.let {<br/>                addQueryParam(param, it)<br/>            }<br/>        }<br/>    }</span></pre><h1 id="8cc5" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">参数化</h1><p id="7369" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">像Spring Boot和Micronaut一样，Quarkus允许以多种方式参数化应用程序:</p><ul class=""><li id="73f9" class="md me iq jw b jx jy kb kc kf mf kj mg kn mh kr ne mj mk ml bi translated">系统属性</li><li id="64ef" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr ne mj mk ml bi translated">环境变量</li><li id="3bb1" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr ne mj mk ml bi translated"><code class="fe mm mn mo mp b">.env</code>文件在当前工作目录下</li><li id="a167" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr ne mj mk ml bi translated"><code class="fe mm mn mo mp b">$PWD/config/application.properties</code>中的配置文件</li><li id="2ebe" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr ne mj mk ml bi translated">类路径中的配置文件<code class="fe mm mn mo mp b">application.properties</code></li><li id="833a" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr ne mj mk ml bi translated">类路径中的配置文件<code class="fe mm mn mo mp b">META-INF/microprofile-config.properties</code></li></ul><p id="2fe8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">注意，不可能使用命令行参数进行参数化。</p><p id="20d2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">与它的兄弟不同，web客户端要求您将URL分成三个部分，主机、端口和是否使用SSL。</p><pre class="mw mx my mz gt nf mp ng nh aw ni bi"><span id="648a" class="nj lb iq mp b gy nk nl l nm nn">app.marvel.server.ssl=true<br/>app.marvel.server.host=gateway.marvel.com<br/>app.marvel.server.port=443</span></pre><p id="bc5b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，我们需要在配置类方面有点创意:</p><pre class="mw mx my mz gt nf mp ng nh aw ni bi"><span id="9e70" class="nj lb iq mp b gy nk nl l nm nn">@Singleton                                            // 1<br/>data class ServerProperties(<br/>    @ConfigProperty(name = "app.marvel.server.ssl")<br/>    val ssl: Boolean,                                 // 2<br/>    @ConfigProperty(name = "app.marvel.server.host")<br/>    val host: String,                                 // 2<br/>    @ConfigProperty(name = "app.marvel.server.port")<br/>    val port: Int                                     // 2<br/>)</span><span id="6345" class="nj lb iq mp b gy no nl l nm nn">@Singleton                                            // 1<br/>data class MarvelProperties(<br/>    val server: ServerProperties,                     // 3<br/>    @ConfigProperty(name = "app.marvel.apiKey")<br/>    val apiKey: String,                               // 2<br/>    @ConfigProperty(name = "app.marvel.privateKey")<br/>    val privateKey: String                            // 2<br/>)</span></pre><ol class=""><li id="83b1" class="md me iq jw b jx jy kb kc kf mf kj mg kn mh kr mi mj mk ml bi translated">配置类是常规的CDI beans。</li><li id="eae1" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr mi mj mk ml bi translated">Quarkus使用微配置文件配置规范。<code class="fe mm mn mo mp b">@ConfigProperty</code>设置要读取的属性键。在所有键上重复相同的前缀是不方便的。因此，Microprofile提供了<code class="fe mm mn mo mp b">@ConfigProperties</code>来设置类的前缀。然而，这样一个类需要一个零参数的构造函数，这对Kotlin的数据类不起作用。</li><li id="f053" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr mi mj mk ml bi translated">注入另一个配置类，并从嵌套结构中获益</li></ol><h1 id="60c5" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">测试</h1><p id="21c9" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">像它的兄弟一样，Quarkus为测试提供了专用的注释，<code class="fe mm mn mo mp b">@QuarkusTest</code>。它还提供了<code class="fe mm mn mo mp b">@NativeImageTest</code>，允许在本地映像环境中运行测试。想法是在用前者注释的类中定义JVM测试，并创建用后者注释的子类。这样，测试将在JVM上下文和本机上下文中运行。请注意，我不确定它在我的设置中是否有效。</p><p id="b23d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是依我看，Quarkus在测试环境中的附加价值在于它如何定义一个可重用的资源抽象。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nq"><img src="../Images/9902162806fa8b59ad0ec931aa454ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NJf6iLiE6aVYhI7SkVu5iw.png"/></div></div></figure><p id="c826" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">只有一个接口和一个注释，就可以定义一个资源，<em class="kw">，例如</em>，一个模拟服务器，在测试之前启动它，在测试之后停止它。让我们这样做:</p><pre class="mw mx my mz gt nf mp ng nh aw ni bi"><span id="7fc6" class="nj lb iq mp b gy nk nl l nm nn">class MockServerResource : QuarkusTestResourceLifecycleManager {</span><span id="b2e9" class="nj lb iq mp b gy no nl l nm nn">    private val mockServer = MockServerContainer(<br/>        DockerImageName.parse("mockserver/mockserver")<br/>    )</span><span id="e3c0" class="nj lb iq mp b gy no nl l nm nn">    override fun start(): Map&lt;String, String&gt; {<br/>        mockServer.start()<br/>        val mockServerClient = MockServerClient(<br/>            mockServer.containerIpAddress,<br/>            mockServer.serverPort<br/>        )<br/>        val sample =<br/>            this::class.java.classLoader.getResource("sample.json")<br/>                                       ?.readText()<br/>        mockServerClient.`when`(<br/>            HttpRequest.request()<br/>                .withMethod("GET")<br/>                .withPath("/v1/public/characters")<br/>        ).respond(<br/>            HttpResponse()<br/>                .withStatusCode(200)<br/>                .withHeader("Content-Type", "application/json")<br/>                .withBody(sample)<br/>        )<br/>        return mapOf(<br/>            "app.marvel.server.ssl" to "false",<br/>            "app.marvel.server.host" to<br/>                mockServer.containerIpAddress,<br/>            "app.marvel.server.port" to<br/>                mockServer.serverPort.toString()<br/>        )<br/>    }</span><span id="900c" class="nj lb iq mp b gy no nl l nm nn">    override fun stop() = mockServer.stop()<br/>}</span></pre><p id="cb4e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，我们可以在测试中使用这个服务器:</p><pre class="mw mx my mz gt nf mp ng nh aw ni bi"><span id="2e2e" class="nj lb iq mp b gy nk nl l nm nn">@QuarkusTest<br/>@QuarkusTestResource(MockServerResource::class)<br/>class QuarkusApplicationTest {</span><span id="c264" class="nj lb iq mp b gy no nl l nm nn">    @Test<br/>    fun `should deserialize JSON payload from server and serialize it back again`() {<br/>        val model = given()                                 // 1<br/>            .`when`()<br/>            .get("/")<br/>            .then()<br/>            .statusCode(200)<br/>            .contentType(ContentType.JSON)<br/>            .and()<br/>            .extract()<br/>            .`as`(Model::class.java)<br/>        assertNotNull(model)<br/>        assertNotNull(model.data)<br/>        assertEquals(1, model.data.count)<br/>        assertEquals("Anita Blake", model.data.results.first().name)<br/>    }<br/>}</span></pre><ol class=""><li id="1bbb" class="md me iq jw b jx jy kb kc kf mf kj mg kn mh kr mi mj mk ml bi translated">Quarkus集成了RestAssured API。它使用了Kotlin的一些关键字，所以我们需要用反勾号对它们进行转义。</li></ol><p id="6dea" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我喜欢它将测试从依赖中分离出来的方式。</p><h1 id="34ec" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Docker和GraalVM集成</h1><p id="8289" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">当一个人搭建一个新项目时，Quarkus会创建不同的现成可用的<code class="fe mm mn mo mp b">Dockerfile</code>:</p><ul class=""><li id="c820" class="md me iq jw b jx jy kb kc kf mf kj mg kn mh kr ne mj mk ml bi translated">一个古老的罐子</li><li id="770f" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr ne mj mk ml bi translated">分层JAR方法:首先将依赖项添加到映像中，这样如果其中任何一个发生变化，构建就可以重用它们的层</li><li id="683c" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr ne mj mk ml bi translated">本土形象</li><li id="eb7d" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr ne mj mk ml bi translated">具有<em class="kw">发行版</em>父级的本机映像</li></ul><p id="a1f7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好的一面是，用户可以根据自己的需要配置这些模板中的任何一个。缺点是它需要本地Docker安装。此外，模板只是模板，您可以完全更改它们。</p><p id="2b28" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你不喜欢这种方法，Quarkus提供了一个带有<a class="ae ks" href="https://github.com/GoogleContainerTools/jib" rel="noopener ugc nofollow" target="_blank">悬臂</a>的<a class="ae ks" href="https://quarkus.io/guides/container-image#jib" rel="noopener ugc nofollow" target="_blank">集成点</a>。在本节的其余部分，我们将继续使用Docker文件。</p><p id="18f0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要创建GraalVM本地二进制文件，可以使用以下命令:</p><pre class="mw mx my mz gt nf mp ng nh aw ni bi"><span id="a472" class="nj lb iq mp b gy nk nl l nm nn">./mvnw package -Pnative -Dquarkus.native.container-build=true</span></pre><p id="eb27" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可以在<code class="fe mm mn mo mp b">target</code>文件夹中找到生成的本机可执行文件。</p><p id="7593" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要将其包装在Docker容器中，请使用:</p><pre class="mw mx my mz gt nf mp ng nh aw ni bi"><span id="5144" class="nj lb iq mp b gy nk nl l nm nn">docker build -f src/main/docker/Dockerfile.native -t native-quarkus .</span></pre><p id="00b8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">注意，如果在非Linux平台上运行第一个命令，Docker容器将无法启动。要解决这个问题，需要添加一个选项:</p><pre class="mw mx my mz gt nf mp ng nh aw ni bi"><span id="0853" class="nj lb iq mp b gy nk nl l nm nn">./mvnw package -Pnative -Dquarkus.native.container-build=true \<br/>                         -Dquarkus.container-image.build=true</span></pre><blockquote class="kt ku kv"><p id="1c80" class="ju jv kw jw b jx jy jz ka kb kc kd ke kx kg kh ki ky kk kl km kz ko kp kq kr ij bi translated"><code class="fe mm mn mo mp b"><em class="iq">quarkus.container-image.build=true</em></code> <em class="iq">指示Quarkus使用最终的应用程序工件(在本例中是本机可执行文件)创建一个容器映像。</em></p><p id="432e" class="ju jv kw jw b jx jy jz ka kb kc kd ke kx kg kh ki ky kk kl km kz ko kp kq kr ij bi translated"><em class="iq">—</em><a class="ae ks" href="https://quarkus.io/guides/building-native-image#using-the-container-image-extensions" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://quar kus . io/guides/building-native-image # using-the-container-image-extensions</em></a></p></blockquote><p id="ecbe" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于较小的图像，我们可以使用distroless分布。</p><p id="3092" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">结果如下:</p><pre class="mw mx my mz gt nf mp ng nh aw ni bi"><span id="8c17" class="nj lb iq mp b gy nk nl l nm nn">REPOSITORY                TAG     IMAGE ID     CREATED        SIZE<br/>native-quarkus-distroless latest  7a13aef3bcd2 2 hours ago    67.9MB<br/>native-quarkus            latest  6aba7346d987 2 hours ago    148MB</span></pre><p id="126c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们潜水吧:</p><pre class="mw mx my mz gt nf mp ng nh aw ni bi"><span id="b58a" class="nj lb iq mp b gy nk nl l nm nn">┃ ● Layers ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━<br/>Cmp   Size  Command<br/>    2.4 MB  FROM 58f4b2390f4a511                                 #1<br/>     18 MB  bazel build ...                                      #2<br/>    2.3 MB  bazel build ...                                      #2<br/>    113 kB  #(nop) COPY file:b8552793e0627404932d516d478842f7f9   #3<br/>     45 MB  COPY target/*-runner /application # buildkit         #4</span></pre><ol class=""><li id="e6d3" class="md me iq jw b jx jy kb kc kf mf kj mg kn mh kr mi mj mk ml bi translated">父发行版映像</li><li id="4679" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr mi mj mk ml bi translated">添加系统库，显然是通过Bazel构建系统</li><li id="9d39" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr mi mj mk ml bi translated">又一个系统库</li><li id="95ad" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr mi mj mk ml bi translated">我们的本地可执行文件</li></ol><p id="46b9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们现在可以运行容器了:</p><pre class="mw mx my mz gt nf mp ng nh aw ni bi"><span id="55e1" class="nj lb iq mp b gy nk nl l nm nn">docker run -it -p8080:8080 native-quarkus-distroless</span></pre><p id="97c4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以下URL按预期工作:</p><pre class="mw mx my mz gt nf mp ng nh aw ni bi"><span id="ab6a" class="nj lb iq mp b gy nk nl l nm nn">curl localhost:8080<br/>curl 'localhost:8080?limit=1'<br/>curl 'localhost:8080?limit=1&amp;offset=50'</span></pre><h1 id="6a53" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="8f7c" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">夸库斯带来了激动人心的表演。与Micronaut不同，它不会在每次编译时生成额外的<em class="kw">字节码</em>。只有在通过Maven命令生成本机映像时，才会生成额外的代码。此外，如果您碰巧有一个Docker守护进程，那么依靠Dockerfiles可以让您随心所欲地配置它们。</p><p id="39d1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是，缺少Kotlin集成。您必须降级您的模型表示以允许Quarkus水合您的数据类，从<code class="fe mm mn mo mp b">val</code>移动到<code class="fe mm mn mo mp b">var</code>并设置默认值。此外，需要在每个字段上设置Jackson注释。最后，配置属性不能很好地处理数据类。</p><p id="c828" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">和Micronaut一样，如果Kotlin是你的必备，那么你最好选择Spring Boot而不是夸库斯。否则，给夸库斯一个机会。</p><p id="b05b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">感谢塞巴斯蒂安·布兰克和克莱门特·埃斯科菲耶的评论。</p><p id="b651" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这篇文章的完整源代码可以在GitHub 上找到<a class="ae ks" href="https://github.com/ajavageek/quarkus-native" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="c8c4" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">更进一步:</strong></h1><ul class=""><li id="5109" class="md me iq jw b jx ly kb lz kf nr kj ns kn nt kr ne mj mk ml bi translated"><a class="ae ks" href="https://code.quarkus.io/" rel="noopener ugc nofollow" target="_blank"> Quarkus应用程序配置器</a></li><li id="7b72" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr ne mj mk ml bi translated"><a class="ae ks" href="https://quarkus.io/guides/cli-tooling" rel="noopener ugc nofollow" target="_blank"> Quarkus命令行界面</a></li><li id="bd6b" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr ne mj mk ml bi translated"><a class="ae ks" href="https://quarkus.io/guides/maven-tooling" rel="noopener ugc nofollow" target="_blank">用Maven构建应用</a></li><li id="ed7e" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr ne mj mk ml bi translated"><a class="ae ks" href="https://quarkus.io/guides/kotlin" rel="noopener ugc nofollow" target="_blank">使用Kotlin </a></li><li id="41df" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr ne mj mk ml bi translated"><a class="ae ks" href="https://quarkus.io/guides/getting-started-reactive#mutiny" rel="noopener ugc nofollow" target="_blank">反应兵变入门</a></li><li id="ce27" class="md me iq jw b jx mq kb mr kf ms kj mt kn mu kr ne mj mk ml bi translated"><a class="ae ks" href="https://quarkus.io/guides/container-image" rel="noopener ugc nofollow" target="_blank">容器图像</a></li></ul></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="d5bc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="kw">最初发表于</em> <a class="ae ks" href="https://blog.frankel.ch/native/quarkus/" rel="noopener ugc nofollow" target="_blank"> <em class="kw">一个Java极客</em></a><em class="kw">2021年12月11日</em></p></div></div>    
</body>
</html>