# 面向初学者的 OAuth 2.0 简介

> 原文：<https://itnext.io/an-oauth-2-0-introduction-for-beginners-6e386b19f7a9?source=collection_archive---------0----------------------->

## OAuth 2.0 如何工作以及如何选择正确的流程

## TL；DR；

你真差劲！你只想要密码。

但是，在文章的最后，你会发现一份问卷，可以帮助你选择你需要的流量。

本文并不想成为 OAuth 2 的最终指南，而是对组成这个框架的流程的介绍。您将看到四个基本流程和一些实际场景，以理解所涉及的参与者和详细的行为。目标是能够选择最适合您需求的流程。

![](img/1dd838a3bb1ccbea83e4556f7606a723.png)

应该选择哪个 Oauth 2 流？

为了尽可能简单，请专家们原谅，我们可以说有四个不同的版本。或者更准确地说，四种不同的流动。OAuth 2 是这些流量的总和。不一定要全部实现，而是只实现你需要的那些。

目标始终保持不变:**获得一个 access_token** 并使用它来访问受保护的资源。这四种模式是:

*   ***授权码授予:*** 发出一个*码*，用于获取 *access_token* 。这个*代码*在用户登录后被释放给一个前端应用程序(在浏览器上)。取而代之的是，access_token 由服务器端发布，使用其密码和获得的*代码*对客户端进行认证。
*   ***隐式授予:*** 用户登录后，立即发出 access_token。
*   ***客户端凭证授予:***‘*access _ token*是在服务器上颁发的，只对客户端进行认证，不对用户进行认证。
*   ***密码授权:***access _ token 会立即发出一个包含所有登录信息的请求:用户名、用户密码、客户端 id 和客户端密码。它可能看起来更容易实现，但它有一些复杂性。

![](img/5cf5957a4bdc8c81182030d7c79cfcdd.png)

OAuth 2 流程的要求

# 授权码授予

![](img/f5ab1f3c4b95d31bf5219b600799f485.png)

授权代码流程，如下所述

这是最完整最复杂的流程。登录过程分为两个阶段，这确保了更高的安全性。

# 参与的演员

*   ***用户*** :希望被认证的人，访问受保护的信息。
*   ***客户端 App*** :在这个流程中，客户端通常是 web 应用。应用程序必须同时具有前端和后端，稍后我们将看到为什么。这意味着一个纯粹的前端应用程序(Javascript，React，Angular)不能实现这个流，但是可以使用*隐式授权*的那个。
*   ***授权服务器*** :是执行认证和授权的组件，它处理登录请求、用户认证、令牌生成和安全验证。
*   ***资源服务器*** :它公开资源，因为它们可能是 REST API。*客户端 App* 获得 *access_token* 后，将使用它调用*资源服务器*。授权服务器和资源服务器的区别之一是，第一个服务器“只”处理认证和授权，第二个服务器“只”提供内容(资源)。这种划分可能会产生一些混乱:重要的是要记住这是一个逻辑差异，而不是一个实现规则。

# 流动

我们来详细看看*授权码授予*流程。

## 1.用户想要登录

这个流的经典场景在用户浏览器中播放。用户将点击“使用 OAuth 登录”按钮，客户端将生成并向*授权服务器*发送登录请求。

## 2.用户被重定向到授权服务器

客户端为*授权服务器*生成一个登录请求。请求将以`HTTP Redirect`的形式发送，信息将作为`GET`参数发送。

```
GET /token*Location:* [*https://the-authorization-server/token?client_id=[the_client_id]&redirect_uri=[a*](https://the-authorization-server/token?client_id=[the_client_id]&redirect_uri=[a) *redirect uri]&response_type=code&scope=[list of scopes]&state=[some client parameter]*
```

这些参数如下:

*   ***client_id*** :标识调用应用
*   ***redirect_uri*** :用户登录后，*授权服务器*将*授权码*发送(通过重定向)到的 URL。
*   ***response _ type***:标识*授权服务器将返回*的响应类型。值`code`通常在*授权码*流程中。
*   ***范围*** :应用程序询问用户的许可列表。比如: *read_email* ， *write_post* 。将要求用户授予这些许可。当客户端将访问*资源服务器*时，这将非常有用。这将决定是否允许或拒绝访问。例如，一个客户端，用脸书登录，询问`email`范围。如果客户端(一旦获得令牌)调用需要`friend_list`作用域的`/{user-id}/friendlists` API，将会获得拒绝访问错误。
*   ***状态*** :该可选参数在登录过程结束后，将原样返回给客户端。它可用于检索客户端应用程序上的信息，例如关于用户会话的信息。

## 3.请求验证

L' *授权服务器*必须验证所有请求参数:

*   ***client_id*** :是否存在具有该 id 的客户端？是否允许客户端执行此请求？
*   ***redirect_uri*** :客户端可以使用这个重定向 uri 吗？这个重定向 URI 与这个客户有关吗？
*   ***response_type*** :是否允许客户端使用该响应类型？
*   ***范围*** :是否允许客户使用这些授权？

为了执行这些验证，*授权服务器*必须预先注册所有将要访问的客户端。客户机的加入和维护超出了 OAuth 的范围。

## 4.登录表单

*授权服务器*显示登录表单，用户必须输入用户名和密码才能登录(图中的*步骤 5)。*

在验证数据后(图中的*步骤 6*)*授权服务器*向用户询问*范围中指定的同意。*用户将决定授予或不授予一个或多个范围。相反的情况下，客户会采取不同的行动。例如，它可以限制或禁止应用程序的使用。

## 7.使用 authorization_code 重定向到客户端

*授权服务器*生成一个授权码( *authorization_code* )并发送给客户端，发送给请求中指定的 URI。

所有这些操作都发生在客户端，在浏览器(或移动应用程序)上，接下来的步骤客户端必须使用后端。

> 在我看来，这是在选择哪个 OAuth 2 流最适合您的需求时要考虑的一个方面。

## 8 和 9。授权码验证

现在，客户端必须调用*授权服务器*来验证接收到的代码。要执行此操作，它将通过:

*   待验证的 ***授权 _ 代码*** 。
*   ***client_id*** :这是必需的，与 *client_secret、*一起使用，以确保请求来自该客户端，并且令牌不会在您处于前端时被“窃取”。
*   ***client _ secret***是客户端密码，必须保存在安全的地方，这就是为什么你需要一个后端。

*授权服务器*执行所有上述验证，检查*授权 _ 代码*是否完整、未被更改、未过期并针对该特定客户端发布。

## 10.客户端接收访问令牌

A *授权服务器*创建一个 ***访问令牌*** 并返回给客户端。有许多类型的令牌，它们有到期日期，并且可以刷新。通常，与令牌一起返回的还有更多信息:

*   *令牌 _ 类型:*其中最著名的是*持有者*，意思是:授予此令牌持有者访问权限。 [mac](https://tools.ietf.org/id/draft-ietf-oauth-v2-http-mac-05.html) 是另一种类型。
*   *expires_in* :令牌的持续时间
*   *refresh_token* :另一个令牌，用于在 *access_token* 到期时更新。

## 11.客户端使用 access_token。

既然客户端已经获得了 *access_token* ，它就可以使用它向*资源服务器*认证自己。

*资源服务器*是一个通用组件，可以服务于许多不同类型的资源: *REST API、SOAP 服务、网页*等……根据资源类型，发送 *access_token* 的方法可以改变。针对 REST API 最常见的发送方式是使用 HTTP 头: ***授权*** ，将 *token_type* 与 *access_token* 串联起来。示例:

```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ
```

## 12 和 13。令牌验证

当资源服务器收到请求时，必须检查令牌的存在和完整性。

令牌验证，尤其是基于其类型的验证，可以通过多种方式完成。在某些情况下*资源服务器*可以验证它，在另一些情况下必须调用*授权服务器*。

在某些情况下，这两个组件可能是同一个应用程序，这是透明的，对客户端来说并不重要。如果您需要实现 OAuth 服务器，那么如何验证令牌的选择将根据您的架构和您决定使用的令牌类型而有所不同。

## 14 和 15。访问和显示受保护的资源。

一旦资源服务器成功验证了令牌，它就会将资源返回给客户端，这样就可以向用户显示资源。

# 隐式授权流

![](img/46000bc5a65f9c8a17537f74876d80ef.png)

此图显示了 OAuth 2.0 隐式授权流

这个流程与*认证码*非常相似，但是 *access_token* **是在用户登录**后立即以*隐式*的方式返回给客户端。您在单页面应用程序和纯 Javascript 应用程序中使用这个流程，在这些应用程序中，不可能对 *client_secret* 保密。涉及的演员和上一个流程一样。

第一个区别是在初始重定向到*授权服务器时，*参数 *response_type* 的值是`token`而不是`code`。这意味着来自服务器的响应类型将(立即)是*访问 _ 令牌*，而不是*授权 _ 代码*。

这样，您将为客户端少执行一个步骤，但也不太安全，因为整个流程是在浏览器上执行的(一般来说是在*用户代理*上执行的)，包括令牌。在*授权代码*流中，令牌来自服务器到服务器的调用，因此拦截或操纵它更加困难。

# 客户端凭据

![](img/df0c8a866f44340641a1c31c7200bb6a.png)

客户端凭据授予流程

上面提到的流程之间的主要区别是，在这个流程中没有用户交互。应用程序直接执行身份验证请求。

这意味着应用程序不能代表用户做任何动作，而只能代表它自己。

这个流程不是发生在浏览器上，而是发生在服务器上。没有重定向，但是执行了一个`HTTP POST`调用，请求的参数是:

*   客户端 id
*   客户端 _ 机密
*   授予 _ 类型:`client_credentials`

```
POST /token&client_id=my-fancy-client-application
&client_secret=xxxxxxx
&grant_type=client_credentials
```

这个请求的响应是 *access_token* ，它可以在*资源服务器*上使用。

# 密码授权流程

![](img/104c8d27eb7def62e55fcbdedc3e2f5d.png)

密码授权流程

在我看来，这个流程的主要概念是**用户在客户端应用程序**中输入他们的用户名和密码，而不是在*授权服务器*中。值得注意的是，凭证*属于*授权服务器，*不属于客户端，*

*这个事实意味着用户必须完全信任客户端应用程序，才能插入他们的*授权服务器*凭证。为了更好地理解这一点，假设您创建了一个应用程序，用户使用脸书登录，但是用户在该应用程序上插入他们的(脸书)用户名和密码。作为用户，你会这样做吗？*

*您必须确保该应用程序是绝对可信的，例如，不会保存或修改您的脸书密码。*

*如果我没记错的话，Spotify 有这个功能，大概用的就是这个 OAuth 2 流。我记得我在 Spotify 上直接用脸书的凭证登录过。*

*一旦用户名和用户密码在前端被收集，它们就被发送到应用程序后端，应用程序后端对*授权服务器*执行一个`HTTP POST`。这一请求的参数是:*

*   ****grant _ type***:`password`*
*   ****用户的用户名****
*   ****用户的密码****
*   ****客户端 _id****
*   ****客户端 _ 秘密****

```
*POST /tokengrant_type=**password**
&username=username@authorization-server.com
&password=TheUserPassword
&client_id=my-fancy-client-app
&client_secret=xxxxxxx*
```

**授权服务器*在验证所有凭证后，返回 l’*访问令牌*。*

*对于这个流，你既需要前端，也需要后端。*

# *OAuth 2 的实施*

*![](img/4cdfb64714dae32967dde08a057c9352.png)*

*照片由 [Fancycrave](https://unsplash.com/@fancycrave?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)*

*要实现 OAuth 2，您必须开发:*

*   *客户端:如果你想使用一个*授权服务器*服务*
*   *服务器:如果您想要公开身份验证机制*

## *客户端*

*您必须再次记住，要实现一些 OAuth 流，您需要使用客户端密码，并且必须将密码保存在一个安全的地方。所以你可能需要一个服务器。*

*这意味着如果没有服务器，就无法实现某些流。不需要服务器的应用程序是单页应用程序和在用户设备上运行的应用程序:移动和桌面应用程序。您可以通过创建一个专用的服务器或后端来执行 OAuth 服务器调用，或者通过使用一些 crypt 机制来绕过这个问题。*

## *服务器端*

*许多语言中有许多实现 OAuth 的框架。对于暴露所需端点的部分，这使得生活变得稍微容易一些；尤其是所有需要的验证。但我很少找到“交钥匙”解决方案。*

*一件困难的事情是为客户提供入门和管理平台。只要想想许多现有的`developers.[preferred-social-network].com`就知道它们是复杂的应用程序。*

*您还必须注意*作用域*和权限，它们的管理一点也不平庸，尤其是在资源保护阶段。*

*另一个有趣的地方是令牌管理。需要使用数据库来保证完整的生命周期:*

*   *释放；排放；发布*
*   *更新*
*   *呼气*
*   *取消*

# *我该选择哪个流量？*

*![](img/c550a7444e73f6aa78fc0a08dbcc3140.png)*

*回答这些问题，你就会发现哪个最适合你。*

*正确流程的选择取决于许多因素，请回答这些问题，了解哪种流程最适合您。*

> *你能在一个安全和秘密的地方维护客户秘密吗？*

*   *是:下一个问题*
*   *否: ***隐式授予****

> *您的应用程序是 Web 应用程序吗？*

*   *是:回答下一个问题*
*   *否: ***客户凭证授予****

> *你的用户足够信任你在你的网站上插入他们的凭证(用户名和密码)吗？例如:用户会在你的网站上输入他们的脸书密码吗？*

*   *是: ***密码授予****
*   *否: ***授权码授予****

# *结论*

*我希望 OAuth 的世界更加清晰，现在您已经阅读了这篇文章，我的目标是探索这个协议的基础。如果你有任何意见或建议，欢迎在这里留下。*

*恭喜你！！😎你坚持到了最后。如果你喜欢👌这篇文章，点击下面按钮👏。这对我意义重大，也有助于其他人了解这个故事。*

**更帖由* [*spyna*](https://medium.com/@spyna) *。**

*[](https://medium.com/swlh/react-global-state-with-hooks-f163e49f90f9) [## *用钩子反应全局状态

### 使用钩子管理 React 应用程序全局状态的解决方案。

medium.com](https://medium.com/swlh/react-global-state-with-hooks-f163e49f90f9) [](https://medium.com/@spyna/the-truth-about-amazon-job-interview-b940a2190585) [## *如何在亚马逊找到工作

### 我们听说了很多关于亚马逊招聘流程的故事，有些是真的，有些不是。我想分享我的…

medium.com](https://medium.com/@spyna/the-truth-about-amazon-job-interview-b940a2190585)*