<html>
<head>
<title>A little Web Component in my React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的一个小Web组件</h1>
<blockquote>原文：<a href="https://itnext.io/a-little-web-component-in-my-react-3c66a918ea99?source=collection_archive---------4-----------------------#2018-03-05">https://itnext.io/a-little-web-component-in-my-react-3c66a918ea99?source=collection_archive---------4-----------------------#2018-03-05</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><p id="9165" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在工作中，我使用React和所有与之配套的工具。在家里，我喜欢尽可能地接近金属(浏览器)。我记得当我可以检查页面，下载源代码，然后黑进我自己的东西。不再是了。</p><p id="f361" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">考虑到这一点，我已经花了很多时间在web组件中使用<a class="ae km" href="https://developers.google.com/web/fundamentals/web-components/customelements" rel="noopener ugc nofollow" target="_blank">定制元素v1 </a>和<a class="ae km" href="https://developers.google.com/web/fundamentals/web-components/shadowdom" rel="noopener ugc nofollow" target="_blank">影子DOM v1 </a>规范。老实说，这两个规范可能会很快改变我们构建web应用的方式。根据CanIUse.com<a class="ae km" href="https://caniuse.com/" rel="noopener ugc nofollow" target="_blank">的</a>统计，他们分别为全球用户的<a class="ae km" href="https://caniuse.com/#feat=custom-elementsv1" rel="noopener ugc nofollow" target="_blank"> 77.65% </a>和<a class="ae km" href="https://caniuse.com/#feat=shadowdomv1" rel="noopener ugc nofollow" target="_blank"> 78.36% </a>启用。当与浏览器中的原生ES6模块结合时，我已经能够从我的工具链中删除相当多的工具。</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gi gj kn"><img src="../Images/2db979636985a3ce9e78329070749574.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4SlFHOdFGFt9RnzR."/></div></div><figcaption class="kz la gk gi gj lb lc bd b be z dk translated"><a class="ae km" href="https://unsplash.com/@barnimages" rel="noopener ugc nofollow" target="_blank">@ barn images</a>:<a class="ae km" href="https://unsplash.com/photos/t5YUoHW6zRo" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/t5YUoHW6zRo</a></figcaption></figure><p id="0897" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">作为一个前端人员，有一件事一直困扰着我，那就是我们为了限定CSS的范围而做的所有疯狂的事情。无论是像BEM这样的命名约定，通过CSS模块散列类，还是用Styled-Components这样的工具内联它们，我从未对这个解决方案感到兴奋。事实上，正是这一点让我希望web组件能早点出现。不幸的是，我从来没有机会在专业上使用它，坦率地说，支持是不存在的。但是事情发生了多么大的变化。</p><p id="0689" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">所以前几天我正准备为前端PDX做一个演讲。我正在寻找结合子元素(脸)模式，又名<a class="ae km" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank"> renderProps </a>的功能，与es6'ish组成。没成:(</p><p id="a14f" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">然而，当我在玩FACE模式时，我想我可以用Shadow Dom创建一个超级小的css-in-js解决方案。会有多难呢？结果并不是这样，只有48行代码。</p><figure class="ko kp kq kr gu ks"><div class="bz fq l di"><div class="ld le l"/></div></figure><p id="3d66" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">任何被ShadowDom组件包装的子元素都将被附加到它的ShadowRoot。</p><figure class="ko kp kq kr gu ks"><div class="bz fq l di"><div class="ld le l"/></div></figure><p id="84d8" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">传递给lightDom的任何组件都将被放置在组件light DOM中，并且不会出现，除非您已经在ShadowDom组件中对其进行了槽处理并声明了一个槽。</p><figure class="ko kp kq kr gu ks"><div class="bz fq l di"><div class="ld le l"/></div></figure><p id="7d98" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">给影子世界做造型很老套。只是一个普通的旧样式标签和BAM，我们就有了一个工作的react组件，它具有封装的样式、标记和对生命周期方法的完全访问。</p><figure class="ko kp kq kr gu ks"><div class="bz fq l di"><div class="ld le l"/></div></figure><p id="ec27" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">唯一的警告是测试。JSDOM完全不知道如何处理attachShadow，在花了几个小时试图让它理解之后，我真的放弃了。我不打算使用这个组件，但我想我会分享它，以防有人想尝试一下。</p><p id="7b16" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">回购:<a class="ae km" href="https://github.com/EdwardIrby/react-shadow-dom-component" rel="noopener ugc nofollow" target="_blank">https://github.com/EdwardIrby/react-shadow-dom-component</a><br/>现场版:<a class="ae km" href="https://absorbed-pump.glitch.me/" rel="noopener ugc nofollow" target="_blank">https://absorbed-pump.glitch.me/</a></p></div></div>    
</body>
</html>