<html>
<head>
<title>Templating Concourse pipelines with Jsonnet: Follow-up</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jsonnet模板化Concourse管道:后续</h1>
<blockquote>原文：<a href="https://itnext.io/templating-concourse-pipelines-with-jsonnet-follow-up-e3d0ac0cba9d?source=collection_archive---------5-----------------------#2020-06-12">https://itnext.io/templating-concourse-pipelines-with-jsonnet-follow-up-e3d0ac0cba9d?source=collection_archive---------5-----------------------#2020-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/0f2db873d34081864853222cb7ec7d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/0*JYDwVLYxVMdjSlJy.png"/></div></figure><p id="addd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">大约一个月前，我开始尝试用<a class="ae ks" href="https://jsonnet.org/" rel="noopener ugc nofollow" target="_blank"> jsonnet </a>以编程方式为<a class="ae ks" href="https://concourse-ci.org/" rel="noopener ugc nofollow" target="_blank"> Concourse </a>生成管道。从那以后，我用它来建造基础设施管道。我们使用<a class="ae ks" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>在AWS中提供基础设施。以前，这一过程大多是手动的。随着越来越多的团队加入我们的平台，这种方法变得难以为继。我想在第一篇文章的基础上展开，谈谈我在这个过程中学到的东西。</p><h1 id="100b" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">项目特定资源</h1><p id="11b0" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">在开发我们的管道时，我写了一个小的通用助手函数库。我们在它们的基础上构建了特定于我们的用例的定制资源。多亏了<code class="fe lw lx ly lz b">+:</code>操作符，我们可以覆盖我们所需要的，同时从合理的缺省值中获益。</p><p id="2cc1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的<code class="fe lw lx ly lz b">git</code>和<code class="fe lw lx ly lz b">docker</code>资源已经过调整，可以包含凭据:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="fea8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们意识到我们所有的作业都声明了相同的输入，所以我们也为此构建了一个资源。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><h1 id="1911" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">助手功能</h1><p id="befe" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">每当你试图用简单的YAML重用代码时，你最终都会碰壁。即使你使用<a class="ae ks" href="https://confluence.atlassian.com/bitbucket/yaml-anchors-960154027.html" rel="noopener ugc nofollow" target="_blank">锚</a>，它们也不容易参数化。</p><p id="0c09" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有了<code class="fe lw lx ly lz b">jsonnet</code>，我们可以通过构建简单的函数来基于环境检查条件，从而解决这个限制。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="0933" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可以看到，我们从外部接收到了一个<code class="fe lw lx ly lz b">config</code>对象，这就引出了我的下一点，配置共享相同结构的不同管道。</p><h1 id="bd22" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">配置管道</h1><p id="2f9e" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">我们的管道为不同的团队部署相同的基础设施。存在一些差异，如产品名称、要部署的环境数量、区域等等。</p><p id="f194" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们发现这个配置更容易保存在一个单独的<code class="fe lw lx ly lz b">product.yaml</code>文件中。这样，这个领域的变化看得更清楚，新产品也能很快推出。看起来是这样的:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="ba49" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe lw lx ly lz b">jsonnet</code>可以接收外部配置(<code class="fe lw lx ly lz b">local config = std.extVar('CONFIG')</code>)，虽然你得先把这个文件转换成<code class="fe lw lx ly lz b">json</code>。</p><h1 id="9fa6" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结合一切</h1><p id="1146" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">通过使用所有这些助手和抽象，我们实际的管道定义大约有80行长。下面是提供完整环境的功能的简化版本:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="b8d1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">不可否认，这段代码变得相当复杂！这是难以避免的，因为不同工作之间的依赖关系本身就很复杂。试图在YAML描述所有这些依赖关系将会冗长得多。</p><h1 id="21c6" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">最终结果</h1><p id="9db6" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">为了让您有个概念，这里是我们供应的一种产品的完整管道的图形表示:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mg"><img src="../Images/dff215b3ea658f829d499001ce592ac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qfeEmpZUCYTOxz4b.png"/></div></div></figure><p id="33f3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">是啊，你可能连工作的名字都看不清。那东西太大了！如果你想知道，实际的YAML文件有2781行。你可能会问，为什么它这么大？首先，它在不同地区提供四种不同的环境。我们已经尝试将基础架构划分为更小的模块，以便于管理。</p><p id="60be" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">结果是更容易想象一个大的工作。更小的模块也更容易应用和维护。多亏了<code class="fe lw lx ly lz b">jsonnet</code>，管理管道的复杂性大大降低。我们试着用手工制作这个，但是一点也不成功。</p><h1 id="16ff" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">值得吗？</h1><p id="0cd6" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">如果您的管道共享相似的结构，只有一些参数不同，这显然是肯定的。你做这件事会轻松得多。</p><p id="0aea" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">即使没有要抽象的公共结构，您也可以避免大量的YAML重复，并减少意外的复杂性。我建议探索这个选项，尽管必须小心不要构建一些变得不可维护的东西。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="d101" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="ms">原载于2020年6月12日【https://hceris.com】<a class="ae ks" href="https://hceris.com/templating-concourse-pipelines-with-jsonnet-follow-up/" rel="noopener ugc nofollow" target="_blank"><em class="ms"/></a><em class="ms">。</em></em></p></div></div>    
</body>
</html>