<html>
<head>
<title>The right way to place business logic in your React application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React应用程序中放置业务逻辑的正确方法</h1>
<blockquote>原文：<a href="https://itnext.io/the-right-way-to-place-business-logic-in-your-react-application-8bf16145f48d?source=collection_archive---------0-----------------------#2021-11-30">https://itnext.io/the-right-way-to-place-business-logic-in-your-react-application-8bf16145f48d?source=collection_archive---------0-----------------------#2021-11-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="7f1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">更新(2022年7月17日):我最近总结了我在许多文章中讨论过的模式，并在leanpub </em>  <em class="ko">中发表了一本关于</em> <a class="ae kp" href="https://leanpub.com/maintainable-react" rel="noopener ugc nofollow" target="_blank"> <em class="ko">主题的书。现在差不多完成了(90%)，如果你能给我提供任何反馈，那就太好了。</em></a></p><p id="d915" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你有兴趣深入这个主题，我已经创建了一个在线课程<a class="ae kp" href="https://icodeit.thinkific.com/courses/maintainable-react" rel="noopener ugc nofollow" target="_blank">涵盖了这篇文章中讨论的所有主题以及更多。本课程旨在互动、吸引人，并包含实用的技巧和技术。课程结束时，你将对这门学科有一个扎实的理解，并能够在日常生活中运用所学。</a></p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><p id="7eac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们已经讨论了React应用程序中的项目结构，如何命名我们的文件，何时使用<code class="fe kx ky kz la b">hooks</code>来管理副作用等等。我们甚至会讨论在我们的观点中应该采用哪种编程范式。但是在这些讨论中，我们没有过多触及一个话题，那就是我们应该把我们的商业逻辑放进去的地方。我认为，部分原因是我们忽略了React是一个构建视图的库(而不是框架)。</p><p id="34ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在许多情况下，开发人员会简单地将逻辑写入他们的组件。即使是有经验的开发人员通常也只是停留在将这些计算和逻辑提取到一个定制的钩子或者一些辅助函数中。但是这种提取方式没有解决这个问题。事实是，即使我们有更小的组件，并将逻辑移入钩子或助手中，它们实际上是无组织地分散在各处。以一个网上购物应用程序为例，如果我们想改变<code class="fe kx ky kz la b">cart</code>中的逻辑，很可能我们也会改变<code class="fe kx ky kz la b">product</code>和<code class="fe kx ky kz la b">validation</code>模块。我们通常必须改变助手和视图(更不用说这些相关的测试设备了)。</p><h1 id="6088" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">全景</h1><p id="b3e0" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">而我们应该跳出细枝末节，站在更高的层面来审视整个问题。如果你仔细看看React，并接受它只负责我们应用程序的视图部分，我们面临的许多问题将会自动修复。不管我们是使用传统的<code class="fe kx ky kz la b">MVC/MVP</code>模式还是它们的变体<code class="fe kx ky kz la b">MVVM</code>，如果React是<code class="fe kx ky kz la b">V</code>，显然我们需要其他东西来填充应用程序中的<code class="fe kx ky kz la b">M</code>或<code class="fe kx ky kz la b">VM</code>角色，对吗？</p><p id="4f3e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在许多项目中，我还发现我们在后端使用的许多好的实践在前端世界中不太被注意/认可，例如分层、设计模式等等。一个潜在的原因是前端相对较新，需要一些时间来赶上。例如，在一个典型的Spring MVC应用程序中，我们会有<code class="fe kx ky kz la b">controller</code>、<code class="fe kx ky kz la b">service</code>和<code class="fe kx ky kz la b">repository</code>，每个开发人员都接受这种分离背后的原因:<code class="fe kx ky kz la b">controller</code>没有业务逻辑，<code class="fe kx ky kz la b">service</code>不知道模型如何呈现或序列化给消费者，而<code class="fe kx ky kz la b">repository</code>只关心数据访问。然而，在前端应用程序中，我们以某种方式将React应用程序与Spring进行比较，由于缺乏原生支持(就像没有开箱即用的控制器或存储库)，我们将这些代码编写成组件。这将导致业务逻辑无处不在，随之而来的是缓慢的迭代和较低的代码质量。</p><h1 id="aa73" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">业务逻辑泄漏</h1><p id="b0c4" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">我们可以称之为<code class="fe kx ky kz la b">business logic leakage</code>，意思是业务逻辑本来应该放在某个地方，由于某种原因(维护或管理不好)放错了。虽然我们没有一个好的机制，但结果是它们被写在任何“方便”的地方(在组件、钩子和助手函数中)。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi me"><img src="../Images/3717185110c67e324230ccb6b3968d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*__-1nRy9lJ28J1v6jVgpPg.jpeg"/></div></div></figure><p id="e9a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与真实世界中的泄漏tap不同，在代码中捕捉这种泄漏有点困难。你必须更加注意才能看到它们。以下是我发现的一些常见症状:</p><ul class=""><li id="92f0" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated">使用变压器</li><li id="b85d" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">x.y.z</li><li id="0f6b" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">防御性编程</li></ul><h1 id="df26" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用变压器</h1><p id="f71b" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">很容易检测到这种模式:如果您正在执行<code class="fe kx ky kz la b">map</code>来转换数据，您可能正在跨越两个有界的上下文(这可能导致逻辑泄漏)。我们都见过或可能写过这样的代码:</p><pre class="mf mg mh mi gt ne la nf ng aw nh bi"><span id="9a69" class="ni lc it la b gy nj nk l nl nm">fetch(`https://5a2f495fa871f00012678d70.mockapi.io/api/addresses`)<br/>.then((r) =&gt; r.json())<br/>.then((data) =&gt; {<br/>    const addresses = data.map((datum: RemoteAddress) =&gt; ({<br/>        street: datum.streetName,<br/>        address: datum.streetAddress,<br/>        postcode: datum.postCode<br/>    }))</span><span id="f93d" class="ni lc it la b gy nn nk l nl nm">    setAddresses(addresses)<br/>});</span></pre><p id="3abc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的代码片段中，后端服务返回的内容与前端使用的内容并不完全匹配，因此我们需要转换/翻译它。这可能是因为我们正在使用另一个团队开发的服务，或者我们正在使用第三方服务(比如Google Search API)。因此，看似无害的代码违反了一些原则:</p><ul class=""><li id="3c61" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated">一个组件需要知道<code class="fe kx ky kz la b">RemoteAddress</code>类型</li><li id="39e3" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">一个组件需要定义一个新类型<code class="fe kx ky kz la b">Address</code> (setAddresses)</li><li id="333d" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">data.map正在进行一些较低级别的映射</li></ul><h1 id="89e8" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">x.y.z</h1><p id="8e51" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">如果你使用了不止一个点<code class="fe kx ky kz la b">.</code>操作符，很可能意味着一些概念丢失了。例如，<code class="fe kx ky kz la b">person.deliveryAddress</code>比<code class="fe kx ky kz la b">person.primaryAddress.street.streetNumber + person.primaryAddress.suburb</code>更好，因为前者适当地隐藏了细节。</p><p id="ee8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面的代码表明<code class="fe kx ky kz la b">ProductDialog</code>对<code class="fe kx ky kz la b">product</code>了解太多，一旦<code class="fe kx ky kz la b">product</code>的结构改变，我们必须改变很多地方(测试和组件)</p><pre class="mf mg mh mi gt ne la nf ng aw nh bi"><span id="ce6e" class="ni lc it la b gy nj nk l nl nm">const ProductDialog = (props) =&gt; {<br/>  const { product } = props;</span><span id="4a5e" class="ni lc it la b gy nn nk l nl nm">  if(product.item.type === 'Portion') {<br/>    //do something<br/>  }<br/>}</span></pre><p id="b466" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">显然我们在处理<em class="ko">数据</em>，而不是这里的<em class="ko">模型</em>。所以<code class="fe kx ky kz la b">product.isPortion()</code>会比原始数据检查更有意义。</p><h1 id="a98c" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">防御性编程</h1><p id="ecaa" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">就我个人而言，我对防御性编程没什么意见，我也在某些场合使用它。但我在许多项目中发现，人们倾向于在组件中做太多，这增加了很多噪音。</p><p id="e89a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如:</p><pre class="mf mg mh mi gt ne la nf ng aw nh bi"><span id="86d9" class="ni lc it la b gy nj nk l nl nm">const ProductDetails = (props) =&gt; {<br/>  const { product } = props<br/>  const { item } = product<br/>  const { media } = item as MenuItem<br/>  <br/>  const title = (media &amp;&amp; media.name) || ''<br/>  const description = (media &amp;&amp; media.description) || ''</span><span id="802e" class="ni lc it la b gy nn nk l nl nm">  return (<br/>    &lt;div&gt;<br/>      {/* product details */}<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="de69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，我们在组件的中做空检查和回退操作，我们应该在一个专门的地方做这种类型的逻辑。</p><h1 id="5d0e" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何修复该问题？</h1><p id="e9c2" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">实际上，我们可以尝试两步走的方法来解决这个问题。</p><ol class=""><li id="e070" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn no mw mx my bi translated">常规重构</li><li id="6de3" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn no mw mx my bi translated">系统模型化</li></ol><h1 id="d0ef" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">常规重构</h1><p id="371b" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">首先，当我们在React组件中看到一些逻辑时，我们可以像在任何其他情况下一样执行重构。例如，只需将逻辑/计算从:</p><ul class=""><li id="6878" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated">变形金刚(电影名)</li><li id="5cf5" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">x.y.z</li><li id="b584" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">防御性编程</li></ul><p id="7053" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">帮助函数。以上面的转换器为例，我们可以简单地将匿名函数提取到一个命名函数中，并将其移动到一个单独的文件中:</p><pre class="mf mg mh mi gt ne la nf ng aw nh bi"><span id="bfd8" class="ni lc it la b gy nj nk l nl nm">const transformAddress: Address = (address: RemoteAddress) =&gt; {<br/>    return ({<br/>        street: datum.streetName,<br/>        address: datum.streetAddress,<br/>        postcode: datum.postCode<br/>    })<br/>}</span><span id="40ad" class="ni lc it la b gy nn nk l nl nm">//...<br/>const addresses = data.map(transformAddress)</span></pre><p id="5f1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种情况下看起来没什么大不了的。但是在大多数情况下，我们会放很多空头支票或者回退等等。我们通常需要做一些翻译，例如，我们从remote获取的州名是缩写，如VIC或NSW，但我们需要在页面上以全文显示它们，如Victoria或New South Wales。</p><pre class="mf mg mh mi gt ne la nf ng aw nh bi"><span id="f3be" class="ni lc it la b gy nj nk l nl nm">const states = {<br/>  vic: "Victoria",<br/>  nsw: "New South Wales",<br/>  //...<br/>};</span><span id="4f15" class="ni lc it la b gy nn nk l nl nm">const transformAddress: Address = (address: RemoteAddress) =&gt; {<br/>  return {<br/>    street: address.streetName,<br/>    address: address.streetAddress,<br/>    postcode: address.postCode,<br/>    state: states[address.state.toLowerCase()]<br/>  };<br/>};</span></pre><p id="9f9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，我们可以用<code class="fe kx ky kz la b">extract function</code>把<code class="fe kx ky kz la b">title</code>和<code class="fe kx ky kz la b">description</code>做成一个函数:</p><pre class="mf mg mh mi gt ne la nf ng aw nh bi"><span id="ab2e" class="ni lc it la b gy nj nk l nl nm">const getTitle = (media) =&gt; (media &amp;&amp; media.name) || ''<br/>const getDescription = (media) =&gt; (media &amp;&amp; media.description) || ''</span></pre><p id="305d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着越来越多的像<code class="fe kx ky kz la b">transformAddress</code>和<code class="fe kx ky kz la b">getTitle</code>这样的逻辑被移到<code class="fe kx ky kz la b">helpers.ts</code>中，最终我们将拥有一个庞大的万能文件。这意味着它将变得不可读和高维护成本。我们可以将文件分成模块，但是这些函数之间的引用会使它们难以理解。这有点像我们在面向对象编程之前面临的问题——我们有太多的模块，每个模块中有太多的函数，浏览它们太困难了。换句话说，我们需要一种更好的方式来组织这些助手功能。</p><p id="0dfc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">幸运的是，我们不需要重新发明轮子，面向对象编程就是为此而生的。通过在OOP中简单地使用<code class="fe kx ky kz la b">class</code>和<code class="fe kx ky kz la b">encapsulation</code>，我们可以很容易地将这些函数分组，并使代码更具可读性。分组的过程被称为建模，这意味着我们需要建立一种更好的方式来组织数据，使UI组件更容易使用。</p><h1 id="1760" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">系统模型化</h1><p id="4d8e" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">简而言之，建模是将数据和行为放在一起，隐藏细节，并为消费者提供一种通用语言。例如，我们不应该使用<code class="fe kx ky kz la b">product.item.type === 'Portion'</code>，相反，我们应该创建一个<code class="fe kx ky kz la b">Product</code>类，它有一个<code class="fe kx ky kz la b">isPortion</code>用于它们的消费者。这在后端服务中很常见，但在前端世界中还没有广泛使用。原因是，如上所述，人们忽略了<code class="fe kx ky kz la b">React</code>只负责视图。一个健康的前端应用程序也应该有其他部分，它需要模型、与后端通信的逻辑，甚至日志/路由等等。但是在本文中，我们将只关注建模和逻辑。</p><p id="4f9a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到上面的例子，通过定义一个<code class="fe kx ky kz la b">Address</code>类来替换<code class="fe kx ky kz la b">data.map</code>中的匿名函数，我们得到:</p><pre class="mf mg mh mi gt ne la nf ng aw nh bi"><span id="c95f" class="ni lc it la b gy nj nk l nl nm">class Address {<br/>  constructor(private addr: RemoteAddress) {}</span><span id="e917" class="ni lc it la b gy nn nk l nl nm">  get street() {<br/>    return this.addr.streetAddress;<br/>  }</span><span id="264d" class="ni lc it la b gy nn nk l nl nm">  get postcode() {<br/>    return this.addr.postcode;<br/>  }<br/>}</span></pre><p id="0881" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在用法上没有什么不同:</p><pre class="mf mg mh mi gt ne la nf ng aw nh bi"><span id="1af2" class="ni lc it la b gy nj nk l nl nm">const AddressLine = ({ address }: { address: Address }) =&gt; (<br/>  &lt;li&gt;<br/>    &lt;div className="result"&gt;{address.street}&lt;/div&gt;<br/>  &lt;/li&gt;<br/>);</span></pre><p id="04a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">唯一需要改变的是将<code class="fe kx ky kz la b">transformAddress</code>替换为<code class="fe kx ky kz la b">new Address</code>:</p><pre class="mf mg mh mi gt ne la nf ng aw nh bi"><span id="1383" class="ni lc it la b gy nj nk l nl nm">const addresses = data.map((addr: RemoteAddress) =&gt; new Address(addr))</span></pre><p id="bd8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于状态名转换的私有成员/函数:</p><pre class="mf mg mh mi gt ne la nf ng aw nh bi"><span id="15dc" class="ni lc it la b gy nj nk l nl nm">private readonly states = {<br/>    vic: "Victoria",<br/>    nsw: "New South Wales",<br/>    //...<br/>  };</span><span id="112b" class="ni lc it la b gy nn nk l nl nm">  get state() {<br/>    return this.states[this.addr.state.toLowerCase()];<br/>  }</span></pre><p id="72da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在结构清晰多了。<code class="fe kx ky kz la b">states</code>现在是类<code class="fe kx ky kz la b">Address</code>的私有成员。类的好处是它将所有相关的逻辑聚合到一块，所以它们是隔离的，易于维护。</p><p id="287b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将所有相关的逻辑放在一个地方还有其他好处。首先，这种分离使得测试变得非常容易和可靠，因为组件依赖于模型(而不是原始数据)，我们不需要为组件测试准备空值或越界数据。同样，测试模型更关注数据和逻辑(空值、验证和回退)。其次，一致性使得它更有可能在其他场景中被重用。最后，如果我们需要切换到另一个第三方服务，我们只需要修改模型，视图基本上可以保持不变。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi np"><img src="../Images/9ec51bdbc9b889623c8ec2afb7e7e7f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dycr5BAl6UUidtHsAoOoNg.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">前端应用程序中的反腐败层</figcaption></figure><p id="d306" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着越来越多的模型被创建，我们可能需要为它们创建一个完整的层。这部分代码不知道UI组件的存在，并且纯粹围绕业务逻辑。我们将该层称为反腐败层，它防止不可靠的第三方数据结构破坏我们的视图。通过这个中间层，我们唯一需要改变的就是模型中的变形金刚。</p><h1 id="b1b4" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">摘要</h1><p id="384c" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">封装业务逻辑，即使在瘦客户机的环境中，也是一个相对较大的话题。在本文中，我们讨论了业务逻辑泄漏的几种症状，以及如何处理它们。通过进行定期重构，我们可以确保组件只负责呈现数据，而不应该进行任何计算或数据映射。我们应该将这些逻辑分离到纯JavaScript文件中(而不是jsx/tsx)。通过建模，我们可以使用对象来隐藏细节，只使用<code class="fe kx ky kz la b">getter</code>来访问数据。它将所有的逻辑封装在模型中，并允许视图更简单地完成它们的工作。这种方法给我们带来的好处是:更容易对模型和视图进行测试，更容易跟踪业务需求变化，以及更简单的视图代码(因为大部分工作都是在模型中完成的)。</p><h1 id="9c71" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">参考</h1><ul class=""><li id="1939" class="mq mr it js b jt lz jx ma kb nu kf nv kj nw kn mv mw mx my bi translated"><a class="ae kp" href="https://martinfowler.com/articles/refactoring-external-service.html" rel="noopener ugc nofollow" target="_blank">重构访问外部服务的代码</a></li><li id="aa55" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><a class="ae kp" href="https://martinfowler.com/eaaDev/uiArchs.html" rel="noopener ugc nofollow" target="_blank"> GUI架构</a></li><li id="9339" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><a class="ae kp" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel" rel="noopener ugc nofollow" target="_blank">模型-视图-视图模型</a></li></ul></div></div>    
</body>
</html>