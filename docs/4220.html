<html>
<head>
<title>An AWS Lambda Serverless Journey -Part 3 - Turn your DevOops into DevOps with GitOps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS Lambda无服务器之旅-第3部分-使用GitOps将您的开发运维转变为开发运维</h1>
<blockquote>原文：<a href="https://itnext.io/an-aws-lambda-serverless-journey-part-3-turn-your-devoops-into-devops-with-gitops-ee81ac7c76f2?source=collection_archive---------4-----------------------#2020-05-18">https://itnext.io/an-aws-lambda-serverless-journey-part-3-turn-your-devoops-into-devops-with-gitops-ee81ac7c76f2?source=collection_archive---------4-----------------------#2020-05-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/35115e777124c179d7843c6a152bd278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gxz-GjfXj4nzJxU472kvzw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">自动气象站λ</figcaption></figure><div class=""/><p id="33cb" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如你所看到的，我喜欢我的博客文章的俗气的标题。玩笑归玩笑，你来这里是因为要么你已经知道DevOps是什么，想看看我按照这些思路做了什么，要么你不知道，想知道这些奇怪的词是什么意思。让我们把它从顶部水平设置。</p><p id="d6cf" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">软件开发者是一个利用技术和工具来支持软件构建的人。</p><p id="ae5e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一个<strong class="ke jg"> IT运营(Ops) </strong>人员在组织中的活动通常包括采购和提供硬件和服务器、系统的运营管理、管理IT流程以及创建和监管IT最佳实践。</p><h1 id="8136" class="la lb jf bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">我们曾经的样子</h1><p id="7012" class="pw-post-body-paragraph kc kd jf ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">过去，在IT组织中，这两个重要的角色在沟通方面通常是<a class="ae md" href="https://medium.com/@mitulipatel/in-business-and-in-general-silos-are-bad-very-very-bad-fd06e4f67db3" rel="noopener">孤立的</a>。以下事件顺序清楚地概括了许多组织中发生的事情。</p><ol class=""><li id="ca74" class="me mf jf ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated">软件开发人员会编写他们的代码，当他们认为可以开始时，他们会编写一个部署操作手册文档，其中包含一堆只有他们自己和他们在工作中与之相关的其他不合群的人才能真正理解的神秘步骤。</li><li id="58e6" class="me mf jf ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">他们把这个闪亮的新软件“快乐包”送给了运营团队，然后很快就忘记了它，直到运营人员开始部署它。很多时候，操作人员是唯一一个需要访问部署代码的服务器的人。</li><li id="ac44" class="me mf jf ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">几天后，运营人员会对软件开发人员说，“嘿，伙计，我做了你在那篇名为software_deployment_guide.txt的文章中概述的所有事情，但它仍然不工作。你能去看看发生了什么事吗？漂亮吗？我的老板们真的很想看看你创造的新功能，他们正紧盯着我，让我部署它。”</li><li id="52b2" class="me mf jf ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">第二天早上，在喝了第三杯咖啡后，这位软件开发人员会带着尖刻但礼貌的回答回来，“嗯……它在我的机器上工作。我不知道你做错了什么。”</li><li id="cf1f" class="me mf jf ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">在这一阶段(3个工作日)之后，他们将安排一次会议，坐下来讨论是什么导致运营人员在部署过程中碰壁。当他们解决了这个问题，他们为开发环境更新了software_deployment_guide.txt，并希望它能为测试、试运行和生产等环境的后续部署工作。</li></ol><blockquote class="ms"><p id="c8b1" class="mt mu jf bd mv mw mx my mz na nb kz dk translated">旧的方法是一种缓慢的、非协作的、孤立的软件生产和交付方法，并且很快被大多数组织淘汰。</p></blockquote><h1 id="7172" class="la lb jf bd lc ld le lf lg lh li lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx bi translated">我们要去哪里</h1><p id="bc7c" class="pw-post-body-paragraph kc kd jf ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">德沃普斯德沃普斯德沃普斯。我提到DevOps了吗？在DevOps模型中，开发人员和运营人员经常被合并，开发人员和IT运营人员之间曾经存在的界限正在变得模糊。这不再是“我们对他们”的情况，当某些事情不可避免地出错时，在责备游戏中获胜不再被容忍。自动化和工具的使用越来越多，这使得组织能够在从开发到生产的各种环境中创建稳定可靠的代码部署。这种向高度协作的工作方式的文化转变的好处包括软件产品发布的速度和灵活性的提高。工具和自动化的使用和引入使组织能够根据需求随时扩展其应用程序和基础架构。</p><p id="09d0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">DevOps文化带来的工具和自动化支持:</p><ol class=""><li id="0928" class="me mf jf ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated">频繁地对代码进行小规模更新，从而增加创新并降低与每次部署相关的风险</li><li id="bd88" class="me mf jf ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">在软件开发和部署的每个阶段进行自动化测试，这样就不会出现意外</li><li id="09f7" class="me mf jf ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">开发和部署更小、更集中的微服务。开发人员范围的缩小允许他/她更加关注所产生的代码的质量。</li><li id="f108" class="me mf jf ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">作为代码或I-a-C的基础架构，能够利用声明式代码(在云中)调配和配置硬件和软件功能。这项技术改变了游戏规则(那是我的唐纳德·特朗普时刻)。</li><li id="e7cd" class="me mf jf ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">Configuration-as-Code或C-a-C，它能够以版本化的声明方式指定应用程序或硬件构件的配置。</li></ol><blockquote class="ms"><p id="532f" class="mt mu jf bd mv mw mx my mz na nb kz dk translated">GitOps是DevOps趋势的极端体现，在这种趋势下，所有东西都存储在一个存储库中并被编码。这包含了你的应用程序的代码，I-a-C和C-a-C都在一个地方，可以作为你的唯一的真实来源。这实现了版本控制和部署的自动化，以及在出现问题时(而不是在出现问题时)即时回滚到以前的版本。</p></blockquote></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="e46b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们知道了什么是DevOps和GitOps，我想重温一下我在本系列第2部分中创作的<a class="ae md" href="https://medium.com/@mitulipatel/an-aws-lambda-serverless-journey-part-2-a-serverless-api-in-java-f713d8b80fc6" rel="noopener">无服务器Rolodex API，并讨论我用来在AWS平台上自动化其部署的设计和工具。</a></p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="426a" class="la lb jf bd lc ld nm lf lg lh nn lj lk ll no ln lo lp np lr ls lt nq lv lw lx bi translated">设计</h1><figure class="ns nt nu nv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/077a9c51cc622b78d0dd984d9089b833.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0cDdN0zpY175QMjM5eDeMg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">RolodexAPI开发平台的架构图</figcaption></figure><p id="bccb" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从上面的设计中可以看出，这体现了极端的DevOps场景，其中开发人员是运营人员，反之亦然(即我、我自己和我)。在DevOps模型中，团队之间的协作和沟通是至关重要的，所以我现在可能需要去看心理医生，了解自己是不是新的Sybil(冷静，我只是在开玩笑！真的。)</p><blockquote class="ms"><p id="ff37" class="mt mu jf bd mv mw nw nx ny nz oa kz dk translated">你能解释一下上面架构图中的数字标签是什么意思吗？</p></blockquote><p id="c591" class="pw-post-body-paragraph kc kd jf ke b kf ob kh ki kj oc kl km kn od kp kq kr oe kt ku kv of kx ky kz ij bi translated">我当然可以(看，这是我在和自己合作…是的，这里没有人格分裂的可能)。</p><p id="a925" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">上面架构图中的编号标签描述如下:</p><p id="6d04" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> 1 -代码提交</strong></p><p id="23dd" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">API开发人员将代码提交到CodeCommit，最终将代码合并到“dev”分支。CodeCommit基本上是一个托管的Git存储库，具有一系列云原生特性，允许像我这样的人围绕代码管理活动(如“触发构建”)快速实现自动化。在GitOps模型中，一切都与应用程序代码一起存储在存储库中。这包括<em class="og"> buildspec.yml </em>(构建过程中需要)和<em class="og">server less-Rolodex-API-cfn-template . yml</em>(AWS上I-a-C的CloudFormation模板)<em class="og">。</em></p><figure class="ns nt nu nv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oh"><img src="../Images/272ca2c2a7e3838da815fa0edd302460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tKu0rIQA-mn_dnpDD-vwMw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">AWS代码提交中的RolodexAPI存储库</figcaption></figure><p id="447d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> 2.1 -代码构建(已触发)</strong></p><p id="180b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">代码被提交到RolodexAPI存储库中，合并到“dev”分支会触发一个服务器上的构建(CodeBuild spins up)(您可以基于您的构建的特征来配置您需要的能力)。顺便说一句，AWS是根据这个产品的功能来命名的。这一定是世界第一！好样的。太简单了，简直是天才。继续前进。代码构建的计费是基于构建执行时间的，在免费层，你每月可以获得100分钟的免费构建时间(相信我，我在撰写本文时收到了一个计费提醒！).您应该通过实现一个合适的缓存策略来加速构建，从而确保这一时间最小化。</p><p id="a282" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> 2.2 -代码构建(运行)</strong></p><p id="5981" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">AWS CodeBuild需要一个名为<em class="og"> buildspec.yml </em>的文件。该文件告诉CodeBuild如何在构建之前准备构建服务器，如何使用来自CodeCommit存储库的代码构建项目，以及需要的任何构建后操作。在<em class="og"> buildspec.yaml </em>中，我确保构建对构建后的构建工件(包括一个Java jar文件和一个CloudFormation模板)执行一个“s3 cp”到一个s3到<em class="og">桶:</em> mittcs和<em class="og">键:</em> rolodex-api/dev/build。</p><p id="8ba1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2.3 -代码管道</p><p id="6b41" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我决定使用CodePipeline来编排设计的代码提交和构建阶段。这是一个简单的设置。</p><figure class="ns nt nu nv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oi"><img src="../Images/2b86bc0638050f1cb94a860809eaa0cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kw1xVFsShLpGeDpqMLvDfQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">提交和构建阶段的代码管道</figcaption></figure><p id="1435" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有许多选择，但是正如我在本系列的第2部分中所描述的，我创作了一个CloudFormation模板，并决定在部署阶段使用它。上面描述的管道的成功运行意味着构建已经完成，并且构建工件的副本已经准备好进行部署。<strong class="ke jg">步骤2.3 </strong>中的一个CloudWatch事件通过电子邮件通知DevOps团队(me)管道已经成功。另一个事件触发Lambda函数开始部署。</p><figure class="ns nt nu nv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oj"><img src="../Images/8dc246a2d005ba8cd8e2c908ffa9e7eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*umUBlzbpXQ8lkse7ZlE04w.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">通过Lambda和CloudFormation触发部署的CloudWatch事件</figcaption></figure><p id="314c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> 3.1 / 3.2 - Lambda，系统管理器参数存储，云形成</strong></p><p id="8466" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">部署可以通过CodePipeline直接配置，但是在这种情况下我决定不这么做。我想到的解决方案确保了最新的代码被上传到Rolodex API中的Lambda函数。在为Rolodex API项目开发和创建CloudFormation模板的过程中，我发现自己必须更改模板中jar工件的名称，以使CloudFormation能够识别它。谢天谢地，我在准备<a class="ae md" href="https://www.youracclaim.com/badges/b7f4ab90-5460-4e41-8558-1100208a6dfa/linked_in_profile" rel="noopener ugc nofollow" target="_blank"> DevOps专业认证</a>的过程中学到了这个“有趣的事实”,所以我没有浪费太多时间。这直接来自AWS CloudFormation文档。</p><blockquote class="ok ol om"><p id="9274" class="kc kd og ke b kf kg kh ki kj kk kl km on ko kp kq oo ks kt ku op kw kx ky kz ij bi translated">在栈更新期间，不会自动检测到对亚马逊S3中的部署包的更改。要更新功能代码，请更改模板中的对象关键字或版本。</p></blockquote><p id="53c6" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这里概述的活动中，我确实尝试在管道中配置了名为“部署”的第三阶段(rolodex-api-dev-pipeline的克隆)。我可以确认，在最初创建CFN堆栈后，当代码存储在S3时，CloudFormation不会识别代码的更新(见下图)。如果CloudFormation模板有函数代码‘Inline ’,情况就不会是这样了(我想)。然而，这种方法会限制函数的行数，对于像Java这样的编译语言根本不起作用。</p><figure class="ns nt nu nv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oq"><img src="../Images/a565a671e654254a918530dcd79c88de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wBu4VGHxCsqL66FGDF6KlA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">一个添加了部署阶段的克隆管道，使用CloudFormation作为提供者</figcaption></figure><p id="970a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">上面架构图中的Lambda函数包含使用Systems Manager参数存储来切换CloudFormation模板中Rolodex API函数的jar名称的逻辑(<em class="og">server less-Rolodex-API-cfn-template . yml</em>)来进行跟踪。这个解决方案避开了使用CloudFormation作为部署提供者的限制。自定义Lambda函数还可以处理要部署的堆栈，即它接受一个名为“Stage”的参数。目前，我已经为每个环境的每个函数编写了这些硬编码。可以想象，每个功能的部署逻辑对于该环境可能是唯一的，并且该设计假定了这一点。例如，生产环境可能会做一些额外的工作，比如在完成时更新DNS记录，将API Gateway中的最新代码部署到一个阶段，或者对CloudFront发行版进行一些额外的配置。</p><figure class="ns nt nu nv gt is"><div class="bz fp l di"><div class="or os l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">RolodexAPI-CFN-开发-部署的Lambda函数代码</figcaption></figure><p id="9e0a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> 3.3 - CloudWatch事件，CloudTrail，SNS </strong></p><p id="53c4" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了结束反馈循环，我通知了DevOps团队(还记得我吗？)通过自动电子邮件通知堆栈操作正在运行。这是通过启用CloudTrail来实现的，这样我就可以配置一个CloudWatch事件规则来基于特定的CFN API调用触发SNS主题。当执行“StackCreate”或“stack update”cloud formation API调用时，结果是一个简单但有效的通知。</p><figure class="ns nt nu nv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ot"><img src="../Images/4c63ecfdbaf77096525e791363aa831c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k1WMQRP9s3pUQM_0tCUU_g.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">通过SNS主题订阅和CW事件的堆栈操作通知</figcaption></figure><p id="bb28" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是所有的人。</p><p id="7180" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一如既往，我希望你发现这超级有用，并学到了新的东西。在本系列的第4部分中，我希望回到重新分解Rolodex API来利用Spring Boot框架，并针对我最初的开发执行一些基准测试，我最初的开发根本没有使用任何框架。</p><p id="824e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我希望你保持关注！</p><p id="c59f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">直到下次朋友们，</p><p id="0ab8" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">米图尔</p><figure class="ns nt nu nv gt is"><div class="bz fp l di"><div class="ou os l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">RolodexAPI DevOps自动化的现场演示</figcaption></figure></div></div>    
</body>
</html>