<html>
<head>
<title>How to Write a Node.js CLI using OpenCV with Neural Network Models for Image Classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用OpenCV写一个Node.js CLI，用神经网络模型进行图像分类</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-write-a-node-js-cli-using-opencv-with-neural-network-models-for-image-classification-57785d6f09fe?source=collection_archive---------1-----------------------#2018-08-27">https://itnext.io/how-to-write-a-node-js-cli-using-opencv-with-neural-network-models-for-image-classification-57785d6f09fe?source=collection_archive---------1-----------------------#2018-08-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f3385923e093aaa50bbfd8a86f946cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TDtiRC4bINcFxJzHcFMUpA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用SSD Coco模型的分类图像(对！这是我的卡车。)</figcaption></figure><p id="3a90" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">TL；DR: </strong>在这篇文章中，我们将学习3件事(这些是我在为Github创建项目时不得不忍受的挣扎):</p><ol class=""><li id="6e25" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">如何使用git-lfs (Git大文件系统)将大文件上传到GitHub项目中。</li><li id="454a" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">如何创建节点CLI(命令行界面)</li><li id="b917" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">如何用深度神经网络进行图像分类</li></ol><p id="db76" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我为每个领域创建了一个部分，所以请全部阅读，或者阅读您感兴趣的部分。</p><h1 id="926a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">背景故事</h1><p id="3e07" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">在我们开始之前，先了解一下这一切是如何发生的。在我工作的地方，我们使用内部摄像机进行分析(比如检测石油或天然气泄漏)。当出现警报时，会从MPEG流中获取快照。然后，我团队中的另一名程序员编写Python代码，对这张快照进行分类。我很好奇Node是否也能做同样的事情。我以前从未使用过神经网络，所以这将是一个挑战。我开始使用<a class="ae mr" href="https://js.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> tensorflow.js </a>，但是我在尝试将我们现有的模型转换成tfjs-node包所要求的“网络友好”模型时遇到了问题。</p><p id="491d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后发现了<a class="ms mt ep" href="https://medium.com/u/ffd42e31db07?source=post_page-----57785d6f09fe--------------------------------" rel="noopener" target="_blank"> Vincent Mühler </a>在Medium上写的这篇优秀的文章《<a class="ae mr" href="https://medium.com/@muehler.v/node-js-meets-opencvs-deep-neural-networks-fun-with-tensorflow-and-caffe-ff8d52a0f072" rel="noopener"> <strong class="ke ir"> Node.js遇上OpenCV的深度神经网络Tensorflow和Caffe </strong> </a>的乐趣》。它通过节点包<a class="ae mr" href="https://github.com/justadudewhohacks/opencv4nodejs" rel="noopener ugc nofollow" target="_blank"> opencv4nodejs </a>向我介绍了OpenCV。从那以后，事情开始有了更好的结果。</p><p id="6723" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我把我的包和一个不错的readme markdown放在一起之后，我在把这个项目放到Github上时遇到了问题。模型文件太大！然后我了解了<a class="ae mr" href="https://git-lfs.github.com/" rel="noopener ugc nofollow" target="_blank"> git-lfs </a> (Git大文件系统)。经过几天的努力(当时带宽有限——我在露营),我让它工作了。然后是npm(叹气)问题。我试过<em class="mu"> npm publish </em>，但是打包后上传到注册表失败，出现“javascript堆内存不足”。再说一次，它实在太大了！</p><p id="aee2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我还没有在npm注册表上找到它。我需要探索不同的方法。如果你已经用一个大的软件包完成了这个任务，请随时让我知道你是如何做到的。</p><h1 id="b27f" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">Github和大文件</h1><p id="899f" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">首先，GitHub有一定的局限性。从他们的<a class="ae mr" href="https://help.github.com/articles/what-is-my-disk-quota/" rel="noopener ugc nofollow" target="_blank">文档</a>来看，“我们严格限制文件大小超过100 MB”。好吧，那么，当模型肯定比那个大的时候，这个就不行了。</p><p id="01d3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">进入<a class="ae mr" href="https://git-lfs.github.com/" rel="noopener ugc nofollow" target="_blank"> git-lfs </a>。这个小宝石允许你跟踪git和GitHub中的大文件。虽然是免费的，但它有一些限制，如果你超过这些限制，GitHub将开始<a class="ae mr" href="https://help.github.com/articles/about-storage-and-bandwidth-usage/" rel="noopener ugc nofollow" target="_blank">收费。而且，git-lfs还可以和Gitkraken一起使用——额外奖励！</a></p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/bec523d7b3089f9f00110619853d0563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*G36C_ZwPS0o5gMB2v2tLdQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">LFS在吉克拉肯的支持</figcaption></figure><p id="5be0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注意到文件末尾的<strong class="ke ir"> LFS </strong>了吗？完美。</p><p id="a4cf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">好吧，所以事情并不顺利。在将大文件放入存储库之前，您必须初始化git-lfs，并告诉它为您的项目跟踪哪种文件。在这里阅读它<a class="ae mr" href="https://help.github.com/articles/configuring-git-large-file-storage/" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="781c" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">使用节点创建CLI</h1><p id="3e3c" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">我相信你听说过CLI——命令行界面。它允许用户通过计算机程序与计算机进行交互。通过使用Node创建CLI，可以像运行计算机上的本机编译程序一样运行该包。</p><p id="dee1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">例如，要运行我的名为“classify”的节点包，您通常需要执行以下操作(在classify文件夹中):</p><p id="150b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="mu">节点index.js【参数】</em></p><p id="9058" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可以将软件包全局安装到节点生态系统中，它会将软件包添加到路径中。要安装(从分类文件夹),请执行以下操作:</p><p id="c2c1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="mu"> npm安装-分类</em></p><p id="80dd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这将使用名称“classify”在当前文件夹中安装软件包。</p><p id="c7ad" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，您可以从命令行发出如下语句:</p><p id="b8bd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="mu">分类-图像&lt;图像文件路径&gt; -滤镜。/filter.txt - confidence 50 </em></p><h2 id="084c" class="na lp iq bd lq nb nc dn lu nd ne dp ly kn nf ng mc kr nh ni mg kv nj nk mk nl bi translated">CLI输出</h2><p id="90e7" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">所有CLI都应该有一个输出，以便用户可以理解如何使用它。在这种情况下，“分类”将如下所示:</p><pre class="mw mx my mz gt nm nn no np aw nq bi"><span id="944b" class="na lp iq nn b gy nr ns l nt nu">classify</span><span id="5ede" class="na lp iq nn b gy nv ns l nt nu">Classifies an image using machine learning from passed in image path.</span><span id="c993" class="na lp iq nn b gy nv ns l nt nu">Options</span><span id="9037" class="na lp iq nn b gy nv ns l nt nu">--image imagePath     [required] The image path.                                                    <br/>--confidence value    [optional; default 50] The minimum confidence level to use for classification (ex: 50 for 50%).                                                             <br/>--filter filterFile   [optional] A filter file used to filter out classification not wanted.        <br/>--quick               [optional; default slow] Use quick classification, but may be more inaccurate.                                                                   <br/>--version             Application version.                                                          <br/>--help                Print this usage guide.</span></pre><p id="913c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当然，有一些软件包可以帮你做到这一点。我使用了<a class="ae mr" href="https://github.com/75lb/command-line-usage" rel="noopener ugc nofollow" target="_blank">命令行用法</a>和<a class="ae mr" href="https://github.com/75lb/command-line-args" rel="noopener ugc nofollow" target="_blank">命令行参数</a>来为我完成这项工作。</p><p id="c36f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是，在我们开始之前，如何使用Node运行JavaScript文件，而不在命令行上指定Node呢？</p><p id="5046" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">它与Linux系统上所有脚本的第一行有关。这是使用she-bang符号指定脚本解释器的地方:</p><pre class="mw mx my mz gt nm nn no np aw nq bi"><span id="6f44" class="na lp iq nn b gy nr ns l nt nu">#!/usr/bin/env node</span></pre><p id="ae7e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这告诉环境使用“node”作为该脚本的解释器，并且在创建CLI时应该始终位于JavaScript文件的顶部。</p><h2 id="6078" class="na lp iq bd lq nb nc dn lu nd ne dp ly kn nf ng mc kr nh ni mg kv nj nk mk nl bi translated">命令行用法</h2><p id="e303" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">相当容易使用，它定义了用户将看到什么。</p><p id="4147" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">代码如下:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="9d30" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，为了输出结果，代码如下所示:</p><p id="4ca5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe ny nz oa nn b">console.log(usage)</code></p><h2 id="b8d7" class="na lp iq bd lq nb nc dn lu nd ne dp ly kn nf ng mc kr nh ni mg kv nj nk mk nl bi translated">命令行参数</h2><p id="c937" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">同样，相当容易使用。请确保您处理并验证了所有内容:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="33cc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您会注意到对于<code class="fe ny nz oa nn b">--version</code>命令，我们所要做的就是读入我们的package.json并输出版本。这样，我们只需要在一个地方维护它。</p><p id="bb7b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">剩下的处理是检查是否使用了一个选项，如果使用了，就验证它，等等。</p><p id="5cf7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦我们收集了分类处理所需的所有数据，我们就可以开始分类了。</p><h1 id="5e18" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">利用OpenCV进行图像分类</h1><p id="1b2a" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">现在，我们已经收集并验证了从用户与CLI的交互中收集的参数，真正的乐趣可以开始了。高级处理没有您想象的那么困难:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="6d2b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">不算太坏。您应该注意到，这是我们使用一些用户收集的数据来基于置信度进行过滤的地方，并且过滤文件(如果有的话)。</p><p id="b90b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是，<strong class="ke ir">预测</strong>函数是大部分工作返回预测的地方。而且，不仅仅是<strong class="ke ir">预测</strong>功能。提取数据还需要其他几个支持函数。</p><p id="683d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们来看看这是如何做到的:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="c61f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，你要知道这些模特都是经过训练的。一个是300x300，一个是512x512。300x300型号更快。数据少了。512x512速度较慢，总体预测更准确，因为数据更多。</p><p id="93f4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您会注意到，在上面的函数中，我们必须调整输入图像的大小，以匹配模型中训练图像的大小。如果图像不是正方形，那么我们必须填充它。白色更常用，因为它比使用黑色有较少的问题。</p><p id="f68e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，图像被转换为“blob”并传递给“net.setInput”。你会记得，我们以前有这个代码:</p><pre class="mw mx my mz gt nm nn no np aw nq bi"><span id="330d" class="na lp iq nn b gy nr ns l nt nu">// initialize model from prototxt and modelFile<br/>let net<br/>if (dataFile === 'coco300' || dataFile === 'coco512') {<br/>  net = cv.readNetFromCaffe(prototxt, modelFile)<br/>}</span></pre><p id="3f94" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">以防你忘记了。(对，我知道是全局的，应该传进去了)。</p><p id="e7ec" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，您会注意到前面函数中的最后一件事是提取结果:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="23d3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此时，您可以访问“索引”(与分类类别相关)、分类的“置信度”以及已识别对象的“矩形”区域。这些是我们的“预测”，然后进行过滤。</p><p id="b3c3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可能还记得上面的这段代码(作为复习):</p><pre class="mw mx my mz gt nm nn no np aw nq bi"><span id="e037" class="na lp iq nn b gy nr ns l nt nu">// write updated image with new name<br/>updateImage(imagePath, img, predictions)</span></pre><p id="3d68" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这样做的目的是用过滤后的预测向文件中写入一个新的图像，这样用户就可以看到对象及其置信度。有几个功能可以实现这一点:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="9033" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我不打算深入讨论这些函数，因为它们是非常普通的JavaScript(并且有很好的注释)。</p><h2 id="f616" class="na lp iq bd lq nb nc dn lu nd ne dp ly kn nf ng mc kr nh ni mg kv nj nk mk nl bi translated">警告</h2><p id="b3c1" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">你应该总是使用某种过滤。始终使用置信度。我一般用50，但30可能是我能出的最低价格。为什么？你问？因为事情是这样的:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9d0ee9f84dbb7e625d87529f506ced1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RUJLOqpzUCopD9kaCumUig.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">无置信度过滤分类</figcaption></figure><p id="4db5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果图像非常“繁忙”,你会得到很多分类。其中大部分是伪造的。大多数人都有信心级别&lt; 10. Try playing around with the confidence level. See what works best for you. Remember, this is the same image as the first image in this article (did I make you go back and look?)</p><h2 id="873c" class="na lp iq bd lq nb nc dn lu nd ne dp ly kn nf ng mc kr nh ni mg kv nj nk mk nl bi translated">Examples</h2><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/119d0100cab3f528117edec0351acc6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*z_yjt_u4v0HR9SrN5Knj6g.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Unclassified Train</figcaption></figure><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/ea589211a1f2deceea6237d1bbf07fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*d6hfuyY_Q5HOOWkfJh-IEg.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Classified Train</figcaption></figure><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/366a93e30e04f6aa1e9699019c613b38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n_59n7zLHl1gS4K-JBwYcg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Unclassified Royals</figcaption></figure><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/f8d650ff1ddcb2fdf319b2e551dbc32f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ibuTLpk1YxysxLD14WcCWA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Classified Royals</figcaption></figure><p id="2c33" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Show some teeth Harry! You might have been 100% a person. All jokes aside, this has been fun. I’m still in learning mode. And there’s a devilish amount to learn. I hope what I have written helps you on your path if you have the same interest.</p><p id="70a5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">The complete project can be found on <a class="ae mr" href="https://github.com/hawkeye64/classify" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p><blockquote class="od"><p id="1a29" class="oe of iq bd og oh oi oj ok ol om kz dk translated"><em class="on">这是我第二篇关于媒体的文章，也是我第一篇关于代码的大文章。如果你喜欢你所看到的，给我一些掌声，我以后会做得更多。感谢你花时间阅读我要说的话。</em></p></blockquote></div></div>    
</body>
</html>