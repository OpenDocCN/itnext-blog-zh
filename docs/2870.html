<html>
<head>
<title>Docker Swarm monitoring</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">码头工人群体监控</h1>
<blockquote>原文：<a href="https://itnext.io/docker-swarm-monitoring-4dfe88c72d56?source=collection_archive---------2-----------------------#2019-08-19">https://itnext.io/docker-swarm-monitoring-4dfe88c72d56?source=collection_archive---------2-----------------------#2019-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e086" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当运行<a class="ae kl" href="https://docs.docker.com/engine/swarm/" rel="noopener ugc nofollow" target="_blank"> Docker Swarm </a>和大量Docker节点和容器而不是单个Docker节点时，在正常运行时间和性能监控方面存在一些挑战。就单个节点指标而言，这不仅仅是集群功能的问题，也是部署的问题。</p><p id="b76f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇博文解释了如何设置Docker Swarm monitoring，如何部署和设置以下组件来收集尽可能多的重要指标:</p><ol class=""><li id="ce71" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">管理员</li><li id="d121" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">节点导出器</li><li id="9bd7" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">码头出口商</li></ol><p id="4efa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了收集所有的数据，我们还安装了一个<a class="ae kl" href="https://www.prometheus.io" rel="noopener ugc nofollow" target="_blank"> prometheus </a>服务。</p><p id="9034" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们运行一个3人的Docker Swarm集群，其设置如上一篇博文所述:</p><p id="079a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">【https://www.opvizor.com/install-and-use-docker-swarm T4】</p><p id="ba0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们不想使用docker服务命令运行所有容器，所以我们一步一步地构建docker-compose文件，以拥有一个完整的部署文件来启动我们的docker群集监控。</p><p id="deda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在部署任何监控组件时，重要的部分是它们需要在集群中的所有节点上运行，以允许完全可见性。</p><p id="c155" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们创建了跨节点网络和服务，并确保在需要时将它们部署在每个节点上(设置deploy: mode: <strong class="jp ir"> global </strong>)。</p><p id="d322" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们开始创建一个<strong class="jp ir"> docker-compose.stack.yml </strong>并创建覆盖网络(可跨节点访问)、一个用于我们未来的prometheus数据的卷、一个用于我们的prometheus的配置以及一个用于我们在最后创建的Dockerd服务的配置。</p><p id="170d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们使用Docker Swarm配置作为节点导出器的入口点脚本。这样，我们可以使用Stefan Prodan的智能方式来收集Swarm节点元数据，而无需更改容器映像本身(因此我们可以坚持使用总是更新的原始Prometheus节点导出器)。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="9d1a" class="lj lk iq lf b gy ll lm l ln lo">version: "3.3" <br/>networks: <br/>  net: <br/>  driver: overlay <br/>  attachable: true <br/>volumes: <br/>  prometheus: {} <br/>configs: <br/>  dockerd_config: <br/>    file: ./dockerd-exporter/Caddyfile <br/>  prom_conf: <br/>    file: ./prometheus/conf/prometheus.yml <br/>  node_exporter_entrypoint: <br/>    file: ./node-exporter/docker-entrypoint.sh <br/>services:</span></pre><h1 id="4c9f" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">部署cAdvisor</h1><p id="d493" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">cAdvisor(容器顾问)让容器用户了解他们正在运行的容器的资源使用和性能特征。它是一个正在运行的守护进程，收集、聚合、处理和导出关于正在运行的容器的信息。具体来说，对于每个容器，它保存资源隔离参数、历史资源使用、完整的历史资源使用直方图和网络统计。该数据按容器和机器范围导出。</p><p id="7122" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">cAdvisor拥有对Docker容器的本地支持，并且应该支持任何其他开箱即用的容器类型。我们努力争取全面的支持，因此如果情况不是这样，请随时提出问题。cAdvisor的容器抽象是基于<a class="ae kl" href="https://github.com/google/lmctfy" rel="noopener ugc nofollow" target="_blank"> lmctfy </a>的，所以容器本质上是分层嵌套的。</p><p id="0d73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您想了解更多关于cAdvisor的信息:</p><p id="0100" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">【https://github.com/google/cadvisor T4】</p><p id="ae3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将cadvisor服务添加到docker-compose.stack.yml中</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="4bd2" class="lj lk iq lf b gy ll lm l ln lo">cadvisor:<br/>    image: google/cadvisor<br/>    networks:<br/>      - net<br/>    command: -logtostderr -docker_only<br/>    volumes:<br/>      - /var/run/docker.sock:/var/run/docker.sock:ro<br/>      - /:/rootfs:ro<br/>      - /var/run:/var/run<br/>      - /sys:/sys:ro<br/>      - /var/lib/docker/:/var/lib/docker:ro<br/>    deploy:<br/>      mode: global<br/>      resources:<br/>        limits:<br/>          memory: 128M<br/>        reservations:<br/>          memory: 64M</span></pre><h1 id="f7f8" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">部署节点导出器</h1><p id="07f2" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">我们要添加的下一个服务是节点导出器，它公开了额外的指标。</p><p id="1281" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://hub.docker.com/r/prom/node-exporter/" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/r/prom/node-exporter/</a></p><p id="64a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们还没有创建将被加载到Docker Swarm配置中的入口点配置文件，所以我们现在需要创建它。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="03c6" class="lj lk iq lf b gy ll lm l ln lo">mkdir node-exporter <br/>vi docker-entrypoint.sh</span><span id="1d3d" class="lj lk iq lf b gy mr lm l ln lo"># file content:#<br/>#!/bin/sh -e</span><span id="c0ad" class="lj lk iq lf b gy mr lm l ln lo">NODE_NAME=$(cat /etc/nodename)<br/>echo "node_meta{node_id=\"$NODE_ID\", container_label_com_docker_swarm_node_id=\"$NODE_ID\", node_name=\"$NODE_NAME\"} 1" &gt; /home/node-meta.prom</span><span id="b20f" class="lj lk iq lf b gy mr lm l ln lo">set -- /bin/node_exporter "$@"</span><span id="382c" class="lj lk iq lf b gy mr lm l ln lo">exec "$@"</span></pre><p id="b2ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该脚本收集本地节点信息并创建一个元数据文件，该文件将由节点导出器服务获取，供Prometheus抓取:</p><p id="7e5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ms">collector . textfile . directory =/home/</em></p><p id="b457" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">稍后，Prometheus还将存储node_meta信息:</p><figure class="la lb lc ld gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mt"><img src="../Images/e25e3242ec471e7b0cad7addd864a6ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jb51cAsnVvIS9c_zC7YddA.png"/></div></div></figure><p id="a715" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们将节点导出器服务添加到您的docker-compose.stack.yml中(确保保持对齐，这样所有像cadvisor和exporter这样的服务都从相同的位置开始)。</p><p id="e9fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">重要提示:不要在yaml文件中使用制表符</strong></p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="1b1c" class="lj lk iq lf b gy ll lm l ln lo">node-exporter:<br/>    image: prom/node-exporter:latest<br/>    networks:<br/>      - net<br/>    volumes:<br/>      - /sys:/host/sys:ro<br/>      - /:/rootfs:ro<br/>      - /proc:/host/proc:ro<br/>      - /etc/hostname:/etc/nodename<br/>    configs:<br/>      - source: node_exporter_entrypoint<br/>        target: /docker-entrypoint.sh<br/>    deploy:<br/>      mode: global<br/>    environment:<br/>      - NODE_ID={{.Node.ID}}<br/>    command:<br/>      - '--path.procfs=/host/proc'<br/>      - '--path.rootfs=/rootfs'<br/>      - '--path.sysfs=/host/sys'<br/>      - '--collector.filesystem.ignored-mount-points=^/(sys|proc|dev|host|etc)($<br/>      - '--collector.textfile.directory=/home/'<br/>      - '--no-collector.ipvs'<br/>    entrypoint:<br/>       - /bin/sh<br/>       - /docker-entrypoint.sh</span></pre><h1 id="78b9" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">部署Dockerd导出程序</h1><p id="f9df" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">Docker守护程序导出程序也公开了Docker swarm metrics，这是启用该选项所必需的(实验性的),我们将使用一个特定的容器来公开我们的prometheus服务器的prometheus metrics。</p><p id="02b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/stefanprodan/dockerd-exporter" rel="noopener ugc nofollow" target="_blank">https://github.com/stefanprodan/dockerd-exporter</a></p><p id="f14f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最简单的方法是更改或创建文件<strong class="jp ir">/etc/docker/daemon . JSON</strong>，添加以下内容并重启docker服务。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="ba7a" class="lj lk iq lf b gy ll lm l ln lo">{<br/>  "metrics-addr" : "0.0.0.0:9323",<br/>  "experimental" : true<br/>}</span></pre><p id="d879" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要为我们的服务创建配置文件:</p><p id="6e88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">。/dockerd-exporter/caddy file</strong></p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="c653" class="lj lk iq lf b gy ll lm l ln lo">:9323 {<br/>    proxy / {$DOCKER_GWBRIDGE_IP}:9323 {<br/>            transparent<br/>        }</span><span id="2ce7" class="lj lk iq lf b gy mr lm l ln lo">errors stderr<br/>    tls off<br/>}</span></pre><p id="12e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们可以添加Caddy服务，向我们的Prometheus服务发现公开端口9323指标。在添加它之前，确保您的docker网关桥反映了服务描述中的IP地址。因此，请运行以确保其为示例中的172.18.0.1，或者相应地更改该值:</p><p id="8e93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> docker run -rm -net主机alpine IP-o addr show docker _ GW bridge</strong></p><p id="75dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将dockerd exporter服务添加到docker-compose.stack.yml中</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="93e3" class="lj lk iq lf b gy ll lm l ln lo">dockerd-exporter:<br/>    image: stefanprodan/caddy<br/>    networks:<br/>      - net<br/>    environment:<br/>      - DOCKER_GWBRIDGE_IP=172.18.0.1<br/>    configs:<br/>      - source: dockerd_config<br/>        target: /etc/caddy/Caddyfile<br/>    deploy:<br/>      mode: global<br/>      resources:<br/>        limits:<br/>          memory: 128M<br/>        reservations:<br/>          memory: 64M</span></pre><h1 id="4e25" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">部署普罗米修斯</h1><p id="8fe2" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">既然所有需要的导出器服务都在我们的docker-compose文件中，现在让我们添加Prometheus服务器来完成收集器代理和服务部分。</p><p id="41fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要确保在prometheus/conf目录中有一个有效的prometheus.yml配置。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="7c5a" class="lj lk iq lf b gy ll lm l ln lo">global:<br/>  scrape_interval:     15s<br/>  evaluation_interval: 15s</span><span id="bc21" class="lj lk iq lf b gy mr lm l ln lo">external_labels:<br/>    monitor: 'prommon'</span><span id="2f73" class="lj lk iq lf b gy mr lm l ln lo">scrape_configs:<br/>  - job_name: 'prometheus'<br/>    static_configs:<br/>      - targets: ['localhost:9090']</span><span id="1888" class="lj lk iq lf b gy mr lm l ln lo">- job_name: 'dockerd-exporter'<br/>    dns_sd_configs:<br/>    - names:<br/>      - 'tasks.dockerd-exporter'<br/>      type: 'A'<br/>      port: 9323</span><span id="8ca2" class="lj lk iq lf b gy mr lm l ln lo">- job_name: 'cadvisor'<br/>    dns_sd_configs:<br/>    - names:<br/>      - 'tasks.cadvisor'<br/>      type: 'A'<br/>      port: 8080</span><span id="8294" class="lj lk iq lf b gy mr lm l ln lo">- job_name: 'node-exporter'<br/>    dns_sd_configs:<br/>    - names:<br/>      - 'tasks.node-exporter'<br/>      type: 'A'<br/>      port: 9100</span></pre><p id="3ee2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们需要将Prometheus服务添加到Docker Swarm Monitoring stack我们的docker-compose.stack.yml文件中。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="57be" class="lj lk iq lf b gy ll lm l ln lo">prometheus:<br/>    image: prom/prometheus<br/>    networks:<br/>      - net<br/>    ports:<br/>      - "9090:9090"<br/>    command:<br/>      - '--config.file=/etc/prometheus/prometheus.yml'<br/>      - '--storage.tsdb.path=/prometheus'<br/>      - '--storage.tsdb.retention=${PROMETHEUS_RETENTION:-24h}'<br/>    volumes:<br/>      - prometheus:/prometheus<br/>    configs:<br/>      - source: prom_conf<br/>        target: /etc/prometheus/prometheus.yml<br/>    deploy:<br/>      mode: replicated<br/>      replicas: 1<br/>      placement:<br/>        constraints:<br/>          - node.role == manager<br/>      resources:<br/>        limits:<br/>          memory: 2048M<br/>        reservations:<br/>          memory: 128M</span></pre><figure class="la lb lc ld gt mu gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/bfb14b082c0a404c008e2c65e6ac40fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/0*UG3JQKzRrutii7eO.png"/></div></figure><p id="169d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以作为一个名为docker-swarm-monitor的堆栈同时启动一切:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="205b" class="lj lk iq lf b gy ll lm l ln lo">docker stack deploy -c docker-compose.stack.yml docker-swarm-monitor</span></pre><figure class="la lb lc ld gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nc"><img src="../Images/48172aad46c0b13c39d7aa6a8be836a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YqA-R9H5i8uk8LCtMdPong.png"/></div></div></figure><p id="b4fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用<strong class="jp ir"> docker stack ls </strong>和<strong class="jp ir"> docker service ls </strong>来检查堆栈和服务</p><p id="eea7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要删除我们的部署，只需运行<strong class="jp ir">docker stack RM docker-swarm-monitor</strong></p><p id="9dbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您遇到任何服务无法启动的问题，建议您首先检查日志。最简单的方法是使用服务名，即<strong class="jp ir">docker service logs-f docker-swarm-monitor-Prometheus</strong></p><p id="13b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">特别是当从网站上复制/粘贴文件时，格式会变得混乱。</p><h1 id="fd42" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">普罗米修斯刮削术</h1><p id="5ecf" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">现在一切都已经设置好了，服务已经开始了。接下来要检查的是Prometheus的自动抓取，因此正在收集指标。只需访问端口9090上的Swarm集群ip:</p><figure class="la lb lc ld gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nd"><img src="../Images/77a0b4d5854593ec6abbc373f751165a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KZVllSoqagTqepou_A2TbQ.png"/></div></div></figure><p id="79b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果数据真的存在，创建一个简单的普罗米修斯图</p><figure class="la lb lc ld gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ne"><img src="../Images/5984132a11bf094f21881807041a65a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ww5daFhAcEJ3E50STzhltw.png"/></div></div></figure><h1 id="7501" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">形象化</h1><p id="05f7" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">下一步是运行一个<a class="ae kl" href="https://www.grafana.com" rel="noopener ugc nofollow" target="_blank"> Grafana </a>服务，并导入或创建仪表板。</p><p id="49fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您运行Performance Analyzer，您只需连接您的Prometheus数据源，并向我们询问要导入的仪表板。</p><figure class="la lb lc ld gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nf"><img src="../Images/ff6361ea6666f3ae6e1d3a84aea63226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DIiL4hmTaOV9lPojnlX3Ew.png"/></div></div></figure><figure class="la lb lc ld gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nf"><img src="../Images/7844ed34cb0a96bd1a9af187b6f1e4ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uUi0BKBLkb01H68qg2SRaQ.png"/></div></div></figure><p id="90b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">整个项目也可以在github上找到，所以你可以用一个简单的docker stack命令直接开始并运行一个完整的Docker Swarm monitoring stack，而不是复制这里的例子。只是做一个</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="451f" class="lj lk iq lf b gy ll lm l ln lo">git clone <a class="ae kl" href="https://github.com/opvizordz/docker-swarm-monitor.git" rel="noopener ugc nofollow" target="_blank">https://github.com/opvizordz/docker-swarm-monitor.git</a><strong class="lf ir"><br/></strong>docker stack deploy -c docker-compose.stack.yml docker-swarm-monitor</span></pre></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="d5d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ms">原载于2019年8月19日</em><a class="ae kl" href="https://www.opvizor.com/docker-swarm-monitoring" rel="noopener ugc nofollow" target="_blank"><em class="ms">https://www.opvizor.com</em></a><em class="ms">。</em></p></div></div>    
</body>
</html>