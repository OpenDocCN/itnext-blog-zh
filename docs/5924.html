<html>
<head>
<title>Golang Pipeline in Practise</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实践中的戈朗管道</h1>
<blockquote>原文：<a href="https://itnext.io/golang-pipeline-in-practise-6007dafbb85f?source=collection_archive---------2-----------------------#2021-06-30">https://itnext.io/golang-pipeline-in-practise-6007dafbb85f?source=collection_archive---------2-----------------------#2021-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ebfa9731c15b78e43306b00575b55576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yvF_zmW67CBtTjhT.png"/></div></div></figure><p id="a053" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我有一个请求，执行一些关键字的谷歌API搜索，并将结果(网址)保存到文本文件中。这是使用Go的并发模式来组装管道的好机会，因此，并行化IO和CPU。</p><h2 id="a993" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">谷歌搜索API</h2><p id="243f" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">给定一个关键词，比方说一个类别，下面的函数使用<a class="ae lx" href="https://github.com/go-resty/resty" rel="noopener ugc nofollow" target="_blank"> go-resty </a>调用Google search API，然后使用<a class="ae lx" href="https://github.com/tidwall/gjson" rel="noopener ugc nofollow" target="_blank"> gjson </a>库从结果中选取相应的链接。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="c9c9" class="kz la it md b gy mh mi l mj mk">func SearchGoogle(category string, count int) ([]SearchResult, error) {<br/> results := []SearchResult{}<br/> // <em class="ml">... skip some initial assignment</em><br/> for i := 0; i &lt; pages; i++ {<br/>  resp, err := client.R().<br/>   SetQueryParams(map[string]string{<br/>    "cx":  cx,<br/>    "key": key,<br/>    "q":   category,<br/>    "start": fmt.Sprintf("%d", i*10+1)<br/>   }).<br/>   SetHeader("Accept", "application/json").<br/>   Get("https://www.googleapis.com/customsearch/v1")</span><span id="ef3d" class="kz la it md b gy mm mi l mj mk">  //... <em class="ml">skip the error handling part</em> </span><span id="5e70" class="kz la it md b gy mm mi l mj mk">  content := resp.Body()<br/>  if resp.StatusCode() != 200 {<br/>   logrus.Errorf("staus code is non 200, code:%v", resp.StatusCode())<br/>   return results, err<br/>  }<br/>  gjson.GetBytes(content, "items").ForEach(func(_, elm gjson.Result) bool {<br/>   counter += 1<br/>   title := elm.Get("title").String()<br/>   link := elm.Get("link").String()<br/>   snippet := elm.Get("snippet").String()<br/>   <br/>   results = append(results, SearchResult{<br/>    Category: category,<br/>    Title:    title,<br/>    Link:     link,<br/>    Snippet:  snippet,<br/>   })<br/>   return true //keep looping<br/>  })<br/> }<br/> return results, nil<br/>}</span></pre><p id="8403" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们读取关键字来搜索一段字符串。让我们用通道建立golang管道。</p><h2 id="4bad" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">数据馈送</h2><p id="fa0f" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">要启动管道，接收一段字符串并输出一个字符串通道。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="b8b0" class="kz la it md b gy mh mi l mj mk">func Feed(list []string) chan string {<br/> out := make(chan string)<br/> go func() {<br/>  for _, v := range list {<br/>   out &lt;- v<br/>  }<br/>  close(out)<br/> }()</span><span id="5080" class="kz la it md b gy mm mi l mj mk"> return out<br/>}</span></pre><p id="d446" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，创造“出”禅。然后创建一个goroutine来遍历关键字列表，将它发送到输出通道。一旦循环完成，关闭输出通道以通知接收端，它关闭了。</p><p id="1e48" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，除非管道已连接并正在移动，否则发送到通道的操作会被阻塞。这就是为什么我们实际上需要运行它作为一个goroutine。</p><h2 id="35bc" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">搜索</h2><p id="5d4e" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">在数据馈送之后，我们为搜索构造动作。常见的模式是，用一个输入通道拾取输入，构造一个输出通道，处理数据并将结果发送到输出通道，并将输出返回给管道组件。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="cefb" class="kz la it md b gy mh mi l mj mk">func Search(worker int, in chan string) chan []SearchResult {<br/> out := make(chan []SearchResult)</span><span id="e2d7" class="kz la it md b gy mm mi l mj mk"> go func() {<br/>  for text := range in {<br/>   result, err := SearchGoogle(text, 100)<br/>   if err != nil {<br/>    logrus.Errorf("Failed to search: %v", text)<br/>    return<br/>   }<br/>   out &lt;- result<br/>  }</span><span id="247e" class="kz la it md b gy mm mi l mj mk">  close(out)<br/> }()</span><span id="e4cc" class="kz la it md b gy mm mi l mj mk"> return out<br/>}</span></pre><p id="9750" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在<code class="fe mn mo mp md b"><em class="ml">in</em></code>通道上执行范围循环，一旦<code class="fe mn mo mp md b"><em class="ml">in</em></code>通道关闭，范围循环将停止，我们相应地关闭输出通道。对于从通道中获取的每个文本，运行SearchGoogle()，并将结果发送到输出通道。</p><p id="0044" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">工人参数只是工人的一个指标。</p><h2 id="bb9c" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">扇出</h2><p id="e5dd" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">为了并行搜索，我们使用扇出模式。基本上，在管道上，接收一个输入通道，输出一系列通道。看看这个。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="a22f" class="kz la it md b gy mh mi l mj mk">func Fanout(workers int, ch chan string) []chan []SearchResult {<br/> chs := []chan []SearchResult{}<br/> for i := 0; i &lt; workers; i++ {<br/>  chs = append(chs, Search(i, ch))<br/> }<br/> return chs<br/>}</span></pre><p id="45c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在函数中，为SearchResult切片构造一个通道切片。注意，Search函数用于返回SearchResult的一个通道。</p><h2 id="3e15" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">扇入</h2><p id="1f3a" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">在搜索分支之后，现在我们需要使用扇入模式来合并结果。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="c6bf" class="kz la it md b gy mh mi l mj mk">func Fanin(chans []chan []SearchResult) chan SearchResult {<br/> out := make(chan SearchResult)</span><span id="f636" class="kz la it md b gy mm mi l mj mk"> var wg sync.WaitGroup<br/> wg.Add(len(chans))</span><span id="4344" class="kz la it md b gy mm mi l mj mk"> for _, ch := range chans {<br/>  go func(c chan []SearchResult) {<br/>   for list := range c {<br/>    for _, v := range list {<br/>     out &lt;- v<br/>    }<br/>   }</span><span id="6851" class="kz la it md b gy mm mi l mj mk">   wg.Done()<br/>  }(ch)<br/> }</span><span id="e49b" class="kz la it md b gy mm mi l mj mk"> go func() {<br/>  wg.Wait()<br/>  close(out)<br/> }()</span><span id="40c1" class="kz la it md b gy mm mi l mj mk"> return out<br/>}</span></pre><p id="51ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与common模式相同，该函数接受一部分通道，但返回一个通道。这里引入Waitgroup是为了确保所有的扇出通道都完成它们的工作。</p><p id="8b4d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">循环通过输入通道片，在输出通道上发送结果。注意，为了避免在for循环中运行goroutine的常见缺陷，我们将通道作为参数传递给goroutine函数。</p><p id="1d22" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">扇出通道上的范围环路完成后，标记工作组完成。</p><p id="1f5e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在另一个goroutine之外，等待所有扇出通道完成，并关闭输出通道。</p><h2 id="8dd9" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">救援</h2><p id="acf7" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">最后，我们使用<a class="ae lx" href="https://github.com/gocarina/gocsv" rel="noopener ugc nofollow" target="_blank"> gocsv </a>模块将搜索结果保存到一个CSV文件中。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="e787" class="kz la it md b gy mh mi l mj mk">func Save(filename string, in chan SearchResult, done chan struct{}) {<br/> csvFile, err := os.OpenFile("results.csv", os.O_RDWR|os.O_CREATE, os.ModePerm)<br/> if err != nil {<br/>  logrus.Fatalf("Failed to open results file:%v", err)<br/> }</span><span id="17c0" class="kz la it md b gy mm mi l mj mk"> go func() {<br/>  for result := range in {<br/>   list := []SearchResult{result}<br/>   bf := bytes.NewBufferString("")<br/>   err := gocsv.MarshalCSVWithoutHeaders(&amp;list, gocsv.NewSafeCSVWriter(csv.NewWriter(bf)))<br/>   if err != nil {<br/>    logrus.Errorf("Failed to marshal results into csv:%v", err)<br/>   }</span><span id="9ac9" class="kz la it md b gy mm mi l mj mk">   csvFile.WriteString(bf.String())<br/>  }</span><span id="c604" class="kz la it md b gy mm mi l mj mk">  csvFile.Close()   <br/>  done &lt;- struct{}{}<br/>  <br/> }()</span><span id="d830" class="kz la it md b gy mm mi l mj mk">}</span></pre><p id="3047" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">gocsv与自定义编写器一起使用，忽略从通道中获取的每个结果的头。</p><p id="8afb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">传入一个<code class="fe mn mo mp md b">done</code>通道来表示所有工作都已完成。</p><h2 id="963b" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">装配</h2><p id="53cd" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">在主函数中组装管道的时间，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="9b75" class="kz la it md b gy mh mi l mj mk">catList := []string{}<br/>//skip the reading and populating for the catList</span><span id="38de" class="kz la it md b gy mm mi l mj mk">done := make(chan struct{})<br/>Save("results.csv",<strong class="md iu"> Fanin(Fanout(5, Feed(catList)))</strong>, done)</span><span id="869f" class="kz la it md b gy mm mi l mj mk">for {<br/>  select {<br/>  case &lt;-done:<br/>   logrus.Infof("done")<br/>   os.Exit(0)<br/>  }<br/> }</span></pre><p id="d49f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于仔细定义了管道函数的输入/输出，所以组装相对容易，尽管与其他语言相比可能不那么优雅；)</p><p id="ea35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mn mo mp md b"> for and select</code>回路用于等待保存完成的信号。</p></div></div>    
</body>
</html>