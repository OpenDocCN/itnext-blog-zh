<html>
<head>
<title>Wrapping and truncating chart labels in NVD3 horizontal bar charts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在NVD3水平条形图中换行和截断图表标签</h1>
<blockquote>原文：<a href="https://itnext.io/wrapping-and-truncating-chart-labels-in-nvd3-horizontal-bar-charts-b5867a7775e6?source=collection_archive---------4-----------------------#2018-08-21">https://itnext.io/wrapping-and-truncating-chart-labels-in-nvd3-horizontal-bar-charts-b5867a7775e6?source=collection_archive---------4-----------------------#2018-08-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/264a7e76f30213e9f4811e79f54976bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mDFBuLfGsxzEvGCqiTpgHw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我的数据中有一些非常非常非常非常长的图表标签</figcaption></figure><p id="01f2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你的水平条形图标签对于你的左边距来说太长，默认情况下，在NVD3中标签会溢出空间，消失在左边，这很烦人，看起来也不专业。在这些图表中，垂直轴标签的空间非常宝贵，因此要做好工作，仅实现单词级换行是不够的，我们需要合并断字换行和标签截断。</p><p id="08c4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这些标签的空间有限的原因之一是试图让你的水平条围绕一个文本行的高度。在这种情况下，标签包装并不能拯救你(虽然截断可以)。我建议在处理具有长标签的数据时，你也可以考虑增加条形的粗细来适应，我认为这样做的好处是可以得到更好看、更用户友好的图表。</p><p id="ebc8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这篇文章描述了一种算法，可以用于NVD3，实际上是任何基于SVG的显示，获取一个长字符串，包装它(如果需要，使用连字符)并在空间用完时截断它。</p><p id="5d44" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">(注意<a class="ae la" href="https://bl.ocks.org/mbostock/7555321" rel="noopener ugc nofollow" target="_blank"> Mike Bostock有一个包装解决方案</a>,虽然它在单词级包装，不截断；下面的算法使用了类似的概念和扩展。在NVD3中，离散条形图上还有一个<code class="fe lb lc ld le b">wrapLabels:true</code>选项(我假设使用了Mike的解决方案)，但在水平多条条形图上没有</p><h1 id="3ad2" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">该方法</h1><p id="e4c8" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">在我们进入代码之前，让我们考虑一下我们将要采取的整体方法。</p><p id="b48e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以从将最大数量的文本放入一个具有一定宽度和高度的框中的角度来考虑这个问题。该框中到底能容纳多少文本取决于文本大小、行高，以及(如果使用可变宽度的字体)具体包含哪些字母。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/6291b9c3278b22f8a9d09a239302a798.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aefqDPUnIzt8KIq6upSzlA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我们可以在一个框中放多少文字，也就是你的边距宽度和你的栏高度？</figcaption></figure><p id="11de" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以通过分别攻击横向和纵向来解决问题:</p><p id="0b7c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，<strong class="ke ir"> <em class="mn">将文本分成几行</em> </strong>以适应水平方向的可用空间。第二，<strong class="ke ir"> <em class="mn">垂直分布</em> </strong>文本(即把所有的行按顺序一行一行地放在另一行上面)，并确定它们是否适合这个框。最后，<strong class="ke ir"> <em class="mn">减少</em> </strong>文本行的数量，直到那些行仍然适合这个框。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/bcae89f04103da24c3165c96d3263732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6svzzNIftI9pchk6i2wlwQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">垂直溢出的文本需要减少，直到适合可用空间</figcaption></figure><p id="0c53" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了最大限度地利用有限的空间，我们想要包括的一个关键细节是尽可能地用连字符连接单词。不幸的是，断字看起来并不总是正确的——例如，你不想在单词的第一个或两个字母后断字。此外，断字在文本中引入了一个新字符，这需要在宽度计算中加以考虑，所以你不能只是在一行的末尾加上一个连字符来打断一个单词。</p><p id="487e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面是一个流程图，定义了一个可行的、水平间距最大化的断字规则:</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/2052f180360051ab39c67c8995b5ddea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gDoV_q-C8PI3rQswZ1UT7A.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">一种以相当用户友好的方式用连字符连接单词的算法</figcaption></figure><p id="7037" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">它是这样工作的:在我们的水平空格的末端，如果我们发现自己在一个单词的中间，找出它是多少个字母回到前一个单词的分隔符。如果到单词break的距离小于某个最小限制，那么我们不尝试断字，我们只是回溯到单词的开头并在那里断开。这防止我们做像“m-e”或“yo-u”这样看起来很奇怪的事情。我们会将最小值设置为3左右。</p><p id="2e7f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">另一方面，如果到单词break的距离大于这个最小值，那么我们应该尝试使用连字符。我们这样做是通过回溯一个字母，然后添加一个连字符。现在我们需要检查这一行是否仍然水平合适，以防连字符比它所替换的字母更宽。</p><p id="524e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果这条线合适，我们就完成了！否则，我们删除连字符，并保持回溯+连字符，直到该行适合所提供的空间。如果我们到达单词开头剩余的字母数低于最小值的点，我们就在单词边界换行。</p><p id="d4b4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个算法是我发现的最简单的断字策略，它为高度受限的空间提供了合理的结果。在现实中，断字是复杂的，在排版中甚至有关于在哪里划分不同种类的单词的规则(比如，在音节边界)，这对我们来说太复杂了。还有，我们的算法只考虑单词的开头看起来对不对，不关心单词的结尾。因此，我们可以看到像“long-g”或“joi-n”这样的包装，开始很好，但结束很奇怪。我们将暂时忽略这一点，因为修复它会降低水平空间的使用效率。</p><h1 id="ea23" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">代码</h1><p id="cb2e" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">完整的功能可以在这篇文章的底部找到。我们将逐步介绍重要的部分，这样您就可以看到它是如何工作的。</p><p id="39de" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将把它作为一个单独的函数来做，在它里面定义了其他函数。我们将传入一堆定义环境的参数(闭包)。</p><pre class="mj mk ml mm gt mo le mp mq aw mr bi"><span id="c65e" class="ms lg iq le b gy mt mu l mv mw">function wrapLabels(params) {<br/>    var axisSelector = params.axisSelector;<br/>    var maxWidth = params.maxWidth;<br/>    var maxHeight = params.maxHeight;<br/>    var lineHeight = params.lineHeight || 1.2;<br/>    var wordBreaks = params.wordBreaks || [" ", "\t"];<br/>    var minChunkSize = params.minChunkSize || 3;</span><span id="ac6a" class="ms lg iq le b gy mx mu l mv mw">    // implementation goes here<br/>}</span></pre><ul class=""><li id="7c31" class="my mz iq ke b kf kg kj kk kn na kr nb kv nc kz nd ne nf ng bi translated"><strong class="ke ir"> axisSelector </strong> —一个选择器字符串，d3可以使用它来选择我们要包装标签的轴。</li><li id="8188" class="my mz iq ke b kf nh kj ni kn nj kr nk kv nl kz nd ne nf ng bi translated"><strong class="ke ir"> maxWidth </strong> —文本框需要容纳的最大宽度。这可能等于你给条形图的左边距</li><li id="49c2" class="my mz iq ke b kf nh kj ni kn nj kr nk kv nl kz nd ne nf ng bi translated"><strong class="ke ir"> maxHeight </strong> —文本框需要容纳的最大高度。这可能等于钢筋的厚度</li><li id="5e8b" class="my mz iq ke b kf nh kj ni kn nj kr nk kv nl kz nd ne nf ng bi translated"><strong class="ke ir">行高</strong> —您想要使用的行高，它定义了文本行之间所需的间距</li><li id="2f45" class="my mz iq ke b kf nh kj ni kn nj kr nk kv nl kz nd ne nf ng bi translated"><strong class="ke ir">断字符</strong> —你认为是单词间断点的字符列表。我们在这里默认为空格和制表符。</li><li id="cbda" class="my mz iq ke b kf nh kj ni kn nj kr nk kv nl kz nd ne nf ng bi translated"><strong class="ke ir"> minChunkSize </strong> —断词时连字符前允许的最小字母数。</li></ul><p id="48cf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦我们以通常的方式使用NVD3绘制了图表，我们就可以应用包装作为后期渲染修改。为此，我们需要获取每个轴标签并对其执行转换。我们将完全按照上面的描述来分解算法:分离、分布、减少:</p><pre class="mj mk ml mm gt mo le mp mq aw mr bi"><span id="6f80" class="ms lg iq le b gy mt mu l mv mw">d3.selectAll(axisSelector + " .tick text").each(function(i, e) {<br/>    var text = d3.select(this);<br/>    var tspans = <em class="mn">separate</em>(text);<br/>    do {<br/>        <em class="mn">distribute</em>(text, tspans);<br/>    }<br/>    while (<em class="mn">reduce</em>(text, tspans))<br/>});</span></pre><p id="8da2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们获取每个标签的文本，并使用我们的<em class="mn">单独的</em>函数将其转换成一个<code class="fe lb lc ld le b">tspan</code>对象列表。然后我们<em class="mn">垂直分布</em>这些<code class="fe lb lc ld le b">tspans</code>，然后应用<em class="mn"> reduce </em>函数，如果我们缩小了文本，则返回<code class="fe lb lc ld le b">true</code>，如果文本现在合适，则返回<code class="fe lb lc ld le b">false</code>。</p><h2 id="2419" class="ms lg iq bd lh nm nn dn ll no np dp lp kn nq nr lt kr ns nt lx kv nu nv mb nw bi translated">不同的</h2><p id="bc65" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">分隔文本是最复杂的功能，因为它涉及到连字符。</p><p id="785e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们正在定义一个函数，它采用轴标签的<code class="fe lb lc ld le b">text</code>节点:</p><pre class="mj mk ml mm gt mo le mp mq aw mr bi"><span id="788f" class="ms lg iq le b gy mt mu l mv mw">function separate(text) { ... }</span></pre><p id="9375" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，我们获取文本内容作为一个字符数组，然后用一个<code class="fe lb lc ld le b">tspan</code>替换文本内容，我们可以用它来检查文本宽度:</p><pre class="mj mk ml mm gt mo le mp mq aw mr bi"><span id="6091" class="ms lg iq le b gy mt mu l mv mw">var chars = text.text().trim().split("");<br/>text.text(null);<br/>var x = text.attr("x");<br/>var tspan = text.append("tspan").attr("x", x).attr("y", 0);</span></pre><p id="6460" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们要遍历这个<code class="fe lb lc ld le b">chars</code>数组，构建每一行，直到它填满，并应用我们的断字算法:</p><pre class="mj mk ml mm gt mo le mp mq aw mr bi"><span id="0b10" class="ms lg iq le b gy mt mu l mv mw">var lines = [];<br/>var currentLine = [];</span><span id="d589" class="ms lg iq le b gy mx mu l mv mw">while (chars.length &gt; 0) {<br/>    var char = chars.shift();<br/>    ...<br/>}</span></pre><p id="9a3c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们创建了两个注册表——一个记录<code class="fe lb lc ld le b">lines</code>的列表，另一个记录<code class="fe lb lc ld le b">currentLine</code>的进度。然后我们执行一个循环，直到<code class="fe lb lc ld le b">chars</code>数组为空。我们不能通过<code class="fe lb lc ld le b">chars</code>数组进行for-each，因为我们将在该数组中向前和向后跟踪，所以我们不必每次迭代只消耗一个字符。然后，我们的第一个动作是从数组前面删除第一个字符。</p><p id="e2ce" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下一步很简单，只需将第一个<code class="fe lb lc ld le b">char</code>添加到<code class="fe lb lc ld le b">currentLine</code>中，并将<code class="fe lb lc ld le b">currentLine</code>放入<code class="fe lb lc ld le b">tspan</code>中:</p><pre class="mj mk ml mm gt mo le mp mq aw mr bi"><span id="fbe9" class="ms lg iq le b gy mt mu l mv mw">currentLine.push(char);<br/>tspan.text(currentLine.join(""));</span></pre><p id="9e28" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们检查该行是否合适，如果不合适，就调整它并处理断字。我们将看看整个事情，然后在下面讨论它:</p><pre class="mj mk ml mm gt mo le mp mq aw mr bi"><span id="fd70" class="ms lg iq le b gy mt mu l mv mw">var maxed = false;<br/>var hyphenated = false;<br/>while(_isTooLong(tspan)) {<br/>    maxed = true;</span><span id="616e" class="ms lg iq le b gy mx mu l mv mw">    if (hyphenated) {<br/>        currentLine.splice(currentLine.length - 1);<br/>        hyphenated = false;<br/>    }</span><span id="1821" class="ms lg iq le b gy mx mu l mv mw">    _backtrack(1, currentLine, chars);</span><span id="dc56" class="ms lg iq le b gy mx mu l mv mw">    if (_isMidWord(currentLine, chars)) {<br/>        var toPrevSpace = _toPrevSpace(currentLine);</span><span id="fcc4" class="ms lg iq le b gy mx mu l mv mw">        if (toPrevSpace === -1 || toPrevSpace - 1 &gt; minChunkSize) {<br/>            _backtrack(1, currentLine, chars);<br/>            currentLine.push("-");<br/>            hyphenated = true;<br/>        } else {<br/>            _backtrack(toPrevSpace, currentLine, chars);<br/>        }<br/>    }</span><span id="e9ca" class="ms lg iq le b gy mx mu l mv mw">    currentLine = currentLine.join("").trim().split("");<br/>    tspan.text(currentLine.join(""));<br/>}</span></pre><p id="25e0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们从一个问题开始:这条线是不是太长了？如果不是，这些代码都不会执行，并且继续消耗<code class="fe lb lc ld le b">chars</code>数组，直到行<em class="mn">变得</em>过长。</p><p id="ab9f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">暂时忽略<code class="fe lb lc ld le b">maxed</code>和<code class="fe lb lc ld le b">hyphenated</code>，接下来发生的事情是我们<strong class="ke ir">回溯</strong> 1字符。这将从<code class="fe lb lc ld le b">currentLine</code>中删除最后一个字符，并将其放回<code class="fe lb lc ld le b">chars</code>。</p><p id="fdf1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们问另一个问题:我们正处于一个词的中间吗？如果没有，则更新<code class="fe lb lc ld le b">currentLine</code>和<code class="fe lb lc ld le b">tspan</code>(在循环的最后两行中)，然后循环将在下一次迭代时终止，因为该行不再太长。如果我们不想用连字符连接，这就足够了——我们会用我们的<code class="fe lb lc ld le b">chars</code>数组中的字符填充整行。</p><p id="dd64" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我们<em class="mn">在一个单词的中间</em>，那么应用我们的断字算法:首先计算出它离前面的空格有多远。如果我们在找到空格之前到达文本的开头，这可能是<code class="fe lb lc ld le b">-1</code>，或者如果我们找到空格，这可能是某个数字。</p><p id="38b3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果这个数字小于我们的<code class="fe lb lc ld le b">minChunkSize</code>，我们将不使用连字符(否则我们会以类似“m-e”的文本结束)，所以我们<strong class="ke ir">回溯</strong>到单词的开头并在那里结束。</p><p id="1a72" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">否则，我们<strong class="ke ir">回溯</strong> 1字符，插入“-”并继续，注意我们将绊网<code class="fe lb lc ld le b">hyphenated</code>设置为<code class="fe lb lc ld le b">true</code>。这将在循环的下一次迭代中发挥作用。如果我们将<code class="fe lb lc ld le b">hyphenated</code>设置为<code class="fe lb lc ld le b">true</code>开始循环，那么我们要做的第一件事就是在继续之前删除最后一个字符(连字符)。这处理了连字符比它所替换的字符更宽的可能性，并允许我们回溯尽可能多的字母，以使行适合于<code class="fe lb lc ld le b">tspan</code>。</p><p id="b047" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这完全实现了我们上面的断字算法。除了<code class="fe lb lc ld le b">_isTooLong</code>之外，我不会详细介绍这里使用的其他函数，因为它包含了如何进行宽度检查的关键细节。函数如下:</p><pre class="mj mk ml mm gt mo le mp mq aw mr bi"><span id="20b4" class="ms lg iq le b gy mt mu l mv mw">function <em class="mn">_isTooLong</em>(tspan) {<br/>    return tspan.node().getComputedTextLength() &gt;= maxWidth<br/>}</span></pre><p id="5df7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">它在<code class="fe lb lc ld le b">tspan</code>节点上使用<code class="fe lb lc ld le b">getComputedTextLength</code>，并确定它是否比某个指定的(在本例中是闭包)<code class="fe lb lc ld le b">maxWidth</code>更宽。这是我们必须确定文本是否溢出空间的方法，因为我们只能计算DOM元素的宽度，我们不能在文本进入DOM之前计算它的宽度。</p><p id="e631" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们以一些终止条件结束了对<code class="fe lb lc ld le b">chars</code>数组的循环:</p><pre class="mj mk ml mm gt mo le mp mq aw mr bi"><span id="5dc7" class="ms lg iq le b gy mt mu l mv mw">if (!maxed &amp;&amp; chars.length &gt; 0) {<br/>    continue;<br/>}</span><span id="8a47" class="ms lg iq le b gy mx mu l mv mw">if (maxed || chars.length === 0) {<br/>    lines.push(currentLine);<br/>    currentLine = [];<br/>}</span></pre><p id="8700" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我们还没有达到极限，并且还有角色可以消耗，那么继续。如果我们确实用完了数组，或者没有剩余的字符要消耗，那么将<code class="fe lb lc ld le b">currentLine</code>记录在列表<code class="fe lb lc ld le b">lines</code>中，并将<code class="fe lb lc ld le b">currentLine</code>重置为空，准备好填充下一行字符。</p><p id="bee3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们现在跳出<code class="fe lb lc ld le b">chars</code>数组上的while循环，并构造完整的<code class="fe lb lc ld le b">tspans</code>列表以返回给调用者。</p><pre class="mj mk ml mm gt mo le mp mq aw mr bi"><span id="9b21" class="ms lg iq le b gy mt mu l mv mw">while (chars.length &gt; 0) {<br/>    var char = chars.shift();<br/>    // see above for detail...<br/>}</span><span id="73c0" class="ms lg iq le b gy mx mu l mv mw">tspan.remove();<br/>var tspans = [];<br/>for (var i = 0; i &lt; lines.length; i++) {<br/>    tspan = text.append("tspan").attr("x", x).attr("y", 0);<br/>    tspan.text(lines[i].join(""));<br/>    tspans.push(tspan);<br/>}</span><span id="d77e" class="ms lg iq le b gy mx mu l mv mw">return tspans;</span></pre><p id="256b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请注意，我们删除了在这里创建的原始的<code class="fe lb lc ld le b">tspan</code>——我们只是使用该元素来测量文本的宽度，所以一旦我们有了行列表，我们就清理它并重新开始。</p><h2 id="7da8" class="ms lg iq bd lh nm nn dn ll no np dp lp kn nq nr lt kr ns nt lx kv nu nv mb nw bi translated">分配</h2><p id="08b8" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">现在我们有了一组包含文本的<code class="fe lb lc ld le b">tspan</code>元素，它们水平地适合所提供的空间，我们可以考虑文本是否垂直适合。</p><p id="3755" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的<em class="mn">独立的</em>函数将它创建的<code class="fe lb lc ld le b">tspans</code>与它替换的<code class="fe lb lc ld le b">text</code>的原始<code class="fe lb lc ld le b">x</code>位置对齐，但是它将<code class="fe lb lc ld le b">y</code>设置为<code class="fe lb lc ld le b">0</code>，这意味着所有的元素都位于彼此之上。<em class="mn"> distribute </em>功能通过垂直排列线条来解决这一问题，使组的中心位于可用空间的中心(这又会使组相对于图表中的条形居中)。</p><pre class="mj mk ml mm gt mo le mp mq aw mr bi"><span id="2b8b" class="ms lg iq le b gy mt mu l mv mw">function <em class="mn">distribute</em>(text, tspans) { <br/>    var pmax = lineHeight * (tspans.length - 1);<br/>    var dy = parseFloat(text.attr("dy"));<br/><br/>    for (var j = 0; j &lt; tspans.length; j++) {<br/>        var pos = (lineHeight * j) - (pmax / 2.0) + dy;<br/>        var tspan = tspans[j];<br/>        tspan.attr("dy", pos + "em");<br/>    }<br/>}</span></pre><p id="bd4e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们首先计算出元素集(<code class="fe lb lc ld le b">pmax</code>)在分布时的最大高度，并获取原始文本属性的<code class="fe lb lc ld le b">dy</code>——这告诉我们原始偏移量NVD3用于将一行文本与条居中。大约是0.32毫米。</p><p id="c2a5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后我们简单地按照一个简单的公式计算每个<code class="fe lb lc ld le b">tspan</code>的<code class="fe lb lc ld le b">dy</code>位置:</p><pre class="mj mk ml mm gt mo le mp mq aw mr bi"><span id="18c9" class="ms lg iq le b gy mt mu l mv mw">var pos = (lineHeight * j) - (pmax / 2.0) + dy;</span></pre><ul class=""><li id="eb2b" class="my mz iq ke b kf kg kj kk kn na kr nb kv nc kz nd ne nf ng bi translated">行高乘以<code class="fe lb lc ld le b">tspan</code>数字告诉我们从我们想要移动到的<code class="fe lb lc ld le b">tspans</code>集合顶部的原始偏移量</li><li id="a908" class="my mz iq ke b kf nh kj ni kn nj kr nk kv nl kz nd ne nf ng bi translated">超过2的块的最大高度告诉我们将文本向后移动多远，以使它处于相对于条的正确位置</li><li id="b363" class="my mz iq ke b kf nh kj ni kn nj kr nk kv nl kz nd ne nf ng bi translated">添加<code class="fe lb lc ld le b">dy</code>将恢复<code class="fe lb lc ld le b">text</code>元素的原始偏移量，以将文本的中心与条的中心对齐</li></ul><p id="5b48" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦知道了这个<code class="fe lb lc ld le b">pos</code>，那么我们只需适当地设置<code class="fe lb lc ld le b">tspan</code>的<code class="fe lb lc ld le b">dy</code>。</p><h2 id="cfe5" class="ms lg iq bd lh nm nn dn ll no np dp lp kn nq nr lt kr ns nt lx kv nu nv mb nw bi translated">减少</h2><p id="8225" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">有了一组水平排列、垂直分布的<code class="fe lb lc ld le b">tspans</code>，我们现在可以最终确定它们是否适合这个盒子。</p><p id="ac18" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的reduce函数查看已用空间和已分配空间，如果有溢出，就删除最后一个元素。另外，它还用省略号替换了前一行的最后几个字母，以表示截断。</p><pre class="mj mk ml mm gt mo le mp mq aw mr bi"><span id="6e9c" class="ms lg iq le b gy mt mu l mv mw">function <em class="mn">reduce</em>(text, tspans) {<br/>    var reduced = false;<br/>    var box = text.node().getBBox();<br/>    if (box.height &gt; maxHeight &amp;&amp; tspans.length &gt; 1) {<br/>        tspans[tspans.length - 1].remove();<br/>        tspans.pop();<br/>        var line = tspans[tspans.length - 1].text();<br/>        if (line.length &gt; 3) {<br/>            line = line.substring(0, line.length - 3) + "...";<br/>        }<br/>        tspans[tspans.length - 1].text(line);<br/>        reduced = true;<br/>    }<br/>    return reduced;<br/>}</span></pre><p id="c921" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这使用了一个特性<code class="fe lb lc ld le b">getBBox</code>或<code class="fe lb lc ld le b">getBoundingBox</code>，它告诉我们一个元素的宽度、高度和位置。如果盒子高度大于某个最大高度，并且还有<code class="fe lb lc ld le b">tspans</code>需要移除，那么我们只需从DOM和内存列表中移除最后一个。然后我们删除最后一行的最后3个字母，用省略号替换它们，用新文本更新UI，然后返回<code class="fe lb lc ld le b">true</code>。如果没有元素被移除，我们返回<code class="fe lb lc ld le b">false</code>，这使得这个函数适合我们在开始时介绍的<code class="fe lb lc ld le b">do ... while</code>循环。</p><h2 id="af2b" class="ms lg iq bd lh nm nn dn ll no np dp lp kn nq nr lt kr ns nt lx kv nu nv mb nw bi translated">将这一切结合在一起</h2><p id="fbee" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">我们将所有代码放入一个函数中，这个函数本身包含了我们定义的其他函数，给了我们一个很好的结尾:</p><pre class="mj mk ml mm gt mo le mp mq aw mr bi"><span id="d6ae" class="ms lg iq le b gy mt mu l mv mw">function wrapLabels(params) {<br/>    var axisSelector = params.axisSelector;<br/>    var maxWidth = params.maxWidth;<br/>    var maxHeight = params.maxHeight;<br/>    var lineHeight = params.lineHeight || 1.2;<br/>    var wordBreaks = params.wordBreaks || [" ", "\t"];<br/>    var minChunkSize = params.minChunkSize || 3;</span><span id="1d54" class="ms lg iq le b gy mx mu l mv mw">    function _isMidWord(currentLine, remainder) {...}</span><span id="4083" class="ms lg iq le b gy mx mu l mv mw">    function _toPrevSpace(currentLine) {...}</span><span id="d48e" class="ms lg iq le b gy mx mu l mv mw">    function _backtrack(count, currentLine, remainder) {...}</span><span id="d458" class="ms lg iq le b gy mx mu l mv mw">    function _isTooLong(tspan) {...}</span><span id="ab86" class="ms lg iq le b gy mx mu l mv mw">    function separate(text) {...}</span><span id="4834" class="ms lg iq le b gy mx mu l mv mw">    function distribute(text, tspans) {...}</span><span id="5010" class="ms lg iq le b gy mx mu l mv mw">    function reduce(text, tspans) {...}</span><span id="8b68" class="ms lg iq le b gy mx mu l mv mw">    d3.selectAll(axisSelector + " .tick text").each(function(i, e) {<br/>        var text = d3.select(this);<br/>        var tspans = separate(text);<br/>        do {<br/>            distribute(text, tspans);<br/>        }<br/>        while (reduce(text, tspans))<br/>    });<br/>}</span></pre><p id="5e3e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后我们需要做的就是在每次图表更新时调用这个函数(记住在第一次呈现图表时调用它):</p><pre class="mj mk ml mm gt mo le mp mq aw mr bi"><span id="43b0" class="ms lg iq le b gy mt mu l mv mw">function updateChart() {<br/>    chart.update();<br/>    edges.nvd3.tools.wrapLabels({<br/>        axisSelector: "#mychart .nv-x.nv-axis",<br/>        maxWidth: 200,  // the left margin<br/>        maxHeight: 40   // the bar height<br/>    });<br/>}</span><span id="df7e" class="ms lg iq le b gy mx mu l mv mw">updateChart();<br/>nv.utils.windowResize(updateChart);</span></pre><p id="e240" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里唯一新的重要的一点是理解如何选择正确的轴。在水平多栏上，这是<code class="fe lb lc ld le b">.nv-x.nv-axis</code>,我们将其本地化为<code class="fe lb lc ld le b">#mychart</code>,这样我们就不会对页面中的所有图表应用换行。</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="b229" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在理想情况下，图表标签应该很短，因为这对用户来说是最容易的。然而，有时这是不可能的，当你设计通用的可视化来呈现你无法控制的数据时，你没有太多的选择。在这些情况下，你需要做一些事情来改善默认的“溢出框”的方法，你从NVD3和这个标签包装，断字和截断方法是非常合适的。</p><p id="9a18" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="mn">理查德是软件开发咨询公司</em> <a class="ae la" href="https://cottagelabs.com" rel="noopener ugc nofollow" target="_blank"> <em class="mn">山寨实验室</em> </a> <em class="mn">的创始人和高级合伙人，该公司专注于数据生命周期的各个方面。他偶尔会在推特上发</em><a class="ae la" href="https://twitter.com/richard_d_jones" rel="noopener ugc nofollow" target="_blank"><em class="mn">@ Richard _ d _ Jones</em></a></p><p id="d635" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">PS——这是完整的代码片段</p><pre class="mj mk ml mm gt mo le mp mq aw mr bi"><span id="cf51" class="ms lg iq le b gy mt mu l mv mw">function wrapLabels(params) {<br/>    var axisSelector = params.axisSelector;<br/>    var maxWidth = params.maxWidth;<br/>    var maxHeight = params.maxHeight;<br/>    var lineHeight = params.lineHeight || 1.2;<br/>    var wordBreaks = params.wordBreaks || [" ", "\t"];<br/>    var minChunkSize = params.minChunkSize || 3;<br/><br/>    function _isMidWord(currentLine, remainder) {<br/>        var leftChar = $.inArray(currentLine[currentLine.length - 1], wordBreaks) === -1;<br/>        var rightChar = $.inArray(remainder[0], wordBreaks) === -1;<br/>        return leftChar &amp;&amp; rightChar;<br/>    }<br/><br/>    function _toPrevSpace(currentLine) {<br/>        for (var i = currentLine.length - 1; i &gt;= 0; i--) {<br/>            var char = currentLine[i];<br/>            if ($.inArray(char, wordBreaks) !== -1) {<br/>                return currentLine.length - i;<br/>            }<br/>        }<br/>        return -1;<br/>    }<br/><br/>    function _backtrack(count, currentLine, remainder) {<br/>        for (var i = 0; i &lt; count; i++) {<br/>            remainder.unshift(currentLine.pop());<br/>        }<br/>    }<br/><br/>    function _isTooLong(tspan) {<br/>        return tspan.node().getComputedTextLength() &gt;= maxWidth<br/>    }<br/><br/>    function separate(text) {<br/>        // get the current content then clear the text element<br/>        var chars = text.text().trim().split("");<br/>        text.text(null);<br/><br/>        // set up registries for the text lines that they will create<br/>        var lines = [];<br/><br/>        // create a tspan for working in - we need it to calculate line widths dynamically<br/>        var x = text.attr("x");<br/>        var tspan = text.append("tspan").attr("x", x).attr("y", 0);<br/><br/>        // record the current line<br/>        var currentLine = [];<br/><br/>        // for each character in the text, push to the current line, assign to the tspan, and then<br/>        // check if we have exceeded the allowed max width<br/>        while (chars.length &gt; 0) {<br/>            var char = chars.shift();<br/>            currentLine.push(char);<br/>            tspan.text(currentLine.join(""));<br/><br/>            var maxed = false;<br/>            var hyphenated = false;<br/>            while(_isTooLong(tspan)) {<br/>                // record that we pushed the tspan to the limit<br/>                maxed = true;<br/><br/>                // if we already added a hyphen, remove it<br/>                if (hyphenated) {<br/>                    currentLine.splice(currentLine.length - 1);<br/>                    hyphenated = false;<br/>                }<br/><br/>                // if we have exceeded the max width back-track 1<br/>                _backtrack(1, currentLine, chars);<br/><br/>                if (_isMidWord(currentLine, chars)) {<br/>                    var toPrevSpace = _toPrevSpace(currentLine);<br/><br/>                    if (toPrevSpace === -1 || toPrevSpace - 1 &gt; minChunkSize) {<br/>                        _backtrack(1, currentLine, chars);<br/>                        currentLine.push("-");<br/>                        hyphenated = true;<br/>                    } else {<br/>                        _backtrack(toPrevSpace, currentLine, chars);<br/>                    }<br/>                }<br/><br/>                currentLine = currentLine.join("").trim().split("");<br/>                tspan.text(currentLine.join(""));<br/>            }<br/><br/>            // if we didn't yet fill the tspan, continue adding characters<br/>            if (!maxed &amp;&amp; chars.length &gt; 0) {<br/>                continue;<br/>            }<br/><br/>            // otherwise, move on to the next line<br/>            if (maxed || chars.length === 0) {<br/>                lines.push(currentLine);<br/>                currentLine = [];<br/>            }<br/>        }<br/><br/>        // create all the tspans<br/>        tspan.remove();<br/>        var tspans = [];<br/>        for (var i = 0; i &lt; lines.length; i++) {<br/>            tspan = text.append("tspan").attr("x", x).attr("y", 0);<br/>            tspan.text(lines[i].join(""));<br/>            tspans.push(tspan);<br/>        }<br/><br/>        return tspans;<br/>    }<br/><br/>    function distribute(text, tspans) {<br/>        var imax = tspans.length;<br/>        var pmax = lineHeight * (imax - 1);<br/>        var dy = parseFloat(text.attr("dy"));<br/><br/>        for (var j = 0; j &lt; tspans.length; j++) {<br/>            var pos = (lineHeight * j) - (pmax / 2.0) + dy;<br/>            var tspan = tspans[j];<br/>            tspan.attr("dy", pos + "em");<br/>        }<br/>    }<br/><br/>    function reduce(text, tspans) {<br/>        var reduced = false;<br/>        var box = text.node().getBBox();<br/>        if (box.height &gt; maxHeight &amp;&amp; tspans.length &gt; 1) {<br/>            tspans[tspans.length - 1].remove();<br/>            tspans.pop();<br/>            var line = tspans[tspans.length - 1].text();<br/>            if (line.length &gt; 3) {<br/>                line = line.substring(0, line.length - 3) + "...";<br/>            }<br/>            tspans[tspans.length - 1].text(line);<br/>            reduced = true;<br/>        }<br/>        return reduced;<br/>    }<br/><br/>    d3.selectAll(axisSelector + " .tick text").each(function(i, e) {<br/>        var text = d3.select(this);<br/>        var tspans = separate(text);<br/>        do {<br/>            distribute(text, tspans);<br/>        }<br/>        while (reduce(text, tspans))<br/>    });<br/>}</span></pre></div></div>    
</body>
</html>