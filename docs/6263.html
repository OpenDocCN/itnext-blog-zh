<html>
<head>
<title>Faster Maven builds</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更快的Maven构建</h1>
<blockquote>原文：<a href="https://itnext.io/faster-maven-builds-1-f2aa80a33d9?source=collection_archive---------3-----------------------#2021-10-03">https://itnext.io/faster-maven-builds-1-f2aa80a33d9?source=collection_archive---------3-----------------------#2021-10-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0fc5c993e7592a09c961aecc15983c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mkibOpJu_THXZZzq9RDQ1A.png"/></div></div></figure><p id="c4fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">构建需要一些属性，其中最主要的是可再现性。我认为速度是优先级中较低的。然而，这也是你的发布周期的最大限制因素之一:如果你的构建需要<em class="kw"> T </em>，你不能比每个<em class="kw"> T </em>发布得更快。因此，在达到一定的成熟度级别后，您可能希望加快构建速度，以支持更频繁的发布。</p><p id="ad66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我想详细介绍一些你可以用来提高Maven构建速度的技术。下面这篇文章将重点介绍如何在Docker内部做同样的事情。</p><h1 id="78ea" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">基线</h1><p id="1244" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">因为我想提出技术并评估它们的影响，所以我们需要一个样本库。我选择了<a class="ae ma" href="https://github.com/hazelcast/hazelcast-code-samples" rel="noopener ugc nofollow" target="_blank"> Hazelcast代码示例</a>，因为它提供了足够大的多模块代码库，包含许多子模块；确切的提交是<a class="ae ma" href="https://github.com/hazelcast/hazelcast-code-samples/commit/448febd9977b9927a3f00bbf61ba50b2c0d94bb4" rel="noopener ugc nofollow" target="_blank"> 448febd </a>。</p><p id="dd92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">规则如下:</p><ul class=""><li id="22c3" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">我运行该命令五次，以避免临时问题</li><li id="f755" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">我在每次运行之间执行<code class="fe mp mq mr ms b">mvn clean</code>,从一个空的<code class="fe mp mq mr ms b">target</code>存储库开始</li><li id="0e07" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">所有依赖项和插件都已下载</li><li id="c6fe" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">我在控制台日志中报告了Maven显示的时间:</li></ul><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="e48f" class="nb ky iq ms b gy nc nd l ne nf">[INFO] -------------------------------------------------------<br/>[INFO] BUILD SUCCESS<br/>[INFO] -------------------------------------------------------<br/>[INFO] Total time:  22.456 s (Wall Clock)<br/>[INFO] Finished at: 2021-09-24T23:20:41+02:00<br/>[INFO] -------------------------------------------------------</span></pre><p id="dff8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从我们的基线开始，<code class="fe mp mq mr ms b">mvn test</code>。结果是:</p><ul class=""><li id="2dc5" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">02:00分</li><li id="fb41" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">01时57分</li><li id="d316" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">01时58分</li><li id="ea5d" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">01时56分</li><li id="cf6f" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">01时58分</li></ul><h1 id="02e8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用所有CPU</h1><p id="4d94" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">默认情况下，Maven使用单线程。在多核时代，这只是浪费。通过设置一个绝对数字或相对于可用内核数量的数字，可以使用多线程运行并行构建。更多信息，请查看<a class="ae ma" href="https://cwiki.apache.org/confluence/display/MAVEN/Parallel+builds+in+Maven+3" rel="noopener ugc nofollow" target="_blank">相关文档</a>。</p><p id="7bdd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你拥有的相互不依赖的子模块越多，<em class="kw">也就是</em>，Maven可以并行构建它们，你用这种技术就能实现得越好。它非常适合我们的代码库。</p><p id="a5f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用尽可能多的可用内核线程。相关命令是<code class="fe mp mq mr ms b">mvn test -T 1C</code>。</p><p id="f0e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当该命令启动时，您应该会在控制台中看到以下消息:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="5348" class="nb ky iq ms b gy nc nd l ne nf">Using the MultiThreadedBuilder implementation with a thread count of X</span></pre><ul class=""><li id="8288" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">51.487秒(挂钟)</li><li id="fe23" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">40.322秒(挂钟)</li><li id="af8d" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">52.468秒(挂钟)</li><li id="7ef5" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">41.862秒(挂钟)</li><li id="7d18" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">41.699秒(挂钟)</li></ul><p id="53f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">数字要好得多，但方差更大。</p><h1 id="0a93" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">并行测试执行</h1><p id="8081" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">并行化是一种优秀的技术。我们可以在测试执行方面做同样的事情。默认情况下，Maven Surefire插件按顺序运行测试，但是也可以将其配置为并行运行测试。请参考<a class="ae ma" href="https://maven.apache.org/surefire/maven-surefire-plugin/examples/fork-options-and-parallel-execution.html#Parallel_Test_Execution" rel="noopener ugc nofollow" target="_blank">文档</a>了解整套选项。</p><p id="f621" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果每个模块中有大量的单元，这种方法是非常好的。请注意，您的测试<strong class="ka ir">需要</strong>相互独立。</p><p id="210a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将手动设置线程数量:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="2145" class="nb ky iq ms b gy nc nd l ne nf">mvn test -Dparallel=all -DperCoreThreadCount=false -DthreadCount=16 #1 #2</span></pre><ol class=""><li id="8930" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv ng mh mi mj bi translated">配置Surefire并行运行类和方法</li><li id="c840" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv ng mh mi mj bi translated">手动将线程数改为16</li></ol><p id="894e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们运行它:</p><ul class=""><li id="ab54" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">02分04秒</li><li id="68a1" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">02分03秒</li><li id="baa5" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">01:46分钟</li><li id="5a65" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">01分52秒</li><li id="4812" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">01:53分钟</li></ul><p id="ef60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">似乎线程同步的成本抵消了运行并行测试的潜在收益。</p><h1 id="985a" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">脱机的</h1><p id="d7dc" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Maven将在每次运行时检查一个<code class="fe mp mq mr ms b">SNAPSHOT</code>依赖项是否有新的“版本”。这意味着额外的网络往返。我们可以用<code class="fe mp mq mr ms b">--offline</code>选项来防止这种检查。</p><p id="042d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然您应该避免<code class="fe mp mq mr ms b">SNAPSHOT</code>依赖，但有时这是不可避免的，尤其是在开发期间。</p><p id="8c53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该命令为<code class="fe mp mq mr ms b">mvn test -o</code>，<code class="fe mp mq mr ms b">-o</code>为<code class="fe mp mq mr ms b">--offline</code>的快捷方式。</p><ul class=""><li id="dced" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">01:46分钟</li><li id="515e" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">01:46分钟</li><li id="6980" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">01:47分钟</li><li id="4d66" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">01:55分钟</li><li id="a319" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">01:44分钟</li></ul><p id="736a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代码库有相当多的<code class="fe mp mq mr ms b">SNAPSHOT</code>依赖项；因此离线大大加快了构建速度。</p><h1 id="996d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">JVM参数</h1><p id="f268" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Maven本身是一个基于Java的应用程序。这意味着每次运行都会启动一个新的JVM。JVM首先解释<em class="kw">字节码</em> <strong class="ka ir">和</strong>，然后分析工作负载，并相应地将<em class="kw">字节码</em>编译成<em class="kw">本机代码</em>:这意味着性能达到峰值，但只是在一段(长)时间之后。它非常适合长时间运行的流程，但不太适合命令行应用程序。</p><p id="dc53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在构建的环境中，我们可能不会达到最高的性能点，因为它们是相对短暂的，但是我们仍然在为分析成本买单。我们可以通过配置适当的JVM参数来配置Maven放弃它。有几种配置JVM的方法。最直接的方法是在项目文件夹的<code class="fe mp mq mr ms b">.mvn</code>子文件夹中创建一个专用的<code class="fe mp mq mr ms b">jvm.config</code>配置文件。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="6e51" class="nb ky iq ms b gy nc nd l ne nf">-XX:-TieredCompilation -XX:TieredStopAtLevel=1</span></pre><p id="0cd6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们简单地运行<code class="fe mp mq mr ms b">mvn test</code>:</p><ul class=""><li id="684c" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">01:44分钟</li><li id="56f6" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">01:44分钟</li><li id="37d5" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">01:53分钟</li><li id="7b01" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">01:53分钟</li><li id="5d38" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">01:55分钟</li></ul><h1 id="b826" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Maven守护进程</h1><p id="ed80" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Maven守护进程是Maven生态系统的新成员。它从<a class="ae ma" href="https://docs.gradle.org/current/userguide/gradle_daemon.html" rel="noopener ugc nofollow" target="_blank"> Gradle守护进程</a>中汲取灵感:</p><blockquote class="nh ni nj"><p id="9505" class="jy jz kw ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated"><em class="iq"> Gradle运行在Java虚拟机(JVM)上，并使用几个支持库，这些库需要大量的初始化时间。因此，有时启动会显得有点慢。这个问题的解决方案是Gradle Daemon:一个长寿的后台进程，它执行您的构建要比其他情况快得多。我们通过避免昂贵的引导过程和通过在内存中保存项目数据来利用缓存来实现这一点。</em></p></blockquote><p id="f6c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Gradle团队很早就认识到命令行工具并不是JVM的最佳用法。为了解决这个问题，需要保持一个JVM后台进程(守护进程)一直运行。它充当服务器，而CLI本身则扮演客户端的角色。</p><p id="541f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为一个额外的好处，这样一个长时间运行的进程只加载类一次(如果它们在两次运行之间没有改变)。</p><p id="fe3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦你安装了软件，你可以用<code class="fe mp mq mr ms b">mvnd</code>命令运行守护进程，而不是标准的<code class="fe mp mq mr ms b">mvn</code>命令。下面是<code class="fe mp mq mr ms b">mvnd test</code>的结果:</p><ul class=""><li id="a57a" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">33.124秒(挂钟)</li><li id="5927" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">33.114秒(挂钟)</li><li id="abe4" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">34.440秒(挂钟)</li><li id="a11c" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">32.025秒(挂钟)</li><li id="2059" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">29.364秒(挂钟)</li></ul><p id="04f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意守护进程默认使用多线程，带有<code class="fe mp mq mr ms b">number of cores - 1</code>。</p><h1 id="1ee8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">混合和搭配</h1><p id="b43a" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们已经看到了几种加速构建的方法。如果我们联合使用它们会怎么样？</p><p id="b0ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们首先尝试一下目前为止我们在同一次跑步中看到的每一项技术:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="f2ae" class="nb ky iq ms b gy nc nd l ne nf">mvnd test -Dparallel=all -DperCoreThreadCount=false -DthreadCount=16 -o #1 #2 #3 #4</span></pre><ol class=""><li id="818f" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv ng mh mi mj bi translated">使用Maven守护进程</li><li id="57b4" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv ng mh mi mj bi translated">并行运行测试</li><li id="9e0e" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv ng mh mi mj bi translated">不更新<code class="fe mp mq mr ms b">SNAPSHOT</code>依赖关系</li><li id="c4ba" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv ng mh mi mj bi translated">通过<code class="fe mp mq mr ms b">jvm.config</code>文件如上配置JVM参数——不需要设置任何选项</li></ol><p id="12cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该命令返回以下结果:</p><ul class=""><li id="e25d" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">27.061秒(挂钟)</li><li id="ef49" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">24.457秒(挂钟)</li><li id="3f1a" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">24.853秒(挂钟)</li><li id="8a0f" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">25.772秒(挂钟)</li></ul><p id="1418" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想想看，Maven守护进程<em class="kw">是</em>一个长期运行的进程。出于这个原因，让JVM分析并编译从<em class="kw">字节码</em>到<em class="kw">本机代码</em>是合情合理的。因此，我们可以删除<code class="fe mp mq mr ms b">jvm.config</code>文件并重新运行上面的命令。结果是:</p><ul class=""><li id="2b46" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">23.840秒(挂钟)</li><li id="a3ef" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">26.589秒(挂钟)</li><li id="42be" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">22.283秒(挂钟)</li><li id="94a7" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">23.788秒(挂钟)</li><li id="d471" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">22.456秒(挂钟)</li></ul><p id="c9d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以显示整合后的结果:</p><p id="5f0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ma" href="https://gist.github.com/nfrankel/e60ae1a08009370db98b87c5e552da16" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nfrankel/e 60 AE 1a 08009370 db 98 b 87 C5 e 552 da 16</a></p><h1 id="f686" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="13a8" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在这篇文章中，我们看到了几种加速Maven构建的方法。总结如下:</p><ul class=""><li id="2a3c" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated"><strong class="ka ir"> Maven守护进程</strong>:坚实、安全的起点</li><li id="a21a" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated"><strong class="ka ir">并行化构建</strong>:当构建包含多个相互独立的模块时</li><li id="50ca" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated"><strong class="ka ir">并行测试</strong>:当项目包含多个测试时</li><li id="2d13" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated"><strong class="ka ir">离线</strong>:当项目包含<code class="fe mp mq mr ms b">SNAPSHOT</code>依赖项<em class="kw">和</em>时，您不需要更新它们</li><li id="245a" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated"><strong class="ka ir"> JVM参数</strong>:当你想做得更多的时候</li></ul><p id="df3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我建议每个用户开始使用Maven守护进程，并在必要时根据你的项目继续优化。</p><p id="29be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下一篇文章中，我们将重点关注如何加速容器内的Maven构建。</p><p id="e66f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更进一步:</strong></p><ul class=""><li id="60bd" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated"><a class="ae ma" href="https://cwiki.apache.org/confluence/display/MAVEN/Parallel+builds+in+Maven+3" rel="noopener ugc nofollow" target="_blank">Maven 3中的并行构建</a></li><li id="9972" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated"><a class="ae ma" href="https://maven.apache.org/surefire/maven-surefire-plugin/examples/fork-options-and-parallel-execution.html#Parallel_Test_Execution" rel="noopener ugc nofollow" target="_blank">万全并行测试执行</a></li><li id="dcbf" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated"><a class="ae ma" href="https://github.com/mvndaemon/mvnd" rel="noopener ugc nofollow" target="_blank">mvnd—Maven守护进程</a></li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="0f73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">原载于</em> <a class="ae ma" href="https://blog.frankel.ch/faster-maven-builds/1/" rel="noopener ugc nofollow" target="_blank"> <em class="kw">一个Java怪胎</em></a><em class="kw">2021年10月3日</em></p></div></div>    
</body>
</html>