<html>
<head>
<title>How to Create a Custom Persistent Volume Plugin in Kubernetes via FlexVolume (Part-2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过FlexVolume在Kubernetes中创建自定义持久卷插件(第2部分)</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-create-a-custom-persistent-volume-plugin-in-kubernetes-via-flexvolume-part-2-c6390f9f94e0?source=collection_archive---------6-----------------------#2018-05-10">https://itnext.io/how-to-create-a-custom-persistent-volume-plugin-in-kubernetes-via-flexvolume-part-2-c6390f9f94e0?source=collection_archive---------6-----------------------#2018-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="ff4d" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">这是一个两部分的系列。<a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/how-to-create-a-custom-persistent-volume-plugin-in-kubernetes-via-flexvolume-part-1-f6d9d966e123"> <strong class="jt ir">第一部分</strong> </a>:司机。<strong class="jt ir">第二部</strong>:补给者</p></blockquote><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/9b7c667900b047553ba5d8c4a9dc161a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*55O0xGeMLVe8Hjwc."/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">照片由<a class="ae kp" href="https://unsplash.com/@alexkixa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alexandre Debiève </a>在<a class="ae kp" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="737a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">在<a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/how-to-create-a-custom-persistent-volume-plugin-in-kubernetes-via-flexvolume-part-1-f6d9d966e123"> <strong class="jt ir">第一部分</strong> </a>中，我已经谈到了如何基于FlexVolume的规范编写一个定制的永久卷(PV)驱动程序，它使人们能够创建与定制的PV生命周期相集成的静态PV。</p><p id="c0dd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">在这一部分中，我将带您了解如何创建一个动态供应器，它将使用在第一部分中创建的驱动程序并动态供应您的PVs。</p><p id="2b54" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">管理静态PV是一个手动过程，需要电子表格类型的工作来跟踪PV库存。这种方法有很多开销，但是它确实有一些有用的用途。例如，它允许您创建一个简单的备份和灾难恢复(DR)计划，因为所有的PV都是已知的，并根据使用情形进行了逻辑标记。它还可以通过仅向群集用户提供有限的库存来充当基础配额。</p><p id="a14c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">尽管静态PV有其优点，但在许多其他情况下，使用动态供应器更为常见，因为现代应用程序(尤其是微服务环境)大多是无状态的。有状态数据存储在缓存或数据库中，或者当pod重新启动时，它可以很容易地恢复到PVs上。</p><p id="7258" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">我们将利用<a class="ae kp" href="https://github.com/kubernetes-incubator/external-storage" rel="noopener ugc nofollow" target="_blank">外部存储</a>库(在<a class="ae kp" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>中编写)来创建一个动态供应器。它为构建树外持久性卷供应器提供了一个简单的界面。它基本上是一个使用client-go库的定制Kubernetes控制器(对于感兴趣的人，我将在另一篇文章中详细介绍如何创建自己的定制Kubernetes控制器)。</p><p id="6c25" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">有几个步骤涉及到:</p><ul class=""><li id="a60a" class="lj lk iq jt b ju jv jy jz lg ll lh lm li ln ko lo lp lq lr bi translated">实现两个外部存储器的接口</li><li id="b83b" class="lj lk iq jt b ju ls jy lt lg lu lh lv li lw ko lo lp lq lr bi translated">整理家属</li><li id="d9db" class="lj lk iq jt b ju ls jy lt lg lu lh lv li lw ko lo lp lq lr bi translated">封装二进制文件并运行您的部署清单</li></ul><h2 id="47a9" class="lx ly iq bd lz ma mb dn mc md me dp mf lg mg mh mi lh mj mk ml li mm mn mo mp bi translated">提供者</h2><p id="efc6" class="pw-post-body-paragraph jq jr iq jt b ju mq jw jx jy mr ka kb lg ms ke kf lh mt ki kj li mu km kn ko ij bi translated">你需要做几件关键的事情[1]:</p><ol class=""><li id="5b56" class="lj lk iq jt b ju jv jy jz lg ll lh lm li ln ko mv lp lq lr bi translated">导入“github . com/kubernetes-孵化器/外部-存储/库/控制器”</li><li id="486e" class="lj lk iq jt b ju ls jy lt lg lu lh lv li lw ko mv lp lq lr bi translated">为您的置备程序实现两个接口:</li></ol><pre class="kr ks kt ku gt mw mx my mz aw na bi"><span id="eae4" class="lx ly iq mx b gy nb nc l nd ne">Provision(VolumeOptions) (*v1.PersistentVolume, error)</span><span id="a18e" class="lx ly iq mx b gy nf nc l nd ne">Delete(*v1.PersistentVolume) error</span></pre><p id="b34c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">基本上，您的供应器将观察PVC的生命周期，并在相应事件发生时进行供应和删除。</p><p id="8aa3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><code class="fe ng nh ni mx b">Provision</code>方法处理所有需要的业务逻辑，并返回相应的PV(类似于PV清单的规范要求)。例如，业务逻辑将包括提供物理持久性卷，从而可以避免手动管理。</p><p id="68c4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><code class="fe ng nh ni mx b">delete</code>方法将根据PV的保留策略指定的内容删除物理持久性卷。</p><p id="300a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">如果您计划运行共享同一存储类的多个不同的置备程序实例，您将需要为每个置备程序提供一个身份，通过注释将该身份添加到返回的PV中，并在删除PV时对其进行检查。需要注意的是，如果您删除了其中一个置备程序，则该置备程序创建的PVs将是无父级的，并且由于身份不匹配，不会由其余置备程序处理。</p><p id="ce38" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">下面是示例代码(<strong class="jt ir">不是<em class="js"/>T5】一个完整的实现)来帮助你入门。一个是主要的，另一个是提供者。</strong></p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="bb0d" class="lx ly iq bd lz ma mb dn mc md me dp mf lg mg mh mi lh mj mk ml li mm mn mo mp bi translated">谈谈Go的包装管理</h2><p id="3c7b" class="pw-post-body-paragraph jq jr iq jt b ju mq jw jx jy mr ka kb lg ms ke kf lh mt ki kj li mu km kn ko ij bi translated">尽管<strong class="jt ir"> dep </strong>是官方的实验，但是没有一个通用的包管理工具可以像其他语言一样管理Go。由于历史原因，许多应用程序都使用其他包管理工具[2]。比如Glide和Godep。现在，Vgo有了一个新的提议，但仍不清楚何时会正式安装一个通用的包管理工具[更新:似乎Vgo被批准了，<a class="ae kp" href="https://codeengineered.com/blog/2018/golang-godep-to-vgo/#comment-3912763285" rel="noopener ugc nofollow" target="_blank">但社区对其方法有分歧</a>][更新2:考虑使用<a class="ae kp" href="https://blog.golang.org/using-go-modules" rel="noopener ugc nofollow" target="_blank"> go模块</a>。尽管Dep努力提供一个通用的接口，但是这些工具之间并不兼容，因此仍然可以导入带有不同软件包管理工具的旧回购协议。然而，它仍然有问题，并不总是与使用不同包管理工具的旧回购。</p><h2 id="2df3" class="lx ly iq bd lz ma mb dn mc md me dp mf lg mg mh mi lh mj mk ml li mm mn mo mp bi translated">家属</h2><p id="cf5e" class="pw-post-body-paragraph jq jr iq jt b ju mq jw jx jy mr ka kb lg ms ke kf lh mt ki kj li mu km kn ko ij bi translated">外部存储使用<a class="ae kp" href="https://github.com/Masterminds/glide" rel="noopener ugc nofollow" target="_blank">滑动</a>作为包管理工具。因此，您的新回购也需要使用glide。</p><p id="cc44" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">要引导glide，只需运行:</p><pre class="kr ks kt ku gt mw mx my mz aw na bi"><span id="0792" class="lx ly iq mx b gy nb nc l nd ne">$ glide init</span></pre><p id="2f7d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">该命令将生成一个<code class="fe ng nh ni mx b">glide.yaml</code>文件，除了<code class="fe ng nh ni mx b">version</code>之外，如下图所示。您可能希望指定<a class="ae kp" href="https://github.com/kubernetes-incubator/external-storage/releases" rel="noopener ugc nofollow" target="_blank">外部存储发布版本</a>，这样您就可以确保您的provisioner可以在正确版本的Kubernetes上运行。</p><pre class="kr ks kt ku gt mw mx my mz aw na bi"><span id="a252" class="lx ly iq mx b gy nb nc l nd ne">package: github.com/your-github-username/awesome-repo<br/>import:<br/>- package: github.com/golang/glog<br/>- package: github.com/kubernetes-incubator/external-storage<br/>  subpackages:<br/>  - lib/controller<br/>  - lib/util<br/>  <strong class="mx ir">version: v1.10.beta</strong><br/>- package: k8s.io/api<br/>  subpackages:<br/>  - core/v1<br/>- package: k8s.io/apimachinery<br/>  subpackages:<br/>  - pkg/api/resource<br/>  - pkg/apis/meta/v1<br/>  - pkg/util/wait<br/>- package: k8s.io/client-go<br/>  subpackages:<br/>  - kubernetes<br/>  - rest</span></pre><p id="c4c9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">在<code class="fe ng nh ni mx b">glide.yaml</code>文件准备好之后，您需要运行下面的命令将依赖项安装到供应商文件夹中，这样代码就可以被编译，而不是依赖于<code class="fe ng nh ni mx b">$GOPATH</code>中的库:</p><pre class="kr ks kt ku gt mw mx my mz aw na bi"><span id="93e0" class="lx ly iq mx b gy nb nc l nd ne">$ glide install -v</span></pre><p id="6cdf" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><strong class="jt ir">注意:你必须使用</strong> <code class="fe ng nh ni mx b"><strong class="jt ir">-v</strong></code> <strong class="jt ir">标志，这样嵌套的供应商文件夹将被glide移除，否则你的编译将会失败。</strong></p><h2 id="16a8" class="lx ly iq bd lz ma mb dn mc md me dp mf lg mg mh mi lh mj mk ml li mm mn mo mp bi translated">汇编</h2><p id="d902" class="pw-post-body-paragraph jq jr iq jt b ju mq jw jx jy mr ka kb lg ms ke kf lh mt ki kj li mu km kn ko ij bi translated">您可以使用普通的<code class="fe ng nh ni mx b">go build</code>命令编译您的代码。然而，在创建docker映像时，您需要使用已经安装的基本容器。</p><p id="f9bc" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">另一种方法是编译静态链接的二进制文件，例如为linux编译:</p><pre class="kr ks kt ku gt mw mx my mz aw na bi"><span id="1864" class="lx ly iq mx b gy nb nc l nd ne">CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo ldflags '-w' -o awesome-provisioner</span></pre><p id="1461" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">这样做的好处是您可以使用任何基于linux的映像，包括<code class="fe ng nh ni mx b">scratch</code>。</p><h2 id="7070" class="lx ly iq bd lz ma mb dn mc md me dp mf lg mg mh mi lh mj mk ml li mm mn mo mp bi translated">完成</h2><p id="f8f5" class="pw-post-body-paragraph jq jr iq jt b ju mq jw jx jy mr ka kb lg ms ke kf lh mt ki kj li mu km kn ko ij bi translated">在容器化了您的provisioner之后，剩下要做的一件事就是编写一个<code class="fe ng nh ni mx b">deployment</code>清单，然后简单地将它部署到您的Kubernetes集群。请注意，如果您要将机密传递给<code class="fe ng nh ni mx b">FlexVolume</code>，您将需要由您的置备程序创建或引用相关的机密。</p><h2 id="6407" class="lx ly iq bd lz ma mb dn mc md me dp mf lg mg mh mi lh mj mk ml li mm mn mo mp bi translated">参考</h2><p id="ee74" class="pw-post-body-paragraph jq jr iq jt b ju mq jw jx jy mr ka kb lg ms ke kf lh mt ki kj li mu km kn ko ij bi translated">[1] <a class="ae kp" href="https://github.com/kubernetes-incubator/external-storage/blob/master/docs/demo/hostpath-provisioner/README.md" rel="noopener ugc nofollow" target="_blank">编写一个树外动态供应器</a></p><p id="76bb" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">[1] <a class="ae kp" href="https://github.com/golang/go/wiki/PackageManagementTools" rel="noopener ugc nofollow" target="_blank"> Go包管理工具</a></p></div></div>    
</body>
</html>