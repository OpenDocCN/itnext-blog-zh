<html>
<head>
<title>Flutter Best Practices — Part 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振最佳实践—第4部分</h1>
<blockquote>原文：<a href="https://itnext.io/flutter-best-practices-part-4-709e7bceabf?source=collection_archive---------1-----------------------#2022-08-10">https://itnext.io/flutter-best-practices-part-4-709e7bceabf?source=collection_archive---------1-----------------------#2022-08-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fb9f7f623926b5b65dcdb475e7356093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dlcfo-mzwSXI5wWRu4WFdA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">颤振最佳实践—第4部分</figcaption></figure><p id="0600" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">以下是成为专业flutter开发者的5个新的最佳实践</em></p><p id="4d22" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">本系列的其他部分链接在本文末尾提供。</em></p><h1 id="1242" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">1.对未修改的变量使用final/const关键字</h1><p id="aa14" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">“final”意味着单次赋值:final变量或字段必须有一个初始值设定项。一旦赋值，最终变量的值就不能更改。final修改变量。</p><p id="023c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果在编译时不知道值，final应该用在const之上，它会在运行时被计算/抓取。</p><p id="d258" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你有一个const集合，里面的所有东西都在const中。如果你有一个最终的收藏，里面的一切都不是最终的。</p><p id="a024" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有更多的差异和更多的理解的例子。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6e70" class="mn lc iq mj b gy mo mp l mq mr">// Don’t</span><span id="b636" class="mn lc iq mj b gy ms mp l mq mr">String firstName = “John”<br/>int a = 1</span><span id="22b4" class="mn lc iq mj b gy ms mp l mq mr">// Do</span><span id="bca2" class="mn lc iq mj b gy ms mp l mq mr">final String firstName = “John”<br/>const int a = 1</span><span id="0cea" class="mn lc iq mj b gy ms mp l mq mr">//or const a = 1</span></pre><h1 id="5eaf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">2.不要使用“+”来连接字符串，使用字符串插值</h1><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="bf67" class="mn lc iq mj b gy mo mp l mq mr">// Don't<br/>final String firstName = "John";<br/>final String text = firstName + " Doe"</span><span id="73a0" class="mn lc iq mj b gy ms mp l mq mr">// Do <br/>final String firstName = "John";<br/>final String text = "$firstName Doe"</span></pre><h1 id="666c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak"> 3。不要创建一个lambda，当一个撕裂将做</strong></h1><p id="4478" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">如果我们有一个函数调用一个方法，这个方法的参数与传递给它的参数相同，那么您不需要手动将调用包装在lambda中。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2ae5" class="mn lc iq mj b gy mo mp l mq mr">List&lt;String&gt; names = []<br/>  <br/>// Don’t<br/>names.forEach((name) {<br/>  print(name);<br/>});</span><span id="f21f" class="mn lc iq mj b gy ms mp l mq mr">// Do<br/>names.forEach(print);</span></pre><h1 id="9cf5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">4.使用异步/等待更可读的方式</h1><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6662" class="mn lc iq mj b gy mo mp l mq mr">// Don’t<br/>Future&lt;int&gt; getUsersCount() {<br/>  return getUsers().then((users) {<br/>    return users?.length ?? 0;<br/>  }).catchError((e) {<br/>    log.error(e);<br/>    return 0;<br/>  });<br/>}</span><span id="1489" class="mn lc iq mj b gy ms mp l mq mr">// Do<br/>Future&lt;int&gt; getUsersCount() async {<br/>  try {<br/>    var users = await getActiveUser();<br/>    return users?.length ?? 0;<br/>  } catch (e) {<br/>    log.error(e);<br/>    return 0;<br/>  }<br/>}</span></pre><h1 id="b536" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">5.使用ListView.builder创建具有相同视图的建筑列表。</h1><ul class=""><li id="9087" class="mt mu iq ke b kf lz kj ma kn mv kr mw kv mx kz my mz na nb bi translated"><strong class="ke ir"> <em class="la"> Listview.builder </em> </strong>创建仅按需构建行视图的列表。</li><li id="c374" class="mt mu iq ke b kf nc kj nd kn ne kr nf kv ng kz my mz na nb bi translated"><strong class="ke ir"><em class="la">listview . builder</em></strong>将屏幕外的行视图重新用于用户可见的视图。</li><li id="e038" class="mt mu iq ke b kf nc kj nd kn ne kr nf kv ng kz my mz na nb bi translated"><strong class="ke ir"> <em class="la">默认列表视图</em> </strong>不会重用行并一次创建所有列表，如果列表太大，会导致性能问题。</li></ul><h1 id="ea6b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">前几集</strong></h1><div class="nh ni gp gr nj nk"><a rel="noopener  ugc nofollow" target="_blank" href="/flutter-best-practices-part-1-e89467ea4823"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">颤振—最佳实践—第1部分</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">这是颤振最佳实践的第一部分…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">itnext.io</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny jw nk"/></div></div></a></div><div class="nh ni gp gr nj nk"><a rel="noopener  ugc nofollow" target="_blank" href="/flutter-best-practices-part-2-e9e5c79ccb16"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">颤振最佳实践—第2部分</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">让我们开始…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">itnext.io</p></div></div><div class="nt l"><div class="nz l nv nw nx nt ny jw nk"/></div></div></a></div><div class="nh ni gp gr nj nk"><a rel="noopener  ugc nofollow" target="_blank" href="/flutter-best-practices-part-3-747f1bfaec6b"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">颤振最佳实践—第3部分</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">你可以在下面找到这个系列的前两部分</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">itnext.io</p></div></div><div class="nt l"><div class="oa l nv nw nx nt ny jw nk"/></div></div></a></div><p id="65a6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">希望你喜欢这篇文章。请在评论中让我知道。</p><p id="5c7d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你觉得有用，请鼓掌。</p><p id="2e1b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">感谢阅读。</p><p id="45f2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae ob" href="https://coderzheaven.com/" rel="noopener ugc nofollow" target="_blank">更多教程</a></p><p id="1d65" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae ob" href="https://www.youtube.com/c/MobileProgrammer" rel="noopener ugc nofollow" target="_blank">视频教程</a></p></div></div>    
</body>
</html>