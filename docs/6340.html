<html>
<head>
<title>Cypress Component Testing vs Storybook Interaction Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Cypress组件测试与故事书交互测试</h1>
<blockquote>原文：<a href="https://itnext.io/cypress-component-testing-vs-storybook-interaction-testing-fe1f0270d30a?source=collection_archive---------1-----------------------#2021-10-20">https://itnext.io/cypress-component-testing-vs-storybook-interaction-testing-fe1f0270d30a?source=collection_archive---------1-----------------------#2021-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e008dc0e7be9597be8e808f53cefddf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ED_PCospHgJ51F-XdJlk-g.jpeg"/></div></div></figure><p id="ba3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">鉴于基于组件的库(Vue、React)和基于它们构建的框架(Nuxt、Next等)的兴起，隔离地对组件进行<a class="ae kw" href="https://www.browserstack.com/guide/end-to-end-testing" rel="noopener ugc nofollow" target="_blank">端到端测试</a>至关重要。<a class="ae kw" href="https://docs.cypress.io/guides/overview/why-cypress" rel="noopener ugc nofollow" target="_blank"> Cypress </a>宣布了其专用的<a class="ae kw" href="https://www.cypress.io/blog/2021/04/06/cypress-component-testing-react/" rel="noopener ugc nofollow" target="_blank">组件测试运行器</a>7.0版本的alpha发布。它允许您在浏览器中运行您的测试，就像访问您的应用程序的人会使用它一样。这些测试可以放在组件文件旁边，目标是创建针对每个组件而不是整个应用程序的测试。</p><p id="e9a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编写组件测试与我们所知的老柏树e2e测试非常相似，除了没有使用<strong class="ka ir"> <em class="kx"> cy </em> </strong> <em class="kx">。visit() </em>要导航到一个URL，您将<strong class="ka ir">挂载</strong>()组件，并使用相同的<a class="ae kw" href="https://docs.cypress.io/api/table-of-contents" rel="noopener ugc nofollow" target="_blank"> API命令</a>编写断言。由于本博客并不打算作为安装指南，请查看官方的<a class="ae kw" href="https://docs.cypress.io/guides/component-testing/introduction#Project-Setup" rel="noopener ugc nofollow" target="_blank"> Cypress文档</a>以获得安装和使用的逐步说明。因为组件测试不需要页面路由或加载应用程序的其余部分，所以这些测试可以运行得更快、更可靠、开销更少。</p><p id="018a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，我认为，虽然Cypress组件测试强制开发模块化和可测试的组件，但它肯定错过了UI文档。如果你想为组件创建UI文档和风格指南，你仍然需要依赖一些工具，比如故事书。(<em class="kx">如果你不熟悉这个工具，你可以看看我的</em> <a class="ae kw" href="https://kailaash.medium.com/storybook-for-vue-d1db1c288ed8" rel="noopener"> <em class="kx">文章</em> </a> <em class="kx">做个介绍。简而言之:Storybook让你以更少的开销独立地构建web应用程序的各个部分。</em></p><p id="6d08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，对于一个简单的组件，例如一个按钮，它会成为一个维护问题，因为它可能会有三四个文件用于不同的用例，如下所示。</p><ol class=""><li id="6f93" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ld le lf lg bi translated">Button.js(组件)</li><li id="f89f" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">Button.unit.js(用于单元测试)</li><li id="dcf4" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">Button.storybook.js (UI文档)</li><li id="e833" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">Button.cypress.js (Cypress组件测试)</li></ol><p id="116a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，如果你的应用已经使用了Storybook，而不是使用组件测试运行器来测试每一个组件，为什么我们不e2e测试Storybook呢？这样，我们得到了两个世界的精华，即漂亮的UI文档和经过良好测试的组件风格指南。</p><h1 id="fec1" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">为什么要测试故事书</h1><p id="f453" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">在我们研究故事书测试策略之前，让我们讨论一下为什么测试故事书很重要。我是故事书的忠实粉丝。但是，像任何软件一样，如果不进行测试，它很容易腐烂。尽管它与您的web应用程序共享代码，但它有单独的配置、构建过程和代码路径。这很容易忽略对它的测试。原因之一是开发人员倾向于更多地关注单元和e2e测试，而不去测试故事书组件。</p><p id="75e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你的项目使用故事书，我们问这些问题是非常重要的:</p><ol class=""><li id="b90f" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ld le lf lg bi translated">如果故事书构建失败了，如何发现它？</li><li id="d0cf" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">如果你的故事书组件渲染失败，你会得到怎样的通知？</li></ol><p id="d005" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个问题的简短答案很简单。也就是说，<a class="ae kw" href="https://storybook.js.org/tutorials/intro-to-storybook/react/en/deploy/" rel="noopener ugc nofollow" target="_blank"> CI </a>应该失效。如果您的应用程序没有在CI中执行故事书构建，那么将它添加到管道中是至关重要的。关于第二点，答案是利用Cypress进行e2e测试。Storybook中还有一个即将到来的<a class="ae kw" href="https://storybook.js.org/blog/interaction-testing-sneak-peek/" rel="noopener ugc nofollow" target="_blank">集成测试</a>特性，它似乎是组件测试的一个可行的替代方案。在接下来的小节中，让我们简单地讨论一下这些方法。</p><h1 id="10ad" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">用纯柏树测试故事书</h1><p id="d8e3" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">Storybook本质上是一个独立的应用程序，有自己的构建配置。实际上，当我们处理应用程序、更新依赖关系等时，它可能会失败。让我们编写一个简单的测试来检测Storybuild构建何时失败，至少以最基本、最容易检测的方式(例如，当默认故事无法呈现时)。</p><p id="1259" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我假设你已经在用Cypress测试你的应用了。首先，创建第二个Cypress配置(cypress.storybook.json ),它指向您的storybook服务器的URL(在下面的例子中是:9000 ),并引用一个单独的集成文件夹，因此我们在纯e2e和Storybook测试之间引入了一个关注点分离。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="5bfe" class="my ln iq mu b gy mz na l nb nc">//cypress.storybook.json</span><span id="00f9" class="my ln iq mu b gy nd na l nb nc">{ <br/>  “baseUrl”: “http://localhost:9000",<br/>  “integrationFolder”: “cypress/storybook”,<br/>  ...<br/>}</span></pre><p id="13cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了方便起见，在package.json中添加脚本。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="41c6" class="my ln iq mu b gy mz na l nb nc">//package.json<br/>“scripts”: {<br/>  “start:storybook”: “start-storybook -p 9000 -s public”,<br/>  “cy:test:storybook”: “cypress run — headless -C   cypress.storybook.json”,<br/>...<br/>}</span></pre><p id="1d77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，在集成文件夹中创建一个<em class="kx"> storybook.spec.j </em> s文件，如<em class="kx"> button.storybook.json </em>文件中所设置的，并添加以下内容。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="886f" class="my ln iq mu b gy mz na l nb nc">// button.spec.js<br/>const getIframeBody = () =&gt; {</span><span id="a4c4" class="my ln iq mu b gy nd na l nb nc">// get the iframe &gt; document &gt; body<br/>  return cy.get(‘iframe[id=”storybook-preview-iframe”]’)<br/>  // and retry until the body element is not empty<br/>  .its(‘0.contentDocument.body’).should(‘not.be.empty’)<br/>  // wraps “body” DOM element<br/>  // <a class="ae kw" href="https://on.cypress.io/wrap" rel="noopener ugc nofollow" target="_blank">https://on.cypress.io/wrap</a><br/>  .then(cy.wrap);<br/>}</span><span id="27c1" class="my ln iq mu b gy nd na l nb nc">describe(“Button”, () =&gt; {<br/>  before(() =&gt; {<br/>    cy.visit(“/”);<br/>  });</span><span id="2154" class="my ln iq mu b gy nd na l nb nc">  it(“loads primary button with default text”, () =&gt; {<br/>    getIframeBody().get(‘#root’).contains(‘button’, ‘Button’);<br/>  });<br/>});</span></pre><p id="2bcd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能已经注意到了，这个测试使用了iframes。在Cypress中使用iframes有点棘手。因为当cypress DOM命令到达iframe内部的#document节点时，遍历操作就会停止。然而，正如这里的所记录的那样，可以创建一个自定义代码来使其工作。上述解决方案在它所做的意义上是最小的。但是它保证了一个立足点，如果我们想在未来增加更多的Cypress Storybook测试。该逻辑还可以扩展，甚至可以通过查询参数操纵旋钮等，或者使用<a class="ae kw" href="https://github.com/NicholasBoll/cypress-storybook" rel="noopener ugc nofollow" target="_blank"> cypress-storybook </a>库为storybook添加cypress命令。该库直接调用故事书路由器，并提供命令来测试组件旋钮、标签等。</p><h1 id="619a" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">故事书交互测试</h1><p id="0c4b" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">Storybook最近宣布，他们正在开发一个<a class="ae kw" href="https://storybook.js.org/blog/interaction-testing-sneak-peek/" rel="noopener ugc nofollow" target="_blank">交互测试</a>功能，允许你编写交互脚本并检查故事本身的预期。这将使您能够在与开发ui相同的浏览器环境中跨ui运行功能测试。由<a class="ae kw" href="https://testing-library.com/" rel="noopener ugc nofollow" target="_blank">测试库</a>提供支持，它具有时间旅行能力，也有便于调试的永久链接。有了内置的测试设置，我们可以在故事本身内部编写交互测试。这也在Cypress和Storybook之间设置了一个清晰的关注边界，其中前者可以专注于纯e2e测试，而后者专注于组件文档和测试。</p><p id="c24d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Cypress和Storybook团队都在致力于扩展他们工具的表面，现在看起来有所重叠；Storybook和他们的Storybook交互测试，Cypress和他们的组件测试人员。如前所述，故事书交互测试目前正在积极开发中。一旦发布，我相信这将是测试隔离元件的方法。如果你的应用程序还没有使用Storybook，现在是时候引入这个工具了，因为它简化了UI开发和文档。如果您的应用程序使用Storybook，编写Storybook Cypress测试似乎是一个可行的选择。至于Cypress组件测试，我当然不会将它们用于Storybook中已经有UI文档的组件。我并不是说你根本不应该使用Cypress组件测试，但是如果你确实有UI文档或者构建一个设计系统，最好在一个已经隔离的环境上运行Storybook的交互测试。</p><p id="28f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">免责声明</strong>:在写这篇博客的时候，Cypress <a class="ae kw" href="https://www.cypress.io/blog/2021/04/06/cypress-component-testing-react/" rel="noopener ugc nofollow" target="_blank">组件测试运行器</a>是一个alpha版本，Storybook的<a class="ae kw" href="https://storybook.js.org/blog/interaction-testing-sneak-peek/" rel="noopener ugc nofollow" target="_blank">交互测试</a>正在积极开发中。在后续版本中，本博客中讨论的案例可能不真实。</p></div></div>    
</body>
</html>