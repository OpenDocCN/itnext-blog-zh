<html>
<head>
<title>Building a Paint App in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在TypeScript中构建绘画应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/building-a-paint-app-in-typescript-1ce42c5b1698?source=collection_archive---------5-----------------------#2019-05-09">https://itnext.io/building-a-paint-app-in-typescript-1ce42c5b1698?source=collection_archive---------5-----------------------#2019-05-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="894b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何利用现代工具开发高性能web应用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/186f1417bf994c0405f35b8b757e440e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5W3BRA3SVxL7j6nnPjBHRg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5" rel="noopener ugc nofollow" target="_blank"> HTML5 </a>、<a class="ae ky" href="https://developer.mozilla.org/en/docs/Web/CSS/CSS3" rel="noopener ugc nofollow" target="_blank"> CSS3 </a>和<a class="ae ky" href="https://www.typescriptlang.org" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>中开发的一个<a class="ae ky" href="https://kenreilly.github.io/paintbros/" rel="noopener ugc nofollow" target="_blank">简单画图app </a>的截图</figcaption></figure><h2 id="2891" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h2><p id="3ee4" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">自从2013年初在0.3版本左右被介绍给<a class="ae ky" href="https://www.typescriptlang.org" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>以来，我一直在利用一切机会使用它，从重构混合桌面应用程序的前端，到构建简单的游戏、网站，甚至自动化语音通信系统等大规模生产服务，都取得了很大的成功。</p><p id="6109" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">去年，我构建了一个名为<a class="ae ky" href="https://kenreilly.github.io/paintbros/" rel="noopener ugc nofollow" target="_blank"> paintbros </a>的简单绘图程序，作为一个业余爱好项目，为开发一个实验性的2D游戏引擎创建自定义格式的光栅图形。虽然功能还不完整，但它展示了使用TypeScript和HTML5和CSS3的现代功能创建高度交互的web体验的概念——我们将对此进行更详细的研究。</p><h2 id="a8ac" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">基本设置</h2><p id="870a" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">由于这种应用程序的自定义性质，以及它唯一的系统要求是全屏设备上的现代浏览器，所以没有使用预先存在的框架。这个想法是利用尽可能多的现代浏览器的内置特性——唯一的开发依赖是Node和TypeScript编译器。正如Google Lighthouse中的这些性能和最佳实践指标所揭示的那样，从头开始做有一个非常好的理由:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/886d1434b21a93c2edddc035418ad0fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jaFcXXV4KEeBsxndLstE3w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">保持简单可以实现的性能示例</figcaption></figure><p id="5aa2" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这是股票表现，不需要真正的优化或其他改进，这是一个很好的位置。在阿尔法MVP上达到99%就像从终点线开始。这展示了选择轻量级工具和技术(如TypeScript)以及利用HTML5和CSS3中可用的强大功能时的强大功能。</p><p id="466f" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">让我们看看项目布局，以及我们的两个项目配置文件。从这里，我们可以看到该应用程序具有典型的网站结构、少量的TypeScript文件、一些基本的资产文件夹和项目配置设置:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/f593d33830faa29111a436610e3e3f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*92usSMvh9eKA6v0P5g-Eyw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">项目布局，用编译器选项生成的<strong class="bd lb"> package.json、</strong>和<strong class="bd lb"> tsconfig.json </strong></figcaption></figure><p id="1925" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">外部运行时依赖性的缺乏使得这是一个非常干净和轻量级的应用程序，但这也意味着一切都必须从头开始定义。幸运的是，使用这种设置有许多很大的优势，特别是在<a class="ae ky" href="https://code.visualstudio.com" rel="noopener ugc nofollow" target="_blank">与代码</a>之间，后者是为了支持TypeScript而从头开始设计的，并且包括针对现代web技术的强大的内置代码完成和重构工具。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="f1d2" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建基本的UX结构</h2><p id="95f9" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">配置文件准备就绪后，下一步是定义应用程序的基本HTML结构。这里我们有一些用于<a class="ae ky" href="https://www.w3.org/International/questions/qa-html-encoding-declarations" rel="noopener ugc nofollow" target="_blank">字符集</a>、<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag" rel="noopener ugc nofollow" target="_blank">视口</a>、<a class="ae ky" href="http://ogp.me" rel="noopener ugc nofollow" target="_blank">打开图</a>和CSS样式表的元数据，以及主javascript构建输出文件<strong class="lx iu">。我们用<strong class="lx iu"> type="module" </strong>定义的/build/paintbros.js </strong>，用于<a class="ae ky" href="https://developers.google.com/web/fundamentals/primers/modules" rel="noopener ugc nofollow" target="_blank">直接将我们编译的ES6模块</a>加载到浏览器中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/0314539d9768bdb0c81edcd1f6a61ead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WIOVmHUU2Ukq1rubK-lDTw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">带有<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag" rel="noopener ugc nofollow" target="_blank">视口</a>、<a class="ae ky" href="http://ogp.me" rel="noopener ugc nofollow" target="_blank">打开图形</a>和<a class="ae ky" href="https://developers.google.com/web/fundamentals/primers/modules" rel="noopener ugc nofollow" target="_blank"> javascript模块</a>的HTML头</figcaption></figure><p id="0cbe" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">让我们进一步看看<strong class="lx iu">体</strong>。包括一个带有<strong class="lx iu">按钮</strong>的<strong class="lx iu">标题</strong>，一个<strong class="lx iu">编辑器</strong>区域，以及一个<strong class="lx iu">侧栏</strong>，它带有用于<strong class="lx iu">调色板</strong>、<strong class="lx iu">样本</strong>和<strong class="lx iu">工具</strong>的容器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/f95d7ff56d18d2088193c22f8fa32f8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e8YPNss0uSqNLymG2-NpOg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">编辑器界面和一些基本工具的HTML定义</figcaption></figure><p id="9fc0" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这些组件充当应用程序主(也是唯一的)屏幕的工作空间。它非常简单，在屏幕顶部有一个标志和标准命令，在侧面有一些选择颜色和工具的东西。不太新颖，但想法是保持简单。除此之外，我们还有一个带有版权信息的页脚和一些用于处理基本操作(如创建、加载或保存图像)的模态对话框:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/a8d0b0d7ad1eba5654cfaa88fbe04a59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i9H1mOkYcUxl1fDlJSKhIQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">用于文件操作的静态页脚和简单对话框组件</figcaption></figure><p id="3861" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这就是应用程序HTML的基本内容(除了加载文件对话框和关于对话框，加载文件对话框主要是前两个对话框的另一个副本，关于对话框只显示一些信息文本)。我可以更进一步，为对话框创建一个抽象组件，但是在应用程序中总共有三个这样的组件实在不值得。然而，再多一点，创造一些可以配置和重用的东西将是一个很好的投资。</p><p id="3a4f" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">CSS也非常精简，没有预先存在的框架来允许从零开始100%可定制的UX。我们将使用CSS3的特性，如<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties" rel="noopener ugc nofollow" target="_blank">变量</a>和<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/CSS/calc" rel="noopener ugc nofollow" target="_blank"> calc() </a>来定义一些通过应用程序使用的全局属性:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/7eaf2850cc92c9e42993c90a8eb6c225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VRBKqRjIxOIFr4Axtr_aTw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">利用CSS3强大的功能，包括<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties" rel="noopener ugc nofollow" target="_blank">变量</a>和<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/CSS/calc" rel="noopener ugc nofollow" target="_blank">计算</a>()函数</figcaption></figure><p id="4537" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在这里，我们定义了颜色值、边距、调色板组件大小和45度条纹编辑器背景，以便在任何像素被任何颜色占据时都很明显。像这样提前定义CSS变量对构建图形应用程序的UX原型有很大的帮助，在这种情况下，您可能需要多次修改布局细节才能得到正确的结果。</p><p id="06ac" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们不会深入研究整个CSS文件(您可以在这里查看项目源代码<a class="ae ky" href="https://github.com/kenreilly/paintbros" rel="noopener ugc nofollow" target="_blank"/>)，但是让我们来看看构成UX的几个关键概念:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/6a40aa467ca5ea281339ea07dd41e3c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W3gCkaXUnSDtSMspUKkz4g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">带有静态标题和命令按钮样式的全屏正文</figcaption></figure><p id="f21f" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">由于这是一个全屏的web应用程序，不像基于内容的网站那样滚动，我们将我们的高度和宽度设置为100%(我通常使用<strong class="lx iu"> vh </strong>单位，但我在几天内就完成了这个项目，所以代码没有被修改)。我们可以立即从CSS变量中受益，而不必为CSS预处理器添加另一个依赖项，例如<a class="ae ky" href="https://sass-lang.com" rel="noopener ugc nofollow" target="_blank"> SASS </a>，我通常会将它留给更大更复杂的项目。接下来，我们将了解应用程序中最重要的概念之一，编辑器表面样式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/ca13d53f951c0c949c3486b2f5400b91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kUXfSP_mEsN15GKu_Mfl7A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">主显示和编辑器容器、编辑器本身和编辑器“像素”的样式。<strong class="bd lb">编辑&gt;本人</strong></figcaption></figure><p id="885e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><a class="ae ky" href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" rel="noopener ugc nofollow" target="_blank"> Flexbox </a>用于在元素各自的父容器中水平和垂直地定位和拉伸元素。定义了显示、编辑器容器、编辑器和侧栏组件，形成了前端布局的核心结构。编辑器像素在编辑器中水平换行，所有内容都以所需的方式拉伸以适合其父级。</p><p id="58f1" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这总结了我们分别使用HTML5和CSS3对表示和样式的定义，并且很容易理解为什么它呈现得很快并且达到了大致的性能指标。还有更多的东西，但不多——一些或多或少重复了我们已经讨论过的概念的项目。</p><p id="0fc2" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在我们已经了解了结构和图形元素，让我们深入到在TypeScript中构建应用程序逻辑的过程中。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="d40b" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">定义调色板颜色、界面和枚举</h2><p id="f61b" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在这个阶段，第一个任务是创建文件<strong class="lx iu"> src/colors.ts，</strong>粘贴从这个<a class="ae ky" href="https://jonasjacek.github.io/colors/" rel="noopener ugc nofollow" target="_blank"> xterm颜色备忘单</a>复制的256个颜色值，并将其导出为var。接下来是<strong class="lx iu"> src/types.ts </strong>，在这里我们导出一些<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/interfaces.html" rel="noopener ugc nofollow" target="_blank">接口</a>和<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/enums.html" rel="noopener ugc nofollow" target="_blank">枚举</a>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/8afe0af8a1d8583a83ffbc7e7c293320.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*26LrvSU9Vr9-ThiLvRWj9w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Xterm的超级复古256色调色板和一些方便的定义</figcaption></figure><p id="1060" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这里我们有一些驱动应用程序其余部分的基本概念:</p><ul class=""><li id="e5df" class="nc nd it lx b ly mo mb mp li ne lm nf lq ng mn nh ni nj nk bi translated"><strong class="lx iu"> ImageSize </strong>:图像的高度和宽度(假设为像素单位)</li><li id="a947" class="nc nd it lx b ly nl mb nm li nn lm no lq np mn nh ni nj nk bi translated"><strong class="lx iu">图像内容</strong>:用于加载、保存和编辑的图像的结构</li><li id="4af1" class="nc nd it lx b ly nl mb nm li nn lm no lq np mn nh ni nj nk bi translated"><strong class="lx iu"> PaintTool </strong>:工具列表，从中选择当前选中的工具</li><li id="621c" class="nc nd it lx b ly nl mb nm li nn lm no lq np mn nh ni nj nk bi translated"><strong class="lx iu">工具模式</strong>:未使用，用于区域操作(待实施)</li></ul></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="b47d" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">主应用程序文件</h2><p id="6539" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">接下来我们将看看<strong class="lx iu"> build/paintbros.js </strong>背后的源代码，这个文件是我们如上所述作为ES6模块导入的，它随后会根据需要加载其他模块。该文件的源文件在<strong class="lx iu"> src/paintbros.ts: </strong>中</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/1891ead14f4f17236b08c129f911ea22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j2crVtzIlgqh8i3NEt6Zpw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">具有按钮、对话框和静态初始化的PaintBros类</figcaption></figure><p id="0005" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">PaintBros抽象类包含对文件操作的按钮和对话框的静态引用，并初始化其他应用程序组件，如调色板和编辑器。这里我们开始看到TypeScript的一些好处。这段代码很大程度上是自文档化的，很容易判断什么去哪里，为什么去。从这里，我们将开始研究核心编辑特性。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="9f13" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">调色板UX</h2><p id="1bc3" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">接下来，我们将在<strong class="lx iu"> src/palette.ts </strong>中检查我们的第一个基本控制器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/e7870389af00fa9a03c5fd7499cdcc80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pEToR7VwY0Pv0rAEuFNxRw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">显示元素引用、数据访问器属性和init方法的调色板类</figcaption></figure><p id="e433" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">Palette类是调色板和样本UX的控制器，具有对调色板元素本身的静态引用、显示当前和以前选择的颜色的元素以及包含当前选择的颜色的字符串(即'<em class="nr"> #00FFA0 </em>')。访问器<strong class="lx iu"> swatch_data() </strong>用于检索最近使用的颜色，以便稍后将它们与图像文件一起保存。<strong class="lx iu"> init() </strong>方法检索我们的DOM元素引用，并通过创建每个元素、将其绑定到事件处理程序、然后将每个颜色元素追加到调色板来绘制调色板本身。此外，我们可以看到<strong class="lx iu"> init_swatch() </strong>和<strong class="lx iu"> reset_swatch() </strong>函数，它们处理这些任务。</p><p id="dd9e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">让我们看看Palette类中定义的其他方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/5ab0de0d10fd63ecd17c3873e4ba1c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RXAMCLUFXIuEl4t55xcXog.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">调色板类中用于处理样本和处理单击事件的方法</figcaption></figure><p id="6143" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在这个类中，我们还找到了用于从先前保存的文件中加载颜色的<strong class="lx iu"> load_swatch() </strong>方法(我们将在后面讨论文件操作)，以及用于生成样本项目元素的<strong class="lx iu"> make_color_el() </strong>，以及用作单击调色板颜色的事件处理程序的<strong class="lx iu"> on_click_color() </strong>方法。当单击一种颜色时，如果它与当前选定的颜色匹配，则该事件将被丢弃，否则色板中的最后一个项目将被删除，当前颜色将被推送到色板堆栈的前面，新选定的颜色将被设置为当前颜色。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="1ed2" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">工具UX</h2><p id="91dc" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">继续我们应用程序的下一个组件，我们将看看允许用户在画笔、橡皮擦等之间进行选择的控制器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/6e586e87cdea9212719fb9227c0d209e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fxlANDGfoJDu2CB5iZmkqA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">带有<strong class="bd lb"> init() </strong>和<strong class="bd lb"> on_click_tool() </strong>函数的工具类——对这个来说不算什么</figcaption></figure><p id="6035" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">分配给<strong class="lx iu"> current_tool </strong>的默认工具是画笔，我们可以看到<strong class="lx iu"> init() </strong>函数选择了工具按钮，并将每个按钮绑定到<strong class="lx iu"> on_click_tool() </strong>处理程序，当选择了一个尚未构建的工具(毕竟这是一夜之间完成的)时，它会发出“尚未实现”的警告。当用户选择一个已存在的工具时，它就成为被选中的选项。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="31dc" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">编辑</h2><p id="ffa3" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">这是大部分活动发生的地方。编辑器包含实际的图像信息本身，以及显示图像的方法，并允许使用该程序的人对其进行编辑。这里是<strong class="lx iu"> src/editor.ts </strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/b68a970b2e4a20938476e06435ae8737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Inl_atWWiC9Ug6sraQQyqQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">编辑器类，视图中有<strong class="bd lb"> image_data() </strong>访问器和<strong class="bd lb"> init() </strong>方法</figcaption></figure><p id="7ba8" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">编辑器具有图像尺寸的属性、对编辑器元素及其父容器的DOM元素引用，以及跟踪鼠标按下状态的布尔值。为了简单起见，实际的工作图像数据作为<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset" rel="noopener ugc nofollow" target="_blank">数据集</a>属性存储在像素元素本身中，并且仅在必要时通过<strong class="lx iu"> image_data() </strong>访问器进行检索，该访问器的工作方式就像样本中的访问器一样，提取要在文件保存操作中使用的数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/3624ce66a4a66f90aad21dbbcd57ac9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*saeIuU7HI8c1clTh8Ae0pA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">编辑器类中的<strong class="bd lb"> clear() </strong>、<strong class="bd lb"> load_image() </strong>和<strong class="bd lb"> new_image() </strong>函数</figcaption></figure><p id="45a4" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这里我们有从实现<strong class="lx iu"> ImageContent </strong>的对象加载先前保存的图像并将其绘制到编辑器<strong class="lx iu">、</strong>上的方法，以及从<strong class="lx iu"> ImageSize </strong>创建新的空白图像的方法。组件面板和编辑器的各种组件都会更新，以反映每个场景所需的结果，同时创建单独的“像素”并附加到编辑器中。</p><p id="30c5" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">随着我们进入应用程序更复杂的部分，TypeScript的优势变得越来越明显。我们不必一行一行地阅读意大利面条式的代码来拼凑编辑器如何工作的不同概念，而是获得了更多的关于所有东西是如何组装的图形表示，开发人员可以在几分之一秒内推断出什么东西，而不必四处挖掘。这里的关键是上下文，因为每一行都包含足够的信息来帮助正确理解它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/e41e1fa7ec3983f0a9d531a23fce97b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NROGpxoT5h3Ps9riux_pIg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">编辑器类的其余方法:调整大小和单击事件的处理程序</figcaption></figure><p id="468c" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">最后，我们的编辑器类包含在绘制屏幕或改变屏幕尺寸时调整大小的方法，在单击时更新“像素”的方法，以及处理鼠标移动事件的方法(主要是为了防止鼠标“卡”在<em class="nr">向下</em>的位置和在编辑器上随意绘制)。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="25c1" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">模态对话框UX</h2><p id="8432" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">下一个是带modal的src/modal.ts ,这是我们的对话框将扩展的一个抽象类:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/d1a8df8b2035c494665bf1fd0247bee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Smbqg5dGA7isepOygnA45Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">各个对话框类扩展的基本模式类</figcaption></figure><p id="8976" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">Modal类包含模态容器和对话框的属性，以及一个对当前可见实例的静态引用，该实例用于当用户在对话框之外单击时全局隐藏任何打开的对话框，它由<strong class="lx iu"> hide_listener </strong>静态属性<strong class="lx iu">处理。</strong>此外，我们还有我们的<strong class="lx iu"> show() </strong>和<strong class="lx iu"> hide() </strong>方法，一个实现全局对话框隐藏特性的静态<strong class="lx iu"> hide() </strong>方法，以及一个内部的<strong class="lx iu"> querySelector </strong>来方便地选择对话框的子元素:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/ee4a84e385d71203089b56c2d41772d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kuhM0DsSxP3N-2FSvF4LHw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">一个模态对话框的例子，<strong class="bd lb">新文件对话框</strong>类</figcaption></figure><p id="617e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">NewFileDialog类是我们第一个扩展抽象模态基类的实现。我们的对话框字段有一个属性，一个默认的处理程序用于<strong class="lx iu"> on_request_new_image </strong>(在对话框初始化过程中被PaintBros类设置的实际处理程序所替换，用于处理真实事件)，单击“确定”和“取消”的处理程序调用附加的处理程序用于<strong class="lx iu"> on_request_new_image </strong>和/或隐藏对话框，以及一个基本的<strong class="lx iu">构造函数()</strong>，它将对话框标题传递给带有<strong class="lx iu"> super() </strong>的基本模态类，并初始化DOM引用和事件处理程序</p><p id="6416" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们不会深入研究另外两个对话框，LoadFileDialog和SaveFileDialog，它们实际上是NewFileDialog的副本，只做了一些修改，并连接到处理相应功能的事件处理程序。然而，接下来我们将研究这些函数的实现。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="bd88" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">文件操作</h2><p id="f438" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">最后，我们来看最后一个但并非最不重要的特性，用于保存和加载图像的文件操作。这在<strong class="lx iu"> file.ts </strong>中实现:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/62f36e31474b74ff8aa65251ee4325e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GNAyhnI0E3SNo0ETHasW-w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd lb"> src/file.ts </strong>和file类的全部内容，处理所有的app文件操作</figcaption></figure><p id="1d60" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">File类也非常精简，在37行自文档化的代码中处理该程序100%的文件加载和保存操作。<strong class="lx iu"> load() </strong>方法利用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/FileReader" rel="noopener ugc nofollow" target="_blank"> FileReader </a> web API从<strong class="lx iu"> LoadFileDialog </strong>上的文件输入元素返回的Blob中异步加载图像JSON文件的内容，后者将数据传递给<strong class="lx iu"> on_load </strong>处理程序，进而将JSON解析为一个对象并将其传递给<strong class="lx iu"> Editor.load_image() </strong>。</p><p id="a5eb" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu"> save() </strong>方法执行与预期相反的操作，序列化图像名称以及从编辑器中提取的图像数据，将其打包到一个Blob中，并通过触发文件下载点击事件将其保存到本地机器。</p><p id="9130" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">文件操作到此为止。目前唯一支持的格式是自定义的“格式”，它只是序列化为JSON并作为<em class="nr">存储在本地机器上的图像信息。json </em>文件，但是我确实计划在将来的某个时候实现保存和加载BMP文件的选项。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="0a13" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h2><p id="316a" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">TypeScript提供了强大而丰富的功能集，可以创建像真正的软件一样执行和行为的真正的应用程序，而不是笨重臃肿的网站，当太多的内容在浏览器的JavaScript引擎上争用时间时，这些网站会永远加载和堵塞。</p><p id="84a9" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">虽然这个程序不太可能成为光栅图形编辑中的下一个大事件，但它显示了只用几个小的类型脚本文件和几行干净、定义良好的HTML5和CSS3就可以完成多少工作。</p><p id="53b9" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我希望你喜欢这篇文章，并祝你的下一个打字稿项目好运！</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><blockquote class="ns"><p id="33ad" class="nt nu it bd nv nw nx ny nz oa ob mn dk translated">肯尼斯·雷利(<a class="ae ky" href="https://twitter.com/8_bit_hacker" rel="noopener ugc nofollow" target="_blank"> 8_bit_hacker </a>)是<a class="ae ky" href="https://lvl-up.tech/" rel="noopener ugc nofollow" target="_blank"> LevelUP </a>的CTO</p></blockquote></div></div>    
</body>
</html>