<html>
<head>
<title>You Don’t Need React-Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你不需要反应-还原</h1>
<blockquote>原文：<a href="https://itnext.io/why-you-shouldnt-need-connect-from-react-redux-498876de9e4e?source=collection_archive---------2-----------------------#2018-09-20">https://itnext.io/why-you-shouldnt-need-connect-from-react-redux-498876de9e4e?source=collection_archive---------2-----------------------#2018-09-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/5575e9d596a5b6060ce856044a651242.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mw70aoN18CWteKll2h5Wog.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="49ac" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">渲染道具比高阶的‘连接’函数要好。</h2></div><p id="7994" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有一种方法是用Redux代替React-Redux的高阶组件使用渲染道具:<code class="fe lm ln lo lp b">connect</code>。这可以从根本上改变你对React和Redux中状态的看法，就像<a class="ae lq" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">新的React上下文API </a>的工作方式一样。它还有一个额外的好处，就是可以更容易地使用无状态的功能组件。</p><p id="fd4f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我创建了一个<code class="fe lm ln lo lp b">ReduxConnection</code>组件，用Redux处理渲染道具。你总是可以写你自己的，但是这本书为你做了所有的事情，并且基本上是<code class="fe lm ln lo lp b">connect</code>的替代者。</p><h1 id="3e54" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">React和Redux的问题？</h1><p id="8bcd" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">在React中使用Redux的最大问题之一是<code class="fe lm ln lo lp b">connect</code>高阶组件。我知道当我第一次开始使用它时，我花了一段时间来理解它是如何工作的，以及我将如何使用它。</p><p id="65d7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe lm ln lo lp b">ReduxConnection</code>只要你明白反应过来就可以用；虽然，如果你习惯了React-Redux的<code class="fe lm ln lo lp b">connect</code>，渲染道具的方法需要一点说服力。</p><h1 id="a572" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">使用Redux渲染道具</h1><p id="ba06" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">这里有一个你熟悉的使用React-Redux的<code class="fe lm ln lo lp b">connect</code>的例子:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1fa9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这就是你如何用<code class="fe lm ln lo lp b">ReduxConnection</code>做同样的事情:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="374f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">注意<code class="fe lm ln lo lp b">textSelector</code>和<code class="fe lm ln lo lp b">mapStateToProps</code>一样，但是命名不同。我们可以随意命名这些函数。关键是你从状态中选择一些东西，并把它传递给<code class="fe lm ln lo lp b">children</code>。</p><p id="3ba3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">主要区别是高阶组件在你的组件之外，而渲染道具在里面。这就是你将在<code class="fe lm ln lo lp b">ReduxConnection</code>中看到力量的地方。虽然乍一看可能很奇怪，但是如果您熟悉React-Router v4+中的渲染道具，您很快就会意识到动态状态选择器组件的强大。随着<a class="ae lq" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">新的上下文API </a>的出现，渲染道具已经成为未来规范的一部分。</p><h1 id="6748" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">选择器的概念</h1><p id="4d5e" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">选择器函数是一种可重用的方法，用于:</p><ul class=""><li id="ad16" class="mu mv jb ks b kt ku kw kx kz mw ld mx lh my ll mz na nb nc bi translated">从冗余状态中选择一些东西。</li><li id="6ffa" class="mu mv jb ks b kt nd kw ne kz nf ld ng lh nh ll mz na nb nc bi translated">在把状态交给你的组件之前，有一个统一的方法来计算状态。</li><li id="ece1" class="mu mv jb ks b kt nd kw ne kz nf ld ng lh nh ll mz na nb nc bi translated">在需要的地方增加记忆以提高性能(<em class="ni">见</em> <a class="ae lq" href="https://github.com/reduxjs/reselect" rel="noopener ugc nofollow" target="_blank"> <em class="ni">重选</em> </a>)。</li></ul><p id="337b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">使用选择器，你可以从状态中提取东西，并使用<code class="fe lm ln lo lp b">component</code>道具或渲染道具将它们传递给组件。</p><h1 id="bf11" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">限制状态更新</h1><p id="ea76" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated"><code class="fe lm ln lo lp b">ReduxConnection</code>有一种方法，只有当进来的道具不同时才限制状态更新。这正是<code class="fe lm ln lo lp b">connect</code>的工作方式，但是因为您可以在<code class="fe lm ln lo lp b">ReduxConnection</code>中包装组件的特定部分，所以您不需要经常在没有意义的地方创建单独的组件。</p><p id="a147" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">ReduxConnection能够完成这一壮举的方式是通过<code class="fe lm ln lo lp b">shouldComponentUpdate() { return false }</code>。如果道具改变，它会选择何时更新，跳过<code class="fe lm ln lo lp b">selector</code>，这样你就可以放一个内嵌函数，而不用担心一堆重新渲染。</p><h1 id="6912" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">带有渲染道具的未来</h1><p id="a2a3" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">一般来说，高阶组件在使用React-Hot-Loader和TypeScript等其他工具时会有一些奇怪之处。尽管随着时间的推移，黑客和合法的解决方案都在解决这些问题，但很明显，这个行业正朝着渲染道具的方向发展。</p><p id="67db" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">要了解更多关于渲染道具的信息，请查看<a class="ae lq" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank">官方React页面</a>和<a class="ae lq" href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce" rel="noopener ugc nofollow" target="_blank">迈克尔杰克逊的原帖</a>。</p><p id="ffc9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在我看来，高阶组件编写起来很麻烦，因为它们需要在不需要的地方创建额外的组件。我最不希望的就是制造一堆不必要的间接。</p><p id="7478" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">举个例子，尝试将一个<code class="fe lm ln lo lp b">div</code>封装在一个<code class="fe lm ln lo lp b">connect</code>函数中。这需要将其取出，创建一个新的React组件，添加PropTypes，并将该文件导入到当前组件中。或者找到一种方法，在一个文件中包含两个组件，而不会变得笨拙。<code class="fe lm ln lo lp b">ReduxConnection</code>提供了一种方法来做到这一点，而无需制造单独的组件。</p><h1 id="2fc7" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">魔术道具</h1><p id="5ec7" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">你可能想知道某些道具是从哪里来的。当使用像<code class="fe lm ln lo lp b">connect</code>这样的高阶元件时，这些都是隐藏的。如果该属性是从父组件传递过来的，或者是直接来自Redux而不需要进入每个父组件，您实际上没有任何可见性。我称这些为“魔术道具”。</p><p id="9bf9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">例如:</p><pre class="mo mp mq mr gt nj lp nk nl aw nm bi"><span id="b5cc" class="nn ls jb lp b gy no np l nq nr">const propTypes = {<br/>  children: PropTypes.node.isRequired,<br/>  hasReceivedAuthInfo: PropTypes.bool.isRequired,<br/>  isAuthenticated: PropTypes.bool.isRequired,<br/>}</span></pre><p id="96cd" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我的假设是我必须传递这三个道具。虽然，实际上，他们中的2个来自<code class="fe lm ln lo lp b">connect</code>。</p><p id="4bc9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在记录组件时，我会分别标记哪些道具来自更高级别的组件；否则，对于使用您的组件的人来说，该组件期望的是什么是令人困惑的。</p><p id="2362" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">以下是我如何在高阶组件中补偿魔法道具的示例:</p><pre class="mo mp mq mr gt nj lp nk nl aw nm bi"><span id="534e" class="nn ls jb lp b gy no np l nq nr">const propTypes = {<br/>  children: PropTypes.node.isRequired,<br/>  <br/>  // Redux<br/>  hasReceivedAuthInfo: PropTypes.bool.isRequired,<br/>  isAuthenticated: PropTypes.bool.isRequired,<br/>}</span></pre><p id="61c4" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">欢迎你和你的团队每次创建新的组件或添加新的道具或从状态拉新的道具额外的工作。完全是不必要的维护。当您有更重要的事情要考虑时，这种事情很容易在拉请求中被忽略。我仍然更喜欢这种方法，而不是不标注道具来自哪里，但理想情况下，我们将只使用渲染道具。</p><p id="04e0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">渲染道具解决了魔法道具的问题，很像<a class="ae lq" href="https://reacttraining.com/react-router/web/api/Route" rel="noopener ugc nofollow" target="_blank"> how React-Router v4+是怎么做的</a>。</p><p id="cca9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">以这个<code class="fe lm ln lo lp b">IsAuthenticated</code>组件为例:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="6c75" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有了<code class="fe lm ln lo lp b">ReduxConnection</code>，很容易看到我们的组件只把<code class="fe lm ln lo lp b">children</code>作为一个道具。我不必考虑传入的组件之外的道具，比如<code class="fe lm ln lo lp b">hasReceivedAuthInfo</code>和<code class="fe lm ln lo lp b">isAuthenticated</code>。</p><p id="d6d2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这是<code class="fe lm ln lo lp b">connect</code>的样子:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="965d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">简单吧？不完全是。当您开始传入函数并查看属性类型时，这变得非常复杂。这是一个很小的例子；尽管通常情况下，您会有具有不同状态需求的较大组件。你并不总是想把这些组件分解成更小的组件，因为在某些时候你会遇到间接性的问题。</p><p id="35db" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">下面是在使用PropTypes时对这两个组件的另一种看法:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="dd17" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因为<code class="fe lm ln lo lp b">ReduxConnection</code>示例使用了组件内部的组合，所以很清楚这种状态来自哪里，以及作为消费者的您需要将哪些支持传递给<code class="fe lm ln lo lp b">IsAuthenticated</code>。</p><p id="b838" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果你仍然认为<code class="fe lm ln lo lp b">connect</code>版本更好，当:</p><ul class=""><li id="e27e" class="mu mv jb ks b kt ku kw kx kz mw ld mx lh my ll mz na nb nc bi translated">你用<code class="fe lm ln lo lp b">mapDispatchToProps</code>。</li><li id="fcf0" class="mu mv jb ks b kt nd kw ne kz nf ld ng lh nh ll mz na nb nc bi translated">您可以堆叠高阶组件，如<code class="fe lm ln lo lp b">connect</code>和<code class="fe lm ln lo lp b">reduxForm</code>。</li><li id="991f" class="mu mv jb ks b kt nd kw ne kz nf ld ng lh nh ll mz na nb nc bi translated">您必须为一个组件组合两个或更多的状态选择器。</li><li id="7117" class="mu mv jb ks b kt nd kw ne kz nf ld ng lh nh ll mz na nb nc bi translated">您并不真正知道哪些组件是状态包装的，哪些不是(想想新的开发人员)。</li></ul><p id="f9fe" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这里有一个复杂的组件，在<code class="fe lm ln lo lp b">connect</code>和<code class="fe lm ln lo lp b">ReduxConnection</code>中都有魔法道具:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="381e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这两个例子的主要区别是<code class="fe lm ln lo lp b">namespace</code>道具。使用<code class="fe lm ln lo lp b">connect</code>的时候不见了，因为在<code class="fe lm ln lo lp b">mapStateToProps</code>是引擎盖下用的。您必须知道如何将它传入并添加到PropTypes中，因为它从未被<code class="fe lm ln lo lp b">PersonsList</code>直接使用过。如果错过了，很快就会变成调试灾难。</p><p id="b32f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">还要注意，在组件级别要跟踪的PropTypes要少得多。显然，如果你使用的是Flow或TypeScript，你会希望涵盖进入渲染道具的类型，但从组件道具的角度来看，这只是变得更加清晰。</p><p id="8547" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在<code class="fe lm ln lo lp b">connect</code>中使用<code class="fe lm ln lo lp b">mapDispatchToProps</code>的另一个变化是我们必须定义<code class="fe lm ln lo lp b">dispatch</code>并将其作为渲染道具。那是我们唯一可以走那条路的方法。<code class="fe lm ln lo lp b">ReduxConnection</code>的好处是你可以把它放在任何地方，并且可以非常精确地知道在哪里使用<code class="fe lm ln lo lp b">dispatch</code>函数。</p><h1 id="996e" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">重构</h1><p id="8dcb" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">你可能已经注意到这些文件中有很多跳转。大多数人不会像我一样写垂直间隔的组件，但我想让它变得明显，渲染道具，事实上，当内联使用时，可以突出你的组件。</p><p id="4e3a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这是有益的；虽然在很多情况下并不需要，但是将组件的一些部分分离成更小的组件。这就是<code class="fe lm ln lo lp b">ReduxConnection</code>上的<code class="fe lm ln lo lp b">component</code>支柱派上用场的地方。感谢React-Router v4+的创意！</p><p id="adc6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现在我们可以进一步精简:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1599" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe lm ln lo lp b">ReduxConnection</code>允许这些类型的简化，而不必创建一堆额外的组件，这些组件本身也必须包装在<code class="fe lm ln lo lp b">connect</code>中。<code class="fe lm ln lo lp b">PersonsList</code>现在是一个智能组件，只告诉它的孩子从哪里得到他们需要的东西。</p><h1 id="f2fa" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">为什么不应该使用<code class="fe lm ln lo lp b">mapDispatchToProps</code></h1><p id="deb8" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated"><code class="fe lm ln lo lp b">mapDispatchToProps</code>是一个奇妙的小助手函数，它移除了Redux对组件的依赖性。此时，看起来您只是将函数作为道具传递，然后像往常一样调用这些函数。</p><p id="01d9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">可悲的是，这样做的副作用是隐藏了一个事实，即当一个函数被调用时，你正在调度一个动作。</p><p id="3cde" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">很有可能您的组件可能接受多个函数，但并不是所有的函数都包装在dispatch中。也可能是您利用JavaScript作用域，最终不知道您使用的函数是传入的还是导入的。或者在另一种情况下，您的高阶组件通过了<code class="fe lm ln lo lp b">mapDispatchToProps</code>，但是当您加载组件并希望添加功能或修复bug时，您无法看到这一点。</p><p id="9174" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当试图快速辨别组件的功能时，所有这些都会导致不必要的混乱。</p><h1 id="29c4" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">冗余连接的缺点</h1><p id="134d" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">在处理渲染道具时，有一些事情你需要知道。如果提供道具的组件(如<code class="fe lm ln lo lp b">ReduxConnection</code>)自定义<code class="fe lm ln lo lp b">shouldComponentUpdate</code>，则需要传递渲染道具函数使用的相同道具；否则，它不会有来自父组件的最新道具。</p><p id="cf8b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这里有一个例子，我试图通过包装<code class="fe lm ln lo lp b">ListItem</code>来优化<code class="fe lm ln lo lp b">dispatch</code>的位置，而不是将其包含在父<code class="fe lm ln lo lp b">ReduxConnection</code>中:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="f83e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在本例中，如果<code class="fe lm ln lo lp b">listItems</code>发生变化，因为<code class="fe lm ln lo lp b">ReduxConnection</code>知道您正在关闭<code class="fe lm ln lo lp b">id</code>和<code class="fe lm ln lo lp b">name</code>，那么<code class="fe lm ln lo lp b">ReduxConnection</code>将不会更新<code class="fe lm ln lo lp b">id</code>或<code class="fe lm ln lo lp b">name</code>。解决方案是使用简化的示例，从<code class="fe lm ln lo lp b">map</code>函数中直接将<code class="fe lm ln lo lp b">component</code>道具传递道具作为<code class="fe lm ln lo lp b">ReduxConnection</code>上的道具。这样，您可以关闭它们，并且<code class="fe lm ln lo lp b">ReduxConnection</code>会意识到关闭。</p><p id="77d5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这不是<code class="fe lm ln lo lp b">connect</code>的问题，因为你被迫将道具传递给组件。在<code class="fe lm ln lo lp b">connect</code>中，没有关闭道具的选项。幸运的是，你可以用<code class="fe lm ln lo lp b">component</code>道具模仿<code class="fe lm ln lo lp b">connect</code>在<code class="fe lm ln lo lp b">ReduxConnection</code>中的功能，并且仍然获得渲染道具的大部分优势。</p><p id="9470" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">虽然解决这个问题很容易，但是如果您不知道它的工作方式，调试可能是一场噩梦。将来这个问题会得到解决，但目前还不是这样。只要您的团队得到通知，您应该能够使用<code class="fe lm ln lo lp b">ReduxConnection</code>并解决闭包带来的问题。</p><p id="bf76" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">您还可以用自己的组件包装ReduxConnection，并用一个<code class="fe lm ln lo lp b">randomNumber={Math.random()}</code> prop强制它更新。</p><h1 id="08e6" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">今天就开始用<code class="fe lm ln lo lp b">ReduxConnection</code>吧！</h1><p id="c28f" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">你今天就可以开始使用<code class="fe lm ln lo lp b">ReduxConnection</code>！查看npm的初始版本，请点击此处:</p><div class="ip iq gp gr ir ns"><a href="https://www.npmjs.com/package/@ghadyani-framework/redux-components" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jc gy z fp nx fr fs ny fu fw ja bi translated">@ ghadyani-framework/redux-components</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">Redux助手组件。</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">www.npmjs.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og ix ns"/></div></div></a></div><p id="3151" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果你很好奇，可以在GitHub上找到源代码:<br/><a class="ae lq" href="https://github.com/Sawtaytoes/Ghadyani-Framework-Redux-Components/blob/master/components/ReduxConnection.js" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/Sawtaytoes/Ghadyani-Framework-Redux-Components/blob/master/Components/Redux connection . js</a></p><h1 id="7653" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">特别感谢</h1><p id="beed" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">我要感谢杰森·纳尔。他的<a class="ae lq" href="https://github.com/jsonnull/redux-render" rel="noopener ugc nofollow" target="_blank"> redux-render </a>库启发我编写自己的库。我从他的原始结构中格式化了ReduxConnection的基本概念。</p><h1 id="bfaa" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">更多阅读</h1><p id="b4c8" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">如果您对与React相关的更多主题感兴趣，您应该查看我的其他文章:</p><ul class=""><li id="21e8" class="mu mv jb ks b kt ku kw kx kz mw ld mx lh my ll mz na nb nc bi translated"><a class="ae lq" href="https://medium.com/@Sawtaytoes/the-secret-to-using-redux-createnamespacereducer-d3fed2ccca4a" rel="noopener">使用Redux的秘密:createNamespaceReducer </a></li><li id="c67f" class="mu mv jb ks b kt nd kw ne kz nf ld ng lh nh ll mz na nb nc bi translated"><a class="ae lq" href="https://medium.com/@Sawtaytoes/using-redux-reducers-in-react-components-4e92985dd9cb" rel="noopener">在React组件中使用Redux还原剂</a></li><li id="7284" class="mu mv jb ks b kt nd kw ne kz nf ld ng lh nh ll mz na nb nc bi translated"><a class="ae lq" href="https://medium.com/@Sawtaytoes/redux-observable-can-solve-your-state-problems-15b23a9649d7" rel="noopener"> Redux-Observable可以解决你的状态问题</a></li><li id="c569" class="mu mv jb ks b kt nd kw ne kz nf ld ng lh nh ll mz na nb nc bi translated"><a class="ae lq" href="https://medium.com/flicblog/flic-buttons-and-the-observable-customization-using-rxjs-2214bc53d407" rel="noopener"> RxJS和可观察的Flic按钮</a></li><li id="b18e" class="mu mv jb ks b kt nd kw ne kz nf ld ng lh nh ll mz na nb nc bi translated">函数式编程的表情爱好者指南:第一部分</li></ul></div></div>    
</body>
</html>