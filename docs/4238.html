<html>
<head>
<title>Testing Airflow data pipelines with Catcher end to end</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用捕集器端到端测试气流数据管道</h1>
<blockquote>原文：<a href="https://itnext.io/testing-airflow-data-pipelines-with-catcher-end-to-end-93cec5c881ad?source=collection_archive---------5-----------------------#2020-05-20">https://itnext.io/testing-airflow-data-pipelines-with-catcher-end-to-end-93cec5c881ad?source=collection_archive---------5-----------------------#2020-05-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9e41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文是关于为数据管道编写端到端测试的。它将涵盖气流，作为当今最流行的数据管道调度程序之一，也是最复杂的测试之一。对于不耐烦的人来说——这里是已经设置好一切的<a class="ae kl" href="https://github.com/comtihon/catcher_airflow_example" rel="noopener ugc nofollow" target="_blank">库</a>。</p><h1 id="d114" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">什么是数据管道，为什么测试它很重要？</h1><p id="e3b3" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">这是一种开发模式，当我们从一个或几个数据源获取数据，处理它(不总是)并把它转移到另一个地方。可以是实时的，也可以是批量的。它可以通过不同的框架和工具(如气流，火花，弹簧批，手工制作)来完成。<br/>但它有一个共同点:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/d010795a47797ba3293e9eddfb8820e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/0*g8XGL8WuKEXXOPyS.jpg"/></div></figure><p id="1912" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">任何数据管道都非常难以测试，因为您总是需要一个完全部署的系统，预先准备好数据集和外部服务的模拟。</p><p id="8692" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设您有一个标准的业务案例:您的后端正在将结果发送到Postgres，您需要在Salesforce中更新商家的状态，以便您的客户支持代理能够即时回答客户的问题。</p><p id="3f5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要测试它，你必须通过这些复杂的步骤:</p><ul class=""><li id="dd57" class="lx ly iq jp b jq jr ju jv jy lz kc ma kg mb kk mc md me mf bi translated">从生产中下载数据，并对其进行个性化处理；</li><li id="eaa7" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">设置沙箱或直接在代码中使用模拟；</li></ul><h1 id="e05a" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">什么是捕手，它如何帮助你？</h1><p id="91b2" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">Catcher是一个端到端工具l，专门设计用于测试包含许多组件的系统。最初是作为端到端微服务测试工具开发的，它非常适合数据管道测试的需求。</p><p id="3715" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主要捕集器的特点是:</p><ul class=""><li id="875e" class="lx ly iq jp b jq jr ju jv jy lz kc ma kg mb kk mc md me mf bi translated">模块化架构。它有许多不同需求的模块——从<a class="ae kl" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank">卡夫卡</a>到<a class="ae kl" href="https://aws.amazon.com/s3/" rel="noopener ugc nofollow" target="_blank">S3</a>；</li><li id="99db" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">模板。它完全支持<a class="ae kl" href="https://jinja.palletsprojects.com/en/2.11.x/" rel="noopener ugc nofollow" target="_blank"> Jinja2 </a>模板，让您轻松生成数据集；</li><li id="3c03" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">不同环境的不同清单文件。在本地编写您的测试，并通过更改库存文件在云环境中运行；</li></ul><p id="f27b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里阅读<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/catcher-e2e-tests-tool-for-beginners-359413721e28">。</a></p><p id="2b23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您是Catcher新手，您会发现这篇文章很有用。</p><h1 id="7b59" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">管道</h1><p id="ee65" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">想象一下，您有一个处理用户注册的后端。所有新注册的用户都存储在MySQL中。你也有另一个后端工程与GDPR和退订。业务需求是—第二个后端应该以某种方式知道新创建的用户，因为它需要这些信息来进行适当的取消订阅事件匹配。最后一点是——你的后端开发人员不知道Kafka/Rabbit，所以唯一的方法是编写一个管道，将数据从MySQL上传到Postgres。</p><p id="66aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">管道将:</p><ol class=""><li id="7908" class="lx ly iq jp b jq jr ju jv jy lz kc ma kg mb kk ml md me mf bi translated">从MySQL获取数据并加载到S3</li><li id="c165" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk ml md me mf bi translated">把S3的数据放到Postgres中</li></ol><pre class="lq lr ls lt gt mm mn mo mp aw mq bi"><span id="d925" class="mr kn iq mn b gy ms mt l mu mv">start &gt;&gt; mysql_to_s3 &gt;&gt; s3_to_psql &gt;&gt; end</span></pre><p id="4f73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在现实世界中，该管道的第2步和第3步最有可能被加入到自定义操作符MySQLtoPostgresViaS3Operator中。但是这里我们把它分开，以展示一个比一个实际的步骤管道更长的例子:)。</p><p id="ce8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">start和end都是伪运算符。我添加它是因为它是一个定制通知slack等的好地方。<br/> <code class="fe mw mx my mn b">mysql_to_s3</code>是一个python运算符:</p><pre class="lq lr ls lt gt mm mn mo mp aw mq bi"><span id="a03e" class="mr kn iq mn b gy ms mt l mu mv">mysql_to_s3 = PythonOperator(task_id='mysql_to_s3',<br/>                             python_callable=mysql_to_s3,<br/>                             retries=0,<br/>                             dag=dag,<br/>                             provide_context=True)</span></pre><p id="a5b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它只是调用<code class="fe mw mx my mn b">mysql_to_s3</code>函数:</p><pre class="lq lr ls lt gt mm mn mo mp aw mq bi"><span id="b092" class="mr kn iq mn b gy ms mt l mu mv">def mysql_to_s3(**context): <br/>  mysql_hook = MySqlHook(mysql_conn_id=mysql_conn_id) <br/>  s3_hook = S3Hook(aws_conn_id=aws_conn_id) <br/>  sql = f'Select * from {mysql_tbl_name} order by email' <br/>  df: DataFrame = mysql_hook.get_pandas_df(sql=sql) <br/>  with NamedTemporaryFile(newline='', mode='w+') as f: <br/>    key_file = f"data/{mysql_tbl_name}/year={datetime.date.today().year}/" \ <br/>               f"month={datetime.date.today().strftime('%m')}/" \ <br/>               f"day={datetime.date.today().strftime('%d')}/" \ <br/>               f"{mysql_tbl_name}.csv" <br/>    df.to_csv(path_or_buf=f, <br/>              sep=",", <br/>              columns=df.columns.values.tolist(), <br/>              index=False ) <br/>    f.flush() <br/>    s3_hook.load_file(filename=f.name, <br/>                      key=key_file, <br/>                      bucket_name=bucket_name)  <br/>    context["ti"].xcom_push(key=key_str, value=key_file) <br/>    f.close()</span></pre><p id="697f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个函数中，我们通过MySQL hook从给定的SQL查询中检索Pandas数据帧(请注意，确保该查询不会读取太多数据，也不会使内存过载，否则会成块读取)，并将该数据帧作为CSV文件存储在S3上。</p><p id="a907" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">S3文件被加载后的下一个任务:<code class="fe mw mx my mn b">s3_to_psql</code>被调用:</p><pre class="lq lr ls lt gt mm mn mo mp aw mq bi"><span id="d082" class="mr kn iq mn b gy ms mt l mu mv">s3_to_psql = PythonOperator(task_id='s3_to_psql', <br/>                            python_callable=s3_to_psql, <br/>                            retries=0, <br/>                            dag=dag, <br/>                            provide_context=True)</span></pre><p id="4b48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它也是一个调用<code class="fe mw mx my mn b">s3_to_psql</code>函数的python操作符:</p><pre class="lq lr ls lt gt mm mn mo mp aw mq bi"><span id="40b0" class="mr kn iq mn b gy ms mt l mu mv">def s3_to_psql(**context): <br/>  ti = context["ti"] <br/>  key_file = ti.xcom_pull(dag_id='simple_example_pipeline', <br/>                          task_ids='mysql_to_s3', <br/>                          key=key_str) <br/>  psql_hook = PostgresHook(postgres_conn_id=postgres_conn_id) <br/>  s3_hook = S3Hook(aws_conn_id=aws_conn_id) <br/>  lines = s3_hook.read_key(key=key_file, bucket_name=bucket_name).split("\n") <br/>  lines = [tuple(line.split(',')) for line in lines if line != ''] <br/>  df = DataFrame.from_records(data=lines[1:], columns=lines[0]) <br/>  df.to_sql(name=psql_tbl_name, <br/>            con=psql_hook.get_sqlalchemy_engine(), <br/>            if_exists="replace", <br/>            index=False)</span></pre><p id="1cb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个函数中，我们将文件从S3读入工作内存，从中构建Pandas数据帧，并将其存储到Postgres中。</p><p id="eddf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有气流连接id都是在文件开头硬编码的:</p><pre class="lq lr ls lt gt mm mn mo mp aw mq bi"><span id="bb61" class="mr kn iq mn b gy ms mt l mu mv">postgres_conn_id = 'psql_conf' <br/>mysql_conn_id = 'mysql_conf' <br/>aws_conn_id = 's3_config'</span></pre><p id="cc80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您无需费心将其添加到气流测试环境中——Catcher将在运行测试期间为您处理。</p><p id="ac54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅此而已。现在是检验它的时候了。</p><h1 id="5ecc" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">测试本身</h1><p id="c414" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">让我们从定义Catcher测试局部变量开始:</p><pre class="lq lr ls lt gt mm mn mo mp aw mq bi"><span id="0332" class="mr kn iq mn b gy ms mt l mu mv">variables: <br/>  users: <br/>    - uuid: '{{ random("uuid4") }}' <br/>      email: 'bar@test.com' <br/>    - uuid: '{{ random("uuid4") }}' <br/>      email: 'baz@test.com' <br/>    - uuid: '{{ random("uuid4") }}' <br/>      email: 'foo@test.com' <br/>  pipeline: 'simple_example_pipeline' <br/>  mysql_tbl_name: 'my_table'</span></pre><p id="6365" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们设置了Airflow的管道名、mysql表名和3个将被导出的用户。</p><p id="e16e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在这里提供两种不同的库存:一种用于本地运行，一种用于码头运行。哪些存货由你决定，取决于具体情况。<br/>本地<a class="ae kl" href="https://github.com/comtihon/catcher_airflow_example/blob/master/inventory/local.yml" rel="noopener ugc nofollow" target="_blank">库存</a>是:</p><pre class="lq lr ls lt gt mm mn mo mp aw mq bi"><span id="6481" class="mr kn iq mn b gy ms mt l mu mv">mysql_conf: 'root:test@localhost:3307/test' <br/>psql_conf: 'postgres:postgres@localhost:5432/postgres' <br/>airflow_db: 'airflow:airflow@localhost:5433/airflow' <br/>airflow_web: 'http://127.0.0.1:8080' <br/>s3_config: <br/>  url: <a class="ae kl" href="http://127.0.0.1:9001" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:9001</a> <br/>  key_id: minio <br/>  secret_key: minio123</span></pre><p id="f77b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您已经有了<code class="fe mw mx my mn b">stage</code>或<code class="fe mw mx my mn b">dev </code>环境设置，您可以为其添加清单，就像我们为local所做的一样，但是指定DNS名称而不是localhost ip地址。</p><p id="3030" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Docker <a class="ae kl" href="https://github.com/comtihon/catcher_airflow_example/blob/master/inventory/docker.yml" rel="noopener ugc nofollow" target="_blank"> inventory </a>是一样的，但是用域名代替了localhost。</p><pre class="lq lr ls lt gt mm mn mo mp aw mq bi"><span id="c550" class="mr kn iq mn b gy ms mt l mu mv">mysql_conf: 'mysql://root:test@mysql:3306/test' <br/>psql_conf: 'postgresql://postgres:postgres@custom_postgres_1:5432/postgres' <br/>airflow_db: 'airflow:airflow@postgres:5432/airflow' <br/>airflow_web: 'http://webserver:8080' <br/>airflow_fernet: 'zp8kV516l9tKzqq9pJ2Y6cXbM3bgEWIapGwzQs6jio4=' s3_config: <br/>  url: <a class="ae kl" href="http://minio:9000" rel="noopener ugc nofollow" target="_blank">http://minio:9000</a> <br/>  key_id: <br/>  minio secret_key: minio123</span></pre><h2 id="a8f4" class="mr kn iq bd ko mz na dn ks nb nc dp kw jy nd ne la kc nf ng le kg nh ni li nj bi translated">步伐</h2><p id="025e" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated"><strong class="jp ir">第一步</strong>应该填充测试数据:它创建MySQL和Postgres表并生成数据。作为一名数据工程师，它可以让你避免枯燥的工作，简化你的生活。忘记测试数据集手动构建和生产数据导出到csv并复制到测试环境。以及与之相关的各种问题:数据匿名化、sql中的正则表达式和生成器。</p><p id="2e18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了准备您的测试数据<a class="ae kl" href="https://catcher-modules.readthedocs.io/en/latest/source/prepare_expect.html" rel="noopener ugc nofollow" target="_blank">准备</a>步骤最适合:</p><pre class="lq lr ls lt gt mm mn mo mp aw mq bi"><span id="5466" class="mr kn iq mn b gy ms mt l mu mv">prepare: <br/>  populate: <br/>    mysql: <br/>      conf: '{{ mysql_conf }}' <br/>      schema: my_table.sql <br/>      data: <br/>        my_table: my_table.csv <br/>    postgres: <br/>      conf: '{{ psql_conf }}' <br/>      schema: psql_tbl.sql</span></pre><p id="0721" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您在<code class="fe mw mx my mn b">prepare</code>中看到的，我们已经为MySQL和Postgres数据源定义了<code class="fe mw mx my mn b">populate</code>。对于两个数据源，这一步遵循相同的逻辑:提供配置并从指定的SQL文件运行DDL代码。<code class="fe mw mx my mn b">mysql_conf</code>和<code class="fe mw mx my mn b">psql_conf</code>值都来自当前的库存文件(您正在使用它运行测试)。</p><p id="2b58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">唯一不同的是，对于<code class="fe mw mx my mn b">mysql</code>，我们指定了用于填充<code class="fe mw mx my mn b">my_table</code>的输入数据。我们没有为Postgres指定输入数据，因为它应该在执行过程中由我们的气流管道填充。让我们更深入地了解mysql populate语句是如何定义的。</p><p id="6735" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/comtihon/catcher_airflow_example/blob/master/resources/my_table.sql" rel="noopener ugc nofollow" target="_blank"> my_table.sql </a>是包含create table语句的sql文件。在现实世界中，您也可以在这里使用grant access语句，添加索引等:</p><pre class="lq lr ls lt gt mm mn mo mp aw mq bi"><span id="f661" class="mr kn iq mn b gy ms mt l mu mv">CREATE TABLE if not exists test.my_table( <br/>                     user_id varchar(36) primary key, <br/>                     email varchar(36) NOT NULL <br/>                     );</span></pre><p id="681c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/comtihon/catcher_airflow_example/blob/master/resources/my_table.csv" rel="noopener ugc nofollow" target="_blank"> my_table.csv </a>是一个数据文件，与一般测试方法的主要区别是——我们在这里不指定实际数据。我们从一开始就应用Jinja2模板来基于我们的<code class="fe mw mx my mn b">users</code>变量生成csv文件。所以Catcher最酷的特性之一:它到处支持Jinja2模板。</p><pre class="lq lr ls lt gt mm mn mo mp aw mq bi"><span id="989c" class="mr kn iq mn b gy ms mt l mu mv">user_id,email<br/>{%- for user in users -%}<br/>{{ user.uuid }},{{ user.email }}<br/>{%- endfor -%}</span></pre><p id="fb35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/comtihon/catcher_airflow_example/blob/master/resources/psql_tbl.sql" rel="noopener ugc nofollow" target="_blank"> psql_tbl.sql </a>与<code class="fe mw mx my mn b">my_table.sql</code>几乎相同，但具有另一个表名。</p><p id="c4c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当所有的数据都准备好了，我们应该触发我们的管道。这是第<strong class="jp ir">第二</strong>步:</p><pre class="lq lr ls lt gt mm mn mo mp aw mq bi"><span id="c827" class="mr kn iq mn b gy ms mt l mu mv">- airflow: <br/>    run: <br/>      config: <br/>        db_conf: '{{ airflow_db }}' <br/>        url: '{{ airflow_web }}' <br/>        populate_connections: true <br/>        fernet_key: '{{ airflow_fernet }}'  <br/>      dag_id: '{{ pipeline }}' <br/>      sync: true <br/>      wait_timeout: 150</span></pre><p id="cf2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它将运行气流管道<code class="fe mw mx my mn b">simple_example_pipeline</code>，并等待它完成(或在150秒内失败)。并且它还将<a class="ae kl" href="https://catcher-modules.readthedocs.io/en/latest/source/airflow.html" rel="noopener ugc nofollow" target="_blank">基于您的捕集器库存文件创建</a>气流连接。</p><p id="c7e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一点很重要——Catcher将在气流中创建连接，并将它们命名为库存文件中的名称:</p><p id="14a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于库存中的<code class="fe mw mx my mn b">psql_conf: 'postgres:<a class="ae kl" href="mailto:postgres@localhost" rel="noopener ugc nofollow" target="_blank">postgres@localhost</a>:5432/postgres'</code>,它将在气流中创建连接<code class="fe mw mx my mn b">psql_conf</code>。因此，为了进行工作测试，管道中的连接id应该与库存文件中的连接id相同:<code class="fe mw mx my mn b">postgres_conn_id = 'psql_conf'</code>。名字本身并不重要。</p><p id="b803" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第三步</strong>检查S3文件是否已创建并下载:</p><pre class="lq lr ls lt gt mm mn mo mp aw mq bi"><span id="740c" class="mr kn iq mn b gy ms mt l mu mv">- s3: <br/>    get: <br/>      config: '{{ s3_config }}' <br/>      path: 'my_awesome_bucket/data/{{ mysql_tbl_name }}/year={{ now()[:4] }}/month={{ now()[5:7] }}/day={{ now()[8:10] }}/my_table.csv' <br/>    register: {s3_csv: '{{ OUTPUT }}'}</span></pre><p id="26e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们上面所说的，Catcher可以在任何地方应用jinja模板，在这里你可以看到一个例子，如何构建到我们的S3资源的路径。我们在原始管道中的路径是动态构建的，取决于execution_date。我们现在使用内置函数<a class="ae kl" href="https://catcher-test-tool.readthedocs.io/en/latest/source/catcher.modules.filter_impl.html#catcher.modules.filter_impl.bifs.function_now" rel="noopener ugc nofollow" target="_blank"/>()，它以字符串形式返回当前日期时间，并应用一些python字符串操作，如<code class="fe mw mx my mn b">[5:7]</code>来仅检索字符串的一部分。我们提取资源并将步骤的输出注册为一个新变量<code class="fe mw mx my mn b">s3_csv</code>。</p><p id="02e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">接下来的</strong>两步是从资源文件中加载内容并与<code class="fe mw mx my mn b">s3_csv</code>进行比较(我们在原始气流管道中的最后一步):</p><pre class="lq lr ls lt gt mm mn mo mp aw mq bi"><span id="cafc" class="mr kn iq mn b gy ms mt l mu mv">- echo: {from_file: 'my_table.csv', register: {expect_csv: '{{ OUTPUT }}'}} <br/>- check: <br/>    equals: {the: '{{ s3_csv.strip() }}', is: '{{ expect_csv.strip() }}'} <br/>    name: 'Check data in s3 expected'</span></pre><p id="651b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://catcher-test-tool.readthedocs.io/en/latest/source/catcher.steps.html?highlight=echo#catcher.steps.echo.Echo" rel="noopener ugc nofollow" target="_blank"> echo </a>步骤也可用于写入或读取文件。这里我们读取相同的资源<code class="fe mw mx my mn b">my_table.csv</code>，它用于填充MySQL并将step的输出保存到变量<code class="fe mw mx my mn b">expect_csv</code>。Echo step还将运行Jinja2模板并生成适当的内容。</p><p id="4f7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://catcher-test-tool.readthedocs.io/en/latest/source/internal_modules.html?highlight=check#module-catcher.steps.check" rel="noopener ugc nofollow" target="_blank">检查</a>等于<a class="ae kl" href="https://catcher-test-tool.readthedocs.io/en/latest/source/internal_modules.html?highlight=check#catcher.steps.check.Equals" rel="noopener ugc nofollow" target="_blank">步骤用于比较<code class="fe mw mx my mn b">expect_csv</code>和<code class="fe mw mx my mn b">s3_csv</code>变量值。因为它们的内容是字符串，我们使用python的string </a><a class="ae kl" href="https://docs.python.org/3.7/library/stdtypes.html#str.strip" rel="noopener ugc nofollow" target="_blank"> strip </a>()方法来删除最后的空格和结束行。</p><p id="e8bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一个步骤是检查Postgres中实际写入了什么。<a class="ae kl" href="https://catcher-modules.readthedocs.io/en/latest/source/prepare_expect.html#expect" rel="noopener ugc nofollow" target="_blank">期望</a>步骤最适合我们:</p><pre class="lq lr ls lt gt mm mn mo mp aw mq bi"><span id="c8a8" class="mr kn iq mn b gy ms mt l mu mv">- expect: <br/>    compare: <br/>      postgres: <br/>        conf: '{{ psql_conf }}' <br/>        data: <br/>          psql_tbl: 'my_table.csv' <br/>        strict: true <br/>    name: 'Postgres data match expected'</span></pre><h2 id="3185" class="mr kn iq bd ko mz na dn ks nb nc dp kw jy nd ne la kc nf ng le kg nh ni li nj bi translated">竣工清理</h2><p id="047f" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们需要在测试后添加清理，以消除任何副作用，以便在干净的环境下运行其他测试。</p><p id="d3c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们将块<code class="fe mw mx my mn b">finally</code>添加到测试的根:</p><pre class="lq lr ls lt gt mm mn mo mp aw mq bi"><span id="d412" class="mr kn iq mn b gy ms mt l mu mv">finally: <br/>  - mysql: <br/>      request: <br/>        conf: '{{ mysql_conf }}' <br/>        query: 'drop table my_table' <br/>      name: 'Clean up mysql' <br/>      ignore_errors: true <br/>  - postgres: <br/>      request: <br/>        conf: '{{ psql_conf }}' <br/>        query: 'drop table psql_tbl' <br/>      name: 'Clean up postgres' <br/>      ignore_errors: true <br/>  - s3: <br/>      delete: <br/>        config: '{{ s3_config }}' <br/>        path: 'my_awesome_bucket/data/{{ mysql_tbl_name }}/year={{ now()[:4] }}/month={{ now()[5:7] }}/day={{ now()[8:10] }}/my_table.csv' <br/>      name: 'Clean up s3' <br/>      ignore_errors: true</span></pre><p id="357f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们从mysql和postgres删除所有数据，并从S3删除文件。<code class="fe mw mx my mn b">ignore_errors</code>意味着我们不关心操作是否失败(如果数据库中的S3或表上没有这样的文件)。顺便说一下，这里的好方法是将S3文件路径移到Catcher变量中，并在<code class="fe mw mx my mn b">S3:get</code>(步骤#3)和删除步骤中重用它，以减少代码重复。</p><h1 id="50ce" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">怎么跑</h1><h2 id="4918" class="mr kn iq bd ko mz na dn ks nb nc dp kw jy nd ne la kc nf ng le kg nh ni li nj bi translated">在docker本地</h2><p id="2927" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">如果你没有任何环境，你可以使用这个docker-compose在本地创建一个。它基于<a class="ae kl" href="https://github.com/puckel/docker-airflow" rel="noopener ugc nofollow" target="_blank"> puckel </a> -airflow docker库。</p><pre class="lq lr ls lt gt mm mn mo mp aw mq bi"><span id="8b1a" class="mr kn iq mn b gy ms mt l mu mv">docker-compose up -d</span></pre><p id="19e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在您启动docker-compose之后，您需要在<strong class="jp ir">相同的</strong>网络中运行catcher docker <a class="ae kl" href="https://hub.docker.com/repository/docker/comtihon/catcher" rel="noopener ugc nofollow" target="_blank"> image </a>挂载您的测试、资源并指定清单:</p><pre class="lq lr ls lt gt mm mn mo mp aw mq bi"><span id="b8c9" class="mr kn iq mn b gy ms mt l mu mv">docker run -it --volume=$(pwd)/test:/opt/catcher/test \ <br/>               --volume=$(pwd)/resources:/opt/catcher/resources \ <br/>               --volume=$(pwd)/inventory:/opt/catcher/inventory \ <br/>               --network catcherairflowexample_default \ <br/>                 comtihon/catcher -i inventory/docker.yml test</span></pre><p id="7d5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">网络非常重要，因为如果您要在本地运行catcher，您可能会对所有服务主机127.0.0.1使用本地清单。您和Catcher都可以访问它们，<strong class="jp ir">但是</strong> Catcher将使用您本地库存中的127.0.0.1填充Airflow连接，因此您的管道将失败，因为docker中的Airflow将无法通过127.0.0.1访问数据库/minio。</p><p id="6578" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">点击查看更多docker运行指令<a class="ae kl" href="https://catcher-test-tool.readthedocs.io/en/latest/source/run.html#docker" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="8bc3" class="mr kn iq bd ko mz na dn ks nb nc dp kw jy nd ne la kc nf ng le kg nh ni li nj bi translated">远程环境中</h2><p id="1982" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">自动化你的测试是一个很好的观点。您可以让您的配置项在每次部署到每个环境后运行catcher。可以从CI代理使用Catcher-in-docker或Catcher cli。只要使用适当的库存。</p><h2 id="a756" class="mr kn iq bd ko mz na dn ks nb nc dp kw jy nd ne la kc nf ng le kg nh ni li nj bi translated">输出</h2><p id="afa7" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">如果你运行你的测试，你会看到漂亮的彩色输出。它将被分成两部分。</p><p id="679d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先是逐步运行总结。它帮助您理解测试是如何运行的:</p><pre class="lq lr ls lt gt mm mn mo mp aw mq bi"><span id="b49e" class="mr kn iq mn b gy ms mt l mu mv">INFO:catcher:Step Create table and populate initial data OK INFO:catcher:Step Trigger pipeline simple_example_pipeline OK INFO:catcher:Step Get file from s3 OK INFO:catcher:user_id,email ea1d710b-0a7b-45f6-a1c4-52a5f7d91bce,bar@test.com cf0a3043-6958-412d-a7b0-924092e7e95b,baz@test.com e7a53958-f4aa-45e7-892e-69514990c992,foo@test.com INFO:catcher:Step echo OK INFO:catcher:Step Check data in s3 expected OK INFO:catcher:Step Postgres data match expected OK INFO:catcher:Test test/test.yml passed.</span></pre><p id="caaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和以下清理部分:</p><pre class="lq lr ls lt gt mm mn mo mp aw mq bi"><span id="4cf8" class="mr kn iq mn b gy ms mt l mu mv">INFO:catcher:Step Clean up mysql OK <br/>INFO:catcher:Step Clean up postgres OK <br/>INFO:catcher:Step Clean up s3 OK <br/>INFO:catcher:Test test/test.yml [cleanup] passed.</span></pre><p id="2f7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在多个测试的情况下，它们将相互跟随。</p><p id="5f00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二部分是运行总结，针对所有测试。它显示了每个测试运行的统计数据和状态。如果失败，它将显示步骤号。在我们的案例中:</p><pre class="lq lr ls lt gt mm mn mo mp aw mq bi"><span id="c60a" class="mr kn iq mn b gy ms mt l mu mv">INFO:catcher:Test run 1. Success: 1, Fail: 0. Total: 100% <br/>Test test: pass</span></pre><h1 id="4617" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结论</h1><p id="18fc" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">当开发人员听说端到端测试时，他们通常会想到复杂的BDD框架和他们需要编写的大量代码，以使一切正常工作。这不是关于捕手。创建测试不需要了解任何编程语言。</p><p id="1196" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当QA工程师听说端到端测试时，他们通常会想到很多手动操作，在测试时很容易错过或出错。这不是关于捕手。做一次你的手动动作，并把它们放入捕手的脚本中，在每次部署时重复。</p><p id="8416" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前端开发人员听到端到端测试，通常会想——“我们是前端开发人员，为什么需要端到端测试”。这不是关于捕手。在我的下一篇文章中，我将向您展示如何在一个Catcher脚本中自动化前端+后端测试。</p><p id="1c42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试愉快！</p></div></div>    
</body>
</html>