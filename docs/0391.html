<html>
<head>
<title>Running Jenkins builds in containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在容器中运行Jenkins构建</h1>
<blockquote>原文：<a href="https://itnext.io/running-jenkins-builds-in-containers-458e90ff2a7b?source=collection_archive---------2-----------------------#2018-03-04">https://itnext.io/running-jenkins-builds-in-containers-458e90ff2a7b?source=collection_archive---------2-----------------------#2018-03-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4470" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着<a class="ae kl" href="https://opensource.com/resources/what-docker" rel="noopener ugc nofollow" target="_blank"> Docker </a>和<a class="ae kl" href="https://opensource.com/resources/what-is-kubernetes" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>提供了一个可扩展的、可管理的应用平台，在容器中运行应用程序最近已经成为企业部门广泛接受的实践。基于容器的方法也非常适合在过去几年中势头强劲的<a class="ae kl" href="https://martinfowler.com/articles/microservices.html" rel="noopener ugc nofollow" target="_blank">微服务架构</a>。</p><p id="2df8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们只关注拥有容器应用程序平台的一个最重要的优势:我们可以动态地使用资源有限的隔离容器。让我们看看这将如何改变我们运行CI/CD任务的方式。</p><p id="5895" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">构建和打包应用程序需要一个可以下载源代码、访问依赖项并安装了构建工具的环境。作为构建的一部分运行单元和组件测试可能会使用本地端口，或者需要在某个地方运行第三方应用程序(数据库、消息代理等)。最后，我们通常有多个预先配置好的构建服务器，每个服务器都运行特定类型的作业。对于测试，我们维护第三方应用程序的专用实例(或尝试嵌入运行它们),并避免并行运行可能会破坏彼此结果的作业。这种CI/CD环境所需的预配置可能会很麻烦，而且随着团队在版本和开发平台之间的转换，不同工作所需的服务器数量可能会随着时间的推移而发生显著变化。</p><p id="d35a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们可以访问容器平台(现场或云中)，为什么不将资源密集型CI/CD任务执行转移到动态创建的容器中呢？可以为每个作业的执行独立地启动和配置构建环境。构建过程中的测试可以自由地使用这个孤立的盒子中的可用资源，同时我们也可以在一个只存在于这个作业的生命周期中的侧面容器中调用第三方应用程序。</p><p id="23ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">听起来不错…让我们看看它在现实生活中实际上是如何工作的。</p><blockquote class="km kn ko"><p id="76f6" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">这篇博客是基于一个真实世界的解决方案，我们为一个最近在<a class="ae kl" href="https://www.openshift.com/" rel="noopener ugc nofollow" target="_blank"> Red Hat OpenShift </a> v3.7集群上运行的项目整理的。OpenShift是Kubernetes的企业版，因此这些实践也适用于k8s集群。尝试下载<a class="ae kl" href="https://developers.redhat.com/products/cdk/overview/" rel="noopener ugc nofollow" target="_blank">红帽CDK </a>并运行<a class="ae kl" href="https://github.com/openshift/origin/tree/master/examples/jenkins" rel="noopener ugc nofollow" target="_blank">“詹金斯-短暂”或“詹金斯-持久”模板</a>，在OpenShift上为你创建一个预配置的詹金斯主模板。</p></blockquote><h2 id="6727" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">解决方案概述</h2><p id="026b" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">执行CI/CD任务(构建、测试等)的解决方案。)基于<a class="ae kl" href="https://wiki.jenkins.io/display/JENKINS/Distributed+builds" rel="noopener ugc nofollow" target="_blank"> Jenkins分布式构建</a>，这意味着:</p><ul class=""><li id="6e05" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated">需要一个Jenkins主服务器，它可以在集群内部运行，但也可以与外部主服务器一起工作</li><li id="8f69" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">Jenkins特性/插件照常可用，因此可以使用现有的项目</li><li id="6ac7" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">Jenkins GUI可用于配置、运行和浏览作业输出</li><li id="7685" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">如果你更喜欢代码，可以使用<a class="ae kl" href="https://jenkins.io/doc/book/pipeline/" rel="noopener ugc nofollow" target="_blank"> Jenkins Pipeline </a></li></ul><p id="30ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从技术角度来看，运行作业的动态容器是Jenkins代理节点。当构建开始时，首先启动一个新节点，并通过JNLP(端口5000)向Jenkins主节点“报到”。构建将排队等候，直到代理节点出现并获得构建。构建输出被发送回主服务器，就像普通的Jenkins代理服务器一样，但是一旦构建完成，代理容器就会关闭。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mf"><img src="../Images/41f20a36a5f3fb57029267f43c902516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kOREjLTvlsfG8LS3uR93Pw.png"/></div></div></figure><p id="539e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不同类型的构建(例如，java、nodejs、python等。)需要不同的代理节点。这并不新鲜——以前也可以使用标签来限制哪些代理节点应该运行构建。要为每个作业启动的Jenkins代理容器定义配置，您需要设置以下内容:</p><ul class=""><li id="6d7d" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated">要启动的docker映像</li><li id="d7fd" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">资源限制</li><li id="8c8e" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">环境变量</li><li id="76eb" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">已装载的卷</li></ul><p id="57e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的核心组件是Jenkins Kubernetes插件。这个插件与k8s集群交互(通过使用ServiceAccount)并启动/停止代理节点。在插件的配置下，可以将多个代理类型定义为“Kubernetes Pod模板”(在项目中通过标签<em class="kp">引用它们)。</em></p><p id="579c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些<a class="ae kl" href="https://access.redhat.com/containers/#/search/jenkins%2520slave" rel="noopener ugc nofollow" target="_blank">代理映像</a>是开箱即用的(也在<a class="ae kl" href="https://hub.docker.com/search/?isAutomated=0&amp;isOfficial=0&amp;page=1&amp;pullCount=0&amp;q=openshift+jenkins+slave+&amp;starCount=0" rel="noopener ugc nofollow" target="_blank"> centos7 </a>上):</p><ul class=""><li id="aa7e" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated"><a class="ae kl" href="https://github.com/openshift/jenkins/tree/master/slave-base" rel="noopener ugc nofollow" target="_blank"> jenkins-slave-base-rhel7 </a>:启动连接到Jenkins master的代理的基础映像。根据容器内存设置Java堆。</li><li id="16de" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">Jenkins-slave-Maven-rhel 7:Maven和Gradle构建的图像(扩展基础)</li><li id="70bf" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated"><a class="ae kl" href="https://github.com/openshift/jenkins/tree/master/slave-nodejs" rel="noopener ugc nofollow" target="_blank">Jenkins-slave-nodejs-rhel 7</a>:带有NodeJS4工具的图像(扩展基础)</li></ul><blockquote class="km kn ko"><p id="861e" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">请注意，这里描述的解决方案与OpenShift的<a class="ae kl" href="https://docs.openshift.com/container-platform/3.7/architecture/core_concepts/builds_and_image_streams.html#source-build" rel="noopener ugc nofollow" target="_blank">源到映像(S2I) </a>构建无关，但也可以用于某些CI/CD任务。</p></blockquote><h2 id="608b" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">学习材料</h2><p id="d213" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">有几个关于Jenkins在OpenShift上构建的博客和很好的文档。这些链接是很好的开始:</p><ul class=""><li id="010d" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated"><a class="ae kl" href="https://docs.openshift.com/container-platform/3.7/using_images/other_images/jenkins.html" rel="noopener ugc nofollow" target="_blank"> OpenShift Jenkins </a>图像文档和<a class="ae kl" href="https://github.com/openshift/jenkins" rel="noopener ugc nofollow" target="_blank">来源</a></li><li id="5fdb" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated"><a class="ae kl" href="https://blog.openshift.com/cicd-with-openshift/" rel="noopener ugc nofollow" target="_blank">带OpenShift的CI/CD</a>网络广播</li><li id="f6db" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated"><a class="ae kl" href="http://v1.uncontained.io/playbooks/continuous_delivery/external-jenkins-integration.html" rel="noopener ugc nofollow" target="_blank">外部詹金斯整合</a>行动手册</li></ul><p id="0ee7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快速浏览上面的这些资源，了解整体解决方案。在这里，我只想展示我们在应用这些实践时遇到的不同问题。</p><h2 id="152d" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">构建我的应用程序</h2><p id="52ba" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">作为一个<a class="ae kl" href="https://github.com/bszeti/camel-springboot/tree/master/camel-rest-complex" rel="noopener ugc nofollow" target="_blank">例子</a>，让我们假设一个java项目有以下构建步骤:</p><ul class=""><li id="4d32" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated">Source:从Git存储库中提取项目源代码。</li><li id="86ad" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">使用maven构建:依赖项来自内部存储库(让我们使用Apache Nexus)镜像外部Maven存储库。</li><li id="7440" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">部署工件:构建的jar被上传到存储库。</li></ul><p id="1475" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在CI/CD流程中，我们需要与Git和Nexus进行交互，因此Jenkins作业需要以某种方式访问这些系统。这需要可以在不同位置管理的配置和存储的凭据:</p><ul class=""><li id="3270" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated">在Jenkins本身中:您可以向Jenkins添加git插件可以使用的凭证，并以某种方式向项目添加文件。没有什么新鲜的，只是因为我们使用容器。</li><li id="9cde" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">在OpenShift中:使用作为文件或环境变量添加到Jenkins代理容器中的ConfigMap和Secret对象。</li><li id="e6ef" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">在完全定制的Docker映像中:预先配置了运行某类作业所需的一切。扩展其中一个代理映像。</li></ul><p id="8a46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个偏好的问题，你最终的解决方案可能是一个组合。当配置主要在OpenShift中管理时，下面我们看一下第二个选项。我们通过设置环境变量和挂载文件，经由Kubernetes插件配置来定制<em class="kp"> maven </em>代理容器。</p><blockquote class="km kn ko"><p id="9abf" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">由于一个<a class="ae kl" href="https://issues.jenkins-ci.org/browse/JENKINS-47112" rel="noopener ugc nofollow" target="_blank">错误</a>，通过UI添加环境变量在Kubernetes plugin v1.0版中不起作用。作为一种解决方法，更新插件或直接编辑config.xml并重新启动Jenkins。</p></blockquote><h2 id="f4d1" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">从Git提取源代码</h2><p id="a406" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">拉一个公共git是微不足道的。对于私有git repo，需要身份验证，并且客户端需要信任服务器以获得安全连接。Git拉取通常可以通过两种协议完成:</p><ul class=""><li id="d9b4" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated">HTTPS:使用用户名/密码进行认证。服务器的SSL证书必须受到作业的信任，这只有在它由自定义CA签名时才比较棘手。<br/> <code class="fe mr ms mt mu b">git clone <a class="ae kl" href="https://git.mycompany.com:443/myproject.git" rel="noopener ugc nofollow" target="_blank">https://git.mycompany.com:443/myapplication.git</a></code></li><li id="e7b5" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">SSH:认证是用私钥进行的。当在<em class="kp"> known_hosts </em>文件中找到其公钥的指纹时，服务器是可信的。<br/> <code class="fe mr ms mt mu b">git clone <!-- -->ssh://git@git.mycompany.com:22/myapplication.git</code></li></ul><p id="7f01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">手动使用用户名/密码通过HTTP下载源代码是可以的，对于自动构建来说SSH更好。</p><h2 id="b29f" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">使用ssh运行Git</h2><p id="2ccb" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">对于ssh下载，显然我们需要确保代理容器和git的ssh端口之间的SSH连接正常工作。首先，我们需要一个私钥-公钥对。为了生成一个运行:<br/> <code class="fe mr ms mt mu b">ssh keygen -t rsa -b 2048 -f my-git-ssh -N ''<br/></code>它在<em class="kp"> my-git-ssh </em>(空密码短语)中生成一个私钥，在<em class="kp"> my-git-ssh.pub </em>中生成一个匹配的公钥。在git服务器上给用户添加公钥(最好是一个服务帐户)，web UIs通常支持上传。要使ssh连接工作，代理容器中需要两个文件:</p><ul class=""><li id="e545" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated">位于<em class="kp"> ~/的私钥。ssh/id_rsa </em></li><li id="8dfb" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">服务器的公钥在<em class="kp"> ~/中。ssh/known_hosts </em> <br/>要做到这一点，请在您的机器上尝试<code class="fe mr ms mt mu b">ssh git.mycompany.com </code>，接受指纹，这将在您的known_hosts文件中创建一个新行。用那个。</li></ul><p id="9fb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将私钥作为<em class="kp"> id_rsa </em>存储，将服务器的公钥作为<em class="kp"> known_hosts </em>存储在OpenShift secret(或配置映射)中。</p><pre class="mg mh mi mj gt mv mu mw mx aw my bi"><span id="2662" class="kt ku iq mu b gy mz na l nb nc">apiVersion: v1<br/>kind: Secret<br/>metadata:<br/>  name: mygit-ssh<br/>stringData:<br/>  id_rsa: |-<br/>    -----BEGIN RSA PRIVATE KEY-----<br/>    ...<br/>    -----END RSA PRIVATE KEY-----<br/>  known_hosts: |-<br/>    git.mycompany.com ecdsa-sha2-nistp256 AAA...</span></pre><p id="281a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后在Kubernetes插件中为挂载点<em class="kp"> /home/jenkins/的<em class="kp"> maven </em> pod配置一个卷。ssh/。</em>密匙中的每一项都将是挂载目录下一个与密匙名称相匹配的文件。你可以使用UI(管理Jenkins/Configure/Cloud/Kubernetes)，或者编辑Jenkins config<em class="kp">/var/lib/Jenkins/config . XML</em>:</p><pre class="mg mh mi mj gt mv mu mw mx aw my bi"><span id="2d1c" class="kt ku iq mu b gy mz na l nb nc">&lt;org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;<br/>&lt;name&gt;maven&lt;/name&gt;<br/>...<br/>  &lt;volumes&gt;<br/>    &lt;org.csanchez.jenkins.plugins.kubernetes.volumes.SecretVolume&gt;<br/>      &lt;mountPath&gt;/home/jenkins/.ssh&lt;/mountPath&gt;<br/>      &lt;secretName&gt;mygit-ssh&lt;/secretName&gt;<br/>    &lt;/org.csanchez.jenkins.plugins.kubernetes.volumes.SecretVolume&gt;<br/>  &lt;/volumes&gt;</span></pre><p id="4d99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，通过ssh拉git源代码应该可以在这个代理上运行的作业中工作。</p><blockquote class="km kn ko"><p id="f61b" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">也可以在~/中自定义ssh连接。ssh/config。例如，如果我们不想麻烦knows_hosts，或者私钥安装在不同的位置:</p></blockquote><pre class="mg mh mi mj gt mv mu mw mx aw my bi"><span id="1fae" class="kt ku iq mu b gy mz na l nb nc"><em class="kp">Host git.mycompany.com<br/>   StrictHostKeyChecking no<br/>   IdentityFile /home/jenkins/.config/git-secret/ssh-privatekey</em></span></pre><h2 id="387d" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">使用http的Git</h2><p id="e96f" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">如果首选HTTP下载，将用户名/密码添加到某处的<a class="ae kl" href="https://git-scm.com/docs/git-credential-store/1.8.2" rel="noopener ugc nofollow" target="_blank"> git-credential-store </a>文件中:</p><ul class=""><li id="0621" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated">例如/ <em class="kp"> home/jenkins/。来自OpenShift secret的config/git-secret/credentials</em>，每行一个站点:</li></ul><pre class="mg mh mi mj gt mv mu mw mx aw my bi"><span id="c908" class="kt ku iq mu b gy mz na l nb nc"><a class="ae kl" href="https://bszeti:d5pgj-yFhurFPZTkHHby@gitlab.consulting.redhat.com" rel="noopener ugc nofollow" target="_blank">https://username:password@git.mycompany.com</a><br/><a class="ae kl" href="https://username:password@git.mycompany.com" rel="noopener ugc nofollow" target="_blank">https://user:pass@github.com</a></span></pre><ul class=""><li id="5db3" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated">在<em class="kp"> /home/jenkins/预期的<a class="ae kl" href="https://git-scm.com/docs/git-config/1.8.2" rel="noopener ugc nofollow" target="_blank"> git-config </a>中启用它。config/git/config </em></li></ul><pre class="mg mh mi mj gt mv mu mw mx aw my bi"><span id="948e" class="kt ku iq mu b gy mz na l nb nc">[credential]<br/>  helper = store --file=/home/jenkins/.config/git-secret/credentials</span></pre><p id="f172" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果git服务有一个定制CA签署的证书，最快的方法就是为代理设置<code class="fe mr ms mt mu b">GIT_SSL_NO_VERIFY=true</code> env var。合适的解决方案需要两样东西:</p><ul class=""><li id="f821" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated">将自定义CA的公共证书从配置映射添加到代理容器的路径(例如<em class="kp">/usr/CA/mytrustedca . PEM</em>)</li><li id="b449" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">在一个env var <code class="fe mr ms mt mu b">GIT_SSL_CAINFO=/usr/ca/myTrustedCA.pem</code> <br/>或上面提到的git-config文件中告诉git这个证书的路径:</li></ul><pre class="mg mh mi mj gt mv mu mw mx aw my bi"><span id="05c6" class="kt ku iq mu b gy mz na l nb nc">[http <!-- -->"https://<!-- -->git.mycompany.com<!-- -->"<!-- -->]<br/>    sslCAInfo = /usr/ca/myTrustedCA.pem</span></pre><blockquote class="km kn ko"><p id="1b1c" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">在OpenShift v3.7版(以及更早版本)中，配置映射和秘密挂载点<a class="ae kl" href="https://bugzilla.redhat.com/show_bug.cgi?id=1430322" rel="noopener ugc nofollow" target="_blank">不能重叠</a>，所以你不能同时映射到<em class="iq"> /home/jenkins </em>和<em class="iq"> /home/jenkins/dir </em>。这就是为什么我们没有使用上面众所周知的文件位置。OpenShift v3.9版有望修复。</p></blockquote><h2 id="7d8d" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">专家</h2><p id="ccf1" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">要让Maven构建工作，通常要做两件事:</p><ul class=""><li id="5d11" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated">应建立一个公司Maven存储库(如Apache Nexus ),作为外部回购的代理。用这个当镜子。</li><li id="9c32" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">这个内部存储库可能有一个https端点，该端点带有由自定义CA签名的证书。</li></ul><p id="e6f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果构建在容器中运行，拥有一个内部maven存储库实际上是必不可少的，因为它们从一个空的本地存储库(缓存)开始，所以Maven每次都下载所有的jar。从本地网络上的内部代理回购下载显然比直接从互联网上下载要快。</p><p id="8e9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/openshift/jenkins/tree/master/slave-maven" rel="noopener ugc nofollow" target="_blank"> <em class="kp"> maven </em> Jenkins代理</a>镜像支持一个环境变量，该变量可用于设置该代理的url。在Kubernetes插件容器中设置模板:<br/> <code class="fe mr ms mt mu b">MAVEN_MIRROR_URL=https://nexus.mycompany.com/repository/maven-public</code></p><p id="ff54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">构建工件(jar)也应该归档在一个存储库中，这个存储库可能是也可能不是上面作为依赖关系镜像的那个存储库。Maven <em class="kp"> deploy </em>需要<a class="ae kl" href="https://maven.apache.org/pom.html#Distribution_Management" rel="noopener ugc nofollow" target="_blank"><em class="kp">distribution management</em></a>下pom.xml中的repo url(所以这与代理映像无关):</p><pre class="mg mh mi mj gt mv mu mw mx aw my bi"><span id="335f" class="kt ku iq mu b gy mz na l nb nc">&lt;project ...&gt;<br/>&lt;distributionManagement&gt;<br/> &lt;snapshotRepository&gt;<br/>  &lt;id&gt;mynexus&lt;/id&gt;<br/>  &lt;url&gt;<a class="ae kl" href="http://nexus3-bszeti-ci-cd.apps.na1.openshift.opentlc.com/repository/maven-snapshots/" rel="noopener ugc nofollow" target="_blank">https://nexus.mycompany.com/repository/maven-snapshots/</a>&lt;/url&gt;<br/> &lt;/snapshotRepository&gt;<br/> &lt;repository&gt;<br/>  &lt;id&gt;mynexus&lt;/id&gt;<br/>  &lt;url&gt;<a class="ae kl" href="http://nexus3-bszeti-ci-cd.apps.na1.openshift.opentlc.com/repository/maven-snapshots/" rel="noopener ugc nofollow" target="_blank">https://nexus.mycompany.com</a>/<a class="ae kl" href="http://nexus3-bszeti-ci-cd.apps.na1.openshift.opentlc.com/repository/maven-releases/" rel="noopener ugc nofollow" target="_blank">repository/maven-releases/</a>&lt;/url&gt;<br/> &lt;/repository&gt;<br/>&lt;/distributionManagement&gt;</span></pre><p id="d368" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上传工件可能需要身份验证。在这种情况下，用户名/密码必须设置在settings.xml中与pom.xml中的服务器id相匹配的服务器id下。我们需要从OpenShift secret在<em class="kp"> maven </em> Jenkins代理容器上挂载一个包含url、用户名和密码的完整settings.xml。我们还可以使用如下环境变量:</p><ul class=""><li id="2aa3" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated">将环境变量从一个secret添加到容器<br/>中<code class="fe mr ms mt mu b">MAVEN_SERVER_USERNAME=admin<br/>MAVEN_SERVER_PASSWORD=admin123</code></li><li id="dd6f" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">将settings.xml从配置映射挂载到<em class="kp">/home/Jenkins/. m2/settings . XML</em></li></ul><pre class="mg mh mi mj gt mv mu mw mx aw my bi"><span id="c609" class="kt ku iq mu b gy mz na l nb nc">&lt;settings ...&gt;<br/> &lt;mirrors&gt;<br/>  &lt;mirror&gt;<br/>   &lt;mirrorOf&gt;external:*&lt;/mirrorOf&gt;<br/>   &lt;url&gt;${env.MAVEN_MIRROR_URL}&lt;/url&gt;<br/>   &lt;id&gt;mirror&lt;/id&gt;<br/>  &lt;/mirror&gt;<br/> &lt;/mirrors&gt;<br/> &lt;servers&gt;<br/>  &lt;server&gt;<br/>   &lt;id&gt;mynexus&lt;/id&gt;<br/>   &lt;username&gt;${env.MAVEN_SERVER_USERNAME}&lt;/username&gt;<br/>   &lt;password&gt;${env.MAVEN_SERVER_PASSWORD}&lt;/password&gt;<br/>  &lt;/server&gt;<br/> &lt;/servers&gt;<br/>&lt;/settings&gt;</span></pre><blockquote class="km kn ko"><p id="5e90" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">禁用交互模式(使用批处理模式)来跳过下载日志，方法是对maven命令使用'-B '，或者在settings.xml中添加<code class="fe mr ms mt mu b"><em class="iq">&lt;interactiveMode&gt;false&lt;/interactiveMode</em></code> &gt;</p></blockquote><p id="3344" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果Maven repository https端点使用由定制CA签署的证书，我们需要使用<a class="ae kl" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html" rel="noopener ugc nofollow" target="_blank"> keytool </a>创建一个包含可信CA证书的Java密钥库。这个密钥库应该作为Openshift中的配置映射上传。使用<em class="kp"> oc </em>命令从文件创建配置图:</p><p id="3692" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mr ms mt mu b">oc create configmap maven-settings --from-file=settings.xml=settings.xml --from-file=myTruststore.jks=myTruststore.jks</code></p><p id="9337" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Jenkins代理上的某个地方挂载配置映射。在这个例子中，我们使用了<em class="kp"> /home/jenkins/.m2，</em>，但是仅仅因为我们在同一个配置映射中有settings.xml，所以密钥库可以放在任何路径下。</p><p id="b268" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，通过在容器的MAVEN_OPTS环境变量中设置java参数，使Maven java进程将该文件用作信任库:</p><pre class="mg mh mi mj gt mv mu mw mx aw my bi"><span id="9d2d" class="kt ku iq mu b gy mz na l nb nc">MAVEN_OPTS=<br/>-Djavax.net.ssl.trustStore=/home/jenkins/.m2/myTruststore.jks<br/>-Djavax.net.ssl.trustStorePassword=changeit</span></pre><h2 id="c15f" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">内存使用</h2><p id="139b" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">这可能是最重要的部分，因为如果你没有正确设置最大内存，你会在一切看起来正常工作后遇到间歇性的构建失败。</p><p id="1bd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们不在java命令行中设置堆，在容器中运行java会导致高内存使用错误。JVM <a class="ae kl" href="https://developers.redhat.com/blog/2017/03/14/java-inside-docker/" rel="noopener ugc nofollow" target="_blank">看到的是主机</a>的总内存，而不是容器的内存限制，并相应地设置<a class="ae kl" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html#default_heap_size" rel="noopener ugc nofollow" target="_blank">默认最大堆</a>。这通常远远超过容器的内存限制，当java进程为堆分配更多内存时，OpenShift会直接杀死容器。</p><p id="5627" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管jenkins-slave-base映像有一个内置的<a class="ae kl" href="https://github.com/openshift/jenkins/blob/master/slave-base/contrib/bin/run-jnlp-client" rel="noopener ugc nofollow" target="_blank">脚本来将max heap </a>设置为容器内存的一半(可以通过env var <code class="fe mr ms mt mu b">CONTAINER_HEAP_PERCENT=0.50</code>修改)，但它只适用于jenkins代理java进程。在Maven构建的情况下，我们有重要的额外java进程在运行:</p><ul class=""><li id="3725" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated">mvn命令本身就是一个java工具</li><li id="bfd1" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">默认情况下,<a class="ae kl" href="http://maven.apache.org/surefire/maven-surefire-plugin/examples/fork-options-and-parallel-execution.html" rel="noopener ugc nofollow" target="_blank"> maven-surefire-plugin </a>在分叉的JVM中执行单元测试</li></ul><p id="c0c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一天结束时，我们将有三个java进程同时在容器中运行，估计它们的内存使用情况以避免意外死亡是很重要的。每个进程都有不同的方式来设置JVM选项:</p><ul class=""><li id="82a9" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated">詹金斯代理堆如上所述计算，但我们绝对不应该让代理有这么大的堆。另外两个JVM需要内存。设置<em class="kp"> JAVA_OPTS </em>适用于Jenkins代理。</li><li id="fa1f" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">Jekins作业调用<em class="kp"> mvn </em>工具。设置<em class="kp"> MAVEN_OPTS </em>来定制这个java进程。</li><li id="6731" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">surefire为单元测试生成的JVM可以通过<a class="ae kl" href="http://maven.apache.org/surefire/maven-surefire-plugin/test-mojo.html#argLine" rel="noopener ugc nofollow" target="_blank"><em class="kp">argLine</em></a>maven属性定制。它可以在pom.xml中设置，在settings.xml的配置文件中设置，或者简单地通过在<em class="kp"> MAVEN_OPTS </em>的<em class="kp"> mvn </em>命令中添加<em class="kp"> -DargLine=… </em>来设置</li></ul><p id="ccb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个如何为<em class="kp"> maven </em>代理容器设置这些环境变量的例子:<br/> <code class="fe mr ms mt mu b">JAVA_OPTS=-Xms64m -Xmx64m<br/>MAVEN_OPTS=-Xms128m -Xmx128m -DargLine=${env.SUREFIRE_OPTS}<br/>SUREFIRE_OPTS=-Xms256m -Xmx256m<br/></code>这些数字在我们为SpringBoot应用程序构建和运行1024Mi代理容器内存限制单元测试时发挥了作用。这些都是相对较低的数字和较大的堆大小，复杂的maven项目和单元测试可能需要更高的限制。</p><blockquote class="km kn ko"><p id="158d" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">Java8进程的实际内存使用量大约是heap size+MetaSpace+OffHeapMemory，这可能远远大于最大堆大小设置。按照上面的设置，在我们的例子中，三个java进程总共占用了900多兆内存。容器内进程见rss内存:<br/> <code class="fe mr ms mt mu b">ps -e -o pid,user,rss,comm,args</code></p></blockquote><p id="5449" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Jenkins代理映像安装了JDK 64位和32位。对于mvn和surefire，默认使用64位JVM。为了降低内存使用，只要-Xmx小于1.5 GB，强制使用32位JVM是有意义的:<br/> <code class="fe mr ms mt mu b">JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.161–0.b14.el7_4.i386</code></p><blockquote class="km kn ko"><p id="718f" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">还可以在java_TOOL_OPTIONS env var中设置JAVA参数，任何启动的JVM都会选择它。JAVA_OPTS和MAVEN_OPTS中的参数覆盖了JAVA_TOOL_OPTIONS中的参数，因此我们可以在不使用<em class="iq"> argLine </em> : <br/> <code class="fe mr ms mt mu b">JAVA_OPTS=-Xms64m -Xmx64m<br/>MAVEN_OPTS=-Xms128m -Xmx128m<br/>JAVA_TOOL_OPTIONS=-Xms256m -Xmx256m<br/></code>的情况下为我们的JAVA进程实现与上面相同的堆配置，这仍然有点令人困惑，因为所有JVM都记录了“挑选JAVA_TOOL_OPTIONS:”。</p></blockquote><h2 id="ada7" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">詹金斯管道公司</h2><p id="5ebe" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">按照上面的设置，我们现在应该已经为运行一个成功的构建做好了准备。我们可以提取代码，下载依赖项，运行单元测试，并将工件上传到我们的仓库。让我们创建一个Jenkins pipeline项目来实现这一点:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3c0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于一个真实的项目，当然你的CI/CD管道应该做的不仅仅是maven构建:部署到开发环境，运行集成测试，提升到更高的环境，等等。上面链接的文章展示了如何做的例子。</p><h2 id="3146" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">多个容器</h2><p id="05a8" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">一个pod可以运行多个容器，每个容器都有自己的资源限制。它们共享同一个网络接口，所以您可以在<em class="kp"> localhost </em>上访问已启动的服务，但是您需要考虑端口冲突。环境变量是单独设置的，但是对于在一个Kubernetes Pod模板中配置的所有容器，装载的卷是相同的。</p><p id="e591" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当单元测试需要一个外部服务，而一个嵌入式解决方案不起作用时(例如，数据库、消息代理等)，使用多个容器是很有用的。).在这种情况下，第二个容器也以Jenkins代理开始和停止。</p><p id="f44b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请参见Jenkins config.xml片段，其中我们在Maven构建的侧面启动了一个httpbin服务:</p><pre class="mg mh mi mj gt mv mu mw mx aw my bi"><span id="183c" class="kt ku iq mu b gy mz na l nb nc">&lt;org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;<br/>  &lt;name&gt;maven&lt;/name&gt;<br/>  &lt;volumes&gt;<br/>    ...<br/>  &lt;/volumes&gt;<br/>  &lt;containers&gt;<br/>    &lt;org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;<br/>      &lt;name&gt;jnlp&lt;/name&gt;<br/>      &lt;image&gt;registry.access.redhat.com/openshift3/jenkins-slave-maven-rhel7:v3.7&lt;/image&gt;<br/>      &lt;resourceLimitCpu&gt;500m&lt;/resourceLimitCpu&gt;<br/>      &lt;resourceLimitMemory&gt;1024Mi&lt;/resourceLimitMemory&gt;<br/>      &lt;envVars&gt;<br/>      ...<br/>      &lt;/envVars&gt;        <br/>      ...<br/>    &lt;/org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;<br/>    &lt;org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;<br/>      &lt;name&gt;httpbin&lt;/name&gt;<br/>      &lt;image&gt;citizenstig/httpbin&lt;/image&gt;<br/>      &lt;resourceLimitCpu&gt;&lt;/resourceLimitCpu&gt;<br/>      &lt;resourceLimitMemory&gt;256Mi&lt;/resourceLimitMemory&gt;<br/>      &lt;envVars/&gt;<br/>      ...<br/>    &lt;/org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;<br/>  &lt;/containers&gt;<br/>  &lt;envVars/&gt;<br/>&lt;/org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;</span></pre><h2 id="500c" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">摘要</h2><p id="d553" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">作为总结，请参见Jenkins config.xml中创建的OpenShift资源和Kubernetes插件配置，以及上面描述的所有配置。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f8b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从文件<br/> <code class="fe mr ms mt mu b">oc create configmap maven-settings --from-file=settings.xml=settings.xml --from-file=myTruststore.jks=myTruststore.jks</code>创建了一个额外的配置图</p><p id="a9ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes插件配置:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b396" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快乐建造！</p><blockquote class="km kn ko"><p id="da9f" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">感谢<a class="ae kl" href="http://ushnash.blogspot.com/" rel="noopener ugc nofollow" target="_blank">乌什纳什</a>的贡献。</p></blockquote></div></div>    
</body>
</html>