<html>
<head>
<title>Taking a Kubernetes Operator to Production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让Kubernetes运营商投入生产</h1>
<blockquote>原文：<a href="https://itnext.io/taking-a-kubernetes-operator-to-production-bc59708db420?source=collection_archive---------1-----------------------#2020-02-28">https://itnext.io/taking-a-kubernetes-operator-to-production-bc59708db420?source=collection_archive---------1-----------------------#2020-02-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/d0505aea2e2e2ce0ddadd3569244b9f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xUw-f48yuezpgqNnK0og-w.png"/></div></div></figure><div class=""/><p id="f6cc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在最近的一次客户接触中，我们的团队编写了“CronJob预分频器”操作符。该运算符的目的是在cronjob需要启动之前，强制集群通过autoscaler进行扩展，从而允许作业准时启动，而不是等待扩展。代码在这里:<a class="ae kw" href="https://github.com/microsoft/k8s-cronjob-prescaler" rel="noopener ugc nofollow" target="_blank">https://github.com/microsoft/k8s-cronjob-prescaler</a>。我将引用这段代码的各个方面来说明各个要点。</p><p id="ed4e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然操作员的功能大部分是用几个sprints编写的，但是有信心在您精心保护的生产集群中部署和运行它是另一回事。这篇文章记录了我们为“生产化”操作员所进行的高级活动。</p><p id="a734" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于上下文，我们使用Kubebuilder(【https://kubebuilder.io/】见<a class="ae kw" href="https://kubebuilder.io/" rel="noopener ugc nofollow" target="_blank"><em class="kx"/></a>)构建了操作符。这个团队是:<a class="ae kw" href="https://github.com/bart-jansen" rel="noopener ugc nofollow" target="_blank">巴特·詹森</a>，<a class="ae kw" href="https://github.com/lawrencegripper/" rel="noopener ugc nofollow" target="_blank">劳伦斯·抓手</a>，<a class="ae kw" href="https://github.com/storey247" rel="noopener ugc nofollow" target="_blank">戴夫·斯托里</a>，<a class="ae kw" href="https://github.com/EliiseS" rel="noopener ugc nofollow" target="_blank">埃利斯·塞林</a>，<a class="ae kw" href="https://github.com/Stuartleeks" rel="noopener ugc nofollow" target="_blank">斯图尔特·里克斯</a>，<a class="ae kw" href="https://github.com/magencio" rel="noopener ugc nofollow" target="_blank">亚历杭德罗·马根西奥</a>，<a class="ae kw" href="https://github.com/martinpeck" rel="noopener ugc nofollow" target="_blank">马丁·佩克</a>，&amp;T22】本人。这个帖子试图将每个人的好想法收集到一个地方。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h2 id="5ec8" class="lf lg jb bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated">1.单元测试</h2><p id="ace4" class="pw-post-body-paragraph jy jz jb ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">这通常是不言而喻的——然而——在这里对你的代码进行单元测试并不是必然的。对于cron预分频器操作符，我们发现实际单元测试的逻辑非常少。大部分代码都是获取一个CRD，更改一些属性并提交回k8s。</p><p id="2684" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">务实一点，能单元测试就单元测试，但不要试图复试k8s。对我们来说，这意味着为cron操作逻辑<em class="kx">编写单元测试(参见</em><a class="ae kw" href="https://github.com/microsoft/k8s-cronjob-prescaler/blob/master/controllers/utilities_test.go" rel="noopener ugc nofollow" target="_blank"><em class="kx">utilities _ test . go</em></a><em class="kx">)</em>。对于其余的，我们转移到集成测试。</p><h2 id="306a" class="lf lg jb bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated">2.集成测试</h2><p id="e4cf" class="pw-post-body-paragraph jy jz jb ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">对于我们的项目，这些测试发展成两种类型:</p><ul class=""><li id="4972" class="md me jb ka b kb kc kf kg kj mf kn mg kr mh kv mi mj mk ml bi translated"><strong class="ka jc">【本地】集成测试，实物运行</strong>。如果你正在使用kubebuilder，那么银杏测试框架已经为你搭建好了，Kind已经成为你构建/部署过程的一部分。这里有两种方法——要么使用作为测试一部分启动的本地API服务器，要么使用“现有集群”——这意味着无论<code class="fe mm mn mo mp b">kubectl</code>指向什么(对我们来说，Kind)。因为我们的操作符创建了一个<code class="fe mm mn mo mp b">CronJob</code>对象并将其发送回k8s，所以我们需要标准的<code class="fe mm mn mo mp b">CronJob</code>操作符运行——这意味着一个现有的集群。如果您的运营商不交互或不依赖其他k8s功能，您可以简化并使用“嵌入式”API服务器。<br/>检查该区块的<code class="fe mm mn mo mp b"><a class="ae kw" href="https://github.com/microsoft/k8s-cronjob-prescaler/blob/f44bc23d206e584ec2f7fbf4d3239b559db3bfeb/controllers/suite_test.go#L48" rel="noopener ugc nofollow" target="_blank">suite_test.go</a></code>:</li></ul><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/d9e3c8db7bc6a657d402f51626f7b938.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*Wqy16SJtIe2sb_kI479HvA.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">使用现有集群进行集成测试</figcaption></figure><ul class=""><li id="7901" class="md me jb ka b kb kc kf kg kj mf kn mg kr mh kv mi mj mk ml bi translated"><strong class="ka jc">“长期运行”集成测试，在真实集群上运行。</strong>针对Kind的测试非常棒，因为它快速、可重复、独立，并且可以在构建代理上运行。然而，为了验证您的操作者在一个真实的集群上确实表现良好，您需要在一个真实的集群上运行您的测试。方便的是，如果您选择使用现有集群进行集成测试，那么就需要更改kube上下文并再次运行测试(假设操作者已经部署并运行在该集群中)。下图显示了在我们观察pod/nodes/auto scaler时运行的集成测试——测试在左下角的终端中运行。</li></ul><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mz"><img src="../Images/eaf98cb3ad7f264fc30f04054393cd88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rUQ9iKMDRD85wY9RKm4bkQ.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">通过银杏对实时集群进行集成测试</figcaption></figure><h2 id="25e7" class="lf lg jb bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated">3.CI和矩阵构建</h2><p id="383e" class="pw-post-body-paragraph jy jz jb ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">当然，这些测试——尤其是针对Kind运行的测试——可以在您的CI <em class="kx">中运行(参见我们的</em><a class="ae kw" href="https://github.com/microsoft/k8s-cronjob-prescaler/actions?query=workflow%3ACI" rel="noopener ugc nofollow" target="_blank"><em class="kx">GitHub Actions</em></a><em class="kx">)。</em></p><p id="4f76" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">k8s有很多版本，所以我们需要明确我们的目标是哪一个——并进行适当的测试。假设您的测试套件正在使用Kind，您可以通过env var甚至矩阵传递版本，这样您就可以确保给定的更改不会损害对您当时没有考虑的k8s版本的支持<em class="kx">(参见</em><a class="ae kw" href="https://github.com/microsoft/k8s-cronjob-prescaler/blob/master/.github/workflows/main.yml" rel="noopener ugc nofollow" target="_blank"><em class="kx">main . YAML</em></a><em class="kx">)</em>:</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi na"><img src="../Images/a6904d6f0f9b1678d0d13b6ba2e313c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*1QFRCpDOggXgGgTd22CK3g.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">用于矩阵构建的Yaml</figcaption></figure><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/d621fc6ea1037845b0c3444fd8208d6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:496/format:webp/1*faePfSdHYUs2EZgSUhlgMw.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">GitHub操作中的矩阵构建</figcaption></figure><h2 id="528f" class="lf lg jb bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated">4.可观察性</h2><p id="5606" class="pw-post-body-paragraph jy jz jb ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">如果没有合理的可观察性，你的操作员就成了一个黑盒，坐在另一个黑盒里。这一点不仅对“获得刺激”至关重要，而且对开发整个事物也很重要——所以一定要安排充足的时间来充实这一点。</p><ul class=""><li id="8fb6" class="md me jb ka b kb kc kf kg kj mf kn mg kr mh kv mi mj mk ml bi translated"><strong class="ka jc">日志</strong>。可观察性的最明显和最基本的方面。对伐木要慷慨。这是在一个地方捕捉操作员正在做的所有事情的好方法，并且允许您在观看它运行的同时流式传输日志:<code class="fe mm mn mo mp b">kubectl logs my-pod-name manager -f</code></li></ul><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nc"><img src="../Images/938ab8a3ebfb52fa8921c8d5dbf714ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*11DWnpJxA6BQeclT4E1VDg.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">记录所有的事情</figcaption></figure><ul class=""><li id="6264" class="md me jb ka b kb kc kf kg kj mf kn mg kr mh kv mi mj mk ml bi translated"><strong class="ka jc">事件</strong>。事件允许您将消息发送回您的操作员正在监视的CRD。这样做的好处是，最终用户可能无法访问操作员日志，但可以运行<code class="fe mm mn mo mp b">kubectl describe MyCustomResource</code>，这将向他们显示与其资源相关的事件。<strong class="ka jc">当心</strong>，然而默认情况下<em class="kx">事件在90分钟后消失(我相信)。</em></li><li id="7580" class="md me jb ka b kb nd kf ne kj nf kn ng kr nh kv mi mj mk ml bi translated"><strong class="ka jc">指标</strong>。普罗米修斯已经成为监控k8s的标准，为什么不推自己的度量让它刮呢？使用Prometheus客户端<em class="kx">(github.com/prometheus/client_golang/prometheus)</em>输出您认为相关的任何指标。</li></ul><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/77a6890ce99b332ea35de593e8b7f4be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*oh6esN24fm5m63hLJXTxww.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">将指标推送到端点</figcaption></figure><ul class=""><li id="da5b" class="md me jb ka b kb kc kf kg kj mf kn mg kr mh kv mi mj mk ml bi translated"><strong class="ka jc">图形</strong>。度量是好的，但是只有当你能够理解它们并使用它们来做决策时才是真正有用的。这就是格拉夫纳的用武之地。它能很好地配合普罗米修斯，帮助你从远处观察你的操作员。这是第二天行动的关键。你怎么知道你的操作员还在做它应该做的事情？</li></ul><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nj"><img src="../Images/0bd3837cbba4fcbac0b1bbd0a8ff0dd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FXmwQjylZi8ayOq-kOg0kw.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">为您的操作员提供单一的玻璃疼痛</figcaption></figure><h2 id="756f" class="lf lg jb bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated">5.稳定性和恢复</h2><p id="7b55" class="pw-post-body-paragraph jy jz jb ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">我们必须记住，操作符很可能在单个pod中的一个线程中运行(您可以运行多个，但默认情况下是单个)。这意味着如果它倒下了，任何依赖它的东西也会失败。这又有多危险取决于你的操作者实际在做什么——但这需要考虑。我们不得不考虑:</p><ul class=""><li id="f7bf" class="md me jb ka b kb kc kf kg kj mf kn mg kr mh kv mi mj mk ml bi translated"><strong class="ka jc">输入验证</strong>。有人会向你的操作员发送一个文本文件(可能是yaml)。他们在里面放了什么会破坏你的代码？幸运的是，模式验证发生在您的代码被调用之前——所以您可以确信一个<code class="fe mm mn mo mp b">int</code>字段将包含一个<code class="fe mm mn mo mp b">int</code>值。然而，如果你正在期待<code class="fe mm mn mo mp b">1-10</code>而有人给你发来<code class="fe mm mn mo mp b">1000000</code>呢？你的代码会有什么反应？</li><li id="99f2" class="md me jb ka b kb nd kf ne kj nf kn ng kr nh kv mi mj mk ml bi translated"><strong class="ka jc">等幂</strong>。这不仅对于恢复很重要，而且考虑到如果(当)您的操作程序重新启动，k8s将所有CRD交给它重新处理时会发生什么。接下来会发生什么？您需要考虑要创建的对象已经存在的代码路径。你怎么知道它的存在？你怎么知道它有效？</li><li id="437c" class="md me jb ka b kb nd kf ne kj nf kn ng kr nh kv mi mj mk ml bi translated"><strong class="ka jc">活性/准备就绪探测器</strong>。k8s怎么知道你运营商不开心？它能判断运行时中的某些东西是否变得没有响应了吗？这就是活跃度和准备度变得重要的地方。我们的很好也很简单，如果项目变得更复杂，还可以扩展:</li></ul><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/dd0fc74dcabf576ccbd40762f91fc4ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*Bwy8e_eJhXtofL7j-TozYg.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">manager.yaml中的livenessProbe</figcaption></figure><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/9198b73545c3431ea0b8142d3a7a258b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*RE3T3vpbLVZsAzTVuPdcRQ.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">活着的时候返回200—main . go</figcaption></figure><h2 id="a56f" class="lf lg jb bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated">6.Pod元数据</h2><p id="d7f3" class="pw-post-body-paragraph jy jz jb ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">你的操作员会像其他人一样在一个舱里运行。考虑到这一点，良好的卫生习惯非常重要:</p><ul class=""><li id="f5c8" class="md me jb ka b kb kc kf kg kj mf kn mg kr mh kv mi mj mk ml bi translated"><strong class="ka jc">吊舱优先级</strong>。在资源受限的集群中，如果您的操作员出现故障，或者部署了更多的pod，会发生什么情况？如果这是您的集群中的一个“核心”服务，您希望它运行——它比其他pods更重要。所以设定优先级。</li></ul><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/8c3f2ee5a7b45d2e34fab43472826be2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*K6SVyfOPdJ6zU7OTy35DBQ.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">为您的操作员舱创建超高优先级类别</figcaption></figure><ul class=""><li id="b4fb" class="md me jb ka b kb kc kf kg kj mf kn mg kr mh kv mi mj mk ml bi translated"><strong class="ka jc">资源限制&amp;请求。</strong>告诉k8s运行你的操作符需要什么。</li></ul><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/21452a32b9b5776a6cc3d8674b5c9c01.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*OF3OS08UZj0QzR17ZX6kgw.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">manager.yaml中的资源</figcaption></figure><h1 id="3a46" class="no lg jb bd lh np nq nr lk ns nt nu ln nv nw nx lq ny nz oa lt ob oc od lw oe bi translated">最后的想法…</h1><p id="b5fc" class="pw-post-body-paragraph jy jz jb ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">不要为了让项目‘上线’而把这些活动推到最后一分钟。添加适当的测试和可观察性实际上会帮助您加速开发，因为预先付出代价会导致更清晰、更简单和更安全的开发。</p></div></div>    
</body>
</html>