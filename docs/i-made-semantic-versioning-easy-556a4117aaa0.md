# 我简化了语义版本控制

> 原文：<https://itnext.io/i-made-semantic-versioning-easy-556a4117aaa0?source=collection_archive---------5----------------------->

## 无论您在什么平台上工作，都可以轻松地将语义版本集成到开发周期中。

![](img/0164114d63d8c979ca3d7a101de2da98.png)

分支和清晰的定义可能会很复杂。基拉·奥德·海德在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

S 软件的动态版本控制——无论我们在哪里谈论微服务或整体应用，都会给工作中的关系带来严重的压力。听起来可能很荒谬——补丁、次要版本和最终主要版本的理论很简单。尽管如此，团队内部实现的难度，即所谓的人为因素，随着项目中开发人员的数量呈指数增长，并随着他们的服务年限而成倍增长。对一个人来说是小事的事情可能被另一个人认为是补丁，带走了作为新发布参与者的快乐，并直接影响了在项目中做出贡献的心情和意愿。

在我目前从事的一个项目中，对语义版本化的需求变得很明显。微服务无处不在，使用多种语言和技术，自动化部署周期，除此之外，一个经验丰富的工程师团队试图实施最佳实践，带有一点个人偏好偏见和牢不可破的自豪感。最初关于语义的讨论让我思考— *我们真的需要经历所有这些吗*因为数字本身甚至不是让我们去赞美的，而是让基础设施的所有部分去收集它们可以使用的适当版本。毕竟——这不像是 *1.8.124* 会成为我的新纹身，我新生儿的名字或者一个幸运数字，对吧？

我最初的版本化方法远非最佳，容易出错(我的过失)，尽管它是完全自动化的。它允许我推送提交，版本号是自动生成的——允许我识别包含我一直在轻松开发的特定微服务版本的容器。我已经在 [Kubernetes、微服务和 Github Actions 文章](/unified-microservices-builds-using-github-actions-3442c4ee175e?sk=e0879dc75de9b9e249d9fee608350369)中描述了我一直在使用的整个工作流程。它简单地工作，满足了基本要求。使用构建号和 GitHub 运行对于我的个人项目来说是绝对足够的，这个项目分布在 30 多个存储库中。尽管如此，我们现在是在一个职业联赛中，我们应该调整方法，以适应 semver.org[所描述的既定标准。](https://semver.org/)

原则和问题在实际工作开始之前，我整个周五下午和晚上大部分时间都在问自己:

*   如何实现正确的版本控制，而不用花费团队的大部分时间来争论引入的变更是小的还是简单的补丁。
*   谁允许开发人员，那些创建应该被版本化的软件的人同时做出自主的决定。
*   最后，让它完全自动化，这样就没人需要浪费时间去摆弄标签和按按钮了。

> 12 个小时的通宵编码

![](img/ed3b49433ebf07c4bedbc7cffda672a6.png)

丹尼·豪在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

It 凌晨 5 点，解决方案就摆在我面前，我决定公开给大家，一劳永逸地解除手工管理语义版本的负担。几个最后的润色，把它给正在为同一个问题挣扎的朋友测试和收集反馈，导致了一些额外的修复和功能。

我为您呈现的是 [**语义版本生成器**](https://github.com/lukaszraczylo/semver-generator) ，一夜无眠的成果，希望能在开发过程中节省您的时间和神经。

[](https://github.com/lukaszraczylo/semver-generator) [## lukaszraczylo/SEM ver-发电机

### 一夜之间创建的项目，证明语义版本管理并不痛苦，也不需要争论…

github.com](https://github.com/lukaszraczylo/semver-generator) 

它可以作为 Linux ( amd64 和 arm64)、OSX ( amd64 和 arm 64——所以 M1 用户不会孤单)和 Windows(我个人不喜欢 Windows，但也有很多优秀的开发人员)的二进制文件。
最重要的是，如果你想自己运行它，你有 amd64 和 arm64 docker 图像，我第一次 [GitHub](https://medium.com/u/8df3bf3c40ae?source=post_page-----556a4117aaa0--------------------------------) 行动，我有些自豪，也可以在 [GitHub Marketplace](https://github.com/marketplace/actions/semantic-version-generator) 上获得。

[](https://github.com/marketplace/actions/semantic-version-generator) [## 语义版本生成器- GitHub 市场

### 一夜之间创建的项目，证明语义版本管理并不痛苦，也不需要争论…

github.com](https://github.com/marketplace/actions/semantic-version-generator) 

你可能会问，它是如何工作的？原理比较简单。开发人员应该已经提到了自治，我不太喜欢那些在用户身上强加某些命名约定的项目；因此，您有一个包含配置的简单 YAML 文件。您可以将这个配置文件放在您的代码库中，GitHub 操作将在运行过程中获取它。

**词语**部分是配置的核心。它允许您定义关键字集，版本的特定部分将在这些关键字集上递增。我强烈建议任何人不要使用示例配置，并设置足够独特的词语，以免触发误报。

如果您有一个使用任何版本控制的项目，以确保您不会突然从 1.5.7 之前的版本 0.0.5 开始，那么 Force 部分非常方便。你可以设置程序的次要版本、主要版本和补丁版本(或者其中的任何一个)，应该考虑“默认”的起始值。

你注意到**提交**的定义了吗？它将允许您指定提交的散列，计算将从该散列开始。如果你正在使用提到的神秘的 *1.5.7* 版本。你决定使用*语义版本生成器，*但是由于之前缺乏规则，它计算出下一个版本是*25 . 32 . 7*——你不是一个人，我支持你。指定开始提交后，所有计算都从那里开始。

为了保持适当的顺序，可以使用以下内容作为配置文件的一部分:

```
force:
  major: 1
  minor: 5
  patch: 7
  commit: 97d3682ed94168600926f9ff6da650403d1f3317
```

而下一个生产的版本将是 *1.5.9* ，因为提交 *97d368* 算作一个。

***关于措辞设置本身需要记住的几件事***

您可以在那里放置任何东西，尽管您应该记住，如果您使用**作为补丁版本**——您很可能会在一个频繁更新的存储库中得到版本 1.20.823281。唯一性是关键。****

****单词匹配使用模糊匹配；因此， *whl* 可以取为*轮*或*鲸*。****

****补丁版本将在每一次提交时在**递增，如果检测到来自指定配置的字，它将再加 1。这是为了在*挤压*的情况下，创造机会添加“空白”版本和补丁发布之间的间隔。******

****如果您对该功能有任何其他建议，请不要犹豫，在存储库内提出问题。我很乐意接受反馈，我收集的想法越多，产生的结果就越好(因为我坚信开源运动和社区的力量)。❤️****