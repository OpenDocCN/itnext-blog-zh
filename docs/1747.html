<html>
<head>
<title>How (not) to store passwords</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何(不)存储密码</h1>
<blockquote>原文：<a href="https://itnext.io/how-not-to-store-passwords-4955569e6e84?source=collection_archive---------1-----------------------#2019-01-18">https://itnext.io/how-not-to-store-passwords-4955569e6e84?source=collection_archive---------1-----------------------#2019-01-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/203267cf040a1f1e9729cc1f98859f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NGRNyPRV178l6zbnzP9eQg.jpeg"/></div></div></figure><div class=""/><p id="d108" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">验证和认证应用程序的用户是网络安全的主要领域之一。<br/>正确存储密码至关重要，但这也是许多开发人员未能做到的一点。<br/>部分原因是这个领域可能非常技术性、数学化，而且非常容易出错，部分原因是——尽管很可悲——纯粹出于懒惰。</p><p id="6f9f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我将介绍存储网站或应用程序密码的不同方法。有些人会比其他人更受欢迎。</p><h1 id="de0e" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">将密码存储为明文</h1><p id="5737" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">因此，您正在为您的网站创建一个登录系统，您需要有效地存储密码。<br/>当然，真正幼稚的方法非常简单:储存起来。<br/>您有一个包含所有用户的表的数据库，它可能看起来类似于<code class="fe lz ma mb mc b">(id, username, password)</code>。<br/>创建用户时，将用户名和密码以明文形式存储在这些字段中，登录时，提取与输入的用户名相关的行，并将输入的密码与数据库中的密码进行比较。如果匹配，你就让你的用户进来。非常简单且易于实现。</p><p id="1940" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">显然(我希望)，这是一种极其糟糕和不安全的存储密码的方式！<br/>如果你很不幸，你的数据库被黑了，你的每一个用户密码都会直接暴露在肉眼下。<br/>让我们用一些事实来强调这次灾难的意义:<br/>大多数人对所有(或至少多个)服务使用同一个密码。<br/>因此，你不仅危及了对自己网站的访问，还潜在地泄露了用户在其他地方使用的密码；他们的个人电子邮件或网上银行。<br/>此外，如果您选择以纯文本形式存储您的用户密码，您可能不太关心<a class="ae md" href="https://codex.wordpress.org/Validating_Sanitizing_and_Escaping_User_Data" rel="noopener ugc nofollow" target="_blank">净化</a>您的输入或者使用<a class="ae md" href="https://www.w3schools.com/php/php_mysql_prepared_statements.asp" rel="noopener ugc nofollow" target="_blank">准备好的语句</a>来防止SQL注入。你的网页被黑客攻击的几率可能并没有那么小。</p><p id="f5d6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但愿，你已经因为读到这里而畏缩了，并对自己说:“这只是常识，没有人真的这么做”。<br/>再想想！当我在2019年写这篇文章时，仍然有许多网站——见鬼，甚至是大公司——像这样存储密码。<br/>如果你被这个事实吓倒了，我不怪你。<br/>有一种快速的方法可以验证你自己的密码是否以明文形式存储。尝试使用网站的“恢复密码”功能。如果你收到一封通知你密码的邮件，那是因为网站以明文形式存储了密码，这将是一个<strong class="ka jc">巨大的</strong>危险信号！</p><h1 id="3695" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">加密您的密码</h1><p id="68f1" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在数据库的密码上增加一层安全层的第一种方法是利用加密。<br/>让我们以一种非常简单的方式快速浏览一下加密的工作原理:</p><figure class="mf mg mh mi gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi me"><img src="../Images/e0e7138c3e395928531446500de04c65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VyeGb0bufZqF5TFwHfrpRw.png"/></div></div></figure><ul class=""><li id="132b" class="mj mk jb ka b kb kc kf kg kj ml kn mm kr mn kv mo mp mq mr bi translated">生成将用于加密消息的密钥。</li><li id="4fd2" class="mj mk jb ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated">这个密钥现在将加密明文信息，并把它们变成密文(乱码)。</li><li id="4acd" class="mj mk jb ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated">之后，同样的密钥可以用来解密密文，把它变成原始消息。</li></ul><p id="991f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于存储密码，其思想是在将密码存储到数据库之前，使用生成的密钥对密码进行加密。<br/>每次用户登录时，输入的密码将使用相同的密钥加密，加密后的输入密码将与存储在数据库中的密码进行比较。<br/>如果黑客找到了进入数据库的方法，他们会在密码字段中看到密文。</p><p id="089c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这比明文存储密码要好，但这仍然是不安全的，也是很糟糕的做法。<br/>让我们拿出更多的事实:<br/>根据Troy Hunt的调查，<a class="ae md" href="https://www.troyhunt.com/86-of-passwords-are-terrible-and-other-statistics/" rel="noopener ugc nofollow" target="_blank"> 86%的密码都很糟糕</a>！比方说，作为一名黑客，我的确设法闯入了你的数据库。<br/>现在，我将拥有许多带有加密密码的条目。<br/>根据统计，这些密码中有很大概率是‘123456’或‘password’或‘ABC 123’(或其他常用的前100名密码之一)。我现在会尝试其中的一些，如果幸运的话，我可以很容易地得到加密密钥。或者更好——我会写一个简单的小脚本来完成它。现在，我可以立即在数据库中尝试使用前10.000个密码！<br/>搞定！我所要做的就是找到一个匹配的密码——知道了密钥，我现在可以有效地解密数据库中剩余的每一个密码。</p><h1 id="2c5f" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">散列你的密码</h1><p id="c430" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">不使用加密，你可以选择在创建时对你的密码进行散列运算。<br/>毕竟，在上面的例子中，我们从来不需要解密加密后的密码。我们只需要确保相同的密码每次都会产生相同的密文，然后简单地比较它们。<br/>这是一种<em class="mx">散列算法</em>变得有益的情况。</p><figure class="mf mg mh mi gt is gh gi paragraph-image"><div class="gh gi my"><img src="../Images/cb8aa5c23dad250c1d36950aad32c8ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*ldeOzY4GTB_jefmYXWAgZg.png"/></div></figure><p id="c5e5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中，使用散列算法的好处是</p><ul class=""><li id="b1fd" class="mj mk jb ka b kb kc kf kg kj ml kn mm kr mn kv mo mp mq mr bi translated">它是不可逆的。也就是说，从输出散列中重建输入在计算上是不现实的。</li><li id="7846" class="mj mk jb ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated">输出散列的长度是固定的。也就是说，不管输入的是一个单词还是莎士比亚的全部作品，输出散列的长度总是为<em class="mx"> x </em>个字符。</li><li id="ea16" class="mj mk jb ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated">输入的最小变化将导致完全不同的输出散列。这也被称为<a class="ae md" href="https://en.wikipedia.org/wiki/Avalanche_effect" rel="noopener ugc nofollow" target="_blank">雪崩效应</a>。</li><li id="2374" class="mj mk jb ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated">同样的输入每次都会产生同样的输出。因此哈希算法是一个<em class="mx">函数</em>。</li></ul><p id="fa36" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mx">如果你想了解更多关于哈希的知识，推荐你阅读劳尔·乔丹的</em> <a class="ae md" href="https://medium.com/zkcapital/the-state-of-hashing-algorithms-the-why-the-how-and-the-future-b21d5c0440de" rel="noopener"> <em class="mx">这篇文章</em> </a> <em class="mx">。</em></p><p id="f268" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过在存储密码之前应用散列函数，我们可以有效地规避使用加密时引入的问题。<br/>但不幸的是，这仍然是一种<strong class="ka jc">不安全的方式</strong>来存储密码！</p><p id="4bdb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一般来说，散列函数的一个结果是总会存在<em class="mx">散列冲突</em>的可能性。也就是说，两个不同的输入将映射到同一个输出散列。给定上述第二个标准；输出散列是固定长度的，这在数学上是可以证明的，冲突是不可避免的。背后的数学原理被称为鸽子笼原理。</p><p id="5065" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，如果很难找到映射到相同输出散列的两个输入，则称加密散列函数是抗冲突的。<br/>一个已知的抗冲突哈希算法的好例子是<a class="ae md" href="https://en.wikipedia.org/wiki/MD5" rel="noopener ugc nofollow" target="_blank"> MD5 </a>，这是多年来的行业标准。<br/>然而，1996年发现MD5的设计有缺陷，2004年证明MD5不抗碰撞。</p><p id="265c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回想一下，在存储之前对密码应用散列时，我们也只在授权登录时比较散列。这意味着，如果我能找到一个与数据库中存储的散列相同的输入，我就可以使用这个输入来登录。</p><p id="513a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是为什么应该<strong class="ka jc">完全避免使用MD5 </strong>进行任何关于认证和存储密码的事情。流行的<a class="ae md" href="https://en.wikipedia.org/wiki/SHA-1" rel="noopener ugc nofollow" target="_blank"> SHA-1 </a>也是如此，以今天的计算资源，也很容易被攻破。</p><p id="04f7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是，现在有更现代、更安全的哈希算法。<br/>目前的行业标准有<a class="ae md" href="https://en.wikipedia.org/wiki/PBKDF2" rel="noopener ugc nofollow" target="_blank"> PBKDF2 </a> <strong class="ka jc">，</strong> <a class="ae md" href="https://en.wikipedia.org/wiki/Bcrypt" rel="noopener ugc nofollow" target="_blank"> bcrypt </a> <strong class="ka jc">，</strong>和<strong class="ka jc"> </strong> <a class="ae md" href="https://en.wikipedia.org/wiki/Scrypt" rel="noopener ugc nofollow" target="_blank"> scrypt </a>。然而，即使应用了最先进的哈希技术，这仍然是一种不安全的存储密码的方式。</p><p id="7485" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们回想一下，所有密码中有86%是可怕的。作为一名黑客，我知道如果我使用MD5对密码“123456”进行哈希运算，我将总是得到相同的输出哈希。使用最常用的密码列表，我将遍历这些密码，应用常用的哈希算法并存储输出哈希。下次我想破解散列密码时，我只需在存储的输出散列列表中进行查找，很有可能在这里找到原始输入。事实上，我甚至不需要自己创建这个列表。人们已经用各种不同的哈希算法组合完成了这项工作。这些列表被称为<a class="ae md" href="https://en.wikipedia.org/wiki/Rainbow_table" rel="noopener ugc nofollow" target="_blank">彩虹表</a>。对于一大串最常用的密码，实际上并不比简单地将散列粘贴到谷歌中更困难，你可能会在前几次搜索命中中得到原始密码。<br/>您还将了解在执行散列时应用了哪种散列算法。</p><p id="0503" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你自己试试！看看能不能破解这个哈希密码:<em class="mx">482 c8 11 da 5d 5 B4 BC 6d 497 FFA 98491 e38</em></p><h1 id="44c5" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">哈希+加盐</h1><p id="b3cf" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">一种防止上述安全隐患的方法，如在执行散列之前对密码应用<em class="mx">盐</em>。</p><p id="5d2c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个<a class="ae md" href="https://en.wikipedia.org/wiki/Salt_(cryptography)" rel="noopener ugc nofollow" target="_blank"> salt </a>是一个随机生成的长字符串，它与密码连接在一起。这个salt在每个新用户创建时生成，并与用户名和散列密码一起存储。</p><figure class="mf mg mh mi gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mz"><img src="../Images/a59a60ffc41ccba73eb10469c2c515a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UhougWn8-PPLR2UlSmz2TQ.png"/></div></div></figure><p id="c236" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，密码“HappyFace”每次用于创建新用户时都会生成一个完全不同的散列。<br/>它不会匹配在任何其他网站上使用的相同密码的哈希，即使在同一个数据库中多次使用相同的密码，也会导致完全不同的输出哈希。</p><p id="3186" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，作为一名黑客，我只剩下一个选择:暴力攻击。也就是说，简单地尝试每一种可能的字符组合，直到我偶然发现正确的密码。<br/>如果密码和salt足够长，这几乎不可能实现。</p><p id="557a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，总结一下，如果你真的必须存储密码，最安全的方法是应用散列+加盐，从而使用众所周知的<a class="ae md" href="https://en.wikipedia.org/wiki/Password_policy" rel="noopener ugc nofollow" target="_blank">密码策略</a>强制执行强密码。</p><h1 id="0fe5" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">根本不要存储密码</h1><p id="41dc" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">尽管您可以通过遵循上面的约定来应用令人满意的安全层，但是仍然非常非常容易出错！因此，如果您必须存储密码，请确保在开始之前进行适当的研究，并确保遵循您选择的任何框架或方法的最新安全约定。当你读完这篇文章的时候，可能有些事情已经改变了。所以一定要查阅最新的标准。</p><p id="03de" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总之，<strong class="ka jc">存储密码的最佳方式</strong>是<strong class="ka jc">根本不存储密码！</strong></p><p id="4efd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">谷歌、微软、脸书、推特等等，都有很好的、易于实现的、现成的用户认证解决方案。<br/>您可以绝对肯定，他们雇佣了该领域最有经验的专家，他们应用了所有最新、最前沿的安全技术，并且如果报告了任何违反其安全标准的情况，他们将第一个做出重大改变！</p><p id="3288" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我强烈建议您始终使用这些第三方解决方案来验证您网站上的用户，并且根本不要存储任何密码。</p><p id="1f74" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">就是这样！<br/>如果您有任何问题或反馈，请随时在下方评论。如果你喜欢这篇文章，请鼓掌👏扣几下吧！<br/>你也可以在</strong><a class="ae md" href="https://twitter.com/SimonLH_" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc">Twitter</strong></a><strong class="ka jc">上找到我，我会在那里发布更多类似的内容。</strong></p></div></div>    
</body>
</html>