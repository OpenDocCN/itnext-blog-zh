<html>
<head>
<title>Jenkins X — Managing Nexus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jenkins X —管理关系</h1>
<blockquote>原文：<a href="https://itnext.io/jenkins-x-managing-nexus-17d31ad493d6?source=collection_archive---------6-----------------------#2019-08-23">https://itnext.io/jenkins-x-managing-nexus-17d31ad493d6?source=collection_archive---------6-----------------------#2019-08-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/47f7353d597f96f3635c05838c81b6f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O2uZfgIOzVL86ERThnPMYg.png"/></div></div></figure><p id="43cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我的上一篇文章<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/jenkins-x-managing-jenkins-926f0e0f8bcf?source=friends_link&amp;sk=3dcd9c4a8c028661f0b09156c14c271e">Jenkins X——管理Jenkins </a>中，我谈到了我们如何管理我们的Jenkins服务器。这一次，我将关注Nexus服务器，以及如何对其进行类似的管理。</p><h1 id="e09a" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">当前状态</h1><p id="6f5e" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated"><a class="ae kz" href="https://jenkins-x.io/" rel="noopener ugc nofollow" target="_blank"> Jenkins X </a>附带一个可选的Nexus服务器，该服务器已打包到平台中，非常适合您使用。然而，随着您的项目变得越来越复杂，您可能会发现自己需要其他的存储库或者对配置进行更改。事实证明，正是这些变化有点难以管理。以下是截至今天的设置:</p><ul class=""><li id="6f88" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">当前的Jenkins X nexus图表对预打包的存储库进行了硬编码</li><li id="468d" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated"><code class="fe mr ms mt mu b">postStart.sh</code>脚本获取存储库脚本文件列表并执行它们</li><li id="4320" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">GitHub 上有一个未解决的问题，将文件移动到<code class="fe mr ms mt mu b">values.yaml</code>中，但我不确定何时会修复。</li></ul><p id="171c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，在这种情况下，我们需要一种方法来添加我们的自定义存储库。现在，在我进入实现之前，我想给你一些关于实际发生了什么的背景知识。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="e977" class="la lb it bd lc ld nc lf lg lh nd lj lk ll ne ln lo lp nf lr ls lt ng lv lw lx bi translated">postStart.sh脚本</h1><p id="6950" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated"><a class="ae kz" href="https://github.com/jenkins-x-charts/nexus/blob/master/postStart.sh" rel="noopener ugc nofollow" target="_blank"> postStart.sh </a>脚本在nexus服务器可用后直接运行。它的工作之一是循环遍历包含存储库创建脚本的文件列表并在Nexus中执行它们。脚本本身是幂等的，这意味着只有在Nexus存储库不存在的情况下才会创建它。这可以确保您的Nexus服务器在启动时拥有所有必需的存储库。</p><p id="e91e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么，脚本是如何工作的呢？</p><h2 id="bbc0" class="nh lb it bd lc ni nj dn lg nk nl dp lk km nm nn lo kq no np ls ku nq nr lw ns bi translated">Nexus API</h2><p id="ecbf" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">Sonatype Nexus使用groovy脚本来配置实例。在这篇文章的范围之外，<a class="ae kz" href="https://github.com/samrocketman/nexus3-config-as-code" rel="noopener ugc nofollow" target="_blank">这里有一个通过脚本配置Nexus的很好的例子</a>。</p><p id="4d9b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是来自Nexus官方网站的更多信息:</p><ul class=""><li id="9fc7" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated"><a class="ae kz" href="https://help.sonatype.com/repomanager3/rest-and-integration-api/script-api/examples" rel="noopener ugc nofollow" target="_blank">https://help . sonatype . com/repo manager 3/rest-and-integration-API/script-API/examples</a></li><li id="fdf6" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated"><a class="ae kz" href="https://github.com/sonatype-nexus-community/nexus-scripting-examples" rel="noopener ugc nofollow" target="_blank">https://github . com/sonatype-nexus-community/nexus-scripting-examples</a></li></ul><blockquote class="nt"><p id="c2a9" class="nu nv it bd nw nx ny nz oa ob oc ky dk translated"><strong class="ak">还有？你为什么要告诉我这些？</strong></p></blockquote><p id="545a" class="pw-post-body-paragraph kb kc it kd b ke od kg kh ki oe kk kl km of ko kp kq og ks kt ku oh kw kx ky im bi translated">因为，尽管<code class="fe mr ms mt mu b">postStart.sh</code>脚本的主要功能是建立nexus存储库，<strong class="kd iu">实际上没有什么可以阻止您添加其他脚本</strong>，比如说:</p><ul class=""><li id="f707" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">创建存储库组</li><li id="d5f9" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">添加用户</li><li id="0392" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">添加角色</li><li id="dd96" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">安排任务等。</li></ul></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="0566" class="la lb it bd lc ld nc lf lg lh nd lj lk ll ne ln lo lp nf lr ls lt ng lv lw lx bi translated">创建脚本文件</h1><p id="6ca2" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">让我们首先创建一个包含自定义脚本的<code class="fe mr ms mt mu b">ConfigMap</code>资源。由于某种原因，Medium不想正确显示要点，因此这里的<a class="ae kz" href="https://gist.github.com/sboardwell/42ca099b43b8a6163ae5ff6afc31c70a" rel="noopener ugc nofollow" target="_blank">是指向问题要点的链接:</a></p><figure class="oi oj ok ol gt ju"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="2f1c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上述示例展示了四种最常见的任务类型:</p><ul class=""><li id="f1bd" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated"><strong class="kd iu">redshift-maven-repository . JSON<br/></strong>一个公开的maven发布库</li><li id="7b98" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated"><strong class="kd iu">Apache-org-snapshot s . JSON<br/></strong>一个公共maven快照库</li><li id="ae64" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated"><strong class="kd iu"> my-protected-repo.json <br/></strong></li><li id="6431" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated"><strong class="kd iu"> maven-group.json <br/> </strong>脚本创建各种maven存储库组</li></ul><p id="0c15" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">查看内容并用真正的换行符替换<code class="fe mr ms mt mu b">\n</code>，您可以看到将要执行的实际脚本，例如:</p><figure class="oi oj ok ol gt ju"><div class="bz fp l di"><div class="om on l"/></div></figure><blockquote class="oo op oq"><p id="29e9" class="kb kc or kd b ke kf kg kh ki kj kk kl os kn ko kp ot kr ks kt ou kv kw kx ky im bi translated"><strong class="kd iu">注意:</strong>这里有一些关于Nexus脚本的优秀信息，包括一个示例项目:<a class="ae kz" href="https://help.sonatype.com/repomanager3/rest-and-integration-api/script-api/writing-scripts" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">https://help . sonatype . com/repo manager 3/rest-and-integration-API/script-API/writing-scripts</strong></a></p></blockquote></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="1a7d" class="la lb it bd lc ld nc lf lg lh nd lj lk ll ne ln lo lp nf lr ls lt ng lv lw lx bi translated">获取必要的信息</h1><p id="16e0" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">那么，我们如何把我们的文件放在正确的地方呢？我们需要将文件放在Nexus pod上的适当目录中。</p><p id="1b5a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但我们对此有异议。我们不能挂载整个目录，因为那会破坏所有现有的文件。幸运的是，我们可以使用本文中提到的子路径<a class="ae kz" href="https://blog.sebastian-daschner.com/entries/multiple-kubernetes-volumes-directory" rel="noopener ugc nofollow" target="_blank">来挂载单个文件。</a></p><p id="f1e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我想自动完成这项工作，所以我们希望将当前挂载与所需列表进行比较。之后，我们需要修补nexus部署，添加任何尚未添加的挂载。</p><p id="21f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们需要:</p><ul class=""><li id="a6e7" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">列出当前的nexus部署挂载点</li><li id="7770" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">列出当前的nexus部署子路径</li><li id="0087" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">从我们的文件中列出自定义回购</li><li id="9a30" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">将配置映射添加到集群</li><li id="2e22" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">创建包含任何新挂载点和子路径的补丁字符串</li><li id="f10a" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">如有必要，应用补丁</li></ul><p id="3a12" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为此，我们需要我最喜欢的两个命令的帮助，<a class="ae kz" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> jq </a>和<a class="ae kz" href="https://mikefarah.github.io/yq/" rel="noopener ugc nofollow" target="_blank"> yq </a>，以及一个小命令行fu。</p><p id="b652" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们走吧…</p><h2 id="4aec" class="nh lb it bd lc ni nj dn lg nk nl dp lk km nm nn lo kq no np ls ku nq nr lw ns bi translated">部署中的当前挂载点</h2><pre class="oi oj ok ol gt ov mu ow ox aw oy bi"><span id="9015" class="nh lb it mu b gy oz pa l pb pc">kubectl get deployment jenkins-x-nexus \<br/>  -o 'jsonpath={ .spec.template.spec.volumes[*].name }'</span></pre><p id="d4dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">会给你这样的信息:</p><pre class="oi oj ok ol gt ov mu ow ox aw oy bi"><span id="9a45" class="nh lb it mu b gy oz pa l pb pc">nexus nexus-data-volume nexus-custom-repo-files</span></pre><h2 id="7563" class="nh lb it bd lc ni nj dn lg nk nl dp lk km nm nn lo kq no np ls ku nq nr lw ns bi translated">部署中的当前子路径(repo文件)</h2><pre class="oi oj ok ol gt ov mu ow ox aw oy bi"><span id="f299" class="nh lb it mu b gy oz pa l pb pc">kubectl get deployment jenkins-x-nexus \<br/>  -o 'jsonpath={ .spec.template.spec.containers[0].volumeMounts[*].subPath }'</span></pre><p id="3298" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">会给你这样的信息:</p><pre class="oi oj ok ol gt ov mu ow ox aw oy bi"><span id="38e0" class="nh lb it mu b gy oz pa l pb pc">apache-org-snapshots.json my-protected-repo.json maven-group.json redshift-maven-repository.json</span></pre><h2 id="93a0" class="nh lb it bd lc ni nj dn lg nk nl dp lk km nm nn lo kq no np ls ku nq nr lw ns bi translated">来自自定义yaml的当前脚本文件</h2><p id="23f9" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">这实际上比最初想的更复杂，主要是因为<code class="fe mr ms mt mu b">yq</code>不允许输出地图对象的键。为了解决这个问题，我需要使用<code class="fe mr ms mt mu b">yq</code>来输出数据部分，然后使用<code class="fe mr ms mt mu b">jq</code>来输出密钥。最终结果是:</p><pre class="oi oj ok ol gt ov mu ow ox aw oy bi"><span id="030b" class="nh lb it mu b gy oz pa l pb pc">cat "nexus-repos/nexus-custom-repo-files.yaml" \<br/>  | docker run -i — rm evns/yq -j -r '.data' \<br/>  | docker run -i — rm imega/jq -r 'keys[]' \<br/>  | xargs</span></pre><blockquote class="oo op oq"><p id="e488" class="kb kc or kd b ke kf kg kh ki kj kk kl os kn ko kp ot kr ks kt ou kv kw kx ky im bi translated"><strong class="kd iu">注意:</strong>如果本地安装了yq和jq，docker命令可以替换为二进制命令</p></blockquote></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="efaf" class="la lb it bd lc ld nc lf lg lh nd lj lk ll ne ln lo lp nf lr ls lt ng lv lw lx bi translated">创建部署补丁</h1><p id="ccfe" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">现在我们有了主要的输入变量，我们可以处理它们并构造我们的补丁字符串。我们将使用json补丁类型，因为这允许我们添加到现有的列表中。关于json合并<a class="ae kz" href="https://kubernetes.io/docs/tasks/run-application/update-api-object-kubectl-patch/#use-a-json-merge-patch-to-update-a-deployment" rel="noopener ugc nofollow" target="_blank">的更多信息可以在这里找到</a>。</p><h2 id="c539" class="nh lb it bd lc ni nj dn lg nk nl dp lk km nm nn lo kq no np ls ku nq nr lw ns bi translated">卷安装</h2><p id="bbaa" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">首先，添加自定义回购配置映射作为卷(如果它还不存在的话)</p><pre class="oi oj ok ol gt ov mu ow ox aw oy bi"><span id="16e5" class="nh lb it mu b gy oz pa l pb pc">if [[ "${volumeNames}" != *nexus-custom-repo-files* ]]; then<br/>  patchItemString='<br/>{<br/>  "op": "add",<br/>  "path": "/spec/template/spec/volumes/-",<br/>  "value": {<br/>    "name" : "nexus-custom-repo-files",<br/>    "configMap" : { "name" : "nexus-custom-repo-files" }<br/>  }<br/>}<br/>'<br/> fi</span></pre><h2 id="8093" class="nh lb it bd lc ni nj dn lg nk nl dp lk km nm nn lo kq no np ls ku nq nr lw ns bi translated">子路径</h2><p id="d0d0" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">其次，遍历我们的存储库脚本文件，在必要的地方添加子路径(注意<code class="fe mr ms mt mu b">maven-group.json</code>被放在父目录中——这是postStart.sh期望的位置)</p><pre class="oi oj ok ol gt ov mu ow ox aw oy bi"><span id="d4ed" class="nh lb it mu b gy oz pa l pb pc">for repoF in $repoFiles; do<br/>    [ -n "${patchItemString}" ] &amp;&amp; separator=',' || separator=''<br/>    if [[ "${subPaths}" != *${repoF}* ]]; then<br/>        local mountPath<br/>        if [[ "${repoF}" == maven-group.json ]]; then<br/>            mountPath="/opt/sonatype/nexus/${repoF}"<br/>        else<br/>            mountPath="/opt/sonatype/nexus/repositories/${repoF}"<br/>        fi<br/>        patchItemString="<br/>${patchItemString}${separator}<br/>{<br/>\"op\": \"add\",<br/>\"path\": \"/spec/template/spec/containers/0/volumeMounts/-\",<br/>\"value\": {<br/>\"mountPath\" : \"${mountPath}\",<br/>\"name\" : \"nexus-custom-repo-files\",<br/>\"subPath\" : \"${repoF}\"<br/>}<br/>}<br/>"<br/>    fi<br/>done</span></pre><h2 id="0abc" class="nh lb it bd lc ni nj dn lg nk nl dp lk km nm nn lo kq no np ls ku nq nr lw ns bi translated">更新配置图</h2><p id="bd00" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">第三，应用配置图为装载做准备:</p><pre class="oi oj ok ol gt ov mu ow ox aw oy bi"><span id="68e9" class="nh lb it mu b gy oz pa l pb pc"># update config map<br/>kubectl apply -f &lt;(sops -d nexus-repos/nexus-custom-repo-files.yaml)</span></pre><blockquote class="oo op oq"><p id="c4be" class="kb kc or kd b ke kf kg kh ki kj kk kl os kn ko kp ot kr ks kt ou kv kw kx ky im bi translated"><strong class="kd iu">注意:</strong>你会注意到我正在使用<a class="ae kz" href="https://github.com/mozilla/sops" rel="noopener ugc nofollow" target="_blank"> sops </a>动态解密文件。我加密了存储库脚本配置映射文件，因为它包含my-protected-repo的凭证。</p></blockquote><h2 id="09a2" class="nh lb it bd lc ni nj dn lg nk nl dp lk km nm nn lo kq no np ls ku nq nr lw ns bi translated">修补部署</h2><p id="f813" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">最后，如有必要，修补部署:</p><pre class="oi oj ok ol gt ov mu ow ox aw oy bi"><span id="7235" class="nh lb it mu b gy oz pa l pb pc"># patch if necessary<br/>if [ -n "${patchItemString}" ]; then<br/>    # patch deployment<br/>    patchFile=$(mktemp)<br/>    echo "Patch file: ${patchFile}"<br/>    echo -e "[\n${patchItemString}\n]" &gt; "${patchFile}"<br/>    kubectl patch deployment jenkins-x-nexus - type='json' - patch "$(cat ${patchFile})"<br/>else<br/>    echo "All custom repositories found. No need to patch."<br/>fi</span></pre></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="2103" class="la lb it bd lc ld nc lf lg lh nd lj lk ll ne ln lo lp nf lr ls lt ng lv lw lx bi translated">把所有的放在一起</h1><p id="d524" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">最后，将所有这些放在一个bash函数中会得到这个函数:</p><figure class="oi oj ok ol gt ju"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="8eb8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它可以作为Jenkins X配置过程的一部分运行。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><p id="d705" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是你的Jenkins X managed Nexus服务器中的自定义存储库。</p><p id="aa76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望这篇文章对你有所帮助，并且你现在对Nexus脚本API有了一点了解。</p><p id="a262" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在下一章中，我将看看如何使用gitversion作为你项目的动态版本驱动。</p></div></div>    
</body>
</html>