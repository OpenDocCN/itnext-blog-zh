<html>
<head>
<title>Kubernetes Ingress Past, Present, and Future</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">库伯内特入口过去、现在和未来</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-ingress-past-present-and-future-f614f11ea924?source=collection_archive---------3-----------------------#2019-04-15">https://itnext.io/kubernetes-ingress-past-present-and-future-f614f11ea924?source=collection_archive---------3-----------------------#2019-04-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3676a6f72d646b281235ebf1050770b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-Cw39VI3X_MASbzV.jpeg"/></div></div></figure><p id="3e04" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇文章的灵感来自于听2019年2月19日，<a class="ae kz" href="https://kubernetespodcast.com/" rel="noopener ugc nofollow" target="_blank"> Kubernetes播客</a>，<a class="ae kz" href="https://kubernetespodcast.com/episode/041-ingress/" rel="noopener ugc nofollow" target="_blank">“入口，蒂姆·霍金。”</a>Kubernetes播客被证明是一个非常好的播客，非常值得一听。在Ingress一集中，播客们采访了Tim Hockin，他是Kubernetes的原始联合创始人之一，是Kubernetes前身Borg/Omega的团队领导，在Kubernetes社区中仍然非常活跃，例如主持目前拥有Ingress资源规范的<a class="ae kz" href="https://github.com/kubernetes/community/tree/master/sig-network" rel="noopener ugc nofollow" target="_blank"> Kubernetes网络特别兴趣小组</a>。Tim在播客中讲述了Kubernetes Ingress的历史、Ingress的当前发展以及未来发展。这次谈话启发我思考入口控制器(实现入口清单的实现)和入口概念(允许Kubernetes集群之外的客户端访问Kubernetes集群中运行的服务)。</p><h1 id="07b8" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">那么什么是Kubernetes入口？</h1><p id="2960" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">根据<a class="ae kz" href="https://kubernetes.io/docs/concepts/services-networking/ingress/#what-is-ingress" rel="noopener ugc nofollow" target="_blank"> Kubernetes Ingress </a>文档的解释，Ingress是一个L7网络服务，它公开了从Kubernetes集群外部到内部的HTTP(S)路由。Kubernetes集群可以运行一个或多个<a class="ae kz" href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/" rel="noopener ugc nofollow" target="_blank">入口控制器</a>，每个控制器管理服务可达性、负载平衡、TLS/SSL终止以及该控制器相关路由的其他服务。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div class="gh gi md"><img src="../Images/07d068af17d17c82398fc49c77cffdd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/0*1qXOWMiZYx9n3Kb4.png"/></div></figure><p id="97ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个入口清单包括指示哪个入口控制器应该管理该入口资源的注释。例如，要让<a class="ae kz" href="https://solo.io/" rel="noopener ugc nofollow" target="_blank"> Solo.io </a> <a class="ae kz" href="https://gloo.solo.io/" rel="noopener ugc nofollow" target="_blank"> Gloo </a>管理一个特定的入口资源，可以指定如下内容。注意包含的注释<code class="fe mi mj mk ml b">kubernetes.io/ingress.class: gloo</code>。</p><figure class="me mf mg mh gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="f9cb" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">入口挑战</h1><p id="5ac4" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">自Kubernetes 1.1以来，Ingress一直是一个测试版扩展，它被证明是一个最小公分母的API。例如，NGNIX社区入口控制器在生产中被许多人使用，但是NGNIX入口控制器需要使用许多<a class="ae kz" href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/" rel="noopener ugc nofollow" target="_blank"> NGNIX特定入口注释</a>用于除了最简单的用例之外的所有情况。当前的Kubernetes入口资源规范有许多限制，例如所有引用的服务和秘密必须与入口在同一个名称空间中，即没有跨名称空间引用。关于如何确切地解释<code class="fe mi mj mk ml b">path</code>属性已经有了很长时间的争论；它是像文档中暗示的正则表达式，还是像NGNIX实现的一些控制器那样的路径前缀。这些挑战使得在实践中很难有一个跨实现可移植的入口清单。目前的入口清单还被证明难以与<a class="ae kz" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank">客户资源(CRD) </a>进行往返同步，这很不幸，因为CRD被证明是扩展Kubernetes的一种有益方式。</p><h1 id="c377" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Ingress的下一步是什么？</h1><p id="115e" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在播客中，Tim Hockin表示，鉴于有多少人在生产中使用当前的beta Ingress规范，有一种推动将现有的Ingress规范转移到GA状态，然后开始制定下一代规范，要么是Ingress v2，要么是跨多个CRD分解Ingress。Tim提到了Kubernetes社区如何看待几个基于<a class="ae kz" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank"> Envoy </a>的Ingress实现，以获得下一代Ingress的灵感。例如，<a class="ae kz" href="https://github.com/heptio/contour" rel="noopener ugc nofollow" target="_blank"> Heptio Contour </a>创建了一个非常有趣的、实现中性的CRD，称为<a class="ae kz" href="https://github.com/heptio/contour/blob/master/docs/ingressroute.md" rel="noopener ugc nofollow" target="_blank">入口路线</a>。入口路由旨在解决入口的治理挑战，例如，如果一家公司想要公开一条<code class="fe mi mj mk ml b">/eng</code>路由路径，那么当前的入口模型会面临许多挑战，因为您可能会有与路由<code class="fe mi mj mk ml b">/eng</code>相冲突的入口清单。入口路由提供了一种创建治理和委托的方式，例如集群管理员可以定义一个虚拟主机<code class="fe mi mj mk ml b">/eng</code>并将实施明确委托给<code class="fe mi mj mk ml b">eng</code>命名空间，这样可以防止其他人覆盖该路由路径。</p><p id="873b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Istio社区也基于Envoy，如Heptio Contour，他们也定义了入口CRD。</p><p id="edc2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在不太遥远的将来，看看Ingress是如何发展的将会非常有趣。</p><p id="ca55" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">相关阅读:<a class="ae kz" href="https://medium.com/solo-io/api-gateways-are-going-through-an-identity-crisis-d1d833a313d7" rel="noopener"> API网关正在经历一场身份危机</a>。</p><h1 id="931c" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">演示时间</h1><p id="5f66" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我发现看到一些有助于使概念更加真实的工作代码是很有帮助的，所以让我们来看几个Ingress和beyond的例子。</p><p id="75d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于这个例子，我将使用从<a class="ae kz" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/</a>创建的Kubernetes服务，它提供了一组快速的REST APIs，这些API提供了不同的JSON输出，可以帮助测试。它基于node . js<a class="ae kz" href="https://github.com/typicode/json-server" rel="noopener ugc nofollow" target="_blank">JSON-server</a>——非常酷，值得独立看。我派生出最初的GitHub <a class="ae kz" href="https://github.com/typicode/jsonplaceholder" rel="noopener ugc nofollow" target="_blank"> jsonplaceholder存储库</a>，在项目上运行<code class="fe mi mj mk ml b"><a class="ae kz" href="https://draft.sh/" rel="noopener ugc nofollow" target="_blank">draft create</a></code>，并对生成的<a class="ae kz" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank"> Helm </a>图表做了一些调整。Draft 是一种将现有代码引导到Kubernetes的超级快速简单的方法。我使用<a class="ae kz" href="https://kubernetes.io/docs/setup/minikube/" rel="noopener ugc nofollow" target="_blank"> minikube </a>在本地运行这个例子。</p><p id="9fca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">jsonplaceholder服务附带了六个公共资源，每个资源返回几个JSON对象。对于这个例子，我们将在<code class="fe mi mj mk ml b">/users/1</code>获得第一个用户资源。</p><ul class=""><li id="ad8b" class="mo mp it kd b ke kf ki kj km mq kq mr ku ms ky mt mu mv mw bi translated"><code class="fe mi mj mk ml b">/posts</code> 100个帖子</li><li id="9516" class="mo mp it kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated"><code class="fe mi mj mk ml b">/comments</code> 500条评论</li><li id="787a" class="mo mp it kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated"><code class="fe mi mj mk ml b">/albums</code> 100张专辑</li><li id="eabb" class="mo mp it kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated"><code class="fe mi mj mk ml b">/photos</code> 5000张照片</li><li id="007c" class="mo mp it kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated"><code class="fe mi mj mk ml b">/todos</code> 200托多</li><li id="2f3c" class="mo mp it kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated"><code class="fe mi mj mk ml b">/users</code> 10个用户</li></ul><p id="650b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是您自己尝试这个例子的脚本，还有一个<a class="ae kz" href="https://asciinema.org/" rel="noopener ugc nofollow" target="_blank">asci NEMA</a>回放，这样您可以看到它在我的机器上运行的样子。我们将解开回放后发生的事情。</p><figure class="me mf mg mh gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="me mf mg mh gt ju gh gi paragraph-image"><a href="https://asciinema.org/a/JjLna1ONZiGmQeYrJhP4oNcS5"><div class="gh gi nc"><img src="../Images/251aa65511e5c83831562b18f7231d41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pa7FH8LD2WSkKCgaoixVBQ.png"/></div></a></figure><h1 id="f440" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">发生了什么事？</h1><p id="af8a" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我们安装了本地工具(您可以查看各自的网站了解完整的安装细节)。</p><ul class=""><li id="3b64" class="mo mp it kd b ke kf ki kj km mq kq mr ku ms ky mt mu mv mw bi translated"><a class="ae kz" href="https://kubernetes.io/docs/setup/minikube/" rel="noopener ugc nofollow" target="_blank"> minikube </a></li><li id="418d" class="mo mp it kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated"><a class="ae kz" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank">库贝克特尔</a></li><li id="d763" class="mo mp it kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated"><a class="ae kz" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank">舵</a></li><li id="17e8" class="mo mp it kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated"><a class="ae kz" href="https://draft.sh/" rel="noopener ugc nofollow" target="_blank">草稿</a></li><li id="32b1" class="mo mp it kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated"><a class="ae kz" href="https://gloo.solo.io/" rel="noopener ugc nofollow" target="_blank"> glooctl </a></li></ul><p id="4137" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们启动了一个本地Kubernetes集群(minikube ),并初始化了Helm和Draft。我们还在本地集群中安装了<a class="ae kz" href="https://gloo.solo.io/user_guides/basic_ingress/" rel="noopener ugc nofollow" target="_blank"> Gloo ingress </a>。</p><p id="3024" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们<code class="fe mi mj mk ml b">git clone</code>我们的例子，并使用<code class="fe mi mj mk ml b">draft up</code>来构建和部署它到我们的集群。让我们花一分钟来看看这一步发生了什么。我最初分叉了<code class="fe mi mj mk ml b">jsonplaceholder</code> GitHub库，并对其代码运行了<code class="fe mi mj mk ml b">draft create</code>。Draft自动检测源代码语言，在本例中是Node.js，并创建一个<code class="fe mi mj mk ml b">Dockerfile</code>,将我们的示例应用程序构建到一个图像容器中，并创建一个默认的Helm chart。然后我对舵图做了一些小的调整，以使它能够进入。让我们看看入境旅客名单。主要的变化是增加了<code class="fe mi mj mk ml b">ingress.class: gloo</code>注释来为Gloo的入口控制器标记这个入口。并且主机设置为<code class="fe mi mj mk ml b">gloo.example.com</code>，这也是我们curl语句设置<code class="fe mi mj mk ml b">curl --header "Host: gloo.example.com"</code>的原因。</p><figure class="me mf mg mh gt ju"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">图表/模板/ingress.yaml</figcaption></figure><p id="503d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">更多使用Gloo作为基本入口控制器的例子，你可以查看使用Gloo 的Kubernetes入口控制。</p><p id="83a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可能还注意到了curl命令中对<code class="fe mi mj mk ml b">$(glooctl proxy url --name ingress-proxy)</code>的调用。当您在minikube这样的本地环境中运行并且需要获得Gloo代理服务器的主机IP和端口时，这是必需的。当Gloo部署到Google或AWS等云提供商时，这些环境将关联一个静态IP并允许使用端口80(或HTTPS的端口443)，该静态IP将注册到DNS服务器，即当Gloo部署到云管理的Kubernetes时，您可以做<code class="fe mi mj mk ml b">curl <a class="ae kz" href="http://gloo.example.com/users/1." rel="noopener ugc nofollow" target="_blank">http://gloo.example.com/users/1</a></code> <a class="ae kz" href="http://gloo.example.com/users/1." rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="8ddf" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">入口示例挑战</h1><p id="0450" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">假设我们想将现有的<code class="fe mi mj mk ml b">/users/1</code>重新映射到<code class="fe mi mj mk ml b">/people/1</code>，因为用户也是人。由于我们可以为<code class="fe mi mj mk ml b">/people</code>设置第二个规则，这对于入口清单来说变得很棘手，但是我们需要在发送到我们的服务之前重写到<code class="fe mi mj mk ml b">/users</code>的路径，因为它不知道如何处理对<code class="fe mi mj mk ml b">/people</code>的请求。如果您使用的是NGNIX ingress，您可以添加另一个注释<code class="fe mi mj mk ml b">nginx.ingress.kubernetes.io/rewrite-target: /</code>，但是现在我们添加了特定于实现的注释，也就是说，nginx注释不会被其他ingress控制器识别。注释是一个平面的名称空间，所以添加大量的注释会变得非常混乱，这也是为什么<a class="ae kz" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank">定制资源(CRD) </a>被创建的部分原因。让我们看看原始路线，以及我们的路径重写路线，在基于CRD的Ingress: Gloo中会是什么样子。</p><h1 id="5f61" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Solo.io Gloo虚拟服务</h1><p id="eacd" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">Gloo使用了一个叫做<a class="ae kz" href="https://gloo.solo.io/introduction/concepts#virtual-services" rel="noopener ugc nofollow" target="_blank">虚拟服务</a>的概念，这个概念来源于Istio和Envoy中的类似概念，在概念上相当于一个入口资源。最简单的方法是向您展示我们到目前为止在Gloo虚拟服务中创建的示例入口的等价物。</p><figure class="me mf mg mh gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="c58a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您会注意到，它看起来与我们之前创建的入口非常相似，只是做了一些细微的更改。路径说明符是<code class="fe mi mj mk ml b">prefix: /</code>，这通常是人们想要的，也就是说，如果请求消息路径的开头与路由路径说明符匹配，那么就应用路由操作。如果我们想精确匹配之前的入口，我们可以使用<code class="fe mi mj mk ml b">regex: /.*</code>来代替。虚拟服务允许您通过前缀、精确和正则表达式来指定路径。您还可以看到，虚拟服务有一个<code class="fe mi mj mk ml b">routeAction</code>委托给一个<code class="fe mi mj mk ml b">single</code> <code class="fe mi mj mk ml b">upstream</code>，而不是有<code class="fe mi mj mk ml b">serviceName</code>和<code class="fe mi mj mk ml b">servicePort</code>的<code class="fe mi mj mk ml b">backend:</code>。Gloo上游是自动发现的，可以引用Kubernetes服务和REST/gRPC函数、像AWS Lambda和Google函数这样的云函数以及Kubernetes服务的其他外部函数。</p><p id="8e69" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有关Solo.io Gloo的更多详细信息，请访问:</p><ul class=""><li id="e41b" class="mo mp it kd b ke kf ki kj km mq kq mr ku ms ky mt mu mv mw bi translated"><a class="ae kz" href="https://medium.com/solo-io/routing-with-gloo-function-gateway-301765bb103e" rel="noopener">带Solo.io Gloo功能网关的路由</a></li><li id="c8c5" class="mo mp it kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated"><a class="ae kz" href="https://medium.com/solo-io/5-minutes-with-gloo-the-anatomy-of-a-virtualservice-4deb4cfc558e" rel="noopener">solo . io Gloo的5分钟——虚拟服务的剖析</a></li></ul><p id="1ba1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们回到我们的例子，更新我们的虚拟服务来做我们想要的路径重写，即<code class="fe mi mj mk ml b">/people</code> = &gt; <code class="fe mi mj mk ml b">/users.</code></p><figure class="me mf mg mh gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9d90" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加了第二个路由匹配器，就像在入口中添加第二个路由路径并指定<code class="fe mi mj mk ml b">prefix: /people</code>。这将匹配所有以<code class="fe mi mj mk ml b">/people</code>开始的请求，所有其他对<code class="fe mi mj mk ml b">gloo.example.com</code>域的调用将由另一个路由匹配器处理。我们还添加了一个<code class="fe mi mj mk ml b">routePlugins</code>部分，它将重写到<code class="fe mi mj mk ml b">/users</code>的请求路径，这样我们的服务现在将正确地处理我们的请求。<a class="ae kz" href="https://gloo.solo.io/user_guides/advanced_route_plugins/" rel="noopener ugc nofollow" target="_blank">路由插件</a>允许你对上游服务的请求和从上游服务返回的响应执行许多操作。最好用一个例子来展示，所以对于我们新的<code class="fe mi mj mk ml b">/people</code>路由，让我们也转换响应，添加一个新的头<code class="fe mi mj mk ml b">x-test-phone</code>和来自响应体的值，让我们转换响应体以返回几个字段:名称、地址/街道和地址/城市。</p><figure class="me mf mg mh gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="a201" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看那是什么样子。我的示例GitHub存储库已经包含了我们刚刚检查过的完整的Gloo虚拟服务。我们需要为<code class="fe mi mj mk ml b">gateway</code>配置Gloo，这意味着除了入口资源之外，还要添加另一个代理来处理虚拟服务。我们将使用<code class="fe mi mj mk ml b">draft up</code>来确保我们的示例被完全部署，包括完整的虚拟服务，然后我们将调用<code class="fe mi mj mk ml b">/users/1</code>和<code class="fe mi mj mk ml b">/people/1</code>来查看差异。</p><figure class="me mf mg mh gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="me mf mg mh gt ju gh gi paragraph-image"><a href="https://asciinema.org/a/5DXyvz6bOmd6zTjayKJ4kjZlB"><div class="gh gi nc"><img src="../Images/e1c9a180ab0d138949c76a4c4fba57af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FxXeq_0vj8cI-AjGNv-_Vg.png"/></div></a></figure><figure class="me mf mg mh gt ju gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/9718690cbf0bf8924fef80b05e1c1486.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*noj_EGEoD6AMsz06-Ox39g.png"/></div></figure><p id="631d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好吧，如果你使用过其他L7网络产品或做过其他集成工作，这并不令人惊讶，但相对于标准的入口对象来说仍然很酷。Gloo使用Inja模板来处理JSON响应体。更多细节请见<a class="ae kz" href="https://gloo.solo.io/user_guides/advanced_route_plugins#transformation_template" rel="noopener ugc nofollow" target="_blank"> Gloo文档</a>。</p><h1 id="0e1a" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">摘要</h1><p id="d9f3" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在本文中，我们谈到了现有Kubernetes入口资源的一些历史和困难。尽管基于注释的扩展面临许多挑战，但是入口资源仍然在Kubernetes部署中发挥着作用。Kubernetes Custom Resources (CRDs)的创建就是为了解决其中的一些扩展挑战，它可以提供一种更简洁的方式来扩展Kubernetes，正如您在Gloo入口和网关示例中看到的那样。正如Istio和Contour社区中的其他人一样，我非常相信基于Envoy的解决方案的潜力，看到Kubernetes社区在最终将现有资源规范转移到GA状态后如何决定发展Ingress将是令人兴奋的。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><p id="d879" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np">原载于</em><a class="ae kz" href="https://scott.cranton.com/ingress_and_beyond.html" rel="noopener ugc nofollow" target="_blank"><em class="np">scott.cranton.com</em></a><em class="np">。</em></p></div></div>    
</body>
</html>