<html>
<head>
<title>Re-sorting Web-based Tabs like it works in Google Chrome</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重新排序基于网络的标签，就像在谷歌浏览器中一样</h1>
<blockquote>原文：<a href="https://itnext.io/re-sorting-web-based-tabs-like-it-works-in-google-chrome-38d749fc8ede?source=collection_archive---------4-----------------------#2020-10-24">https://itnext.io/re-sorting-web-based-tabs-like-it-works-in-google-chrome-38d749fc8ede?source=collection_archive---------4-----------------------#2020-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2dd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尤其是当你在浏览器中打开了很多标签页时，你很可能每天都在使用这个功能。基于拖放的重新排序使用起来很有趣，并且提供了很好的用户体验。</p><p id="1815" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只是为了确保你脑子里有同样的画面:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="kq kr l"/></div></figure><p id="7dc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果你看看今天大多数使用标签的基于网络的用户界面，你会注意到没有基于拖放的重新排序。</p><p id="3f0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这实际上是一个问题，因为用户熟悉这个特性并且喜欢它。</p><p id="529a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我接受了为基于网络的应用程序实现相同的UX的挑战，包括垂直标签栏和倒置的flexbox布局。</p><p id="2f8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文将展示我在途中遇到的一些问题，并深入到编码方面。</p><h1 id="301f" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">内容</h1><ol class=""><li id="fcf5" class="lq lr iq jp b jq ls ju lt jy lu kc lv kg lw kk lx ly lz ma bi translated">介绍</li><li id="0a7d" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">neo.mjs是什么？</li><li id="08f8" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">如何给基于flexbox的工具栏添加动画？</li><li id="9344" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">拖动:移动逻辑是如何工作的？</li><li id="6f35" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">标签重新排序是如何工作的？</li><li id="efa2" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">正在使用工具栏。SortZone可选？</li><li id="1488" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">视频示例的在线演示</li><li id="7409" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">如何使用该功能</li><li id="bace" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">neo.mjs路线图上的下一个项目是什么？</li><li id="746f" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">最后的想法</li></ol><h1 id="7695" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">1.介绍</h1><p id="88bc" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">为了提前获得一个快速概览，这里有一个简短的视频，展示了基于拖放的标签重新排序，包括垂直标题工具栏，动态更改布局和主题:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="kq kr l"/></div></figure><p id="8a15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在基于开源的neo.mjs UI框架中实现了逻辑，但是您也可以让它适用于不同的场景。</p><h1 id="1fbb" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">2.neo.mjs是什么？</h1><p id="524e" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">neo.mjs是一个极具颠覆性的基于Javascript的下一代UI框架。<br/>它能让你创建超快的多线程前端。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mj"><img src="../Images/a7fca033f8ce88ca8542d4f3178f46dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WUiHLOpUj8WzxltePJNt3A.png"/></div></div></figure><p id="ad71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里找到麻省理工学院授权资料库:</p><div class="mq mr gp gr ms mt"><a href="https://github.com/neomjs/neo" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">近地天体</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">neo.mjs使您能够使用一个以上的CPU创建可扩展的高性能应用程序，而无需使用…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">github.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh mo mt"/></div></div></a></div><p id="640b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想加入一个可爱的开源项目:neo.mjs正在寻找更多的贡献者。对基于neo.mjs的ui的需求正在快速增长，因此如果您正在寻找新的客户项目，了解最新情况是有意义的。</p><h1 id="8656" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">3.如何给基于flexbox的工具栏添加动画？</h1><p id="58f5" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">TabHeader只是<code class="fe ni nj nk nl b">container.Toolbar</code>的一个类扩展。<br/>显然它坚持使用CSS3并使用<code class="fe ni nj nk nl b">display:flex</code>，所以标签(按钮)可以有一个灵活的样式来指定它们的宽度，或者使用一个固定的宽度。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nm"><img src="../Images/cf905d8eb627091ca765fe0e3826e211.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u7YrzpYbukwpYEtA3KPS_g.png"/></div></div></figure><p id="7f38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想想看:<br/>使用动画在flexbox布局中移动项目<strong class="jp ir">是不可能的</strong>。</p><p id="ed5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，它是如何工作的呢？</p><p id="1657" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主线程使用鼠标或触摸传感器，并将自定义的<code class="fe ni nj nk nl b">drag:start</code>、<code class="fe ni nj nk nl b">drag:move</code>和<code class="fe ni nj nk nl b">drag:end</code>事件转发给应用程序工作人员。</p><p id="3329" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你愿意，你可以选择使用DragDrop主线程插件。这确保了在你的应用不需要DD的情况下，没有关于文件大小的开销。详细描述插件会离题太远，所以我只是贴上它的源代码链接(以防你好奇):</p><p id="71c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae nn" href="https://github.com/neomjs/neo/blob/dev/src/main/addon/DragDrop.mjs" rel="noopener ugc nofollow" target="_blank">https://github . com/neom js/neo/blob/dev/src/main/addon/dragdrop . mjs</a></p><p id="a1f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将要详细介绍的是新的<code class="fe ni nj nk nl b">draggable.toolbar.SortZone</code>。</p><p id="ecc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个类是对<code class="fe ni nj nk nl b">draggable.toolbar.DragZone</code>的扩展，它将订阅提到的与拖动相关的事件。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="no kr l"/></div></figure><p id="b5f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae nn" href="https://github.com/neomjs/neo/blob/dev/src/draggable/toolbar/DragZone.mjs#L35" rel="noopener ugc nofollow" target="_blank">https://github . com/neom js/neo/blob/dev/src/draggable/toolbar/drag zone . mjs # L35</a></p><p id="b477" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">启用动画选项卡移动的一种方法是将每个选项卡转换为绝对定位的元素。为此，我们需要获取相关的DomRects，其中包含相关的大小和位置。</p><p id="e098" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ni nj nk nl b">Element.getBoundingClientRect()</code>助此:</p><div class="mq mr gp gr ms mt"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">Element.getBoundingClientRect()</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">方法返回一个元素的大小和它相对于视图的位置…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">developer.mozilla.org</p></div></div><div class="nc l"><div class="np l ne nf ng nc nh mo mt"/></div></div></a></div><p id="41e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们的代码在App Worker范围内运行，所以不能直接访问DOM。不过这没什么大不了的，因为我们可以使用remotes API轻松地从主线程获取数据:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="no kr l"/></div></figure><p id="32f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以传递一个id数组，并异步获取相关数据。</p><p id="93c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ni nj nk nl b">Neo.main.DomAccess</code>也不存在于App Worker范围内，但是remotes API将通过承诺使公开的方法可用。这个调用将从应用程序工作人员向主线程发送一条postMessage，获取数据，向应用程序工作人员发回一条postMessage，承诺就实现了。</p><p id="df2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完整的逻辑如下:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="no kr l"/></div></figure><p id="1762" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里重要的部分是第20行<code class="fe ni nj nk nl b">item.style=</code>。<br/>虽然这可能看起来像一个赋值，但Component.style是一个基于neo.mjs的类配置。改变<code class="fe ni nj nk nl b">style</code>的值将触发一个setter，比较新的样式对象和当前的样式对象，并将相关的增量更新发送给主线程。</p><p id="07b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您一直在关注与neo.mjs相关的其他博客帖子，您将会知道在运行时动态更改DOM是这个框架的一大优势。</p><p id="91ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们正在转换所有工具栏项目，包括我们正在拖动的项目。该项目将获得样式<code class="fe ni nj nk nl b">visibility: 'hidden'</code>，以保持定位和移动逻辑一致。</p><h1 id="8779" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">4.拖动:移动逻辑是如何工作的？</h1><p id="17a7" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">此时，您可能想知道如何拖动隐藏的元素。我们没有。答案就在<code class="fe ni nj nk nl b">draggable.DragZone</code>里面:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="no kr l"/></div></figure><p id="3c9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们获取想要拖动的元素的DomRect，并调用<code class="fe ni nj nk nl b">createDragProxy()</code>方法。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="no kr l"/></div></figure><p id="0822" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个正在克隆我们想要拖动的组件的DOM树，并且正在创建一个新的DragProxyComponent。</p><p id="0120" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们的用例来说，<code class="fe ni nj nk nl b">moveInMainThread</code>等于true，所以我们不需要手动处理应用工人内部的运动。性能方面快了一个百分点。</p><p id="0c54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以传递一个<code class="fe ni nj nk nl b">boundaryContainerId</code>给主线程DragDrop addon，它将移动限制在匹配的DomRect。</p><h1 id="d2f6" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">5.标签重新排序是如何工作的？</h1><p id="29c1" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">我们的应用程序工作人员订阅了<code class="fe ni nj nk nl b">drag:move</code>事件，因此我们可以轻松地添加更多应该发生的逻辑。</p><p id="c605" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ni nj nk nl b">draggable.toolbar.SortZone</code>逻辑看起来是这样的:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="no kr l"/></div></figure><p id="4398" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我试了几次才把代码做成这个形状。</p><p id="69b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它涵盖了4种使用情形:</p><ol class=""><li id="6e7d" class="lq lr iq jp b jq jr ju jv jy nq kc nr kg ns kk lx ly lz ma bi translated"><code class="fe ni nj nk nl b">flex-direction: row</code></li><li id="a912" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><code class="fe ni nj nk nl b">flex-direction: row</code>，<code class="fe ni nj nk nl b">sort-direction: row-reverse</code></li><li id="f321" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><code class="fe ni nj nk nl b">flex-direction: column</code></li><li id="38ee" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><code class="fe ni nj nk nl b">flex-direction: column</code>，<code class="fe ni nj nk nl b">sort-direction: column-reverse</code></li></ol><p id="4d7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住，当我们反转<code class="fe ni nj nk nl b">sort-direction</code>时，索引从容器的另一侧开始，但是我们仍然需要以正确的方式比较<code class="fe ni nj nk nl b">left</code>或<code class="fe ni nj nk nl b">top</code>的值。</p><p id="6a0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ni nj nk nl b">switchItems()</code>的逻辑非常简单:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="no kr l"/></div></figure><p id="86f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要一个indexMap，因为一个拖动操作可以触发多个<code class="fe ni nj nk nl b">switchItems()</code>调用，我们只在<code class="fe ni nj nk nl b">drag:end</code>触发时调整实际项目。</p><p id="72bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这也使我们能够在任何时间点停止拖动操作。<br/>例如，我们可以在用户点击ESC键时添加一个<code class="fe ni nj nk nl b">drag:cancel</code>事件，并删除绝对定位。</p><p id="89ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果有人想添加这个功能，欢迎您加入:)</p><p id="726e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ni nj nk nl b">updateItem()</code>逻辑很简单:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="no kr l"/></div></figure><p id="fcb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们只是再次使用样式配置设置器。</p><p id="5f06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更改左上方的值将自动触发基于CSS3的动画:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nt"><img src="../Images/5ccbe2720a8dabcd959f02ef259dfba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nmJgFB6qDImR9ANcP1dU4Q.png"/></div></div></figure><p id="c603" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然，<code class="fe ni nj nk nl b">onDragEnd()</code>将删除绝对定位，恢复固定项目大小(如果它们存在的话)并触发相关的<code class="fe ni nj nk nl b">Container.moveTo()</code>逻辑。</p><p id="31ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里查看完整的<code class="fe ni nj nk nl b">SortZone</code>源代码:</p><p id="2980" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae nn" href="https://github.com/neomjs/neo/blob/dev/src/draggable/toolbar/SortZone.mjs" rel="noopener ugc nofollow" target="_blank">https://github . com/neom js/neo/blob/dev/src/draggable/toolbar/sort zone . mjs</a></p><p id="dddc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有更多的边缘案例&amp;隐藏的宝石等待你去发现。</p><h1 id="fd4d" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">6.正在使用工具栏。SortZone可选？</h1><p id="da87" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">是的，绝对是。<code class="fe ni nj nk nl b">tab.header.Toolbar</code>有一个<code class="fe ni nj nk nl b">sortable</code>配置，<br/>将自动触发:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="no kr l"/></div></figure><p id="d9e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个逻辑其实很美。</p><p id="316d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您所希望的那样，neo.mjs开发模式直接在浏览器中运行，没有任何构建或代码转换。</p><p id="6c59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们可以使用动态导入，浏览器只会在需要时加载相关文件。</p><p id="1030" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这段代码也可以很好地与基于webpack的<code class="fe ni nj nk nl b">dist/production</code>环境的相关构建一起工作。</p><p id="89e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我在我的跨应用拆分块博文中提到的:</p><div class="mq mr gp gr ms mt"><a href="https://medium.com/swlh/cross-app-bundling-a-different-approach-for-micro-frontends-e4f212b6a9a" rel="noopener follow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">跨应用捆绑——微前端的一种不同方法</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">捆绑分布式版本的应用程序代码一直是一个挑战，尤其是在您想要共享代码的情况下…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">medium.com</p></div></div><div class="nc l"><div class="nu l ne nf ng nc nh mo mt"/></div></div></a></div><p id="f3b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们确实有动态块。你可以将多个应用放在一个页面上，几乎没有任何开销。这也涵盖了一些场景，在这些场景中，你有一些模块的基本依赖项，而你已经将这些模块惰性加载到你的应用中了。</p><h1 id="3441" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">7.视频示例的在线演示</h1><p id="13a4" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">这个例子还没有完全适应移动设备，但是基于拖放的逻辑在那里工作得很好。</p><p id="79c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae nn" href="https://neomjs.github.io/pages/node_modules/neo.mjs/dist/production/examples/tab/container/index.html" rel="noopener ugc nofollow" target="_blank">https://neom js . github . io/pages/node _ modules/neo . mjs/dist/production/examples/tab/container/index . html</a></p><p id="7558" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用Chrome开发工具切换到平板电脑视图:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nv"><img src="../Images/3bbd2bd1c90222fa12ac7c6e0a1a4a61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Mx7Rt05Fp_IvygvNFWXeQ.png"/></div></div></figure><p id="dfa7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">提示</strong>:切换到手机模拟后，请确保<strong class="jp ir">重新加载</strong>页面。</p><p id="952d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">框架要么使用<code class="fe ni nj nk nl b">MouseSensor</code>要么使用<code class="fe ni nj nk nl b">TouchSensor</code>，而不是同时使用两者。</p><p id="3a58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还添加了重新排序neo.mjs文档应用程序的选项卡。<br/>是的，它也适用于动态添加的标签:</p><p id="6093" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae nn" href="https://neomjs.github.io/pages/node_modules/neo.mjs/dist/production/docs/index.html" rel="noopener ugc nofollow" target="_blank">https://neom js . github . io/pages/node _ modules/neo . mjs/dist/production/docs/index . html</a></p><p id="d8f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该功能还添加到了Covid仪表板以及SharedWorkers驱动的多浏览器窗口应用程序中。</p><p id="ab1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在此找到所有在线示例:</p><p id="4fa1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae nn" href="https://neomjs.github.io/pages/node_modules/neo.mjs/dist/production/apps/website/index.html#mainview=examples" rel="noopener ugc nofollow" target="_blank">https://neom js . github . io/pages/node _ modules/neo . mjs/dist/production/apps/website/index . html # main view = examples</a></p><h1 id="34f0" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">8.如何使用该功能</h1><p id="71ec" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">为你的工具栏或标签容器使用拖放重新排序功能是非常简单的。你需要做的就是添加<code class="fe ni nj nk nl b">sortable:true</code>配置。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="no kr l"/></div></figure><h1 id="6aa8" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">9.neo.mjs路线图上的下一个项目是什么？</h1><p id="4671" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">现在，我正在做一个客户端项目，创建一个基于neo.mjs的UI生成器。有点类似于WebFlow，但是它将创建基于neo.mjs的组件树。</p><p id="8d6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感觉就像一部永恒的手机:</p><p id="091f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于neo.mjs的UI，使其应用程序用户能够通过拖放创建基于neo.mjs的UI。</p><p id="7dc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于框架本身来说，这意味着接下来我将关注树的拖拽区域和排序区域。绝对是一个史诗项目。</p><p id="1518" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为此时浏览器对公共类字段的支持非常好:</p><div class="mq mr gp gr ms mt"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">公共类字段</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">静态和实例公共字段都是可写、可枚举和可配置的属性。因此，不像他们…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">developer.mozilla.org</p></div></div><div class="nc l"><div class="nw l ne nf ng nc nh mo mt"/></div></div></a></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nx"><img src="../Images/95d0909b8e1bdb98869bd6db36ea5b70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S58ceH_AjKdT-awK0_CTLw.png"/></div></div></figure><p id="2f33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想尽快把它添加到neo.mjs框架中。我们可以将所有“原始”配置移出<code class="fe ni nj nk nl b">static getConfig()</code>逻辑。</p><p id="a96b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是该框架上市以来第一次真正的突破性变化，所以这将是neo.mjs v2。</p><p id="3a5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">唯一阻碍我的是webpack还不支持公共类字段。更准确地说:他们使用的是acorn解析器，没有相关的Stage3提议。</p><p id="1646" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，我还没有运气覆盖npm依赖:</p><div class="mq mr gp gr ms mt"><a href="https://github.com/neomjs/neo/issues/1228" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">添加对公共类字段的支持问题#1228 neomjs/neo</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">解散GitHub是超过5000万开发者的家园，他们一起工作来托管和审查代码，管理项目，以及…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">github.com</p></div></div><div class="nc l"><div class="ny l ne nf ng nc nh mo mt"/></div></div></a></div><p id="e996" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果有人有一个好主意，帮助这一个是赞赏的！</p><h1 id="81cf" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">10.最后的想法</h1><p id="ff9b" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">通过基于拖放的标签重新排序，您可以轻松地将此功能添加到您的应用程序中。</p><p id="75b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">非常欢迎您在其上构建自定义逻辑。</p><p id="82ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦基于树的拖放逻辑就位，我还想进一步增强日历组件，并进一步完善对话框的拖放。</p><p id="8518" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">特别是一个多浏览器窗口的拖放演示将是惊人的。在我的待办事项列表中，准备下一篇博文。</p><p id="6edc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">祝编码愉快，并在疫情期间保持安全！</p><p id="323e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最诚挚的问候，<br/>托拜厄斯</p></div></div>    
</body>
</html>