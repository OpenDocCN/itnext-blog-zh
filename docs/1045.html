<html>
<head>
<title>Consuming a multipart/form-data REST Method with OutSystems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用外部系统的多部分/形式数据REST方法</h1>
<blockquote>原文：<a href="https://itnext.io/consuming-a-multipart-form-data-rest-method-with-outsystems-c466e404118d?source=collection_archive---------0-----------------------#2018-07-11">https://itnext.io/consuming-a-multipart-form-data-rest-method-with-outsystems-c466e404118d?source=collection_archive---------0-----------------------#2018-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7b7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更新:文章中有一些技术上的错误，我已经改正了。</p><p id="5170" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更新(2023年2月22日):OutSystems宣布，在Service Studio 11.53.40和Platform Server 11.19.0中，下面描述的功能现在是OutSystems REST consume的原生部分。我暂时保留这篇文章，以后我可能会用原生功能更新它。</p><h2 id="4411" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">前言</h2><p id="e831" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">几周前，我被要求在OutSystems中创建一个与外部供应商的REST API的接口。除了REST API的供应商严重缺乏功能文档之外，这个过程非常简单，直到我遇到了一个绊脚石:其中一个上传文档的方法使用了一种叫做“多部分/表单数据”的东西，该平台本身并不支持这种东西。在<a class="ae lj" href="https://www.outsystems.com/forums" rel="noopener ugc nofollow" target="_blank"> OutSystems社区论坛</a>上相当活跃，我经常看到有人在尝试消费REST服务时遇到这个问题(例如，这里的<a class="ae lj" href="http://•&#9;https://www.outsystems.com/forums/discussion/17055/rest-api-multipart-form-data" rel="noopener ugc nofollow" target="_blank"/>、这里的<a class="ae lj" href="http://•&#9;https://www.outsystems.com/forums/discussion/32907/multipart-file-upload" rel="noopener ugc nofollow" target="_blank"/>和这里的<a class="ae lj" href="http://•&#9;https://www.outsystems.com/forums/discussion/33380/how-to-consume-http-post-rest-api-using-multipart-form-data-method" rel="noopener ugc nofollow" target="_blank"/>)，但我自己从未经历过，直到现在。所以我做了两件事:首先，我为OutSystems创建了一个<a class="ae lj" href="https://www.outsystems.com/ideas/5022/rest-native-support-of-multipart-form-data" rel="noopener ugc nofollow" target="_blank">社区想法</a>来本地支持它；其次，我想到了如何满足REST API，同时对其接口的实现产生最小的影响，这将在本文中描述。</p><h2 id="de51" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">在外部系统中休息</h2><p id="2359" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">我想看的第一件事是OutSystems实现REST的方式。REST是HTTP(用于检索网页的协议)之上的一个协议，通常(但不是唯一的)使用JSON进行数据通信。通过HTTP发送数据时，发送方必须指定要发送的内容类型。因为OutSystems只支持JSON，所以它在HTTP“Content-Type”头中发送“application/json”。在消息体中，实际的JSON以紧凑的方式(没有换行)发送，如下所示:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="2ace" class="kl km iq lp b gy lt lu l lv lw">{"name":"Test for POST","type":"PACKAGE","language":"en","description":"This is a test for posting a package"}</span></pre><p id="1218" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这适用于大约95%的REST方法，因此它符合支持最常用软件模式的OutSystems哲学，而不需要支持所有这些模式。</p><h2 id="c26f" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">多重什么？</h2><p id="b507" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">那么我前面提到的“多部分/形式数据”是什么，为什么要使用它呢？首先介绍一些背景。“表单数据”是HTTP术语，指用户在网页上输入的任何数据(“HTML表单”)，这些数据随后通过HTTP发送(或“发布”)到web服务器。通常，表单只包含简单的输入字段，并且这些字段以您可能认识的格式发送，因为它与用于向web屏幕传递参数的格式相同:它由名称/值对组成，由赋值字符(" = ")分隔，由与号(" &amp; ")连接，特殊字符由百分号及其十六进制字符代码替换(例如，" %20 "表示空格):</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="ec2f" class="kl km iq lp b gy lt lu l lv lw">name=This%20is%20a%20test&amp;language=en</span></pre><p id="9cc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种格式的HTTP内容类型是“application/x-www-form-urlencoded”。这对于简单的输入字段来说很好，但是网页也可能允许用户上传一个或多个文件。为了支持这一点，在web早期创建了另一种格式，它以其内容类型“多部分/表单数据”而闻名。因此，从本质上说，多部分/形式数据是浏览器向web服务器发送一个或多个文件的一种方式(它后来被用于在电子邮件中发送附件，甚至后来被用于REST)。发送多部分/形式数据的确切格式相当神秘(就像大多数早期的web协议一样)，但幸运的是，对我们来说，它主要是纯文本的，所以很容易阅读和操作。</p><p id="53ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，发送multipart/form-data的客户机(如浏览器或REST消费应用程序)将HTTP内容类型设置为“multipart/form-data”，而不仅仅是内容类型，还需要指定一个叫做<em class="lx">边界</em>的东西。这是一个独特的文本字符串，必须保证它不会出现在消息中的任何地方，因此它可以指示几个部分(毕竟是<em class="lx"> multi </em> part)。习惯上，边界以一串破折号开始，后跟某种GUID，尽管只要满足我上面提到的规则，客户可以随意设置边界。边界添加在内容类型后面，用分号隔开，后面是文本“boundary=”，再后面是边界本身，用双引号括起来:</p><p id="bc48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ly lz ma lp b">Content-Type: multipart/form-data;boundary="MyBoundary"</code></p><p id="0575" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">消息正文由一个或多个部分组成，每个部分以两个破折号(<code class="fe ly lz ma lp b">--</code>)开头，后跟边界文本。在下一行，有文本<code class="fe ly lz ma lp b">Content-Disposition: form-data; name="<em class="lx">name</em>"</code>，其中引号中的<em class="lx">名称</em>是商品的名称。如果该部分包含文件数据，该行也包含文件名，如下所示:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="cfe5" class="kl km iq lp b gy lt lu l lv lw">--MyBoundary<br/>Content-Disposition: form-data; name="myFile" filename="myfile.docx"</span></pre><p id="34e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一行之后有一个空行，后面是与“<em class="lx"> name </em>关联的值。对于简单的输入字段，这是输入字段的值，对于文件，这是其二进制数据。在数据之后，一个新的部分开始(中间没有空行)。在最后一部分之后，为了表示多部分/格式数据消息的结束，再次添加了边界，但是这一次，边界不仅以两个破折号开始，而且以两个破折号结束:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="d0c7" class="kl km iq lp b gy lt lu l lv lw">--MyBoundary--</span></pre><p id="c766" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，我不是第一个试图解决发送多部分/形式数据问题的人。各种REST APIs的Forge组件已经用许多不同的方式解决了这个问题，甚至有一个Forge组件用于<a class="ae lj" href="https://www.outsystems.com/forge/component/3731/multipart-upload" rel="noopener ugc nofollow" target="_blank">独立于REST发送多部分/表单数据</a>。但是到目前为止，我所看到的没有一件是我完全喜欢的。所以我决定创建一个适合我的需求(和我的审美品味)的实现。</p><h2 id="1b6d" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">实施细节</h2><p id="7732" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">无论选择哪种实现，最终都需要做两件事:发送正确的内容类型头，以及发送格式正确的正文(如上所述)。如果包含包含二进制数据的文件(即除文本文件之外的任何文件)，则需要声明REST API方法，该方法具有一个数据类型为“二进制数据”的参数，并且其“Send In”属性设置为“Body”。这允许不加修改地发送二进制数据，这正是我们想要的。如果还阻止平台在标题中添加内容类型标签，那么您需要添加(通过一个参数，将“Send In”设置为“Header”)。(小的)缺点是，为了编写消息，您需要<a class="ae lj" href="https://www.outsystems.com/forge/component/2067/binary-concat/" rel="noopener ugc nofollow" target="_blank"> Binary Concat </a> Forge组件来连接各个部分，以及来自BinaryData扩展(这是一个系统组件，所以已经安装了)的动作，以便在将消息的基于文本的部分与文件的二进制数据连接之前，将其转换为二进制。</p><p id="a5e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一种方法是将REST API方法声明为“普通”JSON方法，并在消息发送到REST服务之前修改消息，这种方法只在消息不包含任何二进制数据时有效(例如，只发送文本文件时)。在OutSystems中，这是通过定义OnBeforeRequest操作来完成的。OnBeforeRequest操作在REST API的高级属性中定义。从下拉菜单中选择“新建OnBeforeRequest”(不是“高级”菜单！)，在REST API下面会出现动作:</p><figure class="lk ll lm ln gt mc gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/75dbe8a015656398e66598366b2d2538.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*hNQWKTIeZT8ejJyWYEejJA.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">选择“OnBeforeRequest”大正义！</figcaption></figure><figure class="lk ll lm ln gt mc gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/ab37aad9d1474db1454d600644030388.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/format:webp/1*U8g-4bDe8DUtDgdI-HsxVQ.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">给你，为了你的修饰快乐。</figcaption></figure><p id="e71b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如图所示，OnBeforeRequest有一个输入参数和一个输出参数。两者都是HTTPRequest类型，包含修改REST消息所需的一切:</p><figure class="lk ll lm ln gt mc gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/cf2fe385a73187c67d81819640c932fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:352/format:webp/1*sILCCcH1Fl1VQ_0mkRFLcQ.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">HTTPRequest结构。</figcaption></figure><p id="e626" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意OnBeforeRequest是一种修改REST消息的通用方法，并不特定于multipart/form-data。还要注意，整个REST API只有一个OnBeforeRequest，而不是每个方法都有一个。这意味着在OnBeforeRequest内部，您需要通过检查请求输入参数的URLPath和HTTPMethod属性来检查调用了哪个方法。</p><h2 id="b12f" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">我的解决方案</h2><p id="f535" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">当我需要发送二进制数据时，我不得不选择第一种方法。这意味着我添加了两个输入参数:一个用于内容类型，一个用于二进制体。使用我的Forge组件(见下文),我将多个部分(包括一个JSON部分)添加到消息中，之后我通过二进制数据参数分配连接的部分。</p><h2 id="9584" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">锻造部件</h2><p id="4724" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">不管对您的项目有意义的具体解决方案是什么，我都创建了一个Forge组件，恰当地命名为<a class="ae lj" href="https://www.outsystems.com/forge/4026/" rel="noopener ugc nofollow" target="_blank"> Multipart/form-data </a>，它由一个eSpace和一些公共动作组成，这些动作有助于创建正确的内容:</p><ul class=""><li id="3d76" class="ml mm iq jp b jq jr ju jv jy mn kc mo kg mp kk mq mr ms mt bi translated">MultipartFormDataCreate —主操作，以多部分/格式数据兼容的格式创建由指定部分组成的文本正文。</li><li id="05fb" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">ContentTypeGet —根据使用的边界返回用于REST消息的内容类型头的值。</li><li id="5a3d" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">PartAdd —一个助手函数，可用于轻松创建零件列表。</li></ul><h2 id="71c1" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">包扎</h2><p id="76b0" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">就这样，我的第一篇关于媒介的文章。我希望您喜欢它，并发现它在使用多部分/表单数据实现REST时非常有用。任何问题都可以在<a class="ae lj" href="https://www.outsystems.com/forums" rel="noopener ugc nofollow" target="_blank"> OutSystems社区论坛</a>、<a class="ae lj" href="https://www.outsystems.com/forge/component-discussions/4026/Multipart%2fform-data" rel="noopener ugc nofollow" target="_blank">组件的子论坛</a>上提出，或者作为最后的手段通过<a class="ae lj" href="https://www.outsystems.com/profile/5974/" rel="noopener ugc nofollow" target="_blank"> PM </a>提出。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="ab01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[1]对于消费REST服务来说，这并不完全正确，但是为了本文的目的，我们假设这是正确的，因为其他受支持的类型对于我们想要支持的“多部分/表单数据”来说是没有用的。</p><p id="e421" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[2]另一个解决方案是将需要多部分/形式数据的单个方法隔离在它自己的REST API中，但是我建议不要这样做，因为不再有方法的逻辑分组，并且您需要在服务中心两次配置相同的基本URL，这很容易出错。</p><p id="2386" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[3]在本文的前一个版本中，我提到了选择第二种方法。这是基于一个错误的假设，即我可以通过将二进制数据转换为文本来使其工作，但事实证明并非如此。</p></div></div>    
</body>
</html>