<html>
<head>
<title>Resilient JavaScript with Sanctuary</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带避难所的弹性JavaScript</h1>
<blockquote>原文：<a href="https://itnext.io/resilient-javascript-with-sanctuary-858bf3ca1790?source=collection_archive---------2-----------------------#2019-05-15">https://itnext.io/resilient-javascript-with-sanctuary-858bf3ca1790?source=collection_archive---------2-----------------------#2019-05-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f3af2c5fe29ab3fc7f73ab899bb4d365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N0FGZHTw_Az0641mKXQn4Q.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">圣米格尔·阿尔坎霍堡|法罗林·达·纳扎雷</figcaption></figure><p id="5de6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">JavaScript真的很好，但它是一把双刃剑:一方面，它很容易开始和构建一些东西，而另一方面，它很容易中断流程。</p><p id="ba43" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你正在阅读这篇文章，你可能会明白我在说什么，但仍然不相信JavaScript的健壮性(或者仍然在寻找圣杯)。</p><p id="03eb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这篇文章中，我想展示一个简单的库如何帮助我们用更安全、更有弹性和更可预测的东西来增强我们的代码、逻辑和算法:<strong class="kh iu">避难所</strong>！</p><div class="ld le gp gr lf lg"><a href="https://github.com/sanctuary-js/sanctuary" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab fo"><div class="li ab lj cl cj lk"><h2 class="bd iu gy z fp ll fr fs lm fu fw is bi translated">避难所-js/避难所</h2><div class="ln l"><h3 class="bd b gy z fp ll fr fs lm fu fw dk translated">躲避不安全的JavaScript。通过在…上创建帐户，为sanctuary-js/sanctuary开发做出贡献</h3></div><div class="lo l"><p class="bd b dl z fp ll fr fs lm fu fw dk translated">github.com</p></div></div><div class="lp l"><div class="lq l lr ls lt lp lu jz lg"/></div></div></a></div><p id="6296" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个库依赖于<strong class="kh iu">函数式编程、幻想世界</strong>和<strong class="kh iu"> Haskell </strong>概念，所以如果你不熟悉这些概念，可能会有点困难。如果是这样的话，我建议先查看一下这些资源(这样会让整个事情变得简单很多):</p><div class="ld le gp gr lf lg"><a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab fo"><div class="li ab lj cl cj lk"><h2 class="bd iu gy z fp ll fr fs lm fu fw is bi translated">图片中的函子、应用和单子</h2><div class="ln l"><h3 class="bd b gy z fp ll fr fs lm fu fw dk translated">这里有一个简单的值:我们知道如何对这个值应用一个函数:非常简单。让我们…</h3></div><div class="lo l"><p class="bd b dl z fp ll fr fs lm fu fw dk translated">adit.io</p></div></div><div class="lp l"><div class="lv l lr ls lt lp lu jz lg"/></div></div></a></div><div class="ld le gp gr lf lg"><a href="https://sanderv1992.github.io/fp/" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab fo"><div class="li ab lj cl cj lk"><h2 class="bd iu gy z fp ll fr fs lm fu fw is bi translated">函数式编程(幻想世界JavaScript规范指南)</h2><div class="ln l"><h3 class="bd b gy z fp ll fr fs lm fu fw dk translated">函数式编程(幻想世界JavaScript规范指南)</h3></div><div class="lo l"><p class="bd b dl z fp ll fr fs lm fu fw dk translated">函数式编程(幻想世界JavaScript规范指南)sanderv1992.github.io</p></div></div><div class="lp l"><div class="lw l lr ls lt lp lu jz lg"/></div></div></a></div></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="8a81" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为什么我选择了<em class="me">避难所</em>？</p><p id="9242" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因为除了公开的函数和实用程序，它还依赖于一些代数数据类型，例如，<strong class="kh iu">可能是</strong>:</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/c93bb85a9a968c126853291fd217de02.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*VXwewryK8s_lVnaA8qC1QQ.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae mk" href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" rel="noopener ugc nofollow" target="_blank">http://adit . io/posts/2013-04-17-functors，_applicatives，_ and _ monads _ in _ pictures . html</a></figcaption></figure><p id="840f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">基本上，如上图所示，a Maybe可能是<strong class="kh iu">只是</strong>(我把它看作是一个“盒子”，通过例如<em class="me"> map </em>和<strong class="kh iu"> Nothing </strong>可以访问它的包装值)(是的，Nothing，没有空的、未定义的或类似的奇怪的东西)。因此，在处理“烫手山芋”时，保持一定程度的安全是可能的。</p><p id="1fcc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">与Maybe一起，<strong class="kh iu">或者</strong>也被支持，由<strong class="kh iu">左</strong>(通常处理错误)和<strong class="kh iu">右</strong>(通常处理成功值)组成。</p><p id="46a4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在我们已经，某种程度上，提出了基本的概念，避难所实际上给我们提供了什么？</p><p id="5973" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们从一个简单的例子开始:<strong class="kh iu"> parseInt </strong>(它接受2个参数——string和radix——并返回一个数字(如果有效)或NaN(如果无效)——哦对了，加上null和undefined:)。</p><p id="7b90" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Sanctuary提供了以下解决方案:</p><p id="5889" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe ml mm mn mo b">parseInt :: Radix -&gt; String -&gt; Maybe Integer</code></p><p id="6774" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果不熟悉这种语法，阅读起来可能有点棘手，但它实际上为每个函数(基数和字符串)接受一个参数，并返回一个<em class="me"> Maybe(整数)</em>，它由<em class="me"> Just(整数值)</em>或<em class="me"> Nothing </em>(不是n an、null、undefined或其他什么)组成。</p><pre class="mg mh mi mj gt mp mo mq mr aw ms bi"><span id="bc7b" class="mt mu it mo b gy mv mw l mx my">S.parseInt <em class="me">(</em>10<em class="me">) (</em>'-42'<em class="me">)<br/></em>// Just <em class="me">(</em>-42<em class="me">)<br/><br/></em>S.parseInt <em class="me">(</em>16<em class="me">) (</em>'0xFF'<em class="me">)<br/></em>// Just <em class="me">(</em>255<em class="me">)<br/><br/></em>S.parseInt <em class="me">(</em>16<em class="me">) (</em>'0xGG'<em class="me">)<br/></em>// Nothing</span></pre><p id="0c62" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这很好，因为我们可以在流中统一我们的数据，使之变得简单易懂。</p><p id="19ec" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">另一个例子可能是“<em class="me"> JSON.parse </em>”，其中Try/Catch位于角落后面:</p><p id="7aca" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe ml mm mn mo b">parseJson :: (Any -&gt; Boolean) -&gt; String -&gt; Maybe a</code></p><p id="76bc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这种情况看起来有点不同，但您可能会注意到一个额外的函数，它实际上是我们试图解析的内容的验证器，当truthy时，它返回包装在<em class="me">中的有效对象，只是</em>或<em class="me"> Nothing </em>。</p><pre class="mg mh mi mj gt mp mo mq mr aw ms bi"><span id="ec54" class="mt mu it mo b gy mv mw l mx my">S.parseJson <em class="me">(</em>S.is <em class="me">(</em>$.Array <em class="me">(</em>$.Integer<em class="me">))) (</em>'['<em class="me">)<br/></em>// Nothing<br/><br/>S.parseJson <em class="me">(</em>S.is <em class="me">(</em>$.Array <em class="me">(</em>$.Integer<em class="me">))) (</em>'["1", "2", "3"]'<em class="me">)<br/></em>// Nothing<br/><br/>S.parseJson <em class="me">(</em>S.is <em class="me">(</em>$.Array <em class="me">(</em>$.Integer<em class="me">))) (</em>'[0, 1.5, 3, 4.5]'<em class="me">)<br/></em>// Nothing<br/><br/>S.parseJson <em class="me">(</em>S.is <em class="me">(</em>$.Array <em class="me">(</em>$.Integer<em class="me">))) (</em>'[1, 2, 3]'<em class="me">)<br/></em>// Just <em class="me">([</em>1, 2, 3<em class="me">])</em></span><span id="7370" class="mt mu it mo b gy mz mw l mx my">S.parseJson <em class="me">(_ =&gt;  true) (</em>'["a", "b", "c"]'<em class="me">)<br/></em>// Just <em class="me">(["a"</em>, "b", "c"<em class="me">])</em></span></pre><p id="b278" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">注意:没有<strong class="kh iu">try/catch</strong>，因为该函数为我们处理错误，并且它不返回任何内容。太神奇了！</p><p id="f3fb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们转移到JS的另一个热门话题，<em class="me">点符号</em>。</p><pre class="mg mh mi mj gt mp mo mq mr aw ms bi"><span id="2238" class="mt mu it mo b gy mv mw l mx my">const foo = <em class="me">{<br/>    </em>bar: <em class="me">{<br/>        </em>inner: <em class="me">{<br/>            </em>thing: <em class="me">{<br/>                </em>exists: true<br/>            <em class="me">}<br/>        }<br/>    }<br/>}</em>;<br/>foo.bar.inner.thing.exists<br/>// true</span></pre><p id="0785" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">即使我们非常关注我们的数据，这也可能在任何时候中断，因为链中的一个属性可能没有被定义。为了访问深层结构，我们可以使用“<strong class="kh iu"> S.gets </strong>”，这有助于处理棘手的情况:</p><p id="3ffe" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe ml mm mn mo b">gets :: (Any -&gt; Boolean) -&gt; Array String -&gt; a -&gt; Maybe b</code></p><pre class="mg mh mi mj gt mp mo mq mr aw ms bi"><span id="89b8" class="mt mu it mo b gy mv mw l mx my">const foo = <em class="me">{<br/>    </em>bar: <em class="me">{<br/>        </em>thing: <em class="me">{<br/>            </em>exists: true<br/>        <em class="me">}<br/>    }<br/>}</em>;<br/><br/>S.gets <em class="me">(</em>S.is<em class="me">(</em>$.Boolean<em class="me">)) ([</em>'bar', 'thing', 'exists'<em class="me">]) (</em>foo<em class="me">)<br/></em>// Just<em class="me">(</em>true<em class="me">)<br/><br/></em>S.gets <em class="me">(</em>S.is<em class="me">(</em>$.Number<em class="me">)) ([</em>'bar', 'thing', 'exists'<em class="me">]) (</em>foo<em class="me">)<br/></em>// Nothing<br/><br/>S.gets <em class="me">(</em>S.is<em class="me">(</em>$.Number<em class="me">)) ([</em>'data', 'user', 'name'<em class="me">]) ({})<br/></em>// Nothing</span></pre><p id="fe51" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">得益于此，我们可以实现两件事:</p><ul class=""><li id="84ad" class="na nb it kh b ki kj km kn kq nc ku nd ky ne lc nf ng nh ni bi translated">以安全的方式访问嵌套属性；</li><li id="bdd9" class="na nb it kh b ki nj km nk kq nl ku nm ky nn lc nf ng nh ni bi translated">验证遍历的值；</li></ul><p id="e41a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">通常，如果路径中断或者值不符合我们的期望，<em class="me">不会返回任何内容</em>。</p><p id="acc6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">另一个例子可能是<strong class="kh iu"> <em class="me">头</em> </strong>和<strong class="kh iu"> <em class="me">尾</em> </strong>，来自功能编程字段:</p><pre class="mg mh mi mj gt mp mo mq mr aw ms bi"><span id="cd61" class="mt mu it mo b gy mv mw l mx my">S.head <em class="me">([</em>40, 20, 30, 50<em class="me">])<br/></em>// Just <em class="me">(</em>40<em class="me">)<br/><br/></em>S.head <em class="me">([])<br/></em>// Nothing</span><span id="3dae" class="mt mu it mo b gy mz mw l mx my">S.tail <em class="me">([</em>40, 20, 30, 50<em class="me">])<br/></em>// Just <em class="me">([</em>20, 30, 50<em class="me">])<br/><br/></em>S.tail <em class="me">([])<br/></em>// Nothing</span></pre><p id="b4ae" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">理解起来并不复杂，而且有很多实用程序可以安全地使用。</p><p id="82f4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我真正一直依赖的是“<strong class="kh iu"> <em class="me">管道</em></strong>”<em class="me">它执行一系列函数</em>的从左到右的组合。</p><pre class="mg mh mi mj gt mp mo mq mr aw ms bi"><span id="e206" class="mt mu it mo b gy mv mw l mx my">S.pipe <em class="me">([<br/>    </em>S.add <em class="me">(</em>1<em class="me">)</em>,<br/>    Math.sqrt,<br/>    S.sub <em class="me">(</em>1<em class="me">)<br/>]) (</em>99<em class="me">)</em></span><span id="f5b6" class="mt mu it mo b gy mz mw l mx my"><em class="me">// 9</em></span></pre><p id="01fe" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">以我的拙见，这是描述给定逻辑的一系列步骤的美丽方式，它让我想起了Clojure方式(使用<a class="ae mk" href="https://clojuredocs.org/clojure.core/-%3E%3E" rel="noopener ugc nofollow" target="_blank"> thread-last宏</a>)。</p><p id="6fbb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">例如，我们可能有这样一个简单的算法:</p><pre class="mg mh mi mj gt mp mo mq mr aw ms bi"><span id="14fc" class="mt mu it mo b gy mv mw l mx my">S.pipe<em class="me">([<br/>    </em>S.map<em class="me">(</em>S.pow<em class="me">(</em>2<em class="me">))</em>,  // Map each item to power of 2<br/>    S.filter<em class="me">(</em>S.even<em class="me">)</em>, // Filter even numbers<br/>    S.take<em class="me">(</em>10<em class="me">)</em>,       // Takes first 10 items  <br/>    S.map<em class="me">(</em>S.sum<em class="me">)      // Sum all values ('map' accesses Maybe)<br/>])<br/>(</em>S.range<em class="me">(</em>0<em class="me">)(</em>100<em class="me">)) // Creates an array with numbers from 0 to 100</em></span><span id="c493" class="mt mu it mo b gy mz mw l mx my">// Just (1140)</span></pre><p id="7e48" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">第一:这真的很容易读懂和预测。当进行代码审查时，这可能就像读一首诗，而不是一场悲剧。</p><p id="5e80" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">第二:是的，这是对边缘情况的反应。如果我们更改为“S.range(0)(10)”或一个空数组作为输入，它将不会返回任何内容，因为逻辑将无法从数组中获取10个项目(我们过滤掉偶数，从而减少了可用列表)。</p><p id="7cae" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">更复杂的例子呢？</p><p id="59a3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">真实的场景是遍历和聚合嵌套数据结构的一部分。我将用Github提供的Seach Commits API展示一个例子，并只选择与给定用户相关的提交消息。一个要求:逻辑需要坚如磐石。</p><p id="6d73" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是我们(假设)收到的一些数据——这只是取自Github API指南的一个例子，并混有模拟数据):</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f630" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们的逻辑可能如下:</p><ul class=""><li id="a20e" class="na nb it kh b ki kj km kn kq nc ku nd ky ne lc nf ng nh ni bi translated">接受集合和用户；</li><li id="f668" class="na nb it kh b ki nj km nk kq nl ku nm ky nn lc nf ng nh ni bi translated">访问包含结果的“项目”(是吗？！);</li><li id="c375" class="na nb it kh b ki nj km nk kq nl ku nm ky nn lc nf ng nh ni bi translated">过滤将“提交者”电子邮件与所需用户的电子邮件相匹配的结果项；</li><li id="d58a" class="na nb it kh b ki nj km nk kq nl ku nm ky nn lc nf ng nh ni bi translated">仅聚合提交消息并返回找到的列表；</li></ul><pre class="mg mh mi mj gt mp mo mq mr aw ms bi"><span id="b7ed" class="mt mu it mo b gy mv mw l mx my">const retrieveCommitMessagesByUser = <em class="me">(</em>commits, user<em class="me">) </em>=&gt; <em class="me">{<br/>    </em>return S.pipe<em class="me">([<br/>        <br/>    ])(</em>commits<em class="me">)</em>;<br/><em class="me">}</em>;<br/><br/>getCommitMessagesByUser<em class="me">(</em>commitsCollection, 'octocat@nowhere.com'<em class="me">)</em>;</span></pre><p id="ed10" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">很简单，我们可以使用一个接受提交列表和期望用户的电子邮件的函数，它真的很神奇。</p><p id="6cb7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因此，现在我们可以尝试以一种更好的方式访问商品列表:</p><pre class="mg mh mi mj gt mp mo mq mr aw ms bi"><span id="2ebe" class="mt mu it mo b gy mv mw l mx my">const getCommitsMessagesByUser = <em class="me">(</em>commits, user<em class="me">) </em>=&gt; <em class="me">{<br/>    </em>return S.pipe<em class="me">([<br/>        </em>S.get<em class="me">(</em>S.is<em class="me">(</em>$.Array<em class="me">(</em>$.Object<em class="me">)))(</em>'items'<em class="me">)</em>,<br/>    <em class="me">])(</em>commits<em class="me">)</em>;<br/><em class="me">}</em>;<br/><br/>getCommitsMessagesByUser<em class="me">(</em>commitsCollection, 'octocat@nowhere.com'<em class="me">)</em>;</span><span id="f445" class="mt mu it mo b gy mz mw l mx my">// Output: <br/>// Just ([...truncated items...])</span></pre><p id="fe97" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们可以使用“<em class="me"> S.get </em>”来访问对象中的项目，并进行验证，指定它需要是一个对象数组。如果成功，它将返回<em class="me">只是</em>，否则将返回<em class="me">什么都不是</em>。</p><p id="5293" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">接下来，我们需要过滤用户的提交:</p><pre class="mg mh mi mj gt mp mo mq mr aw ms bi"><span id="0511" class="mt mu it mo b gy mv mw l mx my">const committerIs = committer =&gt; <em class="me">{<br/>    </em>return _ =&gt; S.pipe<em class="me">([<br/>        </em>S.gets<em class="me">(</em>S.is<em class="me">(</em>$.String<em class="me">))([</em>'commit', 'committer', 'email'<em class="me">])</em>,<br/>        S.equals<em class="me">(</em>S.Just<em class="me">(</em>committer<em class="me">))<br/>    ])(</em>_<em class="me">)</em>;<br/><em class="me">}</em>;<br/><br/>const getCommitsMessagesByUser = <em class="me">(</em>commits, user<em class="me">) </em>=&gt; <em class="me">{<br/>    </em>return S.pipe<em class="me">([<br/>        </em>S.get<em class="me">(</em>S.is<em class="me">(</em>$.Array<em class="me">(</em>$.Object<em class="me">)))(</em>'items'<em class="me">)</em>,<br/>        S.map<em class="me">(</em>S.filter<em class="me">(</em>committerIs<em class="me">(</em>user<em class="me">)))</em>,<br/>    <em class="me">])(</em>commits<em class="me">)</em>;<br/><em class="me">}</em>;<br/><br/>getCommitsMessagesByUser<em class="me">(</em>commitsCollection, 'octocat@nowhere.com'<em class="me">)</em>;</span><span id="492b" class="mt mu it mo b gy mz mw l mx my">// Output: <br/>// Just ([...truncated user's items...])</span></pre><p id="59f1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">由于前面的指令返回一个包装的值，为了再次访问它，我们需要使用"<em class="me"> map </em>和"<em class="me"> filter </em>"集合。我创建了一个函数来执行深度检查。最后，这是函数式编程，我们在代码中组合/重用函数。</p><p id="fbeb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">返回的输出是与我们想要的用户相关的提交消息的包装值。</p><p id="a298" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在我们已经有了一组经过筛选的数据，我们可以只接收以下消息:</p><pre class="mg mh mi mj gt mp mo mq mr aw ms bi"><span id="b3f6" class="mt mu it mo b gy mv mw l mx my">const retrieveCommitMessagesByUser = <em class="me">(</em>commits, user<em class="me">) </em>=&gt; <em class="me">{<br/>    </em>return S.pipe<em class="me">([<br/>        </em>S.get<em class="me">(</em>S.is<em class="me">(</em>$.Array<em class="me">(</em>$.Object<em class="me">)))(</em>'items'<em class="me">)</em>,<br/>        S.map<em class="me">(</em>S.filter<em class="me">(</em>committerIs<em class="me">(</em>user<em class="me">)))</em>,<br/>        S.map<em class="me">(</em>S.map<em class="me">(</em>S.gets<em class="me">(</em>S.is<em class="me">(</em>$.String<em class="me">))([</em>'commit', 'message'<em class="me">])))<br/>    ])(</em>commits<em class="me">)</em>;<br/><em class="me">}</em>;<br/><br/>retrieveCommitMessagesByUser<em class="me">(</em>commitsCollection, 'octocat@nowhere.com'<em class="me">)</em>;</span><span id="7398" class="mt mu it mo b gy mz mw l mx my">// Output:<br/>// Just ([Just ("Create styles.css and updated README"), Just ("Updated eslint configuration"), Nothing])</span></pre><p id="92c2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">使用第一个"<em class="me">映射</em>，我们访问<em class="me">可能是</em>，使用第二个"<em class="me">映射</em>，我们迭代列表中的项目。"<em class="me"> S.gets </em>执行对"<em class="me"> commit.message </em>"的访问，并检查检索到的值是否是我们所期望的:<em class="me">一个字符串</em>。您可能会注意到“<em class="me"> Nothing </em>”和“Just”，因为集合中的一个项目有正确的提交者，但出于某种原因，<em class="me">消息被设置为“null”</em>(这只是模拟数据，但从外部API返回的数据可能会发生这种情况，因此处理它完全有意义)。</p><p id="5df2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">之后，让我们仅用有效值来清理输出:</p><pre class="mg mh mi mj gt mp mo mq mr aw ms bi"><span id="168a" class="mt mu it mo b gy mv mw l mx my">const retrieveCommitMessagesByUser = <em class="me">(</em>commits, user<em class="me">) </em>=&gt; <em class="me">{<br/>    </em>return S.pipe<em class="me">([<br/>        </em>S.get<em class="me">(</em>S.is<em class="me">(</em>$.Array<em class="me">(</em>$.Object<em class="me">)))(</em>'items'<em class="me">)</em>,<br/>        S.map<em class="me">(</em>S.filter<em class="me">(</em>committerIs<em class="me">(</em>user<em class="me">)))</em>,<br/>        S.map<em class="me">(</em>S.map<em class="me">(</em>S.gets<em class="me">(</em>S.is<em class="me">(</em>$.String<em class="me">))([</em>'commit', 'message'<em class="me">])))</em>,<br/>        S.map<em class="me">(</em>S.justs<em class="me">)<br/>    ])(</em>commits<em class="me">)</em>;<br/><em class="me">}</em>;</span><span id="92f3" class="mt mu it mo b gy mz mw l mx my">retrieveCommitMessagesByUser<em class="me">(</em>commitsCollection, 'octocat@nowhere.com'<em class="me">)</em>;</span><span id="3bdb" class="mt mu it mo b gy mz mw l mx my">// Output:<br/>// Just (["Create styles.css and updated README", "Updated eslint configuration"])</span></pre><p id="9db9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">酷，到目前为止一切顺利！！</p><p id="95ea" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后一步可能是解开来自<em class="me">或者</em>的值:</p><pre class="mg mh mi mj gt mp mo mq mr aw ms bi"><span id="f1f9" class="mt mu it mo b gy mv mw l mx my">const retrieveCommitMessagesByUser = <em class="me">(</em>commits, user<em class="me">) </em>=&gt; <em class="me">{<br/>    </em>return S.pipe<em class="me">([<br/>        </em>S.get<em class="me">(</em>S.is<em class="me">(</em>$.Array<em class="me">(</em>$.Object<em class="me">)))(</em>'items'<em class="me">)</em>,<br/>        S.map<em class="me">(</em>S.filter<em class="me">(</em>committerIs<em class="me">(</em>user<em class="me">)))</em>,<br/>        S.map<em class="me">(</em>S.map<em class="me">(</em>S.gets<em class="me">(</em>S.is<em class="me">(</em>$.String<em class="me">))([</em>'commit', 'message'<em class="me">])))</em>,<br/>        S.map<em class="me">(</em>S.justs<em class="me">)</em>,<br/>        S.fromMaybe<em class="me">([])<br/>    ])(</em>commits<em class="me">)</em>;<br/><em class="me">}</em>;<br/><br/>retrieveCommitMessagesByUser<em class="me">(</em>commitsCollection, 'octocat@nowhere.com'<em class="me">)</em>;</span><span id="6006" class="mt mu it mo b gy mz mw l mx my">// Output:<br/>// [ 'Create styles.css and updated README',<br/>     'Updated eslint configuration' ]</span></pre><p id="0c76" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">"<strong class="kh iu"> S.fromMaybe </strong>仅从<em class="me">获取</em>的值，或者当<em class="me"> Nothing </em>时，它返回传入的默认值(本例中为空数组)。</p><p id="60b4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">就是这样！</p><p id="e56b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一开始看起来可能有点奇怪，但是当熟悉这种方法和函数式编程时，这就有意义了。很少几行代码处理我们的逻辑，并对边缘情况和不愉快的路径(一些空的/未定义的，不是我们期望的类型，等等)具有弹性。</p><p id="e718" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">有大量的用例，结合其他技术和方法，它将整个事情带到了一个不同的层面。</p><p id="e191" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我创建了一个REPL游乐场，你可以在那里玩耍:</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="nq np l"/></div></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="60b9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">更多资源:</p><p id="b666" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><a class="ae mk" href="https://www.youtube.com/watch?v=a2astdDbOjk" rel="noopener ugc nofollow" target="_blank">视频:ReactiveConf 2018 —大卫·钱伯斯:在不确定的世界中安全编程</a></p><p id="050f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><a class="ae mk" href="https://www.slideshare.net/TychoGrouwstra/fp-in-js" rel="noopener ugc nofollow" target="_blank">幻灯片:JS中的FP</a></p><p id="b097" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><a class="ae mk" href="https://sanctuary.js.org/" rel="noopener ugc nofollow" target="_blank">文献:避难所</a></p><p id="d682" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我希望你喜欢它！</p><p id="0a69" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">干杯:)</p></div></div>    
</body>
</html>