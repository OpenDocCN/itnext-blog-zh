<html>
<head>
<title>NodeJS logging made easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NodeJS日志记录变得简单</h1>
<blockquote>原文：<a href="https://itnext.io/nodejs-logging-made-easy-366425abfa21?source=collection_archive---------3-----------------------#2019-04-09">https://itnext.io/nodejs-logging-made-easy-366425abfa21?source=collection_archive---------3-----------------------#2019-04-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/a8a530c7cb18220a26c97b98cb91272c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*70NPN5WzHLjsY--WQ1QAJg.jpeg"/></div></figure><p id="f9fb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">&gt;我现在有了一个闪亮的新博客。阅读这篇文章，了解https://blog.goncharov.page/nodejs-logging-made-easy<a class="ae ks" href="https://blog.goncharov.page/nodejs-logging-made-easy" rel="noopener ugc nofollow" target="_blank">的最新动态</a></p><p id="9bca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于您想要记录的每一个服务方法，您写了多少次<code class="fe kt ku kv kw b">logger.info('ServiceName.methodName.')</code>和<code class="fe kt ku kv kw b">logger.info('ServiceName.methodName -&gt; done.')</code>？你希望它是自动化的，并在你的整个应用程序中保持相同的签名吗？如果是这样的话，我们非常相似，我们遭受同样的痛苦太多次了，现在我们终于可以尝试解决它。一起。女士们先生们，让我来介绍...<a class="ae ks" href="https://github.com/keenondrums/class-logger" rel="noopener ugc nofollow" target="_blank">类记录器</a>！</p><h1 id="9180" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><a class="ae ks" href="https://github.com/keenondrums/class-logger" rel="noopener ugc nofollow" target="_blank">类记录器</a>的“为什么”</h1><p id="8f57" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">工程师往往是完美主义者。完美主义者到了极点。我们喜欢简洁的抽象。我们喜欢干净的代码。我们在别人甚至看不懂的人工语言中看到了美。我们喜欢制造小型数字世界，按照我们设定的规则生活。我们喜欢所有这些，可能是因为我们非常懒。不，我们不怕工作，但是我们讨厌做任何可以自动化的工作。</p><p id="89c2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">只编写了几千行日志代码，我们通常会提出某些模式，标准化我们想要记录的内容。然而，我们仍然必须手动应用这些模式。因此<a class="ae ks" href="https://github.com/keenondrums/class-logger" rel="noopener ugc nofollow" target="_blank">类记录器</a>的核心思想是提供一种声明性的、高度可配置的标准化方法来记录类方法执行前后的消息。</p><h1 id="971c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">快速启动</h1><p id="530b" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">让我们立即投入运行，看看实际的代码是什么样的。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="4d17" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该服务将记录三次:</p><ul class=""><li id="1389" class="mg mh iq jw b jx jy kb kc kf mi kj mj kn mk kr ml mm mn mo bi translated">创建时将一个参数列表传递给构造函数。</li><li id="1ea3" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated">在<code class="fe kt ku kv kw b">eat</code>被执行之前，它的一个参数列表。</li><li id="e0fe" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated">在<code class="fe kt ku kv kw b">eat</code>被执行后，它带有一个参数和结果的列表。</li></ul><p id="951b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">用代码的话来说:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="781a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://stackblitz.com/edit/class-logger-demo-cats-quick-start" rel="noopener ugc nofollow" target="_blank">现场演示</a>。</p><p id="4b77" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们还能记录什么？以下是事件的完整列表:</p><ul class=""><li id="40ff" class="mg mh iq jw b jx jy kb kc kf mi kj mj kn mk kr ml mm mn mo bi translated">班级建设前。</li><li id="53bc" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated">同步和异步之前的静态和非静态方法和功能属性。</li><li id="60a1" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated">经过同步和异步静态和非静态方法和功能属性。</li><li id="1e3a" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated">同步和异步静态和非静态方法和函数属性的错误。</li></ul><blockquote class="mu mv mw"><p id="ed56" class="ju jv mx jw b jx jy jz ka kb kc kd ke my kg kh ki mz kk kl km na ko kp kq kr ij bi translated"><em class="iq">功能属性是分配给</em> <code class="fe kt ku kv kw b"><em class="iq">class ServiceCats { private meow = () =&gt; null }</em></code> <em class="iq">属性的箭头功能。</em></p></blockquote><h1 id="34f2" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">根据我们的需要调整它</h1><p id="1ad1" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">到目前为止还不错，但我们已经承诺“可定制”，对不对？那么我们该如何调整它呢？</p><p id="0860" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://github.com/keenondrums/class-logger" rel="noopener ugc nofollow" target="_blank">类记录器</a>提供三层分层配置:</p><ul class=""><li id="3d04" class="mg mh iq jw b jx jy kb kc kf mi kj mj kn mk kr ml mm mn mo bi translated">全球的</li><li id="c2b5" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated">班级</li><li id="c7f2" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated">方法</li></ul><p id="1ab7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在每一次方法调用时，它们都被评估并从上到下合并在一起。有一些默认的全局配置，所以你可以不用任何配置就可以使用这个库。</p><h2 id="cfbf" class="nb ky iq bd kz nc nd dn ld ne nf dp lh kf ng nh ll kj ni nj lp kn nk nl lt nm bi translated">全局配置</h2><p id="157a" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">这是应用程序范围的配置。可以用<code class="fe kt ku kv kw b">setConfig</code>呼叫设置。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><h2 id="7103" class="nb ky iq bd kz nc nd dn ld ne nf dp lh kf ng nh ll kj ni nj lp kn nk nl lt nm bi translated">类别配置</h2><p id="2792" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">它对你的类的每个方法都有影响。它可以覆盖全局配置。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><h2 id="3d71" class="nb ky iq bd kz nc nd dn ld ne nf dp lh kf ng nh ll kj ni nj lp kn nk nl lt nm bi translated">方法配置</h2><p id="9bc1" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">它只影响方法本身。重写类配置，因此也重写全局配置。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="1e7a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://stackblitz.com/edit/class-logger-demo-hierarchical-config" rel="noopener ugc nofollow" target="_blank">现场演示</a></p><h1 id="8f7d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">配置选项</h1><p id="5fff" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">好吧，我们已经学会了如何改变默认设置，但它不会伤害到覆盖有什么配置，是吧？</p><blockquote class="mu mv mw"><p id="d454" class="ju jv mx jw b jx jy jz ka kb kc kd ke my kg kh ki mz kk kl km na ko kp kq kr ij bi translated"><a class="ae ks" href="https://github.com/keenondrums/class-logger#examples" rel="noopener ugc nofollow" target="_blank"> <em class="iq">在这里你可以找到很多有用的配置覆盖</em> </a> <em class="iq">。</em> <a class="ae ks" href="https://github.com/keenondrums/class-logger#configuration-object" rel="noopener ugc nofollow" target="_blank"> <em class="iq">这里是config对象接口的链接，以防你打字稿说得比英语好:)</em> </a></p></blockquote><p id="27cf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">配置对象具有以下属性:</p><h2 id="9922" class="nb ky iq bd kz nc nd dn ld ne nf dp lh kf ng nh ll kj ni nj lp kn nk nl lt nm bi translated">原木</h2><p id="d60b" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">这是一个实际记录最终格式化消息的函数。它用于记录这些事件:</p><ul class=""><li id="9988" class="mg mh iq jw b jx jy kb kc kf mi kj mj kn mk kr ml mm mn mo bi translated">班级建设前。</li><li id="0ea8" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated">同步和异步之前的静态和非静态方法和功能属性。</li><li id="4160" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated">经过同步和异步静态和非静态方法和功能属性。</li></ul><p id="a95f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">默认:<code class="fe kt ku kv kw b">console.log</code></p><h2 id="87d8" class="nb ky iq bd kz nc nd dn ld ne nf dp lh kf ng nh ll kj ni nj lp kn nk nl lt nm bi translated">对数误差</h2><p id="7bfe" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">这是一个实际记录最终格式化错误消息的函数。它用来记录这唯一的事件:</p><ul class=""><li id="d9d1" class="mg mh iq jw b jx jy kb kc kf mi kj mj kn mk kr ml mm mn mo bi translated">同步和异步静态和非静态方法和函数属性的错误。</li></ul><p id="107b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">默认:<code class="fe kt ku kv kw b">console.error</code></p><h2 id="74fb" class="nb ky iq bd kz nc nd dn ld ne nf dp lh kf ng nh ll kj ni nj lp kn nk nl lt nm bi translated">格式程序</h2><p id="09a6" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">它是一个有两种方法的对象:<code class="fe kt ku kv kw b">start</code>和<code class="fe kt ku kv kw b">end</code>。它将日志数据格式化为最终的字符串。</p><p id="3257" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe kt ku kv kw b">start</code>格式化这些事件的消息:</p><ul class=""><li id="27e7" class="mg mh iq jw b jx jy kb kc kf mi kj mj kn mk kr ml mm mn mo bi translated">班级建设前。</li><li id="7c94" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated">同步和异步之前的静态和非静态方法和功能属性。</li></ul><p id="96f8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe kt ku kv kw b">end</code>格式化这些事件的消息:</p><ul class=""><li id="dfde" class="mg mh iq jw b jx jy kb kc kf mi kj mj kn mk kr ml mm mn mo bi translated">经过同步和异步静态和非静态方法和功能属性。</li><li id="1c7f" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated">同步和异步静态和非静态方法和函数属性的错误。</li></ul><p id="5ce4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">默认:<code class="fe kt ku kv kw b">new ClassLoggerFormatterService()</code></p><h2 id="0add" class="nb ky iq bd kz nc nd dn ld ne nf dp lh kf ng nh ll kj ni nj lp kn nk nl lt nm bi translated">包括</h2><p id="5966" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">消息中应包含的内容的配置。</p><h2 id="b1e8" class="nb ky iq bd kz nc nd dn ld ne nf dp lh kf ng nh ll kj ni nj lp kn nk nl lt nm bi translated">包含. args</h2><p id="9291" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">它可以是布尔值，也可以是对象。</p><p id="9314" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果是布尔值，它设置是否包含参数列表(还记得那个<code class="fe kt ku kv kw b">Args: [milk]</code>？)分为两部分，开始(构造前和方法调用前)和结束(方法调用后，错误方法调用)，消息。</p><p id="496d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果是一个对象，它应该有两个布尔属性:<code class="fe kt ku kv kw b">start</code>和<code class="fe kt ku kv kw b">end</code>。<code class="fe kt ku kv kw b">start</code>包括/排除开始消息的参数列表，<code class="fe kt ku kv kw b">end</code>对结束消息也是如此。</p><p id="c673" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">默认:<code class="fe kt ku kv kw b">true</code></p><h2 id="90f3" class="nb ky iq bd kz nc nd dn ld ne nf dp lh kf ng nh ll kj ni nj lp kn nk nl lt nm bi translated">包含.构造</h2><p id="471c" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">设置是否记录类构造的布尔标志。</p><p id="6204" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">默认:<code class="fe kt ku kv kw b">true</code></p><h2 id="ecd3" class="nb ky iq bd kz nc nd dn ld ne nf dp lh kf ng nh ll kj ni nj lp kn nk nl lt nm bi translated">包含.结果</h2><p id="3303" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">另一个布尔标志设置是否包括方法调用的返回值或由它抛出的错误。还记得<code class="fe kt ku kv kw b">Res: purr</code>吗？如果您将此标志设置为<code class="fe kt ku kv kw b">false</code>，将不会有<code class="fe kt ku kv kw b">Res: purr</code>。</p><p id="2fd9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">默认:<code class="fe kt ku kv kw b">true</code></p><h2 id="4fe8" class="nb ky iq bd kz nc nd dn ld ne nf dp lh kf ng nh ll kj ni nj lp kn nk nl lt nm bi translated">include.classInstance</h2><p id="ecee" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">再次强调，要么是布尔值，要么是对象。如果您启用它，您的类实例的字符串化表示将被添加到日志中。换句话说，如果您的类实例有一些属性，它们将被转换成JSON字符串并添加到日志消息中。</p><p id="0703" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">并非所有属性都将被添加。<a class="ae ks" href="https://github.com/keenondrums/class-logger" rel="noopener ugc nofollow" target="_blank">类记录器</a>遵循以下逻辑:</p><ul class=""><li id="084b" class="mg mh iq jw b jx jy kb kc kf mi kj mj kn mk kr ml mm mn mo bi translated">获取实例的自身(非原型)属性。<br/> <em class="mx">为什么？当你的原型动态变化时，这种情况很少见，因此记录它几乎没有任何意义。</em></li><li id="dcd4" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated">删除任何具有<code class="fe kt ku kv kw b">function</code>类型的文件。<br/> <em class="mx">为什么？大多数时候</em> <code class="fe kt ku kv kw b"><em class="mx">function</em></code> <em class="mx">属性只是不可变的箭头函数用来代替常规的类方法来保存</em> <code class="fe kt ku kv kw b"><em class="mx">this</em></code> <em class="mx">上下文。用这些函数的字符串体来膨胀日志没有多大意义。</em></li><li id="eaa0" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated">丢弃任何不是普通对象的对象。<br/> <em class="mx">什么物体是素色的？</em> <code class="fe kt ku kv kw b"><em class="mx">ClassLoggerFormatterService</em></code> <em class="mx">如果一个对象的原型严格等于</em> <code class="fe kt ku kv kw b"><em class="mx">Object.prototype</em></code> <em class="mx">，则认为该对象是普通对象。<br/>为什么？通常我们包含其他类的实例作为属性(注入它们作为依赖)。如果我们包含这些依赖项的字符串版本，我们的日志会变得非常庞大。</em></li><li id="c632" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated">剩下的纤维。</li></ul><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="94bd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">默认:<code class="fe kt ku kv kw b">false</code></p><h1 id="ada1" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">控制格式</h1><p id="0341" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">那么，如果你喜欢整体的想法，但希望你的信息看起来不同呢？您可以通过自己的自定义格式化程序来完全控制格式化。</p><p id="5e91" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可以从头开始编写自己的格式化程序。完全同意。然而我们不打算在这里讨论这个选项(如果你真的对此感兴趣，请阅读自述文件的<a class="ae ks" href="https://github.com/keenondrums/class-logger#formatting" rel="noopener ugc nofollow" target="_blank">“格式化”部分</a>)。</p><p id="4462" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最快也可能是最简单的方法是创建一个内置默认格式化程序的子类— <code class="fe kt ku kv kw b">ClassLoggerFormatterService</code>。</p><p id="bbf2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe kt ku kv kw b">ClassLoggerFormatterService</code>有这些受保护的方法，充当最终消息的构建块:</p><ul class=""><li id="2319" class="mg mh iq jw b jx jy kb kc kf mi kj mj kn mk kr ml mm mn mo bi translated"><code class="fe kt ku kv kw b">base<br/></code>返回带有方法名的类名。例子:<code class="fe kt ku kv kw b">ServiceCats.eat</code>。</li><li id="d511" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated"><code class="fe kt ku kv kw b">operation<br/></code>根据方法的成功执行或错误执行返回<code class="fe kt ku kv kw b">-&gt; done</code>或<code class="fe kt ku kv kw b">-&gt; error</code>。</li><li id="f564" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated"><code class="fe kt ku kv kw b">args<br/></code>返回参数的字符串列表。例:<code class="fe kt ku kv kw b">. Args: [milk]</code>。它使用<a class="ae ks" href="https://github.com/davidmarkclements/fast-safe-stringify" rel="noopener ugc nofollow" target="_blank">快速安全纤维</a>用于引擎盖下的物体。</li><li id="0bde" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated"><code class="fe kt ku kv kw b">classInstance<br/></code>返回一个字符串化的类实例。例:<code class="fe kt ku kv kw b">. Class instance: {"prop1":42,"prop2":{"test":42}}</code>。如果你选择包含类实例，但是它不可用(静态方法和类构造就是这样)，它返回<code class="fe kt ku kv kw b">N/A</code>。</li><li id="8d83" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated"><code class="fe kt ku kv kw b">result<br/></code>返回执行的字符串化结果(即使它是一个错误)。使用<a class="ae ks" href="https://github.com/davidmarkclements/fast-safe-stringify" rel="noopener ugc nofollow" target="_blank">快速安全字符串</a>来序列化对象。一个字符串化的错误将由以下属性组成:<br/> -创建错误的类(函数)的名称(<code class="fe kt ku kv kw b">error.constructor.name</code>)。<br/> -错误代码(<code class="fe kt ku kv kw b">error.code</code>)。<br/> -错误信息(<code class="fe kt ku kv kw b">error.message</code>)。<br/>——错误名称(<code class="fe kt ku kv kw b">error.name</code>)。<br/> -堆栈跟踪(<code class="fe kt ku kv kw b">error.stack</code>)。</li><li id="1b5a" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated"><code class="fe kt ku kv kw b">final<br/></code>返回<code class="fe kt ku kv kw b">.</code>只是<code class="fe kt ku kv kw b">.</code></li></ul><p id="8fae" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe kt ku kv kw b">start</code>信息包括:</p><ul class=""><li id="327c" class="mg mh iq jw b jx jy kb kc kf mi kj mj kn mk kr ml mm mn mo bi translated"><code class="fe kt ku kv kw b">base</code></li><li id="c7ef" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated"><code class="fe kt ku kv kw b">args</code></li><li id="fbdc" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated"><code class="fe kt ku kv kw b">classInstance</code></li><li id="68c4" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated"><code class="fe kt ku kv kw b">final</code></li></ul><p id="884c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe kt ku kv kw b">end</code>信息包括:</p><ul class=""><li id="ab92" class="mg mh iq jw b jx jy kb kc kf mi kj mj kn mk kr ml mm mn mo bi translated"><code class="fe kt ku kv kw b">base</code></li><li id="86fd" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated"><code class="fe kt ku kv kw b">operation</code></li><li id="f103" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated"><code class="fe kt ku kv kw b">args</code></li><li id="0588" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated"><code class="fe kt ku kv kw b">classInstance</code></li><li id="5411" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated"><code class="fe kt ku kv kw b">result</code></li><li id="28b8" class="mg mh iq jw b jx mp kb mq kf mr kj ms kn mt kr ml mm mn mo bi translated"><code class="fe kt ku kv kw b">final</code></li></ul><p id="733a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可以覆盖这些构造块方法中的任何一个。让我们看看如何添加时间戳。我不是说我们应该。pino 、<a class="ae ks" href="https://github.com/winstonjs/winston" rel="noopener ugc nofollow" target="_blank"> winston </a>和许多其他的记录器能够自己添加时间戳。所以这个例子纯粹是教育性的。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="ebad" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://stackblitz.com/edit/class-logger-demo-custom-formatter-add-timestamp" rel="noopener ugc nofollow" target="_blank">现场演示</a></p><h1 id="42fe" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="1310" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">请不要忘记遵循<a class="ae ks" href="https://github.com/keenondrums/class-logger#installation" rel="noopener ugc nofollow" target="_blank">安装步骤</a>，并在决定使用该库之前熟悉<a class="ae ks" href="https://github.com/keenondrums/class-logger#requirements" rel="noopener ugc nofollow" target="_blank">要求</a>。</p><p id="9a20" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">希望你已经找到了对你的项目有用的东西。请随时将您的反馈传达给我！我非常感谢任何批评和问题。</p></div></div>    
</body>
</html>