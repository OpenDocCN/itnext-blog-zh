<html>
<head>
<title>Micro In Action, Part4：Pub/Sub</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微在行动，第四部分:发布/订阅</h1>
<blockquote>原文：<a href="https://itnext.io/micro-in-action-part4-pub-sub-564f3b054ecd?source=collection_archive---------1-----------------------#2020-02-14">https://itnext.io/micro-in-action-part4-pub-sub-564f3b054ecd?source=collection_archive---------1-----------------------#2020-02-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/bcc7a528a4723494f9bb0899186d7298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KqbuAv35ueD3MRLENC3x6w.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">微在行动</figcaption></figure><p id="dd18" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是“微在行动”系列文章的第4篇，讨论<a class="ae ld" href="https://micro.mu/" rel="noopener ugc nofollow" target="_blank">微</a>。我们将一步一步地构建微服务，并在此过程中解释Micro的特性。我们将从基本概念和主题开始，然后转向高级功能。</p><p id="a6f0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">今天我们来谈谈异步消息处理。</p><p id="fbd1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">异步消息处理是构建可伸缩、高容错系统的关键技术。虽然功能强大，但开发起来也相当繁琐，要考虑很多技术细节。它远没有同步系统简单明了。</p><p id="ab57" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">幸运的是，Micro对这种编程模型进行了非常优雅的抽象和封装。所以我们可以方便地使用它。</p><p id="47bf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">此外，通过Micro的接口抽象，我们可以透明地(或几乎透明地)支持各种消息代理。</p><p id="a62e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">默认情况下，Micro提供了一个嵌入式Nats消息代理。同时还通过<a class="ae ld" href="https://github.com/micro/go-plugins/tree/master/broker" rel="noopener ugc nofollow" target="_blank">插件</a>为主流消息经纪人提供广泛支持，包括Kafka、RabbitMQ、MQTT、NSQ、亚马逊SQS等。这使得我们在切换消息代理时几乎不需要修改任何业务代码。</p><p id="26a1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Micro以两种不同的方式支持异步消息传递。</p><p id="8186" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一个是<a class="ae ld" href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" rel="noopener ugc nofollow" target="_blank">发布/订阅</a>，另一个是通过<code class="fe le lf lg lh b">micro.Broker</code>接口处理消息。前者相对简单，而后者提供了更多的灵活性。</p><p id="e5b5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Micro内置的发布/订阅功能统一并简化了消息的发送、接收、编码和解码。这将开发人员从底层技术细节中解放出来，让他们专注于创造商业价值。大多数情况下，我们应该选择这种方式。</p><p id="3d5f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">下面我们将举例分析一个发布/订阅系统的开发。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="62e7" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">订阅消息</h1><p id="69a0" class="pw-post-body-paragraph kf kg it kh b ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky mr la lb lc im bi translated">在本系列的第一篇文章中，我们创建了一个样例项目，它已经包含了与消息订阅相关的代码。</p><p id="9fd6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">首先，我们定义消息处理处理器。<strong class="kh iu">的代码。/subscriber/hello.go </strong>如下:</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="dbfe" class="na lq it lh b gy nb nc l nd ne">package subscriber<br/><br/>import (<br/>   "context"<br/>   log "github.com/micro/go-micro/v2/logger"<br/><br/>   hello "hello/proto/hello"<br/>)<br/><br/>type Hello struct{}<br/><br/>func (e *Hello) <strong class="lh iu">Handle</strong>(ctx context.Context, msg *hello.Message) error {<br/>   log.Info("Handler Received message: ", msg.Say)<br/>   return nil<br/>}</span></pre><p id="ffdd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">结构的函数或方法都可以用于消息处理。只要它的签名是<code class="fe le lf lg lh b">func(context.Context, v interface{}) error</code></p><p id="bd8c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">注意，我们的处理函数的第二个参数是<code class="fe le lf lg lh b">*hello.Message</code>，它是在。原型文件。Micro自动解码消息，所以我们可以在消息处理程序中直接使用它。</p><p id="94aa" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">准备好消息处理程序后，您需要注册它。<strong class="kh iu">的相关代码。/main.go </strong>如下:</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="349e" class="na lq it lh b gy nb nc l nd ne">...<br/>// Register Struct as Subscriber<br/>micro.<strong class="lh iu">RegisterSubscriber</strong>("com.foo.service.hello", service.Server(), new(subscriber.Hello))<br/>...</span></pre><p id="1127" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">上面的代码注册了两个消息处理处理程序，这些处理程序将接收来自名为“<strong class="kh iu"> com.foo.service.hello </strong>”的主题的消息。</p><p id="01e0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您想对订阅行为进行更多的控制，您需要向<code class="fe le lf lg lh b">micro.RegisterSubscriber</code>传递额外的参数。让我们先来看看这个方法的签名:</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="a6d5" class="na lq it lh b gy nb nc l nd ne">func <strong class="lh iu">RegisterSubscriber</strong>(topic string, s server.Server, h interface{}, opts ...<strong class="lh iu">server.SubscriberOption</strong>) error</span></pre><p id="e48a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">第一个参数表示主题。第二个参数是<code class="fe le lf lg lh b">server.Server</code>，可以从<code class="fe le lf lg lh b">service.Server()</code>中获得。第三个参数是消息处理程序。</p><p id="2735" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后一个是控制订阅行为的可选参数。它的类型是<code class="fe le lf lg lh b">server.SubscriberOption</code>。目前，Micro提供4种内置选项:</p><ol class=""><li id="c55c" class="nf ng it kh b ki kj km kn kq nh ku ni ky nj lc nk nl nm nn bi translated"><strong class="kh iu">服务器。DisableAutoAck() </strong>，<strong class="kh iu"> </strong>处理完消息后，禁用消息的自动确认。</li><li id="8e1c" class="nf ng it kh b ki no km np kq nq ku nr ky ns lc nk nl nm nn bi translated"><strong class="kh iu">服务器。SubscriberContext(ctx上下文。Context) </strong>，设置上下文选项以允许broker SubscriberOption通过.</li><li id="75d5" class="nf ng it kh b ki no km np kq nq ku nr ky ns lc nk nl nm nn bi translated"><strong class="kh iu">服务器。InternalSubscriber(b bool)，</strong>指定不向发现系统通告订户</li><li id="7966" class="nf ng it kh b ki no km np kq nq ku nr ky ns lc nk nl nm nn bi translated"><strong class="kh iu">服务器。SubscriberQueue(n string) </strong>，跨订户分发消息得共享队列名.</li></ol><p id="c5e9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">注意:我个人认为框架暴露的选项太少。如果你有更高的要求，比如你想控制消息的持久性或重传策略，你必须求助于<code class="fe le lf lg lh b">micro.Broker</code>接口。希望这可以在未来的版本中得到增强</p><p id="360a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">以上选项中，<code class="fe le lf lg lh b">server.SubscriberQueue</code>是值得单独说明的一个。</p><p id="8c76" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们知道在发布/订阅模型中有队列(或某些平台中的通道)的概念。如果一个主题的多个订阅者有自己的队列，那么消息将被复制并分发到不同的队列，这样每个订阅者都可以接收所有的消息。</p><p id="95e6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">默认情况下，Micro为每个订户实例创建一个全局唯一的队列。如果您想与多个订户实例共享一个队列，那么您需要通过<code class="fe le lf lg lh b">server.SubscriberQueue</code>显式地指定队列名称:</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="5143" class="na lq it lh b gy nb nc l nd ne">micro.RegisterSubscriber("com.foo.srv.hello", service.Server(), subscriber.Handler, <strong class="lh iu">server.SubscriberQueue("foo_bar")</strong>)</span></pre><p id="ff16" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这样，订户实例将共享同一个队列。所以消息会被分发到某个节点进行处理，避免了同一条消息被重复处理。</p><p id="1e3e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">考虑到在分布式系统中，多个服务实例在不同的节点上运行是一个常见的场景，我的建议是:除非您知道自己在做什么，否则<strong class="kh iu">总是显式地指定队列名称——即使当前只有一个订阅实例</strong>。最常见的做法是用主题命名队列。</p><p id="6852" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">至此，发布/订阅模型的<strong class="kh iu"> Sub </strong>部分准备就绪。让我们开始工作在<strong class="kh iu">酒吧</strong>部分。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="0bcb" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">发布消息</h1><p id="730f" class="pw-post-body-paragraph kf kg it kh b ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky mr la lb lc im bi translated">让我们创建一个名为<strong class="kh iu"> pub </strong>的发布消息的项目，其结构如下:</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="34cf" class="na lq it lh b gy nb nc l nd ne">.<br/>├── main.go<br/>├── plugin.go<br/>├── proto/hello<br/>│   └── hello.proto<br/>│   └── hello.pb.go<br/>│   └── hello.pb.micro.go<br/>└── go.mod</span></pre><p id="d2e5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">除了<strong class="kh iu"> main.go </strong>之外，其他文件的内容与<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part-2-71230f01d6fb">上一篇文章</a>中描述的相同，此处不再赘述。</p><p id="d45f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">以下是<strong class="kh iu"> main.go </strong>中的代码:</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">main.go</figcaption></figure><ul class=""><li id="1576" class="nf ng it kh b ki kj km kn kq nh ku ni ky nj lc nv nl nm nn bi translated">首先创建并初始化<code class="fe le lf lg lh b">micro.Service</code>的一个实例，命名为“<strong class="kh iu">com . foo . SRV . hello . pub”</strong>。该名称没有特殊含义，在实际项目中可能会有所不同。</li><li id="1a63" class="nf ng it kh b ki no km np kq nq ku nr ky ns lc nv nl nm nn bi translated">然后指定向其发送消息的主题，并创建一个<code class="fe le lf lg lh b">micro.Publisher </code>实例。</li><li id="e674" class="nf ng it kh b ki no km np kq nq ku nr ky ns lc nv nl nm nn bi translated">然后每秒发送一条消息，类型为<code class="fe le lf lg lh b">*hello.Message</code>，框架会自动对消息进行编码。</li></ul><p id="bd20" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">与订阅功能类似，发布接口也支持选项，这些选项可用于控制发布的行为。<code class="fe le lf lg lh b">micro.Publisher</code>界面的定义如下:</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="a701" class="na lq it lh b gy nb nc l nd ne">// Publisher is syntactic sugar for publishing<br/>type Publisher interface {<br/>   Publish(ctx context.Context, msg interface{}, opts ...<strong class="lh iu">client.PublishOption</strong>) error<br/>}</span></pre><p id="6deb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">目前，Micro仅提供一个内置发布选项:</p><ul class=""><li id="8929" class="nf ng it kh b ki kj km kn kq nh ku ni ky nj lc nv nl nm nn bi translated"><strong class="kh iu">当事人。with exchange(e string)publish option</strong>，设置要路由消息的交换机。</li></ul></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="d33e" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">跑起来</h1><p id="8fc8" class="pw-post-body-paragraph kf kg it kh b ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky mr la lb lc im bi translated">准备好<strong class="kh iu"> pub </strong>项目后，运行<strong class="kh iu"> hello server </strong>和<strong class="kh iu"> pub </strong>项目。</p><p id="17c0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后我们会在<strong class="kh iu"> hello server、</strong>的控制台中看到接收消息的日志，每秒一<strong class="kh iu"> </strong>行:</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="e4f6" class="na lq it lh b gy nb nc l nd ne">$ go run main.go plugin.go <br/>2020-04-03 10:10:22  level=info Starting [service] com.foo.service.hello<br/>2020-04-03 10:10:22  level=info Server [grpc] Listening on [::]:52863<br/>2020-04-03 10:10:22  level=info Broker [eats] Connected to [::]:52865<br/>2020-04-03 10:10:22  level=info Registry [mdns] Registering node: com.foo.service.hello-04df9f5a-f93e-437e-9272-0f6a37a99e4e<br/>2020-04-03 10:10:22  level=info Subscribing to topic: com.foo.service.hello<br/>2020-04-03 10:10:22  level=info Handler Received message: 2020-04-03 10:10:22.994619 +0800 CST m=+25.013864340<br/>2020-04-03 10:10:23  level=info Handler Received message: 2020-04-03 10:10:23.994576 +0800 CST m=+26.013819155<br/>2020-04-03 10:10:24  level=info Handler Received message: 2020-04-03 10:10:24.994613 +0800 CST m=+27.013852978<br/>...</span></pre></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="2a7c" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><p id="47b6" class="pw-post-body-paragraph kf kg it kh b ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky mr la lb lc im bi translated">Micro完全支持异步消息传递。它既支持高级发布/订阅模型，也支持通过<code class="fe le lf lg lh b">micro.Broker</code>进行的低级操作。</p><p id="7410" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> Pub/Sub </strong>大大简化了异步消息传递的开发，这样我们就可以专注于业务逻辑而不是技术细节。</p><p id="2b40" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">开发人员只需要定义发布者、订阅者和消息内容。所有其他工作都由框架完成。不再需要考虑异步消息传递系统中的常见问题，如消息路由、重传和接收确认，也不再需要考虑消息编码和解码。</p><p id="0cac" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当然，这种简化也带来了一些局限性。如果Pub/Sub不能满足您的需求，请关注本系列的下一篇文章，我们稍后将讨论与<code class="fe le lf lg lh b">micro.Broker</code>的消息传递</p><p id="ed14" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">未完待续。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><p id="4974" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">另请参见:</p><ul class=""><li id="8191" class="nf ng it kh b ki kj km kn kq nh ku ni ky nj lc nv nl nm nn bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-getting-started-a79916ae3cac"> Micro在行动，第1部分:入门</a></li><li id="de8e" class="nf ng it kh b ki no km np kq nq ku nr ky ns lc nv nl nm nn bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part-2-71230f01d6fb"> Micro In Action，第2部分:Bootstrap终极指南</a></li><li id="19fb" class="nf ng it kh b ki no km np kq nq ku nr ky ns lc nv nl nm nn bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part-3-calling-a-service-55d865928f11">微在行动，第3部分:调用服务</a></li><li id="c571" class="nf ng it kh b ki no km np kq nq ku nr ky ns lc nv nl nm nn bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part-5-message-broker-a3decf07f26a"> Micro在行动，第5部分:消息代理</a></li><li id="a1e9" class="nf ng it kh b ki no km np kq nq ku nr ky ns lc nv nl nm nn bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part6-service-discovery-f988988e5936">微在行动，第6部分:服务发现</a></li><li id="25f6" class="nf ng it kh b ki no km np kq nq ku nr ky ns lc nv nl nm nn bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-7-circuit-breaker-rate-limiter-431ccff6a120">微动作，第7部分:断路器&amp;速率限制器</a></li><li id="b718" class="nf ng it kh b ki no km np kq nq ku nr ky ns lc nv nl nm nn bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-coda-distributed-cron-job-a2b577885b24#39d6-3ace13696421">微操作，Coda:分布式Cron作业</a></li><li id="cd59" class="nf ng it kh b ki no km np kq nq ku nr ky ns lc nv nl nm nn bi translated"><a class="ae ld" href="https://medium.com/@dche423/micro-in-action-1be29b057f2d" rel="noopener">微在行动的索引页</a></li></ul></div></div>    
</body>
</html>