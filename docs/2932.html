<html>
<head>
<title>Using the DOM like a Pro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像专业人士一样使用DOM</h1>
<blockquote>原文：<a href="https://itnext.io/using-the-dom-like-a-pro-163a6c552eba?source=collection_archive---------0-----------------------#2019-09-02">https://itnext.io/using-the-dom-like-a-pro-163a6c552eba?source=collection_archive---------0-----------------------#2019-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="dee7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如何停止害怕DOM，充分利用它的潜力，并真正开始爱上它</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/54b8069ddcfde025e5526c06eb73cd2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mS7vEiMIgqRwI4vZ"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@pankajpatel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pankaj Patel </a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="8fd3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我在2008年开始作为一名专业的web开发人员工作时，我知道一些HTML、CSS和PHP。与此同时，我也在学习这个叫做JavaScript的东西，因为它允许我显示和隐藏元素，做一些很酷的事情，比如下拉菜单。</p><p id="1156" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当时我在一家小公司工作，主要为客户创建CMS系统，我们需要一个多文件上传器。这在当时用原生JavaScript是不可能的。</p><p id="68ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">经过一番搜索，我找到了一个基于Flash 和这个叫做MooTools的JavaScript库的<a class="ae le" href="http://digitarald.de/project/fancyupload/" rel="noopener ugc nofollow" target="_blank">奇特解决方案。MooTools有这个很酷的<code class="fe lf lg lh li b">$</code>功能来选择DOM元素，并带有进度条和Ajax请求等模块。几个星期后，我发现了jQuery，我被震惊了。</a></p><p id="9001" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不再有冗长、笨拙的DOM操作，而是简单、可链接的选择器，并且附带了一大堆有用的插件。</p><p id="ba2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">快进到2019年，世界被框架所统治。如果你在过去的十年里开始做一名web开发人员，那么你可能很难接触到“原始的”DOM。你甚至不需要。</p><p id="4cd0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管Angular和React等框架导致jQuery的受欢迎程度大幅下降，<a class="ae le" href="https://trends.builtwith.com/javascript/jQuery" rel="noopener ugc nofollow" target="_blank">仍有令人震惊的6600万个网站在使用它</a>，估计约占全球所有网站的<a class="ae le" href="https://w3techs.com/technologies/details/js-jquery/all/all" rel="noopener ugc nofollow" target="_blank">74%</a>。</p><p id="272f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">jQuery的遗产令人印象深刻，它如何影响标准的一个很好的例子是模仿jQuery的<code class="fe lf lg lh li b">$</code>函数的<code class="fe lf lg lh li b">querySelector</code>和<code class="fe lf lg lh li b">querySelectorAll</code>方法。</p><p id="a07f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">具有讽刺意味的是，这两种方法可能是jQuery受欢迎程度下降的最大原因，因为它们取代了jQuery最常用的功能:轻松选择DOM元素。</p><p id="219a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是原生DOM API是冗长的。</p><p id="943a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的意思是，这是<code class="fe lf lg lh li b">$</code>对<code class="fe lf lg lh li b">document.querySelectorAll</code>。</p><p id="5d64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这也是开发人员不愿使用原生DOM API的原因。但是真的没必要这样。</p><p id="fa34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">原生DOM API非常棒，而且非常有用。是的，它很冗长，但那是因为这些是低级的构建模块，旨在构建抽象概念。如果你真的担心额外的击键:所有现代编辑器和ide都提供了优秀的代码补全。您还可以为您最常用的功能起别名，我将在这里展示。</p><p id="eec7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们跳进来吧！</p><h1 id="1b1d" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">选择元素</h1><h2 id="3234" class="mi ll it bd lm mj mk dn lq ml mm dp lu kb mn mo ly kf mp mq mc kj mr ms mg mt bi translated">单一元素</h2><p id="cd9d" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">要使用任何有效的CSS选择器选择单个元素，请使用:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="7dbb" class="mi ll it li b gy nd ne l nf ng">document.querySelector(/* your selector */)</span></pre><p id="ef6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以使用这里的任何选择器:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="ed56" class="mi ll it li b gy nd ne l nf ng">document.querySelector('.foo')            // class selector<br/>document.querySelector('#foo')            // id selector<br/>document.querySelector('div')             // tag selector<br/>document.querySelector('[name="foo"]')    // attribute selector<br/>document.querySelector('div + p &gt; span')  // you go girl!</span></pre><p id="8ee5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当没有匹配的元素时，它将返回<code class="fe lf lg lh li b">null</code>。</p><h2 id="da43" class="mi ll it bd lm mj mk dn lq ml mm dp lu kb mn mo ly kf mp mq mc kj mr ms mg mt bi translated">多重元素</h2><p id="79a4" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">要选择多个元素，请使用:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="126a" class="mi ll it li b gy nd ne l nf ng">document.querySelectorAll('p')  // selects all &lt;p&gt; elements</span></pre><p id="d9d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以像使用<code class="fe lf lg lh li b">document.querySelector</code>一样使用<code class="fe lf lg lh li b">document.querySelectorAll</code>。任何有效的CSS选择器都可以，唯一的区别是<code class="fe lf lg lh li b">querySelector</code>将返回一个元素，而<code class="fe lf lg lh li b">querySelectorAll</code>将返回一个包含找到的元素的静态<code class="fe lf lg lh li b">NodeList</code>。如果没有找到元素，它将返回一个空的<code class="fe lf lg lh li b">NodeList</code>。</p><p id="17d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个<code class="fe lf lg lh li b">NodeList</code>是一个可迭代的对象，类似于一个数组，但它不是真正的<em class="lj">一个数组，所以它没有相同的方法。您可以在上面运行<code class="fe lf lg lh li b">forEach</code>，但不能运行<code class="fe lf lg lh li b">map</code>、<code class="fe lf lg lh li b">reduce</code>或<code class="fe lf lg lh li b">find</code>等。</em></p><p id="af36" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你确实需要在它上面运行数组方法，那么你可以简单地使用析构或者<code class="fe lf lg lh li b">Array.from</code>把它变成一个数组:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="eb64" class="mi ll it li b gy nd ne l nf ng">const arr = [...document.querySelectorAll('p')];</span><span id="883a" class="mi ll it li b gy nh ne l nf ng"><em class="lj">or</em></span><span id="3555" class="mi ll it li b gy nh ne l nf ng">const arr = Array.from(document.querySelectorAll('p'));</span><span id="3834" class="mi ll it li b gy nh ne l nf ng">arr.find(element =&gt; {...});  // .find() now works</span></pre><p id="07d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lf lg lh li b">querySelectorAll</code>方法与<code class="fe lf lg lh li b">getElementsByTagName</code>和<code class="fe lf lg lh li b">getElementsByClassName</code>等方法的不同之处在于，这些方法返回的<code class="fe lf lg lh li b">HTMLCollection</code>是<em class="lj">活动</em>集合，而<code class="fe lf lg lh li b">querySelectorAll</code>返回的<code class="fe lf lg lh li b">NodeList</code>是<em class="lj">静态</em>。</p><p id="6b42" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以如果你做了<code class="fe lf lg lh li b">getElementsByTagName('p')</code>并且从文档中删除了一个<code class="fe lf lg lh li b">&lt;p&gt;</code>，那么它也将从返回的<code class="fe lf lg lh li b">HTMLCollection</code>中删除。</p><p id="e865" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是如果你做了<code class="fe lf lg lh li b">querySelectorAll('p')</code>并且从文档中删除了一个<code class="fe lf lg lh li b">&lt;p&gt;</code>，它仍然会出现在返回的<code class="fe lf lg lh li b">NodeList</code>中。</p><p id="6a3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个重要的区别是，<code class="fe lf lg lh li b">HTMLCollection</code>只能包含<code class="fe lf lg lh li b">HTMLElement</code> s，而<code class="fe lf lg lh li b">NodeList</code>可以包含任何类型的<code class="fe lf lg lh li b">Node</code>。</p><h2 id="8926" class="mi ll it bd lm mj mk dn lq ml mm dp lu kb mn mo ly kf mp mq mc kj mr ms mg mt bi translated">相对搜索</h2><p id="d839" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">你不一定需要在<code class="fe lf lg lh li b">document</code>运行<code class="fe lf lg lh li b">querySelector(All)</code>。您可以在任何<code class="fe lf lg lh li b">HTMLElement</code>上运行它来运行相对搜索:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="95c1" class="mi ll it li b gy nd ne l nf ng">const div = document.querySelector('#container');<br/>div.querySelectorAll('p')  // finds all &lt;p&gt; tags in #container only</span></pre><h2 id="f222" class="mi ll it bd lm mj mk dn lq ml mm dp lu kb mn mo ly kf mp mq mc kj mr ms mg mt bi translated">但还是啰嗦！</h2><p id="b70d" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">如果您仍然担心额外的击键，您可以将这两种方法别名化:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="577f" class="mi ll it li b gy nd ne l nf ng">const $ = document.querySelector.bind(document);<br/>$('#container');</span><span id="7eed" class="mi ll it li b gy nh ne l nf ng">const $$ = document.querySelectorAll.bind(document);<br/>$$('p');</span></pre><p id="b7d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">给你。</p><h2 id="08b0" class="mi ll it bd lm mj mk dn lq ml mm dp lu kb mn mo ly kf mp mq mc kj mr ms mg mt bi translated">爬上DOM树</h2><p id="dded" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">使用CSS选择器来选择DOM元素意味着我们只能沿着DOM树向下移动。没有CSS选择器来沿着树向上移动来选择父节点。</p><p id="9623" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是我们可以使用<code class="fe lf lg lh li b">closest()</code>方法沿着DOM树向上移动，该方法也接受任何有效的CSS选择器:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="75a8" class="mi ll it li b gy nd ne l nf ng">document.querySelector('p').closest('div');</span></pre><p id="817a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将找到由<code class="fe lf lg lh li b">document.querySelector('p')</code>选择的段落的最近的父<code class="fe lf lg lh li b">&lt;div&gt;</code>元素。您可以将这些调用链接起来，在树中向上延伸:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="f692" class="mi ll it li b gy nd ne l nf ng">document.querySelector('p').closest('div').closest('.content');</span></pre><h1 id="d0ef" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">添加元素</h1><p id="2256" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">众所周知，向DOM树添加一个或多个元素的代码会很快变得冗长。假设您想要将以下链接添加到您的页面:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="de08" class="mi ll it li b gy nd ne l nf ng">&lt;a href="/home" class="active"&gt;Home&lt;/a&gt;</span></pre><p id="7ea3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您需要做:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="2562" class="mi ll it li b gy nd ne l nf ng">const link = document.createElement('a');<br/>link.setAttribute('href', '/home');<br/>link.className = 'active';<br/>link.textContent = 'Home';</span><span id="ec27" class="mi ll it li b gy nh ne l nf ng">document.body.appendChild(link);</span></pre><p id="0b56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在想象一下，必须对10个元素进行这样的操作…</p><p id="58c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">至少jQuery允许您这样做:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="816f" class="mi ll it li b gy nd ne l nf ng">$('body').append('&lt;a href="/home" class="active"&gt;Home&lt;/a&gt;');</span></pre><p id="85b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你猜怎么着？有一个本地对等项:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="80e0" class="mi ll it li b gy nd ne l nf ng">document.body.insertAdjacentHTML('beforeend', <br/>'&lt;a href="/home" class="active"&gt;Home&lt;/a&gt;');</span></pre><p id="0f44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lf lg lh li b">insertAdjacentHTML</code>方法允许您在DOM的四个位置插入任意有效的HTML字符串，由第一个参数指示:</p><ul class=""><li id="a562" class="ni nj it js b jt ju jx jy kb nk kf nl kj nm kn nn no np nq bi translated"><code class="fe lf lg lh li b">'beforebegin'</code>:元素前</li><li id="c7b9" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated"><code class="fe lf lg lh li b">'afterbegin'</code>:在第一个子元素之前的元素内部</li><li id="c9b4" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated"><code class="fe lf lg lh li b">'beforeend'</code>:在最后一个子元素之后的元素内部</li><li id="accb" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated"><code class="fe lf lg lh li b">'afterend'</code>:元素后</li></ul><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="3bb5" class="mi ll it li b gy nd ne l nf ng">&lt;!-- <em class="lj">beforebegin</em> --&gt;<br/><strong class="li iu">&lt;p&gt;</strong><br/>  &lt;!-- <em class="lj">afterbegin</em> --&gt;<br/>  foo<br/>  &lt;!-- <em class="lj">beforeend</em> --&gt;<br/><strong class="li iu">&lt;/p&gt;</strong><br/>&lt;!-- <em class="lj">afterend</em> --&gt;</span></pre><p id="b574" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这也使得指定应该插入新元素的确切位置变得更加容易。假设您想在这个<code class="fe lf lg lh li b">&lt;p&gt;</code>之前插入一个<code class="fe lf lg lh li b">&lt;a&gt;</code>。如果没有<code class="fe lf lg lh li b">insertAdjacentHTML</code>，你将不得不这样做:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="f1f0" class="mi ll it li b gy nd ne l nf ng">const link = document.createElement('a');<br/>const p = document.querySelector('p');</span><span id="59dc" class="mi ll it li b gy nh ne l nf ng">p.parentNode.insertBefore(link, p);</span></pre><p id="08cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在你可以做:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="1103" class="mi ll it li b gy nd ne l nf ng">const p = document.querySelector('p');</span><span id="2cb1" class="mi ll it li b gy nh ne l nf ng">p.insertAdjacentHTML('beforebegin', '&lt;a&gt;&lt;/a&gt;');</span></pre><p id="f6ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还有一种插入DOM元素的等效方法:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="7e7d" class="mi ll it li b gy nd ne l nf ng">const link = document.createElement('a');<br/>const p = document.querySelector('p');</span><span id="9ae9" class="mi ll it li b gy nh ne l nf ng">p.insertAdjacentElement('beforebegin', link);</span></pre><p id="e14d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">和文本:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="fcc8" class="mi ll it li b gy nd ne l nf ng">p.insertAdjacentText('afterbegin', 'foo');</span></pre><h1 id="74ad" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">移动元素</h1><p id="ebe3" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated"><code class="fe lf lg lh li b">insertAdjacentElement</code>方法也可用于移动同一文档中的现有元素。当用<code class="fe lf lg lh li b">insertAdjacentElement</code>插入的元素已经是文档的一部分时，它将被简单地移动。</p><p id="2a6e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您有这个HTML:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="58cd" class="mi ll it li b gy nd ne l nf ng">&lt;div class="first"&gt;<br/>  &lt;h1&gt;Title&lt;/h1&gt;<br/>&lt;/div&gt;</span><span id="0e0e" class="mi ll it li b gy nh ne l nf ng">&lt;div class="second"&gt;<br/>  &lt;h2&gt;Subtitle&lt;/h2&gt;<br/>&lt;/div&gt;</span></pre><p id="6864" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lf lg lh li b">&lt;h2&gt;</code>插在<code class="fe lf lg lh li b">&lt;h1&gt;</code>之后；</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="8266" class="mi ll it li b gy nd ne l nf ng">const h1 = document.querySelector('h1');<br/>const h2 = document.querySelector('h2');</span><span id="0b2f" class="mi ll it li b gy nh ne l nf ng">h1.insertAdjacentElement('afterend', h2);</span></pre><p id="bbad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将只是简单地被<em class="lj">移动了</em>、<strong class="js iu">而不是复制了</strong>:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="161e" class="mi ll it li b gy nd ne l nf ng">&lt;div class="first"&gt;<br/>  &lt;h1&gt;Title&lt;/h1&gt;<br/>  <strong class="li iu">&lt;h2&gt;Subtitle&lt;/h2&gt;</strong><br/>&lt;/div&gt;</span><span id="a82b" class="mi ll it li b gy nh ne l nf ng">&lt;div class="second"&gt;<br/>  <br/>&lt;/div&gt;</span></pre><h1 id="7070" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">替换元素</h1><p id="cb5d" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">一个DOM元素可以使用它的<code class="fe lf lg lh li b">replaceWith</code>方法被任何其他DOM元素替换:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="0652" class="mi ll it li b gy nd ne l nf ng">someElement.replaceWith(otherElement);</span></pre><p id="c3bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它所替换的元素可以是用<code class="fe lf lg lh li b">document.createElement</code>创建的新元素，也可以是已经是同一文档的一部分的元素(在这种情况下，它将再次被移动，而不是被复制):</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="197c" class="mi ll it li b gy nd ne l nf ng">&lt;div class="first"&gt;<br/>  &lt;h1&gt;Title&lt;/h1&gt;<br/>&lt;/div&gt;</span><span id="ad0d" class="mi ll it li b gy nh ne l nf ng">&lt;div class="second"&gt;<br/>  &lt;h2&gt;Subtitle&lt;/h2&gt;<br/>&lt;/div&gt;</span><span id="5728" class="mi ll it li b gy nh ne l nf ng">const h1 = document.querySelector('h1');<br/>const h2 = document.querySelector('h2');</span><span id="952b" class="mi ll it li b gy nh ne l nf ng">h1.replaceWith(h2);</span><span id="5951" class="mi ll it li b gy nh ne l nf ng">// result:</span><span id="83e2" class="mi ll it li b gy nh ne l nf ng">&lt;div class="first"&gt;<br/>  <strong class="li iu">&lt;h2&gt;Subtitle&lt;/h2&gt;</strong><br/>&lt;/div&gt;</span><span id="00c5" class="mi ll it li b gy nh ne l nf ng">&lt;div class="second"&gt;<br/>  <br/>&lt;/div&gt;</span></pre><h1 id="50d0" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">移除元素</h1><p id="e596" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">就叫它<code class="fe lf lg lh li b">remove</code>法:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="ed21" class="mi ll it li b gy nd ne l nf ng">const container = document.querySelector('#container');<br/>container.remove();  // hasta la vista, baby</span></pre><p id="4864" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">比老办法好多了:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="688a" class="mi ll it li b gy nd ne l nf ng">const container = document.querySelector('#container');<br/>container.parentNode.removeChild(container);</span></pre><h1 id="1729" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">从原始HTML创建元素</h1><p id="ac16" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated"><code class="fe lf lg lh li b">insertAdjacentHTML</code>方法允许我们将原始HTML插入到文档中，但是如果我们想要<em class="lj">从原始HTML创建</em>和元素并在以后使用它呢？</p><p id="bdb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，我们可以使用<code class="fe lf lg lh li b">DomParser</code>对象及其方法<code class="fe lf lg lh li b">parseFromString</code>。<code class="fe lf lg lh li b">DomParser</code>提供将HTML或XML源代码解析成DOM文档的能力。我们使用<code class="fe lf lg lh li b">parseFromString</code>方法创建一个只有一个元素的文档，并只返回这一个元素:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="16da" class="mi ll it li b gy nd ne l nf ng">const createElement = domString =&gt; new DOMParser().parseFromString(domString, 'text/html').body.firstChild;</span><span id="e018" class="mi ll it li b gy nh ne l nf ng">const a = createElement('&lt;a href="/home" class="active"&gt;Home&lt;/a&gt;');</span></pre><h1 id="7509" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">检查大教堂</h1><p id="8113" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">标准的DOM API也提供了一些方便的方法来检查DOM。例如，<code class="fe lf lg lh li b">matches</code>确定一个元素是否匹配某个选择器:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="6920" class="mi ll it li b gy nd ne l nf ng">&lt;p class="foo"&gt;Hello world&lt;/p&gt;</span><span id="417b" class="mi ll it li b gy nh ne l nf ng">const p = document.querySelector('p');</span><span id="da91" class="mi ll it li b gy nh ne l nf ng">p.matches('p');     // true<br/>p.matches('.foo');  // true<br/>p.matches('.bar');  // false, does not have class "bar"</span></pre><p id="ed24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您还可以使用<code class="fe lf lg lh li b">contains</code>方法检查一个元素是否是另一个元素的子元素:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="52f7" class="mi ll it li b gy nd ne l nf ng">&lt;div class="container"&gt;<br/>  &lt;h1 class="title"&gt;Foo&lt;/h1&gt;<br/>&lt;/div&gt;</span><span id="a588" class="mi ll it li b gy nh ne l nf ng">&lt;h2 class="subtitle"&gt;Bar&lt;/h2&gt;</span><span id="8e21" class="mi ll it li b gy nh ne l nf ng">const container = document.querySelector('.container');<br/>const h1 = document.querySelector('h1');<br/>const h2 = document.querySelector('h2');</span><span id="cad5" class="mi ll it li b gy nh ne l nf ng">container.contains(h1);  // true<br/>container.contains(h2);  // false</span></pre><p id="7c0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe lf lg lh li b">compareDocumentPosition</code>方法可以获得关于元素的更详细的信息。此方法允许您确定一个元素是在另一个元素之前还是之后，或者其中一个元素是否包含另一个元素。它返回一个整数，表示被比较元素之间的关系。</p><p id="666f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是一个与上一个示例具有相同元素的示例:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="131e" class="mi ll it li b gy nd ne l nf ng">&lt;div class="container"&gt;<br/>  &lt;h1 class="title"&gt;Foo&lt;/h1&gt;<br/>&lt;/div&gt;</span><span id="3b2f" class="mi ll it li b gy nh ne l nf ng">&lt;h2 class="subtitle"&gt;Bar&lt;/h2&gt;</span><span id="ab80" class="mi ll it li b gy nh ne l nf ng">const container = document.querySelector('.container');<br/>const h1 = document.querySelector('h1');<br/>const h2 = document.querySelector('h2');</span><span id="dd82" class="mi ll it li b gy nh ne l nf ng">//  20: h1 is contained by container and follows container<br/>container.compareDocumentPosition(h1); </span><span id="65cf" class="mi ll it li b gy nh ne l nf ng">// 10: container contains h1 and precedes it<br/>h1.compareDocumentPosition(container);</span><span id="4d23" class="mi ll it li b gy nh ne l nf ng">// 4: h2 follows h1<br/>h1.compareDocumentPosition(h2);</span><span id="602f" class="mi ll it li b gy nh ne l nf ng">// 2: h1 precedes h2<br/>h2.compareDocumentPosition(h1);</span></pre><p id="0544" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从<code class="fe lf lg lh li b">compareDocumentPosition</code>返回的值是一个整数，它的位代表节点之间的关系，相对于给这个方法的参数。</p><p id="c311" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以考虑到语法<code class="fe lf lg lh li b">node.compareDocumentPostion(otherNode)</code>返回值的含义是:</p><ul class=""><li id="a359" class="ni nj it js b jt ju jx jy kb nk kf nl kj nm kn nn no np nq bi translated">1:节点不是同一文档的一部分</li><li id="b1e5" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated">2: <code class="fe lf lg lh li b">otherNode</code>在<code class="fe lf lg lh li b">node</code>之前</li><li id="4c46" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated">4: <code class="fe lf lg lh li b">otherNode</code>跟随<code class="fe lf lg lh li b">node</code></li><li id="00cd" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated">8: <code class="fe lf lg lh li b">otherNode</code>包含<code class="fe lf lg lh li b">node</code></li><li id="aefa" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated">16: <code class="fe lf lg lh li b">otherNode</code>被<code class="fe lf lg lh li b">node</code>包含</li></ul><p id="8b63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以设置多个位，这就是为什么在上面的例子中<code class="fe lf lg lh li b">container.compareDocumenPosition(h1)</code>返回20，而你可能期望16，因为<code class="fe lf lg lh li b">h1</code>被<code class="fe lf lg lh li b">container</code>包含。但是<code class="fe lf lg lh li b">h1</code>也是<em class="lj">跟随</em> <code class="fe lf lg lh li b">container</code> (4)所以结果值是16 + 4 = 20。</p><h2 id="b0bf" class="mi ll it bd lm mj mk dn lq ml mm dp lu kb mn mo ly kf mp mq mc kj mr ms mg mt bi translated">请提供更多细节！</h2><p id="23f3" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">您可以通过<code class="fe lf lg lh li b">MutationObserver</code>界面观察任何DOM节点的变化。这包括文本更改、向被观察节点添加节点或从被观察节点移除节点，或者对节点属性的更改。</p><p id="8fc1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lf lg lh li b">MutationObserver</code>是一个非常强大的API，几乎可以观察到DOM元素及其子节点上发生的任何变化。</p><p id="d7c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过用回调函数调用其构造函数来创建一个新的<code class="fe lf lg lh li b">MutationObserver</code>。每当被观察节点上发生变化时，将调用此回调:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="77aa" class="mi ll it li b gy nd ne l nf ng">const observer = new MutationObserver(callback);</span></pre><p id="074e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了观察一个元素，我们需要调用观察者的<code class="fe lf lg lh li b">observe</code>方法，将被观察的节点作为第一个参数，将一个带有选项的对象作为第二个参数。</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="d16a" class="mi ll it li b gy nd ne l nf ng">const target = document.querySelector('#container');<br/>const observer = new MutationObserver(callback);</span><span id="a06c" class="mi ll it li b gy nh ne l nf ng">observer.observe(target, options);</span></pre><p id="356e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">直到调用<code class="fe lf lg lh li b">observe</code>后，才开始观察目标。</p><p id="c7c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此选项对象采用以下键:</p><ul class=""><li id="c6b2" class="ni nj it js b jt ju jx jy kb nk kf nl kj nm kn nn no np nq bi translated"><code class="fe lf lg lh li b">attributes</code>:设置为<code class="fe lf lg lh li b">true</code>时，将观察节点属性的变化</li><li id="e92b" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated"><code class="fe lf lg lh li b">attributeFilter</code>:要监视的属性名数组，当<code class="fe lf lg lh li b">attributes</code>为<code class="fe lf lg lh li b">true</code>且未设置时，会监视对<em class="lj">节点所有</em>属性的更改</li><li id="9e27" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated"><code class="fe lf lg lh li b">attributeOldValue</code>:当设置为<code class="fe lf lg lh li b">true</code>时，每当发生变化时，将记录属性的先前值</li><li id="f9a1" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated"><code class="fe lf lg lh li b">characterData</code>:当设置为true时，这将记录对<em class="lj">文本节点</em>的文本的更改，因此这仅适用于<code class="fe lf lg lh li b">Text</code>节点，而不适用于<code class="fe lf lg lh li b">HTMLElement</code> s。要实现这一点，被观察的节点需要是一个<code class="fe lf lg lh li b">Text</code>节点，或者，如果观察者监视一个<code class="fe lf lg lh li b">HTMLElement</code>，选项<code class="fe lf lg lh li b">subtree</code>需要设置为<code class="fe lf lg lh li b">true</code>以监视对子节点的更改。</li><li id="f08f" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated"><code class="fe lf lg lh li b">characterDataOldValue</code>:设置为<code class="fe lf lg lh li b">true</code>时，无论何时发生变化，都将记录字符数据的先前值</li><li id="972d" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated"><code class="fe lf lg lh li b">subtree</code>:设置为<code class="fe lf lg lh li b">true</code>，也观察被观察元素的子节点的变化。</li><li id="77bb" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated"><code class="fe lf lg lh li b">childList</code>:设置为<code class="fe lf lg lh li b">true</code>，监控元素添加和删除子节点。当<code class="fe lf lg lh li b">subtree</code>被设置为<code class="fe lf lg lh li b">true</code>时，子元素也将被监视以添加和移除子节点。</li></ul><p id="13dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当通过调用<code class="fe lf lg lh li b">observe</code>开始观察一个元素时，传递给<code class="fe lf lg lh li b">MutationObserver</code>构造函数的回调被调用，带有一个描述发生的变化的<code class="fe lf lg lh li b">MutationRecord</code>对象数组和作为第二个参数调用的观察者。</p><p id="5ed5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个<code class="fe lf lg lh li b">MutationRecord</code>包含以下属性:</p><ul class=""><li id="6da9" class="ni nj it js b jt ju jx jy kb nk kf nl kj nm kn nn no np nq bi translated"><code class="fe lf lg lh li b">type</code>:变更的类型，可以是<code class="fe lf lg lh li b">attributes</code>、<code class="fe lf lg lh li b">characterData</code>或<code class="fe lf lg lh li b">childList</code>。</li><li id="fc8b" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated"><code class="fe lf lg lh li b">target</code>:改变的元素，其属性、字符数据或子元素</li><li id="4b33" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated"><code class="fe lf lg lh li b">addedNodes</code>:添加节点列表，如果没有添加，则为空<code class="fe lf lg lh li b">NodeList</code></li><li id="2b03" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated"><code class="fe lf lg lh li b">removedNodes</code>:删除节点列表，如果没有删除，则为空<code class="fe lf lg lh li b">NodeList</code></li><li id="ac6b" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated"><code class="fe lf lg lh li b">attributeName</code>:变更属性的名称，如果没有属性变更，则为<code class="fe lf lg lh li b">null</code></li><li id="2d93" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated"><code class="fe lf lg lh li b">previousSibling</code>:添加或删除节点的上一个兄弟节点或<code class="fe lf lg lh li b">null</code></li><li id="ba9a" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated"><code class="fe lf lg lh li b">nextSibling</code>:添加或删除节点的下一个兄弟节点或<code class="fe lf lg lh li b">null</code></li></ul><p id="93cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们想要观察属性和子节点的变化:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="897c" class="mi ll it li b gy nd ne l nf ng">const target = document.querySelector('#container');<br/>const callback = (mutations, observer) =&gt; {<br/>  mutations.forEach(mutation =&gt; {<br/>    switch (mutation.type) {<br/>      case 'attributes':<br/>        // the name of the changed attribute is in<br/>        // mutation.attributeName<br/>        // and its old value is in mutation.oldValue<br/>        // the current value can be retrieved with <br/>        // target.getAttribute(mutation.attributeName)<br/>        break;</span><span id="30e1" class="mi ll it li b gy nh ne l nf ng">      case 'childList':<br/>        // any added nodes are in mutation.addedNodes<br/>        // any removed nodes are in mutation.removedNodes<br/>        break;<br/>    }<br/>  });<br/>};</span><span id="cca6" class="mi ll it li b gy nh ne l nf ng">const observer = new MutationObserver(callback);</span><span id="377c" class="mi ll it li b gy nh ne l nf ng">observer.observe(target, {<br/>  attributes: true,<br/>  attributeFilter: ['foo'], // only observe attribute 'foo'<br/>  attributeOldValue: true,<br/>  childList: true<br/>});</span></pre><p id="6c24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您完成对目标的观察后，您可以断开观察器，如果需要的话，调用它的<code class="fe lf lg lh li b">takeRecords</code>方法来获取任何尚未交付给回调的待定突变:</p><pre class="kp kq kr ks gt mz li na nb aw nc bi"><span id="cff9" class="mi ll it li b gy nd ne l nf ng">const mutations = observer.takeRecords();<br/>callback(mutations);<br/>observer.disconnect();</span></pre><h1 id="f4c0" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">不要害怕大教堂</h1><p id="876d" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">DOM API是一个非常强大和通用的API，尽管有些冗长。请记住，它旨在为开发人员提供底层构建模块来构建抽象，因此从这个意义上来说，它需要冗长，以提供明确清晰的API。</p><p id="dfde" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">额外的击键不会吓到你，让你不敢充分发挥它的潜力。</p><p id="26ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">DOM是每个JavaScript开发者的基本知识，因为你可能每天都在使用它。不要害怕它，充分发挥它的潜力。</p><p id="8401" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你会成为更好的开发者。</p></div></div>    
</body>
</html>