<html>
<head>
<title>Kubernetes and Secrets Management In The Cloud: Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes和云中的秘密管理:第二部分</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-and-secrets-management-in-cloud-part-2-6c37c1238a87?source=collection_archive---------4-----------------------#2020-05-07">https://itnext.io/kubernetes-and-secrets-management-in-cloud-part-2-6c37c1238a87?source=collection_archive---------4-----------------------#2020-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ffe5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将API密钥、密码、证书和其他敏感数据存储在云原生秘密管理服务中，并从K8s集群访问它们。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ca9ef31942853186bf21202a49c65a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2VmDyTKVuqf4GOsQpGyJKA.jpeg"/></div></div></figure><h2 id="255f" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">介绍</h2><p id="62be" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated"><em class="mg">秘密对于许多生产系统的运作至关重要。意外泄露机密是应该妥善解决的最大风险之一。开发人员应该尽力保护应用程序的秘密。</em></p><p id="7e94" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">一旦公司转向微服务架构，多个服务需要访问不同的秘密才能正常工作，问题就变得更加棘手。这带来了新的挑战:如何分发、管理、监控和轮换应用程序机密，同时避免意外暴露？</p><p id="ba4e" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">在之前的帖子(<a class="ae mm" href="https://blog.doit-intl.com/kubernetes-and-secrets-management-in-cloud-858533c20dca" rel="noopener ugc nofollow" target="_blank">第一部分</a>)中，我展示了一种将AWS和Google Cloud secrets管理服务(<a class="ae mm" href="https://aws.amazon.com/secrets-manager/" rel="noopener ugc nofollow" target="_blank"> AWS Secrets Manager </a>、<a class="ae mm" href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-parameter-store.html" rel="noopener ugc nofollow" target="_blank"> AWS SSM参数存储</a>和<a class="ae mm" href="https://cloud.google.com/secret-manager" rel="noopener ugc nofollow" target="_blank">Google Cloud Secret Manager</a>)与Kubernetes集成的方法，使用了手动添加到目标Pod中的<a class="ae mm" href="https://hub.docker.com/r/doitintl/secrets-init" rel="noopener ugc nofollow" target="_blank">doit intl/Secrets-init</a><em class="mg">init container</em>。</p><p id="23b5" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">在这篇文章中，我将展示一种<strong class="lp ir"> Kubernetes-native </strong>方法来集成上面提到的云秘密管理服务。</p><h2 id="4f57" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">自动云秘密注入</h2><p id="bdcb" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">虽然可以手动修改Kubernetes部署YAML文件以使用<code class="fe mn mo mp mq b">secret-init</code>作为容器<code class="fe mn mo mp mq b">init</code>系统，但更好的选择是，如果有人可以为您这样做，并且只为引用云秘密的Kubernetes Pods这样做。对我们来说幸运的是，Kubernetes允许我们在使用一种称为<a class="ae mm" href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/" rel="noopener ugc nofollow" target="_blank">变异准入webhook </a>的机制创建容器之前检查和修改任何Pod。</p><p id="58de" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated"><a class="ae mm" href="https://github.com/doitintl/kube-secrets-init" rel="noopener ugc nofollow" target="_blank">DoiT intl/kube-secrets-init</a>是来自<a class="ae mm" href="https://www.doit-intl.com/" rel="noopener ugc nofollow" target="_blank"> DoiT International </a>的一个开源项目，实现了一个用于云秘密注入的Kubernetes <em class="mg">突变准入webhook </em>，支持AWS和Google云管理的秘密。</p><p id="095b" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated"><code class="fe mn mo mp mq b">kube-secrets-init</code>监控Kubernetes集群中新创建或更新的pod，向直接(通过环境变量)和/或间接(通过Kubernetes <code class="fe mn mo mp mq b">Secret</code>和<code class="fe mn mo mp mq b">ConfigMap</code>)引用云秘密的pod添加一个带有<a class="ae mm" href="https://hub.docker.com/r/doitintl/secrets-init" rel="noopener ugc nofollow" target="_blank"> doitintl/secrets-init </a>实用程序的<em class="mg"> initContainer </em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl mr"><img src="../Images/57d5744fc51da7a8559381c00bfb0239.png" data-original-src="https://miro.medium.com/v2/0*hVFCVwhQC-bMZ8jD"/></div></figure><h2 id="00ad" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">与AWS Secrets Manager集成</h2><p id="9b61" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">用户可以把一个AWS秘密<a class="ae mm" href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html" rel="noopener ugc nofollow" target="_blank"> ARN </a>引用作为一个环境变量值。<code class="fe mn mo mp mq b">secrets-init</code>将使用指定的ARN将环境值解析为引用的秘密值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="3438" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">与AWS系统管理器参数存储集成</h2><p id="68d7" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">可以使用AWS系统管理器参数存储来存储应用程序参数和机密。</p><p id="2b31" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">用户可以将AWS参数存储ARN引用作为环境变量。<code class="fe mn mo mp mq b">secrets-init</code>将使用指定的ARN将环境值解析为引用的参数存储值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="235c" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">与谷歌秘密管理集成</h2><p id="3246" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">用户可以将一个Google Secret名称(前缀为<code class="fe mn mo mp mq b">gcp:secretmanager:</code>)作为环境变量值。<code class="fe mn mo mp mq b">secrets-init</code>将使用指定的名称将环境值解析为引用的秘密值。秘密名称可以包括秘密版本，以引用秘密的特定版本。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="a556" class="mu ks iq bd kt mv mw mx kw my mz na kz jw nb jx ld jz nc ka lh kc nd kd ll ne bi translated">要求</h1><h2 id="2ce3" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">自动警报系统</h2><p id="5b93" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">为了从AWS机密管理器和参数存储中解析AWS机密，<code class="fe mn mo mp mq b">secrets-init</code>应用程序应该在AWS IAM角色下运行，并附加以下IAM策略之一。</p><p id="99da" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">对于AWS机密管理器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="988c" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">对于AWS系统管理器参数存储:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="8c41" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">在EKS集群中运行时，建议对服务帐户使用<a class="ae mm" href="https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html" rel="noopener ugc nofollow" target="_blank"> AWS IAM角色。也可以将IAM角色分配给EC2实例，容器在该实例中运行。这种选择被认为不太安全。</a></p><h2 id="ec5a" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">谷歌云</h2><p id="a51a" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">为了从Google Secret Manager中解析Google secrets，<code class="fe mn mo mp mq b">secrets-init</code>应用程序应该在IAM角色下运行，拥有足够的权限来访问所需的机密。例如，您可以将以下两个预定义的Google IAM角色分配给一个Google服务帐户:<code class="fe mn mo mp mq b">Secret Manager Viewer</code>和<code class="fe mn mo mp mq b">Secret Manager Secret Accessor</code>角色。</p><p id="62ac" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">在GKE集群中，可以将IAM角色分配给具有<a class="ae mm" href="https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity" rel="noopener ugc nofollow" target="_blank">工作负载标识</a>的Kubernetes Pod。也可以将IAM角色分配给运行容器的GCE实例。这种选择被认为不太安全。</p><p id="a506" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">取消注释<a class="ae mm" href="https://github.com/doitintl/kube-secrets-init/blob/master/deployment/deployment.yaml" rel="noopener ugc nofollow" target="_blank"> deployment.yaml </a>文件中的<code class="fe mn mo mp mq b">--provider=google</code>标志。</p><h2 id="1bfd" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">Webhook部署</h2><ol class=""><li id="cf2e" class="nf ng iq lp b lq lr lt lu la nh le ni li nj mf nk nl nm nn bi translated">为了部署<code class="fe mn mo mp mq b">kube-secrets-init</code> webhook服务器，我们需要在我们的Kubernetes集群中创建一个webhook服务和一个部署。这很简单，除了一点:服务器的TLS配置。如果您愿意检查一下<a class="ae mm" href="https://github.com/doitintl/kube-secrets-init/blob/master/deployment/deployment.yaml" rel="noopener ugc nofollow" target="_blank"> deployment.yaml </a>文件，您会发现证书和相应的私钥文件是从命令行参数中读取的，并且这些文件的路径来自指向Kubernetes秘密的卷挂载:</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="24fb" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">需要记住的最重要的事情是稍后在webhook配置中设置相应的CA证书，这样<code class="fe mn mo mp mq b">apiserver</code>就会知道它应该被接受。现在，我们将重用最初由Istio团队编写的脚本来生成证书签名请求。然后，我们将请求发送到Kubernetes API，获取证书，并根据结果创建所需的秘密。</p><p id="a9ba" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">首先，运行<a class="ae mm" href="https://github.com/doitintl/kube-secrets-init/blob/master/deployment/webhook-create-signed-cert.sh" rel="noopener ugc nofollow" target="_blank">web hook-create-signed-cert . sh</a>脚本，检查持有证书和密钥的秘密是否已经创建:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="04a3" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">一旦创建了秘密，我们就可以创建部署和服务。这些是标准的Kubernetes部署和服务资源。到目前为止，我们只制作了一个HTTP服务器，它通过端口<code class="fe mn mo mp mq b">443</code>上的服务接受请求:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="826b" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">配置变异准入网络挂钩</h2><p id="ad62" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">现在我们的webhook服务器正在运行，它可以接受来自<code class="fe mn mo mp mq b">apiserver</code>的请求。但是，我们应该首先在Kubernetes中创建一些配置资源。让我们从验证webhook开始，稍后我们将配置变异的webhook。如果你看一下<a class="ae mm" href="https://github.com/doitintl/kube-secrets-init/blob/master/deployment/mutatingwebhook.yaml" rel="noopener ugc nofollow" target="_blank"> webhook配置</a>，你会注意到它包含了一个<code class="fe mn mo mp mq b">CA_BUNDLE</code>的占位符:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d0fa" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">有一个<a class="ae mm" href="https://github.com/doitintl/kube-secrets-init/blob/master/deployment/webhook-patch-ca-bundle.sh" rel="noopener ugc nofollow" target="_blank">小脚本</a>用这个CA替换配置中的CA_BUNDLE占位符。在创建验证webhook配置之前运行以下命令:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="f9d0" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">创建变异webhook配置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="0604" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">为secrets-init-webhook配置RBAC</h2><p id="074c" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">创建一个与<code class="fe mn mo mp mq b">secrets-init-webhook</code>一起使用的Kubernetes服务帐户:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d2e1" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">为webhook服务帐户定义RBAC权限:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="e27e" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">摘要</h2><p id="8b99" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">我希望这篇文章对你有用。我期待您的评论和任何问题。</p><p id="9839" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">我们还邀请您为GitHub项目<a class="ae mm" href="https://github.com/doitintl/kube-secrets-init" rel="noopener ugc nofollow" target="_blank">doit intl/kube-secrets-init</a>贡献(问题、功能、PRs)。</p><p id="6d6c" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">想要更多来自阿列克谢的故事？在<a class="ae mm" href="http://blog.doit-intl.com/" rel="noopener ugc nofollow" target="_blank"> Medium </a>上查看我们的博客，或者<a class="ae mm" href="https://twitter.com/alexeiled" rel="noopener ugc nofollow" target="_blank">在Twitter上关注阿列克谢</a>。</p></div></div>    
</body>
</html>