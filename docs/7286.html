<html>
<head>
<title>Distributed Tracing with Quarkus, Python, Open Telemetry and Jaeger (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Quarkus、Python、Open Telemetry和Jaeger进行分布式追踪(第2部分)</h1>
<blockquote>原文：<a href="https://itnext.io/distributed-tracing-with-quarkus-python-open-telemetry-and-jaeger-part-2-d533e3a83703?source=collection_archive---------4-----------------------#2022-08-10">https://itnext.io/distributed-tracing-with-quarkus-python-open-telemetry-and-jaeger-part-2-d533e3a83703?source=collection_archive---------4-----------------------#2022-08-10</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><p id="628e" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在<a class="ae km" href="https://pilhuhn.medium.com/distributed-tracing-with-quarkus-python-open-telemetry-and-jaeger-part-1-2d83f761b786" rel="noopener">的最后一部分</a>中，我们看了一些Quarkus和Python代码，以获取我们转发给Jaeger的踪迹。不幸的是，这两者没有联系，因此我们无法获得完整的图片。让我们解决这个问题。</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div class="gi gj kn"><img src="../Images/a6046b63283dfc46018c87e1a7014359.png" data-original-src="https://miro.medium.com/v2/resize:fit:372/format:webp/1*TMH253Zs8-OPYY339We2VA.png"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">具有一些嵌入跨度的轨迹</figcaption></figure><p id="c723" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">每个轨迹和每个跨度都有一个唯一的ID。span另外还有traceId和它们的父span的Id(你可以把一个trace想象成一个没有父span)。在上图中，跨度3将跨度2作为父项，跨度1和跨度2都将蓝色轨迹作为其共同的父项。蓝色轨迹本身没有父轨迹。</p><p id="e1e8" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">这意味着能够将我们的Python代码链接到由<em class="kz">后端</em>启动的跟踪，我们需要告诉它跟踪id以及跨度的id，这应该是Python代码的父跨度。一种常见的方法是在http头中传播该信息。有几个标准可以做到这一点，<a class="ae km" href="https://xkcd.com/927/" rel="noopener ugc nofollow" target="_blank">所以一个新的标准被发明了</a>，W3C Tracecontext 。这里，在http-requests中发送一个单独的header <em class="kz"> traceparent </em>。该标题包含所有必要的信息，如下所示(<a class="ae km" href="https://www.w3.org/TR/trace-context/#trace-context-http-headers-format" rel="noopener ugc nofollow" target="_blank">参考完整信息标准</a>):</p><pre class="ko kp kq kr gu la lb lc ld aw le bi"><span id="2ff6" class="lf lg ir lb b gz lh li l lj lk">version2-traceId32-parentId16-flags2</span></pre><p id="ef6e" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">标题值由四个字段组成，用破折号分隔。每个字段由一个十六进制数表示，其中上面给出了位数。有了这些信息，我们现在可以从传入的请求中提取头部，并从中创建SpanContext，然后当我们在requesthandler中创建Span时，它将被传递:</p><pre class="ko kp kq kr gu la lb lc ld aw le bi"><span id="256b" class="lf lg ir lb b gz lh li l lj lk"><strong class="lb is">inc_trace = self.headers["traceparent"]</strong><br/>ctx = {}<br/>span_context = None<br/>if inc_trace is not None:<br/>    span_context = extract_trace_data(<strong class="lb is">inc_trace</strong>)<br/>    ctx = trace.set_span_in_context(NonRecordingSpan(<strong class="lb is">span_context</strong>))<br/>with tracer.start_as_current_span("my-span",<strong class="lb is">context=ctx</strong>) as span:<br/>    self.send_response(200)<br/>    ...</span></pre><p id="d4f9" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我们首先获取http-header，然后将它传递给提取器代码，提取器代码创建一个<em class="kz"> SpanContext </em>对象，当我们在handler方法中启动新的span to时，将使用这个对象。有了这样的改变，我们可以在<em class="kz">后端</em>上触发另一次运行，并在Jaeger中获得预期的结果:</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gi gj ll"><img src="../Images/bb4120690edd7cfcc850fbc8accd0e61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-yD6tjvnAjj3qkOX7ITSWQ.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">包括假rbac和后端的跟踪概述</figcaption></figure><p id="30a0" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在详细视图中，我们还可以清楚地看到橙色的<em class="kz"> fake-rbac </em>的范围</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gi gj lq"><img src="../Images/77ee9a9197ac0fe4c9a95e86c8561aa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TgDrRik6PFcs-bjzZwF71w.png"/></div></div></figure><h2 id="adda" class="lf lg ir bd lr ls lt dn lu lv lw dp lx jz ly lz ma kd mb mc md kh me mf mg mh bi translated">从Python到Quarkus的传播</h2><p id="bbaa" class="pw-post-body-paragraph jo jp ir jq b jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh mm kj kk kl ik bi translated">前面的成功留给我们从Python到第二个<a class="ae km" href="https://quarkus.io" rel="noopener ugc nofollow" target="_blank"> Quarkus </a>服务的传播，如第一篇文章的第一幅图所示。现在我们知道如何手工操作，我使用了一个快捷方式，并且使用了<a class="ae km" href="https://opentelemetry-python-contrib.readthedocs.io/en/latest/instrumentation/requests/requests.html" rel="noopener ugc nofollow" target="_blank"><em class="kz">请求</em>库检测</a>。代码中的设置非常简单:只需在设置<em class="kz"> TraceProvider </em>之前添加下面一行，就大功告成了。</p><pre class="ko kp kq kr gu la lb lc ld aw le bi"><span id="b44e" class="lf lg ir lb b gz lh li l lj lk">RequestsInstrumentor().instrument()</span></pre><p id="9b3f" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">对后端的另一个请求产生以下结果:</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gi gj mn"><img src="../Images/c5fc19acccbc667c8bd55f2cb1e816d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L1WEvm1Dl2R76VkdRhF4Og.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">包含服务的更复杂的跟踪</figcaption></figure><p id="f8fc" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我们看到了所有3个服务，但是概述显示了2个错误。这是怎么回事？让我们看看跟踪的细节，并用红色感叹号展开两个跨度。</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gi gj lq"><img src="../Images/7a72ece631a3e3d1ae2ff98dc16a2ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QMailQFLDhgVNz9WNy5KuA.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">具有扩展详细信息的跟踪视图</figcaption></figure><p id="dd3f" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我们可以在跟踪视图中看到，fake-rbac对引擎的PUT请求导致了400“无效请求”返回代码(用绿色标记)。因此，对请求库的检测将span标记为错误。</p><h2 id="8a82" class="lf lg ir bd lr ls lt dn lu lv lw dp lx jz ly lz ma kd mb mc md kh me mf mg mh bi translated">将跨度标记为错误</h2><p id="e21a" class="pw-post-body-paragraph jo jp ir jq b jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh mm kj kk kl ik bi translated">当我们查看返回400代码的引擎范围时，我们可以看到它也被标记为错误，并且它包含一条日志消息，告诉我们请求失败的原因。为此，<em class="kz">引擎</em>服务器代码需要一些工具:</p><pre class="ko kp kq kr gu la lb lc ld aw le bi"><span id="f6e0" class="lf lg ir lb b gz lh li l lj lk">} catch (Exception e) {<br/>    Span span = Span.<em class="kz">current</em>();    <br/>    span.recordException(e);<br/>    span.setStatus(StatusCode.<em class="kz">ERROR</em>);<br/>    span.setAttribute("condition", condition);</span></pre><p id="74a3" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">这将检索当前范围，然后记录异常。这不会自动将跨度标记为错误，所以我们明确地这样做。在最后一步中，导致异常的condition元素被存储为attribute，这样它就会出现在span的标记中，就像上面用空值做的那样。</p><h2 id="b0d5" class="lf lg ir bd lr ls lt dn lu lv lw dp lx jz ly lz ma kd mb mc md kh me mf mg mh bi translated">更多…</h2><p id="ead8" class="pw-post-body-paragraph jo jp ir jq b jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh mm kj kk kl ik bi translated">你可以在GitHub 上获得<a class="ae km" href="https://github.com/pilhuhn/fake-rbac" rel="noopener ugc nofollow" target="_blank">完整的Python代码。在下一篇</a><a class="ae km" rel="noopener ugc nofollow" target="_blank" href="/distributed-tracing-with-quarkus-python-open-telemetry-and-jaeger-part-3-79137543b2c5">帖子</a>中，我将讨论如何在Kafka中使用OpenTelemetry。</p><p id="c945" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">你可以在介质上找到第1部分。再次感谢<a class="mo mp ep" href="https://medium.com/u/31f1d3c010e9?source=post_page-----d533e3a83703--------------------------------" rel="noopener" target="_blank">Jura ci paix o krhling</a>审阅这篇文章。</p></div></div>    
</body>
</html>