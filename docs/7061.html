<html>
<head>
<title>A Fully Responsive Chart.js Chart</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">完全响应的Chart.js图表</h1>
<blockquote>原文：<a href="https://itnext.io/a-fully-responsive-chart-js-chart-91a72ef5e2c?source=collection_archive---------0-----------------------#2022-05-29">https://itnext.io/a-fully-responsive-chart-js-chart-91a72ef5e2c?source=collection_archive---------0-----------------------#2022-05-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="89eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一点CSS网格知识让我们构建一个图表，在两个方向上填充可用空间。</p><p id="b360" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://www.chartjs.org/" rel="noopener ugc nofollow" target="_blank"> Chart.js </a>是一个功能全面但易于使用的Javascript库，用于创建许多类型的图表和图形，它在画布元素上绘制这些图表和图形。因为画布与图像相似，都具有内在(渲染)像素大小和显示大小，所以使其具有响应性并不是一件简单的事情。<a class="ae kl" href="https://www.chartjs.org/docs/latest/configuration/responsive.html" rel="noopener ugc nofollow" target="_blank"> Chart.js文档简洁地描述了问题</a>:</p><blockquote class="km kn ko"><p id="007a" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">当谈到根据窗口大小改变图表大小时，一个主要的限制是画布<em class="iq">渲染</em>大小(<code class="fe kt ku kv kw b">canvas.width</code>和<code class="fe kt ku kv kw b">.height</code>)可以<strong class="jp ir">而不是</strong>用相对值表示，与<em class="iq">显示</em>大小(<code class="fe kt ku kv kw b">canvas.style.width</code>和<code class="fe kt ku kv kw b">.height</code>)相反。此外，这些尺寸彼此独立，因此画布<em class="iq">渲染</em>尺寸不会根据<em class="iq">显示</em>尺寸自动调整，使得渲染不准确。</p></blockquote><p id="ee39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有关更深入的解释，以及调整画布大小的一般解决方案，请阅读<a class="ae kl" href="https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html" rel="noopener ugc nofollow" target="_blank"> WebGL调整画布大小</a>。</p><p id="5ef2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您曾经阅读过那篇文章，您就会知道调整画布的大小有点复杂。幸运的是，Chart.js为我们完成了大部分复杂的工作！Chart.js图表在默认情况下是响应性的，但是有一个限制:它保持其纵横比。下面是一个几乎没有应用任何样式的示例:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/c064671388e199cdd51cc8b0eb0b6d45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-hiTVYOce8D7WIpLJOs99g.gif"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated"><a class="ae kl" href="https://codepen.io/noraspice/pen/GRQQmaY" rel="noopener ugc nofollow" target="_blank">见此笔</a>自己试试。</figcaption></figure><p id="72ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能会想“如果画布就像一幅图像，这不正是我们想要的吗？”。毕竟，如果你随意改变图像的长宽比，它会显得扭曲和怪异:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ln"><img src="../Images/5257a4dc22f3aa008b8cbc792cd73fe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ACuq4FXKALKMUJHMcdY6ug.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">那是一只被压扁的鸟。长宽比对图像很重要！</figcaption></figure><p id="3b54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是通过图表或图形，我们的数据通常可以在一系列纵横比下清晰呈现:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi lo"><img src="../Images/238722296d8878026e4e13e7d8ce1037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zgKE-mynKvdbKOTk-Xj2qw.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">大多数图表可以很容易地调整到不同的长宽比。</figcaption></figure><p id="927a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我工作的情况下，界面有一些围绕图表的数据和控件面板。我们不知道浏览器的大小，也不知道用户是否会调整浏览器的大小，甚至折叠其中一个面板。但是(几乎)无论发生什么，我们都希望图表占据所有可用的空间:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi lp"><img src="../Images/a8389858d2dbe76eaed9e699a3cba06f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lAeRVkBFFxPCpajoQ8k3Eg.gif"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">我们的目标是:一个可以扩展以填充可用空间的图表，并在两个方向上响应视口的大小调整。</figcaption></figure><h1 id="78bc" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">以二维方式调整图表的大小</h1><p id="f978" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">使用Chart.js的默认行为，图表根据可用宽度而不是高度调整大小，始终保持其初始纵横比。</p><p id="109f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，我们如何让图表在二维空间中调整大小呢？我们绝对不希望一开始就计算出图表的可用空间，然后手动设置纵横比。即使我们做到了这一点，一旦图表绘制完成,<code class="fe kt ku kv kw b">chart.options.aspectRatio</code>也不能被改变。</p><p id="4a82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用CSS网格给我们的布局增加了一点结构，如下所示:</p><pre class="ky kz la lb gt mt kw mu mv aw mw bi"><span id="9c49" class="mx lr iq kw b gy my mz l na nb">.grid {<br/> display: grid;<br/> gap: 1em;<br/> grid-template-rows: min-content 1fr min-content;<br/> grid-template-columns: 1fr 3fr;<br/> grid-template-areas: "a h"<br/>                      "a c"<br/>                      "a f";<br/> height: calc(100vh - 2em);<br/> width: calc(100vw - 2em); /* not necessary, but just to be explicit */<br/> margin: 1em;<br/>}</span></pre><p id="250c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是图表的默认行为:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi nc"><img src="../Images/df642e7e665058f8e1dc7c8cf9a6d243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*VlwvuSBdplNOqrlKw8PAkA.gif"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated"><a class="ae kl" href="https://codepen.io/noraspice/pen/GRQQmaY" rel="noopener ugc nofollow" target="_blank">查看钢笔。</a></figcaption></figure><p id="fbc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您会注意到，当视窗变大时，图表会调整大小(保持纵横比)，但当视窗变小时，图表不会调整大小。我们希望图表能够:</p><ul class=""><li id="238e" class="nd ne iq jp b jq jr ju jv jy nf kc ng kg nh kk ni nj nk nl bi translated">填充垂直和水平空间</li><li id="56cf" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">如果视口在任一方向上变小，则调整大小</li></ul><p id="258f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一项任务很简单。如果我们将<code class="fe kt ku kv kw b">maintainAspectRatio</code>设置为false，图表将在第一次加载时填充水平和垂直的可用空间。此外，它还可以根据可变的纵横比调整大小。这让我们离我们想要的更近了一点:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi nc"><img src="../Images/f32aa86440b16c2391e53fcef44e3509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Bf0L_dLMATUR81T2ub-QFA.gif"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated"><a class="ae kl" href="https://codepen.io/noraspice/pen/YzeeLLy" rel="noopener ugc nofollow" target="_blank">自己试试这支笔</a>。</figcaption></figure><p id="3f07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是同样，你会注意到图表只会变得更大！这是因为Chart.js在其包含的元素改变尺寸时重新呈现画布<a class="ae kl" href="https://www.chartjs.org/docs/latest/configuration/responsive.html#important-note" rel="noopener ugc nofollow" target="_blank">:</a></p><blockquote class="km kn ko"><p id="011d" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">检测画布大小何时改变不能直接从canvas元素中完成。Chart.js使用其父容器来更新画布渲染和显示大小。</p></blockquote><p id="9ae5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用我们当前的CSS网格设置，当视窗变小时，图表的容器元素(它是一个网格项)不会调整大小；<em class="kp">图表本身阻止了它这样做</em>。因此，永远不会触发重新渲染。您可能会发现这种行为有些出乎意料。毕竟，我们设置了网格的高度和宽度，包含图表的网格项的轨道高度为<code class="fe kt ku kv kw b">1fr</code>，宽度为<code class="fe kt ku kv kw b">3fr</code>。那是可用宽度的三分之一，对吗？算是吧。</p><p id="b8dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kt ku kv kw b">3fr</code>其实是<code class="fe kt ku kv kw b">minmax(auto, 3fr)</code>的简称。而网格项的<code class="fe kt ku kv kw b">auto</code>维度是由其内容决定的<a class="ae kl" href="https://www.w3.org/TR/css3-grid-layout/#min-size-auto" rel="noopener ugc nofollow" target="_blank">。网格项目不会变得比其内容小，除非:</a></p><ul class=""><li id="9f7c" class="nd ne iq jp b jq jr ju jv jy nf kc ng kg nh kk ni nj nk nl bi translated">它将溢出设置为可视之外的内容</li><li id="294e" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">它或它的网格轨迹具有确定的(不是分数的)宽度</li><li id="9c19" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">它的网格轨迹的最小宽度是显式设置的</li></ul><p id="2191" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用以上任何一种方法来解决我们的问题，但最简单的是最后一种方法。我们可以用<code class="fe kt ku kv kw b">minmax(0, 3fr)</code>代替<code class="fe kt ku kv kw b">3fr</code>。现在我们有:</p><pre class="ky kz la lb gt mt kw mu mv aw mw bi"><span id="7fb8" class="mx lr iq kw b gy my mz l na nb">.grid {<br/> display: grid;<br/> gap: 1em;<br/> grid-template-rows: min-content minmax(0, 1fr) min-content;<br/> grid-template-columns: 1fr minmax(0, 3r);<br/> grid-template-areas: "a h"<br/>                      "a c"<br/>                      "a f";<br/> height: calc(100vh - 2em);<br/> width: calc(100vw - 2em); /* not necessary, but just to be explicit */<br/> margin: 1em;<br/>}</span></pre><p id="1ae0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这允许栅格轨迹收缩到0宽度。因此，图表的父元素(在本例中是网格项目的<code class="fe kt ku kv kw b">figure</code>元素)会调整大小，并触发图表的重新呈现:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi nc"><img src="../Images/3b19f99067eb633b54db227a17d09f72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0m5RMNS-3KFO9PrrSAHClQ.gif"/></div></div></figure><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi nc"><img src="../Images/3b19f99067eb633b54db227a17d09f72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0m5RMNS-3KFO9PrrSAHClQ.gif"/></div></div></figure><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi nc"><img src="../Images/3b19f99067eb633b54db227a17d09f72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0m5RMNS-3KFO9PrrSAHClQ.gif"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated"><a class="ae kl" href="https://codepen.io/noraspice/pen/GRQQdzW" rel="noopener ugc nofollow" target="_blank">这是CodePen </a>上的全面响应解决方案。</figcaption></figure><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi nc"><img src="../Images/3b19f99067eb633b54db227a17d09f72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0m5RMNS-3KFO9PrrSAHClQ.gif"/></div></div></figure><h1 id="7636" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">结论</h1><p id="dd9a" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">这是一个非常具体的问题，但是追踪解决方案让我更好地理解了网格项目是如何调整大小的，以及为什么有时会导致意外的溢出行为。关于这方面的更多内容，请参阅戴夫·鲁伯特的文章<a class="ae kl" href="https://daverupert.com/2017/09/breaking-the-grid/" rel="noopener ugc nofollow" target="_blank">打破网格</a>，以及<a class="ae kl" href="https://codepen.io/noraspice/pen/oNEoKYj?editors=1100" rel="noopener ugc nofollow" target="_blank">这支带有一堆网格示例的笔</a>。</p></div></div>    
</body>
</html>