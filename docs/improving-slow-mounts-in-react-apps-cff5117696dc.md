# 改善 React 应用中的缓慢装载

> 原文：<https://itnext.io/improving-slow-mounts-in-react-apps-cff5117696dc?source=collection_archive---------1----------------------->

![](img/d31ce7fefaede519cf14f76068c58741.png)

有[百万篇文章](/what-to-do-when-your-react-app-feels-slow-3744c966ddf)关注如何通过移除不必要的重新渲染来提高应用速度&防止不必要的组件更新，但是没有一篇文章谈到一个必要的渲染:初始挂载。

## 介绍

这是因为有一种理论认为在那里做不了多少事情。当你有一个空屏幕，你想渲染一个组件，你必须支付它的挂载价格。这包括 React 需要做的创建[虚拟 DOM](https://reactjs.org/docs/faq-internals.html) 的工作，以及 HTML 的实际[渲染。大多数时候，这个时间量是可以忽略的，甚至不会被人眼察觉。但是，有时您必须呈现由大量其他子组件组成的组件列表，这迫使 React 在您可以看到屏幕上的内容之前进行大量的工作&计算。你知道我在说什么吗？当你导航到一个特定的页面或标签，你感觉你的导航没有 100%的响应时，就是这组项目被渲染；就好像在你点击链接和显示你想要的东西之间有一个时间差。](https://reactjs.org/docs/reconciliation.html)

当我们开发人员将短语“组件列表”放在“性能问题”旁边时，我们的思维被训练成思考“窗口和虚拟化”。虽然虚拟列表**在某些情况下可能是答案，但是在某些情况下，项目列表不够大，不足以保证使用这种技术。在这些情况下，虚拟化库的内部计算比我们一次渲染整个项目列表的成本要高得多。想象一个由 20 张脸书/推特卡片组成的列表，每张卡片由 100 个子组件组成，一个屏幕可以同时显示 5-6 张脸书/推特卡片。大多数情况下，一次渲染全部 20 张卡片比根据滚动位置进行必要的基于滚动的计算来渲染正确的**卡片更容易。****

一个好的思路是让你确认你只渲染屏幕上可见的东西，而把任何不可见的东西(比如模态、弹出窗口、工具提示)留到以后，这样就限制了 React 必须在幕后维护的组件树的深度。这是一个很棒的技术，肯定会产生效果，但是如果在这个领域没有什么可做的了呢？如果实际的延迟来自于组件组成、React 上下文读取、客户端缓存条目识别和反规范化、昂贵的计算等等，那该怎么办？？

## 方法

如果你在屏幕后面点头表示同意，那么你需要的是推迟渲染。我听到你问这是什么？嗯，这是一种声明性地延迟某些组件的呈现的能力，以便将单个阻塞 React 工作负载分割成更小的块。就是说反应“几毫秒后渲染那个组件没问题，我不介意”的选项。这实际上是将 React 渲染 20 个昂贵组件所需的 200 毫秒分割成 50 毫秒的块，每次渲染 5 个组件。

这并不意味着我们并行渲染，因为 JS 仍然是单线程的。我们所做的是将这些渲染块一个接一个地排队，同时在它们之间留出用户输入的空间。类似于 Webpack 思想，理想的块大小取决于组件的数量和复杂性。在上面的例子中，使用 10 个由 2 个组件组成的渲染块可能比使用 2 个由 10 个组件组成的渲染块更好。您需要自己测试它，为您的特定组件集找到块大小的最佳点。

那么，我们如何实现这一点呢？嗯，其实超级简单。我们取一个项目列表，把它分成块，呈现第一个块，让给用户，呈现第二个块，让给用户，等等。我们需要的是在渲染过程的暂停和恢复之间交替。在 JS 领域，这被翻译成 [**微任务**](https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth) 。我们渲染一些项目，将一个任务排队以渲染更多的项目，等待这些项目被渲染，将另一个任务排队以渲染更多的项目，等等。所有这些都可以作为 React 实用程序组件来实现，如下所示:

推迟其子组件呈现的实用程序组件

它可以这样使用:

使用“延迟”一次渲染 5 张卡片

上面这段代码所做的是从立即呈现第一个项目块(给定为`children`)开始，然后让一个微任务排队来呈现另一个项目块。每当主线程上有[空闲时间或经过 200 毫秒后(以先发生者为准),该微任务将被执行。这将持续到所有项目都被渲染。有趣的是，`requestIdleCallback`只有在`renderedItemsCount`改变时才会被注册，以试图限制同时存在于单个进程节拍中的微任务的数量。请记住，这个微任务最多有 16 毫秒的执行时间，这意味着理想的块渲染时间应该不超过 16 毫秒。如果微任务占用的时间明显更多，Chrome 会发出控制台警告，但如果微任务占用的时间多一点，也不是世界末日。这种方法的 UX 优势超过了稍长的微任务的成本。](https://developers.google.com/web/updates/2015/08/using-requestidlecallback)

有趣的是，这整个想法并不新鲜。事实上，这正是 [React 在 v16.x.x .及以上版本的引擎盖下](https://github.com/acdlite/react-fiber-architecture/blob/master/README.md)所做的。它有效地开始在一个微任务中渲染一个组件，不断地检查是否已经过了 16 毫秒，如果已经过了 16 毫秒就暂停所有当前的工作，并在事件循环的下一个滴答中从它停止的地方继续。有趣的是，相同的逻辑可以应用于这两种情况，只是在不同的层上。

## 结束语

我在这里的总体目标是介绍一种技术，以帮助增加你的 UX 时，安装沉重的组件。事实上，这种方法并不局限于列表。通过指定`chunkSize={1}`,您也可以将它用于单个组件，从而将某个“沉重”部分的渲染延迟得足够短，以至于用户不会察觉到它，但是延迟得足够长，以消除整个组件安装上的任何滞后。

如果你想看这个的演示，我已经链接了一个展示这个的代码沙箱。这个演示是故意滞后的，目的是清楚地展示这两种方法的区别。

确保你和`chunkSize`一起玩，看看什么对你来说感觉更好。

非常感谢你的阅读！

*👋 ***嗨，我是***[***Aggelos***](https://aggelosarvanitakis.me/)***！如果你喜欢这个，可以考虑在推特上关注我或者*** [***中***](https://medium.com/@aggelosarvanitakis) **😀***