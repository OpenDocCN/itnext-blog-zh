<html>
<head>
<title>JavaScript Closure for Privacy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保护隐私的JavaScript闭包</h1>
<blockquote>原文：<a href="https://itnext.io/javascript-closure-for-privacy-8a40c274192e?source=collection_archive---------2-----------------------#2018-05-29">https://itnext.io/javascript-closure-for-privacy-8a40c274192e?source=collection_archive---------2-----------------------#2018-05-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/fc348758ac3267b60ae2ec57ca040e9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/0*aUfuBc5k38ZMvrEd.png"/></div></figure><p id="750e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">每当我搜索JavaScript闭包的例子时，我总是会遇到这样的情况:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="5bcb" class="le lf it la b gy lg lh l li lj">const multiplier = (factor) =&gt; {<br/>  return ((value) =&gt; {<br/>    return factor * value;<br/>  });<br/>};</span><span id="729b" class="le lf it la b gy lk lh l li lj">const doubler = multiplier(2);</span><span id="56e4" class="le lf it la b gy lk lh l li lj">console.log(doubler(9)); // 18</span></pre><p id="40fe" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这做了一个教科书般的工作，显示JavaScript闭包的基础结构，显示<code class="fe ll lm ln la b">multiplier</code>返回一个冻结的函数，其中函数保留其外部作用域的变量——在本例中是变量<code class="fe ll lm ln la b">factor</code>。</p><p id="4f9d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">尽管每次我看到上面这样的例子，我都忍不住想知道为什么人们不这样做:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="3cdb" class="le lf it la b gy lg lh l li lj">const product = (num1, num2) =&gt; {<br/>  return num1 * num2;<br/>}</span><span id="1be3" class="le lf it la b gy lk lh l li lj">console.log(producut(2, 9)); // 18</span></pre><p id="a3da" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">直到我开始研究闭包和隐私，我才意识到闭包在JavaScript中是多么有用和重要。</p><h1 id="4263" class="lp lf it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">示例:员工注册</h1><p id="5a6f" class="pw-post-body-paragraph jx jy it jz b ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku im bi translated">假设我们负责跟踪一家全新创业公司的所有员工。利用一些面向对象的设计，我们把这些代码放在一起。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="2926" class="le lf it la b gy lg lh l li lj">let employeeId = 0;</span><span id="e2c5" class="le lf it la b gy lk lh l li lj">class Employee {<br/>  constructor(name, role) {<br/>    this.name = name;<br/>    this.role = role;<br/>    this.id = ++employeeId;<br/>  }<br/>}</span><span id="a8d2" class="le lf it la b gy lk lh l li lj">const kevin = new Employee('Kevin', 'Developer');<br/>const george = new Employee('George', 'HR');</span><span id="f137" class="le lf it la b gy lk lh l li lj">console.log(kevin); <br/>// Employee { name: 'Kevin', role: 'Developer', id: 1 }</span><span id="e727" class="le lf it la b gy lk lh l li lj">console.log(george); <br/>// Employee { name: 'George', role: 'HR', id: 2 }</span><span id="f0c0" class="le lf it la b gy lk lh l li lj">console.log(employeeId); //2</span></pre><p id="cf6d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这工作得不错，但是我们的<code class="fe ll lm ln la b">employeeId</code>暴露在荒野中，很容易被覆盖！</p><p id="2c1e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">例如，我们可以将<code class="fe ll lm ln la b">employeeId</code>分配给完全随机的东西，我们下一个员工的id看起来会很傻。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="19d7" class="le lf it la b gy lg lh l li lj">employeeId = 'gibberish';<br/>const jerry = new Employee('Jerry', 'Sales');<br/>console.log(jerry);<br/>// Employee { name: 'Jerry', role: 'Sales', id: NaN }</span></pre><h2 id="0997" class="le lf it bd lq mr ms dn lu mt mu dp ly ki mv mw mc km mx my mg kq mz na mk nb bi translated">输入结束</h2><p id="19aa" class="pw-post-body-paragraph jx jy it jz b ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku im bi translated">为了解决这个问题，我们可以利用闭包，像这样将我们的<code class="fe ll lm ln la b">employeeId</code>变量夹在中间:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="7a48" class="le lf it la b gy lg lh l li lj">function createEmployee() {<br/>  let employeeId = 0;<br/>  return class {<br/>    constructor(name, role) {<br/>      this.name = name;<br/>      this.role = role;<br/>      this.id = ++employeeId;<br/>    }<br/>  }<br/>}</span><span id="c0d6" class="le lf it la b gy lk lh l li lj">const Employee = createEmployee();</span></pre><p id="dc2a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">此时，我们的<code class="fe ll lm ln la b">employeeId</code>变量从<code class="fe ll lm ln la b">createEmployee()</code>的外部<em class="lo">关闭</em>，但是在<code class="fe ll lm ln la b">createEmployee()</code>返回的函数内部可以访问。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="4725" class="le lf it la b gy lg lh l li lj">const kevin = new Employee('Kevin', 'Developer');<br/>const george = new Employee('George', 'HR');</span><span id="0a73" class="le lf it la b gy lk lh l li lj">console.log(kevin); <br/>// Employee { name: 'Kevin', role: 'Developer', id: 1 }</span><span id="78ea" class="le lf it la b gy lk lh l li lj">console.log(george); <br/>// Employee { name: 'George', role: 'HR', id: 2 }</span><span id="1050" class="le lf it la b gy lk lh l li lj">console.log(employeeId); <br/>// ReferenceError: employeeId is not defined</span></pre><p id="de43" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，即使我们在<code class="fe ll lm ln la b">createEmployee()</code>函数之外分配我们的<code class="fe ll lm ln la b">employeeId</code>值，这也不会破坏我们编写的雇员创建函数。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="b963" class="le lf it la b gy lg lh l li lj">employeeId = 'gibberish'; <br/>// this employeeId !== employeeId inside createEmployee()</span><span id="2321" class="le lf it la b gy lk lh l li lj">const jerry = new Employee('Jerry', 'Sales');</span><span id="500c" class="le lf it la b gy lk lh l li lj">console.log(jerry);<br/>// { name: 'Jerry', role: 'Sales', id: 3 }</span></pre><h1 id="bec0" class="lp lf it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">结束语</h1><p id="b19b" class="pw-post-body-paragraph jx jy it jz b ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku im bi translated">对我来说，使用闭包从外部关闭变量访问确实帮助我看到了闭包的实际用途。希望您发现这个创建员工id的演练是一个利用JavaScript闭包的真实例子。</p><p id="272a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="lo">感谢阅读！如果你喜欢这篇博文，请随意留下一些掌声并关注我！</em></p></div></div>    
</body>
</html>