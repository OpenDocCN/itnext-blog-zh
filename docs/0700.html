<html>
<head>
<title>CORS — Understanding it practically</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CORS——从实际出发理解它</h1>
<blockquote>原文：<a href="https://itnext.io/cors-understanding-it-practically-9c401ed818cd?source=collection_archive---------1-----------------------#2018-05-10">https://itnext.io/cors-understanding-it-practically-9c401ed818cd?source=collection_archive---------1-----------------------#2018-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4ccf33069f2098ede71c944ee304cad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5FBObjeM-t6kok0prSTPpg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">资源共享…</figcaption></figure><p id="084a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">跨源资源共享(<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Glossary/CORS" rel="noopener ugc nofollow" target="_blank"> CORS </a>)是一种机制，它使用额外的<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Glossary/HTTP" rel="noopener ugc nofollow" target="_blank"> HTTP </a>报头，让<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Glossary/user_agent" rel="noopener ugc nofollow" target="_blank">用户代理</a>获得从不同源(域)的服务器访问选定资源的许可，而不是当前使用的站点。(资料来源:MDN)</p><p id="17f6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">关于CORS的美丽描述请访问@ MDN。<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS</a></p><p id="e0d6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我对跨源资源共享实际上是如何工作的有很多困惑。是浏览器停止了XMLHttpRequest调用吗？是服务器来停止通话吗？跨源请求到达服务器了吗？如果服务器不支持CORS，我们实际上可以用什么方法继续开发呢？</p><p id="cf51" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这篇文章中，我们想以一种实用的方式来回答这些问题。此外，本文假设您对CORS有一个基本的了解。</p><p id="c336" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">设置:</strong></p><p id="ee95" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我在本地Tomcat上运行了一个非常基本的J2EE应用程序。这个应用程序公开了一个非常简单的API，它返回一个JSON数据。<a class="ae la" href="http://localhost:8081/e2e/api/" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/e2e/API/</a></p><p id="e818" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">以上API返回:{"id" : "1 "，" value" : "AwesomeAPI"}</p><p id="46cd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于客户端应用程序，我有一个使用angular CLI创建的Angular 5应用程序，运行在<a class="ae la" href="http://localhost:4200." rel="noopener ugc nofollow" target="_blank"> http://localhost:4200上。</a></p><p id="b59a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了看到CORS的行动，我们将从<em class="lb"> Angular app </em>调用<em class="lb"> J2EE app </em>。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><ol class=""><li id="be49" class="lj lk iq ke b kf kg kj kk kn ll kr lm kv ln kz lo lp lq lr bi translated">使用XMLHttpRequest对象。</li></ol><p id="327f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在angular应用程序中，以下代码片段用于从j2EE应用程序访问资源。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="0abb" class="mb mc iq lx b gy md me l mf mg"><em class="lb">var</em> xhttp = new XMLHttpRequest();</span><span id="d9a0" class="mb mc iq lx b gy mh me l mf mg">xhttp.onreadystatechange = <em class="lb">function</em> () {</span><span id="9ee4" class="mb mc iq lx b gy mh me l mf mg">if (this.readyState == 4 &amp;&amp; this.status == 200) {</span><span id="5456" class="mb mc iq lx b gy mh me l mf mg"><em class="lb">console</em>.log(xhttp.responseText);</span><span id="8600" class="mb mc iq lx b gy mh me l mf mg">}</span><span id="79f9" class="mb mc iq lx b gy mh me l mf mg">};</span><span id="cd35" class="mb mc iq lx b gy mh me l mf mg">xhttp.open("GET", "http://localhost:8081/e2e/api/", true);</span><span id="92ad" class="mb mc iq lx b gy mh me l mf mg">xhttp.send();</span></pre><p id="91ab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">java应用程序在servlet的doGet()方法中有以下代码。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="39bb" class="mb mc iq lx b gy md me l mf mg">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {</span><span id="b884" class="mb mc iq lx b gy mh me l mf mg">response.getWriter().println("{\"id\" : \"1\" , \"value\" : \"AwesomeAPI\"}");</span><span id="364b" class="mb mc iq lx b gy mh me l mf mg">}</span></pre><p id="a908" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">上面的角代码在被触发时击中位于localhost:8081的服务器，并且在chrome developer tool的网络选项卡中，我们观察到以下请求和响应:</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/5eb563f6435ac1419631827cb371e98b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wWXQElpsrgHSrCF7pa8IGg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">CORS未启用时的请求-响应。</figcaption></figure><p id="f16c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里需要注意的重要一点是请求头。</p><p id="26cc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">主机指的是托管API的服务器，而源指的是为客户端提供服务的服务器。</p><p id="6a0a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="lb">尽管调用到达API </em>并且响应包含状态为200 OK的预期数据，<em class="lb">浏览器仍然不允许响应数据</em>到达调用者代码。浏览器将抄袭声明:</p><p id="d7a7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">无法加载<a class="ae la" href="http://localhost:8081/e2e/api/abc" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/e2e/API/</a>:请求的资源上不存在“Access-Control-Allow-Origin”标头。原点'<a class="ae la" href="http://localhost:4200'" rel="noopener ugc nofollow" target="_blank"> http://localhost:4200' </a>因此不允许访问。</p><blockquote class="mj mk ml"><p id="3a61" class="kc kd lb ke b kf kg kh ki kj kk kl km mm ko kp kq mn ks kt ku mo kw kx ky kz ij bi translated">来解决这个问题</p></blockquote><p id="2bb5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在响应中添加具有适当值的“Access-Control-Allow-Origin”标头。</p><p id="ad96" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">随着这一变化，API代码将:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="cff5" class="mb mc iq lx b gy md me l mf mg">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {</span><span id="6308" class="mb mc iq lx b gy mh me l mf mg">response.addHeader("Access-Control-Allow-Origin", "*");</span><span id="03e3" class="mb mc iq lx b gy mh me l mf mg">response.getWriter().println("{\"id\" : \"1\" , \"value\" : \"AwesomeAPI\"}");</span><span id="27c9" class="mb mc iq lx b gy mh me l mf mg">}</span></pre><p id="9f44" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里*表示允许从任何来源访问该API。这也可以是特定的原始值，但现在我们继续使用*。</p><p id="2a15" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">再次从位于localhost:4200的客户端启动相同的API，观察到以下请求响应:</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/e869ea8ed8b1d0ca232a0cad56b51685.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SUu1usivafL7URBcGLHBnA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">启用CORS时的请求-响应</figcaption></figure><p id="d087" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因为响应包含Access-Control-Allow-Origin: *，所以浏览器接受响应并允许代码读取相同的内容。参见控制台。</p><p id="b3b1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2.在Angular中使用<a class="ae la" href="https://angular.io/guide/http" rel="noopener ugc nofollow" target="_blank"> HttpClinet </a>库</p><p id="cc77" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以在Angular应用程序中使用<a class="ae la" href="https://angular.io/guide/http" rel="noopener ugc nofollow" target="_blank"> HttpClient </a>库，而不是使用普通的XMLHttpRequest API。这个API返回RxJs可观察值。</p><p id="03da" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">代码:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="af8f" class="mb mc iq lx b gy md me l mf mg">this.httpClient.get("<a class="ae la" href="http://localhost:8081/e2e/api/abc" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/e2e/api/abc</a>").subscribe(data =&gt; {</span><span id="6a2d" class="mb mc iq lx b gy mh me l mf mg">  console.log(data);</span><span id="cb80" class="mb mc iq lx b gy mh me l mf mg">});</span></pre><p id="2f1b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因为HttpClient在内部使用XMLHttpRequest web APIs，所以当启用/禁用CORS时，我们会得到相同的行为。</p><p id="e048" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.当服务器不支持CORS时。</p><p id="3fb2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如前所述，当服务器在响应中添加所需的“Access-Control-Allow-Origin”报头时，CORS开始工作。在我们无法控制服务器响应的情况下，我们需要一个<em class="lb">代理</em>来访问跨源资源。</p><p id="d033" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.1角支撑</p><p id="fc44" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Angular应用开发推荐Node.js开发方式。这意味着我们安装angular CLI作为节点模块，并通过package.json维护依赖关系。</p><p id="6098" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">节点服务器用于服务客户端文件，包括angular框架。</p><p id="ebf6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">默认情况下，节点服务器从<a class="ae la" href="http://localhost:4200." rel="noopener ugc nofollow" target="_blank"> http://localhost:4200开始。</a></p><p id="7b33" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了创建可以将呼叫重定向到其他来源(以支持CORS)的代理，web pack(Angular使用的模块捆绑器)开发服务器提供了支持。</p><p id="01f0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">关于这一点的细节可以在这篇文章中读到:</p><p id="f157" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae la" href="https://github.com/angular/angular-cli/blob/master/docs/documentation/stories/proxy.md" rel="noopener ugc nofollow" target="_blank">https://github . com/angular/angular-CLI/blob/master/docs/documentation/stories/proxy . MD</a></p><p id="d6d0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">基本上，我们希望从angular客户端发出的所有CORS调用都将通过运行在<a class="ae la" href="http://localhost:4200" rel="noopener ugc nofollow" target="_blank"> http://localhost:4200 </a>的节点服务器，服务器将代理调用并返回响应。</p><p id="f860" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="lb">首先:</em></p><p id="b5e6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.1.1位于<a class="ae la" href="http://localhost:8081/e2e/api/" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/e2e/API/</a>的API不支持CORS，不在响应头中添加“Access-Control-Allow-Origin”。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="7831" class="mb mc iq lx b gy md me l mf mg">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {</span><span id="d071" class="mb mc iq lx b gy mh me l mf mg">response.getWriter().println("{\"id\" : \"1\" , \"value\" : \"AwesomeAPI\"}");</span><span id="a308" class="mb mc iq lx b gy mh me l mf mg">}</span></pre><p id="29d2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">客户代码</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="00d3" class="mb mc iq lx b gy md me l mf mg">this.httpClient.get("/<a class="ae la" href="http://localhost:8081/e2e/api/abc" rel="noopener ugc nofollow" target="_blank">e2e/api</a>").subscribe(data =&gt; {</span><span id="dc64" class="mb mc iq lx b gy mh me l mf mg">console.log(data);</span><span id="900e" class="mb mc iq lx b gy mh me l mf mg">});</span></pre><p id="f541" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">服务器响应404，因为API不是通过<a class="ae la" href="http://localhost:4200" rel="noopener ugc nofollow" target="_blank"> http://localhost:4200 </a>提供的</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/504b4475c68b3d97032258cdf905988c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zuM8DWPH4o_iWWVb6YFpKA.png"/></div></div></figure><p id="8504" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.1.3定义一个名为proxy.conf.json的文件，并将其放在package.json旁边</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="5b2d" class="mb mc iq lx b gy md me l mf mg">{<br/>  "/e2e/api": {<br/>    "target": "http://localhost:8081",<br/>    "secure": false,<br/>    "changeOrigin": true<br/>  }<br/>}</span></pre><p id="ab5f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.1.4使用代理配置选项启动服务器</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="a3f9" class="mb mc iq lx b gy md me l mf mg">ng serve --proxy-config proxy.conf.json</span></pre><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/4345d794ee87f7a67688fd3603664791.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d35AprxPn8cR1fXCMEsSyQ.png"/></div></div></figure><p id="98ae" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们得到了回应。观察请求头。Origin不可用，API将通过我们在<a class="ae la" href="http://localhost:4200" rel="noopener ugc nofollow" target="_blank">的代理http://localhost:4200 </a></p><p id="5f0e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当服务器端对CORS的支持不可用时，这实际上是一个通用的API代理解决方案。</p><p id="04e3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">4.无法设置代理时实现CORS。(仅在开发/测试阶段——非生产场景)</p><p id="b0cf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">假设我们有一个场景，我们不能设置服务器代理，只想检查一个API是否符合我们的目的。无论API是否发送正确的数据，在开发阶段，我们都可以使用浏览器插件，将“访问控制允许来源”添加到所有响应中。</p><p id="78d2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">只需为你的浏览器搜索CORS插件。</p><p id="6995" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我添加了<a class="ae la" href="https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi?hl=en" rel="noopener ugc nofollow" target="_blank">https://chrome . Google . com/web store/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi？hl=en </a>用于测试目的。</p><p id="552e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我已经重置了我的角度代码，这样它就可以直接调用<a class="ae la" href="http://localhost:8081/e2e/api" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/e2e/API</a></p><p id="e23d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">api没有发送“Access-Control-Allow-Origin”作为响应，因此调用失败。</p><p id="cb37" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">新增的插件在chrome中提供了以下选项:</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/2532bfb036a2c7f7162c5e88ad7c09bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0c8Ofr402dBHz_DLf4KpAQ.png"/></div></div></figure><p id="d4ab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如设置所示，我已经给出了<a class="ae la" href="http://localhost:8081/e2e/api/*" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/e2e/API/*</a>作为要拦截的URL模式。</p><p id="ec16" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，当客户端在<a class="ae la" href="http://localhost:4200" rel="noopener ugc nofollow" target="_blank"> http://localhost:4200 </a>发出一个调用时，我们得到正确的响应，如下所示:</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/c97a3ec120932fd5aff0f559bd403e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xsi_lU_P9So7GXiIyo_Z6w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">通过浏览器插件添加“访问控制允许来源”标题</figcaption></figure></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="0f84" class="mb mc iq bd ms mt mu dn mv mw mx dp my kn mz na nb kr nc nd ne kv nf ng nh ni bi translated">摘要</h2><p id="b203" class="pw-post-body-paragraph kc kd iq ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz ij bi translated"><strong class="ke ir">总结一下</strong>跨原点资源共享是浏览器出于安全原因而停止的事情。</p><p id="42d2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">浏览器</strong>期望托管API的服务器返回带有适当值的“Access-Control-Allow-Origin”头作为响应。</p><p id="996f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">在</strong>的情况下，服务器不发送所需的报头——可以设置一个代理，该代理最终将是源服务器到主机(api)服务器的调用。Angular通过代理配置文件(proxy.conf.json)提供简单的支持。</p><p id="219d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">如果</strong> API只需要测试(不在生产场景中)，可以使用浏览器插件在响应中添加所需的访问控制头。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="c018" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">感谢阅读:)</p></div></div>    
</body>
</html>