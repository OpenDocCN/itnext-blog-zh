<html>
<head>
<title>Building Git in Elixir — Part 1 (Initialize Repo &amp; Store blobs)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Elixir中构建Git第1部分(初始化Repo &amp; Store blobs)</h1>
<blockquote>原文：<a href="https://itnext.io/building-git-in-elixir-part-1-2f2ec245df74?source=collection_archive---------0-----------------------#2021-03-06">https://itnext.io/building-git-in-elixir-part-1-2f2ec245df74?source=collection_archive---------0-----------------------#2021-03-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="64b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi ko translated">我最近拿到了詹姆斯·科格兰写的《T2建筑指南》。这是一本相当厚的书，正如标题所说，涵盖了使用Ruby编程语言构建Git版本控制系统。当我读这本书的时候，我认为用Elixir实现Git会是一个有趣的练习。本文是一系列文章中的第一篇介绍性文章，重点介绍我用Elixir编程语言实现Git的旅程。</p><p id="0917" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这不是一堂介绍性的编程课。因此，我不打算把重点放在灵丹妙药的概念或图书馆。请参考[1]和[2]。此外，为了收集关于Git内部的详细知识，我建议你阅读上面的书和/或浏览<a class="ae kx" href="https://git-scm.com/docs" rel="noopener ugc nofollow" target="_blank">文档</a>【3】。</p><p id="2626" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为这只是这一系列文章的第1部分，所以我将解释一些我们在这篇文章中试图构建的理论，并逐步实现Elixir。</p><h1 id="84d6" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">一点理论</h1><p id="e6ab" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">Git将其存储库信息存储在。git目录。在一个普通的项目中，我们输入<strong class="js iu"> <em class="mb"> </em> git init <em class="mb">，</em> </strong>。git目录如下所示—</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/fb742fa5bf7606fd3e5070934d304cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2N-tZjFddQwKI96sg9ApmA.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">git存储库结构</figcaption></figure><p id="92e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简单概述一下——</p><ul class=""><li id="089b" class="ms mt it js b jt ju jx jy kb mu kf mv kj mw kn mx my mz na bi translated"><strong class="js iu"> HEAD </strong> —包含对当前提交的引用，使用提交ID或对当前分支的符号引用</li><li id="cd89" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><strong class="js iu">配置</strong> —包含此存储库的配置设置</li><li id="dc06" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><strong class="js iu">描述</strong> —包含存储库的名称</li><li id="89c1" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><strong class="js iu">钩子</strong> —包含由各种git命令执行的各种脚本</li><li id="a35c" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><strong class="js iu">信息</strong> —包含关于存储库的各种元数据信息</li><li id="6dd8" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><strong class="js iu">对象<em class="mb"> — </em> </strong>这是git的数据库，包含了它跟踪的所有内容<strong class="js iu"> <em class="mb">。在本文中，我们将主要关注构建和填充这个目录</em> </strong></li><li id="faa6" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><strong class="js iu">引用</strong> —将各种指针存储到<strong class="js iu">中。git/objects </strong>数据库。最重要的是，<strong class="js iu">。git/refs/heads </strong>存储每个本地分支和<strong class="js iu">上的最新提交。git/refs/tags </strong>存储标签</li></ul><p id="89a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">提交一个示例<strong class="js iu"> hello.txt </strong>文件后，内容<strong class="js iu"> hello </strong>如下—</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ng"><img src="../Images/c611c092daf195843d8aa24157257e61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UQCmXoZtTe3Kifl5k2kuBw.png"/></div></div></figure><p id="a537" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">储存库结构看起来如下，有一些新的目录和文件—</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nh"><img src="../Images/81d45aa88b781cd468c52f881c09338d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aKxMnfQhuka1fLud4ebTbw.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">初始提交后的存储库结构</figcaption></figure><p id="eb3e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><ul class=""><li id="ee2b" class="ms mt it js b jt ju jx jy kb mu kf mv kj mw kn mx my mz na bi translated"><strong class="js iu">提交编辑消息</strong> —包含给定的提交消息</li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/2b9ec29b2e78edb2f2783288744ac654.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uTRBJ5xKDCzvRAb6tKJJBw.png"/></div></div></figure><ul class=""><li id="df74" class="ms mt it js b jt ju jx jy kb mu kf mv kj mw kn mx my mz na bi translated"><strong class="js iu">索引</strong> —包含用于构建下一次提交的二进制数据</li><li id="0a46" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><strong class="js iu">日志</strong>——包含<strong class="js iu">参考日志</strong>命令使用的各种日志</li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ni"><img src="../Images/d68111feb4847799000bcc1fd66b4a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D-vZdgqoOGfvJd6zhCLrsA.png"/></div></div></figure><ul class=""><li id="9bd2" class="ms mt it js b jt ju jx jy kb mu kf mv kj mw kn mx my mz na bi translated"><strong class="js iu">新对象/ &lt;子目录&gt; </strong> —一些新的子目录是用加密哈希作为文件名创建的。如果我们检查其中一个由<strong class="js iu"> git log </strong>命令打印的ID—</li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nj"><img src="../Images/5f3ae017f564f346e5dcfeb416a07907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SPAtYaXl9Ky7-V63TlXpcg.png"/></div></div></figure><p id="9d92" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从提交ID中，我们可以看到它匹配了一个<strong class="js iu">对象</strong>子目录—</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nk"><img src="../Images/35ea687a98394508fa56c44968b54d54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U0CTqnZNS9xFbicK2v64jA.png"/></div></div></figure><p id="66f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以使用<strong class="js iu"> git cat-file -p </strong>来显示git数据库中关于这个对象的信息</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/5e52e2a3b86406385e83e5530fffbb0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LO_sQwN0mZnLRSmrIz6mUA.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">关于对象的信息</figcaption></figure><p id="dfeb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的输出引用了一个提交ID为<strong class="js iu">aa 96 ce D2 9 a 1 c 8 e 72 c 56 b 253 a 0 e 2 Fe 78393 feb 7</strong>的树</p><p id="e572" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以使用类似的命令来检查这个对象—</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nk"><img src="../Images/434afeb8af51d4c34d974cfd9cb082ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oKeqJz82hjULTU-kUKTBuw.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">树表示</figcaption></figure><p id="2ce0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从输出中我们可以看到这个树引用了另一个提交ID<strong class="js iu">ce 013625030 ba 8d ba 906 f 756967 f 9 e 9 ca 394464 a</strong>，它代表了文件<strong class="js iu"> hello.txt. </strong></p><p id="a16c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用相同的命令检查这个提交显示—</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nj"><img src="../Images/aa75b122dea592359f679b9f8895eeb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TUr_GzMMpAa5z5V47EmR0w.png"/></div></div></figure><p id="d56b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，为了检查git如何在文件系统中存储对象，我们可以这样做—</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ni"><img src="../Images/ba96d5b97f538f4fedfeca7ac10c77a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0mxIoBT8YMbOSURYB9E_sg.png"/></div></div></figure><p id="7274" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出显示了文件系统上对象blob的压缩内容。</p><p id="f6bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这本书提供了一个方便的命令来膨胀压缩的内容—</p><pre class="md me mf mg gt nl nm nn no aw np bi"><span id="903f" class="nq kz it nm b gy nr ns l nt nu">alias inflate='ruby -r zlib -e "STDOUT.write Zlib::Inflate.inflate(STDIN.read)"'</span></pre><p id="35ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用这个命令，我们可以看到这个对象的明文内容—</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nv"><img src="../Images/1b21ff88bf8c1e7a0f9874905a343c52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vvkWtsjNSan6B36L54v47Q.png"/></div></div></figure><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nj"><img src="../Images/cdf45f1d6828b1ab925a0b9f4ebbbdcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z3vs9Twt2H9FwHydrlsdyA.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">对膨胀的blob应用了hexdump命令</figcaption></figure><p id="765f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="mb">正如我们所看到的，git存储blob的方式是在它们前面加上单词blob、一个空格、blob的长度、一个空字节，然后是使用zlib压缩的内容。</em> </strong></p><h1 id="292e" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">本文的重点</h1><p id="bd99" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">在本文中，我的重点是从零开始，构建两个命令—</p><ul class=""><li id="d536" class="ms mt it js b jt ju jx jy kb mu kf mv kj mw kn mx my mz na bi translated">git init——它将初始化。仅带有<strong class="js iu">对象</strong>和<strong class="js iu">引用</strong>目录的git</li><li id="5bfa" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated">git commit  —这将使用当前工作目录中的任何文件创建对象数据库</li></ul><p id="73db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="mb">在本文中，我不会关注树或提交历史或消息。这将是未来某个项目的重点。</em> </strong></p><p id="117e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从现在开始，我将使用它的可执行名称来指代这个elixir版本— <strong class="js iu"> egit </strong></p><h1 id="45a0" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">仙丹代码演练</strong></h1><p id="3b34" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">本文的源代码可以从https://github.com/imeraj/elixir_git的<a class="ae kx" href="https://github.com/imeraj/elixir_git" rel="noopener ugc nofollow" target="_blank">获得</a></p><p id="cfde" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它包含一个关于如何构建可执行文件和使用<strong class="js iu"> git init </strong>和<strong class="js iu"> commit </strong>命令的<strong class="js iu"> README </strong>文件。</p><h2 id="4b63" class="nq kz it bd la nw nx dn le ny nz dp li kb oa ob lm kf oc od lq kj oe of lu og bi translated">解析命令行参数</h2><p id="ed54" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">cli.ex 执行命令行参数解析-</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="ce0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，</p><ul class=""><li id="deb0" class="ms mt it js b jt ju jx jy kb mu kf mv kj mw kn mx my mz na bi translated"><strong class="js iu"> parse_args </strong>(第12 -17行)—解析命令行参数并为内部处理命令创建元组—</li></ul><blockquote class="oj ok ol"><p id="8ac3" class="jq jr mb js b jt ju jv jw jx jy jz ka om kc kd ke on kg kh ki oo kk kl km kn im bi translated">{:init，dir} → for egit init</p><p id="0cc3" class="jq jr mb js b jt ju jv jw jx jy jz ka om kc kd ke on kg kh ki oo kk kl km kn im bi translated">{:commit，dir} → for egit提交</p></blockquote><p id="9728" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> egit init </strong>命令也可以将可选目录作为参数。如果什么都没有传递，它将创建。当前工作目录中的git目录。</p><ul class=""><li id="3a46" class="ms mt it js b jt ju jx jy kb mu kf mv kj mw kn mx my mz na bi translated"><strong class="js iu">进程</strong>(第51–57行)—处理解析的命令行参数，并调用初始化和提交所需的模块</li></ul><h2 id="e452" class="nq kz it bd la nw nx dn le ny nz dp li kb oa ob lm kf oc od lq kj oe of lu og bi translated">助手模块</h2><p id="3c00" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated"><strong class="js iu"> helpers.ex </strong>提供了一些助手功能—</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="3e85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><ul class=""><li id="6b35" class="ms mt it js b jt ju jx jy kb mu kf mv kj mw kn mx my mz na bi translated"><strong class="js iu"> git_path </strong>(第6–9行)—为。git目录</li><li id="aa5a" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><strong class="js iu"> db_path </strong>(第11–14行)—为对象构建db路径</li><li id="5a49" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><strong class="js iu"> ls_r </strong>(第16–30行)—列出当前工作目录下的所有文件，包括所有子目录</li><li id="a68f" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><strong class="js iu"> generate_random_string </strong>(第33–38行)——生成给定长度的随机字母数字字符串</li></ul><h2 id="0a9b" class="nq kz it bd la nw nx dn le ny nz dp li kb oa ob lm kf oc od lq kj oe of lu og bi translated">实现e <em class="op"> git init </em></h2><p id="6cce" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated"><strong class="js iu"> init.ex </strong>执行init命令—</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="2e6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><ul class=""><li id="bd59" class="ms mt it js b jt ju jx jy kb mu kf mv kj mw kn mx my mz na bi translated"><strong class="js iu"> init </strong>(第8–12行)—使用路径调用，其中。应该创建git目录</li><li id="22d9" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated">make_dirs (第14- 28行)——在. git下创建目录。现在它只创建<strong class="js iu">。git/objects </strong>和。如果。git尚不存在。</li><li id="ad55" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><strong class="js iu">第26行</strong> —打印消息，如果。git目录已正确初始化</li></ul><h2 id="eb7a" class="nq kz it bd la nw nx dn le ny nz dp li kb oa ob lm kf oc od lq kj oe of lu og bi translated">实施egit提交</h2><p id="f89f" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated"><strong class="js iu"> commit.ex </strong>执行提交命令—</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="9f75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，</p><ul class=""><li id="58a9" class="ms mt it js b jt ju jx jy kb mu kf mv kj mw kn mx my mz na bi translated"><strong class="js iu">提交</strong>(第8–20行)——执行提交命令。现在，它提交当前目录和任何子目录中的所有文件。</li></ul><p id="33ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我会更深入地讨论这里发生了什么—</p><ul class=""><li id="f638" class="ms mt it js b jt ju jx jy kb mu kf mv kj mw kn mx my mz na bi translated"><strong class="js iu">第9行</strong> —列出当前目录下的所有文件，包括所有子目录。</li></ul><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="eaf1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它依靠辅助函数<strong class="js iu"> ls_r() </strong>来完成这项工作</p><ul class=""><li id="d123" class="ms mt it js b jt ju jx jy kb mu kf mv kj mw kn mx my mz na bi translated"><strong class="js iu">第10–14行— </strong>对于在上述步骤中获得的任何文件，它将使用文件内容构建一个BLOB结构，并写入对象数据库。</li></ul><p id="23b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">BLOB结构模块(<strong class="js iu"> blob.ex) </strong>如下所示—</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="648b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个结构有两个字段——数据<strong class="js iu">和T42 oid</strong>(我将很快讨论oid<strong class="js iu">和T45)</strong></p><p id="b083" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> database.ex </strong>提供数据库模块，并完成大部分填充对象目录的繁重工作——</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="6ccc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><ul class=""><li id="ec53" class="ms mt it js b jt ju jx jy kb mu kf mv kj mw kn mx my mz na bi translated"><strong class="js iu">第10行</strong> —使用以下结构构建内容:blob单词、一个空格、blob长度和一个空字节，后跟字符串形式的明文文件内容</li><li id="3daf" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><strong class="js iu">第11行</strong> —使用内容上的SHA-1构建对象ID哈希</li><li id="1cd1" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><strong class="js iu">第12行</strong>——实际写blobs的工作</li><li id="44cc" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><strong class="js iu">第19行</strong> —通过连接oid的前两个字符和其余字符，从db_path构建object_path。因此，我们得到一个路径，比如—<strong class="js iu">db _ path/&lt;2 chars&gt;/&lt;rest chars&gt;</strong>，它表示对象数据库中的以下内容—</li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi oq"><img src="../Images/7bd5eb3e0fceb08428420d871e590f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_d6qQGR7KG_YQwtQaeNGpQ.png"/></div></div></figure><ul class=""><li id="e66f" class="ms mt it js b jt ju jx jy kb mu kf mv kj mw kn mx my mz na bi translated"><strong class="js iu">第21行</strong> —使用<strong class="js iu"> generate_temp_name </strong>()函数创建一个临时文件路径，该函数以与实际Git相同的格式创建文件名。代码首先在这个临时路径中写入blob，然后将其重命名为实际的object_path ( <strong class="js iu"> line 41 </strong>)。</li><li id="e3cc" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><strong class="js iu">第23–35行:</strong>以读、写和独占模式创建临时文件，这样如果文件已经存在，它就会出错(以防我们的临时文件名发生冲突)。</li><li id="ea21" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><strong class="js iu">第37行</strong>:压缩内容</li><li id="dc82" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><strong class="js iu">第38–39行</strong>:写入压缩内容并关闭文件</li></ul><h1 id="1fed" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">带着埃吉特去兜风</h1><p id="1aeb" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">既然已经实现了egit init和commit，那么让我们来看看egit，并与真正的git的数据库进行比较。</p><p id="6cbf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">初始化repo并提交内容为<strong class="js iu"> hello </strong>的文件<strong class="js iu"> hello.txt </strong>的示例会话如下所示</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/a175ce29f12f4684cea0a49b031ead93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5B4bjTACaeuDAdt5AjmCLQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">与egit的会议</figcaption></figure><p id="d44e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><ul class=""><li id="637a" class="ms mt it js b jt ju jx jy kb mu kf mv kj mw kn mx my mz na bi translated">我初始化了。目录位置egit处的git</li><li id="a6ea" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><strong class="js iu">树。git </strong>显示下面是什么。在<strong class="js iu">开始初始化</strong>之后立即git</li><li id="8729" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated">我用“hello”作为内容创建了hello.txt</li><li id="dc28" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><strong class="js iu">树。git </strong>显示了下面的内容。git在<strong class="js iu"> egit提交</strong>之后</li><li id="6ae1" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated">最后，带有inflate和hexdump的cat以纯文本形式显示对象数据库blob的内容，这表明数据以与真实Git相似的格式存储</li></ul><h1 id="0680" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="2c61" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">在这些文章系列的第1部分中，我已经从头开始实现了<strong class="js iu"> egit init </strong>和<strong class="js iu"> egit commit </strong>(非常基本的)命令，并展示了与真实git版本控制系统相比较的输出。本系列的后续文章将随着我阅读本书— <a class="ae kx" href="https://shop.jcoglan.com/building-git/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">构建Git </strong> </a>的进展，继续在Elixir中添加和改进更多的命令。</p><p id="b38b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mb">更多详细和深入的未来技术帖子，请关注我这里或上</em><a class="ae kx" href="https://twitter.com/meraj_enigma" rel="noopener ugc nofollow" target="_blank"><em class="mb">Twitter</em></a><em class="mb">。</em></p><h1 id="c2f3" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">参考</h1><ol class=""><li id="f5c3" class="ms mt it js b jt lw jx lx kb or kf os kj ot kn ou my mz na bi translated"><a class="ae kx" href="https://elixir-lang.org/getting-started/introduction.html" rel="noopener ugc nofollow" target="_blank">https://elixir-lang.org/getting-started/introduction.html</a></li><li id="6b78" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn ou my mz na bi translated"><a class="ae kx" href="https://elixir-lang.org/docs.html" rel="noopener ugc nofollow" target="_blank">https://elixir-lang.org/docs.html</a></li><li id="e129" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn ou my mz na bi translated"><a class="ae kx" href="https://git-scm.com/docs" rel="noopener ugc nofollow" target="_blank">https://git-scm.com/docs</a></li><li id="6402" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn ou my mz na bi translated">https://github.com/imeraj/elixir_git<a class="ae kx" href="https://github.com/imeraj/elixir_git" rel="noopener ugc nofollow" target="_blank"/></li></ol></div></div>    
</body>
</html>