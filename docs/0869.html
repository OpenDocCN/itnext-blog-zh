<html>
<head>
<title>Building a (Web) HTTP Server with Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Go构建(Web) HTTP服务器</h1>
<blockquote>原文：<a href="https://itnext.io/building-a-web-http-server-with-go-6554029b4079?source=collection_archive---------2-----------------------#2018-06-11">https://itnext.io/building-a-web-http-server-with-go-6554029b4079?source=collection_archive---------2-----------------------#2018-06-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/722275fa55ca481e79dcbe2b2f65d37f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ISFSTDtS-mKO2l1YaLCHjQ.png"/></div></div></figure><div class=""/><p id="5f64" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Go是一种通用编程语言，使用清晰的语法和高级功能进行编译和静态类型化。它的性能和设计使它成为金融科技公司最喜欢的语言。尽管有这么多好处，Go lang对整个社区的许多开发者来说仍然是陌生的，所以我们将在这里尝试改变这一点。</p><p id="aaa6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你还没有在围棋上“破冰”，请花5分钟来演示围棋的简单和容易。你不会后悔的。</p><h1 id="0a09" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">假设Docker中有一个环境</h1><p id="da74" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们将从以前的帖子中获取一个已经准备好的环境，因此如果您还没有阅读它，请参考它:</p><div class="ip iq gp gr ir lz"><a href="https://medium.com/@rrgarciach/bootstrapping-a-go-application-with-docker-47f1d9071a2a" rel="noopener follow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd jc gy z fp me fr fs mf fu fw ja bi translated">用Docker引导Go应用程序</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">如果您正在使用Go创建一个Web应用程序(针对HTTP或其他类型的服务),那么您可能…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">medium.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn ix lz"/></div></div></a></div><h1 id="d430" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">规格</h1><p id="ffcd" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们的HTTP服务器必须能够完成三个关键任务:</p><ol class=""><li id="849f" class="mo mp jb ka b kb kc kf kg kj mq kn mr kr ms kv mt mu mv mw bi translated">处理动态请求:处理来自任何类型客户端(用户或其他服务)的符合HTTP标准的传入请求。</li><li id="2f74" class="mo mp jb ka b kb mx kf my kj mz kn na kr nb kv mt mu mv mw bi translated">服务静态资产:向客户端(通常是Web浏览器)提供Javascript文件、CSS文件和图像。</li><li id="649c" class="mo mp jb ka b kb mx kf my kj mz kn na kr nb kv mt mu mv mw bi translated">接受连接:HTTP服务器应该监听特定端口上的传入连接。</li></ol><p id="0be6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也就是说，让我们从代码开始。</p><h1 id="7332" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">主文件</h1><p id="2d53" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">为了遵循Go惯例，我们将创建一个<code class="fe nc nd ne nf b">main.go</code>文件，声明“主”包，导入我们将需要的两个必需的包(<code class="fe nc nd ne nf b">fmt</code>和<code class="fe nc nd ne nf b">net/http</code>)，并声明标准的<code class="fe nc nd ne nf b">main</code>方法，这将是我们的应用程序的入口点:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="d53c" class="no kx jb nf b gy np nq l nr ns">package main</span><span id="38b6" class="no kx jb nf b gy nt nq l nr ns">import (<br/> "fmt"<br/> "net/http"<br/>)</span><span id="cf63" class="no kx jb nf b gy nt nq l nr ns">func main() {<br/>}</span></pre><p id="f6ff" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们所有的业务逻辑都将放入<code class="fe nc nd ne nf b">main</code>功能中。现在让我们开始实施我们的规范。</p><h1 id="bb1c" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">处理动态请求</h1><p id="9b30" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们将依赖一个名为<code class="fe nc nd ne nf b">net/http</code>的Go核心库/包，它包含了我们动态处理请求所需的所有功能。首先要做的是使用<code class="fe nc nd ne nf b">http.HandleFunc</code>函数为我们想要的每条路径注册一个新的处理程序。该函数接受两个参数:第一个参数是表示匹配路径的字符串，第二个参数是将被执行来处理请求的函数。</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="f844" class="no kx jb nf b gy np nq l nr ns">http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {<br/>  fmt.Fprintf(w, "This is a website server by a Go HTTP server.")<br/> })</span></pre><p id="03de" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是所有REST API框架中非常常见的模式。请注意所提供的函数作为第二个参数是如何接收两个服务作为参数的(通过依赖注入)；一个处理响应(<code class="fe nc nd ne nf b">http.ResponseWriter</code>)，另一个(<code class="fe nc nd ne nf b">http.Request</code>)从请求中获取任何数据或值。对于第二个服务，我们可以用<code class="fe nc nd ne nf b">r.URL.Query().Get("keyword")</code>读取GET参数，或者用<code class="fe nc nd ne nf b">r.Body</code>在请求体中发送参数。</p><h1 id="06df" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">服务静态资产</h1><p id="c7a3" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">接下来要做的是提供静态资产，通常是Javascript或CSS文件以及图像。为此，我们将使用<code class="fe nc nd ne nf b">net/http</code>包中的<code class="fe nc nd ne nf b">http.FileServer</code>,并通过向其传递要提供的文件所在的目录，将它指向一个URL路径:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="fe64" class="no kx jb nf b gy np nq l nr ns">fs := http.FileServer(http.Dir("static/"))</span></pre><p id="12c7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在变量<code class="fe nc nd ne nf b">fs</code>保存了静态资产内部服务器的实例，所以现在我们只需要将它映射到一个URL路径，就像我们之前处理动态请求一样:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="711e" class="no kx jb nf b gy np nq l nr ns">http.Handle("/static/", http.StripPrefix("/static/", fs))</span></pre><p id="9f9c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，我们使用了一个额外的方法<code class="fe nc nd ne nf b">http.StripPrefix</code>来去除部分URL路径，以便正确地从系统中提供文件。</p><h1 id="7dee" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">接受连接</h1><p id="dcfa" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们就要完成了，这里要做的最后一部分是监听和接受来自网络/互联网上的客户端的连接。为此，我们将再次依赖Go的内置<code class="fe nc nd ne nf b">net/http</code>包:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="ad29" class="no kx jb nf b gy np nq l nr ns">http.ListenAndServe(":3001", nil)</span></pre><p id="dffe" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过这种方式，我们指示我们Go应用程序监听端口3001上的任何传入请求(<code class="fe nc nd ne nf b">gin</code>包默认使用这个服务器来监听)。</p><h1 id="0d83" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">试试看！</h1><p id="4806" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">现在运行docker来启动我们的服务器容器:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="4050" class="no kx jb nf b gy np nq l nr ns">docker-compose up</span></pre><p id="be8f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦服务器开始运行，转到浏览器并导航到<code class="fe nc nd ne nf b">localhost:3030</code>。你会看到一个文本“这是一个网站服务器由一个去HTTP服务器。”这意味着您的服务器已经启动并正常运行。</p><h1 id="baa5" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">其他路线</h1><p id="e891" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">最后，让我们添加一条额外的路线，看看会发生什么:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="0a18" class="no kx jb nf b gy np nq l nr ns">http.HandleFunc("/hello", func(w http.ResponseWriter, r *http.Request) {<br/>  fmt.Fprintf(w, "Hello World! I'm a HTTP server!")<br/> })</span></pre><p id="17a3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你所看到的，这里我们添加了一个稍微大一点的路径，而不仅仅是“/”，然后提供一个不同的文本。切记在<code class="fe nc nd ne nf b">http.ListenAndServe(“:3001”, nil)</code>之前注册该功能。</p><p id="d625" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加完这段代码后，在容器的stdout控制台中等待自动重新加载完成:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="f23c" class="no kx jb nf b gy np nq l nr ns">go-expense-api    | [gin] Building...<br/>go-expense-api    | [gin] Build finished</span></pre><p id="2147" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在转到您的浏览器，现在导航到<code class="fe nc nd ne nf b">localhost:3030/hello</code>以查看“hello world”。</p><h1 id="b5e1" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">代码</h1><p id="a043" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">有了所有这些，我们得到的HTTP服务器应用程序项目将如下所示:</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h1 id="0d5a" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">摘要</h1><p id="49db" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在这个版本中，我们通过创建一个能够处理动态请求、服务静态资产和监听来自客户端的传入请求的超级最小(但功能齐全)HTTP服务器来“打破僵局”。从这一点来看，很容易理解围棋是如何发展的。</p><p id="8e98" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你现在可能意识到使用构建的包<code class="fe nc nd ne nf b">net/http</code>来声明和映射路由是多么容易，然而我们将在接下来的文章中看到如何使用一个更加容易和流行的包<code class="fe nc nd ne nf b">gorilla/mux</code>来创建路由。所以请保持联系，在<a class="ae nw" href="https://medium.com/@rrgarciach" rel="noopener">媒体</a>、<a class="ae nw" href="https://github.com/rrgarciach" rel="noopener ugc nofollow" target="_blank"> Github </a>或<a class="ae nw" href="https://twitter.com/rrgarciach" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我，以便从我这里接收更新和新闻。你也可以访问我的<a class="ae nw" href="http://spacedevelopercat.wordpress.com" rel="noopener ugc nofollow" target="_blank">网络博客空间开发者猫</a>来找到我的这篇和其他帖子。</p></div></div>    
</body>
</html>