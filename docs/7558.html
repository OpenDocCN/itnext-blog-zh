<html>
<head>
<title>Kotlin Native and GraalVM — The Story So Far</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林土著和GraalVM——到目前为止的故事</h1>
<blockquote>原文：<a href="https://itnext.io/kotlin-native-and-graalvm-the-story-so-far-e10d7e9cfc91?source=collection_archive---------1-----------------------#2022-11-06">https://itnext.io/kotlin-native-and-graalvm-the-story-so-far-e10d7e9cfc91?source=collection_archive---------1-----------------------#2022-11-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e206aedce2fad4c88d5a9377277fb236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pr5SqBoSF7jtvXNoldKzkQ.png"/></div></div></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="412b" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di"> T </span>今天有很多<code class="fe lp lq lr ls b"><strong class="kk iu">buzz</strong></code>关于一项我们倾向于称之为<strong class="kk iu">本土</strong>的技术。<strong class="kk iu">原生技术</strong>或<strong class="kk iu">原生代码</strong>通常是指用<strong class="kk iu"> C </strong>编写的代码，编译后无需<strong class="kk iu">虚拟机</strong>就可以直接在一个特定的系统中运行。例如，所有的<strong class="kk iu"> JVM </strong>语言代码(即Java、Kotlin、Scala、Groovy)都需要一个<strong class="kk iu">虚拟机</strong>来运行。我们首先将我们的<strong class="kk iu">源文件</strong>编译成能够被<strong class="kk iu">虚拟机</strong>读取的<strong class="kk iu">字节码</strong>，然后我们用我们的<strong class="kk iu">字节码</strong>启动<strong class="kk iu">虚拟机</strong>。Javascript代码也需要虚拟机来运行，许多其他语言也需要虚拟机。然而，当我们原生编译任何代码<strong class="kk iu"/>时，甚至是C代码，它实际上意味着代码是以这样一种方式编译的，我们可以从命令行调用这些生成的<strong class="kk iu">可执行文件</strong>，而不需要参考其他任何东西。我们不需要<strong class="kk iu"> NodeJS </strong>来运行它们，我们不需要最新的<strong class="kk iu"> JRE </strong>来运行它们，我们也不需要任何<strong class="kk iu"> SBT </strong>、<strong class="kk iu"> Gradle </strong>或<strong class="kk iu"> Python </strong>工具来运行它们。我们只需运行<strong class="kk iu">可执行文件</strong>。当然，有一个问题是我们不能在任何系统中运行这些文件。我们只能在理解这些文件的系统中运行这些文件，我们在编译时定义了这些文件。这就是为什么我们不能在没有任何支持的情况下在Linux中运行windows文件，反之亦然。因此，举例来说，如果我们想在<strong class="kk iu"> MAC-OS </strong>中运行任何<strong class="kk iu"> windows可执行文件</strong>，我们将需要类似<a class="ae lt" href="https://www.winehq.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> Wine </strong> </a>的东西。</p><p id="d22b" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果你是几年前的人，我指的是软盘时代，你可能熟悉<strong class="kk iu"> EXE、COM、</strong>和<strong class="kk iu"> BAT </strong>文件的概念。像<strong class="kk iu"> AUTOEXEC这样的东西。BAT </strong>应该会想到。对于那些认识这些东西的人，我已经可以给你们举个例子，你们可能已经知道了，这些都不能在MAC-OS或LINUX上运行。这些文件特定于旧的MS-DOS系统和一些旧的Windows版本。无论如何，这里的要点是我们现在知道当我们谈论<strong class="kk iu">本机</strong>时，我们指的是一种独立运行我们代码的方式。我们编译的代码将在本地工作。它将尽可能地使用低级资源和直通抽象，以便在非常低的级别上执行命令，并且最好是不需要预安装的命令。</p><h1 id="d8b0" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">1.介绍</h1><p id="292f" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">我们</span>要用Kotlin Native和其他编译原生代码的变种和形式做一些实验。为此，我们需要数据，我的小说《好故事》第二章提供了这些数据。对于这篇文章，我们来看看<a class="ae lt" href="https://github.com/jesperancinha/whiskers-kotlin-native/blob/main/docs/good.story/good.story.chapter.2.md" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">第二章——帮助露西的猫</strong> </a></p><h1 id="5ec0" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">2.要求</h1><p id="3957" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi lg translated">对于本文来说，我提供的库是在只考虑运行安装了Linux的容器的Linux系统的情况下创建的。我最初没有对MAC-OS进行测试。我打算提供对MAC-OS机器的全面支持，也许以后还会提供对Windows的支持。如果你真的需要我的仓库也支持Windows和MAC-OS，请向我的repo或我的任何其他仓库开放问题。然后我会觉得有必要帮助你，并且会增加我这样做的动力。正因为如此，如果你能在这里公开你的问题，我会非常感激。</p><p id="e298" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">你还需要考虑的是你的机器的容量。我做了几次测试，我的机器在编译时被阻塞了，直到我最终提高了文件侦听器的数量:</p><pre class="mx my mz na gt nb ls nc bn nd ne bi"><span id="aa1a" class="nf lv it ls b be ng nh l ni nj">echo fs.inotify.max_user_watches=33554432 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p<br/>cat /proc/sys/fs/inotify/max_user_watches</span></pre><p id="0bfa" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated"><code class="fe lp lq lr ls b"><strong class="kk iu">inotify</strong></code> <strong class="kk iu">手表</strong> <strong class="kk iu">编号</strong> <strong class="kk iu"> 3354432 </strong>是我最后使用的，但是如果你的机器可以的话，请多尝试一下。你可以在我的所有云回购中找到更多关于这个<a class="ae lt" href="https://github.com/jesperancinha/jeorg-cloud-test-drives" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="0135" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果您打算运行我将在下面描述的所有示例，请记住，在本地环境中编译也意味着从强类型语言(如我们正在使用的语言<strong class="kk iu"> Kotlin </strong>)进行的转换非常慢，因此您必须预料到编译时间会非常慢<strong class="kk iu"/>。它与您的机器、硬件或您可能正在使用的任何操作系统都没有任何关系，进行编译可能会非常令人沮丧。作为预防措施，请不要在执行下面指示的安装步骤之前使用您的<strong class="kk iu"> IDE </strong>。</p><h1 id="77cb" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">3.科特林本地人</h1><p id="54df" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi lg translated">对于纯Kotlin原生用户，我们只打算用命令行创建一些有趣的东西。Kotlin Native提供了几个命令行指令的包装器，我们可以很容易地使用它们。我们将在水下有效地使用C，并使其与GCC一起运行。</p><h1 id="b9f1" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">3.1.什么是Kotlin Native，它是如何工作的？</h1><p id="f2f5" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi lg translated">奥特林土著在它所能做的方面仍然非常有限，它也有一种非常不同的运行和工作方式。因此，我们需要首先从基础开始深入了解使用Kotlin native的实际情况，然后在此基础上建立我们的知识。</p><p id="f848" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">当我们第一次使用初始IntelliJ布局创建Kotlin原生初始解决方案时，我们可能会认为我们将使用一个普通的环境，在这个环境中，我们只需添加库并配置<strong class="kk iu"> Gradle </strong>即可工作。相反，我们将使用可用于<strong class="kk iu">本机</strong>代码生成的库。因此，在我们做任何事情之前，我们先启动一个本地多平台应用程序项目:</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/f8c69774f56f0e25436717aa43a0dce6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g6NfljZLmIvNixAXy2A0rw.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd lw">在IntelliJ中启动本地应用</strong></figcaption></figure><p id="f650" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">当我这样做的时候，我意识到最终的项目是一个<strong class="kk iu"> Gradle </strong>项目。比如先来看看<a class="ae lt" href="https://github.com/jesperancinha/whiskers-kotlin-native/tree/main/good-feel" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">手感好的</strong> </a>项目。这个项目是一个简单的基于控制台的项目，它简单地输出一个随机的正面信息到屏幕上，给你一个美好的感觉。如果我们看看正在使用的基本插件，只有一个叫做<strong class="kk iu">多平台</strong>:</p><pre class="mx my mz na gt nb ls nc bn nd ne bi"><span id="e5ca" class="nf lv it ls b be ng nh l ni nj">plugins {<br/>    kotlin("multiplatform") version "1.7.22"<br/>}</span></pre><p id="028f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">一旦这个插件就位，Intellij还会配置Kotlin本地编译:</p><pre class="mx my mz na gt nb ls nc bn nd ne bi"><span id="6e16" class="nf lv it ls b be ng nh l ni nj">plugins {<br/>    kotlin("multiplatform") version "1.7.22"<br/>}<br/><br/>group = "org.jesperancinha"<br/>version = "1.0-SNAPSHOT"<br/><br/>repositories {<br/>    mavenCentral()<br/>}<br/><br/>kotlin {<br/>    val hostOs = System.getProperty("os.name")<br/>    val isMingwX64 = hostOs.startsWith("Windows")<br/>    val nativeTarget = when {<br/>        hostOs == "Mac OS X" -&gt; macosX64("native")<br/>        hostOs == "Linux" -&gt; linuxX64("native")<br/>        isMingwX64 -&gt; mingwX64("native")<br/>        else -&gt; throw GradleException("Host OS is not supported in Kotlin/Native.")<br/>    }<br/><br/>    nativeTarget.apply {<br/>        binaries {<br/>            executable {<br/>                entryPoint = "main"<br/>            }<br/>        }<br/>    }<br/>    sourceSets {<br/>        val nativeMain by getting<br/>        val nativeTest by getting<br/>    }<br/><br/>}</span></pre><p id="51c0" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这意味着编译器会判断出你在哪个机器上运行它，然后如果可能的话，把你的代码编译成本机代码。该代码包括与<strong class="kk iu"> Windows </strong>、<strong class="kk iu"> Mac OS X、</strong>和<strong class="kk iu"> Linux </strong>的可能兼容性。正如我之前提到的，在本文中，我们将只看一下在Linux生态系统中实现<strong class="kk iu">原生</strong>代码。</p><p id="b91c" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">让我们看看实际的代码。它非常简单，我这样做是为了提供某种杠杆来理解本机代码是如何工作的:</p><pre class="mx my mz na gt nb ls nc bn nd ne bi"><span id="6f2b" class="nf lv it ls b be ng nh l ni nj">fun main() {<br/>    println("*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*")<br/>    println(randomMessage())<br/>    println("*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*")<br/>}<br/><br/>fun randomMessage(): String {<br/>   return listOf(<br/>       "Good Morning!",<br/>       "You are looking great today!",<br/>       "What a great day today!",<br/>       "Good job!",<br/>       "I really appreciate what you just did! Thank you!",<br/>       "Thanks for bringing me coffee!",<br/>       "You are the best pal ever!",<br/>       "I love working with you!",<br/>       "Rise and shine!"<br/>   ).random()<br/>}</span></pre><p id="5b21" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">因此，在本模块中，我们只打印出几个字符串，这是两个分隔符，它们之间有很好的信息。如果我们点击这些资源，我们会很快意识到并没有什么真正的改变。这只是标准的<strong class="kk iu"> Kotlin </strong>库<strong class="kk iu">代码。如果我们用命令<code class="fe lp lq lr ls b"><strong class="kk iu">make b</strong></code>编译该文件夹中的代码，我们将在<code class="fe lp lq lr ls b"><strong class="kk iu">build/bin/native/releaseExecutable/plus.kexe</strong></code> <strong class="kk iu"> </strong>中得到一个可执行文件。我们可以通过这个精确的链接手动调用这个文件，或者运行脚本<code class="fe lp lq lr ls b"><strong class="kk iu">make run</strong></code> <strong class="kk iu">。</strong>您将在输出中得到类似这样的内容:</strong></p><pre class="mx my mz na gt nb ls np nq aw nr bi"><span id="ccdb" class="ns lv it ls b gy nt nu l nv nj">*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*<br/>Good job!<br/>*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*</span></pre><p id="e921" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这个项目的想法仅仅是为了说明在科特林本土启动一个项目是多么容易。我们也将看到它会变得多么困难。这就是我创建项目<strong class="kk iu"> plus、</strong>的原因，它本质上只是项目<strong class="kk iu"> good-feel </strong>的扩展。当点击时，特别是<strong class="kk iu"> Map </strong>类，特别是源代码在哪里，我们很快意识到我们并没有真正地使用普通的jar库。事实上，我们根本没有在使用Java库。我们正在研究的是。<strong class="kk iu"> knm </strong>文件。这些是本机编译的库，IntelliJ可以部分解释并提供对它们的简单的<strong class="kk iu">接口</strong>访问。这一切都发生在设计阶段，这意味着<strong class="kk iu">智能感知</strong>正在为您工作:</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/71142aaabd84bcb2a66d4dde548be566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xWW14pRUJ-RxuEdnqWcSmg.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd lw">科特林原生</strong> <code class="fe lp lq lr ls b"><strong class="bd lw">stdlib</strong></code> <strong class="bd lw">布局</strong></figcaption></figure><p id="1f2a" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们当然仍在使用标准库，但不是我们习惯使用的那个。在这种情况下，标准库是本机运行的代码。但首先，让我们看看我们在新代码中使用了什么:</p><pre class="mx my mz na gt nb ls nc bn nd ne bi"><span id="f176" class="nf lv it ls b be ng nh l ni nj">fun main() {<br/>    println("*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*")<br/>    println(randomMessage())<br/>    println("*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*")<br/>    val groupBy: Map&lt;String, List&lt;Int&gt;&gt; = allMessages().groupBy({ it }, { it.length })<br/>    val hashMap = allMessages().groupBy({ it }, { it.length }).entries.fold(HashMap&lt;String, List&lt;Int&gt;&gt;()) { a, b -&gt;<br/>        a[b.key] = b.value<br/>        a<br/>    }<br/>    println(groupBy::class.qualifiedName)<br/>    println(hashMap::class.qualifiedName)<br/>    val toTypedArray: Map&lt;String, String&gt; = allMessages().toTypedArray().associateBy { it }<br/>    println(toTypedArray::class.qualifiedName)<br/>}<br/><br/>fun randomMessage(): String {<br/>    return allMessages().random()<br/>}<br/><br/>private fun allMessages() = listOf(<br/>    "Good Morning!",<br/>    "You are looking great today!",<br/>    "What a great day today!",<br/>    "Good job!",<br/>    "I really appreciate what you just did! Thank you!",<br/>    "Thanks for bringing me coffee!",<br/>    "You are the best pal ever!",<br/>    "I love working with you!",<br/>    "Rise and shine!"<br/>)</span></pre><p id="09a8" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这种情况下，我只是创建一些地图，然后我使用实体来重新创建它们，本质上我只是创建地图。超级简单代码的有趣之处在于它看起来和感觉上都像Kotlin。在很多方面都是Kotlin，但这段代码会提前编译。我们称这种情况下的编译器为<strong class="kk iu"> AOT(提前编译器)。</strong>这意味着生成的代码不仅仅是可执行文件。当我们运行它时，它将以一个性能峰值开始，因为没有<strong class="kk iu">即时编译过程</strong>。在JVM中，当我们制作我们所谓的可执行jar时，编译过程并没有就此停止。这足以让我们在JVM中启动jar。<strong class="kk iu">完整编译</strong>将在应用程序启动期间优化进程时发生。这通常是我们谈论JIT时所指的。在我们继续深入时，请记住这一点，因为我们将在本文的其余部分讨论这两个概念。</p><p id="b409" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">例如，如果我们分析其中一个生成的<code class="fe lp lq lr ls b"><strong class="kk iu">knm</strong></code> <strong class="kk iu"> </strong>文件，我们将看到以下内容(<code class="fe lp lq lr ls b"><strong class="kk iu"><em class="nx">00_collections.knm</em></strong></code> <strong class="kk iu"> <em class="nx"> ) </em> </strong>):</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/6f89d0cb3ad8cf517474c10ae8580cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4aSnU0bQyr5J0LmupMagaA.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd lw"><em class="nz">00 _ collections . knm of</em>包kotlin.collections </strong></figcaption></figure><p id="849a" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们可以在顶部看到，与我们通常在SDK 的<strong class="kk iu"> Kotling标准库中看到的不同，我们只看到类似接口和不可读函数体的引用。我们也看到一些声明的变量，但是我们从来没有看到任何实现。目前，至少不容易在Kotlin本地标准库中看到这些方法的实际实现，这是不可能的。原生库当然是原生的，我们看不到这一点，就像我们看不到使用Java中的原生绑定在C中实现的函数一样。这也是用<strong class="kk iu">Kotlin</strong>T24】native</strong>T26】SDK实现的实际意思的一个侧面。我们现在在将JVM代码与本机代码分开的灰色区域编程，我们这样做当然是因为我们希望我们的最终产品不再与JVM有任何关系。另外，请注意反编译器的第一条注释，它基本上陈述了我们刚刚讨论的内容:</p><pre class="mx my mz na gt nb ls np nq aw nr bi"><span id="d51b" class="ns lv it ls b gy nt nu l nv nj">// IntelliJ API Decompiler stub source generated from a class file<br/>// Implementation of methods is not available</span></pre><p id="91ef" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这就是Kotlin Native最纯粹、最简单的工作方式。我们当然可以将我们的Kotlin代码与C代码结合起来，这允许我们探索更多的可能性，看看我们能用本机代码和我们的最终汇编做些什么。</p><h1 id="6b90" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">3.2.<a class="ae lt" href="https://github.com/jesperancinha/whiskers-kotlin-native/tree/main/whiskers-runners/whiskers-runners-knative" rel="noopener ugc nofollow" target="_blank">科特林本地运行器实现</a></h1><p id="48bf" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">正如</span>我们将进一步看到的，我们将使用一个例子，我们将创建一个runnable，它将进行非常简单的操作。它将分割一个文本，并立即连接它回来，没有检查。这是一个分割耗时O(n ),连接耗时O(n)的操作，导致总时间复杂度为O(n)。就空间而言，分割的复杂度也是O(n ),连接的复杂度也是O(n)。代码实现非常简单，如下所示:</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/a5f36ffde21face6572de50ff828dadf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8g4LL7F34AcdBfks_BdznQ.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd lw">没有C互操作性绑定的本地运行器</strong></figcaption></figure><p id="ab88" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">该示例的创建方式与创建<strong class="kk iu">良好体验</strong>示例的方式相同。</p><h1 id="3acc" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">3.3.<a class="ae lt" href="https://github.com/jesperancinha/whiskers-kotlin-native/tree/main/whiskers-runners/whiskers-runners-native" rel="noopener ugc nofollow" target="_blank">带C互操作绑定的Kotlin本机运行程序运行程序</a></h1><p id="d94c" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di"> B </span>在解释Kotlin本地运行程序如何与<strong class="kk iu"> C </strong>互操作性一起工作之前，考虑一下为什么在这种特殊情况下运行代码会有意义可能是很重要的。如前所述，在<strong class="kk iu"> C </strong>中创建代码提供了一种通过Kotlin代码创建本机代码的替代方法。这可以为创建新软件提供多种可能性。在这种情况下，我们想要测试的是当运行同一个runnable时会有什么样的影响，特别是我们使用C代码而不是<strong class="kk iu"> Kotlin </strong>代码。现在我们可以继续有趣的部分，这就是C绑定的创建。但在我们开始之前，我想分享一些我在做这件事时很快意识到的事情:</p><ul class=""><li id="6d79" class="oa ob it kk b kl km kp kq kt oc kx od lb oe lf of og oh oi bi translated">很难将<strong class="kk iu"> Kotlin原生编译C代码</strong>配置到最终编译的runnable中，使其适用于每台机器。</li><li id="91cf" class="oa ob it kk b kl oj kp ok kt ol kx om lb on lf of og oh oi bi translated">在这个例子中，我发现单独编译<strong class="kk iu"> C代码</strong>，然后用Kotlin native将编译后的本机代码引入程序集中会更好。</li></ul><p id="a2ab" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">所以首先我们创建我们的小图书馆。这是头文件:</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/3bb56643fe368b1281163f72ec303cff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*KBk0VzUMbKpagVjy_58vLw.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd lw"> redcat.h </strong></figcaption></figure><p id="1b6e" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在我们需要实现文件<strong class="kk iu"> ( </strong> <code class="fe lp lq lr ls b"><strong class="kk iu">redcat.c</strong></code> <strong class="kk iu"> ) </strong>:</p><pre class="mx my mz na gt nb ls nc bn nd ne bi"><span id="d60e" class="nf lv it ls b be ng nh l ni nj">#include "redcat.h"<br/>#include &lt;stdio.h&gt;<br/>#include &lt;string.h&gt;<br/><br/>static char c[255] = "The red cat used to roam around in the neighbourhood. For some reason this cat found in Lucy a connection and became Lucy's friend\0";<br/>static char str[sizeof(char*)*256];<br/>static char delim[] = " ";<br/>static char result[sizeof(char*)*256];<br/>static char array[sizeof(char*)*256];<br/><br/>char* tell_story() {<br/>    char *namePtr;<br/>    namePtr = c;<br/>    return namePtr;<br/>}<br/><br/>char* scramble_story() {<br/> char* story = tell_story();<br/> memcpy(str, story, sizeof(char*)*256);<br/> int init_size = strlen(str);<br/> char *ptr = strtok(str, delim);<br/> while (ptr != NULL)<br/> {<br/>  memcpy(array, ptr, sizeof(char*)*256);<br/>  strcat(result, array);<br/>  strcat(result, delim);<br/>  ptr = strtok(NULL, delim);<br/> }<br/> strcat(result, "\0");<br/>    char *namePtr;<br/>    namePtr = result;<br/> return namePtr;<br/>}<br/>int answer() {<br/>  return 42;<br/>}<br/><br/>char love() {<br/>    return 'L';<br/>}</span></pre><p id="74bd" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在我的例子中，我想要的只是一个<strong class="kk iu">静态库。</strong>这最终是<strong class="kk iu"> Kotlin本机编译器</strong>访问我们用c开发的代码所需的。这是我们代码的二进制本机版本，我们也可以将其注入Kotlin代码。在该项目的<strong class="kk iu"> Make </strong>文件中，我们将看到这组指令，以便能够将我们的代码编译成我们需要的二进制文件:</p><pre class="mx my mz na gt nb ls nc bn nd ne bi"><span id="ee9e" class="nf lv it ls b be ng nh l ni nj">gcc -c "-I$(PWD)" src/nativeInterop/cinterop/code/redcat.c -o src/nativeInterop/cinterop/code/redcat.o<br/><br/>ar rcs src/nativeInterop/cinterop/code/redcat.a src/nativeInterop/cinterop/code/redcat.o<br/><br/>./kotlin.native/bin/cinterop -def src/nativeInterop/cinterop/redcat.def -compiler-options "-I$(PWD)/src/nativeInterop/cinterop/code" -o src/nativeInterop/cinterop/code/redcat.klib<br/><br/>./kotlin.native/bin/konanc -l src/nativeInterop/cinterop/code/redcat.klib src/nativeMain/kotlin/Main.kt -linker-options src/nativeInterop/cinterop/code/redcat.a -o main</span></pre><p id="809b" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">用<code class="fe lp lq lr ls b"><strong class="kk iu">gcc</strong></code> <strong class="kk iu"> </strong>我们得到构建我们的o文件。简而言之，<code class="fe lp lq lr ls b">.<strong class="kk iu">o</strong></code>文件是<code class="fe lp lq lr ls b"><strong class="kk iu">.h</strong></code>和<code class="fe lp lq lr ls b"><strong class="kk iu">.c</strong></code>文件的合并。这就是所谓的<strong class="kk iu">对象</strong>文件，编译器可以用它来链接所有需要的<strong class="kk iu">对象</strong>，以创建最终的可执行文件或二进制文件。<code class="fe lp lq lr ls b"><strong class="kk iu">ar</strong></code> <strong class="kk iu"> </strong>命令从指定的<strong class="kk iu">对象</strong>文件创建一个静态库。</p><p id="45d7" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">下面我们使用的命令是<code class="fe lp lq lr ls b"><strong class="kk iu">cinterop</strong></code>命令。<code class="fe lp lq lr ls b"><strong class="kk iu">Cinterop</strong></code>属于<strong class="kk iu">科特林-原生库</strong>。我提供了在本地安装它的方法。有一个关于这个的脚本叫做<code class="fe lp lq lr ls b"><strong class="kk iu">install-kotlin-native-linux</strong></code> <strong class="kk iu"> </strong>但是现在，这并不重要。<code class="fe lp lq lr ls b"><strong class="kk iu">cinterop</strong></code> <strong class="kk iu"> </strong>所做的正是它名字中的内容。C表示C语言的<strong class="kk iu"> C </strong>，而<strong class="kk iu"> interop </strong>代表<strong class="kk iu">互操作性</strong>。生成的文件是一个<code class="fe lp lq lr ls b"><strong class="kk iu">readcat.klib</strong></code>文件。如果我们在命令行中键入这个文件，我们将得到类似这样的结果:</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/bf4c3c93eddd7e112ad8f17e9b3439e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MbEC-H02QxpTNx2utUOcLg.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd lw">文件内容的最后一行</strong> <code class="fe lp lq lr ls b"><strong class="bd lw"> redcat.klib</strong></code> <strong class="bd lw">库</strong></figcaption></figure><p id="b881" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">看着眼熟？如果不是的话，这不是问题，但是请记住我们在查看<strong class="kk iu"> Kotlin原生SDK </strong>的内容时上面的几段话。我们自己的图书馆也是如此。<code class="fe lp lq lr ls b"><strong class="kk iu">Klib</strong></code> <strong class="kk iu"> </strong>文件是<strong class="kk iu"> Kotlin </strong>原生世界中的<strong class="kk iu">jar</strong>，<code class="fe lp lq lr ls b"><strong class="kk iu">knm</strong></code>文件与<code class="fe lp lq lr ls b"><strong class="kk iu">Klib</strong></code> <strong class="kk iu"> </strong>文件几乎相同，但在<strong class="kk iu"> SDK中。</strong>最后我们有了<code class="fe lp lq lr ls b"><strong class="kk iu">Klib</strong></code> <strong class="kk iu"> </strong>文件，可以导入到我们的项目中。方法是使用<code class="fe lp lq lr ls b"><strong class="kk iu">.def</strong> </code>文件。这些文件需要默认位于<code class="fe lp lq lr ls b"><strong class="kk iu">src/nativeInterop/cinterop</strong></code> <strong class="kk iu">、</strong>中，但不一定。我们将明确地做所有这些，这样我们就知道它是如何工作的了。所以在我们进入<code class="fe lp lq lr ls b"><strong class="kk iu">.def</strong></code> <strong class="kk iu"> </strong>文件的细节之前，让我们先来看看<code class="fe lp lq lr ls b"><strong class="kk iu">build.gradle.kts</strong></code> <strong class="kk iu"> </strong>是如何工作的:</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi op"><img src="../Images/12cb141eb919d0e83da585e3b1f26a1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YxHr9ETJAl3wfBn3LjclGw.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd lw">提供与C互操作性的梯度定义</strong></figcaption></figure><p id="8299" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们之前已经介绍过多平台插件的用法。对于这种配置，我们将更深入地了解一下<code class="fe lp lq lr ls b"><strong class="kk iu">cinterops</strong></code> <strong class="kk iu"> </strong>配置。在那里，我们发现我们创建了一个名为redcat <strong class="kk iu">的变量。</strong>这个变量是我们<strong class="kk iu">red cat</strong>library<strong class="kk iu">的配置。<code class="fe lp lq lr ls b"><strong class="kk iu">defFile</strong></code> <strong class="kk iu"> </strong>是一个接受包含我们之前提到的<code class="fe lp lq lr ls b"><strong class="kk iu">.def</strong></code>文件的<strong class="kk iu">文件</strong>的方法。<code class="fe lp lq lr ls b"><strong class="kk iu">packageName</strong></code>是我们想要通过<code class="fe lp lq lr ls b"><strong class="kk iu">C</strong></code>代码生成的包。<strong class="kk iu">头文件</strong>是用来配置我们需要的所有头文件的方法，最后，我们包括了编译器应该找到所有头文件的目录。我们之前提到过，我们手动进行编译，以避免编译时出现问题。这最后两个属性<code class="fe lp lq lr ls b"><strong class="kk iu">headers</strong></code> <strong class="kk iu"> </strong>和<code class="fe lp lq lr ls b"><strong class="kk iu">includeDirs</strong></code>对于我们的具体情况是不必要的。</strong></p><p id="d0b5" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">最后，让我们看看我们的<strong class="kk iu">。def </strong>文件！</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oq"><img src="../Images/f130ac307c03dd20c629a5a820110a93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z6KzgyN_1a22GmNXM-I-AQ.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd lw">。def文件</strong> <code class="fe lp lq lr ls b"><strong class="bd lw">redcat.def</strong></code></figcaption></figure><p id="3b88" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated"><code class="fe lp lq lr ls b"><strong class="kk iu">staticLibraries</strong></code>属性是我们在这个文件中感兴趣的一个属性。还有更多属性可以使用，包括编译器的路径、您可能使用的编译器以及扩展的配置量。对于本文，正如我们之前提到的，现在担心这个还没有意义，因为编译时没有使用<strong class="kk iu">。def </strong>文件只是更容易。然而，这可以在另一篇文章中讨论，同时在这里<a class="ae lt" href="https://kotlinlang.org/docs/native-c-interop.html" rel="noopener ugc nofollow" target="_blank">你可以找到更多关于如何</a><a class="ae lt" href="https://kotlinlang.org/docs/native-c-interop.html" rel="noopener ugc nofollow" target="_blank">配置的信息。更高级别的def文件</a>。</p><p id="7ead" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">最后，我们可以检查我们的代码:</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi or"><img src="../Images/0a7e14dcfb14c8f508743da3b8c7527c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HH4i5mvcD_sQx8gKLLcGLA.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd lw">kot Lin代码中的C互操作性</strong></figcaption></figure><p id="94b3" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果我们仔细看看，我们会看到我们的包<code class="fe lp lq lr ls b"><strong class="kk iu">org.jesperancinha.knative</strong></code>。我们可以看到我们得到了<code class="fe lp lq lr ls b"><strong class="kk iu">tell_story</strong></code>和<code class="fe lp lq lr ls b"><strong class="kk iu">scramble_story</strong></code>方法。这太棒了！我们可以就命名方法进行长时间的讨论，但是我认为约定的讨论不应该出现在本文中，因为我们要看一下Native在不同框架的性能方面的表现。</p><p id="35c9" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">也许提及<code class="fe lp lq lr ls b"><strong class="kk iu">toKString()</strong></code>方法的作用也很重要。我们在代码中看不到它，但是<code class="fe lp lq lr ls b"><strong class="kk iu">tell_story</strong></code>和<code class="fe lp lq lr ls b"><strong class="kk iu">scramble_story</strong></code> <strong class="kk iu"> </strong>都返回了类型<code class="fe lp lq lr ls b"><strong class="kk iu">CPointer&lt;ByteVar&gt;</strong></code> <strong class="kk iu"> </strong>。这只是一种在内存中表示一个指向字符串开始的指针的方式。如果你不知道什么是指针，先<a class="ae lt" href="https://www.guru99.com/c-pointers.html" rel="noopener ugc nofollow" target="_blank">查一下什么是c指针可能是个更好的主意</a>。因此，通过互操作性，<strong class="kk iu"> Kotlin </strong>将返回的<strong class="kk iu">字符串</strong>解释为<strong class="kk iu">字节流</strong>流。既然这是<strong class="kk iu">科特林</strong>那么我们当然有一个方便的方法来为我们做一切事情，这个方法叫做<code class="fe lp lq lr ls b"><strong class="kk iu">toKString()</strong></code> <strong class="kk iu">。</strong></p><h1 id="acd0" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">3.4.<a class="ae lt" href="https://github.com/jesperancinha/whiskers-kotlin-native/tree/main/whiskers-ktor" rel="noopener ugc nofollow" target="_blank">企业Kotlin原生Ktor服务实现</a></h1><p id="1d19" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">O</span>kot Lin Native让它如此有趣的一个方面是，它允许我们以创纪录的启动时间和最小的资源内存使用来创建服务。还可能有其他好处，如性能。这里我们将使用Ktor生态系统中唯一可能的替代品，即<strong class="kk iu"> CIO(基于协程的I/O) </strong>引擎。</p><p id="58f1" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">对于本节，我们将使用我们在以上所有章节中已经建立的知识来创建一个服务。如果你习惯于<code class="fe lp lq lr ls b"><strong class="kk iu">Spring</strong></code>、<code class="fe lp lq lr ls b"><strong class="kk iu">Micronaut</strong></code>或任何其他<strong class="kk iu"> web服务框架</strong>，你会发现这很容易理解。如果没有，我会尽量说清楚。</p><p id="838e" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">让我们回顾一下我们在这个阶段想要构建Ktor服务的原因。我们想比较一下<strong class="kk iu">科特林人</strong>和<strong class="kk iu">格拉尔姆人</strong>。我们还想检查它们的异同。<strong class="kk iu"> GraalVM </strong>主要用于将jar转换成可执行文件，而<strong class="kk iu"> Spring Native Cloud </strong>用于创建我们可以在云中运行的容器。Spring Native 之所以是本地的，是因为它要么使用GraalVM 要么使用容器化版本来运行。后者还使用表面下的<strong class="kk iu"> GraalVM </strong>。Kotlin native没有办法创建本地服务，除非使用由<strong class="kk iu"> Ktor </strong>提供的<strong class="kk iu"> CIO </strong>替代，它独立于<strong class="kk iu"> GraalVM </strong>。</p><p id="01db" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在我们来讨论一下这些服务的另一个方面。为了让数据库工作，我不得不在互联网上寻找替代方案。有一个名为<a class="ae lt" href="https://github.com/cashapp/sqldelight" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> SQLDelight </strong> </a>的项目，它提供了我在<a class="ae lt" href="https://github.com/cashapp/sqldelight" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> GitHub </strong> </a>上的这个项目所需要的一些有用的绑定。在<code class="fe lp lq lr ls b"><strong class="kk iu">Philip Wedemann</strong></code>的另一个<a class="ae lt" href="https://github.com/hfhbd/postgres-native-sqldelight" rel="noopener ugc nofollow" target="_blank">项目</a>中，有允许连接到数据库的代码。于是我用<a class="ae lt" href="https://github.com/cashapp/sqldelight" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> SQLDelight </strong> </a>和来自<a class="ae lt" href="https://github.com/hfhbd/postgres-native-sqldelight" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">postgres-native-SQL delight</strong></a><strong class="kk iu"/>的一些提示，创建了一个位于<strong class="kk iu"> Database.kt </strong>类的小驱动。驱动程序的实现方式非常复杂，对本文来说没什么用处。重要的是，CIO允许服务在本地编译，而不需要借助转换。尽管如此，理解我们如何从本机代码访问对象还是很重要的。</p><p id="1db6" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这个实现中，我们只是下载Postgres驱动程序，提取它，编译它，然后我们使用下面的<code class="fe lp lq lr ls b"><strong class="kk iu">.def </strong></code>文件创建链接:</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi os"><img src="../Images/7081902dc48512aeed348adbd93c89a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B1Kvd7E9gjtXvX1sHf5oVg.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd lw"> Redcat定义</strong></figcaption></figure><p id="4072" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">正如我们在上面的脚本中看到的，我们仍然需要从通用的<strong class="kk iu"> postgresql </strong> includes中访问一个<strong class="kk iu"> libpq-fe.h </strong>文件。为此，我们还需要在本地安装一些库:</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ot"><img src="../Images/08ac450569532f698dce5a9130cb1f3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jllttp0U0vHf1uYhL0a9sg.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">【Linux必需的Libpq库</figcaption></figure><p id="f608" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">完成后，我们仍然需要编译我们之前下载的整个驱动程序目录，这是使用以下命令序列完成的:</p><pre class="mx my mz na gt nb ls np nq aw nr bi"><span id="7b42" class="ns lv it ls b gy nt nu l nv nj">./configure<br/>make all</span></pre><p id="54d0" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated"><a class="ae lt" href="https://github.com/jesperancinha/whiskers-kotlin-native/tree/main/whiskers-ktor/postgresql" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> postgres </strong> </a>目录包含我添加的脚本，用于自动执行所有必要的操作。在我对这个设置的调查中，我还发现成功编译<code class="fe lp lq lr ls b"><strong class="kk iu">libpq</strong></code> <strong class="kk iu">还需要一个文件<code class="fe lp lq lr ls b"><strong class="kk iu">explicit_bzero_chk.c</strong></code> <strong class="kk iu"> </strong>。有很多关于如何更好地做这件事的建议，但是我找到了我做这件事的方法，一个完美的执行我的测试的方法。这可能不是我们在生产中应该做的，但是当我们等待PostgreSQL的可靠的本地库发布时，除了寻找实现它的最佳方式，我们没有太多的选择，因为目前，关于如何本地使用SQL没有太多的规则，也没有太多的替代方法。</strong></p><p id="2ed5" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">让我们最后快速浏览一下<code class="fe lp lq lr ls b"><strong class="kk iu">build.gradle.kts</strong></code>文件:</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ou"><img src="../Images/aef6d61c6b76bedb83673abdfb11fd27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bT16o-TpRz4UH2t86MaY_w.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd lw">为Ktor服务建立gradle文件</strong></figcaption></figure><p id="a796" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我发现在实现原生服务时有一点非常限制，那就是一切都需要通过插件激活才能工作。如果我们仔细想想，这确实是有意义的，因为与科特林本地人合作是完全不同的事情。我们使用的所有库都需要能够支持<strong class="kk iu">本机</strong>，这也意味着，在<strong class="kk iu"> Kotlin </strong>端，我们只能看到接口，而看不到实现。这意味着，为了能够使用一些jar，我们需要标准支持。这在很大程度上限制了这个<strong class="kk iu"> CIO </strong>服务器的实现。这也是我没有导入<strong class="kk iu"> Philip Wedemann提供的<a class="ae lt" href="https://github.com/hfhbd/postgres-native-sqldelight" rel="noopener ugc nofollow" target="_blank">库</a>的部分原因。</strong>本地库很难配置，并且这个特定的库仍然非常依赖于特定的本地配置。我这样做，允许我们使用<strong class="kk iu"> Libpq </strong>链接到为本地Linux机器优化的编译库。</p><p id="0150" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">最后，我们可以看看<strong class="kk iu"> CIO </strong>服务器是如何实现的。它基本上遵循了许多企业解决方案所遵循的典型的<strong class="kk iu">洋葱</strong>模式，例如<strong class="kk iu"> Spring </strong>、<strong class="kk iu"> JEE </strong>、<strong class="kk iu"> KumuluzEE </strong>、<strong class="kk iu"> Micronaut </strong>等。它本质上只是一个MVC实现。但是，让我们来看看端点实现:</p><pre class="mx my mz na gt nb ls nc bn nd ne bi"><span id="4b1e" class="nf lv it ls b be ng nh l ni nj">embeddedServer(CIO, port = configuration.server.port) {<br/>    routing {<br/>        install(ContentNegotiation) {<br/>            json()<br/>        }<br/>        get {<br/>            call.respondText("Welcome to the Cat Ktor Service!")<br/>        }<br/>        route("/cat") {<br/>            route("/sayings") {<br/>                get {<br/>                    call.respond(listOf&lt;CatSaying&gt;())<br/>                }<br/>                get("/encoded") {<br/>                    call.respondWithEncodedFlow(status = OK, listOf&lt;CatSaying&gt;())<br/>                }<br/>            }<br/>            route("/saying") {<br/>                post {<br/>                    val catSaying = call.receive&lt;CatSaying&gt;()<br/>                    call.respond(status = Created, catSaying)<br/>                }<br/>            }<br/>        }<br/>        route("/story") {<br/>            route("/paragraph") {<br/>                post {<br/>                    val paragraph = call.receive&lt;Paragraph&gt;()<br/>                    call.respond(status = Created, paragraph)<br/>                }<br/>                post("/encoded") {<br/>                    val paragraph = call.receive&lt;Paragraph&gt;()<br/>                    call.respondWithEntity(status = Created, paragraph)<br/>                }<br/>            }<br/>            route("paragraphs") {<br/>                delete {<br/>                   call.respond(status = Accepted,"")<br/>                }<br/>                post("/encoded") {<br/>                    val paragraphs = call.receive&lt;List&lt;Paragraph&gt;&gt;()<br/>                    call.respondWithEncodedFlow(status = Created, paragraphs)<br/>                }<br/>                get {<br/>                    call.respond(listOf&lt;Paragraph&gt;())<br/>                }<br/>                get("/encoded") {<br/>                    call.respond(listOf&lt;Paragraph&gt;())<br/>                }<br/>            }<br/>        }<br/>    }<br/>}.start(wait = true)<br/>}</span></pre><p id="05c1" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这个<code class="fe lp lq lr ls b"><strong class="kk iu">CIO</strong></code>实现是我们对所有服务进行测试的方式。本质上，我们将对cat语句执行<code class="fe lp lq lr ls b"><strong class="kk iu">GET’s</strong></code>，我们将<code class="fe lp lq lr ls b"><strong class="kk iu">POST’s</strong></code>将段落插入数据库，我们将<code class="fe lp lq lr ls b"><strong class="kk iu">GET</strong></code>它们，并且还将测试算法以编码的方式<code class="fe lp lq lr ls b"><strong class="kk iu">GET</strong></code>它们。我们将进一步了解将进行哪些测试。</p><h1 id="5ae1" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">4.<a class="ae lt" href="https://github.com/jesperancinha/whiskers-kotlin-native/tree/main/whiskers-graalvm" rel="noopener ugc nofollow" target="_blank"> GraalVM </a></h1><p id="5d93" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di"> G </span> <strong class="kk iu"> raalVM </strong>是一个高性能的运行时，它支持许多不同的语言，如<strong class="kk iu"> Java </strong>、<strong class="kk iu"> Javascript </strong>、<strong class="kk iu"> LLVM </strong>语言等。在这一节中，我们将了解的特定功能是<strong class="kk iu"> GraalVM </strong>创建本机映像和可执行文件的方式。这个想法是，我们选择一个可运行的jar文件，然后将它转换成可在命令行中使用的可执行文件或在云中使用的docker映像。对于GraalVM，我们将使用市场上最受欢迎的框架之一Spring Framework。我们将使用其反应形式，这是Ktor的首席信息官的工作方式。然而，我们需要记住，在本节中，我们并没有将Spring与<strong class="kk iu"> CIO </strong>一起使用。相反，我们将使用Netty，它通常是Spring的反应式实现的默认服务。我们还需要<strong class="kk iu"> </strong>考虑这可能会对我们的结果产生影响，因为简单地说，<strong class="kk iu"> CIO </strong>不是<strong class="kk iu"> Netty </strong>。</p><p id="8fba" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这一点上，我应该给你一个警告(如果以前没有给过的话),用GraalVM构建东西的资源消耗和用Kotlin Native构建一样高。请准备好<strong class="kk iu">内存不足问题</strong>、<strong class="kk iu">机器挂起</strong>，不得不重启<strong class="kk iu">、</strong>等。执行构建有时会非常困难和令人沮丧。</p><h1 id="abcb" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">4.1.<a class="ae lt" href="https://github.com/jesperancinha/whiskers-kotlin-native/tree/main/whiskers-runners/whiskers-runners-graalvm" rel="noopener ugc nofollow" target="_blank">可运行的jar实现</a></h1><p id="11df" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi lg translated">借助GraalVM，我们可以轻松地将jar转换成可执行的本地应用程序。在本文后面的内容中，我们将看到用GraalVM实现事情是多么容易，但是首先让我们看一下我们的<code class="fe lp lq lr ls b"><strong class="kk iu">gradle.build.kts</strong></code>文件:</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ov"><img src="../Images/3cf046174b1301609346354ac20db2b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rUFpBX7lR2gOjyUgCc7Oag.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><code class="fe lp lq lr ls b"><strong class="bd lw">gradle.build.kts</strong></code> <strong class="bd lw">配置文件进行编译</strong></figcaption></figure><p id="a747" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">您可能刚刚意识到，无论如何都没有对<strong class="kk iu"> GraalVM </strong>的引用。这是因为这只是一个普通的<strong class="kk iu"> GraalVM </strong>项目。但是，我们将通过发出以下命令来生成一个本地runnable:</p><pre class="mx my mz na gt nb ls np nq aw nr bi"><span id="f5df" class="ns lv it ls b gy nt nu l nv nj">$(JAVA_HOME)/bin/native-image -jar build/libs/whiskers-runners-graalvm-standalone.jar</span></pre><p id="373d" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这样做的目的是在根目录中创建一个生产就绪的本机映像。</p><p id="d9fb" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这将创建一个名为<code class="fe lp lq lr ls b"><strong class="kk iu">whiskers-runners-graalvm-standalone</strong></code> <strong class="kk iu"> </strong>的程序，它将包含与本机对应的<strong class="kk iu"> Kotlin </strong>完全相同的代码。</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/9dd824d1b53e8d54becc03ef53f7c9b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OUxFW1b5_fCgsDEbCtK8OA.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">可运行的GraalVM本机应用程序的Kotlin代码</figcaption></figure><h1 id="c4b5" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">4.2.<a class="ae lt" href="https://github.com/jesperancinha/whiskers-kotlin-native/tree/main/whiskers-graalvm" rel="noopener ugc nofollow" target="_blank">企业Spring原生服务实现</a></h1><p id="1e1d" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi lg translated">pring为我们提供了实现本地解决方案的不同方法。其中之一是一个独立的解决方案，它本质上允许我们在一个本地包中创建一个已编译的服务，该服务可以在我们选择的操作系统中运行。对于这种情况，我们的<strong class="kk iu"> Gradle </strong>文件需要考虑一种配置来允许这种情况发生。让我们来看看:</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ow"><img src="../Images/3551397622bf5c9be3c1947b431bc63b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pJf-XUCVxMq_AtgR993PVQ.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><code class="fe lp lq lr ls b"><strong class="bd lw">gradle.build.kts</strong></code> <strong class="bd lw">为GraalVM可运行</strong></figcaption></figure><p id="95b5" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">花一点时间来找出在这种配置中可能与GraalVM相关的内容。如果您没有找到它，这真的不是问题，因为它在文件的任何地方都不可见。它就是<code class="fe lp lq lr ls b"><strong class="kk iu">org.springframework.experimental.aot</strong></code> <strong class="kk iu"> </strong>插件。它的<a class="ae lt" href="https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/#_linux_and_macos" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">已经包含了</strong></a><a class="ae lt" href="https://github.com/spring-projects-experimental/spring-native" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">spring-native</strong></a>插件。要生成一个可运行的文件，我们只需运行以下命令:</p><pre class="mx my mz na gt nb ls np nq aw nr bi"><span id="70a6" class="ns lv it ls b gy nt nu l nv nj">./gradlew nativeCompile</span></pre><p id="0e6e" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在展示生成可执行文件的位置之前，让我们先看看代码。它是按照<strong class="kk iu">洋葱</strong>设计模式实现的，创建了大多数<strong class="kk iu"> Spring框架MVC </strong>环境；</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ox"><img src="../Images/680456626d151051e7b314891609ece9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZpfPKa-Yxgg5PYY_Z25Sgg.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd lw">故事控制器</strong></figcaption></figure><p id="63dd" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">对于应用程序的其余部分，一切都以这种方式完成。</p><p id="fa1e" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">构建完成后，可运行的将从模块的根目录开始在这个位置可用:</p><pre class="mx my mz na gt nb ls np nq aw nr bi"><span id="c2f8" class="ns lv it ls b gy nt nu l nv nj">./build/native/nativeCompile/whiskers-graalvm</span></pre><h1 id="eba9" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">4.3.<a class="ae lt" href="https://github.com/jesperancinha/whiskers-kotlin-native/tree/main/whiskers-cloudnative" rel="noopener ugc nofollow" target="_blank">企业Spring云原生服务实现</a></h1><p id="99fb" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di"/>云原生实现允许我们创建一个优化的映像，在Spring Cloud Native创建的容器中运行我们的可执行原生包。它是如何工作的，它调用哪个图像，以及它创建的容量对我们来说不再重要，不再是一个问题。我们只需创建云原生映像，然后就可以在容器中运行我们的原生解决方案。现在，让我们来看看Gradle构建文件:</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ow"><img src="../Images/bca88b34c43ff779387e90a37e70ed63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v2R0UlvvUVVxwhVJ4qvm9A.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><code class="fe lp lq lr ls b"><strong class="bd lw">gradle.build.kts</strong></code> <strong class="bd lw">为GraalVM云原生映像</strong></figcaption></figure><p id="e903" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这个<code class="fe lp lq lr ls b"><strong class="kk iu">gradle.build.kts</strong></code>文件中，很容易看出<a class="ae lt" href="https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/#getting-started-buildpacks" rel="noopener ugc nofollow" target="_blank">与</a>的不同之处。你能看见它吗？</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oy"><img src="../Images/8a097d760f517ad954919cc4104d0073.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OeWnH4W_algHADhsrT_fMA.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><strong class="bd lw">本地云映像构建的bootBuildImage脚本</strong></figcaption></figure><p id="0efd" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">因此，使用这个<code class="fe lp lq lr ls b"><strong class="kk iu">BootBuildImage</strong></code> <strong class="kk iu"> </strong>任务，我们可以轻松地构建一个映像，该映像将被推送到我们的本地Docker repo，它将被命名为:<code class="fe lp lq lr ls b"><strong class="kk iu">whiskers-cloudnative:0.0.1-SNAPSHOT</strong></code> <strong class="kk iu">。</strong></p><p id="6550" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这使得用一个简单的命令行运行变得很容易:</p><pre class="mx my mz na gt nb ls np nq aw nr bi"><span id="060c" class="ns lv it ls b gy nt nu l nv nj"><strong class="ls iu">docker run whiskers-cloudnative:0.0.1-SNAPSHOT</strong></span></pre><h1 id="a265" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">5.运行应用程序</h1><p id="472a" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">为了能够运行这些应用程序，我在项目的根目录和各个模块的根目录下创建了大量的脚本。很难保证这能在你的Linux机器上运行，但是我已经在两台Linux机器上测试过了，它看起来运行得很完美。所以分步骤来说，这就是我们需要做的。</span></p><ol class=""><li id="1050" class="oa ob it kk b kl km kp kq kt oc kx od lb oe lf oz og oh oi bi translated"><strong class="kk iu">安装环境:运行</strong>T4】</li><li id="b808" class="oa ob it kk b kl oj kp ok kt ol kx om lb on lf oz og oh oi bi translated"><strong class="kk iu">安装所有必要的软件包:运行</strong>T5】</li><li id="2dae" class="oa ob it kk b kl oj kp ok kt ol kx om lb on lf oz og oh oi bi translated"><strong class="kk iu">手动安装所有必要的可再发行软件:运行</strong> <code class="fe lp lq lr ls b"><strong class="kk iu">. ./init.sh</strong></code></li><li id="f6a4" class="oa ob it kk b kl oj kp ok kt ol kx om lb on lf oz og oh oi bi translated"><strong class="kk iu">生成构建:运行</strong> <code class="fe lp lq lr ls b"><strong class="kk iu">make b</strong></code></li><li id="1a19" class="oa ob it kk b kl oj kp ok kt ol kx om lb on lf oz og oh oi bi translated"><strong class="kk iu">运行所有测试:运行</strong> <code class="fe lp lq lr ls b"><strong class="kk iu">make measure-all</strong></code></li></ol><p id="40e7" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">所有这些运行都需要一些时间来完成。我建议您在运行构建时不要打开IntelliJ。构建会消耗资源，但也会创建大量的<strong class="kk iu">增量文件</strong>，这将使<strong class="kk iu"> IntelliJ </strong>完全混乱。如果你遇到问题，你可能会，请打开我的回购问题。我很乐意帮助你。支持本文的repo可能永远也不会支持这个星球上的每一台机器，因为它与生俱来的特性，但是我会尽我所能尽可能接近这个目标，有了您的投入，我会更快地达到这个目标。</p><h1 id="7e49" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">6.性能测试</h1><p id="faf1" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi translated">如果您成功运行了所有测试，您应该会在<a class="ae lt" href="https://github.com/jesperancinha/whiskers-kotlin-native/blob/main/Results.md" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">results . MD</strong></a><strong class="kk iu">f</strong>文件中获得最终结果:</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pa"><img src="../Images/2772df189df5bca176a32cb63ccbba53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bcaJqm0ps2P9f6wgtEnUsg.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">运行服务结果</figcaption></figure><figure class="mx my mz na gt ju gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/8a6a124affd8a6421ca5da9c90476c37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*leeQMldOKF_xt70KYOling.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">跑步者结果</figcaption></figure><h1 id="0ccd" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">7.结论</h1><p id="d912" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi lg translated">在研究Kotlin Native及其工作原理时，我们已经在这篇文章中看到，现实总是比宣传的差一些。我真的很喜欢Kotlin Native的想法，我认为这是一个很好的扩展，让我们走出自己的舒适区，简单地说就是尝试一些新的东西。</p><p id="868d" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这就是我想要的，也正是我在写这篇文章和实现这个案例来支持它时所实现的。我确实看到了更快的启动时间，我也确实看到了这方面的未来，也就是因为我们节省了大量资源。</p><p id="3d64" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">不幸的是，就性能而言，并不是一切都很清楚。在80年代，我们习惯于在直接使用C和C++时手动处理内存。然后Java在90年代后期成为主流。Java的初始阶段进行得非常顺利，因为大多数开发人员并不想为内存而烦恼，而且大多数开发人员想要一种更高级的语言。科林在2010年左右来到现场，想法是一样的。简而言之，科特林想把Java带到一个更高的水平。这一点确实已经实现。JVM一直在不断发展，变得更高效、更好。在我个人看来，本地化的想法与所有这些相矛盾，因为在某种程度上，我们对本地代码的工作方式给予了信任，并且在软件开发方面真正回到了我们的根本。这实际上可能是一个好迹象。在大学时，我的一位老师一直告诉我“你必须学习C，Java只是一种时尚”。几年后，科特林本地人相信了我老师最初说的话。但是不幸的是，回到C语言或者让Kotin编译成本地代码也意味着C语言背后的人，甚至普通的开发人员也需要知道C语言是如何工作的，这也意味着回到学习内存分配是如何工作的。这也意味着学习<code class="fe lp lq lr ls b"><strong class="kk iu">pointers</strong></code>如何工作、<code class="fe lp lq lr ls b"><strong class="kk iu">memory references</strong></code>如何工作、<code class="fe lp lq lr ls b"><strong class="kk iu">string</strong> <strong class="kk iu">terminators</strong></code>、<code class="fe lp lq lr ls b"><strong class="kk iu">pointers</strong></code>的<code class="fe lp lq lr ls b"><strong class="kk iu">pointer</strong></code>、<code class="fe lp lq lr ls b"><strong class="kk iu">pointers</strong></code>、<code class="fe lp lq lr ls b"><strong class="kk iu">struct</strong></code>等的内容。这可能是我们在测试性能时看到的有趣现象的原因。看起来，对于一个已经运行的进程来说，本机代码实际上会降低性能。如果JVM如此复杂，以至于它比我们几分钟内能想到的任何东西都要好，那么它可能是比本地化更好的选择。</p><p id="3512" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">因此，这篇文章的关键点是，当涉及到一般的本地化时，有几个优点和缺点，这两个优点和缺点同样适用于科特林本地人和T21本地人。所以我们来列举一下:</p><p id="9478" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated"><strong class="kk iu">优点</strong>:</p><ul class=""><li id="17ed" class="oa ob it kk b kl km kp kq kt oc kx od lb oe lf of og oh oi bi translated"><strong class="kk iu">极快的启动时间</strong>——但不要忘乎所以。我们说的是几秒钟的差别。对于没有耐心的人来说，这可能是一件好事。如果你正在考虑多次启动多个进程，那么这也是一件值得你关注的事情。</li><li id="0c26" class="oa ob it kk b kl oj kp ok kt ol kx om lb on lf of og oh oi bi translated"><strong class="kk iu">低内存使用率</strong>——毫无理由地继续使用JVM会对你的预算产生巨大的影响。对于多次运行的服务器或服务，它们执行的任务不需要高性能，也不需要符合苛刻的SLA和高可用性要求，这可能是一个理想的选择。</li><li id="cb5e" class="oa ob it kk b kl oj kp ok kt ol kx om lb on lf of og oh oi bi translated"><strong class="kk iu">即时峰值性能</strong> —这是本机应用程序的一个通常不太好解释的属性，这意味着<strong class="kk iu"> JIT </strong>在运行的应用程序中不起作用，因为应用程序所需的一切都已经提前编译好了(<strong class="kk iu"> AOT </strong>)。<strong class="kk iu"> </strong>这只是意味着一旦应用程序启动，它将不会执行任何优化任务，因为它发生在<strong class="kk iu">即时</strong>编译器(<strong class="kk iu"> JIT </strong>)中。这就是为什么多个短时间运行比<strong class="kk iu">本地</strong>和<strong class="kk iu">JVM</strong>中的长时间运行性能更好的原因。</li><li id="8a5d" class="oa ob it kk b kl oj kp ok kt ol kx om lb on lf of og oh oi bi translated"><strong class="kk iu">不需要运行JVM — </strong>我们可以在任何我们想要的地方运行可执行文件，而不需要担心JDK是否可用或者版本是否正确</li><li id="4221" class="oa ob it kk b kl oj kp ok kt ol kx om lb on lf of og oh oi bi translated">安全问题——因为我们正在使用本地编译的代码，而且我们已经在线运行了，大多数与JVM相关的安全问题都不再是问题。与运行中的jar可执行文件相比，本地编译的可执行文件在运行时更难更改。</li></ul><p id="64e6" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated"><strong class="kk iu">缺点</strong>:</p><ul class=""><li id="c85a" class="oa ob it kk b kl km kp kq kt oc kx od lb oe lf of og oh oi bi translated"><strong class="kk iu">缓慢的性能风险</strong>——正如我们在结果中看到的，无论我们以何种形式尝试，本机代码的性能似乎都比在<strong class="kk iu"> JVM </strong>中运行的常规代码差得多。</li><li id="c24b" class="oa ob it kk b kl oj kp ok kt ol kx om lb on lf of og oh oi bi translated"><strong class="kk iu">编译时间— </strong>在本机编译时，编译时间可能是一场噩梦。这对<strong class="kk iu"> GraalVM </strong>和<strong class="kk iu"> Kotlin Native </strong>有效。它还消耗了如此多的资源，以至于开发人员可能会发现他们的机器刚刚被阻塞，内存刚刚用完，他们不得不重新启动他们的机器。关键是，等待代码编译这么长时间并没有那么有用。这会影响开发时间和开发成本。</li></ul><p id="acbc" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果我们分析一下<strong class="kk iu">和</strong>的利弊，我们可能会相信<strong class="kk iu">《原生》</strong>也是一个不错的故事，但它还没有入围。对我来说，它真的很重要，但不是大多数情况下。有了这篇文章和它的案例，我已经可以保证这一点，正如我之前提到的，如果我们想要启动几个独立的有限进程，<strong class="kk iu"> Kotlin </strong> native目前是最好的选择。对于服务，我相信我们仍然需要等待<strong class="kk iu"> CIO </strong>的发展或者<strong class="kk iu"> Netty </strong>最终也支持<strong class="kk iu">原生</strong>。目前，我仍然看不到原生使用服务的明显好处。恰恰相反。</p><p id="672d" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">就数据库的使用而言，每次运行的结果差异如此之大，以至于我无法做出任何结论。<strong class="kk iu"> Netty </strong>和<strong class="kk iu">PostgreSQL</strong><strong class="kk iu">Native</strong><strong class="kk iu">Support</strong>for<strong class="kk iu">kot Lin</strong>仍在开发中，所以我对得出任何有意义的结论的期望并不高。然而，一旦<strong class="kk iu">本地支持最终可用</strong>，项目已经准备好执行测试。需要指出的另一件事是，尽管CIO支持协程，但我不能被动地访问数据库。这意味着数据库访问测试是以对数据库非反应性的方式进行的，这对我们回复客户端的方式有不利影响。</p><p id="b690" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">说到可运行测试，我确实看到了一些线索，表明在<strong class="kk iu"> C </strong>中使用我们自己的实现可能比使用<strong class="kk iu"> Kotlin-Native的</strong>自己的实现性能好一点。准确地说，在我们的示例中，相差<strong class="kk iu"> 161 </strong>到<strong class="kk iu"> 28 </strong>秒。无论如何，互操作配置本身似乎根本不会影响性能。</p><p id="878a" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">最后，我只想提一下，这篇文章不会有大的更新，只会有修改。当最终本地服务在运行性能方面优于普通服务时，我会再写一篇文章。这一个因为历史原因留了下来。</p><p id="f1aa" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我希望这篇文章能增加你对T2科特林语母语的兴趣。很明显，<strong class="kk iu"> Kotlin Native </strong>由于其性质仍然有相当多的限制，并且可能永远如此，但它确实显示了独立执行的好处。它的工作方式与GraalVM的工作方式完全相同。我在<strong class="kk iu"> Kotlin </strong>中编写了整个代码，因为我不想通过采用另一种语言如<strong class="kk iu"> Java </strong>或<strong class="kk iu"> Scala </strong>来包含更多的差异，但是我想说的是关于<strong class="kk iu"> Kotlin vs Java </strong>的观点。GraalVM 做了很多令人惊奇的事情，它已经可以兼容更多的东西。它本身已经可以使用已经在<strong class="kk iu"> netty </strong>上运行的服务来创建<strong class="kk iu">可执行文件</strong>，并且我们对我们可以实现的内容没有任何限制。我们不必将<strong class="kk iu"> GraalVM </strong>与<strong class="kk iu"> Java </strong>一起使用，因为它基本上是独立于语言的。那么，为什么是科特林本地人呢？我不知道！我不知道为什么科特林本地人。在本文中，我找不到一个清晰的迹象来说明为什么<strong class="kk iu"> Kotlin-Native </strong>与使用<strong class="kk iu"> GraalVM有任何不同。目前<strong class="kk iu"> GraalVM </strong>确实提供了更多的可能性，但是从长远来看，我不知道Kotlin-Native </strong>会发生什么。它们似乎是两种技术，很快将再次以某种受网飞启发的怀旧方式相互竞争，我已经准备好了解这种怀旧方式，并用一桶爆米花来消化。但是老实说，像<strong class="kk iu"> Java vs Kotlin </strong>，<strong class="kk iu"> GraalVM vs Kotlin-Native </strong>这又是一种令人惊讶的<code class="fe lp lq lr ls b"><strong class="kk iu">good-story</strong></code> <strong class="kk iu"> </strong>并且仅此而已。<code class="fe lp lq lr ls b"><strong class="kk iu">Goed verhaal </strong></code>反正用荷兰语。</p><p id="27f6" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我已经把这个应用程序的所有源代码放到了<a class="ae lt" href="https://github.com/jesperancinha/whiskers-kotlin-native" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上</p><p id="5d4c" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我希望你能像我喜欢写这篇文章一样喜欢它。</p><p id="25e2" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我很想听听你的想法，所以请在下面留下你的评论。</p><p id="6018" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">感谢您的阅读！</p><h1 id="f23a" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">8.参考</h1><p id="0949" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi translated"><a class="ae lt" href="https://kotlinlang.org/docs/native-get-started.html" rel="noopener ugc nofollow" target="_blank">https://kotlinlang.org/docs/native-get-started.html</a></p><div class="pc pd gp gr pe pf"><a href="https://cashapp.github.io/sqldelight/" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">SQLDelight</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">SQLDelight从您的SQL语句中生成类型安全的kotlin APIs。它验证您的模式、语句和迁移…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">cashapp.github.io</p></div></div></div></a></div><div class="pc pd gp gr pe pf"><a href="https://github.com/hfhbd/postgres-native-sqldelight" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">GitHub-HF hbd/postgres-native-sqldelight:一个用于SQL delight的Kotlin原生Postgres驱动程序。</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">SqlDelight的本机Postgres驱动程序。您需要在您的$PATH中安装并提供libpq。此包已上传…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">github.com</p></div></div><div class="po l"><div class="pp l pq pr ps po pt jz pf"/></div></div></a></div><div class="pc pd gp gr pe pf"><a href="https://github.com/kotlin-orm/ktorm" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">GitHub - kotlin-orm/ktorm:一个用于kotlin的轻量级orm框架，具有强类型SQL DSL和…</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">Ktorm是一个直接基于纯JDBC的轻量级高效的Kotlin框架。它提供了强类型和…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">github.com</p></div></div><div class="po l"><div class="pu l pq pr ps po pt jz pf"/></div></div></a></div><div class="pc pd gp gr pe pf"><a href="https://discuss.kotlinlang.org/t/kotlin-native-as-a-go-alternative-in-2021/23665" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">Kotlin(原生)作为2021年的围棋替代方案</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">大家好，我最近在2019年的这个论坛上读了一个比较Kotlin/Native to Go的帖子，我想知道是否…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">discuss.kotlinlang.org</p></div></div><div class="po l"><div class="pv l pq pr ps po pt jz pf"/></div></div></a></div><div class="pc pd gp gr pe pf"><a href="https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">AOT本地部署概述。网</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">将您的应用程序发布为AOT本地应用程序会生成一个独立的应用程序，并且已经提前(AOT)进行了编译…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">learn.microsoft.com</p></div></div><div class="po l"><div class="pw l pq pr ps po pt jz pf"/></div></div></a></div><div class="pc pd gp gr pe pf"><a href="https://en.wikipedia.org/wiki/Ahead-of-time_compilation" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">超前编译-维基百科</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">在计算机科学中，超前编译(AOT编译)是编译一个(通常)更高级别的…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">en.wikipedia.org</p></div></div><div class="po l"><div class="px l pq pr ps po pt jz pf"/></div></div></a></div><div class="pc pd gp gr pe pf"><a href="https://www.graalvm.org/why-graalvm/" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">为什么选择GraalVM？</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">GraalVM是为Java和其他JVM语言编写的高性能JDK发行版，同时支持…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">www.graalvm.org</p></div></div><div class="po l"><div class="py l pq pr ps po pt jz pf"/></div></div></a></div><div class="pc pd gp gr pe pf"><a href="https://blogs.oracle.com/java/post/simplifying-the-cloud-native-journey-with-graalvm-and-helidon" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">使用GraalVM和Helidon简化云原生之旅</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">Unsplash渣打银行是一家国际银行和金融服务公司</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">blogs.oracle.com</p></div></div><div class="po l"><div class="pz l pq pr ps po pt jz pf"/></div></div></a></div></div></div>    
</body>
</html>