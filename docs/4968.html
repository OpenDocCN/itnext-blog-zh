<html>
<head>
<title>Event driven updates with Firebase Functions triggered from Firestore updates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Firestore更新中触发具有Firebase功能的事件驱动更新</h1>
<blockquote>原文：<a href="https://itnext.io/event-driven-updates-with-firebase-functions-triggered-from-firestore-updates-fb6a62407b3b?source=collection_archive---------3-----------------------#2020-11-04">https://itnext.io/event-driven-updates-with-firebase-functions-triggered-from-firestore-updates-fb6a62407b3b?source=collection_archive---------3-----------------------#2020-11-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b4a7fb7e6787c96f706a0a002d4e0ae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lk9aZHgPliF6A16riZMAfg.jpeg"/></div></div></figure><p id="57bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想象一个典型的场景，用户将从前端发起一个动作，该动作将触发对管理数据集的更新。当然，您可以在操作过程中直接进行更新，但这可能会导致更长的操作时间，甚至导致错误。</p><blockquote class="kw kx ky"><p id="9664" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">保持用户界面/UX尽可能的流畅和快速应该是一个优先考虑的问题，因此最好是只为用户做最不必要的动作，异步地做任何其他的任务。</p></blockquote><p id="b28c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种管理任务的一些例子可以是给定项目的等级的重新计算，或者是<a class="ae ld" href="https://www.hotjar.com/net-promoter-score/" rel="noopener ugc nofollow" target="_blank"> NPS </a>分数。</p><h1 id="fe18" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">前端代码——React或任何其他框架</h1><p id="916b" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">在这种情况下，我们将重点关注NPS示例。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b8d6" class="mq lf iq mm b gy mr ms l mt mu">import app from "firebase/app";<br/>import "firebase/firestore";<br/>class Firebase {<br/>  constructor() {<br/>    app.initializeApp(config);<br/>    this.store = app.firestore();<br/>  }<br/>  trackNPSVote = async ({ score, comment = "" }) =&gt; {<br/>    const NPSRef = this.store.collection("NPS");<br/>    let autoID = await NPSRef.doc().id;<br/>    const data = {<br/>      score,<br/>      createdAt: new Date().toISOString(),<br/>      comment,<br/>    };<br/>    return await NPSRef.doc(`${autoID}`).set(data);<br/>  };<br/>}<br/>export default Firebase;</span></pre><p id="7a44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，需要调用这段代码，想象一个简单的UI，有1-10个按钮和一个可选的注释字段，在提交时，调用trackNPSVote函数。</p><h1 id="81e6" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">后端代码—云功能</h1><p id="5d2c" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">现在，我们需要监听用户在我们的云函数中创建的新文档(NPS条目)</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ca44" class="mq lf iq mm b gy mr ms l mt mu">const functions = require("firebase-functions");<br/>function calculateNPS(scores) {<br/>  var promoters = 0;<br/>  var detractors = 0;<br/>  for (var i = 0, l = scores.length; i &lt; l; i++) {<br/>    if (scores[i] &gt;= 9) promoters++;<br/>    if (scores[i] &lt;= 6) detractors++;<br/>  }<br/>  return Math.round((promoters / l - detractors / l) * 100);<br/>}<br/>exports.onNPSQuestionnaireFilled = functions.firestore<br/>  .document("NPS/{npsEntry}")<br/>  .onCreate(async (snap) =&gt; {<br/>    const questionnaire = snap.data();<br/>    const npsRef = firestore.collection("adminCollection").doc("NPS");<br/>    const doc = await npsRef.get();<br/>    try {<br/>      // we already have some historic data<br/>      if (doc.exists) {<br/>        const npsStats = doc.data();<br/>        npsStats.scores.push(questionnaire.score);<br/>        npsStats.score = calculateNPS(npsStats.scores);<br/>        return await npsRef.set(npsStats);<br/>      } else {<br/>        // we need to create the document<br/>        const score = calculateNPS([questionnaire.score]);<br/>        const data = {<br/>          score: score,<br/>          scores: [questionnaire.score],<br/>        };<br/>        await npsRef.set(data);<br/>      }<br/>      return true;<br/>    } catch (err) {<br/>      console.error(err.message);<br/>    }<br/>  });</span></pre><p id="4ff3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以计算我们的NPS或任何其他任意KPI，而不会对我们的用户造成任何干扰。</p></div></div>    
</body>
</html>