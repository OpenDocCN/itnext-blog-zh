<html>
<head>
<title>Setting up transactional tests with Pytest and SQLAlchemy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Pytest和SQLAlchemy设置事务性测试</h1>
<blockquote>原文：<a href="https://itnext.io/setting-up-transactional-tests-with-pytest-and-sqlalchemy-b2d726347629?source=collection_archive---------1-----------------------#2020-11-02">https://itnext.io/setting-up-transactional-tests-with-pytest-and-sqlalchemy-b2d726347629?source=collection_archive---------1-----------------------#2020-11-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8965f6170adc861cad6d91b079dc8159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ByxRpZMh6ZRmxt7t"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@cdr6934?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯里德</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="e809" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">来自Ruby on Rails的背景，我非常欣赏那些成为解决问题的社区标准的解决方案。其中一个就是<a class="ae kf" href="https://github.com/DatabaseCleaner/database_cleaner" rel="noopener ugc nofollow" target="_blank"> DatabaseCleaner gem </a>，它可以确保你的测试是分开运行的，并且它们之间没有数据泄漏。</p><p id="7fdf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最近我在寻找一个类似的Python解决方案，但是，令我惊讶的是，我没有找到任何解决方案。然而，很容易利用SQLAlchemy和Pytest提供的功能将测试包装在单独的数据库事务中。让我向你展示一个简洁的解决问题的方法，希望你会觉得用起来很方便。</p><h1 id="bb97" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">设置数据库连接</h1><p id="c1c7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在我们能够在测试中使用包含事务的数据库之前，我们需要专门为测试设置一个单独的DB实例。然后，从我们的测试套件中，我们需要连接到数据库。以下是如何与MySQL数据库建立连接的示例:</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="9bcd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您使用另一个数据库引擎，请前往<a class="ae kf" href="https://docs.sqlalchemy.org/en/13/core/engines.html" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy文档</a>获取有关如何构建不同连接字符串的信息。</p><h1 id="9c60" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">表创建和数据库播种</h1><p id="644e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在我们需要重新创建我们的数据库结构。让我们假设您的应用程序中的所有模型都在<code class="fe mn mo mp mq b">models.py</code>文件中声明。</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="186e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">SQLAlchemy提供了一些方法来轻松地创建和删除模式中声明的表:<code class="fe mn mo mp mq b">create_all</code>和<code class="fe mn mo mp mq b">drop_all</code>。我们将在测试套件执行的开始使用它们，以确保所有的表都在适当的位置。在完整的测试运行之后，我们将删除所有的表，以便下一次执行可以从头开始。</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="7653" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您需要用一些数据预先配置数据库，您可以运行一个方法来播种数据库。一个简单的例子如下:</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h1 id="7cfb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">交易中的包装测试</h1><p id="84fe" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">作为最后一步，我们需要建立一种在测试套件中使用事务的方法。因此，我们将构建一个夹具，为每个测试创建一个新的事务。</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="b6e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，您可以将fixture注入到您的测试用例中。在每个测试执行的最后，所有创建的数据都将被清除，确保测试用例的分离。</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h1 id="437a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">摘要</h1><p id="cc96" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">一旦您知道如何做，用Pytest和SQLAlchemy设置工作事务并不需要太多时间。我希望你会发现这个解决方案简洁易用。当然，如果你有任何想法要分享或提出改进，请在评论中告诉我——我总是很乐意学习新的东西。</p><p id="fdbd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为将来的参考，下面是一个完整的代码，您可以在您的项目中重用。祝你好运，并享受用事务编写测试的乐趣！</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure></div></div>    
</body>
</html>