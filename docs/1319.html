<html>
<head>
<title>Decouple View Components with Dependency Inversion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用依赖反转解耦视图组件</h1>
<blockquote>原文：<a href="https://itnext.io/decoupling-app-and-ui-components-cbcea3653d00?source=collection_archive---------3-----------------------#2018-09-10">https://itnext.io/decoupling-app-and-ui-components-cbcea3653d00?source=collection_archive---------3-----------------------#2018-09-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d05d55f72d120b677b1fa17c5bc66525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DE3DeEf86mFYuurjaT4MFg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来自Flickr上的<a class="ae kc" href="https://www.flickr.com/photos/rocor/40020297094" rel="noopener ugc nofollow" target="_blank">rocor</a></figcaption></figure><p id="8b94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章是关于使用依赖反转来分离视图组件的。这样做的好处如下:更简洁易读的呈现函数、减少的导入和分离的组件。</p><h1 id="986c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">基于组件的用户界面</h1><p id="937f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">基于组件的UI开发是web应用程序开发的标准。组件树代表了UI的每一种可能的状态。它的美妙之处在于你永远不必考虑组件树。您可以一次只关注一个组件，以及它所呈现的组件。可以将组件集合在一起，并制作成一个包，以便于导入；但是，在某些框架中，UI组件仍然需要导入到使用它们的每个组件中(Vue除外，yay Vue！).</p><p id="40ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在组件之前，你需要根据UI库的文档构建一组HTML元素，比如Bootstrap。然后，您可以编写一些JS来查找HTML并使其具有交互性。现在，有了组件，我们有了一个更有凝聚力的模型来构建应用程序。需要最少的协调，因为组件包含了它需要的大部分内容，您只需要与组件支持的道具和事件进行交互。</p><p id="7dcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">UI组件的一个优点是它与代码库的其他非UI部分非常相似。你导入你需要的东西，然后你用参数调用它，让它做你想做的事情；然而，有时候一层<a class="ae kc" href="https://en.wikipedia.org/wiki/Indirection" rel="noopener ugc nofollow" target="_blank">间接</a>/抽象会产生更好的代码。</p><h1 id="6182" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">UI组件中的依赖倒置</h1><p id="8f1d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我还没有见过这种类型的模式用于解决基于组件的架构中视图组件之间的依赖关系，但是在我看来，这种模式利大于弊。</p><p id="4b90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看看一个组件在React应用程序中可能是什么样子。我从<a class="ae kc" href="https://material-ui.com/demos/cards/" rel="noopener ugc nofollow" target="_blank">的Material-UI文档</a>中拿了这个例子。我用React的createElement方法替换了JSX。为了消除噪音，我将null作为道具传递给所有组件。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="760a" class="mn lc iq mj b gy mo mp l mq mr">import { createElement as h } from 'react';<br/>import Card from '@material-ui/core/Card';<br/>import CardActionArea from '@material-ui/core/CardActionArea';<br/>import CardActions from '@material-ui/core/CardActions';<br/>import CardContent from '@material-ui/core/CardContent';<br/>import CardMedia from '@material-ui/core/CardMedia';<br/>import Button from '@material-ui/core/Button';<br/>import Typography from '@material-ui/core/Typography';</span><span id="b870" class="mn lc iq mj b gy ms mp l mq mr">function MediaCard (props) {<br/>  return h(Card, null,<br/>    h(CardActionArea, null,<br/>      h(CardMedia, null),<br/>      h(CardContent, null,<br/>        h(Typography, null, 'Lizard')<br/>      )<br/>    ),<br/>    h(CardActions, null,<br/>      h(Button, null, 'Share')<br/>    )<br/>  )<br/>}</span></pre><p id="57ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所见，很大一部分代码是import语句。此外，该组件与材料UI库不可分割地耦合在一起。这是一个孤立的小例子，但是想象一下有多少不同的应用程序组件使用卡作为UI。根据我在React的经验，代码库的很大一部分是导入语句。</p><p id="12c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看当使用依赖反转时，组件可能是什么样子。让我们称这个抽象为“ui-resolver”。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4e1c" class="mn lc iq mj b gy mo mp l mq mr">import uiResolver from '../ui-resolver'<br/>const h = uiResolver.createElement</span><span id="3fe1" class="mn lc iq mj b gy ms mp l mq mr">function MediaCard (props) {<br/>  return h('card', null,<br/>    h('card-main', null,<br/>      h('card-media', null),<br/>      h('card-content', null,<br/>        h('text', null, 'Lizard')<br/>      )<br/>    ),<br/>    h('card-actions', null,<br/>      h('button', null, 'Share')<br/>    )<br/>  )<br/>}</span><span id="28bc" class="mn lc iq mj b gy ms mp l mq mr">// optional step<br/>uiResolver.on('media-card', MediaCard)</span></pre><p id="01a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第二个版本中，MediaCard组件完全不依赖于材质UI库。材料设计卡是一种通用设计模板，由许多UI包实现。你可能已经注意到，不太明显的部分是，现在我们的组件不再依赖于React！我们可以将这个“MediaCard”组件用于任何组件库，只要我们可以将参数映射到组件框架的API。</p><p id="81c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在视图组件中使用依赖反转让我想起了使用web组件。您必须确保您已经将web组件导入到您的项目中，但是一旦导入，您就可以在任何您想要的地方使用它。像定制元素一样，如果组件没有注册，我们可以设置ui-resolver静默失败。ui-resolver还可以向控制台输出警告，而自定义元素则不能。</p><p id="e429" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看看如何设置它。首先，将所有的材质UI组件聚集在一起，作为ui-resolver的插件。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6dab" class="mn lc iq mj b gy mo mp l mq mr">import { createElement } from 'react';<br/>import Card from '@material-ui/core/Card';<br/>import CardActionArea from '@material-ui/core/CardActionArea';<br/>import CardActions from '@material-ui/core/CardActions';<br/>import CardContent from '@material-ui/core/CardContent';<br/>import CardMedia from '@material-ui/core/CardMedia';<br/>import Button from '@material-ui/core/Button';<br/>import Typography from '@material-ui/core/Typography';</span><span id="3cf0" class="mn lc iq mj b gy ms mp l mq mr">const h = c =&gt; (...args) =&gt; createElement(c, ...args)</span><span id="2ca2" class="mn lc iq mj b gy ms mp l mq mr">export default function UiLibrary (uiResolver, options) {<br/>  const { on } = uiResolver<br/><br/>  on('button', h(Button))<br/>  on('card', h(Card))<br/>  on('card-main', h(CardActionArea))<br/>  on('card-actions', h(CardActions))<br/>  on('card-content', h(CardContent))<br/>  on('card-media', h(CardMedia))<br/>  on('button', h(Button))<br/>  on('text', h(Typography))<br/>}</span></pre><p id="715a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，实例化ui-resolver并传递插件。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fcf2" class="mn lc iq mj b gy mo mp l mq mr">import UiResolverLib from 'ui-resolver-lib'<br/>import UiLibrary from './ui-library'</span><span id="f52f" class="mn lc iq mj b gy ms mp l mq mr">const uiResolver = UiResolverLib()<br/>uiResolver.use(UiLibrary)</span><span id="4079" class="mn lc iq mj b gy ms mp l mq mr">export default uiResolver</span></pre><p id="6200" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法的缺点怎么样？有一些小的计算开销。你也不能用JSX(至少现在还不能)。</p><h1 id="4196" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">参考实现</h1><p id="4144" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我整理了一个名为<a class="ae kc" href="https://github.com/rhythnic/ioku" rel="noopener ugc nofollow" target="_blank"> Ioku </a>的小型参考实现(名称可能会改变)。这是30行代码，没有经过测试，还没有使用过，除了玩玩之外，不鼓励做任何事情。当我有时间确定这个想法是否可行时，我会开始重复它。如果有人对探索这个想法感兴趣，我们非常欢迎投稿。</p></div></div>    
</body>
</html>