<html>
<head>
<title>Angular Refactoring Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度重构示例</h1>
<blockquote>原文：<a href="https://itnext.io/angular-refactoring-examples-1fc16c4e58ff?source=collection_archive---------0-----------------------#2020-09-22">https://itnext.io/angular-refactoring-examples-1fc16c4e58ff?source=collection_archive---------0-----------------------#2020-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bafa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">重构Angular应用程序的常见模式、技巧和诀窍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d2113acd67fc2230f4aa81913811ad8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qNdydoGN3QCpH-33oc4rjA.png"/></div></div></figure><p id="212e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">源代码:</strong> <a class="ae lq" href="https://stackblitz.com/edit/angular-refactoring-erxk?file=src/app/app.component.ts" rel="noopener ugc nofollow" target="_blank"> StackBlitz <strong class="kw iu">🚀</strong>T19】</a></p><p id="6c8e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">文章目标:</strong>了解我们在Angular应用程序中可以重构的常见模式</p><p id="4779" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">文章主题(我们将学习什么)</strong></p><ul class=""><li id="cd54" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">用<code class="fe ma mb mc md b">:host</code> / <code class="fe ma mb mc md b">HostBinding</code> / <code class="fe ma mb mc md b">HostListener</code>替换组件“包装器”</li><li id="85b4" class="lr ls it kw b kx me la mf ld mg lh mh ll mi lp lw lx ly lz bi translated">用更多的<strong class="kw iu">声明性</strong>技术取代<code class="fe ma mb mc md b">BehaviorSubject.getValue()</code>用法。</li><li id="66d3" class="lr ls it kw b kx me la mf ld mg lh mh ll mi lp lw lx ly lz bi translated">将做所有事情的组件替换到<strong class="kw iu">容器</strong> &amp; <strong class="kw iu">表示性</strong>组件中</li></ul><p id="77fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mj">重构</em>是一种技术，用于<strong class="kw iu">改进现有代码的设计，同时保留其行为</strong>。本文主要关注重构的具体例子，而不是如何从概念上进行重构。</p><blockquote class="mk ml mm"><p id="4b8a" class="ku kv mj kw b kx ky ju kz la lb jx lc mn le lf lg mo li lj lk mp lm ln lo lp im bi translated">代码设计可能是主观的，这些例子可能倾向于个人偏好。我们将改变设计，但不会改变基本功能。无论重构与否，这两种方法都应该是有效的。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">相同的功能，不同的外观😀</figcaption></figure><h1 id="4a92" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">替换组件包装元素</h1><p id="f84e" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">我们在Angular应用程序中可能看到的一种常见情况是将组件的所有元素包装在一个“包装器”元素中。</p><p id="d9ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，我们主要关注重构模板中的外部<code class="fe ma mb mc md b">div</code>包装器。这个div完成了几件事情:使组件成为块级元素，添加鼠标监听器，以及动态设置边框颜色。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/8d020a37ceb3a9af933726804b38cd3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TF8HXdiGjNgKAQstFF_zvQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><a class="ae lq" href="https://stackblitz.com/edit/angular-refactoring-erxk?file=src%2Fapp%2Fhost-refactor%2Fhost-before.component.ts" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="2ad1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下面的代码片段中，我们已经完全移除了外部的<code class="fe ma mb mc md b">div</code>，进行了以下更改:</p><ul class=""><li id="a3d5" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated"><code class="fe ma mb mc md b">div</code>已经被一个<code class="fe ma mb mc md b">:host</code> css选择器所取代，它将声明<code class="fe ma mb mc md b">display: block</code>并完成<code class="fe ma mb mc md b">div.container</code>之前所做的事情</li><li id="bf09" class="lr ls it kw b kx me la mf ld mg lh mh ll mi lp lw lx ly lz bi translated"><code class="fe ma mb mc md b">(mouseenter)</code>事件绑定已经被替换为向其相应的函数添加<code class="fe ma mb mc md b">HostListener('mouseenter')</code>装饰器</li><li id="9428" class="lr ls it kw b kx me la mf ld mg lh mh ll mi lp lw lx ly lz bi translated"><code class="fe ma mb mc md b">[style.border-color]</code>属性绑定已经被替换为将<code class="fe ma mb mc md b">HostBinding(style.border-color)</code>装饰器添加到其相应的函数中</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/f553fedaa1b15efda5d13cf089ac6280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LVF_q2v8d985JNhwdWDeMQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><a class="ae lq" href="https://stackblitz.com/edit/angular-refactoring-erxk?file=src%2Fapp%2Fhost-refactor%2Fhost-refactor.component.ts" rel="noopener ugc nofollow" target="_blank">信号源</a></figcaption></figure><h2 id="cfc1" class="nv mx it bd my nw nx dn nc ny nz dp ng ld oa ob ni lh oc od nk ll oe of nm og bi translated"><strong class="ak">提示:表单元素&amp;显示内容</strong></h2><p id="3829" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">如果一个表单元素是你的组件(包装器)的第一个也是唯一的子元素。将form元素设置为<code class="fe ma mb mc md b">display: contents</code>，将表单的子元素视为宿主的子元素。<a class="ae lq" href="https://caniuse.com/#feat=css-display-contents" rel="noopener ugc nofollow" target="_blank">警告:实验性🧪 </a></p><h1 id="ed14" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">正在删除BehaviorSubject.getValue()的用法</h1><p id="5a22" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">Angular利用并促进库<a class="ae lq" href="https://www.learnrxjs.io/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>的使用；它遵循<a class="ae lq" href="https://en.wikipedia.org/wiki/Declarative_programming" rel="noopener ugc nofollow" target="_blank">声明式</a>编程范例。</p><p id="d2eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为一个在使用Angular之前花了所有时间编写命令式Java代码的开发人员，当我不知道如何以声明式/RxJS方式实现某件事情时，<code class="fe ma mb mc md b">BehaviorSubject.getValue()</code>是一个快速的答案。</p><p id="8883" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一些方法，我们可以学习声明性范例，替换<code class="fe ma mb mc md b">BehaviorSubject.getValue()</code>的用法。</p><h2 id="ead3" class="nv mx it bd my nw nx dn nc ny nz dp ng ld oa ob ni lh oc od nk ll oe of nm og bi translated">扫描—将值保存和检索为可观察状态</h2><blockquote class="mk ml mm"><p id="c92e" class="ku kv mj kw b kx ky ju kz la lb jx lc mn le lf lg mo li lj lk mp lm ln lo lp im bi translated">当前页码示例📄</p></blockquote><p id="9280" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">跟踪计数，就像分页器中的当前页码。当用户改变页面时，我们希望增加或减少计数。注意<code class="fe ma mb mc md b">currentPageNumber.getValue()</code>计算总和的用法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/ba7c341129e89f93b20198faca23c4de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4FboHcbWy2jk624vCbDBRA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><a class="ae lq" href="https://stackblitz.com/edit/angular-refactoring-erxk?file=src%2Fapp%2Fbs-refactor%2Fbs-before.component.ts" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="901d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用<a class="ae lq" href="http://reactivex.io/documentation/operators/scan.html" rel="noopener ugc nofollow" target="_blank">扫描操作符</a>将当前页码保存为状态，然后在每次发射时递增或递减该状态，而不是每次都使用<code class="fe ma mb mc md b">.getValue()</code>来获取当前页码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/2868ce61503fd4b45d43b92d23419c4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ImmaXaPq9eEdAakdiVj6w.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><a class="ae lq" href="https://stackblitz.com/edit/angular-refactoring-erxk?file=src%2Fapp%2Fbs-refactor%2Fbs-refactor.component.ts" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="8ec9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个上下文中，<code class="fe ma mb mc md b">acc</code>，是我们的累计值。实际上，<code class="fe ma mb mc md b">acc</code>是前一次发射时扫描返回的值(或者是来自<code class="fe ma mb mc md b">getValue()</code>的值)。<code class="fe ma mb mc md b">curr</code>是当前排放/下一次排放()的值。</p><h2 id="3748" class="nv mx it bd my nw nx dn nc ny nz dp ng ld oa ob ni lh oc od nk ll oe of nm og bi translated">withLatestFrom &amp; combineLatests —在发射期间获取值</h2><blockquote class="mk ml mm"><p id="7e04" class="ku kv mj kw b kx ky ju kz la lb jx lc mn le lf lg mo li lj lk mp lm ln lo lp im bi translated">保存活跃用户数据示例️🤸‍♀️</p></blockquote><p id="8ca7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有时我们在可观测的A的发射期间有副作用，我们需要来自可观测的B的最后发射/当前值来进行计算。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/a309622b85fe83dca7960a4d46c782e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ctHy0BHRgBolfprYVZLHA.png"/></div></div></figure><p id="51f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ma mb mc md b">withLatestFrom</code>将从我们的可观测值中获取最新值，并将其添加到下一个运算符中。注意<code class="fe ma mb mc md b">[v, u]</code>下面的<code class="fe ma mb mc md b">filter</code>和<code class="fe ma mb mc md b">switchMap</code>中的参数数组。—在这种情况下，来自<code class="fe ma mb mc md b">withLatestFrom</code>的<code class="fe ma mb mc md b">u</code>的值将是我们从<code class="fe ma mb mc md b">this.activeUser.getValue()</code>中检索到的值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/85fb5919eab1c422c7eae624de841cdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IqDDcHyLneKAhhsZs1olPQ.png"/></div></div></figure><p id="a338" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们希望我们的可观察对象(<code class="fe ma mb mc md b">saveValueToDb$</code>)在我们的<code class="fe ma mb mc md b">activeUser</code>改变/发射时发射，我们应该使用<code class="fe ma mb mc md b">combineLatest</code>。否则使用<code class="fe ma mb mc md b">withLatestFrom</code>避免<code class="fe ma mb mc md b">activeUser</code>在<code class="fe ma mb mc md b">saveValueToDb$</code>可观察发射时产生影响。</p><blockquote class="mk ml mm"><p id="1b9e" class="ku kv mj kw b kx ky ju kz la lb jx lc mn le lf lg mo li lj lk mp lm ln lo lp im bi translated">注意，我们的源观测器<code class="fe ma mb mc md b"><em class="it">saveValueToDb$</em></code>不会发射，直到<code class="fe ma mb mc md b"><em class="it">formSaved$</em></code>和<code class="fe ma mb mc md b"><em class="it">activeUser</em></code>都发射了至少一次。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/b54546cc76fccc403f3db825221662c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZetH13g95eaKEvcD13NZfg.png"/></div></div></figure><h1 id="90f4" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">容器和表示组件📦</h1><p id="ff2b" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">有时候，将一个组件分解成<strong class="kw iu">容器组件(关注事物如何工作)</strong>和<strong class="kw iu">表示组件(关注事物看起来如何)</strong>是有益的。—下面是一个在Angular应用程序中进行区分的示例:</p><p id="828f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的原始组件完成所有工作。它注入依赖关系，处理异步逻辑，定义列表中每一项的外观/格式，并定义事件的逻辑。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/d881edc396823b3dd9088e67425e0fe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9JXsf-vm1irbgv1y5ek9uA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><a class="ae lq" href="https://stackblitz.com/edit/angular-refactoring-erxk?file=src%2Fapp%2Finput-refactor%2Finput-before.component.ts" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="9515" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的新容器组件将处理:注入依赖/数据源<code class="fe ma mb mc md b">constructor(private ps: InputRefactorService)</code>、异步逻辑<code class="fe ma mb mc md b">people$ | async</code>和事件逻辑<code class="fe ma mb mc md b">this.ps.deleteEvent.next(...)</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/3c2b4968daadfaa27f665b68955ad85d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xk4DIEGN3xvWOzVMJzWCKA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><a class="ae lq" href="https://stackblitz.com/edit/angular-refactoring-erxk?file=src%2Fapp%2Finput-refactor%2Finput-refactor-container.component.ts" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="6813" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的表示组件<strong class="kw iu">接受来自容器</strong>的数据作为输入，而<strong class="kw iu">通过输出将逻辑委托给容器</strong>。它不知道任何依赖关系，person是异步/同步的，或者在remove上执行什么逻辑。</p><p id="793e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我觉得这个不必很严格。我们通常可以遵从对用例最有意义的东西。</p><p id="0b75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为一个额外的好处，像这样的表示组件使得自信地设置<code class="fe ma mb mc md b">ChangeDetectionStrategy.OnPush</code>变得更加容易。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/d9e61edacc6b7d0825c82f6e0b055ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zOYONDgbGrRaSORuBPbGPA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><a class="ae lq" href="https://stackblitz.com/edit/angular-refactoring-erxk?file=src%2Fapp%2Finput-refactor%2Finput-refactor-presentational.component.ts" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><h1 id="f3e0" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">参考</h1><ul class=""><li id="9f91" class="lr ls it kw b kx no la np ld om lh on ll oo lp lw lx ly lz bi translated"><a class="ae lq" href="https://stackoverflow.com/questions/37089977/how-to-get-current-value-of-rxjs-subject-or-observable/45227115#45227115" rel="noopener ugc nofollow" target="_blank">行为主体getValue Ben Lesh </a></li><li id="835c" class="lr ls it kw b kx me la mf ld mg lh mh ll mi lp lw lx ly lz bi translated"><a class="ae lq" href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" rel="noopener">丹·阿布拉莫夫(React)的演示组件</a></li><li id="5159" class="lr ls it kw b kx me la mf ld mg lh mh ll mi lp lw lx ly lz bi translated"><a class="ae lq" href="https://angular.io/docs" rel="noopener ugc nofollow" target="_blank">角度文件</a></li></ul><blockquote class="mk ml mm"><p id="5cd7" class="ku kv mj kw b kx ky ju kz la lb jx lc mn le lf lg mo li lj lk mp lm ln lo lp im bi translated">☁️<a class="ae lq" href="https://flotes.app" rel="noopener ugc nofollow" target="_blank">flotes</a>——尝试演示，无需登录。或者免费报名。Flotes是我记笔记和高效学习的方式，即使在我很忙的时候。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/8e468f6e74135bbbc2ecbfce7e2db2bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wGqAj2R16w33dIiKDnHEUA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><a class="ae lq" href="https://flotes.app" rel="noopener ugc nofollow" target="_blank">漂浮物</a></figcaption></figure></div></div>    
</body>
</html>