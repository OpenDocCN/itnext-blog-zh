<html>
<head>
<title>Ultimate guide to concurrent logging in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js并发登录终极指南</h1>
<blockquote>原文：<a href="https://itnext.io/ultimate-guide-to-concurrent-logging-in-node-js-4e47bd2eae37?source=collection_archive---------0-----------------------#2020-01-31">https://itnext.io/ultimate-guide-to-concurrent-logging-in-node-js-4e47bd2eae37?source=collection_archive---------0-----------------------#2020-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e9b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有一个每个人都会认识到的问题:由并发任务产生的日志没有它们的启动上下文是没有用的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/bc13e6db483c855cf2c6cf7bbf6d35f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EYyvWqemYy7Ndgd6EqOe5A.jpeg"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">罗尔。Node.js最强大的日志记录器</figcaption></figure><p id="8c69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你需要一个例子，考虑一个程序，它在接收到一个事件后执行一些产生日志的代码。它可能是传入的HTTP请求、作业队列等。，例如</p><pre class="kp kq kr ks gt la lb lc ld aw le bi"><span id="e502" class="lf lg it lb b gy lh li l lj lk">process.on('task', (task) =&gt; {<br/>  executeTask(task);<br/>});</span><span id="c82e" class="lf lg it lb b gy ll li l lj lk">const executeTask = async (task) =&gt; {<br/>  try {<br/>    // [..]</span><span id="b0a5" class="lf lg it lb b gy ll li l lj lk">    console.log('task completed');<br/>  } catch (error) {<br/>    console.log('task failed');<br/>  }<br/>};</span></pre><p id="620c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际上，该程序将生成如下所示的日志:</p><pre class="kp kq kr ks gt la lb lc ld aw le bi"><span id="dadc" class="lf lg it lb b gy lh li l lj lk">task completed<br/>task completed<br/>task failed<br/>task completed<br/>task failed</span></pre><p id="0d68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关键是，如果我们想要生成有意义的日志，那么我们必须以某种方式将<code class="fe lm ln lo lb b">task</code>与每个日志消息关联起来。</p><pre class="kp kq kr ks gt la lb lc ld aw le bi"><span id="01e5" class="lf lg it lb b gy lh li l lj lk">const executeTask = async (task) =&gt; {<br/>  try {<br/>    await download(task.url);</span><span id="f576" class="lf lg it lb b gy ll li l lj lk">    console.log({task}, 'task completed');<br/>  } catch (error) {<br/>    console.log({task}, 'task failed');<br/>  }<br/>};</span></pre><p id="54b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">问题是，为了实现这一点，您必须将<code class="fe lm ln lo lb b">task</code>对象传递给每个生成日志的函数。在我们的例子中，将<code class="fe lm ln lo lb b">task</code>添加到<code class="fe lm ln lo lb b">console.log</code>很容易，但是通常产生代码的函数是深度嵌套的，或者它们是第三方模块，没有办法将额外的上下文传递给记录器。</p><pre class="kp kq kr ks gt la lb lc ld aw le bi"><span id="1bf5" class="lf lg it lb b gy lh li l lj lk">const download = (url) =&gt; {<br/>  if ([..]) {<br/>    return console.error('invalid url');<br/>  }</span><span id="91e7" class="lf lg it lb b gy ll li l lj lk">  if ([..]) {<br/>    return console.error('unsupported protocol');<br/>  }</span><span id="5060" class="lf lg it lb b gy ll li l lj lk">  // [..]<br/>};</span></pre><p id="6dab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于没有传递日志记录器上下文的约定，您将最终得到一个列出随机事件的日志记录，而没有提供将这些事件与其所属的异步任务相关联所需的上下文。</p><pre class="kp kq kr ks gt la lb lc ld aw le bi"><span id="a7c2" class="lf lg it lb b gy lh li l lj lk">invalid url<br/>task completed {id:6, url: [..]}<br/>task completed {id:4, url: [..]}<br/>unsupported protocol<br/>task completed {id:5, url: [..]}<br/>task completed {id:3, url: [..]}<br/>task failed {id:2, url: [..]}<br/>task completed<br/>task failed {id:1, url: [..]}</span></pre><p id="5e31" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上述日志不足以确定哪个任务由于什么原因而失败。幸运的是，有一个解决方案。</p><h2 id="72e8" class="lf lg it bd lp lq lr dn ls lt lu dp lv kb lw lx ly kf lz ma mb kj mc md me mf bi translated">使用Node.js域</h2><p id="2ab8" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">使用Node.js <a class="ae ml" href="https://nodejs.org/api/domain.html" rel="noopener ugc nofollow" target="_blank"> Domain </a>，我们可以将上下文添加到一系列异步调用中，而不用显式地将它们传递下去(可以把它想象成一个闭包或者React中的<a class="ae ml" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文</a>)，例如</p><pre class="kp kq kr ks gt la lb lc ld aw le bi"><span id="3fa9" class="lf lg it lb b gy lh li l lj lk">import domain from 'domain';</span><span id="5561" class="lf lg it lb b gy ll li l lj lk">process.on('task', (task) =&gt; {<br/>  domain<br/>    .create()<br/>    .run(() =&gt; {<br/>      process.domain.context = {<br/>        task,<br/>      };</span><span id="87c8" class="lf lg it lb b gy ll li l lj lk">      executeTask(task);<br/>    });<br/>});</span><span id="85f5" class="lf lg it lb b gy ll li l lj lk">const download = (url) =&gt; {<br/>  if ([..]) {<br/>    return console.error(process.domain.context, 'invalid url');<br/>  }</span><span id="0343" class="lf lg it lb b gy ll li l lj lk">  if ([..]) {<br/>    return console.error(process.domain.context, 'unsupported protocol');<br/>  }</span><span id="aad2" class="lf lg it lb b gy ll li l lj lk">  // [..]<br/>};</span><span id="7765" class="lf lg it lb b gy ll li l lj lk">const executeTask = async (task) =&gt; {<br/>  try {<br/>    await download(task.url);</span><span id="2afc" class="lf lg it lb b gy ll li l lj lk">    console.log({task}, 'task completed');<br/>  } catch (error) {<br/>    console.log({task}, 'task failed');<br/>  }<br/>};</span></pre><p id="9abc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样，每个日志消息都与启动异步调用链的异步上下文相关联。</p><pre class="kp kq kr ks gt la lb lc ld aw le bi"><span id="0bf8" class="lf lg it lb b gy lh li l lj lk">invalid url {id:1, url: [..]}<br/>task completed {id:6, url: [..]}<br/>task completed {id:4, url: [..]}<br/>unsupported protocol {id:2, url: [..]}<br/>task completed {id:5, url: [..]}<br/>task completed {id:3, url: [..]}<br/>task failed {id:2, url: [..]}<br/>task completed {id:2, url: [..]}<br/>task failed {id:1, url: [..]}</span></pre><p id="7bae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">理论上，域甚至可以是嵌套的，即知道父域的域可以用于将日志消息与导致日志消息的整个异步调用链相关联。Node.js没有提供现成的这种功能。然而，Node.js可以被猴子打补丁以显式地将父域绑定到活动域，例如</p><pre class="kp kq kr ks gt la lb lc ld aw le bi"><span id="efb3" class="lf lg it lb b gy lh li l lj lk">const domain = require('domain');</span><span id="0346" class="lf lg it lb b gy ll li l lj lk">const originalCreate = domain.create;</span><span id="a8c3" class="lf lg it lb b gy ll li l lj lk">domain.create = (...args) =&gt; {<br/>  const parentDomain = process.domain || null;</span><span id="e11f" class="lf lg it lb b gy ll li l lj lk">  const nextDomain = originalCreate(...args);</span><span id="8469" class="lf lg it lb b gy ll li l lj lk">  nextDomain.parentDomain = parentDomain;</span><span id="51ac" class="lf lg it lb b gy ll li l lj lk">  return nextDomain;<br/>};</span></pre><p id="3bea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此后<code class="fe lm ln lo lb b">parentDomain</code>成为对父域的引用:</p><pre class="kp kq kr ks gt la lb lc ld aw le bi"><span id="f335" class="lf lg it lb b gy lh li l lj lk">const d0 = domain.create();</span><span id="3ce2" class="lf lg it lb b gy ll li l lj lk">d0.run(() =&gt; {<br/>  const d1 = domain.create();</span><span id="bd7e" class="lf lg it lb b gy ll li l lj lk">  d1.run(() =&gt; {<br/>    d1.parentDomain === d0;<br/>  });<br/>});</span></pre><p id="4f2f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了使用我将要介绍的记录器，您需要使用<code class="fe lm ln lo lb b"><a class="ae ml" href="https://github.com/gajus/domain-parent" rel="noopener ugc nofollow" target="_blank">domain-parent</a></code>来修补Node.js。</p><h2 id="8239" class="lf lg it bd lp lq lr dn ls lt lu dp lv kb lw lx ly kf lz ma mb kj mc md me mf bi translated">域弃用</h2><p id="3532" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">一些人评论说域模块已经过时，不应该使用。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mm"><img src="../Images/7f4e3cca2127a39e87abf3c8362c2996.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mll2saeZMYARD8JH9_wp1Q.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">弃用通知。</figcaption></figure><p id="95b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管红色大横幅声明该模块已被弃用，但<code class="fe lm ln lo lb b">domain</code>模块并未被弃用。如果你读了标题后面的段落，它声明一旦替换的<strong class="js iu">API完成，模块<strong class="js iu">将被</strong>废弃。很可能<code class="fe lm ln lo lb b"><a class="ae ml" href="https://nodejs.org/api/async_hooks.html" rel="noopener ugc nofollow" target="_blank">async_hooks</a></code>最终会提供<code class="fe lm ln lo lb b">domain</code>模块提供的所有功能，并取代它。在幕后<code class="fe lm ln lo lb b"><a class="ae ml" href="https://github.com/nodejs/node/blob/master/lib/domain.js" rel="noopener ugc nofollow" target="_blank">domain</a></code> <a class="ae ml" href="https://github.com/nodejs/node/blob/master/lib/domain.js" rel="noopener ugc nofollow" target="_blank">模块已经使用</a> <code class="fe lm ln lo lb b"><a class="ae ml" href="https://github.com/nodejs/node/blob/master/lib/domain.js" rel="noopener ugc nofollow" target="_blank">async_hooks</a></code>实现。然而，这不会很快发生(因为流行的NPM模块和Node.js内部的加载依赖于<code class="fe lm ln lo lb b">domain</code>模块),在那之前使用<code class="fe lm ln lo lb b">domain</code>模块是安全的。</strong></p><p id="631c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，所有这些加起来介绍了一个约定驱动的、上下文感知的日志记录器，它已经被开发出来并准备好了:<a class="ae ml" href="https://github.com/gajus/roarr" rel="noopener ugc nofollow" target="_blank"> Roarr </a>。</p><h2 id="c684" class="lf lg it bd lp lq lr dn ls lt lu dp lv kb lw lx ly kf lz ma mb kj mc md me mf bi translated">使用Roarr</h2><p id="d482" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">Roarr <code class="fe lm ln lo lb b"><a class="ae ml" href="https://github.com/gajus/roarr#roarr-api-adopt" rel="noopener ugc nofollow" target="_blank">adopt</a></code>方法创建了一个域，该域有效地将用户定义的上下文绑定到异步调用过程中产生的所有日志消息。为了将上下文与异步代码相关联，只需使用Roarr <code class="fe lm ln lo lb b"><a class="ae ml" href="https://github.com/gajus/roarr#roarr-api-adopt" rel="noopener ugc nofollow" target="_blank">adopt</a></code>方法执行您的例程，例如</p><pre class="kp kq kr ks gt la lb lc ld aw le bi"><span id="3c23" class="lf lg it lb b gy lh li l lj lk">import Logger from 'roarr';</span><span id="0892" class="lf lg it lb b gy ll li l lj lk">process.on('task', (task) =&gt; {<br/>  Logger<br/>    .adopt(<br/>      () =&gt; {<br/>        return executeTask(task);<br/>      },<br/>      // Here we define the context that we want to associate with<br/>      // all the Roarr loggers that will be called when executing<br/>      // `executeTask` with the current `task` value. <br/>      {<br/>        task,<br/>      }<br/>    );<br/>});</span><span id="10ae" class="lf lg it lb b gy ll li l lj lk">const download = (url) =&gt; {<br/>  if ([..]) {<br/>    return log.error('invalid url');<br/>  }</span><span id="7d71" class="lf lg it lb b gy ll li l lj lk">  if ([..]) {<br/>    return log.error('unsupported protocol');<br/>  }</span><span id="196b" class="lf lg it lb b gy ll li l lj lk">  // [..]<br/>};</span><span id="5fb9" class="lf lg it lb b gy ll li l lj lk">const executeTask = async (task) =&gt; {<br/>  try {<br/>    await download(task.url);</span><span id="888d" class="lf lg it lb b gy ll li l lj lk">    log.info('task completed');<br/>  } catch (error) {<br/>    log.info('task failed');<br/>  }<br/>};</span></pre><p id="06d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面将生成相当于以下内容的日志:</p><pre class="kp kq kr ks gt la lb lc ld aw le bi"><span id="4e67" class="lf lg it lb b gy lh li l lj lk">invalid url {id:1, url: [..]}<br/>task completed {id:6, url: [..]}<br/>task completed {id:4, url: [..]}<br/>unsupported protocol {id:2, url: [..]}<br/>task completed {id:5, url: [..]}<br/>task completed {id:3, url: [..]}<br/>task failed {id:2, url: [..]}<br/>task completed {id:2, url: [..]}<br/>task failed {id:1, url: [..]}</span></pre><p id="d5c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，为了让<em class="mr">所有的</em>日志都包含它们的异步上下文，所有的依赖项都需要使用Roarr logger(或者它们必须从<code class="fe lm ln lo lb b">process.domain.roarr.context</code>中读取logger上下文)。然而，与其他记录器不同，Roarr没有配置，可以在可分发的包和顶级程序中使用。因此，已经有数以千计的包裹在使用Roarr。</p><p id="00c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了让您开始使用Roarr，请阅读Node.js 中的《是什么让<a class="ae ml" href="https://medium.com/free-code-camp/roarr-the-perfect-json-logger-node-js-and-browser-935180bda529" rel="noopener"> Roarr成为完美的记录器》，并查看实现记录器的示例库(</a><a class="ae ml" href="https://github.com/gajus/slonik" rel="noopener ugc nofollow" target="_blank"> Slonik </a>是一个好的开始)。</p><p id="8069" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">概括一下:</p><ol class=""><li id="16d4" class="ms mt it js b jt ju jx jy kb mu kf mv kj mw kn mx my mz na bi translated">在并发执行环境中没有上下文的日志是没有意义的。</li><li id="8c1d" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated">域可用于将上下文与异步调用链相关联。</li><li id="5687" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><a class="ae ml" href="https://github.com/gajus/roarr" rel="noopener ugc nofollow" target="_blank"> Roarr </a>利用域来继承描述导致日志消息的异步调用链的上下文。这允许Roarr生成描述完整执行上下文的日志，即使在多个任务并发执行时也是如此。</li></ol><p id="4d27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">试试<a class="ae ml" href="https://github.com/gajus/roarr" rel="noopener ugc nofollow" target="_blank">roar</a>吧。它甚至有一个简洁的CLI程序，内置了漂亮的打印和过滤功能。</p></div></div>    
</body>
</html>