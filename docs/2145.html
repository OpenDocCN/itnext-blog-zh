<html>
<head>
<title>Replace Redux state with React Hooks and Context</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React钩子和上下文替换Redux状态</h1>
<blockquote>原文：<a href="https://itnext.io/replace-redux-state-with-react-hooks-and-context-7906e0fd5521?source=collection_archive---------0-----------------------#2019-04-07">https://itnext.io/replace-redux-state-with-react-hooks-and-context-7906e0fd5521?source=collection_archive---------0-----------------------#2019-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f24a92bedbfe821d163d3177d5f30b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ISGtKTBwJem2C7tPfKL4-A.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://spdload.com/jobs-vacancies/front-end/front-end-developer-react-js/" rel="noopener ugc nofollow" target="_blank">来自spdload的图像</a></figcaption></figure><blockquote class="kg"><p id="47c2" class="kh ki it bd kj kk kl km kn ko kp kq dk translated">免责声明。我知道Redux提供的不仅仅是全局状态。我在这里提供的是一个优雅的全局状态，没有依赖性，但是React 16.8+</p></blockquote><p id="7540" class="pw-post-body-paragraph kr ks it kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln kq im bi lo translated"><span class="l lp lq lr bm ls lt lu lv lw di"> R </span> eact Hooks于2018年底公布。然后在2019年3月发布。最近我看了React Conf视频，其中<a class="ae kf" href="https://twitter.com/dan_abramov/" rel="noopener ugc nofollow" target="_blank">丹·阿布拉莫夫</a>和<a class="ae kf" href="https://twitter.com/ryanflorence?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor" rel="noopener ugc nofollow" target="_blank">瑞安·弗洛伦斯</a>宣布并展示了钩子的力量。Ryan实现了一个带钩子的Reducer，同时慢慢地拆开了旧的React类组件。这是辉煌的，你应该看到这里的两个发言:(你可以跳到丹的一部分)</p><figure class="lx ly lz ma gt ju"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="3d19" class="pw-post-body-paragraph kr ks it kt b ku md kw kx ky me la lb lc mf le lf lg mg li lj lk mh lm ln kq im bi translated">陈述以一些零散的细节结束。在监听状态变化的同时，reducer如何变得全局可用？在视频结束时，他实际上低声说道:</p><blockquote class="kg"><p id="e28a" class="kh ki it bd kj kk mi mj mk ml mm kq dk translated">然后你加上<a class="ae kf" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文……</a></p></blockquote><p id="ecd2" class="pw-post-body-paragraph kr ks it kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln kq im bi translated">突然，一个新世界打开了。</p><ul class=""><li id="aefb" class="mn mo it kt b ku md ky me lc mp lg mq lk mr kq ms mt mu mv bi translated">创建React应用程序。</li><li id="4eef" class="mn mo it kt b ku mw ky mx lc my lg mz lk na kq ms mt mu mv bi translated">从React导入useReducer和useContext。</li><li id="081e" class="mn mo it kt b ku mw ky mx lc my lg mz lk na kq ms mt mu mv bi translated">创建一个减速器开关盒。</li><li id="5443" class="mn mo it kt b ku mw ky mx lc my lg mz lk na kq ms mt mu mv bi translated">创建一个初始状态。</li><li id="d335" class="mn mo it kt b ku mw ky mx lc my lg mz lk na kq ms mt mu mv bi translated">将状态传递给任何一个只有一行代码的组件(！idspnonenote)。！)的代码。</li></ul><p id="59cf" class="pw-post-body-paragraph kr ks it kt b ku md kw kx ky me la lb lc mf le lf lg mg li lj lk mh lm ln kq im bi translated">你得到了全局状态，本地和反应！Medium上出现了很多关于useReducer+useContext设置的文章，给你一个带有Reducer的全局状态，没有npm install redux redux-react。</p><p id="e284" class="pw-post-body-paragraph kr ks it kt b ku md kw kx ky me la lb lc mf le lf lg mg li lj lk mh lm ln kq im bi translated">我开始慢慢重构我的技术雷达协作应用，就像丹和医生建议的那样。然后我做得过火了，把我的应用程序撕成了碎片。我有4个不同的StoreContext.js文件试图完成同样的事情，在遵循指南的同时测试不同的实现。我最终得到的是许多解决方案的组合。</p><p id="ff91" class="pw-post-body-paragraph kr ks it kt b ku md kw kx ky me la lb lc mf le lf lg mg li lj lk mh lm ln kq im bi translated">这是我最终得出的解决方案</p><h1 id="850b" class="nb nc it bd nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny bi translated">用钩子和上下文减少反应状态</h1><p id="8dc0" class="pw-post-body-paragraph kr ks it kt b ku nz kw kx ky oa la lb lc ob le lf lg oc li lj lk od lm ln kq im bi translated">在您的项目中，创建/context目录。添加3个文件:actions.js、reducers.js、StoreContext.js。有了这3个文件和一个React组件，您就可以做很多事情了！</p><p id="21dc" class="pw-post-body-paragraph kr ks it kt b ku md kw kx ky me la lb lc mf le lf lg mg li lj lk mh lm ln kq im bi translated">我在代码沙箱中创建了一个演示应用程序。这显示了使用钩子只需几行代码就可以获得一个全局状态存储。如果你喜欢互动，看看这个演示。进一步的阅读包括这个项目文件的副本。</p><figure class="lx ly lz ma gt ju"><div class="bz fp l di"><div class="oe mc l"/></div></figure><p id="ad2a" class="pw-post-body-paragraph kr ks it kt b ku md kw kx ky me la lb lc mf le lf lg mg li lj lk mh lm ln kq im bi translated">这是怎么回事？</p><h2 id="27e5" class="of nc it bd nd og oh dn nh oi oj dp nl lc ok ol np lg om on nt lk oo op nx oq bi translated">actions.js</h2><p id="ba40" class="pw-post-body-paragraph kr ks it kt b ku nz kw kx ky oa la lb lc ob le lf lg oc li lj lk od lm ln kq im bi translated">使用带有前缀“use”的挂钩约定定义useActions(state，dispatch)。useAction() { … }中定义的所有函数都将在useContext()中的操作中可用。动作用于定义比纯粹的分派(类型、有效负载)功能更高级的逻辑。</p><pre class="lx ly lz ma gt or os ot ou aw ov bi"><span id="78eb" class="of nc it os b gy ow ox l oy oz">import { types } from "./reducers";</span><span id="3de8" class="of nc it os b gy pa ox l oy oz">export const useActions = (state, dispatch) =&gt; {<br/>  function addTechIfNotInList(newTech) {<br/>    const techIndex = state.techList.indexOf(newTech);<br/>    if (techIndex !== -1) {<br/>      alert("Tech is defined in list");<br/>    } else {<br/>      dispatch({ type: types.ADD_TO_TECH_LIST, payload: newTech });<br/>    }<br/>  }</span><span id="ad8c" class="of nc it os b gy pa ox l oy oz">return {<br/>    addTechIfNotInList<br/>  };<br/>};</span></pre><blockquote class="pb pc pd"><p id="9e29" class="kr ks pe kt b ku md kw kx ky me la lb pf mf le lf pg mg li lj ph mh lm ln kq im bi translated">有了Redux，逻辑应该何去何从就有了一个很好的平衡；还原者或行动创造者。找到适合你的模式！</p></blockquote><h2 id="08b0" class="of nc it bd nd og oh dn nh oi oj dp nl lc ok ol np lg om on nt lk oo op nx oq bi translated">reducers.js</h2><p id="9b9d" class="pw-post-body-paragraph kr ks it kt b ku nz kw kx ky oa la lb lc ob le lf lg oc li lj lk od lm ln kq im bi translated">在这个文件中，我定义了初始状态、类型和缩减器本身。当我们从应用程序中的任何地方调度一个类型时，它将匹配开关条件，并对状态执行正确的操作。如果你熟悉Redux，这应该对你来说非常熟悉！</p><pre class="lx ly lz ma gt or os ot ou aw ov bi"><span id="8523" class="of nc it os b gy ow ox l oy oz">const initialState = {<br/>  techList: ["TypeScript", "React Hooks"]<br/>};</span><span id="fc6e" class="of nc it os b gy pa ox l oy oz">const types = {<br/>  SET_TECH_LIST: "SET_TECH_LIST",<br/>  ADD_TO_TECH_LIST: "ADD_TO_TECH_LIST",<br/>  REMOVE_FROM_TECH_LIST: "REMOVE_FROM_TECH_LIST"<br/>};</span><span id="6982" class="of nc it os b gy pa ox l oy oz">const reducer = (state = initialState, action) =&gt; {<br/>  switch (action.type) {<br/>    case types.SET_TECH_LIST:<br/>      return {<br/>        ...state,<br/>        techList: action.payload<br/>      };<br/>    case types.ADD_TO_TECH_LIST:<br/>      return {<br/>        ...state,<br/>        techList: [...state.techList, action.payload]<br/>      };<br/>    case types.REMOVE_FROM_TECH_LIST:<br/>      return {<br/>        ...state,<br/>        techList: state.techList.filter(<br/>          tech =&gt; tech !== action.payload)<br/>      };<br/>    default:<br/>      throw new Error("Unexpected action");<br/>  }<br/>};<br/>export { initialState, types, reducer };</span></pre><p id="01fe" class="pw-post-body-paragraph kr ks it kt b ku md kw kx ky me la lb lc mf le lf lg mg li lj lk mh lm ln kq im bi translated">您可以看到，我已经选择在这个缩减器中包含一些逻辑。移除tech时，调度(REMOVE_FROM_TECH，techObj)就够了。然而，当添加技术时，它总是将它添加到状态中。这是我在动作创建器中创建的逻辑。</p><blockquote class="pb pc pd"><p id="56db" class="kr ks pe kt b ku md kw kx ky me la lb pf mf le lf pg mg li lj ph mh lm ln kq im bi translated">更高级的逻辑应该放在动作创建器中，比如API调用和其他<a class="ae kf" href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976" rel="noopener">副作用，让你的函数变得“不纯粹”。</a>reducer中还可以添加基本的数组、对象和字符串操作。</p></blockquote><h2 id="6675" class="of nc it bd nd og oh dn nh oi oj dp nl lc ok ol np lg om on nt lk oo op nx oq bi translated">StoreContext.js</h2><p id="b64b" class="pw-post-body-paragraph kr ks it kt b ku nz kw kx ky oa la lb lc ob le lf lg oc li lj lk od lm ln kq im bi translated">这就是我们使用上下文使我们的存储全局可检索的地方。这相当于Redux' createStore()，只是…不同。</p><p id="a5ec" class="pw-post-body-paragraph kr ks it kt b ku md kw kx ky me la lb lc mf le lf lg mg li lj lk mh lm ln kq im bi translated">该文件中的代码是</p><pre class="lx ly lz ma gt or os ot ou aw ov bi"><span id="6eb4" class="of nc it os b gy ow ox l oy oz">const StoreContext = createContext(initialState);</span><span id="dec5" class="of nc it os b gy pa ox l oy oz">const StoreProvider = ({ children }) =&gt; {<br/><strong class="os iu">  // Get state and dispatch from Reacts new API useReducer. </strong><br/>  const [state, dispatch] = useReducer(reducer, initialState);<br/><strong class="os iu">  // Get actions from useActions and pass it to Context</strong><br/>  const actions = useActions(state, dispatch);</span><span id="2166" class="of nc it os b gy pa ox l oy oz"><strong class="os iu">// Log new state<br/></strong>  useEffect(() =&gt; console.log({ newState: state })},[state]);</span><span id="293f" class="of nc it os b gy pa ox l oy oz"><strong class="os iu">// Render state, dispatch and special case actions<br/></strong>  return (<br/>    &lt;StoreContext.Provider value={{ state, dispatch, actions }}&gt;<br/>      {children}<br/>    &lt;/StoreContext.Provider&gt;<br/>  );<br/>};</span><span id="4abc" class="of nc it os b gy pa ox l oy oz">export { StoreContext, StoreProvider };</span></pre><p id="8fd7" class="pw-post-body-paragraph kr ks it kt b ku md kw kx ky me la lb lc mf le lf lg mg li lj lk mh lm ln kq im bi translated">现在，您可以在导出的StoreProvider的所有子组件中使用和<strong class="kt iu">上下文</strong>。只需用useContext(StoreContext)初始化它，并获得state、dispatch、actions对象。</p><h2 id="185d" class="of nc it bd nd og oh dn nh oi oj dp nl lc ok ol np lg om on nt lk oo op nx oq bi translated">App.js</h2><p id="f962" class="pw-post-body-paragraph kr ks it kt b ku nz kw kx ky oa la lb lc ob le lf lg oc li lj lk od lm ln kq im bi translated">有了这些设置，你可以清理你的组件了！只需要一行代码就可以获得状态和所有操作。</p><pre class="lx ly lz ma gt or os ot ou aw ov bi"><span id="d572" class="of nc it os b gy ow ox l oy oz">const { state, dispatch, actions } = useContext(StoreContext);</span></pre><p id="5764" class="pw-post-body-paragraph kr ks it kt b ku md kw kx ky me la lb lc mf le lf lg mg li lj lk mh lm ln kq im bi translated">只要确保App.js是从StoreContext.js导出的StoreProvider的子元素即可</p><pre class="lx ly lz ma gt or os ot ou aw ov bi"><span id="91c3" class="of nc it os b gy ow ox l oy oz"><strong class="os iu">//index.js</strong><br/>&lt;StoreProvider&gt;&lt;App/&gt;&lt;/StoreProvider&gt;</span></pre></div><div class="ab cl pi pj hx pk" role="separator"><span class="pl bw bk pm pn po"/><span class="pl bw bk pm pn po"/><span class="pl bw bk pm pn"/></div><div class="im in io ip iq"><p id="15e9" class="pw-post-body-paragraph kr ks it kt b ku md kw kx ky me la lb lc mf le lf lg mg li lj lk mh lm ln kq im bi translated">现在，我已经花了很多时间试图为我的用例解决这个问题！我现在已经在一个中等规模的应用程序中实现了这一点，开发者体验非常棒！如果你有任何批评，问题或意见，并想分享，请这样做！我一直在寻求改进🌟</p></div></div>    
</body>
</html>