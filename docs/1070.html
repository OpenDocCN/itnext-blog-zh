<html>
<head>
<title>Building autocomplete input with React and reenhance-components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React和reenhance组件构建自动完成输入</h1>
<blockquote>原文：<a href="https://itnext.io/build-your-own-autocomplete-input-with-react-and-reenhance-components-97386da48678?source=collection_archive---------3-----------------------#2018-07-16">https://itnext.io/build-your-own-autocomplete-input-with-react-and-reenhance-components-97386da48678?source=collection_archive---------3-----------------------#2018-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b7043d7313215968ab73c2afe815b9f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JR9aYxE2Xl8I_9SW6QAuCw.png"/></div></div></figure><p id="f499" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，使用<code class="fe kw kx ky kz b">AsyncResolver</code>、<code class="fe kw kx ky kz b">StateProvider</code>和<code class="fe kw kx ky kz b">DebouncePropagator from <a class="ae la" href="https://www.npmjs.com/package/reenhance-components" rel="noopener ugc nofollow" target="_blank">reenhance-components</a></code>创建您自己的自动完成输入组件的逐步说明。你可以在底部找到CodePen和示例库。</p><h1 id="83f7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">简短的背景</h1><p id="1fad" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">现代web应用程序具有各种交互式组件。最常用的是自动完成输入，它可以帮助用户快速正确地输入值。通常，这些建议来自后端API，如产品数据库、销售排名、用户历史或其他大数据。</p><p id="3666" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用React制作这样的组件并不容易，因为它充满了异步、事件和状态管理。现在有了<code class="fe kw kx ky kz b">reenhance-components</code>，事情变得简单多了。本文的结果组件如下所示。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi me"><img src="../Images/1234a61c3e9d108d5334c17de5a686dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*wa86UrLSXrCb9-ufZEXieg.gif"/></div></figure><p id="da8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们进行下一步。</p><h1 id="b851" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">管理输入状态</h1><p id="8cb4" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">在React中，输入字段的值应该以某种状态存储。否则，您将需要一个<code class="fe kw kx ky kz b">ref</code>对象来获取DOM属性的值。最常见的方式叫做<a class="ae la" href="https://reactjs.org/docs/forms.html#controlled-components" rel="noopener ugc nofollow" target="_blank">受控组件</a>。</p><p id="32f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然状态可以存储在Redux中，但是这并不总是一个好主意。在我看来，如果字段仅用于过滤或查询值，状态可以存储在本地。要在JSX以声明方式创建本地商店，可以使用<code class="fe kw kx ky kz b">reenhance-components</code>中的<code class="fe kw kx ky kz b">StateProvider</code>，如下所示:</p><pre class="mf mg mh mi gt mj kz mk ml aw mm bi"><span id="48d6" class="mn lc iq kz b gy mo mp l mq mr">const InputState = StateProvider('');</span><span id="c5bf" class="mn lc iq kz b gy ms mp l mq mr">const SuggestedInput = () =&gt; (<br/>  &lt;InputState&gt;<br/>    {({ state: query, setState: setQuery }) =&gt; (<br/>      &lt;div&gt;<br/>        &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt;<br/>      &lt;/div&gt;<br/>    )}<br/>  &lt;/InputState&gt;<br/>);</span></pre><h1 id="cc47" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">正在执行API请求</h1><p id="e303" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">为了从后端系统获得建议，调用<code class="fe kw kx ky kz b">fetch</code> API(或类似的)是必要的。这些API返回<code class="fe kw kx ky kz b">Promise</code>，因此它们必须在呈现内容之前被解析。</p><p id="63ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/simple-ajax-fetch-with-react-rxjs-hocs-bb174bc45d9e">在我以前的文章</a>中，我展示了一个使用RxJS和HoCs的例子，但是现在有了一个包装组件<code class="fe kw kx ky kz b">AsyncResolver</code>。使用<code class="fe kw kx ky kz b">AsyncResolver</code>，您可以通过在JSX中将一个异步函数和参数作为道具传递来检索响应内容。下面是一个例子:</p><pre class="mf mg mh mi gt mj kz mk ml aw mm bi"><span id="798c" class="mn lc iq kz b gy mo mp l mq mr">const asyncFetch =<br/>  ({ query }) =&gt;<br/>    fetch(queryToUrl(query))<br/>      .then(res =&gt; res.json());</span><span id="99ac" class="mn lc iq kz b gy ms mp l mq mr">const SuggestAsyncResolver = AsyncResolver('query', []);</span><span id="e21c" class="mn lc iq kz b gy ms mp l mq mr">const Suggests = ({ query }) =&gt; (<br/>  &lt;SuggestAsyncResolver query={query} subject={asyncFetch}&gt;<br/>    {props =&gt; (<br/>      &lt;ul&gt;<br/>        {props[1].map(str =&gt; (<br/>          &lt;li key={str}&gt;{str}&lt;/li&gt;<br/>        ))}<br/>      &lt;/ul&gt;<br/>    )}<br/>  &lt;/SuggestAsyncResolver&gt;<br/>);</span></pre><h1 id="bb8a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">通过去抖动减少API请求</h1><p id="3062" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">在实际应用中，减少来自最终用户的API请求是非常重要的。对于自动完成，我们可以将API请求延迟150-200毫秒，而不会降低用户体验。</p><p id="c938" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，仅仅延迟是不够的，还必须在这段时间内巩固事件。这样的行为在RxJS中被称为<code class="fe kw kx ky kz b"><a class="ae la" href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-debounce" rel="noopener ugc nofollow" target="_blank">debounce</a></code>。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/7f33a21484c8f2311b27d6a73a91aaab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x48uW7LTVaWcJj3flaItVQ.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">RxJS文件中的去抖图形</figcaption></figure><p id="7461" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以使用<code class="fe kw kx ky kz b">DebouncePropagator</code>来采用它，它将JSX中的prop传播延迟给定的毫秒。</p><p id="2a89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">示例:</p><pre class="mf mg mh mi gt mj kz mk ml aw mm bi"><span id="a591" class="mn lc iq kz b gy mo mp l mq mr">const SuggestDebounce = DebouncePropagator({ query: '' });</span><span id="f977" class="mn lc iq kz b gy ms mp l mq mr">const SuggestsWithDebounce = ({ query }) =&gt; (<br/>  &lt;SuggestDebounce time={200} query={query}&gt;<br/>    {({ query }) =&gt; (<br/>      &lt;div&gt;<br/>        &lt;Suggests query={query} /&gt;<br/>      &lt;/div&gt;<br/>    )}<br/>  &lt;/SuggestDebounce&gt;<br/>)</span></pre><h1 id="9076" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">最终产品</h1><p id="f037" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">你可以在CodePen中试试这个例子。它显示了来自Amazon.com的建议。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b234" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里还有一个使用WebPack和Babel的存储库。只需结帐并键入<code class="fe kw kx ky kz b">npm install</code>和<code class="fe kw kx ky kz b">npm start</code>就可以在本地尝试。</p><div class="na nb gp gr nc nd"><a href="https://github.com/fpt/reenhance-components-babel-examples" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">FPT/re enhance-组件-babel-示例</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">组件-巴别塔-例子-最小反应，网络包，巴别塔设置。你想超越创建-反应-应用…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">github.com</p></div></div></div></a></div><h1 id="8a63" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="bd86" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">乍一看，自动完成输入似乎很复杂，但它可以一步一步地构建。<code class="fe kw kx ky kz b">reenhance-components</code>帮助你把功能元素放在JSX，构建丰富的组件，没有任何类，hoc，Redux。</p></div></div>    
</body>
</html>