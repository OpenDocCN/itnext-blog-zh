<html>
<head>
<title>Stubbing Vue.js Components in vue-test-utils</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">清除vue-test-utils中的Vue.js组件</h1>
<blockquote>原文：<a href="https://itnext.io/stubbing-vue-components-in-vue-test-utils-6e9442e094c3?source=collection_archive---------4-----------------------#2018-07-04">https://itnext.io/stubbing-vue-components-in-vue-test-utils-6e9442e094c3?source=collection_archive---------4-----------------------#2018-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/60714748358410f47396347f27344137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ygEx0D3RupPwlgPF6_Iz6g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来自<a class="ae kc" href="https://syndicode.com/2017/12/27/start-using-tdd-with-vue-js/" rel="noopener ugc nofollow" target="_blank"> Syndicode </a>。</figcaption></figure><p id="24f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">为什么是存根？在编写单元测试时，我们经常想把我们不感兴趣的代码部分删除掉。存根就是代表另一段代码的一段代码。假设您正在为一个<code class="fe lc ld le lf b">&lt;UserContainer&gt;</code>组件编写一个测试。看起来是这样的:</em></p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="7671" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">&lt;UsersDisplay&gt;</code>有一个这样的<code class="fe lc ld le lf b">created</code>生命周期方法:</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="823b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们想写一个断言<code class="fe lc ld le lf b">&lt;UsersDisplay&gt;</code>被渲染的测试。</p><p id="d7fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">axios</code>在<code class="fe lc ld le lf b">created</code>钩子中向外部服务发出ajax请求。这意味着当您执行<code class="fe lc ld le lf b">mount(UserContainer)</code>时，<code class="fe lc ld le lf b">&lt;UsersDisplay&gt;</code>也被挂载，<code class="fe lc ld le lf b">created</code>发起一个ajax请求。由于这是一个单元测试，我们只对<code class="fe lc ld le lf b">&lt;UserContainer&gt;</code>是否正确呈现<code class="fe lc ld le lf b">&lt;UsersDisplay&gt;</code>感兴趣——验证ajax请求是否由正确的端点触发等，是<code class="fe lc ld le lf b">&lt;UsersDisplay&gt;</code>的责任，应该在<code class="fe lc ld le lf b">&lt;UsersDisplay&gt;</code>测试文件中测试。</p><p id="f0db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">防止<code class="fe lc ld le lf b">&lt;UsersDisplay&gt;</code>发起ajax请求的一种方法是通过<em class="lb">清除</em>组件。让我们编写自己的组件并进行测试，以便更好地理解使用存根的不同方式和好处。</p><h1 id="b6f3" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">创建组件</h1><p id="27e0" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">这个例子将使用两个组件。第一个是<code class="fe lc ld le lf b">ParentWithAPICallChild</code>，它简单地呈现了另一个组件:</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="a2a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">&lt;ParentWithAPICallChild&gt;</code>是简单组件。它唯一的责任就是渲染<code class="fe lc ld le lf b">&lt;ComponentWithAsyncCall&gt;</code>。<code class="fe lc ld le lf b">&lt;ComponentWithAsyncCall&gt;</code>顾名思义，使用<code class="fe lc ld le lf b">axios</code> http客户端进行ajax调用:</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="4acf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">&lt;ComponentWithAsyncCall&gt;</code>调用<code class="fe lc ld le lf b">created</code>生命周期钩子中的<code class="fe lc ld le lf b">makeApiCall</code>。</p><h1 id="023c" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">使用<code class="fe lc ld le lf b">mount</code>编写测试</h1><p id="0514" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">让我们首先编写一个测试来验证<code class="fe lc ld le lf b">&lt;ComponentWithAsyncCall&gt;</code>是否被渲染:</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="9192" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行<code class="fe lc ld le lf b">yarn test:unit</code>产量:</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="f0b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试通过了——太好了！然而，我们可以做得更好。注意测试输出中的<code class="fe lc ld le lf b">console.log</code>——这来自于<code class="fe lc ld le lf b">makeApiCall</code>方法。理想情况下，我们不希望在单元测试中调用外部服务，尤其是当它来自一个不是当前测试的主要焦点的组件时。我们可以使用<code class="fe lc ld le lf b">stubs</code>安装选项，如<code class="fe lc ld le lf b">vue-test-utils</code>文档<a class="ae kc" href="https://vue-test-utils.vuejs.org/api/options.html#stubs" rel="noopener ugc nofollow" target="_blank">此处</a>所述。</p><h1 id="56a5" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">使用<code class="fe lc ld le lf b">stubs</code>来短接<code class="fe lc ld le lf b">&lt;ComponentWithAsyncCall&gt;</code></h1><p id="3949" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">让我们更新一下测试，这次是stubbing <code class="fe lc ld le lf b">&lt;ComponentWithAsyncCall&gt;</code>:</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="f8be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<code class="fe lc ld le lf b">yarn test:unit</code>运行时，测试仍然通过，但是<code class="fe lc ld le lf b">console.log</code>不见了。这是因为将<code class="fe lc ld le lf b">[component]: true</code>传递给<code class="fe lc ld le lf b">stubs</code>用一个<em class="lb">存根</em>替换了原来的组件。外部接口仍然相同(我们仍然可以选择使用<code class="fe lc ld le lf b">find</code>，因为<code class="fe lc ld le lf b">find</code>内部使用的<code class="fe lc ld le lf b">name</code>属性仍然相同)。内部方法，比如<code class="fe lc ld le lf b">makeApiCall</code>，被不做任何事情的虚拟方法所取代——它们被“剔除”。</p><p id="6b16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果愿意，您还可以指定用于存根的标记:</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><h1 id="eb01" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">用<code class="fe lc ld le lf b">shallowMount</code>自动打茬</h1><p id="75a6" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们可以简单地使用<code class="fe lc ld le lf b">shallowMount</code>，而不是使用<code class="fe lc ld le lf b">mount</code>和手动存根<code class="fe lc ld le lf b">&lt;ComponentWithAsyncCall&gt;</code>，默认情况下，它会自动存根任何其他组件。用<code class="fe lc ld le lf b">shallowMount</code>进行的测试如下所示:</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="2e17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行<code class="fe lc ld le lf b">yarn test:unit</code>不显示任何<code class="fe lc ld le lf b">console.log</code>，测试通过。<code class="fe lc ld le lf b">shallowMount</code>自动存根<code class="fe lc ld le lf b">&lt;ComponentWithAsyncCall&gt;</code>。<code class="fe lc ld le lf b">shallowMount</code>对于测试有很多子组件的组件很有用，这些子组件可能在生命周期钩子中触发行为，比如<code class="fe lc ld le lf b">created</code>或<code class="fe lc ld le lf b">mounted</code>等等。我倾向于默认使用<code class="fe lc ld le lf b">shallowMount</code>，除非我有充分的理由使用<code class="fe lc ld le lf b">mount</code>。这取决于您的用例，以及您正在测试的内容。</p><h1 id="5590" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><ul class=""><li id="c493" class="mp mq iq kf b kg mk kk ml ko mr ks ms kw mt la mu mv mw mx bi translated"><code class="fe lc ld le lf b">stubs</code>对于剔除与当前单元测试无关的孩子的行为是有用的</li><li id="0b56" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated"><code class="fe lc ld le lf b">shallowMount</code>默认情况下清除子组件</li><li id="8e3c" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">你可以通过<code class="fe lc ld le lf b">true</code>来创建一个默认的存根，或者通过你自己的定制实现</li></ul><p id="d23f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在找到本页<a class="ae kc" href="https://github.com/lmiller1990/vue-testing-handbook/tree/master/demo-app/tests/unit/ParentWithAPICallChild.spec.js" rel="noopener ugc nofollow" target="_blank">中描述的测试。</a></p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><figure class="lg lh li lj gt jr gh gi paragraph-image"><a href="http://vuejs-course.com/"><div class="gh gi nk"><img src="../Images/8860e8ef1f39967845929ca6a9e3821a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g_RGGAoqizZjbVse93Z4TQ.png"/></div></a><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">来看看我的<a class="ae kc" href="https://vuejs-course.com/" rel="noopener ugc nofollow" target="_blank"> Vue.js 3课程</a>！我们涵盖了组合API、类型脚本、单元测试、Vuex和Vue路由器。</figcaption></figure></div></div>    
</body>
</html>