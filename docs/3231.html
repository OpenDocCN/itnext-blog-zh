<html>
<head>
<title>How to Use TypeScript Generics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用TypeScript泛型</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-use-typescript-generics-6c0c09e049c3?source=collection_archive---------1-----------------------#2019-10-31">https://itnext.io/how-to-use-typescript-generics-6c0c09e049c3?source=collection_archive---------1-----------------------#2019-10-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="26bc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于TypeScript最佳特性之一的快速教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ac1da32ec60f510bd9f666064bb4d5dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GP_9S8rs2D2D9lcE1v9SpA.png"/></div></div></figure><p id="6f8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就像Ruby中的<code class="fe lq lr ls lt b"><a class="ae lu" href="https://stackoverflow.com/questions/5890118/what-does-variable-mean-in-ruby" rel="noopener ugc nofollow" target="_blank">@@</a></code> <a class="ae lu" href="https://stackoverflow.com/questions/5890118/what-does-variable-mean-in-ruby" rel="noopener ugc nofollow" target="_blank">语法</a>一样，<strong class="kw iu"> <em class="lv">的<code class="fe lq lr ls lt b">&lt;&gt;</code>TypeScript泛型</em> </strong>让我有点紧张，所以我就直截了当地尽量长时间避开它们。但是，事实证明我是一个大懦夫，因为泛型实际上非常简单和方便。</p><h1 id="c63a" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">泛型放松了僵化的函数</h1><p id="f6d8" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">泛型所做的只是让函数更加灵活。为了演示我们为什么需要这样做，让我们编写一个<em class="lv">镜像函数</em>。它只会返回我们放入的内容:</p><pre class="kj kk kl km gt mt lt mu mv aw mw bi"><span id="3a8a" class="mx lx it lt b gy my mz l na nb">const <strong class="lt iu">mirror1</strong> = (<strong class="lt iu">thing</strong>: <strong class="lt iu"><em class="lv">string</em></strong>) {<br/>  return <strong class="lt iu">thing</strong>;<br/>}</span><span id="e023" class="mx lx it lt b gy nc mz l na nb"><strong class="lt iu">mirror1</strong>('<em class="lv">hello</em>');<br/>&gt; '<em class="lv">hello</em>'<br/><strong class="lt iu">mirror1</strong>(12) // breaks</span></pre><p id="0807" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个好的开始，却是一面可怕的镜子；这只反映了<code class="fe lq lr ls lt b">strings</code>。我们<em class="lv">希望</em>它返回我们放入的任何东西。<strong class="kw iu">这</strong>就是泛型发挥作用的地方。</p><h1 id="bc8b" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">添加类型参数</h1><p id="ed00" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">您可以将类型定义为参数，方法是将它放在<code class="fe lq lr ls lt b">()</code>之前的<code class="fe lq lr ls lt b">&lt;&gt;</code>中:</p><pre class="kj kk kl km gt mt lt mu mv aw mw bi"><span id="b02d" class="mx lx it lt b gy my mz l na nb">const <strong class="lt iu">mirror2</strong> = &lt;<em class="lv">MirrorType</em>&gt;(<br/>  <strong class="lt iu">thing</strong>: <em class="lv">MirrorType<br/></em>): <em class="lv">MirrorType</em> =&gt; {<br/>  return <strong class="lt iu">thing</strong>;<br/>}</span><span id="68e1" class="mx lx it lt b gy nc mz l na nb"><strong class="lt iu">mirror1</strong>&lt;<em class="lv">number</em>&gt;(12);<br/><strong class="lt iu">mirror1</strong>&lt;<em class="lv">string</em>&gt;('<em class="lv">hi</em>');</span><span id="95ed" class="mx lx it lt b gy nc mz l na nb">// non arrow version: <br/>function <strong class="lt iu">mirror3</strong>&lt;<em class="lv">MirrorType</em>&gt;(<br/>  <strong class="lt iu">thing</strong>: <em class="lv">MirrorType<br/></em>): <em class="lv">MirrorType</em> {<br/>  return <strong class="lt iu">thing</strong>;<br/>}</span></pre><p id="742b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们所做的就是告诉我们的函数我们想要使用哪种类型，然后我们可以在任何地方引用它。因此，当我们说<code class="fe lq lr ls lt b">&lt;number&gt;</code>时，这意味着它期望我们的参数是一个<code class="fe lq lr ls lt b">number</code>，并且它也将返回一个<code class="fe lq lr ls lt b">number</code>类型(尽管，在这种情况下，返回是隐式的)。在现实世界中，事情并不总是这么简单。</p><h1 id="3b32" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">现在就开始幻想吧</h1><p id="5560" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">下面我们只对我们的参数中的<em class="lv">一个</em>使用一个泛型:</p><pre class="kj kk kl km gt mt lt mu mv aw mw bi"><span id="28d6" class="mx lx it lt b gy my mz l na nb">const <strong class="lt iu">copyMachine</strong> = &lt;<em class="lv">CopyType</em>&gt;(<br/>  <strong class="lt iu">itemToCopy</strong>: <em class="lv">CopyType</em>,<br/>  <strong class="lt iu">numOfCopies</strong>: <em class="lv">number,</em><br/>) =&gt; {<br/>  <strong class="lt iu"><em class="lv">return</em></strong> Array(<strong class="lt iu">numOfCopies</strong>)<br/>    .fill(<strong class="lt iu">itemToCopy</strong>);<br/>}</span><span id="73ca" class="mx lx it lt b gy nc mz l na nb"><strong class="lt iu">copyMachine</strong>&lt;<em class="lv">string</em>&gt;('<em class="lv">hi</em>', 3);<br/>&gt; [<em class="lv">'hi', 'hi', 'hi'</em>]<br/>// more <a class="ae lu" href="https://stackoverflow.com/questions/34937349/javascript-create-empty-array-of-a-given-size/41246860#41246860" rel="noopener ugc nofollow" target="_blank">array tricks in this link</a></span></pre><p id="cf2f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您也可以使用多种类型:</p><pre class="kj kk kl km gt mt lt mu mv aw mw bi"><span id="b293" class="mx lx it lt b gy my mz l na nb">interface <strong class="lt iu">MagicTypes</strong>&lt;<em class="lv">Type1</em>, <em class="lv">Type2</em>&gt; {<br/>  firstItem: <em class="lv">Type1</em>;<br/>  secondItem: <em class="lv">Type2</em>;<br/>}</span><span id="6753" class="mx lx it lt b gy nc mz l na nb">const <strong class="lt iu">magicMirror</strong> = &lt;<em class="lv">Type1</em>, <em class="lv">Type2</em>&gt;(<br/>  arg1: <em class="lv">Type1</em>,<br/>  arg2: <em class="lv">Type2</em>,<br/>): <strong class="lt iu"><em class="lv">MagicTypes</em></strong>&lt;<em class="lv">Type1</em>, <em class="lv">Type2</em>&gt; =&gt; ({<br/>  firstItem: <strong class="lt iu">arg1</strong>,<br/>  secondItem: <strong class="lt iu">arg2</strong>,<br/>});</span></pre><p id="87c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">哈哈，在丫身上拉了个鬼祟，扔了个<em class="lv">泛型</em> <a class="ae lu" href="https://www.tutorialsteacher.com/typescript/typescript-interface" rel="noopener ugc nofollow" target="_blank"> <em class="lv">接口</em> </a> <em class="lv"> </em>用在我们的返回值里。没错，你也可以使接口通用化。泛型让你可以像对待另一种参数一样对待类型，所以它们被用在很多地方，尤其是<a class="ae lu" href="https://www.tutorialsteacher.com/typescript/typescript-generic-class" rel="noopener ugc nofollow" target="_blank">类</a>。</p><h1 id="24e7" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">需要传入类型吗？</h1><p id="9769" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">令人惊讶的是，你不知道。你总是需要<em class="lv">定义</em>它们，然而，如果一个参数是一个基本类型，TS就能搞清楚:</p><pre class="kj kk kl km gt mt lt mu mv aw mw bi"><span id="5abb" class="mx lx it lt b gy my mz l na nb">const <strong class="lt iu">mirror2</strong> = &lt;<em class="lv">MirrorType</em>&gt;(<br/>  <strong class="lt iu">thing</strong>: <em class="lv">MirrorType<br/></em>): <em class="lv">MirrorType</em> =&gt; {<br/>  return <strong class="lt iu">thing</strong>;<br/>}<br/>// still works<br/><strong class="lt iu">mirror2</strong>('<em class="lv">hi</em>'); </span></pre><p id="061d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本质上，TS对自己说:“没有传递<code class="fe lq lr ls lt b">MirrorType</code>，但是给定的<code class="fe lq lr ls lt b">thing</code>值是一个<code class="fe lq lr ls lt b">string</code>。这意味着<code class="fe lq lr ls lt b">MirrorType</code>一定是一只<code class="fe lq lr ls lt b">string</code>这种类型的逆向工程对于基本值来说很方便。只要参数类型是基本的，就不需要传入泛型类型参数。你实际上<em class="lv">使用类型参数的唯一原因是如果你有一个<a class="ae lu" href="https://www.tutorialsteacher.com/typescript/typescript-interface" rel="noopener ugc nofollow" target="_blank">接口</a> ( <em class="lv">接口</em>是定义对象内部类型的一种方式，点击那个链接可以快速入门)。</em></p><h1 id="4de1" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">有和没有接口</h1><p id="3cf7" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">下面是TS如何对镜像函数的参数对象进行类型检查:</p><pre class="kj kk kl km gt mt lt mu mv aw mw bi"><span id="4710" class="mx lx it lt b gy my mz l na nb"><strong class="lt iu">mirror</strong>({<br/>  name: '',<br/>  mood: '<em class="lv">happy</em>',<br/>  isHungry: 0,<br/>});</span><span id="53ad" class="mx lx it lt b gy nc mz l na nb">// default TS types:<br/>{<br/>  name: <em class="lv">string</em>;<br/>  mood: <em class="lv">string</em>;<br/>  isHungry: <em class="lv">number</em>;<br/>}</span></pre><p id="22e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这很好，但假设界面实际上是:</p><pre class="kj kk kl km gt mt lt mu mv aw mw bi"><span id="582b" class="mx lx it lt b gy my mz l na nb">type <strong class="lt iu"><em class="lv">NumberBoolean</em></strong> = 0 | 1;<br/>interface <strong class="lt iu"><em class="lv">PersonType</em></strong> {<br/>  name: <em class="lv">string</em>;<br/>  mood: 'happy' | 'sad';<br/>  isHungry: <strong class="lt iu"><em class="lv">NumberBoolean</em></strong>;  <br/>};</span></pre><p id="0a3d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这更加具体，并给我们带来了一些额外的好处。要使用此接口，请将其传入:</p><pre class="kj kk kl km gt mt lt mu mv aw mw bi"><span id="860d" class="mx lx it lt b gy my mz l na nb"><strong class="lt iu">mirror</strong>&lt;<strong class="lt iu"><em class="lv">PersonType</em></strong>&gt;({<br/>  name: '',<br/>  mood: '<em class="lv">happy</em>',<br/>  isHungry: 0,<br/>});</span></pre><p id="ba68" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在TypeScript知道<code class="fe lq lr ls lt b">isHungry</code>永远不可能是像<code class="fe lq lr ls lt b">34</code>那样的数字，而<code class="fe lq lr ls lt b">mood</code>只有2个选项。</p><h1 id="a06c" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">关于JSX的警告</h1><p id="1712" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">在你开始定义自己的泛型之前，在<code class="fe lq lr ls lt b">.tsx</code>文件中创建泛型<strong class="kw iu">箭头</strong> <em class="lv"> </em>函数时要小心。虽然TypeScript编译器可以使用通用函数来处理<em class="lv">，就像React中的<code class="fe lq lr ls lt b">useState&lt;Interface&gt;</code>，但是当<em class="lv">定义</em>它们<em class="lv">时就会出错。</em> TS会突然认为type参数是一个jsx HTML标签。有两个选项可以解决这个问题:<a class="ae lu" href="https://stackoverflow.com/a/41112368" rel="noopener ugc nofollow" target="_blank">不使用箭头功能</a>，或者<a class="ae lu" href="https://stackoverflow.com/a/41112882" rel="noopener ugc nofollow" target="_blank">扩展{} </a>。</em></p><h2 id="e566" class="mx lx it bd ly nd ne dn mc nf ng dp mg ld nh ni mi lh nj nk mk ll nl nm mm nn bi translated">常规函数</h2><p id="00ea" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">如果你不关心<code class="fe lq lr ls lt b">this</code>绑定，你可以使用一个普通的函数:</p><pre class="kj kk kl km gt mt lt mu mv aw mw bi"><span id="9a99" class="mx lx it lt b gy my mz l na nb">const <strong class="lt iu">mirrorTSX</strong> = <strong class="lt iu">function</strong>&lt;<em class="lv">ThingType</em>&gt;(<br/>    <strong class="lt iu">thing</strong>: <em class="lv">ThingType</em><br/>) {<br/>  return <strong class="lt iu">thing</strong>;<br/>}</span><span id="2738" class="mx lx it lt b gy nc mz l na nb">// works!<strong class="lt iu"> <br/>mirrorTSX</strong>(12); </span></pre><h2 id="2f94" class="mx lx it bd ly nd ne dn mc nf ng dp mg ld nh ni mi lh nj nk mk ll nl nm mm nn bi translated">扩展{}</h2><p id="58a7" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">使用<code class="fe lq lr ls lt b">extends</code>关键字告诉TS编译器它没有读取HTML:</p><pre class="kj kk kl km gt mt lt mu mv aw mw bi"><span id="8372" class="mx lx it lt b gy my mz l na nb">const <strong class="lt iu">mirrorTSX</strong> = &lt;<em class="lv">ThingType </em><strong class="lt iu"><em class="lv">extends</em></strong><em class="lv"> {}</em>&gt;(<br/>    <strong class="lt iu">thing</strong>: <em class="lv">ThingType</em><br/>) =&gt; {<br/>  return <strong class="lt iu">thing</strong>;<br/>}</span><span id="aafd" class="mx lx it lt b gy nc mz l na nb"><strong class="lt iu">mirrorTSX</strong>('<em class="lv">hi</em>');</span></pre><p id="e6dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe lq lr ls lt b">.tsx</code>文件中定义泛型<em class="lv">并不常见，但是当你得到这个错误却不知道为什么的时候，这真的很烦人。我希望这能为你节省至少25分钟的谷歌搜索时间。</em></p><h1 id="5e21" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">最后</h1><p id="250f" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">我们只是粗略地浏览了一下这个惊人特性的表面，但是它已经足够让您开始工作了。对于一个<a class="ae lu" href="https://medium.com/@rossbulat/typescript-generics-explained-15c6493b510f" rel="noopener"> <em class="lv">多</em>深潜，查看这篇文章</a>。然而，他们说最好的学习方法是实践，所以走出去，变得非常普通。它对我来说确实很有用。</p><p id="9f61" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大家编码快乐，</p><p id="f935" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">麦克风</p></div></div>    
</body>
</html>