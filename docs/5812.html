<html>
<head>
<title>You are refactoring code all wrong</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你重构代码完全错了</h1>
<blockquote>原文：<a href="https://itnext.io/you-are-refactoring-code-all-wrong-6fbace36afba?source=collection_archive---------1-----------------------#2021-05-31">https://itnext.io/you-are-refactoring-code-all-wrong-6fbace36afba?source=collection_archive---------1-----------------------#2021-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/35450bca57984b7500b8cb3b46c925fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YaTuSHaD8GOmS0xDaZjA3w.png"/></div></div></figure><p id="1961" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为一名软件开发人员，你很早就知道重构的重要性。你经常会听到“降低代码复杂度”和“增加可用性”这样的时髦词。但是什么是正确的方法呢？</p><p id="e09d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然重构显然很重要，但最终目标可能是模糊的。你需要知道你为什么要这么做，并且在执行任务时有一个清晰的策略。</p><h1 id="ed4a" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">重构的错误理由</h1><p id="3021" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">首先，让我们掩盖错误的重构理由。</p><h2 id="171e" class="mc la it bd lb md me dn lf mf mg dp lj km mh mi ln kq mj mk lr ku ml mm lv mn bi translated">为了分解而分解</h2><p id="c10e" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">一开始，我认为重构主要是为了保持我的函数和类小。我相信这就是让我的代码变得更好所需要的一切。</p><p id="c675" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但事实并非如此。</p><p id="8b88" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这叫做为分解而分解，对改进代码没有任何帮助。让我们来看看这个例子:</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="37a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个巨大的函数，当然我可以通过拆分它来改进它。对吗？让我们试试:</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="7b6c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mu mv mw mx b">processInventory</code>现在更小了，代码第一眼看上去确实更干净了。然而，就解耦而言，它并不比我们以前的产品好多少。你不能轻易重用这些代码。</p><p id="0497" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的类仍然缺少好代码的基本属性:<strong class="kd iu">可预测、可重用和可测试。</strong>我们将分解这些属性，然后回来以正确的方式重构上面的代码。</p><h2 id="6a5d" class="mc la it bd lb md me dn lf mf mg dp lj km mh mi ln kq mj mk lr ku ml mm lv mn bi translated">壁橱类比</h2><p id="156d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">你也可能在重构工作中走得太远。您可能最终会创建不必要的抽象层，这实际上会损害代码的可读性。</p><p id="fe19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个很好的类比就是整理一个壁橱。如果你把所有的衣服都扔在地板上，那会很乱。如果你花时间把你的衬衫、裤子和鞋子整齐地分开，你的衣柜会变得更整洁，你会发现事情变得更容易。</p><p id="5eb7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，如果你继续努力，试图为你衣柜里的每一件物品找到一个独特的位置，你会花几个小时清理你的衣柜，结果不会比你开始时的混乱好多少。</p><p id="acaa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以尽量避免仅仅为了保持代码小而抽象和拆分代码。</p><p id="163f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么问题是，你为什么要重构？我认为实用重构有两个目标:</p><ul class=""><li id="caf0" class="my mz it kd b ke kf ki kj km na kq nb ku nc ky nd ne nf ng bi translated">去耦码</li><li id="4da3" class="my mz it kd b ke nh ki ni km nj kq nk ku nl ky nd ne nf ng bi translated">代码内聚性</li></ul><h1 id="1a85" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">去耦码</h1><p id="29ba" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">如前所述，解耦代码有三个主要属性:</p><ul class=""><li id="c321" class="my mz it kd b ke kf ki kj km na kq nb ku nc ky nd ne nf ng bi translated">这是可以预见的</li><li id="ad70" class="my mz it kd b ke nh ki ni km nj kq nk ku nl ky nd ne nf ng bi translated">这是可以测试的</li><li id="6a8e" class="my mz it kd b ke nh ki ni km nj kq nk ku nl ky nd ne nf ng bi translated">它是可重复使用的</li></ul><h2 id="7951" class="mc la it bd lb md me dn lf mf mg dp lj km mh mi ln kq mj mk lr ku ml mm lv mn bi translated">可预测代码</h2><p id="6cd6" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">给定相同的输入，可预测的代码将总是返回相同的输出。它对任何外部变化都是不可知的。如果我们专门谈论函数，可预测函数也被称为<a class="ae nm" href="https://en.wikipedia.org/wiki/Pure_function" rel="noopener ugc nofollow" target="_blank">纯函数。</a></p><p id="bc72" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个简单的使函数纯净的方法是使用<a class="ae nm" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入移除任何内部状态突变。</a>让我们来看看我们之前写的<code class="fe mu mv mw mx b">requestInventory</code>方法:</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="e7bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的函数中，我们通过重新分配<code class="fe mu mv mw mx b">this.inventoryItems</code>来改变外部状态。这是一个副作用，应该避免，因为它使我们的功能更难预测。让我们通过提供<code class="fe mu mv mw mx b">inventoryItems</code>作为参数来简化这个函数:</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="e764" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">修复是琐碎的，但仍然是重要的——最糟糕的代码味道通常是最容易修复的。</p><p id="6732" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要了解更多关于节点应用程序上下文中的依赖注入，请查看我的<a class="ae nm" href="https://isamatov.com/node-js-dependency-injection-container/" rel="noopener ugc nofollow" target="_blank">帖子。</a></p><h2 id="c111" class="mc la it bd lb md me dn lf mf mg dp lj km mh mi ln kq mj mk lr ku ml mm lv mn bi translated">可测试代码</h2><p id="3b90" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">这个属性伴随着可预测性，因为您不能测试不可预测的代码。</p><p id="eed8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于任何项目，重要的是要有强大的测试用例作为后盾。然而人们经常避免这样做，通常是因为他们意识到他们的代码很难测试。</p><p id="1ee6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是为什么当你写你的代码时，你应该问你自己:“写这个代码的测试用例有多容易？”如果你认为测试你写的函数会很难，重构它。</p><h2 id="c124" class="mc la it bd lb md me dn lf mf mg dp lj km mh mi ln kq mj mk lr ku ml mm lv mn bi translated">可重用代码</h2><p id="8cb1" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">现在我们来谈谈可重用性。</p><p id="7817" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">编写可重用代码的北极星是<a class="ae nm" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>。这仅仅意味着你的函数应该被设计成做一件事。这里有一个例子:</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="2ee1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mu mv mw mx b">processInventory</code>目前正在做两件事:显示加载器和处理请求。在当前状态下，这个函数不太可重用。所以让我们把它分开:</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="6491" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样更好。<code class="fe mu mv mw mx b">processInventory</code>的重要棋子现在在<code class="fe mu mv mw mx b">updateInventories</code>方法中，可以重用。</p><h1 id="7276" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">代码内聚性</h1><p id="46d3" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">现在让我们来看看项目中的<a class="ae nm" href="https://en.wikipedia.org/wiki/Cohesion_%28computer_science%29" rel="noopener ugc nofollow" target="_blank">代码内聚</a>。</p><h2 id="da7a" class="mc la it bd lb md me dn lf mf mg dp lj km mh mi ln kq mj mk lr ku ml mm lv mn bi translated">特征内聚性</h2><p id="c317" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">从高层次来看，任何应用程序都只是一组独特功能的集合。并不是所有的人都有联系。事实上，很多人都不知道。</p><p id="9004" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是为什么我认为在按功能分组之前，最好围绕特定特性对代码进行分组。让我解释一下我的意思。</p><p id="9935" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设您正在开发包含三个不同页面的React应用程序:仪表板、设置和身份验证。每个页面都有缩减器、动作、组件、容器和实用方法。</p><p id="328c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我建议您首先围绕主页面构建代码和文件。因此，项目结构可能是这样的:</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/c2bfc85674be98a582e7be56a9fbe99c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6d3PGVrKy5y9MI6py3EKVQ.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">特征优先的项目结构</figcaption></figure><p id="9841" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以这种方式构建代码的好处是它适合您的典型工作流。你很少会发现自己同时处理多个不同的特性。通常，我们一次只关注一个。如果这些文件都在同一个文件夹中，那么在它们之间切换就不那么费力了。</p><h2 id="13ee" class="mc la it bd lb md me dn lf mf mg dp lj km mh mi ln kq mj mk lr ku ml mm lv mn bi translated">功能衔接</h2><p id="1a51" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在按特性对代码进行分组后，可以开始按功能对部分代码进行分组。</p><p id="bb09" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">并不是所有的代码都需要这样分组。这种分组的候选者是在多个地方使用的代码片段，并且不依赖于特定的特性。这是一个你有信心会继续重用的代码。一些例子是应用程序范围的实用程序方法、API请求客户端和接口。</p><p id="c918" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果从头开始一个项目，您可以同时根据特性和功能对代码进行分组。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><p id="2cf8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">希望这篇文章能对重构背后的最终目标有所启发。</p><p id="1016" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果做得正确，重构是一个很好的练习，将有助于扩展您的代码库并保持其质量。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><p id="184f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nz">原载于2021年5月31日https://isamatov.com</em><a class="ae nm" href="https://isamatov.com/refactoring-right-way/" rel="noopener ugc nofollow" target="_blank"><em class="nz"/></a><em class="nz">。</em></p></div></div>    
</body>
</html>