<html>
<head>
<title>Logging Bash History via Promtail, Loki and Grafana</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Promtail、Loki和Grafana记录Bash历史</h1>
<blockquote>原文：<a href="https://itnext.io/logging-bash-history-via-promtail-loki-and-grafana-9e70870a6cd?source=collection_archive---------2-----------------------#2022-06-21">https://itnext.io/logging-bash-history-via-promtail-loki-and-grafana-9e70870a6cd?source=collection_archive---------2-----------------------#2022-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/db29cafa5759f6c91596d8c026406c3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B0SULCl4XAWCJ50NZ4elng.png"/></div></div></figure><p id="1f0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们经常使用bash控制台。有时，您必须记住谁做了什么，何时运行了什么命令，并观察基础架构中的用户。或者说，当你使用apt升级和升级eg，Nginx时，你有多容易得到时间和日期？当然，除非您已经实现了GitOps方法，在这种方法中，基础设施中的所有更改都是使用X作为代码来完成的。我不得不这样透明地为我们的基础设施配置一切。</p><p id="0dee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个有趣的观察，那几个直接用手去摸基础设施的人，开始更加小心翼翼的使用控制台，包括我。在一个中心位置跨整个基础设施运行Bash命令是一个不错的选择，尤其是当您的基础设施可能有许多服务器，而您还没有使用编排系统时。</p><p id="47b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我们将一步一步地配置一台服务器，在控制台中显示所有输入的命令。上述所有命令最好与自动基础结构配置一起使用，因为在每台服务器上配置此功能需要很长时间。</p><p id="791c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我使用各种技术为Bash shell设置日志，并将这些日志转发给Grafana。Grafana和Loki在不同的监控服务器上。这使得演示如何为设置Bash日志设置各种组件变得容易，并且应该很容易在您自己的基础设施中复制这一功能。上述所有脚本和命令最好与自动基础结构配置一起使用，因为在每台服务器上单独配置该功能需要很长时间。</p><p id="15b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们开始吧！</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="d290" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">初始数据:</strong> <br/> <em class="ld">服务器1: </em>实验服务器，其bash历史我们会推送到监控中；这种服务器的数量不限。身份设定。<br/> <em class="ld">服务器2: </em>带有Grafana的监控服务器，我们将在其中安装Loki。</p><h1 id="186a" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">服务器1。设置操作员的bash环境</strong></h1><p id="c83d" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">确保您安装了rsyslog:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="be3f" class="mq lf iq mm b gy mr ms l mt mu">apt-get install -y update &amp;&amp; apt-get install -y rsyslog</span></pre><p id="4800" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">提示_命令</strong></p><p id="67b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了设置bash日志记录，我们将使用PROMPT_COMMAND环境变量。PROMPT_COMMAND的内容将在返回Bash提示符之前执行(即在终端中的每个交互命令执行之后)。这个Bash特性将允许我们通过本地对象发送日志，并使用rsyslog将它们写入日志文件。最后，我们将使用Promtail来转发Loki日志，并在Grafana中显示它们。</p><p id="9afb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要使用<strong class="ka ir"> PROMPT_COMMAND </strong>设置环境变量，请将以下代码行添加到<em class="ld"/><strong class="ka ir"><em class="ld">/etc/bash . bashrc:</em></strong></p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="341f" class="mq lf iq mm b gy mr ms l mt mu">export PROMPT_COMMAND=’RETRN_VAL=$?; if [ -f /tmp/lastoutput.tmp ]; then LAST_OUTPUT=$(cat /tmp/lastoutput.tmp); rm /tmp/lastoutput.tmp; fi; logger -S 10000 -p local6.debug “{\”user\”: \”$(whoami)\”, \”path\”: \”$(pwd)\”, \”pid\”: \”$$\”, \”b64_command\”: \”$(history 1 | sed “s/^[ ]*[0–9]\+[ ]*//” | base64 -w0 )\”, \”status\”: \”$RETRN_VAL\”, \”b64_output\”: \”$LAST_OUTPUT\”}”; unset LAST_OUTPUT;</span></pre><p id="1ed4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ld">哪里，</em></p><p id="b063" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="ld"> RETRN_VAL=$？；</em> </strong> — <em class="ld">设置包含前一次命令运行返回值的变量。因为PROMPT_COMMAND是在我们的提示符重新显示之前运行的，这最终意味着脚本将在我们运行每个命令之后运行；</em></p><p id="6981" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"><em class="ld">if[-f/tmp/last output . tmp]；然后LAST _ OUTPUT = $(cat/tmp/LAST OUTPUT . tmp)；RM/tmp/last out . tmp；fi；— </em> </strong> <em class="ld">检查名为/tmp/lastoutput.tmp的文件是否存在，将LAST_OUTPUT的值设置为文件内容的值，如果文件存在，则删除该文件。该文件将通过我们稍后创建的实用函数存储我们的命令的输出；</em></p><p id="7d27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"><em class="ld">logger-S 10000-p local6.debug—</em></strong><em class="ld">使用最多10000个字符的logger命令，并在本地对象local 6 . debug级别设置优先级。这将允许我们稍后使用rsyslog捕获日志；</em></p><p id="bb1b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"><em class="ld">" { \ \ " user \ ":\ " $(whoami)\ "，\\"path\": \"$(pwd)\ "，\ \ " PID \ ":\ " $ $ " b64 _ command \ ":\ " $(history 1 | sed-r " s/^\s*[0–9]+\s*// " | base64-w0)\ "，\\"status\": \"$RETRN_VAL\ "，\ \ " b64 _ output \ ":\ " $ last _ output \ " } "；— </em> </strong> <em class="ld">包含一条日志消息。在我们的例子中，我们使用JSON格式。这将使我们在构建ELK堆栈期间解析登录日志时更加容易。如您所见，我们注册了6个字段，包括:</em></p><ul class=""><li id="076d" class="mv mw iq ka b kb kc kf kg kj mx kn my kr mz kv na nb nc nd bi translated"><em class="ld">当前用户</em></li><li id="00cd" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated"><em class="ld">电流路径</em></li><li id="a48a" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated"><em class="ld"> PID </em></li><li id="d717" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated"><em class="ld">先前提取的运行命令使用</em> <code class="fe nj nk nl mm b"><em class="ld">history</em></code> <em class="ld">和base64编码。Base64编码确保命令在我们的JSON对象中正确转义。</em></li><li id="f4fd" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated"><em class="ld">前一次运行命令的返回值</em></li><li id="de4b" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated"><em class="ld">命令的base64编码输出(如果存在)。稍后我们将深入探讨这一领域；</em></li></ul><p id="d530" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="ld">未设置LAST _ OUTPUT</em> </strong> —我们禁用了LAST_OUTPUT变量，这样它就不会在命令之间持续。</p><p id="39e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">最后_输出</strong></p><p id="acf6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以设置我们的helper函数来捕获我们的命令的输出，这样我们就可以将它们发送到Loki。因为没有自动捕获命令输出的内置方法，所以我们必须执行命令两次，或者使用帮助器函数在PROMPT_COMMAND脚本中捕获输出。</p><p id="6d1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下命令必须包含在您的<strong class="ka ir"><em class="ld">/etc/bash . bashrc</em></strong>文件中:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="159e" class="mq lf iq mm b gy mr ms l mt mu">logoutput() { output=$(while read input; do echo “$input”; done &lt; “${1:-/dev/stdin}”); echo -e “$output“; echo -e “$output” | head -c 10000 | base64 -w0 &gt; /tmp/lastoutput.tmp; return $?; }</span></pre><p id="dacf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如图所示，logoutput命令捕获命令的输出或读取文件的内容，base64编码前10，000个字符，并将它们写入<em class="ld"> /tmp/lastoutput.tmp </em>(记住，这个文件以前在我们的PROMPT_COMMAND中使用过！).这个帮助器函数可以用于系统中的一个文件，或者可以传递给STDOUT以便于日志记录！</p><p id="76d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就完成了我们需要对<em class="ld"> /etc/bash.bashrc </em>文件所做的修改，现在我们可以继续设置rsyslog了。您需要确保将以下内容添加到您的<strong class="ka ir"><em class="ld">/etc/bash . bashrc</em></strong><em class="ld"/>配置中:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="860d" class="mq lf iq mm b gy mr ms l mt mu">export PROMPT_COMMAND=’RETRN_VAL=$?; if [ -f /tmp/lastoutput.tmp ]; then LAST_OUTPUT=$(cat /tmp/lastoutput.tmp); rm /tmp/lastoutput.tmp; fi; logger -S 10000 -p local6.debug “{\”user\”: \”$(whoami)\”, \”path\”: \”$(pwd)\”, \”pid\”: \”$$\”, \”b64_command\”: \”$(history 1 | sed “s/^[ ]*[0–9]\+[ ]*//” | base64 -w0 )\”, \”status\”: \”$RETRN_VAL\”, \”b64_output\”: \”$LAST_OUTPUT\”}”; unset LAST_OUTPUT; ‘</span><span id="1547" class="mq lf iq mm b gy nm ms l mt mu">logoutput() { output=$(while read input; do echo “$input”; done &lt; “${1:-/dev/stdin}”); echo -e “$output“; echo -e “$output” | head -c 10000 | base64 -w0 &gt; /tmp/lastoutput.tmp; return $?; }</span></pre><p id="3e38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">写入/var/log/bash/bash.log </strong></p><p id="9372" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将以下用于rsyslog监视本地对象local6的内容添加到以下文件:<strong class="ka ir"><em class="ld">/etc/rsyslog . d/bash . conf</em></strong>:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="359f" class="mq lf iq mm b gy mr ms l mt mu">local6.* /var/log/bash/bash.log</span></pre><p id="b4f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正在重新加载rsyslog:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a1a4" class="mq lf iq mm b gy mr ms l mt mu">service rsyslog restart</span></pre><p id="3f57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要为我们的日志添加logrotate，以便不无限期地存储它们。打开<strong class="ka ir"><em class="ld">/etc/log rotate . d/r syslog</em></strong>文件，向其中添加以下内容:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="11d7" class="mq lf iq mm b gy mr ms l mt mu">/var/log/bash/bash.log {<br/>    hourly<br/>    missingok<br/>    rotate 1<br/>    compress<br/>    delaycompress<br/>    notifempty<br/>    create 0600 promtail promtail<br/>    sharedscripts<br/>}</span></pre><p id="86ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来看看它是如何工作的！</p><p id="66f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们检查一下在控制台中执行命令后日志是如何写的:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c606" class="mq lf iq mm b gy mr ms l mt mu">cat /var/log/bash/bash.log</span></pre><p id="43ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您应该会在下面的截图中看到它:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/9e691c3a9611bb02795e8e7378381ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KbC_k0Qez16aDeMN9mmewg.png"/></div></div></figure><p id="097a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">设置提示信息</strong></p><p id="1737" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要安装promtail，它会将我们的日志文件直接发送到Loki:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="db27" class="mq lf iq mm b gy mr ms l mt mu"># Downliading promtail binary<br/>wget <a class="ae no" href="https://github.com/grafana/loki/releases/download/v2.3.0/promtail-linux-amd64.zip" rel="noopener ugc nofollow" target="_blank">https://github.com/grafana/loki/releases/download/v2.3.0/promtail-linux-amd64.zip</a></span><span id="544e" class="mq lf iq mm b gy nm ms l mt mu"># Unzipping downloaded archive<br/>unzip promtail-linux-amd64.zip</span><span id="066e" class="mq lf iq mm b gy nm ms l mt mu"># Copy promtail binary file<br/>cp -f promtail-linux-amd64 /usr/local/bin/promtail</span><span id="1bf2" class="mq lf iq mm b gy nm ms l mt mu"># Adding promtail user<br/>useradd --no-create-home --shell /bin/false promtail</span></pre><p id="a31b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们把Promtail变成一项服务。为此，创建<strong class="ka ir"><em class="ld">/etc/systemd/system/promtail . service</em></strong>文件并添加内容:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="dce0" class="mq lf iq mm b gy mr ms l mt mu">[Unit]<br/>Description=Promtail service<br/>After=network.target</span><span id="1d5c" class="mq lf iq mm b gy nm ms l mt mu">[Service]<br/>Type=simple<br/>User=promtail<br/>ExecStart=/usr/local/bin/promtail -config.file /usr/local/bin/config-promtail.ymlServer 2. Install Loki.</span><span id="3b59" class="mq lf iq mm b gy nm ms l mt mu">[Install]<br/>WantedBy=multi-user.target</span></pre><p id="0957" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重新读取服务配置文件:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="678e" class="mq lf iq mm b gy mr ms l mt mu">sudo systemctl daemon-reload</span></pre><p id="a47b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并创建一个配置文件<strong class="ka ir"><em class="ld">/usr/local/bin/config-promtail . yml</em></strong>，内容为:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5ab0" class="mq lf iq mm b gy mr ms l mt mu">server:<br/>http_listen_port: 9080<br/>grpc_listen_port: 0</span><span id="ea14" class="mq lf iq mm b gy nm ms l mt mu">positions:<br/>filename: /tmp/positions.yaml</span><span id="3e26" class="mq lf iq mm b gy nm ms l mt mu">clients:<br/>- url: http://&lt;monitoring server internal IP&gt;:3100/loki/api/v1/push</span><span id="c474" class="mq lf iq mm b gy nm ms l mt mu">scrape_configs:<br/>- job_name: system</span><span id="5917" class="mq lf iq mm b gy nm ms l mt mu">static_configs:<br/>- targets:<br/>- localhost</span><span id="b9d8" class="mq lf iq mm b gy nm ms l mt mu">labels:<br/>job: bash</span><span id="5000" class="mq lf iq mm b gy nm ms l mt mu">__path__: /var/log/bash/bash.log</span></pre><p id="f7cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">启动提示服务:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="738a" class="mq lf iq mm b gy mr ms l mt mu">sudo service promtail start</span></pre><p id="5054" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是时候进入下一步了——设置监控。</p><h1 id="0fa2" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">服务器2。安装Loki并配置Grafana </strong></h1><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="ab gu cl np"><img src="../Images/3629b24ef26de19da5ee34fce518888f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*k-hdOAQjRXKoyguzKuoeKg.png"/></div></figure><p id="ab41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装Loki:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="aa7d" class="mq lf iq mm b gy mr ms l mt mu"># Downloading Loki binary files<br/>wget <a class="ae no" href="https://github.com/grafana/loki/releases/download/v2.3.0/loki-linux-amd64.zip" rel="noopener ugc nofollow" target="_blank">https://github.com/grafana/loki/releases/download/v2.3.0/loki-linux-amd64.zip</a></span><span id="f93d" class="mq lf iq mm b gy nm ms l mt mu"># Unzip<br/>unzip loki-linux-amd64.zip</span><span id="ac95" class="mq lf iq mm b gy nm ms l mt mu"># Copy Loki binary file<br/>cp -f /tmp/loki-linux-amd64 /usr/local/bin/loki</span><span id="49e4" class="mq lf iq mm b gy nm ms l mt mu"># Add Loki user<br/>useradd --no-create-home --shell /bin/false loki</span></pre><p id="2af9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将Loki作为服务—创建<strong class="ka ir"><em class="ld">/etc/systemd/system/Loki . service</em></strong>文件并添加内容:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0b35" class="mq lf iq mm b gy mr ms l mt mu">[Unit]<br/>Description=Loki service<br/>After=network.target</span><span id="d80a" class="mq lf iq mm b gy nm ms l mt mu">[Service]<br/>Type=simple<br/>User=loki<br/>ExecStart=/usr/local/bin/loki -config.file /usr/local/bin/config-loki.yml</span><span id="378f" class="mq lf iq mm b gy nm ms l mt mu">[Install]<br/>WantedBy=multi-user.target</span></pre><p id="2e3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建一个配置文件<strong class="ka ir"><em class="ld">/usr/local/bin/config-Loki . yml</em></strong><br/>，添加内容:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="054c" class="mq lf iq mm b gy mr ms l mt mu">auth_enabled: false</span><span id="fce8" class="mq lf iq mm b gy nm ms l mt mu">server:<br/>    http_listen_port: 3100</span><span id="2961" class="mq lf iq mm b gy nm ms l mt mu">ingester:<br/>    lifecycler:<br/>        address: 127.0.0.1<br/>        ring:<br/>            kvstore:<br/>                store: inmemory<br/>            replication_factor: 1<br/>        final_sleep: 0s<br/>    chunk_idle_period: 5m<br/>    chunk_retain_period: 30s<br/>    max_transfer_retries: 0</span><span id="2109" class="mq lf iq mm b gy nm ms l mt mu">schema_config:<br/>    configs:<br/>        - from: 2018-04-15<br/>          store: boltdb<br/>          object_store: filesystem<br/>          schema: v11<br/>          index:<br/>              prefix: index_<br/>              period: 168h</span><span id="af9e" class="mq lf iq mm b gy nm ms l mt mu">storage_config:<br/>    boltdb:<br/>        directory: /tmp/loki/index</span><span id="2244" class="mq lf iq mm b gy nm ms l mt mu">    filesystem:<br/>        directory: /tmp/loki/chunks</span><span id="df5f" class="mq lf iq mm b gy nm ms l mt mu">limits_config:<br/>    enforce_metric_name: false<br/>    reject_old_samples: true<br/>    reject_old_samples_max_age: 168h</span><span id="7dc3" class="mq lf iq mm b gy nm ms l mt mu">chunk_store_config:<br/>    max_look_back_period: 0s</span><span id="565a" class="mq lf iq mm b gy nm ms l mt mu">table_manager:<br/>    retention_deletes_enabled: false<br/>    retention_period: 0s</span></pre><p id="64be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在官方<a class="ae no" href="https://grafana.com/docs/loki/latest/configuration" rel="noopener ugc nofollow" target="_blank">文档</a>中阅读更多关于配置的信息。</p><p id="9c8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为Loki索引创建目录:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2911" class="mq lf iq mm b gy mr ms l mt mu">mkdir /tmp/loki</span></pre><p id="5343" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，重新启动守护程序:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9738" class="mq lf iq mm b gy mr ms l mt mu">sudo systemctl daemon-reload</span></pre><p id="2604" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并启动Loki服务:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c013" class="mq lf iq mm b gy mr ms l mt mu">sudo service loki enable &amp;&amp; sudo service loki start</span></pre><p id="9e2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">监控服务器上的Loki服务被配置为从Promtail接收日志。</p><p id="62c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">让我们试着通过Grafana </strong> <br/>查看我们的bash历史记录。现在我们需要确保我们可以通过Grafana查看从服务器获得的日志。</p><p id="50c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">登录Grafana，向数据源添加一个新的Loki源:<br/> <strong class="ka ir">配置- &gt;数据源- &gt;添加数据源- &gt; Loki </strong>并将<a class="ae no" href="http://localhost:3100" rel="noopener ugc nofollow" target="_blank"> <em class="ld">添加到URL字段。<br/>如下图截图所示:</em></a></p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/90b7142f3bc1786d6e41781862bed9ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A-0Z6GALlTW5Jvglj6aRDg.png"/></div></div></figure><p id="304e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">浏览日志</strong></p><p id="44b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要查看日志，请点按边栏中的“浏览”按钮(🧭)。单击数据源，您可以看到日志文件列表，选择其中一个来查看日志。也可以这样输入自己的查询:<strong class="ka ir"><em class="ld">{ filename = "/var/log/bash/bash . log " }</em></strong>会给出来自syslog的日志。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/b0cf18243145b106779352b2bd45957d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3LeIRXxf1yZto8VHJgbe2w.png"/></div></div></figure><h1 id="aee5" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">结论。下一步是什么？</strong></h1><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/f9c84391fe7c3445f7b2186d9165d78d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8Av-xY-FynbDz6Eg"/></div></div></figure><p id="7fdd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将此配置扩展到我们所有的云重定向器、本地运营等。让跟踪正在完成的工作变得非常容易。这有时会让我们的生活更轻松。我希望这种方法能够通过Promtail和Loki帮助您在Grafana中配置bash历史日志。</p><p id="4003" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">设置愉快！</strong></p></div></div>    
</body>
</html>