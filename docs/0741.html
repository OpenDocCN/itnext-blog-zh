<html>
<head>
<title>Improve your Angular app performance by using this simple Observable cache decorator 🎉</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用这个简单的可观察缓存装饰器来提高Angular应用程序的性能🎉</h1>
<blockquote>原文：<a href="https://itnext.io/improve-your-angular-app-performance-by-using-this-simple-observable-cache-decorator-71e81dfa76ae?source=collection_archive---------0-----------------------#2018-05-20">https://itnext.io/improve-your-angular-app-performance-by-using-this-simple-observable-cache-decorator-71e81dfa76ae?source=collection_archive---------0-----------------------#2018-05-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/aa758ecf1baca1df653601ad9a0e616a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0Vr_jRpLXkkImjkz."/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@toineprojects?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">托因·卡尼尔</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="8e32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们即将在<a class="ae kc" href="https://www.swiftviews.com" rel="noopener ugc nofollow" target="_blank"> SwiftViews </a>中完成应用程序的开发时，我们注意到所有数据获取用户流中的一个模式。尽管这些应用程序都是数据驱动的，看起来非常动态，但在<strong class="kf ir">同一个用户会话</strong>中<strong class="kf ir">真正改变</strong>的并不是太多，但我们仍然对新内容发出http请求。</p><h2 id="ab47" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">最简单的解决方案是缓存</h2><p id="b3b9" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">缓存在哪里？在服务器上？我们已经有了，但这并不能阻止我们所有的应用程序访问我们的服务，从而增加它们的负载。</p><p id="f451" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也许我们可以使用服务工人，因为它允许缓存API调用？<br/>是的，这是选项之一，因为它已经与Angular进行了很好的<a class="ae kc" href="https://angular.io/guide/service-worker-getting-started" rel="noopener ugc nofollow" target="_blank">集成</a>，并允许一个简单的解决方案来选择性地缓存资源和API。然而，我们想要的是不仅能够选择缓存什么，而且能够选择何时缓存。</p><p id="0814" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">举个简单的例子——我们基本上想缓存下面页面的所有API调用结果，但前提是我们确定数据源没有以某种方式改变。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/78490648c8b8de9ef79cfd42d129460a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J6A7eI-fUYK2FV1pOZOdaQ.png"/></div></div></figure><p id="915f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于这是我的个人库存页面，它实际上唯一可以改变的方式是如果我从这个平台添加一个项目(目前唯一可以这样做的方式)，所以我有关于<strong class="kf ir">这个页面什么时候</strong>会改变以及我可以返回缓存内容多长时间的信息。</p><p id="4dc4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">我们认为以选择性和可配置的方式应用这种缓存的最佳方式是使用平台已经提供给我们的东西</strong></p><p id="d61a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们使用Angular和Typescript ❤️，并且我们所有的数据调用都通过RxJs，所以我们认为我们可以创建一个缓存可观察装饰器，我们用它来只为某些方法提供缓存能力。</p><p id="421c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之前，这是我们的方法，它调用我们的服务器来获取上面页面上的产品:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="ff70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就变成了:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="0f4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意,@Cacheable()已经被应用于我们想要的方法，并且还被传递了<code class="fe mg mh mi mj b">cacheBusterObserver</code>,这基本上是我们基于主题的机制，当流中发出任何值时，它告诉这个精确修饰的方法释放它所有的缓存。</p><p id="4800" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果下面的方法返回的可观察对象发出一个值，那么它将“缓存爆炸”上面方法的缓存😵</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="70f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可能是我们拥有的最复杂的例子，但我们也有其他配置实现，如<strong class="kf ir"> maxCacheCount、maxAge、slidingExpiration和自定义缓存决策器和解析器</strong>，它们为我们提供了对缓存内容、时间和方式的细粒度控制。参见那些在<a class="ae kc" href="## Deployment  Add additional notes about how to deploy this on a live system" rel="noopener ugc nofollow">的自述文件</a>。</p><p id="3204" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下面的两张gif图中，你可以看到我们的应用程序在没有缓存和有缓存时的性能差异。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="mk mf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">不可缓存</figcaption></figure><p id="ffa9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可缓存装饰器还没有应用，所以每次页面加载实际上都将从服务器获取数据</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="mk mf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">已应用可缓存装饰器🎉</figcaption></figure><p id="70dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">应用了可缓存装饰器，我们可以看到所有连续的页面加载都变得更快了。此外，用户资料页面会立即加载，因为我们已经在库存页面上调用了<code class="fe mg mh mi mj b">/user/{id}</code>端点。此外，在我们添加一个新项目后，缓存会崩溃，因此我们的用户会获得新的数据</p><p id="7218" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总而言之，这个简单的装饰器允许我们:</p><ol class=""><li id="ae71" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated">选择性地缓存可观察的方法(不仅仅是端点，也可能是流中计算量大的计算)</li><li id="33d3" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">提高我们应用程序的性能，<strong class="kf ir">而不需要</strong>任何业务逻辑重构(感谢TS decorators ❤️)</li><li id="d451" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">大大降低我们服务器的负载</li></ol><p id="9720" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想在你的项目中使用这个装饰器，就从NPM安装它吧！</p><p id="b61c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mg mh mi mj b">npm install ngx-cacheable</code></p><p id="9746" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你对此有任何问题或者想要贡献，不要介意打开一个pull request @ <a class="ae kc" href="https://github.com/angelnikolov/ngx-cacheable" rel="noopener ugc nofollow" target="_blank"> github </a>或者在下面评论。</p><p id="244b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，如果您喜欢该应用程序，请注册并建立自己的库存@ <a class="ae kc" href="https://www.swiftviews.com" rel="noopener ugc nofollow" target="_blank"> swiftviews </a>。</p><p id="dae7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">谢谢大家！🐦</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/d09768ad586a4129e75a8149eda183f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:192/0*JDnP-N1WOzShrCVA"/></div></figure><p id="3ca3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想找一份远程前端工作？<br/>有空的时候通知我们！立即订阅<a class="ae kc" href="https://www.remotefrontendjobs.com/" rel="noopener ugc nofollow" target="_blank">https://www.remotefrontendjobs.com/</a></p></div></div>    
</body>
</html>