<html>
<head>
<title>A beginner’s guide to networking in Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker网络初学者指南</h1>
<blockquote>原文：<a href="https://itnext.io/a-beginners-guide-to-networking-in-docker-ca5b822fb935?source=collection_archive---------0-----------------------#2020-12-17">https://itnext.io/a-beginners-guide-to-networking-in-docker-ca5b822fb935?source=collection_archive---------0-----------------------#2020-12-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="4d44" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">网络101</h2><div class=""/><div class=""><h2 id="4f1e" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">在本课中，我们将了解主机到容器和容器到容器的通信是如何发生的。由于这不是一个高级指南，我们将只探索Docker中网络的表面。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/1e573e2735de453d3a7f90771fbc3690.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*16qVSwrTxLXaSDugMF-Z7Q.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(来源:<a class="ae lh" href="https://unsplash.com/photos/Zuxxq0iHkN4" rel="noopener ugc nofollow" target="_blank"><strong class="bd li">unsplash.com</strong></a>)</figcaption></figure><p id="a4b8" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在之前的<a class="ae lh" href="https://medium.com/sysf/docker/home" rel="noopener"> <strong class="ll jd">课程</strong> </a>中，我们学习了大量关于Docker、Docker文件、Docker图像和Docker容器的知识。我们了解了Docker容器的隔离性质，以及如何使用<code class="fe mf mg mh mi b">-p</code> ( <em class="mj">或</em> <code class="fe mf mg mh mi b"><em class="mj">--publish</em></code>)标志将主机端口映射到容器端口以进行网络访问，或者使用<code class="fe mf mg mh mi b">-v</code> ( <em class="mj">或</em> <code class="fe mf mg mh mi b"><em class="mj">--volume</em></code>)标志从主机访问容器的文件，从而与运行中的容器连接。</p><p id="518c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在这一课中，我们将谈论集装箱化过程的网络方面。我们将探讨Docker为我们提供了哪些不同的选项来控制Docker容器的网络，以及如何根据我们的需要来使用它们。</p><p id="5dd7" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">Docker网络是一种媒介，通过它Docker容器可以与它的主机、主机上的其他容器或者主机网络内外的任何其他机器进行对话。为了配置网络，我们使用<code class="fe mf mg mh mi b">$ docker <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/network/" rel="noopener ugc nofollow" target="_blank">network</a></code>命令，它提供了子命令，如<code class="fe mf mg mh mi b">ls</code>、<code class="fe mf mg mh mi b">create</code>、<code class="fe mf mg mh mi b">attach</code>来配置网络和容器与它们的关系。</p><p id="fd4b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">当你第一次安装Docker时，我们会得到三种开箱即用的网络。你可以使用<code class="fe mf mg mh mi b">$ docker network <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/network_ls/" rel="noopener ugc nofollow" target="_blank">ls</a></code>命令来查看它们。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/6776f9fd358c02981f238d37ef356a28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*FUHtWGMVzIA9mM40q7HglQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker网络ls</figcaption></figure><p id="dc3c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">该命令显示Docker提供的内置网络，它们是不可移除的，因此您不能使用<code class="fe mf mg mh mi b">$ docker network rm &lt;network&gt;</code>命令(<em class="mj">其中</em> <code class="fe mf mg mh mi b"><em class="mj">network</em></code> <em class="mj">是</em> <code class="fe mf mg mh mi b"><em class="mj">NETWORK ID</em></code> <em class="mj">或</em> <code class="fe mf mg mh mi b"><em class="mj">NAME</em></code>)移除它们。</p><blockquote class="ml mm mn"><p id="a1ea" class="lj lk mj ll b lm ln kd lo lp lq kg lr mo lt lu lv mp lx ly lz mq mb mc md me im bi translated"><em class="it">💡</em>我将使用我们在“<a class="ae lh" href="https://medium.com/sysf/creating-your-first-docker-application-b0ce40ac67d1" rel="noopener">创建您的第一个Docker应用程序</a>”课程中开发的<code class="fe mf mg mh mi b">thatisuday/express-example</code>图像来演示一些网络示例。默认情况下，这个映像公开端口<code class="fe mf mg mh mi b">8000</code>，并运行<code class="fe mf mg mh mi b">node server.js</code>命令(<em class="it">使用</em> <code class="fe mf mg mh mi b"><em class="it">CMD</em></code> <em class="it">指令</em>)来启动一个express HTTP服务器，但是，我们可以通过使用<code class="fe mf mg mh mi b">$ docker run &lt;image&gt; &lt;params&gt;</code>命令提供参数来覆盖这个命令。</p></blockquote></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="5f44" class="my mz it bd li na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">桥接网络</h1><p id="dcc1" class="pw-post-body-paragraph lj lk it ll b lm np kd lo lp nq kg lr ls nr lu lv lw ns ly lz ma nt mc md me im bi translated">名为<strong class="ll jd">网桥</strong>的网络是默认情况下容器所连接的<strong class="ll jd">默认网络</strong>。它是由<strong class="ll jd">桥</strong>驱动程序创建的。驱动程序就像网络的模板，具有特定的行为和功能。网桥驱动程序在通常以IP地址<code class="fe mf mg mh mi b">172.X.X.X</code>开始的主机上创建私有IP地址的隔离池(<em class="mj">私有</em> <a class="ae lh" href="https://en.wikipedia.org/wiki/Subnetwork" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd"> <em class="mj">子网</em> </strong> </a>)。</p><p id="a0fb" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们可以使用<code class="fe mf mg mh mi b">$ docker inspect</code>或更好的<code class="fe mf mg mh mi b">$ docker network <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/network_inspect/" rel="noopener ugc nofollow" target="_blank">inspect</a> &lt;network&gt;</code>命令来检查网络。我们来看看网络<code class="fe mf mg mh mi b">bridge</code>网络的配置。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/c902d5625d47dcbd71d65b68dc9709f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*d15X-shTxQyi7WjnOc69BA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker网络检查</figcaption></figure><p id="d693" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe mf mg mh mi b">$ docker network inspect bridge</code>命令显示名为<code class="fe mf mg mh mi b">bridge</code>的网络配置。显示网络名称为<code class="fe mf mg mh mi b">bridge</code> ( <code class="fe mf mg mh mi b"><em class="mj">Name</em></code> <em class="mj">字段</em>)，由<code class="fe mf mg mh mi b">bridge</code>驱动(<code class="fe mf mg mh mi b"><em class="mj">Driver</em></code> <em class="mj">字段</em>)创建，其<code class="fe mf mg mh mi b">ID</code>为<code class="fe mf mg mh mi b">9a923c76f347</code> ( <code class="fe mf mg mh mi b"><em class="mj">Id</em></code> <em class="mj">字段</em>)。</p><p id="b2a8" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们把注意力集中在上面JSON的<code class="fe mf mg mh mi b">IPAM</code> ( <em class="mj"> IP地址管理</em>)部分。它显示了<code class="fe mf mg mh mi b">Subnet</code>和<code class="fe mf mg mh mi b">Gateway</code>的IP地址。<code class="fe mf mg mh mi b">Subnet</code>字段指定IP地址池，在这种情况下，除了作为默认网关的<code class="fe mf mg mh mi b">172.17.0.1</code>之外，该地址池将从<code class="fe mf mg mh mi b">172.17.X.X</code>开始。任何将连接到该网络的容器将从该地址池接收一个IP地址，并将使用<code class="fe mf mg mh mi b">172.17.0.1</code>地址作为默认网关。</p><blockquote class="ml mm mn"><p id="aeaf" class="lj lk mj ll b lm ln kd lo lp lq kg lr mo lt lu lv mp lx ly lz mq mb mc md me im bi translated"><em class="it">💡</em>连接到该网络的容器将获得从<code class="fe mf mg mh mi b">172.17.X.X</code>开始的IP地址的原因是，在<a class="ae lh" href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd"> CIDR </strong> </a>符号中的子网掩码是由<code class="fe mf mg mh mi b">172.17.0.0/16</code>值表示的<code class="fe mf mg mh mi b">16</code>。这意味着<code class="fe mf mg mh mi b">172.17.0.0</code>的前<code class="fe mf mg mh mi b">16</code>位是固定的，而其他<code class="fe mf mg mh mi b">16</code>位将用于子网的IP池。要了解更多关于子网划分的信息，请观看<a class="ae lh" href="https://www.youtube.com/watch?v=ecCuyq-Wprc" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">这段</strong> </a>视频。</p></blockquote><p id="fe30" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果我们看一下<code class="fe mf mg mh mi b">Containers</code>属性，它似乎是空的。这是因为我们没有连接到这个网络的运行容器。正如我们所了解的，当我们创建一个容器时，默认情况下容器将使用这个网络<strong class="ll jd"/>。</p><p id="d7f5" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">因此，让我们从<code class="fe mf mg mh mi b">thatisuday/express-example</code>图像创建一个容器。我们将以非分离模式运行这个容器，并用<code class="fe mf mg mh mi b">sh</code>命令覆盖默认的<code class="fe mf mg mh mi b">node server.js</code>命令(由Dockerfile 的 <code class="fe mf mg mh mi b"><em class="mj">CMD</em></code> <em class="mj">指令定义的<em class="mj">)来启动一个shell。</em></em></p><pre class="ks kt ku kv gt nv mi nw nx aw ny bi"><span id="816d" class="nz mz it mi b gy oa ob l oc od">$ docker run -it --init thatisuday/express-example sh</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/0fb6e9de431559d893c055f6c66acc06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*e-z8o36S2Z6XdBZuGmgcXg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker运行</figcaption></figure><p id="9f44" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">当我们运行容器时，它会将我们放入容器的外壳中，在那里我们可以访问各种Linux命令。<code class="fe mf mg mh mi b">$ hostname -i</code>显示机器的IP地址(<em class="mj">容器</em>)，即<code class="fe mf mg mh mi b">172.17.0.2</code>。我们可以使用<code class="fe mf mg mh mi b">$ ifconfig</code>命令查看容器的其他网络配置。</p><p id="e9e6" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">从容器的<code class="fe mf mg mh mi b">eth0</code>网络接口，我们还可以读取IP地址和子网掩码。作为子网掩码的<code class="fe mf mg mh mi b">255.255.0.0</code> IP地址被翻译成<code class="fe mf mg mh mi b">/16</code> CIDR符号。因此，我们可以确认该容器正在使用属于名为<code class="fe mf mg mh mi b">bridge</code>的网络的<code class="fe mf mg mh mi b">172.17.0.2/16</code>池中的IP地址。</p><p id="b265" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们使用<code class="fe mf mg mh mi b">$ docker inspect</code>或者更好的是使用<code class="fe mf mg mh mi b">$ docker container inspect &lt;container&gt;</code>命令来检查正在运行的容器，以查看容器的网络配置细节。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi of"><img src="../Images/52ce596da11e07e740cd6945d76faeaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xlo6d6hvS1cRXLrrJ-IWEA.png"/></div></div></figure><p id="1c28" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们可以使用<code class="fe mf mg mh mi b">$ docker ps</code>命令列出正在运行的容器，我们的运行容器ID是<code class="fe mf mg mh mi b">c81cc3b5f8aa</code>。然后使用<code class="fe mf mg mh mi b">$ docker container inspect</code>命令，我们可以看到<code class="fe mf mg mh mi b">.NetworkSettings</code>值。好好看看<code class="fe mf mg mh mi b">Networks</code>房产。它不仅显示<code class="fe mf mg mh mi b">IPAddress</code>，还显示它所连接的网络，在本例中是ID为<code class="fe mf mg mh mi b">9a923c76f347</code>的<code class="fe mf mg mh mi b">bridge</code>。</p><p id="8b0b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在我们有了一个连接到桥接网络的运行容器，我们应该能够在由<code class="fe mf mg mh mi b">$ docker network inspect</code>命令返回的JSON的<code class="fe mf mg mh mi b">Containers</code>字段中看到这个容器。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi og"><img src="../Images/f667a416d07de4cfcb8d2a916e9a5ab3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*51EXexcE4EX1C-j4sPz1KQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker网络检查</figcaption></figure><p id="9908" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">一旦我们退出容器，它将不再连接到网络，并且<code class="fe mf mg mh mi b">Container</code>字段将再次为空。让我们运行另一个容器，但这一次，我们将手动将其连接到网络。所以让我们创建一个桥接网络(<em class="mj">使用桥接驱动</em>)。</p><p id="5410" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们使用<code class="fe mf mg mh mi b">$ docker network <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/network_create/" rel="noopener ugc nofollow" target="_blank">create</a></code>命令创建一个网络。<code class="fe mf mg mh mi b">--driver</code>或<code class="fe mf mg mh mi b">-d</code>标志设置要使用的驱动程序，如果未提供，默认为<code class="fe mf mg mh mi b">bridge</code>。我们还可以使用<code class="fe mf mg mh mi b">--subnet</code>来控制子网(<em class="mj"> IP池</em>),否则Docker会自动配置它。</p><pre class="ks kt ku kv gt nv mi nw nx aw ny bi"><span id="f645" class="nz mz it mi b gy oa ob l oc od">$ docker network create -d bridge mybridge</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/6afa08a4abf7bb5fbdf0c80b16c5284f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*RnTclxYjRxGCMlxRlL0k2A.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker网络创建</figcaption></figure><p id="abf2" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在上面的例子中，我们有一个来自<code class="fe mf mg mh mi b">bridge</code>驱动程序的名为<code class="fe mf mg mh mi b">mybridge</code>的网络。通过检查，我们可以看到该网络的子网是<code class="fe mf mg mh mi b">172.19.0.0/16</code>，这意味着任何连接到该网络的容器都将获得一个以<code class="fe mf mg mh mi b">172.19.X.X</code>开头的IP地址。</p><p id="cd0a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在让我们从<code class="fe mf mg mh mi b">thatisuday/express-example</code>图像创建另一个容器，但是这一次，让我们使用带有<code class="fe mf mg mh mi b">$ docker run</code>的<code class="fe mf mg mh mi b">--network &lt;network&gt;</code>或<code class="fe mf mg mh mi b">--net &lt;network&gt;</code>标志手动指定一个网络。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/c19b591add87d392d1038bd5ec0eb45a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*_66-5GEVRZSN65bEZmS5VQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker运行</figcaption></figure><p id="f3ab" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在上面的例子中，我们已经要求Docker守护进程将<code class="fe mf mg mh mi b">mybridge</code>网络连接到我们正在创建的容器，因此Docker已经将<code class="fe mf mg mh mi b">172.19.0.2</code> IP地址从<code class="fe mf mg mh mi b">mybridge</code> IP池分配给容器。</p><p id="1905" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">您可以使用<code class="fe mf mg mh mi b">$ docker network <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/network_connect/" rel="noopener ugc nofollow" target="_blank">connect</a> &lt;network&gt; &lt;container&gt;</code>命令手动将容器连接到网络。一个容器可以加入多个网络，因此每个网络有多个公共IP地址。这样，一个容器可以与不同网络上的多个容器对话，从而使用多种服务。</p><p id="1dfe" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">类似地，您可以使用<code class="fe mf mg mh mi b"><a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/network_disconnect/" rel="noopener ugc nofollow" target="_blank">disconnect</a></code>子命令来执行相反的操作。只要没有运行的容器连接到网络，就可以使用<code class="fe mf mg mh mi b">$ docker network <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/network_rm/" rel="noopener ugc nofollow" target="_blank">rm</a> &lt;network&gt;</code>命令删除用户定义的网络。</p><h2 id="5b89" class="nz mz it bd li oj ok dn nd ol om dp nh ls on oo nj lw op oq nl ma or os nn iz bi translated">利益</h2><p id="d33a" class="pw-post-body-paragraph lj lk it ll b lm np kd lo lp nq kg lr ls nr lu lv lw ns ly lz ma nt mc md me im bi translated">那么拥有一个桥接网络有什么好处呢？桥接网络创建容器可以加入的私有本地网络，并且它与连接到另一桥接网络的容器隔离。</p><p id="8903" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">桥接网络中的容器就像一台孤立的机器，有自己的公共IP地址，可以被同一个网络中的其他容器<strong class="ll jd">和主机使用进行通信。容器的所有端口对主机保持隐藏，主机需要使用<code class="fe mf mg mh mi b">http://&lt;container-ip&gt;:&lt;port&gt;</code> URL进行HTTP通信。然而，主机可以使用<code class="fe mf mg mh mi b">--publish</code>或<code class="fe mf mg mh mi b">-p</code>标志将本地端口与容器的一个端口绑定在一起，使事情变得简单。</strong></p><blockquote class="ml mm mn"><p id="71e7" class="lj lk mj ll b lm ln kd lo lp lq kg lr mo lt lu lv mp lx ly lz mq mb mc md me im bi translated"><em class="it">💡</em>我在macOS上使用Docker，它在虚拟机中运行Docker引擎。这确实让事情变得有点复杂，但是我已经在<a class="ae lh" href="https://medium.com/sysf/docker-container-as-an-executable-to-process-images-using-go-golang-5233f9bd3bf7" rel="noopener"> <strong class="ll jd">这篇</strong> </a>文章中解释了如何访问这个虚拟机的外壳。所以每当我说主机时，我指的是这个虚拟机。</p></blockquote><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/5ddc838914664ab9533ea28a829d4053.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*ea05yad_r_eeov978JNf4g.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(码头集装箱)</figcaption></figure><p id="4281" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们在之前启动的容器中运行<code class="fe mf mg mh mi b">node server.js</code>命令，在端口<code class="fe mf mg mh mi b">8000</code>上启动一个HTTP服务器。由于这个容器的IP地址是<code class="fe mf mg mh mi b">172.19.0.2</code>，我们应该能够使用<code class="fe mf mg mh mi b">http://172.19.0.2:8080</code> URL从主机访问这个服务器。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/9a0c9dd9919b4569c0b92a791e9996c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*j5zhWVDm6TKV7TcJ0RaspQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(Docker主机)</figcaption></figure><p id="69a3" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如您所见，我们从运行在端口<code class="fe mf mg mh mi b">8000</code>上的IP地址为<code class="fe mf mg mh mi b">172.19.0.2</code>的容器的HTTP服务器获得了响应。然而，我们不能使用<code class="fe mf mg mh mi b">http://127.0.0.1:8000</code>或<code class="fe mf mg mh mi b">http://localhost:8000</code> URL，因为我们还没有将主机的本地端口映射到容器的端口<code class="fe mf mg mh mi b">8000</code>。然而，如果我们在<code class="fe mf mg mh mi b">$ docker run</code>命令中使用<code class="fe mf mg mh mi b">-p 8000:8000</code>标志，我们应该能够做到这一点。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/39eb9e604ec0e4881e3d493d1b87778a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*XvmiGZwIY8VVh4EUAPShOA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(Docker主机)</figcaption></figure><p id="3d33" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">正如我们所讨论的，桥接网络中的容器不能与另一个桥接网络中的容器通信。为了能够通信，它们应该在同一个网络上。我们可以使用<code class="fe mf mg mh mi b">$ docker network connect</code>命令将正在运行的容器与网络连接起来。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/3fd68d95217ddd81c0645d51e98d49c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*LJdF4DpL-9tFWKwPg5JxOQ.png"/></div></figure><p id="f55d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在上面的例子中，第一个容器能够从<code class="fe mf mg mh mi b">http://172.19.0.2:8080</code> URL下载图像，因为它与服务于HTTP端点的容器在同一个网络(<em class="mj"> mybridge </em>)上。然而，第二个容器不能使用这个端点，因为它在默认网络上(<em class="mj">桥</em>)。</p><p id="0ccc" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">桥接网络构建自己的DNS(域名系统)。默认情况下，每个容器的主机名都映射到其IP地址，因此您可以使用<code class="fe mf mg mh mi b">http://&lt;hostname&gt;:&lt;port&gt;</code>与同一个桥接网络中的容器进行通信。您还可以使用带有<code class="fe mf mg mh mi b">$ docker run</code>命令的<code class="fe mf mg mh mi b">--net-alias=&lt;alias&gt;</code>标志在DNS中添加一个条目来解析容器的IP地址，这样<code class="fe mf mg mh mi b">http://&lt;alias&gt;:&lt;port&gt;</code>就可以工作了。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ou"><img src="../Images/ce6342946e291484fa08f4df0be1abe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s_qqJ19xj2ahzVSupyV52g.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(码头集装箱一)</figcaption></figure><p id="fd63" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在上面的例子中，我们创建了一个使用<code class="fe mf mg mh mi b">mybridge</code>网络的容器，并为其设置了<code class="fe mf mg mh mi b">host.one</code>网络别名。让我们创建另一个容器(<em class="mj">有或没有别名</em>)并使用各种可用选项访问第一个容器的服务。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ou"><img src="../Images/ecd57eec444268e188e47cfb7c3ec635.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8k_um2CSsAI5HS6qHVQTAA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(码头集装箱二)</figcaption></figure><p id="094f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">从上面的结果可以看出，您可以使用IP地址、主机名或网络别名来访问连接到同一个桥接网络的容器。这样，您就不必依赖于容器的IP地址或主机名，并且可以自由地使用网络别名。</p><blockquote class="ml mm mn"><p id="f56b" class="lj lk mj ll b lm ln kd lo lp lq kg lr mo lt lu lv mp lx ly lz mq mb mc md me im bi translated"><em class="it">💡</em>要了解更多关于桥网的信息，请关注<a class="ae lh" href="https://docs.docker.com/network/bridge/" rel="noopener ugc nofollow" target="_blank"><strong class="ll jd"/></a>文档。</p></blockquote></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="c214" class="my mz it bd li na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">主机网络</h1><p id="eecc" class="pw-post-body-paragraph lj lk it ll b lm np kd lo lp nq kg lr ls nr lu lv lw ns ly lz ma nt mc md me im bi translated">与桥接网络相比，<strong class="ll jd">主机网络</strong>使用主机的网络，因此容器不再被隔离在专用网络中，并且它们不接收公共IP地址。它们实际上是主机网络上产生的服务，这就是它们消耗主机端口的原因。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/9b0b53b7e8795cd021280e30ebd7c9b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*fYZtZBJJrikb20Mm-tS6gQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker网络ls</figcaption></figure><p id="058b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">主机网络使用<code class="fe mf mg mh mi b">host</code>驱动程序，主机上只能有一个主机网络实例。因此，我们不能使用<code class="fe mf mg mh mi b">$ docker network create -d host</code>命令创建host类型的网络，因为Docker已经为我们创建了一个主机网络。</p><p id="3060" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们从<code class="fe mf mg mh mi b">thatisuday/express-example</code>图像创建一个容器，但是带有<code class="fe mf mg mh mi b">--net=host</code>标志。因为容器将使用主机的端口，所以<code class="fe mf mg mh mi b">--publish</code>或<code class="fe mf mg mh mi b">-p</code>标志没有意义，因此被丢弃并发出警告。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/10a2f84aa248d500097942b0dae6e0e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*rwIvVbtD5ZrmaxyNyaE60w.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(码头集装箱)</figcaption></figure><p id="2e0d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在上面的例子中，我们已经将<code class="fe mf mg mh mi b">host</code>网络连接到容器。如果我们检查容器的ID地址，它不再以<code class="fe mf mg mh mi b">172.X.X.X</code>开头，因为我们正在使用主机的网络，并且主机的IP地址是<code class="fe mf mg mh mi b">192.168.65.3</code>。因为我们已经在容器的端口<code class="fe mf mg mh mi b">8000</code>上启动了一个HTTP服务器，它将使用主机的端口<code class="fe mf mg mh mi b">8000</code>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/d365c1f37d6c078ae76b10ae7b1a0ead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*igxrNVKyzDqx4JIwcMhtbg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(Docker主机)</figcaption></figure><p id="e8ae" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如您所见，我们能够访问主机上的<code class="fe mf mg mh mi b">http://localhost:8000</code> URL，就好像我们已经在主机上启动了HTTP服务器一样。虽然这看起来很优雅，但你将无法从macOS上访问相同的URL(<em class="mj">比如浏览器</em>)。要解决这个问题，请遵循<a class="ae lh" href="https://medium.com/@lailadahi/getting-around-dockers-host-network-limitation-on-mac-9e4e6bfee44b" rel="noopener"> <strong class="ll jd">这篇</strong> </a>文章。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="97b0" class="my mz it bd li na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">无网络</h1><p id="4c0a" class="pw-post-body-paragraph lj lk it ll b lm np kd lo lp nq kg lr ls nr lu lv lw ns ly lz ma nt mc md me im bi translated">一个<strong class="ll jd">无网络</strong>不向容器提供任何联网能力，这意味着容器对于主机来说就像一个黑盒。主机或任何其他容器将无法与该容器通信。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/9b0b53b7e8795cd021280e30ebd7c9b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*fYZtZBJJrikb20Mm-tS6gQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker网络ls</figcaption></figure><p id="bc47" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">与主机网络类似，不能创建none网络。因此，让我们从<code class="fe mf mg mh mi b">thatisuday/express-example</code>图像创建一个带有<code class="fe mf mg mh mi b">--net=none</code>标志的容器。这样，容器就不会获得任何公共IP地址。它拥有的唯一IP地址是它的环回IP地址(<em class="mj"> localhost </em>)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/86b09ccc358359ad52a4284d1dae1307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*iEuiylhvzwdaip84Byw4ZA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(码头集装箱)</figcaption></figure><p id="f800" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">黑盒容器的用例不多，但它可以用来将自己与主机和其他容器隔离开来。它最适合运行非网络任务，同时避免与外部工作的任何通信。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="cb2c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">还有其他类型的网络驱动可用，如<strong class="ll jd">覆盖</strong>、<strong class="ll jd"> MACVLAN </strong>等。这比默认桥接网络提供了更多的功能。想了解更多关于他们的信息，请阅读这篇博文。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ow"><img src="../Images/e3da3bf1cee07cd997d46904bbbf70b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t4VSpLEAu4Gmg-GweZ3RvA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(<a class="ae lh" href="http://thatisuday.com" rel="noopener ugc nofollow" target="_blank"><strong class="bd li">thatisuday.com</strong></a>/<a class="ae lh" href="https://github.com/thatisuday" rel="noopener ugc nofollow" target="_blank">/<strong class="bd li">GitHub</strong></a>/<a class="ae lh" href="https://twitter.com/thatisuday" rel="noopener ugc nofollow" target="_blank"><strong class="bd li">Twitter</strong></a>/<strong class="bd li">stack overflow</strong><strong class="bd li"/>/<a class="ae lh" href="https://www.instagram.com/thatisuday/" rel="noopener ugc nofollow" target="_blank"><strong class="bd li">insta gram</strong></a>)</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/fdebb498630e863a0129025be5b74fb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/1*Cj3GjJSU7reYw49BYdQfpw.gif"/></div></figure></div></div>    
</body>
</html>