<html>
<head>
<title>Swift 101 — Basic Property</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 101 —基本属性</h1>
<blockquote>原文：<a href="https://itnext.io/swift-101-basic-property-92f02256dc07?source=collection_archive---------2-----------------------#2020-10-24">https://itnext.io/swift-101-basic-property-92f02256dc07?source=collection_archive---------2-----------------------#2020-10-24</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj jr"><img src="../Images/cfbb242e17bd6da9721682c3838c2fcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9R10D8GWdXIV66Fp"/></div></div></figure><p id="ff61" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi la translated"><span class="l lb lc ld bm le lf lg lh li di">在</span> Swift world中，有<code class="fe lj lk ll lm b">class</code>、<code class="fe lj lk ll lm b">struct</code>、<code class="fe lj lk ll lm b">enumeration</code>等多种数据类型。他们的区别是什么？<code class="fe lj lk ll lm b">class</code>在<strong class="ke iv">引用类型</strong>中，但<code class="fe lj lk ll lm b">struct</code>在<strong class="ke iv">值类型</strong>中。</p><p id="3d96" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">每个财产可以分为<strong class="ke iv">存储财产</strong>和<strong class="ke iv">计算财产</strong>。第一个有一个固定值，但是后者的值是在每次访问时计算的。此外，Swift为用户提供了一些观察者来监听值变化回调— <code class="fe lj lk ll lm b"><strong class="ke iv">willSet</strong></code>和<code class="fe lj lk ll lm b"><strong class="ke iv">didSet</strong></code>。</p><p id="d3a3" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">以上术语都是初学者的常见挑战。在本文中，我将简要介绍它们并指出一些技巧。希望这对你有用。</p></div><div class="ab cl ln lo hy lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="in io ip iq ir"><h1 id="1dd9" class="lu lv iu bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">引用类型(类)与值类型(结构)</h1><figure class="mt mu mv mw gu jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj ms"><img src="../Images/70dcd5957176bedda6bb3d5d72a79fa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h8addzF2aGkf9at-j5YZ6w.png"/></div></div></figure><p id="2c43" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe lj lk ll lm b">Class</code>和<code class="fe lj lk ll lm b">Struct</code>是Swift中的两种主要内存类型。<code class="fe lj lk ll lm b">Class</code>在<strong class="ke iv">引用类型</strong>中，指向内存的<strong class="ke iv">内存地址</strong>，但<code class="fe lj lk ll lm b">struct</code>在值类型中，<strong class="ke iv">指向存储在内存地址的数据</strong>。</p><figure class="mt mu mv mw gu jv"><div class="bz fq l di"><div class="mx my l"/></div></figure><p id="e95c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">因此，常量<code class="fe lj lk ll lm b">class</code>实例有一个常量内存地址，它的变量数据可以随时改变。然而，常量<code class="fe lj lk ll lm b">struct</code>实例有常量数据但有变量地址。参考第15行，当常量结构的数据被改变时，它将抛出一个编译错误。</p><p id="372f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe lj lk ll lm b">Struct</code>推荐首选。然而，当代码被设计为子类并且必须由Objective-C代码访问时，开发人员应该选择<code class="fe lj lk ll lm b">class</code>。</p></div><div class="ab cl ln lo hy lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="in io ip iq ir"><h1 id="0ff9" class="lu lv iu bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">计算属性— Getter和Setter</h1><figure class="mt mu mv mw gu jv"><div class="bz fq l di"><div class="mx my l"/></div></figure><p id="08ce" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">计算属性是一个特殊的属性，它有一个getter函数和一个setter函数。它的值是由getter函数在每次被访问时确定的(见第15行),而不是一个具有固定值的存储属性。当值改变时，Setter函数被调用(见第19行)。</p><p id="db51" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">常见的用例是使用持久存储进行数据处理。getter函数可以从存储器中检索数据，setter函数可以直接将数据设置到存储器中。它可以大大简化代码。</p><figure class="mt mu mv mw gu jv"><div class="bz fq l di"><div class="mx my l"/></div></figure><p id="b4d0" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">Setter函数在computed属性中是可选的。当计算属性中没有setter函数时，它被视为只读属性。</p></div><div class="ab cl ln lo hy lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="in io ip iq ir"><h1 id="c176" class="lu lv iu bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">观察者— willSet和didSet</h1><figure class="mt mu mv mw gu jv"><div class="bz fq l di"><div class="mx my l"/></div></figure><p id="a28c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe lj lk ll lm b">willSet</code>和<code class="fe lj lk ll lm b">didSet</code>是观察变量数据变化的另一个有用代码。</p><p id="04c9" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe lj lk ll lm b">willSet</code>在数据实际更改之前被调用，它有一个默认常量<code class="fe lj lk ll lm b">newValue</code>，显示将要设置的值。</p><p id="31d8" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">数据存储后立即调用<code class="fe lj lk ll lm b">didSet</code>，它有一个默认常量<code class="fe lj lk ll lm b">oldValue</code>，显示被覆盖的前一个值。</p><figure class="mt mu mv mw gu jv gi gj paragraph-image"><div class="gi gj mz"><img src="../Images/256c1e405c64efd585e2c5478f3e18c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*pcCQPg-ysV5XUdhbZd4D7A.png"/></div></figure><p id="3ac1" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe lj lk ll lm b">willSet</code>和<code class="fe lj lk ll lm b">didSet</code>不能用于计算属性，因为<code class="fe lj lk ll lm b">set</code>函数已经覆盖了它们的功能，实际上<code class="fe lj lk ll lm b">getter</code>只能存储属性不能设置！</p></div><div class="ab cl ln lo hy lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="in io ip iq ir"><h1 id="9cbf" class="lu lv iu bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">懒惰的财产</h1><figure class="mt mu mv mw gu jv"><div class="bz fq l di"><div class="mx my l"/></div></figure><p id="426f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe lj lk ll lm b">lazy</code>是一个很棒的关键字，它可以将对象的初始化推迟到第一次被访问的时候。当初始化过程很长或消耗内存时，这很有用。</p><p id="2e71" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在第13行，<code class="fe lj lk ll lm b">lengthyClass</code>实例被初始化，日志被打印100000000次。然而，<code class="fe lj lk ll lm b">lazyLengthyClass</code>实例被标记为<code class="fe lj lk ll lm b">lazy</code>，直到在第22行的<code class="fe lj lk ll lm b">viewDidLoad</code>方法中被访问，初始化过程才被调用。</p></div><div class="ab cl ln lo hy lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="in io ip iq ir"><h1 id="b881" class="lu lv iu bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">摘要</h1><ol class=""><li id="389f" class="na nb iu ke b kf nc kj nd kn ne kr nf kv ng kz nh ni nj nk bi translated">引用类型实例指向内存地址，而不是数据</li><li id="0dee" class="na nb iu ke b kf nl kj nm kn nn kr no kv np kz nh ni nj nk bi translated">值类型实例指向数据，但不指向地址</li><li id="bfe2" class="na nb iu ke b kf nl kj nm kn nn kr no kv np kz nh ni nj nk bi translated">当计算属性被访问和改变时，Getter和setter函数被调用。</li><li id="9d61" class="na nb iu ke b kf nl kj nm kn nn kr no kv np kz nh ni nj nk bi translated"><code class="fe lj lk ll lm b">willSet</code>和<code class="fe lj lk ll lm b">didSet</code>在存储的属性改变之前和之后被调用。</li><li id="31d2" class="na nb iu ke b kf nl kj nm kn nn kr no kv np kz nh ni nj nk bi translated"><code class="fe lj lk ll lm b">lazy</code>实例在第一次被访问之前不会被初始化。</li></ol></div><div class="ab cl ln lo hy lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="in io ip iq ir"><h1 id="b669" class="lu lv iu bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">参考</h1><h2 id="d0a2" class="nq lv iu bd lw nr ns dn ma nt nu dp me kn nv nw mi kr nx ny mm kv nz oa mq ob bi translated">1.Swift Properties官方文档</h2><div class="oc od gq gs oe of"><a href="https://docs.swift.org/swift-book/LanguageGuide/Properties.html" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fp"><div class="oh ab oi cl cj oj"><h2 class="bd iv gz z fq ok fs ft ol fv fx it bi translated">属性-Swift编程语言(Swift 5.3)</h2><div class="om l"><h3 class="bd b gz z fq ok fs ft ol fv fx dk translated">属性将值与特定的类、结构或枚举相关联。存储属性存储常数和…</h3></div><div class="on l"><p class="bd b dl z fq ok fs ft ol fv fx dk translated">docs.swift.org</p></div></div><div class="oo l"><div class="op l oq or os oo ot ka of"/></div></div></a></div><h2 id="268b" class="nq lv iu bd lw nr ns dn ma nt nu dp me kn nv nw mi kr nx ny mm kv nz oa mq ob bi translated">2.毛毛. es</h2><div class="oc od gq gs oe of"><a href="https://fluffy.es/reference-vs-value-type/" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fp"><div class="oh ab oi cl cj oj"><h2 class="bd iv gz z fq ok fs ft ol fv fx it bi translated">理解引用和值类型</h2><div class="om l"><h3 class="bd b gz z fq ok fs ft ol fv fx dk translated">最近我在r/swift中偶然发现了一个Reddit线程，其中一个用户对为什么他的代码的输出感到困惑…</h3></div><div class="on l"><p class="bd b dl z fq ok fs ft ol fv fx dk translated">毛毛. es</p></div></div><div class="oo l"><div class="ou l oq or os oo ot ka of"/></div></div></a></div><h2 id="14dc" class="nq lv iu bd lw nr ns dn ma nt nu dp me kn nv nw mi kr nx ny mm kv nz oa mq ob bi translated">3.苹果博客——价值和参考类型</h2><div class="oc od gq gs oe of"><a href="https://developer.apple.com/swift/blog/?id=10#:~:text=Types%20in%20Swift%20fall%20into,usually%20defined%20as%20a%20class" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fp"><div class="oh ab oi cl cj oj"><h2 class="bd iv gz z fq ok fs ft ol fv fx it bi translated">价值和参考类型- Swift博客</h2><div class="om l"><h3 class="bd b gz z fq ok fs ft ol fv fx dk translated">Swift中的类型分为两类:第一类是“值类型”，其中每个实例都保留其…</h3></div><div class="on l"><p class="bd b dl z fq ok fs ft ol fv fx dk translated">developer.apple.com</p></div></div><div class="oo l"><div class="ov l oq or os oo ot ka of"/></div></div></a></div><h2 id="de08" class="nq lv iu bd lw nr ns dn ma nt nu dp me kn nv nw mi kr nx ny mm kv nz oa mq ob bi translated">4.在结构和类之间选择</h2><div class="oc od gq gs oe of"><a href="https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fp"><div class="oh ab oi cl cj oj"><h2 class="bd iv gz z fq ok fs ft ol fv fx it bi translated">Apple开发者文档</h2><div class="om l"><h3 class="bd b gz z fq ok fs ft ol fv fx dk translated">编辑描述</h3></div><div class="on l"><p class="bd b dl z fq ok fs ft ol fv fx dk translated">developer.apple.com</p></div></div></div></a></div></div><div class="ab cl ln lo hy lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="in io ip iq ir"><figure class="mt mu mv mw gu jv gi gj paragraph-image"><div class="gi gj ow"><img src="../Images/714cdbac461229aa6279271dd00648fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/0*pqws0DAZrHh3KnBg.png"/></div></figure><p id="9dd7" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">欢迎您通过<a class="ae ox" href="https://twitter.com/myrick_chow" rel="noopener ugc nofollow" target="_blank">Twitter @ my rik _ chow</a>关注我，了解更多信息和文章。感谢您阅读这篇文章。祝您愉快！😄</p></div></div>    
</body>
</html>