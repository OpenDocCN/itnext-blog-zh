<html>
<head>
<title>Build A View-Framework-Free Data Layer Based on MobX — Integration With Vue (1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于MobX构建无视图框架的数据层—与Vue集成(1)</h1>
<blockquote>原文：<a href="https://itnext.io/build-a-view-framework-free-data-layer-based-on-mobx-integration-with-vue-1-8b524b86c7b8?source=collection_archive---------4-----------------------#2018-06-06">https://itnext.io/build-a-view-framework-free-data-layer-based-on-mobx-integration-with-vue-1-8b524b86c7b8?source=collection_archive---------4-----------------------#2018-06-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d3b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">预告:</em> <a class="ae km" href="https://github.com/mobxjs/mobx-vue" rel="noopener ugc nofollow" target="_blank"> <em class="kl"> mobx-vue </em> </a> <em class="kl">已被移至mobxjs组织！</em></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/95b801f5a06e5d9235f03a13e9e236c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DKGrYF_md8fStP0vE6WE2Q.png"/></div></div></figure><p id="71b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几周前我写了一篇文章描述mobx和angularjs的用法以及它的用途，这次我将介绍如何将MobX和Vue结合起来。</p><p id="4b6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">安装</strong></p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="3c6f" class="le lf iq la b gy lg lh l li lj">npm i mobx-vue -S</span></pre><p id="82b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">用途</strong></p><p id="59b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">mobx-vue使用起来非常简单。您只需要使用Connect来装饰您的mobx定义的vue组件存储:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="2d59" class="le lf iq la b gy lg lh l li lj">&lt;template&gt;<br/>    &lt;section&gt;<br/>        &lt;p v-text="amount"&gt;&lt;/p&gt;<br/>        &lt;p v-for="user in users" :key="user.name"&gt;{{user.name}}&lt;/p&gt;<br/>    &lt;/section&gt;<br/>&lt;/template&gt;</span><span id="36b6" class="le lf iq la b gy lk lh l li lj">&lt;script lang="ts"&gt;<br/>    import { Connect } from "mobx-vue";<br/>    import Vue from "vue";<br/>    import Component from "vue-class-component";<br/>    class ViewModel {<br/>        <a class="ae km" href="http://twitter.com/observable" rel="noopener ugc nofollow" target="_blank">@observable</a> users = [];<br/>        <a class="ae km" href="http://twitter.com/computed" rel="noopener ugc nofollow" target="_blank">@computed</a> get amount() { return this.users.length }<br/>        <a class="ae km" href="http://twitter.com/action" rel="noopener ugc nofollow" target="_blank">@action</a> fetchUsers() {}<br/>    }</span><span id="759d" class="le lf iq la b gy lk lh l li lj"><a class="ae km" href="http://twitter.com/Connect" rel="noopener ugc nofollow" target="_blank">@Connect</a>(new ViewModel())<br/>    <a class="ae km" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>()<br/>    export default class App extends Vue {<br/>        mounted() { <br/>            this.fetchUsers();<br/>        }<br/>    }<br/>&lt;/script&gt;</span></pre><p id="5b89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">为什么选择MobX/mobx-vue </strong></p><p id="e233" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们知道MobX和Vue都是基于数据劫持和依赖收集来实现响应机制的。mobx官方也几次提到受vue 启发的<em class="kl">。那么我们为什么要把两个几乎一样的东西组合在一起呢？</em></p><blockquote class="ll lm ln"><p id="9f04" class="jn jo kl jp b jq jr js jt ju jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj kk ij bi translated">是的，很奇怪。</p></blockquote><p id="c69e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2016年，我在构建公司级组件库的时候，就开始思考一个问题:当代码库是基于一个特殊的框架时，我们未来如何尽可能省力地将组件库迁移到其他框架/库？不能基于新技术完全重写，那浪费生命。除了基本的控件，交互/行为逻辑基本上是可确定的，最多在UI中做一些调整。公司简单推倒底层库去尝试新技术也是非常不负责任的。所以我们要接受被框架绑架，卡在一个技术栈里卡住？对于一个前端框架半衰期特别短的领域来说显然是不可接受的，结果要么有人离职，要么找不到人一起补洞……简单来说就是享受不到新技术的好处。</p><p id="5cce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从MVVM架构来看，应用越重，复杂度越集中在M (Model)和VM (ViewModel)两层，尤其是模型层。理论上应该是独立于上层视图独立运行/测试/发布。不同的视图框架只使用具有不同绑定语法的动态模板引擎，我在以前的文章中已经介绍过了..如果我们把视图层做得很薄，我们迁移的成本自然会降到一个可以接受的范畴，甚至有可能通过工具在编译时自动生成不同框架的视图层代码。</p><p id="cb39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使模型甚至ViewModel可以独立地重用，我们需要一个通用的、与框架无关的状态管理机制来帮助我们描述数据模型之间的依赖图。期间尝试了ES6 accessor、redux、rxjs等解决方案，都不尽如人意。存取器太低级异步不友好，redux开发体验太差，rxjs太重等等。直到我遇到了MobX: MobX足够简单，无绑定，面向oop，无框架，其他特性完全符合我的需求。</p><p id="45e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在过去的一年里，我尝试在react、angularjs和angular上构建一个基于MobX的VM/M层。有两个在线项目和一个个人项目。实际效果基本达到了我的预期。在架构上，我们只需要使用相关的连接器在基于同一数据层的不同框架之间进行切换。现在只有Vue还没有用这套思路验证。</p><p id="57a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在mobx-vue之前，社区已经有了一些优秀的连接器实现，比如<a class="ae km" href="https://github.com/nighca/movue" rel="noopener ugc nofollow" target="_blank"> move </a> <a class="ae km" href="https://github.com/dwqs/vue-mobx" rel="noopener ugc nofollow" target="_blank"> vue-mobx </a>，但它们基本上都是基于vue的插件机制，受vue-rx的启发，除了使用的繁琐，最大的问题是实现都是基于vue.util.defineReactive，也就是说，是基于Vue自身的响应机制。这不仅在一定程度上浪费了MobX的反应能力，而且会以可预测的行为迁移到其他视图框架中(也就是说，你无法确定Vue或MobX是谁对状态变化做出反应)。</p><p id="a749" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理想情况下，mobx应该管理数据依赖性，vue只需对mobx做出反应并进行重新渲染。Vue被当作动态模板渲染引擎，就像react一样。</p><p id="6a65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">mobx-vue如何工作</strong></p><p id="5b78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然我们的目标是把vue变成一个纯粹的模板渲染引擎(vdom)并且使用mobx的reactive机制来代替vue的，那么只要劫持vue组件的组件挂载和更新方法，然后在组件挂载时收集依赖项，在依赖项更新时更新组件。</p><p id="2f2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下将称为mobx-vue的工作原理，而不是vue的工作原理:</p><p id="8884" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们知道Vue通常是这样初始化的:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="87eb" class="le lf iq la b gy lg lh l li lj">new Vue({ el: '#app', render: h =&gt; h(App)});</span></pre><p id="6bde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们找到了Vue构造函数:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="74ba" class="le lf iq la b gy lg lh l li lj">function Vue (options) {   ......   this._init(options) }</span></pre><p id="0cf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">转到_init函数，我们找到了$mount函数:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="31b7" class="le lf iq la b gy lg lh l li lj">if (vm.$options.el) {   vm.$mount(vm.$options.el) }</span></pre><p id="9ed7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以web运行时为例，$mount函数是:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="cc27" class="le lf iq la b gy lg lh l li lj">if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {<br/>    updateComponent = () =&gt; {<br/>        ...<br/>    }<br/>} else {<br/>    updateComponent = () =&gt; {<br/>        vm._update(vm._render(), hydrating)<br/>    }<br/>}</span><span id="b811" class="le lf iq la b gy lk lh l li lj">vm._watcher = new Watcher(vm, updateComponent, noop)</span></pre><p id="430b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以看到，updateComponent方法将是组件更新的关键入口，跟进Watcher构造函数，看看Vue是如何调用这个方法的:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="977e" class="le lf iq la b gy lg lh l li lj">constructor (<br/>    vm: Component,<br/>    expOrFn: string | Function,<br/>    cb: Function,<br/>    options?: Object<br/>  ) {<br/>    ...<br/>    this.expression = process.env.NODE_ENV !== 'production'<br/>      ? expOrFn.toString()<br/>      : ''<br/>    // parse expression for getter<br/>    if (typeof expOrFn === 'function') {<br/>      this.getter = expOrFn<br/>    } else {<br/>      this.getter = parsePath(expOrFn)<br/>      ...<br/>    }<br/>    this.value = this.lazy<br/>      ? undefined<br/>      : this.get()<br/>...........</span><span id="52ef" class="le lf iq la b gy lk lh l li lj">get () {<br/>    ...<br/>    try {<br/>      value = this.getter.call(vm, vm)<br/>    } catch (e) {<br/>      ...<br/>  }</span></pre><p id="8b27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以发现组件加载/更新的发起方是:value = this.getter.call(vm，vm)，我们可以通过:vm得到方法引用。_watcher.getter，意思是updateComponent := vm。_watcher.getter。</p><p id="0c8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们只需要在“$mount”之前，直接将MobX管理的数据嵌入到组件上下文中，让MobX在调用“$mount”时收集相应的依赖关系，并在MobX检测到发生变化时调用“updateComponent”。这不仅允许MobX的反应机制以一种简单的方式侵入Vue系统，还保证了组件的原生行为不受影响(生命周期挂钩等。).</p><p id="ffd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根本就是利用MobX的反应机制来接管Vue的Watcher，将Vue降级为一个纯粹的vdom渲染引擎。</p><p id="76dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">核心实现非常简单:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="7730" class="le lf iq la b gy lg lh l li lj">const { $mount } = Component.prototype;</span><span id="9445" class="le lf iq la b gy lk lh l li lj">Component.prototype.$mount = function (this: any, ...args: any[]) {<br/>    let mounted = false;<br/>    const reactiveRender = () =&gt; {<br/>        reaction.track(() =&gt; {<br/>            if (!mounted) {<br/>                $mount.apply(this, args);<br/>                mounted = true;<br/>            } else {<br/>                this._watcher.getter.call(this, this);<br/>            }<br/>        });</span><span id="1a9a" class="le lf iq la b gy lk lh l li lj">return this;<br/>    };<br/>    const reaction = new Reaction(`${name}.render()`, reactiveRender);<br/>    dispose = reaction.getDisposer();<br/>    return reactiveRender();<br/>};</span></pre><p id="21e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是完整的代码:<a class="ae km" href="https://github.com/mobxjs/mobx-vue/blob/master/src/connect.ts" rel="noopener ugc nofollow" target="_blank">https://github . com/mobxjs/mobx-vue/blob/master/src/connect . ts</a></p><p id="ebdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">结论</strong></p><p id="cf9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="lr ls ep" href="https://medium.com/u/4f198f5f1f12?source=post_page-----8b524b86c7b8--------------------------------" rel="noopener" target="_blank">尤雨溪</a>说过:<a class="ae km" href="https://twitter.com/youyuxi/status/736939734900047874" rel="noopener ugc nofollow" target="_blank"> mobx + react是一个更啰嗦的Vue。</a>本质上就是这样，mobx &amp; react组合的能力正是Vue与生俱来的。而mobx-vue做的恰恰相反:降级vue来反应，然后用mobx升级到Vue。这真的很奇怪。但是，我想说的是，我们的初衷并不是指Vue的reactive机制实现得不够好，想用mobx取而代之，而是想通过MobX这种相对中立的状态管理平台，为不同的视图层技术提供一个相对通用的数据层编程范式，试图平滑不同框架和技术栈之间的语法差异，以便为开发者提供更多的视图技术的决策权和可能性，而不会陷入一个框架中。</p></div></div>    
</body>
</html>