<html>
<head>
<title>Using async/await to write cleaner route handlers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用async/await编写更干净的路由处理程序</h1>
<blockquote>原文：<a href="https://itnext.io/using-async-await-to-write-cleaner-route-handlers-7fc1d91b220b?source=collection_archive---------0-----------------------#2018-03-23">https://itnext.io/using-async-await-to-write-cleaner-route-handlers-7fc1d91b220b?source=collection_archive---------0-----------------------#2018-03-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ec6ee47b7f6c3dc634c18cdb4987f171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XdIn9mTX6h0iwnQkFjePbA.png"/></div></div></figure><blockquote class="jy jz ka"><p id="2dbd" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae la" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fusing-async-await-to-write-cleaner-route-handlers-7fc1d91b220b%3Futm_source%3Dmedium_sharelink%26utm_medium%3Dsocial%26utm_campaign%3Dbuffer" rel="noopener ugc nofollow" target="_blank">点击这里在LinkedIn上分享这篇文章</a></p></blockquote><p id="83d5" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">自2013年以来，我一直在编写Node.js应用程序，以编写一个我从未完成的实时聊天中继应用程序。这些年来，我在大部分项目中使用Node.js，我开发了一些看起来不会改变生活的技术，但是稍微改进了工作流。</p><p id="cd87" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">其中一个功能是使用<code class="fe le lf lg lh b">async/await</code>。<code class="fe le lf lg lh b">async/await</code>通过保存缩进级别(臭名昭著的JavaScript回调地狱)给了我清理代码的能力，但也给了我控制应用程序流的能力，而不必求助于另一个缩进级别。</p></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><p id="aab1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在我作为独立web开发人员的工作中，我发现自己大部分时间都在编写RESTful APIs。为了处理一个API调用而执行大量异步操作的情况并不少见，因此使用承诺无疑是让事情运转的一个重要部分。</p><p id="1335" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这是我的一个项目中的一个例子:</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="0222" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这是一个非常简单的路由处理程序，首先从数据库获取<code class="fe le lf lg lh b">media</code>对象，然后使用模板引擎呈现它们。</p><p id="51a0" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">我的项目中最经常出现的一段代码是我的处理程序的<code class="fe le lf lg lh b">.catch()</code>部分。因为我所有的错误都是由路由链中更底层的一个(有时更多)错误处理程序来处理的，所以我需要能够将一个错误传递给<code class="fe le lf lg lh b">next()</code>方法，否则它们就不会被正确处理。</p><p id="1546" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">所以我有两个问题想解决:</p><ol class=""><li id="0b24" class="lv lw iq ke b kf kg kj kk lb lx lc ly ld lz kz ma mb mc md bi translated">我想摆脱回调地狱(虽然，在这个例子中，这不完全是一个问题)</li><li id="94ca" class="lv lw iq ke b kf me kj mf lb mg lc mh ld mi kz ma mb mc md bi translated">我不想再重复自己，一遍又一遍地写同样的代码</li></ol><p id="f89b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">第一个问题可以通过使用<code class="fe le lf lg lh b">async/await</code>很容易地解决，但是我仍然以下面的代码结束:</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="8568" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">如您所见，重要的代码不再被回调分割(在请求处理程序范围内请求数据，并在<code class="fe le lf lg lh b">.then()</code>解析器回调中呈现数据)，但是我仍然有不得不一遍又一遍地重复代码的问题。</p><p id="5727" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">如果您的路由处理程序更加复杂，那么在您的代码中可能会出现多个<code class="fe le lf lg lh b">try/catch</code>块，同样会导致多个缩进层次，从而导致代码不那么整洁。</p><p id="7170" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">然后，我想出了一个非常简单的方法来解决我的问题:一个中间件函数，它允许我用6个额外的字符来包装我的实际路由处理程序，并且再也不用处理这个问题了！</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="6411" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">现在，我所要做的就是将中间件包含在我的<code class="fe le lf lg lh b">routes/videos.js</code>文件中，并使用它:</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="4fbb" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">现在，我的代码可能抛出的所有错误(语法错误、错误的变量名、来自外部库的异常)都将由我的错误处理程序来处理，根据我的环境设置，它可能在生产中显示一个<code class="fe le lf lg lh b">InternalServerError</code>，但在<code class="fe le lf lg lh b">development</code>中显示一个详细的错误。</p><p id="59f3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">希望这一小段代码可以帮助您维护一个干净的存储库。</p><p id="0fee" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated"><strong class="ke ir">TL；dr抽象，不管多小，都能改善你的代码</strong></p></div></div>    
</body>
</html>