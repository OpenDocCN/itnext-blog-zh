<html>
<head>
<title>Using automated runtime data validation decorators in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在TypeScript中使用自动化运行时数据验证装饰器</h1>
<blockquote>原文：<a href="https://itnext.io/using-automated-runtime-data-validation-decorators-in-typescript-d9df5449a06c?source=collection_archive---------4-----------------------#2022-03-11">https://itnext.io/using-automated-runtime-data-validation-decorators-in-typescript-d9df5449a06c?source=collection_archive---------4-----------------------#2022-03-11</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj jr"><img src="../Images/6ca6cfd42c9e934a317a63988958b5bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZirIacImy12o_zsK.png"/></div></div><figcaption class="kc kd gk gi gj ke kf bd b be z dk translated">作者图片</figcaption></figure><p id="e7c2" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">【TypeScript的一个新包使我们能够自动检查运行时数据的有效性，而不必显式调用验证库。相反，<em class="le">运行时数据验证</em>包让我们附加描述数据有效性的装饰器，并安排在给属性赋值或调用方法时自动执行验证。</p></div><div class="ab cl lf lg hy lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="in io ip iq ir"><p id="1ae4" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">在JavaScript中没有类型检查，也没有内置的数据验证。这是这门语言的核心特征，也是它如此受欢迎的部分原因。与此同时，我们在越来越大的项目中使用JavaScript，理论上，这使得有必要使用软件工具来帮助我们编写更简洁的应用程序。在其他语言中，这意味着严格的类型检查和运行时数据检查，但是在JavaScript中，我们不想偏离核心命题太远。</p><p id="9655" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">TypeScript是JavaScript试验高级语言特性的一种方法。例如，它将类型声明和编译时类型检查添加到JavaScript中。最近，在更新我的《在Node.js应用程序中使用Typescript和TypeORM的快速入门》一书(赞助商链接)时，我了解了如何使用TypeScript decorators。从那以后，我创建了一个关于使用和实现TypeScript装饰器的系列文章<a class="ae lm" href="https://techsparx.com/nodejs/typescript/decorators/introduction.html" rel="noopener ugc nofollow" target="_blank">。有一篇文章是关于</a><a class="ae lm" href="https://techsparx.com/nodejs/typescript/decorators/runtime-validation.html" rel="noopener ugc nofollow" target="_blank">开发TypeScript decorators，用于在JavaScript/TypeScript </a>中执行运行时数据验证。从那篇文章中，我创建了<code class="fe ln lo lp lq b"><a class="ae lm" href="https://github.com/runtime-data-validation-js/runtime-data-validation-typescript" rel="noopener ugc nofollow" target="_blank">runtime-data-validation</a></code>包，它是数据验证的完整实现，在TypeScript程序中，它在两种情况下自动验证数据:</p><ol class=""><li id="3004" class="lr ls iu ki b kj kk kn ko kr lt kv lu kz lv ld lw lx ly lz bi translated">带有附加验证装饰器的<code class="fe ln lo lp lq b">set</code>访问器属性的赋值</li><li id="7b73" class="lr ls iu ki b kj ma kn mb kr mc kv md kz me ld lw lx ly lz bi translated">对参数附加了验证装饰符的类方法的调用</li></ol><p id="8600" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这篇文章是关于使用包的，而前一篇文章是关于实现执行运行时数据验证的装饰器。这种方法不同于像Joi或AJV这样的软件包，程序员必须显式地编写数据验证代码。使用<code class="fe ln lo lp lq b">runtime-data-validation</code>，程序员将decorators附加到访问器或方法参数上，这样这些方法就能自动防止无效数据。</p><p id="4fb5" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">举个简单的例子，考虑这个类:</p><pre class="mf mg mh mi gu mj lq mk ml aw mm bi"><span id="ffc2" class="mn mo iu lq b gz mp mq l mr ms">import {<br/>    ValidateAccessor, IsFloatRange,<br/>    conversions<br/>} from 'runtime-data-validation';<br/><br/>const { ToFloat } = conversions;<br/><br/>export class SpeedExample {<br/><br/>    #speed: number;<br/><br/>    @ValidateAccessor&lt;number | string&gt;()<br/>    @IsFloatRange(10, 70)<br/>    set speed(nc: number | string) { <br/>        this.#speed = ToFloat(nc);<br/>    }<br/>    get speed() { return this.#speed; }<br/><br/>}</span></pre><p id="54ef" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">有一个私有属性<code class="fe ln lo lp lq b">#speed</code>和一个处理器函数对<code class="fe ln lo lp lq b">speed</code>，它处理私有属性的获取和设置。<code class="fe ln lo lp lq b">@IsFloatRange</code>装饰器确保该值是在<code class="fe ln lo lp lq b">10</code>和<code class="fe ln lo lp lq b">70</code>之间的浮点数。它还处理一个碰巧是数字的<code class="fe ln lo lp lq b">string</code>值。</p><pre class="mf mg mh mi gu mj lq mk ml aw mm bi"><span id="af08" class="mn mo iu lq b gz mp mq l mr ms">const sp = new SpeedExample();<br/>sp.speed = VALUE;</span></pre><p id="4a3f" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">对于像<code class="fe ln lo lp lq b">30</code>或<code class="fe ln lo lp lq b">'30'</code>这样的值，这可以正确执行。对于像<code class="fe ln lo lp lq b">300</code>或<code class="fe ln lo lp lq b">'300'</code>或<code class="fe ln lo lp lq b">'300 miles/hr'</code>这样的值，会抛出一个错误。该错误阻止了<code class="fe ln lo lp lq b">set</code>访问器的执行，并阻止了属性被赋予不正确的值。</p><p id="fcea" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">换句话说，<code class="fe ln lo lp lq b">runtime-data-validation</code>包的核心价值主张是针对由验证装饰器保护的属性或方法，它们不会收到不正确的数据。任何不正确的数据都将被检测到，从而引发错误。</p><h1 id="e8f5" class="mt mo iu bd mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np bi translated">安装<code class="fe ln lo lp lq b">runtime-data-validation</code>包</h1><p id="d05a" class="pw-post-body-paragraph kg kh iu ki b kj nq kl km kn nr kp kq kr ns kt ku kv nt kx ky kz nu lb lc ld in bi translated">本教程是为Node.js项目编写的。在浏览器端项目中使用<code class="fe ln lo lp lq b">runtime-data-validation</code>尚未经过测试。因此，设置一个Node.js项目，并对其进行配置以进行TypeScript开发。例如:</p><pre class="mf mg mh mi gu mj lq mk ml aw mm bi"><span id="c551" class="mn mo iu lq b gz mp mq l mr ms">$ npm init -y <br/>$ npm install typescript @types/node --save-dev</span></pre><p id="4975" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">接下来，要为支持decorators做两个设置。在您的<code class="fe ln lo lp lq b">tsconfig.json</code>文件中进行这些设置:</p><pre class="mf mg mh mi gu mj lq mk ml aw mm bi"><span id="55a1" class="mn mo iu lq b gz mp mq l mr ms">{<br/>    "compilerOptions": {<br/>        ...<br/>        "experimentalDecorators": true,<br/>        "emitDecoratorMetadata": true,<br/>        ...<br/>    }<br/>}</span></pre><p id="8543" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">完成这个设置后，按如下方式安装软件包:</p><pre class="mf mg mh mi gu mj lq mk ml aw mm bi"><span id="54ab" class="mn mo iu lq b gz mp mq l mr ms">$ npm install runtime-data-validation</span></pre><p id="3d92" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">上面显示的示例代码现在应该运行了。</p><p id="6072" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">有关该包的详细文档，请参见:<a class="ae lm" href="https://runtime-data-validation-js.github.io" rel="noopener ugc nofollow" target="_blank">https://runtime-data-validation-js . github . io</a></p><h1 id="071d" class="mt mo iu bd mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np bi translated">类型检查与数据验证</h1><p id="2e2d" class="pw-post-body-paragraph kg kh iu ki b kj nq kl km kn nr kp kq kr ns kt ku kv nt kx ky kz nu lb lc ld in bi translated">数据验证与类型检查略有不同。例如，类型为<code class="fe ln lo lp lq b">string</code>的变量<code class="fe ln lo lp lq b">title</code>理论上可以包含任何字符串值。但是，应用程序可能要求这个变量具有给定地区/语言的文本，或者被约束为特定的格式。</p><p id="c398" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">类型检查确保变量<code class="fe ln lo lp lq b">title</code>是一个<code class="fe ln lo lp lq b">string</code>。数据验证不仅确保变量具有正确的类型，而且确保其当前值在所需的约束范围内。</p><h1 id="dbac" class="mt mo iu bd mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np bi translated">执行装饰器和验证装饰器</h1><p id="d7ed" class="pw-post-body-paragraph kg kh iu ki b kj nq kl km kn nr kp kq kr ns kt ku kv nt kx ky kz nu lb lc ld in bi translated">从<code class="fe ln lo lp lq b">runtime-data-validation</code>出口的装修工有两种。</p><pre class="mf mg mh mi gu mj lq mk ml aw mm bi"><span id="0c53" class="mn mo iu lq b gz mp mq l mr ms">import {<br/>    IsIntRange, IsInt, IsFloatRange, IsFloat,<br/>    ...<br/>    ValidateParams, ValidateAccessor,<br/>} from 'runtime-data-validation';</span></pre><p id="3bf5" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">大多数的<em class="le">验证装饰符</em>都被拼写成<code class="fe ln lo lp lq b">@IsXYZZY</code>，这里应该理解为“<em class="le"> value is type XYZZY </em>”。它们执行数据验证，每个都包含一个验证函数。</p><p id="c0ad" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">两个<em class="le">执行装饰器</em>分别是<code class="fe ln lo lp lq b">@ValidateParams</code>和<code class="fe ln lo lp lq b">@ValidateAccessor</code>。第一个用于方法，处理附加到方法参数的验证装饰器的执行，而第二个用于<code class="fe ln lo lp lq b">set</code>访问器，处理附加到访问器的验证装饰器的执行。</p><p id="3152" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">为了了解两者的作用，我们来看一个更大的例子:</p><pre class="mf mg mh mi gu mj lq mk ml aw mm bi"><span id="693a" class="mn mo iu lq b gz mp mq l mr ms">import {<br/>    ValidateAccessor, ValidateParams,<br/>    IsIntRange, IsInt, IsFloatRange,<br/>    conversions<br/>} from 'runtime-data-validation';<br/><br/>const { ToFloat, ToInt } = conversions;<br/><br/>export class ValidateExample {<br/><br/>    #year: number;<br/><br/>    @ValidateAccessor&lt;number&gt;()<br/>    @IsIntRange(1990, 2050)<br/>    @IsInt()<br/>    set year(ny: number | string) { this.#year = ToInt(ny); }<br/>    get year() { return this.#year; }<br/><br/>    @ValidateParams<br/>    area(<br/>        @IsFloatRange(0, 1000) width: number | string,<br/>        @IsFloatRange(0, 1000) height: number | string<br/>    ) {<br/>        return ToFloat(width) * ToFloat(height);<br/>    }<br/><br/>}</span></pre><p id="e955" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这里有两项受到验证装饰器的保护:</p><ol class=""><li id="c8be" class="lr ls iu ki b kj kk kn ko kr lt kv lu kz lv ld lw lx ly lz bi translated">私有属性<code class="fe ln lo lp lq b">#year</code>和<code class="fe ln lo lp lq b">set</code>访问器<code class="fe ln lo lp lq b">year</code>，用<code class="fe ln lo lp lq b">@IsInt</code>和<code class="fe ln lo lp lq b">@IsIntRange</code>声明。这些装饰器确保它的值是一个介于<code class="fe ln lo lp lq b">1990</code>和<code class="fe ln lo lp lq b">2050</code>之间的整数。<code class="fe ln lo lp lq b">@ValidateAccessor</code>装饰器处理验证装饰器的执行。</li><li id="0369" class="lr ls iu ki b kj ma kn mb kr mc kv md kz me ld lw lx ly lz bi translated">方法<code class="fe ln lo lp lq b">are</code>有两个参数，每个参数都附加了<code class="fe ln lo lp lq b">@IsFloatRange</code>，确保值在<code class="fe ln lo lp lq b">0</code>到<code class="fe ln lo lp lq b">1000</code>的范围内。<code class="fe ln lo lp lq b">@ValidateParams</code>装饰器处理验证装饰器的执行。</li></ol><p id="cd22" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">该类的测试可能如下所示:</p><pre class="mf mg mh mi gu mj lq mk ml aw mm bi"><span id="a6a3" class="mn mo iu lq b gz mp mq l mr ms">const ve = new ValidateExample();<br/><br/>ve.year = 1999;<br/>console.log({<br/>    year: ve.year,<br/>    area: ve.area(10, 200)<br/>});<br/><br/>// Error: Value 2150 not an integer between 1990 and 2050<br/>ve.year = 2150;<br/><br/>console.log(ve.area('10', '200'));<br/><br/>// Error: Value 'two hundred' not a float between 0 and 1000<br/>console.log(ve.area('10', 'two hundred'));</span></pre><p id="58db" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">对于值在可接受范围内的赋值或方法调用，语句执行时不会出错。对于具有超出范围或无效值的语句，将抛出此处显示的错误。比如写<code class="fe ln lo lp lq b">'two hundred'</code>的程序员可能本意是好的，但是文本字符串不是数值。</p><h1 id="01fa" class="mt mo iu bd mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np bi translated">验证功能</h1><p id="5424" class="pw-post-body-paragraph kg kh iu ki b kj nq kl km kn nr kp kq kr ns kt ku kv nt kx ky kz nu lb lc ld in bi translated">在TypeScript文档中，我们被敦促实现<em class="le">类型保护</em>函数来帮助运行时类型检查。该功能是接收数据项，检查该数据项，并确定它是否具有正确的形状。</p><p id="0fed" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">您可能声明了一个类型:</p><pre class="mf mg mh mi gu mj lq mk ml aw mm bi"><span id="4b2d" class="mn mo iu lq b gz mp mq l mr ms">type CustomType = {<br/>    flag1: boolean;<br/>    speed: number;<br/>    title?: string;<br/>};</span></pre><p id="28c7" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">你的程序如何确定一个变量是否有这种形状？在这种情况下，不能使用<code class="fe ln lo lp lq b">instanceof</code>。这个想法是检查字段并确保它们匹配。</p><pre class="mf mg mh mi gu mj lq mk ml aw mm bi"><span id="1bb8" class="mn mo iu lq b gz mp mq l mr ms">const isCustomType = (value: any): value is CustomType =&gt; {<br/>    if (typeof value !== 'object') {<br/>        return false;<br/>    }<br/>    // Both of these fields are required in<br/>    // the type definition<br/>    if (typeof value?.flag1 !== 'boolean'<br/>     || typeof value?.speed !== 'number') {<br/>        return false;<br/>    }<br/>    // Speed must be a positive number<br/>    if (value.speed &lt; 0) {<br/>        return false;<br/>    }<br/>    // This field is optional, and therefore can<br/>    // be undefined.<br/>    if (typeof value?.title !== 'undefined'<br/>     &amp;&amp; typeof value?.title !== 'string') {<br/>        return false;<br/>    }<br/>    // Be certain that `title` is correct<br/>    if (typeof value?.title !== 'undefined'<br/>     &amp;&amp; typeof value?.title === 'string') {<br/>        if (!validators.isAscii(value.title)<br/>         || !validators.matches(value.title, /^[a-zA-Z0-9 ]+$/)) {<br/>            return false;<br/>        }<br/>    }<br/>    return true;<br/>};</span></pre><p id="fc74" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">参数的类型<code class="fe ln lo lp lq b">any</code>允许测试任何变量。返回类型<code class="fe ln lo lp lq b">value is CustomType</code>，就是TypeScript所说的<em class="le">类型谓词</em>。在行为上，它与<code class="fe ln lo lp lq b">boolean</code>没有区别，换句话说，它是一种<code class="fe ln lo lp lq b">true</code>或<code class="fe ln lo lp lq b">false</code>状态。在这个函数中有一些测试来确保<code class="fe ln lo lp lq b">value</code>有正确的字段来匹配<code class="fe ln lo lp lq b">Customtype</code>。</p><p id="c7af" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">函数的最后一部分超出了类型检查。这将检查<code class="fe ln lo lp lq b">valu.title</code>中字符串的格式。不管出于什么原因，这个应用程序希望它是包含字母、数字和空格的ASCII文本。</p><p id="c833" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">注意，为了验证文本格式，我们使用了<code class="fe ln lo lp lq b">validators.isAscii</code>和<code class="fe ln lo lp lq b">validators.matches</code>。这些函数中的每一个都有相应的验证装饰器。但是这个上下文不允许我们使用decorators。</p><p id="6335" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">包含在<code class="fe ln lo lp lq b">runtime-data-validation</code>中的是一组对应于验证装饰器的验证函数。每个验证装饰器使用一个验证函数。</p><p id="3139" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">要使用这些功能:</p><pre class="mf mg mh mi gu mj lq mk ml aw mm bi"><span id="2f71" class="mn mo iu lq b gz mp mq l mr ms">import { validators } from 'runtime-data-validation';</span></pre><p id="1610" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这个导入提供了对包含验证函数的<code class="fe ln lo lp lq b">validators</code>对象的访问。</p><p id="1af9" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">我们已经看到了如何使用这些函数。它们的行为与类型守卫函数相同，这意味着它们接受一个值，然后提供一个<code class="fe ln lo lp lq b">boolean</code>通知您该值是否匹配。</p><h1 id="19de" class="mt mo iu bd mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np bi translated">自定义验证装饰器</h1><p id="8f77" class="pw-post-body-paragraph kg kh iu ki b kj nq kl km kn nr kp kq kr ns kt ku kv nt kx ky kz nu lb lc ld in bi translated">虽然<code class="fe ln lo lp lq b">runtime-data-validation</code>包包含了一长串验证装饰器，但它们并不是数据验证的最终目的。有接近无数的其他数据验证可以执行。</p><p id="b953" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">为此，<code class="fe ln lo lp lq b">generateValidationDecorator</code>函数允许应用程序创建验证装饰器。例如，<em class="le"> CustomType </em>类型的验证装饰器可能如下所示:</p><pre class="mf mg mh mi gu mj lq mk ml aw mm bi"><span id="3a4b" class="mn mo iu lq b gz mp mq l mr ms">function IsCustom() {<br/>  return generateValidationDecorator(<br/>               isCustomType,<br/>              `Value :value: is not a CustomType`); <br/>}</span></pre><p id="560e" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">每个TypeScript装饰器都由一个函数实现。这意味着<code class="fe ln lo lp lq b">IsCustom</code>函数可以像<code class="fe ln lo lp lq b">@IsCustom()</code>一样用作装饰器。</p><p id="5d20" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated"><code class="fe ln lo lp lq b">generateValidationDecorator</code>的第一个参数是用于验证的函数。该函数将接收一个值，并预期返回一个<code class="fe ln lo lp lq b">boolean</code>，其中<code class="fe ln lo lp lq b">true</code>表示该值是正确的。换句话说，这个函数需要一个类型保护函数。第二个参数是一个字符串，如果值不合适，就打印出来，<code class="fe ln lo lp lq b">:value:</code>接收<code class="fe ln lo lp lq b">util.inspect(value)</code>的结果。</p><p id="295d" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">假设您需要进一步定制验证。例如，<code class="fe ln lo lp lq b">speed</code>字段可能有一个可接受的值范围。</p><pre class="mf mg mh mi gu mj lq mk ml aw mm bi"><span id="9c16" class="mn mo iu lq b gz mp mq l mr ms">function IsCustomRange(min: number, max: number) {<br/>    return generateValidationDecorator(<br/>        (value) =&gt; {<br/>            if (!isCustomType(value)) return false;<br/>            const ct = &lt;CustomType&gt;value;<br/>            if (ct.speed &lt; min || ct.speed &gt; max) return false;<br/>            return true;<br/>        },<br/>        `Value :value: is not a CustomType`);<br/>}</span></pre><p id="8838" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这遵循装饰工厂模式。外部函数的参数配置如何验证值。在这种情况下，新验证函数的代码首先调用<code class="fe ln lo lp lq b">isCustomType</code>，然后检查<code class="fe ln lo lp lq b">speed</code>以验证它是否在要求的范围内。</p><p id="d778" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">要使用它，将<code class="fe ln lo lp lq b">@IsCustomRange(0, 150)</code>附加到一个访问函数或方法参数。</p><h1 id="45b5" class="mt mo iu bd mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np bi translated">摘要</h1><p id="0a88" class="pw-post-body-paragraph kg kh iu ki b kj nq kl km kn nr kp kq kr ns kt ku kv nt kx ky kz nu lb lc ld in bi translated"><code class="fe ln lo lp lq b">runtime-data-validation</code>包填补了JavaScript/TypeScript功能的空白。有了它，我们可以在值到达我们的对象实例之前自动验证它们。</p><p id="e38a" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">它提供了一长串内置的验证装饰器和验证函数。此外，它让您可以轻松定义自己的验证装饰器。</p><p id="fe22" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">由于TypeScript实现decorator的方式，decorator只能附加到<code class="fe ln lo lp lq b">set</code>访问器和方法参数上。若要验证其他内容，请使用验证函数，或者实现您自己的类型保护函数。</p><h1 id="fc7c" class="mt mo iu bd mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np bi translated">关于作者</h1><p id="63ea" class="pw-post-body-paragraph kg kh iu ki b kj nq kl km kn nr kp kq kr ns kt ku kv nt kx ky kz nu lb lc ld in bi translated"><a class="ae lm" href="https://davidherron.com" rel="noopener ugc nofollow" target="_blank"><strong class="ki iv"><em class="le">David Herron</em></strong></a><em class="le">:David Herron是一名作家和软件工程师，专注于技术的明智使用。他对太阳能、风能和电动汽车等清洁能源技术特别感兴趣。David在硅谷从事了近30年的软件工作，从电子邮件系统到视频流，再到Java编程语言，他已经出版了几本关于Node.js编程和电动汽车的书籍。</em></p></div><div class="ab cl lf lg hy lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="in io ip iq ir"><p id="9e25" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated"><em class="le">原载于</em>【https://techsparx.com】<em class="le"/><em class="le">。</em></p></div></div>    
</body>
</html>