<html>
<head>
<title>How to Build a NodeJS Wrapper for a Weather API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为天气API构建NodeJS包装器</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-build-a-nodejs-wrapper-for-a-weather-api-28404caedfdb?source=collection_archive---------0-----------------------#2021-04-08">https://itnext.io/how-to-build-a-nodejs-wrapper-for-a-weather-api-28404caedfdb?source=collection_archive---------0-----------------------#2021-04-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/22507aafb2121a4d36bf19abeb91e4fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xF3iuq5Hg-mYubfkezh97w.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kc" href="https://unsplash.com/@mael_balland?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Mael BALLAND </a>拍摄的照片</figcaption></figure><p id="2aaa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您点击了这篇文章，您可能希望将天气API集成到您的应用程序中。也许这是一个需求，而您的应用程序主要面向天气数据，或者只是一个增强。这个想法是你需要获得一些天气信息，并用它们做一些事情。</p><p id="0a07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数API使用REST、GET和POST调用与客户端通信并发送所需的数据。通常，您必须为GET请求创建一个长的URL，或者创建一个复杂的POST主体，其中还包含一些其他的头。您可以将这些get或POST调用封装在一些易于使用的函数中，并使它们在整个项目中都可用，而不是每次想要获取天气数据时都编写这些调用。</p><p id="e868" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">毕竟，<a class="ae kc" href="https://deviq.com/principles/dont-repeat-yourself" rel="noopener ugc nofollow" target="_blank"> DRY </a>是编程的核心原则，我们在这里也应该应用它。</p><p id="9296" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看到一种可以围绕天气API构建小型包装器的方法。</p><p id="17cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">主要思想是封装收割代码，并通过函数、方法或属性公开其功能。</p><p id="3450" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为编程范例，我们将使用<a class="ae kc" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank"> OOP </a>并将代码封装在一个类中。</p><h1 id="f01e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">代码</h1><p id="95aa" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对于本文，我选择使用Tomorrow.io <a class="ae kc" href="https://www.tomorrow.io/weather-api/" rel="noopener ugc nofollow" target="_blank">天气API </a>。这是一个免费使用的API，提供了多个数据层。你可以用它来获取有关空气质量、花粉火灾风险等数据。文档也非常全面，易于理解，为开发人员提供了许多资源和指南。</p><p id="8850" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最重要的是，通过最新的API更新，所有端点都在一个数据调用中被折叠，因此引入接受任何天气查询的一体化端点使集成变得更加容易。</p><p id="22c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您有不同的天气API，您仍然可以修改本文中的代码并应用相关的模式。</p><p id="60f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">第一步:项目设置</strong></p><p id="3f9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们正在为应用程序的后端构建一个NodeJS包装器。项目设置非常简单。</p><p id="fba2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">打开一个新的命令行，在你想要的文件夹中运行命令<code class="fe me mf mg mh b">npm init -y</code>，然后运行命令<code class="fe me mf mg mh b">npm i node-fetch</code>。这将创建文件<code class="fe me mf mg mh b">package.json</code>并安装模块node-fetch，这是一个轻量级模块，将<code class="fe me mf mg mh b">window.fetch</code>引入Node.js</p><p id="0e5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要完成这个设置，需要创建一个index.js文件并导入node-fetch模块。</p><p id="3aa8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">const fetch = require("node-fetch");</code></p><p id="633f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">第二步:文档</strong></p><p id="a082" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了构建API的包装器，我们首先需要与API进行通信。在这种情况下，API的<a class="ae kc" href="https://docs.climacell.co/reference/migrating" rel="noopener ugc nofollow" target="_blank">文档</a>是我们最好的朋友。这是来自Tomorrow.io文档的URL:</p><p id="5f24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b"><a class="ae kc" href="https://data.tomorrow.io/v4/timelines?location=LAT%2CLONG&amp;fields=FIELD_NAME&amp;timesteps=1m&amp;apikey=API_KEY" rel="noopener ugc nofollow" target="_blank">https://data.tomorrow.io/v4/timelines?location=LAT%2CLONG&amp;fields=FIELD_NAME&amp;timesteps=1m&amp;apikey=API_KEY</a></code></p><p id="1d5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要从该提供商处获取天气数据，我们需要提供:</p><ul class=""><li id="d0f0" class="mi mj iq kf b kg kh kk kl ko mk ks ml kw mm la mn mo mp mq bi translated">我们想要的位置的纬度和经度</li><li id="8681" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">我们的API_KEY</li><li id="5f4d" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">时间步长:<strong class="kf ir"> 1m </strong>为实时，<strong class="kf ir"> 1h </strong>为每小时，<strong class="kf ir"> 1d </strong>为每日数据。</li></ul><p id="edb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">fields</code>参数将是一个包含字段的数组，我们需要获取这些字段的数据。这些值在<a class="ae kc" href="https://docs.climacell.co/reference/data-layers-overview" rel="noopener ugc nofollow" target="_blank">数据层</a>下可用。</p><p id="29e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">API_KEY可以通过在他们的平台上创建一个免费账户来获得。他们提供了一个免费的API密匙，每天最多只能使用1000次。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/404a002153e841cf74b0c5fdcf04d1a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/0*ISfzF7XhAjofGTXK.PNG"/></div></figure><p id="55dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从这些信息开始，假设我们想要实时获得巴塞罗那的温度、湿度和降水概率。我们需要向以下URL发出GET请求:</p><p id="60a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b"><a class="ae kc" href="https://data.tomorrow.io/v4/timelines?location=41.3851%2C2.1734&amp;fields=temperature&amp;fields=humidity&amp;fields=precipitationProbability&amp;timesteps=1m&amp;apikey=API_KEY" rel="noopener ugc nofollow" target="_blank">https://data.tomorrow.io/v4/timelines?location=41.3851%2C2.1734&amp;fields=temperature&amp;fields=humidity&amp;fields=precipitationProbability&amp;timesteps=1m&amp;apikey=API_KEY</a></code></p><p id="3f1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了测试这一点，您可以用自己的密钥替换API_KEY，然后将这个URL粘贴到一个新的选项卡中，您应该会看到下面的输出。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/c5fe4e84e2b0dbe0d31236329fa5b23c.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/0*FIfEi6qwQn0y-2OZ.PNG"/></div></figure><p id="2ca2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，数值将以<strong class="kf ir">国际制</strong>的<strong class="kf ir">为单位。</strong>如果你想检索<strong class="kf ir">美国惯用单位的数据，</strong>那么你必须添加参数<code class="fe me mf mg mh b">&amp;units=imperial</code>。</p><h1 id="16b1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">第三步:包装</h1><p id="9290" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在我们知道了如何编写URL，我们可以开始编码了。</p><p id="9ce9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将从定义我们的类和构造函数开始。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/a0b6a4ee6fd94f912f486296170031b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0I5lEPBlTibxfby6.png"/></div></div></figure><p id="371b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构造函数将接收API_KEY和所需位置的坐标作为参数，并将它们存储为<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields" rel="noopener ugc nofollow" target="_blank">私有字段</a>。</p><h1 id="c6b9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">第四步:获取数据</h1><p id="a1cc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">正如我们之前提到的，在最新的Tomorrow.io更新中，所有端点都被合并到一个端点中，其中包含了我们需要的所有数据，因此我们需要创建一个通用方法来接收我们想要作为参数获取的字段，以及时间步长:实时、每日或每小时。</p><p id="85b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为<code class="fe me mf mg mh b">node-fetch</code>是<code class="fe me mf mg mh b">window.fetch</code>的轻量级包装器，它不提供用查询参数构建复杂URL的方法。因此，为了使事情变得简单，我编写了一个简单的函数来为我们构建URL:</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/7a776adcf968ccb80485b09f93a934a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DHmZ5DrgjQdZDeOG.png"/></div></div></figure><p id="4dcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请记住，我们的测试URL是:</p><p id="21d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b"><a class="ae kc" href="https://data.tomorrow.io/v4/timelines?location=41.3851%2C2.1734&amp;fields=temperature&amp;fields=humidity&amp;fields=precipitationProbability&amp;timesteps=1m&amp;apikey=API_KEY" rel="noopener ugc nofollow" target="_blank">https://data.tomorrow.io/v4/timelines?location=41.3851%2C2.1734&amp;fields=temperature&amp;fields=humidity&amp;fields=precipitationProbability&amp;timesteps=1m&amp;apikey=API_KEY</a></code></p><p id="2dd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用这个助手函数<code class="fe me mf mg mh b"> queryBuilder()</code>来构建这个URL。函数调用如下所示:</p><pre class="mx my mz na gt ne mh nf ng aw nh bi"><span id="c991" class="ni lc iq mh b gy nj nk l nl nm">const url = queryBuilder("https://data.tomorrow.io/v4/timelines", {<br/> location: '41.3851%2C2.1734',<br/> apikey: API_KEY,<br/> fields:['temperature','humidity','precipitationProbability']<br/> timesteps:'1m',<br/>});</span></pre><p id="cba9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们所要做的就是创建一个通用方法，通过提供<code class="fe me mf mg mh b">fields</code>数组和<code class="fe me mf mg mh b">timesteps</code>作为参数来获取我们想要的数据。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/2e8e8156890a4d8e7b883a5daf819af4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Gi9XUbp_74i0KWHM.png"/></div></div></figure><p id="93cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个函数的目的是计算正确的URL，将请求发送到Tomorrow.io，并返回没有任何改动的响应。</p><h1 id="ded8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">第五步:如何使用它</h1><p id="3adb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要使用这个简单的包装器，我们需要使用我们刚刚创建的类实例化一个新对象，并调用<code class="fe me mf mg mh b">getWeatherData()</code>:</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/0af6bf3939d1f23a56aefe03a4ee5a13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PTemk5bFt7BLkz0k.png"/></div></div></figure><p id="6977" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以包括来自其他数据层的字段。例如，如果我们希望了解温度、湿度以及空气质量，我们可以使用空气质量数据图层中的值更新字段数组:</p><p id="c024" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">["temperature", "humidity", "particulateMatter25","particulateMatter10"]</code></p><p id="18bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！基于这个API，你可以进一步扩展这个简单的包装器。</p><p id="8a46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在当前状态下，因为纬度和经度是作为构造函数中的参数发送的，所以您需要为每个想要监视的位置创建一个新的实例。如果您想监视多个位置，并且不想为每个位置创建一个新的对象，那么您可以创建一个<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static" rel="noopener ugc nofollow" target="_blank">静态</a>方法，它将以相同的方式接收<code class="fe me mf mg mh b">fields</code>和<code class="fe me mf mg mh b">timesteps</code>，而且还接收<code class="fe me mf mg mh b">latitude</code>、<code class="fe me mf mg mh b">longitude</code>和<code class="fe me mf mg mh b">apikey</code>。</p></div></div>    
</body>
</html>