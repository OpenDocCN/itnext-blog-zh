# 如何(以及为什么)在 Java 中编写 equals()和 hashCode()

> 原文：<https://itnext.io/how-and-why-to-cook-equals-and-hashcode-in-java-c108fd5b17dd?source=collection_archive---------0----------------------->

![](img/93d650d5606755adf38917637fc5a820.png)

拉奎尔·马丁内斯在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

你好。

今天我要讲的是我最喜欢的一个面试问题:`equals()`和`hashCode()`Java 中的方法。

我为什么喜欢这个问题？嗯，我发现这两种方法在开发过程中非常重要，所以如果这个人对它们一无所知，就会在应用程序中引起很多问题，比如散列数据结构中的数据丢失、错误的等式处理结果等。

那么，让我们继续探索这两种方法。

您可能知道，Java 中有一个类`Object`，它是其他类的父类。这意味着，如果我们以这样的方式创建一个新的类`Person`:

它将隐式扩展`Object`类。这就是为什么，即使我们的`Person`类看起来是空的，它也有几个继承自`Object`类的可用方法:

*   `equals()`
*   `hashCode()`
*   `toString()`
*   `getClass()`
*   `notify()`
*   `notifyAll()`
*   `wait()`

由于其余的方法已经超出了本文的范围，让我们把重点放在`equals()`和`hashCode()`上。

# `equals()`

`equals(Object o)`方法用于指示某个其他对象`o`是否等于当前对象(该方法已在该对象上被调用)。

解释看起来非常清楚，但是可能会出现一个问题:“等等，如果我们有`==`操作符，为什么我们需要这个方法？”。
嗯，这是个好问题！正如我的朋友所说:“如果一些看似简单的东西没有复杂性，那就不是 Java 了”。

对于像`int`、`long`、`boolean`等原始数据类型，操作符可以很好地工作(在这种情况下应该使用)。但是对于非原始(或引用)数据类型`==`操作符显示的不是对象的相等性，而是它们是否引用内存中的同一个对象。由于 Java 内存模型(JMM)，它以这样的方式工作:原语和引用对象保存在不同的内存部分(在这篇文章中，我们不打算深入 JMM，所以现在让我们认为这是理所当然的，但是如果您希望我写一篇关于 JMM 的文章，请给我留下评论)。

让我用代码演示一下。让我们稍微扩展一下 Person 类，使它不为空。

如果我们运行这段代码，我们将得到以下输出:

```
false
```

但是，如果用`equals()`方法来比较这两个`Person`实例而不是`==`运算符，会是什么情况呢？

它会返回`true`吗？不，输出又是`false`。怎么会呢？！答案很简单:现在我们正在使用`equals()`方法的`Object`类实现，所以让我们看看它看起来像什么:

正如我们看到的，它调用了幕后的==操作符，所以错误的输出现在看起来更清楚了。

当然，这个实现不能满足我们的需求，所以我们可以覆盖它。

但是首先让我们稍微推迟一下重写过程，来学习几个 equals()方法规则，它们将在我们的实现中帮助我们:

1.  **反身** : `a.equals(a)`必须始终返回`true`(当然如果`a != null`，否则`NullPointerException`会被抛出)；
2.  **对称**:如果`a.equals(b)`返回`true`，那么`b.equals(a)`也必须总是返回`true`(反之亦然)；
3.  **传递**:如果`a.equals(b)`返回`true`，`a.equals(c)`返回`true`，则意味着`b.equals(c)`也必须是`true`；
4.  **一致**:如果`a.equals(b)`返回`true`(或`false`)，并且`a`和`b`都没有改变，`a.equals(b)`应该总是返回相同的结果。

这些规则简单而直观，但无论如何，遵循它们以忽略应用程序中可能出现的问题是极其重要的。

回到我们的`Person`对比问题:
我提议先不要急，先看一下方法签名来思考，如何正确的重写。您可能已经注意到，`equals()`方法接受`Object o`作为参数，所以不可能编写这样的代码:

由于`Object`类对 name 属性一无所知—编译错误。此外，如果`name == null`或`o == null`，该代码可能会抛出`NullPointerException`。是的，我们可以这样写:

但这不是超越，而是超载。
有很多库和 API 在幕后使用`equals()`方法，所以，正如你可能已经理解的，它们对我们的`equals()`方法的重载版本一无所知，但是会从`Object`类调用那个方法，我们的比较问题又会出现。这意味着重载对于我们的情况来说不是一个合适的解决方案。

让我们通过一步一步来关注重写过程:
正如我们之前看到的，`Object`类`equals()`实现使用`==`操作符来比较对象。听起来合乎逻辑:如果两个对象在内存中指向同一个对象，那么它们肯定是相等的。这是一个很好的切入点:

## 1.使用`==`运算符比较对象。

很好。让我们继续:我们上面提到过，如果`Object o`等于`null`，我们可以面对`NullPointerException`。此外，我们确实知道，我们当前的对象(`Person`实例，我们将在其上调用`equals()`方法)肯定不是`null`，否则`NullPoinerException`将在`null` `Person`实例的方法调用中抛出，但这不是我们现在要做的事情。它伴随着另一个步骤:

## 2.检查对象 o 参数是否不为空。如果是，则返回 false。

看起来更好，但还不够。我们之前提到过，还剩下一个难点:`o`是`Object`类型，所以无法从中得出`Person`数据。当然，我们可以把它投射到`Person`上，看起来我们已经准备好了。但是，不幸的是，它并不安全。看一下代码:

*   想象一下，我们已经将 cast 语句添加到我们的`equals()`实现中:

*   我来介绍一下新的班级`Dog`:

*   并向您展示，如何破解我们的`equals()`实现:

没有编译错误，因为 even is `dog`是`Dog`类型，但它也是`Object`类型(记住，我已经告诉过你，`Object`是每个类的父类)，所以它被允许在我们的方法中传递`dog`。但是如果我们运行这段代码，我们会有一个异常:

```
Exception in thread "main" java.lang.ClassCastException: Dog cannot be cast to Person
```

是的，听起来很有逻辑:我们怎么能把一只狗丢给一个人(或者把史酷比丢给荷马·辛普森)？是的，我知道，在[文学](https://en.wikipedia.org/wiki/Heart_of_a_Dog)中是这样的故事，但是我们是工程师，我们遵循逻辑。这个异常给了我们一个很好的提示，我们可以用它来进行下一步:

## 3.检查对象 o 参数是否和我们的实例有相同的类型。如果没有，返回 false。

这里我们使用了来自`Object`类的`getClass()`方法。这个方法只返回调用它的对象的`Class`。因此，对于`dog.getClass();`，它返回`Dog`，对于`person.getClass();` — `Person`，以此类推。

现在，我们可以继续下一步生产:

## 4.将对象 o 强制转换为当前的类类型。

## 5.比较所选字段的值。

我们在这里使用了`Objects.equals()`方法来简化逻辑并省略 this.name 空检查，因为它已经在`Objects`类的 used 方法中实现:

***Offtop*** :我确实推荐你去了解这个 util 类，因为它包含了几个有用的方法。

让我们试着检查一下，它是否工作正常:

输出最终是可预测的:

```
person1.equals(person2) is true
person1.equals(dog) is false
```

我们甚至可以检查我们实现的所有 4 个`equals()`方法规则:

输出:

```
1\. Reflexive: a.equals(a) must always return true:
person1.equals(person1) is true2\. Symmetric: if a.equals(b) returns true, then b.equals(a) must always return true:
person1.equals(person2) is true
person2.equals(person1) is true3\. Transitive: if a.equals(b) returns true and a.equals(c) returns true, it means, that b.equals(c) must be true:
person1.equals(person2) is true
person1.equals(person3) is true
person2.equals(person3) is true4\. Consistent: if a.equals(b) returns true (or false) and neither a nor b has been changed, a.equals(b) should always return the same result:
person1.equals(person2) is true
person1.equals(person2) is true
person1.equals(person2) is true
person1.equals(person2) is true
```

看起来棒极了！

我们的`equals()`实现完成了吗？是的。但是还有一件事让我不太满意:现在我们用名字来比较两个人。但是让我们想象一下，我们正在构建一个应用程序，它将被大量的人使用。例如，让它成为一家银行。我很确定，当几个不同的人有相同的名字时，会有成百上千种情况。例如，可能是来自斯普林菲尔德的荷马·辛普森一家和来自南方公园城的另一个荷马·辛普森一家。如果第一个人使用我们的应用程序，我们的银行会认为这两个家伙是同一个人，所以会引起一些问题:只有其中一个人能够在我们的应用程序中注册，或者他们中的任何一个人都可以访问彼此的数据，等等。这样不好！

我想说的是，我们的`Person`类需要更新以包含一些数据，这对于具体的 person 实例来说是唯一的。我建议不要重新发明自行车，而使用通常的做法——身份证号码。现在我们的`Person`类是这样的:

现在，如果我们知道`idNumber`对每个人来说总是唯一的，我们可以改变我们的`equals()`实现，使其使用`idNumber`而不是`name`。是的，它可以使用这两个字段，但是由于`idNumber`的独特保证，它是多余的:

现在，如果我们测试这个:

输出如下所示:

```
person1.equals(person2) is true
person1.equals(person3) is false
person1.equals(dog) is false
```

完美！教训是:我们，工程师，应该以这样一种方式设计我们的数据类，它们包含唯一的字段或字段序列，以使比较尽可能严格。

最后但同样重要的是，equals 方法的重要之处在于，如果我们的类包含一些复杂类型的字段(例如，`Person`类中的字段`private Address address;`),并且我们决定将其值包含到`equals()`方法中:

我们应该检查`equals()`是否已经为`Address`类正确实现，因为它将在幕后被调用，并可能导致意想不到的结果。这就是为什么好的实践是为每个数据对象覆盖`equals()`和`hashCode()`(我们很快会谈到这一点)方法。

是的，我知道，实现过程看起来有点庞大，但现在，当我们成功地手动完成并完全理解流程后，让我与您分享这个秘密:我非常确定，您将在一些 IDE (IntelliJ IDEA (my #1)、Eclipse、NetBeans、VSCode 等)中编写代码，而不是在记事本文本编辑器中。).所有的 ide 都可以让你通过几次点击(或者快捷方式)来生成 equals 方法。查看您最喜欢的 IDE 的文档，找到合适的方法(IntelliJ 思想的例子)。

现在，这是针对`equals()`方法的，但是我们稍后会回到它。接下来说`hashCode()`。

# 哈希码()

`hashCode()`方法返回对象的哈希码值。目前，哈希代码是一些 int 值。仅此而已。

让我们试着看看它是如何工作的，让它更清晰。为此，我建议使用我们著名的`Person`类:

我的电脑上的输出是`250421012`。如果你跟着我自己输入代码，我很确定，你的输出和我的不同。怎么可能呢？

要回答这个问题，我们需要记住，我们还没有覆盖`hashCode()`方法，所以我们现在使用的是`Object`实现。如果我们转到`Object`类，我们将看到以下内容:

Java 中的关键字`native`与方法一起使用，表示该方法是在其他语言中实现的(例如，C 或 C++)。使用 [JNI](https://en.wikipedia.org/wiki/Java_Native_Interface) 可以调用这样的方法。这种方法用于性能原因或访问系统或硬件资源，使用 Java 是不可能的。
在该方法的 Javadocs 中，提到了`Object` `hashCode()`是通过将对象的内部地址转换成整数来实现的。这就是为什么我们在不同的虚拟机上有不同的结果。

让我们通过重写该方法来使其行为可预测:

如你所料，输出是`42`。完事了吗？不，这只是我们 hashCode 故事的开始。

顺便说一句，也许你们中的一些人有一个问题:“为什么我们在一篇文章的范围内谈论`equals()`和`hashCode()`？这些方法看起来不相关！”。几年前，我面临同样的问题。让我向你展示几个`hashCode()`方法规则，我希望你能自己找到答案:

1.  对没有改变的同一个对象每次调用`hashCode()`方法都必须产生相同的结果。
2.  如果两个对象通过`equals()`方法相等，那么在这两个对象上调用`hashCode()`方法必须产生相同的结果:

```
// if:
a.equals(b) is true
// then:
a.hashCode() == b.hashCode()
```

3.但是如果在 2 个对象上调用`hashCode()`方法产生相同的结果，并不意味着它们相等(通过`equals()`方法)。

怎么可能呢？简单！正如我们所知，`int`类型具有有限的值范围:从-2 147 483 648 到+2 147 483 647 —因此，大约有 40 亿个唯一值。让我们想象一下，我们正在构建一个应用程序，它保存着世界上每个人的数据。维基百科称，截至 2018 年 5 月，世界人口为 76 亿。如果我们开始为世界上的每个人逐个调用`hashCode()`方法，有可能，前 40 亿个将产生一个唯一的结果，但每个下一个调用将产生一个整数值，这是以前产生的，因为每个 int 现在都被使用。因此，这可能是一种情况，例如，当来自美国的某个男孩和来自澳大利亚的女孩有相同的 hashCode 值，但是我们知道，他们不是同一个人。

所以，正如你已经注意到的，第二条和第三条规则表明`equals()`和`hashCode()`是相连的。如果在面试中你会被问到`equals()` 和`hashCode()`之间的合同，你需要这两条规则。

如果现在一切都清楚了，我建议回到我们的`Person`类，并尝试以正确的方式实现`hashCode()`方法。但是，打住，我们为什么需要这个？看起来，我们当前的方法实现符合这 3 条规则。是的，它是。
这些规则是清楚的，但是它们没有解释，为什么我们需要这个`hashCode()`方法。对于`equals()`方法，这个问题没有出现，因为它是直接的，该方法应该用于比较目的。

你听说过散列集合吗？这样的集合散列它们的每个元素以提供对它们的快速访问(大多数情况下是 [O(1)](https://en.wikipedia.org/wiki/Big_O_notation) )。最流行的 Java 散列集合是`HashMap`。它用于保存“键-值”对。例如，如果你必须收集关于公寓住户的数据，你可以这样做:

现在如果你需要得到 3 号公寓的住户，你需要做:

输出为`Rick Sanchez`。

为什么我在当前文章的范围内谈论`HashMap`？该集合使用`hashCode()`和`equals()`方法进行`put()`和`get()`操作。

**`HashMap`包含几个桶(达到大小时，数量会改变)，可以用来存储键值元素(这样的一对称为`Entry`)。该桶可以包含零个、一个或几个元素。如果有几个元素，这被称为碰撞，元素被存储在桶内的一个`LinkedList`(这只是部分正确，但是，我们现在关注的是这个概念)。**

**因此，当调用`put(Key key, Value value)`方法时，会执行以下步骤:**

1.  **如果`key`为`null`，则将键值对(`Entry`)放入第一个桶；**
2.  **如果不是`null`，则在键上调用`hashCode()`方法；**
3.  **`HashMap`获取密钥哈希值，通过内部计算对其进行处理，以获得要使用的存储桶的编号；**
4.  **如果选择的桶是空的，就把`Entry`放在那里，就这样；**
5.  **如果桶不为空，它遍历桶中所有现有的条目，并使用`equals()`将它们的键与来自`put()`方法的键进行比较；**
6.  **如果`equals()`每次迭代返回`false`，则`Entry`将被存储在当前桶中；**
7.  **如果`equals()`在某些情况下返回`true`，那么`Entry`具有与来自`put()`方法相同的键，这个`Entry`值将被新值替换(来自`put()`方法的参数)。游戏结束。**

**现在我们可以解决硬编码的`hashCode()`实现的第一个可能的问题:在第二步中，`Person`类的每个非空实例将返回`42`，因此所有这些实例都被放入同一个桶中，因为第三步计算对相同的输入产生相同的输出。我们将面对碰撞。**

**碰撞出了什么问题？在解释`get(Key key)`方法步骤的机制时，让我向您展示:**

1.  **如果`key`是`null`，我们到第一个桶，寻找带有`key == null`的`Entry`，如果存在，返回其`value`；**
2.  **如果`key`不是`null`，则在`key`上调用`hashCode()`方法；**
3.  **`HashMap`获取`key`散列值，通过内部计算对其进行处理，以获得要使用的桶的编号；**
4.  **我们使用第 3 步中提供的数字进入存储桶；**
5.  **如果桶是空的—返回`null`；**
6.  **如果那个桶只包含一个`Entry`，我们比较(`equals()`)那个`Entry`键和我们的`key`:如果`true` —返回`Entry` `value`，如果`false` —返回`null`；**
7.  **如果 bucket 包含几个元素，我们遍历每个元素，并将每个`Entry`的键与我们的`key`进行比较(`equals()`):if`true` —返回匹配的`Entry` `value`，if `false` for each —返回`null`。**

**在我们的硬编码`hashCode()`案例中，我们将经历第 7 步场景。
您可能已经注意到，第 5/6 步和第 7 步的场景之间有一个重要的区别:第 5 步和第 6 步不包含冲突，因此只需要一次操作(`key.equals(entry.getKey()`)就可以找到`value`，但是在第 7 步，由于冲突，我们必须多次执行这些操作(`key.equals(entry.getKey()`)(在最坏的情况下是`n`次，其中`n`是桶内条目的数量)。
因此，碰撞破坏了`HashMap`的主要特征——极快的获取操作(一次操作`O(1)`对`n`操作`O(n)`)。**

**如果`hashCode()`每次调用都返回新的哈希值(或者与`equals()`方法不一致)，那么`HashMap`中的另一个可能的问题就会发生。在这种情况下，第二步每次都将返回新的 int 数据，因此第三步将我们引向错误的桶，我们将永远找不到所需的`Entry` —数据将会丢失，这在当今是一个极其糟糕的问题(想象一下，您的工资支付丢失了，因为银行开发人员忘记为`Payment`类正确实现`hashCode()` 方法)。**

**所以，你刚才已经看到了，`equals()`和`hashCode()`方法在`HashMap`中协同工作来获取和放置数据:`hashCode()`用于计算桶号，`equals()`用于查找具有相同键的`Entry`。**

**现在我们已经知道了足够多的信息来最终实现 hashCode()方法。**

*****提示*** :为了符合`hashCode()`和`equals()`方法之间的约定，在这两个方法中使用相同的字段被认为是一个好的做法。**

**因此，当我们决定使用`idNumber`进行比较时，我们也可以在`hashCode()`方法中使用它。但是，正如你所记得的，`idNumber`是`long`类型，但是`hashCode()`返回`int`。小菜一碟:我们将为此使用`Objects.hash()`;**

**即使`idNumber`是`int`(或任何其他数据类型)，使用上述方法对其进行哈希处理也是一个很好的实践，因为哈希算法将负责提供这样的数据，这将更适合于省略冲突。**

**现在，我们的`Person`类最终版本看起来是这样的:**

**干得好，伙计们！**

**让我总结一下这篇文章的所有内容:**

## **equals()方法:**

1.  **用于比较两个非原始对象；**
2.  **方法规则:
    - **自反** : `a.equals(a)`必须始终返回`true`；
    - **对称**:如果`a.equals(b)`返回`true`，那么`b.equals(a)`必定总是返回`true`；
    - **传递**:如果`a.equals(b)`返回`true`，`a.equals(c)`返回`true`，则意味着`b.equals(c)`一定是`true`；
    - **一致**:如果`a.equals(b)`返回`true`(或`false`)，并且`a`和`b`都没有改变，`a.equals(b)`应该总是返回相同的结果。**
3.  **实现步骤:
    1)使用`==`运算符比较对象；
    2)检查`Object o`参数是否不是`null`。如果是，返回`false`；
    3)检查`Object o`参数是否与我们的实例具有相同的类型。如果否，返回`false`；
    4)将`Object o`转换为当前的类类型；
    5)比较所选字段的值。**

## **hashCode()方法:**

1.  **用于哈希目的—为对象提供 int 值；**
2.  **方法的规则:
    ——对同一个没有改变的对象每次调用`hashCode()`方法，每次都必须产生相同的结果；
    -如果两个对象通过`equals()`方法相等，那么在这两个对象上调用`hashCode()`方法必须产生相同的结果；
    -但是如果在 2 个对象上调用`hashCode()`方法产生相同的结果，并不意味着它们相等(通过`equals()`方法)。**
3.  **最后两个规则也被称为`equals()`和`hashCode()`方法之间的契约。**

## **HashMap 和 equals()/hashCode()方法用法:**

1.  **`HashMap`是用于存储键-值对元素的集合，它使用散列来提供极快的 get 操作；**
2.  **`HashMap`的元素存储在桶中；**
3.  **`hashCode()`结果用于计算存储桶的数量，元素将存储在那里；**
4.  **`equals()`用于比较元素键找到需要的元素；**
5.  **如果`hashCode()`是以硬编码的方式实现的，那么同一个类的所有实例都将被存储在一个桶中，这将会导致性能问题(get 进程的`n`操作而不是`1`)；**
6.  **此外，如果`hashCode()`每次都返回新值或者不符合`equals()`和`hashCode()`之间的约定，那么元素可能会丢失。**

**这是一段漫长的旅程，但我们一起走过了。我希望你学到了新的东西，并且在阅读过程中没有睡着。无论如何，谢谢，在评论区和以后的帖子里再见！**

**玩得开心！**