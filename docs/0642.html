<html>
<head>
<title>Leveraging Vue events to reduce prop declarations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Vue事件减少属性声明</h1>
<blockquote>原文：<a href="https://itnext.io/leveraging-vue-events-to-reduce-prop-declarations-e38f5dce2aaf?source=collection_archive---------3-----------------------#2018-04-25">https://itnext.io/leveraging-vue-events-to-reduce-prop-declarations-e38f5dce2aaf?source=collection_archive---------3-----------------------#2018-04-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/4102ebea6c828473d7c306a50c062c73.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*zyNSb0UXhP8TfxYbj-GNWg.png"/></div></figure><blockquote class="ju jv jw"><p id="ba65" class="jx jy jz ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fleveraging-vue-events-to-reduce-prop-declarations-e38f5dce2aaf%3Futm_source%3Dmedium_sharelink%26utm_medium%3Dsocial%26utm_campaign%3Dbuffer" rel="noopener ugc nofollow" target="_blank">点击这里在LinkedIn上分享这篇文章</a></p></blockquote><p id="7146" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">虽然Javascript中的事件是许多模式和框架的“面包和黄油”,但Vue的抽象简单而优雅。对我来说是一个启示。我经常利用它的一个地方是我的容器和表示组件之间的通信。</p><p id="0a48" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">让我们看看典型的todo示例。这个应用程序有一个项目列表，一个标题将有列表的名称和一个按钮来添加一个新项目。这些信息保存在一个<a class="ae kw" href="https://vuex.vuejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Vuex </a>商店中。您可以将这个应用程序的容器想象成这样:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="701f" class="lm ln iq ld b gy lo lp l lq lr">&lt;template&gt;<br/>  &lt;section&gt;<br/>    &lt;todo-header<br/>      :title="title"<br/>      :add-item="handleAddItem"<br/>    /&gt;<br/>    &lt;todo-list<br/>      :items="items"<br/>      :mark-item-complete="handleItemComplete"<br/>    /&gt;<br/>  &lt;/section&gt;<br/>&lt;/template&gt;</span><span id="887f" class="lm ln iq ld b gy ls lp l lq lr">&lt;script&gt;<br/>import { mapState } from 'vuex';</span><span id="c5c9" class="lm ln iq ld b gy ls lp l lq lr">import TodoHeader from './TodoHeader';<br/>import TodoList from './TodoList';<br/>import {<br/>  UPDATE_TITLE,<br/>  ADD_ITEM,<br/>  MARK_ITEM_COMPLETE,<br/>} from './mutation-types';</span><span id="ea63" class="lm ln iq ld b gy ls lp l lq lr">export default {<br/>  name: 'TodoWrapper',<br/>  computed: {<br/>    ...mapState([<br/>      'title',<br/>      'items',<br/>    ]),<br/>  },<br/>  methods: {<br/>    handleUpdateTitle(title) {<br/>      this.$store.commit(UPDATE_TITLE, title);<br/>    },<br/>    handleAddItem(item) {<br/>      this.$store.commit(ADD_ITEM, item);<br/>    },<br/>    handleItemComplete(item) {<br/>      this.$store.commit(MARK_ITEM_COMPLETE, item);<br/>    },<br/>  },<br/>};<br/>&lt;/script&gt;</span></pre><p id="eef0" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">我们来看看<code class="fe la lb lc ld b">TodoHeader</code>:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="bf75" class="lm ln iq ld b gy lo lp l lq lr">&lt;template&gt;<br/>  &lt;h1&gt;{{ title }}&lt;/h1&gt;<br/>  &lt;input type="text" :v-model="newItem" /&gt;<br/>  &lt;button @click="handleAddItem"&gt;Add item&lt;/button&gt;<br/>&lt;/template&gt;</span><span id="65c1" class="lm ln iq ld b gy ls lp l lq lr">&lt;script&gt;<br/>  export default {<br/>    name: 'TodoHeader',<br/>    data() {<br/>      return {<br/>        input: '',<br/>      };<br/>    },<br/>    props: {<br/>      title: {<br/>        type: String,<br/>        required: true,<br/>      },<br/>      addItem: {<br/>        type: Function,<br/>        required: true,<br/>      },<br/>    },<br/>    methods: {<br/>      handleAddItem() {<br/>        this.$props.addItem(this.$data.input);<br/>      },<br/>    },<br/>  };<br/>&lt;/script&gt;</span></pre><p id="7a01" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">随着更多的功能被添加到<code class="fe la lb lc ld b">TodoHeader</code>(或者上面提到的<code class="fe la lb lc ld b">TodoList</code>)中，将会有更多类似于<code class="fe la lb lc ld b">addItem</code>的回调道具被定义。这不仅会增加代码量，还会在单元测试中需要额外的存根。事件将有助于减少这一点！</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="606c" class="lm ln iq ld b gy lo lp l lq lr">// ...</span><span id="9114" class="lm ln iq ld b gy ls lp l lq lr">    props: {<br/>      title: {<br/>        type: String,<br/>        required: true,<br/>      },<br/>    },<br/>    methods: {<br/>      handleAddItem() {<br/>        this.$emit('add-item', this.$data.input);<br/>      },<br/>    },<br/>  };</span><span id="b799" class="lm ln iq ld b gy ls lp l lq lr">// ...</span></pre><p id="89a3" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">现在，<code class="fe la lb lc ld b">add-item</code>不再作为道具传递下去，<code class="fe la lb lc ld b">TodoWrapper</code>将只是监听事件。我们也可以用<code class="fe la lb lc ld b">TodoList</code>做到这一点。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="b701" class="lm ln iq ld b gy lo lp l lq lr">// ...</span><span id="2d37" class="lm ln iq ld b gy ls lp l lq lr">&lt;todo-header<br/>  :title="title"<br/>  @add-item="handleAddItem"<br/>/&gt;<br/>&lt;todo-list<br/>  :items="items"<br/>  @mark-item-complete="handleItemComplete"<br/>/&gt;</span><span id="4f3a" class="lm ln iq ld b gy ls lp l lq lr">// ...</span></pre><p id="c2be" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">这种模式将进一步把你的表示组件从你的容器中分离出来，这将使你的组件更加可重用，并减少你的单元测试中需要的存根数量。</p></div></div>    
</body>
</html>