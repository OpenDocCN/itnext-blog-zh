<html>
<head>
<title>.NET 5: How to authenticate &amp; authorise API’s correctly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">。NET 5:如何正确认证和授权API</h1>
<blockquote>原文：<a href="https://itnext.io/net-5-how-to-authenticate-authorise-apis-correctly-34b09d132d84?source=collection_archive---------1-----------------------#2021-04-01">https://itnext.io/net-5-how-to-authenticate-authorise-apis-correctly-34b09d132d84?source=collection_archive---------1-----------------------#2021-04-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9a33fd15af5b8f9271ed7c65612bedb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kLOCd0wl9di45qGFr6AfmQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">当心安全漏洞！</figcaption></figure><p id="c949" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在我11年的经验中，我见过太多有重大安全缺陷的API。它们或者缺乏正确的认证或授权设置，或者两者都缺乏。开发人员可能觉得没问题，因为这些端点通常不是公共的。但这是一个巨大的安全漏洞，任何人都可以很容易地锁定它。</p><p id="449a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为了更好地理解API的安全性，让我们为FBI创建一个演示项目。将有一个管理员可以登记联邦调查局特工，并改变他们的许可级别。第二，拥有<em class="ld">许可等级1 </em>的联邦调查局特工将能够访问公共文件，拥有<em class="ld">许可等级2 </em>的特工将能够访问公共&amp;机密文件。</p><p id="1706" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">先是一些理论！</p><h1 id="251f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">证明</h1><p id="7bc6" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">我们的代理人成功地通过了他所有的考试；该给他报名了。为了做到这一点，他将提供他的文件，作为回报，将得到他的徽章。</p><p id="fbb6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在上面的场景中，<em class="ld">提供文档</em>就像登录一样，一旦通过验证，他将获得一个令牌(徽章)。这个过程叫做<em class="ld">认证</em>。它决定了代理是否是他们所声称的那个人。</p><p id="31c4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将使用Json Web令牌(JWT)不记名令牌进行身份验证。<em class="ld">承载令牌</em>是一种由服务器生成的令牌，包含试图登录的用户的声明/角色的详细信息。不记名令牌大多是结构化令牌，如<em class="ld"> JWT </em>。<a class="ae mh" href="https://jwt.io/introduction" rel="noopener ugc nofollow" target="_blank">阅读这里</a>了解更多关于JWT的信息。</p><h1 id="12d3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">授权</h1><p id="d0b5" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">现在，联邦调查局特工已经得到了他的徽章，他可以进入联邦调查局大楼。他也能够访问公共文件，但是当试图访问机密文件时，他得到<a class="ae mh" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401" rel="noopener ugc nofollow" target="_blank"> <em class="ld"> 401 </em> </a>错误。</p><p id="e977" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是因为联邦调查局特工没有被授权访问机密文件。授权决定代理可以和不可以访问的内容。</p><p id="253f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如上所述，JWT承载令牌包含声明/角色。基于此，我们的服务器决定是否允许访问私有资源。</p><h1 id="2bd1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">访问流程</h1><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/49cc6e7ec8dabe258982f08a53e48bfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EYHg97Kr9CzdW64f.jpg"/></div></div></figure><p id="2402" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如上图所示，成功登录后，服务器会返回一个不记名令牌。客户端在后续调用中使用承载令牌来访问私有资源。</p><p id="184d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是我们将在本文中实现的两个主要概念。</p><p id="39f3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">理论讲够了，给我看看代码！</p><h1 id="a55b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">项目设置</h1><p id="3ecb" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">通过从cli执行命令dot net new webapi-name FBI创建一个新项目。它将创建一个带有示例WeatherForecast api的项目。</p><p id="db9e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们可以在联邦调查局工作，为什么还要在天气预报上工作。继续删除<em class="ld"> WeatherForecast.cs </em>文件。</p><p id="4e55" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">通过执行命令添加依赖关系</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="4902" class="mr lf it mn b gy ms mt l mu mv">dotnet add package Microsoft.IdentityModel.Tokens --version 6.9.0<br/>dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer --version 5.0.4</span></pre><p id="9444" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在您的<em class="ld"> Startup.cs </em>文件的<em class="ld"> ConfigureServices </em>函数中添加以下代码。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="4c72" class="mr lf it mn b gy ms mt l mu mv">var TokenValidationParameters = new TokenValidationParameters<br/>{<br/>    ValidIssuer = "https://fbi-demo.com",<br/>    ValidAudience = "https://fbi-demo.com",<br/>    IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes("SXkSqsKyNUyvGbnHs7ke2NCq8zQzNLW7mPmHbnZZ")),<br/>    ClockSkew = TimeSpan.Zero // remove delay of token when expire<br/>};</span></pre><p id="cf0c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们正在定义验证令牌的参数。确保用于生成SymmetricSecurityKey的字符串的长度为32。</p><p id="e167" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">接下来，设置服务来为API添加身份验证。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="0de2" class="mr lf it mn b gy ms mt l mu mv">services<br/>    .AddAuthentication(options =&gt;<br/>    {<br/>        options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme;<br/>    })<br/>    .AddJwtBearer(cfg =&gt;<br/>    {<br/>        cfg.TokenValidationParameters = TokenValidationParameters;<br/>    });</span></pre><p id="333f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="ld"> AddAuthentication </em>方法注册认证服务所需的服务。它还将JWT承载认证配置为默认方案。</p><p id="fa53" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="ld"> AddJwtBearer </em>启用JWT承载认证并设置上面定义的TokenValidationParameters。</p><p id="91e0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在让我们为我们的<em class="ld">代理</em> &amp; <em class="ld">管理员</em>添加一些授权声明。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="c31d" class="mr lf it mn b gy ms mt l mu mv">services.AddAuthorization(cfg =&gt;<br/>    {<br/>        cfg.AddPolicy("Admin", policy =&gt; policy.RequireClaim("type", "Admin"));<br/>        cfg.AddPolicy("Agent", policy =&gt; policy.RequireClaim("type", "Agent"));<br/>        cfg.AddPolicy("ClearanceLevel1", policy =&gt; policy.RequireClaim("ClearanceLevel", "1", "2"));<br/>        cfg.AddPolicy("ClearanceLevel2", policy =&gt; policy.RequireClaim("ClearanceLevel", "2"));<br/>    });</span></pre><p id="3a0e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="ld"> AddAuthorization </em>方法注册授权所需的服务。我们还通过调用<em class="ld"> AddPolicy </em>为<em class="ld"> Admin </em>、<em class="ld"> Agent </em>、<em class="ld"> ClearanceLevel1 </em>和<em class="ld"> ClearanceLevel2 </em>添加声明。声明是一个名称值对，表示主题是什么。由于许可级别2也可以访问许可级别1，我们将<em class="ld">“1】、</em>放在许可级别1中。你可以在这里 阅读更多关于<a class="ae mh" href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/claims?view=aspnetcore-5.0" rel="noopener ugc nofollow" target="_blank"> <em class="ld">的主张。</em></a></p><p id="e3fa" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后，在<em class="ld">配置</em>方法中，在<em class="ld">应用程序的正上方添加下面一行。use authorization()；</em></p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="00c7" class="mr lf it mn b gy ms mt l mu mv">app.UseAuthentication();</span></pre><h1 id="dc9c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">管理控制器</h1><p id="e5c6" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">将您的文件<em class="ld">weatherforecastcontroller . cs</em>重命名为<em class="ld"> AdminController.cs </em>。也要更改类名和构造函数名。最后，移除除构造函数之外的所有内容。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="16e5" class="mr lf it mn b gy ms mt l mu mv">using Microsoft.AspNetCore.Mvc;</span><span id="4cf2" class="mr lf it mn b gy mw mt l mu mv">namespace FBI.Controllers<br/>{<br/>    [ApiController]<br/>    [Route("[controller]")]<br/>    public class AdminController : ControllerBase<br/>    {<br/>        public AdminController() { }<br/>    }<br/>}</span></pre><h1 id="a338" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">登录API</h1><p id="5e3a" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">让我们为Admin创建一个登录API，这样她就可以获得一个令牌来执行其他任务。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="e420" class="mr lf it mn b gy ms mt l mu mv">[HttpPost]<br/>[Route("[action]")]<br/>public IActionResult Login([FromBody] User User)<br/>{<br/>    // TODO: Authenticate Admin with Database<br/>    // If not authenticate return 401 Unauthorized<br/>    // Else continue with below flow</span><span id="391f" class="mr lf it mn b gy mw mt l mu mv">    var Claims = new List&lt;Claim&gt;<br/>            {<br/>                new Claim("type", "Admin"),<br/>            };</span><span id="d849" class="mr lf it mn b gy mw mt l mu mv">    var Key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes("SXkSqsKyNUyvGbnHs7ke2NCq8zQzNLW7mPmHbnZZ"));</span><span id="4bb8" class="mr lf it mn b gy mw mt l mu mv">    var Token = new JwtSecurityToken(<br/>        "https://fbi-demo.com",<br/>        "https://fbi-demo.com",<br/>        Claims,<br/>        expires: DateTime.Now.AddDays(30.0),<br/>        signingCredentials: new SigningCredentials(Key, SecurityAlgorithms.HmacSha256)<br/>    );</span><span id="2a55" class="mr lf it mn b gy mw mt l mu mv">    return new OkObjectResult(new JwtSecurityTokenHandler().WriteToken(Token));<br/>}</span></pre><p id="ddf1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在上面的代码<em class="ld">中，用户</em>是一个带有属性<em class="ld">用户名</em> &amp; <em class="ld">密码</em>的模型。我们还使用在<em class="ld"> Startup.cs </em>文件中使用的配置创建了一个<em class="ld"> JwtSecurityToken </em>的对象。然后，令牌被转换为字符串，并在OkObjectResult中返回。</p><p id="e070" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，您可以打开Swagger并执行API来查看不记名令牌。将返回一个不记名令牌，如下所示。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/efbf9e0aaf7161a7bad60e382f3aa11d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NHyVtSQX_uhYzcjF.png"/></div></div></figure><p id="9d03" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请将令牌放在手边，因为我们将在下一节中使用它。你也可以访问<a class="ae mh" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> jwt.io </a>来分析你的令牌。</p><h1 id="2c31" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">生成徽章API</h1><p id="d40c" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">为代理生成工卡是一项敏感任务，只能由<em class="ld">管理员</em>授权。我们将为<em class="ld"> GenerateBadge </em> api添加一个<em class="ld"> Authorize </em>属性。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="49b7" class="mr lf it mn b gy ms mt l mu mv">[HttpPost]<br/>[Route("[action]")]<br/>[Authorize(Policy = "Admin")]<br/>public IActionResult GenerateBadge([FromBody] Agent Agent)<br/>{<br/>    <!-- -->var Claims = new List&lt;Claim&gt;<br/>    {<br/>        new Claim("type", "Agent"),<br/>        new Claim("ClearanceLevel", Agent.ClearanceLevel.ToString()),<br/>    };</span><span id="8cdc" class="mr lf it mn b gy mw mt l mu mv">    var Key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes("SXkSqsKyNUyvGbnHs7ke2NCq8zQzNLW7mPmHbnZZ"));</span><span id="18df" class="mr lf it mn b gy mw mt l mu mv">    var Token = new JwtSecurityToken(<br/>        "<a class="ae mh" href="https://fbi-demo.com" rel="noopener ugc nofollow" target="_blank">https://fbi-demo.com</a>",<br/>        "<a class="ae mh" href="https://fbi-demo.com" rel="noopener ugc nofollow" target="_blank">https://fbi-demo.com</a>",<br/>        Claims,<br/>        expires: DateTime.Now.AddDays(30.0),<br/>        signingCredentials: new SigningCredentials(Key, SecurityAlgorithms.HmacSha256)<br/>    );</span><span id="f3c8" class="mr lf it mn b gy mw mt l mu mv">    return new OkObjectResult(new JwtSecurityTokenHandler().WriteToken(Token));<br/>}</span></pre><p id="b031" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里Agent是一个模型，其属性名称为字符串，ClearanceLevel为int。</p><p id="10f0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，当你回到swagger并试图执行<em class="ld"> GenerateBadge </em> api时，它会给出401未授权响应。由于我们没有传递不记名令牌，我们得到了这个错误。</p><p id="742b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为了能够在Swagger更改<em class="ld">服务中添加Authorize头。AddSwaggerGen </em>如下:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="1fed" class="mr lf it mn b gy ms mt l mu mv">services.AddSwaggerGen(c =&gt;<br/>{<br/>    c.SwaggerDoc("v1", new OpenApiInfo { Title = "FBI", Version = "v1" });<br/>    c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme<br/>    {<br/>        In = ParameterLocation.Header,<br/>        Description = "Please enter JWT with Bearer into field",<br/>        Name = "Authorization",<br/>        Type = SecuritySchemeType.ApiKey<br/>    });<br/>    c.AddSecurityRequirement(new OpenApiSecurityRequirement {<br/>    { new OpenApiSecurityScheme<br/>            {<br/>                Reference = new OpenApiReference { Type = ReferenceType.SecurityScheme, Id = "Bearer"}<br/>            },<br/>        new string[] {}<br/>    }<br/>    });<br/>});</span></pre><p id="9334" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当你在浏览器中刷新Swagger时，你会注意到在API列表上方的右侧有一个<em class="ld">授权</em>按钮。</p><p id="2dfb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">点击Swagger中新添加的<em class="ld">授权</em>按钮，将会打开一个对话框。我们需要提到它是什么类型的令牌。因此，首先在字段中输入<em class="ld"> Bearer </em>，然后输入一个空格，然后输入从前面部分的<em class="ld"> /Admin/Login </em> api生成的令牌。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/1686b47544640649ede0196ef4199610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iHgNeEfPFErnZlFp.png"/></div></div></figure><p id="f703" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">单击标题以锁定令牌。现在你都准备好了。当您再次执行<em class="ld"> GenerateBadge </em> api时，您将获得一个令牌(类似于徽章)。把这个令牌放在手边，因为我们在下一节中需要它。还要确保现在将ClearanceLevel作为1传递。</p><h1 id="262a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">代理控制器</h1><p id="ca05" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">用以下内容创建一个新文件<em class="ld"> AgentController.cs </em>。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="8994" class="mr lf it mn b gy ms mt l mu mv">using Microsoft.AspNetCore.Mvc;</span><span id="c368" class="mr lf it mn b gy mw mt l mu mv">namespace FBI.Controllers<br/>{<br/>    [ApiController]<br/>    [Route("[controller]")]<br/>    [Authorize(Policy = "Agent")]<br/>    public class AgentController : ControllerBase<br/>    {<br/>        public AgentController() { }<br/>    }<br/>}</span></pre><p id="4440" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">正如您在上面看到的，我们授权整个控制器仅供代理访问。因此，即使是管理员也无法访问我们将要创建的API。</p><h1 id="3d8c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">访问记录API</h1><p id="03fa" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">让我们添加api来访问公共和机密文件。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="6370" class="mr lf it mn b gy ms mt l mu mv">[HttpGet]<br/>[Route("[action]")]<br/>[Authorize(Policy = "ClearanceLevel1")]<br/>public ActionResult&lt;String&gt; AccessPublicFiles()<br/>{<br/>    return new OkObjectResult("Public Files Accessed");<br/>}</span><span id="5cdc" class="mr lf it mn b gy mw mt l mu mv">[HttpGet]<br/>[Route("[action]")]<br/>[Authorize(Policy = "ClearanceLevel2")]<br/>public ActionResult&lt;String&gt; AccessClassifiedFiles()<br/>{<br/>    return new OkObjectResult("Classified Files Accessed");<br/>}</span></pre><p id="4d7b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们为这两个API添加了<em class="ld">授权</em>属性，这样公共文件可以由<em class="ld"> ClearanceLevel1 </em>访问，机密文件可以由<em class="ld"> ClearanceLevel2 </em>访问。</p><p id="0481" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你试图用管理令牌访问这些API，你会得到403禁止错误。因此，继续操作，再次点击<em class="ld">授权</em>按钮，然后点击<em class="ld">注销</em>。然后，从上述步骤中获取令牌，并粘贴到以<em class="ld">载体</em>为前缀的字段中，即<em class="ld">载体</em>。</p><p id="06b2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，当您访问<em class="ld">/Agent/AccessPublicFiles</em>API时，您将看到响应200，其中包含消息<em class="ld"> Public Files Accessed </em>。但是当你尝试分类api时，你会得到403禁止错误。</p><h1 id="5f1f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">改变净空高度</h1><p id="1ead" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">一晃3年过去了，我们的<em class="ld">代理商的</em>业绩好得令人难以置信。管理层现在决定将他提升到二级通关。</p><p id="86d7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="ld">代理</em>找到<em class="ld">管理员</em>并要求她提供一个许可级别为2的令牌/徽章。</p><p id="2deb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="ld">管理员</em>首先调用<em class="ld">/管理员/登录</em> api来生成自己的令牌。然后她在<em class="ld">授权</em>对话框中输入它。</p><p id="7cad" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="ld">/Admin/generage badge</em>API随后被ClearanceLevel中值为2的Admin调用。这将生成一个新的令牌/徽章，然后她将它交给<em class="ld">代理</em>。</p><p id="8f74" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="ld">代理</em>在<em class="ld">授权</em>对话框中输入这个令牌/徽章，当他现在调用<em class="ld">/Agent/AccessClassifiedFiles</em>时，他很高兴看到结果<em class="ld">机密文件被访问</em>。</p><h1 id="e54e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="06c8" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">你可以在github上的这里找到整个项目<a class="ae mh" href="https://github.com/shenanigan/fbi-demo" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="1c2f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">API安全性极其重要，即使只供内部使用，也不能掉以轻心。设置认证和授权，你就成功了一半。</p><p id="1ad9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">还有其他一些安全措施可以抵御DDoS攻击，比如只接受来自特定IP或域的API等等。</p><p id="6024" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你觉得这篇文章怎么样？你通常采取的其他安全措施是什么？有任何反馈或意见吗？</p><p id="d2e2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你可以点击查看更多教程<a class="ae mh" href="https://arjavdave.com" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>