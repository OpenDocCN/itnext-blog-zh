<html>
<head>
<title>How to optimize Angular applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何优化角度应用</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-optimize-angular-applications-99bfab0f0b7c?source=collection_archive---------0-----------------------#2018-11-26">https://itnext.io/how-to-optimize-angular-applications-99bfab0f0b7c?source=collection_archive---------0-----------------------#2018-11-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/60394d2cb8b731e8869febfc7b7c8541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FfQRDrla3o-aoOW_atmOzA.jpeg"/></div></div></figure><p id="2ac9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Angular是构建单页面web应用程序最流行的框架。虽然我说的是单页面，但这并不意味着你的应用程序只能包含一个页面。你可以用Angular创建一个有几十个页面的网站。由于团队和社区的努力，框架本身(最新版本)得到了很好的优化，然而当谈到性能时，我们应该总是考虑一些可以使我们的应用程序快速流畅运行的事情。</p><h2 id="469a" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">#1通过延迟加载优化主包</h2><p id="3d9d" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">当我们在没有延迟加载的情况下在生产中构建我们的应用程序时，我们很可能会看到这些文件在<code class="fe lu lv lw lx b">dist</code>文件夹中生成</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="1843" class="kw kx iq lx b gy mg mh l mi mj">polyfills.js<br/>scripts.js<br/>runtime.js<br/>styles.css<br/>main.js</span></pre><p id="cfd4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mk"> polyfills.js </em>是为了让我们的应用程序兼容不同的浏览器。因为我们用最新的特性编写代码，而不是所有的浏览器都支持这些特性。</p><p id="e21f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mk"> scripts.js </em>包含我们在angular.json文件的脚本部分声明的脚本</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="e9f2" class="kw kx iq lx b gy mg mh l mi mj">"scripts": [<br/>   "myScript.js",<br/>]</span></pre><p id="400e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mk"> runtime.js </em>是webpack加载器。该文件包含加载其他文件所需的webpack实用程序</p><p id="00a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mk"> styles.css </em>包含我们在angular.json文件的styles部分声明的所有样式</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="d64f" class="kw kx iq lx b gy mg mh l mi mj">"styles": [<br/>  "src/styles.css",<br/>  "src/my-custom.css"<br/>],</span></pre><p id="701f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mk"> main.js </em>包含我们所有的代码，包括组件(ts、html和css代码)、管道、指令、服务和所有其他导入的模块(包括第三方)。</p><p id="464e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你所看到的，随着时间的推移，main.js文件会越来越大，这是一个问题，因为为了看到网站浏览器需要下载main.js文件，执行，并在页面上呈现，这不仅对互联网速度慢的移动用户来说是一个挑战，对桌面来说也是如此。</p><p id="a3e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解决这个问题最简单的方法是将您的应用程序分成几个惰性模块。当我们为每个模块使用惰性模块时，angular会生成自己的块，直到需要时才会加载(通常是通过激活路由)。</p><p id="6710" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了演示这一点，我创建了两个组件，<em class="mk"> app.component </em>和<em class="mk"> second.component. </em>都在<em class="mk"> app.module </em>中，所以这里没有偷懒。App.component非常简单，有两个按钮用于导航到Second.component和返回App.component。</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/513638c60546823a066731596c1ac6ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*yxeXCQXSN018Avxq55G_6g.png"/></div></figure><p id="d6f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，第二个组件在模板中包含非常大的文本(大约1 mb)。</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/7faa17dc578a042d9f4e1ee1c26eff17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vyaaFM3qT0--Pnj4QHP6lw.png"/></div></div></figure><p id="0056" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为没有懒惰，当我们构建我们的应用程序时，我们得到big main.js，它包含来自app.component和second.component的所有代码。</p><p id="0e1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在在chrome开发工具的网络标签中，我们可以看到main.js确实太大了(1.3 mb)</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/23d847fc31d098d778b52d74205c3b63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2DrkQjFubmM5G8Tj6k9VEw.png"/></div></div></figure><p id="bdc4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题是大部分时候用户访问的是主页面，而不是某个特定的页面，所以加载其他页面的所有代码并不是最好的解决方案。我们可以为第二个组件创建懒惰模块，该模块将只在需要时被激活(即，只有当用户导航到该页面)。这给了我们非常小的main.js，所以主页的第一次加载非常快。</p><p id="655d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们使用延迟加载时，在构建过程之后，新的文件将被创建，比如4.386205799sfghe4.js。这是那个延迟模块的块，它不会在启动时被加载。现在，当我们打开应用程序时，我们看到main.js非常小(266 kb)</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/5d905f88fe250c53753e422eb6f10cf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pDXybFxxrPGSLnPv3UN1xw.png"/></div></div></figure><p id="64c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只有当我们导航到第二页时，我们才看到加载了新文件(1 mb)</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/969e7db8fa000c5f8845cb7998e0da2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NWlazY2bfoLSfVotol92ZQ.png"/></div></div></figure><p id="cff3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，以这种方式加载每个片段也会影响性能，因为初始导航会更慢。幸运的是，Agular通过<a class="ae mq" href="https://angular.io/api/router/PreloadingStrategy" rel="noopener ugc nofollow" target="_blank">预加载策略</a>也提供了解决这个问题的方法。我们可以说Angular加载我们的主模块(main.js ),当它完全加载并执行后，才在后台加载其他惰性模块，所以当用户导航到惰性页面时，所有内容都已经下载了。预加载所有模块的示例代码</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="ccc3" class="kw kx iq lx b gy mg mh l mi mj"><em class="mk">import </em>{ PreloadAllModules, RouterModule } <em class="mk">from </em>'@angular/router';</span><span id="a538" class="kw kx iq lx b gy mr mh l mi mj">RouterModule.forRoot(<br/>[<br/> {<br/>    path: 'second',<br/>    loadChildren: './second/second.module#SecondModule'</span><span id="7c38" class="kw kx iq lx b gy mr mh l mi mj"> } <br/>], {preloadingStrategy: PreloadAllModules})</span></pre><blockquote class="ms mt mu"><p id="11fe" class="jy jz mk ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated">所以总是考虑使用尽可能多的懒惰模块，并采用一些预加载策略。这将保持你的main.js较小，这意味着更快的下载和渲染主页。</p></blockquote><h2 id="d6a9" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">#2使用Webpack Bundle Analyzer调试捆绑包</h2><p id="52be" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">即使在将应用程序的逻辑分割成许多惰性模块后，您得到了大型主包(我个人认为中小型应用程序的“大型”超过1 mb)，您也可以使用Webpack Bundle Analyzer进一步优化。这个npm包允许用一个交互式的可缩放树状图来可视化webpack输出文件的大小。首先在你的angular项目中安装插件作为开发依赖</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="dcdd" class="kw kx iq lx b gy mg mh l mi mj">npm install --save-dev webpack-bundle-analyzer</span></pre><p id="f9d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后修改您的<em class="mk"> package.json </em>文件，在<code class="fe lu lv lw lx b">scripts</code>部分添加这一行</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="6f1c" class="kw kx iq lx b gy mg mh l mi mj">"bundle-report": "ng build --prod --stats-json &amp;&amp; webpack-bundle-analyzer dist/stats.json"</span></pre><p id="b8cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意<code class="fe lu lv lw lx b">dist/stats.json</code>在你的项目中可能是不同的。例如，如果您的包文件是在<code class="fe lu lv lw lx b">dist/browser</code>中生成的，您需要将命令修改为<code class="fe lu lv lw lx b">dist/browser/stats.json</code></p><p id="d47e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">终于跑了</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="a53f" class="kw kx iq lx b gy mg mh l mi mj">npm run bundle-report</span></pre><p id="ad0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将创建包含每个包的统计信息的生产构建，在webpack bundle analyzer的帮助下，我们可以使用zoomable treemap来可视化。</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/9deb1b6e7cfce6f533bc335defc86322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q0l-ZgkWX-YzM_j8ViFXeg.png"/></div></div></figure><p id="f20e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从这里我们可以看到每个包中使用了哪些模块/文件。这非常有帮助，因为我们可以直观地看到不应该出现的内容。</p><h2 id="a8a3" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">#3创建几个小的共享模块</h2><p id="daa6" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">让<a class="ae mq" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">和</a>共享模块被认为是最好的做法，但是有时候共享模块也会变得越来越大。例如，如果我们有包含许多其他模块/组件/管道的<em class="mk"> SharedModule </em>，在app.module中导入这样的模块会增加main.js的包大小，因为我们不仅会导入主模块需要的东西，还会导入<em class="mk"> SharedModule </em>附带的所有其他不必要的东西。为了避免这种情况，我们可以创建另一个共享模块，<em class="mk"> HomeSharedModule </em>，它将只包含主模块及其组件需要的组件。</p><blockquote class="ms mt mu"><p id="0b1a" class="jy jz mk ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated">拥有多个共享模块比一个大的共享模块要好。</p></blockquote><h2 id="4f7f" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">#4对页面中不可见的图像使用延迟加载</h2><p id="f22a" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">当我们第一次加载我们的主页时，我们可以有对用户不可见的图像(不在视窗中)。用户必须向下滚动才能看到图像。然而，当我们加载页面时，图像会被立即下载，如果我们有很多图像，这真的会影响性能。为了解决这个问题，我们可以延迟加载图片，只在用户需要的时候加载。有一个JavaScript API - <a class="ae mq" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank">交叉点观察器API </a>，这使得实现延迟加载内容变得非常容易。此外，我们可以为可重用性创建指令。这是关于它的一篇很好的文章。</p><h2 id="722f" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">#5对大列表使用虚拟滚动</h2><p id="9712" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">框架的第7版在CDK引入了虚拟滚动。虚拟滚动基于列表的可见部分从DOM加载和卸载元素，使得我们的应用程序非常快。</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/99e7207871fb21af4b550dde322f267b.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/1*rowyX9IgjThqqzwz0Zf_DA.png"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">我们可以只显示当时可见的几个项目，而不是加载和显示完整的列表</figcaption></figure><h2 id="fefd" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">#6字体使用<code class="fe lu lv lw lx b">FOUT</code>而不是<code class="fe lu lv lw lx b">FOIT</code></h2><p id="9597" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">在大多数网站上，我们看到的是定制的漂亮字体，而不是普通字体。然而，当用户访问我们的页面时，使用其他服务提供的自定义或字体需要浏览器下载并解析该字体。如果我们使用像Google Fonts <br/> 1这样的第三方服务提供的自定义字体，会出现两种情况。浏览器等待下载字体，解析字体，然后在页面上显示文本。在字体没有被下载和解析之前，页面上的文本是不可见的。这是<code class="fe lu lv lw lx b">FOIT</code>，或者说<code class="fe lu lv lw lx b">Flash of invisible text</code>。</p><p id="1ec6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.浏览器最初以常规字体显示文本，并尝试获取外部字体样式。当下载和解析后，它会用我们的自定义字体替换常规字体。页面上的文本将以常规字体呈现，同时如果浏览器将下载并解析外部字体，字体将被交换。这是<code class="fe lu lv lw lx b">FOUT</code>，或者说<code class="fe lu lv lw lx b">Flash of unstyled text</code></p><p id="7c2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大多数浏览器使用<code class="fe lu lv lw lx b">FOIT</code>，只有Internet Explorer使用<code class="fe lu lv lw lx b">FOUT</code>。为了解决这个问题，我们可以使用<code class="fe lu lv lw lx b">@font-face</code>的<code class="fe lu lv lw lx b">font-display</code>描述符，并告诉浏览器我们是否想使用常规字体，然后交换或隐藏文本。你也可以阅读<a class="ae mq" href="https://malthemilthers.com/font-loading-strategy-acceptable-flash-of-invisible-text" rel="noopener ugc nofollow" target="_blank">这篇文章</a>，它解释了字体是如何工作的，以及在什么情况下你需要<code class="fe lu lv lw lx b">FOIT</code>和<code class="fe lu lv lw lx b">FOUT</code></p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="7acd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用许多其他技术来提高性能，包括服务器端渲染、服务工人、AMP页面等等，我将在下一篇文章中讨论这些技术</p></div></div>    
</body>
</html>