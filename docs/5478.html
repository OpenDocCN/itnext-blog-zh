<html>
<head>
<title>Write concurrent programs using Isolate and Future in Dart</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Dart中使用Isolate和Future编写并发程序</h1>
<blockquote>原文：<a href="https://itnext.io/write-concurrent-programs-using-isolate-and-future-in-dart-da3fd9395db1?source=collection_archive---------4-----------------------#2021-03-15">https://itnext.io/write-concurrent-programs-using-isolate-and-future-in-dart-da3fd9395db1?source=collection_archive---------4-----------------------#2021-03-15</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="eeda" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">使用Isolate和Future的简单web服务器的4种不同实现</h2></div><p id="c6ef" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">dart编程语言中关于并发性的资源很少，特别是关于<a class="ae lf" href="https://api.dart.dev/stable/2.12.1/dart-isolate/dart-isolate-library.html" rel="noopener ugc nofollow" target="_blank"> Isolate </a>，在这篇文章中，我将通过一个web服务器的4个不同实现来描述Dart中的并发性概念(Isolate、Future和Async/Await)，然后开始在每个实现上产生负载，并最终尝试通过使用Isolate来提高性能，除了这4个实现，我还使用<a class="ae lf" href="https://ktor.io/" rel="noopener ugc nofollow" target="_blank"> Ktor </a> (Kotlin)和<a class="ae lf" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html" rel="noopener ugc nofollow" target="_blank"> WebFlux </a> (Java)框架实现了相同的场景来比较最终性能(每秒请求数)。你可以从这个Github库找到最终的Dart代码。</p><h2 id="9dac" class="lg lh iu bd li lj lk dn ll lm ln dp lo ks lp lq lr kw ls lt lu la lv lw lx ly bi translated">前言</h2><p id="4575" class="pw-post-body-paragraph kj kk iu kl b km lz jv ko kp ma jy kr ks mb ku kv kw mc ky kz la md lc ld le in bi translated">默认情况下，dart程序是包含事件循环的单线程(单隔离)异步程序。通过观看这些视频系列，你可以对<code class="fe me mf mg mh b">Async Coding With Dart</code>有一个很好的了解。</p><figure class="mi mj mk ml gu mm"><div class="bz fq l di"><div class="mn mo l"/></div></figure><p id="c3f7" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们将使用dart代码库中的<code class="fe me mf mg mh b">HttpServer</code>类(<code class="fe me mf mg mh b">dart:io</code>和<code class="fe me mf mg mh b">dart:isolate</code>)实现一个简单web服务器的4个不同版本，这个虚拟web服务器打算监听端口<code class="fe me mf mg mh b">4040</code>并计算<code class="fe me mf mg mh b">fibonacci number 35</code>(虚拟繁重工作)，然后将<code class="fe me mf mg mh b">Hello Dart!</code>返回给客户端！我们将通过以下方法实现它:</p><p id="fa9b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">1-使用异步/等待(<a class="ae lf" href="https://github.com/zarinfam/dart_concurrency/blob/master/bin/dart_server_await.dart" rel="noopener ugc nofollow" target="_blank"> dart_server_await.dart </a>)</p><p id="2e7a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">2-使用Future(<a class="ae lf" href="https://github.com/zarinfam/dart_concurrency/blob/master/bin/dart_server_future.dart" rel="noopener ugc nofollow" target="_blank">dart _ server _ Future . dart</a></p><p id="458c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">3-使用隔离和异步/等待(<a class="ae lf" href="https://github.com/zarinfam/dart_concurrency/blob/master/bin/dart_server_isolate_await.dart" rel="noopener ugc nofollow" target="_blank">dart _ server _ Isolate _ Await . dart</a>)</p><p id="59f2" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">4-使用隔离和未来(<a class="ae lf" href="https://github.com/zarinfam/dart_concurrency/blob/master/bin/dart_server_isolate_future.dart" rel="noopener ugc nofollow" target="_blank">dart _ server _ Isolate _ Future . dart</a>)</p><p id="852f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我通过实现一个<a class="ae lf" href="https://en.wikipedia.org/wiki/Fibonacci_number" rel="noopener ugc nofollow" target="_blank"> Fibonacci </a>函数来模拟繁重的工作负载，并使用<code class="fe me mf mg mh b"><a class="ae lf" href="https://github.com/wg/wrk" rel="noopener ugc nofollow" target="_blank">wrk</a></code>在服务器上生成负载:</p><p id="7130" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe me mf mg mh b">wrk -t12 -c1000 -d5m <a class="ae lf" href="http://127.0.0.1:4040/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:4040/</a></code></p><h1 id="4dd9" class="mp lh iu bd li mq mr ms ll mt mu mv lo ka mw kb lr kd mx ke lu kg my kh lx mz bi translated">1-使用异步/等待语法实现一个简单的web服务器</h1><p id="2802" class="pw-post-body-paragraph kj kk iu kl b km lz jv ko kp ma jy kr ks mb ku kv kw mc ky kz la md lc ld le in bi translated">这是dart.dev站点中的默认实现(<a class="ae lf" href="https://github.com/zarinfam/dart_concurrency/blob/master/bin/dart_server_await.dart" rel="noopener ugc nofollow" target="_blank"> dart_server_await.dart </a>)。</p><pre class="mi mj mk ml gu na mh nb nc aw nd bi"><span id="8330" class="lg lh iu mh b gz ne nf l ng nh">import 'dart:io';<br/><br/>import 'dto.dart';<br/><br/>void main() async {<br/>  var server = await HttpServer.bind(<br/>    InternetAddress.loopbackIPv4,<br/>    4040,<br/>  );<br/><br/>  print('Listening on localhost:${server.port}');<br/><br/>  await for (HttpRequest request in server) {<br/>    fib(35);<br/>    request.response.write('Hello Dart!');<br/>    await request.response.close();<br/>  }<br/>}</span></pre><p id="2553" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe me mf mg mh b">HttpServer</code>类操作是异步的，所以它们返回一个<a class="ae lf" href="https://api.dart.dev/stable/dart-async/Future-class.html" rel="noopener ugc nofollow" target="_blank"> Future </a>类的实例，一个<code class="fe me mf mg mh b">Future</code>对象是一个异步操作的结果值的占位符，其值将在未来完成或未完成。</p><p id="f384" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">通过使用Async/Await语法，我们可以以声明的方式编写异步代码，而不是使用回调方法，正如您可以看到的那样，最终的代码看起来很像同步代码，但运行起来像异步代码。</p><p id="068a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">当我使用<code class="fe me mf mg mh b"><a class="ae lf" href="https://github.com/wg/wrk" rel="noopener ugc nofollow" target="_blank">wrk</a></code>为这个实现生成负载时，我发现CPU内核(或超线程)的参与度非常低:</p><figure class="mi mj mk ml gu mm gi gj paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gi gj ni"><img src="../Images/8bf1a74bbfcafbc1a04ad905dfd0f908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-I1Z1_kum-LOdbELHP2kIA.png"/></div></div><figcaption class="np nq gk gi gj nr ns bd b be z dk translated">第一次实施中涉及的CPU核心</figcaption></figure><p id="f33b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe me mf mg mh b">Ktor</code>和<code class="fe me mf mg mh b">WebFlux</code>实现比第一个使用Async/Await的dart实现快7倍，并且在性能测试期间它们涉及所有CPU内核。</p><p id="b8d4" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这个结果是因为Dart编程语言的性质，默认情况下Dart是单线程的(隔离),该线程上有一个事件循环(隔离),但为了获得更好的性能，<code class="fe me mf mg mh b">Ktor</code>和<code class="fe me mf mg mh b">WebFlux</code>为每个CPU内核创建一个事件循环(我的Mac有8个内核，16个超线程)。</p><h1 id="4b81" class="mp lh iu bd li mq mr ms ll mt mu mv lo ka mw kb lr kd mx ke lu kg my kh lx mz bi translated">2-使用未来语法实现一个简单的web服务器</h1><p id="1d67" class="pw-post-body-paragraph kj kk iu kl b km lz jv ko kp ma jy kr ks mb ku kv kw mc ky kz la md lc ld le in bi translated">我只是改变了以前的web服务器，并使用Future来确保为每个请求创建一个新的Future对象不会提高性能(<a class="ae lf" href="https://github.com/zarinfam/dart_concurrency/blob/master/bin/dart_server_future.dart" rel="noopener ugc nofollow" target="_blank">dart _ server _ Future . dart</a>)。</p><p id="6082" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">不出我所料，结果一模一样。首先我调用了<code class="fe me mf mg mh b">server</code>对象的<code class="fe me mf mg mh b">listen</code>方法中的<code class="fe me mf mg mh b">fib</code>函数:</p><pre class="mi mj mk ml gu na mh nb nc aw nd bi"><span id="35a3" class="lg lh iu mh b gz ne nf l ng nh">server.listen((request) {<br/>  fib(35);<br/>  request.response.write('Hello Dart!');<br/>  request.response.close();<br/>});</span></pre><p id="847b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">然后试图将调用<code class="fe me mf mg mh b">fib</code>函数包装成另一个<code class="fe me mf mg mh b">Future</code>:</p><pre class="mi mj mk ml gu na mh nb nc aw nd bi"><span id="4c31" class="lg lh iu mh b gz ne nf l ng nh">.<br/>.<br/>.<br/>server.listen((request) {<br/>    fibF().then((_) {<br/>      request.response.write('Hello Dart!');<br/>      request.response.close();<br/>    });<br/>  });<br/>}<br/><br/>Future&lt;int&gt; fibF(){<br/>  return Future.microtask(() =&gt; fib(35));<br/>}</span></pre><p id="0cba" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在这两种情况下，结果与第一个实现相同。</p><h1 id="d1ca" class="mp lh iu bd li mq mr ms ll mt mu mv lo ka mw kb lr kd mx ke lu kg my kh lx mz bi translated">3-使用Isolate和Async/Await语法实现一个简单的web服务器</h1><p id="b1fa" class="pw-post-body-paragraph kj kk iu kl b km lz jv ko kp ma jy kr ks mb ku kv kw mc ky kz la md lc ld le in bi translated">为了证明Dart编程语言的能力，我尝试使用Isolate重新实现简单的web服务器。我们可以想象一个隔离类似于一个带有一个事件循环的线程，但是它的结构类似于一个Actor，从基础设施的角度来看，隔离非常类似于一个线程，但是没有共享内存，并且两个隔离可以共享某些东西的唯一方式是像Actor一样传递消息(使用<code class="fe me mf mg mh b">ReceivePort</code>和<code class="fe me mf mg mh b">SendPort</code>)。</p><p id="9612" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我尝试<code class="fe me mf mg mh b">spawn</code> 16隔离(CPU超线程的数量)并使用循环算法(使用消息传递)向它们发送每个请求:</p><pre class="mi mj mk ml gu na mh nb nc aw nd bi"><span id="5cf9" class="lg lh iu mh b gz ne nf l ng nh">import 'dart:io';<br/>import 'dart:isolate';<br/><br/>import 'dto.dart';<br/><br/>Future main() async {<br/>  var server = await HttpServer.bind(<br/>    InternetAddress.loopbackIPv4,<br/>    4040,<br/>  );<br/><br/>  final cpuCores = Platform.numberOfProcessors;<br/>  final isolatePorts = &lt;SendPort&gt;[];<br/>  var roundRobin = -1;<br/><br/>  for (var i = 0; i &lt; cpuCores; i++) {<br/>    final receivePort = ReceivePort();<br/>    await Isolate.spawn(<br/>        handler, IsolateData(receivePort.sendPort, 'isolate $i'));<br/>    isolatePorts[i] = await receivePort.first;<br/>  }<br/><br/>  print('Listening on localhost:${server.port}');<br/><br/>  await for (HttpRequest request in server) {<br/>    roundRobin = (roundRobin + 1) % cpuCores;<br/>    final msg = await send(isolatePorts[roundRobin], 'req');<br/>    request.response.write(msg);<br/>    await request.response.close();<br/>  }<br/>}<br/><br/>Future send(SendPort port, msg) {<br/>  final response = ReceivePort();<br/>  port.send([msg, response.sendPort]);<br/>  return response.first;<br/>}<br/><br/>Future&lt;void&gt; handler(IsolateData isolateData) async {<br/>  final port = ReceivePort();<br/>  isolateData.port.send(port.sendPort);<br/><br/>  await for (var msg in port) {<br/>    final request = msg[0];<br/>    SendPort replyTo = msg[1];<br/><br/>    fib(35);<br/><br/>    replyTo.send('Hello Dart!');<br/>  }<br/>}</span></pre><p id="ae73" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">看到使用<code class="fe me mf mg mh b">wrk</code>的性能测试结果没有变化，我非常惊讶！<code class="fe me mf mg mh b">Requests/sec</code>和CPU核心的参与与之前的实现是一样的！</p><p id="4bd3" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><strong class="kl iv">问题出在哪里？</strong></p><p id="5f63" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">现在我们有了几个事件循环，并在它们之间分配请求，希望有更好的性能！</p><p id="bc1e" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">问题是在使用中误用了Async/Await语法，这部分代码是阻塞的:</p><pre class="mi mj mk ml gu na mh nb nc aw nd bi"><span id="ce2c" class="lg lh iu mh b gz ne nf l ng nh">await for (HttpRequest request in server) {<br/>  roundRobin = (roundRobin + 1) % cpuCores;<br/>  final msg = await send(isolatePorts[roundRobin], 'req');<br/>  request.response.write(msg);<br/>  await request.response.close();<br/>}</span></pre><p id="1ae3" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">所以我在最后一个简单web服务器的实现中，尝试改进这部分，使用Future将其转换为非阻塞。</p><h1 id="4baa" class="mp lh iu bd li mq mr ms ll mt mu mv lo ka mw kb lr kd mx ke lu kg my kh lx mz bi translated">4-使用Isolate和Future实现一个简单的web服务器</h1><p id="c708" class="pw-post-body-paragraph kj kk iu kl b km lz jv ko kp ma jy kr ks mb ku kv kw mc ky kz la md lc ld le in bi translated">最后一个实现(<a class="ae lf" href="https://github.com/zarinfam/dart_concurrency/blob/master/bin/dart_server_isolate_future.dart" rel="noopener ugc nofollow" target="_blank">dart _ server _ isolate _ future . dart</a>)大约快了7倍！所有的CPU核心都参与其中。</p><figure class="mi mj mk ml gu mm gi gj paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gi gj nt"><img src="../Images/5c74d02b023e0cf3bdc62a9e51933ff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gbVQZbiI7ghBKPiC5zDgFA.png"/></div></div></figure><pre class="mi mj mk ml gu na mh nb nc aw nd bi"><span id="5222" class="lg lh iu mh b gz ne nf l ng nh">import 'dart:io';<br/>import 'dart:isolate';<br/><br/>import 'dto.dart';<br/><br/>Future main() async {<br/>  var server = await HttpServer.bind(<br/>    InternetAddress.loopbackIPv4,<br/>    4040,<br/>  );<br/><br/>  final cpuCores = Platform.numberOfProcessors;<br/>  final isolatePorts = List&lt;SendPort&gt;(cpuCores);<br/>  var roundRobin = -1;<br/><br/>  for (var i = 0; i &lt; cpuCores; i++) {<br/>    final receivePort = ReceivePort();<br/>    await Isolate.spawn(<br/>        handler, IsolateData(receivePort.sendPort, 'isolate $i'));<br/>    isolatePorts[i] = await receivePort.first;<br/>  }<br/><br/>  print('Listening on localhost:${server.port}');<br/><br/>  server.listen((request) {<br/>    roundRobin = (roundRobin + 1) % cpuCores;<br/>    send(isolatePorts[roundRobin], 'req').then((msg) {<br/>      request.response.write(msg);<br/>      request.response.close();<br/>    });<br/>  });<br/>}<br/><br/>Future send(SendPort port, msg) {<br/>  final response = ReceivePort();<br/>  port.send([msg, response.sendPort]);<br/>  return response.first;<br/>}<br/><br/>Future&lt;void&gt; handler(IsolateData isolateData) async {<br/>  final port = ReceivePort();<br/>  isolateData.port.send(port.sendPort);<br/><br/>  await for (var msg in port) {<br/>    final request = msg[0];<br/>    SendPort replyTo = msg[1];<br/><br/>    fib(35);<br/><br/>    replyTo.send('Hello Dart!');<br/>  }<br/>}</span></pre><p id="b597" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如您所见，我只是从那部分代码中删除了Async/Await语法，并使用<code class="fe me mf mg mh b">listen</code>和<code class="fe me mf mg mh b">then</code>方法来处理异步代码，而不是Async/Await语法。</p><h1 id="de01" class="mp lh iu bd li mq mr ms ll mt mu mv lo ka mw kb lr kd mx ke lu kg my kh lx mz bi translated">结论</h1><p id="7d0b" class="pw-post-body-paragraph kj kk iu kl b km lz jv ko kp ma jy kr ks mb ku kv kw mc ky kz la md lc ld le in bi translated">您可以在dart中使用Isolate编写非常强大和可伸缩的并发程序，其性能可以与其他编程语言竞争，但当您想要在多隔离Dart应用程序中使用Async/Await语法时，您必须小心<strong class="kl iv">，因为您可能会阻止您不需要的程序。当只有一个隔离和一个事件循环时，Async/Await语法是完美的。</strong></p><p id="7b84" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">对我来说，Isolate的另一个有趣之处是它们之间的内存结构和通信。它与<code class="fe me mf mg mh b"><a class="ae lf" href="https://www.erlang.org/" rel="noopener ugc nofollow" target="_blank">Erlang programming language</a></code>和<code class="fe me mf mg mh b"><a class="ae lf" href="https://akka.io/" rel="noopener ugc nofollow" target="_blank">Akka</a></code>中的演员模型概念非常相似。就像演员一样，孤立者彼此分离，唯一的联系方式就是发送消息。</p></div></div>    
</body>
</html>