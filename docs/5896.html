<html>
<head>
<title>Other Reasons Why Rust Is My Favorite Programming Language</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust是我最喜欢的编程语言的其他原因</h1>
<blockquote>原文：<a href="https://itnext.io/other-reasons-why-rust-is-my-favorite-programming-language-ba6805a6a458?source=collection_archive---------0-----------------------#2021-06-24">https://itnext.io/other-reasons-why-rust-is-my-favorite-programming-language-ba6805a6a458?source=collection_archive---------0-----------------------#2021-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/ac8bb8460536744cf31956ae41466c6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*OuDN901VJSSwAqK3mTtRnA.png"/></div></figure><p id="0167" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在围绕Rust有很多炒作。一些特征占据了头条:</p><ol class=""><li id="6e28" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">Rust和C或C++一样快。</li><li id="8b68" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">Rust是内存安全的。</li></ol><p id="19ec" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Rust程序员也喜欢优秀的文档和优秀的包管理器，这无疑是Rust越来越受欢迎的原因。</p><p id="b810" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Rust语言还有一些我非常喜欢的特性，但是我还没有看到太多的讨论。我用Rust编写代码已经有一年了，在这段时间里，它已经成为我所知道的几十种语言中我最喜欢的一种。</p><p id="0036" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下面是三个鲜为人知的语言特性，它们让Rust编程变得非常有趣:</p><ol class=""><li id="fc41" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">没有空值。</li><li id="fe62" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">强大的宏。</li><li id="4864" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">对可变性的精确控制。</li></ol><p id="f7ed" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">还有一个额外的特性我留到了最后，只有在解释了其他特性之后才有意义。</p><p id="1c9c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Rust <a class="ae lg" href="https://cheats.rs/" rel="noopener ugc nofollow" target="_blank">备忘单</a>在接下来的代码样本中快速解释了Rust的一些独特语法。</p><p id="117e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们更深入地了解每个特性。</p><h1 id="5808" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">没有空值</h1><p id="8266" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">Null可能是编程语言设计中最大的错误。<a class="ae lg" href="https://en.wikipedia.org/wiki/Tony_Hoare" rel="noopener ugc nofollow" target="_blank">东尼·霍尔称之为他的“十亿美元的错误”</a></p><p id="ec63" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你有没有做过一个软件项目从来没有抛出过一个NullPointerException或者解引用null而崩溃？如果你的项目是用Rust、Swift、Elm或Haskell编写的，那么也许你有。否则，这种可能性微乎其微。</p><p id="c06e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">取消对null的引用将使程序嘎然而止。为了应对不断的危险，避免软件崩溃，程序员们编写类似<a class="ae lg" href="https://github.com/dotnet/aspnetcore/blob/52eff90fbcfca39b7eb58baad597df6a99a542b0/src/Components/Analyzers/src/ComponentFacts.cs#L15" rel="noopener ugc nofollow" target="_blank">这样的代码:</a></p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="c65d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这段代码被空检查所支配，以至于很难理解这个函数实际上做了什么。可怜的程序员编写了更多的代码来应对参数可能为空的情况，而不是解决他们想要解决的问题。更重要的是，程序员已经多次阅读这种空检查代码，以至于他们已经训练自己忽略它。你看到我在上面的代码中引入的bug了吗？</p><p id="92d0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因为Rust没有null，上面的示例代码可以用Rust写成这样:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="b798" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Rust代码不检查空值，因为两个参数都不能为空。任何传递null的尝试都会被编译器捕获，并报告为类型不匹配。现在我知道了Rust，当我看到其他语言中的空检查时，我会退缩。</p><p id="4ef3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是当然，null可能非常有用。有时，类或结构可以选择保存值，函数可以选择返回值，这很方便。为此，Rust提供了<a class="ae lg" href="https://doc.rust-lang.org/std/option/" rel="noopener ugc nofollow" target="_blank">选项&lt;T&gt;T9】类型。Option &lt; T &gt;的一个实例要么不包含，要么包含一些(T ),但决不包含两者。</a></p><p id="4c92" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们考虑一个表示类似“<a class="ae lg" href="https://www.google.com:80/" rel="noopener ugc nofollow" target="_blank">http://www.google.com</a>/”的url的结构。URL可选地包含一个端口号，如下所示:“<a class="ae lg" href="http://www.google.com:80/" rel="noopener ugc nofollow" target="_blank">http://www.google.com:80/</a>”。在Rust中，我们可以用以下结构来表示解析后的Url:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="e627" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">假设我们想要编写一个名为incr_port()的方法，它增加url中的端口号；我们将像这样调用方法<code class="fe mq mr ms mt b">url.incr_port();</code>。</p><p id="7741" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">天真地说，我们可能会这样写这个方法:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="41b4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Rust编译器拒绝上面的incr_port()，因为端口不是u16这是一个选项<u16>。编译器防止了在其他语言中潜在的空指针异常。</u16></p><pre class="mk ml mm mn gt mu mt mv mw aw mx bi"><span id="97d4" class="my li iq mt b gy mz na l nb nc">14 |      self.port += 1;<br/>   |      ---------^^^^^<br/>   |      |<br/>   |      cannot use `+=` on type `std::option::Option&lt;u16&gt;`</span></pre><p id="6025" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要增加端口，代码必须首先确认端口有一些值。</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="d9c3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">通过选项<t>，Rust在我们需要的时候提供可选值，而不会导致程序崩溃。更重要的是，Rust将程序员从对每个参数和对象进行空检查的苦差事中解放出来。</t></p><h1 id="95ef" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">强大的宏</h1><p id="0c34" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">让我们继续上面的Url结构。我将在Url结构之前添加一行代码，然后讨论这一行代码的所有好处:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="d80a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">通过添加这一行代码，</p><p id="2c65" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mq mr ms mt b">#[derive(Eq, PartialEq, Ord, PartialOrd, Clone, Hash, Default, Debug)]</code></p><p id="20ed" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我现在可以像这样比较两个URL是否相等:</p><p id="ab20" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mq mr ms mt b">url == url2</code></p><p id="888b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我也可以比较它们来点菜。帕蒂亚洛德和Ord宏按照成员在结构中出现的顺序比较结构的成员。</p><p id="411d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mq mr ms mt b">url &gt; url2</code></p><p id="2448" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这意味着我可以将URL放入已排序的容器中:</p><pre class="mk ml mm mn gt mu mt mv mw aw mx bi"><span id="5469" class="my li iq mt b gy mz na l nb nc">let mut sorted_urls = BTreeSet::new();<br/>sorted_urls.insert(url);</span></pre><p id="2565" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我可以克隆一个Url来得到一个精确的副本:</p><p id="126a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mq mr ms mt b">let url2 = url.clone();</code></p><p id="5d4d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我可以将URL插入哈希容器:</p><pre class="mk ml mm mn gt mu mt mv mw aw mx bi"><span id="f6c3" class="my li iq mt b gy mz na l nb nc">let mut urls = HashSet::new();<br/>urls.insert(url4);</span></pre><p id="ffe4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我可以创建一个默认的Url，有点像在其他语言中调用无参数的构造函数:</p><p id="6259" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mq mr ms mt b">let url = Url::default();</code></p><p id="876e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">而且，我可以为Url打印一个漂亮的调试字符串:</p><p id="4ac5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mq mr ms mt b">println!(“{:?}”, url);</code></p><p id="1ac5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">输出:<code class="fe mq mr ms mt b">Url { protocol: “http”, host_name: “www.google.com", port: Some(80), path: “” }</code></p><p id="fbe6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一行代码中包含了大量的功能！在其他语言中，有实现相同行为的方法:代码生成器、后处理器、ide等。有些语言使用内省。然而，我最喜欢Rust的解决方案，因为它不需要额外的工具，也没有额外的代码需要我或我的同事来检查和维护，而且类型错误会在编译时被捕获。</p><p id="3de9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这些宏的行为都与您预期的一样。例如，Ord(ordering或ordered的缩写)按顺序比较结构的每个成员。这可能会使人们在重构代码时出错，因为改变结构成员的顺序会改变排序顺序。为了避免这种情况，我可以实现<a class="ae lg" href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html" rel="noopener ugc nofollow" target="_blank"> std::cmp::PartialOrd </a>并根据我的需要对其进行定制。</p><p id="ba42" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第三方库也可以利用<code class="fe mq mr ms mt b">#[derive()]</code>宏。serde库是Rust事实上的标准，用于将结构序列化/反序列化为十几种格式。让我们添加一些代码来允许Url被序列化到json和从JSON反序列化。导入serde库之后，我向<code class="fe mq mr ms mt b">#[derive()]</code>宏添加了两个属性:</p><p id="c35a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mq mr ms mt b">#[derive(…, Serialize, Deserialize)]</code></p><p id="c22c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我可以从json序列化和反序列化URL。</p><pre class="mk ml mm mn gt mu mt mv mw aw mx bi"><span id="e8c7" class="my li iq mt b gy mz na l nb nc">let text = serde_json::to_string(&amp;url)?;<br/>let url2: Url = serde_json::from_str(&amp;text)?;</span></pre><p id="ac63" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">解析错误立即通过<a class="ae lg" href="https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html" rel="noopener ugc nofollow" target="_blank"/><code class="fe mq mr ms mt b"><a class="ae lg" href="https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html" rel="noopener ugc nofollow" target="_blank">?</a></code><a class="ae lg" href="https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html" rel="noopener ugc nofollow" target="_blank">操作符</a>返回给调用函数。</p><p id="f179" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mq mr ms mt b">#[derive()]</code>宏通过只在我的代码中添加两个符号，为我的Url结构添加了大量的功能！如果Url包含无法序列化为json的类型，编译器就会报告错误。</p><p id="dc7f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae lg" href="https://en.wikipedia.org/wiki/With_great_power_comes_great_responsibility" rel="noopener ugc nofollow" target="_blank">权力越大，责任越大。如果你在20世纪90年代维护一个C或C++代码库，那么你可能会看到人们用宏做可怕的事情。C/C++预处理器的宏可以用任何文本<em class="nd">替换任何符号。人们利用这种能力来创建看起来一点也不像C的代码，并且很难理解和维护。这里有一个那个时代的真实例子:</em></a></p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="93b0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这段代码实际上定义了一个方法，并在主体中构建了一个if-else阶梯，但是除非你剖析了宏，否则你永远不会知道。在调试器中检查这段代码也令人困惑。BEGIN_MESSAGE_MAP()是这样的:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="f5dc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">不出所料，有人强烈反对宏造成这种混乱。从这一经历中诞生的语言有意地缺少宏:即Java和Go。</p><p id="9836" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是我认为那些语言<a class="ae lg" href="https://en.wikipedia.org/wiki/Don%27t_throw_the_baby_out_with_the_bathwater" rel="noopener ugc nofollow" target="_blank">把婴儿和洗澡水一起倒掉了</a>。这个问题不是一般的宏；问题是C/C++预处理器。在Rust中使用了几十个库之后，我还没有见过像BEGIN_MESSAGE_MAP()这样神秘的东西。事实上，我只用过两个库中的宏:<a class="ae lg" href="https://crates.io/crates/serde" rel="noopener ugc nofollow" target="_blank"> serde </a>和<a class="ae lg" href="https://docs.rs/anyhow/1.0.41/anyhow/index.html" rel="noopener ugc nofollow" target="_blank">总之</a>。</p><p id="950a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我看到了一些程序员在Rust中使用宏比在其他语言中更有纪律的原因:</p><ol class=""><li id="dc08" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">Rust提供了<a class="ae lg" href="https://doc.rust-lang.org/reference/items/functions.html#const-functions" rel="noopener ugc nofollow" target="_blank">常量函数</a>，在很多情况下可以替代宏。例如，您可以编写一个<code class="fe mq mr ms mt b">const sqrt()</code>函数，在编译时计算一个常数的平方根。</li><li id="e420" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">使用Rust宏，您不能用任何想要的文本超级全局地替换一个符号。比如这是不可能的:<code class="fe mq mr ms mt b">#define PLUS +</code></li><li id="aa13" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">在Rust中，<a class="ae lg" href="https://docs.rust-embedded.org/book/c-tips/index.html#macros" rel="noopener ugc nofollow" target="_blank">宏必须扩展以完成表达式、语句、项目、类型或模式</a>。他们不能扩展到半个功能。它们不能有不平衡的圆括号、中括号或大括号。上面的BEGIN_MESSAGE_MAP()宏在Rust中是不可能的，因为它有不平衡的大括号。</li><li id="866c" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">在Rust中定义宏比用C/C++预处理器要复杂得多。学习如何在Rust中编写宏就像学习一门全新的编程语言。不能只<code class="fe mq mr ms mt b">#define max(a, b) ((a) &lt; (b) ? (b) : (a))</code>。如果一个东西可以用除了宏之外的任何方式来表达，Rust程序员喜欢选择另一种方式。</li></ol><h1 id="73da" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">对可变性的精确控制</h1><p id="9713" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">Rust给了程序员对可变性的精确控制。可变数据可以被修改。不可变数据不能被修改。</p><p id="5c9f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">不可变数据对于每个必须阅读代码的人来说都很棒，不管他们是人还是机器。推理不可变数据要容易得多，编译器更容易优化使用不可变数据的代码，并且不可变数据总是线程安全的。</p><p id="35ec" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">考虑这个示例代码，它使用了上面的Url示例，并演示了为什么不可变数据使代码更容易推理。</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="f150" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因为url是通过不可变的引用传递给fetch()的，所以fetch()不可能修改url的内容。因此，很容易通过循环的每次迭代来预测url的值。我不必检查fetch()的代码，甚至不必查看它的参数类型来确认它没有修改url，因为我可以看到参数是作为<em class="nd">不可变</em>引用:<code class="fe mq mr ms mt b">&amp;url</code>传递的。要让fetch()修改url，我必须修改调用代码，将url作为可变引用传递，就像这样:<code class="fe mq mr ms mt b">fetch(&amp;mut url)</code>。</p><p id="274d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">同时，我不必在整个循环的上下文中使url不可变，以使它在调用fetch()期间不可变。我仍然可以通过在循环中调用<code class="fe mq mr ms mt b">url.incr_port()</code>来修改url。</p><p id="1ac3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将url作为不可变的引用传递也为fetch()提供了保证。fetch()不仅不可能修改url，而且当fetch()对url有一个不可变的引用时，其他任何东西也不可能修改url。当fetch()正在执行时，任何其他线程都不能修改url。这使得编写fetch()更容易。</p><p id="3604" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我说Rust给了程序员对可变性的精确控制，因为Rust不会将可变性与其他概念纠缠在一起。程序员可以选择数据是可变的还是不可变的，不管数据是分配在堆栈上还是堆上，不管它是通过引用还是通过值传递，也不管它是结构还是像整数这样的原始类型。</p><p id="9ba8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">没有像Rust那样对可变性的精确控制，其他语言引入了各种模式和语言特性来提供某种形式的不变性。一些例子是<a class="ae lg" href="https://howtodoinjava.com/design-patterns/creational/builder-pattern-in-java/" rel="noopener ugc nofollow" target="_blank">构建器模式</a>，只读接口，以及多种聚合类型，每种类型都有自己的可变性规则，比如类对结构对记录。使用这些其他解决方案需要进行权衡，或者编写比Rust更多的代码。</p><h1 id="3a82" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">额外特点:铁锈富有表现力</h1><p id="0b1d" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">Rust被描述为一种富于表现力的语言；表达是一个非常抽象的术语。什么是表现力，为什么有用？</p><p id="5c14" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在表达性语言中，不改变语言的语法，不使用<a class="ae lg" href="https://en.wikipedia.org/wiki/Boilerplate_code" rel="noopener ugc nofollow" target="_blank">样板代码</a>，就有可能引入语言设计者从未想过的新思想。事实上，许多概念纯粹是通过一个库而不是语法来合并的，这证明Rust是有表现力的。</p><p id="7c7c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">例如，Option <t>类型没有内置到语言中；它只是一个标准的库。其他语言需要专用的语法来编码可选值，但是使用Rust，现有的语言特性允许程序员使用Option <t>有效地表达可选值；不需要对语言进行修改。</t></t></p><p id="18c6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Rust用标准库而不是语法实现概念的另一个例子是Rust的<a class="ae lg" href="https://doc.rust-lang.org/std/convert/trait.From.html" rel="noopener ugc nofollow" target="_blank">From&lt;T&gt;and Into&lt;T&gt;T14】traits，它允许程序员编写从一种类型到另一种类型的自定义转换。其他语言增加了运算符语法，使程序员能够定义自定义类型转换。有了Rust，现有的语言特性就足够了。从&lt; T &gt;到&lt; T &gt;都是普通性状。</a></p><p id="f169" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于语言设计师来说，这听起来很棒，但是对于我们其他人来说，这怎么可能是实际的呢？</p><p id="21df" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">考虑这个函数:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="7e16" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">io::Result 返回类型可以恰好包含以下值之一:错误值或表示成功的空值()。</p><p id="2c53" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">想象一下实现这个函数。为了确保我们总是将文件指针重置到其原始位置，在其他编程语言中找到类似于<code class="fe mq mr ms mt b">try {} finally {}</code>的东西肯定会很方便。然后，我们可以简单地在finally块中调用<code class="fe mq mr ms mt b">f.seek(original_offset)</code>。但是Rust没有例外，也没有<code class="fe mq mr ms mt b">try {} finally {}</code>。</p><p id="1722" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了应对没有<code class="fe mq mr ms mt b">try {} finally {}</code>的情况，我写了一个行为相同的宏。首先，一些免责声明:</p><ol class=""><li id="4a9a" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">这个是我写的第一个宏，所以肯定可以改进。</li><li id="8495" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">这是我写的第一个宏，因为我没有写宏的需要。</li><li id="94ce" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">该宏仅用于演示目的。当我几个月前在产品代码中有同样的需求时，我写的是普通的Rust代码。</li><li id="6c44" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">因为Rust有一个内置的宏叫try！()，我必须给我的宏取个不同的名字，所以我把它命名为tryf！().</li></ol><p id="5394" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">免责声明够多了。下面是我用tryf实现的函数的样子！()宏:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="254e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">语法有点不同，但是如果你熟悉有异常的语言，我希望这段代码的作用很明显。这就是表达性语言的美妙之处。我能接受与语言本身无关的想法，并用Rust有效地表达出来。</p><p id="700d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因为Rust富有表现力，我相信我能够用代码高效地表达我自己的各种想法，包括编译时发现的错误，以及没有<a class="ae lg" href="https://en.wikipedia.org/wiki/Boilerplate_code" rel="noopener ugc nofollow" target="_blank">样板代码</a>。</p><h1 id="4edf" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><p id="31e0" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">当然，我喜欢Rust的原因和许多其他人一样:与C/C++相似的速度，内存安全，优秀的文档，优秀的包管理器，通过<a class="ae lg" href="https://webassembly.org/" rel="noopener ugc nofollow" target="_blank"> WebAssembly </a>在浏览器中运行，等等。但我觉得Rust也有一些隐藏的宝石，所以我写了这个帖子。</p><p id="9e78" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你正在考虑将Rust用于工作或爱好，我希望这篇文章能给你一些有用的见解，帮助你做出更明智的决定。要开始学习Rust，我推荐从《Rust by Example 这本书开始。</p><h1 id="eb79" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">承认</h1><p id="c7bc" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">感谢下面的人，他们无疑对自己喜欢的语言有不同的看法，但却慷慨地审阅了这篇文章的草稿。</p><ul class=""><li id="3ae1" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr ne ky kz la bi translated"><a class="ae lg" href="https://users.rust-lang.org/t/seeking-comments-on-my-draft-blog-post-about-my-favorite-features-of-rust/59230" rel="noopener ugc nofollow" target="_blank">铁锈论坛</a></li><li id="fbba" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr ne ky kz la bi translated">乔恩·斯基特<a class="ae lg" href="https://codeblog.jonskeet.uk/" rel="noopener ugc nofollow" target="_blank"/></li><li id="a981" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr ne ky kz la bi translated">丹尼尔·班克海德<a class="ae lg" href="https://www.linkedin.com/in/danielbankhead" rel="noopener ugc nofollow" target="_blank"/></li><li id="a96e" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr ne ky kz la bi translated">本杰明·科</li></ul><p id="2744" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">脚注</p><p id="64ca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">[1]有时，你可能需要给一个不可变的结构增加一个引用计数。对于这样的情况，Rust提供了<a class="ae lg" href="https://doc.rust-lang.org/std/cell/" rel="noopener ugc nofollow" target="_blank">单元</a>、<a class="ae lg" href="https://doc.rust-lang.org/std/rc/index.html" rel="noopener ugc nofollow" target="_blank"> Rc </a>等等。</p></div></div>    
</body>
</html>