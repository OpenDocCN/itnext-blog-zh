<html>
<head>
<title>Export To The File System (Save As…) + Fallback In TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">导出到文件系统(另存为…)+TypeScript中的回退</h1>
<blockquote>原文：<a href="https://itnext.io/export-to-the-file-system-save-as-fallback-in-typescript-6561eba853cb?source=collection_archive---------0-----------------------#2022-02-18">https://itnext.io/export-to-the-file-system-save-as-fallback-in-typescript-6561eba853cb?source=collection_archive---------0-----------------------#2022-02-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c501" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用新的文件系统访问API和针对不兼容浏览器的回退将文件保存到用户的本地设备。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bc038dcfb8814983df583a5723d716ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5z07fHoPx9LGqb4UjH5PYg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@ivvndiaz?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">伊万·迪亚兹</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="0510" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在几乎每个web应用程序中，我最终都重复使用相同的模式以JavaScript将数据导出到文件系统——即使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API" rel="noopener ugc nofollow" target="_blank">文件系统访问API </a>和一个很好的旧“下载”特性作为后备的解决方案。我认为写一篇关于它的文章作为文档是值得的😉。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="ec2a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">介绍</h1><p id="705d" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">文件系统访问API允许在您的浏览器中进行读取、写入和文件管理。它使开发人员能够构建强大的web应用程序，与用户本地设备上的文件进行交互。</p><p id="95a8" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">web.dev团队有一个<a class="ae ky" href="https://web.dev/file-system-access/" rel="noopener ugc nofollow" target="_blank">教程</a>介绍并强调了所有的特性。​</p><p id="3c84" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">它是一个相对较新的API，因此还没有被所有的浏览器厂商采用。​</p><p id="65ad" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">例如，我们使用的一个关键功能——<code class="fe mz na nb nc b">showSaveFilePicker</code>打开一个对话框，选择将写入用户本地驱动器的文件的目的地——只有Edge、Chrome和Opera支持(2022年2月——来源<a class="ae ky" href="https://caniuse.com/?search=showSaveFilePicker" rel="noopener ugc nofollow" target="_blank">可以使用</a>)。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="14fe" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">入门指南</h1><p id="c79e" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">一般来说，我使用打字稿。这个解决方案也提供了类型安全。这就是为什么它需要首先安装文件系统访问API的类型定义。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="7905" class="nh md it nc b gy ni nj l nk nl">npm i -D @types/wicg-file-system-access</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="f381" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">亲自动手</h1><p id="9c97" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">为了导出文件，我使用了一个<code class="fe mz na nb nc b">Blob</code>——也就是我想要导出的文件的内容——和一个<code class="fe mz na nb nc b">filename</code>。我创建了一个功能，可以保存到用户的本地设备，并可以在我的应用程序中使用。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="5752" class="nh md it nc b gy ni nj l nk nl">export const save = (data: {blob: Blob, filename: string}) =&gt; {<br/>    if ('showSaveFilePicker' in window) {<br/>        return exportNativeFileSystem(data);<br/>    }<br/><br/>    return download(data);<br/>};</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="78d8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">文件系统访问API —另存为</h1><p id="d5d4" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi">​</p><p id="7d8f" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">上述功能测试<code class="fe mz na nb nc b">showSaveFilePicker</code>在<code class="fe mz na nb nc b">window</code>对象中是否可用——即检查浏览器是否支持文件系统访问API。​</p><p id="4d2c" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">为了用新的API保存文件，我们首先以“保存”模式向用户显示一个对话框。使用它，用户可以选择保存文件的位置。一旦设置了路径，文件就可以有效地写入本地驱动器。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9218" class="nh md it nc b gy ni nj l nk nl">const exportNativeFileSystem =<br/>        async ({blob, filename}: {blob: Blob, filename: string}) =&gt; {<br/>    const fileHandle: FileSystemFileHandle =<br/>        await getNewFileHandle({filename});<br/><br/>    if (!fileHandle) {<br/>        throw new Error('Cannot access filesystem');<br/>    }<br/><br/>    await writeFile({fileHandle, blob});<br/>};</span></pre><p id="063d" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在许多情况下，我希望我的应用程序建议一个默认的文件名。这可以通过设置<code class="fe mz na nb nc b">suggestedName</code>来实现。此外，我还通过提供mime类型和相关的文件扩展名来确定可以选择的文件类型。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b65a" class="nh md it nc b gy ni nj l nk nl">const getNewFileHandle = <br/>    ({filename}: {filename: string}): Promise&lt;FileSystemFileHandle&gt; =&gt; {<br/>  const opts: SaveFilePickerOptions = {<br/>    suggestedName: filename,<br/>    types: [<br/>      {<br/>        description: 'Markdown file',<br/>        accept: {<br/>          'text/plain': ['.md']<br/>        }<br/>      }<br/>    ]<br/>  };<br/><br/>  return showSaveFilePicker(opts);<br/>};</span></pre><p id="38cd" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">最后，可以使用API的另一个函数<code class="fe mz na nb nc b">writeFile</code>有效地编写文件。它使用我之前请求的文件句柄来知道将数据导出到文件系统的哪里。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6caf" class="nh md it nc b gy ni nj l nk nl">const writeFile = <br/>    async ({fileHandle, blob}: {fileHandle: FileSystemFileHandle, blob: Blob}) =&gt; {<br/>  const writer = await fileHandle.createWritable();<br/>  await writer.write(blob);<br/>  await writer.close();<br/>};</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5ffc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">回退—下载</h1><p id="d50b" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">作为后备，我在DOM中添加了一个可以自动点击的临时锚元素。为了将文件导出到用户的默认下载文件夹，我提供了一个对象作为<code class="fe mz na nb nc b">blob</code>的URL。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6049" class="nh md it nc b gy ni nj l nk nl">const download = async ({filename, blob}: {filename: string; blob: Blob}) =&gt; {<br/>  const a: HTMLAnchorElement = document.createElement('a');<br/>  a.style.display = 'none';<br/>  document.body.appendChild(a);<br/><br/>  const url: string = window.URL.createObjectURL(blob);<br/><br/>  a.href = url;<br/>  a.download = `${filename}.md`;<br/><br/>  a.click();<br/><br/>  window.URL.revokeObjectURL(url);<br/>  a.parentElement?.removeChild(a);<br/>};</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="793b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">获取代码</h1><p id="b349" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">你可以在我最近发布在GitHub上的Chrome插件中找到本文中的所有代码👉<a class="ae ky" href="https://github.com/papyrs/markdown-plugin/blob/main/src/plugin/utils/save.utils.ts" rel="noopener ugc nofollow" target="_blank"> save-utils.ts </a></p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="d1e0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="a2f2" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">这是一个相当短的帖子，我希望至少有点娱乐性🤪。如果你想深入挖掘文件系统访问API，我再次建议你看看<a class="ae ky" href="https://web.dev/file-system-access/" rel="noopener ugc nofollow" target="_blank"> web.dev </a>团队的精彩帖子。​</p><p id="1ced" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">到无限远处<br/>大卫</p></div></div>    
</body>
</html>