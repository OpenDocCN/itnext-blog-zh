<html>
<head>
<title>No need to wait for .Net 5 to start using code generation with Roslyn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不需要等待。Net 5开始使用罗斯林代码生成</h1>
<blockquote>原文：<a href="https://itnext.io/no-need-to-wait-for-net-5-to-start-using-code-generation-with-roslyn-f2317b438a6c?source=collection_archive---------0-----------------------#2020-11-03">https://itnext.io/no-need-to-wait-for-net-5-to-start-using-code-generation-with-roslyn-f2317b438a6c?source=collection_archive---------0-----------------------#2020-11-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7d3a589dc42ad6dd73c5d4e7383d97aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i4wapBXiApzZtOnS5upiag.png"/></div></div></figure><p id="ea16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近，当我回顾即将包含在中的新功能时。Net 5，偶然发现了一个有趣的——<a class="ae kw" href="https://devblogs.microsoft.com/dotnet/introducing-c-source-generators/" rel="noopener ugc nofollow" target="_blank">C #源码生成器</a>。我对这个特性特别感兴趣，因为我在过去的… 5年里一直使用类似的方法，微软提议的只是将这种方法更深入地集成到构建过程中。</p><p id="f343" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，我将分享我在代码生成中使用Roslyn的经验，我认为这将有助于您更好地了解微软到底提供了什么以及何时可以使用它。</p><p id="ef90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们看一个典型的代码生成场景。您有一些外部信息源，比如数据库、某个REST服务的JSON描述、另一个程序集(通过反射)等等。使用这些信息，您可以生成各种类型的源代码，比如dto、db模型类或REST服务的代理。</p><p id="ad0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，有时会出现这样的情况，即没有任何外部信息源，您需要的一切都包含在项目本身的源代码中，您希望在其中添加一些生成的代码。</p><p id="7e1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">巧合的是，我最近发表的一个开源项目就有这样一个例子。在这个项目中有超过100个代表SQL语法树节点的<a class="ae kw" href="https://github.com/0x1000000/SqExpress/tree/main/SqExpress/Syntax" rel="noopener ugc nofollow" target="_blank">类</a>，我需要创建访问者，这些访问者将<a class="ae kw" href="https://github.com/0x1000000/SqExpress/blob/main/SqExpress/SyntaxTreeOperations/Internal/ExprWalker.cs" rel="noopener ugc nofollow" target="_blank">遍历</a>和<a class="ae kw" href="https://github.com/0x1000000/SqExpress/blob/main/SqExpress/SyntaxTreeOperations/Internal/ExprModifier.cs" rel="noopener ugc nofollow" target="_blank">修改</a>树对象(你可以在我以前的文章<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/syntax-tree-and-alternative-to-linq-in-interaction-with-sql-databases-656b78fe00dc?source=friends_link&amp;sk=f5f0587c08166d8824b96b48fe2cf33c">语法树和与SQL数据库交互的LINQ的替代方案</a>中找到关于这个项目的更多信息)。</p><p id="cfb8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代码生成在这里是一个好的选择的原因是，每次我对类做一个很小的更改，我都需要记住修改访问者，这些更改必须非常小心地完成。但是，我不能使用反射来生成代码，因为包含新更改的程序集根本就不存在，如果这些更改与以前的版本不兼容并导致编译错误，那么这个程序集将永远不会出现，直到我手动修复所有错误。</p><p id="c5d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个问题乍一看无解，但实际上我可以用Roslyn编译器来解决。我可以提前预编译模型类，并通过反射获得类似的信息。</p><p id="c9ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们创建一个简单的控制台应用程序，并添加<a class="ae kw" href="https://www.nuget.org/packages/Microsoft.CodeAnalysis.CSharp" rel="noopener ugc nofollow" target="_blank">微软。CodeAnalysis.CSharp </a>包。</p><p id="2847" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">注意:理论上这可以在t4中实现，但是我不喜欢纠结于依赖和奇怪的t4语法。</em></p><p id="e94a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们需要读取包含模型类的所有cs文件，并从中提取语法树:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="132b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从文本的角度来看，这些树包含了大量关于源代码的信息(类名、方法名等等。)，但通常这些信息是不够的，因为我们想知道文本的意思，所以我们需要让Roslyn分析语法树并获得一些语义数据:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="02a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用语义数据我们可以得到一个类型为的<strong class="ka ir">的对象:</strong></p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="13ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它可以提供关于类构造函数和属性的信息:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="5955" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于所有的模型类都是不可变的，所有有意义的属性都必须通过它们的构造函数来设置，所以让我们迭代所有的构造函数参数并获取它们的类型:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="24ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在它需要分析参数类型并找出以下内容:</p><ol class=""><li id="b274" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">类型是列表吗？</li><li id="c2fd" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">类型是否可空(项目使用“<a class="ae kw" href="https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references" rel="noopener ugc nofollow" target="_blank">可空引用类型”</a>)？</li><li id="4425" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">该类型是否从我们为其创建“访问者”的基类型(在我们的例子中是接口)继承。</li></ol><p id="a1a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">语义模型为这些问题提供了答案:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="7d2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">注意:方法“AnalyzeSymbol”从集合和可空值中提取实际类型:</em></p><pre class="ky kz la lb gt ls lt lu lv aw lw bi"><span id="1197" class="lx ly iq lt b gy lz ma l mb mc">List&lt;T&gt; =&gt; T (list := true) <br/>T? =&gt; T (nullable := true) <br/>List&lt;T&gt;? =&gt; T (list := true, nullable := true)</span></pre><p id="1ac4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在语义模型中检查基类型比使用反射更复杂，但也是可能的:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="03ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以将所有信息放在一个简单的容器中:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="8f27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并在代码生成中使用它来创建类似于的<a class="ae kw" href="https://github.com/0x1000000/SqExpress/blob/main/SqExpress/SyntaxTreeOperations/Internal/ExprModifier.cs" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="72d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的项目中，我将代码生成作为控制台实用程序运行，但是在。Net 5您将能够将这一代嵌入到项目中，作为一个标记有特殊属性的类，该类将在编译时自动运行以添加缺少的代码部分。这当然比独立的实用程序更方便，但想法是相似的。</p><p id="6fef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我想说，你不应该把这个新功能。Net 5是一个不可思议的创新，它将从根本上改变诸如AutoMapper、ASP.Net核心等库中使用的动态代码生成方法。(我听过这样的观点)不会的！事实上，代码生成工作在一个静态的环境中，在这个环境中，一切都是预先知道的，但是，例如，AutoMapper不知道它将使用什么类，它仍然必须动态地发出代码。然而，在某些情况下，这种代码生成非常有用(我在本文中描述了其中的一种)。所以值得了解一下这个特性，了解一下它的原理和局限性。</p><p id="e2e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(<a class="ae kw" href="https://github.com/0x1000000/SqExpress/blob/main/SqExpress.GenSyntaxTraversal/Program.cs" rel="noopener ugc nofollow" target="_blank">链接到github上的源代码</a>)</p></div></div>    
</body>
</html>