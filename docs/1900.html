<html>
<head>
<title>Building Driver-based Components in Laravel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Laravel中构建基于驱动程序的组件</h1>
<blockquote>原文：<a href="https://itnext.io/building-driver-based-components-in-laravel-5b390dc25bd9?source=collection_archive---------0-----------------------#2019-02-21">https://itnext.io/building-driver-based-components-in-laravel-5b390dc25bd9?source=collection_archive---------0-----------------------#2019-02-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f232" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们来谈谈在laravel中构建基于驱动的组件。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/351421fd1269fe32cc2ebcb70e8c92e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*okY4u4Bx2q2XdHTc"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@arstyy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">奥斯汀·尼尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="0fde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">组件化是构建可扩展和可靠的软件系统的好方法。它允许我们构建由解耦的、独立的和可重用的组件组成的大型系统。它为我们提供了一种构建软件系统的即插即用方法。</p><p id="982e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Laravel作为一个框架，由大量可重用的组件组成——其中一些是第三方Symfony组件——这些组件都是定义良好的，拼凑在一起构成了系统。</p><h1 id="92ef" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">成分</h1><p id="e7e7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">大多数现代软件系统都是通过组装小型的、独立的、可重用的实体来构建的，这些实体为系统提供特定的服务和功能。从本质上讲，软件组件是一个小单元，通常具有定义良好的接口，这些接口构成了更大系统的组成基础。它将一组相关的功能(或数据)封装到一个可重用的单元中。</p><h2 id="811b" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">基于驱动程序的组件</h2><p id="7738" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">组件通常是在软件系统中实施关注点分离的实体。它们是模块化的，负责向应用程序交付特定的服务，例如，处理web应用程序中的状态的会话组件。有趣的是，您可以以某种方式构建组件，允许它们以不同的方式交付服务，同时仍然提供它承诺的相同契约。这是基于驱动程序的组件设计方法。</p><p id="b854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最核心的是，您在设计组件时考虑到了可扩展性，以某种方式允许其默认行为被实现组件契约的对象所替换。</p><p id="462f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">驱动程序是软件系统的组件契约的具体实现。它提供了一个到底层基础设施的接口，组件的服务构建在底层基础设施上。</p><p id="5853" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种驱动程序和基于驱动程序的组件的思想被构建到laravel中，并且它被框架开箱即用地支持。这是我们想要探索的框架的一个方面，看看我们如何在我们的应用程序中使用这个模式来构建基于驱动的组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/d3c6e85bcbcb3bcef86a87a709cb4fbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uQiQNd0Ek-031IQy"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd lx">进入管理者行列！</strong></figcaption></figure></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="92e4" class="lv lw it bd lx ly nm ma mb mc nn me mf jz no ka mh kc np kd mj kf nq kg ml mm bi translated">经理</h1><p id="ea16" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当我们构建基于驱动的组件时，我们需要一种方法来管理它们。我们希望能够创建多个预定义的驱动程序，甚至在应用程序生命周期的后期创建它们。我们希望能够请求特定驱动程序的实例，并且有一个后备驱动程序，当我们没有指定驱动程序时，调用可以代理到这个后备驱动程序。这是一个经理的工作。</p><blockquote class="nr ns nt"><p id="494b" class="kz la nu lb b lc ld ju le lf lg jx lh nv lj lk ll nw ln lo lp nx lr ls lt lu im bi translated">管理器是管理基于驱动程序的组件的创建的实体。它负责根据应用程序的配置创建特定的驱动程序实现。</p></blockquote><p id="f765" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">管理器的设计思想是组件可以有多个驱动程序(以不同方式实现的组件实例)。使用管理器，组件可以定义创建它支持的驱动程序所需的逻辑。管理器充当组件的创建和定制驱动程序的中枢，是组件的入口。</p><p id="5c03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，laravel附带了对管理器的支持，我们希望利用这一点来创建基于驱动程序的组件。让我们更详细地了解一下经理是如何工作的。</p><h1 id="2ae2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">经理阶层</h1><p id="0a53" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Laravel在支持名称空间(<code class="fe ny nz oa ob b">Illuminate\Support\Manager</code>)中提供了一个抽象管理器类。这个类定义了有用的方法来帮助我们管理我们的驱动程序。首先，您需要<code class="fe ny nz oa ob b">extend</code>manager类，并在子类(组件的manager类)中定义驱动程序创建方法。</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="a8ac" class="ms lw it ob b gy og oh l oi oj">use Illuminate\Support\Manager;</span><span id="5a93" class="ms lw it ob b gy ok oh l oi oj">class FooManager extends Manager<br/>{<br/>    //<br/>}</span></pre><h2 id="11fe" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">创建驱动因素</h2><p id="4e39" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当然，创建一个基于驱动的组件需要我们能够创建驱动。管理器类定义了一个<code class="fe ny nz oa ob b">createDriver($driver)</code>方法，它完全按照tin上所说的那样，创建一个新的驱动程序实例。该方法接受单个参数；要创建的驱动程序的名称。它假设扩展类已经定义了创建驱动程序的方法。这些创建方法应该具有以下签名:</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="bf67" class="ms lw it ob b gy og oh l oi oj">create[Drivername]Driver()</span></pre><p id="df32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<code class="fe ny nz oa ob b">Drivername</code>是经过学习后的驱动程序的名称。</p><p id="762f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您在manager类中定义的驱动程序创建方法应该返回驱动程序的一个实例。</p><h2 id="1a6a" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">获取驱动程序</h2><p id="7754" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这就像订购一个优步，你得到一个管理器的实例并在其上调用<code class="fe ny nz oa ob b">driver($driver = null)</code>方法。基本管理器提供了这个方法，它接受一个可选参数；要获取其实例的驱动程序的名称。然后，管理器通过调用您在管理器类中定义的适当的驱动程序创建方法来为您创建驱动程序。如果您没有将想要获得的驱动程序的名称传递给<code class="fe ny nz oa ob b">driver($driver = null)</code>方法，它将返回默认驱动程序的一个实例。</p><h2 id="c495" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">后备驱动程序</h2><p id="6847" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">管理器是一个抽象类，它声明了一个必须由扩展管理器类定义的抽象<code class="fe ny nz oa ob b">getDefaultDriver()</code>方法。当未指定驱动程序时，此方法应返回组件应使用的默认驱动程序的名称。这个后备驱动程序应该作为主要驱动程序。</p><h2 id="cf18" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">扩展组件</h2><p id="e7c0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您可以通过调用管理器上的<code class="fe ny nz oa ob b">extend()</code>方法来添加不是由基于驱动程序的组件预定义的自定义驱动程序。该方法为您提供了一种使用闭包注册自定义驱动程序创建者的方法。当您向管理器请求驱动程序时，它会检查该驱动程序是否存在自定义驱动程序创建者，并调用自定义创建者。注册为定制创建者的闭包在被调用时会收到一个<code class="fe ny nz oa ob b">\Illuminate\Foundation\Application</code>的实例。</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="1036" class="ms lw it ob b gy og oh l oi oj">protected function callCustomCreator($driver)<br/>{<br/>    return $this-&gt;customCreators[$driver]($this-&gt;app);<br/>}</span></pre><blockquote class="nr ns nt"><p id="c543" class="kz la nu lb b lc ld ju le lf lg jx lh nv lj lk ll nw ln lo lp nx lr ls lt lu im bi translated">如果尚未创建，这些自定义驱动程序可以覆盖管理器中同名的预定义驱动程序。</p></blockquote><p id="87eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想了解基本管理器类的完整实现，请访问Github。(本文发布时的Laravel 5.7)</p><div class="ol om gp gr on oo"><a href="https://github.com/laravel/framework/blob/5.7/src/Illuminate/Support/Manager.php" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">laravel/框架</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">在GitHub上创建一个帐户，为laravel/framework开发做贡献。</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">github.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ks oo"/></div></div></a></div></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="df2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，说得够多了，让我们通过在Laravel中构建一个简单的基于驱动程序的SMS组件来看看经理们的表现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/077e1438c164095b4f68e823cc2a5aaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jPRLc1NC8jCCqa9y"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@joannakosinska?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Joanna Kosinska </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="afaa" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">SMS组件</h1><p id="e57e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们想建立一个简单的具有多个驱动程序的SMS组件。开箱即用，该组件将支持三个驱动程序:一个Nexmo驱动程序、一个Twilio驱动程序和一个Null驱动程序。正如我们将在本文后面看到的，我们还可以扩展组件并为其创建自定义驱动程序。</p><p id="cc8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的组件将存在于应用程序的<code class="fe ny nz oa ob b">App\Components\Sms</code>名称空间中。首先，让我们创建组件的ServiceProvider:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="1426" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将我们的<code class="fe ny nz oa ob b">sms</code>组件注册为服务容器中的单例组件，并返回组件管理器的实例(<code class="fe ny nz oa ob b">App\Components\Sms\SmsManager)</code>)。让我们在<code class="fe ny nz oa ob b">config/app.php</code>快速向Laravel注册我们的服务提供商:</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="a9ea" class="ms lw it ob b gy og oh l oi oj">'providers' =&gt; [<br/>    // Other service providers...<br/><br/>    <!-- -->App\Providers\SmsServiceProvider::class,<br/>],</span></pre><p id="68fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们继续定义经理:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="88d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先要注意的是我们的manager类如何扩展Laravel的Manager ( <code class="fe ny nz oa ob b">Illuminate\Support\Manager</code>)。这是在laravel中创建基于驱动的组件的第一步。基础管理器类定义了帮助创建和管理我们的驱动程序的逻辑。因为它是一个抽象类，并且声明了一个必须实现的<code class="fe ny nz oa ob b">getDefaultDriver()</code>方法，所以我们在manager类中定义了该方法，并返回了默认的驱动程序:</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="9440" class="ms lw it ob b gy og oh l oi oj">/**<br/>*<br/><em class="nu">* Get the default SMS driver name.<br/>*<br/>* </em>@return<em class="nu"> </em>string<br/>*/<br/><em class="nu">public</em> function getDefaultDriver()<br/>{<br/>   return $this-&gt;app['config']['sms.default'] ?? 'null';<br/>}</span></pre><p id="4f9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会注意到配置来自于一个配置文件(<code class="fe ny nz oa ob b">config/sms.php</code>)，我们定义它来保存关于组件的信息。这是一个非常简单的文件，包含每个驱动程序的凭证以及要使用的默认驱动程序。如果没有设置默认驱动程序，我们将退回到<code class="fe ny nz oa ob b">NullDriver</code>。</p><p id="af17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了方便地选择使用哪个驱动程序，manager类定义了一个返回指定驱动程序实例的<code class="fe ny nz oa ob b">driver($name)</code>方法。我们为名为<code class="fe ny nz oa ob b">channel($name)</code>的组件创建了一个方便的方法，该方法调用基本的<code class="fe ny nz oa ob b">driver($name)</code>方法，并将我们想要获得的驱动程序的名称传递给它。</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="1a52" class="ms lw it ob b gy og oh l oi oj">/**<br/><em class="nu">* Get a driver instance.<br/>*<br/>* </em>@param<em class="nu">  </em>string|null<em class="nu">  $name<br/>* </em>@return<em class="nu"> </em>mixed<br/>*/<br/><em class="nu">public</em> function channel($name = null)<br/>{<br/>   return $this-&gt;driver($name);<br/>}</span></pre><p id="62b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的驱动程序位于<code class="fe ny nz oa ob b">App\Components\Sms\Drivers</code>名称空间中。为了创建我们的驱动程序，我们定义了3个创建方法来创建组件支持的每个驱动程序。所有驱动程序<code class="fe ny nz oa ob b">extends</code>一个基类<code class="fe ny nz oa ob b">Driver</code>实现我们组件的契约(<code class="fe ny nz oa ob b">App\Components\Sms\Contracts\SMS</code>)。该契约声明了一个<code class="fe ny nz oa ob b">send </code>方法，该方法必须由组件的所有驱动程序实现。这是组件对系统的服务合同，它承诺能够发送SMS。</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="5bd9" class="ms lw it ob b gy og oh l oi oj">&lt;?php</span><span id="e0a0" class="ms lw it ob b gy ok oh l oi oj">namespace App\Components\Sms\Contracts;</span><span id="9d0f" class="ms lw it ob b gy ok oh l oi oj">interface SMS<br/>{<br/>  /**<br/>   <em class="nu">* Send the given message to the given recipient.<br/>   *<br/>   * </em>@return<em class="nu"> </em>mixed<br/>   */<br/>   <em class="nu">public</em> function send();<br/>}</span></pre><p id="0dcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一下<code class="fe ny nz oa ob b">NexmoDriver</code>，看看我们的组件是如何在内部工作的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="e435" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">驱动程序实现了<code class="fe ny nz oa ob b">send</code>方法，并使用Nexmo PHP客户端传递消息。</p><p id="c96c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们设置好我们的组件，也就是说，为我们的组件注册一个facade为<code class="fe ny nz oa ob b">SMS</code>，设置配置文件，并安装我们的依赖项，我们就可以通过获得一个<code class="fe ny nz oa ob b">SmsManager</code>的实例并在其上调用<code class="fe ny nz oa ob b">send</code>方法来快速使用组件。</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="9937" class="ms lw it ob b gy og oh l oi oj">SMS::to($phoneNumber)<br/>    -&gt;content('Building driver-based components in Laravel')<br/>    -&gt;send();</span></pre><p id="f7c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ny nz oa ob b">to($phoneNumber)</code>和<code class="fe ny nz oa ob b">content($message)</code>方法由组件中所有驱动程序扩展的基类<code class="fe ny nz oa ob b">Driver</code>定义。</p><p id="8e14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们没有指定要使用的驱动程序，所以它默认为我们的<code class="fe ny nz oa ob b">Nexmo</code>驱动程序，因为这是我们在组件中设置的默认驱动程序。要指定一个驱动程序，我们可以调用<code class="fe ny nz oa ob b">channel($name)</code>方法或者基础<code class="fe ny nz oa ob b">driver($name)</code>方法。</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="a7c3" class="ms lw it ob b gy og oh l oi oj">SMS::channel('twilio')<br/>    -&gt;to($phoneNumber)<br/>    -&gt;content('Using twilio driver to send SMS')<br/>    -&gt;send();</span></pre><p id="745e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们已经在laravel中成功地创建了一个基于驱动程序的组件。如果你有兴趣看完整的实现，我已经把源代码添加到GitHub中了。</p><div class="ol om gp gr on oo"><a href="https://github.com/orobogenius/building-driver-based-components" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">orobogenius/基于建筑驱动因素的组件</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">关于在laravel中构建基于驱动的组件的文章的演示报告。-orobogenius/基于建筑驱动因素的组件</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">github.com</p></div></div><div class="ox l"><div class="pg l oz pa pb ox pc ks oo"/></div></div></a></div></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="5da7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经创建了组件，我们可以通过扩展组件和添加自定义驱动程序创建者来添加更多的驱动程序。为此，我们获取了一个<code class="fe ny nz oa ob b">SmsManager</code>的实例，并在其上调用了<code class="fe ny nz oa ob b">extend</code>方法。但是首先，我们将创建一个实现组件契约的驱动程序:</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="1e0c" class="ms lw it ob b gy og oh l oi oj">&lt;?php</span><span id="9c69" class="ms lw it ob b gy ok oh l oi oj">use App\Components\Sms\Contracts\SMS;</span><span id="86b9" class="ms lw it ob b gy ok oh l oi oj">class FooSmsDriver implements SmsContract<br/>{<br/>    protected $someDependency;</span><span id="b0ab" class="ms lw it ob b gy ok oh l oi oj">    public function __construct($dependency)<br/>    {<br/>        $this-&gt;someDependency = $dependency;<br/>    }</span><span id="837b" class="ms lw it ob b gy ok oh l oi oj">    <em class="nu">public</em> function send()<br/>    {<br/>       // Define send logic<br/>    }<br/>}</span></pre><p id="3aa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将调用extend方法，并为其提供定制的驱动程序创建逻辑。</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="49f3" class="ms lw it ob b gy og oh l oi oj">SMS::extend('foo', function ($app) {<br/>    return new FooSmsDriver($dependency);<br/>});</span></pre><p id="4a51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们注册了自定义驱动程序创建器，我们现在就可以像使用该组件支持的其他现成驱动程序一样使用它了。</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="8092" class="ms lw it ob b gy og oh l oi oj">SMS::channel('foo')<br/>    -&gt;send();</span></pre><p id="0921" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过测试，我们可以验证该组件能够使用多个驱动程序，包括自定义创建的驱动程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pe pf l"/></div></figure></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="9919" class="lv lw it bd lx ly nm ma mb mc nn me mf jz no ka mh kc np kd mj kf nq kg ml mm bi translated">结论</h1><p id="d0f1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Laravel使得使用管理器类创建基于驱动程序的组件变得很容易。我应该很快指出，在构建基于驱动程序的组件时，总是使用这个管理器类并不是一成不变的，您可以构建自己的管理器来处理组件的驱动程序创建和管理。</p><p id="d949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章是有帮助的，感谢阅读。</p></div></div>    
</body>
</html>