<html>
<head>
<title>Getting Started with Persistent Offline Storage with IndexedDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用IndexedDB开始使用持久脱机存储</h1>
<blockquote>原文：<a href="https://itnext.io/getting-started-with-persistent-offline-storage-with-indexeddb-1af66727246c?source=collection_archive---------3-----------------------#2018-05-02">https://itnext.io/getting-started-with-persistent-offline-storage-with-indexeddb-1af66727246c?source=collection_archive---------3-----------------------#2018-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0fa6784e6b96d0f405dacf3513e06a2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gtlPjMBtqJkgh2c9gtl5MQ.png"/></div></div></figure><h1 id="3b91" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">简介:寻找选择</h1><p id="1fd4" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">随着web技术的进步，创建离线web应用程序的能力越来越接近现实。我写过一些小的在线web应用程序，但从来没有像桌面应用程序那样通过浏览器访问的。所以我决定研究离线存储选项，看看最适合在我想要使用的实际应用程序下创建一个数据库层。</p><p id="70e2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在我的研究中，我发现了以下选择</p><ul class=""><li id="3d4c" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">局部存储器</li><li id="3bf3" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">应用程序缓存</li><li id="4165" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">Web SQL</li><li id="9aa8" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">索引b</li></ul><p id="4db7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这四种存储机制中，我不得不放弃本地存储，因为它只是一种键值存储机制，不太适合需要数据库功能的应用程序。应用程序缓存和Web SQL是不推荐使用的API，我不想冒险在应用程序中使用它们，只是为了删除它们。</p><p id="c9b0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">所以左IndexedDB。让我们深入研究这个API，看看我们能用它做些什么。</p><h1 id="1239" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">从IndexedDB开始</h1><p id="6752" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">IndexedDB是一个异步事务数据库系统，专门为存储大量结构化内容而设计。这很好，因为离线应用程序需要将所有内容存储在浏览器中。根据应用程序的不同，除了文本之外，我们还可能存储大文件(例如，pdf、图像)。</p><p id="67a9" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然而，IndexedDB并不像SQL那样以基于表的列格式存储数据，而是存储在对象存储中，对象存储中存放着由键索引的JavaScript对象。这意味着您不必像创建MySQL那样担心创建预定义的模式，尽管您仍然需要考虑如何存储和组织数据，以便从数据库中高效检索。</p><p id="0f9a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">因此，让我们创建一个小型数据库来保存发票。我们可能希望存储的对象类别有:</p><ul class=""><li id="abbc" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">发票(元数据)</li><li id="f895" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">发票项目(发票上的行项目)</li><li id="c966" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">发票附件(用于发票、提货单等的扫描件。)</li></ul><p id="2f0a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在让我们来创建它！</p><h1 id="b689" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">实施索引b</h1><p id="5a6c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了第一次开始使用IndexedDB，我们需要运行以下代码:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="404a" class="mw jz iq ms b gy mx my l mz na">const request = window.indexedDB.open("database", 1);</span><span id="fddf" class="mw jz iq ms b gy nb my l mz na">// Create schema<br/>request.onupgradeneeded = event =&gt; {<br/>    const db = event.target.result;<br/>    <br/>    const invoiceStore = db.createObjectStore(<br/>        "invoices",<br/>        { keyPath: "invoiceId" }<br/>    );<br/>    invoiceStore.createIndex("VendorIndex", "vendor");</span><span id="317e" class="mw jz iq ms b gy nb my l mz na">    const itemStore = db.createObjectStore(<br/>        "invoice-items",<br/>        { keyPath: [ "invoiceId", "row" ] }<br/>    );<br/>    itemStore.createIndex("InvoiceIndex", "invoiceId");</span><span id="8494" class="mw jz iq ms b gy nb my l mz na">    const fileStore = db.createObjectStore(<br/>        "attachments",<br/>        { autoIncrement: true }<br/>    );<br/>    fileStore.createIndex("InvoiceIndex", "invoiceId");    <br/>};</span></pre><p id="401a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在第一行中，我们开始请求打开名为<code class="fe nc nd ne ms b">database</code>的数据库版本1。由于这是第一次加载数据库，浏览器将找不到具有该名称的数据库，因此请求将触发<code class="fe nc nd ne ms b">onupgradeneeded</code>事件。我们希望创建一个事件处理程序来处理我们创建新数据库的逻辑。</p><p id="ae79" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们从触发的事件中获取结果，该事件是一个表示数据库连接的对象，并将它存储在一个名为<code class="fe nc nd ne ms b">db</code>的变量中。然后，我们在数据库中创建三个对象存储和三个索引。</p><p id="049d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">对<code class="fe nc nd ne ms b">.createObjectStore()</code>的每个调用都有两个参数:一个名称和一个可选的options对象。我们正在创建名为<code class="fe nc nd ne ms b">invoices</code>、<code class="fe nc nd ne ms b">invoice-items</code>和<code class="fe nc nd ne ms b">attachments</code>的商店。但是，我们为每一个都传入了不同的options对象，所以让我们来看一下每一个。</p><p id="b931" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在第一个例子中，我们简单地说，在我们将要存储的每个对象中都有一个名为<code class="fe nc nd ne ms b">invoiceId</code>的属性，数据库应该将这个属性与对象本身配对(这样，当我们查找一个对象时，我们只需要说“get by <code class="fe nc nd ne ms b">invoiceId</code>”。然而，键路径可以是复合的，所以在第二个we中，<code class="fe nc nd ne ms b">invoiceId</code>和<code class="fe nc nd ne ms b">row</code>将作为检索对象的键。最后，对于最后一个商店，通过只传递<code class="fe nc nd ne ms b">autoincrement: true</code>，我们说没有关键路径，数据库应该为我们生成一个。</p><p id="2c5a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">每个对象存储可以有选择地为一个或多个属性创建索引，这允许除了使用键路径之外的另一种检索对象的方法。每个<code class="fe nc nd ne ms b">.createIndex()</code>调用都有一个索引名，以及应该索引什么属性。</p><p id="f32b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">最后要注意的一点是:如果用户再次访问站点并执行相同的连接请求，除非数据库版本增加到更大的整数(在我们的例子中是2或更大)，否则不会触发<code class="fe nc nd ne ms b">onupgradeneeded</code>事件。</p><h1 id="9fe0" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">实现CRUD操作</h1><p id="41f6" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">所有积垢操作的工艺流程如下:</p><ul class=""><li id="58ff" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">打开数据库连接</li><li id="2964" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">开始交易</li><li id="2e60" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">指示要使用哪个对象存储</li><li id="ec00" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">对该商店执行操作</li><li id="0255" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">打扫</li></ul><h2 id="655b" class="mw jz iq bd ka nf ng dn ke nh ni dp ki lh nj nk km ll nl nm kq lp nn no ku np bi translated">创造</h2><p id="6de3" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">要在数据库中创建新的发票，我们需要执行以下操作:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="c539" class="mw jz iq ms b gy mx my l mz na">const request = window.indexedDB.open("database", 1);<br/>request.onsuccess = () =&gt; {<br/>    const db = request.result;<br/>    const transaction = db.transaction(<br/>        [ "invoices", "invoice-items" ],<br/>        "readwrite"<br/>    );<br/>    const invStore = transaction.objectStore("invoices");<br/>    const itemStore = transaction.objectStore("invoice-items");<br/>  <br/>    // Add data<br/>    invStore.add(<br/>        { invoiceId: "123", vendor: "Whirlpool", paid: false }<br/>    );<br/>    itemStore.add({<br/>        invoiceId: "123",<br/>        row: "1",<br/>        item: "Dish washer",<br/>        cost: 1400<br/>    });<br/>    itemStore.add({<br/>        invoiceId: "123",<br/>        row: "2",<br/>        item: "Labor",<br/>        cost: 500<br/>    });</span><span id="de25" class="mw jz iq ms b gy nb my l mz na">    // Clean up: close connection<br/>    transaction.oncomplete = () =&gt; {<br/>        db.close();<br/>    };<br/>};</span></pre><p id="570a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果打开数据库的请求成功，那么<code class="fe nc nd ne ms b">onsuccess</code>事件处理程序将执行事务。我们首先将数据库分配给变量<code class="fe nc nd ne ms b">db</code>，然后在该数据库上打开一个事务，指定它是一个<code class="fe nc nd ne ms b">readwrite</code>操作。<code class="fe nc nd ne ms b">db.transaction()</code>的第一个参数是我们希望事务能够看到的对象存储列表。在我们的例子中，因为有两种类型的数据来表示一张发票，所以我们使用了<code class="fe nc nd ne ms b">invoices</code>和<code class="fe nc nd ne ms b">invoice-items</code>存储。</p><p id="31aa" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后我们访问每个对象存储和数据。一旦事务成功完成，我们就关闭数据库连接。</p><h2 id="c151" class="mw jz iq bd ka nf ng dn ke nh ni dp ki lh nj nk km ll nl nm kq lp nn no ku np bi translated">更新</h2><p id="b2ce" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了更新，我们执行相同的开始步骤(连接到数据库、创建事务和访问对象存储)。假设我们想修改洗碗机系列产品的成本:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="95b9" class="mw jz iq ms b gy mx my l mz na">// ...open database, initiate transaction<br/>const itemStore = objectStore.put({<br/>    invoiceId: "123",<br/>    row: "1",<br/>    item: "Dish washer",<br/>    cost: 1300<br/>});<br/>// ...clean up</span></pre><p id="904a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">该操作将确定键路径(按照上面的模式定义)，并更新该对象。对象本身被在<code class="fe nc nd ne ms b">.put()</code>中指定的对象所覆盖，所以要确保包含所有的原始字段和原始数据，这样文档才不会丢失任何信息。</p><p id="a824" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">对于具有显式定义的键路径的对象存储，没有必要将键作为第二个参数添加。如果我们让数据库自动生成一个键，我们只需要指定这个键。因此，如果我们想要更新我们的<code class="fe nc nd ne ms b">attachments</code>存储中的一个扫描文件，我们会想要执行</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="aa98" class="mw jz iq ms b gy mx my l mz na">attachmentStore.put({ new data}, KEY_NUMBER);</span></pre><p id="7774" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">还有，关于<code class="fe nc nd ne ms b">.put()</code>的最后一点:它有双重功能。如果我们的对象存储中没有发票行<code class="fe nc nd ne ms b">123</code>和行<code class="fe nc nd ne ms b">1</code>，这个方法就会为我们创建它(充当上面的<code class="fe nc nd ne ms b">.add()</code>)。</p><h2 id="1ef3" class="mw jz iq bd ka nf ng dn ke nh ni dp ki lh nj nk km ll nl nm kq lp nn no ku np bi translated">删除</h2><p id="2004" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果我们想要删除发票上的第二行项目，我们所要做的就是指定我们想要从<code class="fe nc nd ne ms b">invoice-items</code>商店中删除的密钥:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="67fa" class="mw jz iq ms b gy mx my l mz na">itemStore.delete([ "123", "2" ]);</span></pre><h2 id="971c" class="mw jz iq bd ka nf ng dn ke nh ni dp ki lh nj nk km ll nl nm kq lp nn no ku np bi translated">阅读</h2><p id="020a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">从数据库中读取数据最不像表单中的其他三个操作，因为为了使数据可用，我们必须实现另一个事件处理程序。让我们获取之前添加到数据库中的发票:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="d9f3" class="mw jz iq ms b gy mx my l mz na">// ...open database, initiate transaction<br/>const getRequest = invStore.get("123");<br/>getRequest.onsuccess = () =&gt; {<br/>    // Do something with the data<br/>    console.log(getRequest.result);<br/>};</span></pre><p id="fa4d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为了获得从我们的对象存储返回的数据，我们必须创建一个<code class="fe nc nd ne ms b">onsuccess</code>事件处理程序。从数据库中提取数据并准备好进行处理后，将触发此事件。由于事务的异步性，有必要使用事件处理程序；我们不希望后面的代码行在数据还不存在的时候就假设数据已经准备好了。</p><p id="a251" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们有什么方法可以处理这种情况？我们可以在<code class="fe nc nd ne ms b">onsuccess</code>处理程序的外部范围内创建一个变量:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="d1a1" class="mw jz iq ms b gy mx my l mz na">let data;</span><span id="0746" class="mw jz iq ms b gy nb my l mz na">const getRequest = invStore.get("123");<br/>getRequest.onsuccess = () =&gt; {<br/>    data= getRequest.result;<br/>};</span></pre><p id="a14f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们仍然要担心这样一个事实，即<code class="fe nc nd ne ms b">getData</code>在函数调用中使用之前可能没有分配给它的数据。因此，虽然它可以工作，但并不理想。</p><p id="a8aa" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我处理这个问题的方法是在get请求逻辑周围创建一个包装器函数，它在<code class="fe nc nd ne ms b">onsuccess</code>处理程序中执行一个回调。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="cdbe" class="mw jz iq ms b gy mx my l mz na">const getFromDB(key, callbackFn) {<br/>    const request = window.indexedDB.open("database", 1);<br/>    request.onsuccess = () =&gt; {<br/>        const db = request.result;<br/>        const transaction = db.transaction("invoices", "readwrite");<br/>        const invStore = transaction.objectStore("invoices");</span><span id="e746" class="mw jz iq ms b gy nb my l mz na">        const get = invStore.get(key);<br/>        get.onsuccess = () =&gt; {<br/>            callbackFn(get.result);<br/>        };<br/>    };<br/>};</span></pre><p id="586d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">通过这种方式，您可以封装处理这些数据所需的所有业务逻辑，并且由于IndexedDB事务的异步特性，您可以确保正确地处理这些数据。</p><p id="27f2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">关于从IndexedDB数据库读取数据，还有一点需要说明:我们也可以使用我们在对象存储上创建的任何索引来完成这项工作。</p><p id="7bd2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">例如，如果我们想获得某个特定供应商的所有发票的列表，我们可以查询索引:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="f833" class="mw jz iq ms b gy mx my l mz na">// ...open database, initiate transaction<br/>const invStore = transaction.objectStore("invoices");<br/>const invIndex = invStore.index("VendorIndex");<br/>const getRequest = invIndex.getAll("Whirlpool");</span><span id="a38a" class="mw jz iq ms b gy nb my l mz na">getRequest.onsuccess = () =&gt; {<br/>    // Do something with the data<br/>    console.log(getRequest.result);<br/>};</span></pre><p id="fc6d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们只需访问对象存储中声明的索引，并运行<code class="fe nc nd ne ms b">.getAll("Whirlpool")</code>从Whirlpool中提取所有发票。我们也可以使用<code class="fe nc nd ne ms b">.get("Whirlpool")</code>，但是这只会返回一个找到的匹配。</p><h1 id="4d3b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="e68c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们简要介绍了如何初始化一个新的数据库，并在其上执行基本的CRUD操作。IndexedDB的内容比本文所能给出的要多得多(只要浏览一下<a class="ae nq" href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" rel="noopener ugc nofollow" target="_blank"> MDN的文档</a>就能发现它有这么多的用处)，随着我了解得越来越多，我希望能写更多关于它们的文章。我将把<a class="ae nq" href="https://gist.github.com/ryandabler/41c458871cb6b64f599fb182ba88daba" rel="noopener ugc nofollow" target="_blank">这个要点</a>作为基本IndexedDB用法的完整示例。</p></div></div>    
</body>
</html>