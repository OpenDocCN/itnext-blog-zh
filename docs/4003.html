<html>
<head>
<title>How to modify incoming HTTP-Headers in Quarkus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Quarkus中修改传入的HTTP头</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-mangle-http-headers-in-quarkus-d91a904adea7?source=collection_archive---------4-----------------------#2020-04-08">https://itnext.io/how-to-mangle-http-headers-in-quarkus-d91a904adea7?source=collection_archive---------4-----------------------#2020-04-08</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><p id="4346" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">与我上一篇文章中的<a class="ae km" href="https://medium.com/@pilhuhn/how-to-rewrite-http-request-paths-in-quarkus-aa85c3400d95" rel="noopener">类似，我们需要对</a><a class="ae km" href="https://quarkus.io/" rel="noopener ugc nofollow" target="_blank"> Quarkus </a>中的传入HTTP-header进行一些更改:用户在没有请求特定媒体类型的情况下调用<em class="kn"> /openapi.json </em>端点<em class="kn"> </em>，这使得Quarkus返回Yaml。</p><figure class="kp kq kr ks gu kt gi gj paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gi gj ko"><img src="../Images/27078dacbd4eca142685da1b684831e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R3EBgLZ-LBBQO3-b8tzW1Q.jpeg"/></div></div><figcaption class="la lb gk gi gj lc ld bd b be z dk translated">图片来源<a class="ae km" href="https://pixabay.com/de/users/succo-96729/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1311577" rel="noopener ugc nofollow" target="_blank">成功</a>失败<a class="ae km" href="https://pixabay.com/de/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1311577" rel="noopener ugc nofollow" target="_blank">图片来源</a></figcaption></figure><p id="23ce" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">用户习惯于假设URL路径的后缀也决定了媒体类型——可能是因为在Windows上是这样的——他们期望调用<em class="kn"> /openapi.json </em>来返回json格式的数据。</p><p id="3138" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">查看<a class="ae km" href="https://github.com/quarkusio/quarkus" rel="noopener ugc nofollow" target="_blank"> Quarkus源代码</a>显示<a class="ae km" href="https://github.com/quarkusio/quarkus/blob/master/extensions/smallrye-openapi/runtime/src/main/java/io/quarkus/smallrye/openapi/runtime/OpenApiHandler.java#L65" rel="noopener ugc nofollow" target="_blank">open API数据的默认媒体类型是Yaml </a>。如果用户需要Json，需要传递一个额外的HTTP Accept头，但用户代码没有提供(因为它已经有了后缀)。</p><h2 id="da6e" class="le lf ir bd lg lh li dn lj lk ll dp lm jz ln lo lp kd lq lr ls kh lt lu lv lw bi translated">Vert.x路由器拯救世界</h2><p id="7c3f" class="pw-post-body-paragraph jo jp ir jq b jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh mb kj kk kl ik bi translated">正如我之前所展示的，所有HTTP请求都通过Quarkus的<a class="ae km" href="https://vertx.io/docs/vertx-web/java/#_basic_vert_x_web_concepts" rel="noopener ugc nofollow" target="_blank"> Vert.x Web路由器</a>层:</p><figure class="kp kq kr ks gu kt gi gj paragraph-image"><div class="gi gj mc"><img src="../Images/43b36357d2aef58a29ceeb421ea813bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*XQunwOIlaM_g5FiEjS0loA.png"/></div><figcaption class="la lb gk gi gj lc ld bd b be z dk translated">Quarkus中HTTP请求的路径</figcaption></figure><p id="c9d0" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">这意味着我们可以使用一个<a class="ae km" href="https://vertx.io/" rel="noopener ugc nofollow" target="_blank">vert . x</a>T22】route filter来完成这项工作:</p><pre class="kp kq kr ks gu md me mf mg aw mh bi"><span id="5c39" class="le lf ir me b gz mi mj l mk ml">@<strong class="me is">RouteFilter</strong>(401)                                          // (1)<br/>void oasAcceptHeaderMangler(RoutingContext <strong class="me is">rc</strong>) {<br/>    if (rc.normalisedPath().endsWith("openapi.json")) {    // (2)<br/>        rc.request().headers().remove("Accept");           // (3)<br/>        rc.request().headers()<br/>                    .add("Accept","application/json");     <br/>    }<br/>    rc.next();                                             // (4)<br/>}</span></pre><p id="626f" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我们在(1)中用<em class="kn"> RouteFilter </em>对该方法进行了注释。如果我们的路径以“openapi.json”结束，我们开始修改请求(2)。当我们查看来自<em class="kn"> RoutingContext </em>的<em class="kn"> normalisedPath() </em>时，我们不需要担心查询参数，不像我在另一篇文章中的情况，我们必须使用HttpRequest-URI。<br/>下一步，当旧的Accpet-Header存在时，我删除它，并添加一个请求Json (3)的Accpet-Header。最后，但同样重要的是，我们告诉Vert.x调用链中的下一个过滤器或分派到下一层(4)。如果我们忘记这一点，夸库斯就会被绞死。</p><h2 id="7141" class="le lf ir bd lg lh li dn lj lk ll dp lm jz ln lo lp kd lq lr ls kh lt lu lv lw bi translated">结论</h2><p id="229f" class="pw-post-body-paragraph jo jp ir jq b jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh mb kj kk kl ik bi translated"><a class="ae km" href="https://vertx.io/docs/vertx-web/java/#_basic_vert_x_web_concepts" rel="noopener ugc nofollow" target="_blank"> Vert.x web路由器</a>是Quarkus中的逻辑点，用于独立于更高层中使用的应用程序框架来修改HTTP请求。在<a class="ae km" href="https://medium.com/@pilhuhn/how-to-rewrite-http-request-paths-in-quarkus-aa85c3400d95" rel="noopener">的上一篇文章</a>中，我们已经看到了如何使用它来改变请求路径。</p><p id="134d" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><a class="ae km" href="https://quarkus.io/guides/reactive-routes" rel="noopener ugc nofollow" target="_blank">反应式路由指南</a>讲述了更多关于Quarkus及其Vert.x网络路由器的信息。</p></div></div>    
</body>
</html>