<html>
<head>
<title>Rails, Webpacker, and Vue CLI Can Actually Play Nicely</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rails、Webpacker和Vue CLI实际上可以很好地发挥作用</h1>
<blockquote>原文：<a href="https://itnext.io/rails-webpacker-and-vue-cli-can-actually-play-nicely-10215fe833e1?source=collection_archive---------1-----------------------#2019-10-03">https://itnext.io/rails-webpacker-and-vue-cli-can-actually-play-nicely-10215fe833e1?source=collection_archive---------1-----------------------#2019-10-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ca0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">(2011年9月6日更新，以指定webpack-assets-manifest包的具体版本，并对vue.config.js稍作修改，以支持Webpack 4) </em></p><p id="9a3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">(2011年9月7日再次更新，修复了热模块替换或实时重新加载，这显然与原始配置无法正常工作)</em></p><h1 id="fa99" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">动机</h1><p id="e9ab" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">当我最初设想写这篇文章时，我完全打算写一篇文章，展示如何集成Rails和Vue CLI(或者甚至Webpack ),而不必使用或接触<a class="ae lp" href="https://github.com/rails/webpacker" rel="noopener ugc nofollow" target="_blank"> Webpacker </a> gem。如果你不熟悉的话，Webpacker是官方的Ruby on Rails集成Webpack的方式。它被合并到Rails 5.1中，并被设置为Rails 6中的默认资产打包系统，有效地取代了<a class="ae lp" href="https://guides.rubyonrails.org/asset_pipeline.html" rel="noopener ugc nofollow" target="_blank">资产管道</a>。那么，如果这个gem是集成Webpack的Rails标准，为什么我要避免使用它呢？我的理由很简单。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="4ebb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我尝试了一下，获得了不同程度的成功。然而，当我试图将它与VueJS结合使用时，遇到了一些突出的问题。</p><p id="9ec2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，文档处于过渡状态。这是在Webpacker 4正式发布之前。版本3强迫我使用特定VueJS NPM包的旧版本，比如<a class="ae lp" href="https://github.com/ktsn/vue-template-loader" rel="noopener ugc nofollow" target="_blank"> vue-template-loader </a>。Webpacker 4有预发行版本，但是缺少文档(我相信现在也是)。</p><p id="bd8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其次，这与我的第一点密切相关，我的终端收到了大量警告。从没完没了地抱怨javascript解析器到过时的NPM依赖项，尽管我尽了最大努力，还是无法更新到最新最好的版本。</p><p id="bac5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第三，也是我的主要观点，Webpacker gem似乎强迫你以一种非常Ruby-on-Rails特有的方式进行Webpack配置。虽然为开发、测试和生产使用单独的配置本身并没有什么错，而且我也很喜欢使用webpacker.yml配置文件，但我不喜欢的是它从本质上劫持了Webpack配置并夺走了我的控制权，同时给幕后发生的事情增加了一定程度的神秘/ WTF时刻。这也有效地让你在使用Webpacker和Vue CLI之间做出选择。</p><p id="07d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Webpacker将配置从您手中拿走的主要方式是将一个NPM依赖项注入到名为“@rails/webpacker”的package.json文件中。这是一个作为Webpacker gem本身的一部分管理和创建的包。简单看一下回购的这一部分，就能看出一个方案的侵入性和广泛性:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi lx"><img src="../Images/a551fcf061cbaa95f2119215172abce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yIm3EihAA8m67aZS874lEg.png"/></div></div></figure><p id="8a2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这有很多文件，更糟糕的是，这些文件中有很多Rails的神奇之处。如果除了在webpacker.yml配置文件中可以修改的内容之外，您并不真正关心Webpack的配置，那么这可能很好。但是如果你想做一些微调，毫无疑问，你首先会发现自己在研究Webpack的文档，然后你可能需要钻研Webpacker的文档，以了解如何以Ruby on Rails的方式做同样的事情。如果在那里找不到答案，你可能不得不开始钻研Webpacker的源代码，而这正是我发现自己正在做的事情。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="f188" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与资产管道不同，Webpack是一个完全存在于Ruby on Rails领域之外的工具。依我拙见，使用它最有效的方法是直接使用，而不是局限于特定的、通常是旧版本的依赖项中。想用Vue CLI 3这种前沿的东西会怎么样？根本没有这样做的机制。如果您只是使用Webpacker Vue安装程序，您肯定不会使用Vue CLI和它提供的所有功能和灵活性。</p><p id="b1b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有人可能会说，如果你想使用像Vue CLI这样的工具，你可以简单地创建一个连接到任何后端的独立项目，包括Rails。好吧，我同意你的说法。但是，假设(无论出于什么原因，您认为有必要)您希望将所有代码放在一个地方，并且您可能希望在Vue应用程序和Rails应用程序之间共享诸如样式和脚本之类的资产？那么将它们构建到同一个项目中可能是有意义的。</p><p id="91dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我第一次提到的，我最初试图在没有Webpacker的情况下连接Ruby on Rails和Webpack。我甚至为我工作的公司<a class="ae lp" href="https://www.mobilecause.com/" rel="noopener ugc nofollow" target="_blank"> MobileCause </a>创建了一个概念证明。我深入到Webpacker源代码中，以弄清楚他们是如何解决某些问题的，比如代理、Rails和Vue之间的共享配置、webpack-dev-server的检测、前端资源变更的检测、manifest.json文件的生成等。我甚至在我们的代码库中重新利用了Webpacker代码的小片段来支持这种集成。随着我在这个集成中添加更多的功能，我发现自己越来越深入地钻研Webpacker的源代码。在我在我们的知识库中全面复制他们的源代码之前，我决定可能值得再尝试使用这个宝石。然而，这一次，我带着尽可能使用Webpacker的Rails端代码的心态去做，但是自己做所有的Webpack配置。下面是在你自己的项目中可以遵循的步骤。</p><h1 id="dacd" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">安装Webpacker</h1><p id="3270" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">首先，要么用Webpack生成一个新的Rails应用程序并禁用链轮/资产管道，要么将webpacker gem添加到现有项目中</p><pre class="ly lz ma mb gt mj mk ml mm aw mn bi"><span id="5ae5" class="mo kn iq mk b gy mp mq l mr ms">// ------ FOR A NEW RAILS APPLICATION --------<br/>// From command line<br/>rails new webpackerapp --skip-sprockets --webpack<br/>// -------------------------------------------</span><span id="6674" class="mo kn iq mk b gy mt mq l mr ms">// ------ FOR AN EXISTING RAILS APPLICATION --<br/>// Add to Gemfile:<br/>gem 'webpacker'<br/>// From command line<br/>bundle install<br/>// ------ FOR RAILS &gt;= 5 ---------------------<br/>bundle exec rails webpacker:install<br/>// ------ FOR RAILS &lt; 5 ----------------------<br/>bundle exec rake webpacker:install<br/>// -------------------------------------------</span></pre><p id="882f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">注意:Webpacker需要Rails 4.2或更高版本。运行上面的install命令，您可能会在尝试运行上面的rake命令时收到一个错误，类似于“没有这样的文件或目录-”。/bin/rake (LoadError)"。如果是这种情况，这仅仅意味着您的项目可能是在使用新的Rails应用程序自动生成binstubs之前创建的(这在Rails 4中的某个时候开始发生)。只需运行“rake rails:update:bin”来生成它们，然后重新运行安装命令。</em></p><h1 id="5d65" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">撕掉Webpacker的大部分</h1><p id="880b" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">现在Webpacker已经安装好了，有趣的部分来了:让我们把它的大部分拆出来:</p><pre class="ly lz ma mb gt mj mk ml mm aw mn bi"><span id="e787" class="mo kn iq mk b gy mp mq l mr ms">rm -rf node_modules/ package.json yarn.lock babel.config.js config/webpack app/javascript .browserslistrc postcss.config.js</span></pre><p id="3fd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">他们进来了，大多数人出去了。事实上，应该只剩下三个特定于Webpacker的文件:</p><ul class=""><li id="fb52" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated">“config/webpacker.yml”:该文件将作为在Rails应用程序(使用Webpacker gem)和前端应用程序之间共享配置数据的一种方式，我们将在前端应用程序中配置该文件以从中读取</li><li id="4923" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">“bin/webpack”:web packer gem使用这个文件来构建用于生产的web pack条目文件。Webpacker gem修改了Rake assets:precompile任务，以便在我们进行部署时在我们的生产服务器上编译我们的Webpack条目文件</li><li id="8fb6" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">“bin/webpack-dev-server”:我们不会以任何有意义的方式使用这个文件；然而，Webpacker gem依赖于它的存在来编译我们的代码，所以我们保留它仅仅是因为这个原因。</li></ul><p id="9ea2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上，Webpacker gem的Ruby端的所有东西都依赖于这三个文件的存在，我们将很好地利用前两个文件。但是首先，让我们使用Vue CLI创建一个Vue应用程序。</p><h1 id="d035" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用Vue CLI生成Vue应用程序</h1><p id="fd34" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">请确保您已经安装了<a class="ae lp" href="https://cli.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue CLI 3 </a>所需的所有软件包。如果一切安装正确，就可以开始生成Vue应用程序了。在本次演示中，我将在名为“frontend”的子目录中的Rails目录“app”中生成Vue应用程序:</p><pre class="ly lz ma mb gt mj mk ml mm aw mn bi"><span id="7930" class="mo kn iq mk b gy mp mq l mr ms">// From command line, within the root directory of the project<br/>cd app<br/>vue create frontend<br/>// For my app, I chose "Manually select features",<br/>//  then added CSS Preprocessors, dart-scss, and<br/>//  ESLint + Standard Configuration, Lint on Save,<br/>//  and dedicated config files<br/>cd frontend</span></pre><h1 id="3b36" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">模仿Webpacker的组织和设置</h1><p id="db69" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">好了，现在我们已经有了Vue CLI生成的文件，我们将把它们移到我们的root Rails目录中，代替由Webpacker安装的文件。</p><pre class="ly lz ma mb gt mj mk ml mm aw mn bi"><span id="b408" class="mo kn iq mk b gy mp mq l mr ms">// From command line, within the app/frontend directory<br/>mv node_modules/ yarn.lock package.json babel.config.js ../..<br/>// There may be additional files to move depending on your<br/>//   selections when generating the app using Vue CLI<br/>cd ../..</span></pre><p id="22cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，回到Rails应用程序的根目录，我们将安装“@rails/webpacker”已经为我们安装的一个关键依赖项(如果我们没有删除它):<a class="ae lp" href="https://www.npmjs.com/package/webpack-assets-manifest" rel="noopener ugc nofollow" target="_blank"> webpack-assets-manifest </a>。该Webpack插件将自动生成一个manifest.json文件，其中包括Webpack托管资产与其Webpack生成路径之间的映射:</p><pre class="ly lz ma mb gt mj mk ml mm aw mn bi"><span id="05a8" class="mo kn iq mk b gy mp mq l mr ms">// From command line, within the root directory of the project<br/>yarn add -D webpack-assets-manifest@3.1.1<br/>// Note: the @3.1.1 is a recent edit from 09/06/21 as newer versions of the package appear not to work properly with vue ui</span></pre><p id="04cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们对位于config/webpacker.yml中的Webpacker配置文件做一些小的修改:</p><ol class=""><li id="4681" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk ni na nb nc bi translated">将“source_path”属性更改为“app/frontend/src”</li><li id="5bf0" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk ni na nb nc bi translated">将“source_entry_path”属性更改为空字符串' '<br/>这是上述“source_path”指定目录内的目录，所有条目文件都将位于该目录中。默认情况下，Webpackser假设您希望将所有的条目文件放在它们自己的名为pack的目录中。这可能只是个人偏好的问题，但是Vue应用程序中的惯例似乎总是将这些文件放在src目录的根级别；因此，将这个值设置为空字符串可以确保遵循这个Vue约定。</li><li id="9782" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk ni na nb nc bi translated">将“hmr”属性(嵌套在开发/dev_server中)更改为true。这将在webpack dev服务器运行时启用热模块替换或livereload。</li></ol><p id="d155" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们也借此机会改变Webpacker构建入口点的方式。我们将修改“bin/webpack”脚本，使用Yarn和Vue CLI进行编译，而不是使用Webpacker的内部设置进行编译。打开“bin/webpack ”,将内容更改为:</p><pre class="ly lz ma mb gt mj mk ml mm aw mn bi"><span id="5f39" class="mo kn iq mk b gy mp mq l mr ms">#!/usr/bin/env ruby<br/>ENV["NODE_ENV"] ||= "development"</span><span id="d38a" class="mo kn iq mk b gy mt mq l mr ms">Dir.chdir(File.expand_path("..", __dir__)) do<br/>  Kernel.exec(ENV, "yarn build")<br/>end</span></pre><p id="6042" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进行这些更改将有效地修改Rake任务“webpacker:compile ”,以使用我们的Vue CLI应用程序生成的package . JSON“build”任务进行构建。这也将改变Rake任务“assets:precompile”在将我们的应用程序部署到生产环境时的运行方式。</p><h1 id="ac57" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用Vue CLI共享Webpacker的配置</h1><p id="0a39" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">通过在root Rails目录下创建一个名为“vue.config.js”的文件，可以配置Vue CLI应用程序，而不仅仅是现成的。下面是我使用的带注释的配置文件:</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="fcaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实际上，我们读取了安装webpacker时包含的YAML配置文件“webpacker.yml”。我们使用该文件中的各种配置来构建我们的Vue Webpack配置。这包括动态确定入口点、生成manifest.json文件的配置、指定webpack dev服务器设置等。</p><h1 id="9894" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">在Rails中使用Webpacker</h1><p id="08c4" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">好了，现在我们已经大致准备好了开始使用Webpacker从Webpack Dev服务器提供资产，并使用Vue CLI进行配置。让我们生成一个简单的例子，把所有的部分都拉进来。</p><p id="9fdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们生成一个简单的控制器和动作</p><pre class="ly lz ma mb gt mj mk ml mm aw mn bi"><span id="2706" class="mo kn iq mk b gy mp mq l mr ms">// From command line<br/>rails generate controller pages index</span></pre><p id="f6a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进入布局文件“app/views/layouts/application . html . erb ”,将对“stylesheet_link_tag”和“javascript_include_tag”的调用替换为:</p><pre class="ly lz ma mb gt mj mk ml mm aw mn bi"><span id="1556" class="mo kn iq mk b gy mp mq l mr ms">&lt;%= stylesheet_packs_with_chunks_tag 'main' %&gt;</span></pre><p id="6a1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就在body标记结束之前，添加下面一行:</p><pre class="ly lz ma mb gt mj mk ml mm aw mn bi"><span id="7583" class="mo kn iq mk b gy mp mq l mr ms">&lt;%= javascript_packs_with_chunks_tag 'main' %&gt;</span></pre><p id="969c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进入模板文件“app/views/pages/index ”,将文件内容替换为:</p><pre class="ly lz ma mb gt mj mk ml mm aw mn bi"><span id="3a88" class="mo kn iq mk b gy mp mq l mr ms">&lt;div id="app"&gt;&lt;/div&gt;</span></pre><p id="c44f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe nl nm nn mk b">rails server</code>在一个选项卡中启动您的服务器，使用<code class="fe nl nm nn mk b">yarn serve </code>在另一个选项卡中启动webpack-dev-server，并通过访问<a class="ae lp" href="http://localhost:3000/pages/index" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/pages/index</a>查看您的页面。</p><p id="38eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果一切正常，您应该会看到类似如下的页面:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi no"><img src="../Images/a5b4d0074f6a935864e5ddc22382d2d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mBKhzhB9LZFUZ3Zjux1MoQ.png"/></div></div></figure><h1 id="52bb" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">包扎</h1><p id="4aca" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">如果你的页面渲染正确，恭喜你！您已经成功地将Webpacker与Vue CLI集成在一起。通过修改Vue应用程序中的代码，比如修改“app/frontend/src/App.vue”，继续尝试热模块重载。您几乎可以立即在网页上看到变化。</p><p id="6a50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您也可以尝试退出webpack-dev-server并再次点击页面。这一次，由于它首先需要编译，所以可能需要更长一点的时间，但是随后的加载应该几乎是即时的。但是，如果您对Webpacker管理的任何资产进行了更改，Webpacker将在您下次重新加载页面时自动重新编译。</p><p id="aa76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您部署您的应用程序时，Webpacker将自动注入到assets:precompile步骤中，并且应该使用NODE_ENV production来构建您的代码。</p><p id="8805" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们可能会涉及到更多内容，比如如何利用VueCLI自动注入但Rails会丢失的预取和预加载链接，如何从Webpack渲染ERB模板，如何结合Rails的路由器使用Vue-router的历史模式等，但我会将这些内容留到以后的文章中讨论。</p><p id="4be6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我欢迎反馈、建议或故障排除请求，希望本文对您有所帮助。</p></div></div>    
</body>
</html>