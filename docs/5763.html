<html>
<head>
<title>My Dream Programming Language</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我梦想中的编程语言</h1>
<blockquote>原文：<a href="https://itnext.io/my-dream-programming-language-707e33466c23?source=collection_archive---------1-----------------------#2021-05-20">https://itnext.io/my-dream-programming-language-707e33466c23?source=collection_archive---------1-----------------------#2021-05-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0baa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在使用不同的编程语言一段时间后，我开始考虑构建自己的语言。我就是这么想出来的！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/11811575d55106ae5c1515204631dbeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I_0orFFpJzuwGWRozQp1DQ.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@waguluz_" rel="noopener ugc nofollow" target="_blank">安德里亚斯·瓦格纳</a>在<a class="ae le" href="https://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="19f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我一直对编程语言很着迷。每种编程语言都有自己的语法、语义和范例。</p><p id="a18a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果必须选择如何实现自己的编程语言，你会怎么做？这是我对Inferi的想法，一种编程语言。</p><h1 id="6f2a" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">索引</h1><ul class=""><li id="ce48" class="md me it js b jt mf jx mg kb mh kf mi kj mj kn mk ml mm mn bi translated">类型和语法</li><li id="6fc8" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated">内置数据结构</li><li id="3724" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated">函数！函数！函数！</li><li id="5c26" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated">不纯函数</li><li id="7347" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated">故障处理</li><li id="417d" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated">示例程序</li><li id="7fa8" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated">项目状态</li></ul><h1 id="093d" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">类型和语法</h1><p id="cff1" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">Inferi是一种静态类型的编程语言。它使用亨德利·米尔纳类型系统进行类型签名。让我们定义一个简单的<code class="fe mw mx my mz b">add</code>函数，它将两个数字相加:</p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="4473" class="ne lg it mz b gy nf ng l nh ni">@spec add : Int -&gt; Int -&gt; Int<br/>add (x y) -&gt;<br/>  x + y</span></pre><p id="9931" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">括号是完全可选的，所以来自类似于C语言的开发人员会发现使用这种语言更容易:</p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="8db1" class="ne lg it mz b gy nf ng l nh ni">@spec add : Int -&gt; Int -&gt; Int<br/>add (x y) -&gt; {<br/>  x + y<br/>}</span></pre><p id="85f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，类型注释是完全可选的，可以在编译时推断出来(<strong class="js iu"> REPL </strong>示例):</p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="5298" class="ne lg it mz b gy nf ng l nh ni">&gt; let add x y -&gt; x + y<br/>&gt; "add : Int -&gt; Int -&gt; Int"</span></pre><p id="9259" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Inferi </strong>让您可以访问类型类，这样您就可以像下面这样重构<code class="fe mw mx my mz b">add</code>类型签名(就像在<strong class="js iu"> Haskell </strong>中一样):</p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="f4cd" class="ne lg it mz b gy nf ng l nh ni">@spec add Num a =&gt; a -&gt; a -&gt; a<br/>add (x y) -&gt; {<br/>  x + y<br/>}</span></pre><p id="ff8f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">函数将总是自动编译，以便(例如)T2函数可以利用部分应用:</p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="fc46" class="ne lg it mz b gy nf ng l nh ni">@spec add : Int -&gt; Int -&gt; Int<br/>add (x y) -&gt; {<br/>  x + y<br/>}<br/><br/>@spec add5 -&gt; Int -&gt; Int<br/>add5 -&gt; add 5<br/><br/>main -&gt; {<br/>  print add5(10)  -- 15<br/>  print add(10 5) -- 15<br/>}</span></pre><p id="5769" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个Inferi程序都需要一个<code class="fe mw mx my mz b">main</code>函数，这个函数将是程序本身的入口点:</p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="7892" class="ne lg it mz b gy nf ng l nh ni">main -&gt; println "Hello, World!"</span></pre><h1 id="b925" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">内置数据结构</h1><p id="b015" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">Inferi提供了一组有用的内置数据结构，例如:</p><p id="b90c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">地图</strong></p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="9a6e" class="ne lg it mz b gy nf ng l nh ni">data MapExample = {<br/>  firstName : String,<br/>  lastName  : String,<br/>  nickname  : String<br/>}</span><span id="1e19" class="ne lg it mz b gy nj ng l nh ni">@spec mapExample -&gt; Map(MapExample)<br/>mapExample -&gt; {<br/>  %{<br/>    firstName: "Michele",<br/>    lastName:  "Riva",<br/>    nickname:  "Mitch"<br/>  }<br/>}</span></pre><p id="afe1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">列出了</strong></p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="8d62" class="ne lg it mz b gy nf ng l nh ni">@spec listExample -&gt; [Int]<br/>listExample -&gt; [10, 50, 20, 1010, 20391, 2039484]</span></pre><p id="4344" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">元组</strong></p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="700d" class="ne lg it mz b gy nf ng l nh ni">@spec tupleExample -&gt; {String, Float, Bool}<br/>tupleExample -&gt; {"I am a string", -30.02, true}</span></pre><h1 id="558d" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">函数！函数！函数！</h1><p id="c37e" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">阴尸从<strong class="js iu">哈斯克尔</strong>和<strong class="js iu">仙丹</strong>身上都拿了很多。</p><p id="2b31" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以通过创建不同的函数来对多个值进行模式匹配，就像在<strong class="js iu"> Haskell </strong>中一样(愚蠢的例子):</p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="70fe" class="ne lg it mz b gy nf ng l nh ni">@spec greet : String -&gt; String<br/>greet ("Mitch") -&gt; "Hello, Mitch!"<br/>greet ("Jona")  -&gt; "Hello, Jona!"<br/>greet (_)       -&gt; "Hello, stranger!"</span></pre><p id="bced" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，您可以将传递的参数绑定到变量:</p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="9cae" class="ne lg it mz b gy nf ng l nh ni">@spec greet : String -&gt; String<br/>greet ("Mitch") -&gt; "Hello, Mitch!"<br/>greet ("Jona")  -&gt; "Hello, Jona!"<br/>greet (name)    -&gt; "Hello, ${name}!"</span></pre><p id="2599" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以使用<strong class="js iu">管道</strong>操作符来组合函数:</p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="1a8a" class="ne lg it mz b gy nf ng l nh ni">@spec scream : String -&gt; String<br/>scream (str) -&gt; {<br/>  str<br/>    |&gt; upcase<br/>    |&gt; (\x -&gt; "${x}!!!") -- Lambda function, just like in Haskell<br/>}</span></pre><p id="6633" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者像Haskell中那样奉承:</p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="48f7" class="ne lg it mz b gy nf ng l nh ni">@spec scream : String -&gt; String<br/>scream (str) -&gt; str · upcase · (\x -&gt; "${x}!!!")</span></pre><p id="2fd5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，lambda函数支持用于lambda函数的Elixir <strong class="js iu">捕获运算符</strong>:</p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="cd65" class="ne lg it mz b gy nf ng l nh ni">@spec scream : String -&gt; String<br/>scream (str) -&gt; str · upcase · (&amp; "${&amp;1}!!!")<br/>--                              ^     ^ Here we say that we want to use the first argument of our lambda function<br/>--                              ^ Here we say that this is a lambda functions</span></pre><h1 id="e5d3" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">不纯函数</h1><p id="e0cd" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">与Haskell不同，<strong class="js iu"> Inferi </strong>不是一种纯粹的函数式编程语言，它允许我们编写一些支持不纯计算的函数。</p><p id="994a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">功能不纯:</strong></p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="8917" class="ne lg it mz b gy nf ng l nh ni">import http (call) -- import the "call" function from the "http" library<br/>import list (push)</span><span id="9b38" class="ne lg it mz b gy nj ng l nh ni">data RESTPeople = {<br/>  name : String `json:"name"` -- a little bit of Golang<br/>  age  : Int    `json:"age"`<br/>}</span><span id="8a17" class="ne lg it mz b gy nj ng l nh ni">@spec callRestAPI : Either(Error [String])<br/>callRestAPI? -&gt; {<br/>  let mut people : [String]<br/>  let mut callResult : [RESTPeople]</span><span id="344e" class="ne lg it mz b gy nj ng l nh ni">  &amp;callResult &lt;- await call("https://my-rest-api.com/get-people")</span><span id="eb56" class="ne lg it mz b gy nj ng l nh ni">  for person in callResult -&gt; {<br/>    { name, age } = person<br/>    if age &gt;= 18 {<br/>      push(people, name)<br/>    }<br/>  }</span><span id="3455" class="ne lg it mz b gy nj ng l nh ni">  return people<br/>}</span></pre><p id="c65d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们从<code class="fe mw mx my mz b">http</code>库导入<code class="fe mw mx my mz b">call</code>函数，从<code class="fe mw mx my mz b">list</code>库<br/>导入<code class="fe mw mx my mz b">push</code>，我们定义一个<code class="fe mw mx my mz b">type</code>(在这种情况下，实际上类似于<strong class="js iu"> Golang </strong> structs)来声明哪个值需要从REST API的JSON响应中解码。</p><p id="0222" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">之后，我们定义一个名为<code class="fe mw mx my mz b">callRestAPI</code>的函数，它返回一个单子(带有<code class="fe mw mx my mz b">mut</code>关键字或其他不纯计算的函数必须返回一个单子，参见失败处理段落)。</p><p id="ddd1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们声明一个可变的<code class="fe mw mx my mz b">people</code>变量，它是一个字符串列表。我们声明可变的<code class="fe mw mx my mz b">callResult</code>变量，它将包含REST响应。</p><p id="5c2d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们最终可以调用我们的REST API，并将调用的结果放在<code class="fe mw mx my mz b">callResult</code>变量中。<br/>之后，我们循环结果(这是一个<code class="fe mw mx my mz b">RESTPeople</code>列表),并使用<code class="fe mw mx my mz b">push</code>函数更新之前创建的列表<code class="fe mw mx my mz b">people</code>。</p><p id="f159" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为我们函数的最后一条语句，我们需要使用<code class="fe mw mx my mz b">return</code>关键字，它将结果包装成一个单子。<br/>如果出现错误，它会将错误封装在<code class="fe mw mx my mz b">Left</code>结果中，否则它会填充单子的<code class="fe mw mx my mz b">Right</code>结果。</p><p id="3469" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">纯对应:</strong></p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="ce1c" class="ne lg it mz b gy nf ng l nh ni">import http (call?)</span><span id="340f" class="ne lg it mz b gy nj ng l nh ni">data RESTPeople = {<br/>  name : String `json:"name"`<br/>  age  : Int    `json:"age"`<br/>}</span><span id="3e12" class="ne lg it mz b gy nj ng l nh ni">@spec callRestAPI : Either(Error [String])<br/>callRestAPI? -&gt; {<br/>  return $<br/>    (await call?("https://my-rest-api.com/get-people") : [RESTPeople])<br/>      |&gt; filter(&amp; &amp;1.age &gt;= 18 )<br/>      |&gt; map(&amp; drop(&amp;1, "age"))<br/>}</span></pre><p id="f563" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您还可以通过使用管道操作符更纯粹地编写相同的函数。<br/>操作符<code class="fe mw mx my mz b">$</code>用在<code class="fe mw mx my mz b">return</code>之后，用于替换圆括号，就像在Haskell中一样。</p><h1 id="4a1b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">故障处理</h1><p id="6667" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">功能总是会失败。这就是为什么<strong class="js iu"> Inferi </strong>想要提供三种不同的方法来处理和避免运行时错误，如下所示:</p><p id="1596" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 1)模式匹配:</strong></p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="b19f" class="ne lg it mz b gy nf ng l nh ni">divide (x y) -&gt; x / y<br/>divide (x 0) -&gt; error "You can't divide by 0"</span><span id="4c09" class="ne lg it mz b gy nj ng l nh ni">main -&gt; {<br/>  divide (10 5) -- 2<br/>  divide (10 0) -- Runtime error: You can't divide by 0<br/>}</span></pre><p id="b310" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 2)一元故障处理:</strong> <br/>可以在函数名后面加上<code class="fe mw mx my mz b">?</code>，这样它会把函数输出封装成一个<code class="fe mw mx my mz b">Either</code>一元:</p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="0916" class="ne lg it mz b gy nf ng l nh ni">@spec divide : Either (Num a =&gt; a -&gt; a -&gt; a)<br/>divide? (x y) -&gt; x / y</span><span id="8aa5" class="ne lg it mz b gy nj ng l nh ni">main -&gt; {<br/>  divide?(10 5) -- Right (10)<br/>  divide?(10 0) -- Left (Error{reason: "Division by 0", args: {10, 0}})<br/>}</span></pre><p id="8f53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果出现运行时错误，<strong class="js iu"> Inferi </strong>将通过返回一个包含错误原因和传递的参数的struct让您知道(便于调试)。</p><p id="4650" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您也可以自己实现<strong class="js iu">一元故障处理</strong>:</p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="95c1" class="ne lg it mz b gy nf ng l nh ni">@spec divide : Either (Num a =&gt; a -&gt; a -&gt; a)<br/>divide? (x y) -&gt; {<br/>  try {<br/>    result = x / y<br/>    Right(result)<br/>  } catch error -&gt; {<br/>    println (error) -- you can debug the error, send it to Sentry,<br/>                    -- do whatever you want<br/>    Left(Error{reason: "You can't divide by 0!"}) -- The arguments will <br/>                                                  -- automatically be attached runtime<br/>  }<br/>}</span></pre><p id="b3e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3)使用状态元组:</strong> <br/>就像在Elixir/Erlang中一样，可以返回一些表示你的计算结果的元组。这不能防止运行时错误，但这是定义不同类型函数的最佳实践:</p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="4d9e" class="ne lg it mz b gy nf ng l nh ni">@spec divide! : Num a =&gt; a -&gt; a -&gt; Status(a)<br/>--          ^ it is best practice to set `!` after the function name for telling<br/>--            that you're returning a Status tuple</span><span id="ba21" class="ne lg it mz b gy nj ng l nh ni">divide! (x y) (when y == 0) -&gt; {:error, 0, "Division by 0"}<br/>--           ^ Please note this Erlang-style guards</span><span id="1a34" class="ne lg it mz b gy nj ng l nh ni">divide! (x y) -&gt; {<br/>  result = x / y<br/>  {:ok, result, ""}<br/>}</span><span id="6281" class="ne lg it mz b gy nj ng l nh ni">main -&gt; {<br/>  print divide(10 5) -- {:ok, 2, ""}<br/>  print divide(10 0) -- {:error, 0, "Division by 0"}<br/>}</span></pre><p id="a9db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Status是一个私有类型，表示<code class="fe mw mx my mz b">:ok</code>或<code class="fe mw mx my mz b">:error</code>原子(取自Elixir/Erlang atoms):</p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="bb86" class="ne lg it mz b gy nf ng l nh ni">type Status a   -&gt; {Atom, a, String}<br/>type Status a b -&gt; {Atom, a, b}</span></pre><p id="6a31" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如你在上面的定义中看到的，我们可以将参数传递给我们的类型。<br/>这意味着我们可以根据我们编写的函数定义不同的<code class="fe mw mx my mz b">Status</code>类型。</p><p id="a1f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，这将会失败:</p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="0372" class="ne lg it mz b gy nf ng l nh ni">@spec divideFloat! : Float -&gt; Float -&gt; Status(Float)<br/>divideFloat! (x y) (when y == 0.0) -&gt; {:error, 0, "Division by 0"}</span><span id="0b28" class="ne lg it mz b gy nj ng l nh ni">-- The 0 passed to the Status tuple is of Int type, but the Status Tuple<br/>-- wants a Float (so, 0.0)!</span></pre><p id="f81d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但这是可行的:</p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="ea69" class="ne lg it mz b gy nf ng l nh ni">@spec divideFloat! : Float -&gt; Float -&gt; Status(Float)<br/>divideFloat! (x y) (when y == 0.0) -&gt; {:error, 0.0, "Division by 0"}</span></pre><p id="cc38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如您在<code class="fe mw mx my mz b">Status</code>定义中看到的，我们还可以通过显式传递第三个tuple元素的类型来自定义它:</p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="e188" class="ne lg it mz b gy nf ng l nh ni">@spec doSomethingCool : String -&gt; String -&gt; Status(String Maybe(Error))<br/>doSomethingCool (str1 str2) -&gt; {<br/>  returningString       = "${str1} ${str2}"<br/>  {:ok, returningString, Nothing}<br/>}</span><span id="d0a0" class="ne lg it mz b gy nj ng l nh ni">main -&gt; {<br/>  print doSomethingCool ("Michele" "Riva") -- {:ok, "Michele Riva", Nothing}<br/>}</span></pre><h1 id="16ff" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">示例程序</h1><p id="c7d9" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">让我们只使用<strong class="js iu"> Inferi </strong>标准库编写一个非常简单的web服务器:</p><pre class="kp kq kr ks gt na mz nb nc aw nd bi"><span id="5982" class="ne lg it mz b gy nf ng l nh ni">import webserver<br/>import system (env)</span><span id="31d4" class="ne lg it mz b gy nj ng l nh ni">{--<br/>  Here we get the port number that we want to expose<br/>  from our webserver.<br/>--}</span><span id="ab30" class="ne lg it mz b gy nj ng l nh ni">@spec port : Int<br/>port -&gt; {<br/>  case env("PORT") -&gt; {<br/>    | Just(env_port) -&gt; read env_port -- automatic unwrap, is this OCaml?<br/>    | Nothing        -&gt; 8000 <br/>  }<br/>}</span><span id="b06a" class="ne lg it mz b gy nj ng l nh ni">{--<br/>  We then specify a list of tuples which represents<br/>  our webserver routes.<br/>--}</span><span id="1cfa" class="ne lg it mz b gy nj ng l nh ni">@spec routes : [webserver.Route]<br/>routes -&gt; {<br/>  [<br/>    {"/",            indexController}<br/>  , {"/about",       aboutController}<br/>  , {"/greet/:name", greetController}<br/>  ]<br/>}</span><span id="0cd2" class="ne lg it mz b gy nj ng l nh ni">{-- Here we write down some controllers --}</span><span id="d452" class="ne lg it mz b gy nj ng l nh ni">@spec indexController : [webserver.Req] -&gt; [webserver.Res]<br/>indexController (_ res) -&gt; {<br/>  res.json(%{        -- hey! Is this Express.js?<br/>    success: true<br/>  })<br/>}</span><span id="2224" class="ne lg it mz b gy nj ng l nh ni">@spec aboutController : [webserver.Req] -&gt; [webserver.Res]<br/>aboutController (_ res) -&gt; {<br/>  res.render("about.html") -- oh Express.js, here we meet again<br/>}</span><span id="17e7" class="ne lg it mz b gy nj ng l nh ni">@spec greetController : [webserver.Req] -&gt; [webserver.Res]<br/>greetController (req res) -&gt; {<br/>  %{ name } = Req.path -- destructure the request path and get the "name" variable</span><span id="cc0f" class="ne lg it mz b gy nj ng l nh ni">  case name -&gt; {<br/>    | ""   -&gt; res.json(%{success: false, message: "Who should I greet?"})<br/>    | name -&gt; res.json(%{success: true, message: "Hello, ${name}!"})<br/>  }<br/>}</span><span id="34f4" class="ne lg it mz b gy nj ng l nh ni">{-- our main function --}</span><span id="4ea8" class="ne lg it mz b gy nj ng l nh ni">main -&gt; {<br/>  webserver.start(%{<br/>    routes -- Hey is this JavaScript? <br/>  , port<br/>  })<br/>}</span></pre><h1 id="2b7d" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">项目状态</h1><p id="2131" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">整个项目只是一个想法。<br/>没有编译器，没有规范，就这篇文章。</p><p id="59f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在你可能会疑惑:“Inferi真的很像Haskell，Rust，Elixir，OCaml你为什么要写这个？”。</p><p id="28f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我相信软件开发的未来是功能性的。但是即使这样，纯粹的函数式编程对许多人来说还是很难，我们需要一种语言，它既是命令式的又是函数式的，从两个世界中取长补短。由于这个原因，我认为未来的编程语言将会是翻转的，而Inferi将会是我未来构建这种语言的努力方向。</p></div></div>    
</body>
</html>