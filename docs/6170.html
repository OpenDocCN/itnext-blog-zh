<html>
<head>
<title>Easy Modular Monolith — Part 3 — Logging (Serilog and Seq)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简易模块化整体式测井仪—第3部分—测井(Serilog及以下)</h1>
<blockquote>原文：<a href="https://itnext.io/easy-modular-monolith-part-3-logging-57caceac1ff5?source=collection_archive---------6-----------------------#2021-09-06">https://itnext.io/easy-modular-monolith-part-3-logging-57caceac1ff5?source=collection_archive---------6-----------------------#2021-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e0fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在一个完美的世界里，IT系统中没有漏洞和维护的位置。作为开发人员，我们更喜欢交付新东西，而不是维护旧代码和修复错误。但是在大多数软件系统中，我们必须维护一些东西，修复一些问题或者改变当前实现的逻辑。<br/> <br/>如何让我们的生活更轻松，让我们做上面的事情快很多？<br/>从<strong class="jp ir">开始实施测井！</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/22566791fe7b760f16653013b87401e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*erVqlTKQ7b1wnZhdBRMNKQ.jpeg"/></div></div></figure><h2 id="e8d6" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">什么是日志记录？</h2><p id="0db4" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">日志记录是存储有关系统中发生的事件的信息的操作。存储的信息称为日志。<br/>日志记录是可观察性的三大支柱之一，与跟踪和指标并列。<br/>由于它提供了事件的上下文数据，因此我们可以节省大量故障排除时间。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lv"><img src="../Images/e40cae08b044a153fcb5c1cad27cbe36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ftDIHsfJFi6vq1FRWVnddA.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">来自ModularMonolith应用程序的示例日志</figcaption></figure><h2 id="de08" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">我们应该记录什么？</h2><p id="9e73" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">实现日志记录最关键的部分是它应该主要用作诊断工具。<br/>日志记录不应包含任何敏感数据，如密码、令牌和任何被视为隐私和机密的东西。</p><h2 id="15a4" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">在我们的示例中，我们将重点关注日志记录:</h2><ul class=""><li id="23ce" class="ma mb iq jp b jq lq ju lr jy mc kc md kg me kk mf mg mh mi bi translated">请求流—能够跟踪执行流。</li><li id="1ab8" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">性能统计—对缓慢的请求进行故障排除。</li><li id="5c95" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">例外—为了更容易维护和修复错误。</li></ul><h1 id="af5a" class="mo ky iq bd kz mp mq mr lc ms mt mu lf mv mw mx li my mz na ll nb nc nd lo ne bi translated">履行</h1><h2 id="fd07" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">要求:</h2><ul class=""><li id="b281" class="ma mb iq jp b jq lq ju lr jy mc kc md kg me kk mf mg mh mi bi translated">至少在两个地方记录信息——我们应该能够在控制台(对于开发环境)和文件(对于生产环境)中看到日志。</li><li id="cb37" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">我们应该能够从appsettings.json文件中更改配置。</li><li id="ef6f" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">实现应该是灵活的，允许我们很容易地添加更多的“接收器”(保存日志的地方)。</li></ul><p id="e26e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">记住这些要求，让我们实现一个解决方案。</p><h2 id="9c09" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">测井工具</h2><p id="d4f9" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">首先，我们应该选择测井工具。有几个选项值得考虑，但根据我的经验<strong class="jp ir"> Serilog* </strong>是正确的选择。</p><h2 id="ef92" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">为什么是Serilog？</h2><ul class=""><li id="5b2f" class="ma mb iq jp b jq lq ju lr jy mc kc md kg me kk mf mg mh mi bi translated">使用方便</li><li id="db17" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">灵活的</li><li id="8368" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">出色的文档</li><li id="514d" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">接收器插件(MsSql，Seq等)。</li></ul><h2 id="7ca5" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">代码:</h2><p id="5c30" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">让我们在我们的<strong class="jp ir">模块中安装Serilog NuGet包。基础设施</strong>项目:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/11b36c8851d5630e3ce57b2b271702ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K4EpPP--IPzGhEl3NjTUyg.png"/></div></div></figure><p id="9884" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们创建一个新的扩展方法，它将为我们注册一个日志记录器。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="3619" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码试图从appsettings . JSON(14–16)中解析变量，然后用相应的“接收器”注册一个日志记录器。</p><p id="66e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">配置文件如下所示:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/b81af2c54b126b75d4f8aa2b3cfbae41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*u63E0rbVGvRWJo1_Sz0-_Q.png"/></div></figure><ul class=""><li id="a90f" class="ma mb iq jp b jq jr ju jv jy nj kc nk kg nl kk mf mg mh mi bi translated"><strong class="jp ir"> EnableConsole </strong>和<strong class="jp ir"> EnableFile </strong>将告诉日志记录器哪个sink log</li><li id="4788" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir">文件路径</strong> —启用EnableFile时文件的路径。该路径将包含我们的日志文件。</li><li id="a11c" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir">日志级别</strong> —告诉记录器哪些日志应该写入“接收器”。只会记录所选级别及以上级别的日志。</li></ul><p id="f2e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir"> WebApi </strong>项目中，让我们添加新的扩展——这将在应用程序中启用logger。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="3582" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看，如果我们运行应用程序并尝试向某个端点发出请求，现在会发生什么:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nm"><img src="../Images/89776520046c64acda8e2dce21e87933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eQN5tPmbMYrujRW_Y45XGA.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">控制台中的记录器输出</figcaption></figure><p id="6948" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您在上面的图像中所看到的，控制台输出中列出了所有重要的消息。相同的输出被保存到服务器硬盘上的文件中，这样我们就可以在应用程序关闭的情况下恢复它。如果需要，我们可以在应用程序中添加新的接收器。取决于我们到底想要实现什么有多个Serilog sinks扩展。</p><p id="48c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里找到所有可用的水槽:<br/><a class="ae nn" href="https://github.com/serilog/serilog/wiki/Provided-Sinks" rel="noopener ugc nofollow" target="_blank">https://github.com/serilog/serilog/wiki/Provided-Sink</a></p><h2 id="d95f" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">SEQ</h2><p id="fb82" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated"><a class="ae nn" href="https://datalust.co/seq" rel="noopener ugc nofollow" target="_blank"> Seq </a>是专为现代结构化日志数据构建的智能搜索、分析和警报服务器。它将允许我们以非常方便的方式查看日志。<br/>让我们看看如何轻松地将其添加到ModularMonolith解决方案中。</p><p id="fe88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，为seri log:<br/><a class="ae nn" href="https://github.com/serilog/serilog-sinks-seq" rel="noopener ugc nofollow" target="_blank">https://github.com/serilog/serilog-sinks-seq</a><br/>安装一个额外的接收器，然后我们将更新我们的LoggerConfiguration类。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="32ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第32行我们看到了一个新的部分——我们需要做的就是调用新的WriteTo方法。<br/>作为参数，我们应该传递Seq服务器的URL地址和API键。</p><p id="f8fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何设置序列服务器</p><ul class=""><li id="5fae" class="ma mb iq jp b jq jr ju jv jy nj kc nk kg nl kk mf mg mh mi bi translated">将其安装在您的计算机/服务器上。</li><li id="6d8e" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">通过使用Docker。</li></ul><p id="9684" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在本文中使用第二种方法:</p><p id="17d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先在你的机器上安装docker:<br/><a class="ae nn" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank">https://www.docker.com/products/docker-desktop</a><br/>然后你需要做的就是在你的控制台中调用它:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="32e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，当我们转到<a class="ae nn" href="http://localhost:5341/" rel="noopener ugc nofollow" target="_blank"> http://localhost:5341/ </a>时，我们应该会看到一个seq页面:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi no"><img src="../Images/a52b3377d1fb2944d9903569faf960cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*53k8RMKAlcOzIHmLpXz2cg.png"/></div></div></figure><p id="0931" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了让我们的日志出现在这个页面上，我们还需要做一件事。<br/>导航到:<a class="ae nn" href="http://localhost:5341/#/settings/api-keys" rel="noopener ugc nofollow" target="_blank">http://localhost:5341/#/settings/api-keys</a>并创建一个在我们的应用程序中用于配置sink的API密钥:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi np"><img src="../Images/44dd26bf74af085ea5dc3fe78bddda04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5v69NuGKFJEA8J137gWpTA.png"/></div></div></figure><h1 id="f459" class="mo ky iq bd kz mp mq mr lc ms mt mu lf mv mw mx li my mz na ll nb nc nd lo ne bi translated">摘要</h1><p id="8314" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">日志提供了关于请求流、完成请求所需的时间以及应用程序中发生的所有异常的信息。有了这些信息，我们能够更快地解决问题。</p><p id="7a88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Seq这样的工具可以更快更有效地处理日志，特别是当我们是支持团队的时候:)</p><p id="4e9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一篇文章中，我们将看看全局异常处理，以及如何记录来自任何模块的信息。</p><h1 id="f9f8" class="mo ky iq bd kz mp mq mr lc ms mt mu lf mv mw mx li my mz na ll nb nc nd lo ne bi translated">完整代码可在此处获得:</h1><p id="b07d" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated"><a class="ae nn" href="https://github.com/Ridikk12/ModularMonolith/tree/Logging" rel="noopener ugc nofollow" target="_blank">https://github.com/Ridikk12/ModularMonolith/tree/Logging</a></p><h1 id="dbee" class="mo ky iq bd kz mp mq mr lc ms mt mu lf mv mw mx li my mz na ll nb nc nd lo ne bi translated">上一个:</h1><div class="nq nr gp gr ns nt"><a href="https://ridikk12.medium.com/easy-modular-monolith-part-2-the-outbox-pattern-b4566724fb68" rel="noopener follow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">简易模块化整体结构—第2部分—发件箱模式</h2><div class="oa l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">ridikk12.medium.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og kv nt"/></div></div></a></div><h2 id="9ae7" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">在下一部分:</h2><ul class=""><li id="69cf" class="ma mb iq jp b jq lq ju lr jy mc kc md kg me kk mf mg mh mi bi translated">异常处理—可观察性</li></ul><h1 id="ebf7" class="mo ky iq bd kz mp mq mr lc ms mt mu lf mv mw mx li my mz na ll nb nc nd lo ne bi translated">将来(此列表可能会更改):</h1><ul class=""><li id="e910" class="ma mb iq jp b jq lq ju lr jy mc kc md kg me kk mf mg mh mi bi translated">认证/授权</li><li id="b4e2" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">发件箱改进。</li><li id="1a89" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">域事件。</li><li id="b75d" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">单元/集成测试。</li><li id="459c" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">存储配置。</li><li id="9142" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">模块之间的直接通信。</li><li id="ee36" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">数据库方法(多个数据源)。</li><li id="6741" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">准备微服务(用RabbitMq代替MediatR)。</li><li id="00c1" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">迁移到微服务。</li></ul><h1 id="3e3b" class="mo ky iq bd kz mp mq mr lc ms mt mu lf mv mw mx li my mz na ll nb nc nd lo ne bi translated">参考资料:</h1><div class="nq nr gp gr ns nt"><a href="https://serilog.net/" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">Serilog -简单。具有完全结构化事件的. NET日志记录</h2><div class="oh l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">Serilog消息模板是一个简单的DSL扩展。NET格式字符串。参数可以被命名，它们的值是…</h3></div><div class="oa l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">serilog.net</p></div></div></div></a></div><div class="nq nr gp gr ns nt"><a href="https://docs.datalust.co/docs/getting-started-with-docker" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">Docker入门</h2><div class="oh l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">序列在Docker上可作为datalust/seq获得。Seq的基于Linux的Docker映像非常适合部署到Linux主机和…</h3></div><div class="oa l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">docs.datalust.co</p></div></div></div></a></div><h2 id="2402" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">值得检查:</h2><p id="15ef" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">https://github.com/serilog/serilog-settings-configuration<a class="ae nn" href="https://github.com/serilog/serilog-settings-configuration" rel="noopener ugc nofollow" target="_blank">—作为我们定制代码的替代方案，整个Serilog配置可以通过appsettings.json文件使用这个包来完成。</a></p></div></div>    
</body>
</html>