<html>
<head>
<title>How to compute the Betweenness Centrality against open source graph database NebulaGraph</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何计算开源图数据库NebulaGraph的中间中心度</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-compute-the-betweenness-centrality-against-open-source-graph-database-nebulagraph-f922d196dce?source=collection_archive---------2-----------------------#2022-09-13">https://itnext.io/how-to-compute-the-betweenness-centrality-against-open-source-graph-database-nebulagraph-f922d196dce?source=collection_archive---------2-----------------------#2022-09-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/21332f24300739474af5a94e56e6920b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gJ_bIN_6vLC-zNwD.jpg"/></div></div></figure><p id="49ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">中间中心性(简称BC)反映了顶点在整个网络中的重要性。本文将介绍如何通过<a class="ae kw" href="https://nebula-graph.io" rel="noopener ugc nofollow" target="_blank">星云图</a>计算图形数据库的中间中心度。</p><h1 id="6be1" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">相关概念</h1><p id="8d40" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><strong class="ka ir">中心性</strong>表示一个顶点在整个网络图中的中心程度，包括度中心性、接近中心性、中间中心性等。度中心性通过计算顶点的传入和传出边的数量来反映顶点的受欢迎程度，而接近中心性计算图中顶点和所有其他顶点之间的最短路径的长度之和。因此，一个顶点越中心，它离所有其他顶点就越近。</p><p id="320d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">中间中心性</strong>统计一个顶点在任意两个其他顶点之间的最短路径上出现的次数，以此来表示这个顶点对于网络连通性的<strong class="ka ir">重要性。</strong></p><p id="4c43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">顶点的介数中心性</strong>是所有最短路径中通过该顶点的路径数占最短路径总数的比例。</p><p id="c23f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">计算图中顶点的介数中心性可以在带权图或不带权图中进行。</strong>对于未加权图，广度优先搜索(简称BFS)用于寻找最短路径，而Dijkstra算法用于加权图。</p><p id="5ff5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的算法都是针对无向图的。</p><h1 id="90bc" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">适用场景</h1><p id="12ba" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">中间中心性通过测量顶点如何桥接图或网络中的所有其他顶点来反映顶点在整个网络中的重要性。我们可以看到，下图中的顶点C充当了一个重要的桥接顶点。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/b2089d34d7f8bfdcf3188b4869ca743d.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*5Q5ir0XQ8zn3RIH7.png"/></div></figure><p id="b667" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">中间中心性</strong>可以用来识别</p><p id="a585" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">a.<strong class="ka ir">反欺诈场景中的中介实体</strong>金融风险控制领域。</p><p id="c6fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">b.<strong class="ka ir">特定疾病控制基因</strong>在医学领域提高药物靶点。</p><h1 id="fafd" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">中间中心性算法</h1><p id="727c" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">顶点的介数中心性可以计算如下:</p><p id="7979" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">CB=∑s≠v≠t∈Vσst(v)σst</p><p id="eeb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(公式1)</p><p id="222d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个公式中，</p><p id="fccf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">σst(v)是从<code class="fe mf mg mh mi b">Vertex s</code>到<code class="fe mf mg mh mi b">Vertex t</code>的最短路径数。</p><p id="3ef2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">σst是通过<code class="fe mf mg mh mi b">Vertex v</code>的最短路径数。</p><p id="0565" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mf mg mh mi b">Vertex s</code>和<code class="fe mf mg mh mi b">Vertex t</code>是属于顶点集的一对顶点。</p><p id="b43e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为方便起见，每对顶点的介数可以计算如下:</p><p id="e237" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">δst(v)=σst(v)σst</p><p id="d96c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(公式2)</p><p id="166e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，公式1可以用公式2代替，从而得到公式3，如下所示:</p><p id="1d4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">CB(v)=∑s≠v≠t∈Vδst(v)</p><p id="c872" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(公式3)</p><h1 id="a3dd" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">求解过程</h1><p id="280d" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">为了得到<code class="fe mf mg mh mi b">Vertex v</code>的中间中心性，即得到$$\frac{，我们需要知道<code class="fe mf mg mh mi b">Vertex v</code>是否位于从<code class="fe mf mg mh mi b">Vertex s</code>到<code class="fe mf mg mh mi b">Vertex t</code>的路径上。</p><p id="264e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(1)为了知道<code class="fe mf mg mh mi b">Vertex v</code>是否在从<code class="fe mf mg mh mi b">Vertex s</code>到<code class="fe mf mg mh mi b">Vertex t</code>的最短路径上，使用下面的公式dG表示从<code class="fe mf mg mh mi b">Vertex s</code>到<code class="fe mf mg mh mi b">Vertex t</code>的最短路径:</p><p id="eb3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果<code class="fe mf mg mh mi b">Vertex v</code>位于从<code class="fe mf mg mh mi b">Vertex s</code>到<code class="fe mf mg mh mi b">Vertex t</code>的最短路径上，则满足G(s，t)=dG(s，v)+dG(v，t)。</p><p id="e104" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(公式4)</p><p id="5cc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">dG(s，v)和dG(v，t)是相互独立的。根据组合规则，从<code class="fe mf mg mh mi b">Vertex s</code>到<code class="fe mf mg mh mi b">Vertex t</code>的最短路径总数是从<code class="fe mf mg mh mi b">Vertex s</code>到<code class="fe mf mg mh mi b">Vertex t</code>的最短路径数和从<code class="fe mf mg mh mi b">Vertex s</code>到<code class="fe mf mg mh mi b">Vertex t</code>的最短路径数的乘积。</p><p id="a295" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基于以上两种情况，可以推导出公式5:</p><p id="315a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">σst(v)={σsv×σvtif d(s，v)+d(v，t)=d(s，t) 0if other</p><p id="b1e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(公式5)</p><p id="b46b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(2)根据上面的公式，我们可以得出结论:从<code class="fe mf mg mh mi b">Vertex s</code>到<code class="fe mf mg mh mi b">Vertex t</code>经过<code class="fe mf mg mh mi b">Vertex w</code>的最短路径数是σst(w)=σsw×σwt的结果。</p><p id="a827" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在图中，<code class="fe mf mg mh mi b">Vertex v</code>是<code class="fe mf mg mh mi b">Vertex w</code>的前一个顶点。因此，计算从<code class="fe mf mg mh mi b">Vertex s</code>到<code class="fe mf mg mh mi b">Vertex t</code>经过<code class="fe mf mg mh mi b">Vertex v</code>到<code class="fe mf mg mh mi b">Vertex w</code>的最短路径数的公式为:</p><p id="bbf6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">σst(v，v，w)=σsv×σwt</p><p id="c482" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(公式6)</p><p id="c2dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有两种情况，t=wandt≠w。</p><p id="0808" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">a.如果t=w，那么σwt将不存在，我们可以得到</p><p id="a40a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">δ(v，v，w)=σsvσsw</p><p id="2a0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(公式7)</p><p id="f0b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">b.如果≠w，那么我们可以得到</p><p id="4d55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">δ(v，v，w)=σsw(v)σsw×σst(w)σst</p><p id="655a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(公式8)</p><p id="1168" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(3)所以，考虑到以上两种情况，我们可以得到</p><p id="5baa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">δs(v)=∑w:v∈Ps(w)(σSW(v)σSW+∑t≠w∈vσSW(v)σSW×σST(w)σST)=∑w:v∈Ps(w)σSW(v)σSW(1+∑t≠w∈vσST(w)σST)=∑w:v∈Ps(w)σ</p><p id="f754" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(公式9)</p><p id="806c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Inw:v∈Ps(w)，<code class="fe mf mg mh mi b">Vertex v</code>是<code class="fe mf mg mh mi b">Vertex s</code>到<code class="fe mf mg mh mi b">Vertex w</code>路径中<code class="fe mf mg mh mi b">Vertex w</code>的前身。</p><p id="dbed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(4)根据上面得到δsv的公式，未加权图的介数中心性的算法流程可以给出如下:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/9b89307ea39c1f9108edf4e98a5ee8cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ejNag5CvTgjD2EV7.png"/></div></div></figure><p id="0d36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于未加权的图形，遵循上述过程。</p><p id="4723" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">计算加权图中的介数中心性需要Dijkstra算法，即在第一个while循环中改变代码。</p><p id="e43a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">针对星云图的介数中心性实现了加权图和非加权图的算法。代码见<a class="ae kw" href="https://github.com/vesoft-inc/nebula-algorithm/blob/master/nebula-algorithm/src/main/scala/com/vesoft/nebula/algorithm/lib/BetweennessCentralityAlgo.scala" rel="noopener ugc nofollow" target="_blank">https://github . com/vesoft-Inc/nebula-algorithm/blob/master/nebula-algorithm/src/main/Scala/com/vesoft/nebula/algorithm/lib/betwenescentralyalgo . Scala</a>。</p><h1 id="291c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">计算示例</h1><p id="1071" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">首先读取星云图中的图形数据，指定数据读取的边缘数据。</p><p id="830e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其次，根据星云图的边数据制作拓扑图，并进行中心性计算。</p><p id="4347" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在星云图中读取的图形数据可以在下面的未加权图形中进行说明:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/d3df102d963818dc0434ba59bef2016a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G8mtKSEcka4j9hek.png"/></div></div></figure><p id="e566" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">计算顶点1的BC:</strong></p><p id="bea9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">路径最短的顶点对经过顶点1。</p><p id="3b64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顶点对之间最短路径的总数。</p><p id="e24b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过顶点12–43(2–3–4，2–5–4，2–1–4)1的最短路径数</p><p id="c89c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顶点1的BC:1/3</p><p id="ef34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">计算顶点2的BC:</strong></p><p id="e2d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过顶点2的最短路径的顶点对</p><p id="bfc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顶点对之间最短路径的总数</p><p id="3ecb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过顶点21–32(1–2–3，1–4–3)13–52(3–2–5，3–4–5)1的最短路径数</p><p id="0469" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">计算顶点3的BC:</strong>:</p><p id="0746" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过顶点3的最短路径的顶点对</p><p id="3365" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顶点对之间最短路径的总数</p><p id="c695" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过顶点32–43(2–3–4，2–5–4，2–1–4)1的最短路径数</p><p id="f5d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顶点3的BC:1/3</p><p id="200c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">计算顶点4的BC:</strong>:</p><p id="4328" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过顶点4的最短路径的顶点对</p><p id="555b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顶点对之间最短路径的总数</p><p id="44f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过顶点41–32(1–4–3，1–2–3)13–52(3–4–5，3–2–5)1的最短路径数</p><p id="5285" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">计算顶点5的BC:</strong>:</p><p id="245d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过顶点5的最短路径的顶点对</p><p id="9412" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顶点对之间最短路径的总数</p><p id="1220" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过顶点52–43(2–3–4，2–5–4，2–1–4)1的最短路径数</p><p id="7553" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顶点5的BC:1/3</p><p id="15c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以每个顶点的BC是:顶点1: 1/3顶点2: 1顶点3: 1/3顶点4: 1顶点5: 1/3</p><h1 id="a022" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结果示例</h1><p id="8b84" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">数据:读取星云图测试中的边数据，取srcId、dstId、rank作为拓扑图中边的三元组(源顶点、目的顶点、Rank)。</p><pre class="mb mc md me gt ml mi mm mn aw mo bi"><span id="6854" class="mp ky iq mi b gy mq mr l ms mt">(root@nebula) [test]&gt; match (v:node) -[e:relation] -&gt; ()  return e<br/>+------------------------------------+<br/>| e                                  |<br/>+------------------------------------+<br/>| [:relation "3"-&gt;"4" @1 {col: "f"}] |<br/>+------------------------------------+<br/>| [:relation "2"-&gt;"3" @2 {col: "d"}] |<br/>+------------------------------------+<br/>| [:relation "2"-&gt;"5" @4 {col: "e"}] |<br/>+------------------------------------+<br/>| [:relation "4"-&gt;"5" @2 {col: "g"}] |<br/>+------------------------------------+<br/>| [:relation "1"-&gt;"5" @1 {col: "a"}] |<br/>+------------------------------------+<br/>| [:relation "1"-&gt;"2" @3 {col: "b"}] |<br/>+------------------------------------+<br/>| [:relation "1"-&gt;"4" @5 {col: "c"}] |<br/>+------------------------------------+</span></pre><p id="31ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">读取星云图中的边数据，将该图设置为未加权，计算每个顶点的介数中心性。结果如下:</p><pre class="mb mc md me gt ml mi mm mn aw mo bi"><span id="956f" class="mp ky iq mi b gy mq mr l ms mt">vid: 4 BC: 1.0<br/>vid: 1 BC: 0.3333333333333333<br/>vid: 3 BC: 0.3333333333333333<br/>vid: 5 BC: 0.3333333333333333<br/>vid: 2 BC: 1.0</span></pre><p id="96d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">读取<a class="ae kw" href="https://nebula-graph.io" rel="noopener ugc nofollow" target="_blank"> NebulaGraph </a>的边数据，将图设为加权，计算每个顶点的介数中心性。结果如下:</p><pre class="mb mc md me gt ml mi mm mn aw mo bi"><span id="a2d0" class="mp ky iq mi b gy mq mr l ms mt">vid: 4 BC: 2.0<br/>vid: 1 BC: 0.5<br/>vid: 3 BC: 1.0<br/>vid: 5 BC: 2.0<br/>vid: 2 BC: 0.0</span></pre><h1 id="8aa2" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">参考</h1><ul class=""><li id="99c0" class="mu mv iq ka b kb lv kf lw kj mw kn mx kr my kv mz na nb nc bi translated">论文:一种快速的中间中心性算法</li><li id="1e6e" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">Python的NetworkX实现中间中心性的源代码:<a class="ae kw" href="https://github.com/networkx/networkx/blob/master/networkx/algorithms/centrality" rel="noopener ugc nofollow" target="_blank">https://github . com/NetworkX/NetworkX/blob/master/NetworkX/algorithms/Centrality</a></li></ul></div></div>    
</body>
</html>