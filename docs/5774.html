<html>
<head>
<title>Designing an opinionated functional API (Typescript) 🔺 🔻</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计自以为是的功能API(类型脚本)🔺 🔻</h1>
<blockquote>原文：<a href="https://itnext.io/designing-an-opinionated-functional-api-typescript-e7e89e8ab338?source=collection_archive---------1-----------------------#2021-05-22">https://itnext.io/designing-an-opinionated-functional-api-typescript-e7e89e8ab338?source=collection_archive---------1-----------------------#2021-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/765fec845e6a7cba3c25572d6bd42ecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*yRv_WRRG99s-5NBravykhg.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">这张图片是一个伟大的“石器时代的女王”专辑的艺术作品</figcaption></figure><p id="9caf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我打算与你分享我选择的处理我领导的项目中的错误的方法，以及我选择向我的用户公开的功能API。</p><p id="0484" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">处理错误是设计API时的一个关键部分，因为最终你编写的优秀软件会失败，而不是以一种来自你的代码或你使用的第三方的神秘异常的形式，或者以一种更好的分类错误的形式。</p><p id="0198" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个程序可能因为很多原因而失败，例如，当物理资源被超过时的运行时崩溃，或者由于误用或未处理的异常等等..</p><p id="a8ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将错误视为返回的数据类型迫使您映射所有可能的失败并解决它们。</p><p id="b6b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">回到我的案例，让我们对错误进行分类</strong></p><p id="35bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我遇到了程序中会导致错误的部分。<br/>在这种情况下，我们希望指出具体的失败，所以我们将定义一个枚举类型，将这种情况表示为<strong class="ka ir"> ErrorType </strong>。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi kw"><img src="../Images/b6512e0903461f4ee59ffcc023577afc.png" data-original-src="https://miro.medium.com/v2/resize:fit:96/0*EjcVCv4l9qJQ0pj8"/></div></figure><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="86f0" class="lg lh iq lc b gy li lj l lk ll">export enum ErrorType {<br/>    <em class="lm">UnsupportedFormat </em>= 'UnsupportedFormat',<br/>    <em class="lm">InvalidParameter </em>= 'InvalidParameter'<br/>}</span></pre><p id="06cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，我们将定义一个引用errorType的类型。<br/>此时，我们刚刚创建了一个数据/模型表示，我们的目标是使我们的开发体验更加流畅。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="18c1" class="lg lh iq lc b gy li lj l lk ll">export interface ErrorClassification {<br/>  message: string;<br/>  type: ErrorType;<br/>}</span></pre><p id="8952" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">**旁注—在这里使用enum而不是const enum并不是禁忌...</p><p id="f41e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们基本上想要标记一个错误案例，并将其传递给程序的下一部分进行处理。</p><p id="c0b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我受到了Rust lang的启发，我想创建一个结果类型，以提供一个密切的开发体验。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="9f4a" class="lg lh iq lc b gy li lj l lk ll">export type Result&lt;E, T&gt; = Error&lt;E&gt; | Just&lt;T&gt;;<br/>type Just&lt;T&gt; = T;<br/>type Error&lt;E&gt; = Just&lt;E&gt;; //LOL :)</span></pre><p id="9989" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了知道在运行时Result将返回哪种类型，我创建了isError() util。util包含一个E类型的约束来扩展我的特定错误分类类型+双重检查我自己的错误分类的“消息”和“类型”属性的存在性..</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ln lo l"/></div></figure><h2 id="8a49" class="lg lh iq bd lp lq lr dn ls lt lu dp lv kj lw lx ly kn lz ma mb kr mc md me mf bi translated">随波逐流</h2><p id="4522" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">花点时间想想下面的函数返回类型。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="70ba" class="lg lh iq lc b gy li lj l lk ll">function koko(input: string): <strong class="lc ir">Result&lt;ErrorClassification, string&gt;</strong> {<br/>  if (...leadToErr) {<br/>    return {<br/>      message: 'cannot use given input',<br/>      type: ErrorType.badInput,<br/>    };<br/>  }<br/>  return doSomethingWitthInput(input);<br/>}</span></pre><p id="390d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为以下项目的替代方案:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="5193" class="lg lh iq lc b gy li lj l lk ll">function koko(input: string): <strong class="lc ir">string</strong> {<br/>  if (...leadToErr) {<br/>    throw new <strong class="lc ir"><em class="lm">Error</em></strong>('cannot use given input');<br/>  }<br/>  return doSomethingWitthInput(input);<br/>}</span></pre><p id="3c36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，使用<strong class="ka ir">结果</strong>类型会立即告诉你这段代码可能会返回一个失败。</p><p id="912d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二段代码表明这个函数只是返回一个字符串，但是:<br/> 1。我应该有一个注释来记录这个函数可能抛出一个错误。<br/> 2。一旦抛出一个错误，程序就会崩溃，如果我没有捕捉到它，我可能会捕捉到它，但在这种情况下的精神状态不是“流动的”。</p><p id="befe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们在库代码中使用了一个koko()函数，它显式地返回了<strong class="ka ir"> Error | string </strong>，所以我必须对它做些什么。<br/>但是我如何从<strong class="ka ir">结果&lt;错误分类，字符串&gt; </strong>中提取实际结果呢</p><p id="1cd1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是我不喜欢的部分:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="376c" class="lg lh iq lc b gy li lj l lk ll">const result: Result&lt;ErrorClassification, string&gt; = koko();<br/>if (isError(result)) {<br/>  return result as ErrorClassification;<br/>}<br/><strong class="lc ir"><em class="lm">console</em></strong>.log(result as string);</span></pre><p id="ee81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我会解释，Result(或者)不是运行时存在的东西，由于我们在Typescript中没有模式匹配，transpiler (tsc)不会以优雅的方式为我解析类型，如下面的Rust片段所示。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="9c9f" class="lg lh iq lc b gy li lj l lk ll">match foo.run(result) {<br/>    <em class="lm">Ok</em>(_) =&gt; {}<br/>    <em class="lm">Err</em>(e) =&gt; {...},<br/>}</span></pre><blockquote class="ml mm mn"><p id="3120" class="jy jz lm ka b kb kc kd ke kf kg kh ki mo kk kl km mp ko kp kq mq ks kt ku kv ij bi translated"><a class="ae mr" href="https://doc.rust-lang.org/book/ch18-00-patterns.html" rel="noopener ugc nofollow" target="_blank"> <em class="iq">模式是Rust中的一种特殊语法，用于匹配复杂和简单类型的结构。将模式与</em> </a> <code class="fe ms mt mu lc b"><a class="ae mr" href="https://doc.rust-lang.org/book/ch18-00-patterns.html" rel="noopener ugc nofollow" target="_blank"><em class="iq">match</em></a></code> <a class="ae mr" href="https://doc.rust-lang.org/book/ch18-00-patterns.html" rel="noopener ugc nofollow" target="_blank"> <em class="iq">表达式和其他结构结合使用，可以更好地控制程序的控制流。</em> </a></p></blockquote><p id="fc28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是等等，我不希望我的库消费者使用isError()函数来提取他们的结果！！<br/>我希望他们(和我自己)能写出令人愉快的代码，比如:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="14ca" class="lg lh iq lc b gy li lj l lk ll"><em class="lm">result</em><strong class="lc ir"><em class="lm"><br/>    </em></strong>.ok(transformValFn)<br/>    .map((transformedVal) =&gt; whatever..)<br/>    .err((transformedErr: ErrorClassification) =&gt; {<br/>      //do something<br/>      return <strong class="lc ir"><em class="lm">result</em></strong>;<br/>    });</span></pre><h2 id="11a8" class="lg lh iq bd lp lq lr dn ls lt lu dp lv kj lw lx ly kn lz ma mb kr mc md me mf bi translated">结果结构:</h2><p id="4a34" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">为了制作这样的API，我们需要一个结构，输入ResultT:</p><p id="0d01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ResultT有两个方法，ok()和err()用于注册结果值或错误数据类型，还有一个map()方法用于更常规/惯用的转换。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="175e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mr" href="https://en.wikipedia.org/wiki/Functor" rel="noopener ugc nofollow" target="_blank"> ResultT </a>是函子吗？<br/>让我们按照<a class="ae mr" href="https://github.com/hemanth/functional-programming-jargon#functor" rel="noopener ugc nofollow" target="_blank">FP-行话</a>基于<a class="ae mr" href="https://github.com/fantasyland/fantasy-land" rel="noopener ugc nofollow" target="_blank">幻境</a>规范，</p><p id="3eec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ms mt mu lc b">1. <strong class="ka ir">Identity</strong>: object.map(x =&gt; x) ≍ object</code></p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="b591" class="lg lh iq lc b gy li lj l lk ll">const isInstanceofResultT = result.map((a) =&gt; a) instanceof ResultT;<br/><strong class="lc ir"><em class="lm">console</em></strong>.log('isInstanceofResultT', isInstanceofResultT); // true</span></pre><p id="dc6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ok()，err()和map()都返回ResultT标识。</p><p id="c831" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ms mt mu lc b">2. <strong class="ka ir">composition</strong>: object.map(compose(f, g)) ≍ object.map(g).map(f)</code></p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="6b54" class="lg lh iq lc b gy li lj l lk ll">function one(s: string) {<br/>  const one = 'one';<br/>  return one + s;<br/>}<br/>function two(s: string) {<br/>  const two = 'two';<br/>  return two + s;<br/>}</span><span id="fefe" class="lg lh iq lc b gy mv lj l lk ll">const fooBox = new ResultT('foo');</span><span id="7f14" class="lg lh iq lc b gy mv lj l lk ll">const isResultT =<br/>  fooBox.map(() =&gt; two(one('foo'))).map(<strong class="lc ir"><em class="lm">console</em></strong>.log) ===<br/>  fooBox<br/>    .map(() =&gt; one('foo'))<br/>    .map(two)<br/>    .map(<strong class="lc ir"><em class="lm">console</em></strong>.log);<br/><strong class="lc ir"><em class="lm">console</em></strong>.log('isResultT', isResultT); //true both 'twoonefoo'</span></pre><p id="9788" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用resultT很容易(将来我可能会发布一个ResultT实用程序)</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="0738" class="lg lh iq lc b gy li lj l lk ll">export function myAwesomeAPIFn(<em class="lm">input1: string</em>, input2: Foo): ResultT&lt;ErrorClassification, string&gt; <br/>{<br/>  return new ResultT(_myAwesomeAPIFnThatMayFail(<em class="lm">input1</em>, input2));<br/>}</span></pre><p id="f73d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">暂时就这些了:)</p><p id="9241" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个可运行的例子可以在这里找到:</p><div class="mw mx gp gr my mz"><a href="https://github.com/LironHazan/advanced-patterns-in-typescript/blob/master/functional/error-handling%20/error-classifier.ts" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">LironHazan/高级模式输入脚本</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">打字稿中的高级模式。为LironHazan/advanced-patterns-in-typescript开发做出贡献，创建一个…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn js mz"/></div></div></a></div><p id="d832" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢这篇文章，你可能会喜欢我上一篇关于使用<a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/fp-ts-in-action-d7d5f41c4858"> fp-ts </a>的文章。</p><p id="7c98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">干杯，<br/>立伦！</p></div></div>    
</body>
</html>