<html>
<head>
<title>How to Decide Between React and Vue When Building a Static Site</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建静态站点时，如何在React和Vue之间做出决定</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-decide-between-react-and-vue-when-building-a-static-site-9fd4673fc19b?source=collection_archive---------7-----------------------#2020-05-19">https://itnext.io/how-to-decide-between-react-and-vue-when-building-a-static-site-9fd4673fc19b?source=collection_archive---------7-----------------------#2020-05-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a6c234ee8371dfb4832e5d855608a1a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xcj9LBG5x4aL01xra6oFOg.jpeg"/></div></div></figure><p id="519a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将从多个角度比较两个领先的JS框架——React和vue . JS——包括学习曲线、性能、社区规模以及雇主的兴趣。</p><p id="7ded" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还将解释使用各自的静态站点生成器Gatsby和Gridsome构建静态站点之间的区别。</p><h1 id="f385" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Jamstack一直是JavaScript吗？</h1><p id="3191" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如果你是Jamstack的新手，只需知道它不是一个产品或框架，而是一种构建网站的方式。Jamstack代表JavaScript、API和标记。Jamstack网站的关键在于它不依赖于web服务器。用JavaScript框架构建的静态站点是Jamstack，但用。NET、PHP和其他平台。栈名中的JavaScript指向静态站点部署后的动态功能。</p><p id="e1cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JavaScript是Jamstack最流行的平台，因为它易于使用。你可以在几小时内建立并运行一个网站。而且几乎每个人都懂一点JavaScript，这使得初学者的入门门槛很低。</p><h1 id="6d4d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">React or Vue.js</h1><p id="f19a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">React、Vue.js和Angular组成了最流行的JavaScript框架的三巨头。出于本文的目的，我将重点放在React和Vue.js上，因为Angular的学习曲线很陡，它通常更适合喜欢TypeScript和面向对象编程的大型项目和团队。</p><p id="2547" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看React与Vue.js相比如何，以及它们在每个类别中可以获得多少分:</p><h1 id="c9cb" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">学习曲线</h1><p id="c07f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">从React开始，您需要理解JSX，构建系统，并具备以前的JavaScript知识。Vue.js不需要这些，只需要一点JavaScript知识来理解语法。</p><p id="c6e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">获胜者:<strong class="ka ir"> Vue.js </strong></p><h1 id="37e8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">证明文件</h1><p id="f20e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Vue.js的文档比React的更简单明了。</p><p id="6386" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">获胜者:<strong class="ka ir"> Vue.js </strong></p><h1 id="3725" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">表演</h1><p id="a605" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">React和Vue.js的性能都差不多。Vue.js大概是一半大小。然而，与其他网站资源相比，这一事实本身不应成为决定性因素。</p><p id="1bc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">获胜者:<strong class="ka ir">平局</strong></p><h1 id="11e4" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">社区规模</h1><p id="7aae" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">React和Vue.js都有庞大的社区，拥有类似数量的明星、贡献者和GitHub repos的观察者。</p><p id="ccaa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">赢家:<strong class="ka ir">平手</strong></p><h1 id="9279" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">缩放比例</h1><p id="c4be" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">两家公司都准备扩大规模。Vue.js更适合按比例缩小。</p><p id="8698" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">赢家:<strong class="ka ir">平手</strong></p><h1 id="9a5e" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">雇主的兴趣</h1><p id="6d73" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">虽然两者都有许多工作机会，但React在全球范围内正经历着雇主更高的兴趣。</p><p id="1e8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">胜利者:<strong class="ka ir">做出反应</strong></p><p id="251b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你看，没有明显的赢家，Vue.js以5:4领先，但比分如此接近，我认为这是平局。你会发现开发人员对React和Vue.js都充满热情。许多人喜欢并使用这两者。就像汽车一样。如果你学会开奥迪，你也能开奔驰。</p><h1 id="f4b4" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">盖茨比vs. Gridsome比赛</h1><p id="5b2f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Gatsby和Gridsome分别是React和Vue.js的静态站点生成器。我肯定你在某个地方听说过第一个。Gatsby已经成为SSGs之王，因为它已经存在了很长时间，并且目标反应开发者。</p><p id="87a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Vue.js比React年轻，所以Gridsome也比盖茨比年轻。盖茨比的领先优势使其在与Gridsome的特色战中取得了决定性的优势。但是当我们开始使用它们来构建同一个网站时，它们是如何比较的呢？</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/a56c6636760eaf16fc9e63539a9beb4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sMpYpgkyBJgQ2nNYcFqBDQ.jpeg"/></div></div></figure><p id="7e5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是Phantom，一个我从HTML5UP.net<a class="ae me" href="https://html5up.net" rel="noopener ugc nofollow" target="_blank">得到的免费HTML网页模板。它在主页上包含一个文章列表，并且每篇文章都有自己的专用页面。静态站点的完美简单用例。</a></p><p id="aea1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将使用的内容来自我用于个人网站的<a class="ae me" href="http://bit.ly/38aGvfn" rel="noopener ugc nofollow" target="_blank">无头CMS Kentico Kontent </a>。然而，这些天我对外发布了我的大部分博客文章，所以如果你看到一些旧的，不要惊讶。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/bfe9c02a3eae89f044dc967fab3613d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jLsTzWxISdv4UCVKaZPC1w.jpeg"/></div></div></figure><h1 id="226f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">初始化空白网站</h1><p id="29ba" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">使用静态站点生成器构建新站点的第一步是获得一个初始站点。通常有许多初学者可供选择，最好的选择是从你喜欢的获取内容的方式开始。在我的例子中，内容的来源是一个<a class="ae me" href="http://bit.ly/38aGvfn" rel="noopener ugc nofollow" target="_blank">无头CMS </a>。</p><h2 id="92f2" class="mg kx iq bd ky mh mi dn lc mj mk dp lg kj ml mm lk kn mn mo lo kr mp mq ls mr bi translated">盖茨比（姓）</h2><p id="97df" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在谷歌上搜索“Gatsby Kontent starter”会把我带到starter的GitHub库。我需要克隆这个库并安装软件包:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="ecb9" class="mg kx iq mt b gy mx my l mz na">git clone <a class="ae me" href="https://github.com/Kentico/gatsby-starter-kontent" rel="noopener ugc nofollow" target="_blank">https://github.com/Kentico/gatsby-starter-kontent</a><br/>cd gatsby-starter-kontent<br/>npm i</span></pre><p id="9891" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过运行<code class="fe nb nc nd mt b">gatsby develop</code>，我可以在网络浏览器中访问该网站。</p><h2 id="59f9" class="mg kx iq bd ky mh mi dn lc mj mk dp lg kj ml mm lk kn mn mo lo kr mp mq ls mr bi translated">网格体</h2><p id="220f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">就像Gatsby一样，也有一个特定于Kontent的示例站点，但是它功能齐全。我宁愿使用空白的Gridsome安装:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="7b80" class="mg kx iq mt b gy mx my l mz na">npm i --global @gridsome/cli<br/>gridsome create gridsome-starter-kontent<br/>cd gridsome-starter-kontent</span></pre><p id="2707" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过运行<code class="fe nb nc nd mt b">gridsome develop</code>，一个美好的<em class="ne">你好，世界！</em>站点显示。</p><h1 id="84b7" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">添加源插件</h1><p id="ca1e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我正在使用REST API提供的<a class="ae me" href="http://bit.ly/38aGvfn" rel="noopener ugc nofollow" target="_blank">无头CMS </a>中的数据。静态站点生成器需要一个插件来下载数据并将它们转换成本地GraphQL节点。</p><h2 id="480e" class="mg kx iq bd ky mh mi dn lc mj mk dp lg kj ml mm lk kn mn mo lo kr mp mq ls mr bi translated">盖茨比（姓）</h2><p id="0b98" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我安装了一个已经包含Kentico Kontent <a class="ae me" href="https://bit.ly/39TifPO" rel="noopener ugc nofollow" target="_blank">源代码插件</a>的入门网站。我只需要更改<code class="fe nb nc nd mt b">gatsby-config.js</code>中的<em class="ne">项目Id </em>:</p><p id="958a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nb nc nd mt b">918ba95f-885b-0045-a463-650b22e1196a</code></p><p id="619a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我现在尝试使用<code class="fe nb nc nd mt b">gatsby develop</code>运行网站时，它会失败，并出现一些GraphQL错误。这是意料之中的，我更改了<em class="ne"> projectId，</em>，现在网站收到的数据与页面要求的完全不同。我们以后会改变的。</p><h2 id="3a4a" class="mg kx iq bd ky mh mi dn lc mj mk dp lg kj ml mm lk kn mn mo lo kr mp mq ls mr bi translated">网格体</h2><p id="c3ac" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">由于我安装了一个空白的Gridsome项目，我需要使用npm安装<a class="ae me" href="https://github.com/CMeeg/gridsome-source-kentico-kontent" rel="noopener ugc nofollow" target="_blank"> Kontent插件</a>:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="4d91" class="mg kx iq mt b gy mx my l mz na">npm install @meeg/gridsome-source-kentico-kontent</span></pre><p id="a1c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还需要将包含我的<em class="ne">项目Id </em>的插件添加到<code class="fe nb nc nd mt b">gridsome.config.js</code>:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="cc84" class="mg kx iq mt b gy mx my l mz na">plugins: [<br/>  {<br/>    use: '@meeg/gridsome-source-kentico-kontent',<br/>    options: {<br/>      deliveryClientConfig: {<br/>        projectId: process.env.KENTICO_KONTENT_PROJECT_ID<br/>      }<br/>    }<br/>  }<br/> ]</span></pre><p id="24da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该网站仍将以同样的方式工作，因为其索引页没有绑定到任何数据源。</p><h1 id="7af7" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">添加样式和图像</h1><p id="47ae" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">最初的web模板Phantom包含一些样式表和图像。让我们来看看如何添加它们。</p><h2 id="085e" class="mg kx iq bd ky mh mi dn lc mj mk dp lg kj ml mm lk kn mn mo lo kr mp mq ls mr bi translated">盖茨比（姓）</h2><p id="9c15" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">对于前端资产，在项目的根目录下，我可以创建一个文件夹并将其命名为<em class="ne"> static </em>。Gatsby会简单地将该文件夹的所有内容复制到最终版本中。</p><p id="c395" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于样式表，最好的方法是直接将其导入到组件和页面中。所以幻影模板的<em class="ne"> css </em>文件夹的内容将进入<em class="ne"> src/css </em>。</p><p id="7354" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">准备好所有的样式表后，我需要更改导入Gatsby站点布局的样式。布局是在<code class="fe nb nc nd mt b">src/components/layout.js</code>中定义的，包含下面一行，我应该删除:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="5f1a" class="mg kx iq mt b gy mx my l mz na">import './layout.css';</span></pre><p id="ade2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我需要添加以下几行:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="eea0" class="mg kx iq mt b gy mx my l mz na">import '../css/fontawesome-all.min.css';<br/>import '../css/main.css';</span></pre><p id="3a0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一步是调整CSS文件中引用资源的路径。这些是典型的字体和背景图片。对我来说，它的字体很棒:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="92ac" class="mg kx iq mt b gy mx my l mz na">...<br/>src:url(../webfonts/fa-brands-400.eot);<br/>...</span></pre><p id="16ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">字体文件将被自动拷贝到最终版本，因此它们的路径会相应地改变:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="e339" class="mg kx iq mt b gy mx my l mz na">...<br/>src:url(/assets/webfonts/fa-brands-400.eot);<br/>...</span></pre><p id="1973" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我运行<em class="ne">替换所有</em>../webfonts/"到“/assets/webfonts/”。</p><h2 id="1881" class="mg kx iq bd ky mh mi dn lc mj mk dp lg kj ml mm lk kn mn mo lo kr mp mq ls mr bi translated">网格体</h2><p id="2143" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">静态资产的文件夹<em class="ne"> static </em>已经在项目根中，所以我可以直接复制粘贴资产。</p><p id="e574" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了确保Gridsome将样式添加到布局中，我需要将以下代码添加到特殊文件<code class="fe nb nc nd mt b">main.js</code>中:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="1a7f" class="mg kx iq mt b gy mx my l mz na">head.link.push({<br/>    rel: 'stylesheet',<br/>    href: '/assets/css/fontawesome-all.min.css'<br/>})<br/> <br/>head.link.push({<br/>    rel: 'stylesheet',<br/>    href: '/assets/css/main.css'<br/>})</span></pre><p id="cd92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于样式和字体都放在同一个<em class="ne">静态</em>文件夹中，我不需要更新字体文件的路径。</p><h1 id="fc92" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">调整布局</h1><p id="20b8" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">一旦样式就位，我需要调整布局和内容页面的HTML。布局是所有页面都相同的页面部分。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/79c3fc815383eb08541b776c476cf40c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*25aut3uMc3OSlxa3ddEneg.png"/></div></figure><p id="c4af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我通常创建布局的方式是从模板中复制并粘贴HTML代码到<code class="fe nb nc nd mt b">&lt;body&gt;</code>和<code class="fe nb nc nd mt b">&lt;/body&gt;</code>标签之间。然后，我删除了每个页面应该呈现其内容的代码。</p><h2 id="f169" class="mg kx iq bd ky mh mi dn lc mj mk dp lg kj ml mm lk kn mn mo lo kr mp mq ls mr bi translated">盖茨比（姓）</h2><p id="44cc" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">默认布局在<code class="fe nb nc nd mt b">src/components/layout.js</code>中。我们在导入CSS时已经偶然发现了这个文件。</p><p id="68c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我用模板中的HTML替换了StaticQuery的呈现部分中的所有代码:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="843a" class="mg kx iq mt b gy mx my l mz na">&lt;StaticQuery<br/>     query={...}<br/>     render={(data) =&gt; (*HTML code from the template*)}<br/>&gt;&lt;/StaticQuery&gt;</span></pre><p id="bd7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">盖茨比要求JSX，但我粘贴了HTML，所以我需要做一些修改。最重要的一个就是把所有的<code class="fe nb nc nd mt b">class="*"</code>属性都改成<code class="fe nb nc nd mt b">className="*"</code>。HTML注释也需要删除。</p><p id="a54a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幻影模板有一个<code class="fe nb nc nd mt b">&lt;div id="wrapper"&gt;</code>元素，它环绕整个页面，但在最后包含一些脚本导入。Gatsby需要单个根元素，所以我必须使用另一个包装元素，<code class="fe nb nc nd mt b">&lt;div&gt;</code>或<code class="fe nb nc nd mt b">&lt;React.Fragment&gt;</code>。</p><p id="0910" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我需要用<code class="fe nb nc nd mt b">{children}</code>替换子页面将呈现其内容的HTML。在这种情况下，它是在<code class="fe nb nc nd mt b">&lt;footer&gt;</code>之前的<code class="fe nb nc nd mt b">&lt;div id="main"&gt;</code>和<code class="fe nb nc nd mt b">&lt;/div&gt;</code>之间的代码。如果你按照我的步骤做，不要只是删除代码，把它放到剪贴板上，因为下一步你会用到它。</p><h2 id="b56f" class="mg kx iq bd ky mh mi dn lc mj mk dp lg kj ml mm lk kn mn mo lo kr mp mq ls mr bi translated">网格体</h2><p id="60ed" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">默认布局在<code class="fe nb nc nd mt b">src/layouts/Default.vue</code>中。它是一个Vue.js组件，因此有三个部分:</p><p id="9120" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在布局中，我只需要标记，所以我将HTML从模板复制粘贴到<code class="fe nb nc nd mt b">&lt;template&gt;</code>部分。就在<code class="fe nb nc nd mt b">&lt;footer&gt;</code>之前的<code class="fe nb nc nd mt b">&lt;div id="main"&gt;</code>和<code class="fe nb nc nd mt b">&lt;/div&gt;</code>之间的中间部分需要替换，就像Gatsby一样，带有一个<code class="fe nb nc nd mt b">&lt;slot /&gt;</code>标签。</p><h1 id="cc32" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">添加静态页面</h1><p id="c62a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">幻影模板中唯一真正静态的页面是索引。它包含一个博客文章列表，并带有链接到它们的URL。</p><h2 id="f79d" class="mg kx iq bd ky mh mi dn lc mj mk dp lg kj ml mm lk kn mn mo lo kr mp mq ls mr bi translated">盖茨比（姓）</h2><p id="8e78" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">使用Kontent source插件获取博客文章数据的GraphQL查询如下所示:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="082f" class="mg kx iq mt b gy mx my l mz na">allKontentItemBlogPost {<br/>   edges {<br/>     node {<br/>       system {<br/>         codename<br/>       }<br/>       elements {<br/>         title {<br/>           value<br/>         }<br/>         teaser {<br/>           value<br/>         }<br/>         image_url {<br/>           value<br/>         }<br/>         image {<br/>           value {<br/>             url<br/>           }<br/>         }<br/>       }<br/>     }<br/>}</span></pre><p id="36f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意<code class="fe nb nc nd mt b">codename</code>；我将用它作为博客文章的URL。</p><p id="fd9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">索引页的代码在<code class="fe nb nc nd mt b">src/pages/index.js</code>文件中。有一个常量<code class="fe nb nc nd mt b">query</code>保存GraphQL查询。页面的代码在常量索引中，也是默认的<code class="fe nb nc nd mt b">export</code>。我在上一节中删除的HTML代码放在这里的<code class="fe nb nc nd mt b">return</code>表达式中。</p><p id="abfb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我需要动态生成<code class="fe nb nc nd mt b">&lt;section class="tiles"&gt;</code>和<code class="fe nb nc nd mt b">&lt;/section&gt;</code>之间的标记。JSX允许我们将JavaScript和HTML结合起来，所以我使用了<code class="fe nb nc nd mt b">map</code>函数来这样做:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="2826" class="mg kx iq mt b gy mx my l mz na">const items = data.allKontentItemBlogPost.edges.map(({node:item}, index) =&gt; <br/>     &lt;article className={`style${index}`}&gt;<br/>       &lt;span className="image"&gt;<br/>         &lt;img src="images/pic01.jpg" alt="" /&gt;<br/>       &lt;/span&gt;<br/>       &lt;a href={`/blog/${item.system.codename}`}&gt;<br/>         &lt;h2&gt;{item.elements.title.value}&lt;/h2&gt;<br/>         &lt;div className="content" dangerouslySetInnerHTML={{__html: item.elements.teaser.value}}&gt;<br/>         &lt;/div&gt;<br/>       &lt;/a&gt;<br/>     &lt;/article&gt;<br/>)</span></pre><p id="196d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nb nc nd mt b">&lt;article&gt;</code>需要递增的类名(style1，style2，style3)，所以我也使用映射函数的<code class="fe nb nc nd mt b">index</code>变量来正确地生成CSS。每篇博文的目标链接都是<code class="fe nb nc nd mt b">/blog/{codename}</code>。</p><h2 id="4dd2" class="mg kx iq bd ky mh mi dn lc mj mk dp lg kj ml mm lk kn mn mo lo kr mp mq ls mr bi translated">Gridsome</h2><p id="13e6" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">索引页面在<code class="fe nb nc nd mt b">src/pages/Index.vue</code>中实现，包含两个部分——模板和脚本。对于我的用例，我不需要<code class="fe nb nc nd mt b">&lt;script&gt;</code>部分，但是我需要用GraphQL查询添加一个页面查询部分，从无头CMS收集数据:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="53c8" class="mg kx iq mt b gy mx my l mz na">&lt;page-query&gt;<br/> query {<br/>   allBlogPost {<br/>     edges {<br/>       node {<br/>         path<br/>         imageUrl<br/>         image {<br/>           URL<br/>         }<br/>         teaser<br/>         title<br/>       }<br/>     }<br/>   }<br/> }<br/>&lt;/page-query&gt;</span></pre><p id="0930" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你看数据的结构和盖茨比有点不同。这是因为每个源插件对待数据的方式不同。</p><p id="4564" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nb nc nd mt b">&lt;template&gt;</code>标签中的标记与幻影模板相同，除了我呈现博客文章列表的部分。Vue.js允许我指定HTML，并使用绑定属性来生成尽可能多的迭代。</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="5fd0" class="mg kx iq mt b gy mx my l mz na">&lt;section class="tiles"&gt;<br/>   &lt;article v-for="(item, index) in $page.allBlogPost.edges" :key="item.node.codename" :class="`style${index}`"&gt;<br/>     &lt;span class="image"&gt;<br/>       &lt;img src="images/pic01.jpg" alt="" /&gt;<br/>     &lt;/span&gt;<br/>     &lt;a :href="`${item.node.path}`"&gt;<br/>       &lt;h2&gt;{{ item.node.title }}&lt;/h2&gt;<br/>       &lt;div class="content" v-html="item.node.teaser"&gt;<br/>       &lt;/div&gt;<br/>     &lt;/a&gt;<br/>   &lt;/article&gt;<br/>&lt;/section&gt;</span></pre><p id="ad62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你注意到链接中的<code class="fe nb nc nd mt b">item.node.path</code>了吗？不应该有<code class="fe nb nc nd mt b">/blog/{item.node.codename}</code>吗？干得好！我将在下一节解释我们实际生成页面的地方。</p><h1 id="f1b4" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">基于内容生成静态页面</h1><p id="103d" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这是我需要基于来自无头CMS的模板和数据集生成页面的最有趣的部分。我还需要指定这些网页的网址。</p><h2 id="d11f" class="mg kx iq bd ky mh mi dn lc mj mk dp lg kj ml mm lk kn mn mo lo kr mp mq ls mr bi translated">盖茨比（姓）</h2><p id="555d" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我将用于生成页面的模板与之前编辑的页面具有相同的结构。因此，我将<code class="fe nb nc nd mt b">index.js</code>文件复制粘贴到<em class="ne">模板</em>文件夹中，并将其重命名为<code class="fe nb nc nd mt b">blog.js</code>。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/cf447d5d3818a9cb7a21cb2bb4387580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*rm0V0SCXemuPpFj0nNU5Ug.jpeg"/></div></figure><p id="610b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模板接收它应该呈现的项目的代码名。它需要实现自己的GraphQL查询，以获取附加数据，如标题、图像和内容:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="c049" class="mg kx iq mt b gy mx my l mz na">query projectReferenceQuery($codename: String!) {<br/>       kontentItemBlogPost(system: {codename: {eq: $codename}}) {<br/>         elements {<br/>           title {<br/>             value<br/>           }<br/>           image_url {<br/>             value<br/>           }<br/>           teaser {<br/>             value<br/>           }<br/>           image {<br/>             value {<br/>               url<br/>             }<br/>           }<br/>         }<br/>         system {<br/>           codename<br/>         }<br/>       }<br/>}</span></pre><p id="4364" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在只剩下一点额外的逻辑和标记:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="1116" class="mg kx iq mt b gy mx my l mz na">const item = data.kontentItemBlogPost;<br/> <br/> let imageUrl = item.elements.imageUrl;<br/> if (!imageUrl &amp;&amp; item.elements.image.value.length &gt; 0)<br/> {<br/>   imageUrl = item.elements.image.value[0].url;<br/> }<br/> <br/> return (<br/>     &lt;Layout&gt;<br/>       &lt;div id="main"&gt;<br/>         &lt;div class="inner"&gt;<br/>           &lt;h1&gt;{item.elements.title.value}&lt;/h1&gt;<br/>           &lt;span class="image main"&gt;&lt;img src="images/pic13.jpg" alt="" /&gt;&lt;/span&gt;<br/>           &lt;div dangerouslySetInnerHTML={{__html: item.elements.teaser.value}}&gt;&lt;/div&gt;<br/>         &lt;/div&gt;<br/>       &lt;/div&gt;<br/>     &lt;/Layout&gt;<br/>);</span></pre><p id="6b0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦模板准备好了，我需要在<code class="fe nb nc nd mt b">gatsby-node.js</code>文件中添加一些代码，负责获取代码名和生成页面。在GraphQL查询中，我得到了所有博客文章的代码名，随后调用了<code class="fe nb nc nd mt b">createPage</code>函数，该函数指定了盖茨比应该在哪个路径上以及使用哪个模板生成每一页。</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="70de" class="mg kx iq mt b gy mx my l mz na"> exports.createPages = ({ graphql, actions }) =&gt; {<br/>   const { createPage } = actions;<br/>   return new Promise((resolve) =&gt; {<br/>     graphql(`<br/>     {<br/>       allKontentItemBlogPost {<br/>         edges {<br/>           node {<br/>             system {<br/>               codename<br/>             }<br/>           }<br/>         }<br/>       }<br/>     }<br/>     `).then(result =&gt; {<br/>         result.data.allKontentItemBlogPost.edges.forEach(({node}) =&gt; {<br/>           createPage({<br/>             path: `blog/${node.system.codename}`,<br/>             component: path.resolve(`./src/templates/blog.js`),<br/>             context: {<br/>               // Data passed to context is available in page queries as GraphQL variables.<br/>               codename: node.system.codename<br/>             },<br/>           });<br/>         })<br/>         resolve();<br/>     });<br/>   });<br/> };</span></pre><h2 id="ad65" class="mg kx iq bd ky mh mi dn lc mj mk dp lg kj ml mm lk kn mn mo lo kr mp mq ls mr bi translated">Gridsome</h2><p id="929e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">模板的创建方式与页面相同。Gridsome使用id的概念。每个内容项都有一个唯一的标识符，您可以使用它进行查询。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/69761491dfda8ab70b10e8720c84816c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*b2d0DyAbv-msTFyyOkd7yg.jpeg"/></div></figure><p id="78e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我将要构建的模板从获取特定博客帖子数据的页面查询开始:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="4e36" class="mg kx iq mt b gy mx my l mz na"> &lt;page-query&gt;<br/> query MyQuery ($id:ID!) {<br/>   blogPost (id: $id)<br/>   {<br/>     codename<br/>     imageUrl<br/>     image {<br/>       url<br/>     }<br/>     teaser<br/>     title<br/>   }<br/> }<br/> &lt;/page-query&gt;</span></pre><p id="6242" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模板的标记如下所示:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="ec1d" class="mg kx iq mt b gy mx my l mz na"> &lt;template&gt;<br/>   &lt;Layout&gt;<br/>     &lt;div id="main"&gt;<br/>       &lt;div class="inner"&gt;<br/>         &lt;h1&gt;{{$page.blogPost.title}}&lt;/h1&gt;<br/>         &lt;span class="image main"&gt;&lt;img :src="$page.blogPost.imageUrl ? $page.blogPost.imageUrl : $page.blogPost.image.value[0].url" alt="" /&gt;&lt;/span&gt;<br/>         &lt;div v-html="$page.blogPost.teaser"&gt;&lt;/div&gt;<br/>       &lt;/div&gt;<br/>     &lt;/div&gt;<br/>   &lt;/Layout&gt;<br/> &lt;/template&gt;</span></pre><p id="3a55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在真正的魔法来了。Gridsome不像Gatsby，它只满足了你的一半，不需要你自己构建页面创建逻辑。我刚刚为其创建了一个模板的内容类型叫做BlogPost。Gridsome知道这一点，所以只要模板以相同的方式命名，我只需要在<code class="fe nb nc nd mt b">gridsome.config.js</code>文件中指定网址结构:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="4300" class="mg kx iq mt b gy mx my l mz na"> module.exports = {<br/>   ...<br/>   templates: {<br/>     BlogPost: '/blog/:codename'<br/>   }<br/> }</span></pre><p id="02f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过指定URL，Gridsome将使用<code class="fe nb nc nd mt b">path</code>变量增强所有BlogPost内容项，该变量将被缩短并调整以满足URL要求。您应该将其用于项目中的所有链接。如果你在你的代码中使用<code class="fe nb nc nd mt b">/blog/{codename}</code>的话，你会引用不存在的页面。</p><h1 id="1d9c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">谁是赢家？</h1><p id="f90a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在本文中，我试图向您展示使用不同的框架构建一个静态站点是多么的相似。废话，告诉我哪一个已经更好了？！</p><p id="cc14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我个人更喜欢Vue.js和Gridsome。两者在我心中都有特殊的位置，因为它们如此直观和直接。我喜欢他们的文件。当我开始使用静态站点生成器时，它对我帮助很大。</p><p id="502d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，盖茨比赢得了功能之战，我将它更多地用于需要高级功能的客户项目，比如图像预加载、多种语言、复杂的表格等等。为盖茨比从<a class="ae me" href="http://bit.ly/38aGvfn" rel="noopener ugc nofollow" target="_blank">无头CMS Kentico Kontent </a>获取数据的<a class="ae me" href="https://bit.ly/39TifPO" rel="noopener ugc nofollow" target="_blank">源插件</a>也更先进。</p><p id="b795" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不会说一个比另一个好。两者都很棒。如果你需要挑选一个，试着在它们上面建立一个样本站点，并且相信你的直觉。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="acb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ne">原为发表于</em><a class="ae me" href="https://kontent.ai/blog/react-or-vue-gatsby-or-gridsome" rel="noopener ugc nofollow" target="_blank"><em class="ne">https://kontent . ai</em></a><em class="ne">。</em></p></div></div>    
</body>
</html>