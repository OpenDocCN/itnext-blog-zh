<html>
<head>
<title>Container Runtime in Rust — Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust中的容器运行时间—第二部分</h1>
<blockquote>原文：<a href="https://itnext.io/container-runtime-in-rust-part-ii-9c88e99d8cbc?source=collection_archive---------1-----------------------#2021-10-06">https://itnext.io/container-runtime-in-rust-part-ii-9c88e99d8cbc?source=collection_archive---------1-----------------------#2021-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="70c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">克隆容器进程和父子通信</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/2afe15f93aa9cda0f06da7407abf0ec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rtZ6gyTeG1B22M4Zoy8bxw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">Rust中的容器运行时</figcaption></figure><p id="e381" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本系列的第一部分描述了文件系统布局以及运行时如何将容器进程锁在容器的根文件系统中。</p><p id="67f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二部分对实现进行了更深入的探讨，展示了运行时如何创建子进程，以及它们如何通信，直到用户定义的进程开始。它还将描述如何设置伪终端，并展示Unix套接字的重要性。</p><p id="b4e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到这一部分结束时，我们应该有一个可以与Docker互操作的基本运行时。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="4039" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">克隆</h1><p id="5b36" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">第0部分简要解释了克隆系统调用。它类似于fork/vfork，但是有更多的选项来控制子进程。实际上，fork的一些实现传播了对clone()的调用。</p><p id="4727" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了控制执行上下文的哪些部分从父进程共享之外，克隆调用还为我们提供了为子进程的堆栈创建单独的内存块的可能性。克隆的nix实现具有以下签名:</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="1f9d" class="mr lk iq mn b gy ms mt l mu mv">pub fn clone(<br/> cb: <a class="ae lb" href="https://docs.rs/nix/0.22.1/nix/sched/type.CloneCb.html" rel="noopener ugc nofollow" target="_blank">CloneCb</a>&lt;’_&gt;, <br/> stack: <a class="ae lb" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html" rel="noopener ugc nofollow" target="_blank">&amp;mut [</a><a class="ae lb" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html" rel="noopener ugc nofollow" target="_blank">u8</a><a class="ae lb" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html" rel="noopener ugc nofollow" target="_blank">]</a>, <br/> flags: <a class="ae lb" href="https://docs.rs/nix/0.22.1/nix/sched/struct.CloneFlags.html" rel="noopener ugc nofollow" target="_blank">CloneFlags</a>, <br/> signal: <a class="ae lb" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" rel="noopener ugc nofollow" target="_blank">Option</a>&lt;<a class="ae lb" href="https://docs.rs/libc/0.2.99/x86_64-unknown-linux-gnu/libc/unix/type.c_int.html" rel="noopener ugc nofollow" target="_blank">c_int</a>&gt;<br/>) -&gt; <a class="ae lb" href="https://docs.rs/nix/0.22.1/nix/type.Result.html" rel="noopener ugc nofollow" target="_blank">Result</a>&lt;<a class="ae lb" href="https://docs.rs/nix/0.22.1/nix/unistd/struct.Pid.html" rel="noopener ugc nofollow" target="_blank">Pid</a>&gt;</span></pre><p id="9895" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果指定了<code class="fe mw mx my mn b">signal</code>参数，当子进程终止时，它将被发送回父进程。</p><p id="54f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是描述<strong class="jp ir"> create </strong>命令和父子关系的代码片段:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">OCI创建命令的基本布局</figcaption></figure><p id="e60d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">鉴于上述情况，产生的一个问题是父母和孩子之间的沟通。在生成线程的情况下，可以说创建一个内存通道可以解决这个问题(Rust对多线程和线程安全<a class="ae lb" href="https://doc.rust-lang.org/std/sync/mpsc/index.html" rel="noopener ugc nofollow" target="_blank">多生产者、单消费者队列</a>有很好的支持)。在我们的例子中，情况并非如此，因为它用自己独立的内存空间创建(或者更好地说是克隆)了一个新进程。</p><p id="880d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进程间通信(IPC)是一组允许进程相互通信的技术。最广泛使用的两种是:</p><ol class=""><li id="b56e" class="nb nc iq jp b jq jr ju jv jy nd kc ne kg nf kk ng nh ni nj bi translated">共用存储器</li><li id="be6b" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">套接字</li></ol><p id="64e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，我们将使用Unix套接字(AF_UNIX)在父进程和子进程之间建立一个“客户机-服务器”通道。容器进程将绑定到那个Unix套接字，并侦听来自父进程的传入连接。当执行的不同部分通过或失败时，两个进程都将使用套接字连接来通知对方。调用start命令时，套接字连接也很方便，它通知容器进程启动用户定义的程序。下图更好地描述了“协议”:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi np"><img src="../Images/2c78dc1cf2d4bb99e2d80c6bf69b64e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*janvQC7ZCEtbLoJ7f-lunw.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">运行时和容器进程通信</figcaption></figure><h1 id="4797" class="lj lk iq bd ll lm nq lo lp lq nr ls lt lu ns lw lx ly nt ma mb mc nu me mf mg bi translated">Unix套接字</h1><p id="44fe" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">对于那些不熟悉<a class="ae lb" href="https://man7.org/linux/man-pages/man7/unix.7.html" rel="noopener ugc nofollow" target="_blank"> Unix(域)套接字</a>的人来说，这个Linux特性有望让人大吃一惊(至少对我来说是这样)。Unix套接字是一种进程间通信机制，它在同一台机器上运行的进程之间建立双向数据交换通道。人们可以把它们想象成TCP/IP套接字，它们不使用网络栈来发送和接收数据，而是文件系统上的一个文件。</p><p id="b4b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在容器运行时的情况下，Unix套接字为运行时父进程和子进程提供双向数据交换。该交换通道对于容器运行时是必不可少的！如果在子进程中出现问题怎么办？父进程如何继续？或者孩子如何知道启动命令何时被调用？</p><p id="a5e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">出于这些目的，容器运行时实现了IPC通道。这些是使用Unix域套接字的双向通道。一个进程充当“服务器”，其他进程(称为“客户端”)连接到服务器进程。</p><p id="a286" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，下面是Rust代码的大概样子:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">Rust中使用Unix套接字的IPC通道</figcaption></figure><p id="45ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">服务器调用<strong class="jp ir"> new </strong>方法并绑定到<em class="nv">。sock </em>文件。然后它调用<strong class="jp ir"> accept </strong>并等待进入的连接。另一方面，客户端只是用同一个<em class="nv">调用<strong class="jp ir">连接</strong>。sock </em>文件，在此之后，服务器和客户端可以交换消息。最终，两个进程都调用<strong class="jp ir"> close </strong>，通信结束。</p><p id="9faa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我使用了<code class="fe mw mx my mn b">SOCK_SEQPACKET</code>套接字，因为消息是按顺序出现的，它是基于连接的，消息会被一次刷新(与<code class="fe mw mx my mn b">SOCK_STREAM</code>相反)。</p><h1 id="26a2" class="lj lk iq bd ll lm nq lo lp lq nr ls lt lu ns lw lx ly nt ma mb mc nu me mf mg bi translated">末端的</h1><p id="cdb0" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">为了在容器启动后与它进行良好的交互，如果用户请求终端，运行时应该能够提供一个终端接口。</p><p id="566b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当运行这样的Docker命令时:</p><p id="41fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mw mx my mn b">docker run alpine ping 8.8.8.8</code></p><p id="7bfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您将看到ping命令向Google的DNS发送ICMP请求的输出。ping命令的输出通过Docker传输，但是当我们想要停止命令(通过使用Ctrl+C)时，什么也没有发生。这是因为当按下<a class="ae lb" href="https://dsa.cs.tsinghua.edu.cn/oj/static/unix_signal.html" rel="noopener ugc nofollow" target="_blank"> SIGINT </a>组合键时，信号被发送到Docker，Docker没有将命令传递给实际的容器进程。</p><p id="a6c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，跑步时:</p><p id="cce3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mw mx my mn b">docker run -it alpine ping 8.8.8.8</code></p><p id="5376" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并按Ctrl+C，该命令会立即终止，就像在主机上运行一样。这是为什么呢？</p><p id="1424" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是因为在第一个例子中，容器进程没有实例化终端，因此用户和Docker都不能通过tty将信号转发给容器。</p><p id="056d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，<code class="fe mw mx my mn b">-t</code>选项在<strong class="jp ir"> config.json </strong>文件中设置了<code class="fe mw mx my mn b">terminal: true</code>标志。之后，容器运行时负责创建一个所谓的<a class="ae lb" href="https://linux.die.net/man/7/pty" rel="noopener ugc nofollow" target="_blank">“伪终端”(pty) </a>。</p><p id="f28c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单来说，PTY是一对(主-从)通信设备，就像一个真正的终端。发送到主机的任何命令都会被转发到从机端，从文本输入到处理信号。pty是Linux内核非常重要且常用的特性(<em class="nv"> ssh </em>使用它！).</p><p id="ee50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在很简单:</p><ol class=""><li id="dde1" class="nb nc iq jp b jq jr ju jv jy nd kc ne kg nf kk ng nh ni nj bi translated">如果<code class="fe mw mx my mn b">terminal: true</code>容器运行时创建一个PTY</li><li id="8d38" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">从属描述符转到子进程</li><li id="5dca" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">主描述符转到调用进程(在本例中为Docker)</li></ol><p id="97c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是子进程如何将主描述符发送给Docker呢？</p><p id="12a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">唉…这是一个真正的<a class="ae lb" href="https://www.allacronyms.com/PITA/Pain_In_The_Ass" rel="noopener ugc nofollow" target="_blank">皮塔</a>要找到，解决方案超出了OCI运行时规范的范围。<code class="fe mw mx my mn b">runc</code>开发了一个解决方案，此处<a class="ae lb" href="https://github.com/opencontainers/runc/blob/master/docs/terminals.md#detached-new-terminal" rel="noopener ugc nofollow" target="_blank">描述了其步骤</a>。TLDR；我们的朋友Unix sockets来帮忙了。Docker创建一个Unix域套接字，并将其作为<code class="fe mw mx my mn b">console-socket</code>参数传递给容器运行时。在容器运行时创建PTY之后，它用<a class="ae lb" href="https://man7.org/linux/man-pages/man3/cmsg.3.html" rel="noopener ugc nofollow" target="_blank"> SCM_RIGHTS </a>将主端发送到同一个Unix套接字。</p><h1 id="c8aa" class="lj lk iq bd ll lm nq lo lp lq nr ls lt lu ns lw lx ly nt ma mb mc nu me mf mg bi translated">结论</h1><p id="6920" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">最后，我们有了一个可以测试的OCI容器运行时！</p><p id="0a39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一部分解释了克隆系统调用以及它如何将执行上下文从父进程中分离出来。它还有一个灵活的API，因此我们可以为流程指定新的堆栈。</p><p id="cf2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Unix域套接字在这里起了很大的作用，因为它们同步整个父子通信，并在双方都出现错误时处理潜在的场景。</p><p id="01af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二部分总结了Rust 系列中的<strong class="jp ir">容器运行时。实验容器运行时的完整源代码可以在这个<a class="ae lb" href="https://github.com/penumbra23/pura" rel="noopener ugc nofollow" target="_blank"> Github repo </a>上找到。欢迎提问或指出实现中有趣的事情。</strong></p><h1 id="01cd" class="lj lk iq bd ll lm nq lo lp lq nr ls lt lu ns lw lx ly nt ma mb mc nu me mf mg bi translated">参考</h1><ol class=""><li id="504e" class="nb nc iq jp b jq mh ju mi jy nw kc nx kg ny kk ng nh ni nj bi translated"><a class="ae lb" href="https://man7.org/linux/man-pages/man2/clone.2.html" rel="noopener ugc nofollow" target="_blank">克隆人手册页</a></li><li id="be5e" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated"><a class="ae lb" href="https://man7.org/linux/man-pages/man7/unix.7.html" rel="noopener ugc nofollow" target="_blank"> Unix域套接字</a></li><li id="135d" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated"><code class="fe mw mx my mn b"><a class="ae lb" href="https://github.com/opencontainers/runc/blob/master/docs/terminals.md" rel="noopener ugc nofollow" target="_blank">runc</a></code> <a class="ae lb" href="https://github.com/opencontainers/runc/blob/master/docs/terminals.md" rel="noopener ugc nofollow" target="_blank">终端模式</a></li></ol></div></div>    
</body>
</html>