<html>
<head>
<title>Build &amp; Ship: GitHub Container Registry &amp; Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建和发布:GitHub容器注册和Kubernetes</h1>
<blockquote>原文：<a href="https://itnext.io/build-ship-github-container-registry-kubernetes-aa06029b3f21?source=collection_archive---------1-----------------------#2020-09-23">https://itnext.io/build-ship-github-container-registry-kubernetes-aa06029b3f21?source=collection_archive---------1-----------------------#2020-09-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e8ef15730b4925ea3e7291825615868b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rCRnx6BoIcdWcyYDojJVrg.png"/></div></div></figure><p id="a752" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本月初<a class="ae kw" href="https://www.github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>宣布了新的<a class="ae kw" href="https://github.blog/2020-09-01-introducing-github-container-registry/" rel="noopener ugc nofollow" target="_blank"> GitHub容器注册</a>服务。这个服务类似于<a class="ae kw" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>和GitHub自己的<a class="ae kw" href="https://github.blog/2019-05-10-introducing-github-package-registry/" rel="noopener ugc nofollow" target="_blank">包注册表</a>。在这篇文章中，我将解释为什么你应该使用GitHub的容器注册表，描述如何创建一个<a class="ae kw" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> GitHub动作</a>来自动构建和推送<a class="ae kw" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>图像到GitHub的容器注册表，以及如何在你的<a class="ae kw" href="https://kubernetes.io" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>集群中使用这些Docker图像。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="a7e7" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">目录</h1><p id="80da" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">— <a class="ae kw" href="#eb5a" rel="noopener ugc nofollow">为什么要用GitHub的容器注册表而不是Docker Hub？</a><br/>——<a class="ae kw" href="#34a6" rel="noopener ugc nofollow">GitHub包注册表VS GitHub容器注册表:用哪个？</a> <br/> — <a class="ae kw" href="#0075" rel="noopener ugc nofollow">使用GitHub动作创建Docker图像并发布到GCR </a> <br/> — <a class="ae kw" href="#7678" rel="noopener ugc nofollow">如何公开GCR Docker图像</a> <br/> — <a class="ae kw" href="#2237" rel="noopener ugc nofollow">如何使用Kubernetes </a> <br/>拉取公开的GCR Docker图像— <a class="ae kw" href="#b6cb" rel="noopener ugc nofollow">如何使用Kubernetes拉取私人的GCR Docker图像</a></p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/29ef1c322c261bb95d04a3c591c14a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rb5TXCsWYGicxKmVg1ebeg.png"/></div></div></figure><h1 id="eb5a" class="le lf iq bd lg lh mm lj lk ll mn ln lo lp mo lr ls lt mp lv lw lx mq lz ma mb bi translated"><strong class="ak">为什么要用GitHub的容器注册表而不是Docker Hub？</strong></h1><p id="419f" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">首先，如果你在Docker项目中使用GitHub，那么使用GitHub的容器注册表通过只使用一个服务简化了你的工作流程。其次，使用GitHub动作构建Docker映像是可定制的，这让您在构建Docker映像时更加灵活，更重要的是，在出现错误时有更多的方法来调试问题。接下来，GitHub Actions将在几分钟内构建并发布Docker图像，我经常要等20多分钟才能在Docker Hub上构建并提供我的新Docker图像。最后，GitHub目前没有计划删除旧的Docker图片，不像Docker Hub最近宣布的那样。</p><h1 id="34a6" class="le lf iq bd lg lh mm lj lk ll mn ln lo lp mo lr ls lt mp lv lw lx mq lz ma mb bi translated"><strong class="ak"> GitHub包注册表VS GitHub容器注册表:用哪个？</strong></h1><p id="d08b" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">2019年GitHub推出了<a class="ae kw" href="https://github.blog/2019-05-10-introducing-github-package-registry/" rel="noopener ugc nofollow" target="_blank"> GitHub包注册表</a>，然后在2020年他们推出了<a class="ae kw" href="https://github.blog/2020-09-01-introducing-github-container-registry/" rel="noopener ugc nofollow" target="_blank"> GitHub容器注册表</a>。乍一看，这两种服务看起来完全相同，但至少有一个重要的区别。</p><p id="dfbb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GitHub列出了容器注册表的主要区别:</p><blockquote class="mr ms mt"><p id="cb7f" class="jy jz mu ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated">-将容器图像存储在您的组织和用户帐户中，而不是存储库中。<br/> -独立于存储库权限和可见性设置细粒度的权限和可见性。<br/> -匿名访问公共容器图像。</p></blockquote><p id="e511" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不过在我看来，GitHub包注册表和GitHub容器注册表最重要的区别就是上传到<a class="ae kw" href="https://docs.github.com/en/packages/publishing-and-managing-packages/deleting-a-package#about-public-package-deletion" rel="noopener ugc nofollow" target="_blank"> GitHub包注册表的图片不能删除</a>！嗯，这并不是100%正确，如果你将GitHub库设为私有，那么你可以删除这个包，但是将GitHub库设为私有会产生意想不到的后果。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="0075" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用GitHub动作自动创建Docker图像，并将它们发布到GitHub的容器注册表中</h1><p id="d8a4" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">在这个例子中，我将使用我所做的工作将我的<a class="ae kw" href="https://github.com/kevincoakley/twitter-stream-archive" rel="noopener ugc nofollow" target="_blank">Twitter-stream-archive</a>Docker映像从Docker Hub迁移到GitHub的容器注册表中，用于我的Kubernetes集群。twitter-stream-archive做什么并不重要，重要的是twitter-stream-archive在GitHub存储库根目录中有一个<code class="fe my mz na nb b">DockerFile</code>并将通过运行<code class="fe my mz na nb b">docker build .</code>创建一个有效的Docker映像。如果GitHub存储库中没有工作的<code class="fe my mz na nb b">DockerFile</code>，下面的指令将不会创建一个工作的Docker映像。</p><p id="c40c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想自己查看文件和GitHub操作，twitter-stream-archive GitHub存储库在:<a class="ae kw" href="https://github.com/kevincoakley/twitter-stream-archive" rel="noopener ugc nofollow" target="_blank">https://github.com/kevincoakley/twitter-stream-archive</a>和Docker图片在<a class="ae kw" href="https://github.com/kevincoakley?tab=packages" rel="noopener ugc nofollow" target="_blank">https://github.com/kevincoakley?tab=packages</a></p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="4c0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 1。创建GitHub个人访问令牌</strong></p><p id="06b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GitHub容器注册表使用GitHub个人访问令牌代替您的GitHub密码进行身份验证。进入你的账户设置，创建一个拥有<code class="fe my mz na nb b">read:packages</code> &amp; <code class="fe my mz na nb b">write:packages</code>权限的<a class="ae kw" href="https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token" rel="noopener ugc nofollow" target="_blank"> GitHub个人访问令牌</a>。复制粘贴或记下您的GitHub个人访问令牌，用于步骤#2。另外，我建议为每个存储库创建一个新的GitHub个人访问令牌。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/b40993db4cd47ace9f219960381fb6a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*esA8LuIJODr_o-Rnue3IhQ.png"/></div></div></figure><p id="7d69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 2。创建CR_PAT库密码</strong></p><p id="5b45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，转到包含您的Docker项目的GitHub存储库的存储库设置，并<a class="ae kw" href="https://docs.github.com/en/actions/configuring-and-managing-workflows/creating-and-storing-encrypted-secrets#creating-encrypted-secrets-for-a-repository" rel="noopener ugc nofollow" target="_blank">创建一个名为<code class="fe my mz na nb b">CR_PAT</code>的存储库秘密</a>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/a1aa4cb72bca6ec20649a48fd960a284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iyXafymZHWlzKCCGsl7L4w.png"/></div></div></figure><p id="1e2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 3。创建GitHub动作工作流yaml文件</strong></p><p id="68a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在创建GitHub动作工作流yaml文件。GitHub在<a class="ae kw" href="https://github.com/actions/starter-workflows" rel="noopener ugc nofollow" target="_blank">动作/启动程序-工作流存储库</a>中创建了一个名为<strong class="ka ir">发布Docker容器</strong>的GitHub动作工作流。该工作流也可以在存储库的Actions选项卡上找到，单击<strong class="ka ir"> New Workflow </strong>按钮并在<strong class="ka ir">持续集成工作流</strong>部分下搜索<strong class="ka ir"> Publish Docker容器</strong>。点击<strong class="ka ir">设置此工作流程</strong>按钮将在GitHub网站上打开一个文本编辑器。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/5a2c653160f812990eabcd32bb500aae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9y37GA2QwKiJJAUigcTJpg.png"/></div></div></figure><p id="1569" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您不喜欢使用GitHub的网站来创建动作，您可以在您的计算机上创建GitHub动作工作流yaml文件，并将其提交到您的GitHub存储库。<a class="ae kw" href="https://github.com/actions/starter-workflows/blob/60765e84900ccf192eadf19a9459e67566ffaabe/ci/docker-publish.yml" rel="noopener ugc nofollow" target="_blank">在发表这篇文章的时候，最新的稳定版本可以在这里找到</a>或者<a class="ae kw" href="https://github.com/kevincoakley/twitter-stream-archive/blob/master/.github/workflows/docker-publish.yml" rel="noopener ugc nofollow" target="_blank">你可以参考我的twitter-stream-archive GitHub资源库中的docker-publish . YAML</a>。</p><p id="8e42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 4。更新IMAGE_NAME </strong></p><p id="b030" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦<code class="fe my mz na nb b">/.github/workflows/docker-publish.yaml</code>在一个编辑器中打开，无论是在GitHub的网站上还是在你的电脑上，找到<code class="fe my mz na nb b">IMAGE_NAME</code>变量并将其更改为你想要调用Docker图像的名称。<code class="fe my mz na nb b">IMAGE_NAME</code>可以是任何东西，不必与库名相同，但是为了简单起见，我总是将<code class="fe my mz na nb b">IMAGE_NAME</code>设置为GitHub库名。</p><pre class="mi mj mk ml gt nf nb ng nh aw ni bi"><span id="62f0" class="nj lf iq nb b gy nk nl l nm nn">env:  <br/>  # TODO: Change variable to your image's name.  <br/>  IMAGE_NAME: <strong class="nb ir">&lt;docker-image-name&gt;</strong></span></pre><p id="01d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 5。提交并推送GitHub动作工作流yaml文件</strong></p><p id="a256" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，在更新了<code class="fe my mz na nb b">IMAGE_NAME</code>之后，继续将<code class="fe my mz na nb b">/.github/workflows/docker-publish.yaml</code>提交到您的存储库中。如果您提交了对<code class="fe my mz na nb b">master</code>分支的更改，那么Publish Docker Container GitHub动作应该会为您的GitHub存储库创建一个Docker映像。您可以通过GitHub个人资料上的Packages选项卡来验证Docker映像是否已创建:<strong class="ka ir">https://github.com/&lt;GitHub-username&gt;？tab =包装</strong>。如果有问题，那么您可以通过访问<strong class="ka ir">https://github.com/&lt;github-username&gt;/&lt;GitHub-repository&gt;/actions</strong>并查看GitHub操作输出来排除故障。</p><p id="5253" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您将更改提交到除了<code class="fe my mz na nb b">master</code>之外的分支，那么您会注意到Docker映像没有构建。根据发布Docker容器GitHub操作中的<code class="fe my mz na nb b">on</code>定义，Docker映像仅在git推送到<code class="fe my mz na nb b">master</code>分支时创建(Docker映像标记为最新),或者在通过git tag命令从<code class="fe my mz na nb b">v</code>开始创建新的git标记时创建，或者在GitHub网站上创建新版本时创建。</p><pre class="mi mj mk ml gt nf nb ng nh aw ni bi"><span id="bdd0" class="nj lf iq nb b gy nk nl l nm nn">on:<br/>  push:<br/>    # Publish `master` as Docker `latest` image.<br/>    branches:<br/>      - master<br/><br/>    # Publish `v1.2.3` tags as releases.<br/>    tags:<br/>      - v*<br/><br/>  # Run tests for any PRs.<br/>  pull_request:</span></pre><p id="bb2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在你有了一个由GitHub的容器注册表托管的工作Docker映像，但是我们还没有准备好将这个Docker映像部署到Kubernetes。默认情况下，新创建的GitHub容器注册表Docker映像是私有的。下面我将向您展示如何公开GitHub容器注册Docker映像，这样您就可以将GitHub容器注册Docker映像拉至您的Kubernetes集群而无需认证，我还将向您展示如何认证您的Kubernetes集群以拉下私有GitHub容器注册Docker映像。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="7678" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">如何公开GitHub容器注册表Docker图像</h1><p id="ffa7" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">如果你不在乎保持你的GitHub容器注册Docker图像的私密性，那么我推荐你公开你的GitHub容器注册Docker图像。一旦GitHub容器注册表出测试版，我相信GitHub会向用户收取存储私有图像的费用。</p><p id="6f68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了公开GitHub容器注册表Docker映像，请按照以下步骤操作:</p><p id="1610" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1.转到您的<strong class="ka ir"> GitHub档案上的<strong class="ka ir">包</strong>选项卡。</strong>包选项卡的直接URL是<strong class="ka ir">https://github.com/&lt;github-username&gt;？tab =包装</strong>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/2aa714c0fe2f812fd53a012863bd93a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cBX1cWzh7TwnMJuvtLWp-w.png"/></div></div></figure><p id="b72d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.选择Docker图像</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/a5502c7bf18c4fd9a6f8b61664cf6293.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mi9qmCHDmqCJC6mvvxZHXA.png"/></div></div></figure><p id="c55c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.转到<strong class="ka ir">编辑包下的<strong class="ka ir">包设置</strong>。</strong></p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/a18e52e34f0dff2b9b9e53b71c78951c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jJPvlIGw9GQTtgCvmHw5sQ.png"/></div></div></figure><p id="1121" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4.点击<strong class="ka ir">张扬</strong>按钮。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/f7b41f49b76a925a7c898afe0a328441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QytckGVYpcQJlp4Xzom_ww.png"/></div></div></figure><p id="c4ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在你的GitHub容器注册Docker镜像是公开的。任何人都可以通过GitHub个人资料上的Packages选项卡找到它，并将其下拉到他们的Docker系统。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="2237" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">如何用Kubernetes提取公共GitHub容器注册Docker图像</h1><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/81c6dfb5cd621742f6f0dbb3aff7fb50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7HRxnisHCLSsRiKf3Xs0Xw.png"/></div></div></figure><p id="1a9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果GitHub容器注册表中的Docker映像是公开的，那么您所要做的就是更新Kubernetes部署中的<code class="fe my mz na nb b">image</code>键定义。如果您使用Docker Hub，请更改图像值:</p><pre class="mi mj mk ml gt nf nb ng nh aw ni bi"><span id="8127" class="nj lf iq nb b gy nk nl l nm nn">containers:<br/>  - name: twitter-stream-archive<br/>    image: <strong class="nb ir">&lt;docker-hub-username&gt;/&lt;docker-image-name&gt;:&lt;tag&gt;</strong></span></pre><p id="9f58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用ghcr.io Docker注册服务器:</p><pre class="mi mj mk ml gt nf nb ng nh aw ni bi"><span id="6a0b" class="nj lf iq nb b gy nk nl l nm nn">containers:<br/>  - name: twitter-stream-archive<br/>    image: <strong class="nb ir">ghcr.io/&lt;github-username&gt;/&lt;docker-image-name&gt;:&lt;tag&gt;</strong></span></pre><p id="3b12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果有任何问题，图像值应该是什么去<strong class="ka ir">https://github.com/&lt;github-username&gt;？tab=packages </strong>并选择封装。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/65e925a01017fb4e2cfdc2c610805262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UKaqh3gwwcfqDPbyTv8Wng.png"/></div></div></figure><p id="9b17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">部署定义更新后，使用<code class="fe my mz na nb b">kubectl</code>应用更新的YAML文件，Kubernetes将终止运行Docker Hub Docker映像的Pod，并创建一个运行GitHub容器注册Docker映像的新Pod。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="b6cb" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">如何用Kubernetes拉私有GitHub容器注册Docker图像</h1><p id="71d0" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">如果GitHub容器注册docker映像是私有的，那么您必须在Kubernetes中创建docker-registry secret，以便向GitHub容器注册服务进行认证，从而下载Docker映像。<em class="mu">注意:docker-registry secret必须在每个Kubernetes名称空间中创建，它将提取docker图像</em>。docker-registry secret将包含您的GitHub用户名和一个GitHub个人访问令牌。我建议为每个Kubernetes集群创建一个新的<a class="ae kw" href="https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token" rel="noopener ugc nofollow" target="_blank"> GitHub个人访问令牌</a>,不要重复使用为GitHub动作创建的个人访问令牌来创建Docker映像。</p><p id="ad61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦你有了一个新的GitHub个人访问令牌，你就可以运行下面的<code class="fe my mz na nb b">kubectl</code>命令来创建docker-registry secret:</p><pre class="mi mj mk ml gt nf nb ng nh aw ni bi"><span id="b88e" class="nj lf iq nb b gy nk nl l nm nn">kubectl -n <strong class="nb ir">&lt;k8s-namespace&gt;</strong> create secret docker-registry <strong class="nb ir">&lt;k8s-docker-registry-secret-name&gt;</strong> --docker-server=ghcr.io --docker-username=<strong class="nb ir">&lt;github-username&gt;</strong> --docker-password=<strong class="nb ir">&lt;github-personal-access-token&gt;</strong>  --docker-email=<strong class="nb ir">&lt;email-address&gt;</strong></span></pre><p id="53a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建docker-registry secret之后，您可以更新和应用您的Kubernetes部署定义，并添加<code class="fe my mz na nb b">imagePullSecrets</code>键。下面是我的twitter流存档项目中的一个例子:</p><pre class="mi mj mk ml gt nf nb ng nh aw ni bi"><span id="4ae7" class="nj lf iq nb b gy nk nl l nm nn">---<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: twitter-stream-archive-deployment<br/>  labels:<br/>    app: twitter-stream-archive<br/>  namespace: twitter-stream-archive<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: twitter-stream-archive<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: twitter-stream-archive<br/>    spec:<br/>containers:<br/>  - name: twitter-stream-archive<br/>    image: ghcr.io/&lt;github-username&gt;/&lt;docker-image-name&gt;:&lt;tag&gt;<br/><strong class="nb ir">imagePullSecrets:<br/>  - name: &lt;k8s-docker-registry-secret-name&gt;</strong></span></pre><p id="b440" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意<code class="fe my mz na nb b">imagePullSecrets</code>键与<code class="fe my mz na nb b">containers</code>键在同一层，不是<code class="fe my mz na nb b">containers</code>键的子键。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="fd69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！GitHub通过使用GitHub操作创建了一个美妙的CI/CD体验，使得将所有Docker图像迁移到GitHub容器注册表变得很容易。通过一些实践，您应该能够在几分钟内将Docker项目从Docker Hub迁移到GitHub容器注册表。</p></div></div>    
</body>
</html>