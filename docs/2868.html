<html>
<head>
<title>How to avoid SOLID principles violations in Vue. JS application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何避免在Vue中违反坚实的原则？JS应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/https-medium-com-manuustenko-how-to-avoid-solid-principles-violations-in-vue-js-application-1121a0df6197?source=collection_archive---------0-----------------------#2019-08-19">https://itnext.io/https-medium-com-manuustenko-how-to-avoid-solid-principles-violations-in-vue-js-application-1121a0df6197?source=collection_archive---------0-----------------------#2019-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b0d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几天前，我的朋友Philipp决定创建一个新的业务(一个制作美味饼干的面包店),并请我帮助他创建一个todo list应用程序，他可以在其中写下自己的任务。他决定用Vue。JS作为一个前端框架，但真的不知道如何在未来保持他的应用程序易于扩展和维护。他听到一些关于固体的神话(固体是什么意思？？？)原则和清晰的架构，但不知道如何在Vue中使用它们。JS app。</p><p id="040d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我想讨论如何在我们的Vue中避免违反坚实的原则。JS项目。</p><p id="48ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">什么是固体？SOLID是由Michael Feathers创造的首字母缩写词，由美国软件工程师Robert c .“<em class="kl">Bob叔叔</em>”Martin在他的书“<em class="kl">Design Principles and Design Patterns”中推广。这些原则是面向对象编程范例中非常重要的部分，旨在使我们的程序在下一次开发中更加灵活、可读和可维护。坚实的原则包括下一个概念:</em></p><ul class=""><li id="acca" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">单一责任原则</li><li id="2723" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">开闭原理</li><li id="3050" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">利斯科夫替代原理</li><li id="e538" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">界面分离原理</li><li id="bdb4" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">从属倒置原则</li></ul><p id="98dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看real Vue中的所有这些原则。JS项目以及我们如何避免违反原则。我们将创建一个简单的待办事项列表应用程序。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h2 id="9f0d" class="lh li iq bd lj lk ll dn lm ln lo dp lp jy lq lr ls kc lt lu lv kg lw lx ly lz bi translated"><strong class="ak">先决条件</strong></h2><p id="6443" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">让我们创建一个新的Vue。使用vue cli的JS应用程序(<a class="ae mf" href="https://cli.vuejs.org/" rel="noopener ugc nofollow" target="_blank">https://cli.vuejs.org/</a>)。</p><p id="692f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mg mh mi mj b">vue create todo-app</code></p><p id="2470" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的应用程序中，我将使用vue 2.6.10 + typescript 3.4.3，所以如果你还不熟悉typescript，你可以在这里找到文档(<a class="ae mf" href="https://www.typescriptlang.org/docs/home.html" rel="noopener ugc nofollow" target="_blank">https://www.typescriptlang.org/docs/home.html</a>)。</p><p id="c501" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装后，我们必须清理一下，并删除所有演示组件。我们的<code class="fe mg mh mi mj b">src</code>目录结构如下所示</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="85ba" class="lh li iq mj b gy ms mt l mu mv">src<br/>----views<br/>-------Home.vue<br/>----App.vue<br/>----main.ts<br/>----shims-tsx.d.ts<br/>----shims-vue.d.ts<br/>----types.ts</span></pre><figure class="mk ml mm mn gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6873" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们准备好出发了…</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h2 id="0c6e" class="lh li iq bd lj lk ll dn lm ln lo dp lp jy lq lr ls kc lt lu lv kg lw lx ly lz bi translated"><strong class="ak">单一责任原则</strong></h2><p id="7152" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">假设我们修改了<code class="fe mg mh mi mj b">views/Home.vue</code>组件来获取任务列表并显示给用户。它可能看起来像这样:</p><figure class="mk ml mm mn gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="d622" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上，我们在一个<code class="fe mg mh mi mj b">views/Home.vue</code>组件中创建了整个应用程序。这里我们可以看到SRP的违反，它告诉我们:“<strong class="jp ir"> <em class="kl">每个组件应该只有一个理由来改变</em> </strong>”。但是，我们有多少理由去改变这个成分呢？</p><p id="6c8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.我们希望更改fetchTodos()方法来获取Todos。这可能是任何改变的原因:获取到axios或任何其他库、api、方法本身等等。</p><p id="1436" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.我们想添加更多的元素到这个组件:侧栏，菜单，页脚等。</p><p id="92f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.我们想改变现有的元素:标题或待办事项列表。</p><p id="ff14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们发现了至少三个我们想要改变<code class="fe mg mh mi mj b">views/Home.vue</code>的理由。真正的问题开始于应用程序何时会增长和变化。它变得太大，我们不再记得我们的代码，失去了我们的控制。我们可以通过将每个原因提取到它自己的组件、类或函数来避免SRP违规。让我们做一些重构。</p><p id="f8ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们可以通过创建一个新的Api类来提取fetching todos方法，并将其放到<code class="fe mg mh mi mj b">api.ts</code>文件中。</p><figure class="mk ml mm mn gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0b2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们将标题提取到一个新的功能组件<code class="fe mg mh mi mj b">components/Header.vue</code></p><figure class="mk ml mm mn gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e2d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一步是提取待办事项列表。</p><figure class="mk ml mm mn gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f832" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在<code class="fe mg mh mi mj b">views/Home.vue</code>中的代码现在看起来更加清晰易读。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h2 id="5d2d" class="lh li iq bd lj lk ll dn lm ln lo dp lp jy lq lr ls kc lt lu lv kg lw lx ly lz bi translated"><strong class="ak">开闭原理(OCP) </strong></h2><p id="486d" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">让我们更仔细地看看我们的<code class="fe mg mh mi mj b">components/TodoList.vue</code>。我们可以看到，该组件获取待办事项列表，并创建一堆卡片来表示我们的任务。然而，如果我们想改变这些卡片，甚至将我们的任务显示为表格，而不是卡片，会发生什么呢？我们必须改变(修改)我们的组件。现在看起来有点呆板。OCP告诉我们:“<strong class="jp ir"> <em class="kl">组件对于扩展应该是打开的，对于修改</em> </strong>应该是关闭的”。让我们解决这个违规问题。</p><p id="8fe8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用vue插槽使我们的<code class="fe mg mh mi mj b">components/TodoList.vue</code>更加灵活。</p><figure class="mk ml mm mn gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="dfe7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并将我们的卡片移动到一个单独的组件<code class="fe mg mh mi mj b">components/TodoCard.vue</code></p><figure class="mk ml mm mn gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f40b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并更新<code class="fe mg mh mi mj b">views/Home.vue</code></p><figure class="mk ml mm mn gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="b41f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以轻松地用另一个组件替换我们的任务可视化。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="1957" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">利斯科夫替代原理(LSP) </strong></p><p id="f734" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来研究我们的Api类。</p><p id="3894" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将Api类重命名并重构为BaseApi类，并将其移动到一个单独的目录中<code class="fe mg mh mi mj b">api/BaseApi.ts</code></p><figure class="mk ml mm mn gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c5af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，BaseApi类有一个fetch()方法，它接受一个参数“url”。</p><p id="cc05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">出于某些原因，我们决定在应用程序中添加axios库。</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="ec9f" class="lh li iq mj b gy ms mt l mu mv">npm install --save axios</span></pre><p id="8fc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并创建一个新类AxiosApi，它是<code class="fe mg mh mi mj b">api/AxiosApi.ts</code>中BaseApi的子类</p><figure class="mk ml mm mn gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e01f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们在<code class="fe mg mh mi mj b">views/Home.vue</code>的fetchTodos()方法中用一个新的AxiosApi(子类)替换我们的BaseApi(父类)</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="76be" class="lh li iq mj b gy ms mt l mu mv">import { AxiosApi } from '@/api/AxiosApi'</span><span id="4f80" class="lh li iq mj b gy mz mt l mu mv"><em class="kl">...<br/>async </em>fetchTodos(): <em class="kl">Promise</em>&lt;<em class="kl">ITodo</em>[]&gt; {<br/>  <em class="kl">const </em>api = <em class="kl">new </em>AxiosApi()<br/>  <em class="kl">return await </em>api.fetch('todos')<br/>}</span></pre><p id="6170" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它会破坏我们的应用程序，因为我们没有遵循LSP:“<strong class="jp ir"><em class="kl">当扩展一个类时，记住你应该能够传递子类的对象来代替父类的对象，而不会破坏客户端代码</em> </strong>”。</p><p id="2f61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您所注意到的，我们将object作为参数传递给AxiosApi类的fetch()方法，但是BaseApi类接受string。在这种情况下，我们不能毫无痛苦地用父类替换子类。</p><p id="e170" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们迅速修理它。</p><figure class="mk ml mm mn gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4000" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以两者都用，还有BaseApi和AxiosApi。我们甚至可以更深入，通过在<code class="fe mg mh mi mj b">api/api.ts</code>中创建Api类来改进我们的代码，该类扩展了基类并具有私有属性提供者</p><figure class="mk ml mm mn gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ca23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在<code class="fe mg mh mi mj b">views/Home.vue</code>中的方法fetchTodos()不需要知道我们正在使用哪个库，我们可以很容易地在Api类中切换提供者。</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="2ad1" class="lh li iq mj b gy ms mt l mu mv"><em class="kl">import </em>{ Api } <em class="kl">from </em>'@/api/api'</span><span id="5861" class="lh li iq mj b gy mz mt l mu mv">...</span><span id="d6ce" class="lh li iq mj b gy mz mt l mu mv"><em class="kl">async </em>fetchTodos(): <em class="kl">Promise</em>&lt;I<em class="kl">Todo</em>[]&gt; {<br/>  <em class="kl">const </em>api = <em class="kl">new </em>Api()<br/>  <em class="kl">return await </em>api.fetch('todos')<br/>}</span></pre></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h2 id="8baf" class="lh li iq bd lj lk ll dn lm ln lo dp lp jy lq lr ls kc lt lu lv kg lw lx ly lz bi translated"><strong class="ak">接口隔离原理(ISP) </strong></h2><p id="5b6b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们现在把我们的任务想象成卡片。让我们也在<code class="fe mg mh mi mj b">components/TodoRow.vue</code>中添加简单的任务列表</p><figure class="mk ml mm mn gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ffba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并用列表可视化代替卡片可视化</p><figure class="mk ml mm mn gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7be3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您所注意到的，我们在TodoCard.vue和TodoRow.vue中将整个todo对象作为prop发送，但是我们只使用了该对象的一部分。我们没有在两个组件中都使用<code class="fe mg mh mi mj b">userId</code>属性，也没有在TodoCard.vue中使用<code class="fe mg mh mi mj b">id</code>属性。我们违反了ISP规定:“<strong class="jp ir">组件不应该被强制依赖于它们不使用的</strong>属性和方法”。</p><p id="6fa2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有很多方法可以解决这个问题:</p><ul class=""><li id="1df2" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">将Todo接口分割成几个较小的接口</li><li id="ece5" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">仅将使用过的属性传递给组件</li></ul><p id="880b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们重构代码，使用功能性(无状态)组件。</p><figure class="mk ml mm mn gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a35e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在看起来好多了。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h2 id="d3fe" class="lh li iq bd lj lk ll dn lm ln lo dp lp jy lq lr ls kc lt lu lv kg lw lx ly lz bi translated"><strong class="ak">依存倒置原则(DIP) </strong></h2><p id="1059" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">DIP告诉:“<strong class="jp ir">高级类(组件)不应该依赖低级类(组件)。两者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象。</strong></p><p id="b908" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">什么叫高等级和低等级。</p><ul class=""><li id="9bb3" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">低级类实现基本操作，如使用API。</li><li id="6fd2" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">高级类包含复杂的业务逻辑，指导低级类做一些事情。</li></ul><p id="6413" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们回到我们的Api类，在<code class="fe mg mh mi mj b">types.ts</code>中为我们的Api类创建一个新的接口。</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="c0e1" class="lh li iq mj b gy ms mt l mu mv"><em class="kl">export interface IApi </em>{<br/>  fetch(url: <em class="kl">string</em>): <em class="kl">Promise</em>&lt;<em class="kl">any</em>&gt;<br/>}</span></pre><p id="fd6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并更新我们在<code class="fe mg mh mi mj b">api</code>目录和<code class="fe mg mh mi mj b">views/Home.vue</code>中的所有api类。</p><figure class="mk ml mm mn gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0b84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们的低级(api类)和高级(views/Home.vue)类依赖于一个接口。原来依赖的方向已经颠倒了:低级api类现在依赖于高级抽象。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h2 id="57bd" class="lh li iq bd lj lk ll dn lm ln lo dp lp jy lq lr ls kc lt lu lv kg lw lx ly lz bi translated"><strong class="ak">结论</strong></h2><p id="5b9c" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在这篇文章中，我们在small Vue中讨论了所有坚实的原理。JS项目。我希望它能帮助您避免项目中的一些架构错误，并提高您对坚实原则的理解。</p><p id="c94a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码可以在这里找到<a class="ae mf" href="https://github.com/NovoManu/SOLID-vue" rel="noopener ugc nofollow" target="_blank">https://github.com/NovoManu/SOLID-vue</a></p><p id="dbb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在推特上关注我<a class="ae mf" href="https://twitter.com/ManuSEngineer" rel="noopener ugc nofollow" target="_blank">https://twitter.com/ManuSEngineer</a></p><p id="9a07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">祝你好运！</p></div></div>    
</body>
</html>