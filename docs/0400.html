<html>
<head>
<title>Microservices the Event Sourcing way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务事件源方式</h1>
<blockquote>原文：<a href="https://itnext.io/microservices-the-event-sourcing-way-124a8a772680?source=collection_archive---------2-----------------------#2018-03-05">https://itnext.io/microservices-the-event-sourcing-way-124a8a772680?source=collection_archive---------2-----------------------#2018-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/714e77231f45356aa6eab1b3ba0d4d0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e4gymWUORWorIlQ6."/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae jd" href="https://unsplash.com/@neonbrand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NeONBRAND </a>拍摄的照片</figcaption></figure><div class=""/><div class=""><h2 id="d1c0" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">吻别巨石</h2></div><p id="01b9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fmicroservices-the-event-sourcing-way-124a8a772680" rel="noopener ugc nofollow" target="_blank"> <em class="lr">点击这里在LinkedIn上分享这篇文章</em> </a></p><p id="ab20" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/from-monoliths-to-microservices-b6b851ab43e3"> <em class="lr">上一篇</em> </a>文章中，我写了一种在从单片架构迁移到微服务时加快迭代速度的方法，以及一旦单片被驯服并在CI/CD管道中作为Kubernetes部署运行时使用<a class="ae jd" href="https://www.martinfowler.com/bliki/StranglerApplication.html" rel="noopener ugc nofollow" target="_blank"> <em class="lr">扼杀者模式</em> </a>。</p><p id="093c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在是时候更深入一点了，看看<a class="ae jd" href="https://martinfowler.com/eaaDev/EventSourcing.html" rel="noopener ugc nofollow" target="_blank"> <em class="lr">事件源</em> </a>和<a class="ae jd" href="https://martinfowler.com/bliki/CQRS.html" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> CQRS </em> </a>作为圣杯，它将防止你陷入迁移到微服务的许多经典陷阱，但也可能发现新的陷阱。</p><p id="a5e2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦你开始考虑你可能遇到的问题，在你刚刚建立的同一个Kubernetes <em class="lr">围墙花园</em>中的Monolith和你的新的、萌芽中的微服务，<em class="lr">数据一致性</em>可能是需要担心的事情。因为您希望尊重微服务的独立数据存储库的<em class="lr">架构约束，但不可避免的是，一些数据会在Monolith和一个或多个微服务数据存储库中找到需要的方式。</em></p><blockquote class="ls lt lu"><p id="4cd7" class="kv kw lr kx b ky kz kh la lb lc kk ld lv lf lg lh lw lj lk ll lx ln lo lp lq ij bi translated">想象一下，你得到了一部新手机，但旧手机上仍有内容，你还没有真正弄清楚新手机是如何工作的，所以你把旧手机保持在wifi上，然后…嗯，我认为这个比喻有点道理。</p></blockquote><p id="d1b6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">回到正题。因为毕竟一切都是(或者可以成为)服务，所以您仍然可以从一个地方到另一个地方访问数据。那个<em class="lr">感觉很安心</em>。你站在白板前，开始画一个箭头，从整体到微服务A，然后另一个，到微服务C，然后另一个，回到整体，然后另一个…</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ly"><img src="../Images/b7ab8f09bf95523872f32e7bf52f0d34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Bs4LNTMPlfMqmgz627scw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">虚构的图，不要在家里尝试</figcaption></figure><p id="0e1f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">很快，事情将开始看起来像这个图表，然后你会开始怀疑这个微服务的想法是否有一些根本性的缺陷。</p><p id="2adb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，你正在做的是用<em class="lr">网络调用</em>替换旧的但是可靠的<em class="lr">进程调用</em>，用<em class="lr">分布式系统</em>替换<em class="lr">单个进程</em>，并且你非常清楚<a class="ae jd" href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing" rel="noopener ugc nofollow" target="_blank"> <em class="lr">网络是可靠的</em> </a>，并且还有你的计算机科学教授告诉你关于<a class="ae jd" href="https://en.wikipedia.org/wiki/CAP_theorem" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> CAP定理</em> </a>的记忆，并且感觉他们一直从你的肩膀后面偷看你的白板而且<em class="lr">他们也不帮忙！</em></p><p id="8ad6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">大约10分钟后，你也可能突然有一个灯泡亮了，这是一个充满希望的时刻，你开始认为这(当然)是HTTP，所以你可以<em class="lr">缓存</em>它。那就是你在上面画红框的时候。尤里卡。或者不是。你很快就会意识到缓存并不能拯救世界:你需要注意的一切都是系统状态的一个<em class="lr">突变</em>，缓存是为了别的事情。</p><p id="5959" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在30分钟的时候，一旦你开始考虑在这个<em class="lr">弗兰克建筑中进行监控、故障排除和调试，一种微妙而纯粹的恐怖感就会出现。</em>你记得有一天你在某处读到关于<em class="lr">分布式跟踪</em>的内容。你<a class="ae jd" href="https://www.google.com/search?q=distributed+tracing" rel="noopener ugc nofollow" target="_blank"> <em class="lr">谷歌一下</em> </a>，很快就意识到这不是银弹，而只是你需要实现<em class="lr">和</em>的其他东西。哎哟。</p><p id="68f4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还不到一个小时，就很明显地发现，您还必须实现一种机制<em class="lr">来重试失败的HTTP调用</em>，可能采用指数回退策略，降低您的应用程序的可用性，然后，哦不，在<em class="lr">网络分区</em>的情况下，数据可能不一致(只是说“<em class="lr">有人在以太网电缆上绊倒了”</em>的更好的说法)。因为<a class="ae jd" href="https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/" rel="noopener ugc nofollow" target="_blank"> <em class="lr">上限不仅仅是一个定理</em> </a>。</p><p id="a46d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是嘿，至少你可以扩展这些微服务，所以性能应该会更好，不是吗？这会让你高兴一点点，直到你想到<a class="ae jd" href="https://www.infoq.com/articles/N-Plus-1" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> N+1问题</em> </a>。</p><p id="1412" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那是什么？想起<em class="lr">中的</em>。我是说，这个网站。想象一下，有一个存储<em class="lr">帖子</em>的微服务和一个存储<em class="lr">掌声</em>的微服务。并考虑如何返回一个包含相应掌声计数的<em class="lr"> N </em>帖子列表(1个查询)(每个帖子1个查询，所以<em class="lr"> N </em>)。就这样，<em class="lr"> N+1个查询</em>。由于每个查询都有大约30毫秒的延迟，您可能要等将近一秒钟才能在主页上显示30篇文章的列表。效率不是很高。</p><p id="0b3e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">“为什么没人告诉我？”</p><p id="78ff" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你开始怀念那块巨石了吗？</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="3a7d" class="mk ml jg bd mm mn mo mp mq mr ms mt mu km mv kn mw kp mx kq my ks mz kt na nb bi translated">活动采购和CQRS的救援</h1><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nc"><img src="../Images/2fa958c2206108f201eea987389aac44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z-y6MRVqKcS1wmQs."/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@vincentiu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">文森特·索罗门</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="4978" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">事件采购</em>和<em class="lr"> CQRS </em>的基本思路其实很简单。你可以在<a class="ae jd" href="https://www.google.com/search?q=event+sourcing+and+cqrs" rel="noopener ugc nofollow" target="_blank">更有声望的来源</a>上读到它，但是快速电梯间距是应用程序状态中的每一个<em class="lr">突变</em>(或者CQRS的说法是<em class="lr">命令</em>)都被发布到一个<em class="lr">事件流</em>。然后，多个服务订阅<em class="lr">事件流</em>，读取它们感兴趣的事件，并将结果状态保存在独立的数据存储中。</p><p id="9af1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看起来是这样的:</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/2b0ca395d822ec46676c60534d68d0ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AkWkPq9fTg8Vqh18gh0qBg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">基本的准系统活动采购</figcaption></figure><p id="cb5f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于每个微服务，您都有一个订阅事件流的函数，侦听新事件，如果事件与服务的领域相关，则将它们的影响保存到服务数据存储中。每个订阅可以捕获一个事件(或其中的一部分),并保存在每个数据存储中。</p><p id="fa8c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">数据存储的设计目标是优化读取或查询，以便将面向它们的微服务的延迟降至最低。这就是CQRS 的意义。</p><p id="8448" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感到困惑？想看下一个故事吗？你的巨石呢？</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/4830855aa48a3788d1da58a269483067.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k752_FN2Xh4mzJNA6y9DyA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">中型(虚拟)微服务架构</figcaption></figure><p id="323c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">很公平，所以为了让事情更具体，让我们继续假设你正在这个架构上构建介质:你有一个用于<em class="lr">成员档案</em>的微服务，一个用于<em class="lr">帖子</em>，一个用于<em class="lr">鼓掌</em>，一个用于<em class="lr">出版物</em>。可能还有一些，因为你不知道的秘密，因为你不在那里工作。</p><p id="d498" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以看到它在上面的样子。</p><blockquote class="ls lt lu"><p id="2986" class="kv kw lr kx b ky kz kh la lb lc kk ld lv lf lg lh lw lj lk ll lx ln lo lp lq ij bi translated">声明:我真的不知道Medium是如何构建的。我想如果我真的想知道的话，我可以谷歌一下。</p></blockquote><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/7cd24507b4b79572e1c50b54a8b20f30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iQ5NRcinRpz5nbZlai18NQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">发布后事件示例</figcaption></figure><p id="7075" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，在这个中型微服务架构中，当我最终完成这篇文章并将其发布到<em class="lr">帖子</em>微服务时，它将依次更新自己的数据存储，然后在事件流中发布一个事件，用于应用程序中可能关心我的帖子发生了什么的任何其他内容。</p><p id="375e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">同样订阅了事件流的<em class="lr">会员资料</em>服务也将获取该事件的一些片段，在我的资料中添加该故事的链接(可能还会获取<em class="lr">标题</em>和<em class="lr">副标题</em>，以及缩略图的链接)。如果我将此作为出版物的一部分发布(比如说<a class="ae jd" href="https://itnext.io/" rel="noopener ugc nofollow" target="_blank"><em class="lr">it next . io</em></a><em class="lr">)</em><em class="lr">出版物</em>服务的订阅者也将捕获事件的一些片段，并更新<em class="lr">出版物数据库</em>。单个事件，以及每个微服务的大量更新。</p><p id="c0e0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可能会问“为什么？”。因为通过这种方式，当我查看我的个人资料时，我可以获得我已经发布的故事列表，并且这样做不需要<em class="lr">成员个人资料</em>服务来查询或者甚至知道<em class="lr">帖子</em>服务。<em class="lr">帖子</em>服务实际上可能会中断几秒钟，我不知道。当然，有人会注意到，但不是我，对我来说这才是最重要的。</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/8e2368b8e8aef930196bafb9cafebf75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GkVz_25g9_93RCSMfcE1bw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">Clap事件示例</figcaption></figure><p id="430c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个故事一旦发表，你可能会决定为它<em class="lr">鼓掌</em>。这就是<em class="lr">拍手</em>服务的另一个事件，它也被<em class="lr">帖子</em>服务捕获，为什么不被<em class="lr">个人资料</em> <em class="lr">服务</em>和发布服务捕获。你鼓掌，事情就发生了。</p><p id="3b2f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">试试吧:)。</em></p><p id="8820" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个模型中，<em class="lr">每个服务对某些数据或领域</em>都是权威的，但是每个服务也知道为查询提供有意义的响应所需的其他一切，而不需要向其他服务请求任何东西。</p><p id="b932" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看到了吗？现在一切都<em class="lr">解开</em>，每个微服务都是自力更生，就像长大了一样。</p><p id="1361" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这一点上，我需要说，如果这一切让你想起了<a class="ae jd" href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" rel="noopener ugc nofollow" target="_blank"><em class="lr"/></a>，那么，你是对的。类似的，但是<em class="lr">有点扭曲</em>。</p><p id="4295" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在事件源中，<em class="lr">事实的单一来源是事件流</em>，而不是单个服务数据存储。此外，与PubSub相反，事件在被读取时不会从流中移除。仅这个属性，事件流的<em class="lr">不变性</em>和<em class="lr">持久性</em>，使得每个数据存储都可以被清除，并且可以通过从时间开始开始读取事件来<em class="lr">重建。</em></p><p id="efbb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好吧，你可能会说，这是伟大的，但发生了什么事呢？因为<em class="lr">中</em>当然有，而且需要去。</p><p id="55bd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好吧，它来了。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="b2b5" class="mk ml jg bd mm mn mo mp mq mr ms mt mu km mv kn mw kp mx kq my ks mz kt na nb bi translated">进入巨石</h1><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nf"><img src="../Images/af59b3f803ad698e26478eba3904f327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HbSFynjXIX1JvIfq."/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">丹尼尔·冯·阿彭在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="3ca8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以，我已经谈到了<em class="lr">扼杀整体</em>，以及如何逐渐将功能从整体转移到微服务。我已经提到过，活动采购是一种解决方案。但是怎么做呢？</p><p id="076c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">简单:让整块石头成为<em class="lr">事件发射器</em>。单块应用程序状态的每一个变化都作为一个新事件发送到流中。然后，您可以让微服务订阅这些事件，并更新它们的数据存储。无论Monolith和整个应用程序状态发生什么变化，现在都会反映在微服务自己的数据存储中。</p><p id="ea2f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还需要<em class="lr">创建一个初始状态</em>，从Monolith datastore中提取当前状态并将其放入事件流中。把它想象成你将要写的最后一篇ETL(我在骗谁呢？).</p><p id="abcf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦对一个<em class="lr">域</em>有权威的服务赶上了，就该开始向它路由只读流量了。<em class="lr">突变</em>仍将被路由至整块，直到<em class="lr">域</em>不再与整块相关。</p><p id="daea" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">回到<em class="lr">中的</em>，让我们想象你从编写一个<em class="lr"> ETL </em>开始，它将所有的<em class="lr">帖子</em>加载到事件流中。并且，您在Monolith中添加代码，以便当一个新的帖子被创建(或者被编辑)时，它将一个相应的事件发送到流中。</p><p id="f0f6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这可能需要几天的时间，但有一天早上你会看到你的帖子订阅功能已经赶上了，这意味着我们为帖子提供的微服务已经准备好接收阅读流量了。</p><p id="de6a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您仍然在向Monolith发送突变(或<em class="lr">写流量</em>，因为那里仍然有许多其他函数需要知道帖子是何时创建的。比方说，Monolith中的<em class="lr">成员档案</em>功能。跑的那个</p><pre class="lz ma mb mc gt ng nh ni nj aw nk bi"><span id="d7b5" class="nl ml jg nh b gy nm nn l no np">SELECT * FROM posts WHERE member_id=123243 LIMIT 30</span></pre><p id="2d6d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">是的，那还是需要的。</p><p id="83e6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是你是无情的，你继续为其他<em class="lr">域</em>写ETL，一个接一个。简介？已迁移。拍手？完成了。你是一个<em class="lr">迁徙英雄</em>。</p><p id="4424" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦Monolith不再需要知道一个特定的<em class="lr">域</em>，那么你就可以开始将写流量(突变)路由到微服务。一个接一个，你已经在不丢失数据和保持(至少<em class="lr">最终</em>)系统一致性的情况下扼杀了这个整体。</p><p id="fdc8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，它会是这样的:</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nq"><img src="../Images/c817f694ac8853b399cb607e890f5b5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gSVClgZDAT59UnXscokbbw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">整个</figcaption></figure><p id="ef6f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下一篇<a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/creating-a-blueprint-for-microservices-and-event-sourcing-on-aws-291d4d5a5817">文章</a>将详细介绍如何实现这一切(至少在AWS上，使用Kinesis、Lambda、DynamoDB、RDS、ApiGateway、CloudFront、Edge Functions、Kubernetes等等)，以及你需要接受的约束，以及你需要知道的陷阱，以使这一切工作。</p></div></div>    
</body>
</html>