<html>
<head>
<title>Kubernetes: How to Actually Do StatefulSets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes:如何实际做陈述集</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-how-to-actually-do-statefulsets-1a6f5528e901?source=collection_archive---------4-----------------------#2018-03-14">https://itnext.io/kubernetes-how-to-actually-do-statefulsets-1a6f5528e901?source=collection_archive---------4-----------------------#2018-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/258c3b74bb10cd90d76567d1d8f322cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FWYZ9mEhTs4BkeapJt634A.jpeg"/></div></div></figure></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="fd84" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><a class="ae ld" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fkubernetes-how-to-actually-do-statefulsets-1a6f5528e901" rel="noopener ugc nofollow" target="_blank">点击这里在LinkedIn上分享这篇文章</a></p><p id="a226" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">编辑:谷歌已经更新了他们的文档并修复了这个问题…</p><blockquote class="le lf lg"><p id="5ef1" class="kf kg lh kh b ki kj kk kl km kn ko kp li kr ks kt lj kv kw kx lk kz la lb lc ij bi translated">TL；StatefulSets博士刚刚在k8s 1.9中正式发布。这是我的故事，讲述了在与Google的教程和Kubernetes的官方文档争论之后，我是如何设法将StatefulSet部署到我的GKE集群的。此外，我在凌晨1:00写完这篇文章，所以如果你看到错别字，请在评论中注明。</p></blockquote><p id="2cd2" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">下面是完整的yaml文件。这个故事的要点是，我不知道如何让一个国家设置部署在GKE。部分原因是谷歌<a class="ae ld" href="https://github.com/kubernetes/kubernetes/issues/59867" rel="noopener ugc nofollow" target="_blank">没有在他们的CLI sdk工具包</a>中发布kubectl 1.9，另一部分原因是谷歌的教程没有完全充实，另一个原因可能是我就是我，把事情搞砸了。我设法部署了我的StatefulSet，这是我如何做的。如果你知道更好的方法或者知道如何工作，请在评论中给我留言:)</p><p id="f18d" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">正如我之前在<a class="lp lq ep" href="https://medium.com/u/504c7870fdb6?source=post_page-----1a6f5528e901--------------------------------" rel="noopener" target="_blank"> Medium </a>和我的个人网站上提到的，我目前正在开发一个slackbot(并在<a class="ae ld" href="https://categorylinksbot.io" rel="noopener ugc nofollow" target="_blank">https://categorylinksbot . io</a>上寻找beta用户)来帮助人们组织他们的链接。我的长期目标是为每个主要的消息平台建立一个messenger集成。然后利用这些数据建立一个比谷歌搜索更好的广告产品。在GCP之上建立一个击败谷歌搜索的广告平台的讽刺意味并没有被我忽略😜。</p><p id="d9f5" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我的slackbot需要请求之间的有状态交互。我用redis来管理这些交互。Redis很棒，但是如果redis运行的实例重新启动，那么所有的数据都会丢失。由于我在我的GKE集群中将redis作为可抢占实例的容器运行(因为我很便宜)，我的实例可以在任何时候重启，几乎没有任何警告。我需要能够定期在我的redis数据库上运行<code class="fe ll lm ln lo b"><a class="ae ld" href="https://redis.io/commands/bgsave" rel="noopener ugc nofollow" target="_blank">BGSAVE</a></code>,以便在可抢占实例再次启动时最小化最终用户问题。</p><p id="aa89" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在Kubernetes中，扩展有状态应用程序的正确方式是利用StatefulSets。StatefulSets允许您创建应用程序的副本(读:scale it ),然后它可以访问您用来存储由<code class="fe ll lm ln lo b">BGSAVE</code>创建的文件的挂载卷。</p><p id="9d01" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">首先，你需要定义一个<code class="fe ll lm ln lo b">PersistentVolume</code> (pv)。在<a class="ae ld" href="https://cloud.google.com/kubernetes-engine/docs/how-to/stateful-apps" rel="noopener ugc nofollow" target="_blank"> GCP教程</a>中，pv描述了将要挂载的卷。GCP教程中的例子有一个错误。它需要一个叫做<code class="fe ll lm ln lo b">storageClassName</code>的东西被我们创建的pvc引用。下面的示例<a class="ae ld" href="#440f" rel="noopener ugc nofollow"> </a>更新为yaml定义中的<code class="fe ll lm ln lo b">storageClassName</code>参数。没有它，我们就不能绑定到这个pv。</p><p id="11a9" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">说到装订，<code class="fe ll lm ln lo b">PersistentVolumeClaims</code> (pvc)将帮助我们做到这一点。看一下那个例子<a class="ae ld" href="#de84" rel="noopener ugc nofollow"> </a>会再次显示<strong class="kh ir">错误</strong> - &gt;否<code class="fe ll lm ln lo b">storageClassName</code>。<strong class="kh ir">免责声明:</strong>如果你没有注意，只是复制粘贴了下面的文件，我已经为你添加了。所以不客气:)</p><p id="9a60" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">现在，当您运行<code class="fe ll lm ln lo b">kubectl apply -f my-pv.yaml</code>并对您的<code class="fe ll lm ln lo b">my-pv-claim.yaml</code>文件(分别称为文件<a class="ae ld" href="#440f" rel="noopener ugc nofollow"> </a>和文件<a class="ae ld" href="#de84" rel="noopener ugc nofollow"> </a>)执行同样的操作时，您应该看到该声明能够绑定到pv，并且运行<code class="fe ll lm ln lo b">gcloud compute disks list</code>或w/e也应该显示您创建的磁盘。请阅读教程中的<a class="ae ld" href="https://cloud.google.com/kubernetes-engine/docs/how-to/stateful-apps#submitting_a_persistentvolumeclaim" rel="noopener ugc nofollow" target="_blank">部分</a>,因为它解释了当pvc没有绑定到pv时应该寻找什么。免责声明..</p><p id="3fd2" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">您需要的第三部分是与您的StatefulSet接口的服务。我有一个nginx容器来处理路由到我的应用程序的所有请求，所以这个服务已经创建好了，但是为了清楚起见，我把它放在了<a class="ae ld" href="#a90a" rel="noopener ugc nofollow"> </a>下面，可能会让那些只是复制粘贴我的内容到页脚的读者感到困惑。</p><p id="f7da" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">最后，我把StatefulSet的定义放在下面，因为制作页脚链接是一个皮塔饼(这里还有一个<a class="ae ld" href="https://medium.com/@siranachronist/it-would-be-great-if-we-could-deeplink-footnotes-or-better-yet-show-them-in-the-margins-like-how-f5c8e93464af" rel="noopener">链接</a>，我在那里学会了如何做)。Google教程和kubernetes官方文档的最后一个问题是StatefulSet定义中的<code class="fe ll lm ln lo b">volumeClaimTemplates</code>部分的用法。对于我来说，当我运行<code class="fe ll lm ln lo b">kubectl apply</code>时，我不能得到这种验证或任何东西。我试着做了很多没有运气的事情。最终我搜索了一下，找到了这篇博文。基本要点是，您应该在StatefulSet定义的<code class="fe ll lm ln lo b">volumes</code>部分中使用<code class="fe ll lm ln lo b">persistentVolumeClaim</code>关键字。</p><p id="5f6a" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">基本上，您的StatefulSet定义应该是这样的..</p><pre class="lr ls lt lu gt lv lo lw lx aw ly bi"><span id="7841" class="lz ma iq lo b gy mb mc l md me">apiVersion: apps/v1beta2<br/>kind: StatefulSet<br/>metadata:<br/>  name: [STATEFULSET_NAME]<br/>spec:<br/>  serviceName: [SERVICE_NAME]<br/>  replicas: 3<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: [APP_NAME]<br/>    spec:<br/>      updateStrategy:<br/>        type: RollingUpdate<br/>      containers:<br/>      - name: [CONTAINER_NAME]<br/>        image: ...<br/>        ports:<br/>        - containerPort: 80<br/>          name: [PORT_NAME]<br/>        volumeMounts:<br/>        - name: my-volume<br/>          mountPath: /data-or-something<br/>      <strong class="lo ir">volumes</strong>:<br/>        - ...<br/>        <!-- -->- name: <!-- -->my-volume<br/>          <strong class="lo ir">persistentVolumeClaim</strong>:<br/>            claimName: <strong class="lo ir">$$YOUR-PVC-NAME</strong></span></pre><p id="c606" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">应该就是这样！在评论区发表你的任何问题。我希望这可以作为一个很好的故障排除参考页面，帮助那些陷入StatefulSets的人。k8s社区中的每个人都说k8s仍然在努力让有状态的应用变得正确。我认为陈述集是朝着正确方向迈出的一步。它们是一个巨大的特性，将为像我这样的小开发者提供大量的价值。我希望实际上摆脱谷歌的云SQL实例，只在k8s中运行StatefulSet postgres容器，这样可以节省一些钱。我也希望更多的人会在k8s中使用StatefulSets来构建真正酷的东西。</p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="3b74" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><a class="ae ld" href="#9d01" rel="noopener ugc nofollow">【1】</a>:</p><pre class="lr ls lt lu gt lv lo lw lx aw ly bi"><span id="440f" class="lz ma iq lo b gy mb mc l md me">apiVersion: v1<br/>kind: PersistentVolume<br/>metadata:<br/>  name: $$NAME-ME-SOMETHING<br/>spec:<br/>  capacity:<br/>    storage: 20Gi<br/>  <!-- -->storageClassName: manual<br/>  accessModes:<br/>    - ReadWriteOnce<br/>  gcePersistentDisk:<br/>    pdName: [PD_NAME]<br/>    fsType: ext4</span></pre><p id="9aac" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><a class="ae ld" href="#11a9" rel="noopener ugc nofollow">【2】</a>:</p><pre class="lr ls lt lu gt lv lo lw lx aw ly bi"><span id="de84" class="lz ma iq lo b gy mb mc l md me">apiVersion: v1<br/>kind: PersistentVolumeClaim<br/>metadata:<br/>  name: $$NAME-ME-SOMETHING<br/>spec:<!-- --> <br/>  storageClassName: manual<br/>  <!-- -->accessModes:<br/>    - ReadWriteOnce<br/>  resources:<br/>    requests:<br/>      storage: 20Gi</span></pre><p id="d15d" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><a class="ae ld" href="#3fd2" rel="noopener ugc nofollow">【3】</a>:</p><pre class="lr ls lt lu gt lv lo lw lx aw ly bi"><span id="a90a" class="lz ma iq lo b gy mb mc l md me">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: myApp<br/>  namespace: default<br/>spec:<br/>  ports:<br/>  - port: 80<br/>    targetPort: 80<br/>    protocol: TCP<br/>  type: NodePort<br/>  selector:<br/>    run: myApp</span></pre></div></div>    
</body>
</html>