<html>
<head>
<title>Securing the Configuration of Kubernetes Cluster Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保护Kubernetes集群组件的配置</h1>
<blockquote>原文：<a href="https://itnext.io/securing-the-configuration-of-kubernetes-cluster-components-c9004a1a32b3?source=collection_archive---------1-----------------------#2018-12-06">https://itnext.io/securing-the-configuration-of-kubernetes-cluster-components-c9004a1a32b3?source=collection_archive---------1-----------------------#2018-12-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2535" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本系列<strong class="jp ir"> <em class="km">的<a class="ae kl" href="https://blog.giantswarm.io/securing-the-base-infrastructure-of-a-kubernetes-cluster/" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中，我们讨论了在保护部署了Kubernetes集群的基础设施时需要考虑的事项。这一次，我们将注意力转向星团本身。</em></strong></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/7c60bb5468cb2bf54d0b5321604b7a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*scBnmy84-WMlOMmNSabrvg.png"/></div></div></figure><p id="ad6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes是一个复杂的系统，上图显示了构成一个集群的许多不同的组成部分。这些组件中的每一个都需要小心保护，以保持集群的整体完整性。</p><p id="57a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们不可能涵盖集群级安全性的所有方面，但是我们将致力于解决更重要的主题。正如我们将在后面看到的，在Kubernetes集群的最佳实践安全性方面，以及用于衡量最佳实践遵守情况的工具方面，可以从更广泛的社区获得帮助。</p><h1 id="649f" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">集群安装程序</h1><p id="48d3" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">我们应该先简要观察一下可以用来安装集群组件的许多不同的工具。</p><p id="1d71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes集群组件的一些默认配置参数从安全角度来看是次优的，需要正确设置以确保集群的安全。除非您选择托管的Kubernetes集群(如Giant Swarm提供的集群),其中整个集群由您管理，否则这个问题会因许多不同的集群安装工具而加剧，每种工具都会应用稍微不同的配置。虽然大多数安装程序都有合理的默认设置，但我们永远不应该认为他们会在安全方面保护我们，我们应该将确保根据我们的要求配置安装程序机制来保护群集作为我们的目标。</p><p id="6591" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看一下控制平面安全性的一些重要方面。</p><h1 id="6d5c" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">API服务器</h1><p id="7bcf" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">API服务器是集群内所有通信的中枢，它位于API服务器上，集群的大部分安全配置都应用于此。API服务器是集群控制平面的唯一组件，能够直接与集群的状态存储进行交互。操作集群的用户、其他控制平面组件，有时还有集群工作负载，都使用服务器的基于HTTP的REST API与集群进行交互。</p><p id="d102" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于它在控制集群中的关键作用，仔细管理对API服务器的访问就安全性而言至关重要。如果某人或某物获得了对API的未经请求的访问，他们就有可能获得所有类型的敏感信息，并获得对群集本身的控制。因此，客户端对Kubernetes API的访问应该经过加密、认证和授权。</p><h1 id="a439" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">保护与TLS的通信</h1><p id="3824" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">为了防止中间人攻击，应该使用TLS对每个客户端和API服务器之间的通信进行加密。为此，API服务器需要配置一个私钥和X.509证书。</p><p id="8ff7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在TLS握手期间，颁发API服务器证书的根证书颁发机构(CA)的X.509证书必须可供任何需要向API服务器进行身份验证的客户端使用，这就引出了集群的证书颁发机构问题。正如我们马上会看到的，有许多方法可以让客户端向API服务器进行身份验证，其中之一就是X.509证书。如果采用这种客户端身份验证方法，这在大多数情况下可能是正确的(至少对于集群组件而言)，每个集群组件都应该获得自己的证书，并且建立集群范围的PKI功能是非常有意义的。</p><p id="9acd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有许多方法可以为集群实现PKI功能，没有一种方法比另一种更好。它可以手动配置，也可以由您选择的安装程序配置，或者通过其他方式配置。事实上，集群可以被配置为拥有自己的内置CA，它可以发布证书以响应通过API服务器提交的证书签名请求。在这里，在Giant Swarm，我们使用一个名为<a class="ae kl" href="https://github.com/giantswarm/cert-operator" rel="noopener ugc nofollow" target="_blank"> cert-operator </a>的运营商，与Hashicorp的<a class="ae kl" href="https://www.vaultproject.io/" rel="noopener ugc nofollow" target="_blank"> Vault </a>联合使用。</p><p id="c789" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们谈到与API服务器的安全通信时，一定要禁用它的不安全端口(在Kubernetes 1.13之前)，该端口通过普通HTTP ( <code class="fe mc md me mf b">--insecure-port=0</code>)为API提供服务！</p><h1 id="add8" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">认证、授权和准入控制</h1><p id="91de" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">现在，让我们将注意力转向控制哪些客户端可以在集群中的哪些资源上执行哪些操作。我们不会在这里详细讨论，因为总的来说，这是下一篇文章的主题。重要的是，要确保控制面板的组件配置为提供底层访问控制。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mg"><img src="../Images/2fa19a8fa37660b014bf60861cea30e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V1iXXNySjC_XGfRUTGlQxA.png"/></div></div></figure><p id="89c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当API请求到达API服务器时，它执行一系列检查来确定是否服务于该请求，如果服务于该请求，则根据定义的策略来验证或改变资源对象。执行链如上图所示。</p><p id="491e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes支持许多不同的身份验证方案，这些方案几乎总是在集群外部实现，包括X.509证书、基本身份验证、不记名令牌、用于向可信身份提供者进行身份验证的OpenID Connect (OIDC ),等等。使用API服务器上的相关配置选项来启用各种方案，因此请确保为您计划使用的身份验证方案提供这些配置选项。例如，X.509客户端证书认证需要包含一个或多个ca证书(<code class="fe mc md me mf b">--client-ca-file</code>)的文件的路径。需要记住的重要一点是，默认情况下，任何未经身份验证方案验证的API请求都被视为匿名请求。虽然匿名请求获得的访问权限可以通过授权来限制，但是如果不需要的话，应该完全关闭它们(<code class="fe mc md me mf b">--anonymous-auth=false</code>)。</p><p id="b413" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦请求被认证，API服务器就根据授权策略考虑该请求。同样，授权模式是一个配置选项(<code class="fe mc md me mf b">--authorization-mode</code>)，至少应该从AlwaysAllow的缺省值进行更改。理想情况下，授权模式列表应该包括<code class="fe mc md me mf b">RBAC</code>和<code class="fe mc md me mf b">Node</code>，前者用于启用细粒度访问控制的RBAC API，后者用于授权kubelet API请求(见下文)。</p><p id="ad20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦API请求被验证和授权，资源对象就可以在被保存到集群的状态数据库之前，使用准入控制器进行验证或变异。建议<a class="ae kl" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#is-there-a-recommended-set-of-admission-controllers-to-use" rel="noopener ugc nofollow" target="_blank">使用</a>一组最少的准入控制器，并且不应该从列表中删除，除非有非常好的理由这样做。值得考虑的其他安全相关准入控制器有:</p><ul class=""><li id="7125" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><strong class="jp ir"> DenyEscalatingExec </strong> —如果有必要允许您的pod以增强的权限运行(例如，使用主机的IPC/PID名称空间)，该准入控制器将阻止用户在pod的特权容器中执行命令。</li><li id="f49c" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><strong class="jp ir"> PodSecurityPolicy </strong> —为所有创建的pod提供应用各种安全机制的方法。我们将在本系列的下一篇文章中进一步讨论这一点，但是现在重要的是确保启用这个准入控制器，否则我们的安全策略将无法应用。</li><li id="154f" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><strong class="jp ir"> NodeRestriction </strong> —一个许可控制器，控制kubelet对集群资源的访问，这将在下面详细介绍。</li><li id="24c5" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><strong class="jp ir"> ImagePolicyWebhook </strong> —允许外部“图像验证器”检查为pod容器定义的图像的漏洞，例如图像实施器。<a class="ae kl" href="https://github.com/open-policy-agent/contrib/tree/master/image_enforcer" rel="noopener ugc nofollow" target="_blank"> Image Enforcer </a>基于<a class="ae kl" href="https://www.openpolicyagent.org/" rel="noopener ugc nofollow" target="_blank">开放策略代理</a> (OPA)，与开源漏洞扫描器<a class="ae kl" href="https://github.com/coreos/clair" rel="noopener ugc nofollow" target="_blank"> Clair </a>协同工作。</li></ul><p id="68ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">动态准入控制是Kubernetes中相对较新的特性，旨在提供比静态插件准入控制机制更大的灵活性。它是通过准入webhooks和基于控制器的初始化器实现的，并且一旦社区解决方案达到足够成熟的水平，它对集群安全性有很大的承诺。</p><h1 id="c581" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">库伯莱</h1><p id="b27c" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">kubelet是一个在集群中的每个节点上运行的代理，负责它所运行的节点上所有与pod相关的活动，包括启动/停止和重新启动pod容器，报告pod容器的健康状况等。在API服务器之后，kubelet是安全性方面要考虑的下一个最重要的集群组件。</p><h1 id="11c5" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">访问Kubelet REST API</h1><p id="fc8a" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">kubelet在端口10250和10255上提供一个小的REST API。端口10250是一个读/写端口，而10255是一个带有API端点子集的只读端口。</p><p id="8d92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">提供对端口10250的自由访问是危险的，因为它可能在pod的容器内执行任意命令，以及启动任意pod。类似地，两个端口都提供对有关pod及其容器的潜在敏感信息的读取访问，这可能会使工作负载容易受到危害。</p><p id="e4fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了防止潜在的危害，应通过设置kubelet的配置<code class="fe mc md me mf b">--read-only-port=0</code>来禁用只读端口。然而，端口10250需要可用于度量收集和其他重要功能。应该小心控制对此端口的访问，所以让我们讨论一下关键的安全配置。</p><h1 id="9ca3" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">客户端身份验证</h1><p id="6e6a" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">除非经过特别配置，否则kubelet API对来自客户端的未经验证的请求是开放的。因此，配置一种可用的身份验证方法很重要；X.509客户端证书或带有包含不记名令牌的授权头的请求。</p><p id="2d4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在X.509客户端证书的情况下，CA包的内容需要对kubelet可用，以便它可以在TLS握手期间对客户端提供的证书进行身份验证。这是kubelet配置的一部分(<code class="fe mc md me mf b">--client-ca-file</code>)。</p><p id="b56b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在理想情况下，唯一需要访问kube let API的客户机是Kubernetes API服务器。它需要访问kubelet的API端点来实现各种功能，比如收集日志和指标、在容器中执行命令(比如kubectl exec)、将端口转发到容器等等。为了让kubelet对它进行认证，API服务器需要配置客户机TLS凭证(<code class="fe mc md me mf b">--kubelet-client-certificate</code>和<code class="fe mc md me mf b">--kubelet-client-key</code>)。</p><h1 id="8248" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">匿名认证</h1><p id="4ec2" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">如果您已经仔细配置了API服务器对kubelet的API的访问，那么您认为“任务完成”也是情有可原的。但事实并非如此，因为任何访问kubelet的API的请求，如果不尝试通过kubelet进行身份验证，都被视为匿名请求。默认情况下，kubelet传递匿名请求进行授权，而不是以未经身份验证为由拒绝它们。</p><p id="31fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果在您的环境中允许匿名kubelet API请求是必不可少的，那么就有了授权门，它提供了一些灵活性来决定什么可以、什么不可以由API提供服务。然而，通过将kubelet的<code class="fe mc md me mf b">--anonymous-auth</code>配置设置为<code class="fe mc md me mf b">false</code>，完全禁止匿名API请求要安全得多。通过这样的配置，API向未授权的客户端返回一个<code class="fe mc md me mf b">401 Unauthorized</code>响应。</p><h1 id="d9bb" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">批准</h1><p id="4959" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">通过授权对kubelet API的请求，再次有可能违反默认的Kubernetes设置。对kubelet API的授权以两种模式之一运行；<code class="fe mc md me mf b">AlwaysAllow</code>(默认)或<code class="fe mc md me mf b">Webhook</code>。<code class="fe mc md me mf b">AlwaysAllow</code>模式做的正是您所期望的——它将允许所有通过认证门的请求成功。这包括匿名请求。</p><p id="47d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最好的方法是使用kubelet的<code class="fe mc md me mf b">--authorization-mode</code>配置选项和<code class="fe mc md me mf b">webhook</code>值，将授权决策卸载给Kubernetes API服务器，而不是让它完全开放。使用这种配置，kubelet调用<code class="fe mc md me mf b">SubjectAccessReview</code> API(它是API服务器的一部分)来决定是否允许主体发出请求。</p><h1 id="6a85" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">限制库伯勒的权力</h1><p id="b5d4" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">在Kubernetes的旧版本(1.7之前)中，kubelet可以读写所有节点和Pod API对象，即使节点和Pod对象受另一个运行在不同节点上的kubelet的控制。他们也有读取pod规格中包含的所有对象的权限；Secret、ConfigMap、PersistentVolume和PersistentVolumeClaim对象。换句话说，一个库伯莱人可以使用和控制许多它不负责的资源。这是非常强大的，在集群节点受损的情况下，损害可能会迅速扩大到有问题的节点之外。</p><h1 id="be25" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">节点授权人</h1><p id="373f" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">出于这个原因，专门为kubelet引入了节点授权模式，目的是控制它对Kubernetes API的访问。节点授权者限制ku elet读取与ku elet相关的对象(例如，pod、节点、服务),并对Secrets、Configmap、PersistentVolume和PersistentVolumeClaim对象应用进一步的只读限制，这些对象与绑定到ku elet运行的节点的pod特别相关。</p><h1 id="9d08" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">节点限制准入控制器</h1><p id="1b40" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">限制kubelet对相关对象的只读访问是防止集群或工作负载受损的重要一步。然而，kubelet需要对其节点和Pod对象进行写访问，作为其正常功能的一种手段。考虑到这一点，一旦kubelet的API请求通过了节点授权，它就要服从NodeRestriction准入控制器，该控制器限制kubelet可以修改的节点和Pod对象——它自己的对象。为此，kubelet用户必须是<code class="fe mc md me mf b">system:node:&lt;nodeName&gt;</code>，它必须属于<code class="fe mc md me mf b">system:nodes</code>组。当然，这是kubelet用户的<code class="fe mc md me mf b">nodeName</code>组件，NodeRestriction准入控制器使用它来允许或禁止修改节点和Pod对象的kubelet API请求。因此，每个kubelet都应该有一个惟一的X.509证书，用于向API服务器进行身份验证，主题可分辨名称的通用名称反映用户，组织反映组。</p><p id="f876" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，这些重要的配置不会自动发生，API服务器需要以<code class="fe mc md me mf b">Node</code>作为<code class="fe mc md me mf b">--authorization-mode</code>配置选项的一个逗号分隔的插件列表来启动，而<code class="fe mc md me mf b">NodeRestriction</code>需要在由<code class="fe mc md me mf b">--enable-admission-plugins</code>选项指定的准入控制器列表中。</p><h1 id="4f84" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">最佳实践</h1><p id="5693" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">需要强调的是，我们只讨论了集群层安全考虑的一个子集(尽管很重要)，如果您认为这一切听起来很可怕，那么不用担心，因为帮助就在身边。</p><p id="fcc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与为基础设施层的元素(如Docker)创建基准安全建议的方式一样，它们也是为Kubernetes集群创建的。互联网安全<a class="ae kl" href="https://www.cisecurity.org/" rel="noopener ugc nofollow" target="_blank">中心</a> (CIS)已经为集群的每个组件编译了一套完整的配置设置和文件系统检查，作为<a class="ae kl" href="https://www.cisecurity.org/benchmark/kubernetes/" rel="noopener ugc nofollow" target="_blank"> CIS Kubernetes基准</a>发布。</p><p id="f78b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能还想知道Kubernetes社区已经开发了一个开源工具，用于根据基准对Kubernetes集群进行审计，这个工具就是<a class="ae kl" href="https://github.com/aquasecurity/kube-bench" rel="noopener ugc nofollow" target="_blank">Kubernetes Bench for Security</a>。这是一个Golang应用程序，支持许多不同的Kubernetes版本(从1.6开始)，以及不同版本的基准测试。</p><p id="961f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您真的想适当地保护您的集群，那么使用基准作为合规性的衡量标准是必须的。</p><h1 id="1677" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">摘要</h1><p id="cd29" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">显然，采取预防措施，通过适当的配置来保护集群，对于保护集群中运行的工作负载至关重要。虽然Kubernetes社区非常努力地提供所有必要的安全控制来实现这种安全性，但由于历史原因，一些默认配置忽略了被认为是最佳实践的内容。我们忽视这些缺点是很危险的，无论何时我们建立一个集群，或者当我们升级到提供新功能的新版本时，我们都必须承担起弥补差距的责任。</p><p id="5734" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在此讨论的一些内容为堆栈中的下一层铺平了道路，在这一层中，我们利用已配置的安全机制来定义和应用安全控制，以保护在群集上运行的工作负载。下一篇文章叫做<strong class="jp ir"> <em class="km">将最佳实践安全控制应用到Kubernetes集群</em> </strong>。</p><p id="c343" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由<a class="ae kl" href="https://twitter.com/puja108" rel="noopener ugc nofollow" target="_blank">Puja Abbas si</a>——开发者倡议@ <a class="ae kl" href="https://giantswarm.io/" rel="noopener ugc nofollow" target="_blank">巨型虫群</a>撰写</p><div class="mv mw gp gr mx my"><a href="https://twitter.com/puja108" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd ir gy z fp nd fr fs ne fu fw ip bi translated">Puja Abbassi (@puja108) |推特</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">Puja Abbassi的最新推文(@puja108)。开发者倡导者@ GiantSwarm &amp; Researcher主题:码头工人…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">twitter.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm kx my"/></div></div></a></div></div></div>    
</body>
</html>