<html>
<head>
<title>17 Git Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">17个Git最佳实践</h1>
<blockquote>原文：<a href="https://itnext.io/17-git-best-practices-1988c7306e6b?source=collection_archive---------1-----------------------#2022-05-02">https://itnext.io/17-git-best-practices-1988c7306e6b?source=collection_archive---------1-----------------------#2022-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d7bb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Git 17岁生日的时候</h2></div><p id="0fec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">去年Git 16岁生日的时候，我做了一个<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/16-git-tips-and-tricks-bf08d0602d3b">“16个Git技巧和窍门”</a>。今年，我将列出一个对初学者更友好的最佳实践列表。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/bd54075123fdb59a938e7e22ef093780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m_OauEVikYcLzAxPk7gYCQ.png"/></div></div></figure><h1 id="4c32" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">0.输入您的个人信息</h1><p id="0818" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">这通常是人们会做的第一件事，因为git不允许您提交:</p><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="87cb" class="mt ls it mp b gy mu mv l mw mx">git config --global user.name "Mohammad-Ali A'râbi"<br/>git config --global user.email "mohammad-ali@aerabi.com"</span></pre><p id="66d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一件要记住的事情是，还有回购专用的个人信息。有时，我在同一台机器上提交我的工作回购和个人回购，但我必须用我的工作电子邮件处理前者，用我的个人电子邮件处理后者。很容易忘记和混淆电子邮件地址。</p><p id="c6fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是为什么我建议在克隆回购的最开始更改回购级别的个人信息:</p><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="10c6" class="mt ls it mp b gy mu mv l mw mx">git config user.email "mohammad@my-employer.com"</span></pre><h1 id="c114" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">1.忽略东西</h1><p id="ed03" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">当你犯了不该犯的错误时，把它从git的历史中删除会很痛苦。如果你已经提交了GitHub或GitLab，你可能不能。</p><p id="5750" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是为什么有些文件一存在就忽略比较好。最好的例子是编译后的文件。当然还有秘密、数据集、数据库等等。</p><p id="215a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建一个<code class="fe my mz na mp b">.gitignore</code>文件，并添加您希望git忽略的所有路径、扩展名和文件，例如:</p><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="671b" class="mt ls it mp b gy mu mv l mw mx"># extensions<br/>*.pyc</span><span id="fb55" class="mt ls it mp b gy nb mv l mw mx"># paths<br/>/node_modules</span><span id="cedd" class="mt ls it mp b gy nb mv l mw mx"># files<br/>application.exe</span></pre><h1 id="cfa4" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">2.手动暂存文件</h1><p id="c959" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我见过很多人在提交时暂存所有已更改的文件。那是一个坏习惯。我见过很多不需要的文件都是因为同一个习惯而提交的。</p><p id="79c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您想要提交时，首先检查哪些文件发生了更改:</p><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="454c" class="mt ls it mp b gy mu mv l mw mx">git status</span></pre><p id="8422" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后手动登台您想要的，一个接一个:</p><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="ca4d" class="mt ls it mp b gy mu mv l mw mx">git add README.md</span></pre><p id="1967" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我用GUI工具做的唯一一件事，通常是用我的IDE提供的工具，因为我想在提交之前查看更改并检查它们。</p><p id="67ce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用户还可以使用以下命令查看转移文件的更改:</p><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="afef" class="mt ls it mp b gy mu mv l mw mx">git diff --staged</span></pre><h1 id="1a3c" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">3.经常提交</h1><p id="0c6c" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">提交是廉价的，尽管它的名字听起来可能不是这样。经常承诺跟踪你的变化。这将使维护更加容易:</p><ul class=""><li id="9a08" class="nc nd it kk b kl km ko kp kr ne kv nf kz ng ld nh ni nj nk bi translated">如果您的整个工作没有通过一些测试，您可以一次一个提交地回到历史中去寻找根本原因，</li><li id="b218" class="nc nd it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">如果您所做的更改被破坏，您可以恢复对它所做的提交，</li><li id="2435" class="nc nd it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">此外，这也让其他人更容易检查你的工作。</li></ul><h1 id="c2a6" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">4.提交权限</h1><p id="3214" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">下一件重要的事情是要有一个相关的、信息丰富的提交消息。“修复bug”是没有信息的。你希望你的提交有一个说明<em class="nq">什么</em>的标题，还有一个说明<em class="nq">为什么</em>的主体。一个好的提交消息如下所示:</p><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="a457" class="mt ls it mp b gy mu mv l mw mx">Chore: Remove comments from tsconfig.json</span><span id="e2eb" class="mt ls it mp b gy nb mv l mw mx">Snyk cannot import project if the tsconfig.json has comments in it,<br/>it will complain about JSON validity.</span><span id="200e" class="mt ls it mp b gy nb mv l mw mx">Fixes #12</span></pre><p id="651b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要描述提交消息:</p><ul class=""><li id="f6d6" class="nc nd it kk b kl km ko kp kr ne kv nf kz ng ld nh ni nj nk bi translated">第一行是标题。通常，这是打印提交列表时唯一显示的内容。并且不能超过72个字符，否则GitHub(或GitLab)在显示时会将其截断。</li><li id="9e9c" class="nc nd it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">提交主体通过一个空行与标头分开，并包含进行此更改的原因。</li><li id="73b8" class="nc nd it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">最后一行是页脚。人们可以利用这一点将提交与现有问题联系起来。这里的<code class="fe my mz na mp b">#12</code>是这个提交正在解决的问题，当提交合并到master中时，它将自动关闭。</li></ul><p id="e6a0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要了解更多关于提交消息的信息，请参考<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/ten-commandments-of-git-commit-messages-94bd6dcf6e0e">“Git提交消息的十诫”</a>。</p><h1 id="5df8" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">5.创建分支</h1><p id="5580" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">推送给师傅很方便。我当时在场。但是你可能想保持你的主枝干净并一直工作。创建一个分支，将您的代码推入其中，检查它，测试它，确保它可以工作，然后将它合并回master。</p><p id="7108" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最好创建CI作业来检查代码的语法错误，运行测试，检查格式，甚至可能检查提交消息。使用GitHub操作或GitLab-CI。</p><h1 id="df54" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">6.每个拉取请求做一件事</h1><p id="1d79" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">特性分支被称为特性分支是有原因的:它们增加了一个特性。不要在一个拉取请求中包含12个功能:</p><ul class=""><li id="8ddd" class="nc nd it kk b kl km ko kp kr ne kv nf kz ng ld nh ni nj nk bi translated">这使得测试更加困难，</li><li id="589f" class="nc nd it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">这使得复习变得更加困难，</li><li id="8127" class="nc nd it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">这使得找出问题变得更加困难。</li></ul><p id="cf05" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽量保持拉取请求尽可能小。</p><blockquote class="nr"><p id="4c47" class="ns nt it bd nu nv nw nx ny nz oa ld dk translated">让一个程序员检查10行代码，他会发现10个问题。让他做500行，他会说好看。</p></blockquote><p id="85a8" class="pw-post-body-paragraph ki kj it kk b kl ob ju kn ko oc jx kq kr od kt ku kv oe kx ky kz of lb lc ld im bi translated">我记得有一次，我的同事在一个单一的拉请求中对一个特性分支做了六个变更。失败了，他不知道为什么，痛苦地尖叫了整整一周。最终，我介入并为他更改的7件事创建了7个不同的拉请求。将它们一个一个地合并，并找出导致失败的变化。我花了半天时间。</p><p id="a694" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你为了节省时间而同时做多件事，那你就没有做到。</p><h1 id="f795" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">7.每个拉请求合并一个提交</h1><p id="7f5f" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">如果您的拉请求只添加一个特性，那么为每个主分支添加一个提交是有意义的。这就是我所做的:</p><ul class=""><li id="4137" class="nc nd it kk b kl km ko kp kr ne kv nf kz ng ld nh ni nj nk bi translated">开发时经常提交，</li><li id="b537" class="nc nd it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/git-commit-squash-64c5b23b188a">接受变更后，将提交压缩成一个</a>，</li><li id="3f2e" class="nc nd it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">重新基于母版，</li><li id="1c06" class="nc nd it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">做一个快进合并。</li></ul><p id="065b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要在母版上重设基础:</p><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="4834" class="mt ls it mp b gy mu mv l mw mx">git pull --rebase origin master</span></pre><p id="2be0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于快进合并，提交具有您编写的消息。如果你仔细地写了它，它会有一个链接指向你用它解决的问题。在该问题中，有一个指向拉请求的链接。因此，如果在10年后，一个开发人员偶然发现了你的变更并查看了你的提交，她可以找到她需要的所有上下文。</p><p id="9dff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是我喜欢squash-rebase-ff胜过squash merge或创建合并提交的普通合并的主要原因。</p><p id="64b8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要了解有关不同合并方式的更多信息，请参考以下文章:</p><ul class=""><li id="385f" class="nc nd it kk b kl km ko kp kr ne kv nf kz ng ld nh ni nj nk bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/git-merge-vs-rebase-938950fb218">“Git合并vs Rebase:合并的三种类型”</a></li><li id="a80e" class="nc nd it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/git-merge-vs-rebase-and-where-to-use-them-2a0a6e88769d">“Git Merge vs Rebase以及在哪里使用它们”</a></li></ul><h1 id="4075" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">8.正确命名你的分支</h1><p id="1ddc" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">或许，这里最好的规则就是拥有一个。保持一致。拥有10个不同的名为<code class="fe my mz na mp b">bug-fix</code>的分支并不能帮你找到路。</p><p id="9531" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我是这样命名我的分支的:</p><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="862f" class="mt ls it mp b gy mu mv l mw mx">aerabi/32-upgrade-to-angular-12</span></pre><p id="8181" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，它有三个部分:</p><ul class=""><li id="7de8" class="nc nd it kk b kl km ko kp kr ne kv nf kz ng ld nh ni nj nk bi translated">作者句柄。这是我的GitHub ID，后面是一条斜线。</li><li id="afc8" class="nc nd it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">问题ID。您正在修复的问题的ID。</li><li id="4e8a" class="nc nd it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">简短的描述。通常与问题标题相同。</li></ul><p id="6064" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">GitLab和GitHub有从问题中创建分支的功能，我通常只是在它们前面添加我的句柄。</p><h1 id="7467" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">9.合并后清理您的分支</h1><p id="74b2" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">合并您的拉请求后，删除源分支。GitHub和GitLab的UI中有一个按钮可以做到这一点。唯一剩下的问题是从您的本地回购中删除该分支。您可以通过设置git配置来实现这一点:</p><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="acd6" class="mt ls it mp b gy mu mv l mw mx">git config fetch.prune true</span></pre><p id="0603" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下次提取时，在远程存储库中删除的所有分支也将从本地存储库中删除。</p><h1 id="1056" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">10.拉动时重设基底</h1><p id="31f7" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">这可能发生在您身上:您在master上创建了一个新的commit。您希望从远程repo获取更新，在获取时，git会创建一个合并提交。如果发生这种情况，您就不能再推送到主服务器，因为您的本地主服务器不是远程主服务器的后代。</p><p id="0b20" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了避免这种情况，请始终进行重置基础拉动:</p><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="7f3c" class="mt ls it mp b gy mu mv l mw mx">git pull --rebase</span></pre><p id="71c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您甚至可以通过更改配置使其成为默认行为:</p><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="b084" class="mt ls it mp b gy mu mv l mw mx">git config --global pull.rebase true</span></pre><p id="3b25" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">设置好这个配置后，所有的拉取操作都将被提取和重定基础，而不是提取和合并。</p><h1 id="9e46" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">11.重置基础前挤压</h1><p id="4461" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">这就是rebasing的工作方式:它从另一个分支获取提交，并一次一个提交地应用您的更改。如果您的分支中有17个提交，并且有一个冲突，那么您有可能需要解决17次冲突。</p><p id="32ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">甚至有可能在第一次提交时引入了冲突，而在第17次提交时消除了冲突。在这种情况下，通过挤压，你不再需要解决冲突。</p><h1 id="3833" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">12.不要强行推动</h1><p id="3996" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">本节将两个规则合二为一:</p><ul class=""><li id="f1d2" class="nc nd it kk b kl km ko kp kr ne kv nf kz ng ld nh ni nj nk bi translated">从不强行推动，<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/git-force-vs-force-with-lease-9d0e753e8c41">用武力配合租借代替</a>。</li><li id="1078" class="nc nd it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">永远不要强迫推(或强迫租赁推)掌握。</li></ul><p id="34ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于第一个命令，该命令如下所示:</p><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="2174" class="mt ls it mp b gy mu mv l mw mx">git push --force-with-lease</span></pre><p id="019c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它基本上检查另一个合作者是否已经推送到您试图在您覆盖它们之前强制更新的分支。</p><p id="1362" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一点是，主树枝是神圣的，你不应该弄乱它。强行推进会改写历史，而你可能会毁掉它。</p><h1 id="a7d2" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">14.不要提交生成的文件</h1><p id="0d1e" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">项目中通常会有大量的生成文件。对其中的一些人来说，很明显你不应该犯这些错误，对另外一些人来说不是:</p><ul class=""><li id="5096" class="nc nd it kk b kl km ko kp kr ne kv nf kz ng ld nh ni nj nk bi translated">二进制、字节码、机器码或任何其他编译或转换的工件</li><li id="43ae" class="nc nd it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">已安装的包，例如整个<code class="fe my mz na mp b">node_modules</code>目录(由Node.js包管理器生成)</li><li id="d434" class="nc nd it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">Python、<code class="fe my mz na mp b">venv</code>或类似名称的虚拟环境目录(改为向您的项目添加一个依赖项列表并提交该列表)</li><li id="6293" class="nc nd it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">生成的代码(例如，在API规范之外生成的API客户端)</li></ul><p id="2cea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">确保在你的<code class="fe my mz na mp b">.gitignore</code>文件中忽略它们。一旦一个文件被添加到git历史中，取出它是一件痛苦的事情。</p><h1 id="e225" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">15.提交前测试</h1><p id="0906" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">越早修复代码，就越容易。这叫做“左移测试”。确保在提交代码之前运行测试和修复程序(如果有的话)(例如代码样式器和linters)。</p><p id="d2d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您有一些运行测试和代码风格检查的CI作业，那么通过在本地运行它们，您可以节省时间和计算。如果没有，您已经确保您没有推送损坏的代码。</p><p id="92b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我要讲一个故事。过去，我们有一个项目，也有一个运行测试的CI工作。但是这项工作稍微有些中断:即使测试中断了，它也会返回一个退出代码0，所以CI工具会认为测试成功了。这项工作中断了6个月，我们没有注意到，因为我们从来没有将未测试的代码放入其中。</p><p id="0319" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我会说，这是一个纪律严明的团队的表现。</p><h1 id="a82b" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">16.添加一个配置项，并向其添加测试色调</h1><p id="c43c" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">这可能不仅仅是git实践，而是GitOps，但是很难再将两者分开。</p><p id="5df5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在大多数git解决方案都有自己的CI解决方案，例如GitLab-CI或GitHub Actions。而且有了GitLab的Auto-DevOps和GitHub Actions marketplace，现在建立CI工作就容易多了。创建配置项检查，并使其成为您的拉取请求(或合并请求)的强制检查。</p><p id="54b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能要添加的检查:</p><ul class=""><li id="a384" class="nc nd it kk b kl km ko kp kr ne kv nf kz ng ld nh ni nj nk bi translated">编译、转换或编译:你的代码必须在语法上是正确的，并且是可编译的</li><li id="25d1" class="nc nd it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">代码格式化器:添加一个工具来格式化你的代码，并检查你推送的代码是否符合该格式，这将有助于git的责备和代码的一致性</li><li id="62ba" class="nc nd it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">安全检查:有一些工具可以检查你的代码是否有安全缺陷，CodeQL就是一个很好的例子</li></ul><h1 id="3395" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">遗言</h1><p id="c4bf" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">如果你有任何其他你认为应该出现在列表中的建议，请在评论中提出来。否则，</p><ul class=""><li id="e842" class="nc nd it kk b kl km ko kp kr ne kv nf kz ng ld nh ni nj nk bi translated"><a class="ae le" href="https://medium.com/subscribe/@aerabi" rel="noopener">订阅</a>my Medium publishes，以便在新一期Git周刊出版时获得通知。</li><li id="a26c" class="nc nd it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">在Twitter上关注<a class="ae le" href="https://twitter.com/MohammadAliEN" rel="noopener ugc nofollow" target="_blank">我</a>获取git上的每周文章和每日推文。</li></ul></div></div>    
</body>
</html>