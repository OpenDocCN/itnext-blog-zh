<html>
<head>
<title>Kubernetes image policy webhook explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes图像政策webhook解释</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-image-policy-webhook-explained-ac1063d3ea97?source=collection_archive---------3-----------------------#2021-01-07">https://itnext.io/kubernetes-image-policy-webhook-explained-ac1063d3ea97?source=collection_archive---------3-----------------------#2021-01-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3fdb606d4d8c909f6c74e247988fbf1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XsLVjX5ZWsGthVrc.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">这张图片来自k8s文档</figcaption></figure><h2 id="35d1" class="kc kd iq bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">介绍</h2><p id="eab7" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">在本文中，我们将探索webhook在kubernetes中的工作方式，更具体地说，是关于ImagePolicyWebhook，kubernetes的文档对它的描述有点模糊，因为没有真实的例子或实现，所以这里我们将把它分解成不同的替代方案，在现实世界的场景中，我更喜欢依靠<a class="ae lt" href="https://github.com/open-policy-agent/gatekeeper" rel="noopener ugc nofollow" target="_blank"> OPA Gatekeeper </a>， 我计划通过添加一个数据库，让webhook允许或不允许基于漏洞扫描的图像，例如只允许容器中的中等或较低的漏洞，这将是另一天的帖子，如果你有兴趣，你可以在这个<a class="ae lt" href="https://github.com/kainlite/kube-image-bouncer" rel="noopener ugc nofollow" target="_blank"> repo </a>、<a class="ae lt" href="https://techsquad.rocks/blog/kubernetes_image_policy_webhook_explained/#closing-words" rel="noopener ugc nofollow" target="_blank">查看更多</a>中提供帮助。</p><p id="9568" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">有两种方法来实现这一点，每一种都有稍微不同的行为，一种方法是使用<a class="ae lt" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#imagepolicywebhook" rel="noopener ugc nofollow" target="_blank"> ImagePolicyWebhook </a>，另一种方法是使用<a class="ae lt" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/" rel="noopener ugc nofollow" target="_blank">准入控制器</a>或者工作验证或者变异，这里我使用了验证Webhook，你可以了解更多<a class="ae lt" href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="8257" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">该准入控制器将拒绝所有使用带有<code class="fe lz ma mb mc b">latest</code>标签的图像的pod，并且在将来我们将会看到是否所有的pod都不能满足所需的安全级别。</p><h2 id="482a" class="kc kd iq bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">比较</h2><p id="e67b" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated"><a class="ae lt" href="https://kubernetes.io/docs/admin/admission-controllers/#imagepolicywebhook" rel="noopener ugc nofollow" target="_blank"> ImagePolicyWebhook </a>是一个仅评估映像的准入控制器，您需要解析请求、逻辑和响应，以便允许或拒绝群集中的映像。</p><p id="6cc9" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated"><code class="fe lz ma mb mc b">ImagePolicyWebhook</code>的好处:</p><ul class=""><li id="0055" class="md me iq la b lb lu lf lv kl mf kp mg kt mh ls mi mj mk ml bi translated">如果webhook端点不可达，可以指示API服务器拒绝图像，这非常方便，但也可能带来问题，例如核心pods将无法调度。</li></ul><p id="3cbc" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated"><code class="fe lz ma mb mc b">ImagePolicyWebhook</code>不好的地方:</p><ul class=""><li id="d69f" class="md me iq la b lb lu lf lv kl mf kp mg kt mh ls mi mj mk ml bi translated">配置有点复杂，需要访问主节点或apiserver配置，文档不清楚，很难进行更改、更新等。</li><li id="e998" class="md me iq la b lb mm lf mn kl mo kp mp kt mq ls mi mj mk ml bi translated">部署并不简单，因为您需要用systemd部署它，或者在主机中将它作为docker容器运行，更新dns等等。</li></ul><p id="b574" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">另一方面,<a class="ae lt" href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers" rel="noopener ugc nofollow" target="_blank">validatingadmissionweb hook</a>可以用于更多的东西，而不仅仅是图像(如果你使用变异的，那么，你可以动态地注入或改变东西)。</p><p id="9e4d" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated"><code class="fe lz ma mb mc b">ValidatingAdmissionWebhook</code>的精彩之处:</p><ul class=""><li id="3c4b" class="md me iq la b lb lu lf lv kl mf kp mg kt mh ls mi mj mk ml bi translated">更容易部署，因为该服务作为一个单元运行。</li><li id="8ab3" class="md me iq la b lb mm lf mn kl mo kp mp kt mq ls mi mj mk ml bi translated">一切都可以成为kubernetes的资源。</li><li id="855b" class="md me iq la b lb mm lf mn kl mo kp mp kt mq ls mi mj mk ml bi translated">不需要更少的人工干预和对主设备的访问。</li><li id="7cf9" class="md me iq la b lb mm lf mn kl mo kp mp kt mq ls mi mj mk ml bi translated">如果pod或服务不可用，那么所有图像都将被允许，这在某些情况下可能是一个安全风险，因此如果您走这条路，请确保它高度可用，这实际上可以通过指定<code class="fe lz ma mb mc b">failurePolicy</code>到<code class="fe lz ma mb mc b">Fail</code>而不是<code class="fe lz ma mb mc b">Ignore</code>来配置(默认为<code class="fe lz ma mb mc b">Fail</code>)。</li></ul><p id="a8a9" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated"><code class="fe lz ma mb mc b">ValidatingAdmissionWebhook</code>不好的地方:</p><ul class=""><li id="c5c6" class="md me iq la b lb lu lf lv kl mf kp mg kt mh ls mi mj mk ml bi translated">任何拥有足够RBAC权限的人都可以更新/更改配置，因为这只是另一个kubernetes资源。</li></ul><h2 id="5649" class="kc kd iq bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">建筑物</h2><p id="81b1" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">如果您打算将其用作普通服务:</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="e6cf" class="kc kd iq mc b gy mz na l nb nc">$ go get github.com/kainlite/kube-image-bouncer</span></pre><p id="a76b" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">您也可以使用此<a class="ae lt" href="https://hub.docker.com/r/kainlite/kube-image-bouncer/" rel="noopener ugc nofollow" target="_blank"> Docker图像</a>:</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="c1ae" class="kc kd iq mc b gy mz na l nb nc">$ docker pull kainlite/kube-image-bouncer</span></pre><h2 id="cb1e" class="kc kd iq bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">证书</h2><p id="47b5" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">我们可以依靠kubernetes CA来生成我们需要的证书。如果您想了解更多信息，请点击此处<a class="ae lt" href="https://kubernetes.io/docs/tasks/tls/managing-tls-in-a-cluster/" rel="noopener ugc nofollow" target="_blank"/>:</p><p id="d571" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">创建企业社会责任:</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="7705" class="kc kd iq mc b gy mz na l nb nc">$ cat &lt;&lt;EOF | cfssl genkey - | cfssljson -bare server<br/>{<br/>  "hosts": [<br/>    "image-bouncer-webhook.default.svc",<br/>    "image-bouncer-webhook.default.svc.cluster.local",<br/>    "image-bouncer-webhook.default.pod.cluster.local",<br/>    "192.0.2.24",<br/>    "10.0.34.2"<br/>  ],<br/>  "CN": "system:node:image-bouncer-webhook.default.pod.cluster.local",<br/>  "key": {<br/>    "algo": "ecdsa",<br/>    "size": 256<br/>  },<br/>  "names": [<br/>    {<br/>      "O": "system:nodes"<br/>    }<br/>  ]<br/>}<br/>EOF</span></pre><p id="f720" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">然后将其应用到集群</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="c7cc" class="kc kd iq mc b gy mz na l nb nc">$ cat &lt;&lt;EOF | kubectl apply -f -<br/>apiVersion: certificates.k8s.io/v1<br/>kind: CertificateSigningRequest<br/>metadata:<br/>  name: image-bouncer-webhook.default<br/>spec:<br/>  request: $(cat server.csr | base64 | tr -d '\n')<br/>  signerName: kubernetes.io/kubelet-serving<br/>  usages:<br/>  - digital signature<br/>  - key encipherment<br/>  - server auth<br/>EOF</span></pre><p id="18dc" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">批准并获取您的证书以备后用</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="260a" class="kc kd iq mc b gy mz na l nb nc">$ kubectl get csr image-bouncer-webhook.default -o jsonpath='{.status.certificate}' | base64 --decode &gt; server.crt</span></pre><h2 id="c1d5" class="kc kd iq bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">ImagePolicyWebhook路径</h2><p id="490e" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">有两种可能的方法来部署这个控制器(webhook ),为此，您需要创建证书，如下所述，但首先我们需要注意其他细节，将其添加到主服务器或bouncer将运行的主机文件中:</p><p id="35ce" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">我们使用这个名称是因为它必须与证书中的名称相匹配，因为它将在kuberntes之外运行，甚至可能是外部可用的，我们只是用一个hosts条目来伪装它</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="df3c" class="kc kd iq mc b gy mz na l nb nc">$ echo "127.0.0.1 image-bouncer-webhook.default.svc" &gt;&gt; /etc/hosts</span></pre><p id="74d9" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">同样，在apiserver中，您需要用这些设置更新它:</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="f178" class="kc kd iq mc b gy mz na l nb nc">--admission-control-config-file=/etc/kubernetes/kube-image-bouncer/admission_configuration.json --enable-admission-plugins=ImagePolicyWebhook</span></pre><p id="796f" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">如果使用这种方法，您不需要创建<code class="fe lz ma mb mc b">validating-webhook-configuration.yaml</code>资源，也不需要应用kubernetes部署来在集群中运行。</p><p id="36fe" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">创建一个名为<code class="fe lz ma mb mc b">/etc/kubernetes/kube-image-bouncer/admission_configuration.json</code>文件的接纳控制配置文件，内容如下:</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="4d6a" class="kc kd iq mc b gy mz na l nb nc">{<br/>  "imagePolicy": {<br/>     "kubeConfigFile": "/etc/kubernetes/kube-image-bouncer/kube-image-bouncer.yml",<br/>     "allowTTL": 50,<br/>     "denyTTL": 50,<br/>     "retryBackoff": 500,<br/>     "defaultAllow": false<br/>  }<br/>}</span></pre><p id="b671" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">如果您想要默认允许图像，请调整默认值。</p><p id="32f5" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">用以下内容创建一个kubeconfig文件<code class="fe lz ma mb mc b">/etc/kubernetes/kube-image-bouncer/kube-image-bouncer.yml</code>:</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="2c19" class="kc kd iq mc b gy mz na l nb nc">apiVersion: v1<br/>kind: Config<br/>clusters:<br/>- cluster:<br/>    certificate-authority: /etc/kubernetes/kube-image-bouncer/pki/server.crt<br/>    server: <a class="ae lt" href="https://image-bouncer-webhook.default.svc:1323/image_policy" rel="noopener ugc nofollow" target="_blank">https://image-bouncer-webhook.default.svc:1323/image_policy</a><br/>  name: bouncer_webhook<br/>contexts:<br/>- context:<br/>    cluster: bouncer_webhook<br/>    user: api-server<br/>  name: bouncer_validator<br/>current-context: bouncer_validator<br/>preferences: {}<br/>users:<br/>- name: api-server<br/>  user:<br/>    client-certificate: /etc/kubernetes/pki/apiserver.crt<br/>    client-key:  /etc/kubernetes/pki/apiserver.key</span></pre><p id="60b3" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">这个配置文件指示API服务器到达位于<code class="fe lz ma mb mc b">https://image-bouncer-webhook.default.svc:1323</code>的webhook服务器并使用它的<code class="fe lz ma mb mc b">/image_policy</code>端点，我们正在重用来自API server的证书和我们已经生成的用于kube-image-bouncer的证书。</p><p id="11af" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">请注意，您需要与证书一起放在文件夹中，这样才能工作:</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="bc97" class="kc kd iq mc b gy mz na l nb nc">$ docker run --rm -v `pwd`/server-key.pem:/certs/server-key.pem:ro \<br/>-v `pwd`/server.crt:/certs/server.crt:ro -p 1323:1323 \<br/>--network hostkainlite/kube-image-bouncer \<br/>-k /certs/server-key.pem -c /certs/server.crt</span></pre><h2 id="ad7f" class="kc kd iq bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">验证gAdmissionWebhook路径</h2><p id="a355" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">如果你走这条路，你需要做的就是生成证书，其他的事情都可以用kubectl来做，首先你必须创建一个tls secret来保存webhook证书和密钥(我们刚刚在上一步中生成了它):</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="5b44" class="kc kd iq mc b gy mz na l nb nc">$ kubectl create secret tls tls-image-bouncer-webhook \ <br/>--key server-key.pem \ <br/>--cert server.pem</span></pre><p id="11fc" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">然后为<code class="fe lz ma mb mc b">image-bouncer-webhook</code>创建一个kubernetes部署:</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="2fb7" class="kc kd iq mc b gy mz na l nb nc">$ kubectl apply -f kubernetes/image-bouncer-webhook.yaml</span></pre><p id="afb1" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">最后，创建利用我们的webhook端点的<code class="fe lz ma mb mc b">ValidatingWebhookConfiguration</code>,您可以使用它，但是一定要用base64:</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="7a31" class="kc kd iq mc b gy mz na l nb nc">$ kubectl apply -f kubernetes/validating-webhook-configuration.yaml</span></pre><p id="95ff" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">或者，您可以像这样简单地生成<code class="fe lz ma mb mc b">validating-webhook-configuration.yaml</code>文件，并一次性应用它:</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="cf3d" class="kc kd iq mc b gy mz na l nb nc">$ cat &lt;&lt;EOF | kubectl apply -f -<br/>apiVersion: admissionregistration.k8s.io/v1<br/>kind: ValidatingWebhookConfiguration<br/>metadata:<br/>  name: image-bouncer-webook<br/>webhooks:<br/>  - name: image-bouncer-webhook.default.svc<br/>    rules:<br/>      - apiGroups:<br/>          - ""<br/>        apiVersions:<br/>          - v1<br/>        operations:<br/>          - CREATE<br/>        resources:<br/>          - pods<br/>    failurePolicy: Ignore<br/>    sideEffects: None<br/>    admissionReviewVersions: ["v1", "v1beta1"]<br/>    clientConfig:<br/>      caBundle: $(kubectl get csr image-bouncer-webhook.default -o jsonpath='{.status.certificate}')<br/>      service:<br/>        name: image-bouncer-webhook<br/>        namespace: default<br/>EOF</span></pre><p id="0bcd" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">这可以很容易地自动化(舵图表即将推出&amp;mldr;)，变化可能需要一点时间来反映，所以等待几秒钟，并尝试一下。</p><h2 id="4907" class="kc kd iq bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">测试</h2><p id="d083" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">两条路径的工作方式应该相同，您将会看到类似的错误消息，例如:</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="7769" class="kc kd iq mc b gy mz na l nb nc">Error creating: pods "nginx-latest-sdsmb" is forbidden: image policy webhook backend denied one or more images: Images using latest tag are not allowed</span></pre><p id="b259" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">或者</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="2d5f" class="kc kd iq mc b gy mz na l nb nc">Warning FailedCreate 23s (x15 over 43s) replication-controller Error creating: admission webhook "image-bouncer-webhook.default.svc" denied the request: Images using latest tag are not allowed</span></pre><p id="797b" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">创建一个nginx版本化的RC来验证版本化的版本仍然工作:</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="4e5c" class="kc kd iq mc b gy mz na l nb nc">$ cat &lt;&lt;EOF | kubectl apply -f -<br/>apiVersion: v1<br/>kind: ReplicationController<br/>metadata:<br/>  name: nginx-versioned<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    app: nginx-versioned<br/>  template:<br/>    metadata:<br/>      name: nginx-versioned<br/>      labels:<br/>        app: nginx-versioned<br/>    spec:<br/>      containers:<br/>      - name: nginx-versioned<br/>        image: nginx:1.13.8<br/>        ports:<br/>        - containerPort: 80<br/>EOF</span></pre><p id="88a7" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">确保/检查复制控制器确实在运行:</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="e118" class="kc kd iq mc b gy mz na l nb nc">$ kubectl get rc<br/>NAME              DESIRED   CURRENT   READY     AGE<br/>nginx-versioned   1         1         0         2h</span></pre><p id="1e6c" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">现在为nginx-latest创建一个，以验证我们的控制器/webhook实际上可以拒绝包含使用最新标签的图像的pod:</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="25f1" class="kc kd iq mc b gy mz na l nb nc">$ cat &lt;&lt;EOF | kubectl apply -f -<br/>apiVersion: v1<br/>kind: ReplicationController<br/>metadata:<br/>  name: nginx-latest<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    app: nginx-latest<br/>  template:<br/>    metadata:<br/>      name: nginx-latest<br/>      labels:<br/>        app: nginx-latest<br/>    spec:<br/>      containers:<br/>      - name: nginx-latest<br/>        image: nginx<br/>        ports:<br/>        - containerPort: 80<br/>EOF</span></pre><p id="8a46" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">如果我们检查pod，它不应被创建，RC应显示类似于以下输出的内容，您也可以使用<code class="fe lz ma mb mc b">kubectl get events --sort-by='{.lastTimestamp}'</code>进行检查:</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="db30" class="kc kd iq mc b gy mz na l nb nc">$ kubectl describe rc nginx-latest<br/>Name:         nginx-latest<br/>Namespace:    default<br/>Selector:     app=nginx-latest<br/>Labels:       app=nginx-latest<br/>Annotations:  &lt;none&gt;<br/>Replicas:     0 current / 1 desired<br/>Pods Status:  0 Running / 0 Waiting / 0 Succeeded / 0 Failed<br/>Pod Template:<br/>  Labels:  app=nginx-latest<br/>  Containers:<br/>   nginx-latest:<br/>    Image:        nginx<br/>    Port:         80/TCP<br/>    Host Port:    0/TCP<br/>    Environment:  &lt;none&gt;<br/>    Mounts:       &lt;none&gt;<br/>  Volumes:        &lt;none&gt;<br/>Conditions:<br/>  Type             Status  Reason<br/>  ----             ------  ------<br/>  ReplicaFailure   True    FailedCreate<br/>Events:<br/>  Type     Reason        Age                 From                    Message<br/>  ----     ------        ----                ----                    -------<br/>  Warning  FailedCreate  23s (x15 over 43s)  replication-controller  Error creating: admission webhook "image-bouncer-webhook.default.svc" denied the request: Images using latest tag are not allowed</span></pre><h2 id="b0c4" class="kc kd iq bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">排除故障</h2><p id="cc69" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">如果您正在使用准入控制器路径，查看apiserver日志总是有用的，因为它将在那里记录失败的原因，以及来自image-bouncer的日志，例如:apiserver</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="1eee" class="kc kd iq mc b gy mz na l nb nc">W0107 17:39:00.619560       1 dispatcher.go:142] rejected by webhook "image-bouncer-webhook.default.svc": &amp;errors.StatusError{ErrStatus:v1.Status{TypeMeta:v1.TypeMeta{Kind:"", APIVersion:""}, ListMeta:v1.ListMeta{ SelfLink:"", ResourceVersion:"", Continue:"", RemainingItemCount:(*int64)(nil)}, Status:"Failure", Message:"admission webhook \"image-bouncer-webhook.default.svc\" denied the request: Images using latest tag are not allowed", Reason:"", Details:(*v1.StatusDetails)(nil), Code:400}}</span></pre><p id="0cd6" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">kube-image-bouncer</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="9ea8" class="kc kd iq mc b gy mz na l nb nc">echo: http: TLS handshake error from 127.0.0.1:49414: remote error: tls: bad certificate<br/>method=POST, uri=/image_policy?timeout=30s, status=200<br/>method=POST, uri=/image_policy?timeout=30s, status=200<br/>method=POST, uri=/image_policy?timeout=30s, status=200</span></pre><p id="14b1" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">错误来自手动测试，其他是来自apiserver的成功请求。</p><h2 id="bd67" class="kc kd iq bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">代码本身</h2><p id="b74a" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">让我们简单看一下创建准入控制器或webhook的关键部分:</p><p id="9da8" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">这是<code class="fe lz ma mb mc b">main.go</code>的一部分，正如我们可以看到的，我们正在用不同的方法处理两个<code class="fe lz ma mb mc b">POST</code>路径，以及一些其他验证，我们需要知道的是，我们将收到一个带有JSON有效负载的POST方法调用，并且我们需要转换成一个准入控制器审查请求。</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="0b12" class="kc kd iq mc b gy mz na l nb nc">app.Action = func(c *cli.Context) error {<br/>        e := echo.New()<br/>        e.POST("/image_policy", handlers.PostImagePolicy())<br/>        e.POST("/", handlers.PostValidatingAdmission())</span><span id="58f7" class="kc kd iq mc b gy nd na l nb nc">e.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{<br/>            Format: "method=${method}, uri=${uri}, status=${status}\n",<br/>        }))</span><span id="aa65" class="kc kd iq mc b gy nd na l nb nc">if debug {<br/>            e.Logger.SetLevel(log.DEBUG)<br/>        }</span><span id="f715" class="kc kd iq mc b gy nd na l nb nc">if whitelist != "" {<br/>            handlers.RegistryWhitelist = strings.Split(whitelist, ",")<br/>            fmt.Printf(<br/>                "Accepting only images from these registries: %+v\n",<br/>                handlers.RegistryWhitelist)<br/>            fmt.Println("WARN: this feature is implemented only by the ValidatingAdmissionWebhook code")<br/>        } else {<br/>            fmt.Println("WARN: accepting images from ALL registries")<br/>        }</span><span id="0e83" class="kc kd iq mc b gy nd na l nb nc">var err error<br/>        if cert != "" &amp;&amp; key != "" {<br/>            err = e.StartTLS(fmt.Sprintf(":%d", port), cert, key)<br/>        } else {<br/>            err = e.Start(fmt.Sprintf(":%d", port))<br/>        }</span><span id="9264" class="kc kd iq mc b gy nd na l nb nc">if err != nil {<br/>            return cli.NewExitError(err, 1)<br/>        }</span><span id="a560" class="kc kd iq mc b gy nd na l nb nc">return nil<br/>    }</span><span id="8efa" class="kc kd iq mc b gy nd na l nb nc">app.Run(os.Args)</span></pre><p id="d8f9" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">这是来自<code class="fe lz ma mb mc b">handlers/validating_admission.go</code>的一段，基本上它解析并验证图像是否应该被允许，然后它发送一个<a class="ae lt" href="https://pkg.go.dev/k8s.io/api/admission/v1beta1" rel="noopener ugc nofollow" target="_blank">许可响应</a>，标志<code class="fe lz ma mb mc b">Allowed</code>设置为真或假。如果你想进一步了解这里使用的不同类型，你可以探索一下<a class="ae lt" href="https://pkg.go.dev/k8s.io/api/admission/v1beta1" rel="noopener ugc nofollow" target="_blank"> v1beta1。入院文件</a></p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="3c14" class="kc kd iq mc b gy mz na l nb nc">func PostValidatingAdmission() echo.HandlerFunc {<br/>    return func(c echo.Context) error {<br/>        var admissionReview v1beta1.AdmissionReview</span><span id="8f9c" class="kc kd iq mc b gy nd na l nb nc">err := c.Bind(&amp;admissionReview)<br/>        if err != nil {<br/>            c.Logger().Errorf("Something went wrong while unmarshalling admission review: %+v", err)<br/>            return c.JSON(http.StatusBadRequest, err)<br/>        }<br/>        c.Logger().Debugf("admission review: %+v", admissionReview)</span><span id="a937" class="kc kd iq mc b gy nd na l nb nc">pod := v1.Pod{}<br/>        if err := json.Unmarshal(admissionReview.Request.Object.Raw, &amp;pod); err != nil {<br/>            c.Logger().Errorf("Something went wrong while unmarshalling pod object: %+v", err)<br/>            return c.JSON(http.StatusBadRequest, err)<br/>        }<br/>        c.Logger().Debugf("pod: %+v", pod)</span><span id="4a6b" class="kc kd iq mc b gy nd na l nb nc">admissionReview.Response = &amp;v1beta1.AdmissionResponse{<br/>            Allowed: true,<br/>            UID:     admissionReview.Request.UID,<br/>        }<br/>        images := []string{}</span><span id="ed22" class="kc kd iq mc b gy nd na l nb nc">for _, container := range pod.Spec.Containers {<br/>            images = append(images, container.Image)<br/>            usingLatest, err := rules.IsUsingLatestTag(container.Image)<br/>            if err != nil {<br/>                c.Logger().Errorf("Error while parsing image name: %+v", err)<br/>                return c.JSON(http.StatusInternalServerError, "error while parsing image name")<br/>            }<br/>            if usingLatest {<br/>                admissionReview.Response.Allowed = false<br/>                admissionReview.Response.Result = &amp;metav1.Status{<br/>                    Message: "Images using latest tag are not allowed",<br/>                }<br/>                break<br/>            }</span><span id="aa74" class="kc kd iq mc b gy nd na l nb nc">if len(RegistryWhitelist) &gt; 0 {<br/>                validRegistry, err := rules.IsFromWhiteListedRegistry(<br/>                    container.Image,<br/>                    RegistryWhitelist)<br/>                if err != nil {<br/>                    c.Logger().Errorf("Error while looking for image registry: %+v", err)<br/>                    return c.JSON(<br/>                        http.StatusInternalServerError,<br/>                        "error while looking for image registry")<br/>                }<br/>                if !validRegistry {<br/>                    admissionReview.Response.Allowed = false<br/>                    admissionReview.Response.Result = &amp;metav1.Status{<br/>                        Message: "Images from a non whitelisted registry",<br/>                    }<br/>                    break<br/>                }<br/>            }<br/>        }</span><span id="b578" class="kc kd iq mc b gy nd na l nb nc">if admissionReview.Response.Allowed {<br/>            c.Logger().Debugf("All images accepted: %v", images)<br/>        } else {<br/>            c.Logger().Infof("Rejected images: %v", images)<br/>        }</span><span id="f3c6" class="kc kd iq mc b gy nd na l nb nc">c.Logger().Debugf("admission response: %+v", admissionReview.Response)</span><span id="90c4" class="kc kd iq mc b gy nd na l nb nc">return c.JSON(http.StatusOK, admissionReview)<br/>    }<br/>}</span></pre><p id="27e0" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">一切都在这个<a class="ae lt" href="https://github.com/kainlite/kube-image-bouncer" rel="noopener ugc nofollow" target="_blank">回购</a>里。</p><h2 id="e94b" class="kc kd iq bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结束语</h2><p id="ee91" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">这个例子和最初的帖子是在这里<a class="ae lt" href="https://github.com/flavio/kube-image-bouncer" rel="noopener ugc nofollow" target="_blank">完成的</a>，所以感谢<a class="ae lt" href="https://flavio.castelli.me/" rel="noopener ugc nofollow" target="_blank"> Flavio Castelli </a>创建了这样一个伟大的例子，我的修改主要是解释它是如何工作的，以及它在最新的kubernetes版本(目前是v1.20.0)中工作所需的修改，因为我正在学习使用它并创建自己的例子。</p><p id="cccb" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">项目中的自述文件可能与本文不匹配，但应该都可以，我还没有更新整个自述文件。</p><h1 id="0356" class="ne kd iq bd ke nf ng nh kh ni nj nk kk nl nm nn ko no np nq ks nr ns nt kw nu bi translated">正误表</h1><p id="e7ba" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">如果您发现任何错误或有任何建议，请给我发消息，以便解决问题。</p><p id="5321" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">此外，您还可以在这里查看源代码和<a class="ae lt" href="https://github.com/kainlite/kainlite.github.io" rel="noopener ugc nofollow" target="_blank">生成代码</a>和<a class="ae lt" href="https://github.com/kainlite/blog" rel="noopener ugc nofollow" target="_blank">源代码</a>的变化</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="551a" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated"><em class="oc">原载于2021年1月7日</em><a class="ae lt" href="https://techsquad.rocks/blog/kubernetes_image_policy_webhook_explained/" rel="noopener ugc nofollow" target="_blank"><em class="oc">https://tech squad . rocks</em></a><em class="oc">。</em></p></div></div>    
</body>
</html>