<html>
<head>
<title>Elasticsearch index management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">弹性搜索索引管理</h1>
<blockquote>原文：<a href="https://itnext.io/elasticsearch-index-management-17b1f2b28553?source=collection_archive---------0-----------------------#2020-04-23">https://itnext.io/elasticsearch-index-management-17b1f2b28553?source=collection_archive---------0-----------------------#2020-04-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/69b3e0fd708841ed45b0c2f3d91a1469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9xXfXTRVl_D3Yk9TjLTPoQ.png"/></div></div></figure><p id="3586" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Elasticsearch集群中跨节点组织数据的方式对性能和可靠性有着巨大的影响。一个经过良好优化的配置可以改变一切。</p><p id="2e9c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Elasticsearch中的数据存储在索引中。例如，索引管理和配置在弹性搜索集群的性能中起着关键作用。</p><h1 id="500f" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">索引概述</h1><p id="ddae" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">Elasticsearch中的指数到底是什么？尽管这是一个非常基本的问题，但答案却令人惊讶地微妙。</p><p id="62f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个<strong class="kd iu">索引</strong>是一个具有相似特征的<strong class="kd iu">文档</strong>的集合。索引由名称标识，当对其中的文档执行索引、搜索、更新和删除操作时，该名称用于引用索引。</p><p id="2c0f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">文档</strong>是存储在弹性搜索索引中的JSON对象，被认为是存储的基本单元。在关系数据库的世界中，文档可以比作表中的一行。</p><p id="e1bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个文档包含一系列的<strong class="kd iu">字段</strong>，或者键值对。该值可以是简单的值(如字符串、整数、日期)，也可以是嵌套结构，如数组或对象。字段类似于关系数据库中表中的列。</p><p id="289c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">随着索引的增长，其大小可能会超过节点的硬件限制。然而，索引被水平分割成称为<strong class="kd iu">碎片</strong>的块。一个碎片包含一个索引数据的子集。当对索引进行分片时，该索引中的给定文档将只存储在其中一个分片中。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/9e22af0efeb47756a821993ad4e7fbb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ApX4ezGiyYJ90UeEpefYig.png"/></div></div></figure><p id="ecb6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">分片允许跨节点更好地分布数据和操作，从而提高性能。搜索可以跨不同的分片并行运行，从而加快查询处理。</p><blockquote class="mh mi mj"><p id="10f1" class="kb kc mk kd b ke kf kg kh ki kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ky im bi translated">索引中碎片的数量由索引创建决定，以后不能轻易更改。</p></blockquote><p id="3003" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">碎片有两种类型:<strong class="kd iu">初级</strong>和<strong class="kd iu">副本</strong>。<strong class="kd iu">主碎片</strong>是处理文档索引的主碎片，也可以处理查询。索引中的每个文档都属于一个主碎片。副本碎片<strong class="kd iu">是主碎片的副本。副本碎片处理查询，但不直接索引文档。它们为您的数据提供冗余拷贝，以防止硬件故障，并增加处理读取请求(如搜索或检索文档)的能力。副本总是被分配到与主碎片不同的节点，并且在主碎片失败的情况下，副本碎片可以被提升以取代它的位置。</strong></p><p id="29c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于节点和索引状态的可视化表示，我们发现<a class="ae mo" href="https://github.com/lmenezes/cerebro" rel="noopener ugc nofollow" target="_blank"> cerebro </a>做得非常好。在集群升级期间进行集群重新平衡是一件非常有趣的事情。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mp"><img src="../Images/baeef7c230647f9bf0dad5d4e49f728c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ua9N1_JFnNLGRCdA1Z6w1g.png"/></div></div></figure><p id="76a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下图显示了包含5个碎片和1个副本的索引在两个节点上的分布。连续的线方块代表原始碎片，而不连续的线方块代表复制品。</p><h1 id="8fc0" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">日志索引</h1><p id="7048" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">使用Elasticsearch进行日志记录是扩展最多的用例。在这种情况下，每天创建一个包含一天日志的新索引是很常见的。索引列表可能如下所示:</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="9c9c" class="mv la it mr b gy mw mx l my mz">GET _cat/indices?v<br/>health  status index                uuid   pri rep  docs.count docs.deleted store.size pri.store.size<br/>green   open   logstash-2020.04.03  xxxx   5   1    1941829    0            2gb        1gb<br/>green   open   logstash-2020.04.02  xxxx   5   1    2102403    0            2gb        1gb<br/>green   open   logstash-2020.04.01  xxxx   5   1    2243759    0            2gb        1gb</span></pre><blockquote class="mh mi mj"><p id="35c3" class="kb kc mk kd b ke kf kg kh ki kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ky im bi translated">Kibana允许您定义一个索引模式，并一次查询多个索引。</p></blockquote><p id="d2b8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">指数将使用默认的弹性搜索配置，即:</p><ul class=""><li id="872d" class="na nb it kd b ke kf ki kj km nc kq nd ku ne ky nf ng nh ni bi translated">5个主要碎片</li><li id="0a70" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">1个副本碎片</li><li id="c367" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">1000个字段</li><li id="f2c1" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">1s刷新间隔</li></ul><p id="2a35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些值并不总是最佳的，这取决于您的使用情况。如果您想修改它们，建议在创建索引时进行，因为以后修改它们是一个麻烦而困难的过程。这可以通过使用索引模板来实现。</p><h1 id="4f12" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">索引模板</h1><p id="9a9c" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">索引模板定义了基于索引模式创建新索引时将自动应用的设置和映射。</p><blockquote class="mh mi mj"><p id="4723" class="kb kc mk kd b ke kf kg kh ki kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ky im bi translated">模板仅在索引创建时应用。更改模板不会影响现有的索引。</p></blockquote><p id="850b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于日志索引，通常让<a class="ae mo" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/dynamic-mapping.html" rel="noopener ugc nofollow" target="_blank">动态映射</a>完成它的工作，自动检测并向映射添加新的字段。动态制图允许您快速开始可视化和索引数据。</p><blockquote class="mh mi mj"><p id="91ff" class="kb kc mk kd b ke kf kg kh ki kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ky im bi translated">动态映射有以不需要的字段数据类型结束的风险。任何新字段都将被检测到，并使用Elasticsearch认为最接近的数据类型创建。为了强制字段数据类型，您必须在索引模板中为索引定义映射。</p></blockquote><p id="359c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">添加下面的模板，所有前缀为<strong class="kd iu"> logstash- </strong>的新索引将创建4个分片，1个副本(默认)，刷新间隔为30秒，限制为1500个字段。</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="b1b9" class="mv la it mr b gy mw mx l my mz">PUT _template/logstash<br/>{<br/>    "index_patterns" : ["logstash-*"],<br/>    "settings" : {<br/>        "index.mapping.total_fields.limit" : "1500",<br/>        "number_of_shards": 4,<br/>        "refresh_interval": "30s"<br/>    }<br/>}</span></pre><p id="a2ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可以使用以下命令检索索引模板:</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="e364" class="mv la it mr b gy mw mx l my mz">GET /_template/logstash</span></pre><p id="e4af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可以使用以下方法检索所有模板的列表:</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="db48" class="mv la it mr b gy mw mx l my mz">GET _cat/templates</span></pre><p id="765e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可以使用以下方法检索所有模板的列表:</p><h1 id="3c85" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">索引状态管理</h1><p id="b7fa" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">此时，使用由索引模板指定的设置和映射创建新的索引。然而，索引将永远存在，除非它们被手动删除。这就是ISM政策有用的地方。</p><p id="7803" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae mo" href="https://opendistro.github.io/for-elasticsearch-docs/docs/ism/" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">索引状态管理(ISM) </strong> </a>是一个插件，通过根据索引年龄、索引大小或文档数量的变化触发这些操作，您可以自动执行定期的管理操作。使用ISM插件，您可以定义自动处理索引翻转或删除的策略，以适应您的使用情况。</p><p id="3691" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">策略是定义以下内容的JSON文档:</p><ul class=""><li id="82a9" class="na nb it kd b ke kf ki kj km nc kq nd ku ne ky nf ng nh ni bi translated"><strong class="kd iu">表示索引可以处于的</strong>，包括新索引的默认状态。例如，您可以将您的状态命名为“热”、“暖”、“删除”等等。</li><li id="b40e" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">当索引进入一种状态时，您想要采取的任何<strong class="kd iu">动作</strong>，比如执行翻转或者删除索引。</li><li id="8543" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">指数进入新状态所必须满足的<strong class="kd iu">条件</strong>，称为转换。例如，如果一个索引超过60天，您可能希望将其移至“删除”状态。</li></ul><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="b620" class="mv la it mr b gy mw mx l my mz">PUT _opendistro/_ism/policies/60d_retention<br/>{<br/>  "policy": {<br/>    "policy_id": "60d_retention",<br/>    "description": "60d retention policy",<br/>    "default_state": "hot",<br/>    "schema_version": 1,<br/>    "states": [<br/>      {<br/>        "name": "hot",<br/>        "actions": [],<br/>        "transitions": [<br/>          {<br/>            "state_name": "delete",<br/>            "conditions": {<br/>              "min_index_age": "60d"<br/>            }<br/>          }<br/>        ]<br/>      },<br/>      {<br/>        "name": "delete",<br/>        "actions": [<br/>          {<br/>            "delete": {}<br/>          }<br/>        ]<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><p id="11d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下策略包含两个<strong class="kd iu">状态</strong>(热状态和删除状态)，当满足条件时的<strong class="kd iu">转换</strong>(索引超过60天)，以及当索引从热状态转换到删除状态时采取的<strong class="kd iu">动作</strong>(删除状态):</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="43bb" class="mv la it mr b gy mw mx l my mz">PUT _template/logstash<br/>{<br/>    "index_patterns" : ["logstash-*"],<br/>    "settings" : {<br/>        "index.mapping.total_fields.limit" : "1500",<br/>        "number_of_shards": 4,<br/>        "opendistro.index_state_management.policy_id": "60d_retention"<br/>    }<br/>}</span></pre><p id="3e7d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不同的政策可以应用于不同的指数。通过将策略添加到索引模板定义中，可以在创建索引时将策略附加到索引:</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="2e09" class="mv la it mr b gy mw mx l my mz">PUT logstash-2020.04.01<br/>{<br/>  "settings" : {<br/>      "index.mapping.total_fields.limit" : "1500",<br/>      "number_of_shards": 4,<br/>      "opendistro.index_state_management.policy_id": "60d_retention"<br/>    }<br/>}</span></pre><p id="6fa5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您还可以向现有索引添加策略:</p><h1 id="33c5" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">选择索引设置时的一些注意事项</h1><p id="25e4" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated"><strong class="kd iu">碎片数量:</strong>一个好的经验法则是尽量保持碎片大小在10-50 GiB之间。大碎片会让Elasticsearch很难从失败中恢复。另一方面，太多的小碎片会导致性能问题和内存不足错误。</p><p id="b984" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">副本数量:</strong>为了实现高可用性，建议至少有一个副本。副本通常会提高搜索性能。但是，插入和更新需要传播到所有副本，因此，如果您的群集是写入密集型的，您可能希望保留少量副本。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/ec59bd208b763fa37529857a24218e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k5M-R5NqWQmsAEFEkxXyrg.png"/></div></div></figure><p id="72c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">节点和分片之间的关系:</strong>对于一个平衡良好的集群，分片(主+副本)的数量应该与节点的数量成正比。否则，一些节点会比其他节点有更多的碎片，导致更高的负载。</p><h1 id="e019" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">额外的好处:启用慢速日志</h1><p id="6794" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">Elasticsearch有两个慢速日志可以帮助您识别性能问题:搜索慢速日志<strong class="kd iu">和索引慢速日志<strong class="kd iu"/>。这些日志依赖于阈值，这些阈值定义了什么是“缓慢”的搜索或索引操作。</strong></p><h2 id="b255" class="mv la it bd lb np nq dn lf nr ns dp lj km nt nu ln kq nv nw lr ku nx ny lv nz bi translated">搜索慢速日志</h2><p id="4fff" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">搜索缓慢日志用于记录缓慢的搜索。弹性搜索分为两个阶段:</p><ul class=""><li id="5898" class="na nb it kd b ke kf ki kj km nc kq nd ku ne ky nf ng nh ni bi translated"><strong class="kd iu">查询阶段</strong>:在查询阶段，Elasticsearch收集相关结果的文档id。这个阶段完成后，只返回与搜索匹配的文档的id，不会有其他信息，如字段或它们的值等。</li><li id="4154" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated"><strong class="kd iu">获取阶段</strong>:在获取阶段，来自查询阶段的文档id被用来获取真正的文档，这样搜索请求就可以说是完成了。</li></ul><p id="18e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可以为查询阶段和获取阶段设置阈值。</p><h2 id="debb" class="mv la it bd lb np nq dn lf nr ns dp lj km nt nu ln kq nv nw lr ku nx ny lv nz bi translated">索引慢速日志</h2><p id="1b7d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">索引慢速日志用于记录索引过程。当在Elasticsearch中对文档进行索引时，索引缓慢日志会记录需要较长时间才能完成的请求。可以在索引日志的配置设置中调整阈值。</p><p id="1878" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认情况下，Elasticsearch会将文档的前1000行记录到日志文件中。根据我们如何配置设置，这可以更改为null，或者更改为记录整个文档。</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="f520" class="mv la it mr b gy mw mx l my mz">PUT _template/logstash<br/>{<br/>    "index_patterns" : ["logstash-*"],<br/>    "settings" : {<br/>        "index.mapping.total_fields.limit" : 1500,<br/>        "opendistro.index_state_management.policy_id": "60d_retention",<br/>        "number_of_shards": 4,<br/>        "index.search.slowlog.threshold.query.warn": "10s",<br/>        "index.search.slowlog.threshold.query.info": "5s",<br/>        "index.search.slowlog.threshold.query.debug": "2s",<br/>        "index.search.slowlog.threshold.query.trace": "500ms",<br/>        "index.search.slowlog.threshold.fetch.warn": "1s",<br/>        "index.search.slowlog.threshold.fetch.info": "800ms",<br/>        "index.search.slowlog.threshold.fetch.debug": "500ms",<br/>        "index.search.slowlog.threshold.fetch.trace": "200ms",<br/>        "index.search.slowlog.level": "info",<br/>        "index.indexing.slowlog.threshold.index.warn": "10s",<br/>        "index.indexing.slowlog.threshold.index.info": "5s",<br/>        "index.indexing.slowlog.threshold.index.debug": "2s",<br/>        "index.indexing.slowlog.threshold.index.trace": "500ms",<br/>        "index.indexing.slowlog.level": "info",<br/>        "index.indexing.slowlog.source": "1000"<br/>    }<br/>}</span></pre><h1 id="719f" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="79e5" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在giffgaff，我们在管理弹性搜索集群时遇到了一些困难。我们已经从使用现成的索引设置发展到使用定制的索引模板。我们针对不同的索引实施了保留策略，在数据保留和存储之间找到了恰当的平衡。我们还增加了额外的日志记录来识别搜索和索引中的性能问题。</p><p id="fba7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据您的工作量，您必须找到适合您的设置。如果你已经达到这一步，实现它们应该很容易。</p><h2 id="0cb1" class="mv la it bd lb np nq dn lf nr ns dp lj km nt nu ln kq nv nw lr ku nx ny lv nz bi translated">来源</h2><ul class=""><li id="c23f" class="na nb it kd b ke lx ki ly km oa kq ob ku oc ky nf ng nh ni bi translated">弹性文档:<a class="ae mo" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" rel="noopener ugc nofollow" target="_blank">https://www . elastic . co/guide/en/elastic search/reference/current/index . html</a></li><li id="5751" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">open distro docs:<a class="ae mo" href="https://opendistro.github.io/for-elasticsearch-docs/docs/ism/" rel="noopener ugc nofollow" target="_blank">https://open distro . github . io/for-elastic search-docs/docs/ism/</a></li></ul></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><p id="5621" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mk">原发布于</em><a class="ae mo" href="https://www.giffgaff.io/tech/elasticsearch-index-management/" rel="noopener ugc nofollow" target="_blank"><em class="mk">https://www . giffgaff . io</em></a><em class="mk">。</em></p></div></div>    
</body>
</html>