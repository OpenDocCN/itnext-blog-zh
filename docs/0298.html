<html>
<head>
<title>Fun with Stamps. Episode 21. Private data in JavaScript. 4 ways using stamps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">邮票的乐趣。第21集。JavaScript中的私有数据。邮票的4种使用方法</h1>
<blockquote>原文：<a href="https://itnext.io/fun-with-stamps-episode-21-private-data-in-javascript-4-ways-using-stamps-f43ba93e25bb?source=collection_archive---------1-----------------------#2018-02-12">https://itnext.io/fun-with-stamps-episode-21-private-data-in-javascript-4-ways-using-stamps-f43ba93e25bb?source=collection_archive---------1-----------------------#2018-02-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/aec00382b566f09fb04b34ef0377b9b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_9YYG_qF2dyaeyUe8ySDsw.png"/></div></div></figure><div class=""/><p id="0fe9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你好。我是开发者瓦西里·博罗维亚克，欢迎来到第21集<em class="kw">瓦西里·博罗维亚克为</em>带来 <strong class="ka jc"> <em class="kw">乐趣</em> </strong> <em class="kw">。</em></p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="4dc9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae le" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Ffun-with-stamps-episode-21-private-data-in-javascript-4-ways-using-stamps-f43ba93e25bb" rel="noopener ugc nofollow" target="_blank"> <em class="kw">点击这里在LinkedIn上分享这篇文章</em> </a></p><p id="dcfe" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">人们经常问的一个问题是——如何在stamps中拥有私有的(或者受保护的，或者仅仅是特权的)数据或方法。</p><p id="7df4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">回答</strong> —一般来说，与JavaScript中的做法相同。这里有4种方法。</p><p id="0e01" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">TL；DR:闭包、符号、WeakMap、代理对象(通过<a class="ae le" href="https://www.npmjs.com/package/@stamp/privatize" rel="noopener ugc nofollow" target="_blank">私有化</a>戳记)。</p><h1 id="7781" class="lf lg jb bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">1.关闭</h1><p id="f9e5" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">这是最广为人知和最隐私的隐藏数据的方法。(看评论！)</p><p id="e9ee" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们用私有数据<code class="fe mi mj mk ml b">token</code>和私有函数<code class="fe mi mj mk ml b">request</code>创建一个<code class="fe mi mj mk ml b">BlockchainApi</code>戳。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="3ec7" class="mu lg jb ml b gy mv mw l mx my"><strong class="ml jc">const</strong> rp = require(<em class="kw">'request-promise'</em>)<br/><strong class="ml jc">const</strong> {init} = require(<em class="kw">'@stamp/it'</em>) <strong class="ml jc"><em class="kw">// using the init shorthand here</em></strong></span><span id="9799" class="mu lg jb ml b gy mz mw l mx my"><strong class="ml jc">const</strong> BlockchainApi = init(<strong class="ml jc">function</strong> ({config}) {<br/>  <strong class="ml jc"><em class="kw">// private data</em></strong><br/>  <strong class="ml jc">const</strong> token = config.token<br/>  <strong class="ml jc"><em class="kw">// public property</em></strong><br/>  <strong class="ml jc">this</strong>.url = config.url</span><span id="de9c" class="mu lg jb ml b gy mz mw l mx my"><strong class="ml jc"><em class="kw">  // private method accesses both the public and the private data</em></strong><br/>  <strong class="ml jc">const</strong> request = ({path = '', body, method = 'GET'} = {}) =&gt; {<br/>    <strong class="ml jc">return</strong> rp({<br/>      url: <strong class="ml jc">this</strong>.url + <em class="kw">'/'</em> + path, <strong class="ml jc"><em class="kw">// url is public</em></strong><br/>      headers: {authorization: token}, <strong class="ml jc"><em class="kw">// but token is private</em></strong><br/>      json: true,<br/>      body,<br/>      method<br/>    })<br/>  }</span><span id="e128" class="mu lg jb ml b gy mz mw l mx my">  <strong class="ml jc"><em class="kw">// public method accesses the private method<br/></em></strong>  <strong class="ml jc">this</strong>.ping = () =&gt; request()<br/>})</span></pre><p id="6798" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在另一文件中:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="91b4" class="mu lg jb ml b gy mv mw l mx my"><strong class="ml jc">const</strong> config = {token: <em class="kw">'1'</em>, url: <em class="kw">'http://i.ua'</em>}<br/><strong class="ml jc">const</strong> blockchainApi = BlockchainApi({config}) <strong class="ml jc"><em class="kw">// create instance</em></strong></span><span id="dbc7" class="mu lg jb ml b gy mz mw l mx my">blockchainApi.ping().then(() =&gt; console.log(<em class="kw">'ok'</em>)) <strong class="ml jc"><em class="kw">// have access</em></strong></span></pre><p id="03d2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，stamp <code class="fe mi mj mk ml b">BlockchainApi</code>只有一个初始化器。在这里，我们创建了公共方法<code class="fe mi mj mk ml b">ping</code>，它可以访问私有方法<code class="fe mi mj mk ml b">request</code>，而私有方法又可以访问私有数据<code class="fe mi mj mk ml b">token</code>。</p><p id="93ab" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着每个需要访问<code class="fe mi mj mk ml b">request</code>的新方法都必须是这个闭包的一部分。这有时可能不太理想。邮票最好很小。</p><p id="a3c7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">优点:</p><ol class=""><li id="4bd4" class="na nb jb ka b kb kc kf kg kj nc kn nd kr ne kv nf ng nh ni bi translated">这是隐藏数据最私密的方式。没有人可以访问它。</li><li id="5564" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">私有方法可以访问<strong class="ka jc">一些</strong>公共方法(<code class="fe mi mj mk ml b">request</code>可以访问<code class="fe mi mj mk ml b">ping</code>)。</li></ol><p id="fc0e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">缺点:</p><ol class=""><li id="28e2" class="na nb jb ka b kb kc kf kg kj nc kn nd kr ne kv nf ng nh ni bi translated">内存效率不高。它为每个对象实例创建了两个封闭函数。</li><li id="d26f" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">要添加另一个方法(如<code class="fe mi mj mk ml b">verifyBlock()</code>)，它应该是<strong class="ka jc">同</strong> <code class="fe mi mj mk ml b"><strong class="ka jc">init</strong></code> <strong class="ka jc">功能</strong>的一部分。一般来说，膨胀单个图章是个坏主意。如果<code class="fe mi mj mk ml b">BlockchainApi</code>戳记由另一个戳记组成，那么它将不能访问<code class="fe mi mj mk ml b">request</code>方法。</li></ol><h1 id="56bc" class="lf lg jb bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">2.标志</h1><p id="d5f3" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">看评论。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="72ea" class="mu lg jb ml b gy mv mw l mx my"><strong class="ml jc">const </strong>rp = require(<em class="kw">'request-promise'</em>)<br/><strong class="ml jc">const </strong>stampit = require(<em class="kw">'@stamp/it'</em>)<br/><br/><strong class="ml jc">const </strong>requestMethod = Symbol(<em class="kw">'requestMethod'</em>)<br/><strong class="ml jc">const </strong>tokenData = Symbol(<em class="kw">'tokenData'</em>)<br/><br/><strong class="ml jc">const </strong>BlockchainApi = stampit({<br/>  init ({config}) {<br/>    <strong class="ml jc"><em class="kw">// protected data</em></strong><br/>    <strong class="ml jc">this</strong>[tokenData] = config.token<br/>    <strong class="ml jc"><em class="kw">// public property</em></strong><br/>    <strong class="ml jc">this</strong>.url = config.url<br/>  },<br/><br/>  methods: {<br/>    <strong class="ml jc"><em class="kw">// protected method accesses both public and protected data</em></strong><br/>    [requestMethod] ({path = <em class="kw">''</em>, body, method = <em class="kw">'GET'</em>} = {}) {<br/>      <strong class="ml jc">return </strong>rp({<br/>        url: <strong class="ml jc">this</strong>.url + <em class="kw">'/'</em> + path,<br/>        headers: {authorization: <strong class="ml jc">this</strong>[tokenData]},<br/>        json: <strong class="ml jc">true</strong>,<br/>        body,<br/>        method<br/>      })<br/>    },<br/><br/>    ping () {<br/>      <strong class="ml jc"><em class="kw">// public method accesses the protected method</em></strong><br/>      <strong class="ml jc">return this</strong>[requestMethod]()<br/>    }<br/>  }<br/>})</span></pre><p id="aa6a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在另一文件中:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="130e" class="mu lg jb ml b gy mv mw l mx my"><strong class="ml jc">const </strong>config = {token: <em class="kw">'1'</em>, url: <em class="kw">'http://i.ua'</em>}<br/><strong class="ml jc">const </strong>blockchainApi = BlockchainApi({config}) <strong class="ml jc"><em class="kw">// create instance</em></strong><br/><br/>blockchainApi.ping().then(() =&gt; console.log(<em class="kw">'ok'</em>)) <strong class="ml jc"><em class="kw">// have access</em></strong></span></pre><p id="ea21" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用符号作为属性键。这意味着如果代码可以访问符号本身，那么它就可以检索“受保护”的数据。</p><p id="8fa9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">优点:</p><ol class=""><li id="dda0" class="na nb jb ka b kb kc kf kg kj nc kn nd kr ne kv nf ng nh ni bi translated">这是一种简单的隐藏数据的方法。大多数时候都适用。</li><li id="5dc4" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">与闭包不同，内存友好。</li><li id="4eed" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">受保护的方法可以访问<strong class="ka jc">所有</strong>公共方法。</li></ol><p id="f74a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">缺点:</p><ol class=""><li id="daf8" class="na nb jb ka b kb kc kf kg kj nc kn nd kr ne kv nf ng nh ni bi translated">私有数据和方法仍然可以用更多的JavaScript代码来访问和修改(<a class="ae le" href="https://derickbailey.com/2015/10/12/hide-the-backing-variable-of-object-propertiesattributes-using-es6-symbols/" rel="noopener ugc nofollow" target="_blank">示例</a>)。</li><li id="7193" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">要添加另一个方法(如<code class="fe mi mj mk ml b">verifyBlock()</code>)，它应该是<strong class="ka jc">相同文件</strong>的一部分。如果这个<code class="fe mi mj mk ml b">BlockchainApi</code>戳记是由另一个文件中的另一个戳记组成的，那么它将不能访问<code class="fe mi mj mk ml b">request</code>方法。</li></ol><h1 id="d6a3" class="lf lg jb bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">3.WeakMap</h1><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="7410" class="mu lg jb ml b gy mv mw l mx my"><strong class="ml jc">const </strong>rp = require(<em class="kw">'request-promise'</em>)<br/><strong class="ml jc">const </strong>stampit = require(<em class="kw">'@stamp/it'</em>)<br/><br/><strong class="ml jc">const </strong>mapOfPrivateObjects = <strong class="ml jc">new </strong>WeakMap()<br/><br/><strong class="ml jc"><em class="kw">// private method accesses both the public and private data</em></strong><br/><strong class="ml jc">function </strong>requestMethod ({path = <em class="kw">''</em>, body, method = <em class="kw">'GET'</em>} = {}) {<br/>  <strong class="ml jc">return </strong>rp({<br/>    url: <strong class="ml jc">this</strong>.url + <em class="kw">'/'</em> + path,<br/>    headers: {authorization: mapOfPrivateObjects.get(<strong class="ml jc">this</strong>).token},<br/>    json: <strong class="ml jc">true</strong>,<br/>    body,<br/>    method<br/>  })<br/>}<br/><br/><strong class="ml jc">const </strong>BlockchainApi = stampit({<br/>  init ({config}) {<br/>    <strong class="ml jc"><em class="kw">// private data and method</em></strong><br/>    mapOfPrivateObjects.set(<strong class="ml jc">this</strong>, {<br/>      token: config.token,<br/>      request: (...args) =&gt; requestMethod.apply(<strong class="ml jc">this</strong>, ...args)<br/>    })<br/>    <strong class="ml jc"><em class="kw">// public property</em></strong><br/>    <strong class="ml jc">this</strong>.url = config.url<br/>  },<br/><br/>  methods: {<br/>    ping () {<br/>      <strong class="ml jc"><em class="kw">// public method accesses the private method</em></strong><br/>      <strong class="ml jc">return </strong>mapOfPrivateObjects.get(<strong class="ml jc">this</strong>).request()<br/>    }<br/>  }<br/>})</span></pre><p id="4b8b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在另一文件中:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="5922" class="mu lg jb ml b gy mv mw l mx my"><strong class="ml jc">const </strong>config = {token: <em class="kw">'1'</em>, url: <em class="kw">'http://i.ua'</em>}<br/><strong class="ml jc">const </strong>blockchainApi = BlockchainApi({config}) <strong class="ml jc"><em class="kw">// create instance</em></strong></span><span id="db33" class="mu lg jb ml b gy mz mw l mx my">blockchainApi.ping().then(() =&gt; console.log(<em class="kw">'ok'</em>)) <strong class="ml jc"><em class="kw">// have access</em></strong></span></pre><p id="3462" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用WeakMap作为每个对象实例的私有数据存储。这比符号更好，数据现在是真正的私有了。此外，这比闭包要好——内存效率更高。</p><p id="f093" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">优点:</p><ol class=""><li id="3456" class="na nb jb ka b kb kc kf kg kj nc kn nd kr ne kv nf ng nh ni bi translated">这是一种隐藏数据的私人方式。没有人能改变它。</li><li id="6230" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">记忆友好。</li><li id="913d" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">私有方法<strong class="ka jc">可以</strong>访问<strong class="ka jc">任何</strong>公共方法。</li></ol><p id="47ed" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">缺点:</p><ol class=""><li id="bf5e" class="na nb jb ka b kb kc kf kg kj nc kn nd kr ne kv nf ng nh ni bi translated">要添加另一个方法(如<code class="fe mi mj mk ml b">verifyBlock()</code>，它应该是<strong class="ka jc">相同文件</strong>的一部分。如果这个<code class="fe mi mj mk ml b">BlockchainApi</code>图章是由另一个文件中的另一个图章组成的，那么它将无法访问<code class="fe mi mj mk ml b">request</code>方法。</li></ol><h1 id="2217" class="lf lg jb bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">4.代理对象通过<a class="ae le" href="https://www.npmjs.com/package/@stamp/privatize" rel="noopener ugc nofollow" target="_blank">私有化</a>盖章</h1><p id="fa07" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">如果您用您的图章组合<code class="fe mi mj mk ml b">Privatize</code>,那么从您的新图章创建的对象将是包装对象。这些方法将把每个方法(除了您声明为私有的方法)包装到包装器方法中，包装器方法将调用原始的对象实例方法。见图片。</p><figure class="mm mn mo mp gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi no"><img src="../Images/44d71eaa4fb0fcef3ab7ce399b093129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I9mmN96grVRYAXuH6f6Kfg.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">左:对象实例指向其原型。右图:包装器对象调用对象实例方法，并指向其原型。</figcaption></figure><p id="5d2f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">返回的包装对象将具有与原始对象实例相同的方法集，但没有任何属性。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="f3c7" class="mu lg jb ml b gy mv mw l mx my"><strong class="ml jc">const </strong>rp = require(<em class="kw">'request-promise'</em>)<br/><strong class="ml jc">const </strong>stampit = require(<em class="kw">'@stamp/it'</em>)<br/><strong class="ml jc">const </strong>{privatizeMethods} = require(<em class="kw">'@stamp/privatize'</em>)<br/><br/><strong class="ml jc">const </strong>BlockchainApi = stampit({<br/>  init({config}) {<br/>    <strong class="ml jc"><em class="kw">// private data</em></strong><br/>    <strong class="ml jc">this</strong>.token = config.token<br/>    <strong class="ml jc"><em class="kw">// private data too!!! But was public in previous examples</em></strong><br/>    <strong class="ml jc">this</strong>.url = config.url<br/>  }<br/>},<br/>privatizeMethods(<em class="kw">'request'</em>), <strong class="ml jc"><em class="kw">// Hiding a method</em></strong><br/>{<br/>  methods: {<br/>    <strong class="ml jc"><em class="kw">// private method accesses private data, or public methods</em></strong><br/>    request({path = <em class="kw">''</em>, body, method = <em class="kw">'GET'</em>} = {}) {<br/>      <strong class="ml jc">return </strong>rp({<br/>        url: <strong class="ml jc">this</strong>.url + <em class="kw">'/'</em> + path,<br/>        headers: {authorization: <strong class="ml jc">this</strong>.token},<br/>        json: <strong class="ml jc">true</strong>,<br/>        body,<br/>        method<br/>      })<br/>    },<br/><br/>    ping() {<br/>      <strong class="ml jc"><em class="kw">// public method accesses the private method</em></strong><br/>      <strong class="ml jc">return this</strong>.request()<br/>    }<br/>  }<br/>})</span></pre><p id="6141" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在另一文件中:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="3341" class="mu lg jb ml b gy mv mw l mx my"><strong class="ml jc">const </strong>config = {token: <em class="kw">'1'</em>, url: <em class="kw">'http://i.ua'</em>}<br/><strong class="ml jc">const </strong>blockchainApi = BlockchainApi({config}) <strong class="ml jc"><em class="kw">// create instance</em></strong></span><span id="657f" class="mu lg jb ml b gy mz mw l mx my">blockchainApi.ping().then(() =&gt; console.log(<em class="kw">'ok'</em>)) <strong class="ml jc"><em class="kw">// have access</em></strong></span></pre><p id="8c13" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不确定赞成还是反对，但是所有公共方法都可以访问所有私有方法(比如经典类中的<code class="fe mi mj mk ml b">protected</code>关键字)。因此，如果您可以访问从戳记创建的对象实例，您就不能访问私有数据和方法。但是，您可以使用原始的戳记，向它添加一个方法，并授予自己访问所有私有数据和方法的权限。</p><p id="96da" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">优点:</p><ol class=""><li id="3358" class="na nb jb ka b kb kc kf kg kj nc kn nd kr ne kv nf ng nh ni bi translated">只有stamp的成员可以访问私有数据和方法。</li><li id="76a4" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">所有私有方法都可以访问所有公共方法。</li><li id="f8d4" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">您可以从<strong class="ka jc">其他文件</strong>中添加其他方法(如<code class="fe mi mj mk ml b">verifyBlock()</code>)。(如果这个<code class="fe mi mj mk ml b">BlockchainApi</code>戳由另一个文件的另一个戳组成，那么那里的每个方法都可以访问<code class="fe mi mj mk ml b">request</code>方法。)</li></ol><p id="3745" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">缺点:</p><ol class=""><li id="04d7" class="na nb jb ka b kb kc kf kg kj nc kn nd kr ne kv nf ng nh ni bi translated">内存不友好。为每个方法创建一个小的包装函数。</li><li id="0944" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">所有的财产都变成私有。您需要为公共属性创建一个getter。如<code class="fe mi mj mk ml b">getUrl()</code>。</li></ol><p id="4b2d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">玩邮票玩得开心！</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><ul class=""><li id="54b1" class="na nb jb ka b kb kc kf kg kj nc kn nd kr ne kv nt ng nh ni bi translated">第一集。邮票基础知识</li><li id="fdbe" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nt ng nh ni bi translated"><a class="ae le" href="https://medium.com/p/37be8e9a5714" rel="noopener">第二集。FP中的依赖注入</a></li><li id="e1f6" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nt ng nh ni bi translated"><a class="ae le" href="https://medium.com/p/e387ef041896" rel="noopener">第三集。与ES2015类比较</a></li><li id="ca37" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nt ng nh ni bi translated"><a class="ae le" href="https://medium.com/p/e52f5c17dcfe" rel="noopener">第四集。在30 LOC中自己实现stamps</a></li><li id="7d16" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nt ng nh ni bi translated"><a class="ae le" href="https://medium.com/p/fe55721c571a" rel="noopener">第五集。构图设计模式</a></li><li id="bd2a" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nt ng nh ni bi translated"><a class="ae le" href="https://medium.com/@koresar/fun-with-stamps-episode-6-statics-properties-on-stamps-e2b85825152c" rel="noopener">第六集。静态—邮票上的属性</a></li><li id="5434" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nt ng nh ni bi translated"><a class="ae le" href="https://medium.com/@koresar/fun-with-stamps-episode-7-early-and-late-dependency-injection-caef5c91794a" rel="noopener">第七集。早期和晚期依赖注入</a></li><li id="3290" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nt ng nh ni bi translated">第八集。追踪和覆盖构图</li><li id="69a8" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nt ng nh ni bi translated">第九集。正在分离合成()</li><li id="39d1" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nt ng nh ni bi translated">第十集。我的邮票心理模型</li><li id="7937" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nt ng nh ni bi translated"><a class="ae le" href="https://medium.com/@koresar/fun-with-stamps-episode-11-interfering-composition-7abc44ac1f99" rel="noopener">第十一集。干扰成分</a></li><li id="a2a7" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nt ng nh ni bi translated">第12集。新@戳首页</li><li id="efef" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nt ng nh ni bi translated"><a class="ae le" href="https://medium.com/@koresar/fun-with-stamps-episode-13-method-collision-control-d34ec0c8cc8d" rel="noopener">第十三集。方法冲突控制</a></li><li id="8d71" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nt ng nh ni bi translated"><a class="ae le" href="https://medium.com/@koresar/episode-14-new-stamp-it-as-a-replacement-of-stampit-191ef0f4c53e" rel="noopener">第十四集。新的@stamp/it作为Stampit的替代品</a></li><li id="b99e" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nt ng nh ni bi translated"><a class="ae le" href="https://medium.com/@koresar/fun-with-stamps-episode-15-the-stamp-modules-ecosystem-a296d15be599" rel="noopener">第十五集。@stamp/模块生态系统</a></li><li id="92a7" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nt ng nh ni bi translated">第十六集。打字稿混合类vs邮票</li><li id="cefe" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nt ng nh ni bi translated"><a class="ae le" href="https://medium.com/@koresar/fun-with-stamps-episode-17-easy-100-unit-test-coverage-in-js-d97e09591f18" rel="noopener">第十七集。JS中简单的100%单元测试覆盖率</a></li><li id="2881" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nt ng nh ni bi translated"><a class="ae le" href="https://medium.com/@koresar/fun-with-stamps-episode-18-dependency-injection-paradise-10d4a3e39d45" rel="noopener">第十八集。依赖注入天堂</a></li><li id="1a96" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nt ng nh ni bi translated"><a class="ae le" href="https://medium.com/@koresar/fun-with-stamps-episode-19-java-c-abstract-methods-in-javascript-65b1458e0b93" rel="noopener">第十九集。JavaScript中的Java/C#抽象方法</a></li><li id="83bb" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nt ng nh ni bi translated"><a class="ae le" href="https://medium.com/@koresar/fun-with-stamps-episode-20-stampit-v4-9a043a36a984" rel="noopener">第二十集。Stampit v4 </a></li><li id="ecb5" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nt ng nh ni bi translated"><strong class="ka jc">第21集。JavaScript中的私有数据。4邮票使用方式</strong> <em class="kw">(本文)</em></li><li id="862e" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nt ng nh ni bi translated"><a class="ae le" href="https://medium.com/@koresar/fun-with-stamps-episode-22-javascript-instanceof-as-composable-stamp-3956619b249d" rel="noopener">第22集。作为可组合戳记的JavaScript实例</a></li><li id="451c" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nt ng nh ni bi translated"><a class="ae le" href="https://medium.com/@koresar/fun-with-stamps-episode-23-new-stampit-js-org-with-all-the-docs-38a2f50ec252" rel="noopener">第二十三集。拥有所有文件的新stampit.js.org</a></li><li id="a87e" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nt ng nh ni bi translated"><a class="ae le" href="https://medium.com/@koresar/fun-with-stamps-episode-24-new-name-feature-4be91c27edcb" rel="noopener">第二十四集。新的“名称”功能</a></li></ul></div></div>    
</body>
</html>