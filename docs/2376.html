<html>
<head>
<title>Vue and Vue-Testing-Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue和Vue测试库</h1>
<blockquote>原文：<a href="https://itnext.io/vue-and-vue-testing-library-bb388a977e17?source=collection_archive---------2-----------------------#2019-05-14">https://itnext.io/vue-and-vue-testing-library-bb388a977e17?source=collection_archive---------2-----------------------#2019-05-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e2d5c828ecf47f5e383cdab97b91e12f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FVCG9gMuBuDidTAa7QYCsg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">克里斯蒂安·霍尔辛格在<a class="ae kf" href="https://unsplash.com/search/photos/neusiedlersee?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="711e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我是TDD(测试驱动开发)的超级粉丝，我真的建议每个人都去实践它，或者，至少，用一些形或小练习来尝试一下。</p><p id="db9d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天，有了相关测试库支持的最新UI框架，TDD比以前容易多了，它实际上帮助了很多定义、捕捉和测试可能的组件场景。</p><p id="eba1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在用<em class="le">酶</em>测试<em class="le">反应</em>组件时，我清楚地看到了这些实践的好处(在那些库的真正早期阶段)。如果组件易于测试(和布局场景)，那么您就走在了一条好的道路上。</p><p id="fbb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我的职业生涯中，我经历过许多不同UI技术、方法、过程和实践的单元测试。</p><p id="59d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看看下面的图片，你可能会发现<strong class="ki iu">单元测试</strong>应该是测试策略的基础。为什么？其中一个原因是，它们很快，而且可以被隔离。</p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/6275717b7bf8c4b2b4171a4b08cfc78c.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*9skw8tSuimBoaWrONOlWbg.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">迈克·科恩的概念。图片摘自<a class="ae kf" href="https://martinfowler.com/articles/practical-test-pyramid.html" rel="noopener ugc nofollow" target="_blank">https://Martin fowler . com/articles/practical-test-pyramid . html</a></figcaption></figure><p id="cf5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我想展示一种方法，这种方法可能有助于我们的测试代码更加灵活，更重要的是，<strong class="ki iu">遵循最终用户方法</strong>(而不是<em class="le">开发人员方法</em><em class="le"/>)。</p><p id="5cd9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="le"> Vue </em> </strong>和<strong class="ki iu"><em class="le">Vue/Test-Utils</em></strong>是一个很棒的组合！我真的很喜欢它，用传入的道具、商店等等测试组件真的很容易。我非常推荐这些技术，并查看了这两个资源(第一个是Vue/Test-Utils的官方页面，第二个是Vue的UT-TDD实践/解决方案的集合——太棒了):</p><div class="lk ll gp gr lm ln"><a href="https://vue-test-utils.vuejs.org/" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab fo"><div class="lp ab lq cl cj lr"><h2 class="bd iu gy z fp ls fr fs lt fu fw is bi translated">简介| Vue测试工具</h2><div class="lu l"><h3 class="bd b gy z fp ls fr fs lt fu fw dk translated">测试Vue组件的实用程序</h3></div><div class="lv l"><p class="bd b dl z fp ls fr fs lt fu fw dk translated">vue-test-utils.vuejs.org</p></div></div></div></a></div><div class="lk ll gp gr lm ln"><a href="https://github.com/lmiller1990/vue-testing-handbook" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab fo"><div class="lp ab lq cl cj lr"><h2 class="bd iu gy z fp ls fr fs lt fu fw is bi translated">lmiller 1990/vue-测试手册</h2><div class="lu l"><h3 class="bd b gy z fp ls fr fs lt fu fw dk translated">Vue组件和应用测试指南-lmiller 1990/Vue-测试-手册</h3></div><div class="lv l"><p class="bd b dl z fp ls fr fs lt fu fw dk translated">github.com</p></div></div><div class="lw l"><div class="lx l ly lz ma lw mb jz ln"/></div></div></a></div></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="a5ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这真的很棒，但它可能会与另一个名为“<strong class="ki iu"><em class="le">Vue-testing-library</em></strong>”的库相结合，该库强制执行良好的测试实践和更为<strong class="ki iu"> BDD化的</strong>方法(<em class="le">行为驱动开发</em>)。</p><p id="8e0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一种BDD也可以在单元测试中实现，将TDD测试用例与BDD测试用例分开是一个很好的实践。BDD更关注与功能/组件相关的实际行为，而不是“输入/输出”,我想展示一下在这些情况下“<em class="le"> vue-testing-library </em>”是如何方便的。</p><p id="ba37" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据记录，<em class="le"> Vue-testing-library </em> <em class="le">基于Vue/Test-Utils的top </em>，所以你可以只用Vue/Test-Utils实现类似的东西，但是它需要更多的自律。</p><p id="c055" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以用一个命令安装它:</p><pre class="lg lh li lj gt mj mk ml mm aw mn bi"><span id="52ac" class="mo mp it mk b gy mq mr l ms mt">npm install --save-dev vue-testing-library</span></pre><p id="f46d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，我使用了<strong class="ki iu"> Jest-Dom </strong>，它与<strong class="ki iu"> Jest </strong>结合起来非常有用(它有助于Dom断言和期望)。</p><div class="lk ll gp gr lm ln"><a href="https://www.npmjs.com/package/jest-dom" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab fo"><div class="lp ab lq cl cj lr"><h2 class="bd iu gy z fp ls fr fs lt fu fw is bi translated">笑话世界</h2><div class="lu l"><h3 class="bd b gy z fp ls fr fs lt fu fw dk translated">自定义jest匹配器来测试DOM的状态</h3></div><div class="lv l"><p class="bd b dl z fp ls fr fs lt fu fw dk translated">www.npmjs.com</p></div></div><div class="lw l"><div class="mu l ly lz ma lw mb jz ln"/></div></div></a></div><p id="b8c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个简单的挑战是流行的<em class="le">“计数器”</em>，最终用户可以通过页面上的几个按钮增加或减少一个数字。</p><p id="cce9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，让我们从最终用户的角度关注这一点，并收集需求:</p><ul class=""><li id="aed7" class="mv mw it ki b kj kk kn ko kr mx kv my kz mz ld na nb nc nd bi translated">显示实际数字的文本(我们可能期望开始时是0)；</li><li id="b299" class="mv mw it ki b kj ne kn nf kr ng kv nh kz ni ld na nb nc nd bi translated">一个显示“<em class="le">增加</em>的按钮，它应该增加数字；</li><li id="b929" class="mv mw it ki b kj ne kn nf kr ng kv nh kz ni ld na nb nc nd bi translated">一个显示“<em class="le">减少</em>的按钮，该按钮将减少数字；</li></ul><p id="5684" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们编写我们的第一个测试用例"<em class="le">一个显示实际数字的文本(我们可能期望开始时是0)</em>:</p><pre class="lg lh li lj gt mj mk ml mm aw mn bi"><span id="7db7" class="mo mp it mk b gy mq mr l ms mt">//counter.spec.js</span><span id="7bbb" class="mo mp it mk b gy nj mr l ms mt">import <em class="le">{ </em>render <em class="le">} </em>from 'vue-testing-library';<br/>import Counter from '@/components/Counter.vue'<br/><br/>describe<em class="le">(</em>'<strong class="mk iu">Component: Counter.vue</strong>', <em class="le">() </em>=&gt; <em class="le">{<br/>    </em>describe<em class="le">(</em>'<strong class="mk iu">Behavior</strong>', <em class="le">() </em>=&gt; <em class="le">{<br/>        </em>test<em class="le">(</em>'<strong class="mk iu">User should see 0 at the beginning</strong>', <em class="le">() </em>=&gt; <em class="le">{<br/>            </em>const <em class="le">{ </em>getByText <em class="le">} </em>= render<em class="le">(</em>Counter<em class="le">)</em>;<br/>            const textNumberWrapper = getByText<em class="le">(</em>/Counter is:/<em class="le">)</em>;<br/>            expect<em class="le">(</em>textNumberWrapper<em class="le">)</em>.toHaveTextContent<em class="le">(</em>'Counter is: 0'<em class="le">)</em>;<br/>        <em class="le">})</em>;<br/>    <em class="le">})</em>;<br/><em class="le">})</em>;</span></pre><p id="b385" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">导入的<em class="le"> Render </em>函数将负责独立安装所需的组件，并返回一组特定于包装实例的实用程序。更多信息可在以下链接中找到:</p><div class="lk ll gp gr lm ln"><a href="https://testing-library.com/docs/vue-testing-library/api" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab fo"><div class="lp ab lq cl cj lr"><h2 class="bd iu gy z fp ls fr fs lt fu fw is bi translated">API测试库</h2><div class="lu l"><h3 class="bd b gy z fp ls fr fs lt fu fw dk translated">Vue测试库从DOM测试库中重新导出所有东西。它还公开了这些方法:render函数…</h3></div><div class="lv l"><p class="bd b dl z fp ls fr fs lt fu fw dk translated">testing-library.com</p></div></div><div class="lw l"><div class="nk l ly lz ma lw mb jz ln"/></div></div></a></div><p id="8d04" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">测试用例中的另外两条指令实际上很简单:第一条指令选择包含所需文本的元素，最后一条指令只是检查先前找到的元素包含的文本是否是我们所期望的(“<em class="le">计数器在开始时应该是0</em>”)。</p><p id="7357" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将该测试转化为成功测试的一个简单方法是以下Vue组件实现:</p><pre class="lg lh li lj gt mj mk ml mm aw mn bi"><span id="7552" class="mo mp it mk b gy mq mr l ms mt">// src/components/Counter.vue</span><span id="03e9" class="mo mp it mk b gy nj mr l ms mt"><em class="le">&lt;</em>template<em class="le">&gt;<br/>    &lt;</em>div<em class="le">&gt;<br/>        &lt;</em>div class="counter-text"<em class="le">&gt;<br/>            </em>Counter is: 0<br/>        <em class="le">&lt;/</em>div<em class="le">&gt;<br/>    &lt;/</em>div<em class="le">&gt;<br/>&lt;/</em>template<em class="le">&gt;</em></span></pre><p id="6f51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能会注意到，我们的测试并不搜索特定的标签。这是一个好处，因为它有助于依赖测试优先开发，并留有一定的灵活性。此外，终端用户并不关注HTML标签的本质或层次结构，而只关注显示的内容。</p><p id="5224" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，现在你可以想象增加按钮的测试用例，看起来可能如下:</p><pre class="lg lh li lj gt mj mk ml mm aw mn bi"><span id="09a1" class="mo mp it mk b gy mq mr l ms mt">// counter.spec.js</span><span id="069e" class="mo mp it mk b gy nj mr l ms mt">import <em class="le">{<br/>    </em>render,<br/>    fireEvent<br/><em class="le">} </em>from 'vue-testing-library';<br/>import Counter, <em class="le">{ </em>INITIAL_COUNTER <em class="le">} </em>from '@/components/Counter.vue'<br/><br/>describe<em class="le">(</em>'Component: Counter.vue', <em class="le">() </em>=&gt; <em class="le">{<br/>    </em>describe<em class="le">(</em>'Behavior', <em class="le">() </em>=&gt; <em class="le">{<br/>        ...</em><br/>        test<em class="le">(</em>'<strong class="mk iu">When User clicks on Increase, Counter should be increased by 1 unit</strong>', <strong class="mk iu">async</strong> <em class="le">() </em>=&gt; <em class="le">{<br/>            </em>const <em class="le">{ </em>getByText <em class="le">} </em>= render<em class="le">(</em>Counter<em class="le">)</em>;<br/>            const textNumberWrapper = getByText<em class="le">(</em>/Counter is:/<em class="le">)</em>;<br/>            expect<em class="le">(</em>textNumberWrapper<em class="le">)</em>.toHaveTextContent<em class="le">(</em>`Counter is: $<em class="le">{</em>INITIAL_COUNTER<em class="le">}</em>`<em class="le">)</em>;<br/>            <strong class="mk iu">await</strong> fireEvent.click<em class="le">(</em>getByText<em class="le">(</em>'Increase'<em class="le">))</em>;<br/>            expect<em class="le">(</em>textNumberWrapper<em class="le">)</em>.toHaveTextContent<em class="le">(</em>`Counter is: $<em class="le">{</em>INITIAL_COUNTER + 1<em class="le">}</em>`<em class="le">)</em>;<br/>        <em class="le">})</em>;<br/>    <em class="le">})</em>;<br/><em class="le">})</em>;</span></pre><p id="7364" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，您可以看到这个测试用例正在异步运行，因为fireEvent函数正在返回一个承诺，我们正在等待await关键字的执行。</p><p id="a96f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个测试用例非常简单:</p><ul class=""><li id="3542" class="mv mw it ki b kj kk kn ko kr mx kv my kz mz ld na nb nc nd bi translated">它将组件呈现为隔离状态；</li><li id="0312" class="mv mw it ki b kj ne kn nf kr ng kv nh kz ni ld na nb nc nd bi translated">它检查我们的计数器跟踪器是否显示初始状态；</li><li id="69ed" class="mv mw it ki b kj ne kn nf kr ng kv nh kz ni ld na nb nc nd bi translated">它在任何带有“增加”文本的元素上触发一个点击事件，并等待执行；</li><li id="24c2" class="mv mw it ki b kj ne kn nf kr ng kv nh kz ni ld na nb nc nd bi translated">最后，它检查我们的计数器跟踪器是否更新了一个新的数字(在这种情况下，我们期望多1个单位)。</li></ul><p id="add5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了解决这个测试用例，让我们实现这个组件:</p><pre class="lg lh li lj gt mj mk ml mm aw mn bi"><span id="e4a0" class="mo mp it mk b gy mq mr l ms mt">// src/components/Counter.vue</span><span id="c427" class="mo mp it mk b gy nj mr l ms mt"><em class="le">&lt;</em>template<em class="le">&gt;<br/>    &lt;</em>div<em class="le">&gt;<br/>        &lt;</em>div class="counter-text"<em class="le">&gt;<br/>            </em>Counter is: {{ count }}<br/>        <em class="le">&lt;/</em>div<em class="le">&gt;<br/>        &lt;</em>div class="controls"<em class="le">&gt;<br/>            &lt;</em>button @click="increase"<em class="le">&gt;</em>Increase<em class="le">&lt;/</em>button<em class="le">&gt;<br/>        &lt;/</em>div<em class="le">&gt;<br/>    &lt;/</em>div<em class="le">&gt;<br/>&lt;/</em>template<em class="le">&gt;<br/>&lt;</em>script lang="js"<em class="le">&gt;<br/>    </em>export const INITIAL_COUNTER = 0;<br/><br/>    export default <em class="le">{<br/>        </em>name: 'Counter',<br/>        data <em class="le">() {<br/>            </em>return <em class="le">{<br/>                </em>count: INITIAL_COUNTER<br/>            <em class="le">}</em>;<br/>        <em class="le">}</em>,<br/>        methods: <em class="le">{<br/>            </em>increase<em class="le">() {<br/>                </em>this.count += 1;<br/>            <em class="le">}<br/>        }<br/>    }<br/>&lt;/</em>script<em class="le">&gt;</em></span></pre><p id="ebb8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">酷！！</p><p id="3c71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">减少功能呢？</p><pre class="lg lh li lj gt mj mk ml mm aw mn bi"><span id="d304" class="mo mp it mk b gy mq mr l ms mt">// counter.spec.js</span><span id="9188" class="mo mp it mk b gy nj mr l ms mt">...</span><span id="f006" class="mo mp it mk b gy nj mr l ms mt">describe<em class="le">(</em>'Component: Counter.vue', <em class="le">() </em>=&gt; <em class="le">{<br/>    </em>describe<em class="le">(</em>'Behavior', <em class="le">() </em>=&gt; <em class="le">{<br/>        ...</em><br/>        test<em class="le">(</em>'<strong class="mk iu">When User clicks on Decrease, Counter should be decreased by 1 unit</strong>', async <em class="le">() </em>=&gt; <em class="le">{<br/>            </em>const <em class="le">{ </em>getByText <em class="le">} </em>= render<em class="le">(</em>Counter<em class="le">)</em>;<br/>            const textNumberWrapper = getByText<em class="le">(</em>/Counter is:/<em class="le">)</em>;<br/>            expect<em class="le">(</em>textNumberWrapper<em class="le">)</em>.toHaveTextContent<em class="le">(</em>`Counter is: $<em class="le">{</em>INITIAL_COUNTER<em class="le">}</em>`<em class="le">)</em>;<br/>            await fireEvent.click<em class="le">(</em>getByText<em class="le">(</em>'Decrease'<em class="le">))</em>;<br/>            expect<em class="le">(</em>textNumberWrapper<em class="le">)</em>.toHaveTextContent<em class="le">(</em>`Counter is: $<em class="le">{</em>INITIAL_COUNTER - 1<em class="le">}</em>`<em class="le">)</em>;<br/>        <em class="le">})</em>;<br/>    <em class="le">})</em>;<br/><em class="le">})</em>;</span></pre><p id="891a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并且实现类似于另一个:</p><pre class="lg lh li lj gt mj mk ml mm aw mn bi"><span id="c225" class="mo mp it mk b gy mq mr l ms mt">// src/components/Counter.vue</span><span id="65dd" class="mo mp it mk b gy nj mr l ms mt"><em class="le">&lt;</em>template<em class="le">&gt;<br/>    &lt;</em>div<em class="le">&gt;<br/>        ...<br/>        &lt;</em>div class="controls"<em class="le">&gt;<br/>            ...<br/>            &lt;</em>button @click="decrease"<em class="le">&gt;</em>Decrease<em class="le">&lt;/</em>button<em class="le">&gt;<br/>        &lt;/</em>div<em class="le">&gt;<br/>    &lt;/</em>div<em class="le">&gt;<br/>&lt;/</em>template<em class="le">&gt;<br/>&lt;</em>script lang="js"<em class="le">&gt;<br/>    </em>export const INITIAL_COUNTER = 0;<br/><br/>    export default <em class="le">{<br/>        </em>name: 'Counter',<br/>        data <em class="le">() {<br/>            </em>return <em class="le">{<br/>                </em>count: INITIAL_COUNTER<br/>            <em class="le">}</em>;<br/>        <em class="le">}</em>,<br/>        // define methods under the `methods` object<br/>        methods: <em class="le">{<br/>            </em>increase<em class="le">() {<br/>                </em>this.count += 1;<br/>            <em class="le">}</em>,<br/>            decrease<em class="le">() {<br/>                </em>this.count -= 1;<br/>            <em class="le">}<br/>        }<br/>    }<br/>&lt;/</em>script<em class="le">&gt;</em></span></pre><p id="fc43" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完整的示例如下:</p><figure class="lg lh li lj gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><figure class="lg lh li lj gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a92b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Jest输出如下:</p><blockquote class="nn no np"><p id="1e4e" class="kg kh le ki b kj kk kl km kn ko kp kq nq ks kt ku nr kw kx ky ns la lb lc ld im bi translated">通过测试/单元/计数器. spec.js</p><p id="47d5" class="kg kh le ki b kj kk kl km kn ko kp kq nq ks kt ku nr kw kx ky ns la lb lc ld im bi translated">组件:Counter.vue</p><p id="c331" class="kg kh le ki b kj kk kl km kn ko kp kq nq ks kt ku nr kw kx ky ns la lb lc ld im bi translated">行为</p><p id="3d48" class="kg kh le ki b kj kk kl km kn ko kp kq nq ks kt ku nr kw kx ky ns la lb lc ld im bi translated">用户应该在开头看到0</p><p id="431c" class="kg kh le ki b kj kk kl km kn ko kp kq nq ks kt ku nr kw kx ky ns la lb lc ld im bi translated">当用户点击增加时，计数器应增加1个单位</p><p id="ca3b" class="kg kh le ki b kj kk kl km kn ko kp kq nq ks kt ku nr kw kx ky ns la lb lc ld im bi translated">当用户点击减少时，计数器应减少1个单位</p></blockquote><p id="c17c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在有趣的部分来了。</p><p id="2ad3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您更改标签或层次结构(例如:更改类，span而不是div，或者不同的嵌套HTML标签)，会发生什么？除非我们修改文本，否则没有什么会真正影响我们的测试。太棒了。</p><p id="b5e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以我的拙见，我真的相信这是在我们的单元测试中覆盖用户行为的一个很好的方式，因为这些测试运行得非常快并且是孤立的(并且它们对实现的变化也很灵活)。</p><p id="15b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以在以下链接中找到更多示例:</p><div class="lk ll gp gr lm ln"><a href="https://github.com/testing-library/vue-testing-library/tree/master/tests/__tests__" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab fo"><div class="lp ab lq cl cj lr"><h2 class="bd iu gy z fp ls fr fs lt fu fw is bi translated">测试库/vue测试库</h2><div class="lu l"><h3 class="bd b gy z fp ls fr fs lt fu fw dk translated">轻量级适配器允许使用dom-testing-library测试构建在@vue/test-utils之上的Vue.js组件…</h3></div><div class="lv l"><p class="bd b dl z fp ls fr fs lt fu fw dk translated">github.com</p></div></div><div class="lw l"><div class="nt l ly lz ma lw mb jz ln"/></div></div></a></div><p id="74eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">干杯:)</p></div></div>    
</body>
</html>