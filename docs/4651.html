<html>
<head>
<title>Node.js Script writers: Top-level async/await now available</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js脚本编写器:顶级异步/等待现在可用</h1>
<blockquote>原文：<a href="https://itnext.io/node-js-script-writers-top-level-async-await-now-available-a1e86566d5f6?source=collection_archive---------1-----------------------#2020-08-14">https://itnext.io/node-js-script-writers-top-level-async-await-now-available-a1e86566d5f6?source=collection_archive---------1-----------------------#2020-08-14</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><p id="c23e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">Async/await函数是JavaScript程序员的福音，简化了异步代码的编写。它将难以编写和调试的末日金字塔变成了干净清晰的代码，结果和错误都在自然的地方。除了一点之外，一切都很好，我们不能在Node.js的顶层代码中使用await关键字，但是在Node.js 14.8中，这个问题已经解决了。</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj kp"><img src="../Images/ee493af9fbc34148cc2a13be724f9d95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6QAshcOdmu6h5IyLtPC6ZA.png"/></div></div></figure><p id="ec71" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">编写脚本可能涉及读取或写入文件、检索外部数据、处理该数据并产生结果，该结果可能被写回外部文件或数据库。在Node.js中，这需要异步代码。在脚本中，代码位于JavaScript文件的顶层，这使得我们无法使用<code class="fe lb lc ld le b">await</code>关键字。</p><p id="e709" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">考虑:</p><pre class="kq kr ks kt gu lf le lg lh aw li bi"><span id="4198" class="lj lk iu le b gz ll lm l ln lo">const fs = require('fs').promises;  </span><span id="011a" class="lj lk iu le b gz lp lm l ln lo">const txt = await fs.readFile('test.txt', 'utf-8');<br/>console.log(txt);</span></pre><p id="5a6e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们刚刚描述的脚本可能会对输入文件进行一些处理，然后将输出写到其他地方。但是让我们关注一下读取数据文件的异步行为。</p><p id="1c5e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这是一个传统的CommonJS风格的Node.js程序。程序员对自己说，让我们使用<code class="fe lb lc ld le b">await</code>吧，因为它是一个非常有用的关键字。程序员甚至小心翼翼地使用<code class="fe lb lc ld le b">require('fs').promises</code>来获得承诺的<code class="fe lb lc ld le b">fs</code>包。但是，运行脚本时，他们会看到:</p><pre class="kq kr ks kt gu lf le lg lh aw li bi"><span id="7b68" class="lj lk iu le b gz ll lm l ln lo">$ nvm use 14.7<br/>Now using node v14.7.0 (npm v6.14.7)<br/>$ node m1.js<br/>/Users/David/nodejs/top-level-async-await/m1.js:8<br/>const txt = await fs.readFile('test.txt', 'utf-8');<br/>            ^^^^^</span><span id="4d3e" class="lj lk iu le b gz lp lm l ln lo">SyntaxError: await is only valid in async function<br/>    at wrapSafe (internal/modules/cjs/loader.js:1172:16)<br/>    at Module._compile (internal/modules/cjs/loader.js:1220:27)<br/>    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1277:10)<br/>    at Module.load (internal/modules/cjs/loader.js:1105:32)<br/>    at Function.Module._load (internal/modules/cjs/loader.js:967:14)<br/>    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:60:12)<br/>    at internal/main/run_main_module.js:17:47</span></pre><p id="58ef" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在这篇文章中，我将使用<code class="fe lb lc ld le b">nvm</code>来管理正在使用的Node.js版本。选择14.7版本的重要性将在后面变得清楚。</p><p id="5969" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这就是我们过去几年在Node.js中所经历的。我们可以在标有<code class="fe lb lc ld le b">async</code>关键字的函数中使用<code class="fe lb lc ld le b">await</code>关键字，但是我们不能在顶级代码中使用它。换句话说，该脚本必须写成:</p><pre class="kq kr ks kt gu lf le lg lh aw li bi"><span id="411f" class="lj lk iu le b gz ll lm l ln lo">const fs = require('fs').promises;  <br/>(async () =&gt; {<br/>     const txt = await fs.readFile('test.txt', 'utf-8');<br/>     console.log(txt); <br/>})();</span></pre><p id="98ca" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这将异步的<code class="fe lb lc ld le b">await</code>调用包装在一个轻量级的<code class="fe lb lc ld le b">async</code>函数中，该函数被立即调用。这是一种简单的技术，让我们几乎可以在Node.js脚本的顶层编写异步/等待代码。重要提示:这个简单的脚本缺少一些重要的错误处理。</p><p id="0cf8" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们真正想要的是像这篇文章中的第一个片段那样编写代码。这是我们能得到的最接近的，直到现在。</p><h1 id="cf98" class="lq lk iu bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">Node.js 14.8中的顶级异步/等待</h1><p id="28a8" class="pw-post-body-paragraph jr js iu jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko in bi translated">Node.js 14.8今天发布，包含了一个非常重要的进步。在ES6模块中，我们现在可以在顶级代码中使用<code class="fe lb lc ld le b">await</code>关键字，没有任何标志。</p><p id="2e5a" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这意味着在扩展名为<code class="fe lb lc ld le b">.mjs</code>的文件中，我们可以这样写:</p><pre class="kq kr ks kt gu lf le lg lh aw li bi"><span id="99a2" class="lj lk iu le b gz ll lm l ln lo">import { promises as fs } from 'fs';  </span><span id="fe9a" class="lj lk iu le b gz lp lm l ln lo">const txt = await fs.readFile('test.txt', 'utf-8');<br/>console.log(txt);</span></pre><p id="f339" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这个<code class="fe lb lc ld le b">import</code>语句是我们在ES6模块中访问promised<code class="fe lb lc ld le b">fs</code>模块的方式。否则这和上面的例子是一样的。</p><p id="3b13" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们可以这样运行它:</p><pre class="kq kr ks kt gu lf le lg lh aw li bi"><span id="398d" class="lj lk iu le b gz ll lm l ln lo">$ nvm use 14.8 <br/>Now using node v14.8.0 (npm v6.14.7) <br/>$ node m1.mjs<br/>Hello, world!</span></pre><p id="bd71" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这正如我们所希望的那样，在顶层完美地执行。</p><p id="3f57" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这就是相同示例在Node.js 14.7中的工作方式</p><pre class="kq kr ks kt gu lf le lg lh aw li bi"><span id="2ff6" class="lj lk iu le b gz ll lm l ln lo">$ cat test.txt  <br/>Hello, world!<br/>$ nvm use 14.7<br/>Now using node v14.7.0 (npm v6.14.7) <br/>$ node m1.mjs<br/>file:///Volumes/Extra/nodejs/top-level-async-await/m1.mjs:6 <br/>const txt = await fs.readFile('test.txt', 'utf-8');<br/>            ^^^^^  <br/>SyntaxError: Unexpected reserved word     <br/>    at Loader.moduleStrategy (internal/modules/esm/translators.js:122:18)<br/>    at async link (internal/modules/esm/module_job.js:42:21)</span></pre><p id="7379" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这就是Node.js 14.8变化的意义。我们现在可以在顶级Node.js代码中使用<code class="fe lb lc ld le b">await</code>关键字，给我们自然的异步脚本。我们不再需要面对这个令人不快的错误。</p><p id="b7c0" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在最后一个节点上，这个特性只有在Node.js运行ES6模块时才起作用。如果它正在执行一个CommonJS模块，就像第一个例子:</p><pre class="kq kr ks kt gu lf le lg lh aw li bi"><span id="6608" class="lj lk iu le b gz ll lm l ln lo">$ node --version<br/>v14.8.0 <br/>$ node m1.js<br/>/Volumes/Extra/nodejs/top-level-async-await/m1.js:8 <br/>const txt = await fs.readFile('test.txt', 'utf-8');<br/>            ^^^^^  <br/>SyntaxError: await is only valid in async function<br/>     at wrapSafe (internal/modules/cjs/loader.js:1167:16)<br/>     at Module._compile (internal/modules/cjs/loader.js:1215:27)<br/>     at Object.Module._extensions..js (internal/modules/cjs/loader.js:1272:10)<br/>     at Module.load (internal/modules/cjs/loader.js:1100:32)<br/>     at Function.Module._load (internal/modules/cjs/loader.js:962:14)<br/>     at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)<br/>     at internal/main/run_main_module.js:17:47</span></pre><p id="eac3" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这是顶部显示的同一个CommonJS示例，但这次是用Node.js 14.8执行的。两种情况都是一样的错误。</p><p id="b37b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这很好，我们现在可以在Node.js脚本中使用异步代码了。但是，让我们尝试一个更全面的例子，而不是这种人为的简单事情。</p><h1 id="ac79" class="lq lk iu bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">异步下载和处理Node.js脚本中的图像</strong></h1><p id="26a5" class="pw-post-body-paragraph jr js iu jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko in bi translated"><code class="fe lb lc ld le b">node-fetch</code>包为Node.js带来了<code class="fe lb lc ld le b">fetch</code>功能，这使它成为从某个地方下载文件的一种极好的方式。当然，下载是作为异步调用来处理的。这个<code class="fe lb lc ld le b">sharp</code>包是一个处理图像的优秀工具。让我们一起使用这两者来下载和处理一个图像。</p><p id="aa8b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在Node.js网站上(在<a class="ae ms" href="https://nodejs.org/en/about/resources/" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/en/about/resources/</a>)有标准Node.js徽标的SVG版本。正确使用正确的商标图像很重要。让我们编写一个小脚本来下载SVG，将其大小调整为300像素，使其灰度化，并将其写入JPG。</p><p id="d55b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">首先，在一个带有<code class="fe lb lc ld le b">package.json</code>的目录中:</p><pre class="kq kr ks kt gu lf le lg lh aw li bi"><span id="a0cf" class="lj lk iu le b gz ll lm l ln lo">$ npm install sharp node-fetch --save</span></pre><p id="a610" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这将安装所需的软件包。如果你喜欢纱线，就用那个。</p><p id="2f79" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">然后我们编写一个文件<code class="fe lb lc ld le b">node-logo.mjs</code>，包含:</p><pre class="kq kr ks kt gu lf le lg lh aw li bi"><span id="b88d" class="lj lk iu le b gz ll lm l ln lo">import { default as fetch } from 'node-fetch'; <br/>import { default as sharp } from 'sharp'; <br/>import { default as fs } from 'fs';  </span><span id="a12c" class="lj lk iu le b gz lp lm l ln lo">(await fetch('https://nodejs.org/static/images/logos/nodejs-new-pantone-black.svg'))<br/>         .body.pipe(<br/>             sharp().resize(300).grayscale()<br/>                 .toFormat('jpeg')<br/>         )<br/>         .pipe(fs.createWriteStream('node-logo.jpg'));</span></pre><p id="3991" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><code class="fe lb lc ld le b">fetch</code>函数返回一个承诺，我们使用<code class="fe lb lc ld le b">await</code>来处理它的成功或失败。我不明白为什么<code class="fe lb lc ld le b">node-fetch</code>文档告诉我们使用<code class="fe lb lc ld le b">.then</code>处理程序，而我们可以直接使用<code class="fe lb lc ld le b">await</code>。通过这种方式，它产生一个可以通过管道传输到某个地方的ReadStream。</p><p id="2255" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在管道的中间部分，我们有一个用Sharp实现的图像处理器。我们只是告诉它调整图像大小，使其灰度，然后转换为JPG格式。</p><p id="e8ad" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">管道的最后一部分使用WriteStream将数据发送到命名文件。</p><p id="750c" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在Node.js 14.7中，我们不得不将它写在一个异步函数中，如前面所示。在Node.js 14.8中，它只是像这样运行:</p><pre class="kq kr ks kt gu lf le lg lh aw li bi"><span id="c2cc" class="lj lk iu le b gz ll lm l ln lo">$ node node-logo.mjs</span></pre><p id="e422" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">它产生了这个:</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div class="gi gj mt"><img src="../Images/a9af298e40f0e9cc99e4d794b27cce77.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*50xiHKnALSq8QEKL.jpg"/></div></figure><h1 id="974f" class="lq lk iu bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">摘要</h1><p id="3543" class="pw-post-body-paragraph jr js iu jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko in bi translated">这一进步将为在Node.js中编写简单的脚本提供新的便利。我们可能希望使用Node.js完成无数不同的一次性任务。例如，就在几天前，我正在探索与我的静态网站生成器(AkashaCMS)一起使用的确切的图像下载/调整大小/etc管道。我上周写的例子必须使用异步包装函数，但是今天不再需要了。</p><p id="0376" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这应该消除了Node.js采用的一个障碍。我们可以继续使用Node.js，而不必求助于Python或其他语言来编写这样的简单脚本。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><p id="6439" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><em class="nb">最初发表于</em><a class="ae ms" href="https://techsparx.com/nodejs/async/top-level-async.html" rel="noopener ugc nofollow" target="_blank"><em class="nb">【https://techsparx.com】</em></a><em class="nb">。</em></p></div></div>    
</body>
</html>