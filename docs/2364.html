<html>
<head>
<title>Dockerizing .NET core app: A case study on the AllReady app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">归档。NET core app:all ready app的案例研究</h1>
<blockquote>原文：<a href="https://itnext.io/dockerizing-net-core-app-a-case-study-on-the-allready-app-4d4a3b01a12a?source=collection_archive---------1-----------------------#2019-05-12">https://itnext.io/dockerizing-net-core-app-a-case-study-on-the-allready-app-4d4a3b01a12a?source=collection_archive---------1-----------------------#2019-05-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/642b4b51263eed7f29c8a0a4349bf4f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*dT4RloWll24_jSCn9jBZTg.png"/></div></figure><div class=""/><p id="c6a3" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">使用<a class="ae kv" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> docker </a>和<a class="ae kv" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> compose </a>为<a class="ae kv" href="https://dotnet.microsoft.com/" rel="noopener ugc nofollow" target="_blank">创建一个端到端的环境。NET Core</a>+<a class="ae kv" href="https://www.microsoft.com/en-us/sql-server/sql-server-2017" rel="noopener ugc nofollow" target="_blank">SQL server</a>+<a class="ae kv" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">Typescript</a>app。</p></div><div class="ab cl kw kx hx ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="im in io ip iq"><p id="bad9" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这篇文章比平常要长一点，因为它从初学者的角度非常详细地介绍了<strong class="jz jb">创建dockerfile </strong>脚本和<strong class="jz jb"> docker-compose </strong>文件。对于高级docker用户来说，这可能太详细了。它旨在观察实际情况。NET核心服务器渲染的(主要)应用程序，并满足其特定的依赖性。最终的目标是通过这样做来传达我所学到的东西，并在行动中表现出来。</p></div><div class="ab cl kw kx hx ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="im in io ip iq"><p id="efac" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我一直在努力为<a class="ae kv" href="https://github.com/HTBox/allReady" rel="noopener ugc nofollow" target="_blank">做贡献。这是一个开源的准备运动应用——一个好的理由。如果你想用代码或其他方式做出贡献，请去阅读它。</a></p><p id="06f6" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我印象深刻的一件事是，让一个新开发人员能够快速建立一个开发环境，查看应用程序，并了解它是如何组织的。将所需的环境归档似乎是一个好主意(似乎我不是唯一一个有这种想法的人)。我真的很喜欢学习Docker，所以…</p><p id="d259" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们从我所说的'<em class="lh">dockering</em>'开始:有一个声明性的<strong class="jz jb"> docker </strong>文件和<strong class="jz jb"> docker-compose </strong>文件，当运行(<code class="fe ld le lf lg b">docker-compose up</code>)时，会导致应用程序从源代码中获得<strong class="jz jb">构建的</strong>和在本地docker实例上部署的<strong class="jz jb"/>(可能不仅仅是——实际上是docker可用的任何机器):</p><p id="c619" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">本练习的最终目标<strong class="jz jb"> </strong>是能够按照以下步骤运行应用程序:</p><ol class=""><li id="7c0f" class="li lj ja jz b ka kb ke kf ki lk km ll kq lm ku ln lo lp lq bi translated">安装Docker</li><li id="fc86" class="li lj ja jz b ka lr ke ls ki lt km lu kq lv ku ln lo lp lq bi translated"><code class="fe ld le lf lg b">git clone</code><a class="ae kv" href="https://github.com/HTBox/allReady" rel="noopener ugc nofollow" target="_blank">回购</a></li><li id="6f68" class="li lj ja jz b ka lr ke ls ki lt km lu kq lv ku ln lo lp lq bi translated"><code class="fe ld le lf lg b">docker-compose up</code>准备好应用程序</li></ol><p id="5069" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz jb">准备</strong>的步骤是:</p><ol class=""><li id="960d" class="li lj ja jz b ka kb ke kf ki lk km ll kq lm ku ln lo lp lq bi translated">研究应用程序有哪些组件。</li><li id="9221" class="li lj ja jz b ka lr ke ls ki lt km lu kq lv ku ln lo lp lq bi translated">研究它们是如何被部署的。</li><li id="ea01" class="li lj ja jz b ka lr ke ls ki lt km lu kq lv ku ln lo lp lq bi translated">构建或使用现有映像来模拟组件和部署。</li></ol><p id="0530" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">研究部分产生了以下应用组件:</p><ul class=""><li id="e0c1" class="li lj ja jz b ka kb ke kf ki lk km ll kq lm ku lw lo lp lq bi translated">应用程序数据的SQL server实例。它有一个名为<code class="fe ld le lf lg b">AllReady</code>的数据库。</li><li id="6907" class="li lj ja jz b ka lr ke ls ki lt km lu kq lv ku lw lo lp lq bi translated">。NET核心应用程序，通过实体框架核心与SQL对话。它还使用实体框架迁移来更新(迁移)数据库。</li><li id="a601" class="li lj ja jz b ka lr ke ls ki lt km lu kq lv ku lw lo lp lq bi translated">前端是一个带有Typescript元素的ASP.NET核心MVC应用程序。后者通过<code class="fe ld le lf lg b">gulp</code>脚本进行构建。</li></ul><p id="dca5" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="lh">许多信息来自描述构建和运行过程的</em> <code class="fe ld le lf lg b"><em class="lh">appveyor.yml</em></code> <em class="lh">文件。另外</em> <code class="fe ld le lf lg b"><em class="lh">gulpfile.js</em></code> <em class="lh">详细描述了前端资源编译的步骤。当然，</em> <code class="fe ld le lf lg b"><em class="lh">startup.cs</em></code> <em class="lh">和</em> <code class="fe ld le lf lg b"><em class="lh">appsettings.json</em></code> <em class="lh">告诉了我需要知道的事情。NET app。</em></p><p id="8279" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">接下来是有趣的部分——模仿容器中的环境。</p><h2 id="cd8b" class="lx ly ja bd lz ma mb dn mc md me dp mf ki mg mh mi km mj mk ml kq mm mn mo mp bi translated">首先是数据库</h2><p id="c853" class="pw-post-body-paragraph jx jy ja jz b ka mq kc kd ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku im bi translated">我知道微软官方支持SQL server <a class="ae kv" href="https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-2017&amp;pivots=cs1-bash" rel="noopener ugc nofollow" target="_blank">镜像。从那篇文章中，我对如何在我的本地Docker实例上部署一个实例有了很好的了解。我还意识到该映像附带了允许SQL查询和命令的<code class="fe ld le lf lg b">sqlcmd</code>命令行实用程序。完美——因为我需要某种创建数据库的方法。所以我的计划是启动</a><a class="ae kv" href="https://hub.docker.com/_/microsoft-mssql-server" rel="noopener ugc nofollow" target="_blank"> SQL server映像</a>的<strong class="jz jb">一个容器实例</strong>来实际充当数据库服务器，启动同一个映像的<strong class="jz jb">另一个容器实例</strong>来用于其<code class="fe ld le lf lg b">sqlcmd</code>实用程序，而不是在其中启动SQL。</p><p id="7d75" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">主实例:</p><pre class="mv mw mx my gt mz lg na nb aw nc bi"><span id="b745" class="lx ly ja lg b gy nd ne l nf ng">docker run -e ACCEPT_EULA=Y -e SA_PASSWORD=sa12345! -p 1433:1433 --name sql1 --network sql -d mcr.microsoft.com/mssql/server:2017-latest</span></pre><p id="4e37" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">指示呈现容器的环境变量<code class="fe ld le lf lg b">-e ACCEPT_EULA=Y -e SA_PASSWORD=sa12345!</code>需要接受最终用户协议并设置系统管理员帐户，<code class="fe ld le lf lg b">— network sql</code>告诉docker为该容器创建一个网络(或加入，如果存在的话，<code class="fe ld le lf lg b">-d</code>表示在后台运行，然后是映像的名称<code class="fe ld le lf lg b">mcr.microsoft.com/mssql/server:2017-latest</code>。这需要几分钟下载，然后几秒钟旋转起来。</p><p id="ae5d" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">完成后，是第二个实例的时候了:<br/> <code class="fe ld le lf lg b">docker run --rm -it --network sql mcr.microsoft.com/mssql/server:2017-latest bash</code>其中<code class="fe ld le lf lg b">--rm</code>表示—在容器退出后移除它(而不是保留它以便重新启动和重用)，<code class="fe ld le lf lg b">-it</code>表示给我容器的输入输出—即在容器“内部”获得一个控制台，允许命令，<code class="fe ld le lf lg b">— network sql</code>使两个容器处于相同的网络中，最后—容器的名称<code class="fe ld le lf lg b">mcr.microsoft.com/mssql/server:2017-latest</code>和最后【T5)—当它启动时在容器中运行什么。我不想启动数据库服务器—这是默认设置。然后在容器中我们可以运行<code class="fe ld le lf lg b">/opt/mssql-tools/bin/sqlcmd -S sql1,1433 -U sa -P sa12345!</code>和<code class="fe ld le lf lg b">create database AllReady</code>和<code class="fe ld le lf lg b">go</code>和<code class="fe ld le lf lg b">select name from sys.databases</code>和<code class="fe ld le lf lg b">go</code>:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nh"><img src="../Images/ce8d80da2886fc2c84737c22c033bacc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YlN4SCNzwehW-4Pe0p-FPg.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">我保留了原始抄本(有错别字)。我注意到了有趣的部分run命令、到sql1:1433上的服务器的连接，然后创建数据库并查询以查看它是否真的在那里</figcaption></figure><p id="2f68" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">就是这样，我们在一个容器中有一个正在运行的SQL server实例，容器中有应用程序期望找到的数据库。这是足够的数据库了。</p><h2 id="3ad3" class="lx ly ja bd lz ma mb dn mc md me dp mf ki mg mh mi km mj mk ml kq mm mn mo mp bi translated">接下来——应用程序本身</h2><p id="b699" class="pw-post-body-paragraph jx jy ja jz b ka mq kc kd ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku im bi translated">如前所述，这是一个. NET核心应用程序，它也需要节点。从<code class="fe ld le lf lg b">npm</code>得到几个包，从<code class="fe ld le lf lg b">nuget</code>得到几个包。构建<code class="fe ld le lf lg b">dotnet</code>应用程序，使用<code class="fe ld le lf lg b">gulp</code>任务传输文件类型脚本并准备资源，最后运行数据库迁移并启动服务器应用程序，服务器应用程序进而向用户提供内容。</p><p id="6994" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们将从描述我们想要构建的图像的<code class="fe ld le lf lg b">dockerfile</code>开始，然后详细讨论文件的每个部分。也就是说，当我们运行<code class="fe ld le lf lg b">docker build .</code>时，它将获取当前文件夹和docker文件，并逐个执行指令。每个<strong class="jz jb">指令</strong>都会在<strong class="jz jb">之前的</strong>图像上产生一个<strong class="jz jb">层</strong>，这样我们就得到一个新的图像。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nq"><img src="../Images/466710213f3702d31761226efe286058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6HeouEtifHjGvm7zbs4BbA.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">从一个基础图像开始，我们添加一层，然后得到下一个图像，再下一个，等等。一层一层地，直到我们得到我们需要的。</figcaption></figure><p id="a772" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">下面是最终的<code class="fe ld le lf lg b">dockerfile</code>和<strong class="jz jb">细节</strong>:</p><figure class="mv mw mx my gt iv"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="6c95" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">脚本的分步描述:</p><p id="a502" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">微软发布了一张的<a class="ae kv" href="https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/net-core-net-framework-containers/official-net-docker-images" rel="noopener ugc nofollow" target="_blank">图片。NET Core 2.2安装完毕，随时可用。(如果你想知道香肠是如何制作的，这是原始文档)。下面是我们如何指示Docker从该图像开始，即提取图像*并将其用作运行<code class="fe ld le lf lg b">dockerfile</code>后将构建的图像的基础。</a></p><p id="96fb" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">* <em class="lh">仅当它不在本地缓存中时才拉取，否则使用缓存的。它的行为很像NPM——在本地提取和缓存包。</em></p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nt"><img src="../Images/ae6d2b36a5e061d9e4543509b0447835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C_NnPvRQoO4P0tTi0V33ew.png"/></div></div></figure><p id="90c0" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">app还需要<code class="fe ld le lf lg b">node/npm</code>和<code class="fe ld le lf lg b">gulp</code>。接下来的几行从<a class="ae kv" href="https://deb.nodesource.com" rel="noopener ugc nofollow" target="_blank">https://deb.nodesource.com</a>那里获得<code class="fe ld le lf lg b">bash</code>脚本，并在bash中运行它(通过管道传递给bash ),它准备好了包的源代码。下一行实际上安装了<code class="fe ld le lf lg b">nodejs</code> (Linux)包。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nu"><img src="../Images/86061757d1a567916a22fbdcccc04482.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-2b6kT8SNsjx_DkImcChw.png"/></div></div></figure><p id="fc84" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">之后，使用现在可用的<code class="fe ld le lf lg b">npm</code>作为全球可用的命令行实用程序来安装<code class="fe ld le lf lg b">gulp</code>:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nv"><img src="../Images/b2031565080434e0754c3ee624be43bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mKxmy_ExTmReAADUlpH8vA.png"/></div></div></figure><p id="e26c" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后创建一个文件夹，并使其成为当前工作文件夹:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nv"><img src="../Images/15617740cf0d2577f3afc6063e8eeed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AVsjfoY14zvJGa95jYoRGw.png"/></div></div></figure><p id="3ece" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">之后,<code class="fe ld le lf lg b">package.json</code>从我们的构建上下文中复制过来(稍后会有更多介绍)。然后我们运行<code class="fe ld le lf lg b">npm install</code>，它将获得<code class="fe ld le lf lg b">package.json</code>的依赖项部分中列出的所有包。我们需要专门复制仅<code class="fe ld le lf lg b">package.json</code>文件，因为Docker缓存层，Docker文件的每一行代表一层。实际上——当<code class="fe ld le lf lg b">package.json</code>没有改变时,<code class="fe ld le lf lg b">npm install</code>步骤不会重复——所以我们的<code class="fe ld le lf lg b">node_modules</code>将被缓存。如果我们复制整个<code class="fe ld le lf lg b">src</code>文件夹，然后运行<code class="fe ld le lf lg b">npm install</code>，docker将看到<code class="fe ld le lf lg b">src</code>文件夹中的一些文件被更改，这将使缓存层无效并重新触发<code class="fe ld le lf lg b">npm install</code>。这并不理想。<code class="fe ld le lf lg b">npm install</code>只依赖于<code class="fe ld le lf lg b">package.json</code>所以这就是我们复制过来的。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nu"><img src="../Images/2f26b03ead565c74a7dfb1ebbc5d03ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bwAowe7udjsWRINLxqUxUw.png"/></div></div></figure><p id="d7ad" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">接下来，我们对<code class="fe ld le lf lg b">.csproj</code>文件进行类似的复制，并恢复它们的依赖关系。<code class="fe ld le lf lg b">AllReady.Core</code>是<code class="fe ld le lf lg b">AllReady</code> web项目的依赖项，所以先获取它。再次，对<code class="fe ld le lf lg b">.csproj</code>文件的任何更改将触发层失效，并将再次调用<code class="fe ld le lf lg b">dotnet restore</code>。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nv"><img src="../Images/9da3e409a209fe03f672e36a0ded24b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fFjNWFcWr9Wb3tuHOTpzhg.png"/></div></div></figure><p id="8bec" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后我们复制源代码的其余部分，创建一个输出文件夹<code class="fe ld le lf lg b">publish</code>并构建应用程序。使用<code class="fe ld le lf lg b">--no-restore</code>，因为我们已经安装了所有的依赖项。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nv"><img src="../Images/32e5fa669c56a193f9f8ec50896804b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u_-RRacLPrFv6w3laFpQEw.png"/></div></div></figure><p id="3842" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后，我们运行<code class="fe ld le lf lg b">gulp</code>任务，并将其输出复制到<code class="fe ld le lf lg b">/published</code>中的build(又名published)应用程序旁边。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nu"><img src="../Images/8ed57d0c7ad380426569f276bf10bc56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y1qvmnKhLKMlV2cpaHod-Q.png"/></div></div></figure><p id="09c8" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最后，我们可以开始迁移，完成后，运行应用程序。我们将这两个步骤作为一个<code class="fe ld le lf lg b">CMD</code>来完成，这样当来自这个<code class="fe ld le lf lg b">dockerfile</code>的构建映像的容器实例运行时就会发生这种情况。也就是说，在构建映像时不运行<code class="fe ld le lf lg b">CMD</code>,而是在创建并运行它的实例时运行。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nw"><img src="../Images/76ca3d836049112b9a09ffdb819421be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lMBDqKEFCpraA3Z-iTNpRw.png"/></div></div></figure><p id="b416" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对于最后一个，有一点细节:如前所述<strong class="jz jb"> dockerfile </strong>是一系列的<strong class="jz jb">指令</strong>，当它们被执行时会创建一个<strong class="jz jb">图像</strong>。它包含一些文件，并准备好被推送到<code class="fe ld le lf lg b">hub.docker.com</code> <strong class="jz jb"> </strong>或docker图像的另一个存储库，或者只是您机器上的本地存储库<strong class="jz jb"> </strong>。从那里可以运行<strong class="jz jb">映像</strong>，或者我喜欢称之为<strong class="jz jb">实例化</strong> *。这个实例就是我们所说的<strong class="jz jb">容器。</strong>从镜像中获取文件的<strong class="jz jb">副本</strong>，并运行<code class="fe ld le lf lg b">CMD</code>(或<code class="fe ld le lf lg b">ENTRYPOINT</code>)中指定的命令。容器保持<strong class="jz jb">活动</strong>，直到该命令<strong class="jz jb">结束</strong>。例如，如果服务器启动，容器将在服务器进程运行时运行。例如，如果执行一个短期命令，<code class="fe ld le lf lg b">ls</code>容器将在<code class="fe ld le lf lg b">ls</code>打印出文件夹内容后立即停止。</p><p id="ebf5" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="lh">* *与. NET类非常相似的是</em> <strong class="jz jb"> <em class="lh">实例化</em> </strong> <em class="lh">，我们得到的实例是实际的运行时单元。容器是运行的图像。容器就是实例。它可以有自己的状态并操纵它，但映像保持不变，其他容器副本可以从中派生出来并相互独立。假设你有一个</em> <code class="fe ld le lf lg b"><em class="lh">class Cat</em></code> <em class="lh">和两个实例。</em> <code class="fe ld le lf lg b"><em class="lh">var cat1 = new Cat(’puff’); var car2 = new Cat(’fluff’);</em></code> <em class="lh">实例共享蓝图，但它们的状态是它们自己操纵的。</em></p><p id="5e45" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">从所有这些，我们现在有一个docker文件，我们可以建立一个图像:</p><pre class="mv mw mx my gt mz lg na nb aw nc bi"><span id="42a0" class="lx ly ja lg b gy nd ne l nf ng">docker build --tag allready .</span></pre><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nx"><img src="../Images/1b26d8d7c1629e049f7e15caae12707d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HbtYOExfrUH-s0pwsDUkNg.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">这是构建输出的一部分。请注意“—--&gt;在721e47669ec3中运行”，然后是“移除中间容器721e47669ec3”，最后是“dad6c85f65da”。这就是从上一步的图像结果中旋转出一个容器，在容器中执行一个命令，然后从运行的容器中创建一个图像。图像(ex dad6c85f65da)全部可用并可访问。例如，尝试“docker run -it dad6c85f65da bash ”(用您自己构建的哈希替换该哈希),您将能够浏览图像。</figcaption></figure><p id="2bcb" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这将<strong class="jz jb">的结果</strong>在图像<strong class="jz jb">中标记为</strong> <code class="fe ld le lf lg b">allready:latest</code>以便于访问。让我们来谈谈背景。注意到命令的<strong class="jz jb">端</strong>上的<strong class="jz jb">点</strong>了吗？这就是我们如何在<strong class="jz jb">上下文</strong>中传递，即我们希望<strong class="jz jb">允许</strong> docker在构建图像时<strong class="jz jb">看到的文件夹。它是我们用来<code class="fe ld le lf lg b">COPY</code>的。所以如果我们在文件夹<code class="fe ld le lf lg b">myfolder</code>中，用它作为上下文。<code class="fe ld le lf lg b">COPY .\package.json .</code>指令将在<code class="fe ld le lf lg b">\myfolder\package.json</code>中寻找<code class="fe ld le lf lg b">package.json</code>，如果没有找到则出错。请注意，如果我们尝试<code class="fe ld le lf lg b">COPY ..\..\package.json</code>，我们将得到一个错误，因为这是<strong class="jz jb">在我们允许docker看到的<strong class="jz jb">上下文</strong>的</strong>之外。</strong></p><p id="2fba" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">回到主线，我们继续。然后，我们可以根据刚刚构建的映像旋转一个容器:</p><pre class="mv mw mx my gt mz lg na nb aw nc bi"><span id="9b86" class="lx ly ja lg b gy nd ne l nf ng">docker run -it allready</span></pre><p id="9e0b" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe ld le lf lg b">-it</code>告诉Docker在运行的容器中获取一个shell。我们将在那里看到一些<strong class="jz jb">错误</strong>，这是由于应用程序试图<strong class="jz jb">获取<strong class="jz jb">数据库</strong>的</strong>和<strong class="jz jb">失败</strong>造成的。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi ny"><img src="../Images/37e18b58f13b7ec6aa0f05dddf148a8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W6YopDA2UJvAALCp0DAqbg.png"/></div></div></figure><p id="95e5" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果我们看一下配置文件<code class="fe ld le lf lg b">appsettings.json </code>，我们可以看到默认连接:</p><figure class="mv mw mx my gt iv"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d93d" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><a class="ae kv" href="https://medium.com/@gparlakov/the-confusion-of-asp-net-configuration-with-environment-variables-c06c545ef732" rel="noopener">我们知道</a>我们可以用特殊的语法通过环境变量将配置传递给<code class="fe ld le lf lg b">dotnet core</code>，所以<code class="fe ld le lf lg b">Data.DefaultConnection.ConnectionString</code>变成了<code class="fe ld le lf lg b">Data__DefaultConnection__ConnectionString</code></p><p id="2409" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">所以我们现在可以做以下事情(假设我们已经构建了上面标记为<strong class="jz jb">的图像):</strong></p><ol class=""><li id="a396" class="li lj ja jz b ka kb ke kf ki lk km ll kq lm ku ln lo lp lq bi translated">创建共享的<strong class="jz jb">网络</strong></li><li id="6da9" class="li lj ja jz b ka lr ke ls ki lt km lu kq lv ku ln lo lp lq bi translated">打开<strong class="jz jb">端口</strong>和<strong class="jz jb">网络</strong>运行<strong class="jz jb"> DB镜像</strong></li><li id="4a91" class="li lj ja jz b ka lr ke ls ki lt km lu kq lv ku ln lo lp lq bi translated">使用<strong class="jz jb">相同的网络</strong>但不同的命令再次运行DB镜像——即<strong class="jz jb">创建</strong>数据库<strong class="jz jb">数据库</strong></li><li id="7925" class="li lj ja jz b ka lr ke ls ki lt km lu kq lv ku ln lo lp lq bi translated">在同一个<strong class="jz jb">网络</strong>中运行<strong class="jz jb"> app </strong>，传入连接数据库服务器和实例所需的<strong class="jz jb">环境变量</strong>。它通过主机上的8080暴露端口80。所以localhost:8080应该会显示<strong class="jz jb"> app </strong>！</li></ol><h2 id="42d5" class="lx ly ja bd lz ma mb dn mc md me dp mf ki mg mh mi km mj mk ml kq mm mn mo mp bi translated">创作这一切</h2><p id="1b8b" class="pw-post-body-paragraph jx jy ja jz b ka mq kc kd ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku im bi translated">哇，<strong class="jz jb"> </strong>工作量真大。至此，我们可以收工了。但是我想更进一步。<br/>对于重复构建和部署，我们可以在命令行上手动一个接一个地执行上述步骤。或者是要复制粘贴的备忘单文本文件。或者批处理/bash脚本。<br/>或<br/>我们可以使用一个<code class="fe ld le lf lg b"><a class="ae kv" href="https://docs.docker.com/compose/compose-file/" rel="noopener ugc nofollow" target="_blank"><strong class="jz jb">docker-compose</strong></a></code> <strong class="jz jb"> </strong>文件:</p><figure class="mv mw mx my gt iv"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1aa8" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">它声明了我们在前面的<strong class="jz jb">步骤</strong>中手动输入的所有内容以及更多内容。本质上，我们创建了一个我们的基础设施的声明，可以很容易地在本地重用或在其他地方重用。</p><p id="7657" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在其中，我们声明了三个<strong class="jz jb">服务</strong>——<code class="fe ld le lf lg b">sql_db</code>(从第4行开始)、<code class="fe ld le lf lg b">sql_database_creator</code>(从第16行开始)和<code class="fe ld le lf lg b">app</code>(从第23行开始):</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nz"><img src="../Images/edfdbdf379a3d84da879033aba4b6288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pyite8qHHqSuyqUMfPy6LA.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">这只是服务声明的顶层。他们中的每一个人都可以并且确实宣布了细节。</figcaption></figure><p id="2a43" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">他们每个人都可以使用现有的图像:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi oa"><img src="../Images/77db3813f721acf8d5fc5297ab018b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fOq3wrLKIHJAaLuoOU53vg.png"/></div></div></figure><p id="0340" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">或者及时建立一个:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi oa"><img src="../Images/cf1387c70d1cde28c0559e3926a09bd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hbCF3AzvJOCFPLiNjw4fMg.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">基本上与“docker build-tag app”相同</figcaption></figure><p id="1bcf" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们可以在容器内部设置环境变量:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi oa"><img src="../Images/8a027d2181ffe0944dd1c3c5703f386a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*krYOMvk2trPXi9lqXbF7ug.png"/></div></div></figure><p id="96e2" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们可以创建一个<code class="fe ld le lf lg b">volume</code>来将SQL server数据库文件保存在我们机器上的永久文件系统中docker主机:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi oa"><img src="../Images/e997789518a48639c5f64cb0eae4d45b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ybi1mxmwRGQ_DEOEnvgaTQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">看起来有点空，但就是这样。就像{volume: {database: {}}一样。</figcaption></figure><p id="ee7c" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后将该卷(实际上是一个文件夹)传递给文件夹【where SQL Server将数据库文件存储在运行的数据库容器中:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi oa"><img src="../Images/134408095dfa723f45760af981983380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FfcxZlNaHvokut9SQhoukA.png"/></div></div></figure><p id="752a" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">创建<code class="fe ld le lf lg b"><strong class="jz jb">network</strong></code>:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi oa"><img src="../Images/861c63baeffc214f20b8060e75fbd72c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i-AUFKxWTOdusr7yC49ulQ.png"/></div></div></figure><p id="2fbd" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让所有的容器都成为它的一部分:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi oa"><img src="../Images/0131b023cf38fad8d24f8093e871ab2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*00-RmRZ2YLbMPuSeM0eEfA.png"/></div></div></figure><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi oa"><img src="../Images/aa0edaf3fc3345230ef55528608e2d55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cUdKfA8CjObufeqJc2hQyw.png"/></div></div></figure><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi oa"><img src="../Images/a707750f5f102b5f05d0687c9824cb82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jZl0C52yBX7r0hSP_R9UdA.png"/></div></div></figure><p id="2f5f" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">声明<code class="fe ld le lf lg b">app</code> <strong class="jz jb">依赖于</strong>其他两个服务——因此只有当其他两个<strong class="jz jb">成功启动</strong>时,<code class="fe ld le lf lg b">app</code>容器才会启动:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi oa"><img src="../Images/e3d56daba9047c7bff27289e66590bda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*osSwbCClL2RqkmvY2Nl5Zw.png"/></div></div></figure><p id="8adf" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">也为<code class="fe ld le lf lg b">sql_database_creator</code>:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi oa"><img src="../Images/afbbac9a91fd143b42c77c30fc418e78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*naxLgZOh2wFFu1_aNlZ3DA.png"/></div></div></figure><p id="0ad8" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注意<strong class="jz jb">开始</strong>不等于<a class="ae kv" href="https://docs.docker.com/compose/startup-order/" rel="noopener ugc nofollow" target="_blank"> <strong class="jz jb">不等于</strong> <strong class="jz jb">准备好</strong> </a>。在尝试创建数据库之前，我们等待一段时间以确保SQL server正在运行:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi ob"><img src="../Images/7c58931735ec19311c0e08fa3fc1da3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oLlJ82_8hVIuxCfwXpo5NA.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">“命令”将在容器<strong class="bd lz">中执行，而不是在预定义的CMD/ENTRYPOINT的</strong>中执行</figcaption></figure><p id="8f3f" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当然，还要定义端口绑定，即我们将本地主机的哪个端口连接到容器内的哪个端口。即localhost:8080连接到容器中的端口:80。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi oc"><img src="../Images/70743b269448f349d64b273757f8d856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zE0SvfeccepUtxf7MiEq7Q.png"/></div></div></figure><p id="405f" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">声明如果应用程序失败，它应该重新启动(因为它可能会尝试在尚未启动的数据库上运行迁移)</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi oc"><img src="../Images/776ed1dbacbd0fa4b3e52491730dd6e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TCeQkQu2GESKieRdl2T_nA.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">实际上，从上面的要点来看，行数是30。不知道那里发生了什么。</figcaption></figure><p id="c472" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，有了<code class="fe ld le lf lg b">docker-compose.yml</code>,我们可以在命令行上运行<code class="fe ld le lf lg b">docker-compose up</code>,我们的应用程序就启动并运行了。这个单一命令将<strong class="jz jb">拉出</strong>所有需要的容器，<strong class="jz jb">构建</strong>需要构建的容器，创建<strong class="jz jb">卷</strong>和<strong class="jz jb">网络</strong>需要的容器，<strong class="jz jb">启动</strong>容器，然后<strong class="jz jb">监控</strong>容器，如果其中一个容器失败，则采取规定的行动(如重启“应用”服务)。我们可能想在编辑源代码时做<code class="fe ld le lf lg b">docker-compose up --build</code>，以迫使Docker每次都重建我们的映像，否则，它会使用最新的映像。<br/>哪里来的<code class="fe ld le lf lg b">docker-compose</code>从来的<strong class="jz jb">？它安装了Docker桌面版，这里有更多细节<a class="ae kv" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank">其他场景</a>。</strong></p></div><div class="ab cl kw kx hx ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="im in io ip iq"><p id="e10a" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了<strong class="jz jb">重述</strong>，我们<strong class="jz jb">从一个应用程序开始</strong>，这个应用程序<strong class="jz jb">要求</strong>开发者(以及运营和任何需要运行或开发应用程序的人)在他们的<strong class="jz jb">本地</strong>机器上<strong class="jz jb">安装</strong>许多<strong class="jz jb">依赖项</strong>。SQL Server，。NET Core SDK，Node 8，囫囵吞枣地说出了其中的大部分。<br/>我们到达了一个<strong class="jz jb">点</strong>，在那里我们可以运行<code class="fe ld le lf lg b">docker-compose up</code>并查看应用程序！完成后，我们可以删除图像，彻底删除-应用程序什么都没有留下！并且不会与我们已经为其他项目运行的工具的其他版本发生冲突。我真的很喜欢最后一个。我们可以在持续集成机器上做同样的事情，等等。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi od"><img src="../Images/56fe6b21fc4a84f8105eb99e1dd83cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t0HWBrDcSryLtmuKG-8fgw.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">跳过一点…</figcaption></figure><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi oe"><img src="../Images/2211872371b2cc5e1d2d8d319a227ca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gtdWZGmRB7drneY0hEDoOQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">多跳过一些…</figcaption></figure><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi of"><img src="../Images/1ebe67fd1a78adfb25dbe6218cd3265c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*buCSBwSsDMh0y7rY0tUi8Q.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">(不要介意日志时间几乎有10分钟的差距——必须重新运行)跳过一些更多…和一些更多…和更多..ef迁移相当冗长…更多…最后</figcaption></figure><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi og"><img src="../Images/085f904c9acb36809534447772c24877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F0WWhwqSZrK8mzLYizWWGw.png"/></div></div></figure></div><div class="ab cl kw kx hx ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="im in io ip iq"><p id="f5c6" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">感谢阅读！</p><p id="c98e" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个练习对我来说很有趣，我希望对你有所帮助。我正在考虑将它扩展为一个在线研讨会，我希望得到您的反馈:</p><p id="2eed" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你想要一个更详细的版本，一个在线研讨会，让你一步一步地完成整个过程，有一些指导吗？请投票:</p><figure class="mv mw mx my gt iv"><div class="bz fp l di"><div class="oh ns l"/></div></figure></div><div class="ab cl kw kx hx ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="im in io ip iq"><p id="cc65" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我想留给你们一些资源，它们对我理解和使用docker和docker-compose帮助很大。</p><ul class=""><li id="12fc" class="li lj ja jz b ka kb ke kf ki lk km ll kq lm ku lw lo lp lq bi translated">A very nice <strong class="jz jb"> video </strong> from a docker conference for Docker basics — “Docker FROM scratch” <a class="ae kv" href="https://www.youtube.com/watch?v=i7yoXqlg48M" rel="noopener ugc nofollow" target="_blank"> WEBv=i7yoXqlg48M </a></li><li id="45d5" class="li lj ja jz b ka lr ke ls ki lt km lu kq lv ku lw lo lp lq bi translated">Docker 文档 <a class="ae kv" href="https://docs.docker.com/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/ </a></li><li id="86b8" class="li lj ja jz b ka lr ke ls ki lt km lu kq lv ku lw lo lp lq bi translated">Docker-compose 文档 h <a class="ae kv" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> ttps://docs.docker.com/compose/ </a></li></ul></div></div>    
</body>
</html>