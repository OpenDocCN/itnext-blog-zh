<html>
<head>
<title>React, Redux and a little bit of math.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应，还原和一点点数学。</h1>
<blockquote>原文：<a href="https://itnext.io/react-redux-and-a-little-bit-of-math-fe2c9a4a477c?source=collection_archive---------6-----------------------#2020-03-25">https://itnext.io/react-redux-and-a-little-bit-of-math-fe2c9a4a477c?source=collection_archive---------6-----------------------#2020-03-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="a579" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">TLDR；在这个故事中，我想展示前端工程可以是非常理论化和精确的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/d7b8fe16a28eaea02641f15ada4c88b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LdfPfiL6ykTKkycb-YYZzg.jpeg"/></div></div></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="a676" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae lh" href="http://holloway.com/" rel="noopener ugc nofollow" target="_blank"> Holloway </a>，我们试图在网上创造最好的长格式文本阅读体验，它包括在一页上一次性呈现整本书，因为我们想给用户在任何给定时间以任何方式“翻转”(滚动)我们的书的自由。</p><p id="2dc7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">显然，具有交互性的非分页长阅读内容呈现起来有点困难。我们有很多工具提示、建议、书签，而且每周我们都会增加一些。</p><p id="318b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我今天要谈的一个挑战是让每个段落组件实例总是连接到redux状态。我们的新功能——高光需要它。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h2 id="17ca" class="li lj it bd lk ll lm dn ln lo lp dp lq kb lr ls lt kf lu lv lw kj lx ly lz ma bi translated">问题是</h2><p id="251d" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">我们最小的指南之一，<a class="ae lh" href="https://www.holloway.com/g/equity-compensation/" rel="noopener ugc nofollow" target="_blank">股权补偿</a>，有600多个段落，用户可以添加书签，添加建议或高亮显示其中的任何一个，这是可能的，因为每个段落组件实例都连接到redux并准备接收更新。</p><p id="caa2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，将每个段落连接到redux会大大降低页面性能，每个redux操作都会触发600多次连接组件检查往返。</p><p id="4e28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">高级连接有一点帮助，但仍然会有600+稍微更快的每次商店更新的往返，我们不希望这样。</p><p id="bd67" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虚拟滚动将有助于减少页面上的段落数量，但由于长格式文本阅读体验的独特功能，它需要的不仅仅是放入几个侦听器并在用户滚动时呈现内容(这并非不可能，但比看起来更难)。</p><p id="5890" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们需要定义什么是高效或廉价的操作，什么不是。如果我们有一个永远不会变异的状态，那么新旧状态的简单比较将非常便宜(<code class="fe mg mh mi mj b">===</code>)，即使一千个也不会有太大的不同，一个现代浏览器只需要几分之一毫秒的时间。</p><p id="cf2a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还知道，连接的元件越少越好。如果我们有一个容器来检查更新和重新呈现段落列表会怎么样？</p><p id="76e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不幸的是，这样效率不高。虽然连接的组件较少，但重新呈现长列表并不是一个快速的操作。</p><p id="ad9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们决定将每个段落组件连接到商店，那么最坏的情况是<strong class="js iu"> <em class="mk"> n </em> </strong> redux往返和一次重新呈现。对于单个容器，它将是<strong class="js iu"> 1 </strong>连接的组件redux roundtrip和react将需要更新一个包含<strong class="js iu"> <em class="mk"> n </em> </strong>元素的列表。</p><p id="314c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，连接的组件越少，每次存储更改的更新越少越好，但是对每个元素执行简单的比较操作也是可以的。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h2 id="e883" class="li lj it bd lk ll lm dn ln lo lp dp lq kb lr ls lt kf lu lv lw kj lx ly lz ma bi translated">两个弹珠和解决方案</h2><p id="db54" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">你可能知道流行的<a class="ae lh" href="https://stackoverflow.com/questions/6547/two-marbles-and-a-100-story-building" rel="noopener ugc nofollow" target="_blank">两个弹珠和一座100层的建筑</a>面试问题:</p><blockquote class="ml mm mn"><p id="3ed2" class="jq jr mk js b jt ju jv jw jx jy jz ka mo kc kd ke mp kg kh ki mq kk kl km kn im bi translated">给你两个弹珠，并告诉你它们会在从某个高度掉下来时破碎(如果从这个高度以下掉下来，大概不会受到伤害)。然后你被带到一个100层的建筑(可能比特定的高度要高)，并被要求找到你能尽可能高效地从最高的楼层扔下一个弹球而不打碎它。</p></blockquote><p id="15a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解决方案简单而优雅。楼层被分成几个部分，第一个大理石用于找到一个足够高的部分来打破它，第二个用于找到该部分内的确切楼层。</p><p id="05d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这表明了我们的问题的另一个方面，如果我们将<strong class="js iu"> <em class="mk"> n </em> </strong>元素除以<strong class="js iu"> <em class="mk"> s </em> </strong>子列表组件，并将每个子列表组件连接到商店，那么在最坏的情况下，我们会有每次商店更新的<strong class="js iu"> <em class="mk"> s </em> </strong>往返，以及<strong class="js iu"> <em class="mk"> n / s </em> </strong> react组件更新，因为对子列表的更新意味着对子列表的每个元素的更新。</p><p id="2999" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个程序更新我们的列表需要的时间是:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/9460aee597a424d609c14a6cca260a70.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*4ir2Ox-ZsP42R_Zq"/></div></figure><p id="8633" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中<strong class="js iu"> <em class="mk"> R </em> </strong> — redux连接往返时间，<strong class="js iu"> <em class="mk"> U </em> </strong> —react组件更新时间。让我们看看时间<strong class="js iu"> <em class="mk"> t </em> </strong>相对于子列表<strong class="js iu"> <em class="mk"> s </em> </strong>的变化率，我们可以通过对<a class="ae lh" href="https://www.wolframalpha.com/input/?i=d%2Fds%28s+%2B+%28n+%2F+s%29%29" rel="noopener ugc nofollow" target="_blank">对<strong class="js iu"><em class="mk">ds</em></strong></a><strong class="js iu"><em class="mk">:</em></strong>求导</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/30323d67945d83b45a9fe847e21112ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/0*IjChbb15QrkSSWNT"/></div></figure><p id="d2ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们去掉<strong class="js iu"> <em class="mk"> R </em> </strong>和<strong class="js iu"> <em class="mk"> U </em> </strong>因为它们是常数。现在我们可以看到，如果<strong class="js iu"> <em class="mk"> s = sqrt(n) </em> </strong>它将导数值变为0，这意味着函数处于局部最小值。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mt"><img src="../Images/e39ecd297e310ea9a1f3e8f84dd60ff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XJuDH1LZwq1mvbk91i04cg.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated"><strong class="bd lk"> <em class="my"> t = s + (n / s)，</em> </strong> <em class="my">其中</em> <strong class="bd lk"> <em class="my"> R </em> </strong> <em class="my">和</em> <strong class="bd lk"> <em class="my"> U </em> </strong> <em class="my">为了简单起见省略了</em></figcaption></figure><p id="6726" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实上，使用Wolfram Mathematica我们可以看到<a class="ae lh" href="https://www.wolframalpha.com/input/?i=t+%3D+s+%2B+%28n+%2F+s%29%2C+n+%3D+1000%2C+t+%3E+0%2C+s+%3C+n" rel="noopener ugc nofollow" target="_blank">数值解</a>非常接近预测值。同样，3d <a class="ae lh" href="https://www.wolframalpha.com/input/?i=plot3d+z+%3D+x+%2B+%28y+%2F+x%29%2C+y+%3E+1" rel="noopener ugc nofollow" target="_blank">可视化</a>表示显示，对于<strong class="js iu">T5 s&gt;0T7】和<strong class="js iu">T9】n&gt;0</strong>，函数只有一个局部最小值，这意味着对于给定的<strong class="js iu"><em class="mk"/></strong>，导数等于0的点就是<strong class="js iu"><em class="mk"/></strong>的最小值</strong></p><p id="c93a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样。</p><p id="ae22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了获得最佳的更新时间，我们需要通过连接到redux store的<strong class="js iu"><em class="mk">【sqrt(n)</em></strong>sub<strong class="js iu"><em class="mk">-</em></strong>列表来呈现一个列表。</p><h2 id="5c28" class="li lj it bd lk ll lm dn ln lo lp dp lq kb lr ls lt kf lu lv lw kj lx ly lz ma bi translated">结论</h2><p id="ce35" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">这篇文章强调了一个问题的纯理论解决方案，但是如果你想在现实生活中看到这个东西，请查看股权薪酬指南:<a class="ae lh" href="https://www.holloway.com/g/equity-compensation" rel="noopener ugc nofollow" target="_blank">https://www.holloway.com/g/equity-compensation</a></p><p id="82b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您对这篇文章或我在霍洛韦所做的工作有任何反馈，请告诉我，我将非常高兴。</p></div></div>    
</body>
</html>