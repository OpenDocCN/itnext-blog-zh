<html>
<head>
<title>The curious case of the always O(n*logn) QuickSort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">总是O(n*logn)快速排序的奇怪例子</h1>
<blockquote>原文：<a href="https://itnext.io/the-curious-case-of-the-always-o-n-logn-quicksort-603b56230e6?source=collection_archive---------2-----------------------#2022-01-10">https://itnext.io/the-curious-case-of-the-always-o-n-logn-quicksort-603b56230e6?source=collection_archive---------2-----------------------#2022-01-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="874b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我告诉你QuickSort是O(n*logn ),你可能会抗议并反驳你的观点。如果是这样的话，你可能会发现这篇文章令人大开眼界。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/13ac870bac90c33fdbd6772fd569aa6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QyJLgwLY7bggoejgJc-eXg.png"/></div></div></figure><p id="107b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上，我曾无数次地讨论过以下问题:</p><blockquote class="kx ky kz"><p id="d03a" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated"><strong class="jp ir">人甲:</strong>快速排序是个糟糕的算法。<br/> <strong class="jp ir">我:</strong>为什么？<br/> <strong class="jp ir">人甲:</strong>嗯拿一个来说，这是O(n*n)最坏的情况。我:只有当我们随机选择支点时才成立。<br/> <strong class="jp ir">人甲:</strong>你在说什么？无论你如何选择支点，它总是O(n*n)最坏的情况。</p></blockquote><p id="2972" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，是的，如果我们随机/任意地选择支点，QuickSort可以转化为SelectSort，使它为O(n*n)。然而，我们可以选择我们的枢纽来消除这种最坏的情况，使快速排序在最坏的O(n*logn)下进行。</p><p id="b973" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文将首先介绍经典的QuickSort，它选择中间的元素作为支点，并演示一个C++实现。然后，我们将讨论always O(n*logn)快速排序。</p><h1 id="1625" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">O(n*n)快速排序</h1><p id="a011" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">快速排序是一种递归分区算法。分区算法将移动序列中的元素，从满足谓词的元素开始，然后是不满足谓词的元素。</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="59c2" class="mm lf iq mi b gy mn mo l mp mq"># Before partition<br/>1 2 3 4 5 6 7 8 9<br/># After partition with is_even<br/>2 4 6 8 1 3 5 7 9</span></pre><p id="eb3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于快速排序，我们需要一个三向划分，它将序列划分为小于所选枢轴、等于枢轴、最后大于所选枢轴的元素。</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="82a7" class="mm lf iq mi b gy mn mo l mp mq"># Before partition with pivot 5<br/>9 9 5 5 5 3 2 1<br/># After partition with pivot 5<br/>3 2 1 5 5 5 9 9</span></pre><p id="227b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在C++中，我们有一个标准的双向分区:<code class="fe mr ms mt mi b">std::partition</code>算法。但是让我们快速看一下如何自己实现它:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="99f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是分区算法的一般版本。我们先来看一下实现。该算法采用两个迭代器(C++语义是<code class="fe mr ms mt mi b">[first,last)</code>)。我们首先找到不满足谓词的最左边的元素(第6行)，如果没有，我们就已经完成了(第7行)。</p><p id="9919" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们检查剩余的每个元素(第9–10行)，如果元素满足谓词，我们必须将它移到所有不满足谓词的元素之前(第12–13行)。<code class="fe mr ms mt mi b">std::iter_swap</code>将交换迭代器后面的元素。</p><p id="cdf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看这个实现，我们现在可以用公式表达这个算法需要的C++20概念。传入的迭代器必须满足<code class="fe mr ms mt mi b">std::forward_iterator</code>(对于<code class="fe mr ms mt mi b">++</code>和<code class="fe mr ms mt mi b">!=</code>)和<code class="fe mr ms mt mi b">std::indirectly_swapable</code>(对于<code class="fe mr ms mt mi b">std::iter_swap</code>)。条件必须满足<code class="fe mr ms mt mi b">std::predicate</code>概念(可调用，返回一个布尔值)。如果你想了解更多，我有一篇关于C++20概念的文章。</p><h2 id="f835" class="mm lf iq bd lg mx my dn lk mz na dp lo jy nb nc ls kc nd ne lw kg nf ng ma nh bi translated">快速排序</h2><p id="8685" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">构建基本的快速排序相对简单。然而，我们需要小心我们的支点:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="b17f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两个分区调用一起表示一个3路分区(第10行和第11行)。我们将pivot隐藏到子序列的末尾，然后将它移回到分区点<code class="fe mr ms mt mi b">pp2</code>所指向的位置，该分区点指向比pivot大的第一个元素(第7–8行和第13–14行)。在划分并固定了轴心之后，我们递归(第16–17行)并检测一个空范围的终止条件(第4–5行)。</p><p id="6da8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了移动轴心，我们还可以复制一个值。这个版本更适合那些交换成本低但复制成本高的元素。</p><p id="03ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个简单版本的QuickSort工作得很好，但是因为我们选择中枢作为中间元素<code class="fe mr ms mt mi b">first + std::distance(first, last)/2</code>，如果我们总是命中最小或最大元素，它可能会退化为O(n*n)。那么，让我们来谈谈我们需要做些什么来实现一个always O(n*logn)快速排序。</p><h1 id="964c" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">O(n*logn)快速排序</h1><p id="39ba" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">只要我们任意选择支点，在最坏的情况下，我们总是会以快速排序降级为选择排序而告终。我们需要一种选择在O(n)中运行的主元的方法，并且总是设法选择一个好的主元。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="8fca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以让我们讨论一种方法，在最坏的情况下，它会给我们一个以3:7的比例分割序列的支点。</p><h1 id="ebfa" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">中位数</h1><p id="358e" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">该算法遵循其名称。首先，我们将序列分成五个元素块，计算每个块的中位数，然后从这些中位数中选择中位数作为我们的中枢。</p><p id="ccb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这听起来很简单，但实现涉及到快速选择和相互递归，并且可能相当棘手，所以我们将一步一步来。</p><h2 id="f359" class="mm lf iq bd lg mx my dn lk mz na dp lo jy nb nc ls kc nd ne lw kg nf ng ma nh bi translated">3:7的比例</h2><p id="5756" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">当我们选择中位数时，我们知道一半的五行组块的中位数低于我们的中位数，一半的五行组块的中位数高于我们的中位数。</p><p id="33f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于具有较低中位数的组块，我们知道有两个元素比中位数本身低，所以我们知道这些组块中的每一个都至少有三个比中位数低的元素(组块的中位数和另外两个元素)。</p><p id="1330" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们计算一下，它是(一半的块)* 3个元素= (1/2)*(n/5)*3 = n*(3/10)。因此，至少30%的元素将低于中位数(类似的逻辑适用于更高的元素)。</p><h2 id="2716" class="mm lf iq bd lg mx my dn lk mz na dp lo jy nb nc ls kc nd ne lw kg nf ng ma nh bi translated">实施</h2><p id="fa32" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">首先，我们需要一种方法来从一个五元素块中选择一个中值。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="b923" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，这里的复杂性无关紧要，因为我们总是从最多五个元素中选择。</p><p id="1f9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们的中位数实施:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="74bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们首先需要迭代五个元素的块(第11-13行)，将相应的中间值移动到序列的开头(第15-17行)，然后调用<code class="fe mr ms mt mi b">quick_select</code>从这些中间值中选取合适的中间值(第21行)。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="d6e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">QuickSelect实现应该看起来很熟悉。事实上，这是一种非常片面的快速排序。分区之后，我们知道目标元素在哪里，所以我们只搜索那个分区。</p><p id="73bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我们实际上调用了QuickSelect中的中位数(第8行)，然后调用QuickSelect返回实际的中位数。</p><p id="947e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有这些加在一起，为快速选择提供了最坏情况下的O(n)复杂度，为快速排序提供了最坏情况下的O(n*logn)复杂度。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="01a7" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">实际问题</h1><p id="9f6a" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">所以，现在你可能想知道为什么我们不在所有地方都使用这种方法。嗯，中位数是一个很好的例子，说明了为什么大O符号不能讲述整个故事。</p><p id="df10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，这种方法消除了最坏情况下的复杂性。然而，在实践中，实现该算法所需的额外比较和移动的开销使其不切实际。因此，您将在您的库实现中找到IntroSort (QuickSort + HeapSort)或其他混合方法。</p><p id="4ea6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与此同时，排序算法是一个活跃的研究领域，一些论文指出，带有智能枢纽选择的快速排序的变体可能是实用的。</p><h1 id="886b" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">链接和技术说明</h1><p id="1931" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">包含所有代码的资源库位于:<a class="ae mw" href="https://github.com/HappyCerberus/article-quicksort" rel="noopener ugc nofollow" target="_blank">https://github.com/HappyCerberus/article-quicksort</a>。</p><p id="b3f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于中位数的更多信息，包括复杂性的证明，请查看维基百科文章。</p><h1 id="4b1a" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">感谢您的阅读</h1><p id="09f5" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">感谢您阅读这篇文章。你喜欢吗？</p><p id="8675" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也在YouTube上发布视频。你有问题吗？在推特<a class="ae mw" href="https://twitter.com/SimonToth83" rel="noopener ugc nofollow" target="_blank">或LinkedIn </a>上联系我。</p></div></div>    
</body>
</html>