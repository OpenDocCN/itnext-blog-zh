<html>
<head>
<title>Building and Deploying Cloud-Native Quarkus-based Java Applications to Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为Kubernetes构建和部署基于云原生Quarkus的Java应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/building-and-deploying-cloud-native-quarkus-applications-to-kubernetes-a4c494e3a843?source=collection_archive---------0-----------------------#2022-06-01">https://itnext.io/building-and-deploying-cloud-native-quarkus-applications-to-kubernetes-a4c494e3a843?source=collection_archive---------0-----------------------#2022-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4ab1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用GitOps为AWS上的Kubernetes开发、测试、构建和部署基于Quarkus的本地Java微服务</h2></div><h1 id="cf34" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">介绍</h1><p id="16e3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">尽管它可能不再是无可争议的编程语言领导者，但根据许多开发者调查，Java仍然与Go、Python、C/C++和JavaScript并列。鉴于Java的持续流行，尤其是在企业中，以及云原生软件开发的同时兴起，供应商们已经专注于创建专门构建的、现代的基于JVM的框架、工具和标准来开发应用程序，特别是微服务。</p><p id="99ce" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">领先的基于JVM的微服务应用程序框架通常提供一些功能，例如对<a class="ae mb" href="https://www.baeldung.com/java-reactive-systems" rel="noopener ugc nofollow" target="_blank">反应式编程模型</a>、<a class="ae mb" href="http://microprofile.io/" rel="noopener ugc nofollow" target="_blank">微文件</a>、<a class="ae mb" href="https://www.graalvm.org/22.0/reference-manual/native-image/" rel="noopener ugc nofollow" target="_blank"> GraalVM本机映像</a>、<a class="ae mb" href="https://www.openapis.org/" rel="noopener ugc nofollow" target="_blank"> OpenAPI </a>和Swagger定义生成、<a class="ae mb" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>、<a class="ae mb" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank"> CORS </a>(跨源资源共享)、<a class="ae mb" href="https://en.wikipedia.org/wiki/GRPC" rel="noopener ugc nofollow" target="_blank"> gRPC </a> (gRPC远程过程调用)、<a class="ae mb" href="https://www.cdi-spec.org/" rel="noopener ugc nofollow" target="_blank"> CDI </a>(上下文和依赖注入)、服务发现</p><h1 id="1735" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">领先的基于JVM的微服务框架</h1><p id="35ff" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">回顾一下最受欢迎的Java云原生微服务框架列表，你肯定会发现<a class="ae mb" href="https://spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring Boot和Spring Cloud </a>、<a class="ae mb" href="https://micronaut.io/" rel="noopener ugc nofollow" target="_blank"> Micronaut </a>、<a class="ae mb" href="https://helidon.io/" rel="noopener ugc nofollow" target="_blank"> Helidon </a>和<a class="ae mb" href="https://quarkus.io/" rel="noopener ugc nofollow" target="_blank"> Quarkus </a>位于或接近顶部。</p><h2 id="7418" class="mc kj it bd kk md me dn ko mf mg dp ks lj mh mi ku ln mj mk kw lr ml mm ky mn bi translated">春云Spring Boot</h2><p id="7069" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">根据他们网站的说法，<a class="ae mb" href="https://spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring </a>让每个人编写Java变得更快、更容易、更安全。Spring对速度、简单性和生产力的关注使它成为了<a class="ae mb" href="https://snyk.io/blog/jvm-ecosystem-report-2018-platform-application/" rel="noopener ugc nofollow" target="_blank">世界上最受欢迎的</a> Java框架。<a class="ae mb" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>使得创建独立的、生产级的基于Spring的应用程序变得容易，你可以<em class="mo">直接运行</em>。Spring Boot的许多专门构建的功能使得在生产中大规模构建和运行您的微服务变得非常容易。然而，微服务的分布式特性带来了挑战。Spring Cloud可以帮助服务发现、负载平衡、断路、分布式跟踪，以及使用几个现成的云模式进行监控。它甚至可以充当API网关。</p><h2 id="2430" class="mc kj it bd kk md me dn ko mf mg dp ks lj mh mi ku ln mj mk kw lr ml mm ky mn bi translated">赫利登</h2><p id="c645" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Oracle的<a class="ae mb" href="https://helidon.io/" rel="noopener ugc nofollow" target="_blank"> Helidon </a>是一套云原生的开源Java库，用于编写运行在由<a class="ae mb" href="https://netty.io/" rel="noopener ugc nofollow" target="_blank"> Netty </a>支持的快速web核心上的微服务。Helidon支持<a class="ae mb" href="http://microprofile.io/" rel="noopener ugc nofollow" target="_blank"> MicroProfile </a>，这是一种反应式编程模型，并且与Micronaut、Spring和Quarkus类似，它支持<a class="ae mb" href="https://www.graalvm.org/22.0/reference-manual/native-image/" rel="noopener ugc nofollow" target="_blank"> GraalVM本地映像</a>。</p><h2 id="7198" class="mc kj it bd kk md me dn ko mf mg dp ks lj mh mi ku ln mj mk kw lr ml mm ky mn bi translated">微型机器人</h2><p id="547a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">根据他们的网站介绍，<a class="ae mb" href="https://micronaut.io/" rel="noopener ugc nofollow" target="_blank"> Micronaut </a>框架是一个现代的、开源的、基于JVM的、全栈的工具包，用于构建模块化的、易于测试的微服务和无服务器应用。Micronaut支持多语言编程模型、发现服务、分布式跟踪和面向方面编程(AOP)。此外，Micronaut提供快速启动时间、极快的吞吐量和最小的内存占用。</p><h2 id="0821" class="mc kj it bd kk md me dn ko mf mg dp ks lj mh mi ku ln mj mk kw lr ml mm ky mn bi translated">夸库斯</h2><p id="906f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">由RedHat开发并赞助的Quarkus自称是“超音速亚原子Java”。Quarkus是一个云原生、Kubernetes原生、[Linux]容器优先、微服务优先的框架，用于编写Java应用程序。Quarkus是一个为OpenJDK HotSpot和GraalVM定制的Kubernetes原生Java栈，由50多个同类最佳的Java库和标准精心制作而成。</p><h1 id="1624" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">开发原生Quarkus微服务</h1><p id="edb2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在接下来的文章中，我们将为Kubernetes开发、构建、测试、部署和监控一个本地Quarkus微服务应用程序。RESTful服务将公开一个丰富的应用程序编程接口(API ),并与后端的PostgreSQL数据库进行交互。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mp"><img src="../Images/71989ddfdd0b278c48db7b9339fadf2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Ujv7saBt5anvZ2i5wSEYw.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">Quarkus应用程序生产环境的高级AWS架构图</figcaption></figure><p id="9975" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">本文中Quarkus应用程序的一些特性包括:</p><ul class=""><li id="34ac" class="nf ng it lc b ld lw lg lx lj nh ln ni lr nj lv nk nl nm nn bi translated">Hibernate对象关系映射器(ORM)，事实上的<a class="ae mb" href="https://en.wikipedia.org/wiki/Jakarta_Persistence" rel="noopener ugc nofollow" target="_blank"> Jakarta持久性API </a>(以前的Java持久性API)实现</li><li id="7f61" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><a class="ae mb" href="https://quarkus.io/guides/hibernate-reactive-panache" rel="noopener ugc nofollow" target="_blank">Hibernate Reactive with Panache</a>，这是一个Quarkus特有的库，简化了Hibernate Reactive实体的开发</li><li id="8bc0" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><a class="ae mb" href="https://quarkus.io/guides/resteasy-reactive" rel="noopener ugc nofollow" target="_blank"> RESTEasy反应式</a>，一个新的<a class="ae mb" href="https://quarkus.io/specs/jaxrs/2.1/index.html" rel="noopener ugc nofollow" target="_blank"> JAX-RS </a>实现，与通用<a class="ae mb" href="https://vertx.io/" rel="noopener ugc nofollow" target="_blank">垂直x </a>层一起工作，因此是完全反应式的</li><li id="030f" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated">高级RESTEasy反应式<a class="ae mb" href="https://github.com/FasterXML/jackson" rel="noopener ugc nofollow" target="_blank"> Jackson支持</a>JSON序列化</li><li id="cf52" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><a class="ae mb" href="https://quarkus.io/guides/reactive-sql-clients" rel="noopener ugc nofollow" target="_blank">反应式PostgreSQL客户端</a></li><li id="7966" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated">构建在<a class="ae mb" href="https://github.com/graalvm/mandrel" rel="noopener ugc nofollow" target="_blank">心轴</a>，<a class="ae mb" href="https://developers.redhat.com/blog/2020/06/05/mandrel-a-community-distribution-of-graalvm-for-the-red-hat-build-of-quarkus/" rel="noopener ugc nofollow" target="_blank">上的GraalVM社区版的下游发行版</a></li><li id="f841" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated">使用Gradle 构建的现代开源构建自动化工具专注于灵活性和性能</li></ul><h1 id="a6fb" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="5aa1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在阅读全文之前，您想探索一下这篇文章的Quarkus微服务应用程序的源代码，还是将其部署到Kubernetes？所有的源代码和Kubernetes资源都是开源的，可以在GitHub上获得:</p><pre class="mq mr ms mt gt nt nu nv nw aw nx bi"><span id="672b" class="mc kj it nu b gy ny nz l oa ob">git clone --depth 1 -b main \<br/>    <!-- -->https://github.com/garystafford/tickit-srv.git</span></pre><p id="3db3" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">最新的Docker图片可在<a class="ae mb" href="https://hub.docker.com/r/garystafford/tickit-srv" rel="noopener ugc nofollow" target="_blank"> docker.io </a>上获得:</p><pre class="mq mr ms mt gt nt nu nv nw aw nx bi"><span id="a382" class="mc kj it nu b gy ny nz l oa ob">docker pull garystafford/tickit-srv:&lt;latest-tag&gt;</span></pre><h1 id="cefb" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">具有智能的Quarkus项目</h1><p id="77be" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">尽管不是必需的，我还是使用了<a class="ae mb" href="https://www.jetbrains.com/idea/" rel="noopener ugc nofollow" target="_blank">JetBrains IntelliJ IDEA 2022</a>(终极版)来开发和测试post的Quarkus应用程序。用IntelliJ引导Quarkus项目很容易。使用终极版附带的Quarkus插件，开发人员可以快速创建一个Quarkus项目。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oc"><img src="../Images/e19b5923f2079612abbf668d1a158e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oCTH3JJYpH0u_0bI8yNHZw.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">JetBrains IntelliJ IDEA对Quarkus项目的本地支持</figcaption></figure><p id="d742" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">Quarkus插件的项目创建向导基于<a class="ae mb" href="https://code.quarkus.io/" rel="noopener ugc nofollow" target="_blank"> code.quarkus.io </a>。如果您已经引导了一个Spring Initializr项目，<a class="ae mb" href="https://code.quarkus.io/" rel="noopener ugc nofollow" target="_blank"> code.quarkus.io </a>的工作方式与<a class="ae mb" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"> start.spring.io </a>非常相似。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oc"><img src="../Images/ef762f2fe92cab61b5d8a409b545a6e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*79ZfUTXQdJwxPEmTKqEiDw.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">在IntelliJ中为新的Quarkus项目添加扩展</figcaption></figure><h2 id="6831" class="mc kj it bd kk md me dn ko mf mg dp ks lj mh mi ku ln mj mk kw lr ml mm ky mn bi translated">Visual Studio代码</h2><p id="7bfc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">RedHat还为流行的Visual Studio代码IDE提供了一个Quarkus扩展。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi od"><img src="../Images/c866170b5bf12259dee3e0d6a9254d22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MVDmY3HuEum9nnb0rL0_Iw.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">安装了Quarkus扩展的Visual Studio代码IDE</figcaption></figure><h1 id="888c" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">格拉德勒</h1><p id="f3ea" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这篇文章使用Gradle代替Maven来开发、测试、构建、打包和部署Kubernetes的Quarkus应用程序。基于上面显示的新项目设置中选择的包，Quarkus插件的项目创建向导创建以下<code class="fe oe of og nu b">build.gradle</code>文件(<a class="ae mb" href="https://projectlombok.org/" rel="noopener ugc nofollow" target="_blank"> Lombak </a>单独添加)。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="32cd" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">向导还创建了下面的<code class="fe oe of og nu b">gradle.properties</code>文件，该文件已经更新到本文发布时可用的Quarkus的<a class="ae mb" href="https://github.com/quarkusio/quarkus/releases" rel="noopener ugc nofollow" target="_blank">最新版本</a>2 . 9 . 2。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="oh oi l"/></div></figure><h2 id="28ba" class="mc kj it bd kk md me dn ko mf mg dp ks lj mh mi ku ln mj mk kw lr ml mm ky mn bi translated">格拉德和夸库斯</h2><p id="df1a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你可以使用<a class="ae mb" href="https://quarkus.io/guides/cli-tooling" rel="noopener ugc nofollow" target="_blank"> Quarkus CLI </a>或者Quarkus Maven插件来搭建一个Gradle项目。依赖Quarkus插件会给Gradle增加几个额外的Quarkus任务。我们将使用Gradle来开发、测试、构建、封装Quarkus微服务应用程序，并将其部署到Kubernetes。在这篇文章中，<code class="fe oe of og nu b">quarkusDev</code>、<code class="fe oe of og nu b">quarkusTest</code>和<code class="fe oe of og nu b">quarkusBuild</code>任务将特别有用。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/ba06389fd52ce6dcbc6fa28afd5ac1a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*BoxDp8i2VRpaS13S_BiQ7A.png"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">在IntelliJ中看到的附加Quarkus梯度任务</figcaption></figure><h1 id="c00f" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">Java编译</h1><p id="dbf6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">本文中的Quarkus应用程序是用最新的Java 17版本的<a class="ae mb" href="https://github.com/graalvm/mandrel" rel="noopener ugc nofollow" target="_blank"> Mandrel </a>，<a class="ae mb" href="https://developers.redhat.com/blog/2020/06/05/mandrel-a-community-distribution-of-graalvm-for-the-red-hat-build-of-quarkus/" rel="noopener ugc nofollow" target="_blank">GraalVM community edition</a>的下游发行版编译成原生映像的。</p><h2 id="0598" class="mc kj it bd kk md me dn ko mf mg dp ks lj mh mi ku ln mj mk kw lr ml mm ky mn bi translated">GraalVM和本机映像</h2><p id="b707" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">根据<a class="ae mb" href="https://www.graalvm.org/22.1/docs/getting-started/" rel="noopener ugc nofollow" target="_blank">文档</a>，GraalVM是一个高性能的JDK发行版。它旨在加速用Java和其他JVM语言编写的应用程序的执行，同时还为JavaScript、Ruby、Python和其他流行语言提供运行时。</p><p id="2319" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">此外，根据GraalVM 的说法，原生映像是一种提前将Java代码编译成独立可执行文件的技术，称为原生映像。该可执行文件包括应用程序类、其依赖项中的类、运行时库类以及JDK中静态链接的本机代码。Native Image builder ( <code class="fe oe of og nu b">native-image</code>)是一个实用程序，它处理应用程序的所有类及其依赖项，包括来自JDK的类。它静态地分析数据，以确定在应用程序执行期间哪些类和方法是可访问的。</p><h2 id="d8f3" class="mc kj it bd kk md me dn ko mf mg dp ks lj mh mi ku ln mj mk kw lr ml mm ky mn bi translated">心轴</h2><p id="d6db" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">mandrel<a class="ae mb" href="https://developers.redhat.com/blog/2020/06/05/mandrel-a-community-distribution-of-graalvm-for-the-red-hat-build-of-quarkus/" rel="noopener ugc nofollow" target="_blank">是GraalVM社区版</a>的下游发行版。Mandrel的主要目标是提供一个专门支持Quarkus的<code class="fe oe of og nu b">native-image</code>版本。目的是将GraalVM的<code class="fe oe of og nu b">native-image</code>功能与<a class="ae mb" href="https://openjdk.java.net/" rel="noopener ugc nofollow" target="_blank"> OpenJDK </a>和Red Hat Enterprise Linux库结合起来，以提高原生Quarkus应用程序的可维护性。Mandrel最好被描述为一个带有特殊打包的GraalVM原生映像构建器的常规OpenJDK的发行版(<code class="fe oe of og nu b">native-image</code>)。</p><h1 id="e9a3" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">Docker图像</h1><p id="caff" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一旦编译完成，本地Quarkus可执行文件将在部署到Kubernetes的<code class="fe oe of og nu b">quarkus-micro-image:1.0</code>基础运行时映像中运行。Quarkus提供了这个<a class="ae mb" href="https://quarkus.io/guides/quarkus-runtime-base-image" rel="noopener ugc nofollow" target="_blank">基础映像</a>来简化本地可执行文件的容器化。与其他图像相比，它的占用空间最小(压缩后为10.9 MB/未压缩后为29.5 MB)。比如最新的UBI(通用基础镜像)Quarkus心轴镜像(<code class="fe oe of og nu b"><a class="ae mb" href="https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags" rel="noopener ugc nofollow" target="_blank">ubi-quarkus-mandrel:22.1.0.0-Final-java17</a></code>)是714 MB未压缩，而OpenJDK 17镜像(<code class="fe oe of og nu b"><a class="ae mb" href="https://hub.docker.com/layers/openjdk/library/openjdk/17.0.2-jdk/images/sha256-98f0304b3a3b7c12ce641177a99d1f3be56f532473a528fda38d53d519cafb13?context=explore" rel="noopener ugc nofollow" target="_blank">openjdk:17-jdk</a></code>)是471 MB未压缩。即使是RedHat的通用基础映像Minimal image ( <code class="fe oe of og nu b"><a class="ae mb" href="https://catalog.redhat.com/software/containers/ubi8/ubi-minimal/5c359a62bed8bd75a2c3fba8?tag=8.6-751&amp;push_date=1652217593000" rel="noopener ugc nofollow" target="_blank">ubi-minimal:8.6</a></code>)也是93.4 MB未压缩。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ok"><img src="../Images/54b564d3b625e0c75da7c98829e0a2bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KmFZCA02m0DZhUPYB_vg8A.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">用于大小比较的未压缩Quarkus相关Docker图像</figcaption></figure><p id="c18a" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">来自Quarkus的一个更小的选项是一个<a class="ae mb" href="https://quarkus.io/guides/building-native-image#using-a-distroless-base-image" rel="noopener ugc nofollow" target="_blank">无发行版基础映像</a> ( <code class="fe oe of og nu b"><a class="ae mb" href="https://quay.io/repository/quarkus/quarkus-distroless-image?tab=tags&amp;tag=1.0" rel="noopener ugc nofollow" target="_blank">quarkus-distroless-image</a>:1.0)</code>只有9.2 MB压缩/ 22.7 MB未压缩)。Quarkus小心翼翼地指出，distroless映像支持是实验性的，在没有经过严格测试的情况下，不应该用于生产。</p><h1 id="175a" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">PostgreSQL数据库</h1><p id="797b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于Quarkus应用程序的后端数据持久层，我们将使用PostgreSQL。帖子中使用的所有DDL(数据定义语言)和DML(数据操作语言)语句都用最新版本的<a class="ae mb" href="https://www.postgresql.org/docs/current/index.html" rel="noopener ugc nofollow" target="_blank"> PostgreSQL 14 </a>进行了测试。</p><p id="ce70" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">有许多PostgreSQL兼容的示例数据库可用于本文。我正在使用由AWS提供的、为Amazon Redshift(AWS的云数据仓库服务)设计的<a class="ae mb" href="https://docs.aws.amazon.com/redshift/latest/dg/c_sampledb.html" rel="noopener ugc nofollow" target="_blank"> TICKIT样本数据库</a>。在传统的数据仓库<a class="ae mb" href="https://en.wikipedia.org/wiki/Star_schema" rel="noopener ugc nofollow" target="_blank">星型模式</a>中，数据库由七个表组成——两个事实表和五个维度表。</p><p id="e2d5" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在这篇文章中，我将TICKIT数据库的星型模式重新建模为一个针对Quarkus应用程序优化的规范化关系数据模型。数据库最显著的变化是将原来的<code class="fe oe of og nu b">Users</code>维度表分成两个独立的表——<code class="fe oe of og nu b">buyer</code>和<code class="fe oe of og nu b">seller</code>。这一改变将允许更好的关注点分离(SoC)、可扩展性和对个人可识别信息的增强保护(PII)。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ol"><img src="../Images/c551df17bdbe7add28e28da014e5701a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jv6vT8s1kXi7dJqsjtlrNQ.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">邮政中使用的TICKIT数据库关系数据模型</figcaption></figure><h1 id="b056" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">源代码</h1><p id="ad0a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">PostgreSQL TICKIT数据库中六个表中的每一个都由一个实体、存储库和资源Java类表示。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ok"><img src="../Images/15967c8d9ba1b6d6d76fab9890a500e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J_mVEns9b4bHTJevfpFv-Q.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">查看Quarkus应用程序的源代码</figcaption></figure><h2 id="3ad5" class="mc kj it bd kk md me dn ko mf mg dp ks lj mh mi ku ln mj mk kw lr ml mm ky mn bi translated">实体类</h2><p id="9b03" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Java持久性是用于管理持久性和对象/关系映射的API。Java持久性API (JPA)为Java开发人员提供了一个对象/关系映射工具，用于管理Java应用程序中的关系数据。PostgreSQL TICKIT数据库中的每个表都由一个<a class="ae mb" href="https://docs.oracle.com/javaee/7/api/javax/persistence/package-summary.html" rel="noopener ugc nofollow" target="_blank"> Java持久性</a>实体表示，如类声明上的<code class="fe oe of og nu b">Entity</code>注释所示。注释指定该类是一个实体。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div class="gh gi om"><img src="../Images/fb423012413dda9f596bf1ee9b616292.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*kngJfBZ0lVoRym_KWyqVIg.png"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">JPA实体关系，镜像数据库的数据模型</figcaption></figure><p id="37e2" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">每个实体类都扩展了<code class="fe oe of og nu b"><a class="ae mb" href="https://javadoc.io/static/io.quarkus/quarkus-hibernate-orm-panache/2.9.1.Final/io/quarkus/hibernate/orm/panache/package-summary.html" rel="noopener ugc nofollow" target="_blank">io.quarkus.hibernate.orm.panache</a></code>包中的<code class="fe oe of og nu b">PanacheEntityBase</code>类。根据Quarkus文档，您可以通过扩展<code class="fe oe of og nu b">PanacheEntityBase</code>而不是<code class="fe oe of og nu b">PanacheEntity</code>来指定您自己的定制ID策略，在本文的示例中就是这样做的。</p><p id="6a91" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">如果你不想为你的实体定义getter/setter，我们在文章的例子中没有，扩展<code class="fe oe of og nu b">PanacheEntityBase</code>，Quarkus将为你生成它们。或者，扩展<code class="fe oe of og nu b">PanacheEntity</code>并利用它提供的默认ID，如果您没有使用定制ID策略的话。</p><p id="a7e4" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">下面显示的示例<code class="fe oe of og nu b">SaleEntity</code>类是Quarkus应用程序的典型实体。除了<code class="fe oe of og nu b">Entity</code>之外，实体类还包含几个额外的JPA注释，包括<code class="fe oe of og nu b">Table</code>、<code class="fe oe of og nu b">NamedQueries</code>、<code class="fe oe of og nu b">Id</code>、<code class="fe oe of og nu b">SequenceGenerator</code>、<code class="fe oe of og nu b">GeneratedValue</code>和<code class="fe oe of og nu b">Column</code>。实体类还利用了<a class="ae mb" href="https://projectlombok.org/" rel="noopener ugc nofollow" target="_blank"> Project Lombok </a>注释。Lombok生成两个样板构造函数，一个不带参数(<code class="fe oe of og nu b">NoArgsConstructor</code>)，另一个为每个字段带一个参数(<code class="fe oe of og nu b">AllArgsConstructor</code>)。</p><p id="6e10" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><code class="fe oe of og nu b">SaleEntity</code>类还定义了两个多对一关系，分别是<code class="fe oe of og nu b">ListingEntity</code>和<code class="fe oe of og nu b">BuyerEntity</code>实体类。这种关系反映了数据库的数据模型，如上面的模式图所示。使用<code class="fe oe of og nu b">ManyToOne</code>和<code class="fe oe of og nu b">JoinColumn</code> JPA注释定义关系。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="0f6c" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">给定实体之间的关系，一个表示为嵌套JSON对象的<code class="fe oe of og nu b">saleEntity</code>对象将如下所示:</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="oh oi l"/></div></figure><h2 id="48b6" class="mc kj it bd kk md me dn ko mf mg dp ks lj mh mi ku ln mj mk kw lr ml mm ky mn bi translated">知识库类</h2><p id="204d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">PostgreSQL TICKIT数据库中的每个表都有一个对应的存储库类，通常称为“存储库模式”repository类实现了<code class="fe oe of og nu b"><a class="ae mb" href="https://javadoc.io/static/io.quarkus/quarkus-hibernate-orm-panache/0.19.0/io/quarkus/hibernate/orm/panache/PanacheRepositoryBase.html" rel="noopener ugc nofollow" target="_blank">PanacheRepositoryBase</a></code>接口，它是<code class="fe oe of og nu b"><a class="ae mb" href="https://javadoc.io/static/io.quarkus/quarkus-hibernate-orm-panache/2.9.1.Final/io/quarkus/hibernate/orm/panache/package-summary.html" rel="noopener ugc nofollow" target="_blank">io.quarkus.hibernate.orm.panache</a></code>包的一部分。<code class="fe oe of og nu b"><a class="ae mb" href="https://javadoc.io/static/io.quarkus/quarkus-hibernate-orm-panache/0.19.0/io/quarkus/hibernate/orm/panache/PanacheRepositoryBase.html" rel="noopener ugc nofollow" target="_blank">PanacheRepositoryBase</a></code> Java接口代表特定类型实体的存储库。根据<a class="ae mb" href="https://quarkus.io/guides/hibernate-orm-panache#custom-ids" rel="noopener ugc nofollow" target="_blank">文档</a>，如果您正在使用存储库并且有一个定制的ID策略，那么您将想要扩展<code class="fe oe of og nu b">PanacheRepositoryBase</code>而不是<code class="fe oe of og nu b">PanacheRepository</code>，并且将您的ID类型指定为一个额外的类型参数。实现<code class="fe oe of og nu b">PanacheRepositoryBase</code>将在<code class="fe oe of og nu b">PanacheEntityBase</code>上给你同样的方法。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi on"><img src="../Images/35987c8bbd15ef169a463a884e16ee83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FioVSx1objTzpEoNvjncfg.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">PanacheRepositoryBase公开的方法的部分列表</figcaption></figure><p id="dc73" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">repository类允许我们利用通过<code class="fe oe of og nu b">PanacheEntityBase</code>已经可用的方法，并添加额外的定制方法。例如，repository类包含一个定制方法<code class="fe oe of og nu b">listWithPaging</code>。该方法检索(<code class="fe oe of og nu b">GET</code>)一个<code class="fe oe of og nu b">SaleEntity</code>对象列表，其额外的好处是能够指示页码、页面大小、按字段排序和排序方向。</p><p id="b6a9" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">由于在<code class="fe oe of og nu b">SaleEntity</code>类与<code class="fe oe of og nu b">ListingEntity</code>和<code class="fe oe of og nu b">BuyerEntity</code>实体类之间存在多对一的关系，我们也有两个定制方法，通过<code class="fe oe of og nu b">BuyerEntity</code> ID或<code class="fe oe of og nu b">EventEntity</code> ID检索所有的<code class="fe oe of og nu b">SaleEntity</code>对象。这两个方法调用SaleEntity中的SQL查询，在类声明中用JPA <code class="fe oe of og nu b">NamedQueries</code> / <code class="fe oe of og nu b">NamedQuery</code>注释进行了注释。</p><h2 id="83c7" class="mc kj it bd kk md me dn ko mf mg dp ks lj mh mi ku ln mj mk kw lr ml mm ky mn bi translated">斯莫尔莱兵变</h2><p id="ba68" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">repository类中定义的每个方法都返回一个SmallRye哗变<code class="fe oe of og nu b"><a class="ae mb" href="https://smallrye.io/smallrye-mutiny/getting-started/creating-unis" rel="noopener ugc nofollow" target="_blank">Uni&lt;T&gt;</a></code>。据<a class="ae mb" href="https://smallrye.io/smallrye-mutiny/index.html" rel="noopener ugc nofollow" target="_blank">网站</a>报道，哗变是一个直观的、事件驱动的反应式Java编程库。哗变提供了一个简单但强大的异步开发模型，让您构建反应式应用程序。manturity可以用在任何表现出异步的Java应用程序中，包括反应式微服务、数据流、事件处理、API网关和网络实用程序。</p><h2 id="0fb9" class="mc kj it bd kk md me dn ko mf mg dp ks lj mh mi ku ln mj mk kw lr ml mm ky mn bi translated">大学</h2><p id="caeb" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">同样，根据兵变的<a class="ae mb" href="https://smallrye.io/smallrye-mutiny/getting-started/creating-unis" rel="noopener ugc nofollow" target="_blank">文档</a>，一个<code class="fe oe of og nu b">Uni</code>代表一个<em class="mo">流</em>，它只能发出一个项目或者一个失败事件。一个<code class="fe oe of og nu b">Uni&lt;T&gt;</code>是一个专门的流，它只发出一个项目或一个失败。通常，<code class="fe oe of og nu b">Uni&lt;T&gt;</code>非常适合表示异步动作，比如远程过程调用、HTTP请求或产生单一结果的操作。一个<code class="fe oe of og nu b">Uni</code>代表一个懒惰的异步动作。它遵循订阅模式，这意味着只有当一个<code class="fe oe of og nu b">UniSubscriber</code>订阅了<code class="fe oe of og nu b">Uni</code>时才会触发该动作。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="oh oi l"/></div></figure><h2 id="36d5" class="mc kj it bd kk md me dn ko mf mg dp ks lj mh mi ku ln mj mk kw lr ml mm ky mn bi translated">资源类</h2><p id="e247" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">最后，PostgreSQL TICKIT数据库中的每个表都有一个相应的资源类。根据Quarkus <a class="ae mb" href="https://quarkus.io/guides/hibernate-orm-panache#defining-your-repository" rel="noopener ugc nofollow" target="_blank">文档</a>，在<code class="fe oe of og nu b">PanacheEntityBase</code>中定义的所有操作在您的存储库中都是可用的，因此使用它与使用活动记录模式完全相同，除了您需要注入它。我们将相应的存储库类注入到资源类中，公开存储库和<code class="fe oe of og nu b"><a class="ae mb" href="https://javadoc.io/static/io.quarkus/quarkus-hibernate-orm-panache/0.19.0/io/quarkus/hibernate/orm/panache/PanacheRepositoryBase.html" rel="noopener ugc nofollow" target="_blank">PanacheRepositoryBase</a></code>的所有可用方法。例如，注意下面的自定义<code class="fe oe of og nu b">listWithPaging</code>方法，它是在<code class="fe oe of og nu b">SaleRepository</code>类中声明的。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi on"><img src="../Images/6419b8816e34650a416bbca7fde67279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uizS5g3wVc3TW_C4UI3X9A.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">通过将存储库类注入资源类而公开的方法的部分列表</figcaption></figure><p id="e61f" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">与repository类类似，resource类中定义的每个方法也返回一个SmallRye哗变(<code class="fe oe of og nu b">io.smallrye.mutiny</code> ) <code class="fe oe of og nu b">Uni&lt;T&gt;</code>。</p><p id="9417" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">存储库定义了与数据库上的CRUD操作(创建、读取、更新和删除)相对应的HTTP方法(<code class="fe oe of og nu b">POST</code>、<code class="fe oe of og nu b">GET</code>、<code class="fe oe of og nu b">PUT</code>和<code class="fe oe of og nu b">DELETE</code>)。这些方法用相应的<code class="fe oe of og nu b">javax.ws.rs</code>注释进行了注释，表明它们响应的HTTP请求的类型。<code class="fe oe of og nu b">javax.ws.rs</code>包包含用于创建RESTful服务资源的高级接口和注释，比如我们的Quarkus应用程序。</p><p id="fba0" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">带注释的<code class="fe oe of og nu b">POST</code>、<code class="fe oe of og nu b">PUT</code>和<code class="fe oe of og nu b">DELETE</code>方法都有与它们相关联的<code class="fe oe of og nu b">io.quarkus.hibernate.reactive.panache.common.runtime</code>包的<code class="fe oe of og nu b">ReactiveTransactional</code>注释。我们在方法上使用这种注释来在反应式<code class="fe oe of og nu b">Mutiny.Session.Transation</code>中运行它们。如果带注释的方法返回一个<code class="fe oe of og nu b">Uni</code>，他们确实这样做了，这与方法包含在对<code class="fe oe of og nu b">Mutiny.Session.withTransaction(java.util.function.Function)</code>的调用中的行为完全相同。如果方法调用失败，则回滚整个事务。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="oh oi l"/></div></figure><h1 id="ba09" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">开发者体验</h1><p id="124c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Quarkus有几个特性可以增强开发人员的体验。特性包括<a class="ae mb" href="https://quarkus.io/guides/dev-mode-differences#dev-services" rel="noopener ugc nofollow" target="_blank">开发服务</a>、<a class="ae mb" href="https://quarkus.io/guides/dev-mode-differences#dev-ui" rel="noopener ugc nofollow" target="_blank">开发UI </a>、<a class="ae mb" href="https://quarkus.io/guides/dev-mode-differences#live-reload" rel="noopener ugc nofollow" target="_blank">无需重新构建和重启应用程序即可实时重新加载</a>代码、<a class="ae mb" href="https://quarkus.io/guides/continuous-testing#introduction" rel="noopener ugc nofollow" target="_blank">持续测试</a>在保存代码更改后立即运行测试、配置文件、Hibernate ORM、JUnit和放心集成。使用这些Quarkus特性，很容易开发和测试Quarkus应用程序。</p><h2 id="2ea9" class="mc kj it bd kk md me dn ko mf mg dp ks lj mh mi ku ln mj mk kw lr ml mm ky mn bi translated">配置描述文件</h2><p id="2ccc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">类似于Spring，Quarkus使用配置文件。根据<a class="ae mb" href="https://access.redhat.com/documentation/en-us/red_hat_build_of_quarkus/quarkus-2-7/guide/34313937-d855-48cd-b793-8db36fe92a8d#proc_using-configuration-profiles_quarkus-configuration-guide" rel="noopener ugc nofollow" target="_blank"> RedHat </a>，您可以根据您的环境使用不同的配置文件。配置文件使您能够在同一个<code class="fe oe of og nu b">application.properties</code>文件中拥有多个配置，并使用一个配置文件名在它们之间进行选择。Quarkus可识别三种默认配置文件:</p><ul class=""><li id="89f1" class="nf ng it lc b ld lw lg lx lj nh ln ni lr nj lv nk nl nm nn bi translated">开发:在开发模式下激活</li><li id="2162" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated">测试:运行测试时激活</li><li id="1878" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated">prod:不在开发或测试模式下运行时的默认概要文件</li></ul><p id="b084" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在<code class="fe oe of og nu b">application.properties</code>文件中，概要文件使用<code class="fe oe of og nu b">%environment.</code>格式作为前缀。例如，当定义Quarkus的日志级别为<code class="fe oe of og nu b">INFO</code>时，您添加了公共的<code class="fe oe of og nu b">quarkus.log.level=INFO</code>属性。然而，为了只将测试环境的日志级别更改为<code class="fe oe of og nu b">DEBUG</code>，对应于<code class="fe oe of og nu b">test</code>概要文件，您可以添加一个带有<code class="fe oe of og nu b">%test.</code>前缀的属性，比如<code class="fe oe of og nu b">%test.quarkus.log.level=DEBUG</code>。</p><h2 id="090c" class="mc kj it bd kk md me dn ko mf mg dp ks lj mh mi ku ln mj mk kw lr ml mm ky mn bi translated">开发服务</h2><p id="04ea" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Quarkus支持在开发和测试模式下自动提供未配置的服务，称为<a class="ae mb" href="https://quarkus.io/guides/dev-services" rel="noopener ugc nofollow" target="_blank">开发服务</a>。如果您包含了一个扩展，但没有对其进行配置，那么Quarkus将在后台使用测试容器自动启动相关服务，并连接您的应用程序以使用该服务。</p><p id="62f5" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在开发Quarkus应用程序时，您可以创建自己的本地PostgreSQL数据库，例如，使用Docker:</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="2a0f" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">以及相应的应用程序配置属性:</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="oh oi l"/></div></figure><h2 id="d45e" class="mc kj it bd kk md me dn ko mf mg dp ks lj mh mi ku ln mj mk kw lr ml mm ky mn bi translated">零配置数据库</h2><p id="8d9c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">或者，我们可以依靠<a class="ae mb" href="https://quarkus.io/guides/dev-services" rel="noopener ugc nofollow" target="_blank">开发服务</a>，使用被称为<a class="ae mb" href="https://quarkus.io/guides/datasource#dev-services" rel="noopener ugc nofollow" target="_blank">零配置设置</a>的特性。Quarkus为您提供开箱即用的零配置数据库；不需要数据库配置。Quarkus负责提供数据库，运行DDL和DML语句来创建数据库对象，并用测试数据填充数据库，最后，当开发或测试会话完成时，取消提供数据库容器。当应用程序中存在反应式或JDBC数据源扩展且尚未配置数据库URL时，将启用数据库开发服务。</p><p id="c4e9" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">使用<code class="fe oe of og nu b">quarkusDev</code> Gradle任务，我们可以启动应用程序运行，如下面的视频所示。请注意创建的两个新Docker容器。另外，注意项目的<code class="fe oe of og nu b">import.sql</code> SQL脚本是自动运行的，执行所有DDL和DML语句来准备和填充数据库。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="oo oi l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">使用“quarkusDev”Gradle任务在本地启动Quarkus应用程序的API</figcaption></figure><h2 id="6fb7" class="mc kj it bd kk md me dn ko mf mg dp ks lj mh mi ku ln mj mk kw lr ml mm ky mn bi translated">引导TICKIT数据库</h2><p id="c7b9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当使用带有Quarkus的Hibernate ORM时，我们有几个选项可以选择当Quarkus应用程序启动时如何处理数据库。这些是在application.properties文件中定义的。<code class="fe oe of og nu b"><a class="ae mb" href="https://quarkus.io/guides/hibernate-orm#quarkus-hibernate-orm_quarkus.hibernate-orm.database.generation" rel="noopener ugc nofollow" target="_blank">quarkus.hibernate-orm.database.generation</a></code>属性决定是否生成数据库模式。<code class="fe oe of og nu b">drop-and-create</code>是理想的开发模式，如上图。这个属性默认为<code class="fe oe of og nu b">none</code>，但是，如果Dev Services正在使用，并且没有其他管理模式的扩展，那么这个属性将默认为<code class="fe oe of og nu b">drop-and-create</code>。接受值:<code class="fe oe of og nu b">none</code>、<code class="fe oe of og nu b">create</code>、<code class="fe oe of og nu b">drop-and-create</code>、<code class="fe oe of og nu b">drop</code>、<code class="fe oe of og nu b">update</code>、<code class="fe oe of og nu b">validate</code>。对于开发和测试模式，我们使用默认值为<code class="fe oe of og nu b">drop-and-create</code>的开发服务。对于这篇文章，我们假设数据库和模式已经存在于产品中。</p><p id="b6eb" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">第二个属性<code class="fe oe of og nu b"><a class="ae mb" href="https://quarkus.io/guides/hibernate-orm#quarkus-hibernate-orm_quarkus.hibernate-orm.sql-load-script" rel="noopener ugc nofollow" target="_blank">quarkus.hibernate-orm.sql-load-script</a></code>提供了一个文件的路径，该文件包含Hibernate ORM启动时要执行的SQL语句。在开发和测试模式下，默认为<code class="fe oe of og nu b">import.sql</code>。只需在resources目录的根目录下添加一个<code class="fe oe of og nu b">import.sql</code>文件，Hibernate就会被启动，而无需设置这个属性。该项目包含一个<code class="fe oe of og nu b">import.sql</code>脚本来创建所有数据库对象和少量测试数据。您还可以为不同的配置文件显式设置不同的文件，并为属性添加配置文件前缀(例如，<code class="fe oe of og nu b">%dev.</code>或<code class="fe oe of og nu b">%test.</code>)。</p><pre class="mq mr ms mt gt nt nu nv nw aw nx bi"><span id="6ea7" class="mc kj it nu b gy ny nz l oa ob">%dev.<!-- -->quarkus.hibernate-orm.database.generation=drop-and-create<br/>%dev.<!-- -->quarkus.hibernate-orm.sql-load-script=import.sql</span></pre><p id="fc06" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">另一个选择是<a class="ae mb" href="https://quarkus.io/guides/flyway" rel="noopener ugc nofollow" target="_blank"> Flyway </a>，这是JVM环境中常用的流行数据库迁移工具。Quarkus为使用Flyway提供了一流的支持。</p><h1 id="4452" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">开发用户界面</h1><p id="9e6b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">根据<a class="ae mb" href="https://quarkus.io/guides/dev-ui" rel="noopener ugc nofollow" target="_blank">文档</a>，Quarkus现在附带了一个新的实验开发UI，默认情况下在<code class="fe oe of og nu b">/q/dev</code>的开发模式下可用(当你用Gradle的quarkusDev任务启动Quarkus时)。它允许您快速可视化当前加载的所有扩展，查看它们的状态并直接进入它们的文档。除了访问加载的扩展，您还可以在Dev UI中查看日志和运行测试。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi op"><img src="../Images/4fb9a0de61c4b8d8a06a602a30f27b4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5xo4tY3ioGbFPB1hwSIn0w.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">Quarkus开发UI显示日志和测试</figcaption></figure><h2 id="e2d6" class="mc kj it bd kk md me dn ko mf mg dp ks lj mh mi ku ln mj mk kw lr ml mm ky mn bi translated">配置</h2><p id="7ba4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">从Dev UI中，您可以访问和修改Quarkus应用程序的应用程序配置。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oq"><img src="../Images/e3567a66d23b3bacac17e7a2345d830a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NLFMOPXVSxWyP4S6LWam7w.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">Quarkus开发UI的配置编辑器</figcaption></figure><p id="c043" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">您还可以查看开发服务的配置，包括正在运行的容器和无配置数据库配置。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi or"><img src="../Images/dfd4593bdd839578eaaa5b0e435fd1a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C5tV5z4BuKKQyrN4ial39A.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">开发服务配置控制台</figcaption></figure><h2 id="be4c" class="mc kj it bd kk md me dn ko mf mg dp ks lj mh mi ku ln mj mk kw lr ml mm ky mn bi translated">Quarkus REST乐谱控制台</h2><p id="94fe" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">加载RESTEasy Reactive扩展后，您可以从开发UI访问Quarkus REST Score控制台。REST分数控制台通过分数和颜色编码显示端点性能:绿色、黄色或红色。RedHat最近发表了一篇博客，讨论评分过程以及如何优化性能端点。三项测量显示了REST反应式应用是否可以进一步优化。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oq"><img src="../Images/0392d4f229e9deb7bcfa1e0a02b6cc71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7RHaHyevgsQFjEq1w657rg.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">REST反应性应用终点的测量</figcaption></figure><h1 id="ca36" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">应用测试</h1><p id="07cd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Quarkus通过为<a class="ae mb" href="https://quarkus.io/guides/getting-started-testing" rel="noopener ugc nofollow" target="_blank">集成</a>提供通用测试框架，例如包括<a class="ae mb" href="https://junit.org/junit5/" rel="noopener ugc nofollow" target="_blank"> JUnit </a>、<a class="ae mb" href="https://site.mockito.org/" rel="noopener ugc nofollow" target="_blank"> Mockito </a>和<a class="ae mb" href="https://rest-assured.io/" rel="noopener ugc nofollow" target="_blank">放心</a>，来支持健壮的基于JVM的本地连续测试。Quarkus的许多测试特性都是通过注释实现的，比如<code class="fe oe of og nu b">QuarkusTestResource</code>、<code class="fe oe of og nu b">QuarkusTest</code>、<code class="fe oe of og nu b">QuarkusIntegrationTest</code>和<code class="fe oe of og nu b">TransactionalQuarkusTest</code>。</p><p id="711e" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">Quarkus通过两种不同的方法支持模拟对象的使用。您可以使用CDI替代方案来模拟所有测试类的bean，或者使用<code class="fe oe of og nu b"><a class="ae mb" href="https://quarkus.io/blog/mocking/" rel="noopener ugc nofollow" target="_blank">QuarkusMock</a></code>来模拟每个测试的bean。这包括与<a class="ae mb" href="https://site.mockito.org/" rel="noopener ugc nofollow" target="_blank"> Mockito </a>的集成。</p><p id="542a" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">放心集成对于测试Quarkus微服务API应用程序特别有用。根据他们的<a class="ae mb" href="https://rest-assured.io/" rel="noopener ugc nofollow" target="_blank">网站</a>，restassure是一个Java DSL，用于简化基于REST的服务的测试。它支持最常见的HTTP请求方法，可用于验证这些请求的响应。放心使用作为<a class="ae mb" href="http://dannorth.net/introducing-bdd/" rel="noopener ugc nofollow" target="_blank">行为驱动开发</a> (BDD)的一部分而流行的<code class="fe oe of og nu b">given()</code>、<code class="fe oe of og nu b">when()</code>、<code class="fe oe of og nu b">then()</code>测试方法。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">放心测试方法示例</figcaption></figure><p id="cc08" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">可以使用<code class="fe oe of og nu b">quarkusTest</code> Gradle任务运行测试。该应用程序包含少量的集成测试来演示这一特性。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oq"><img src="../Images/768c4d0a11965a58fcf3736a755a56f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EAAI9lIVx1mSY0h39lXUow.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">Quarkus应用测试结果报告</figcaption></figure><h1 id="9047" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">Swagger和OpenAPI</h1><p id="864e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Quarkus提供了符合<a class="ae mb" href="https://github.com/eclipse/microprofile-open-api/" rel="noopener ugc nofollow" target="_blank"> MicroProfile OpenAPI </a>规范的<a class="ae mb" href="https://github.com/smallrye/smallrye-open-api/" rel="noopener ugc nofollow" target="_blank"> Smallrye OpenAPI </a>扩展，允许您生成API <a class="ae mb" href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md" rel="noopener ugc nofollow" target="_blank"> OpenAPI v3规范</a>并公开<a class="ae mb" href="https://swagger.io/tools/swagger-ui/" rel="noopener ugc nofollow" target="_blank"> Swagger UI </a>。<code class="fe oe of og nu b"> /q/swagger-ui</code>资源公开了Swagger UI，允许您可视化Quarkus API的资源并与之交互，而无需任何实现逻辑。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oq"><img src="../Images/01f112393233d63bae994a7911a22b60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f_FM279Q6S68yUs_foTTLQ.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">展示Quarkus应用程序的API资源的Swagger UI</figcaption></figure><p id="c2f4" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">可以使用Swagger UI测试资源，而无需编写任何代码。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oq"><img src="../Images/9132f11176ed93ee31472be86583a204.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kcp-6Tq0PffDMK7KORjo8w.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">在Swagger UI中测试Quarkus应用程序的API资源</figcaption></figure><p id="b799" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">OpenAPI规范(以前称为Swagger规范)是REST APIs的一种API描述格式。<code class="fe oe of og nu b">/q/openapi</code>资源允许您生成一个<a class="ae mb" href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md" rel="noopener ugc nofollow" target="_blank"> OpenAPI v3规范</a>文件。OpenAPI文件允许你描述你的整个API。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi os"><img src="../Images/33441e782b55598c09a6c51c2eade2de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iHMWdGjXogyAvgnQY1PaGw.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">OpenAPI v3规范可通过Quarkus应用程序的API资源访问</figcaption></figure><p id="9082" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><a class="ae mb" href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md" rel="noopener ugc nofollow" target="_blank"> OpenAPI v3规范</a>可以保存为文件，并导入到像<a class="ae mb" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>这样的应用程序中，这是一个用于构建和使用API的API平台。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi os"><img src="../Images/7045c758404e09231c6a84c9c5743dc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K7tCKTQDFQM76GejG4j-Dg.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">将Quarkus微服务的OpenAPI文件导入Postman</figcaption></figure><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi os"><img src="../Images/e904f5eaed413118435b27e9f2eefeb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m8d4UTqSAsE8RRWrSZLr8g.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">在Postman中使用OpenAPI API规范与API的资源进行交互</figcaption></figure><h1 id="5991" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">具有GitHub操作的GitOps</h1><p id="0059" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在本文中，<a class="ae mb" href="https://about.gitlab.com/topics/gitops/" rel="noopener ugc nofollow" target="_blank"> GitOps </a>用于持续测试、构建、打包Quarkus微服务应用并将其部署到Kubernetes。具体来说，帖子使用了<a class="ae mb" href="https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions" rel="noopener ugc nofollow" target="_blank"> GitHub动作</a>。GitHub Actions是一个持续集成和持续交付(CI/CD)平台，允许您自动化您的构建、测试和部署管道。工作流是在存储库中的<code class="fe oe of og nu b">.github/workflows</code>目录中定义的，一个存储库可以有多个工作流，每个工作流可以执行一组不同的任务。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ot"><img src="../Images/0ce72d34dd21d839302de2c6413c706f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FUpUd5SQXPV79SY2_tLopA.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">GitHub行动工作流程的结果</figcaption></figure><p id="79ee" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">两个GitHub动作与这篇文章的GitHub库相关联。第一个动作，<code class="fe oe of og nu b">build-test.yml</code>，在每次推送GitHub时，在本地心轴容器中本地构建和测试源代码。第二个动作(<em class="mo">如下图所示</em>)，<code class="fe oe of og nu b">docker-build-push.yml</code>，构建并封装本机构建的可执行文件，将其推送到Docker的容器注册表(<a class="ae mb" href="https://hub.docker.com/r/garystafford/tickit-srv/tags" rel="noopener ugc nofollow" target="_blank"> docker.io </a>)，最后将应用程序部署到Kubernetes。这个动作是通过将新的<a class="ae mb" href="https://git-scm.com/book/en/v2/Git-Basics-Tagging" rel="noopener ugc nofollow" target="_blank"> Git标签</a>推送到GitHub来触发的。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ot"><img src="../Images/f8e6518d5753534d493af3b5728a6ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Npv_tKk11llAlYLiHHT8A.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">与触发部署的Quarkus应用程序相关联的Git标记</figcaption></figure><p id="7f89" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">动作的构建步骤中包含了几个Quarkus配置属性。或者，这些属性可以在<code class="fe oe of og nu b">application.properties</code>文件中定义。然而，我已经决定将它们作为Gradle构建任务的一部分，因为它们是特定于构建类型和容器注册表以及我正在推送到工件的Kubernetes平台的。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="oh oi l"/></div></figure><h2 id="1133" class="mc kj it bd kk md me dn ko mf mg dp ks lj mh mi ku ln mj mk kw lr ml mm ky mn bi translated">库伯内特资源公司</h2><p id="cf1a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">由Quarkus build创建的Kubernetes resources YAML文件也通过GitHub操作的最后一步上传并保存为GitHub中的工件。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ot"><img src="../Images/eab5493101cc49015d6eb039c2ab8e7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E0cy3hsGNfID_ATnbcNKeA.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">Kubernetes文件保存为GitHub操作工件以供参考</figcaption></figure><p id="7885" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">Quarkus自动生成<code class="fe oe of og nu b">ServiceAccount</code>、<code class="fe oe of og nu b">Role</code>、<code class="fe oe of og nu b">RoleBinding</code>、<code class="fe oe of og nu b">Service</code>、<code class="fe oe of og nu b">Deployment</code>资源。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">Kubernetes资源YAML文件由Quarkus自动生成</figcaption></figure><h2 id="1291" class="mc kj it bd kk md me dn ko mf mg dp ks lj mh mi ku ln mj mk kw lr ml mm ky mn bi translated">选择Kubernetes平台</h2><p id="6ce9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">唯一特定于云提供商的代码在第二个GitHub动作中。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="ce81" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在这种情况下，应用程序被部署到现有的<a class="ae mb" href="https://aws.amazon.com/eks/" rel="noopener ugc nofollow" target="_blank"> Amazon Elastic Kubernetes服务</a> (Amazon EKS)，这是AWS提供的一个完全托管的、经过认证的符合Kubernetes的服务。这些步骤可以很容易地替换为部署到其他云平台的步骤，如微软的Azure Kubernetes服务或谷歌云的谷歌Kubernetes引擎。</p><h2 id="e7e7" class="mc kj it bd kk md me dn ko mf mg dp ks lj mh mi ku ln mj mk kw lr ml mm ky mn bi translated">GitHub秘密</h2><p id="a65b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一些属性使用GitHub环境变量，其他属性使用安全的GitHub <a class="ae mb" href="https://docs.github.com/en/actions/security-guides/encrypted-secrets#creating-encrypted-secrets-for-a-repository" rel="noopener ugc nofollow" target="_blank">存储库加密秘密</a>。使用<code class="fe oe of og nu b"><a class="ae mb" href="https://github.com/kodermax/kubectl-aws-eks" rel="noopener ugc nofollow" target="_blank">kodermax/kubectl-aws-eks@master</a></code> GitHub操作时，使用秘密来保护Docker凭证(用于将Quarkus应用程序映像推送到Docker的映像存储库)、AWS IAM凭证以及部署到AWS上的Kubernetes所需的<code class="fe oe of og nu b"><a class="ae mb" href="https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html" rel="noopener ugc nofollow" target="_blank">kubeconfig</a></code>文件的base64编码内容。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ot"><img src="../Images/426dff3dd8f258abd5bc07d51f795fd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BKDgkDu7X6T_qEVsl7j7sA.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">GitHub secure GitHub为GitHub操作加密的存储库机密</figcaption></figure><h2 id="60f1" class="mc kj it bd kk md me dn ko mf mg dp ks lj mh mi ku ln mj mk kw lr ml mm ky mn bi translated">码头工人</h2><p id="73b7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">查看包含在动作构建步骤中的配置属性，注意用于构建本地Quarkus应用程序<code class="fe oe of og nu b"><a class="ae mb" href="https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags&amp;tag=22.1.0.0-Final-java17" rel="noopener ugc nofollow" target="_blank">quay.io/quarkus/ubi-quarkus-mandrel:22.1.0.0-Final-java17</a></code>的心轴容器。此外，请注意，项目的Docker文件用于构建最终的Docker映像，将其推送到映像存储库，然后用于在Kubernetes，<code class="fe oe of og nu b">src/main/docker/Dockerfile.native-micro</code>上提供容器。这个Dockerfile文件使用<code class="fe oe of og nu b"><a class="ae mb" href="https://quay.io/repository/quarkus/quarkus-micro-image?tab=tags&amp;tag=1.0" rel="noopener ugc nofollow" target="_blank">quay.io/quarkus/quarkus-micro-image:1.0</a></code>基础映像来封装本地Quarkus应用程序。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="4b02" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这些属性还定义了图像的存储库名称和标签(例如<code class="fe oe of og nu b">garystafford/tickit-srv:1.1.0</code>)。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oq"><img src="../Images/862c9fba01c062d83a35482d47a5bf84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6xNIghAu9wHXdaL38Va_Bw.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">显示Quarkus应用程序映像的Docker映像注册表</figcaption></figure><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oq"><img src="../Images/773509dca245db83ab3f9ea96ff2ef62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-4vysRpSrG-NG8eQmrCVyw.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">显示最新Quarkus应用程序图像标签的Docker图像注册表</figcaption></figure><h1 id="f450" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">库伯内特斯</h1><p id="6f69" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">除了预先创建<code class="fe oe of og nu b">ticket</code>名称空间之外，Kubernetes的一个秘密被预先部署到<code class="fe oe of og nu b">ticket</code>名称空间。GitHub动作还需要一个角色和角色绑定来将工作负载部署到Kubernetes集群。最后，HorizontalPodAutoscaler (HPA)用于自动扩展工作负载。</p><pre class="mq mr ms mt gt nt nu nv nw aw nx bi"><span id="d03a" class="mc kj it nu b gy ny nz l oa ob">export NAMESPACE=tickit</span><span id="437c" class="mc kj it nu b gy ou nz l oa ob"># Namespace<br/>kubectl create namespace ${NAMESPACE}</span><span id="9a40" class="mc kj it nu b gy ou nz l oa ob"># Role and RoleBinding for GitHub Actions to deploy to Amazon EKS<br/>kubectl apply -f kubernetes/github_actions_role.yml -n ${NAMESPACE}</span><span id="2aff" class="mc kj it nu b gy ou nz l oa ob"># Secret<br/>kubectl apply -f kubernetes/secret.yml -n ${NAMESPACE}</span><span id="433b" class="mc kj it nu b gy ou nz l oa ob"># HorizontalPodAutoscaler (HPA)<br/>kubectl apply -f kubernetes/tickit-srv-hpa.yml -n ${NAMESPACE}</span></pre><p id="6e55" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">作为动作构建步骤中包含的配置属性的一部分，请注意使用了<a class="ae mb" href="https://kubernetes.io/docs/concepts/configuration/secret/" rel="noopener ugc nofollow" target="_blank"> Kubernetes secrets </a>。</p><pre class="mq mr ms mt gt nt nu nv nw aw nx bi"><span id="a5f5" class="mc kj it nu b gy ny nz l oa ob">-Dquarkus.kubernetes-config.secrets=tickit<br/>-Dquarkus.kubernetes-config.secrets.enabled=true</span></pre><p id="c3cd" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">此机密包含base64编码的敏感凭据和连接值，用于连接到生产PostgreSQL数据库。对于这篇文章，我已经预先构建了一个用于PostgreSQL的<a class="ae mb" href="https://aws.amazon.com/rds/postgresql/?p=pm&amp;c=rds&amp;z=2" rel="noopener ugc nofollow" target="_blank">Amazon RDS</a>数据库实例，创建了门票数据库和所需的数据库对象，最后，导入GitHub存储库中包含的示例数据<code class="fe oe of og nu b"><a class="ae mb" href="https://github.com/garystafford/tickit-srv-data" rel="noopener ugc nofollow" target="_blank">garystafford/tickit-srv-data</a></code>。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">帖子中使用的Kubernetes秘密示例</figcaption></figure><p id="4902" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在Secret中看到的五个密钥在<code class="fe oe of og nu b">application.properties</code>文件中使用，以提供从Quakus应用程序到生产PostgreSQL数据库的访问。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="7707" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在亚马逊EKS上使用Kubernetes secrets的一个更好的替代方案是<a class="ae mb" href="https://github.com/aws/secrets-store-csi-driver-provider-aws" rel="noopener ugc nofollow" target="_blank"> AWS Secrets和为<a class="ae mb" href="https://secrets-store-csi-driver.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes Secrets Store CSI驱动程序</a>提供配置的提供商</a> (ASCP)。<a class="ae mb" href="https://aws.amazon.com/secrets-manager/" rel="noopener ugc nofollow" target="_blank"> AWS Secrets Manager </a>将秘密作为文件存储在亚马逊EKS pod中。</p><h1 id="a1e7" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">AWS架构</h1><p id="e97a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">GitHub动作将应用程序的映像推送到Docker的容器注册表(<a class="ae mb" href="https://hub.docker.com/r/garystafford/tickit-srv/tags" rel="noopener ugc nofollow" target="_blank"> docker.io </a>)，然后将应用程序部署到Kubernetes。或者，您可以使用AWS的Amazon弹性容器注册中心(Amazon ECR)。亚马逊EKS在创建Kubernetes Pod容器时从Docker中提取图像。</p><p id="676b" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">有许多方法可以将流量从请求者路由到Kubernetes上运行的Quarkus应用程序。在这篇文章中，Quarkus应用程序被公开为一个<a class="ae mb" href="https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport" rel="noopener ugc nofollow" target="_blank">节点端口</a>上的<a class="ae mb" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank"> Kubernetes服务</a>。对于这篇文章，我已经用<a class="ae mb" href="https://aws.amazon.com/route53/" rel="noopener ugc nofollow" target="_blank"> Amazon Route 53 </a>注册了一个域名<code class="fe oe of og nu b">example-api.com</code>，并用<a class="ae mb" href="https://aws.amazon.com/certificate-manager/" rel="noopener ugc nofollow" target="_blank"> AWS证书管理器</a>注册了一个相应的TLS证书。使用HTTPS或端口443将Quarkus应用程序的入站请求定向到子域<code class="fe oe of og nu b">ticket.example-api.com</code>。Amazon Route 53将这些请求路由到第7层<a class="ae mb" href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/introduction.html" rel="noopener ugc nofollow" target="_blank">应用负载平衡器</a> (ALB)。然后，ALB使用简单的循环负载平衡将这些请求路由到节点端口上的亚马逊EKS Kubernetes集群。Kubernetes会自动将请求路由到适当的工作节点和Kubernetes pod。然后，响应通过类似的路径返回给请求者。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mp"><img src="../Images/71989ddfdd0b278c48db7b9339fadf2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Ujv7saBt5anvZ2i5wSEYw.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">Quarkus应用程序生产环境的高级AWS架构图</figcaption></figure><h1 id="a32c" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">结果</h1><p id="fc57" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果GitHub动作成功，任何对GitHub的代码修改都会导致应用程序部署到Kubernetes。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ov"><img src="../Images/1d674ab76e6eeb80d14f8b470f710ff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dAQWxciJmrQIyW_vI__2oQ.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">部署到Kubernetes集群中的票证名称空间的资源</figcaption></figure><p id="a76e" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们还可以使用Kubernetes仪表板查看部署的Quarkus应用程序资源。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oq"><img src="../Images/ea6ee4648a9a2164f33b28982bc50217.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ufpoBYiU6zuW4Wt0X0m1Aw.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">在Kubernetes仪表板中查看的Quarkus应用程序窗格</figcaption></figure><h1 id="92ad" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">韵律学</h1><p id="c773" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">post的Quarkus应用程序实现了<code class="fe oe of og nu b"><a class="ae mb" href="https://quarkus.io/guides/micrometer" rel="noopener ugc nofollow" target="_blank">micrometer-registry-prometheus</a></code>扩展。微米度量库公开了运行时和应用度量。<a class="ae mb" href="https://micrometer.io/" rel="noopener ugc nofollow" target="_blank">千分尺</a>定义了一个核心库，提供了度量和核心度量类型的注册机制。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ot"><img src="../Images/ffe409919ce7121494872b16ef953bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KBcv9SNKDLq5DvRUunoL7A.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">Quarkus应用程序API的指标资源公开的指标示例</figcaption></figure><p id="7134" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">使用千分尺扩展，度量资源在<code class="fe oe of og nu b">/q/metrics</code>被暴露，它可以被工具如<a class="ae mb" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank">普罗米修斯</a>抓取和可视化。AWS为Prometheus (AMP) 提供完全托管的<a class="ae mb" href="https://docs.aws.amazon.com/grafana/latest/userguide/prometheus-data-source.html" rel="noopener ugc nofollow" target="_blank">亚马逊托管服务，可以轻松与亚马逊EKS整合。</a></p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oq"><img src="../Images/303ebefbbd2a4058d3ded0bd90792287.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mEzrys9LGBTBiNTkg_sc1w.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">Prometheus从Quarkus应用程序中抓取的HTTP服务器请求图</figcaption></figure><p id="76cf" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">使用Prometheus作为数据源，我们可以在<a class="ae mb" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank"> Grafana </a>中构建仪表板来观察Quarkus应用程序指标。与AMP类似，AWS提供其完全托管的<a class="ae mb" href="https://aws.amazon.com/grafana/" rel="noopener ugc nofollow" target="_blank">亚马逊托管的Grafana </a> (AMG)。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ot"><img src="../Images/ae4580348069174b33e8d6e54da73eb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SDfNOy2TWXTHJKwU-cx9Xg.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">通过Prometheus利用Quarkus应用指标构建的Grafana仪表板示例</figcaption></figure><h1 id="bf21" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">集中式日志管理</h1><p id="2e32" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">根据Quarkus <a class="ae mb" href="https://quarkus.io/guides/logging#logging-adapters" rel="noopener ugc nofollow" target="_blank">文档</a>，在内部，Quarkus使用<a class="ae mb" href="https://access.redhat.com/documentation/en-us/red_hat_build_of_quarkus/1.11/html/configuring_logging_with_quarkus/con-jboss-logmanager-and-supported-logging-frameworks_quarkus-configuring-logging" rel="noopener ugc nofollow" target="_blank"> JBoss日志管理器</a>和JBoss日志门面。您可以在代码中使用JBoss日志facade或任何支持的日志API，包括JDK <code class="fe oe of og nu b">java.util.logging</code>(又名JUL)、<a class="ae mb" href="https://github.com/jboss-logging/jboss-logging" rel="noopener ugc nofollow" target="_blank"> JBoss日志</a>、<a class="ae mb" href="https://www.slf4j.org/" rel="noopener ugc nofollow" target="_blank"> SLF4J </a>和<a class="ae mb" href="https://commons.apache.org/proper/commons-logging/" rel="noopener ugc nofollow" target="_blank"> Apache Commons日志</a>。Quarkus会将它们发送给JBoss日志管理器。</p><p id="0fad" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">有许多方法可以集中日志。例如，您可以将这些日志发送到开源的集中式日志管理系统，如<a class="ae mb" href="https://www.graylog.org/" rel="noopener ugc nofollow" target="_blank"> Graylog </a>、<a class="ae mb" href="https://www.elastic.co/elastic-stack/" rel="noopener ugc nofollow" target="_blank"> Elastic Stack </a>、fka <a class="ae mb" href="https://www.elastic.co/elastic-stack/" rel="noopener ugc nofollow" target="_blank"> ELK </a> (Elasticsearch、Logstash、Kibana)、<a class="ae mb" href="https://docs.fluentd.org/v/0.12/articles/docker-logging-efk-compose" rel="noopener ugc nofollow" target="_blank"> EFK </a> (Elasticsearch、Fluentd、Kibana)，以及带有<a class="ae mb" href="https://fluentbit.io/" rel="noopener ugc nofollow" target="_blank"> Fluent Bit </a>的<a class="ae mb" href="https://opensearch.org/" rel="noopener ugc nofollow" target="_blank"> OpenSearch </a>。</p><p id="17e0" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">如果您使用Kubernetes，最简单的方法是将日志发送到控制台，并在集群中集成一个中央日志管理器。由于本文中的Quarkus应用程序运行在亚马逊EKS上，所以我选择了带有<a class="ae mb" href="https://fluentbit.io/" rel="noopener ugc nofollow" target="_blank"> Fluent Bit </a>的<a class="ae mb" href="https://aws.amazon.com/opensearch-service" rel="noopener ugc nofollow" target="_blank">亚马逊OpenSearch服务</a>，这是一个开源的多平台日志处理器和转发器。Fluent Bit完全兼容Docker和Kubernetes环境。亚马逊提供了一个关于使用Fluent Bit安装和配置亚马逊OpenSearch服务的<a class="ae mb" href="https://www.eksworkshop.com/intermediate/230_logging/" rel="noopener ugc nofollow" target="_blank">优秀研讨会</a>。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oq"><img src="../Images/2c7e1d979505f2a380a0ce1ad390f385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qa_jmwMv8I5C0KyPpePSSg.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">Amazon OpenSearch显示了Quarkus应用程序的调试日志</figcaption></figure><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oq"><img src="../Images/fef9393b1d715a28abe9104e7741fa8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tihUJZtXiZXfndk3ZL55pw.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">Amazon OpenSearch日志过滤了Quarkus应用程序抛出的错误</figcaption></figure><h1 id="75e7" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">结论</h1><p id="0d66" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">正如我们在这篇文章中了解到的，Quarkus，即“超音速亚原子Java”框架，是一个用于编写Java应用程序的云原生、Kubernetes原生、容器优先、微服务优先的框架。我们观察了如何构建、测试和部署一个RESTful Quarkus本地应用程序到Kubernetes。</p><p id="77f3" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">Quarkus的功能和特性远远超出了本文的范围。在未来的帖子中，我们将探索Quarkus的其他功能，包括可观察性、GraphQL集成、缓存、数据库代理、跟踪和调试、消息队列、数据管道和流分析。</p></div><div class="ab cl ow ox hx oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="im in io ip iq"><p id="dc6f" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">本博客代表我自己的观点，不代表我的雇主亚马逊网络服务公司(AWS)的观点。所有产品名称、徽标和品牌都是其各自所有者的财产。所有图表和插图都是作者的财产。</p></div></div>    
</body>
</html>