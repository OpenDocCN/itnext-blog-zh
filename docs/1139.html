<html>
<head>
<title>What’s the deal with functional components in Vue.js?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue.js中的功能组件是怎么处理的？</h1>
<blockquote>原文：<a href="https://itnext.io/whats-the-deal-with-functional-components-in-vue-js-513a31eb72b0?source=collection_archive---------1-----------------------#2018-07-28">https://itnext.io/whats-the-deal-with-functional-components-in-vue-js-513a31eb72b0?source=collection_archive---------1-----------------------#2018-07-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="26a7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">弄清楚Vue.js功能组件的内容、原因、时间和方式。</h2></div><p id="b861" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我花了几天时间试图理解Vue.js中的功能组件。也许对于具有React或Angular背景的人来说，它们是一种熟悉的模式，但我发现即使是一些基本问题的答案，例如:</p><ul class=""><li id="b11a" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">什么是功能组件？</li><li id="b6bf" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">我为什么要在乎？</li><li id="775b" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">我应该什么时候使用它们？</li></ul><p id="2b89" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有点难以捉摸。所以，我花了很多时间在Vue文档的这个页面和其他一些分散的资源上，以弄清事情的真相。</p><h1 id="922e" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">什么是功能组件？</h1><p id="1896" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">我最初被这个名字吸引住了:“<strong class="kh ir">功能性</strong>组件。”我天真地认为这听起来像是一个用来做某事的组件，而不是UI的一部分。虽然这是功能组件的一种类型(委托或修饰其他组件的“高级组件”或“包装组件”)，但还有另一种更简单的类型:哑组件。我称它们是哑的，因为它们没有自己的数据(它们是<em class="mn">无状态</em>)，也没有自己的方法，甚至没有实例(意思是没有<code class="fe mo mp mq mr b">this</code>，也没有生命周期)。</p><h1 id="e4e5" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">我为什么要在乎？</h1><p id="344b" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">使用功能组件，您可以获得组件的组织性、干燥的好处，而没有Vue的反应系统的开销。这可以提高你的应用程序的性能。</p><h1 id="db1a" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">什么时候应该使用功能组件？</h1><p id="a8db" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">任何时候你的应用程序不需要自己的反应数据，也不需要拥有任何方法，但是你仍然想要一个组件提供的可重用的、隔离的代码块的便利，考虑一个功能组件。</p><p id="7fe9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，在回答了这些基本问题之后，我开始了一个更复杂的问题:</p><h1 id="00d9" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">我如何构建功能组件？</h1><p id="d980" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">为了深入了解这一点，我决定以4种不同的方式构建相同的组件:</p><ul class=""><li id="05e6" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">标准的普通单文件组件(SFC)</li><li id="8007" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">用渲染函数(RF)而不是模板构建的标准组件</li><li id="db90" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">用渲染函数构建的功能组件</li><li id="08da" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">一个功能单一的文件组件(在模板上使用<code class="fe mo mp mq mr b">functional</code>关键字)</li></ul><p id="8fdb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的示例有些做作，目的是探索各种常见组件功能，包括:</p><ul class=""><li id="a953" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">触发事件</li><li id="9dfd" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">使用插槽</li><li id="1e8d" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">使用道具</li><li id="99e6" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">带v-if和v-for的逻辑</li></ul><p id="84e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个组件将:</p><ul class=""><li id="5d44" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">输出一个包含一个<code class="fe mo mp mq mr b">img</code>和一个<code class="fe mo mp mq mr b">figcaption</code>以及一组标签的<code class="fe mo mp mq mr b">figure</code>。</li><li id="7353" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">接受一个“类型”属性，它将决定一个类/样式和不同的标记。</li><li id="535d" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">发出click事件，该事件将触发组件节点上指定的方法。</li></ul><p id="1299" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lp" href="http://norabrowndesign.com/vue/functional/" rel="noopener ugc nofollow" target="_blank">最终结果看起来像这样</a>:</p><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ms"><img src="../Images/862418a7806b803501b537e0a40d6029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wEG0aWQ1nWNPooZ0CAST3A.jpeg"/></div></div></figure><p id="c738" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是App.vue文件的代码:</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2d0d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它非常标准，包括:</p><ol class=""><li id="0490" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la ng lh li lj bi translated">使用4个组件中每一个组件的模板</li><li id="d5a4" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la ng lh li lj bi translated">一个脚本块，它导入组件，并用这些组件和一些方法实例化App Vue实例</li><li id="a7b3" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la ng lh li lj bi translated">一个样式块(我在样式上走得太远了，参见Github 上的<a class="ae lp" href="https://github.com/nabrown/vue-functional-examples/blob/master/src/App.vue" rel="noopener ugc nofollow" target="_blank">完整源代码)。)</a></li></ol><h2 id="8f50" class="nh lr iq bd ls ni nj dn lw nk nl dp ma ko nm nn mc ks no np me kw nq nr mg ns bi translated">首先:一个标准的单个文件组件</h2><p id="e7db" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">组件的第一个版本是标准的<a class="ae lp" href="https://vuejs.org/v2/guide/single-file-components.html" rel="noopener ugc nofollow" target="_blank">单文件组件</a>:</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">第一个版本是标准的单个文件组件</figcaption></figure><p id="b253" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们正在指定我们想要的标记，并使用我们传入的属性，我们已经定义了一些验证。唯一值得注意的是使用<code class="fe mo mp mq mr b">v-on:click="$emit('click’)"</code>来发出一个点击事件(因为我们希望被触发的方法存在于App组件上，而不是这个子组件上)，并使用<code class="fe mo mp mq mr b">v-if="$slots.default"</code>来检测是否有任何东西(在我们的例子中，是一个标题)被传递来填充默认槽(<a class="ae lp" href="https://vuejs.org/v2/api/#vm-slots" rel="noopener ugc nofollow" target="_blank">参见</a> <code class="fe mo mp mq mr b"><a class="ae lp" href="https://vuejs.org/v2/api/#vm-slots" rel="noopener ugc nofollow" target="_blank">vm.$slots</a></code> <a class="ae lp" href="https://vuejs.org/v2/api/#vm-slots" rel="noopener ugc nofollow" target="_blank">文档</a>)。如果不是，我们不显示包装默认槽的<code class="fe mo mp mq mr b">figcaption</code>标记。</p><h2 id="7b60" class="nh lr iq bd ls ni nj dn lw nk nl dp ma ko nm nn mc ks no np me kw nq nr mg ns bi translated">接下来:使用渲染函数的标准组件</h2><p id="06f1" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">下一种方法是使用渲染函数而不是模板的标准组件。</p><p id="be05" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然功能组件和渲染功能的概念实际上是完全分开的，但它们在Vue.js文档中是紧密相关的(功能组件的解释嵌套在<a class="ae lp" href="https://vuejs.org/v2/guide/render-function.html" rel="noopener ugc nofollow" target="_blank">‘渲染功能&amp;JSX’页面</a>中)，我在那里看到的功能组件与传统模板的例子非常少。所以，我们最好也弄清楚渲染函数。</p><p id="a421" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码如下:</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">第二个版本，使用渲染函数的标准组件</figcaption></figure><p id="3da3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最大的变化显然是模板不见了，取而代之的是一个渲染属性。它的值是<code class="fe mo mp mq mr b">render(createElement){}</code>函数。<code class="fe mo mp mq mr b">createElement</code>是我们可以在render函数中使用的函数，用来构建虚拟DOM节点树(VNodes ),最终由Vue添加到实际的DOM中。</p><p id="b462" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mo mp mq mr b"><a class="ae lp" href="https://vuejs.org/v2/guide/render-function.html#createElement-Arguments" rel="noopener ugc nofollow" target="_blank">createElement</a></code> <a class="ae lp" href="https://vuejs.org/v2/guide/render-function.html#createElement-Arguments" rel="noopener ugc nofollow" target="_blank">函数有3个参数</a>:</p><ol class=""><li id="0b6e" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la ng lh li lj bi translated">要创建的html元素的字符串</li><li id="9343" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la ng lh li lj bi translated">一个<code class="fe mo mp mq mr b">data</code>对象，指定VNode的所有不同属性</li><li id="6364" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la ng lh li lj bi translated">以及将由创建的元素包装的字符串数组(用于文本节点)或其他VNodes。</li></ol><p id="1242" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在上面的渲染函数中看到，创建一棵相对较小的树也是一个非常痛苦的过程。在本例中，我们:</p><ol class=""><li id="44b3" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la ng lh li lj bi translated">创建<code class="fe mo mp mq mr b">img</code>元素</li><li id="6b0e" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la ng lh li lj bi translated">如果缺省槽中有内容，则创建<code class="fe mo mp mq mr b">figcaption</code>元素</li><li id="f2cd" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la ng lh li lj bi translated">如果标签作为属性传递，则创建标签标记</li><li id="b361" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la ng lh li lj bi translated">将上述所有内容以数组形式作为第三个参数传递给我们对<code class="fe mo mp mq mr b">createElement</code>的最后一个调用，该调用返回包装<code class="fe mo mp mq mr b">figure</code>元素的VNode。</li></ol><p id="76f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">咻。</p><p id="8002" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为这只是一个标准组件，它有一个实例，我们可以使用<code class="fe mo mp mq mr b">this</code>来访问我们的<code class="fe mo mp mq mr b">props</code>和<code class="fe mo mp mq mr b">$slots</code>。为了从我们的模板中实现<code class="fe mo mp mq mr b">v-if</code>的行为，我们手动检查<code class="fe mo mp mq mr b">this.$slots.default</code>，如果它不存在就返回一个空字符串。我们在模板中使用了<code class="fe mo mp mq mr b">v-for</code>，这里我们使用<code class="fe mo mp mq mr b">Array.map</code>为每个标签返回一个单独的<code class="fe mo mp mq mr b">span</code> VNode。<em class="mn">累死人</em>，老实说。</p><p id="886c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用JSX 重新引入类似模板的语法，这看起来有点疯狂，但在某些情况下可能是有意义的。</p><h2 id="ba6e" class="nh lr iq bd ls ni nj dn lw nk nl dp ma ko nm nn mc ks no np me kw nq nr mg ns bi translated">第三:使用渲染函数的功能组件</h2><p id="c353" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">第三个版本是我们的第一个功能组件，您可以通过<code class="fe mo mp mq mr b">functional: true</code>属性看出:</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">第三个版本，使用渲染函数的功能组件</figcaption></figure><p id="cdc6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个组件还使用了一个render函数，它看起来与前一个类似，但是有一些重要的区别。我们不使用<code class="fe mo mp mq mr b">this</code>，而是使用提供给渲染函数的第二个参数<code class="fe mo mp mq mr b">context</code>。使用<a class="ae lp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Unpacking_fields_from_objects_passed_as_function_parameter" rel="noopener ugc nofollow" target="_blank">对象析构</a>，我们从<code class="fe mo mp mq mr b">context</code>对象中取出我们需要的属性:<code class="fe mo mp mq mr b">props</code>、<code class="fe mo mp mq mr b">listeners</code>和<code class="fe mo mp mq mr b">slots</code>。</p><p id="0290" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mo mp mq mr b">Slots</code>是一个函数，它返回一个带有不同插槽的对象，所以之前我们使用了<code class="fe mo mp mq mr b">$slots.default</code>，现在我们可以使用<code class="fe mo mp mq mr b">slots().default</code>。</p><p id="af7e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于<code class="fe mo mp mq mr b">context</code>对象的两个属性，有一些深奥的东西需要注意。一、<code class="fe mo mp mq mr b">children</code>和<code class="fe mo mp mq mr b">slots()</code>给你类似，但略有不同的东西。<a class="ae lp" href="https://vuejs.org/v2/guide/render-function.html#slots-vs-children" rel="noopener ugc nofollow" target="_blank">在这里阅读区别</a>。二、<code class="fe mo mp mq mr b">listeners</code>是<code class="fe mo mp mq mr b">data.on</code>的别名。</p><h2 id="2488" class="nh lr iq bd ls ni nj dn lw nk nl dp ma ko nm nn mc ks no np me kw nq nr mg ns bi translated">最后的最佳:一个功能性的单文件组件</h2><p id="8f90" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">最后一个版本也是一个单文件组件，但是这次使用了<code class="fe mo mp mq mr b">functional</code>关键字。这是最难挖掘信息的一个，但最终。文档中提到了<code class="fe mo mp mq mr b">functional</code>关键字，但只是顺便提及，没有太多细节(太不符合角色性格了！).在vue-loader文档中有这个诱人的片段。</p><p id="0e75" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将其与第一个标准组件版本进行比较:</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">上一个版本是一个功能性的单文件组件</figcaption></figure><p id="b654" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是并列的主要区别:</p><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nx"><img src="../Images/1b66753764d3f8326a2aebf390c69ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FF1riu2_4VNBVDSOIJEThQ.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">左边是标准单文件组件，右边是功能性单文件组件。</figcaption></figure><p id="d87d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">差异的产生是因为功能组件的无实例性。没有实例，我们就不能简单地使用我们的专有名称，或<code class="fe mo mp mq mr b">$slots</code>，这是一个实例属性。但是，和上面的版本3一样，我们可以访问render <code class="fe mo mp mq mr b">context</code>对象，正如我们之前看到的，它有一个<code class="fe mo mp mq mr b">props</code>对象、一个<code class="fe mo mp mq mr b">listeners</code>对象和一个<code class="fe mo mp mq mr b">slots()</code>函数。</p><p id="3cfb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于大多数哑组件，这种语法可能是最容易编写和理解的。您仍然有一个相当简单的、类似html的模板，如果稍微详细一点的话，并且顶部的<code class="fe mo mp mq mr b">functional</code>关键字立刻标识了这个组件。因此，您可以获得单个文件组件的优势，而没有成熟的Vue组件的开销。#胜利。</p><h1 id="7857" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">结论</h1><p id="b2d6" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">事实证明，我一直在开发的应用程序充满了愚蠢组件的候选:小但经常重复的部分，如按钮、表单输入、徽章。对于任何您希望可重用但不需要自己的反应数据的部分，带有<code class="fe mo mp mq mr b">functional</code>关键字的sfc是一个不错的选择。使用功能组件可以提高应用程序的性能，将它们编写为单个文件组件可以使它们易于阅读，并与其他组件更加一致。</p><p id="8395" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果您需要的控制级别在普通模板中是不可用的(或者更有可能是非常冗长的)，那么render函数可能是解决方案。我见过的大多数例子都涉及基于大量条件逻辑的html输出，这将是重复的，很难以模板形式阅读。</p><p id="85c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">思想？</strong>留下善意的评论。既然你已经走了这么远，不如鼓掌一两下吧？</p><h2 id="ad70" class="nh lr iq bd ls ni nj dn lw nk nl dp ma ko nm nn mc ks no np me kw nq nr mg ns bi translated">有用的链接</h2><ul class=""><li id="7f2e" class="lb lc iq kh b ki mi kl mj ko ny ks nz kw oa la lg lh li lj bi translated"><a class="ae lp" href="https://github.com/nabrown/vue-functional-examples" rel="noopener ugc nofollow" target="_blank">Github上的所有代码</a></li><li id="1bc1" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae lp" href="http://norabrowndesign.com/vue/functional/" rel="noopener ugc nofollow" target="_blank">最终结果</a></li><li id="2d27" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae lp" href="https://www.youtube.com/watch?v=KS4eizPXRCQ" rel="noopener ugc nofollow" target="_blank">Dan Aprahamian关于渲染功能的视频</a>。</li><li id="8e3f" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae lp" href="https://www.youtube.com/watch?v=8vp5OXcbM34" rel="noopener ugc nofollow" target="_blank">埃里克·汉切特的另一封信</a></li><li id="7e2d" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae lp" href="https://vuejs.org/v2/guide/render-function.html" rel="noopener ugc nofollow" target="_blank">在Vue.js上渲染函数</a></li><li id="bd77" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae lp" href="https://vuejs.org/v2/guide/render-function.html#Functional-Components" rel="noopener ugc nofollow" target="_blank">vue . js上的功能组件</a>(同上)</li><li id="51b5" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae lp" href="https://alligator.io/vuejs/functional-components/" rel="noopener ugc nofollow" target="_blank">关于功能组件的Alligator.io文章</a></li></ul></div></div>    
</body>
</html>