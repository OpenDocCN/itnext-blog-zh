<html>
<head>
<title>Testing Kubernetes Operators with Ginkgo, Gomega and the Operator Runtime</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Ginkgo、Gomega和操作符运行时测试Kubernetes操作符</h1>
<blockquote>原文：<a href="https://itnext.io/testing-kubernetes-operators-with-ginkgo-gomega-and-the-operator-runtime-6ad4c2492379?source=collection_archive---------1-----------------------#2020-03-06">https://itnext.io/testing-kubernetes-operators-with-ginkgo-gomega-and-the-operator-runtime-6ad4c2492379?source=collection_archive---------1-----------------------#2020-03-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="io ip gp gr iq ir gh gi paragraph-image"><div class="ab gu cl is"><img src="../Images/202b49e9c5ce6855905655725627595f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*kI1fu8tsZf6AE0ws5zYVig.png"/></div></figure><div class=""/><p id="4259" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我最近写了我们将<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/taking-a-kubernetes-operator-to-production-bc59708db420"> Kubenetes运营商投入生产</a>的经历——当然，其中很大一部分是测试。这篇文章将更深入地探讨这个测试故事。</p><blockquote class="kt ku kv"><p id="84fb" class="ju jv kw jw b jx jy jz ka kb kc kd ke kx kg kh ki ky kk kl km kz ko kp kq kr ij bi translated">我将从头到尾引用我们预先指定的CronJob操作符——在这里找到:<a class="ae ks" href="https://github.com/microsoft/k8s-cronjob-prescaler" rel="noopener ugc nofollow" target="_blank">https://github.com/microsoft/k8s-cronjob-prescaler</a>。</p></blockquote><h1 id="b090" class="la lb ix bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">入门指南</h1><p id="0da7" class="pw-post-body-paragraph ju jv ix jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">有一些非常好的文章和银杏文档可以帮助你启动和运行。我建议你先阅读以下两个指南。</p><ul class=""><li id="70fa" class="md me ix jw b jx jy kb kc kf mf kj mg kn mh kr mi mj mk ml bi translated"><a class="ae ks" href="https://medium.com/boldly-going/unit-testing-in-go-with-ginkgo-part-1-ce6ff06eb17f" rel="noopener">https://medium . com/boldly-going/unit-testing-in-go-with-ginkgo-part-1-ce 6 ff 06 EB 17 f</a></li><li id="99ff" class="md me ix jw b jx mm kb mn kf mo kj mp kn mq kr mi mj mk ml bi translated"><a class="ae ks" href="https://onsi.github.io/ginkgo/#getting-started-writing-your-first-test" rel="noopener ugc nofollow" target="_blank">https://onsi . github . io/ginkgo/#开始编写您的第一个测试</a></li></ul><p id="5d24" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将重点用银杏测试操作员。</p><h1 id="26cf" class="la lb ix bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">编写您的测试</h1><p id="5931" class="pw-post-body-paragraph ju jv ix jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">因为我们的测试基本上是将对象发送给我们在Kubernetes中的操作者，并检查我们返回的内容是否正确，所以我们需要一个Kubernetes管理器&amp;客户端。在我们的<code class="fe mr ms mt mu b">BeforeSuite</code>方法中:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="a768" class="nd lb ix mu b gy ne nf l ng nh">k8sManager, err = ctrl.NewManager(cfg, ctrl.Options{<br/>  Scheme:             scheme.Scheme,<br/>  MetricsBindAddress: metricsAddr,<br/>})</span><span id="b26a" class="nd lb ix mu b gy ni nf l ng nh">k8sManager.Start(ctrl.SetupSignalHandler())</span><span id="d378" class="nd lb ix mu b gy ni nf l ng nh">k8sClient = <strong class="mu iy">k8sManager.GetClient()</strong></span></pre><p id="2d7c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在让我们创建一个资源，并在k8s发射它。下面的代码显示了一个Describe / Context / It块，我们在这里向Kubernetes发送*some*对象。这可能是一个pod、一个部署或您自己的一个CRD:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="abd0" class="nd lb ix mu b gy ne nf l ng nh">var _ = Describe("PrescaledCronJob Controller", func() {<br/>  Context("Cronjob Autogeneration", func() {<br/>    It("Should create cronjob correctly", func() {<br/>      toCreate := generatePSCSpec()<br/>      Expect(<strong class="mu iy">k8sClient.Create</strong>(ctx, &amp;toCreate)).Should(Succeed())</span><span id="6009" class="nd lb ix mu b gy ni nf l ng nh">...</span></pre><p id="d0ae" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在让我们把物体拿回来，看看它看起来像什么。为此，我们将使用来自<a class="ae ks" href="https://onsi.github.io/gomega/" rel="noopener ugc nofollow" target="_blank"> Gomega </a> matcher库的<code class="fe mr ms mt mu b">Eventually()</code>块——这是一个方便的助手函数，它将不断尝试做一些事情，直到matcher成功或超时:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="aeb0" class="nd lb ix mu b gy ne nf l ng nh"><strong class="mu iy">Eventually</strong>(func() bool {<br/>  err := k8sClient.Get(ctx, types.NamespacedName{Name:toCreate.Name, Namespace: namespace}, fetched)<br/>  return err == nil<br/>}, timeout, interval).Should(BeTrue())</span></pre><p id="3d63" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，我们将检查它看起来应该是什么样子:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="0be9" class="nd lb ix mu b gy ne nf l ng nh"><strong class="mu iy">Expect</strong>(fetchedAutogenCron.Name).To(Equal(autogenName))<br/>// ... many more Expects...</span></pre><h2 id="01da" class="nd lb ix bd lc nj nk dn lg nl nm dp lk kf nn no lo kj np nq ls kn nr ns lw nt bi translated">表格驱动测试</h2><p id="523f" class="pw-post-body-paragraph ju jv ix jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">我们想用不同的参数测试许多相似的场景。这是一个使用Ginkgo的表驱动测试的好机会。这些与许多其他数据驱动的测试框架不同，因为传递给测试的每一行数据都会在运行时自动生成一个新的测试。</p><p id="a1a2" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">导入表扩展:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="21fc" class="nd lb ix mu b gy ne nf l ng nh">. "github.com/onsi/ginkgo/extensions/table"</span></pre><p id="927e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">创建一个<code class="fe mr ms mt mu b">DescribeTable</code>块，包括每次运行的函数，以及要传递给它的数据行:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="0d71" class="nd lb ix mu b gy ne nf l ng nh"><strong class="mu iy">DescribeTable</strong>(“Integration test configurations”,<br/>  func(testCase testCase) {</span><span id="1949" class="nd lb ix mu b gy ni nf l ng nh">    // your test logic here...<br/>    Expect(result).To(Equal(testCase.shouldPass))<br/>    Expect(err != nil).To(Equal(testCase.shouldError))<br/>},</span><span id="97f1" class="nd lb ix mu b gy ni nf l ng nh">// add a line per test case here…</span><span id="7a48" class="nd lb ix mu b gy ni nf l ng nh"><strong class="mu iy">Entry</strong>(“LONG TEST: 1 minute, 1 warmup”, testCase{minsApart: 1, warmUpMins: 1, shouldPass: true, shouldError: false}),</span><span id="4239" class="nd lb ix mu b gy ni nf l ng nh"><strong class="mu iy">Entry</strong>(“LONG TEST: 3 minutes, 1 warmup”, testCase{minsApart: 3, warmUpMins: 2, shouldPass: true, shouldError: false}),</span><span id="11a9" class="nd lb ix mu b gy ni nf l ng nh"><strong class="mu iy">Entry</strong>(“LONG TEST: 4 minutes, 1 warmup”, testCase{minsApart: 4, warmUpMins: 2, shouldPass: true, shouldError: false}),</span></pre><p id="e3fa" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可能注意到了，我们创建了一个基本的<code class="fe mr ms mt mu b">testCase</code>结构来传递，而不是传递大量的单个参数。</p><h1 id="deb1" class="la lb ix bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">测试环境</h1><p id="d182" class="pw-post-body-paragraph ju jv ix jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">对于要测试的环境，您有两个主要的选择——要么使用真实的集群，要么使用本地API端点。如果您的操作员不与K8s的其他部分交互或者不依赖于K8s的其他部分，那么就使用内置的API端点。对于我们的例子，我们需要检查默认的<code class="fe mr ms mt mu b">CronJob</code>操作符是否已经接收并创建了一个自动生成的<code class="fe mr ms mt mu b">CronJob</code>对象，所以我们需要使用一个真正的集群。</p><p id="279d" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">幸运的是有了<code class="fe mr ms mt mu b">envtest</code>包(“sigs . k8s . io/controller-runtime/pkg/env test”)，真的很简单:</p><figure class="mv mw mx my gt ir gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/3a3793724bd0452b3584bf726992e19d.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*qtwr1t1RDM7ufMUj07unbQ.png"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">suite_test.go中的testEnv</figcaption></figure><p id="b0aa" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">还可以在运行每个测试之前对测试环境进行定制:</p><figure class="mv mw mx my gt ir gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/a781f55c6dae173dca97f1a239e03fa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*ihPG05Y4bpqlFSvxvLR_8A.png"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">CRDDirectoryPaths允许您在测试时应用yaml</figcaption></figure><p id="c12d" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是配置您的测试环境并确保在您运行您的测试之前所需的资源已经存在的好方法——然而，根据我们的经验，在其他地方应用yaml更简单(例如makefile ),因为我们可以决定<em class="kw">何时</em>或<em class="kw">如果</em>我们想要应用它。</p><h2 id="aed8" class="nd lb ix bd lc nj nk dn lg nl nm dp lk kf nn no lo kj np nq ls kn nr ns lw nt bi translated">对照实物测试</h2><p id="ad11" class="pw-post-body-paragraph ju jv ix jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated"><a class="ae ks" href="https://kind.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank">种类</a>对于集成测试至关重要，因为您可以在本地运行完整的集群——甚至在构建管道中。因为<code class="fe mr ms mt mu b">testEnv</code>现在正在使用一个‘真正的’集群——它只会对<code class="fe mr ms mt mu b">kubectl</code>指向的任何东西发出命令。对我们来说，这很好。</p><p id="405d" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在makefile中:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="fc2d" class="nd lb ix mu b gy ne nf l ng nh"><strong class="mu iy">deploy-kind</strong>: kind-start kind-load-img deploy-cluster manifests install-crds kustomize-deployment</span></pre><p id="1ba1" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上面的make命令将启动Kind，然后部署我们所有的定制和操作符。</p><p id="33b3" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了运行测试，我们将运行:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="0d09" class="nd lb ix mu b gy ne nf l ng nh"><strong class="mu iy">kind-tests</strong>: ginkgo --skip="LONG TEST:" --nodes 6 --race --randomizeAllSpecs --cover --trace --progress --coverprofile ../controllers.coverprofile ./controllers</span><span id="4877" class="nd lb ix mu b gy ni nf l ng nh">-kubectl delete prescaledcronjobs --all -n psc-system</span></pre><p id="d5ad" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上面的make命令做了几件事:</p><ul class=""><li id="e954" class="md me ix jw b jx jy kb kc kf mf kj mg kn mh kr mi mj mk ml bi translated">跳过任何被描述为“长测试:*”的测试。这是一种选择在本地运行哪些测试的相当低fi的方式，相对于可能更长时间运行的集成测试。</li><li id="b1c3" class="md me ix jw b jx mm kb mn kf mo kj mp kn mq kr mi mj mk ml bi translated">并行测试6个围棋程序(<code class="fe mr ms mt mu b">--nodes 6</code>)。这是加速整个测试执行的好方法。</li><li id="d382" class="md me ix jw b jx mm kb mn kf mo kj mp kn mq kr mi mj mk ml bi translated">运行覆盖率工具</li><li id="9e6e" class="md me ix jw b jx mm kb mn kf mo kj mp kn mq kr mi mj mk ml bi translated">试图删除我们在测试中获得的资源。makefile中的<code class="fe mr ms mt mu b">-</code>字符表示“如果这一行抛出一个错误，就继续执行”。</li></ul><h1 id="c45c" class="la lb ix bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">针对真实集群进行测试</h1><p id="58c3" class="pw-post-body-paragraph ju jv ix jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">这种方法最大的好处之一是，现在可以对一个“真正的”集群运行测试。我们的是蓝色的。你所需要做的就是设置你的<code class="fe mr ms mt mu b">kubectx</code>指向你真正的集群而不是种类，部署你的定制，并再次运行测试。</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="92a4" class="nd lb ix mu b gy ne nf l ng nh"><strong class="mu iy">deploy-cluster</strong>: manifests install-crds kustomize-deployment</span><span id="ab12" class="nd lb ix mu b gy ni nf l ng nh">$&gt; make deploy-cluster<br/>$&gt; make kind-tests</span></pre><p id="9cfb" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有了这种测试的重用，就很容易明白您可能希望在构建中对Kind运行测试，或者在发布过程中对您的真实集群运行集成测试套件。</p><h1 id="8f74" class="la lb ix bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">输出测试结果</h1><p id="5f43" class="pw-post-body-paragraph ju jv ix jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">由于许多构建代理(我们使用Azure Devops)不“理解”go测试结果，有一个方便的扩展可以让Ginkgo以JUnit格式输出测试结果，这是许多构建代理能够理解的。它是测试的入口点:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="b421" class="nd lb ix mu b gy ne nf l ng nh"><strong class="mu iy">junitReporter</strong> := reporters.NewJUnitReporter(fmt.Sprintf("../TEST-ginkgo-junit_%d.xml", config.GinkgoConfig.ParallelNode))</span><span id="1607" class="nd lb ix mu b gy ni nf l ng nh">RunSpecsWithDefaultAndCustomReporters(t, "Controller Suite", []Reporter{envtest.NewlineReporter{}, <strong class="mu iy">junitReporter</strong>})</span></pre><p id="b7b2" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这将在测试中为每个“节点”(go例程)创建一个xml文件。但是构建代理应该将它们全部挑选出来以报告结果:</p><figure class="mv mw mx my gt ir gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi oa"><img src="../Images/8ac6a9ee2df1c703a860cc0cde87ee81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9e9vMN4nQazPWB8Z96g_Aw.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">ADO中的测试结果</figcaption></figure></div></div>    
</body>
</html>