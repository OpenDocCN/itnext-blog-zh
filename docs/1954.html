<html>
<head>
<title>Understanding application routing in Istio</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Istio中的应用程序路由</h1>
<blockquote>原文：<a href="https://itnext.io/understanding-application-routing-in-istio-aade30d594f4?source=collection_archive---------3-----------------------#2019-03-01">https://itnext.io/understanding-application-routing-in-istio-aade30d594f4?source=collection_archive---------3-----------------------#2019-03-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/10b0a44cd652a7ca9dd98f59f736595b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_OniEuttoorKX0b5Yo3NhQ.jpeg"/></div></div></figure><p id="f910" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇博客中，我们将看看如何部署同一个应用程序的两个版本，并根据权重路由流量。这对于在一定比例的用户上测试应用程序的新版本，或者更一般地对于完整的蓝/绿部署来说，非常方便。</p><p id="988a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们需要一个kubernetes集群，为了构建它，我们将使用下面的<a class="ae kw" href="https://docs.microsoft.com/azure/aks/kubernetes-walkthrough?WT.mc_id=docs-blog-sccoulto" rel="noopener ugc nofollow" target="_blank">文档</a>或使用下面的代码。如果你没有Azure账户，你可以在这里获得免费试用。确保在运行任何其他命令之前运行了<code class="fe kx ky kz la b">az login</code>命令。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="371b" class="lj lk iq la b gy ll lm l ln lo">az group create --name k8s --location eastus<br/><br/>az aks create --resource-group k8s \​<br/>    --name k8s \​<br/>    --generate-ssh-keys \​<br/>    --kubernetes-version 1.12.5 \​<br/>    --enable-rbac \​<br/>    --node-vm-size Standard_DS2_v2</span></pre><p id="8ebc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将创建我们的资源组，然后创建我们的kubernetes集群，如果您已经安装了<code class="fe kx ky kz la b">kubectl</code>，则跳过下一步。如果没有，请使用以下命令安装二进制文件</p><p id="6cc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">az install aks-cli</code></p><p id="5321" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在用我们的凭证来设置<code class="fe kx ky kz la b">kubectl</code>。我们将使用下面的命令来完成这项工作。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="1814" class="lj lk iq la b gy ll lm l ln lo">az aks get-credentials --resource-group k8s --name k8s</span></pre><p id="4e1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经启动并运行了集群，我们将通过<a class="ae kw" href="https://docs.microsoft.com/en-us/azure/aks/kubernetes-helm?WT.mc_id=docs-medium-sccoulto" rel="noopener ugc nofollow" target="_blank"> Helm </a>部署Istio。在这篇博客中，我们不打算深入研究赫尔姆。如果你想了解更多，请点击上面的链接。现在，为了让你快速启动并运行，我创建了一个脚本来安装helm和Istio。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="405b" class="lj lk iq la b gy ll lm l ln lo">#!/bin/bash<br/><br/>if [[ "$OSTYPE" == "linux-gnu" ]]; then<br/>    OS="linux"<br/>    ARCH="linux-amd64"<br/>elif [[ "$OSTYPE" == "darwin"* ]]; then<br/>    OS="osx"<br/>    ARCH="darwin-amd64"<br/>fi    <br/><br/>ISTIO_VERSION=1.0.4<br/>HELM_VERSION=2.11.0<br/><br/>check_tiller () {<br/>POD=$(kubectl get pods --all-namespaces|grep tiller|awk '{print $2}'|head -n 1)<br/>kubectl get pods -n kube-system $POD -o jsonpath="Name: {.metadata.name} Status: {.status.phase}" &gt; /dev/null 2&gt;&amp;1 | grep Running<br/>}<br/><br/>pre_reqs () {<br/>curl -sL "https://github.com/istio/istio/releases/download/$ISTIO_VERSION/istio-$ISTIO_VERSION-$OS.tar.gz" | tar xz<br/>if [ ! -f /usr/local/bin/istioctl ]; then  <br/>    echo "Installing istioctl binary"<br/>    chmod +x ./istio-$ISTIO_VERSION/bin/istioctl<br/>    sudo mv ./istio-$ISTIO_VERSION/bin/istioctl /usr/local/bin/istioctl<br/>fi           <br/><br/>if [ ! -f /usr/local/bin/helm ]; then  <br/>    echo "Installing helm binary"<br/>    curl -sL "https://storage.googleapis.com/kubernetes-helm/helm-v$HELM_VERSION-$ARCH.tar.gz" | tar xz<br/>    chmod +x $ARCH/helm <br/>    sudo mv linux-amd64/helm /usr/local/bin/<br/>fi    <br/>}    <br/><br/>install_tiller () {<br/>echo "Checking if tiller is running"<br/>check_tiller<br/>if [ $? -eq 0 ]; then<br/>    echo "Tiller is installed and running"<br/>else<br/>echo "Deploying tiller to the cluster"<br/>cat &lt;&lt;EOF | kubectl apply -f -<br/>apiVersion: v1<br/>kind: ServiceAccount<br/>metadata:<br/>  name: tiller<br/>  namespace: kube-system<br/>---<br/>apiVersion: rbac.authorization.k8s.io/v1beta1<br/>kind: ClusterRoleBinding<br/>metadata:<br/>  name: tiller<br/>roleRef:<br/>  apiGroup: rbac.authorization.k8s.io<br/>  kind: ClusterRole<br/>  name: cluster-admin<br/>subjects:<br/>  - kind: ServiceAccount<br/>    name: tiller<br/>    namespace: kube-system<br/>EOF<br/>helm init --service-account tiller<br/>fi           <br/>check_tiller<br/>while [ $? -ne 0 ]; do<br/>  echo "Waiting for tiller to be ready"<br/>  sleep 30<br/>done<br/><br/>}<br/><br/>install () {<br/>echo "Deplying istio"<br/><br/>helm install istio-$ISTIO_VERSION/install/kubernetes/helm/istio --name istio --namespace istio-system \<br/>    --set global.controlPlaneSecurityEnabled=true \<br/>    --set grafana.enabled=true \<br/>    --set tracing.enabled=true \<br/>    --set kiali.enabled=true<br/><br/>if [ -d istio-$ISTIO_VERSION ]; then <br/>    rm -rf istio-$ISTIO_VERSION<br/>  fi    <br/>}<br/><br/>pre_reqs<br/>install_tiller<br/>install</span></pre><p id="807a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">确保所有Istio吊舱都在运行</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="e873" class="lj lk iq la b gy ll lm l ln lo">NAMESPACE      NAME                                      READY   STATUS    RESTARTS   AGE<br/>istio-system   grafana-546d9997bb-9mmmn                  1/1     Running   0          4m32s<br/>istio-system   istio-citadel-5c9544c886-hplv6            1/1     Running   0          4m31s<br/>istio-system   istio-egressgateway-6f9db5ff8d-9lgsd      1/1     Running   0          4m32s<br/>istio-system   istio-galley-8dcbb5f99-gf44n              1/1     Running   0          4m32s<br/>istio-system   istio-ingressgateway-6c6b9f9c55-mm82k     1/1     Running   0          4m32s<br/>istio-system   istio-pilot-74984d9cf5-49kj9              2/2     Running   0          4m31s<br/>istio-system   istio-policy-6dd4496b8c-p9s2h             2/2     Running   0          4m31s<br/>istio-system   istio-sidecar-injector-6bd4d9487c-hhwqb   1/1     Running   0          4m31s<br/>istio-system   istio-telemetry-7bb4ffcd9d-5f2bf          2/2     Running   0          4m31s<br/>istio-system   istio-tracing-6445d6dbbf-65mwt            1/1     Running   0          4m31s<br/>istio-system   kiali-ddf8fbbb-sjklt                      1/1     Running   0          4m31s<br/>istio-system   prometheus-65d6f6b6c-8bgzm                1/1     Running   0          4m31s<br/>kube-system    coredns-754f947b4-2r565                   1/1     Running   0          14m<br/>kube-system    coredns-754f947b4-d5pdf                   1/1     Running   0          18m<br/>kube-system    coredns-autoscaler-6fcdb7d64-q245b        1/1     Running   0          18m<br/>kube-system    heapster-5fb7488d97-v45pc                 2/2     Running   0          18m<br/>kube-system    kube-proxy-gpxvg                          1/1     Running   0          14m<br/>kube-system    kube-proxy-rdrxl                          1/1     Running   0          14m<br/>kube-system    kube-proxy-sc9q6                          1/1     Running   0          14m<br/>kube-system    kube-svc-redirect-5t75d                   2/2     Running   0          14m<br/>kube-system    kube-svc-redirect-6bzz8                   2/2     Running   0          14m<br/>kube-system    kube-svc-redirect-jntkv                   2/2     Running   0          14m<br/>kube-system    kubernetes-dashboard-847bb4ddc6-6vxn4     1/1     Running   1          18m<br/>kube-system    metrics-server-7b97f9cd9-x59p2            1/1     Running   0          18m<br/>kube-system    tiller-deploy-6f6fd74b68-rf2lf            1/1     Running   0          5m20s<br/>kube-system    tunnelfront-8576f7d885-tzhnw              1/1     Running   0          18m</span></pre><p id="9000" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经准备好部署我们的应用程序了。我们的应用程序将由一个简单的单页web应用程序组成。我们将有这个应用程序的两个版本<code class="fe kx ky kz la b">v1</code>和<code class="fe kx ky kz la b">v2</code>。对于这个帖子，我们将在两者之间平均路由流量。如果这是一个生产环境，你可能只希望金丝雀5%的流量到你的应用程序的新版本，看看用户喜欢它等等。</p><p id="7c08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们要做的第一件事是标记默认名称空间，让Istio自动注入特使代理。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="0e7d" class="lj lk iq la b gy ll lm l ln lo">kubectl label namespace default istio-injection=enabled</span></pre><p id="5488" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我看来，如果这是一个生产环境，我会为应用程序创建一个新的名称空间，并让代理自动注入。</p><p id="be6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来要做的是部署我们的应用程序。我们将使用标准的Kuberntes部署类型来完成这项工作。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="7f68" class="lj lk iq la b gy ll lm l ln lo">cat &lt;&lt;EOF | kubectl apply -f - <br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: webapp<br/>  labels:<br/>    app: webapp<br/>spec:<br/>  ports:<br/>  - port: 3000<br/>    name: http<br/>  selector:<br/>    app: webapp<br/>---<br/>apiVersion: extensions/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  name: webapp-v1<br/>spec:<br/>  replicas: 1<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: webapp<br/>        version: v1<br/>    spec:<br/>      containers:<br/>      - name: webapp<br/>        image: scottyc/webapp:v1<br/>        imagePullPolicy: IfNotPresent<br/>        ports:<br/>        - containerPort: 3000<br/>---<br/>apiVersion: extensions/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  name: webapp-v2<br/>spec:<br/>  replicas: 1<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: webapp<br/>        version: v2<br/>    spec:<br/>      containers:<br/>      - name: webapp<br/>        image: scottyc/webapp:v2<br/>        imagePullPolicy: IfNotPresent<br/>        ports:<br/>        - containerPort: 3000<br/>EOF</span></pre><p id="39b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您会注意到，在这个部署中，我们正在部署应用程序的<code class="fe kx ky kz la b">v1</code>和<code class="fe kx ky kz la b">v2</code>。</p><p id="b0c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们的部署启动并运行，我们必须添加一个目的地规则，以便Istio了解我们的应用程序。Istio现在将在内部为应用程序分配一个DNS名称。该名称将由应用程序名称、主机名(取自下面的部署)和名称空间组成。它将被这样追加<code class="fe kx ky kz la b">&lt;namespace&gt;.svc.cluster.local</code>。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="4482" class="lj lk iq la b gy ll lm l ln lo">cat &lt;&lt;EOF | kubectl apply -f -<br/>apiVersion: networking.istio.io/v1alpha3<br/>kind: DestinationRule<br/>metadata:<br/>  name: webapp<br/>spec:<br/>  host: webapp<br/>  subsets:<br/>  - name: v1<br/>    labels:<br/>      version: v1<br/>  - name: v2<br/>    labels:<br/>      version: v2<br/>EOF</span></pre><p id="5b74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将创建Istio网关。这将定义应用程序将监听的入站端口以及我们将路由到的主机。在我们的例子中，它将是端口<code class="fe kx ky kz la b">80</code>，我们将使用一个<code class="fe kx ky kz la b">*</code>来访问任何主机。我们还将把我们的网关绑定到默认的Istio入口网关。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="fbea" class="lj lk iq la b gy ll lm l ln lo">cat &lt;&lt;EOF | kubectl apply -f -<br/>apiVersion: networking.istio.io/v1alpha3<br/>kind: Gateway<br/>metadata:<br/>  name: webapp-gateway<br/>spec:<br/>  selector:<br/>    istio: ingressgateway # use istio default controller<br/>  servers:<br/>  - port:<br/>      number: 80<br/>      name: http<br/>      protocol: HTTP<br/>    hosts:<br/>    - "*"<br/>EOF</span></pre><p id="0d24" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们将创建Istio虚拟服务。这定义了我们如何根据权重路由流量。正如我之前提到的，我们将对流量进行50/50加权，但在这里有一个游戏，并更改数字。这将让你很好地掌握引擎盖下的机制。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="21b0" class="lj lk iq la b gy ll lm l ln lo">cat &lt;&lt;EOF | kubectl apply -f -<br/>apiVersion: networking.istio.io/v1alpha3<br/>kind: VirtualService<br/>metadata:<br/>  name: webapp<br/>spec:<br/>  hosts:<br/>  - "*"<br/>  gateways:<br/>  - webapp-gateway<br/>  http:<br/>  - route:<br/>    - destination:<br/>        host: webapp<br/>        subset: v1<br/>      weight: 50 <br/>    - destination:<br/>        host: webapp<br/>        subset: v2<br/>      weight: 50<br/>EOF</span></pre><p id="c48e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经部署好了一切，我们的应用程序可以访问互联网了。要获得Istio网关的公共IP，请使用以下内容。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="1870" class="lj lk iq la b gy ll lm l ln lo">kubectl get svc istio-ingressgateway -n istio-system -o jsonpath="{.status.loadBalancer.ingress[0].ip}"​</span></pre><p id="2b90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在在你的浏览器中使用公共IP，你应该得到应用程序的一个版本。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lp"><img src="../Images/553a6344185214dc52baa9afbbd31865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w86tuVtIQwOdgBT0p12WtA.png"/></div></div></figure><p id="7b5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后使用匿名窗口和相同的公共ip地址，你应该得到另一个版本</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lq"><img src="../Images/0faccaf6a8dbf80b1e757d46a150367b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*d8hY08Hnqv8Ln9RoY8pQ5g.png"/></div></div></figure><p id="2b38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果你得到了相同的版本，只需关闭隐姓埋名窗口，再试一次。</p><p id="681f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是Istio能做什么的一个基本例子。如果你想了解更多关于Istio及其交通规则配置的信息，官方文件在<a class="ae kw" href="https://istio.io/docs/reference/config/istio.networking.v1alpha3/#Destination" rel="noopener ugc nofollow" target="_blank">这里</a></p></div></div>    
</body>
</html>