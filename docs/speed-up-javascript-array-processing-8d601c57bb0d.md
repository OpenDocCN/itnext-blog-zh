# 加速 JavaScript 数组处理

> 原文：<https://itnext.io/speed-up-javascript-array-processing-8d601c57bb0d?source=collection_archive---------0----------------------->

![](img/9f2cdf48cc2033fd51a36075db9ee667.png)

照片由 [Cris Ovalle](https://unsplash.com/@crisovalle?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

## 使用 RxJS 作为同步传感器库

当您只有几个项目时，JavaScript 数组是很棒的，但是当您有大量数据或者想要通过大量的`map`、`filter`和`reduce`方法调用来进行复杂的转换时，您会发现使用`Array.prototype`方法会显著降低性能。

以这个简单的`map`为例:

```
initialArray
.map(String)
```

即使像单个阵列`map`这样简单的东西，使用传感器也可以快几个数量级。正如您将在我的性能分析中看到的，最终的数字令人难以置信地惊讶。

# 问题是

在您提高速度之前，您可能甚至不会意识到速度有多慢，但是也有极少数情况下，您要么要处理大量数据，要么要处理大量转换，并且需要提高性能。

让我们使用`Array.prototype.map`对 1000 万个项目做一个简单的性能测试:

然后让我们将其与本机`for`循环进行比较:

每个测试我运行 7 次，取平均值。在我的超频[英特尔酷睿 i7–4770k](https://ark.intel.com/products/75123/Intel-Core-i7-4770K-Processor-8M-Cache-up-to-3-90-GHz-)上，我们的阵列方法平均为 1281 毫秒，而我们的`for`循环平均为 323 毫秒。难以置信吧？多好的性能提升啊！但是`for`循环是 10 年前的事了。在进行复杂的转换时，它们很难编写，也很难推理。

我们如何解决这几乎 300%的性能差异，但仍然保持我们的代码可读？

# 传感器来救援了！

转换是一种在输出一个值之前，通过将数组包装在一组递归的归约函数中，对数组中每个单独的项进行一系列逻辑处理的方法。这与 JavaScript `Array`方法的工作方式不同，因为数组中的每一项都是用一个单独的`map`、`filter`或`reduce`方法处理的，然后继续下一步，并且每一步都在创建全新的数组来存放数据。

有很多用于处理转导的库，也有很多关于如何用它来代替原生`Array`方法的文章，但是我想回顾一下我在我的一个家庭项目中尝试的一个实验，它使用 RxJS 代替 JavaScript 的原生`Array`方法。

我相信学好一件事比不得不学习一大堆其他事情更容易，也更便宜。虽然为正确的工作使用正确的工具很重要，但我一直在探索为一堆不同的工作使用相同工具的方法，因为它可以最小化团队的学习成本，并显著降低项目的实施成本。

就像我的关于 RxJS 中背压的文章一样，这个实现是实验性的。通常，我会写一些关于我在生产中遇到的事情的文章，但这两篇文章是关于我想出的扩展 RxJS 功能的想法。

如果你想深入了解传感器， [Eric Elliot](https://medium.com/@_ericelliott) 有一篇精彩的文章可以帮你入门:

[](https://medium.com/javascript-scene/transducers-efficient-data-processing-pipelines-in-javascript-7985330fe73d) [## 转换器:JavaScript 中高效的数据处理管道

### 注意:这是学习函数式编程和组合软件的“组合软件”系列的一部分…

medium.com](https://medium.com/javascript-scene/transducers-efficient-data-processing-pipelines-in-javascript-7985330fe73d) 

# RxJS 传感器

转换器像 RxJS 流一样通过一组函数来运行单个项目，这一点现在尤其重要，因为 RxJS 用他们的`pipe`方法和 lettable 操作符实现了转换器模式，可能有一种方法可以使它们兼容。

如果 RxJS 已经是你的项目的一部分，我会将它用于同步传感器来代替数组方法，但是有一些注意事项。

首先，不管出于什么原因，RxJS 不像其他转换器库那样实现转换器接口，所以它与它们的开箱即用不兼容。如果你用的只是 RxJS，这没什么大不了的。

其次，RxJS 依赖于使用回调的`subscribe`方法。`Array`方法返回数组，而不是包含数组值的可观察值。那你是做什么的？除非你正在使用`BehaviorSubject`，否则你不能拉一个同步值，即使使用它，你也不能确定你得到的值将会是你所期望的。

最重要的是，RxJS 观察值没有区分异步和同步操作符。您可以围绕您的逻辑创建一个同步包装器，但是它只能在运行时保护您。

# 一些实验

由于 RxJS 的`BehaviorSubject`接近我们想要的，让我们看一个使用它的实现:

呸！这不是我想在我的代码库中反复做的事情。订阅后还得记得退订？每次都记得`mergeMap`？你一定是在开玩笑。

还要注意，**这个连**都不行。您的`value`是您传入的原始数组，而不是经过管道的数组。你只能通过传递一个句柄给`subscribe`来获得你转换后的`value`，所以`BehaviorSubject`被证明是非常没有价值的。

如果我们使用`from`，我们可以模仿同样的行为，让它工作，并且使用更少的代码:

这是一个非常干净的工具，现在`value`是正确的，但是它仍然有和以前一样的问题:难以维护，难以编写(而且很恶心)。如果它只是你代码库中的一个点，没问题，但不止于此？开始想更好的办法。

# 解决方案

我们需要的是一种方法来消除我们对`subscribe`方法的依赖，以同步生成一个可观察的函数并返回一个值。在这种情况下，我们需要一个数组。

为了得到一个值，我们需要在我们的可观测值上有这样的东西:

```
source$
.execute = () => {
  // do transducer logic

  return value
}
```

虽然这是一个目前 RxJS 中不存在的方法，但它绝对是我们可以在自己的项目中添加的东西。

RxJS 有一个类似于我们虚构的`execute`的方法，叫做`forEach`，但是它的设计类似于`Array.prototype.forEach`，除了它不是返回`undefined`，而是返回一个承诺。promise `then`方法不返回任何东西，但是它会告诉你什么时候你的可观察性是完整的。如果它出错，`catch`将会触发。这是一个非常漂亮的设置，但是当我们试图复制`Array`的同步操作时就没用了。

因为我们处理的是一个数组，没有随时间变化的值。RxJS 已经处理了这个问题，并在到达列表末尾时完成了可观察性。如果我们将`subscribe`包装在`execute`函数中，我们可以让它返回一个同步值，类似于 async-await 的工作方式，而不需要您重写整个应用程序。

# 履行

这是我想象我们如何使用`execute`:

通过这个特殊的实现，我能够在异步代码运行时捕获错误:

请注意我们的值是`undefined`，但是我们仍然能够在一段时间后看到关于它的用法的错误。因为它是异步的，所以我们不能使用 try-catch 来发现错误，但是我们*可以在运行时将它记录到控制台，这样您就可以意识到有问题了。*

但是这个实现有一个缺陷，您可能有一个从不退订并且只记录错误的异步观察对象。

相反，我们需要在执行后立即取消订阅，但是我们将无法知道我们的可观察对象是否有异步操作符:

唯一的另一种方法是添加一个`take(1)`操作符，并且只在抛出错误后才取消订阅，但是因为您不能用一个永远不会触发的可观察对象来确定这种内存泄漏，所以这也可能不是一个好的实现。

我认为自动退订更符合你的预期。这样，即使你错过了一些有用的“你搞砸了”的错误，你也不会因为使用`execute`而出现内存泄漏的情况。

如果我自己使用函数组合并订阅可观察对象，而不是扩展类，这个实现会干净得多，但是我想模仿它在 RxJS 中实现的样子。

这个 API 可以通过使用`from`进一步改进。消费`createExecutableObservable`的时候就少了一样进口的东西。

# 性能影响

现在，我们已经创建了传感器逻辑，让我们使用之前所做的相同比较来运行性能测试:

它在`for`循环中使用了更干净的 API，但是比原始的`map`测试多了很多代码，所以正如你所料，这可能会花费更长的时间。我的意思是，与这个怪物相比，本机示例只是一个方法调用。

当我运行性能测试时，我惊讶地发现平均速度为 371 毫秒。这比我们的`map`测试快了 240%,只比我们的`for`循环慢了 13%。我认为这对我来说已经足够好了，但是如果您在嵌入式系统中工作并且有非常严格的处理约束，可能就不够好了。

为了可读性，您是愿意编写一个`for`循环还是使用您现有的 RxJS 传感器知识？哪个更容易维护，尤其是当你可能再过 3-4 年才能看到另一个`for`循环的时候？

## 真实的故事

传感器并不都是桃子和奶油。当你有很少的项目时，传感器比任何一种解决方案都慢。寻找大多数机器的折衷点超出了本文的范围，但是让我们用一组 3 个项目重新进行这些性能测试。

*   阵列方法:0.33 毫秒
*   对于循环:0.22 毫秒
*   传感器:3.06 毫秒

突然间，形势发生了逆转。3 件物品 3 毫秒？这比其他两种解决方案要长一个数量级。你在开玩笑吗？显然不是。

所有这些传感器逻辑都是有代价的。该设置虽然在大型操作中速度很快，但在处理少量数据时速度极慢。

这就是“为正确的工作使用正确的工具”发挥作用的地方。如果你有一个小数组，使用内置方法。你失去了那些令人惊讶的 RxJS 操作符的好处，例如`tap`(只需使用`filter`)，但是你获得了惊人的速度，并且不必用你的换能器模式偷工减料地使用有充分证明的`Array`方法。

当你已经在 RxJS 转换器管道中时，真正的困境就来了。当您在可观察数组执行和同步数组执行之间切换映射时，您使用哪个？我认为这取决于你的团队和所需的处理。如果需要 RxJS 操作符，就使用它们。如果没有，只要没有大量的条目或复杂的转换，就可以安全地使用 JavaScripts 原生的`Array`方法。

# 其他集合类型

转换器是通用的，不关心集合本身，只关心每个转换器的进出值(RxJS 操作符)。这意味着理论上我们可以对其他集合使用同样的方法，比如迭代器。

让我们使用我上一篇关于 RxJS 中的 [*无损反压的文章中的生成器，但是没有异步反压处理程序:*](/lossless-backpressure-in-rxjs-b6de30a1b6d4)

很酷吧？这样做的唯一原因是因为 RxJS 遍历整个生成器的值，创建数组，并通过管道一个接一个地推送值。

更复杂的主题处理，比如我写的背压迭代器函数，不会像你期望的那样工作，会让你工作到深夜。如果说这整个设计中有一个缺陷，那就是你不能确定你的管道是否是异步的。

# 结论

虽然 RxJS 可以用作转换器库，这确实会显著加快大型数据集的执行时间，但偷工减料地使用`subscribe`函数肯定不是它的本意。

我很想看看将来是否有更好的方法来做到这一点，但是这个用例大大简化了它，而不必拆除、维护和学习另一个库。

# 更多阅读

如果你对更多与 RxJS 相关的话题感兴趣，你应该看看我的其他文章:

*   [使用转换器加速 JavaScript 数组](/using-transducers-to-speed-up-javascript-arrays-92677d000096)
*   函数式编程的表情爱好者指南:第一部分
*   [处理缓存和 AJAX 竞争条件](/handling-cache-and-ajax-race-conditions-4cb152db8764)
*   [RxJS 中的无损背压](/lossless-backpressure-in-rxjs-b6de30a1b6d4)
*   [Redux-Observable 可以解决你的状态问题](https://medium.com/@Sawtaytoes/redux-observable-can-solve-your-state-problems-15b23a9649d7)