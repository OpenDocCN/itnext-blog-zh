<html>
<head>
<title>Create powerful dynamic themes and layouts using ElectronCSS 0.10 new framework agnostic dynamicCSS feature</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ElectronCSS 0.10新的框架不可知动态特性创建强大的动态主题和布局</h1>
<blockquote>原文：<a href="https://itnext.io/create-powerful-dynamic-themes-and-layouts-using-electroncss-0-10-4c15654f9e7d?source=collection_archive---------4-----------------------#2018-07-24">https://itnext.io/create-powerful-dynamic-themes-and-layouts-using-electroncss-0-10-4c15654f9e7d?source=collection_archive---------4-----------------------#2018-07-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/f1a0f35489a91b30ddf5a5bbc1e40590.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/1*3RNSb3SfmLA5EckcVW-wiw.gif"/></div></figure><p id="a96f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你曾经尝试过在React中创建主题，并且发现让它成为一个提供者相当困难，请举手。我看不到你的手，所以我假设你举起来了。</p><p id="6816" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">通常，尤其是如果你打算在JS中使用CSS，当你试图为你的CSS应用提供主题时，你会遇到一个大问题。为什么？主要是因为你的CSS不像你漂亮的JSX / ng模板那样动态。我不打算深入描述React中的上下文API，因为它在这里是以一种非常优雅的方式完成的:<a class="ae kv" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/context.html</a>，而且，令人惊讶的是，使用的例子是，我给你:CSS主题。</p><p id="37ce" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，这不仅极大地膨胀了你的组件的代码，突然让一切都由<code class="fe kw kx ky kz b">Consumer</code>组件驱动，而且这也使它非常固执己见，甚至可能影响性能。解决方案？这是对此的另一种理解:ElectronCSS现在提出了一个动态的应用编程接口来解决这个问题。</p><h1 id="4fed" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">入门指南</h1><p id="0e16" class="pw-post-body-paragraph jx jy it jz b ka ly kc kd ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku im bi translated">如果您还没有，您应该从<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/stop-using-css-in-js-and-welcome-proper-styling-in-js-with-electron-css-d28536ba3e85">electronics的入门文章</a>开始，以便设置您的环境。同样，如果你太懒，你可以用这个JSFiddle:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><h1 id="d61e" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">如何使用它</h1><p id="5056" class="pw-post-body-paragraph jx jy it jz b ka ly kc kd ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku im bi translated">创建动态属性集的第一步是建立一个您的类可以订阅的对象。</p><pre class="md me mf mg gt mj kz mk ml aw mm bi"><span id="8282" class="mn lb it kz b gy mo mp l mq mr">const Theme = DynamicCSS();</span></pre><p id="3887" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">按照惯例，该对象被赋予一个PascalCase名称。您还可以为属性提供默认值:</p><pre class="md me mf mg gt mj kz mk ml aw mm bi"><span id="a009" class="mn lb it kz b gy mo mp l mq mr">const Theme = DynamicCSS({<br/>  mainColor: color.red<br/>});</span></pre><p id="61c2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在我们有了主题，让我们在CSS中使用它:</p><pre class="md me mf mg gt mj kz mk ml aw mm bi"><span id="6dcd" class="mn lb it kz b gy mo mp l mq mr">const Theme = DynamicCSS({<br/>  mainColor: color.red<br/>});</span><span id="bf61" class="mn lb it kz b gy ms mp l mq mr">const myButton = CSS({<br/>  backgroundColor: Theme.mainColor<br/>});</span></pre><p id="ebdc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你可能已经注意到DynamicCSS对象并不局限于实际的CSS属性，你可以把任何你需要的东西放在里面。你通常想要重构你的颜色代码，就像设计师用他/她自己的调色板那样，这样你就可以在任何地方重用它们。</p><p id="f6ba" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最后，很明显，您会希望在某个地方使用CSS类:</p><pre class="md me mf mg gt mj kz mk ml aw mm bi"><span id="3d22" class="mn lb it kz b gy mo mp l mq mr">const Theme = DynamicCSS({<br/>  mainColor: color.red<br/>});</span><span id="f27a" class="mn lb it kz b gy ms mp l mq mr">const myButton = CSS({<br/>  backgroundColor: Theme.mainColor<br/>});</span><span id="3153" class="mn lb it kz b gy ms mp l mq mr">&lt;div class={myButton}&gt;&lt;/div&gt;</span></pre><p id="9c85" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在怎么办？嗯，这就是神奇之处。假设你的用户想把你的网站切换到夜间模式。您所要做的就是创建一个普通对象，其属性与您的夜间模式相匹配，并使用Theme.use()来使用它。下面是一个工作示例:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="e12d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">顺便说一下，我已经谈了很多关于主题的内容，但是不要让这阻止你:DynamicCSS还有很多其他的用途，例如对用户动作做出反应，比如滚动和鼠标移动。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><h2 id="66f5" class="mn lb it bd lc mt mu dn lg mv mw dp lk ki mx my lo km mz na ls kq nb nc lw nd bi translated">使用和注射</h2><p id="d620" class="pw-post-body-paragraph jx jy it jz b ka ly kc kd ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku im bi translated">有两种方法可以更新你的动态css属性。第一个版本，use()，正如我们之前看到的，将完全重置您的CSS。</p><pre class="md me mf mg gt mj kz mk ml aw mm bi"><span id="9017" class="mn lb it kz b gy mo mp l mq mr">const Theme = DynamicCSS();<br/>Theme.use({<br/>  color: 'red',<br/>  width: '1px'<br/>})</span><span id="d74b" class="mn lb it kz b gy ms mp l mq mr">Theme.use({color: 'blue'}); </span><span id="5f3e" class="mn lb it kz b gy ms mp l mq mr">// here the width will be removed from the theme</span></pre><p id="8062" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当你想为你的网站加载一个全局的主题/布局，并且你担心旧的属性会弄乱结果，因为新选择的主题实际上不会覆盖它们的时候，这是非常有用的。</p><p id="d2ef" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在某些情况下，您可能想要加载主题进行更多的本地编辑。</p><pre class="md me mf mg gt mj kz mk ml aw mm bi"><span id="7c84" class="mn lb it kz b gy mo mp l mq mr">const Theme = DynamicCSS();<br/>Theme.use({<br/>  color: 'red',<br/>  width: '1px'<br/>})</span><span id="7be8" class="mn lb it kz b gy ms mp l mq mr">Theme.inject({someThirdPartyProperty: '123px'});</span><span id="31b4" class="mn lb it kz b gy ms mp l mq mr">// here the width and color will remain the same</span></pre><p id="6cae" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果您有一个更模块化的方法，为特定组件(或第三方组件)提供子主题，这将非常有用。但是不要滥用它，因为它可能会导致意想不到的结果(什么都不会重置！).</p><h1 id="ba1e" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">它是如何工作的</h1><p id="5961" class="pw-post-body-paragraph jx jy it jz b ka ly kc kd ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku im bi translated">在本文中，我选择更详细地介绍技术背景噪声。如果你对这部分不感兴趣，直接跳到结论！</p><h2 id="0ccd" class="mn lb it bd lc mt mu dn lg mv mw dp lk ki mx my lo km mz na ls kq nb nc lw nd bi translated">规则</h2><p id="6314" class="pw-post-body-paragraph jx jy it jz b ka ly kc kd ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku im bi translated">每当创建一个动态对象时，你基本上就创建了一个可观察的对象。它实际上有一个subscribe()函数！</p><pre class="md me mf mg gt mj kz mk ml aw mm bi"><span id="88ed" class="mn lb it kz b gy mo mp l mq mr">const test = DynamicCSS();</span><span id="233c" class="mn lb it kz b gy ms mp l mq mr">// foo is a classname for who is subscribing<br/>test.subscribe('foo', () =&gt; {<br/>  console.log('ho ! ho !');<br/>});</span><span id="376e" class="mn lb it kz b gy ms mp l mq mr">test.refresh(); // ho ! ho !</span></pre><p id="9861" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但是有一个主要的区别:每次通知订阅者时，他们都会被取消订阅！继续阅读了解原因。</p><h2 id="e377" class="mn lb it bd lc mt mu dn lg mv mw dp lk ki mx my lo km mz na ls kq nb nc lw nd bi translated">上层社会</h2><p id="2ec4" class="pw-post-body-paragraph jx jy it jz b ka ly kc kd ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku im bi translated">每次你试图在electronic中刷新一个CSS对象时，它*不会*试图直接在样式表中编辑它:那会是太多的工作，因为你通常有多个规则集用于同一个类(伪元素，如:hover、containments、media-query等……)，并且过滤所有潜在的候选对象需要遍历整个样式表。相反，ElectronCSS将简单地交换元素的类名:</p><pre class="md me mf mg gt mj kz mk ml aw mm bi"><span id="26e4" class="mn lb it kz b gy mo mp l mq mr">const test = DynamicCSS({<br/>  foo: 'bar'<br/>});</span><span id="f793" class="mn lb it kz b gy ms mp l mq mr">const testCSS = CSS({<br/>  color: test.foo<br/>});</span><span id="ebb3" class="mn lb it kz b gy ms mp l mq mr">console.log(testCSS.toString()) // .class0</span><span id="471a" class="mn lb it kz b gy ms mp l mq mr">test.use({foo: 'notbar'});</span><span id="13e5" class="mn lb it kz b gy ms mp l mq mr">console.log(testCSS.toString()) // .class1</span></pre><p id="5c1f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">它会操纵你的DOM来应用这个新类。在呈现时，这个新类将根据它们的定义订阅您的DynamicCSS规则。</p><p id="0a12" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">旧班级会发生什么？它们只是被ElectronCSS的内部垃圾收集器删除了！</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="0626" class="la lb it bd lc ld nl lf lg lh nm lj lk ll nn ln lo lp no lr ls lt np lv lw lx bi translated">结论</h1><p id="383c" class="pw-post-body-paragraph jx jy it jz b ka ly kc kd ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku im bi translated">主题和布局有时令人头疼，你的堆栈越复杂，就越难在整个应用程序中正确地更新和传播你的CSS定制。就CSS-in-JS代码质量而言，electronicss提出了一个既直观又符合electronicss标准的解决方案。如果掌握得好，它将允许重要的UI库提供非常灵活的主题选项，而不会牺牲易用性和直观性。</p><p id="0588" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">感谢阅读！让我知道你的想法，非常感谢你的反馈！</p><div class="nq nr gp gr ns nt"><a href="https://twitter.com/stepienik" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">扬·斯特皮尼克(@斯特皮尼克)|推特</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">Yann Stepienik (@stepienik)的最新推文。土豆工程。纽约州纽约市</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">twitter.com</p></div></div></div></a></div></div></div>    
</body>
</html>