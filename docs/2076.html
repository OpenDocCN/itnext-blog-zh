<html>
<head>
<title>Let’s Dockerize a Nodejs Express API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们对Nodejs Express API进行Dockerize</h1>
<blockquote>原文：<a href="https://itnext.io/lets-dockerize-a-nodejs-express-api-22700b4105e4?source=collection_archive---------0-----------------------#2019-03-27">https://itnext.io/lets-dockerize-a-nodejs-express-api-22700b4105e4?source=collection_archive---------0-----------------------#2019-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f753" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从Hello World到持续发展。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/28f9b7f366ac8035001dee056d8e282a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W4DwYGZCe2tMlcUIdDF0Sg.jpeg"/></div></div></figure><h2 id="d9c9" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">NodeJS Hello World！</h2><p id="ad64" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">首先，让我们创建一个包含简单GET route的最小nodejs api。对于这个例子，我将使用expressjs，这是一个流行的nodejs框架。</p><ol class=""><li id="1698" class="mg mh iq lp b lq mi lt mj la mk le ml li mm mf mn mo mp mq bi translated">初始化新的npm项目</li></ol><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="7e6d" class="kr ks iq ms b gy mw mx l my mz">npm init</span></pre><p id="efd3" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">2.创建所需的文件</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="f086" class="kr ks iq ms b gy mw mx l my mz">touch .gitignore<br/>touch .dockerignore<br/>touch server.js</span></pre><p id="6496" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">3.忽略你的。使用<strong class="lp ir">意外提交到git的env和secrets。gitignore </strong>同样，使用。阻止文件打包成docker镜像。</p><p id="9d83" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">4.让我们使用expressjs创建一个简单的服务器。为此，我们将需要以下软件包</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="a57e" class="kr ks iq ms b gy mw mx l my mz">npm install --save express cors body-parser @rama41222/node-logger</span></pre><p id="e1ad" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">6.为了持续开发，您将需要nodemon。将nodemon作为开发依赖项安装。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="2585" class="kr ks iq ms b gy mw mx l my mz">npm install --save-dev nodemon</span></pre><p id="bc3a" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">5.安装完这些包之后，创建server.js，如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">server.js</figcaption></figure><p id="0562" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">6.转到package.json，在脚本下创建以下命令</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="6e4d" class="kr ks iq ms b gy mw mx l my mz">"scripts": {<br/>  "start": "node server.js",<br/>  "dev": "nodemon server.js"<br/>}</span></pre><p id="bdc1" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">7.让我们运行它</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="561b" class="kr ks iq ms b gy mw mx l my mz">npm run dev</span></pre><p id="54a2" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">8.如果您的api运行良好，您应该会看到下面的日志。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="b72b" class="kr ks iq ms b gy mw mx l my mz"><em class="nj">2019–03–27 00:25:56 info: sample-express-app running on 0.0.0.0:3000</em></span></pre><p id="65a2" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">我们几乎完成了nodejs编码。现在让我们进入docker。</p><h2 id="1593" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">Docker文件</h2><ol class=""><li id="c4b8" class="mg mh iq lp b lq lr lt lu la nk le nl li nm mf mn mo mp mq bi translated">首先创建一个<strong class="lp ir"> Dockerfile </strong>和一个<strong class="lp ir"> docker-compose.yml </strong>来使用docker运行nodejs api。</li></ol><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="38f3" class="kr ks iq ms b gy mw mx l my mz">touch Dockerfile<br/>touch docker-compose.yml</span></pre><p id="83ca" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">2.让我们创建Dockerfile和docker-compose.yml，如下所示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">docker-compse.yml和Dockerfile</figcaption></figure><h2 id="5f9e" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">让我们快速浏览一下Dockerfile文件</h2><p id="0ff8" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">所以在docker文件中，我们使用的是<strong class="lp ir"> alpine </strong>图像，因为它非常简单、重量轻且更安全。Alpine Linux基于<em class="nj"> musl libc </em>和<em class="nj"> busybox。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/8e05876bfd61d2dbf5b02ba3ae783e18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DmFpyNq__ebT3MFE_ud-uw.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated"><strong class="bd kt"> alpine </strong> linux图像大小</figcaption></figure><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="905d" class="kr ks iq ms b gy mw mx l my mz"><strong class="ms ir">FROM </strong>node:11-alpine</span></pre><p id="2713" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated"><a class="ae no" href="https://docs.docker.com/engine/reference/builder/#run" rel="noopener ugc nofollow" target="_blank">运行</a>是一个映像构建步骤，容器的状态在一个<code class="fe np nq nr ms b">RUN</code>命令后将被提交到docker映像中。一个docker文件可以有许多<code class="fe np nq nr ms b">RUN</code>步骤，这些步骤层层叠加来构建图像。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="e8c0" class="kr ks iq ms b gy mw mx l my mz"><strong class="ms ir">RUN </strong>mkdir <strong class="ms ir">-</strong>p <strong class="ms ir">/</strong>usr<strong class="ms ir">/</strong>src<strong class="ms ir">/</strong>app</span></pre><p id="0a85" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">然后，我们通过下面的命令设置默认的工作目录</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="cbb3" class="kr ks iq ms b gy mw mx l my mz"><strong class="ms ir">WORKDIR /</strong>usr<strong class="ms ir">/</strong>src<strong class="ms ir">/</strong>app</span></pre><p id="185e" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">将所有文件复制到映像</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="cdeb" class="kr ks iq ms b gy mw mx l my mz"><strong class="ms ir">COPY </strong>. .</span></pre><p id="b5fc" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">安装软件包</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="1951" class="kr ks iq ms b gy mw mx l my mz"><strong class="ms ir">RUN </strong>npm install</span></pre><p id="f071" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">现在，我们必须向外界公开API运行端口，以便接收请求。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="49e5" class="kr ks iq ms b gy mw mx l my mz"><strong class="ms ir">EXPOSE </strong>3000</span></pre><p id="e168" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated"><a class="ae no" href="https://docs.docker.com/engine/reference/builder/#cmd" rel="noopener ugc nofollow" target="_blank"> CMD </a>是启动构建映像时容器默认执行的命令。一个Dockerfile只能有一个<code class="fe np nq nr ms b">CMD</code>。使用<code class="fe np nq nr ms b">docker run $image $other_command</code>启动集装箱时，可以覆盖<code class="fe np nq nr ms b">CMD</code>。</p><p id="73c0" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated"><a class="ae no" href="https://docs.docker.com/engine/reference/builder/#entrypoint" rel="noopener ugc nofollow" target="_blank">入口点</a>也与<code class="fe np nq nr ms b">CMD</code>密切相关，可以修改容器启动图像的方式</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="9d86" class="kr ks iq ms b gy mw mx l my mz"><strong class="ms ir">CMD </strong>["npm", "run", "start"]</span></pre><h2 id="a0a9" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">让我们使用docker运行API</h2><ol class=""><li id="d813" class="mg mh iq lp b lq lr lt lu la nk le nl li nm mf mn mo mp mq bi translated">让我们建立docker图像</li></ol><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="b9f4" class="kr ks iq ms b gy mw mx l my mz">docker-compose build</span></pre><p id="2b3a" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">2.让我们运行容器。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="6782" class="kr ks iq ms b gy mw mx l my mz">docker-compose up</span></pre><p id="c97c" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">3.让我们在后台运行上面的命令</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="0e05" class="kr ks iq ms b gy mw mx l my mz">docker-compose up -d</span></pre><p id="835b" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">看看下面的命令。它们非常有用</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="77e5" class="kr ks iq ms b gy mw mx l my mz">docker-compose stop<br/>docker-compose start<br/>docker-compose run &lt;custom service&gt;</span></pre><ul class=""><li id="a0b5" class="mg mh iq lp b lq mi lt mj la mk le ml li mm mf ns mo mp mq bi translated">当你在后台运行docker容器时，如果你想查看控制台输出，使用下面的命令。T3】</li></ul><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="86b0" class="kr ks iq ms b gy mw mx l my mz">docker logs $(sudo docker ps -aq --filter name=&lt;&gt;</span></pre><ul class=""><li id="65b3" class="mg mh iq lp b lq mi lt mj la mk le ml li mm mf ns mo mp mq bi translated"><strong class="lp ir"> <em class="nj">为现场控制台输出</em> </strong></li></ul><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="987d" class="kr ks iq ms b gy mw mx l my mz">docker logs -f &lt;CONTAINER&gt;</span></pre></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><h1 id="a81e" class="oa ks iq bd kt ob oc od kw oe of og kz jw oh jx ld jz oi ka lh kc oj kd ll ok bi translated">使用Nodemon动态更改运行容器的内容。</h1></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="4e83" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">为此，我们需要实现一个叫做卷映射的东西，为此，您必须使用docker-compose来映射卷。</p><p id="226e" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">将卷映射添加到docker-compose.yml中</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="dafe" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">现在，如果我们在本地机器上更改一个文件，它也必须反映在docker容器上。这是因为我们正在映射卷。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="c15c" class="kr ks iq ms b gy mw mx l my mz">volumes:<br/> hostDir:WorkDir</span></pre><p id="e652" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">现在试着在server.js文件中做些改变，并检查您的server.js是否重新启动。如果到目前为止您一直在学习本教程，它应该还没有重启服务器，因为我们没有在Dockerfile CMD中使用nodemon。现在就用吧。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="2786" class="kr ks iq ms b gy mw mx l my mz"><strong class="ms ir">CMD </strong>["npm", "run", "dev"]</span></pre><p id="6e9c" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">改了这个之后。使用docker compose构建映像，然后运行它。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="4ebb" class="kr ks iq ms b gy mw mx l my mz">docker-compose down<br/>docker-compose build<br/>docker-compose up</span></pre><p id="67ce" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">现在更改server.js文件并检查服务器是否重新启动。因此，如果它正在重新启动，你已经成功地完成了本教程。</p><p id="63c6" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">所以使用这种方法，我们也可以使用docker进行持续开发。我在github上创建了一个资源库。你可以参考一下。</p><p id="4651" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la na lx ly le nb ma mb li nc md me mf ij bi translated">终于！！！！去集装箱！！！。再见。</p></div></div>    
</body>
</html>