# 如何单元测试角形 CanDeactivate 防护装置

> 原文：<https://itnext.io/how-to-unit-test-angular-candeactivate-guards-82dd51e4cccd?source=collection_archive---------4----------------------->

![](img/42e8c78880c3c22ae9ceb3ba1b996daa.png)

纽约洛克菲勒中心的保安。2018 贾里德·尤塞

CanDeactivate guards 通常用于防止用户离开肮脏的表单，即编辑内容未保存的表单。我今天在工作中发现自己处于这种情况，并且无法在 web 上找到如何对防护进行单元测试的解决方案。问题在于，防护是依赖于组件的服务，而不是相反。这和我迄今为止看到的所有模式完全相反。因此，我深入研究并开始试验，对角度依赖注入的内部工作方式有了更好的理解。最后，如果你使用一个接口而不是一个硬组件依赖，那就更有意义了。

我建议先把[回购](https://github.com/fivedice/ngx-candeactivate-test)分出来，玩一玩，了解一下它是如何运作的。我们不会详细讨论组件和 UI，只讨论测试的防护和实现。你会想看看 GuardedComponent 并理解它的 canDeactivate 方法，但是为了测试，我们只需要理解它，因为它完全被模仿掉了。

首先，我们从一个接口开始，这个接口允许我们以抽象的方式处理任何需要这种保护的组件。这将使嘲笑变得容易得多。

警卫本身就很直白。它实现了`CanDeactivate<T>`，其中 T 是我们的接口。它验证实现该接口的组件是否正确执行了该操作(第 11 行)(*注意:这似乎是一种常见的模式，以防你设法欺骗编译器？*)然后调用接口方法。就是这样。

在单元测试中，我们想要模拟实现接口的实际组件。我们不希望在测试中必须导入并提供所有组件的依赖项。在我们的 spec 文件中，我们将添加一个实现接口的 MockComponent。(*注意:我们还没有用* `@Component` *来装饰它，但是我们可以，而且它仍然可以工作。*)在第 3 行，我们添加了一个`returnValue: boolean`，我们可以在测试中设置它，这样我们就可以模拟真实组件的 canDeactivate 响应。

现在，让我们看看我们的测试设置:

注意第 9 行。我们提供我们的模拟就像一项服务！对，这个真的管用！即使没有所有常见的装饰。

现在，我们要做的就是为不同的场景设置 mockComponent 的 returnValue。

在第一个测试中，我们从组件中的 canActivate 返回一个布尔值。例如，当表单不脏时，真正的组件会这样做。如果你试图从原始形态航行，警卫不会阻止你。在这种情况下，我们只是根据用户是否在 UI 中打开了保护来决定。

在第二个和第三个测试中，我们返回了一个可观察的结果，就像用户打开了 UI 中的防护。这将导致显示灌注确认对话框。它有`accept()`和`reject()`方法，在支持可观察对象的主题上分别调用`next(true)`和`next(false)`。

不可否认，我一开始是在没有接口的情况下构建所有这些的。因此，我的模拟扩展 GuardedComponent。它是一个组件。因此，我必须导入我所有的依赖项。将组件视为提供者是一件非常落后的事情！但它确实起作用了！这个界面清理了很多东西，并且更加符合官方的 Angular 文档。

我对“记录你所学到的东西”这种事情还很陌生。我希望这能对你有所帮助，我很好奇你是否以不同的方式处理了这个问题。

感谢阅读，如果你喜欢这篇文章，请给我一些掌声。