<html>
<head>
<title>Golang Error Handling — Best Practice in 2020</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang错误处理—2020年最佳实践</h1>
<blockquote>原文：<a href="https://itnext.io/golang-error-handling-best-practice-a36f47b0b94c?source=collection_archive---------0-----------------------#2019-12-25">https://itnext.io/golang-error-handling-best-practice-a36f47b0b94c?source=collection_archive---------0-----------------------#2019-12-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7a50d554f820bd10b2094b8121014f00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v1_qFGBq5cfbPm1xaeY_AQ.png"/></div></div></figure><p id="82e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Golang有很多优点，它的受欢迎程度说明了这一点。但是Go 1中的错误处理不是很高效，我们在日常开发中要写很多冗长、不方便的代码。</p><p id="7cd4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有几种开源解决方案可以解决这个问题。与此同时，Go团队正在从语言和标准库两个方面对此进行改进。</p><p id="67a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">今天，我们将分析常见问题，比较解决方案，并展示目前的最佳实践(go 1.13)。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="ed29" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">先下结论:我的偏好是<code class="fe lg lh li lj b">github.com/pkg/errors</code>。原因将在下面详细解释。</p><h1 id="135e" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">问题</h1><p id="6b83" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated">在Go中编程时，我们需要检查返回的错误并处理它，一个最简单的例子是这样的:</p><pre class="mn mo mp mq gt mr lj ms mt aw mu bi"><span id="47b3" class="mv ll it lj b gy mw mx l my mz">import (<br/>   "database/sql"<br/>   "fmt"<br/>)<br/><br/>func foo() error {<br/>   return sql.ErrNoRows<br/>}<br/><br/>func bar() error {<br/>   return foo()<br/>}<br/><br/>func main() {<br/>   err := bar()<br/>   if <strong class="lj iu">err != nil</strong> {<br/>      fmt.Printf("got err, %+v\n", err)<br/>   }<br/>}<br/>//Outputs:<br/>// got err, sql: no rows in result set</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="19bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有时我们需要根据不同类型的错误进行不同的处理:</p><pre class="mn mo mp mq gt mr lj ms mt aw mu bi"><span id="0733" class="mv ll it lj b gy mw mx l my mz">import (<br/>   "database/sql"<br/>   "fmt"<br/>)<br/><br/>func foo() error {<br/>   return sql.ErrNoRows<br/>}<br/><br/>func bar() error {<br/>   return foo()<br/>}<br/><br/>func main() {<br/>   err := bar()<br/>   if <strong class="lj iu">err == sql.ErrNoRows</strong> {<br/>      fmt.Printf("data not found, %+v\n", err)<br/>      return<br/>   }<br/>   if err != nil {<br/>      // Unknown error<br/>   }<br/>}<br/>//Outputs:<br/>// data not found, sql: no rows in result set</span></pre><p id="82af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在实践中，我们经常在错误返回之前添加额外的上下文。上下文将帮助呼叫者理解正在发生什么。例如，我们可以重写函数<code class="fe lg lh li lj b">foo</code>:</p><pre class="mn mo mp mq gt mr lj ms mt aw mu bi"><span id="8912" class="mv ll it lj b gy mw mx l my mz">func foo() error {<br/>   return fmt.Errorf("foo err, %v", sql.ErrNoRows)<br/>}</span></pre><p id="6da8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么<code class="fe lg lh li lj b">err == sql.ErrNoRows</code>条件将变为假。此外，当返回错误时，调用堆栈会被丢弃，这是最重要的诊断信息。我们需要一个更灵活的方法来处理这些问题。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="967a" class="lk ll it bd lm ln na lp lq lr nb lt lu lv nc lx ly lz nd mb mc md ne mf mg mh bi translated">解决方法</h1><p id="7d32" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated">有几种方法可以解决这个问题。用这些库包装错误将保持根错误和完整调用堆栈的可访问性</p><h1 id="67db" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">1.github.com/pkg/errors</h1><p id="fb88" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated">从<a class="ae nf" href="https://dave.cheney.net/" rel="noopener ugc nofollow" target="_blank">戴夫·切尼</a>开始，这个库有3个关键方法:</p><ol class=""><li id="3d4d" class="ng nh it kd b ke kf ki kj km ni kq nj ku nk ky nl nm nn no bi translated"><code class="fe lg lh li lj b">Wrap</code>用于包装底层错误，添加上下文文本信息，附加调用栈。一般来说，它用于包装其他人(标准库或第三方库)对API的调用。</li><li id="3720" class="ng nh it kd b ke np ki nq km nr kq ns ku nt ky nl nm nn no bi translated"><code class="fe lg lh li lj b">WithMessage</code>用于向底层错误添加上下文文本信息，而不附加调用堆栈。仅对“包装错误”应用此方法。注意:不要重复<code class="fe lg lh li lj b">Wrap</code>，它会记录冗余调用栈</li><li id="916d" class="ng nh it kd b ke np ki nq km nr kq ns ku nt ky nl nm nn no bi translated"><code class="fe lg lh li lj b">Cause</code>方法用于确定潜在误差</li></ol><p id="8828" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用<code class="fe lg lh li lj b">github.com/pkg/errors</code>重写上面的例子:</p><pre class="mn mo mp mq gt mr lj ms mt aw mu bi"><span id="63d0" class="mv ll it lj b gy mw mx l my mz">import (<br/>   "database/sql"<br/>   "fmt"<br/><br/>   "github.com/pkg/errors"<br/>)<br/><br/>func foo() error {<br/>   return <strong class="lj iu">errors.Wrap</strong>(sql.ErrNoRows, "foo failed")<br/>}<br/><br/>func bar() error {<br/>   return <strong class="lj iu">errors.WithMessage</strong>(foo(), "bar failed")<br/>}<br/><br/>func main() {<br/>   err := bar()<br/>   if <strong class="lj iu">errors.Cause</strong>(err) == sql.ErrNoRows {<br/>      fmt.Printf("data not found, <strong class="lj iu">%v</strong>\n", err)<br/>      fmt.Printf("<strong class="lj iu">%+v</strong>\n", err)<br/>      return<br/>   }<br/>   if err != nil {<br/>      // unknown error<br/>   }<br/>}</span><span id="990c" class="mv ll it lj b gy nu mx l my mz">/*Output:</span><span id="ec14" class="mv ll it lj b gy nu mx l my mz">data not found, bar failed: foo failed: sql: no rows in result set<br/>sql: no rows in result set<br/>foo failed<br/>main.foo<br/>    /usr/three/main.go:11<br/>main.bar<br/>    /usr/three/main.go:15<br/>main.main<br/>    /usr/three/main.go:19<br/>runtime.main<br/>    ...</span><span id="36c3" class="mv ll it lj b gy nu mx l my mz">*/</span></pre><p id="f13c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们使用<code class="fe lg lh li lj b">%v</code>作为格式参数，我们将得到一个单行输出字符串，按照调用堆栈的顺序包含所有上下文文本。如果将格式参数改为<code class="fe lg lh li lj b">%+v</code>，我们将得到完整的调用栈。</p><p id="0e0f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想简单地用附加调用栈包装错误，不需要额外的上下文文本，那么使用<code class="fe lg lh li lj b">WithStack</code></p><pre class="mn mo mp mq gt mr lj ms mt aw mu bi"><span id="196d" class="mv ll it lj b gy mw mx l my mz">func foo() error {<br/>   return errors.WithStack(sql.ErrNoRows)<br/>}</span></pre><p id="00f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意:当使用<code class="fe lg lh li lj b">Wrap</code>、<code class="fe lg lh li lj b">WithMessage</code>或<code class="fe lg lh li lj b">WithStack</code>时，如果err参数为nil，则返回nil，这意味着我们在调用方法之前不需要检查<code class="fe lg lh li lj b">err != nil</code>条件。保持代码简单</p><h1 id="40e4" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">2.golang.org/x/xerrors</h1><p id="45e9" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated">在听取了来自社区的反馈后，Go团队发布了一个<a class="ae nf" href="https://go.googlesource.com/proposal/+/master/design/29934-error-values.md" rel="noopener ugc nofollow" target="_blank">提案</a>来简化Go 2中的错误处理。Go核心团队成员<a class="ae nf" href="https://research.swtch.com/" rel="noopener ugc nofollow" target="_blank"> Russ Cox </a>在<code class="fe lg lh li lj b">golang.org/x/xerrors</code>部分实施了该提议。它用类似于<code class="fe lg lh li lj b">github.com/pkg/errors</code>的方法解决了同样的问题，引入了一个格式动词<code class="fe lg lh li lj b">: %w</code>，并使用方法<code class="fe lg lh li lj b">Is</code>来确定底层错误。</p><pre class="mn mo mp mq gt mr lj ms mt aw mu bi"><span id="0236" class="mv ll it lj b gy mw mx l my mz">import (<br/>   "database/sql"<br/>   "fmt"<br/><br/>   "golang.org/x/xerrors"<br/>)<br/><br/>func bar() error {<br/>   if err := foo(); err != nil {<br/>      return <strong class="lj iu">xerrors.Errorf</strong>("bar failed<strong class="lj iu">: %w</strong>", foo())<br/>   }<br/>   return nil<br/>}<br/><br/>func foo() error {<br/>   return <strong class="lj iu">xerrors.Errorf</strong>("foo failed<strong class="lj iu">: %w</strong>", sql.ErrNoRows)<br/>}<br/><br/>func main() {<br/>   err := bar()<br/>   if <strong class="lj iu">xerrors.Is</strong>(err, sql.ErrNoRows) {<br/>      fmt.Printf("data not found, %v\n", err)<br/>      fmt.Printf("%+v\n", err)<br/>      return<br/>   }<br/>   if err != nil {<br/>      // unknown error<br/>   }<br/>}<br/>/* Outputs:</span><span id="6501" class="mv ll it lj b gy nu mx l my mz">data not found, bar failed: foo failed: sql: no rows in result set<br/>bar failed:<br/>    main.bar<br/>        /usr/four/main.go:12<br/>  - foo failed:<br/>    main.foo<br/>        /usr/four/main.go:18<br/>  - sql: no rows in result set<br/>*/</span></pre><p id="878a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与<code class="fe lg lh li lj b">github.com/pkg/errors</code>相比，它有几个缺点:</p><ol class=""><li id="eaf4" class="ng nh it kd b ke kf ki kj km ni kq nj ku nk ky nl nm nn no bi translated">用格式参数<code class="fe lg lh li lj b">: %w</code>替换<code class="fe lg lh li lj b">Wrap</code>。看起来简化了代码，但是这种方法<strong class="kd iu">失去了编译时检查</strong>。如果<code class="fe lg lh li lj b">: %w</code>不是格式字符串的尾部(<code class="fe lg lh li lj b">e.g., "foo : %w bar"</code>)，或者缺少冒号(<code class="fe lg lh li lj b">e.g., "foo %w"</code>)，或者冒号和百分号之间缺少空格(<code class="fe lg lh li lj b">e.g., "foo:%w"</code>)，换行会失败，不会有任何警告</li><li id="9a01" class="ng nh it kd b ke np ki nq km nr kq ns ku nt ky nl nm nn no bi translated">更严重的是打<code class="fe lg lh li lj b">xerrors.Errorf</code>之前还要检查病情<code class="fe lg lh li lj b">err != nil </code>。这实际上根本没有简化开发人员的工作</li></ol><h1 id="5157" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">3.Go 1.13中内置的错误包装支持</h1><p id="8929" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated">从Go 1.13开始，<code class="fe lg lh li lj b">xerrors</code>的部分(不是全部)特性已经集成到标准库中。它继承了<code class="fe lg lh li lj b">xerrors</code>的所有缺点，贡献了一个额外的one☹️.因此，我建议目前不要使用它</p><pre class="mn mo mp mq gt mr lj ms mt aw mu bi"><span id="ae85" class="mv ll it lj b gy mw mx l my mz">import (<br/>   "database/sql"<br/>   "errors"<br/>   "fmt"<br/>)<br/><br/>func bar() error {<br/>   if err := foo(); err != nil {<br/>      return <strong class="lj iu">fmt.Errorf</strong>("bar failed<strong class="lj iu">: %w</strong>", foo())<br/>   }<br/>   return nil<br/>}<br/><br/>func foo() error {<br/>   return <strong class="lj iu">fmt.Errorf</strong>("foo failed<strong class="lj iu">: %w</strong>", sql.ErrNoRows)<br/>}<br/><br/>func main() {<br/>   err := bar()<br/>   if <strong class="lj iu">errors.Is</strong>(err, sql.ErrNoRows) {<br/>      fmt.Printf("data not found,  %+v\n", err)<br/>      return<br/>   }<br/>   if err != nil {<br/>      // unknown error<br/>   }<br/>}<br/>/* Outputs:<br/>data not found,  bar failed: foo failed: sql: no rows in result set<br/>*/</span></pre><p id="8969" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">类似于<code class="fe lg lh li lj b">xerrors</code>版本。但是它<a class="ae nf" href="https://github.com/golang/go/issues/29934#issuecomment-489682919" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">不支持调用栈输出</strong> </a>。而且根据<a class="ae nf" href="https://github.com/golang/go/issues/34349" rel="noopener ugc nofollow" target="_blank">官方说法</a>来看，这个是没有时间表的。所以目前<code class="fe lg lh li lj b">github.com/pkg/errors</code>是更好的选择</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="28d2" class="lk ll it bd lm ln na lp lq lr nb lt lu lv nc lx ly lz nd mb mc md ne mf mg mh bi translated">总结</h1><p id="308d" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated">通过以上比较，我相信你已经做出了选择。让我说清楚。我的选择顺序是1&gt; 2&gt; 3</p><ol class=""><li id="21af" class="ng nh it kd b ke kf ki kj km ni kq nj ku nk ky nl nm nn no bi translated">如果你用的是<code class="fe lg lh li lj b">github.com/pkg/errors</code>，那就留着吧。目前没有比这更好的解决方案了</li><li id="f130" class="ng nh it kd b ke np ki nq km nr kq ns ku nt ky nl nm nn no bi translated">如果你已经大量使用<code class="fe lg lh li lj b">golang.org/x/xerrors</code>，不要匆忙切换到内置解决方案，那不值得</li></ol><p id="16cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">平心而论，围棋自诞生以来，在大多数方面已经相当成熟和健壮。在其演变过程中很少出现犹豫和摇摆。但是错误处理是个例外。</p><p id="374d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">别说广受抱怨的<code class="fe lg lh li lj b">if err != nil</code>，就连它的改进路线图都是那么有争议。实际上Go团队<a class="ae nf" href="https://github.com/golang/go/issues/32437#issuecomment-512035919" rel="noopener ugc nofollow" target="_blank">已经调整了</a>一个<a class="ae nf" href="https://github.com/golang/go/issues/32437" rel="noopener ugc nofollow" target="_blank">提案</a>由于压倒性的反对。</p><p id="ce25" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">幸运的是，Go团队比以前更愿意听取社区的意见，他们甚至专门针对这个问题建立了一个<a class="ae nf" href="https://github.com/golang/go/wiki/Go2ErrorHandlingFeedback" rel="noopener ugc nofollow" target="_blank">反馈页面</a>。我相信我们最终会找到更好的解决方案</p><h1 id="869f" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">最后一个音符</h1><p id="5f61" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated">虽然我们讨论了如何高效、优雅地包装错误，但是像其他技术一样，它应该只在适当的地方使用。不应将其视为一般原则。</p><p id="8109" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为什么？当用户开始使用<code class="fe lg lh li lj b">errors.Cause(err, sql.ErrNoRows)</code>或<code class="fe lg lh li lj b">xerrors.Is (err, sql.ErrNoRows)</code>时，意味着<code class="fe lg lh li lj b">sql.ErrNoRows</code>作为一个实现细节被暴露给了外界，成为API的一部分。</p><p id="f901" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你正在用一些库进行应用程序开发，这是可以接受的。</p><p id="a1cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，如果您正在定义一些公共API，这个问题就变得特别重要。也许更好的方法是定义一个基本的错误类型，然后从中派生出不同的错误实例，并附上错误代码</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="7987" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">参见:<a class="ae nf" href="https://medium.com/@dche423/mastering-wire-f1226717bbac" rel="noopener">掌握钢丝</a></p></div></div>    
</body>
</html>