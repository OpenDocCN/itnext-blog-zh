<html>
<head>
<title>The Ideas Behind React Easy State</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Easy State背后的想法</h1>
<blockquote>原文：<a href="https://itnext.io/the-ideas-behind-react-easy-state-901d70e4d03e?source=collection_archive---------2-----------------------#2018-02-14">https://itnext.io/the-ideas-behind-react-easy-state-901d70e4d03e?source=collection_archive---------2-----------------------#2018-02-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/38e187273196f1ce9ea795b0a7074afa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XfsCM-sSrmRwydcsVxQePA.jpeg"/></div></div></figure><div class=""/><p id="8de6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前端开发人员经常将透明反应(MobX、Vue或<a class="ae kw" href="https://github.com/solkimicreb/react-easy-state" rel="noopener ugc nofollow" target="_blank"> React Easy State </a>的核心)称为魔法，但这并没有什么神奇之处。它基于一个非常简单的想法，我将用下面的片段和一些常识来演示。</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="d547" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以完美地定义何时重新呈现<code class="fe ld le lf lg b">NotesApp</code>和<code class="fe ld le lf lg b">Note</code>:何时添加或删除新注释，以及何时修改作者或注释的文本。幸运的是，这一结论不是由复杂的人类直觉，而是简单的可编程if-else逻辑驱动的。</p><blockquote class="lh li lj"><p id="d863" class="jy jz lk ka b kb kc kd ke kf kg kh ki ll kk kl km lm ko kp kq ln ks kt ku kv ij bi translated">如果状态存储的一部分(在组件的渲染中使用)发生变化，请重新渲染组件以反映新的状态。</p></blockquote><p id="84a6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你的大脑正在创建以下关于物体属性的三元关系——在渲染方法中使用。</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="lb lc l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">当object.property改变时-&gt;重新渲染组件</figcaption></figure><p id="2e3e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当一个对象的属性被修改时，它会查找属于那个<code class="fe ld le lf lg b">(object, property)</code>对的所有组件，并想象性地重新渲染它们。让我们在现实生活中这样做吧！</p><p id="5f5d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lk">本文的其余部分假设您对ES6代理和React Easy State有基本的了解。如果你不知道我在说什么，快速看一下</em><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener ugc nofollow" target="_blank"><em class="lk">MDN Proxy docs</em></a><em class="lk">和我的</em> <a class="ae kw" href="https://hackernoon.com/introducing-react-easy-state-1210a156fa16" rel="noopener ugc nofollow" target="_blank"> <em class="lk">介绍React Easy State </em> </a> <em class="lk">的文章就够了。</em></p><h1 id="8c64" class="ls lt jb bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">制作反应堆芯</h1><p id="2cc5" class="pw-post-body-paragraph jy jz jb ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">为了构建<code class="fe ld le lf lg b">(object, property, component)</code>关系，我们必须知道<code class="fe ld le lf lg b">NotesApp</code>和<code class="fe ld le lf lg b">Note</code>在渲染时使用了哪些对象和属性。开发人员可以通过看一眼代码就知道这一点，但是库却不能。</p><p id="96ca" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要知道对象的属性何时发生变化，以便从保存的关系中收集相关的组件并呈现它们。</p><p id="78cb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这两个问题都可以用ES6代理来解决。</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="68e8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ld le lf lg b">store</code>代理拦截所有的属性获取和设置操作，并分别构建和查询关系表。</p><p id="2e29" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有一个大问题:get陷阱中的<code class="fe ld le lf lg b">currentlyRenderingComp</code>是什么，我们如何知道哪个组件正在渲染？这就是<code class="fe ld le lf lg b">view</code>发挥作用的地方。</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="a20c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ld le lf lg b">view</code>包装一个组件并用一个简单的逻辑检测它的<code class="fe ld le lf lg b">render</code>方法。它在组件渲染时为组件设置了<code class="fe ld le lf lg b">currentlyRenderingComp</code>标志。这样，我们就拥有了在get陷阱中建立关系所需的所有信息。<code class="fe ld le lf lg b">object</code>和<code class="fe ld le lf lg b">property</code>来自陷阱参数，<code class="fe ld le lf lg b">component</code>是<code class="fe ld le lf lg b">currentlyRenderingComp</code>—<code class="fe ld le lf lg b">view</code>设置的。</p><p id="54f4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们回到notes应用程序，看看反应式代码中发生了什么。</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="lb lc l"/></div></figure><ol class=""><li id="2abd" class="mv mw jb ka b kb kc kf kg kj mx kn my kr mz kv na nb nc nd bi translated"><code class="fe ld le lf lg b">NotesApp</code>第一次渲染。</li><li id="93ba" class="mv mw jb ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated"><code class="fe ld le lf lg b">view</code>在渲染时将<code class="fe ld le lf lg b">currentlyRenderingComp</code>设置为<code class="fe ld le lf lg b">NotesApp</code>组件。</li><li id="2039" class="mv mw jb ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated"><code class="fe ld le lf lg b">NotesApp</code>迭代<code class="fe ld le lf lg b">notes</code>数组，并为每个音符呈现一个<code class="fe ld le lf lg b">Note</code>。</li><li id="a368" class="mv mw jb ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated"><code class="fe ld le lf lg b">notes</code>周围的代理拦截所有get操作，保存<code class="fe ld le lf lg b">NotesApp</code>使用<code class="fe ld le lf lg b">notes.length</code>渲染的事实。它创建了一个<code class="fe ld le lf lg b">(notes, length, NotesApp)</code>关系。</li><li id="ad10" class="mv mw jb ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">用户添加了新的注释，这改变了<code class="fe ld le lf lg b">notes.length</code>。</li><li id="78bf" class="mv mw jb ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">我们的反应核心查找与<code class="fe ld le lf lg b">(notes, length)</code>相关的所有组件，并重新渲染它们。</li><li id="02d2" class="mv mw jb ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">在我们的例子中:<code class="fe ld le lf lg b">NotesApp</code>被重新渲染。</li></ol><h1 id="3c67" class="ls lt jb bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">真正的挑战</h1><p id="3c0a" class="pw-post-body-paragraph jy jz jb ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">上一节向您展示了如何构建一个乐观的反应式内核，但真正的挑战在于众多的陷阱、边缘案例和设计决策。在本节中，我将简要介绍其中的一些。</p><h2 id="de73" class="nj lt jb bd lu nk nl dn ly nm nn dp mc kj no np mg kn nq nr mk kr ns nt mo nu bi translated">计划渲染</h2><p id="229f" class="pw-post-body-paragraph jy jz jb ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">一个透明的反应性库除了构建、保存、查询和清理相关get/set操作上的那些<code class="fe ld le lf lg b">(object, property, component)</code>关系之外，不应该做任何事情。执行渲染不是工作的一部分。</p><p id="4c09" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简单状态收集属性突变时的陈旧组件，并将它们的呈现传递给调度程序函数。然后，调度程序可以决定何时以及如何呈现它们。在我们的例子中，调度器是一个虚拟的<code class="fe ld le lf lg b">setState</code>，它告诉React:‘我想被渲染，当你喜欢它的时候就做’。</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="lb lc l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">Easy State源代码中的几行代码</figcaption></figure><p id="1f37" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一些反应库没有定制调度器的灵活性，调用<code class="fe ld le lf lg b">forceUpdate</code>而不是<code class="fe ld le lf lg b">setState</code>，翻译过来就是:‘现在渲染我！我不在乎你的优先权。</p><p id="0557" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这还不明显——因为React仍然使用相当简单的<a class="ae kw" href="https://stackoverflow.com/a/48610973" rel="noopener ugc nofollow" target="_blank">渲染批处理</a>逻辑——但随着<a class="ae kw" href="https://edgecoders.com/react-16-features-and-fiber-explanation-e779544bb1b7" rel="noopener ugc nofollow" target="_blank"> React纤程</a>调度器的引入，这将变得更加重要。</p><h2 id="1b47" class="nj lt jb bd lu nk nl dn ly nm nn dp mc kj no np mg kn nq nr mk kr ns nt mo nu bi translated">清理</h2><p id="8ef9" class="pw-post-body-paragraph jy jz jb ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">保存和查询三元关系没有那么难。至少我是这么认为的，直到我不得不自己收拾残局。</p><p id="00e3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果不再使用存储对象或组件，则必须清理它们之间的所有关系。这需要一些交叉引用——因为这些关系必须可以被<code class="fe ld le lf lg b">component</code>、<code class="fe ld le lf lg b">object</code>和<code class="fe ld le lf lg b">(object, property)</code>对查询。长话短说，我搞砸了，Easy State背后的反应核心泄露了整整一年的内存。</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nv"><img src="../Images/95305608c239dd981c7a57460459aac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZfAcmie_9pYYXb8HCrBQDQ.png"/></div></div></figure><p id="546d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在解决这个问题的无数“聪明”的方法之后，我解决了在所有渲染之前擦除组件的每一个关系。在渲染过程中，这些关系将从触发的get陷阱中再次建立。</p><p id="b0e4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可能看起来有点矫枉过正，但是它对性能的影响非常低，并且有两个巨大的好处。</p><ol class=""><li id="b36a" class="mv mw jb ka b kb kc kf kg kj mx kn my kr mz kv na nb nc nd bi translated">我终于修复了内存泄漏。</li><li id="44ff" class="mv mw jb ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">轻松状态变得适应渲染功能。它根据当前的应用程序状态动态地取消观察和重新观察条件分支。</li></ol><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="fc26" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当<code class="fe ld le lf lg b">car.isMoving</code>为假时，<code class="fe ld le lf lg b">Car</code>不会——不必要地——在<code class="fe ld le lf lg b">speed</code>改变时重新渲染。</p><h2 id="ade2" class="nj lt jb bd lu nk nl dn ly nm nn dp mc kj no np mg kn nq nr mk kr ns nt mo nu bi translated">实现代理陷阱</h2><p id="7f29" class="pw-post-body-paragraph jy jz jb ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">Easy State的目标是增加JavaScript的反应性，而不是彻底改变它。为了实现反应性增强，我必须将基本操作分成两组。</p><ul class=""><li id="fe62" class="mv mw jb ka b kb kc kf kg kj mx kn my kr mz kv nw nb nc nd bi translated">Get-like操作从对象中检索数据。这些包括枚举、迭代和简单的属性get/has操作。关系保存在它们的拦截器中。</li><li id="6ba5" class="mv mw jb ka b kb ne kf nf kj ng kn nh kr ni kv nw nb nc nd bi translated">类似集合的操作使数据变异。这些操作包括属性添加、设置和删除操作，它们的拦截器查询关系表中的陈旧组件。</li></ul><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="da5e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在确定了这两个组之后，我必须一个接一个地检查操作，并以无缝的方式给它们添加反应性。这需要对基本的JavaScript操作有深刻的理解，ECMAScript标准在这里有很大的帮助。如果你不知道下面所有问题的答案，请查看一下。</p><ul class=""><li id="c1a7" class="mv mw jb ka b kb kc kf kg kj mx kn my kr mz kv nw nb nc nd bi translated">什么是属性描述符？</li><li id="4f28" class="mv mw jb ka b kb ne kf nf kj ng kn nh kr ni kv nw nb nc nd bi translated">属性集操作遍历原型链吗？</li><li id="b4fb" class="mv mw jb ka b kb ne kf nf kj ng kn nh kr ni kv nw nb nc nd bi translated">可以用<code class="fe ld le lf lg b">delete</code>操作符删除属性访问器吗？</li><li id="bb48" class="mv mw jb ka b kb ne kf nf kj ng kn nh kr ni kv nw nb nc nd bi translated">get操作的目标和接收方有什么区别？他们什么时候能不一样？</li><li id="3f82" class="mv mw jb ka b kb ne kf nf kj ng kn nh kr ni kv nw nb nc nd bi translated">有没有拦截对象枚举的方法？</li></ul><h2 id="e615" class="nj lt jb bd lu nk nl dn ly nm nn dp mc kj no np mg kn nq nr mk kr ns nt mo nu bi translated">管理动态商店树</h2><p id="a9bf" class="pw-post-body-paragraph jy jz jb ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">到目前为止，你已经看到了<code class="fe ld le lf lg b">store</code>用反应代理包装对象，但是这只会产生一个级别的反应属性。为什么<code class="fe ld le lf lg b">person.name.first</code>改变后下面的app会重新渲染？</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="35fc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了支持嵌套属性，我们的reactive core的“get part”必须稍加修改。</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="9e88" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最重要的部分是第15–18行，它需要一些解释。</p><ul class=""><li id="62f6" class="mv mw jb ka b kb kc kf kg kj mx kn my kr mz kv nw nb nc nd bi translated">它通过在获取时将嵌套对象包装在反应存储中，使属性在任意深度上反应迟缓。</li><li id="ca7b" class="mv mw jb ka b kb ne kf nf kj ng kn nh kr ni kv nw nb nc nd bi translated">它只包装在组件渲染中使用的对象——多亏了<code class="fe ld le lf lg b">currentlyRenderingComp</code>检查。其他对象永远不会触发渲染，也不需要反应式仪器。</li><li id="a7bc" class="mv mw jb ka b kb ne kf nf kj ng kn nh kr ni kv nw nb nc nd bi translated">具有缓存的反应式包装器的对象肯定会在组件渲染中使用，因为之前已经通过了第15行的<code class="fe ld le lf lg b">currentlyRenderingComp</code>检查。这些对象可能会触发属性突变的反应式呈现，因此get陷阱必须返回它们的包装版本。</li></ul><p id="b4f3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些点以及在每次渲染之前清理关系的事实，导致嵌套反应存储属性的最小自适应子集。</p><h2 id="4a60" class="nj lt jb bd lu nk nl dn ly nm nn dp mc kj no np mg kn nq nr mk kr ns nt mo nu bi translated">猴子修补内置对象</h2><p id="ed18" class="pw-post-body-paragraph jy jz jb ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">一些内置的JavaScript对象——比如ES6集合——有特殊的“内部插槽”。这些隐藏的代码片段不能被修改，它们可能对自己的<code class="fe ld le lf lg b">this</code>值有所期望。如果有人用一个意外的<code class="fe ld le lf lg b">this</code>调用它们，它们会用一个<code class="fe ld le lf lg b">incompatible receiver error</code>失败。</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nx"><img src="../Images/fe7e9cf6e4b8c2616d5d76a664abf33c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UENDbmzFRKjyyBexuQNufQ.png"/></div></div></figure><p id="ea59" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是，在这些情况下，代理也是无效的接收者，代理包装的对象抛出同样的错误。</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nx"><img src="../Images/1addf130110df01c94f84cc29e978770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H12HZPGQPxo2xb_vPI12Rg.png"/></div></div></figure><p id="6bc7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了解决这个问题，我必须为内置对象找到一个可行的替代代理。幸运的是，他们都有一个基于函数的接口，所以我可以求助于老式的猴子补丁。</p><p id="c661" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该过程与基于代理的方法非常相似。内置的接口必须分成两组:类set操作和类get操作。然后，对象的方法必须用适当的反应逻辑来修补——即构造和查询反应关系。</p><h2 id="79d1" class="nj lt jb bd lu nk nl dn ly nm nn dp mc kj no np mg kn nq nr mk kr ns nt mo nu bi translated">一点直觉</h2><p id="dee8" class="pw-post-body-paragraph jy jz jb ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">当我说电抗核心仅由冷逻辑制成时，我有点过于概括了。最后我也不得不使用一些直觉。</p><p id="89be" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让一切都变得被动是一个不错的挑战，但是违背了用户的期望。我收集了一些元操作——人们不想被动的——并让它们失去了乐趣。</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="1ef6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些选择是我在使用测试中凭直觉做出的。其他人可能对此有不同的方法，但我认为我收集了该语言的一个合理子集。上表中的每一项操作都有充分的理由不被动。</p><h1 id="0a64" class="ls lt jb bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">结论</h1><p id="d370" class="pw-post-body-paragraph jy jz jb ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">本文中实现的反应式核心不在React Easy状态的源代码中。实际上，反应式逻辑在一个更通用的库中——称为<a class="ae kw" href="https://github.com/nx-js/observer-util" rel="noopener ugc nofollow" target="_blank">观察者实用程序</a>——而Easy State只是React的一个瘦端口。我有意简化了这一点，使其更容易理解，但提出的想法仍然是一样的。如果你已经做到了，我希望你能学到新的东西！</p><p id="afdf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lk">如果这篇文章引起了你的兴趣，请分享出来。还要检查一下</em> <a class="ae kw" href="https://github.com/solkimicreb/react-easy-state" rel="noopener ugc nofollow" target="_blank"> <em class="lk">易邦回购</em> </a> <em class="lk">走之前留个星。</em></p><p id="512a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lk">谢谢！</em></p></div></div>    
</body>
</html>