<html>
<head>
<title>What is the JavaScript Set in ES2015 and when should you use it?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2015中的JavaScript集是什么，应该在什么时候使用？</h1>
<blockquote>原文：<a href="https://itnext.io/what-is-the-javascript-set-in-es2015-and-when-should-you-use-it-d7e3b8048891?source=collection_archive---------0-----------------------#2018-01-21">https://itnext.io/what-is-the-javascript-set-in-es2015-and-when-should-you-use-it-d7e3b8048891?source=collection_archive---------0-----------------------#2018-01-21</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj jr"><img src="../Images/fed722c75405f4f123948362297705dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h0HCAJxJyYSElCMB0OLNrg.jpeg"/></div></div></figure><h2 id="9114" class="kc kd iu bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">ES2015规范充满了新功能，这些新功能将不断引入所有新浏览器。这个系列是那些新事物中的一个。</h2><p id="41a1" class="pw-post-body-paragraph lc ld iu le b lf lg lh li lj lk ll lm kl ln lo lp kp lq lr ls kt lt lu lv lw in bi translated">我的第一个想法是，我可以用一个普通的<code class="fe ky kz la lb b">Array</code>！但是我会告诉你你可以用<code class="fe ky kz la lb b">Set</code>系列做什么。</p><h1 id="e2cd" class="lx kd iu bd ke ly lz ma kh mb mc md kk me mf mg ko mh mi mj ks mk ml mm kw mn bi translated">ES2015套装是什么？</h1><p id="4f05" class="pw-post-body-paragraph lc ld iu le b lf lg lh li lj lk ll lm kl ln lo lp kp lq lr ls kt lt lu lv lw in bi translated">什么是<code class="fe ky kz la lb b">Set</code>，你能用它做什么？Mozilla文档对此非常清楚:</p><blockquote class="mo"><p id="cfad" class="mp mq iu bd mr ms mt mu mv mw mx lw dk translated"><code class="fe ky kz la lb b">Set</code>集合允许您存储任何类型的唯一值，无论是原始值还是对象引用。<strong class="ak">来源:</strong><a class="ae my" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noopener ugc nofollow" target="_blank"><strong class="ak">Mozilla Docs</strong></a></p></blockquote><p id="7ab1" class="pw-post-body-paragraph lc ld iu le b lf mz lh li lj na ll lm kl nb lo lp kp nc lr ls kt nd lu lv lw in bi translated">这个特殊的对象可以像普通对象一样存储各种值，但是它们必须是唯一的，重复的值将被过滤掉。</p><p id="4d52" class="pw-post-body-paragraph lc ld iu le b lf ne lh li lj nf ll lm kl ng lo lp kp nh lr ls kt ni lu lv lw in bi translated">感谢Addy Osmani的推文，我发现了<code class="fe ky kz la lb b">Set()</code>！</p><figure class="nj nk nl nm gu jv"><div class="bz fq l di"><div class="nn no l"/></div></figure><p id="0d2c" class="pw-post-body-paragraph lc ld iu le b lf ne lh li lj nf ll lm kl ng lo lp kp nh lr ls kt ni lu lv lw in bi translated">从JavaScript数组中过滤出重复的值总是一件麻烦的事情，你需要遍历数组并自己找出答案，所以<code class="fe ky kz la lb b">Set</code>让这变得容易多了。😁</p><h1 id="5cb3" class="lx kd iu bd ke ly lz ma kh mb mc md kk me mf mg ko mh mi mj ks mk ml mm kw mn bi translated">向集合添加数据</h1><p id="fd9f" class="pw-post-body-paragraph lc ld iu le b lf lg lh li lj lk ll lm kl ln lo lp kp lq lr ls kt lt lu lv lw in bi translated">有几种方法可以将数据添加到<code class="fe ky kz la lb b">Set</code>集合中。</p><h1 id="d216" class="lx kd iu bd ke ly lz ma kh mb mc md kk me mf mg ko mh mi mj ks mk ml mm kw mn bi translated">作为参数传递</h1><p id="75b2" class="pw-post-body-paragraph lc ld iu le b lf lg lh li lj lk ll lm kl ln lo lp kp lq lr ls kt lt lu lv lw in bi translated">这是一个将数据作为参数添加到<code class="fe ky kz la lb b">Set</code>集合的例子。</p><pre class="nj nk nl nm gu np lb nq nr aw ns bi"><span id="bfae" class="kc kd iu lb b gz nt nu l nv nw">const numbersSet = new Set([1,2,3,4,5]);<br/>const stringSet = new Set(['Jan', 'Rick', 'Raymon', 'Tim']);<br/>const objectSet = new Set([{a: 1, b: 2}]);<br/>const arraySet = new Set([['javascript', 'coffeescript'], ['css', 'sass']]);</span></pre><h1 id="452f" class="lx kd iu bd ke ly lz ma kh mb mc md kk me mf mg ko mh mi mj ks mk ml mm kw mn bi translated">通过Add方法添加数据</h1><p id="18ed" class="pw-post-body-paragraph lc ld iu le b lf lg lh li lj lk ll lm kl ln lo lp kp lq lr ls kt lt lu lv lw in bi translated">将数据传递到<code class="fe ky kz la lb b">Set</code>集合的另一种方式是使用<code class="fe ky kz la lb b">add()</code>方法。</p><pre class="nj nk nl nm gu np lb nq nr aw ns bi"><span id="bea4" class="kc kd iu lb b gz nt nu l nv nw">const newSetObject = new Set();<br/>newSetObject.add('Raymon');<br/>newSetObject.add({a: 1, b: 2});<br/>newSetObject.add(1).add(2).add(3).add(4).add(5)<br/>    <br/>// Result: Raymon, {a: 1, b: 2}, 1, 2, 3, 4, 5</span></pre><h1 id="6c08" class="lx kd iu bd ke ly lz ma kh mb mc md kk me mf mg ko mh mi mj ks mk ml mm kw mn bi translated">使用has方法检查集合内部的值</h1><p id="c0e9" class="pw-post-body-paragraph lc ld iu le b lf lg lh li lj lk ll lm kl ln lo lp kp lq lr ls kt lt lu lv lw in bi translated"><code class="fe ky kz la lb b">Set</code>集合有一个非常方便的方法来检查某个值是否在对象内部。</p><pre class="nj nk nl nm gu np lb nq nr aw ns bi"><span id="f23e" class="kc kd iu lb b gz nt nu l nv nw">const numbersSet = new Set([1,2,3,4,5]);<br/>const stringSet = new Set(['Jan', 'Rick', 'Raymon', 'Tim']);<br/>const objectSet = new Set([{a: 1, b: 2}]);<br/>const arraySet = new Set([['javascript', 'coffeescript'], ['css', 'sass']]);<br/>    <br/>numberSet.has(4); // true<br/>numberSet.has(6); // false<br/>stringSet.has('Raymon'); // true<br/>objectSet.has({a: 1, b: 2}); // false<br/>arraySet.has('css'); // false</span></pre><p id="bd6b" class="pw-post-body-paragraph lc ld iu le b lf ne lh li lj nf ll lm kl ng lo lp kp nh lr ls kt ni lu lv lw in bi translated"><code class="fe ky kz la lb b">has()</code>方法在<a class="ae my" href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" rel="noopener ugc nofollow" target="_blank">原始值</a>上工作正常，但是像<code class="fe ky kz la lb b">Object</code>和<code class="fe ky kz la lb b">Array</code>这样的非原始值就不起作用了。</p><p id="2caf" class="pw-post-body-paragraph lc ld iu le b lf ne lh li lj nf ll lm kl ng lo lp kp nh lr ls kt ni lu lv lw in bi translated">非原始值不能链接原始值的原因有一个。原因是<code class="fe ky kz la lb b">has()</code>方法不仅比较值，还比较它与<code class="fe ky kz la lb b">===</code>操作符的引用。</p><p id="cb38" class="pw-post-body-paragraph lc ld iu le b lf ne lh li lj nf ll lm kl ng lo lp kp nh lr ls kt ni lu lv lw in bi translated">如果你在一个变量中引用了<code class="fe ky kz la lb b">Object</code>或<code class="fe ky kz la lb b">Array</code>并在<code class="fe ky kz la lb b">has()</code>方法中使用了它们，那么结果将会和预期的一样。</p><pre class="nj nk nl nm gu np lb nq nr aw ns bi"><span id="b1c6" class="kc kd iu lb b gz nt nu l nv nw">const exampleObject = {a: 1, b: 2};<br/>const exampleArray1 = ['javascript', 'coffeescript']<br/>const exampleArray2 = ['css', 'sass'];<br/>const objectSet = new Set([exampleObject]);<br/>const arraySet = new Set([exampleArray1, exampleArray2]);<br/>    <br/>objectSet.has({a: 1, b: 2}); // false<br/>objectSet.has(exampleObject); // true<br/>arraySet.has('css'); // false<br/>arraySet.has(exampleArray1); // true<br/>arraySet.has(exampleArray2); // true</span></pre><p id="c482" class="pw-post-body-paragraph lc ld iu le b lf ne lh li lj nf ll lm kl ng lo lp kp nh lr ls kt ni lu lv lw in bi translated">所以请记住，在对<code class="fe ky kz la lb b">Set</code>集合使用<code class="fe ky kz la lb b">has()</code>方法时，拥有对非原始值的引用是很重要的。</p><h1 id="a35b" class="lx kd iu bd ke ly lz ma kh mb mc md kk me mf mg ko mh mi mj ks mk ml mm kw mn bi translated">从集合中移除数据</h1><p id="968b" class="pw-post-body-paragraph lc ld iu le b lf lg lh li lj lk ll lm kl ln lo lp kp lq lr ls kt lt lu lv lw in bi translated">向<code class="fe ky kz la lb b">Set</code>集合中添加数据非常简单，但是从集合中删除数据也一样简单。</p><h1 id="52ee" class="lx kd iu bd ke ly lz ma kh mb mc md kk me mf mg ko mh mi mj ks mk ml mm kw mn bi translated">用删除方法删除数据</h1><p id="98d3" class="pw-post-body-paragraph lc ld iu le b lf lg lh li lj lk ll lm kl ln lo lp kp lq lr ls kt lt lu lv lw in bi translated">如果你想删除<code class="fe ky kz la lb b">Set</code>集合中的一个项目，只需使用<code class="fe ky kz la lb b">remove</code>方法。</p><pre class="nj nk nl nm gu np lb nq nr aw ns bi"><span id="8bee" class="kc kd iu lb b gz nt nu l nv nw">const numbersSetObject = new Set([1,2,3,4,5,6,7,8,9]);<br/>numbersSetObject.has(2); // true<br/>numbersSetObject.delete(2);<br/>numbersSetObject.has(2); // false<br/>console.log(numbersSetObject); // 1,3,4,5,6,7,8,9</span></pre><h1 id="ede1" class="lx kd iu bd ke ly lz ma kh mb mc md kk me mf mg ko mh mi mj ks mk ml mm kw mn bi translated">用clear方法删除所有数据</h1><p id="a435" class="pw-post-body-paragraph lc ld iu le b lf lg lh li lj lk ll lm kl ln lo lp kp lq lr ls kt lt lu lv lw in bi translated">但是如果您想从<code class="fe ky kz la lb b">Set</code>集合中移除所有数据，请使用<code class="fe ky kz la lb b">clear</code>方法。</p><pre class="nj nk nl nm gu np lb nq nr aw ns bi"><span id="bda5" class="kc kd iu lb b gz nt nu l nv nw">const numbersSetObject = new Set([1,2,3,4,5,6,7,8,9]);<br/>numbersSetObject.has(2); // true<br/>numbersSetObject.clear();<br/>console.log([...numbersSetObject]); // []</span></pre><h1 id="07ca" class="lx kd iu bd ke ly lz ma kh mb mc md kk me mf mg ko mh mi mj ks mk ml mm kw mn bi translated">使用size属性检查项目的数量</h1><p id="ddbd" class="pw-post-body-paragraph lc ld iu le b lf lg lh li lj lk ll lm kl ln lo lp kp lq lr ls kt lt lu lv lw in bi translated">像<code class="fe ky kz la lb b">Array</code>一样，您使用<code class="fe ky kz la lb b">length</code>属性检查项目的数量，而<code class="fe ky kz la lb b">Set</code>集合具有用于此的<code class="fe ky kz la lb b">size</code>属性。</p><p id="4137" class="pw-post-body-paragraph lc ld iu le b lf ne lh li lj nf ll lm kl ng lo lp kp nh lr ls kt ni lu lv lw in bi translated">如果我们检查前一个例子中的<code class="fe ky kz la lb b">Set</code>集合，大小将是7。</p><pre class="nj nk nl nm gu np lb nq nr aw ns bi"><span id="feab" class="kc kd iu lb b gz nt nu l nv nw">newSetObject.size // 7</span></pre><h1 id="0e7b" class="lx kd iu bd ke ly lz ma kh mb mc md kk me mf mg ko mh mi mj ks mk ml mm kw mn bi translated">过滤重复的原始值</h1><p id="3bb8" class="pw-post-body-paragraph lc ld iu le b lf lg lh li lj lk ll lm kl ln lo lp kp lq lr ls kt lt lu lv lw in bi translated">如果我试图将复制的原始值放入<code class="fe ky kz la lb b">Set</code>，只有唯一的值会保留下来。</p><pre class="nj nk nl nm gu np lb nq nr aw ns bi"><span id="710a" class="kc kd iu lb b gz nt nu l nv nw">const uniqueArray = new Set([1,2,2,2,3,4,5,5,6,7,9,9,8]);<br/>console.log('uniqueArray: ', uniqueArray)<br/>// unique: 1, 2, 3, 4, 5, 6, 7, 9, 8</span></pre><h1 id="bdd0" class="lx kd iu bd ke ly lz ma kh mb mc md kk me mf mg ko mh mi mj ks mk ml mm kw mn bi translated">过滤重复的非原始值</h1><p id="8748" class="pw-post-body-paragraph lc ld iu le b lf lg lh li lj lk ll lm kl ln lo lp kp lq lr ls kt lt lu lv lw in bi translated">过滤掉重复值后，非原始值略有不同。文档非常清楚，<code class="fe ky kz la lb b">Set</code>本身不是比较对象，而是比较参考。</p><p id="a2ee" class="pw-post-body-paragraph lc ld iu le b lf ne lh li lj nf ll lm kl ng lo lp kp nh lr ls kt ni lu lv lw in bi translated">把它看作是用<code class="fe ky kz la lb b">==</code>操作符比较事物，但是用<code class="fe ky kz la lb b">===</code>操作符将比较引用和值。</p><p id="47e1" class="pw-post-body-paragraph lc ld iu le b lf ne lh li lj nf ll lm kl ng lo lp kp nh lr ls kt ni lu lv lw in bi translated">如果我们试着把两个相同的物体放在<code class="fe ky kz la lb b">Set</code>中，用不同的参照物，那么就不会有问题。</p><pre class="nj nk nl nm gu np lb nq nr aw ns bi"><span id="5d3e" class="kc kd iu lb b gz nt nu l nv nw">const objectSet = new Set([{a: 1, b: 2}, {a: 1, b: 2}]);<br/>console.log('objectSet: ', objectSet);<br/>// objectSet: {a: 1, b: 2}, {a: 1, b: 2};</span></pre><p id="01a5" class="pw-post-body-paragraph lc ld iu le b lf ne lh li lj nf ll lm kl ng lo lp kp nh lr ls kt ni lu lv lw in bi translated">但是当我们放入相同参考的相等物体时会发生什么呢？</p><pre class="nj nk nl nm gu np lb nq nr aw ns bi"><span id="ece9" class="kc kd iu lb b gz nt nu l nv nw">const demoObject = {a: 1, b: 2};<br/>const objectSet = new Set([demoObject, demoObject]);<br/>console.log('objectSet: ', objectSet);<br/>// objectSet: {a: 1, b: 2};</span></pre><p id="b547" class="pw-post-body-paragraph lc ld iu le b lf ne lh li lj nf ll lm kl ng lo lp kp nh lr ls kt ni lu lv lw in bi translated">希望你猜到了<code class="fe ky kz la lb b">objectSet</code>只包含1个<code class="fe ky kz la lb b">demoObject</code>。它清除重复的😁</p><h1 id="df9d" class="lx kd iu bd ke ly lz ma kh mb mc md kk me mf mg ko mh mi mj ks mk ml mm kw mn bi translated">在集合上循环</h1><p id="40e0" class="pw-post-body-paragraph lc ld iu le b lf lg lh li lj lk ll lm kl ln lo lp kp lq lr ls kt lt lu lv lw in bi translated">一个<code class="fe ky kz la lb b">Set</code>的好处是，你可以在一个<code class="fe ky kz la lb b">Set</code>上循环！</p><p id="80a1" class="pw-post-body-paragraph lc ld iu le b lf ne lh li lj nf ll lm kl ng lo lp kp nh lr ls kt ni lu lv lw in bi translated">医生告诉我们更多关于这个场景的信息:</p><blockquote class="mo"><p id="be91" class="mp mq iu bd mr ms mt mu mv mw mx lw dk translated">集合对象是值的集合。您可以按插入顺序循环访问集合中的元素。<strong class="ak">来源:</strong><a class="ae my" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noopener ugc nofollow" target="_blank"><strong class="ak">Mozilla Docs</strong></a></p></blockquote><p id="daca" class="pw-post-body-paragraph lc ld iu le b lf mz lh li lj na ll lm kl nb lo lp kp nc lr ls kt nd lu lv lw in bi translated">要循环遍历一个<code class="fe ky kz la lb b">Set</code>集合，我们可以使用<code class="fe ky kz la lb b">for-of</code>循环和附加到<code class="fe ky kz la lb b">Set</code>的<code class="fe ky kz la lb b">forEach</code>方法。</p><h1 id="cae0" class="lx kd iu bd ke ly lz ma kh mb mc md kk me mf mg ko mh mi mj ks mk ml mm kw mn bi translated">用forEach方法循环</h1><p id="1dc6" class="pw-post-body-paragraph lc ld iu le b lf lg lh li lj lk ll lm kl ln lo lp kp lq lr ls kt lt lu lv lw in bi translated">使用<code class="fe ky kz la lb b">Set.forEach()</code>，您可以遍历<code class="fe ky kz la lb b">Set</code>集合中的所有数据。</p><pre class="nj nk nl nm gu np lb nq nr aw ns bi"><span id="e02d" class="kc kd iu lb b gz nt nu l nv nw">const objectSet = new Set([{a: 1, b: 2}, {a: 1, b: 2}]);<br/>objectSet.forEach(object =&gt; {<br/>    console.log('Object: ', object);<br/>})<br/>    <br/>// result:  <br/>// Object:  {a: 1, b: 2}<br/>// Object:  {a: 1, b: 2}</span></pre><h1 id="c900" class="lx kd iu bd ke ly lz ma kh mb mc md kk me mf mg ko mh mi mj ks mk ml mm kw mn bi translated">使用for-of循环方法的循环</h1><p id="0876" class="pw-post-body-paragraph lc ld iu le b lf lg lh li lj lk ll lm kl ln lo lp kp lq lr ls kt lt lu lv lw in bi translated">使用<code class="fe ky kz la lb b">for-of</code>循环，我们有一些方法来循环遍历<code class="fe ky kz la lb b">Set</code>集合中的所有项目。</p><ul class=""><li id="3e3d" class="nx ny iu le b lf ne lj nf kl nz kp oa kt ob lw oc od oe of bi translated"><code class="fe ky kz la lb b">entries()</code></li><li id="f2fe" class="nx ny iu le b lf og lj oh kl oi kp oj kt ok lw oc od oe of bi translated"><code class="fe ky kz la lb b">keys()</code></li><li id="82b8" class="nx ny iu le b lf og lj oh kl oi kp oj kt ok lw oc od oe of bi translated"><code class="fe ky kz la lb b">values()</code></li></ul><pre class="nj nk nl nm gu np lb nq nr aw ns bi"><span id="d917" class="kc kd iu lb b gz nt nu l nv nw">const objectSet = new Set([{a: 1, b: 2}, {a: 1, b: 2}]);<br/>for (let [key, value] of objectSet.entries())  {<br/>   console.log(key);<br/>}<br/>    <br/>// {a: 1, b: 2}<br/>// {a: 1, b: 2}</span></pre><p id="72b0" class="pw-post-body-paragraph lc ld iu le b lf ne lh li lj nf ll lm kl ng lo lp kp nh lr ls kt ni lu lv lw in bi translated">唯一奇怪的是，<code class="fe ky kz la lb b">entries</code>、<code class="fe ky kz la lb b">keys</code>和<code class="fe ky kz la lb b">values</code>方法在<code class="fe ky kz la lb b">Set</code>上返回完全相同的东西。可能是因为<code class="fe ky kz la lb b">Set</code>和<code class="fe ky kz la lb b">Map</code> API有很多共同点吧。</p><h1 id="e27f" class="lx kd iu bd ke ly lz ma kh mb mc md kk me mf mg ko mh mi mj ks mk ml mm kw mn bi translated">集合和地图的区别</h1><p id="fbad" class="pw-post-body-paragraph lc ld iu le b lf lg lh li lj lk ll lm kl ln lo lp kp lq lr ls kt lt lu lv lw in bi translated"><code class="fe ky kz la lb b">Map</code>和<code class="fe ky kz la lb b">Set</code>最大的区别在于<code class="fe ky kz la lb b">Set</code>看起来很像<code class="fe ky kz la lb b">Array</code>而<code class="fe ky kz la lb b">Map</code>看起来更像<code class="fe ky kz la lb b">Object</code>。</p><p id="569d" class="pw-post-body-paragraph lc ld iu le b lf ne lh li lj nf ll lm kl ng lo lp kp nh lr ls kt ni lu lv lw in bi translated">希望这篇文章对你有所帮助！如果你有问题，请在评论中告诉我。</p><h1 id="93be" class="lx kd iu bd ke ly lz ma kh mb mc md kk me mf mg ko mh mi mj ks mk ml mm kw mn bi translated">阅读我的其他帖子</h1><div class="ol om gq gs on oo"><a rel="noopener  ugc nofollow" target="_blank" href="/dive-into-graphql-w-apollo-client-by-building-a-spacex-app-in-angular-8-20e703c93f0a"><div class="op ab fp"><div class="oq ab or cl cj os"><h2 class="bd iv gz z fq ot fs ft ou fv fx it bi translated">通过构建SpaceX深入了解GraphQL w/ Apollo客户端🚀Angular 8中的应用</h2><div class="ov l"><h3 class="bd b gz z fq ot fs ft ou fv fx dk translated">我知道这听起来很奇怪，但是在带有Apollo客户端的Angular 8应用程序中使用GraphQL感觉就像…</h3></div><div class="ow l"><p class="bd b dl z fq ot fs ft ou fv fx dk translated">itnext.io</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ka oo"/></div></div></a></div><div class="ol om gq gs on oo"><a rel="noopener  ugc nofollow" target="_blank" href="/graphql-microservices-architecture-by-apollo-8b6eb557c5e2"><div class="op ab fp"><div class="oq ab or cl cj os"><h2 class="bd iv gz z fq ot fs ft ou fv fx it bi translated">阿波罗的GraphQL(微服务)架构</h2><div class="ov l"><h3 class="bd b gz z fq ot fs ft ou fv fx dk translated">GraphQL太棒了！阿波罗围绕它制造工具，使我们的生活更容易，大规模使用它</h3></div><div class="ow l"><p class="bd b dl z fq ot fs ft ou fv fx dk translated">itnext.io</p></div></div><div class="ox l"><div class="pd l oz pa pb ox pc ka oo"/></div></div></a></div><div class="ol om gq gs on oo"><a rel="noopener  ugc nofollow" target="_blank" href="/prevent-cannot-read-property-of-undefined-errors-with-javascript-classes-typescript-a388c1f0ef45"><div class="op ab fp"><div class="oq ab or cl cj os"><h2 class="bd iv gz z fq ot fs ft ou fv fx it bi translated">用JavaScript类+ TypeScript防止“无法读取未定义的属性”…”错误</h2><div class="ov l"><h3 class="bd b gz z fq ot fs ft ou fv fx dk translated">每个开发JavaScript的人都会遇到类似“无法读取undefined的属性“…”这样的错误。有一个…</h3></div><div class="ow l"><p class="bd b dl z fq ot fs ft ou fv fx dk translated">itnext.io</p></div></div><div class="ox l"><div class="pe l oz pa pb ox pc ka oo"/></div></div></a></div><div class="ol om gq gs on oo"><a href="https://medium.com/@devbyrayray/from-xhr-to-fetch-with-async-await-on-the-finish-line-b021de1d226b" rel="noopener follow" target="_blank"><div class="op ab fp"><div class="oq ab or cl cj os"><h2 class="bd iv gz z fq ot fs ft ou fv fx it bi translated">从XHR到终点的异步/等待取货</h2><div class="ov l"><h3 class="bd b gz z fq ot fs ft ou fv fx dk translated">我已经有一段时间没有写我的最新帖子了。我一直在忙着探索一些与我的…</h3></div><div class="ow l"><p class="bd b dl z fq ot fs ft ou fv fx dk translated">medium.com</p></div></div><div class="ox l"><div class="pf l oz pa pb ox pc ka oo"/></div></div></a></div></div></div>    
</body>
</html>