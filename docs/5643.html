<html>
<head>
<title>To normalize or to denormalize, that is the question</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">规范化还是反规范化，这是一个问题</h1>
<blockquote>原文：<a href="https://itnext.io/to-normalize-or-to-denormalize-that-is-the-question-4cc3968439a8?source=collection_archive---------1-----------------------#2021-04-23">https://itnext.io/to-normalize-or-to-denormalize-that-is-the-question-4cc3968439a8?source=collection_archive---------1-----------------------#2021-04-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a83e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据是您最宝贵的资产之一。而且，因为数据非常有价值，所以在开始定义任何模式之前，花时间仔细考虑并提出尽可能多的问题非常重要。数据将如何被消费？多久更新一次？我们对最终的一致性满意吗？我们需要什么总量或报告？而且，多得多。如果你对学习如何在NoSQL建立关系数据模型感兴趣，你可能会对我以前的文章感兴趣<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/nosql-does-not-mean-relational-8aac79ce6b9c"> NoSQL不是指！关系型</a>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/3ba923ea6e7f67e9c45e47888bbdbe25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ax67tpRF13lDttJccVeJUQ.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">图片由unDraw.co提供</figcaption></figure><p id="b93f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我发现采用<a class="ae kl" href="https://cloud.google.com/firestore" rel="noopener ugc nofollow" target="_blank"> Cloud Firestore </a>和其他NoSQL数据库的一个好处是，它们非常灵活，但永远不要忘记“强大的力量带来巨大的责任”——本叔叔(“斯坦·李”)。NoSQL数据库通常被称为无模式数据库，你可以动态地修改数据以适应你的模型，但是9/10的这种想法会给你带来比你意识到的更多的痛苦。</p><p id="83c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，我已经说了很多，没有太多的解释，所以让我们开始吧。我们将查看一个类似CRM的票证应用程序，试图了解我们何时应该规范化，何时应该反规范化。</p><p id="1789" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，对于那些不知道的人来说，数据规范化是将数据组织到多个容器(例如，表)中以减少数据重复和提高数据完整性的技术。</p><pre class="kn ko kp kq gt lc ld le lf aw lg bi"><span id="eed0" class="lh li iq ld b gy lj lk l ll lm"><strong class="ld ir">SQL Model</strong></span><span id="a9ad" class="lh li iq ld b gy ln lk l ll lm"><strong class="ld ir">Organizations<br/></strong>  - id<br/><strong class="ld ir">  </strong>- name<br/>  - address<br/>  - city<br/>  - state<br/>  - postal_code<br/>  - phone</span><span id="f124" class="lh li iq ld b gy ln lk l ll lm"><strong class="ld ir">Users<br/></strong>  - id<br/><strong class="ld ir">  </strong>- name<br/>  - email<br/>  - phone<br/>  - organization_id</span><span id="ce15" class="lh li iq ld b gy ln lk l ll lm"><strong class="ld ir">Tickets<br/></strong>  - id<br/><strong class="ld ir">  </strong>- submitter_name<br/>  - note<br/>  - assigned_to // REFERENCES App_User(id)</span></pre><p id="6528" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看上面的SQL模型，您可以看到我们已经规范化了数据——我们使用<code class="fe lo lp lq ld b">assigned_to</code>引用了<code class="fe lo lp lq ld b">Tickets</code>中的<code class="fe lo lp lq ld b">User</code>,通过<code class="fe lo lp lq ld b">organization_id</code>引用了<code class="fe lo lp lq ld b">User</code>中的<code class="fe lo lp lq ld b">Organization</code>。</p><p id="2ace" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于那些不知道什么是反规范化数据的人来说，反规范化数据是一种策略，用于以前规范化的数据库，通过复制数据来提高读取性能，代价是写入性能。</p><p id="d832" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但这并不完全准确，反规范化数据也可以用于数据完整性。在我的<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/nosql-does-not-mean-relational-8aac79ce6b9c">上一篇文章</a>中，我讨论了一个点餐应用程序，它有<code class="fe lo lp lq ld b">dishes</code>、<code class="fe lo lp lq ld b">orders</code>和<code class="fe lo lp lq ld b">order_items</code>，一个<code class="fe lo lp lq ld b">order</code>有多个<code class="fe lo lp lq ld b">order_items</code>，一个<code class="fe lo lp lq ld b">dish</code>有一个由<code class="fe lo lp lq ld b">restaurant</code>设置的<code class="fe lo lp lq ld b">price</code>。当a <code class="fe lo lp lq ld b">user</code>选择一个<code class="fe lo lp lq ld b">dish</code>进行订购时，我们创建一个<code class="fe lo lp lq ld b">order</code>和一个<code class="fe lo lp lq ld b">order_item</code>。现在，如果我们通过一个外键引用<code class="fe lo lp lq ld b">dish</code>,由于原料短缺，餐馆提高了<code class="fe lo lp lq ld b">dish</code>的价格，我们的历史报告数据会发生什么情况？报告数据会是错误的！例如，顾客将无法从餐馆调出他们的订单历史，并看到他们之前为这道菜支付了10美元，但是如果我们从<code class="fe lo lp lq ld b">dish</code>记录中反规格化并复制<code class="fe lo lp lq ld b">price</code>呢？我们保留客户在订单时支付的<code class="fe lo lp lq ld b">price</code>。</p><p id="44a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回到我们的ticket应用程序，让我们来看一个非规范化的模型，这次我将使用一个文档数据库模型。</p><pre class="kn ko kp kq gt lc ld le lf aw lg bi"><span id="0993" class="lh li iq ld b gy lj lk l ll lm"><strong class="ld ir">Document Model - Firestore<br/>users {<br/>  </strong>user_id<strong class="ld ir"> </strong>{<br/>    name,<br/>    email,<br/>    phone,<br/>    organization: {<br/>      id: ${organization_id}<br/>      name: ${organization.name}<br/>    }<br/>  }<br/><strong class="ld ir">}<br/>organizations {<br/></strong>  organization_id {<br/>    name,<br/>    address,<br/>    city,<br/>    state,<br/>    postalCode,<br/>    phone,<br/>  }<br/>  <br/>  <strong class="ld ir">tickets (</strong>sub-collection)<br/>    id {<br/>      submitted_name,<br/>      note,<br/>      assigned_to: {<br/>        id: ${user_id},<br/>        name: ${user.name}<br/>      }<br/>    }<br/><strong class="ld ir">}</strong></span><span id="0587" class="lh li iq ld b gy ln lk l ll lm">// users &amp; organizations are collections<br/>// tickets are a sub-collection under the organization</span></pre><p id="f098" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在查看文档模型并将其与SQL模型进行比较，您会看到我已经将<strong class="jp ir"> SQL </strong> <code class="fe lo lp lq ld b">Tickets</code>上的<code class="fe lo lp lq ld b">assigned_to</code>数据规范化，但是在<strong class="jp ir">文档</strong> <code class="fe lo lp lq ld b">tickets</code>中，我已经通过将用户的<code class="fe lo lp lq ld b">name</code>直接包含在标签上而将<code class="fe lo lp lq ld b">assigned_to</code>非规范化。公平地说，我们可以用RDBMS做完全相同的非规范化模式，这不是文档或NoSQL数据库所独有的。许多工程师会看到这一点，并说，等一下只需引用<code class="fe lo lp lq ld b">user</code>并加入数据，这是一个逻辑解决方案，但它可能不是最佳解决方案。</p><p id="1ca7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在票证控制面板中，您通常会看到一些有限的数据—您通常会看到提交者的姓名、创建时间、分配给谁以及可能的最后更新时间戳。现在，假设分配到票证的员工结婚了，并将他们的姓名从<code class="fe lo lp lq ld b">Jane Doe</code>更改为<code class="fe lo lp lq ld b">Jane Smith</code>，如果使用规范化模型，登录并查看其票证的客户(“提交者”)可能会感到困惑，为什么当他们看到<code class="fe lo lp lq ld b">Jane Smith</code>时<code class="fe lo lp lq ld b">Jane Doe</code>不再是他们的<code class="fe lo lp lq ld b">assigned</code>代表。在规范化模型中，您不能选择旧名称是否应该保留在票据上，或者新名称是否应该出现在票据上。现在，看看这个非规范化的模型，你会发现我们有一个选择，更好的是我们可以将这个选择提供给<code class="fe lo lp lq ld b">Jane</code>或<code class="fe lo lp lq ld b">organization</code>。我们可以让<code class="fe lo lp lq ld b">Jane</code>或<code class="fe lo lp lq ld b">organization</code>决定是用她的新名字更新她的所有票，还是只让新票使用她的新名字。</p><p id="17eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，如果Jane决定让所有的票都用她的新名字，我们该如何更新名字呢？在SQL中这很容易，让我们假设我们已经反规范化了上面的SQL模型，现在<code class="fe lo lp lq ld b">Tickets</code>包括了<code class="fe lo lp lq ld b">assigned_to_id</code>和<code class="fe lo lp lq ld b">assigned_to_name</code>。我们的SQL查询如下所示</p><pre class="kn ko kp kq gt lc ld le lf aw lg bi"><span id="2675" class="lh li iq ld b gy lj lk l ll lm"><strong class="ld ir">UPDATE</strong> Tickets <br/><strong class="ld ir">SET</strong> assigned_to_name = $assigned_to_name <br/><strong class="ld ir">WHERE</strong> assigned_to_id = $user_id;</span></pre><p id="ee80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数文档数据库要求您查询和更新每个文档。使用文档数据库的一个例子是</p><pre class="kn ko kp kq gt lc ld le lf aw lg bi"><span id="ec63" class="lh li iq ld b gy lj lk l ll lm"><strong class="ld ir">Firestore Node.js (Admin-SDK)</strong></span><span id="769d" class="lh li iq ld b gy ln lk l ll lm">// Function to update the ticket<br/>// In the event of an error we push the data to pubsub<br/><strong class="ld ir">async function updateTicket</strong>({ticketId, data}){<br/>  const docRef = firestore<br/>    .doc(`organizations/{organizationId}/tickets/{ticketId}`);</span><span id="f660" class="lh li iq ld b gy ln lk l ll lm">  try {<br/>    await docRef.update(data);<br/>  } catch error {<br/>    // handle your error<br/>    logging(error);<br/>    pubsub.add(JSON.stringify({ticketId, data});<br/>  }<br/>}<strong class="ld ir">;</strong></span><span id="144d" class="lh li iq ld b gy ln lk l ll lm"><em class="lr">// retrieve all of the tickets for the user by the user id</em><br/><strong class="ld ir">const tickets</strong> = await firestore<br/>  .collection(`organizations/${organizationId}/tickets`)<br/>  .where('assigned_to.id', '==', ${userId})<br/>  .get();</span><span id="8b6a" class="lh li iq ld b gy ln lk l ll lm"><strong class="ld ir">const promises</strong> = tickets.docs.map(doc =&gt; {<br/>  // use our updateTicket function to write data<br/>  return updateTicket({doc.id, assigned_to_name: $assigned_to_name})<br/>});</span><span id="b60c" class="lh li iq ld b gy ln lk l ll lm"><strong class="ld ir">await Promise.all(promises);<br/></strong>// This is only an example</span></pre><p id="ed98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您在上面看到的，文档数据库更新确实需要更多的工作。您很可能希望在后台执行此操作，云函数之类的东西对于此用例来说是一个很好的工具。</p><p id="1597" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于非规范化数据还有其他注意事项，您必须确保在更改外键/引用时更新非规范化数据。这意味着什么呢？如果我们决定将一张票从<code class="fe lo lp lq ld b">Jane</code>重新分配给<code class="fe lo lp lq ld b">John</code>，在一个规范化的数据库中，我们不需要担心将票上的名字更新为<code class="fe lo lp lq ld b">John</code>我们将在<code class="fe lo lp lq ld b">JOIN</code>数据时得到他的名字。但是，在一个非规范化的模型上，我们需要更新<code class="fe lo lp lq ld b">assigned_to.id</code>和<code class="fe lo lp lq ld b">assigned_to.name</code>。这没什么大不了的，因为您正在为新id更新文档/记录，您只需要确保记住也要更新name字段— <em class="lr">提示:这是一些测试的好地方。</em></p><p id="05ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么什么时候决定是否应该反规格化呢？我通常这样想，如果我的演示/视图需要显示数据，我会把它放在我的文档中。如果我的数据需要保留历史记录，我会将数据反规范化。然而，如果数据有经常变化的趋势，并且我们不需要保留历史值，我选择规范化模型。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="ee15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">en.wikipedia.org反规格化<a class="ae kl" href="https://en.wikipedia.org/wiki/Denormalization#:~:text=Denormalization%20is%20a%20strategy%20used,data%20or%20by%20grouping%20data" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/反规格化#:~:text =反规格化%20is%20a%20strategy%20used，data % 20 or % 20 by % 20 group % 20 data</a>。</p></div></div>    
</body>
</html>