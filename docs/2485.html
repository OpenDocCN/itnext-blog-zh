<html>
<head>
<title>Protocol Buffers To Pass Data Between Elixir/Phoenix And Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Elixir/Phoenix和Python之间传递数据的协议缓冲区</h1>
<blockquote>原文：<a href="https://itnext.io/protocol-buffers-to-pass-data-between-elixir-phoenix-and-python-89191abe84e1?source=collection_archive---------1-----------------------#2019-05-31">https://itnext.io/protocol-buffers-to-pass-data-between-elixir-phoenix-and-python-89191abe84e1?source=collection_archive---------1-----------------------#2019-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="4640" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇文章是我之前的一篇文章的扩展，标题是“使用来自Phoenix (Elixir)应用程序 的经过Python训练的机器学习模型”。在我的上一篇文章中，我展示了如何使用<a class="ae ko" href="http://erlport.org" rel="noopener ugc nofollow" target="_blank"> ErlPort </a>从Elixir应用程序中使用python训练的机器学习模型。然而，从Phoenix (Elixir)应用程序传递的使用Python代码进行预测的模型参数是一个简单的列表数据类型，并且它受ErlPort的内置数据类型映射的支持。</p><p id="de86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，对于复杂的数据，我们需要一些机制来序列化/反序列化数据。在本文中，我将扩展我以前的项目，使用“<strong class="js iu">协议缓冲区</strong>”来完成数据序列化/反序列化。</p><h1 id="87b0" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">什么是协议缓冲区？</h1><p id="81f0" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">由Google发明—“<em class="kp">协议缓冲区是Google的语言中立、平台中立、可扩展的机制，用于序列化结构化数据—想想XML，但是更小、更快、更简单。您只需定义一次数据的结构化方式，然后就可以使用专门生成的源代码，使用各种语言轻松地将结构化数据写入各种数据流或从中读取数据</em>。(src:<a class="ae ko" href="https://developers.google.com/protocol-buffers/" rel="noopener ugc nofollow" target="_blank">T11】https://developers.google.com/protocol-buffers/T13】</a></p><p id="eb22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Google在其网站上为协议缓冲区提供了可扩展的文档，在这里可以找到支持的语言的开发人员指南和代码示例以及教程—<a class="ae ko" href="https://developers.google.com/protocol-buffers/docs/overview" rel="noopener ugc nofollow" target="_blank"><em class="kp">https://developers . Google . com/protocol-buffers/docs/overview</em></a></p><h1 id="6aa7" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">它是如何工作的？</h1><p id="f9a0" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">协议缓冲区的工作方式非常简单。我们需要写一个<strong class="js iu">。定义消息格式的proto </strong>文件。这个。协议编译器(<strong class="js iu">protocol</strong>)编译proto 文件，生成所需语言的代码。</p><blockquote class="lt lu lv"><p id="d122" class="jq jr kp js b jt ju jv jw jx jy jz ka lw kc kd ke lx kg kh ki ly kk kl km kn im bi translated">。proto→proto编译器→生成的语言代码</p></blockquote><p id="e31a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将把数据从Elixir代码传递给Python。所以我们需要使用<strong class="js iu">协议</strong>编译器为Elixir和Python生成代码。Python支持已经内置于编译器中。但是对于药剂部分，我们将使用<strong class="js iu">protobuf-Elixir</strong>(<a class="ae ko" href="https://github.com/tony612/protobuf-elixir" rel="noopener ugc nofollow" target="_blank"><em class="kp"/></a>)这是协议缓冲区的纯药剂实现。</p><h1 id="3c86" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">安装Protobuf</h1><p id="e0c3" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">首先我们需要安装协议缓冲编译器。我们可以在Mac上使用自制软件(<a class="ae ko" href="https://formulae.brew.sh/formula/protobuf" rel="noopener ugc nofollow" target="_blank"><em class="kp">https://formulae.brew.sh/formula/protobuf</em></a>)通过下面的命令来完成这个任务</p><blockquote class="lt lu lv"><p id="4da9" class="jq jr kp js b jt ju jv jw jx jy jz ka lw kc kd ke lx kg kh ki ly kk kl km kn im bi translated">brew安装protobuf</p></blockquote><h1 id="f49f" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">凤凰(仙丹)部分</h1><h2 id="f030" class="lz kr it bd ks ma mb dn kw mc md dp la kb me mf le kf mg mh li kj mi mj lm mk bi translated">修改mix.exs并添加依赖项:</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="98e4" class="lz kr it mq b gy mu mv l mw mx">defp deps do<br/>    [<br/>      {:phoenix, "~&gt; 1.4.0"},<br/>      {:phoenix_pubsub, "~&gt; 1.1"},<br/>      {:phoenix_html, "~&gt; 2.11"},<br/>      {:phoenix_live_reload, "~&gt; 1.2", only: :dev},<br/>      {:gettext, "~&gt; 0.11"},<br/>      {:jason, "~&gt; 1.0"},<br/>      {:plug_cowboy, "~&gt; 2.0"},<br/>      {:erlport, "~&gt; 0.10.0"},<br/>      <strong class="mq iu">{:protobuf, "~&gt; 0.5.3"},<br/>      # Only for files generated from Google's protos.<br/>      # Can be ignored if you don't use Google's protos.<br/>      {:google_protos, "~&gt; 0.1"}</strong><br/>    ]<br/>  end</span></pre><p id="9514" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要在mix.exs文件中添加粗体部分，并使用以下命令更新依赖关系—</p><blockquote class="lt lu lv"><p id="d723" class="jq jr kp js b jt ju jv jw jx jy jz ka lw kc kd ke lx kg kh ki ly kk kl km kn im bi translated">混合deps.get</p></blockquote><h2 id="10bb" class="lz kr it bd ks ma mb dn kw mc md dp la kb me mf le kf mg mh li kj mi mj lm mk bi translated"><strong class="ak">安装协议插件:</strong></h2><p id="dca4" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">我们需要使用下面的命令为药剂安装协议插件<strong class="js iu">协议-生成-药剂</strong></p><blockquote class="lt lu lv"><p id="a3e1" class="jq jr kp js b jt ju jv jw jx jy jz ka lw kc kd ke lx kg kh ki ly kk kl km kn im bi translated">mix escript.install hex protobuf</p></blockquote><h2 id="052b" class="lz kr it bd ks ma mb dn kw mc md dp la kb me mf le kf mg mh li kj mi mj lm mk bi translated">注意:<code class="fe my mz na mq b">protoc-gen-elixir </code>需要在PATH中。</h2><h2 id="cf20" class="lz kr it bd ks ma mb dn kw mc md dp la kb me mf le kf mg mh li kj mi mj lm mk bi translated"><strong class="ak">定义消息(。原型文件):</strong></h2><p id="a4ce" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">我们放置了我们的<strong class="js iu">。在<strong class="js iu"><em class="kp">lib/phoenix _ ml/proto buf</em></strong>文件夹下的proto </strong>文件和生成的代码。我们的消息定义文件<strong class="js iu"> iris.proto </strong>如下所示</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="09f0" class="lz kr it mq b gy mu mv l mw mx">syntax = "proto3";<br/><br/>package PhoenixMl;<br/><br/>message IrisParams {<br/>    float sepal_length = 1;<br/>    float sepal_width = 2;<br/>    float petal_length = 3;<br/>    float petal_width = 4;<br/>}</span></pre><p id="4580" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用<strong class="js iu"> proto3 </strong>语法，这里详细介绍—<em class="kp"/><a class="ae ko" href="https://developers.google.com/protocol-buffers/docs/proto3" rel="noopener ugc nofollow" target="_blank"><em class="kp">https://developers.google.com/protocol-buffers/docs/proto3</em></a></p><p id="bee4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基本上，我们的消息格式很简单，包含四个用于模型参数的浮点值— <strong class="js iu"> sepal_length，sepal_width，petal_length，petal_width </strong>。</p><h2 id="eb70" class="lz kr it bd ks ma mb dn kw mc md dp la kb me mf le kf mg mh li kj mi mj lm mk bi translated"><strong class="ak">编译。原型文件并生成药剂代码:</strong></h2><p id="6bf6" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">我们将使用下面的命令从上面的<strong class="js iu">生成仙丹代码。原型</strong>文件—</p><blockquote class="lt lu lv"><p id="be78" class="jq jr kp js b jt ju jv jw jx jy jz ka lw kc kd ke lx kg kh ki ly kk kl km kn im bi translated">protocol-elixir _ out =。iris.proto(从lib/phoenix_ml/protobuf文件夹中运行)</p></blockquote><p id="19f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将生成<strong class="js iu"> iris.pb.ex </strong>文件。</p><h2 id="d166" class="lz kr it bd ks ma mb dn kw mc md dp la kb me mf le kf mg mh li kj mi mj lm mk bi translated"><strong class="ak">更新源代码:</strong></h2><p id="c077" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">接下来，我们将使用以下代码更新<strong class="js iu"> page_controller.ex </strong>文件(已编辑)—</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="566d" class="lz kr it mq b gy mu mv l mw mx"><strong class="mq iu">alias PhoenixMl.IrisParams, as: Iris</strong></span><span id="2f59" class="lz kr it mq b gy nb mv l mw mx">...</span><span id="2180" class="lz kr it mq b gy nb mv l mw mx">...</span><span id="90de" class="lz kr it mq b gy nb mv l mw mx">with {sepal_length, _} &lt;- Float.parse(sepal_length),<br/>         {sepal_width, _} &lt;- Float.parse(sepal_width),<br/>         {petal_length, _} &lt;- Float.parse(petal_length),<br/>         {petal_width, _} &lt;- Float.parse(petal_width) do<br/>      <strong class="mq iu">iris_params = %Iris{<br/>        sepal_length: sepal_length,<br/>        sepal_width: sepal_width,<br/>        petal_length: petal_length,<br/>        petal_width: petal_width<br/>      }</strong><br/><br/>class = ML.predict([<strong class="mq iu">Iris.encode(iris_params)</strong>])</span></pre><p id="5d94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">粗体部分是必要的代码更改。这里我们—</p><ul class=""><li id="28a6" class="nc nd it js b jt ju jx jy kb ne kf nf kj ng kn nh ni nj nk bi translated">导入的<strong class="js iu"> PohenixMl。虹膜参数</strong>模块为<strong class="js iu">虹膜</strong></li><li id="edb3" class="nc nd it js b jt nl jx nm kb nn kf no kj np kn nh ni nj nk bi translated">用参数定义了<strong class="js iu"> %Iris{} </strong>结构</li><li id="e4a0" class="nc nd it js b jt nl jx nm kb nn kf no kj np kn nh ni nj nk bi translated">调用<strong class="js iu"> Iris.encode </strong>生成序列化数据</li></ul><h1 id="3e8e" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">Python部分</h1><h2 id="6ae4" class="lz kr it bd ks ma mb dn kw mc md dp la kb me mf le kf mg mh li kj mi mj lm mk bi translated">编译。原型文件并生成Python代码:</h2><p id="d00d" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">我们将使用下面的命令从上面生成Python代码。原型文件—</p><blockquote class="lt lu lv"><p id="bbfe" class="jq jr kp js b jt ju jv jw jx jy jz ka lw kc kd ke lx kg kh ki ly kk kl km kn im bi translated">protocol-python _ out =。iris.proto(从lib/phoenix_ml/protobuf文件夹中运行)</p></blockquote><p id="1842" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将生成<strong class="js iu"> iris_pb2.py </strong>文件。</p><h2 id="ab2b" class="lz kr it bd ks ma mb dn kw mc md dp la kb me mf le kf mg mh li kj mi mj lm mk bi translated">更新源代码:</h2><p id="184f" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">接下来，我们将用下面的代码更新<strong class="js iu">分类器. py </strong>文件(已编辑)—</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="5abf" class="lz kr it mq b gy mu mv l mw mx">import os<br/>from sklearn.externals import joblib <br/><strong class="mq iu">import sys<br/>sys.path.insert(0, 'lib/phoenix_ml/protobuf')<br/></strong><br/><strong class="mq iu">import iris_pb2</strong><br/><br/>def load_model():<br/>    path = os.path.abspath('lib/phoenix_ml/model/classifier.pkl')<br/>    return joblib.load(path)  <br/><br/>def predict_model(args):<br/>   <strong class="mq iu"> iris_params = iris_pb2.IrisParams()<br/>    iris_params.ParseFromString(args)<br/>    model_params = [[iris_params.sepal_length, iris_params.sepal_width, iris_params.petal_length, iris_params.petal_width]]</strong><br/><br/>    iris_classifier = load_model()<br/>    return iris_classifier.predict(<strong class="mq iu">model_params</strong>)[0]</span></pre><p id="7154" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">粗体部分是必要的代码更改。这里我们—</p><ul class=""><li id="ec9c" class="nc nd it js b jt ju jx jy kb ne kf nf kj ng kn nh ni nj nk bi translated">导入生成的<strong class="js iu"> iris_pb2 </strong>模块</li><li id="2b15" class="nc nd it js b jt nl jx nm kb nn kf no kj np kn nh ni nj nk bi translated">反序列化我们从Elixir app收到的<strong class="js iu">args</strong>—<strong class="js iu">ParseFromString(args)</strong>并定义一个二维数组<strong class="js iu"> model_params </strong></li><li id="b944" class="nc nd it js b jt nl jx nm kb nn kf no kj np kn nh ni nj nk bi translated">用<strong class="js iu">模型参数</strong>进行预测</li></ul><p id="574b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个阶段，我们的更改已经完成，我们应该能够像之前一样进行预测，如下图所示——</p><figure class="ml mm mn mo gt nq gh gi paragraph-image"><div class="ab gu cl nr"><img src="../Images/810b4029ff2d7771ec6585471f8fb3db.png" data-original-src="https://miro.medium.com/v2/format:webp/1*jNLEISDskgHoQO0_5NTjAw.png"/></div></figure><h1 id="b409" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">源代码</h1><p id="c95e" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">早期项目的源代码可以在这里找到——<a class="ae ko" href="https://github.com/imeraj/Phoenix_Playground/tree/master/1.4/phoenix_ml" rel="noopener ugc nofollow" target="_blank"><em class="kp">https://github . com/imeraj/Phoenix _ Playground/tree/master/1.4/Phoenix _ ml</em></a>(<strong class="js iu"><em class="kp">master branch</em></strong>)</p><p id="2f43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用协议缓冲区的更新源代码可以在这里找到—<a class="ae ko" href="https://github.com/imeraj/Phoenix_Playground/tree/protobuf_file/1.4/phoenix_ml" rel="noopener ugc nofollow" target="_blank"><em class="kp">https://github . com/imeraj/Phoenix _ Playground/tree/proto buf _ file/1.4/Phoenix _ ml</em></a>(<strong class="js iu"><em class="kp">proto buf _ file branch</em></strong>)</p><h1 id="99ba" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">参考</h1><ol class=""><li id="1fb9" class="nc nd it js b jt lo jx lp kb nu kf nv kj nw kn nx ni nj nk bi translated"><a class="ae ko" href="https://developers.google.com/protocol-buffers/" rel="noopener ugc nofollow" target="_blank">https://developers.google.com/protocol-buffers/</a></li><li id="dd8b" class="nc nd it js b jt nl jx nm kb nn kf no kj np kn nx ni nj nk bi translated"><a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/using-machine-learning-models-python-from-phoenix-elixir-applications-cd028e4e5f01">https://it next . io/using-machine-learning-models-python-from-phoenix-elixir-applications-CD 028 E4 e 5 f 01</a></li></ol><p id="b6ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.<a class="ae ko" href="https://github.com/tony612/protobuf-elixir" rel="noopener ugc nofollow" target="_blank">https://github.com/tony612/protobuf-elixir</a></p><p id="80a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望这篇文章能够帮助一些读者理解如何使用协议缓冲区来序列化和反序列化数据，并在Elixir和Python之间传递以构建有用的应用程序。</p><p id="7fae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="kp">更多详细和深入的未来技术帖子，请关注我这里或上</em><a class="ae ko" href="https://twitter.com/meraj_enigma" rel="noopener ugc nofollow" target="_blank"><em class="kp">Twitter</em></a><em class="kp">。</em></p></div></div>    
</body>
</html>