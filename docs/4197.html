<html>
<head>
<title>Configuring routing for MetalLB in L2 mode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在L2模式下为MetalLB配置路由</h1>
<blockquote>原文：<a href="https://itnext.io/configuring-routing-for-metallb-in-l2-mode-7ea26e19219e?source=collection_archive---------0-----------------------#2020-05-14">https://itnext.io/configuring-routing-for-metallb-in-l2-mode-7ea26e19219e?source=collection_archive---------0-----------------------#2020-05-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b6261e37db04a5fc935f8e9f3db80b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wI1GLh4MrCzuwiwB.png"/></div></div></figure><p id="bfcf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不久前，我还面临着一个非常不寻常的任务，为MetalLB配置路由。所有这些都不算什么，因为MetalLB通常不需要用户进行任何额外的配置，但是在我们的例子中，有一个相当大的集群，其网络配置非常简单。</p><p id="aea9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将向您展示如何为集群上的外部网络配置基于源和基于策略的路由。</p><p id="11ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不会详细讨论MetalLB的安装和配置，因为我假设您已经有了一些经验。先了解本质，配置路由。所以我们有四种情况:</p><h1 id="2ac7" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">情况1:当您不需要配置任何东西时</h1><p id="bf25" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们考虑一个简单的案例。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/943db8c9e69da9044e8334219c18d8ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/0*TvAegKAqMruqV-i9.png"/></div></figure><p id="ab4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当MetalLB发出的地址与您的节点上配置的地址位于同一子网时，不需要额外的路由配置。</p><p id="c16f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，您有一个子网<code class="fe me mf mg mh b">192.168.1.0/24</code>，它有一个路由器<code class="fe me mf mg mh b">192.168.1.1</code>，并且您的节点有地址:<code class="fe me mf mg mh b">192.168.1.10–30</code>，那么您可以为MetalLB配置范围<code class="fe me mf mg mh b">192.168.1.100–120</code>，并确保它无需任何额外配置即可工作。</p><p id="151f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为什么这样因为您的节点已经配置了路由:</p><pre class="ma mb mc md gt mi mh mj mk aw ml bi"><span id="f8d0" class="mm kx iq mh b gy mn mo l mp mq"># ip route<br/>default via 192.168.1.1 dev eth0 onlink <br/>192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.10</span></pre><p id="de13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来自同一子网的地址将重复使用它们，无需任何额外设置。</p><h1 id="3f6e" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">案例2:当您需要额外的配置时</h1><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/91225991c07320bdec79d713f1ec0ab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/0*VuxN4tUFDv7hQAFh.png"/></div></figure><p id="8648" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当您的节点没有为MetalLB发出地址的子网配置IP地址或路由时，您都需要配置额外的路由。</p><p id="3ee9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我会更详细地解释。每当MetalLB发出一个地址时，这可以被比作一个简单的分配，例如:</p><pre class="ma mb mc md gt mi mh mj mk aw ml bi"><span id="3175" class="mm kx iq mh b gy mn mo l mp mq">ip addr add 10.9.8.7/32 dev lo</span></pre><p id="7bd1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意:</p><ul class=""><li id="b2c7" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated"><strong class="ka ir"> a) </strong>该地址分配有前缀<code class="fe me mf mg mh b">/32</code>，因此该子网的路由不会自动添加(这只是一个IP地址)</li><li id="9bd6" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><strong class="ka ir"> b) </strong>可以在节点上的任何接口上分配地址(例如，环回)。这里值得一提的是Linux网络栈的特性。不管您在哪个接口上添加地址，内核总是处理arp请求并向其中任何一个发送arp回复，这种行为被认为是正确的，而且，它在Kubernetes这样的动态环境中被广泛使用。</li></ul><p id="b04a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，可以通过启用严格arp来配置此行为:</p><pre class="ma mb mc md gt mi mh mj mk aw ml bi"><span id="a0c7" class="mm kx iq mh b gy mn mo l mp mq">echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore<br/>echo 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announce</span></pre><p id="c73b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，只有当接口明确包含特定的IP地址时，才会发送arp回复。如果您计划使用MetalLB并且您的kube-proxy在IPVS模式下工作，则需要此设置。</p><p id="94ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管如此，MetalLB并不使用内核来处理arp请求，而是在用户空间中自行处理，因此该选项不会影响MetalLB的操作。</p><p id="2f13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们回到我们的任务。如果您的节点上不存在已发布地址的路由，请提前将其添加到您的所有节点:</p><pre class="ma mb mc md gt mi mh mj mk aw ml bi"><span id="191f" class="mm kx iq mh b gy mn mo l mp mq">ip route add 10.9.8.0/24 dev eth1</span></pre><h1 id="013c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">案例3:当您需要基于源的路由时</h1><p id="5e6a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">当您通过单独的网关(而不是默认配置的网关)接收数据包时，您需要分别配置基于源的路由，响应数据包必须通过同一个网关。</p><p id="8d67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，您为节点分配了相同的子网<code class="fe me mf mg mh b">192.168.1.0/24</code>,但您希望使用MetalLB发布外部地址。假设您有几个来自位于VLAN 100的<code class="fe me mf mg mh b">1.2.3.0/24</code>子网的地址，并且您想使用它们从外部访问Kubernetes服务。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/54bfc3e6036fcbdefad6a1d57759f94c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/0*yQPI8HI4Q4nmvjRO.png"/></div></figure><p id="5e3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当访问<code class="fe me mf mg mh b">1.2.3.4</code>时，您将从<code class="fe me mf mg mh b">1.2.3.0/24</code>之外的不同子网发出请求，并等待响应。当前包含由MetalLB分配的地址<code class="fe me mf mg mh b">1.2.3.4</code>的节点将从路由器<code class="fe me mf mg mh b">1.2.3.1</code>接收数据包，但是对它们的应答必须通过<code class="fe me mf mg mh b">1.2.3.1</code>沿着相同的路由进行。</p><p id="2a1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们的节点已经配置了默认网关<code class="fe me mf mg mh b">192.168.1.1</code>，默认情况下，这些响应包将通过它，而不是通过我们接收原始包的<code class="fe me mf mg mh b">1.2.3.1</code>。</p><p id="f8f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么如何应对这种情况呢？</p><p id="b870" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，您需要准备好所有节点，以便在不进行额外配置的情况下为外部地址提供服务。也就是说，对于上面的示例，您需要提前在节点上创建一个VLAN接口:</p><pre class="ma mb mc md gt mi mh mj mk aw ml bi"><span id="1c78" class="mm kx iq mh b gy mn mo l mp mq">ip link add link eth0 name eth0.100 type vlan id 100<br/>ip link set eth0.100 up</span></pre><p id="ced8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后添加路线:</p><pre class="ma mb mc md gt mi mh mj mk aw ml bi"><span id="5657" class="mm kx iq mh b gy mn mo l mp mq">ip route add 1.2.3.0/24 dev eth0.100 table 100<br/>ip route add default via 1.2.3.1 table 100</span></pre><p id="ee89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，我们将路由添加到单独的路由表<code class="fe me mf mg mh b">100</code>中，它将只包含通过<code class="fe me mf mg mh b">eth0.100</code>接口和<code class="fe me mf mg mh b">1.2.3.1</code>网关发送响应数据包所需的两条路由。</p><p id="a110" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要添加一个简单的规则:</p><pre class="ma mb mc md gt mi mh mj mk aw ml bi"><span id="f6f4" class="mm kx iq mh b gy mn mo l mp mq">ip rule add from 1.2.3.0/24 lookup 100</span></pre><p id="5447" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中明确表示:如果数据包的源地址在<code class="fe me mf mg mh b">1.2.3.0/24</code>中，则使用路由表<code class="fe me mf mg mh b">100</code>。我们已经添加了将通过<code class="fe me mf mg mh b">1.2.3.1</code>网关发送的路由。</p><h1 id="0604" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">案例4:当您需要基于策略的路由时</h1><p id="fe32" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">网络拓扑与上例相同，但假设您也希望能够从pod内部访问<code class="fe me mf mg mh b">1.2.3.0/24</code>范围的外部地址:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/be8202e292d1f5b6a508ced6d41a2a31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/0*2Wvn3XyfAEuQkd8y.png"/></div></figure><p id="b1fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">独特之处在于，当访问<code class="fe me mf mg mh b">1.2.3.0/24</code>中的任何地址时，到达节点并且源地址在范围<code class="fe me mf mg mh b">1.2.3.0/24</code>内的响应包将顺从地通过<code class="fe me mf mg mh b">eth0.100</code>发送，但是我们希望让Kubernetes将其重定向回我们的第一个pod，这是由原始请求生成的。</p><p id="81af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解决这个问题并不容易，但多亏了基于策略的路由，这才成为可能。</p><p id="9c38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从前面的例子开始，创建一个额外的路由表并向其中添加所需的路由:</p><pre class="ma mb mc md gt mi mh mj mk aw ml bi"><span id="f8b4" class="mm kx iq mh b gy mn mo l mp mq">ip route add 1.2.3.0/24 dev eth0.100 table 100<br/>ip route add default via 1.2.3.1 table 100</span></pre><p id="971f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">方法由</strong> <a class="nh ni ep" href="https://medium.com/u/d67b2f5867f9?source=post_page-----7ea26e19219e--------------------------------" rel="noopener" target="_blank"> <strong class="ka ir">乔治·舒克林</strong> </a>提出</p><p id="5806" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章发表后，我得到了一个更简单、更优雅的方法来解决这个问题，为此你只需要添加两条规则:</p><pre class="ma mb mc md gt mi mh mj mk aw ml bi"><span id="80bd" class="mm kx iq mh b gy mn mo l mp mq">ip rule add from 1.2.3.0/24 lookup 100<br/>ip rule add from 1.2.3.0/24 to 10.112.0.0/12 lookup main</span></pre><p id="759e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中:</p><ul class=""><li id="c26a" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated"><code class="fe me mf mg mh b">1.2.3.0/24</code> —是外部网络</li><li id="9e86" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><code class="fe me mf mg mh b">10.112.0.0/12</code> —是你的podNetwork</li></ul><p id="f09b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了获得最高优先级，第二个规则必须添加在第一个规则之后。</p><p id="819d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">带连接标记的方法</strong></p><p id="a6bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了更好地理解，我将在这里提供一个netfilter框图:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/e3a95025a7d37fd5e072cb2fa246341c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/0*UAr5xjHUxma-BNs2.jpg"/></div></figure><p id="94bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在添加一些iptables规则:</p><pre class="ma mb mc md gt mi mh mj mk aw ml bi"><span id="1f1e" class="mm kx iq mh b gy mn mo l mp mq">iptables -t mangle -A PREROUTING -j CONNMARK --restore-mark<br/>iptables -t mangle -A PREROUTING -m mark ! --mark 0 -j RETURN<br/>iptables -t mangle -A PREROUTING -i bond0.100 -j MARK --set-mark 0x100<br/>iptables -t mangle -A POSTROUTING -j CONNMARK --save-mark</span></pre><p id="08b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些规则将标记到<code class="fe me mf mg mh b">eth0.100</code>接口的传入连接，通过将<code class="fe me mf mg mh b">0x100</code>标记添加到其中的所有数据包，同一连接内的响应数据包也将被标记相同的标记。</p><p id="1699" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以添加一个路由规则:</p><pre class="ma mb mc md gt mi mh mj mk aw ml bi"><span id="fe70" class="mm kx iq mh b gy mn mo l mp mq">ip rule add from 1.2.3.0/24 fwmark 0x100 lookup 100</span></pre><p id="5230" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也就是说，所有带有源地址<code class="fe me mf mg mh b">1.2.3.0/24</code>和标签<code class="fe me mf mg mh b">0x100</code>的数据包都应该使用表<code class="fe me mf mg mh b">100</code>进行路由。</p><p id="d96f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，来自其他接口的其他数据包将不满足此规则，这允许它们使用标准Kubernetes机制进行路由。</p><p id="e5f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Linux中还有一个东西，它被称为反向路径过滤器，s̶p̶o̶i̶l̶s̶̶t̶h̶e̶̶w̶h̶o̶l̶e̶̶r̶a̶s̶p̶b̶e̶r̶r̶y执行一个简单的检查:对于所有传入的数据包，它将源地址更改为目的地址，并检查数据包是否可以通过接收它的同一个接口，如果不能，那么它将被内核丢弃。</p><p id="6da1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题是在我们的例子中它不能正常工作，但是我们可以禁用它:</p><pre class="ma mb mc md gt mi mh mj mk aw ml bi"><span id="782c" class="mm kx iq mh b gy mn mo l mp mq">echo 0 &gt; /proc/sys/net/ipv4/conf/all/rp_filter<br/>echo 0 &gt; /proc/sys/net/ipv4/conf/eth0.100/rp_filter</span></pre><p id="46ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，第一个命令控制rp_filter的全局行为，必须禁用它，否则第二个命令将没有任何作用。但是，其他接口将保持启用rp_filter。</p><p id="a564" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了不完全限制过滤器，我们可以使用netfilter的rp_filter实现。使用rpfilter作为iptables模块，您可以配置相当灵活的规则，例如:</p><pre class="ma mb mc md gt mi mh mj mk aw ml bi"><span id="0b8e" class="mm kx iq mh b gy mn mo l mp mq">iptables -t raw -A PREROUTING -i eth0.100 -d 1.2.3.0/24 -j RETURN<br/>iptables -t raw -A PREROUTING -i eth0.100 -m rpfilter --invert -j DROP</span></pre><p id="6784" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将在<code class="fe me mf mg mh b">eth0.100</code>接口上为除<code class="fe me mf mg mh b">1.2.3.0/24.</code>之外的所有地址启用rp_filter</p></div></div>    
</body>
</html>