<html>
<head>
<title>How to create a stub for testing a one-time password service.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建用于测试一次性密码服务的存根？</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-create-a-stub-for-testing-a-one-time-password-service-68e0de6f6641?source=collection_archive---------2-----------------------#2020-04-12">https://itnext.io/how-to-create-a-stub-for-testing-a-one-time-password-service-68e0de6f6641?source=collection_archive---------2-----------------------#2020-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a058df3c8b0c0a900e4a9d9964bce420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hXuK9AKid4mfDurSO9H5VQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@goshua13?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">约书亚·阿拉贡</a>在<a class="ae kc" href="https://unsplash.com/@max_duz?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="65f2" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">存根与模拟—有什么区别？</h1><p id="6f7a" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir">存根</strong></p><p id="762b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我相信最大的区别是你已经用预定的行为写了一个存根。因此，您将有一个实现依赖关系的类(最有可能是抽象类或接口),这是您为了测试目的而伪造的，而这些方法只是用set responses来清除。他们不会做任何花哨的事情，并且您已经在测试之外为它编写了存根代码。</p><p id="be8b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">嘲弄</strong></p><p id="9778" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">模拟是你测试的一部分，你必须根据你的期望来设置。模拟不是以预先确定的方式建立的，所以您可以在测试中用代码来完成。模拟在某种程度上是在运行时确定的，因为设置期望的代码必须在它们做任何事情之前运行。</p><p id="af0f" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">模拟和存根之间的差异</strong></p><p id="33d9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">用模拟编写的测试通常遵循:</p><p id="a3e2" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><code class="fe me mf mg mh b">initialize -&gt; set expectations -&gt; exercise -&gt; verify</code>图案要测试。而预写的存根将跟随一个<code class="fe me mf mg mh b">initialize -&gt; exercise -&gt; verify</code>。</p><p id="1332" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">仿制品和存根之间的相似性。</strong></p><p id="5dda" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">两者的目的都是为了消除对一个类或函数的所有依赖的测试，这样你的测试就能更集中和更简单地证明它们所要证明的。</p><p id="5d65" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi mi translated">唱存根而不是web服务。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/5354cea4a01a8879cdb06b1d52dd7bee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3WxQbUAGWcyKv2p1upKoWg.jpeg"/></div></div></figure><p id="3d58" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">既然我们在谈论测试，很可能我们有所有的可能性，不仅仅是以嗅探器的形式放置网格，还可以完全取代其中一个服务。使用这种方法，人工服务将获得“频繁的”请求，并且我们将能够控制消息目的地的行为。为此，有一个很棒的WireMock库。你可以在项目的<a class="ae kc" href="https://github.com/tomakehurst/wiremock" rel="noopener ugc nofollow" target="_blank"> GitHub页面</a>查看它的代码。底线是，这是一个具有良好REST API的web服务，几乎可以以任何方式进行配置。这是一个JAVA库，但它能够作为一个独立的应用程序运行，可以在JRE中使用。然后是带有详细文档的简单设置。</p><p id="e1ce" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi mi translated">T21:我们怎么做呢？</p><pre class="ms mt mu mv gt mw mh mx my aw mz bi"><span id="6c33" class="na ke iq mh b gy nb nc l nd ne">testing_service -&gt; service_stub : (its log): {message}.</span></pre><p id="db2c" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">所以我们需要做几件事情:</strong></p><p id="9a8b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">启动存根服务，并通过响应OK来强制它接受某些消息。这将由WireMock完成。</p><p id="9478" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">确保消息被传递到存根服务。</p><p id="2d62" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">失败已经发生的事情。有两种选择——使用WireMock工具进行验证，或者从中获取请求列表，对它们应用匹配器。</p><h1 id="70f5" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">入门指南</h1><p id="111e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">如何手动提升服务在Wiremock网站的<a class="ae kc" href="http://wiremock.org/docs/getting-started/" rel="noopener ugc nofollow" target="_blank">独立运行</a>部分有详细描述。</p><p id="fcc1" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">创建JUnit规则，该规则将在测试开始时引发所需端口上的服务，并在测试结束后结束:</p><pre class="ms mt mu mv gt mw mh mx my aw mz bi"><span id="6ad0" class="na ke iq mh b gy nb nc l nd ne">@Rule<br/><strong class="mh ir">public </strong>WireMockRule <strong class="mh ir">wiremock </strong>= <strong class="mh ir">new </strong>WireMockRule(8091);</span></pre><p id="ef9c" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">测试看起来会像这样:</p><pre class="ms mt mu mv gt mw mh mx my aw mz bi"><span id="2f94" class="na ke iq mh b gy nb nc l nd ne">@Test<br/><strong class="mh ir">public void </strong>shouldSend3Callbacks() <strong class="mh ir">throws </strong>Exception {<br/>    <em class="nf"><br/>    </em>stubFor(any(urlMatching(<strong class="mh ir">".*"</strong>)).willReturn(aResponse()<br/>            .withStatus(HttpStatus.OK_200).withBody(<strong class="mh ir">"OK"</strong>)));</span></pre><p id="6c7e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">让我们的存根接受任何消息。</p><h1 id="3dff" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">作为独立进程运行</h1><p id="7e98" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">WireMock服务器可以在自己的进程中运行，并通过Java API、JSON over HTTP或JSON文件进行配置。</p><p id="6da4" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">一旦<a class="ae kc" href="https://repo1.maven.org/maven2/com/github/tomakehurst/wiremock-standalone/2.26.3/wiremock-standalone-2.26.3.jar" rel="noopener ugc nofollow" target="_blank">下载了独立的JAR </a>,您就可以简单地这样运行它:</p><pre class="ms mt mu mv gt mw mh mx my aw mz bi"><span id="6d65" class="na ke iq mh b gy nb nc l nd ne">$ java -jar wiremock-standalone-"number of last version".jar --port 8091</span></pre><h1 id="9c5c" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">命令行选项</h1><p id="552a" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">可以选择在命令行上指定以下内容:</p><p id="0331" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><code class="fe me mf mg mh b">--port</code>:设置HTTP端口号，如<code class="fe me mf mg mh b">--port 9999</code>。使用<code class="fe me mf mg mh b">--port 0</code>来动态确定端口。</p><h1 id="1f89" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">JSON文件配置</h1><p id="e27a" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">您还可以通过文件使用JSON API。当WireMock服务器启动时，它在当前目录下创建两个目录:<code class="fe me mf mg mh b">mappings</code>和<code class="fe me mf mg mh b">__files</code>。</p><p id="c2a7" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">要通过这种方法创建如上所示的存根，将一个扩展名为<code class="fe me mf mg mh b">.json</code>的文件放在<code class="fe me mf mg mh b">mappings</code>下，内容如下:</p><pre class="ms mt mu mv gt mw mh mx my aw mz bi"><span id="aa4b" class="na ke iq mh b gy nb nc l nd ne">{<br/>  "request" : {<br/>    "urlPath" : "/get-code",<br/>    "method" : "GET",<br/>    "queryParameters" : {<br/>      "token" : {<br/>        "matches" : "access_token=([^&amp;]*)"<br/>      },<br/>      "phone" : {<br/>        "matches" : "^((\+7|7|8)+([0-9]){10})$"<br/>      }<br/>    }<br/>  },<br/>    "response": {<br/>        "status": 200,<br/>        "headers": {<br/>            "Content-Type": "application/json; charset=utf-8"<br/>        },<br/>        "<!-- -->jsonBody<!-- -->": {<strong class="mh ir">"code"</strong>:<strong class="mh ir">"1234"}</strong><br/>    }<br/>}</span></pre><p id="85be" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">重新启动服务器后，您应该能够执行以下操作:</p><pre class="ms mt mu mv gt mw mh mx my aw mz bi"><span id="bc2d" class="na ke iq mh b gy nb nc l nd ne">$ curl <a class="ae kc" href="http://localhost:8080/api/mytest" rel="noopener ugc nofollow" target="_blank">http://localhost:8091/get-code</a>/</span></pre><h1 id="ef03" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">停工</h1><p id="4cd6" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">要关闭服务器，向<code class="fe me mf mg mh b">http://&lt;host&gt;:&lt;port&gt;/__admin/shutdown</code>发送一个带有空主体的请求。</p><h1 id="b888" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">JUnit 4.x规则</h1><p id="97eb" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">JUnit规则提供了一种在测试用例中包含WireMock的便捷方式。它为您处理生命周期，在每个测试方法之前启动服务器，之后停止。</p><pre class="ms mt mu mv gt mw mh mx my aw mz bi"><span id="8cb5" class="na ke iq mh b gy nb nc l nd ne">@Rule<br/><strong class="mh ir">public </strong>WireMockRule <strong class="mh ir">wireMockRule </strong>= <strong class="mh ir">new </strong>WireMockRule();</span></pre><p id="41f7" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">此外，规则的构造函数可以接受一个Options实例来覆盖各种设置。</p><pre class="ms mt mu mv gt mw mh mx my aw mz bi"><span id="b254" class="na ke iq mh b gy nb nc l nd ne">@Rule<br/><strong class="mh ir">public </strong>WireMockRule <strong class="mh ir">wireMockRule </strong>= <strong class="mh ir">new </strong>WireMockRule(<em class="nf">options</em>().port(8091));</span></pre><p id="1f19" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">实现代码可能如下所示:</p><pre class="ms mt mu mv gt mw mh mx my aw mz bi"><span id="3f20" class="na ke iq mh b gy nb nc l nd ne"><em class="nf">/**<br/> * The type Base api.<br/> */<br/></em><strong class="mh ir">public class </strong>BaseApi {<br/>    <br/>    <em class="nf">/**<br/>     * Default constructor.<br/>     */<br/>    </em><strong class="mh ir">public </strong>BaseApi() {<br/>        <strong class="mh ir">super</strong>();<br/>        <em class="nf">//empty<br/>        </em><strong class="mh ir">return</strong>;<br/>    }<br/><br/>    @Rule<br/>    <strong class="mh ir">public </strong>WireMockRule <strong class="mh ir">wireMockRule </strong>= <strong class="mh ir">new </strong>WireMockRule(<em class="nf">options</em>().port(8091));<br/><br/><br/><br/>    <em class="nf">/**<br/>     * Before test.<br/>     */<br/>    </em>@BeforeTest(alwaysRun = <strong class="mh ir">true</strong>)<br/>    <strong class="mh ir">public void </strong>beforeTest() {<br/>        <strong class="mh ir">wireMockRule</strong>.start();<br/><br/>        <strong class="mh ir">final </strong>MockApiService mockApiService = <strong class="mh ir">new </strong>MockApiService();<br/>        mockApiService.startMockService();<br/><br/>    }<br/><br/>    <em class="nf">/**<br/>     * After test.<br/>     */<br/>    </em>@AfterTest<br/>    <strong class="mh ir">public void </strong>afterTest() {<br/>        <strong class="mh ir">wireMockRule</strong>.stop();<br/>    }<br/>}</span></pre><h1 id="7b8d" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Java(非JUnit)用法</h1><p id="b1b5" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">如果您想在JUnit之外使用来自Java(或任何其他JVM语言)的WireMock，您可以通过编程创建、启动和停止服务器:</p><pre class="ms mt mu mv gt mw mh mx my aw mz bi"><span id="fc67" class="na ke iq mh b gy nb nc l nd ne"><em class="nf">/**<br/> * The type Base api.<br/> */<br/></em><strong class="mh ir">public class </strong>BaseApi {<br/><br/>    <em class="nf">/**<br/>     * Value mWireMockServer.<br/>     */<br/>    </em><strong class="mh ir">private </strong>WireMockServer <strong class="mh ir">mWireMockServer</strong>;<br/><br/>    <em class="nf">/**<br/>     * Value HTTP_PORT.<br/>     */<br/>    </em><strong class="mh ir">public static final int <em class="nf">HTTP_PORT </em></strong>= 8091;<br/><br/>    <em class="nf">/**<br/>     * Default constructor.<br/>     */<br/>    </em><strong class="mh ir">public </strong>BaseApi() {<br/>        <strong class="mh ir">super</strong>();<br/>        <em class="nf">//empty<br/>        </em><strong class="mh ir">return</strong>;<br/>    }<br/><br/>    <em class="nf">/**<br/>     * Before test.<br/>     */<br/>    </em>@BeforeTest(alwaysRun = <strong class="mh ir">true</strong>)<br/>    <strong class="mh ir">public void </strong>beforeTest() {<br/>        <strong class="mh ir">mWireMockServer </strong>= <strong class="mh ir">new </strong>WireMockServer(<em class="nf">options</em>().port(<strong class="mh ir"><em class="nf">HTTP_PORT</em></strong>));<br/>        <strong class="mh ir">mWireMockServer</strong>.start();<br/><br/>        <strong class="mh ir">final </strong>MockApiService mockApiService = <strong class="mh ir">new </strong>MockApiService();<br/>        mockApiService.startMockService();<br/><br/>    }<br/><br/>    <em class="nf">/**<br/>     * After test.<br/>     */<br/>    </em>@AfterTest<br/>    <strong class="mh ir">public void </strong>afterTest() {<br/>        <strong class="mh ir">mWireMockServer</strong>.stop();<br/>    }<br/>}</span></pre><p id="544e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">基本存根<br/> </strong>下面的代码将配置一个状态为200的响应，在相对URL与/get-code完全匹配时返回(包括查询参数token和phone)。响应的主体将是“code ”,并且将发送一个带有值text-plain的内容类型头。</p><pre class="ms mt mu mv gt mw mh mx my aw mz bi"><span id="eea0" class="na ke iq mh b gy nb nc l nd ne"><em class="nf">/**<br/> * The type Mock service.<br/> */<br/></em><strong class="mh ir">public class </strong>MockApiService {<br/><br/>    <em class="nf">/**<br/>     * The constant SUCCESS.<br/>     */<br/>    </em><strong class="mh ir">private static final int <em class="nf">SUCCESS </em></strong>= 200;<br/><br/>    <em class="nf">/**<br/>     * Default constructor.<br/>     */<br/>    </em><strong class="mh ir">public </strong>MockApiService() {<br/>        <strong class="mh ir">super</strong>();<br/>        <em class="nf">//empty<br/>        </em><strong class="mh ir">return</strong>;<br/>    }<br/><br/>    <em class="nf">/**<br/>     * Start mock service.<br/>     */<br/>    </em><strong class="mh ir">public void </strong>startMockService() {<br/>        <em class="nf">configureFor</em>(<strong class="mh ir">"localhost"</strong>, <strong class="mh ir"><em class="nf">HTTP_PORT</em></strong>);<br/>        <em class="nf">stubFor</em>(<em class="nf">get</em>(<em class="nf">urlPathMatching</em>(<strong class="mh ir">"/get-code"</strong>))<br/>                .withQueryParam(<strong class="mh ir">"token"</strong>, <em class="nf">matching</em>(<strong class="mh ir">"access_token=([^&amp;]*)"</strong>))<br/>                .withQueryParam(<strong class="mh ir">"phone"</strong>, <em class="nf">matching</em>(<strong class="mh ir">"^((\\+7|7|8)+([0-9]){10})$"</strong>))<br/>                .willReturn(<em class="nf">aResponse</em>()<br/>                        .withStatus(<strong class="mh ir"><em class="nf">SUCCESS</em></strong>)<br/>                        .withHeader(<strong class="mh ir">"Content-Type"</strong>, <strong class="mh ir">"application/json"</strong>)<br/>                        .withBody(<strong class="mh ir">"{\"code\":\"1234\"}"</strong>)));<br/><br/>    }<br/>}</span></pre><p id="d0f6" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">本教程介绍了WireMock以及如何设置和配置这个库来测试REST APIs。</p><p id="9abb" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这篇文章教会了我们两件事:</p><ul class=""><li id="eac0" class="ng nh iq ld b le lz li ma lm ni lq nj lu nk ly nl nm nn no bi translated">Stubbing是一种允许我们配置HTTP响应的技术，当我们的WireMock服务器收到一个特定的HTTP请求时，就会返回这个响应。</li><li id="f340" class="ng nh iq ld b le np li nq lm nr lq ns lu nt ly nl nm nn no bi translated">创建获取一次性密码的服务。</li></ul><p id="0e09" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在下一篇文章中，我们将学习如何使用web UI测试工具Selenium WebDriver来处理一次性密码服务</p></div></div>    
</body>
</html>