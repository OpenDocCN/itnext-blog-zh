<html>
<head>
<title>[Refactor] Go Worker Pool — A way around to the sync package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[Refactor]Go Worker Pool——一种绕过同步包的方法</h1>
<blockquote>原文：<a href="https://itnext.io/refactor-go-worker-pool-a-way-around-to-the-sync-package-7d45b1afb768?source=collection_archive---------0-----------------------#2021-07-05">https://itnext.io/refactor-go-worker-pool-a-way-around-to-the-sync-package-7d45b1afb768?source=collection_archive---------0-----------------------#2021-07-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5211" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过使用信号量模式而不是sync.WaitGroup来同步工作线程执行。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a3cef63a988ce7916768959a141dc73a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AfbInTo4PqRhyu8srHFmLA.png"/></div></div></figure><blockquote class="kr ks kt"><p id="6114" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">在您继续之前</strong>，我想让您知道，本文不会告诉您信号量比使用WaitGroups更好，反之亦然，但是您可以通过纯粹使用通道为我们的WorkerPool实现选择一种不同的方法。</p></blockquote><h1 id="1d18" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">介绍</h1><blockquote class="kr ks kt"><p id="cd09" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">【TL:DR】</strong><em class="iq">你可以跳过这个</em> <a class="ae mj" href="#8501" rel="noopener ugc nofollow"> <em class="iq">直接跳到实现</em> </a> <em class="iq">。</em></p></blockquote><p id="b4b4" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld mk lf lg lh ml lj lk ll mm ln lo lp lq ij bi translated">上周我想出了<a class="ae mj" rel="noopener ugc nofollow" target="_blank" href="/explain-to-me-go-concurrency-worker-pool-pattern-like-im-five-e5f1be71e2b0"> <strong class="kx ir"> <em class="kw">“向我解释Go Worker Pool模式就像我五岁一样”</em> </strong> </a> <strong class="kx ir"> </strong>的帖子，在那里我们经历了这个模式，它的组件，以及它们是如何一起工作的。在我的LinkedIn账户上发布了这篇文章后，我的一位前同事向我指出，我们仍然可以让<code class="fe mn mo mp mq b">WorkerPool</code>照原样工作，而不需要使用sync包中的<code class="fe mn mo mp mq b">WaitGroup</code>作为<code class="fe mn mo mp mq b">Worker</code>的同步机制。</p><div class="mr ms gp gr mt mu"><a rel="noopener  ugc nofollow" target="_blank" href="/explain-to-me-go-concurrency-worker-pool-pattern-like-im-five-e5f1be71e2b0"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd ir gy z fp mz fr fs na fu fw ip bi translated">向我解释Go并发工作池模式，就像我五岁时一样</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">简单解释一下这个模式的所有组件如何协同工作来并发处理一批作业。</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">itnext.io</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni kp mu"/></div></div></a></div><p id="db0a" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld mk lf lg lh ml lj lk ll mm ln lo lp lq ij bi translated">记住上一篇文章，<code class="fe mn mo mp mq b">WaitGroup</code>的目标是阻塞运行<code class="fe mn mo mp mq b">WorkerPool</code>的goroutine，直到每个<code class="fe mn mo mp mq b">Worker</code>完成<code class="fe mn mo mp mq b">Job</code>的处理。因此，如果我们不得不移除<code class="fe mn mo mp mq b">WaitGroup</code>，我们将不得不以某种方式模拟它的功能。我们如何实现这样的行为实现？</p><h1 id="8501" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">关键是利用渠道！</h1><p id="1371" class="pw-post-body-paragraph ku kv iq kx b ky nj jr la lb nk ju ld mk nl lg lh ml nm lk ll mm nn lo lp lq ij bi translated">从某种意义上说，要从组合中去掉<code class="fe mn mo mp mq b">WaitGroup</code>，我们必须:</p><ol class=""><li id="ba41" class="no np iq kx b ky kz lb lc mk nq ml nr mm ns lq nt nu nv nw bi translated">创建一个<code class="fe mn mo mp mq b">execution</code> <code class="fe mn mo mp mq b">slot</code>计数器。每个被允许加工<code class="fe mn mo mp mq b">Job</code>的<code class="fe mn mo mp mq b">Worker</code>必须<code class="fe mn mo mp mq b"><strong class="kx ir">acquire</strong></code>一个<code class="fe mn mo mp mq b">execution</code>一个<code class="fe mn mo mp mq b">slot</code>。该操作<em class="kw">将</em> <code class="fe mn mo mp mq b">slots</code>可用性减少1。</li><li id="bae3" class="no np iq kx b ky nx lb ny mk nz ml oa mm ob lq nt nu nv nw bi translated">将<code class="fe mn mo mp mq b">slot</code>标记为<code class="fe mn mo mp mq b"><strong class="kx ir">release</strong></code> d，这个<em class="kw">在<code class="fe mn mo mp mq b">Worker</code>完成后增加</em> <code class="fe mn mo mp mq b">slots</code>可用性1。</li><li id="07d7" class="no np iq kx b ky nx lb ny mk nz ml oa mm ob lq nt nu nv nw bi translated">阻止<code class="fe mn mo mp mq b">WorkerPool</code>返回，所以我们<code class="fe mn mo mp mq b"><strong class="kx ir">wait</strong></code>直到<code class="fe mn mo mp mq b">Worker</code> s完成他们的处决。</li></ol><h2 id="85a4" class="oc ls iq bd lt od oe dn lx of og dp mb mk oh oi md ml oj ok mf mm ol om mh on bi translated">计数槽的通道</h2><p id="ee56" class="pw-post-body-paragraph ku kv iq kx b ky nj jr la lb nk ju ld mk nl lg lh ml nm lk ll mm nn lo lp lq ij bi translated">用工作计数容量配置的<code class="fe mn mo mp mq b">execution</code> <code class="fe mn mo mp mq b">slots</code>缓冲通道将代表<code class="fe mn mo mp mq b">slot</code>总计数。</p><pre class="kg kh ki kj gt oo mq op oq aw or bi"><span id="741b" class="oc ls iq mq b gy os ot l ou ov"><em class="kw">type </em>slot <em class="kw">struct</em>{}<br/><em class="kw">type </em>slots <em class="kw">chan </em>slot<br/><br/><em class="kw">type </em>execution <em class="kw">struct </em>{<br/>   slots slots<br/>}<br/><br/><em class="kw">func </em>newExecutionSlots(capacity int) execution {<br/>   slots := make(<em class="kw">chan </em>slot, capacity) // capacity = worker count<br/>   <em class="kw">return </em>execution{slots: slots}<br/>}</span><span id="d251" class="oc ls iq mq b gy ow ot l ou ov"><em class="kw">func </em>(e execution) <strong class="mq ir">acquire</strong>() { // <strong class="mq ir">1<br/></strong>   e.slots &lt;- slot{}<br/>}<br/><br/><em class="kw">func </em>(e execution) <strong class="mq ir">release</strong>() { // <strong class="mq ir">2</strong><br/>   &lt;-e.slots<br/>}<br/><br/><em class="kw">func </em>(e execution) <strong class="mq ir">wait</strong>() { // <strong class="mq ir">3</strong><br/>   <em class="kw">for </em>i := 0; i &lt; cap(e.slots); i++ {<br/>      e.slots &lt;- slot{} // empty struct type<br/>   }<br/>}</span><span id="49fe" class="oc ls iq mq b gy ow ot l ou ov">// close the slots channel when done with it<br/><em class="kw">func </em>(e execution) close() {<br/>   close(e.slots)<br/>}</span></pre><ol class=""><li id="46c3" class="no np iq kx b ky kz lb lc mk nq ml nr mm ns lq nt nu nv nw bi translated">对于<code class="fe mn mo mp mq b"><strong class="kx ir">acquire</strong></code> <strong class="kx ir"> </strong>其中一个，我们必须将一个空结构推到<code class="fe mn mo mp mq b">execution</code>的<code class="fe mn mo mp mq b">slots</code>通道上。此<em class="kw">会降低</em> <code class="fe mn mo mp mq b">slot</code>的可用性。</li><li id="a0ea" class="no np iq kx b ky nx lb ny mk nz ml oa mm ob lq nt nu nv nw bi translated">为了<code class="fe mn mo mp mq b"><strong class="kx ir">release</strong></code>，需要从<code class="fe mn mo mp mq b">execution</code>的<code class="fe mn mo mp mq b">slots</code>通道中读出一个<code class="fe mn mo mp mq b">slot</code>读数。这个<em class="kw">增加了</em> <code class="fe mn mo mp mq b">slot</code>的可用性。</li><li id="4bd4" class="no np iq kx b ky nx lb ny mk nz ml oa mm ob lq nt nu nv nw bi translated">到<code class="fe mn mo mp mq b">WorkerPool</code>上的<code class="fe mn mo mp mq b"><strong class="kx ir">wait</strong></code>为了让<code class="fe mn mo mp mq b">Workers</code>完成，我们试图在工人计数到<code class="fe mn mo mp mq b">slots</code>通道时推送许多空结构(目的是将它们全部取出)。但是这是不允许的，因为这个通道被<code class="fe mn mo mp mq b">Workers</code>完全<code class="fe mn mo mp mq b"><strong class="kx ir">acquire</strong></code> d(没有更多的空闲槽可用)，这会阻塞当前的goroutine。这种情况会一直发生，直到<code class="fe mn mo mp mq b">Worker</code>结束，而<code class="fe mn mo mp mq b"><strong class="kx ir">release</strong></code>成为<code class="fe mn mo mp mq b">slot</code>为止。因此，通过这种方式，我们阻止了<code class="fe mn mo mp mq b">WorkerPool</code>从执行中返回。</li></ol><p id="2c78" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld mk lf lg lh ml lj lk ll mm ln lo lp lq ij bi translated">正如我们在这里看到的，<code class="fe mn mo mp mq b">Worker</code>同步将由这个在<code class="fe mn mo mp mq b">Worker</code>的goroutines间共享的<em class="kw">伪</em>计数器来管理。增加/减少<code class="fe mn mo mp mq b">slot</code>可用性将由我们通过<code class="fe mn mo mp mq b">slots</code>渠道执行的操作来表示。</p><ul class=""><li id="984a" class="no np iq kx b ky kz lb lc mk nq ml nr mm ns lq ox nu nv nw bi translated"><code class="fe mn mo mp mq b"><strong class="kx ir">slots</strong></code> <strong class="kx ir">计数</strong> ( <code class="fe mn mo mp mq b">Worker</code>计数)= <code class="fe mn mo mp mq b"><em class="kw">slot</em></code> <em class="kw">通道容量</em></li><li id="3b62" class="no np iq kx b ky nx lb ny mk nz ml oa mm ob lq ox nu nv nw bi translated"><strong class="kx ir"/><code class="fe mn mo mp mq b"><strong class="kx ir">slots</strong></code><strong class="kx ir">计数</strong> = <code class="fe mn mo mp mq b"><em class="kw">slot</em></code> <em class="kw">通道长度</em></li><li id="e7d8" class="no np iq kx b ky nx lb ny mk nz ml oa mm ob lq ox nu nv nw bi translated"><strong class="kx ir">空闲</strong> <code class="fe mn mo mp mq b"><strong class="kx ir">slots</strong></code> <strong class="kx ir">计数</strong> = ( <em class="kw">容量—长度</em>)</li></ul><p id="da2f" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld mk lf lg lh ml lj lk ll mm ln lo lp lq ij bi translated">我们在这里所做的只是描述一个<code class="fe mn mo mp mq b"><strong class="kx ir">semaphore</strong></code>实现。在计算机科学中，这是一种允许进程安全并发地访问共享资源的机制。</p><pre class="kg kh ki kj gt oo mq op oq aw or bi"><span id="1181" class="oc ls iq mq b gy os ot l ou ov"><em class="kw">type </em><strong class="mq ir">semaphore</strong> <em class="kw">interface </em>{<br/>   acquire()<br/>   release()<br/>   wait()<br/>   close()<br/>}</span></pre><p id="a3dc" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld mk lf lg lh ml lj lk ll mm ln lo lp lq ij bi translated">为了寻找一个易于理解的概念描述，我无意中发现了维基百科的一个章节，它很好地描述了这个概念:</p><blockquote class="kr ks kt"><p id="a428" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将信号量视为在现实系统中使用的一种有用的方式是记录<strong class="kx ir">有多少单位的特定资源可用</strong>，以及在单位被<strong class="kx ir">获取</strong>或<strong class="kx ir">变得自由(释放)</strong>时安全地调整该记录的操作(即，避免竞争条件)，如果必要的话，<strong class="kx ir">等待</strong>直到一个单位的资源变得可用。</p></blockquote><p id="cc7e" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld mk lf lg lh ml lj lk ll mm ln lo lp lq ij bi translated">因此，我们可以将<code class="fe mn mo mp mq b">execution</code> <code class="fe mn mo mp mq b">slots</code>通道视为<code class="fe mn mo mp mq b">slots</code>可用性的计数器(槽是我们的“<em class="kw">共享资源</em>”)。每个<code class="fe mn mo mp mq b">Worker</code>都要声明一个<code class="fe mn mo mp mq b">slot</code>才能运行。当所有的<code class="fe mn mo mp mq b">slots</code>都是<code class="fe mn mo mp mq b"><strong class="kx ir">acquired</strong></code>时，<code class="fe mn mo mp mq b">WorkerPool</code>将<code class="fe mn mo mp mq b"><strong class="kx ir">wait</strong></code>为它们全部完成以获得<code class="fe mn mo mp mq b"><strong class="kx ir">release</strong></code> d <code class="fe mn mo mp mq b">slot</code>。</p><p id="1f64" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld mk lf lg lh ml lj lk ll mm ln lo lp lq ij bi translated">最后，<code class="fe mn mo mp mq b">WorkerPool</code>代码将如下所示:</p><pre class="kg kh ki kj gt oo mq op oq aw or bi"><span id="06a4" class="oc ls iq mq b gy os ot l ou ov"><em class="kw">func </em>(wp WorkerPool) Run(ctx context.Context) {<br/>   eSlots := <strong class="mq ir">newExecutionSlots</strong>(wp.workersCount) <strong class="mq ir">// create new slots</strong><br/>   <em class="kw">defer </em>eSlots.close() <em class="kw">// closing slots channel before WP returns</em><br/><br/>   <em class="kw">for </em>i := 0; i &lt; wp.workersCount; i++ {<br/>      <strong class="mq ir">//</strong> <strong class="mq ir"><em class="kw">for each worker acquire an execution slot</em></strong><br/>      eSlots.<strong class="mq ir">acquire</strong>()</span><span id="6f86" class="oc ls iq mq b gy ow ot l ou ov"><em class="kw">     // share the slot channel to workers to let them<br/>     // mark them as released as soon they finish      <br/>     go </em>worker(ctx, wp.jobs, wp.results, <strong class="mq ir">eSlots</strong>)<br/>   }</span><span id="3e34" class="oc ls iq mq b gy ow ot l ou ov"><strong class="mq ir">   // wait for workers to finish its execution<br/></strong>   eSlots.<strong class="mq ir">wait</strong>()<br/>   close(wp.results)<br/>}</span></pre><h2 id="7c4e" class="oc ls iq bd lt od oe dn lx of og dp mb mk oh oi md ml oj ok mf mm ol om mh on bi translated">摘要</h2><p id="e088" class="pw-post-body-paragraph ku kv iq kx b ky nj jr la lb nk ju ld mk nl lg lh ml nm lk ll mm nn lo lp lq ij bi translated">这种重构使您的代码只依赖于通道，并让您有机会完全摆脱对<code class="fe mn mo mp mq b">sync</code>包的依赖，因为您只需使用通道就可以模拟<code class="fe mn mo mp mq b">WaitGroup</code>行为。</p><p id="6d4e" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld mk lf lg lh ml lj lk ll mm ln lo lp lq ij bi translated">我把<strong class="kx ir"> PR </strong>留给你，你可以在这里检查我对<code class="fe mn mo mp mq b">WorkerPool</code>的代码所做的更改以及<code class="fe mn mo mp mq b">WaitGroup</code>是如何被替换的。</p><div class="mr ms gp gr mt mu"><a href="https://github.com/godoylucase/workers-pool/pull/3" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd ir gy z fp mz fr fs na fu fw ip bi translated">用信号量替换WaitGroup，而不是用godoylucase Pull请求#3 …</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">将此建议添加到可以作为单次提交应用的批处理中。此建议无效，因为没有更改…</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">github.com</p></div></div><div class="nd l"><div class="oy l nf ng nh nd ni kp mu"/></div></div></a></div><p id="a191" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld mk lf lg lh ml lj lk ll mm ln lo lp lq ij bi translated">欢迎任何意见或建议，感谢阅读！</p></div></div>    
</body>
</html>