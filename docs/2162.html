<html>
<head>
<title>Telegram bot in Go: speak robot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋中的电报机器人:说话机器人</h1>
<blockquote>原文：<a href="https://itnext.io/telegram-bot-in-go-speak-robot-16c54d655455?source=collection_archive---------4-----------------------#2019-04-09">https://itnext.io/telegram-bot-in-go-speak-robot-16c54d655455?source=collection_archive---------4-----------------------#2019-04-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7b24225aa710425db36ddedeb38ee591.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6bTgcpA9zwS2UuLe.jpg"/></div></div></figure><p id="9d78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上次我教我的机器人跟人说话。这次我要教它和机器人说话。我将添加几个bot命令。在Telegram中，机器人接收的文本与你发送的完全一样。按照惯例，当第一个单词以反斜杠(<code class="fe kx ky kz la b">/</code>)开头时，它被解释为命令。命令用来告诉机器人做什么。这有点像壳牌，我想你大部分时间都在这里度过。</p><p id="cfdc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">go-telegram-bot-api/telegram-bot-api</code>包提供了一些函数来检查接收到的消息中是否有命令，并让您提取它和它的参数。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="d9b3" class="lj lk iq la b gy ll lm l ln lo">for update := range updates {<br/>    if update.Message.IsCommand() {<br/>        command := update.Message.Command()<br/>        arguments := update.Message.CommandArguments()<br/>    }<br/>}</span></pre><p id="d891" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">经过一些轻微的重构，我的机器人已经可以接受命令和普通文本了。实际上，纯文本被简单地映射到<code class="fe kx ky kz la b">/add</code>命令。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="5b3a" class="lj lk iq la b gy ll lm l ln lo">if message.IsCommand() {<br/>    switch command := message.Command(); command {<br/>    case "a", "add":<br/>        c.add(message.CommandArguments())<br/>    case "e", "export":<br/>        c.export()<br/>    case "h", "help":<br/>        c.help()<br/>    case "s", "since":<br/>        c.since(message.CommandArguments())<br/>    case "t", "top":<br/>        c.top()<br/>    case "test":<br/>        c.test()<br/>    default:<br/>        c.sendText(fmt.Sprintf("Eh? /%s?", command))<br/>    }<br/>} else {<br/>    c.add(message.Text)<br/>}</span></pre><h2 id="1b58" class="lj lk iq bd lp lq lr dn ls lt lu dp lv kj lw lx ly kn lz ma mb kr mc md me mf bi translated">/测试</h2><p id="4759" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">最简单的命令是<code class="fe kx ky kz la b">/test</code>，它只是发回一些硬编码的文本。实现起来非常简单:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="3512" class="lj lk iq la b gy ll lm l ln lo">func (c context) test() {<br/>    c.bot.Send(tgbotapi.NewMessage(c.message.Chat.ID, "It works"))<br/>}</span></pre><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/b9d4e22c1b67a14d4de1fd80d5f0fe11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HDBst9Xtq5VzCFnS.png"/></div></div></figure><h2 id="dc52" class="lj lk iq bd lp lq lr dn ls lt lu dp lv kj lw lx ly kn lz ma mb kr mc md me mf bi translated">/导出</h2><p id="07be" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">导出是一个非常重要的命令。我认为它非常重要，所以我首先实现了它。它允许用户下载存储在机器人数据库中的所有数据。对供应商锁定说不。</p><p id="03a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这几天真的很烦。以任何应用程序为例，比如健身追踪器应用程序。它会跟踪你的跑步记录，并将你的数据存储在手机或云端的某个地方。有一天，它停止工作，或者你决定开始使用另一个应用程序。你是做什么的？您如何迁移您的数据？通常，没有简单的方法或者根本没有方法。你必须放弃所有的历史和进步，在新的应用程序中重新开始。</p><p id="6ac6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不希望我还不存在的用户也这样。让他们随时把数据带回家。这就是我拥有<code class="fe kx ky kz la b">/export</code>指挥权的原因。只要对机器人说<code class="fe kx ky kz la b">/export</code>，它就会很乐意遵从:</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/bc192d61cf956a76410812db577e522d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8NYEZUbVxhMTfAca.png"/></div></div></figure><p id="8933" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了生成CSV文件，我使用了内置的包<code class="fe kx ky kz la b">encoding/csv</code>。将所有行导出到CSV文件非常容易:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="395f" class="lj lk iq la b gy ll lm l ln lo">buffer := &amp;bytes.Buffer{}<br/>csv := csv.NewWriter(buffer)<br/><br/>// For each row<br/>for ... {<br/>    csv.Write([]string{name, date})<br/>}<br/><br/>// Flush when done (important!)<br/>csv.Flush()<br/><br/>// Send<br/>c.bot.Send(tgbotapi.NewDocumentUpload(<br/>    c.message.Chat.ID,<br/>    tgbotapi.FileBytes{<br/>        Name:  "data.csv",<br/>        Bytes: buffer.Bytes()}))</span></pre><h2 id="6903" class="lj lk iq bd lp lq lr dn ls lt lu dp lv kj lw lx ly kn lz ma mb kr mc md me mf bi translated">/add和/since</h2><p id="2cc7" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated"><code class="fe kx ky kz la b">/add</code>和<code class="fe kx ky kz la b">/since</code>命令是这个机器人的面包和黄油。顾名思义，一个用于添加事件，另一个用于检查上次添加事件的时间。<code class="fe kx ky kz la b">/add</code>是二合一命令，就像一瓶洗发水&amp;护发素，显示添加前的时间。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/52b92c73acfd1dc335ae570c9a3e2225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pso-_eAYZXEd6QF0.png"/></div></div></figure><h2 id="e312" class="lj lk iq bd lp lq lr dn ls lt lu dp lv kj lw lx ly kn lz ma mb kr mc md me mf bi translated">/顶部</h2><p id="3f16" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">为了练习SQL，我添加了一个相对无用的命令来显示10个最常记录的事件。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="f6d9" class="lj lk iq la b gy ll lm l ln lo">SELECT name, COUNT(name) freq FROM events<br/>    WHERE user = &lt;user-id&gt;<br/>    GROUP BY name<br/>    ORDER BY freq DESC<br/>    LIMIT 10</span></pre><p id="66bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的非常愚蠢的数据集上，它看起来像这样:</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/e3fa23ce6099f9343682093cc2189f89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*P-owbtabh2qvHWRG.png"/></div></div></figure><p id="f833" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不得不说，到目前为止，SQL给我留下了深刻的印象。理论上我知道它能做什么。但是现在我开始尝试，这真的很酷，我可以只写一个简单的查询，而不是写一堆带有循环和变量的代码。可能也更有效率。</p><h2 id="3d22" class="lj lk iq bd lp lq lr dn ls lt lu dp lv kj lw lx ly kn lz ma mb kr mc md me mf bi translated">下一步是什么</h2><p id="f2b0" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">机器人变得越来越聪明。现在它可以用不同的方式响应一些基本的命令。更多的来了。我希望机器人能够绘制图表，并显示一些统计数据，如多长时间发生的事情或分布在一天/一周/一个月。你有什么想法吗？</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/b97e1ad0200b70a38ebcaf51c48efb9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3j81JbNd3Iiz9Ir1.png"/></div></div></figure><p id="a32c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你好奇，可以在GitHub 上找到代码<a class="ae kw" href="https://github.com/detunized/since-bot/tree/day-5" rel="noopener ugc nofollow" target="_blank">。这个版本被标记为<code class="fe kx ky kz la b">day-5</code>。</a></p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="7fc9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mo">原载于</em><a class="ae kw" href="https://detunized.net/posts/2019-04-09-telegram-bot-in-go-speak-robot/" rel="noopener ugc nofollow" target="_blank"><em class="mo">detunized.net</em></a><em class="mo">2019年4月9日</em></p></div></div>    
</body>
</html>