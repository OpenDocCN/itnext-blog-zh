<html>
<head>
<title>Building on the simple MVVM implementation in client side Blazor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在客户端Blazor中构建简单的MVVM实现</h1>
<blockquote>原文：<a href="https://itnext.io/building-on-the-simple-mvvm-implemention-in-client-side-blazor-c2e75c703fae?source=collection_archive---------4-----------------------#2019-04-07">https://itnext.io/building-on-the-simple-mvvm-implemention-in-client-side-blazor-c2e75c703fae?source=collection_archive---------4-----------------------#2019-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="d7bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是关于在客户端Blazor中实现模型-视图-视图模型系列的第二篇文章。在位于此处的第一篇文章中，我们采用了默认的hosted Blazor应用程序模板，并使用具有独立视图、视图模型和模型的MVVM重新实现了FetchData页面:</p><div class="ko kp gp gr kq kr"><a href="https://medium.com/@haywireiv/a-simple-mvvm-implementation-in-client-side-blazor-8c875c365435" rel="noopener follow" target="_blank"><div class="ks ab fo"><div class="kt ab ku cl cj kv"><h2 class="bd iu gy z fp kw fr fs kx fu fw is bi translated">客户端Blazor中一个简单的MVVM实现。</h2><div class="ky l"><h3 class="bd b gy z fp kw fr fs kx fu fw dk translated">如前所述，我正致力于将我的生产Silverlight应用程序迁移到一个新的平台上。我的…</h3></div><div class="kz l"><p class="bd b dl z fp kw fr fs kx fu fw dk translated">medium.com</p></div></div><div class="la l"><div class="lb l lc ld le la lf lg kr"/></div></div></a></div><p id="a387" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将向我们构建的示例客户端添加一些额外的功能。目标是展示一些与构建标准业务线应用程序时可能遇到的情况类似的场景。该项目的代码位于GitHub的这个存储库中:</p><div class="ko kp gp gr kq kr"><a href="https://github.com/lchendricks/BlazorMVVM" rel="noopener  ugc nofollow" target="_blank"><div class="ks ab fo"><div class="kt ab ku cl cj kv"><h2 class="bd iu gy z fp kw fr fs kx fu fw is bi translated">lchendrick s/blazormvm</h2><div class="ky l"><h3 class="bd b gy z fp kw fr fs kx fu fw dk translated">一个客户端Blazor MVVM实现。通过在…上创建帐户，为lchendricks/BlazorMVVM的开发做出贡献</h3></div><div class="kz l"><p class="bd b dl z fp kw fr fs kx fu fw dk translated">github.com</p></div></div><div class="la l"><div class="lh l lc ld le la lf lg kr"/></div></div></a></div><p id="9324" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文的起点是前一篇文章的结尾，代码可以在ArticleOne分支或4.1版本中找到。本文的终点将是ArticleTwo分支和4.2版本。</p><h1 id="0388" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用ViewModel自定义数据视图</h1><p id="490f" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">在第一篇文章中，FetchDataModel中的“RetrieveForecastsAsync()”方法调用了Web API，并直接将WeatherForecast[]返回给ViewModel。这不是一个合适的模型实现，而是在将示例应用程序放在一起时为了简单起见而做的。我们的模型应该包含我们的对象和相关的逻辑，而视图模型应该只包含在视图中显示数据所需的内容。我们将更新我们的模型来保存我们的WeatherForecast[]，然后在我们的应用程序中实现一个“来自业务的新需求”。</p><p id="307a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的假想场景中，我们的企业找到了一个新的基于云的提供商，该提供商将以当前提供商一半的成本为我们提供预测数据。唯一的问题是他们只提供摄氏温度的数据，而不是华氏温度。营销部门意识到我们可以使用提供的数据自己计算这个数字，但他们也认为同时向用户提供这两个数字是压倒性的，会使他们在使用应用程序时感到困惑。已经决定，应用程序现在必须只显示一个温标，并提供一个来回切换的选项。默认情况下，应用程序加载时显示华氏温度，因为焦点研究小组发现摄氏温度太令人困惑。</p><p id="e161" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了模拟服务提供者的变化，我们将实现一个IWeatherForecast接口，但不包括TemperatureF属性。我们的天气预报类现在看起来像这样:</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="63af" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">更新模型</h1><p id="f924" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">我们希望在模型中正确存储检索到的数据。为此，我们将添加一个私有成员变量和一个公共方法，以允许ViewModel访问我们的预测。在这个方法中，我们将setter设为私有，因为ViewModel不允许修改模型中的数据。这是我们添加的代码:</p><pre class="ml mm mn mo gt ms mt mu mv aw mw bi"><span id="e8d2" class="mx lj it mt b gy my mz l na nb">private IWeatherForecast[] _weatherForecasts;<br/>public IWeatherForecast[] WeatherForecasts { get =&gt; _weatherForecasts; private set =&gt; _weatherForecasts = value; }</span></pre><p id="f6b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们不想再返回WeatherForecast[]数组；ViewModel现在将访问模型的公共属性。我们必须将Web API调用的结果存储在模型中，因此我们更改了RetrieveForecastsAsync()上的签名和代码，因此它现在如下所示:</p><pre class="ml mm mn mo gt ms mt mu mv aw mw bi"><span id="c923" class="mx lj it mt b gy my mz l na nb">public async Task RetrieveForecastsAsync()<br/>{<br/>  _weatherForecasts = await _http.GetJsonAsync&lt;WeatherForecast[]&gt;<br/>    ("api/SampleData/WeatherForecasts");<br/>}</span></pre><p id="8dfa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这还需要更改我们的IFetchDataModel，以便通过更新现有方法和添加所需的天气预报公共属性来匹配新代码。我们的模型现在看起来像这样:</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="1213" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">更新视图模型</h1><p id="e6fe" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">我们现在必须打开视图模型并重写“RetrieveForecastsAsync()”方法。首先，我们删除不再使用的局部私有变量的赋值，然后添加代码，从模型中的公共属性填充变量。在许多真实世界的场景中，我们会使用完全不同的类来保存我们呈现给视图的数据，但是在这个简单的例子中，我们将坚持使用WeatherForecast类。然后，我们遍历并更改WeatherForecast的所有引用，使其成为IWeatherForeCast的引用。FetchDataViewModel-的新代码如下:</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="9f04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">构建更新项目的最后一步是现在进入FetchDataView并删除Temp的<th>行。(F)删除@ forecast.TemperatureF的</th><td>行。我们已经实现了我们的“新服务提供商”,但经过这么多努力，我们现在拥有了看起来与我们已经拥有的相同的应用程序，但显示的信息更少。</td></p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/23e7189155a83d0fb1465a21ac7eb6a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jEXSEe4A8eiLrLNafu-seQ.png"/></div></div></figure><h1 id="ee5d" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">添加新功能</h1><p id="a85d" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">现在我们的应用程序又可以工作了，让我们把新的需求放在适当的位置。让我们从默认显示华氏温度开始。因为我们已经知道我们将来回交换，所以我们可以在视图模型中添加一个新的私有布尔变量。</p><pre class="ml mm mn mo gt ms mt mu mv aw mw bi"><span id="bd81" class="mx lj it mt b gy my mz l na nb">private bool _displayFahrenheit;</span></pre><p id="8779" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将在构造函数中将该值设置为true</p><pre class="ml mm mn mo gt ms mt mu mv aw mw bi"><span id="f5ba" class="mx lj it mt b gy my mz l na nb">_displayFahrenheit = true;</span></pre><p id="ef2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后将下面的公共属性和方法添加到我们的视图模型中。然后我们可以使用Ctrl +。快速操作将它们拉至IFetchDataViewModel。</p><pre class="ml mm mn mo gt ms mt mu mv aw mw bi"><span id="a30b" class="mx lj it mt b gy my mz l na nb">public string DisplayTemperatureScaleShort<br/>{<br/>   get<br/>   {<br/>      return _displayFahrenheit ? "F" : "C";<br/>   }<br/>}</span><span id="870d" class="mx lj it mt b gy ni mz l na nb">public int DisplayTemperature(int temperature)<br/>{<br/>   return _displayFahrenheit ? 32 + (int)(temperature / 0.5556) :<br/>     temperature;<br/>}</span></pre><p id="723f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在将使用公共可用的属性来更新视图中的表头</p><pre class="ml mm mn mo gt ms mt mu mv aw mw bi"><span id="5809" class="mx lj it mt b gy my mz l na nb">&lt;th&gt;Temp. (@fetchDataViewModel.DisplayTemperatureScaleShort)&lt;/th&gt;</span></pre><p id="1cbf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并使用新方法更新表体中的温度显示。</p><pre class="ml mm mn mo gt ms mt mu mv aw mw bi"><span id="150e" class="mx lj it mt b gy my mz l na nb">&lt;td&gt;@fetchDataViewModel.DisplayTemperature(@forecast.TemperatureC)&lt;/td&gt;</span></pre><p id="8f24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们再次启动我们的应用程序，气温现在以华氏温度显示，即使服务返回摄氏温度。我们已经使用我们的视图模型为我们的视图提供了由模型提供的数据的修改版本，而没有改变原始数据。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nj"><img src="../Images/adb739f8198165f7222420d3af9fb1c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4wg5ripoMk4z4g0IOMuvwQ.png"/></div></div></figure><p id="7438" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们收到的最后一个要求是允许用户将显示的温度从华氏温度切换到摄氏温度。我们将保持简单，只需在页面上直接添加一个按钮，让他们进行切换。为了支持这一点，我们将向ViewModel添加另一个属性和另一个方法。我们将添加的属性只是为了显示温标的全名</p><pre class="ml mm mn mo gt ms mt mu mv aw mw bi"><span id="7c22" class="mx lj it mt b gy my mz l na nb">public string DisplayOtherTemperatureScaleLong<br/>{<br/>   get<br/>   {<br/>      return !_displayFahrenheit ? "Fahrenheit" : "Celsius";<br/>   }<br/>}</span></pre><p id="3ea4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个方法只是切换我们之前创建的布尔值。</p><pre class="ml mm mn mo gt ms mt mu mv aw mw bi"><span id="3517" class="mx lj it mt b gy my mz l na nb">public void ToggleTemperatureScale()<br/>{<br/>   _displayFahrenheit = !_displayFahrenheit;<br/>}</span></pre><p id="78bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦我们把所有东西都放到接口上，FetchDataViewModel现在看起来就像这样:</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="6e2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们可以进入视图并添加一个按钮，允许我们切换温标并将其放在页面顶部附近。</p><pre class="ml mm mn mo gt ms mt mu mv aw mw bi"><span id="58f3" class="mx lj it mt b gy my mz l na nb">&lt;button class="btn btn-primary" onclick=@fetchDataViewModel.ToggleTemperatureScale&gt;Display @fetchDataViewModel.DisplayOtherTemperatureScaleLong&lt;/button&gt;</span></pre><p id="fce5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦完成，我们就可以启动我们的应用程序，并使用我们的新按钮切换温度显示。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nk"><img src="../Images/9cb1a60b845ece788adce36ce0e8717e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*klr35flg5bCR4pG8AGM5kA.gif"/></div></div></figure><h1 id="1c00" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">今天到此为止</h1><p id="f81f" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">就是这样！我们已经解决了原始实现的一个小缺点，并更改了我们的模型，以接受来自类似但略有不同的服务的数据。随后，我们更新了我们的视图模型和视图，以实现我们收到的新业务需求。我希望有助于展示在客户端Blazor上实现MVVM的这种方式的灵活性。目前，我将继续构建这个演示。在下一篇文章中，我计划使用两个模型来实现我们下一个新的应用程序特性。</p><p id="83cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更新:本系列的第三篇文章现已发表。点击下面的链接阅读。</p><div class="ko kp gp gr kq kr"><a rel="noopener  ugc nofollow" target="_blank" href="/adding-features-to-a-simple-blazor-mvvm-client-with-composition-f31bfb01e20a"><div class="ks ab fo"><div class="kt ab ku cl cj kv"><h2 class="bd iu gy z fp kw fr fs kx fu fw is bi translated">用composition为一个简单的Blazor MVVM客户端添加特性</h2><div class="ky l"><h3 class="bd b gy z fp kw fr fs kx fu fw dk translated">这是详细介绍在客户端Blazor中实现MVVM模式的一种方法的系列文章的第三篇。如果你…</h3></div><div class="kz l"><p class="bd b dl z fp kw fr fs kx fu fw dk translated">itnext.io</p></div></div><div class="la l"><div class="nl l lc ld le la lf lg kr"/></div></div></a></div></div></div>    
</body>
</html>