<html>
<head>
<title>NGRX — from the beginning, part I, Pub-Sub</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NGRX —从头开始，第一部分，发布订阅</h1>
<blockquote>原文：<a href="https://itnext.io/ngrx-from-the-beginning-part-i-a76c3c690ac7?source=collection_archive---------6-----------------------#2019-04-02">https://itnext.io/ngrx-from-the-beginning-part-i-a76c3c690ac7?source=collection_archive---------6-----------------------#2019-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/53f41d5637be6ca5fb733e3a7486c45b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uc_QP4YNtAY7BjrY.jpg"/></div></div></figure><p id="8dee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae kw" href="https://twitter.com/chris_noring" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，很乐意接受您对主题或改进的建议/Chris</p><blockquote class="kx ky kz"><p id="0098" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><em class="iq"> NGRX是Redux模式的一个实现。Redux模式本身是一种发布/订阅模式，也称为发布-订阅模式。本质上，这种模式是关于一个关键的事情，当一个变化发生时，它可能是你的应用程序的一个或多个部分的关注点，你需要一种方法来传达这种变化。您还需要一种方法来做到这一点，而无需耦合您的代码</em></p></blockquote><p id="ef2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，那么，让我们从头开始，学习Pub Sub，Redux，我们需要的类型脚本和一些基本的RxJS，不要再混淆了，好吗？</p><p id="c20e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文是系列文章的一部分:</p><ul class=""><li id="ac1e" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">NGRX —从开始，第一部分，发布-订阅，<strong class="ka ir">我们在这里</strong></li><li id="a250" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae kw" href="https://medium.com/@noringc/ngrx-from-the-beginning-part-ii-redux-6305b481c55" rel="noopener"> NGRX —从头开始，第二部分，Redux，核心概念，和不同的实现，Redux </a></li><li id="51d9" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/ngrx-from-the-beginning-part-iii-ngrx-store-d094ac72e1fa"> NGRX —从头开始，第三部，NGRX store </a>，</li><li id="1696" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">NGRX-从头开始，第四部分，存储最佳实践</li><li id="28dd" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">NGRX —从头开始，第五部分，NGRX效果，<em class="la">进行中</em></li><li id="63b0" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">NGRX —从头开始，第六部分，NGRX实体，<em class="la">进行中</em></li></ul><p id="f10f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文涵盖以下内容:</p><ul class=""><li id="bb10" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated"><strong class="ka ir">发布-订阅</strong>，它是什么以及我们为什么需要它</li><li id="5ba6" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir">使用消息进行通信</strong>，发布-订阅模式的实现，以及我们如何将其应用于我们正在使用的任何基于组件的库/框架。</li></ul><p id="247c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们在开始时所说，NGRX是Redux的一个实现，我们真正添加到应用程序中的是发布-订阅功能，当系统发生变化时，它会广播一条消息。好吧，那什么时候发生？想象一下，你已经把你的应用程序设置成某种语言，然后你改变了那种语言，会发生什么呢？嗯，很有可能某个特定的语言集意味着你的应用程序已经将部分或全部应用程序翻译成了那个选定的语言。因此，当引入一种语言时，需要进行一些翻译，问题是应用程序的哪个部分受到了影响？你可能比我更清楚这一点，但让我们尝试引入一些推理。您的应用程序可能会被分成几个组件，以便于维护。如果你的应用由许多页面组成，每个页面有一个组件，你不需要发布订阅。</p><blockquote class="kx ky kz"><p id="d4ca" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><em class="iq">嗯？</em></p></blockquote><p id="abb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你有一个简单的应用程序，比如说有5个页面，每个页面有一个组件，那么当你改变到一种新的语言时，你只需要影响你所站的页面。此时，您可能会调用一个服务，用伪代码请求这些新的翻译，如下所示:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="c49c" class="mb mc iq lx b gy md me l mf mg">function onLanguageChange(newLang) {<br/>  service.getTranslationsByLang(newLang); <br/>}</span></pre><p id="e339" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在你需要想出一种方法，把这些新的翻译应用到你的网站上，就像这样:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="741c" class="mb mc iq lx b gy md me l mf mg">function onLanguageChange(newLang) { <br/>  const translations = service.getTranslationsByLang(newLang);<br/>  this.title = translations.title; <br/>  this.description = translations.description <br/>}</span></pre><p id="ca9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后当你从这个页面切换到另一个页面时，你需要做一些类似上面的事情，但是要尽可能早，在构造函数或者<code class="fe mh mi mj lx b">ngOnInit</code>中，像这样:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="e6c9" class="mb mc iq lx b gy md me l mf mg">constructor(){ <br/>  const translations = service.getTranslationsByLang(newLang);<br/>  this.title = translations.title; <br/>  this.description = translations.description; <br/>}</span></pre><blockquote class="kx ky kz"><p id="eb14" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><em class="iq">那么我什么时候需要发布/订阅呢？</em></p></blockquote><p id="9606" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦你在一个页面上有了很多组件，你做了一个<em class="la">应用程序范围的</em>改变，比如一个语言的改变，你需要告诉所有那些组件你需要关心的改变已经发生了。现在，如果你正在使用Angular，你可以使用它们的<code class="fe mh mi mj lx b">@Input</code>绑定在那些组件上设置一个属性，但是这很快就变得非常混乱，让我展示给你看:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="197f" class="mb mc iq lx b gy md me l mf mg">class Component { <br/>  private _lang = ''; </span><span id="37b8" class="mb mc iq lx b gy mk me l mf mg">  @Input('language') <br/>  set lang(value) { <br/>    this._lang = value; <br/>    const translations = service.getTranslationsByLang(newLang);<br/>    this.title = translations.title; <br/>    this.description = translations.description; <br/>  }; <br/>  get language() { <br/>    return this._lang; <br/>  } <br/>}</span></pre><p id="a3d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感觉有点耦合吧，有很多东西要写？</p><h1 id="58fd" class="ml mc iq bd mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh bi translated">用信息交流</h1><p id="35da" class="pw-post-body-paragraph jy jz iq ka b kb ni kd ke kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv ij bi translated">在这一点上，伤害是真实的，因为你很可能为10个不同的组件编写了上面的代码。你可能想出了一个好办法来省略对<code class="fe mh mi mj lx b">service.getTranslationsByLang</code>的呼叫，只在一个中心位置这样做，然后我们只发送翻译。</p><p id="397e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">伤害是由什么组成的？啊，现在我们问了正确的问题，伤害不是因为我们需要写3-4行代码并给组件上的每个属性分配正确的翻译——伤害是因为我们使用属性在X个组件上设置语言。这种交流信息的方式非常复杂，并且非常依赖于我们使用的特定框架。</p><blockquote class="kx ky kz"><p id="93b8" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">好的，那么有什么更好的方法呢？</p></blockquote><p id="028a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更好的方法是用消息交流。用消息交流意味着我们有一个发送者和一个或多个收听者。有很多方法可以做到这一点。以下是一个不完整的列表:</p><ul class=""><li id="0458" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">使用普通实现</li><li id="0c9b" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">使用库EventEmitter</li><li id="50e2" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">使用RxJS</li></ul><p id="aeae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们不要让这篇文章太长，但让我们实现第一种情况，一个普通的实现。</p><h1 id="040e" class="ml mc iq bd mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh bi translated">一个普通的实现</h1><p id="fb9d" class="pw-post-body-paragraph jy jz iq ka b kb ni kd ke kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv ij bi translated">在不使用库的实现中，我们需要满足以下条件:</p><ul class=""><li id="dec5" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">我们需要一种传递信息的方式</li><li id="6bdf" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">一种订阅、退订消息的方式</li></ul><p id="05a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，让我们来看看一个简单的实现:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="310c" class="mb mc iq lx b gy md me l mf mg">class PubSub { <br/>  constructor() { <br/>    this.listeners = []; <br/>  } <br/>  <br/>  send(messageType, message) { <br/>    this.listeners.forEach(l =&gt; l(messageType, message)); <br/>  } </span><span id="8923" class="mb mc iq lx b gy mk me l mf mg">  subscribe(listener) { <br/>    this.listeners.push(listener); <br/>  } </span><span id="773b" class="mb mc iq lx b gy mk me l mf mg">  unsubscribe(list) { <br/>    this.listeners = this.listeners.filter( l =&gt; l !== list); <br/>  } <br/>} </span><span id="2504" class="mb mc iq lx b gy mk me l mf mg">module.exports = PubSub;</span></pre><p id="f2b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们上面的实现支持使用<code class="fe mh mi mj lx b">send()</code>方法发送消息，而<code class="fe mh mi mj lx b">subscribe()</code>和<code class="fe mh mi mj lx b">unsubscribe()</code>方法为我们提供了添加/移除监听器的方法。这就是我们要做的所有事情。</p><p id="69b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来看看这个，它看起来像这样:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="a821" class="mb mc iq lx b gy md me l mf mg">const PubSub = require('./pubsub'); <br/>const ps = new PubSub(); </span><span id="a966" class="mb mc iq lx b gy mk me l mf mg">const l1 = (type, message) =&gt; { <br/>  console.log('sub1'); <br/>  console.log(`Type: ${type}, Message: ${message} `); <br/>}; </span><span id="79b2" class="mb mc iq lx b gy mk me l mf mg">const l2 = (type, message) =&gt; { <br/>  console.log('sub2'); <br/>  console.log(`Type: ${type}, Message: ${message} `); <br/>} </span><span id="a5e2" class="mb mc iq lx b gy mk me l mf mg">ps.subscribe(l1); <br/>ps.subscribe(l2) </span><span id="5669" class="mb mc iq lx b gy mk me l mf mg">ps.send('INCREMENT', 1); <br/>ps.send('language', 'en'); </span><span id="de26" class="mb mc iq lx b gy mk me l mf mg">// l1 is no longer listening<br/>ps.unsubscribe(l1); </span><span id="0ba4" class="mb mc iq lx b gy mk me l mf mg">ps.send('spam', 'hello');</span></pre><p id="3b86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从上面我们可以看到，我们定义了两个监听器<code class="fe mh mi mj lx b">l1</code>和<code class="fe mh mi mj lx b">l2</code>。两个听众都订阅了我们的<code class="fe mh mi mj lx b">PubSub</code>类。然后我们看到<code class="fe mh mi mj lx b">l1</code>通过调用<code class="fe mh mi mj lx b">unsubscribe()</code>停止监听。运行该程序，我们得到以下输出:</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/f1a40af2f0177efde96b28d2c4ee6542.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/0*BI1yIXIURb-ZpJFw.png"/></div></figure><p id="00e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出显示了我们的两个监听器是如何得到消息<code class="fe mh mi mj lx b">INCREMENT</code>和<code class="fe mh mi mj lx b">language</code>的，而只有<code class="fe mh mi mj lx b">l2</code>得到消息<code class="fe mh mi mj lx b">spam</code>，因为<code class="fe mh mi mj lx b">l1</code>在消息发生之前就已经退订了。</p><p id="0bf0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，我们的<code class="fe mh mi mj lx b">PubSub</code>班好像还行。那么这一切有什么意义呢？这个想法是为了展示两件事:</p><ol class=""><li id="a526" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv no lk ll lm bi translated">用消息通信</li><li id="8693" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv no lk ll lm bi translated">以一种松散耦合的方式交流，即我们不依赖Angular、Vue、React或我们使用的任何库的实现细节。</li></ol><p id="b43b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将此应用到我们的组件中，在我们更改语言的地方，我们将得到以下代码:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="83e6" class="mb mc iq lx b gy md me l mf mg">class PubSub { <br/>  constructor() { <br/>    this.listeners = []; <br/>  } </span><span id="1e0b" class="mb mc iq lx b gy mk me l mf mg">  send(messageType, message) { <br/>    this.listeners.forEach(l =&gt; l(messageType, message)); <br/>  } </span><span id="6f84" class="mb mc iq lx b gy mk me l mf mg">  subscribe(listener) { <br/>    this.listeners.push(listener); <br/>  } </span><span id="aeed" class="mb mc iq lx b gy mk me l mf mg">  unsubscribe(list) { <br/>    this.listeners = this.listeners.filter( l =&gt; l !== list); <br/>  } <br/>} </span><span id="425a" class="mb mc iq lx b gy mk me l mf mg">const pubSub = new PubSub(); module.exports = pubsub;</span></pre><p id="7e1b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面我们通过创建一个<code class="fe mh mi mj lx b">PubSub</code>的实例对我们的<code class="fe mh mi mj lx b">PubSub</code>类做了一点小小的改变，我们正在导出的就是这个实例。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="8adb" class="mb mc iq lx b gy md me l mf mg">import PubSub = require('pubsub'); </span><span id="b962" class="mb mc iq lx b gy mk me l mf mg">class Component {   <br/>  constructor() { } <br/>  setLanguage() { <br/>    pubsub.send('changeLanguage', 'en'); <br/>  } <br/>}</span></pre><p id="510b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的发送组件只是导入我们的<code class="fe mh mi mj lx b">PubSub</code>实例，并通过调用方法<code class="fe mh mi mj lx b">send()</code>发送消息。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="df59" class="mb mc iq lx b gy md me l mf mg">import PubSub = require('pubsub'); </span><span id="73d3" class="mb mc iq lx b gy mk me l mf mg">class OtherComponent { <br/>  constructor() {  <br/>    pubsub.subscribe(this.onMessage).bind(this); <br/>  } </span><span id="aa0f" class="mb mc iq lx b gy mk me l mf mg">  onMessage(type, message) { <br/>    if (type === 'changeLanguage') { <br/>      const translations = service.getTranslationsByLang(message);<br/>      this.title = translations.title; <br/>    } <br/>  } <br/>}</span></pre><p id="9383" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">监听组件正在使用同一个<code class="fe mh mi mj lx b">PubSub</code>实例，并在构造函数中将它的<code class="fe mh mi mj lx b">onMessage()</code>方法设置为监听器。当消息被发送时，同样的<code class="fe mh mi mj lx b">onMessage()</code>方法被调用。同样值得注意的是，在我们继续从翻译服务获取新的翻译之前，我们如何检查发送的消息是否属于类型<code class="fe mh mi mj lx b">changeLanguage</code>。</p><h1 id="7c33" class="ml mc iq bd mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh bi translated">摘要</h1><p id="2206" class="pw-post-body-paragraph jy jz iq ka b kb ni kd ke kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv ij bi translated">这篇文章旨在讨论NGRX和Redux的底层模式，即发布-订阅。向一个或多个听众发送消息的能力。我们讨论了何时需要它，甚至构建了一个非常简单的实现，一个名为<code class="fe mh mi mj lx b">PubSub</code>的类，并展示了如何在我们的组件中使用它。</p><p id="fc86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下一部分中，我们将特别关注模式Redux，它是一个更专门化的发布订阅版本，本质上是相同的模式，但是具有对当前状态的记忆，并且以更谨慎的方式改变状态。</p></div></div>    
</body>
</html>