<html>
<head>
<title>Build powerful frameworkless web components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建强大的无框架web组件</h1>
<blockquote>原文：<a href="https://itnext.io/build-powerful-frameworkless-web-components-482bab0706b1?source=collection_archive---------2-----------------------#2020-04-02">https://itnext.io/build-powerful-frameworkless-web-components-482bab0706b1?source=collection_archive---------2-----------------------#2020-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c033a11b1aed1d4d4de9eb8e65f7081b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NJbPHGltA3JatW_HdYlLtg.jpeg"/></div></div></figure><h1 id="a473" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">简介—为什么选择Web组件和Stencil.js</h1><p id="21c3" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如今前端框架和库的激增导致许多公司寻找与框架无关的(经得起未来考验的)方法来创建他们的UI构建块。输入Web组件。Web组件是一组<strong class="ky ir">本地</strong>浏览器API，允许我们创建看起来像自定义html标签的东西(例如我们在一个附加的js文件中构建的功能。它们的强大之处在于它们是可重用的、封装的，并且浏览器无需外部库或框架的帮助就能呈现它们。</p><p id="14b7" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">您可以只使用普通的HTML和JavaScript创建定制的Web组件，或者您可以像酷孩子一样使用Stencil.js之类的东西将漂亮的现代js/tsx代码编译成Web组件。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="7d2f" class="jy jz iq bd ka kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv bi translated">本文的目标是</h1><p id="7d44" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我将向您介绍使用模板开发功能性<strong class="ky ir">导航栏</strong>组件的思想过程和代码。我们的目标是，到本文结束时，你将能够理解<a class="ae mp" href="https://codesandbox.io/s/alx-menu-9z9ep" rel="noopener ugc nofollow" target="_blank"> CodeSandbox演示</a>中的大部分代码，并且你也将开始体会到Web组件是多么强大，它们是多么容易构建。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="156a" class="jy jz iq bd ka kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv bi translated">我们的导航栏组件</h1><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/132415dca9b8be23258e1c3f0497aa6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RRfwX5k0yV_76fU7uSbRag.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">我们的导航栏自定义web组件</figcaption></figure><p id="0c17" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">上图显示的是成品。一些要求包括:</p><ul class=""><li id="79f1" class="mz na iq ky b kz ly ld lz lh nb ll nc lp nd lt ne nf ng nh bi translated">需要支持无限深度的嵌套。</li><li id="487d" class="mz na iq ky b kz ni ld nj lh nk ll nl lp nm lt ne nf ng nh bi translated">需要内置基本的可访问性支持。</li><li id="fee8" class="mz na iq ky b kz ni ld nj lh nk ll nl lp nm lt ne nf ng nh bi translated">需要有主题。</li><li id="fd87" class="mz na iq ky b kz ni ld nj lh nk ll nl lp nm lt ne nf ng nh bi translated">标记应该直观简单。</li><li id="d374" class="mz na iq ky b kz ni ld nj lh nk ll nl lp nm lt ne nf ng nh bi translated">需要在Edge和IE11中完美运行</li></ul></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="2b92" class="jy jz iq bd ka kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv bi translated"><strong class="ak">加价</strong></h1><p id="b52b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当构建Web组件时，我喜欢从测试标记中的不同想法开始；我认为这奠定了一个良好的基础。我为navbar提出的第一个概念是实际使用两个定制组件(名为alx-nav和alx-nav-item ),它们将模拟创建菜单的常见<ul> <li>方法:</li></ul></p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/f821f1636f6108831d93620d217526f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*mKgxjUZrvPOebZ3HJ2gSeA.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">第一个想法——模仿一个<ul> <li>结构</li></ul></figcaption></figure><p id="e9d2" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">这是可行的，并且会产生一个非常精细的可定制菜单，但是看起来有点过分了。我可以在整个菜单中只使用一个自定义组件吗？果然:</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/80d8b1ea07094edda7bbd14b7b5ed073.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*oDZhZT3QgnJsV8GCTCMIHw.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">第二个想法——整个导航条只有一个组件</figcaption></figure><p id="2297" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">这个漂亮的标记足以让整个导航条呈现出我们设计中的样子。我们在这里只使用了一个组件，<strong class="ky ir">AlxNavItem</strong>(html标签为&lt; alx-nav-item &gt;)，它采用了一个定义其链接的href的<code class="fe lu lv lw lx b">url</code>属性。如果它是一个父元素，它的内容区域可以有多个alx-nav-items(在它的开始和结束标签之间)。</p><p id="8fbf" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">请记住，上述标记可以在没有任何框架或库的静态html页面中工作。浏览器只是将<alx-nav-item>识别为一个Web组件，并运行我们的幕后代码来渲染，使它按照我们想要的方式工作。</alx-nav-item></p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="e7ac" class="jy jz iq bd ka kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv bi translated">代码概述</h1><p id="bb2b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">的。tsx文件是所有奇迹发生的地方。Stencil使用TypeScript，然后将文件转换为JavaScript。如果您不熟悉，TypeScript只是带有一些语法糖的JavaScript主要是为了支持静态类型。我喜欢TypeScript，但它可能非常冗长，所以我决定不使用它的大部分甜言蜜语。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/247eb079593c9bb18927b4de924dc69d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*KH7ige3BJaaOzktz5tI5qg.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">我们组件的顶部</figcaption></figure><p id="eeae" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">从代码的顶部开始，我们导入了将要使用的模板核心类——没有什么特别的。然而，在我们继续之前，你需要了解一下<strong class="ky ir">装饰者</strong>。Stencil几乎在任何地方都使用一个名为decorators <strong class="ky ir"> </strong>的类型脚本特性。本质上，它们只是以@符号开始的关键字，为编译器提供关于组件、属性、事件等的元数据。它们所依附的东西。我们在上面的代码(第13行)中看到了一个，就在我们进入组件类之前。这里，<code class="fe lu lv lw lx b">@Component</code> decorator告诉编译器我们的组件的定制html标记名应该是什么，以及使用什么样的样式表。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/8f695cb31ee16ab5a9f8e8da2c6f956c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*kfrEZcT_bEOGNGz3ihgFww.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">公共属性/标签属性</figcaption></figure><p id="777a" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">我们转到组件类的内部，从设置一些属性开始。<code class="fe lu lv lw lx b">@Element</code>装饰器将组件本身作为DOM元素返回，并将其分配给<code class="fe lu lv lw lx b">el</code>。之后，我们用@Prop decorator定义了一些公共属性。这些属性可以通过我们的html标签的属性(例如<code class="fe lu lv lw lx b">&lt;alx-nav-item <strong class="ky ir">label=”About us”</strong>&gt;</code>)</p><p id="8d1e" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">每当<code class="fe lu lv lw lx b">ariaExpanded</code>属性被更新时，<code class="fe lu lv lw lx b">@Watch</code>装饰器(第33行)将触发它下面的方法，该方法依次迭代这个组件的每个子组件，并将它们的<code class="fe lu lv lw lx b">parentExpanded</code>属性设置为true。稍后将使用它来为可访问性正确设置<code class="fe lu lv lw lx b">tabIndex</code>。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/9d8a065469c042e6233038ab77fbd3eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*WMaEA7msTFbmR52Gc13dcQ.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">处理和调度事件</figcaption></figure><p id="b20f" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">接下来我们要处理事件。当一个<alx-nav-item>被切换时(通过点击它或者按回车键),我们想要调度一个名为<code class="fe lu lv lw lx b">menuItemToggled()</code>的自定义DOM事件，它可以被使用我们组件的人监听。装饰者为我们设置了这个(第40行)</alx-nav-item></p><p id="613a" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">第48行的监听器通过检查组件实例是否有子实例来处理组件上的click事件，然后简单地切换<code class="fe lu lv lw lx b">ariaExpanded</code>属性的值。记住，这将引起连锁反应，触发上面的<code class="fe lu lv lw lx b">@Watch(‘ariaExpanded’)</code>监视器，然后调度<code class="fe lu lv lw lx b">menuItemToggled</code>事件(第39行)。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/78f938ece256f822292ac9d5dcfb5f20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8uv-HjpHu0cJUhh6veA8PQ.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">挂钩到生命周期方法</figcaption></figure><p id="de8a" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">现在我们来看组件的核心——它的生命周期方法。这些是一系列被自动调用的方法，从一个组件的诞生到它的死亡。上面我们使用了<code class="fe lu lv lw lx b">componentWillRender()</code>方法(它在每个<code class="fe lu lv lw lx b">render()</code>之前被调用)来计算当前&lt; alx-nav-item &gt;在菜单树中的深度。我们通过不断地沿着树向上移动直到到达最外层的父节点来完成这个任务。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/5e858df69b36f34b594aa67d278e37df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WGJKTlqYYpGN7eBGZUHmJw.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">render()生命周期方法</figcaption></figure><p id="b6b0" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated"><code class="fe lu lv lw lx b">render()</code>方法可以被认为是<strong class="ky ir">主</strong>生命周期方法，我们用它在幕后返回组成&lt; alx-nav-item &gt;的元素(在JSX)。如果你不熟悉JSX <a class="ae mp" href="https://stenciljs.com/docs/templating-jsx" rel="noopener ugc nofollow" target="_blank">，看看这里</a>。需要注意的一件重要事情是，每当@Prop或@State变量发生变化时,<code class="fe lu lv lw lx b">render()</code>就会运行。</p><p id="5dfb" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">在我们的<code class="fe lu lv lw lx b">render()</code>方法的顶部，我们设置了这个特定的&lt; alx-nav-item &gt;实例的左缩进，这取决于它在导航树中的当前深度。然后，我们输出一个&lt;和一个&gt;标签，其中充满了与可访问性相关的属性，并组成了组件的实际可点击链接。如果存在子元素，我们还会呈现一个包含子元素&lt; alx-nav-item &gt;的div(第104行)。</p><p id="f6c8" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">一些澄清:</p><ul class=""><li id="adda" class="mz na iq ky b kz ly ld lz lh nb ll nc lp nd lt ne nf ng nh bi translated">特殊的<host>标签(第89行)指的是组件实例的html标签本身(<alx-nav-item>标签)。</alx-nav-item></host></li><li id="eb99" class="mz na iq ky b kz ni ld nj lh nk ll nl lp nm lt ne nf ng nh bi translated">对于<a>元素的onClick事件(第98行),我们通过一个箭头函数传递handleClick()处理程序。我们这样做是因为如果我们直接传递handleClick，那么handleClick()中的“this”关键字将引用被单击的</a><a>元素，而不是我们的AlxNavItem实例(您也可以使用bind()来获得相同的结果)</a></li><li id="6849" class="mz na iq ky b kz ni ld nj lh nk ll nl lp nm lt ne nf ng nh bi translated">一个很酷的小技巧是用逻辑&amp; &amp;操作符内嵌<strong class="ky ir"> if </strong>(第104行)。在JavaScript中，<strong class="ky ir"> true &amp; &amp;表达式</strong>总是计算为<strong class="ky ir">表达式</strong>，所以我们在这里用这个来表示如果组件有子组件，渲染它们。</li><li id="dfb7" class="mz na iq ky b kz ni ld nj lh nk ll nl lp nm lt ne nf ng nh bi translated">浏览器会将自定义元素的内容(开始和结束标记之间的所有内容)放在特殊的<slot>元素(第105行)中。如果要在不同的位置输出内容，也可以使用命名槽。</slot></li></ul></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="1963" class="jy jz iq bd ka kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv bi translated">设计它</h1><p id="c9ec" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们在这个项目中使用了SCSS，这意味着安装@stencil/sass依赖项，并确保将它添加到我们的stencil.config.ts中:</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/efb1fbb1ea0046dda6676bc129f0026a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*LUXOpXORD9XlzDmkDAcQBg.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">在模具中使用Sass/Scss</figcaption></figure><p id="d5b1" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">请记住，我们的组件使用的是影子DOM(我们在类顶部的@Component decorator中设置了这一点)。虽然听起来很酷，但这意味着我们的组件的样式和html将被封装在它们自己的受保护的小DOM中——我们不需要担心CSS作用域或render()函数返回的任何内容会受到它之外的任何内容的影响。</p><p id="f2de" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">我们组件的样式应该非常简单。以下是其中一小部分的一些注释:</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/77844fdda6d0c72fad20048a4b40f12c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1pTa9-9wYkYgmDG3Qs136Q.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">我们样式表的一部分</figcaption></figure><ul class=""><li id="21a8" class="mz na iq ky b kz ly ld lz lh nb ll nc lp nd lt ne nf ng nh bi translated">:host伪类函数(第61行)遵循了与我们在代码的render函数中使用的<host>标记相同的思想，因为它针对的是我们的自定义元素本身(<alx-nav-item>)。这里我们说，如果我们的元素有一个深度属性“1”(即在第一层)，那么样式中的<a>标签会有一点不同。</a></alx-nav-item></host></li><li id="c00d" class="mz na iq ky b kz ni ld nj lh nk ll nl lp nm lt ne nf ng nh bi translated">你会注意到我们使用CSS变量来设置尺寸和颜色。请记住，我们将影子DOM用于我们的组件，所以我们不能从外部改变它的样式。例如，如果在一个特定的页面上，我们想为L1设置背景色，我们需要改变变量<code class="fe lu lv lw lx b">--alx-menu-l1-background</code>，否则它默认为#007acc。在一个健壮的设计系统中，你会有多层这样的变量&amp;它们的缺省值，产生一个非常优雅的主题化方法。</li></ul></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="5b4e" class="jy jz iq bd ka kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv bi translated">演示</h1><p id="82f3" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">你可以在这里找到整个项目:<a class="ae mp" href="https://codesandbox.io/s/alx-menu-9z9ep" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/alx-menu-9z9ep</a></p><p id="98d0" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">CodeSandbox预览窗口正在显示<strong class="ky ir"> src/index.html </strong>的渲染内容。我建议你放弃这个项目，把它玩一玩。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="936f" class="jy jz iq bd ka kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv bi translated">使用我们的组件</h1><p id="d5b5" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Stencil生成的Web组件可以通过在标准html中使用它们的标签或者在React、Vue或Angular等框架中作为JSX组件来使用。不管是什么情况，当你准备好的时候，确保在你的模板项目目录中运行<code class="fe lu lv lw lx b">npm run build</code>。</p><h2 id="b519" class="nw jz iq bd ka nx ny dn ke nz oa dp ki lh ob oc km ll od oe kq lp of og ku oh bi translated">在纯HTML中</h2><p id="1d8c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">要在普通HTML中使用我们的组件，我们所要做的就是复制<code class="fe lu lv lw lx b">/build </code>文件夹，并在我们的页面中包含入口点js文件(例如<code class="fe lu lv lw lx b">&lt;script src="build/alx-menu.js"&gt;&lt;/script&gt;</code>)就是这样！</p><ul class=""><li id="5bef" class="mz na iq ky b kz ly ld lz lh nb ll nc lp nd lt ne nf ng nh bi translated">如果我们的项目中有多个组件，我们仍然只需要包含一个文件；Stencil的动态加载器将只加载页面上正在使用的组件。</li><li id="c2fc" class="mz na iq ky b kz ni ld nj lh nk ll nl lp nm lt ne nf ng nh bi translated">旧的浏览器支持也由Stencil的加载器负责(通过core-js polyfills)，所以我们不需要做任何其他事情来使我们的navbar在IE11中工作！</li></ul><h2 id="0471" class="nw jz iq bd ka nx ny dn ke nz oa dp ki lh ob oc km ll od oe kq lp of og ku oh bi translated">在反应范围内</h2><p id="0316" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我将会写一篇关于如何让你的模板生成的Web组件在React中完美地<strong class="ky ir"/>工作的更广泛的文章(有一些奇怪的地方需要处理),但是现在，这将足以让我们的navbar组件正常工作:</p><ul class=""><li id="8adf" class="mz na iq ky b kz ly ld lz lh nb ll nc lp nd lt ne nf ng nh bi translated">我们将在模板项目的根目录下运行<code class="fe lu lv lw lx b">npm pack</code>——这将把我们的组件打包成一个漂亮的小。存储在本地的tgz文件。(如果我们想与他人分享，我们也可以将其发布到NPM回购协议上)</li><li id="0123" class="mz na iq ky b kz ni ld nj lh nk ll nl lp nm lt ne nf ng nh bi translated">在React项目文件夹中，我们将运行<code class="fe lu lv lw lx b">npm install /absolute/path/to/ourComponentPackage.tgz</code>,然后转到将React应用程序注入DOM的脚本(通常是index.js ),添加以下两行:</li></ul><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/8d6b699ff2ba59a171f750e2d037dda9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*JfSN42nyzYf2S2GUD1242g.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">将我们的web组件导入React</figcaption></figure><ul class=""><li id="e2de" class="mz na iq ky b kz ly ld lz lh nb ll nc lp nd lt ne nf ng nh bi translated">搞定了。我们现在可以在React中使用导航组件，就像使用常规HTML元素一样:</li></ul><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/b2e7756e4d6b236fcbc0ace509bd2830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fkBesYIbfxu8JuGXZy7udA.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">在React中使用我们的web组件</figcaption></figure></div></div>    
</body>
</html>