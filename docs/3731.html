<html>
<head>
<title>Building Cloud native apps: Intro to Open Application Model and Rudr</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建云原生应用:开放应用模型和Rudr简介</h1>
<blockquote>原文：<a href="https://itnext.io/building-cloud-native-apps-intro-to-open-application-model-and-rudr-bd1b55df9bf3?source=collection_archive---------0-----------------------#2020-02-12">https://itnext.io/building-cloud-native-apps-intro-to-open-application-model-and-rudr-bd1b55df9bf3?source=collection_archive---------0-----------------------#2020-02-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8f5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">生产级分布式云原生微服务通常由多个合作团队构建和运营。这说起来容易做起来难！考虑到规模和复杂性，问题会以多种方式出现(并不总是由于技术原因)。其他一些因素包括缺乏职责分离、角色/责任重叠等。，因此能够清楚地区分每个团队/小组负责的领域至关重要——一个典型的例子是应用程序开发人员和操作人员。</p><p id="3ef1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一篇介绍性的博文，帮助你熟悉云原生应用开发领域的几个项目:<strong class="jp ir">开放应用模型</strong>和<strong class="jp ir"> Rudr </strong>。您将了解这些项目及其核心概念的概述。</p><blockquote class="kl km kn"><p id="fb25" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated"><em class="iq">(本系列中的)后续文章将建立在本文所讨论的概念之上，并涵盖实际例子</em></p></blockquote></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><h1 id="bf33" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">开放应用模型:什么和为什么？</h1><p id="f6c2" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated"><code class="fe mc md me mf b"><a class="ae mg" href="https://github.com/oam-dev/spec" rel="noopener ugc nofollow" target="_blank">Open Application Model (OAM)</a></code>采用“关注点分离”原则试图解决这个问题。为了定义应用程序开发的规范，它考虑了以下角色和职责:</p><ul class=""><li id="bbc1" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">应用程序开发人员:他们的职责是构建、描述和配置应用程序。</li><li id="6bb2" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">应用操作员:在平台上工作，负责配置一个或多个微服务的运行时组件。</li><li id="dd1f" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">基础设施操作员:设置和维护运行这些应用程序的核心基础设施。</li></ul><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mv"><img src="../Images/f0a8f6160e5fbf1ad00a1814548567f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T4wy1h6tdQ86_BM7"/></div></div></figure><p id="e8af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单来说，<code class="fe mc md me mf b">OAM</code>是一个构建云原生应用的规范。它提供了一种平台中立的方式来定义这些应用程序，通过抽象出许多因素，如云提供商、编排平台等。它定义的标准可以为不同的实现铺平道路</p><blockquote class="kl km kn"><p id="3f5f" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated"><em class="iq">这种实现的一个例子是</em> <code class="fe mc md me mf b"><em class="iq">Rudr</em></code> <em class="iq">，这在thig博文</em>中有所涉及</p></blockquote></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><h1 id="daa6" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">开放式应用模型:核心概念</h1><p id="3e33" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">开放应用程序模型定义了以下组件——将它们视为可以有不同实现的抽象概念</p><ul class=""><li id="c2ab" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><em class="ko">组件示意图</em>:开发者用来描述一个应用或服务。您可以将组件示意图视为一个“类”,因为这只是应用程序的蓝图</li><li id="5804" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><em class="ko">应用配置</em>:由应用操作员定义的组件、特性和应用范围的组合。将应用程序配置视为创建一个类(组件示意图)的多个“实例”的方式，每个实例都具有不同的属性。</li><li id="f116" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><em class="ko">特性</em>:应用操作员可以为组件分配附加特性，以满足横切需求</li><li id="4bd5" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><em class="ko">工作负载</em>:用于定义特定组件的运行时类型</li><li id="6add" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><em class="ko">应用范围</em>:它们提供了一种将具有共同特征的组件组合成松散耦合的应用程序的方法</li></ul><p id="54b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们对<code class="fe mc md me mf b">OAM</code>及其术语有了一个基本的概念，让我们深入了解<code class="fe mc md me mf b">Rudr</code></p></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><h1 id="ed24" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">你好，路德！</h1><p id="7162" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated"><code class="fe mc md me mf b"><a class="ae mg" href="https://github.com/oam-dev/rudr/" rel="noopener ugc nofollow" target="_blank">Rudr</a></code>是一个<a class="ae mg" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>规范的具体实现。它定义了更高级别的原语，在Kubernetes之上提供了一个抽象层。<code class="fe mc md me mf b">Rudr</code>实现<code class="fe mc md me mf b">OAM</code>概念(如组件、特质等。)使用Kubernetes资源，如<code class="fe mc md me mf b">Deployment</code> s、<code class="fe mc md me mf b">Service</code> s、<code class="fe mc md me mf b">Ingress</code>等。<code class="fe mc md me mf b">Rudr</code>允许您使用YAML清单定义<code class="fe mc md me mf b">OAM</code>实体，它在内部映射到Kubernetes自定义资源定义(CRDs)</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nh"><img src="../Images/53ef053fda269a8d93c9e558290796fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7oAyiWWBb7MIoAIf"/></div></div></figure><blockquote class="kl km kn"><p id="1d17" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated"><em class="iq"/><a class="ae mg" href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/" rel="noopener ugc nofollow" target="_blank"><em class="iq">控制器/操作器模式</em> </a> <em class="iq">用于将这些CRD转换成具体的Kubernetes资源。</em></p></blockquote><p id="65c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mc md me mf b">Rudr</code>实现了<code class="fe mc md me mf b">OAM</code>的承诺，为开发者提供了一种定义应用和其他对象的方式，比如应用配置、特征等。并让操作员定义操作能力。</p><p id="92a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于上一节介绍了<code class="fe mc md me mf b">OAM</code>概念，现在是从<code class="fe mc md me mf b">Rudr</code>的角度深入了解其本质的好时机。</p></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><h1 id="9ddc" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Rudr自定义资源定义(CRDs)</h1><p id="b947" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">本节将概述<code class="fe mc md me mf b">Rudr</code>使用的自定义资源定义。</p><h2 id="edaa" class="ni la iq bd lb nj nk dn lf nl nm dp lj jy nn no ln kc np nq lr kg nr ns lv nt bi translated">成分</h2><p id="8b68" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">组件描述了特定服务或应用程序的特征——它由<code class="fe mc md me mf b">ComponentSchematic</code> CRD表示。这里有一个例子:</p><pre class="mw mx my mz gt nu mf nv nw aw nx bi"><span id="ff58" class="ni la iq mf b gy ny nz l oa ob">apiVersion: core.oam.dev/v1alpha1<br/>kind: ComponentSchematic<br/>metadata:<br/>  name: greeter-component<br/>spec:<br/>  workloadType: core.oam.dev/v1alpha1.Server<br/>  containers:<br/>    - name: greeter<br/>      image: abhirockzz/greeter-go<br/>      env:<br/>        - name: GREETING<br/>          fromParam: greeting<br/>      ports:<br/>        - protocol: TCP<br/>          containerPort: 8080<br/>          name: http<br/>      resources:<br/>        cpu:<br/>          required: 0.1<br/>        memory:<br/>          required: "128"<br/>  parameters:<br/>    - name: greeting<br/>      type: string<br/>      default: abhi_tweeter</span></pre><p id="f448" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mc md me mf b">ComponentSchematic</code> CRD的各个部分是:</p><ul class=""><li id="d805" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><code class="fe mc md me mf b">metadata</code>:用于提供名称、标签、注释等基本信息</li><li id="7cf5" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe mc md me mf b">workloadType</code>:用来表示开发者想要如何运行这个组件。有效选项包括:<code class="fe mc md me mf b">Server</code>、<code class="fe mc md me mf b">Singleton Server</code>、<code class="fe mc md me mf b">Task</code>、<code class="fe mc md me mf b">Singleton Task</code>、<code class="fe mc md me mf b">Worker</code>、<code class="fe mc md me mf b">Singleton Worker</code></li><li id="9c10" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe mc md me mf b">containers</code>:类似于[ <code class="fe mc md me mf b">Kubernetes</code>容器规范](TODO规范链接)，用于定义运行组件的容器化工作负载所需的运行时配置</li><li id="29f0" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe mc md me mf b">parameters</code>:这是可选部分，用于提供组件的配置选项。</li></ul><h2 id="32ec" class="ni la iq bd lb nj nk dn lf nl nm dp lj jy nn no ln kc np nq lr kg nr ns lv nt bi translated">工作量</h2><p id="adda" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">如上所述，<code class="fe mc md me mf b">Rudr</code>定义了六种核心工作负载类型。工作负载类型只是组件中的一个字段。除了核心工作负载，扩展类型可以通过<a class="ae mg" href="https://github.com/oam-dev/rudr/blob/master/docs/tutorials/deploy_openfaas_workload.md" rel="noopener ugc nofollow" target="_blank">实现一个并将其直接添加到</a> <code class="fe mc md me mf b"><a class="ae mg" href="https://github.com/oam-dev/rudr/blob/master/docs/tutorials/deploy_openfaas_workload.md" rel="noopener ugc nofollow" target="_blank">Rudr</a></code>(不那么灵活)或<a class="ae mg" href="https://github.com/oam-dev/rudr/blob/master/docs/tutorials/deploy_prometheus_workload.md" rel="noopener ugc nofollow" target="_blank">使用CRD方法</a>来避免对<code class="fe mc md me mf b">Rudr</code>本身进行代码更改来定义。</p><blockquote class="kl km kn"><p id="3a83" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated"><em class="iq">在上面的</em> <code class="fe mc md me mf b"><em class="iq">ComponentSchematic</em></code> <em class="iq">中，</em> <code class="fe mc md me mf b"><em class="iq">workloadType</em></code> <em class="iq">被定义为</em> <code class="fe mc md me mf b"><em class="iq">core.oam.dev/v1alpha1.Server</em></code></p></blockquote><h2 id="f505" class="ni la iq bd lb nj nk dn lf nl nm dp lj jy nn no ln kc np nq lr kg nr ns lv nt bi translated">应用程序配置</h2><p id="7b56" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">A <code class="fe mc md me mf b">ComponentSchematic</code>本身不做任何有意义的事情。使用与一个或多个组件相关联的<code class="fe mc md me mf b">ApplicationConfiguration</code>来实现基于<code class="fe mc md me mf b">Rudr</code>的服务，并定义如何实例化和配置应用，包括参数覆盖和附加特性。</p><p id="8a88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个例子</p><pre class="mw mx my mz gt nu mf nv nw aw nx bi"><span id="dace" class="ni la iq mf b gy ny nz l oa ob">apiVersion: core.oam.dev/v1alpha1<br/>kind: ApplicationConfiguration<br/>metadata:<br/>  name: greeter-app-config<br/>spec:<br/>  components:<br/>    - componentName: greeter-component<br/>      instanceName: greeter-app</span></pre><p id="3636" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它有这些部分</p><ul class=""><li id="58da" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><code class="fe mc md me mf b">metadata</code>:用于提供名称、标签、注释等基本信息</li><li id="1c58" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe mc md me mf b">components</code>:用于引用一个或多个<code class="fe mc md me mf b">ComponentSchematic</code>，覆盖它们的参数(可选)并定义附加特征</li><li id="0277" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe mc md me mf b">traits</code>:您可以使用此部分对组件应用一个或多个功能，例如自动缩放、入口等。</li><li id="ab9c" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe mc md me mf b">scopes</code>:您可以将多个组件归入一个范围</li><li id="1ee3" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe mc md me mf b">variables</code>:可以替换到应用程序配置的多个其他位置的公共值</li></ul><h2 id="181c" class="ni la iq bd lb nj nk dn lf nl nm dp lj jy nn no ln kc np nq lr kg nr ns lv nt bi translated">特点</h2><p id="ec9d" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">代表系统的特性，这些特性是操作上的关注点，而不是开发人员的关注点。您可以将它们与组件实例相关联，以提供额外的功能，如自动伸缩、持久性等。</p><p id="3a81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个特征的例子</p><pre class="mw mx my mz gt nu mf nv nw aw nx bi"><span id="7c94" class="ni la iq mf b gy ny nz l oa ob">apiVersion: core.oam.dev/v1alpha1<br/>kind: ApplicationConfiguration<br/>metadata:<br/>  name: pv-example<br/>spec:<br/>  components:<br/>    - componentName: rudr-pvc<br/>      instanceName: rudr-pvc1<br/>      traits:<br/>        - name: volume-mounter<br/>          properties:<br/>            volumeName: config-data-vol<br/>            storageClass: default</span></pre><p id="aea9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个特征都有一组不同的属性，是<code class="fe mc md me mf b">properties</code>部分的一部分。在撰写本文时，<code class="fe mc md me mf b">Rudr</code>支持这些特性，并且每个特性都适用于特定的工作负载类型</p><ul class=""><li id="918a" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">手动缩放器—服务器，任务</li><li id="b5c0" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">自动缩放—服务器，任务</li><li id="cd90" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">入口—服务器，SingletonServer</li><li id="b5b9" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">卷安装程序—所有核心工作负载</li></ul><blockquote class="kl km kn"><p id="94a8" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated"><em class="iq">使用</em> <code class="fe mc md me mf b"><em class="iq">kubectl get traits</em></code> <em class="iq">获取支持的特性列表</em></p></blockquote><h2 id="88f6" class="ni la iq bd lb nj nk dn lf nl nm dp lj jy nn no ln kc np nq lr kg nr ns lv nt bi translated">范围</h2><p id="2404" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">在撰写本文时，<code class="fe mc md me mf b">Rudr</code>支持一个<code class="fe mc md me mf b">Health</code>和<code class="fe mc md me mf b">Network</code>作用域，您可以在<code class="fe mc md me mf b">ApplicationConfiguration</code>文件中将该作用域分配给应用程序组件工作负载的实例，以定期检查应用程序内组件的总体健康状况。</p><blockquote class="kl km kn"><p id="bbe6" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated"><em class="iq">使用</em> <code class="fe mc md me mf b"><em class="iq">kubectl get scopes</em></code> <em class="iq">获取支持范围的列表</em></p></blockquote></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><p id="ed28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您对此感兴趣，并想深入了解，请查看以下资源:</p><ul class=""><li id="ca4c" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><a class="ae mg" href="https://github.com/oam-dev/spec/blob/master/1.purpose_and_goals.md" rel="noopener ugc nofollow" target="_blank">OAM规范</a>，以及，</li><li id="e48d" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><a class="ae mg" href="https://github.com/oam-dev/rudr/blob/master/docs/README.md" rel="noopener ugc nofollow" target="_blank"> Rudr文档</a></li></ul><p id="ee65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是目前足够的理论👍即将发布的帖子将通过具体的例子来帮助强化这些概念。敬请期待！</p></div></div>    
</body>
</html>