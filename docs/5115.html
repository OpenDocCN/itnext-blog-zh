<html>
<head>
<title>Understanding Docker image tags and publishing images to Docker Hub</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Docker图像标签并将图像发布到Docker Hub</h1>
<blockquote>原文：<a href="https://itnext.io/understanding-docker-image-tags-and-publishing-images-to-docker-hub-b7a4f900f201?source=collection_archive---------0-----------------------#2020-12-15">https://itnext.io/understanding-docker-image-tags-and-publishing-images-to-docker-hub-b7a4f900f201?source=collection_archive---------0-----------------------#2020-12-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="3d7e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Docker: Docker标签和Docker Hub</h2><div class=""/><div class=""><h2 id="82ab" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">在本课中，我们将讨论如何创建和管理与Docker图像相关的标签。然后，我们将向Docker Hub发布一个示例Docker映像，并在另一台机器上使用它。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f59a2c1789ba86bae042281a40a7e15b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bXSyZPGRUb308mBAdRPvng.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(来源:<a class="ae lh" href="https://unsplash.com/photos/N93F-Ylput4" rel="noopener ugc nofollow" target="_blank"><strong class="bd li">unsplash.com</strong></a>)</figcaption></figure><p id="39db" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在<a class="ae lh" href="https://medium.com/sysf/docker/home" rel="noopener"> <strong class="ll jd">之前的课程</strong> </a>中，我们学习了Docker图像的剖析，Docker容器如何工作，如何从Docker文件创建Docker图像，并了解了Docker图像的一些特征。然而，我们并没有专注于与世界分享一个码头工人的形象。在这节课中，我们将学习Docker图像标签。</p><p id="d736" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在本课中，我们将创建一个简单的Docker映像，当从控制台创建容器时，它会将版本号打印到控制台。该应用程序的源代码位于<a class="ae lh" href="https://github.com/course-one/docker-version-app" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd"> this </strong> </a> GitHub存储库中。</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="d65c" class="mk ml it mg b gy mm mn l mo mp"><strong class="mg jd">docker-version-app/</strong> <br/>├── .dockerignore<br/>├── .gitignore<br/>├── Dockerfile<br/>└── version.txt</span></pre><p id="f5a8" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们的Docker图像将看起来非常简单。我们将有一个Dockerfile和包含版本字符串的<code class="fe mq mr ms mg b">version.txt</code>文件。Dockerfile具有打印<code class="fe mq mr ms mg b">version.txt</code>文件内容的<code class="fe mq mr ms mg b">CMD</code>指令。由于这个操作不需要复杂的设置，我们将使用<code class="fe mq mr ms mg b"><a class="ae lh" href="https://hub.docker.com/_/alpine/" rel="noopener ugc nofollow" target="_blank">alpine</a>:3.12.2</code>图像作为Docker图像的父图像。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(来源:<a class="ae lh" href="https://gist.github.com/thatisuday/285e6478873454fcf029452600728d49" rel="noopener ugc nofollow" target="_blank">gist.github.comT21</a>)</figcaption></figure><p id="c8d5" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在来说说打造Docker形象。在前面的课程中，我们学习了如何创建Docker映像，我们在构建上下文所在的<code class="fe mq mr ms mg b">PATH</code>目录中使用了<code class="fe mq mr ms mg b">$ docker build PATH</code>命令。除非我们在这个命令中使用了<code class="fe mq mr ms mg b">--file</code>或<code class="fe mq mr ms mg b">-f</code>标志，否则我们的Dockerfile必须存在于这个目录中。所以让我们创建一个Docker图像。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mv"><img src="../Images/eaabbb60b5da12b539b0ff550e37f3f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*awTu1RYcXNZdLKxoHxPFVA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker构建</figcaption></figure><p id="695b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">最初，我们没有本地下载的任何Docker映像。一旦我们运行了<code class="fe mq mr ms mg b">$ docker build</code>命令，docker就会从Docker注册表中取出父映像(<em class="mw"> docker.io </em>)，并通过读取Docker文件中的指令来构建映像。当我们再次运行<code class="fe mq mr ms mg b">$ docker images</code>命令时，我们看到ID为<code class="fe mq mr ms mg b">223b43496b9c</code>(在 <code class="fe mq mr ms mg b"><em class="mw">IMAGE ID</em></code> <em class="mw">列</em>中指定的<em class="mw">)的图像。我们可以在像<code class="fe mq mr ms mg b">$ docker run &lt;id&gt;</code>或<code class="fe mq mr ms mg b">$ docker rmi &lt;id&gt;</code>这样的命令中使用这个ID来对这个图像执行一些操作。</em></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/6adbed236ff603a02c6425e1fa937114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*F7vxzFgLJ1A7DyqH6kf9ig.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker运行</figcaption></figure><p id="1fb6" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在让我们把注意力集中在<code class="fe mq mr ms mg b">REPOSITORY</code>和<code class="fe mq mr ms mg b">TAG</code>列上。<code class="fe mq mr ms mg b">REPOSITORY</code>列显示与Docker图像相关联的<strong class="ll jd">名称</strong>，而<code class="fe mq mr ms mg b">TAG</code>显示与Docker图像相关联的<strong class="ll jd">标签</strong>。</p><p id="c4d9" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">把Docker映像想象成一个第三方(<em class="mw">依赖</em>)包。就像包必须有唯一的名称和版本一样，因为Docker映像可以公开共享，<code class="fe mq mr ms mg b">REPOSITORY</code>和<code class="fe mq mr ms mg b">TAG</code>列做了同样的工作来标记Docker映像，以便用户可以从Docker注册表下载正确的映像和适当的版本。</p><p id="7701" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">存储库名称可以是<code class="fe mq mr ms mg b">&lt;name&gt;</code>或<code class="fe mq mr ms mg b">&lt;username&gt;/&lt;name&gt;</code>的形式，其中<code class="fe mq mr ms mg b">&lt;name&gt;</code>是您的Docker映像的唯一名称，而<code class="fe mq mr ms mg b">&lt;username&gt;</code>是您在Docker Hub上的帐户用户名。<a class="ae lh" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd"> Docker Hub </strong> </a>是公开或私下分享Docker图片的公共网络平台。如果您想在Dockerhub上共享图像，那么您的Docker图像必须具有<code class="fe mq mr ms mg b">&lt;username&gt;/&lt;name&gt;</code>格式的存储库名称。</p><p id="ff3b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe mq mr ms mg b">TAG</code>列值显示与Docker图像相关的标签。该值没有约定的格式。这应该是为了区分同名的Docker图像，因此你可以遵循任何你喜欢的格式，但我通常会使用<a class="ae lh" href="https://www.geeksforgeeks.org/introduction-semantic-versioning/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">语义版本</strong> </a>格式，如<code class="fe mq mr ms mg b">1.0.0</code>。</p><p id="0f9b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果您看到与我们的Docker图像相关联的存储库和标签，那么这两列都会显示<code class="fe mq mr ms mg b">&lt;none&gt;</code>。原因是，在运行<code class="fe mq mr ms mg b">$ docker build</code>命令时，我们还没有为这些列指定值。</p><blockquote class="my mz na"><p id="5aa7" class="lj lk mw ll b lm ln kd lo lp lq kg lr nb lt lu lv nc lx ly lz nd mb mc md me im bi translated"><em class="it">💡</em>带有<code class="fe mq mr ms mg b">&lt;none&gt;</code>名称的Docker图像称为<strong class="ll jd">悬空图像</strong>。您可以使用带有<code class="fe mq mr ms mg b">$ docker images</code>的<code class="fe mq mr ms mg b">--filter "dangling=true"</code>标志来列出本地机器上出现的所有悬挂图像。</p></blockquote><p id="defe" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">为了给图像的存储库和标签指定一个值，我们在<code class="fe mq mr ms mg b">$ docker build</code>命令中使用了<code class="fe mq mr ms mg b">--tag</code>或<code class="fe mq mr ms mg b">-t</code>标志。该标志的值的格式是<code class="fe mq mr ms mg b">&lt;repository&gt;:&lt;tag&gt;</code>。如果我们不考虑<code class="fe mq mr ms mg b">:&lt;tag&gt;</code>部分，Docker将隐式使用<code class="fe mq mr ms mg b">latest</code>部分的值。</p><blockquote class="my mz na"><p id="e96b" class="lj lk mw ll b lm ln kd lo lp lq kg lr nb lt lu lv nc lx ly lz nd mb mc md me im bi translated"><em class="it">💡</em>标志<code class="fe mq mr ms mg b">--tag</code>使它变得非常混乱，因为我们不仅指定了<code class="fe mq mr ms mg b">TAG</code>列的值，还指定了<code class="fe mq mr ms mg b">REPOSITORY</code>列的值。这就是为什么<code class="fe mq mr ms mg b">&lt;repository&gt;:&lt;tag&gt;</code>有时被称为标签或名称，所以如果这让你感到困惑，请原谅我。</p></blockquote><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mv"><img src="../Images/de1920af91f0b0e546034fd301c779d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cDb6Ua643i__fRN0MnNxDA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker构建</figcaption></figure><p id="e103" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这一次，我们使用带有<code class="fe mq mr ms mg b">$ docker build</code>命令的<code class="fe mq mr ms mg b">-t version</code>标志来构建一个新的图像。现在，当我们列出图像时，它显示了一个Docker图像，其ID与我们之前的ID相同，但值为<code class="fe mq mr ms mg b">REPOSITORY</code>和<code class="fe mq mr ms mg b">TAG</code>值为<code class="fe mq mr ms mg b">latest</code>。Docker使用<code class="fe mq mr ms mg b">latest</code>值表示<code class="fe mq mr ms mg b">TAG</code>，因为我们在<code class="fe mq mr ms mg b">-t</code>值中没有提到。</p><p id="c9e6" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">因为Docker图像的<code class="fe mq mr ms mg b">IMAGE ID</code>是通过分析Docker图像的内容而生成的<strong class="ll jd">，所以新图像接收我们之前拥有的悬空图像的相同ID，因为两个图像具有相同的内容。然而，由于悬挂图像可能只被其ID引用，现在我们有了一个具有相同ID的新的非悬挂图像，所以它被移除了。</strong></p><blockquote class="my mz na"><p id="0bc2" class="lj lk mw ll b lm ln kd lo lp lq kg lr nb lt lu lv nc lx ly lz nd mb mc md me im bi translated"><em class="it">💡</em>注意<code class="fe mq mr ms mg b">CREATED</code>栏显示的是<code class="fe mq mr ms mg b">26 minutes ago</code>，这意味着我们并没有真正创建一个新图像。它仍然是旧的图像，但是有一个合适的名称(repo:tag)。如果我们试图用完全相同的内容构建一个新的图像，同样的逻辑也适用。</p></blockquote><p id="30d6" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们用适当的存储库和标记值构建另一个图像。让我们使用<code class="fe mq mr ms mg b">1.0.0</code>作为标记值来表示我们将要构建的图像是此类图像的第一个版本。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mv"><img src="../Images/6d4770c5c0a5dc18dcafcd01fce005e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1uUIY1hjAAhyT-F1OyuCIw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker构建</figcaption></figure><p id="42a6" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">使用<code class="fe mq mr ms mg b">-t version:1.0.0</code>标志，我们创建了一个具有<code class="fe mq mr ms mg b">TAG</code>值<code class="fe mq mr ms mg b">1.0.0</code>的新Docker图像。但是，如果您看到<code class="fe mq mr ms mg b">IMAGE ID</code>列，它也引用了旧图像，因为图像的内容仍然相同。</p><p id="a7af" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">当在诸如<code class="fe mq mr ms mg b">$ docker run &lt;image&gt;</code>或<code class="fe mq mr ms mg b">$ docker inspect &lt;image&gt;</code>的命令中引用Docker图像时，我们可以使用图像的名称而不是其ID作为<code class="fe mq mr ms mg b">&lt;image&gt;</code>值。使用图像名称时，<code class="fe mq mr ms mg b">&lt;image&gt;</code>值的通用格式是<code class="fe mq mr ms mg b">&lt;repository&gt;:&lt;tag&gt;</code>，与<code class="fe mq mr ms mg b">--tag</code>相同。</p><p id="2de8" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">例如，<code class="fe mq mr ms mg b">$ docker <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/inspect/" rel="noopener ugc nofollow" target="_blank">inspect</a> version:1.0.0</code>将显示ID为<code class="fe mq mr ms mg b">223b43496b9c</code>的图像的信息。如果我们省略<code class="fe mq mr ms mg b">:&lt;tag&gt;</code>部分，默认情况下会替换为<code class="fe mq mr ms mg b">:latest</code>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/f4327f6e529b3afd03e5b7f8f92b6392.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*PdyClpH9X4keQft4V8Ut4w.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$码头检查/ $码头运行</figcaption></figure><p id="ae1c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在让我们通过用<code class="fe mq mr ms mg b">v1.0.1</code>替换<code class="fe mq mr ms mg b">v1.0.0</code>文本来修改<code class="fe mq mr ms mg b">version.txt</code>文件的内容，并创建一个新的构建。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mv"><img src="../Images/5003bb762d6bc5beb9ecc88aa86b6206.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8toO_k66yPs2fTSsLBnoVg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker构建</figcaption></figure><p id="7a72" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">既然我们正在构建的Docker映像的内容与旧的不同，那么<code class="fe mq mr ms mg b">IMAGE ID</code>也会有所不同。由于我们没有为<code class="fe mq mr ms mg b">--tag</code>标志提供值，Docker创建了一个悬空图像。这一次，让我们为图像提供一个合适的名称。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mv"><img src="../Images/4202502b5ab39e9ef3401b6a265963fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*65iHpAW4obrfA1HUfFHhfg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker构建</figcaption></figure><p id="35cc" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这一次，我们将图像命名为<code class="fe mq mr ms mg b">version:1.0.1</code>。但是，看到带<code class="fe mq mr ms mg b">latest</code>标签的图，还是指的老build。这是因为Docker世界中的<code class="fe mq mr ms mg b">latest</code>并不意味着图像的最新版本，这就是为什么它可能会误导新人。让我们看看问题。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/748f0da1ec9c6fc84314c4f0c7ff4667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*grJ8T2QWShwk5_POtiXjJA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker运行</figcaption></figure><p id="0913" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">当我们从<code class="fe mq mr ms mg b">version</code>图像(<code class="fe mq mr ms mg b"><em class="mw">version:latest</em></code><em class="mw"/>)创建一个容器时，我们通常会期望以最新的(<em class="mw">最近的</em>)图像为目标。但是，对于Docker来说，<code class="fe mq mr ms mg b">latest</code>只是一个默认标签，对它来说并没有更多的意义。所以<code class="fe mq mr ms mg b">version:latest</code>标签和<code class="fe mq mr ms mg b">version:1.0.0</code>或者<code class="fe mq mr ms mg b">version:bla-bla</code>没有什么不同的意思。</p><p id="cb6d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">但是对于我们这些开发者来说，<code class="fe mq mr ms mg b">latest</code>就是最近的意思。因此，我们需要确保我们的新图像有<code class="fe mq mr ms mg b">latest</code>标签。到目前为止，我们了解到标签只是一个<strong class="ll jd">标签，我们分配给图像</strong>，以便我们可以更自然地识别Docker应用程序的不同版本(<em class="mw">具有相同的名称</em>)。一个标签必须指向一个Docker图像，但是一个Docker图像可以有许多标签。</p><p id="fbe1" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">所以让我们用<code class="fe mq mr ms mg b">version:latest</code>标签重建之前的图像。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mv"><img src="../Images/cb576a280bcbe4e875d9103d1f52c853.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rE_JHhA1BnjRL8Qbd8ztNg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker构建</figcaption></figure><p id="afdf" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在上面的例子中，我们构建了一个名为<code class="fe mq mr ms mg b">version:latest</code>的新图像(<em class="mw">而没有修改内容</em>，尽管我们省略了<code class="fe mq mr ms mg b">:latest</code>部分，以便Docker可以施展它的魔法。由于<code class="fe mq mr ms mg b">version:latest</code>标签已经存在，Docker将简单地将<code class="fe mq mr ms mg b">version:latest</code>标签指向ID为<code class="fe mq mr ms mg b">0c102369f408</code>的图像。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/a544cdad1171975b4ca9a45a2f7ddaa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*1JC3StUjfprnEnaGRfEV2w.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker运行</figcaption></figure><p id="079d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在，当我们从<code class="fe mq mr ms mg b">version</code>图像(<code class="fe mq mr ms mg b"><em class="mw">version:latest</em></code> <em class="mw">隐式</em>)创建一个容器时，我们找到了最近的图像。这证明了管理最新图像的责任落在了我们开发人员身上。</p><p id="f6d1" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">由于标签可以很容易地移动，Docker给了我们<code class="fe mq mr ms mg b">$ docker tag</code>命令来创建一个标签，而不必构建带有<code class="fe mq mr ms mg b">--tag</code>标志的图像。</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="fc9d" class="mk ml it mg b gy mm mn l mo mp">$ docker tag &lt;image&gt; &lt;repo&gt;:&lt;tag&gt;</span></pre><p id="8df0" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe mq mr ms mg b">&lt;image&gt;</code>是我们希望新标签引用的图像。我们可以使用这个值的图像ID或图像的<code class="fe mq mr ms mg b">&lt;repo&gt;:&lt;tag&gt;</code>值，其中<code class="fe mq mr ms mg b">:tag</code>部分是可选的，它将默认为<code class="fe mq mr ms mg b">:latest</code>。对于命令的<code class="fe mq mr ms mg b">&lt;repo&gt;:&lt;tag&gt;</code>值，我们可以放任何我们想要的东西。这里<code class="fe mq mr ms mg b">:&lt;tag&gt;</code>部分也是可选的，它将默认为<code class="fe mq mr ms mg b">:latest</code>。</p><p id="39cb" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们通过修改<code class="fe mq mr ms mg b">version.txt</code>文件中的值来创建一个版本为<code class="fe mq mr ms mg b">1.0.2</code>的新构建。但是这一次，我们将使用<code class="fe mq mr ms mg b">$ docker tag</code>命令来移动<code class="fe mq mr ms mg b">version:latest</code>标签。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mv"><img src="../Images/6ef3924cc8516de344dd392635c6921c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eJaaIRSIaMv2fD_ITns-yg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker构建</figcaption></figure><p id="7956" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">从上面的结果可以看出，新的Docker图像具有名为<code class="fe mq mr ms mg b">version:1.0.2</code>的<code class="fe mq mr ms mg b">6001cd23b419</code> ID。由于<code class="fe mq mr ms mg b">version:latest</code>标签指向了一个更早的图像，我们不得不重新定位它。使用<code class="fe mq mr ms mg b">$ docker tag</code>命令，我们已经手动将其重新定位，指向新版本。</p><p id="95a3" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">由于Docker标签只是简单的标签，所以删除标签并不会真正删除图像，除非它是引用图像的最后一个标签。我们没有特殊的命令来取消Docker图像的标记，我们使用相同的旧的<code class="fe mq mr ms mg b">$ docker <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/rmi/" rel="noopener ugc nofollow" target="_blank">rmi</a></code>命令来删除标记。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mv"><img src="../Images/ac8460c5c2ab42cd7228ad59feb3df03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RLZP0kojaWU4NNkbRmPcyg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker rmi</figcaption></figure><p id="96bf" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">仔细观察上面的命令及其输出。我们有一个ID为<code class="fe mq mr ms mg b">6001cd23b419</code>的Docker图像，有两个标签指向它。因此，除非使用<code class="fe mq mr ms mg b">-f</code>或<code class="fe mq mr ms mg b">--force</code>标志，否则用<code class="fe mq mr ms mg b">$ docker rmi &lt;id&gt;</code>命令移除该图像不起作用。</p><p id="b51b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe mq mr ms mg b">$ docker rmi version:1.0.2</code>命令只显示ID为<code class="fe mq mr ms mg b">6001cd23b419</code>的未标记(<em class="mw">移除了标记</em>)图像。现在这个图像只剩下一个标签(<code class="fe mq mr ms mg b"><em class="mw">version:latest</em></code>)，<code class="fe mq mr ms mg b">$ docker rmi version:latest</code> ( <code class="fe mq mr ms mg b"><em class="mw">:latest</em></code> <em class="mw">是可选的</em>)删除标签和图像。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="ef15" class="nl ml it bd li nm nn no np nq nr ns nt ki nu kj nv kl nw km nx ko ny kp nz oa bi translated">将图像发布到Docker Hub</h1><p id="a8c1" class="pw-post-body-paragraph lj lk it ll b lm ob kd lo lp oc kg lr ls od lu lv lw oe ly lz ma of mc md me im bi translated">Docker Hub是共享Docker图像的公共存储库。当您运行<code class="fe mq mr ms mg b">$ docker pull &lt;image&gt;</code>命令或使用Docker文件中的<code class="fe mq mr ms mg b">FROM &lt;image&gt;</code>指令时，Docker默认会在Docker Hub上查找图像(如果不在本地则为<em class="mw">)。</em></p><p id="c078" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">要在Docker Hub上共享图片，我们需要一个Docker Hub帐户。所以你应该在https://hub.docker.com注册，并使用一个不尴尬的用户名，因为这很重要。我在Docker Hub上的用户名是<code class="fe mq mr ms mg b">thatisuday</code>，所以我想在Docker Hub上发布的任何图片都将以前缀<code class="fe mq mr ms mg b">thatisuday/</code>开头，这意味着当我标记一张图片时，它将是<code class="fe mq mr ms mg b">thatisuday/&lt;repo&gt;:&lt;tag&gt;</code>。</p><p id="b0a3" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">一旦我们注册，我们需要设置一个存储库。一个存储库就像一个GitHub存储库，它包含同一个图像的许多版本(<em class="mw">标签</em>)。点击<code class="fe mq mr ms mg b">Repositories</code>链接，然后点击<code class="fe mq mr ms mg b">Create Repository</code>按钮。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi og"><img src="../Images/4e04ae953bc321f940e96cbf221eb75f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FgJI5fSmYcmtZznLkD9u9w.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(Docker存储库)</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi og"><img src="../Images/a52063fb9d1edb5d3e46225d303fdf00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8qdihI7f1-UnykSXQfGMsQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(创建新的存储库)</figcaption></figure><p id="c777" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果您想将存储库设为私有，请选中<code class="fe mq mr ms mg b">Private</code>单选按钮。填写完所有信息后，点击<code class="fe mq mr ms mg b">Create</code>按钮创建存储库。之后，您应该会看到如下页面。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi og"><img src="../Images/9365744c36c6edd916751fd2ae20024b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EnSfnubUf7iA4SSXeX1Imw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(版本存储库)</figcaption></figure><p id="a7d2" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在上面的例子中，我们将存储库命名为<code class="fe mq mr ms mg b">version</code>。现在，我们只需一个命令就可以将我们的Docker映像发布到Docker Hub上的这个存储库中。然而，在我们这样做之前，我们还需要处理一些事情。</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="9392" class="mk ml it mg b gy mm mn l mo mp">$ docker push [OPTIONS] NAME[:TAG]</span></pre><p id="9b66" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们使用<code class="fe mq mr ms mg b">$ docker <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/push/" rel="noopener ugc nofollow" target="_blank">push</a></code>命令将Docker映像从本地机器发布到Docker Hub。如前所述，在将Docker映像推送到Docker Hub时，标记名非常重要，因为没有其他方法可以告诉Docker将映像推送到哪个存储库。因此，当我们推送名为<code class="fe mq mr ms mg b">thatisuday/version:tag</code>的Docker图像时，Docker假设我们想要将图像推送到用户名为<code class="fe mq mr ms mg b">thatisuday</code>的用户的<code class="fe mq mr ms mg b">version</code>存储库。</p><p id="3432" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">因为任何匿名的人都可以恶意地将Docker图像发布到任何人的存储库中，所以<code class="fe mq mr ms mg b">$ docker push</code>命令需要事先授权。为此，我们使用<code class="fe mq mr ms mg b">$ docker <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/login/" rel="noopener ugc nofollow" target="_blank">login</a></code>命令。该命令要求输入用户名和密码来登录您的Docker Hub帐户。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/f6563c062a8c5bf4b4deed7b3e5b5a4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*DiH-ex9QV0PGIpwxaSCG0Q.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker登录</figcaption></figure><p id="579e" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">一旦我们看到<code class="fe mq mr ms mg b">Login Suceeded</code>消息，我们就可以发布图像。但是首先，我们需要一个带有适当标签的图像。因此，让我们从早期的构建中创建一个新的标签来满足Docker Hub标准。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mv"><img src="../Images/37c7e09618333770f68ca420a600092b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZWgNzFDGzB5lHx0-x2tSMA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker推送</figcaption></figure><p id="e53c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">首先，我们创建了两个新标签，即。ID为<code class="fe mq mr ms mg b">223b43496b9c</code>的图像中的<code class="fe mq mr ms mg b">thatisuday/version:1.0.0</code>和<code class="fe mq mr ms mg b">thatisuday/version:latest</code>，存储库名称为<code class="fe mq mr ms mg b">thatisuday/version</code>，我们在<code class="fe mq mr ms mg b">$ docker tag</code>命令中使用<code class="fe mq mr ms mg b">version:1.0.0</code>名称来引用它。</p><p id="fbd2" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">当我们执行<code class="fe mq mr ms mg b">$ docker push &lt;username&gt;/&lt;repo&gt;:&lt;tag&gt;</code>命令时，<strong class="ll jd">只有名为<code class="fe mq mr ms mg b">&lt;username&gt;/&lt;repo&gt;:&lt;tag&gt;</code>的标签</strong> ( <em class="mw">图像</em>)被推送到Docker Hub。如果我们省略<code class="fe mq mr ms mg b">:&lt;tag&gt;</code>部分，<strong class="ll jd">名为<code class="fe mq mr ms mg b">&lt;username&gt;/&lt;repo&gt;</code>的所有标签</strong>都会被推送。因为在我们的例子中我们省略了<code class="fe mq mr ms mg b">:tag</code>部分，所以<code class="fe mq mr ms mg b">1.0.0</code>和<code class="fe mq mr ms mg b">latest</code>标签都将被推送。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi og"><img src="../Images/4fce0bdd0f3b5c482bda6c3a0e321d8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aI2NGhMk-DsOA0N5itOt7Q.png"/></div></div></figure><p id="5fbb" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们可以通过查看<code class="fe mq mr ms mg b">Tags and Scans</code>部分下发布的标签来确认这一点。我们可以看到<code class="fe mq mr ms mg b">latest</code>和<code class="fe mq mr ms mg b">1.0.0</code>标签在那里。现在我们已经发布了我们的第一个Docker图像，让我们来尝试一下。我更喜欢另一台安装了Docker的机器来下载和播放我们的Docker映像，但这真的没有必要。我们可以使用一个集装箱。</p><h2 id="e285" class="mk ml it bd li oi oj dn np ok ol dp nt ls om on nv lw oo op nx ma oq or nz iz bi translated">码头工人</h2><p id="2991" class="pw-post-body-paragraph lj lk it ll b lm ob kd lo lp oc kg lr ls od lu lv lw oe ly lz ma of mc md me im bi translated">可以在Docker容器中运行Docker引擎。<code class="fe mq mr ms mg b"><a class="ae lh" href="https://hub.docker.com/_/docker" rel="noopener ugc nofollow" target="_blank">docker:dind</a></code> ( <em class="mw"> dind代表docker-in-docker </em>)图像让我们创建一个安装了docker的容器。我们可以从这个映像创建一个容器，并使用Docker命令。</p><p id="5e58" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让官方的<code class="fe mq mr ms mg b">docker:dind</code>图像工作起来有点麻烦，你可以按照<a class="ae lh" href="https://hub.docker.com/_/docker" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">这个</strong> </a>页面的设置说明进行操作。但是，此图像基于现在已经过时的<a class="ae lh" href="https://github.com/jpetazzo/dind" rel="noopener ugc nofollow" target="_blank"><strong class="ll jd">jpetazzo/dind</strong></a>图像。然而，它仍然工作，我将用它来启动一个docker-in-docker容器。想了解更多docker-in-docker，关注<a class="ae lh" href="https://www.docker.com/blog/docker-can-now-run-within-docker/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">这篇</strong> </a>的帖子。</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="ef10" class="mk ml it mg b gy mm mn l mo mp">$ docker run --rm --privileged -it jpetazzo/dind</span></pre><p id="a056" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">通过运行上面的命令，我们从Docker Hub中拉出了<code class="fe mq mr ms mg b">jpetazzo/dind</code>映像，并从中运行了一个容器。一旦容器启动并运行，它将把我们放在一个shell中，我们可以像在本地主机上一样运行Docker命令。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi os"><img src="../Images/70cc457cb0630161be18a26972a1b77b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wZ1SKQUOzBlKl6mmrQmxug.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(DIND集装箱)</figcaption></figure><p id="b0fe" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">要从Docker Hub下载Docker映像，我们使用<code class="fe mq mr ms mg b">$ docker <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/pull/" rel="noopener ugc nofollow" target="_blank">pull</a></code>命令。<code class="fe mq mr ms mg b">$ docker pull thatisuday/version</code>命令将从用<code class="fe mq mr ms mg b">thatisuday</code>用户名标识的账户的<code class="fe mq mr ms mg b">version</code>存储库中提取<code class="fe mq mr ms mg b">version:latest</code>图像。如果我们使用<code class="fe mq mr ms mg b">$ docker pull thatisuday/version:1.0.0</code>，它将提取带有标签<code class="fe mq mr ms mg b">1.0.0</code>的图像，尽管在我们的例子中它会指向同一个图像。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi os"><img src="../Images/21f397d240f335997cd022c4d39ad4ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GSD3LIBE9aORC13Pl7ujqQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker运行</figcaption></figure><p id="5816" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe mq mr ms mg b">$ docker run thatisuday/version</code>命令在本地查找<code class="fe mq mr ms mg b">thatisuday/version:latest</code>图像。如果它不能在本地找到它，它将被动态下载，然后从它创建容器，这就是为什么前面的步骤不是真正必要的。我们可以通过查看控制台中的<code class="fe mq mr ms mg b">v1.0.0</code>输出来验证<code class="fe mq mr ms mg b">thatisuday/version:latest</code>图像是<code class="fe mq mr ms mg b">1.0.0</code>(忽略其他 <code class="fe mq mr ms mg b"><em class="mw">INFO</em></code> <em class="mw">行</em>)。</p><blockquote class="my mz na"><p id="c1fb" class="lj lk mw ll b lm ln kd lo lp lq kg lr nb lt lu lv nc lx ly lz nd mb mc md me im bi translated"><em class="it">💡</em>如果Docker Hub存储库没有带<code class="fe mq mr ms mg b">:latest</code>标签的图像，那么<code class="fe mq mr ms mg b">$ docker run thatisuday/version</code>将导致错误。因此，有必要使用<code class="fe mq mr ms mg b">latest</code>标签，除非你的用户消息灵通。</p></blockquote><p id="909e" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们创建一个新的标签<code class="fe mq mr ms mg b">thatisuday/version:1.0.1</code>，它指向本地机器上的<code class="fe mq mr ms mg b">version:1.0.1</code>图像。让我们也移动<code class="fe mq mr ms mg b">thatisuday/version:latest</code>来点这个图像。然后，我们会将新创建的标签推送到Docker Hub存储库。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mv"><img src="../Images/1136eee689b4bd16288cdb2e25e96b2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8M0ArGF6siYBMhw-9UrzRA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker推送</figcaption></figure><p id="0eee" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这次我们推送的是特定的标签，而不是<code class="fe mq mr ms mg b">thatisuday/version</code>图片的所有标签。由于<code class="fe mq mr ms mg b">1.0.0</code>和<code class="fe mq mr ms mg b">1.0.1</code>图像之间只有微小的差异，Docker只推送图像中新的图层。由于<code class="fe mq mr ms mg b">latest</code>和<code class="fe mq mr ms mg b">1.0.1</code>标签引用相同的图像(<em class="mw">因此是相同的层</em>，没有新的层被推送给<code class="fe mq mr ms mg b">latest</code>标签。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi og"><img src="../Images/7714a8033bf04d6854c11a8bf6e3b748.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gsbWLsArBhLNEdhueFPWxg.png"/></div></div></figure><p id="2dba" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">当我们推送存储库中已经存在的标签时，它将被分配给新推送的图像，正如我们在上面的<code class="fe mq mr ms mg b">latest</code>标签中看到的。</p><p id="47d5" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在让我们回到我们的DIND容器，再次运行<code class="fe mq mr ms mg b">$ docker run thatisuday/version</code>命令。你期望什么样的结果？</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi os"><img src="../Images/44edbc869191e82b5f970911d88c8670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*667YUZJvdiK7Cv3rWPkOCw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker运行</figcaption></figure><p id="a1dc" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">因为我们已经有了<code class="fe mq mr ms mg b">thatisuday/version:latest</code>图像，Docker不会再从注册表中取出它，这就是为什么我们仍然会看到<code class="fe mq mr ms mg b">v1.0.0</code>输出。为了下载更新的版本，我们需要使用<code class="fe mq mr ms mg b">$ docker pull</code>命令再次拉这个标签(<em class="mw">图像</em>)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi os"><img src="../Images/bd47bef1f739a566c938080679799ec3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XRBqmyLlJvxMGlg7ieOSQg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$码头工人拉动</figcaption></figure><p id="c5b0" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在，当我们拉动<code class="fe mq mr ms mg b">thatisuday/version:latest</code>标签时，原来有<code class="fe mq mr ms mg b">latest</code>标签的旧图像变得摇摆不定。但是现在我们可以看到从<code class="fe mq mr ms mg b">thatisuday/version:latest</code>图像创建容器时的<code class="fe mq mr ms mg b">v1.0.1</code>输出。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="9de8" class="mk ml it bd li oi oj dn np ok ol dp nt ls om on nv lw oo op nx ma oq or nz iz bi translated">提示和技巧</h2><ul class=""><li id="4c1e" class="ot ou it ll b lm ob lp oc ls ov lw ow ma ox me oy oz pa pb bi translated">如果您想从Docker Hub中删除一个标签或存储库，您应该能够从存储库的<code class="fe mq mr ms mg b">Tags</code>部分执行此操作。</li><li id="5bea" class="ot ou it ll b lm pc lp pd ls pe lw pf ma pg me oy oz pa pb bi translated">如果您想要发布所有存储库的所有标签，使用带有<code class="fe mq mr ms mg b">$ docker push</code>命令的<code class="fe mq mr ms mg b">--all-tags</code>或<code class="fe mq mr ms mg b">-a</code>标志。</li><li id="b61a" class="ot ou it ll b lm pc lp pd ls pe lw pf ma pg me oy oz pa pb bi translated">如果您将存储库设为私有，那么您应该向存储库添加成员，他们将从存储库的<code class="fe mq mr ms mg b">Collaborators</code>部分下载您的图像。他们需要使用<code class="fe mq mr ms mg b">$ docker login</code>命令登录，然后才能使用<code class="fe mq mr ms mg b">$ docker pull</code>命令。</li><li id="5627" class="ot ou it ll b lm pc lp pd ls pe lw pf ma pg me oy oz pa pb bi translated">如果您想私下共享Docker图像，您可以使用<code class="fe mq mr ms mg b">$ docker <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/save/" rel="noopener ugc nofollow" target="_blank">save</a></code>命令将Docker图像保存为tarball文件。稍后，有人可以使用<code class="fe mq mr ms mg b">$ docker <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/import/" rel="noopener ugc nofollow" target="_blank">import</a></code>命令从这个tarball文件或指向这个tarball的URL导入Docker图像。</li></ul></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/e3da3bf1cee07cd997d46904bbbf70b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t4VSpLEAu4Gmg-GweZ3RvA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(<a class="ae lh" href="http://thatisuday.com" rel="noopener ugc nofollow" target="_blank"><strong class="bd li">【thatisuday.com】</strong></a>/<a class="ae lh" href="https://github.com/thatisuday" rel="noopener ugc nofollow" target="_blank"><strong class="bd li">GitHub</strong></a>/<a class="ae lh" href="https://twitter.com/thatisuday" rel="noopener ugc nofollow" target="_blank"><strong class="bd li">Twitter</strong></a>/<a class="ae lh" href="https://stackoverflow.com/users/2790983/uday-hiwarale" rel="noopener ugc nofollow" target="_blank"><strong class="bd li">stack overflow</strong></a><strong class="bd li"/>/<a class="ae lh" href="https://www.instagram.com/thatisuday/" rel="noopener ugc nofollow" target="_blank"><strong class="bd li">insta gram</strong></a>)</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/fdebb498630e863a0129025be5b74fb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/1*Cj3GjJSU7reYw49BYdQfpw.gif"/></div></figure></div></div>    
</body>
</html>