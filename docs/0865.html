<html>
<head>
<title>Learning Iterability by Reverse Engineering jQuery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过逆向工程jQuery学习可迭代性</h1>
<blockquote>原文：<a href="https://itnext.io/learning-iterability-by-reverse-engineering-jquery-b6c05b2f0f9?source=collection_archive---------10-----------------------#2018-06-10">https://itnext.io/learning-iterability-by-reverse-engineering-jquery-b6c05b2f0f9?source=collection_archive---------10-----------------------#2018-06-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fa53d56eecc8f9b825f187acc23e4e34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CnX8khPOR5Uj9s5Ua5lTmg.jpeg"/></div></div></figure><p id="26b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我记得我第一次使用jQuery时，我对仅仅使用CSS选择器和一些链接方法就能操作大量DOM元素感到敬畏。当时我不知道jQuery如何解析类似于<code class="fe kw kx ky kz b">div .button &gt; a.external</code>的东西来找到适合选择器的元素，或者允许我一个接一个地链接方法来与这些元素交互。我喜欢能够写作</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="90a5" class="li lj iq kz b gy lk ll l lm ln">$(...).addClass(...)<br/>    .append(...)<br/>    .attr(...)<br/>    .on(...);</span></pre><p id="c720" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在JavaScript世界呆了很长时间后，我仍然发现jQuery是一个非常有趣的库，但是现在的原因与我第一次使用它时完全不同。</p><p id="a51f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我后来发现jQuery有趣的一点是，<code class="fe kw kx ky kz b">$(...)</code>生成的东西实际上并不是一个数组。在控制台中键入<code class="fe kw kx ky kz b">$("html")</code>将产生类似于</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="47f4" class="li lj iq kz b gy lk ll l lm ln">► n.fn.init [html, prevObject: n.fn.init]</span></pre><p id="2587" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然由于控制台中使用的括号符号，它看起来像一个数组，但在这个输出上调用<code class="fe kw kx ky kz b">Array.isArray()</code>确认它确实不是。事实上，它只是一个对象(因为怀疑它以<code class="fe kw kx ky kz b">n.fn.init</code>开头，这表明它是某个构造函数的结果)，并且<code class="fe kw kx ky kz b">Object.prototype.toString.call()</code>告诉我们它是<code class="fe kw kx ky kz b">[object Object]</code>。</p><p id="2262" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个小小的奇怪之处引出了一些有趣的问题，尤其是当DOM元素不是数组时，jQuery如何遍历其属性来操作DOM元素。研究这是如何可能的把我带到了迭代器的话题上。因此，在这篇文章中，我们将对jQuery的一个简单版本进行逆向工程，来讨论可迭代性以及一些更小的问题，比如对象如何像数组一样在控制台中显示。</p><h1 id="6f03" class="lo lj iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">迭代性</h1><p id="1596" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">在开始之前，我们应该问:什么是可迭代性？</p><p id="e36f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可迭代性是对象指定如何以编程方式访问其数据的一种方式。具体来说，我们指的是JavaScript引擎如何使用<code class="fe kw kx ky kz b">for...of</code>循环、<code class="fe kw kx ky kz b">...</code> (spread)操作符或<code class="fe kw kx ky kz b">Array.from()</code>来访问值。</p><p id="fddb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一些JavaScript对象内置了可迭代性。使用上述技术，字符串、数组、映射和集合都可以轻松地访问数据。因此，我们可以编写以下代码并获得有效的输出:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="0ede" class="li lj iq kz b gy lk ll l lm ln">const str = "abc";<br/>for (const letter of str) {<br/>    console.log(letter);     // prints "a", "b", "c"<br/>}</span><span id="7062" class="li lj iq kz b gy mq ll l lm ln">const arr = [ 1, 2, 3 ];<br/>for (const elem of arr) {<br/>    console.log(elem);      // prints 1, 2, 3<br/>}</span><span id="d020" class="li lj iq kz b gy mq ll l lm ln">const map = new Map();<br/>map.set("first", 1);<br/>map.set("second", 2);<br/>for (const mapping of map) {<br/>    console.log(mapping);   // prints ["first", 1], ["second", 2]<br/>}</span><span id="f676" class="li lj iq kz b gy mq ll l lm ln">const set = new Set();<br/>set.add("first");<br/>set.add("second");<br/>for (const elem of set) {<br/>    console.log(elem);      // prints "first", "second"<br/>}</span></pre><p id="cf72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，我们不能用常规对象如<code class="fe kw kx ky kz b">person = { name: "Albert Einstein", age: 139 }</code>或<code class="fe kw kx ky kz b">arrayLike = { 0: "We", 1: "can't", 2: "iterate", 3: "this" }</code>开箱即用。那么，我们如何使普通对象可迭代呢？</p><p id="b91f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在过去几年对JavaScript的一些Python风格的增强中，实现的特性之一是一个<code class="fe kw kx ky kz b">Symbol.iterator</code>全局常量。通过在我们的对象中使用这个作为方法的名称，我们可以创建一个函数来指定使用<code class="fe kw kx ky kz b">for...of</code>等遍历对象数据的行为。我们将利用这一点来实现我们的jQuery-lite功能。</p><h1 id="25f3" class="lo lj iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">作用域jQuery-lite</h1><p id="c7ea" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">那么，我们想要实现什么呢？为了简单起见，我们将只构建一种方法来查询给定CSS选择器的DOM，并且我们将我们可以执行的方法限制为上面列出的<code class="fe kw kx ky kz b">addClass</code>、<code class="fe kw kx ky kz b">append</code>、<code class="fe kw kx ky kz b">attr</code>和<code class="fe kw kx ky kz b">on</code>。</p><p id="d9a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还将创建一个类似于<code class="fe kw kx ky kz b">$()</code>的函数，它接受CSS选择器字符串或类似数组的对象，并返回我们的jQuery类的一个实例。</p><p id="0452" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们这样做是为了说明JavaScript的可迭代特性，所以我们不会使用数组(或数组的子类)来充当jQuery对象，因为这些对象本来就是可迭代的，不会教给我们任何东西。此外，它们开放了jQuery没有的数组方法，这些方法对于DOM操作没有任何意义(例如<code class="fe kw kx ky kz b">.reduce()</code>)。</p><p id="03db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，让我们首先设置我们将要充实的类框架:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="ac6e" class="li lj iq kz b gy lk ll l lm ln">class JQ {<br/>    constructor(list) {<br/>        let i = 0;</span><span id="9d55" class="li lj iq kz b gy mq ll l lm ln">        while (list[i] !== undefined) {<br/>            this[i] = list[i];<br/>            i++;<br/>        }<br/>    }</span><span id="87df" class="li lj iq kz b gy mq ll l lm ln">    addClass(className) { ... }<br/>    append(content) { ... }<br/>    attr(name, val) { ... }<br/>    on(event, handler) { ... }<br/>}</span><span id="359a" class="li lj iq kz b gy mq ll l lm ln">const $$ = input =&gt; {<br/>    if (typeof input === "string") {<br/>        const nodes = document.querySelectorAll(input);<br/>        return new JQ(nodes);<br/>    }</span><span id="04bc" class="li lj iq kz b gy mq ll l lm ln">    return new JQ(input);<br/>}</span></pre><p id="131b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目前这还不是一个可迭代的对象，但是我们已经开始打基础了。在构造函数中，我们接受一个列表参数(由我们的基本<code class="fe kw kx ky kz b">$$</code>函数计算得到，或者是对应于CSS选择器的HTML元素列表，或者是先前的JQ实例),并使用列表中的索引作为属性键，将每一项指定为JQ类的属性。</p><p id="5d16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我们如何使它可迭代呢？只需将我们的<code class="fe kw kx ky kz b">Symbol.iterator</code>方法添加到我们的JQ类中:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="dc1f" class="li lj iq kz b gy lk ll l lm ln">    [Symbol.iterator]() {<br/>        let i = 0;<br/>        const _this = this;</span><span id="5a8e" class="li lj iq kz b gy mq ll l lm ln">        return {<br/>            next() {<br/>                return _this[i]<br/>                    ? { done: false, value: _this[i++] }<br/>                    : { done: true };<br/>            }<br/>        }<br/>    }</span></pre><p id="53d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们首先创建一个闭包，它将存储一个变量<code class="fe kw kx ky kz b">i</code>和一个对<code class="fe kw kx ky kz b">this</code>的引用，我们将使用它来遍历所有JQ实例的属性，我们希望在其他方法中循环遍历这些属性。</p><p id="e567" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，真正的魔力发生在<code class="fe kw kx ky kz b">return</code>条款中。我们返回的对象有一个<code class="fe kw kx ky kz b">next()</code>方法，只要<code class="fe kw kx ky kz b">next()</code>返回一个带有<code class="fe kw kx ky kz b">done: false</code>属性的对象，JavaScript引擎就会不断调用这个方法。同一个对象将包含一个来自我们的JQ实例的值，当我们最终用完要挑选的值时，我们标记<code class="fe kw kx ky kz b">done: true</code>。</p><p id="11cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，让我们使用新的可迭代性功能来为剩下的方法添加逻辑</p><h1 id="e208" class="lo lj iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">利用可迭代性</h1><p id="a3e8" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">我们将用来充实JQ方法的代码非常简单。我写它的方式将展示我们的可迭代性将被使用的两种方式，虽然它可能不是最好的生产目的，但它对教学是好的。我们充实后的类如下所示:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="9253" class="li lj iq kz b gy lk ll l lm ln">class JQ {<br/>    constructor(list) {<br/>        let i = 0;</span><span id="f2d7" class="li lj iq kz b gy mq ll l lm ln">        while (list[i] !== undefined) {<br/>            this[i] = list[i];<br/>            i++;<br/>        }<br/>    }</span><span id="6cff" class="li lj iq kz b gy mq ll l lm ln">    addClass(className) {<br/>        for (const elem of this) {<br/>            elem.classList.add(className);<br/>        }</span><span id="d4d3" class="li lj iq kz b gy mq ll l lm ln">        return $$([ ...this ]);<br/>    }</span><span id="3b3d" class="li lj iq kz b gy mq ll l lm ln">    append(content) {<br/>        for (const elem of this) {<br/>            elem.append(content.cloneNode());<br/>        }</span><span id="1080" class="li lj iq kz b gy mq ll l lm ln">        return $$([ ...this ]);<br/>    }</span><span id="f53d" class="li lj iq kz b gy mq ll l lm ln">    attr(name, val) {<br/>        for (const elem of this) {<br/>            elem.setAttribute(name, val);<br/>        }</span><span id="c882" class="li lj iq kz b gy mq ll l lm ln">        return $$([ ...this ]);<br/>    }</span><span id="11a6" class="li lj iq kz b gy mq ll l lm ln">    on(event, handler) {<br/>        for (const elem of this) {<br/>            elem.addEventListener(event, handler);<br/>        }</span><span id="b24a" class="li lj iq kz b gy mq ll l lm ln">        return $$([ ...this ]);<br/>    }</span><span id="2545" class="li lj iq kz b gy mq ll l lm ln">    [Symbol.iterator]() {<br/>        let i = 0;<br/>        const _this = this;</span><span id="ac4a" class="li lj iq kz b gy mq ll l lm ln">        return {<br/>            next() {<br/>                return _this[i]<br/>                    ? { done: false, value: _this[i++] }<br/>                    : { done: true };<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="98fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每种方法都使用了<code class="fe kw kx ky kz b">for...of</code>循环和<code class="fe kw kx ky kz b">...</code>操作符。因为我们有迭代器方法，这两个都可以。这就是让你的对象可迭代的全部内容，但是我们还可以用我们的类做一些更有趣的事情。</p><h1 id="2e85" class="lo lj iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">奖励:数组欺骗</h1><p id="619e" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">现在，如果我们将一个JQ实例记录到控制台，它将像一个对象通常会做的那样打印出来。如前所述，jQuery对象不会。那么我们如何强迫一个对象以数组的形式输出呢？</p><p id="dcbb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要做到这一点，只需要满足两个要求:一个<code class="fe kw kx ky kz b">length</code>属性和一个<code class="fe kw kx ky kz b">splice()</code>方法。所以赶紧补充那些吧。为了保持简洁，我们将只修改构造函数(添加长度)并添加拼接方法。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="459f" class="li lj iq kz b gy lk ll l lm ln">class JQ {<br/>    constructor(list) {<br/>        let i = 0;</span><span id="c267" class="li lj iq kz b gy mq ll l lm ln">        while (list[i] !== undefined) {<br/>            this[i] = list[i];<br/>            i++;<br/>        }<br/>        <br/>        this.length = i;<br/>    }<br/>    <br/>    splice(...args) {<br/>        return [ ...this ].splice(...args);<br/>    }<br/>}</span></pre><p id="81d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是我们要做的！现在它将打印为</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="f35f" class="li lj iq kz b gy lk ll l lm ln">► JQ [ ... ]</span></pre><h1 id="9e04" class="lo lj iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">奖励:使用发电机</h1><p id="5389" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">我们可以通过为生成器函数切换出我们的<code class="fe kw kx ky kz b">Symbol.iterator</code>方法来简化我们的类所使用的代码量。简单地说，一个生成器函数返回一个生成器对象，它实现了我们上面手工实现的迭代器规则。</p><p id="c6f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">发电机有三个特别之处:</p><ol class=""><li id="e9a9" class="mr ms iq ka b kb kc kf kg kj mt kn mu kr mv kv mw mx my mz bi translated">它们使用<code class="fe kw kx ky kz b">yield</code>关键字将值传递给调用函数。</li><li id="b392" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">他们会在通话间隙记住自己的状态。</li><li id="1ead" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">他们在声明中使用了一个<code class="fe kw kx ky kz b">*</code>。</li></ol><p id="6cd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们来交换一下。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="6617" class="li lj iq kz b gy lk ll l lm ln">class JQ {<br/>    constructor(list) {<br/>        let i = 0;</span><span id="7d9a" class="li lj iq kz b gy mq ll l lm ln">        while (list[i] !== undefined) {<br/>            this[i] = list[i];<br/>            i++;<br/>        }<br/>    }<br/>    <br/>    *generator() {<br/>        for (let i = 0; i &lt; this.length; i++) {<br/>            yield this[i];<br/>        }<br/>    }<br/>}</span></pre><p id="20c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，现在我们以前的所有方法都被破坏了，因为它们需要迭代器来执行它们的值，而生成器即使实现了它们也不是迭代器。如果我们现在尝试在JQ对象上调用<code class="fe kw kx ky kz b">.addClass()</code>，我们会得到下面的错误:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="1e18" class="li lj iq kz b gy lk ll l lm ln">Uncaught TypeError: this is not iterable</span></pre><p id="d409" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么我们需要做什么呢？我们需要修改我们的其他方法来使用我们的<code class="fe kw kx ky kz b">*generator()</code>。一般来说，如果我们做<code class="fe kw kx ky kz b">const genObj = generator()</code>，我们会得到一个<em class="nf">是</em>可迭代的对象。因此，我们将在每个方法中添加一行额外的代码，并更改两行代码。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="637c" class="li lj iq kz b gy lk ll l lm ln">class JQ {<br/>    constructor(list) {<br/>        let i = 0;</span><span id="6b86" class="li lj iq kz b gy mq ll l lm ln">        while (list[i] !== undefined) {<br/>            this[i] = list[i];<br/>            i++;<br/>        }<br/>    }<br/>    <br/>    *generator() {<br/>        for (let i = 0; i &lt; this.length; i++) {<br/>            yield this[i];<br/>        }<br/>    }</span><span id="ed12" class="li lj iq kz b gy mq ll l lm ln">    addClass(className) {<br/>        const iterable = this.generator();<br/>        <br/>        for (const elem of iterable) {<br/>            elem.classList.add(className);<br/>        }</span><span id="0ec6" class="li lj iq kz b gy mq ll l lm ln">        return $$([ ...this.generator() ]);<br/>    }<br/>}</span></pre><p id="db4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们调用<code class="fe kw kx ky kz b">this.generator()</code>来获得一个可迭代的生成器对象，这允许我们使用<code class="fe kw kx ky kz b">for...of</code>循环。我们还必须在我们的<code class="fe kw kx ky kz b">return</code>语句中再次调用它，因为生成器对象是一次性使用的对象，如果我们重用它，我们将没有数据提供给<code class="fe kw kx ky kz b">$$</code>函数。</p><p id="e7eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是我们如何使用生成器函数来简化我们自己的可迭代性逻辑(代价是我们的方法中多了一点代码)。</p><p id="ee81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我留下以下两个要点来展示我们的JQ类使用<code class="fe kw kx ky kz b">Symbol.iterator</code>和生成器方法的完整实现，以及一个到更技术性的可迭代性解释的链接。</p><ul class=""><li id="bfcc" class="mr ms iq ka b kb kc kf kg kj mt kn mu kr mv kv ng mx my mz bi translated"><a class="ae nh" href="https://gist.github.com/ryandabler/e0916a9454aa42af28c05a981df6d28e" rel="noopener ugc nofollow" target="_blank">要诀运用</a> <code class="fe kw kx ky kz b"><a class="ae nh" href="https://gist.github.com/ryandabler/e0916a9454aa42af28c05a981df6d28e" rel="noopener ugc nofollow" target="_blank">Symbol.iterator</a></code></li><li id="8fbb" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv ng mx my mz bi translated"><a class="ae nh" href="https://gist.github.com/ryandabler/083c34eab2009d0a01ff6b3fd8b44fa1" rel="noopener ugc nofollow" target="_blank">使用发电机法的要诀</a></li><li id="2a49" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv ng mx my mz bi translated">关于迭代器和生成器的好文章</li></ul></div></div>    
</body>
</html>