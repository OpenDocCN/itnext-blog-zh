<html>
<head>
<title>Implementing a simple indexing algorithm in golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用golang实现一个简单的索引算法</h1>
<blockquote>原文：<a href="https://itnext.io/implementing-a-simple-indexing-algorithm-in-golang-c65be7eaa563?source=collection_archive---------5-----------------------#2019-12-21">https://itnext.io/implementing-a-simple-indexing-algorithm-in-golang-c65be7eaa563?source=collection_archive---------5-----------------------#2019-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fbfc3bb3ae9e91f0dd71b5e2626431ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1GPpoTsuWeyabp7f"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">安东尼·马蒂诺在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="f7a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在过去的几周里，我在做一个兼职项目，让outlook会议预约变得更加容易。</p><p id="998f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我开始在golang 做一个简单的<a class="ae kc" href="https://github.com/mhewedy/mego" rel="noopener ugc nofollow" target="_blank"> MS交流会组织者(为什么是golang，因为我是新手，需要多练习)。</a></p><p id="68f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我已经在一个<a class="ae kc" href="https://github.com/mhewedy/ews" rel="noopener ugc nofollow" target="_blank">单独的仓库</a>中实现了EWS (Exchange Web服务)客户端，并将主项目放在另一个<a class="ae kc" href="https://github.com/mhewedy/mego" rel="noopener ugc nofollow" target="_blank">仓库</a>中</p><p id="d130" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我已经完成了大部分工作，除了一件重要的事情，如何搜索联系人的名字？</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/e8b8233a2a7c1cd4f973fcb5a4f4577c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E7PlzwL15KumgRH0e3-sQw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">MEGO中的搜索界面</figcaption></figure><p id="16d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">几年前，我们在用Java做全文搜索，当时我和一位杰出的软件架构师一起工作，他向我们介绍了Apache Lucene。</p><p id="25fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Lucene使用了倒排索引的思想，在倒排索引中，令牌以链接到保存相关结果的文档的方式存储。所以我决定用同样的想法做一个简单的实现。</p><blockquote class="lg lh li"><p id="aee4" class="kd ke lj kf b kg kh ki kj kk kl km kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated">我将使用所谓的<strong class="kf ir"> N-grams </strong>来将文本分成<strong class="kf ir">索引时间</strong>可搜索项。</p></blockquote></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="11ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我的例子中的数据不是很大，可能有几千个联系人，所以我决定将索引保存在内存中(作为包级别的变量):</p><pre class="lc ld le lf gt lu lv lw lx aw ly bi"><span id="c6dc" class="lz ma iq lv b gy mb mc l md me">var indexDB = make(map[token][]*Attendee)</span></pre><p id="1190" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是<strong class="kf ir">索引</strong>函数的实现:</p><pre class="lc ld le lf gt lu lv lw lx aw ly bi"><span id="12d6" class="lz ma iq lv b gy mb mc l md me">func index(attendees []Attendee) {<br/>    for i, aa := range attendees {</span><span id="0236" class="lz ma iq lv b gy mf mc l md me">        // index the DisplayName field<br/>        doOnToken(aa.DisplayName, func(t token) []Attendee {<br/>            indexToken(t, &amp;attendees[i])<br/>            return nil<br/>        })</span><span id="5c3d" class="lz ma iq lv b gy mf mc l md me">        // index the EmailAddress field<br/>        email := strings.Split(aa.EmailAddress, "@")[0]<br/>        doOnToken(email, func(t token) []Attendee {<br/>             indexToken(t, &amp;attendees[i])<br/>             return nil<br/>        })<br/>    }<br/>}</span></pre><p id="ff2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在这里索引<strong class="kf ir">display name</strong>和<strong class="kf ir"> EmailAddress </strong>字段，所以对于其中的每一个字段，我们调用<strong class="kf ir"> doOnToken </strong>函数，该函数将其输入转换为<strong class="kf ir"> Token </strong>，然后对每个token执行<strong class="kf ir"> indexToken </strong>。</p><blockquote class="lg lh li"><p id="4ed5" class="kd ke lj kf b kg kh ki kj kk kl km kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated">注意，<strong class="kf ir"> doOnToken </strong>函数是在索引和搜索的输入上调用的，因此被索引的相同输入也将被搜索。</p></blockquote><pre class="lc ld le lf gt lu lv lw lx aw ly bi"><span id="6cab" class="lz ma iq lv b gy mb mc l md me">func doOnToken(input string, fn func(t token) []Attendee) [][]Attendee {</span><span id="a3c8" class="lz ma iq lv b gy mf mc l md me">    lower := strings.ToLower(input)<br/>    clear := substituteVowels(lower)<br/>    fields := strings.Fields(clear)</span><span id="1c0d" class="lz ma iq lv b gy mf mc l md me">    ii := make([][]Attendee, 0)</span><span id="7721" class="lz ma iq lv b gy mf mc l md me">    for _, field := range fields {<br/>        tokens := tokenize(field, 4)</span><span id="a098" class="lz ma iq lv b gy mf mc l md me">        for _, t := range tokens {<br/>            ii = append(ii, fn(t))<br/>        }<br/>    }<br/>    return ii<br/>}</span></pre><p id="ca55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在doOnToken函数中有3个过滤器，lower、substituteVowels和fields过滤器，分别用于降低、替换元音和在空间上分割。</p><blockquote class="lg lh li"><p id="229a" class="kd ke lj kf b kg kh ki kj kk kl km kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated">起初，该算法用于完全删除元音，结果不太好，但在一个朋友的建议下，我用替换元音来代替，所以每当doOnToken函数表示的索引器/搜索器遇到“a”、“e”或“u”时，我就用“e”来替换，每当遇到“o”或“u”时，就用“o”来替换。</p></blockquote><p id="a88f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该索引现在应该包含如下数据:</p><pre class="lc ld le lf gt lu lv lw lx aw ly bi"><span id="63ae" class="lz ma iq lv b gy mb mc l md me">moh =&gt; [mohammad, mohannad ...] <br/>mad =&gt; [mohammad, emad, ...]<br/>han =&gt; [hanan, mohannad, ...]<br/>....</span></pre></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="da7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们来看看搜索函数，它既简单又高效，它使用相同的doOnToken函数来计算令牌，然后因为我们的<strong class="kf ir"> indexDB </strong> index是基于散列表的，所以检索操作应该和<strong class="kf ir"> <em class="lj"> O(1) </em> </strong>一样快。</p><pre class="lc ld le lf gt lu lv lw lx aw ly bi"><span id="dc4e" class="lz ma iq lv b gy mb mc l md me">func search(input string) []Attendee {</span><span id="54ae" class="lz ma iq lv b gy mf mc l md me">    temp := doOnToken(input, func(t token) []Attendee {<br/>        attendees := indexDB[t]<br/>        result := make([]Attendee, len(attendees))<br/>        for i, a := range attendees {<br/>            result[i] = *a<br/>        }<br/>        return result<br/>    })</span><span id="0278" class="lz ma iq lv b gy mf mc l md me">    return sortByOccurrence(temp)<br/>}</span></pre><p id="d088" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里一个棘手的部分是，我们通过事件搜索结果。例如，如果我们有以下结果:</p><pre class="lc ld le lf gt lu lv lw lx aw ly bi"><span id="d462" class="lz ma iq lv b gy mb mc l md me">moh =&gt; [mohammad, mohannad] <br/>mad =&gt; [mohammad, emad, ahmad]</span></pre><p id="ca50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，输出将按出现次数排序，因此结果将排序为:</p><pre class="lc ld le lf gt lu lv lw lx aw ly bi"><span id="440b" class="lz ma iq lv b gy mb mc l md me">mohammad<br/>emad<br/>ahmad</span></pre><p id="0d3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">能够省略出现次数&lt; n.</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="a827" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Here’s the full implementation of the indexer:</p><div class="mg mh gp gr mi mj"><a href="https://github.com/mhewedy/mego/blob/5607bad4b5fd8c07312e43dd07281fa40c153cc8/mego-api/attendess/indexer.go" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd ir gy z fp mo fr fs mp fu fw ip bi translated">mhewedy/mego</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">You can't perform that action at this time. You signed in with another tab or window. You signed out in another tab or…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">github.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx jw mj"/></div></div></a></div><p id="c5a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://github.com/mhewedy/mego" rel="noopener ugc nofollow" target="_blank">https://github.com/mhewedy/mego</a>的名字</p></div></div>    
</body>
</html>