<html>
<head>
<title>Writing custom Widgets in Flutter (Part 1) — EllipsizedText</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Flutter中编写定制小部件(第1部分)——ellipsized text</h1>
<blockquote>原文：<a href="https://itnext.io/writing-custom-widgets-in-flutter-part-1-ellipsizedtext-a0efdc1368a8?source=collection_archive---------3-----------------------#2021-05-27">https://itnext.io/writing-custom-widgets-in-flutter-part-1-ellipsizedtext-a0efdc1368a8?source=collection_archive---------3-----------------------#2021-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8e030c4e44c18748f20542e56271fd7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dFYac8EFMVpNLOIuLoyZDw.png"/></div></div></figure><h1 id="a183" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="6187" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Flutter中的声明式UI非常漂亮，易于使用，而且尽可能多地使用它是非常诱人的。但是开发人员经常会过度使用它——以声明的方式编写所有内容，即使有时任务可以更有效地完成，并且以更命令的方式更容易理解。</p><p id="fd75" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">每个人都应该明白的是——声明式和命令式编程之间必须保持平衡。每个人都有自己的用途，每个人在一些任务上比其他人更出色。</p><p id="9128" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这一系列文章中，我将描述如何通过从头开始创建自定义小部件来解决不同的问题。每一个都比前一个复杂一点。</p><h1 id="afa0" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">快速理论</h1><p id="6f04" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在看代码之前，我们需要知道一些基本的东西。</p><p id="c278" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">Widget</code> —是一个不可变的(最好是常量)类，包含<code class="fe lz ma mb mc b">Elements</code>和<code class="fe lz ma mb mc b">RenderObjects</code>的配置属性。它还负责创建所述的<code class="fe lz ma mb mc b">Elements</code>和<code class="fe lz ma mb mc b">RenderObjects</code>。重要的是要理解——小部件从不包含状态或任何业务逻辑，只传递它们。</p><p id="1e9f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">Element</code> —是负责实际UI树的实体。它有对所有子节点的引用，也有对其父节点的引用(不像<code class="fe lz ma mb mc b">Widget</code>)。除非<code class="fe lz ma mb mc b">key</code>或<code class="fe lz ma mb mc b">Widget</code>被改变，否则<code class="fe lz ma mb mc b">Elements</code>大部分时间都被重用。因此，如果只改变了<code class="fe lz ma mb mc b">Widget</code>的属性，即使分配了新的<code class="fe lz ma mb mc b">Widget</code>，<code class="fe lz ma mb mc b">Element</code>也将保持不变。</p><p id="1872" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">State</code> —只不过是<code class="fe lz ma mb mc b">Element</code>中的一个用户定义的类，它也有一些来自其<code class="fe lz ma mb mc b">Element</code>的回调。</p><p id="4a86" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">RenderObject</code> —负责实际尺寸计算、儿童放置、绘图、触摸事件处理等。这些对象与Android或其他框架中的经典<code class="fe lz ma mb mc b">Views</code>非常相似。</p><p id="17d0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为什么我们同时有<code class="fe lz ma mb mc b">Elements</code>和<code class="fe lz ma mb mc b">RenderObjects</code>？因为效率。每个<code class="fe lz ma mb mc b">Widget</code>都有各自的<code class="fe lz ma mb mc b">Element</code>，但只有部分有<code class="fe lz ma mb mc b">RenderObjects</code>。由于这一点，许多布局，触摸和其他层次遍历调用可以省略。</p><h1 id="dceb" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">密码</h1><p id="0a12" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">第一个例子是一个非常简单的小部件，当文本不合适时，它会将其省略。你可能会问，当内置文本已经支持省略号时，我们为什么还需要这样一个小部件？答案很简单——从现在开始，它只按单词而不是按字符进行切割(<a class="ae md" href="https://github.com/flutter/flutter/issues/18761" rel="noopener ugc nofollow" target="_blank">https://github.com/flutter/flutter/issues/18761</a>)。因此，如果你在最后有一个很长的单词，大多数时候你只会看到这个单词的第一个字母，即使还有很多空间可以填充。</p><p id="f696" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们开始吧。Flutter有很多内置的基类和mixins，可以帮助构建完全自定义的小部件。以下是其中的几个:</p><ul class=""><li id="8238" class="me mf iq ky b kz lu ld lv lh mg ll mh lp mi lt mj mk ml mm bi translated">LeafRenderObjectWidget没有子项</li><li id="5a36" class="me mf iq ky b kz mn ld mo lh mp ll mq lp mr lt mj mk ml mm bi translated">SingleChildRenderObjectWidget有一个子对象</li><li id="4006" class="me mf iq ky b kz mn ld mo lh mp ll mq lp mr lt mj mk ml mm bi translated">MultiChildRenderObjectWidget具有任意数量的子级</li></ul><p id="fdd5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在我们的例子中，我们将使用LeafRenderObjectWidget，因为我们只需要呈现文本，并且没有子元素:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="3125" class="na jz iq mc b gy nb nc l nd ne"><strong class="mc ir">enum </strong>Ellipsis { <strong class="mc ir">start</strong>, <strong class="mc ir">middle</strong>, <strong class="mc ir">end </strong>}<br/><br/><strong class="mc ir">class </strong>EllipsizedText <strong class="mc ir">extends </strong>LeafRenderObjectWidget {<br/>  <strong class="mc ir">final </strong>String <strong class="mc ir">text</strong>;<br/>  <strong class="mc ir">final </strong>TextStyle? <strong class="mc ir">style</strong>;<br/>  <strong class="mc ir">final </strong>Ellipsis <strong class="mc ir">ellipsis</strong>;<br/><br/>  <strong class="mc ir">const </strong>EllipsizedText(<br/>    <strong class="mc ir">this</strong>.<strong class="mc ir">text</strong>, {<br/>    Key? key,<br/>    <strong class="mc ir">this</strong>.<strong class="mc ir">style</strong>,<br/>    <strong class="mc ir">this</strong>.<strong class="mc ir">ellipsis </strong>= Ellipsis.<strong class="mc ir">end</strong>,<br/>  }) : <strong class="mc ir">super</strong>(key: key);<br/><br/>  @override<br/>  RenderObject createRenderObject(BuildContext context) {<br/>    <strong class="mc ir">return </strong>RenderEllipsizedText()..<strong class="mc ir">widget </strong>= <strong class="mc ir">this</strong>;<br/>  }<br/><br/>  @override<br/>  <strong class="mc ir">void </strong>updateRenderObject(BuildContext context, RenderEllipsizedText renderObject) {<br/>    renderObject.<strong class="mc ir">widget </strong>= <strong class="mc ir">this</strong>;<br/>  }<br/>}</span></pre><p id="928b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们已经创建了我们的小部件。唯一不同寻常的是存在两种方法:</p><ul class=""><li id="6546" class="me mf iq ky b kz lu ld lv lh mg ll mh lp mi lt mj mk ml mm bi translated">createRenderObject —负责实际创建我们的RenderObject</li><li id="e9b5" class="me mf iq ky b kz mn ld mo lh mp ll mq lp mr lt mj mk ml mm bi translated">updateRenderObject当微件的数据发生变化但RenderObject保持不变时将被调用。在这种情况下，我们需要更新RenderObject中的数据，否则它将呈现旧文本。</li></ul><p id="c737" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我还需要注意，最好将每个值从小部件复制到RenderObject。但是我会传递整个小部件，因为它们无论如何都是不可变的(我也懒得写那些样板代码)。</p><p id="c0a1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在让我们从实际的RenderObject开始:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="3b3c" class="na jz iq mc b gy nb nc l nd ne"><strong class="mc ir">class </strong>RenderEllipsizedText <strong class="mc ir">extends </strong>RenderBox {<br/>  <strong class="mc ir">var _widgetChanged </strong>= <strong class="mc ir">false</strong>;<br/>  <strong class="mc ir">var _widget </strong>= <strong class="mc ir">const </strong>EllipsizedText(<strong class="mc ir">''</strong>);<br/><br/>  <strong class="mc ir">set widget</strong>(EllipsizedText widget) {<br/>    <strong class="mc ir">if </strong>(<strong class="mc ir">_widget</strong>.<strong class="mc ir">text </strong>== widget.<strong class="mc ir">text </strong>&amp;&amp;<br/>        <strong class="mc ir">_widget</strong>.<strong class="mc ir">style </strong>== widget.<strong class="mc ir">style </strong>&amp;&amp;<br/>        <strong class="mc ir">_widget</strong>.<strong class="mc ir">ellipsis </strong>== widget.<strong class="mc ir">ellipsis</strong>) {<br/>      <strong class="mc ir">return</strong>;<br/>    }<br/>    <strong class="mc ir">_widgetChanged </strong>= <strong class="mc ir">true</strong>;<br/>    <strong class="mc ir">_widget </strong>= widget;<br/>    markNeedsLayout();<br/>  }<br/>}</span></pre><p id="cb64" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这里我们定义了所有的变量，并编写了一个setter来更新它们。还有一个检查值是否真的改变了的安全措施——如果什么都没有改变，就不需要重新计算省略号和重新绘制文本。</p><p id="718c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在我们需要布局我们的RenderObject。</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="da2e" class="na jz iq mc b gy nb nc l nd ne"><strong class="mc ir">class </strong>RenderEllipsizedText <strong class="mc ir">extends </strong>RenderBox {<br/>  <em class="nf">// ...<br/> </em> <strong class="mc ir">var _constraints </strong>= <strong class="mc ir">const </strong>BoxConstraints();<br/><br/>  @override<br/>  <strong class="mc ir">void </strong>performLayout() {<br/>    <strong class="mc ir">if </strong>(!<strong class="mc ir">_widgetChanged </strong>&amp;&amp; <strong class="mc ir">_constraints </strong>== <strong class="mc ir">constraints </strong>&amp;&amp; <strong class="mc ir">hasSize</strong>) {<br/>      <strong class="mc ir">return</strong>;<br/>    }<br/><br/>    <strong class="mc ir">_widgetChanged </strong>= <strong class="mc ir">false</strong>;<br/>    <strong class="mc ir">_constraints </strong>= <strong class="mc ir">constraints</strong>;<br/><br/>    <strong class="mc ir">size </strong>=_ellipsize(<br/>      minWidth: <strong class="mc ir">constraints</strong>.<strong class="mc ir">minWidth</strong>,<br/>      maxWidth: <strong class="mc ir">constraints</strong>.<strong class="mc ir">maxWidth</strong>,<br/>    );<br/>  }<br/>}</span></pre><p id="cfaf" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">布局的过程非常简单。我们需要做的就是——根据提供给我们的约束计算RenderObject的大小。约束仅仅描述了我们必须遵守的最小和最大尺寸。此外，如果没有任何变化，并且在之前的布局过程中已经计算了尺寸，则增加额外的检查。</p><p id="ff01" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">创建椭圆化文本的实际过程相当繁琐，肯定有更好的解决方案，但我选择使用二分搜索法来找到最佳匹配。</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="3566" class="na jz iq mc b gy nb nc l nd ne"><strong class="mc ir">class </strong>RenderEllipsizedText <strong class="mc ir">extends </strong>RenderBox {<br/>  <em class="nf">// ...<br/>  </em><strong class="mc ir">final _textPainter </strong>= TextPainter(textDirection: TextDirection.<strong class="mc ir">ltr</strong>);<br/><br/>  Size _ellipsize({<strong class="mc ir">required </strong>double minWidth, <strong class="mc ir">required </strong>double maxWidth}) {<br/>    <strong class="mc ir">final </strong>text = <strong class="mc ir">_widget</strong>.<strong class="mc ir">text</strong>;<br/><br/>    <strong class="mc ir">if </strong>(_layoutText(length: text.<strong class="mc ir">length</strong>, minWidth: minWidth) &gt; maxWidth) {<br/>      <strong class="mc ir">var </strong>left = 0;<br/>      <strong class="mc ir">var </strong>right = text.<strong class="mc ir">length </strong>- 1;<br/><br/>      <strong class="mc ir">while </strong>(left &lt; right) {<br/>        <strong class="mc ir">final </strong>index = (left + right) ~/ 2;<br/>        <strong class="mc ir">if </strong>(_layoutText(length: index, minWidth: minWidth) &gt; maxWidth) {<br/>          right = index;<br/>        } <strong class="mc ir">else </strong>{<br/>          left = index + 1;<br/>        }<br/>      }<br/>      _layoutText(length: right - 1, minWidth: minWidth);<br/>    }<br/><br/>    <strong class="mc ir">return constraints</strong>.constrain(Size(<strong class="mc ir">_textPainter</strong>.<strong class="mc ir">width</strong>, <strong class="mc ir">_textPainter</strong>.<strong class="mc ir">height</strong>));<br/>  }<br/>}</span></pre><p id="3469" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我不会重复所有这些逻辑(如果你愿意，你可以从头到尾读一遍)。但重要的是，TextPainter是用来计算文本大小的。如果文本长度超过了我们的限制，我会尽量把它变得越来越短，直到它符合我们的限制。</p><p id="b413" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">_layoutText</code>用于计算我们裁剪的文本尺寸:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="2adf" class="na jz iq mc b gy nb nc l nd ne">double _layoutText({<strong class="mc ir">required </strong>int length, <strong class="mc ir">required </strong>double minWidth}) {<br/>  <strong class="mc ir">final </strong>text = <strong class="mc ir">_widget</strong>.<strong class="mc ir">text</strong>;<br/>  <strong class="mc ir">final </strong>style = <strong class="mc ir">_widget</strong>.<strong class="mc ir">style</strong>;<br/>  <strong class="mc ir">final </strong>ellipsis = <strong class="mc ir">_widget</strong>.<strong class="mc ir">ellipsis</strong>;<br/><br/>  String ellipsizedText = <strong class="mc ir">''</strong>;<br/><br/>  <strong class="mc ir">switch </strong>(ellipsis) {<br/>    <strong class="mc ir">case </strong>Ellipsis.<strong class="mc ir">start</strong>:<br/>      <strong class="mc ir">if </strong>(length &gt; 0) {<br/>        ellipsizedText = text.substring(text.<strong class="mc ir">length </strong>- length, text.<strong class="mc ir">length</strong>);<br/>        <strong class="mc ir">if </strong>(length != text.<strong class="mc ir">length</strong>) {<br/>          ellipsizedText = <strong class="mc ir">'...' </strong>+ ellipsizedText;<br/>        }<br/>      }<br/>      <strong class="mc ir">break</strong>;<br/>    <strong class="mc ir">case </strong>Ellipsis.<strong class="mc ir">middle</strong>:<br/>      <strong class="mc ir">if </strong>(length &gt; 0) {<br/>        ellipsizedText = text;<br/>        <strong class="mc ir">if </strong>(length != text.<strong class="mc ir">length</strong>) {<br/>          <strong class="mc ir">var </strong>start = text.substring(0, (length / 2).round());<br/>          <strong class="mc ir">var </strong>end = text.substring(text.<strong class="mc ir">length </strong>- start.<strong class="mc ir">length</strong>, text.<strong class="mc ir">length</strong>);<br/>          ellipsizedText = start + <strong class="mc ir">'...' </strong>+ end;<br/>        }<br/>      }<br/>      <strong class="mc ir">break</strong>;<br/>    <strong class="mc ir">case </strong>Ellipsis.<strong class="mc ir">end</strong>:<br/>      <strong class="mc ir">if </strong>(length &gt; 0) {<br/>        ellipsizedText = text.substring(0, length);<br/>        <strong class="mc ir">if </strong>(length != text.<strong class="mc ir">length</strong>) {<br/>          ellipsizedText = ellipsizedText + <strong class="mc ir">'...'</strong>;<br/>        }<br/>      }<br/>      <strong class="mc ir">break</strong>;<br/>  }<br/><br/>  <strong class="mc ir">_textPainter</strong>.<strong class="mc ir">text </strong>= TextSpan(text: ellipsizedText, style: style);<br/>  <strong class="mc ir">_textPainter</strong>.layout(minWidth: minWidth, maxWidth: double.<em class="nf">infinity</em>);<br/>  <strong class="mc ir">return _textPainter</strong>.<strong class="mc ir">width</strong>;<br/>}</span></pre><p id="c3d8" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">差不多就是这样。我们剩下要做的——实际上画出我们的文字。</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="3b44" class="na jz iq mc b gy nb nc l nd ne">@override<br/><strong class="mc ir">void </strong>paint(PaintingContext context, Offset offset) {<br/>  <strong class="mc ir">_textPainter</strong>.paint(context.<strong class="mc ir">canvas</strong>, offset);<br/>}</span></pre><p id="91d6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这是结果:</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/b59ab09b8d9b68ca43dd36a34454e6c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*2Hiya57uQorSz1tMmRW0tA.gif"/></div></figure><p id="d48a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">你可以在我的GitHub上找到实现:<br/><a class="ae md" href="https://github.com/MatrixDev/Flutter-CustomWidgets" rel="noopener ugc nofollow" target="_blank">https://github.com/MatrixDev/Flutter-CustomWidgets</a></p><p id="8467" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">希望你喜欢它！</p><h1 id="b276" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">其他文章:</h1><ul class=""><li id="25ae" class="me mf iq ky b kz la ld le lh nh ll ni lp nj lt mj mk ml mm bi translated"><a class="ae md" href="https://rlesovyi.medium.com/writing-custom-widgets-in-flutter-part-2-singlechildrenderobjectwidget-5637fecdf9bb" rel="noopener">第2.a部分——儿童规模(有助手)</a></li><li id="e032" class="me mf iq ky b kz mn ld mo lh mp ll mq lp mr lt mj mk ml mm bi translated"><a class="ae md" href="https://rlesovyi.medium.com/writing-custom-widgets-in-flutter-part-2-b-childsize-no-helpers-61c578c9bbd2" rel="noopener">第2.b部分—子女人数(无助手)</a></li><li id="3773" class="me mf iq ky b kz mn ld mo lh mp ll mq lp mr lt mj mk ml mm bi translated"><a class="ae md" href="https://rlesovyi.medium.com/writing-custom-widgets-in-flutter-part-3a-simpleoverlay-with-helpers-6b3990db48b6" rel="noopener">第3.a部分—简单叠加(带助手)</a></li><li id="66fd" class="me mf iq ky b kz mn ld mo lh mp ll mq lp mr lt mj mk ml mm bi translated"><a class="ae md" href="https://rlesovyi.medium.com/writing-custom-widgets-in-flutter-part-3-b-simpleoverlay-no-helpers-9ddf45cea983" rel="noopener">第3.b部分—简单叠加(无助手)</a></li></ul></div></div>    
</body>
</html>