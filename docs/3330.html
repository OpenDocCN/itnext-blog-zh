<html>
<head>
<title>Kubernetes Operators… getting down to business (logic)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes运营商…进入正题(逻辑)</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-operators-getting-down-to-business-logic-93d6f5303813?source=collection_archive---------1-----------------------#2019-11-23">https://itnext.io/kubernetes-operators-getting-down-to-business-logic-93d6f5303813?source=collection_archive---------1-----------------------#2019-11-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/ef20d808c851bc373d969ab13fae676a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VatTV3bYjJoZGMYaVYz_5w.png"/></div></div></figure><div class=""/><p id="8ff0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上个月，我写了一篇文章,讲述了我在理解用于在Kubernetes中构建定制状态管理组件的操作框架时所经历的挣扎。在这篇文章中，我想进一步阐述这些概念和发现，并深入一点技术细节。</p><p id="dfab" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">请注意:</strong>我不打算在这里讨论“如何编写自定义操作符”，我将在以后的博客文章中讨论。这篇文章旨在更深入地探究什么是操作符以及它们是如何工作的。</p><h1 id="d6fa" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">快速回顾一下</h1><p id="b199" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">所以首先让我们来看看我在之前的博文中介绍的一些基本概念:</p><ul class=""><li id="be8e" class="ma mb jb ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">操作符允许我们在Kubernetes生态系统中定义和封装定制的业务逻辑单元。</li><li id="7519" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">操作员允许我们定义、监控和恢复通常被认为是Kubernetes和/或容器外部的定制组件。</li><li id="3bd1" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">运营商让我们更接近我们的乌托邦梦想，即真正的DevOps，我们的服务部署只不过是一个配置文件，我们的待命警报/电话永远不会ping，因为我们的服务可以自我修复和扩展</li></ul><p id="f6dc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我知道这一切似乎好得不像是真的；这很像一家软件公司的推销词，承诺世界但从不兑现，然而，如果你愿意做必要的跑腿工作，Kubernetes可以让这成为现实。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="e820" class="kx ky jb bd kz la mv lc ld le mw lg lh li mx lk ll lm my lo lp lq mz ls lt lu bi translated">我从哪里开始？</h1><p id="f58f" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">好了，在我们开始举例之前，我们需要先了解一些简单的“基础知识”。</p><ul class=""><li id="ea11" class="ma mb jb ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">Kubernetes的核心只不过是一个监控系统；本质上是一个无限循环，不断监控它所知道的一切。</li><li id="68c7" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">Kubernetes监控的东西可以称为感知状态，与现实相比较，称为实际状态。</li><li id="d54f" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">当Kubernetes检测到感知状态和实际状态之间的差异时，它会计算采取何种措施来使这两种状态匹配。</li></ul><p id="7725" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kubernetes在对账过程中可能采取的措施包括:</p><ul class=""><li id="fe01" class="ma mb jb ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">部署了应用程序的新版本；这意味着一旦新的pod稳定下来，就需要创建新的实例并删除旧的实例。</li><li id="39cf" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">由于正在运行的pod变得不正常，正在创建服务的新pod/实例。</li><li id="63a4" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">因为用户发出了缩减或删除服务的请求而删除pod。</li></ul><p id="201a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个列表<em class="na">并不详尽</em>，只是让我们开始的几个例子。</p><h1 id="6c2a" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">是时候调和我们的分歧了</h1><p id="e5c9" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">所以现在我们从状态的角度来思考。当Kubernetes决定某些东西不同步时会发生什么？</p><p id="84aa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当检测到状态差异时，K8s启动我们称之为<strong class="ka jc">“协调”</strong>的东西。当这种情况发生时，K8s试图从本质上使现实与它被告知的现实应该是什么样子相匹配。请记住，当我们部署服务时，我们的YAML文件实际上是在告诉Kubernetes“我希望世界是这样的”，一旦它实现了这一点，并且状态同步，它将返回到监控状态，等待状态差异出现。</p><p id="90e0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在很大程度上，和解非常简单；旋转新的东西或拆除不想要的东西。但是K8s能做的不仅仅是启动和停止东西。所以让我们再深入一点，好吗？</p><h1 id="df00" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">真实世界的例子</h1><p id="be28" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">好，让我们举一个高级场景的例子。假设我们想让kubernetes部署并监控AWS SQS的实例。这将允许我们部署新的SQS实例，作为我们在YAML的服务部署的一部分，然后让kubernetes为我们做所有的配置、维护和繁重的工作。</p><p id="ff53" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我讨厌陈述显而易见的事实，但是<strong class="ka jc"> SQS并不是在一个容器中运行</strong>；它运行在AWS云平台中，那么Kubernetes(一个容器编排平台)究竟如何帮助我们呢？</p><p id="fcbe" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我要告诉你的是:</p><p id="66d6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> <em class="na">不是所有我们需要通过Kubernetes管理的东西都需要在容器中运行。有时我们需要跳出传统的框框</em> </strong></p><figure class="nc nd ne nf gt is gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/03d16dd056bd8adf4783f161e5f19b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/1*_pGj3DixmBImxcAl_HWWdA.gif"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">我知道没错…太棒了！</figcaption></figure><p id="36e2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相反，我们需要的是在一个容器中运行的东西，这将允许我们与SQS互动。</p><h1 id="4ed0" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">运营商框架来救援！</h1><p id="dc37" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">没错，所以我们需要K8s能够处理有状态的东西，但是不管那个“有状态的东西”是什么，可能会也可能不会在Kubernetes生态系统中运行。太好了！</p><p id="1e67" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我们如何做到这一点呢？？？幸运的是，有一个叫做Kubernetes操作框架的东西可以帮助我们。最初由CoreOS <a class="ae kw" href="https://coreos.com/blog/introducing-operator-framework" rel="noopener ugc nofollow" target="_blank">开发的框架在2018年高调宣布</a>。该框架为我们提供了所有需要的工具和指导，我们可以尝试在Kubernetes中构建名为Operators的扩展。但是它们到底是什么呢？</p><h2 id="217d" class="nk ky jb bd kz nl nm dn ld nn no dp lh kj np nq ll kn nr ns lp kr nt nu lt nv bi translated">我的TL；DR；运算符的定义:</h2><blockquote class="nw"><p id="b2db" class="nx ny jb bd nz oa ob oc od oe of kv dk translated">操作符可以简单地看作是一个RESTful API，它运行在K8s上的一个容器中。它们有控制器和动作(和所有RESTful服务一样)，每当需要进行协调时，K8s就会调用它们。</p></blockquote><h2 id="c4f7" class="nk ky jb bd kz nl og dn ld nn oh dp lh kj oi nq ll kn oj ns lp kr ok nu lt nv bi translated">但是，Kubernetes如何知道调用哪个控制器呢？</h2><p id="5113" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">当我们编写我们的操作符时，我们将创建定制的控制器，然后我们将使用K8s控制平面安装或注册我们的控制器。我们通过将我们的控制器挂接到一个叫做<strong class="ka jc">控制器管理器</strong>的东西来实现这一点。</p><p id="794c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是即使注册了控制器，Kubernetes如何知道哪个控制器做什么呢？所以还有最后一块拼图我们还没有看，Kubernetes的一个关键概念/术语，它让操作框架完成它的工作；这就是CRD或自定义资源定义。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="72a5" class="kx ky jb bd kz la mv lc ld le mw lg lh li mx lk ll lm my lo lp lq mz ls lt lu bi translated">CRD不是垃圾</h1><p id="73b0" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">自定义资源是Kubernetes API的扩展，允许我们定义自己的复杂类型。就其本身而言，除了允许我们在K8s中存储和检索结构化数据之外，它们并不允许我们做更多的事情。</p><p id="9227" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回想一下您的YAML文件，您在其中定义了您希望在集群中包含的内容。你总是定义你想要的东西的<strong class="ka jc">种类</strong>，这实质上是它的‘资源定义’。你可能已经遇到过一些了。想想豆荚、服务、秘密或部署；都是资源定义。它们只是碰巧是预装的默认设置。</p><p id="d71f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们了解了CRD的，我们可以看到，当我们通过K8s的控制器管理器组件将自定义资源与自定义控制器结合/绑定时，我们就可以真正开始创造奇迹了。</p><p id="2bfd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好，让我们来看一个非常简单的流程:</p><figure class="nc nd ne nf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ol"><img src="../Images/fb0c31cc34326eb6d41d3b132df15452.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2mrv7ibYrVmfSiWzWyAbPA.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">简化的K8s CRD控制器调节回路流量</figcaption></figure><p id="4c36" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么在上面的简图中发生了什么呢:</p><ul class=""><li id="d260" class="ma mb jb ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">用户使用“kubectl”通过yaml文件请求一个自定义资源的新实例(例如:SQS)。</li><li id="0ee3" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">这个请求通过Kubernetes控制平面进入Kubernetes系统，控制平面是Kubernetes实例的大脑和中枢。</li><li id="c4c4" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">Kubernetes然后执行内部逻辑，查询它的etcd实例以确定是否需要任何动作。</li><li id="dd21" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">Kubernetes将当前状态与期望状态进行比较。</li><li id="d180" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">在这种情况下，我们想要一个新的SQS，因此Kubernetes向我们的控制器发布了一条消息，注册为能够处理SQS类型的CRD；说“嘿，我们需要和解”</li><li id="f971" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">我们的定制控制器就像节点内pod上的任何其他服务/应用程序一样运行。</li><li id="0b81" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">当控制器被调用时，动作中的逻辑被执行，成功/失败被报告回控制平面。</li></ul><h1 id="6e0b" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">把所有的放在一起</h1><p id="c689" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">对，所以我们现在有了一个非常简单的想法，所有这些部分是如何在库伯内特土地上结合在一起的。但是让我们快速回顾一下:</p><ul class=""><li id="bc89" class="ma mb jb ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">一个<strong class="ka jc"> CRD </strong>(定制资源类型)允许我们通过YAML或kubectl请求新的定制资源。</li><li id="38f2" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">一个<strong class="ka jc">控制器</strong>本质上是一个RESTful服务，它在一个节点上的容器内运行，并响应来自K8s控制平面的控制请求。</li><li id="6984" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">一个<strong class="ka jc"> CRD通过K8s内部的</strong> <strong class="ka jc">控制器管理器</strong>绑定到一个控制器 <strong class="ka jc"/></li><li id="a94e" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">当感知状态(我们拥有的)和期望状态(我们想要的)之间存在差异时，K8s将执行<strong class="ka jc">协调循环</strong>以尝试将状态恢复同步。</li></ul><h2 id="01a4" class="nk ky jb bd kz nl nm dn ld nn no dp lh kj np nq ll kn nr ns lp kr nt nu lt nv bi translated">当我们的控制器被调用时会发生什么？</h2><p id="9654" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">坦白说，不管我们想让它做什么。这就是操作符的魅力所在，因为一旦你的控制器动作被调用，你就可以做任何你想做的事情。我不想让这篇文章在技术实现上陷入困境，所以为了简单起见，这里有一个简单的流程图来解释这段代码的结构:</p><figure class="nc nd ne nf gt is gh gi paragraph-image"><div class="gh gi om"><img src="../Images/d29378217d2a3c04ab8e7a8054e23a1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*noJRHYeqp_mr37wbjyYD0Q.png"/></div></figure><p id="3c51" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我执行了我需要的任何操作，并且我的业务逻辑得到了满足，我就可以向Kubernetes报告我的控制器已经完成了协调，然后K8s将继续监视。</p><h1 id="1251" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">我们在下沉！还是应该同步？！？！</h1><p id="7142" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">没错，我们有自己的控制器，它就在外面，我们可以通过使用YAML或kubectl来请求新资源、更改现有资源和删除资源。一切都很完美！我们离乌托邦式的开发运营梦想又近了一步！</p><h2 id="987e" class="nk ky jb bd kz nl nm dn ld nn no dp lh kj np nq ll kn nr ns lp kr nt nu lt nv bi translated">但是等等…如果有人来删除我们在AWS中的SQS队列会发生什么？！</h2><figure class="nc nd ne nf gt is gh gi paragraph-image"><div class="gh gi on"><img src="../Images/75ee78d2e00ebb15edfe5cae8d1d08a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/1*vtluS2pH9xQeYIApu8o0Rg.gif"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">恐慌的时候到了？！？！</figcaption></figure><p id="129f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是，由于Operator框架，我们还可以安排手动协调循环。是的，你没看错人；我们可以告诉K8s，我们希望它在状态差异范围之外执行一个协调循环。您的用例可能不需要这样做，但是完全有可能编写业务逻辑来说“嘿，Kubernetes，我们现在都很好，但是在<em class="na"> x秒</em>之后回来再检查一次，好吗？-谢谢。</p><p id="1f20" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请记住，Kubernetes对外部世界一无所知，因此如果我们希望能够对外部事件(SQS删除等)做出反应，我们将需要在正常的状态更改流之外处理这些场景。现在就像变魔术一样，如果有人要删除我们的SQS，它会神奇地在下一个调和循环中重新出现！</p><figure class="nc nd ne nf gt is gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/096c190536b4891089f9e89264c14f17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*BYTSRgiW_rYdGdUr2jkDvA.gif"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">唷…那是一次惊险的经历</figcaption></figure><h1 id="32f7" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">提醒一句</h1><p id="8961" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">你已经看到了操作符是如何让我们封装复杂的业务逻辑的。您还看到了我们如何通过协调循环维护外部状态。但是记住人们:</p><ul class=""><li id="d704" class="ma mb jb ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">协调循环需要是非阻塞的。实现在几秒钟内阻塞pod资源的协调代码是一个糟糕的设计决策</li><li id="25f2" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">想想你的上游依赖，不要DDOS他们。</li><li id="1c12" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">考虑一下您的控制平面，如果您正在安排手动协调循环，并且您预计会有很多组件，请保守一些，因为您可能会削弱实例节点。</li><li id="a04f" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">好好设计您的操作符，考虑向后兼容性，以防止在推出新版本时发生重大变化</li></ul><h1 id="fd5e" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">最后一点</h1><p id="015e" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我相信我们都看过著名的米老鼠场景，魔法师学徒，米老鼠找到了一种方法来自动化他的艰苦工作，但没有学会如何正确地控制它，导致混乱和失控的过程。我们以同样的方式考虑操作符。是的，它们非常强大，但是，仔细想想设计和结构；因为你最不希望的就是你的自动化失去控制</p><figure class="nc nd ne nf gt is gh gi paragraph-image"><div class="gh gi op"><img src="../Images/d107b516bca48ae3e68c07506970b5dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/1*5L3nE8i6gGKKUEQBc9g-qA.gif"/></div></figure></div></div>    
</body>
</html>