<html>
<head>
<title>A ReasonML Tutorial: Building an App Shell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ReasonML教程:构建应用程序外壳</h1>
<blockquote>原文：<a href="https://itnext.io/a-reasonml-tutorial-building-an-app-shell-dd7cc617d0c5?source=collection_archive---------3-----------------------#2018-02-15">https://itnext.io/a-reasonml-tutorial-building-an-app-shell-dd7cc617d0c5?source=collection_archive---------3-----------------------#2018-02-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="920e" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq">注意:这是关于从反应过渡到理性的“理性之旅”系列的一部分。敬请关注。还会有更多这样的事情发生！<br/> </em> <a class="ae kp" href="https://medium.com/@RRafatpanah/a-journey-to-reason-c408a87a54de" rel="noopener"> <em class="iq"> &lt;上一篇</em></a><em class="iq">|</em><a class="ae kp" href="https://medium.com/netscape/a-journey-to-reason-2c2c4cddc012" rel="noopener"><em class="iq">&lt;&lt;从第1部分开始</em> </a></p></blockquote><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/e44428facc7f88778c30961e67a3b79d.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*sQ-jhxLUUYX6dseLJDFnIg.gif"/></div></figure><p id="8064" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated"><a class="ae kp" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fa-reasonml-tutorial-building-an-app-shell-dd7cc617d0c5" rel="noopener ugc nofollow" target="_blank"> <em class="js">点击这里在LinkedIn上分享这篇文章</em> </a></p><p id="16f9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">让我们构建一个应用程序外壳，它可以作为您的web应用程序的起点。</p><p id="0898" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">首先，我们将介绍<a class="ae kp" href="https://github.com/persianturtle/reason-app-shell-starter-kit" rel="noopener ugc nofollow" target="_blank"> Reason App Shell Start Kit </a>项目，并展示如何使用和定制它。</p><p id="00a1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">然后，我们将展示一个Reason &amp; ReasonReact教程，在其中我们使用<a class="ae kp" href="https://github.com/reasonml-community/reason-scripts" rel="noopener ugc nofollow" target="_blank"> Create React App </a>作为基础来构建这个项目。本教程假设对<a class="ae kp" href="https://reasonml.github.io/" rel="noopener ugc nofollow" target="_blank">原因</a>原因&amp;原因<a class="ae kp" href="https://reasonml.github.io/reason-react/" rel="noopener ugc nofollow" target="_blank">原因反应</a>有一个基本的了解，并有反应的背景。</p><blockquote class="jn jo jp"><p id="4303" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">如果你想知道ReasonML是什么，为什么像我这样的前端web开发人员对使用它感兴趣，请查看本系列的第一篇文章。</p></blockquote><h1 id="d2de" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">原因介绍-应用程序-外壳-入门套件</h1><p id="d99c" class="pw-post-body-paragraph jq jr iq jt b ju lz jw jx jy ma ka kb ky mb ke kf kz mc ki kj la md km kn ko ij bi translated">github:<a class="ae kp" href="https://github.com/persianturtle/reason-app-shell-starter-kit" rel="noopener ugc nofollow" target="_blank">https://github . com/persianturtle/reason-app-shell-starter-kit</a></p><p id="2d4f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">该项目旨在作为web应用程序的起点。它带有以下内容:</p><ul class=""><li id="fb82" class="me mf iq jt b ju jv jy jz ky mg kz mh la mi ko mj mk ml mm bi translated"><a class="ae kp" href="https://reasonml.github.io/reason-react/docs/en/router.html" rel="noopener ugc nofollow" target="_blank">react内置路由器</a></li><li id="29a7" class="me mf iq jt b ju mn jy mo ky mp kz mq la mr ko mj mk ml mm bi translated">与路由器一起工作的助手组件</li><li id="6d08" class="me mf iq jt b ju mn jy mo ky mp kz mq la mr ko mj mk ml mm bi translated">保持我们的<strong class="jt ir">路线</strong> &amp; <strong class="jt ir">页面标题</strong>同步的好方法</li><li id="effa" class="me mf iq jt b ju mn jy mo ky mp kz mq la mr ko mj mk ml mm bi translated">一个<strong class="jt ir">导航</strong> <strong class="jt ir">抽屉</strong>，当它打开时，对触摸有很好的反应</li></ul><p id="adaa" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">该项目使用<a class="ae kp" href="https://github.com/reasonml-community/reason-scripts" rel="noopener ugc nofollow" target="_blank"> Create React App </a>，<a class="ae kp" href="https://reasonml.github.io/" rel="noopener ugc nofollow" target="_blank"> Reason </a>，<a class="ae kp" href="https://reasonml.github.io/reason-react/" rel="noopener ugc nofollow" target="_blank">Reason React</a>&amp;<a class="ae kp" href="https://sass-lang.com/" rel="noopener ugc nofollow" target="_blank">Sass</a>，没有其他依赖关系。它有意保持简单和小巧，以便易于编辑来满足您的需求。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="74a6" class="lb lc iq bd ld le nd lg lh li ne lk ll lm nf lo lp lq ng ls lt lu nh lw lx ly bi translated">如何使用它</h1><ol class=""><li id="4efd" class="me mf iq jt b ju lz jy ma ky ni kz nj la nk ko nl mk ml mm bi translated">克隆<a class="ae kp" href="https://github.com/persianturtle/reason-app-shell-starter-kit" rel="noopener ugc nofollow" target="_blank">回购</a></li></ol><p id="e376" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">2.<code class="fe ms mt mu mv b">npm install &amp;&amp; npm start</code></p><p id="7ff4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">3.在<code class="fe ms mt mu mv b">app.re</code>内做一些编辑</p><ul class=""><li id="9586" class="me mf iq jt b ju jv jy jz ky mg kz mh la mi ko mj mk ml mm bi translated">自定义您的应用程序的<strong class="jt ir">路线</strong>类型。</li></ul><pre class="kr ks kt ku gt nm mv nn no aw np bi"><span id="d7c9" class="nq lc iq mv b gy nr ns l nt nu">type <strong class="mv ir">route</strong> =<br/>| Home<br/>| Page1<br/>| Page2<br/>| Page3;</span></pre><blockquote class="jn jo jp"><p id="c954" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">注意:<strong class="jt ir">路线</strong>是OCaml/Reason中的变体类型。如果这对你来说听起来很陌生，那就看一看<a class="ae kp" href="https://reasonml.github.io/docs/en/variant.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></blockquote><ul class=""><li id="f3f9" class="me mf iq jt b ju jv jy jz ky mg kz mh la mi ko mj mk ml mm bi translated">定制路由器的<strong class="jt ir"> watchUrl </strong>函数，将各种路径映射到组件。点击阅读ReasonReact路由器<a class="ae kp" href="https://reasonml.github.io/reason-react/docs/en/router.html" rel="noopener ugc nofollow" target="_blank">的威力。</a></li></ul><pre class="kr ks kt ku gt nm mv nn no aw np bi"><span id="e5c9" class="nq lc iq mv b gy nr ns l nt nu">subscriptions: self =&gt; [<br/>  Sub(<br/>    () =&gt;<br/>      ReasonReact.Router.<strong class="mv ir">watchUrl</strong>(url =&gt;<br/>        switch url.path {<br/>        | ["page1"] =&gt; self.send(<strong class="mv ir">Navigate</strong>((Page1, "Page1")))<br/>        | ["page2"] =&gt; self.send(<strong class="mv ir">Navigate</strong>((Page2, "Page2")))<br/>        | ["page3"] =&gt; self.send(<strong class="mv ir">Navigate</strong>((Page3, "Page3")))<br/>        | _ =&gt; self.send(<strong class="mv ir">Navigate</strong>((Home, "Home")))<br/>        }<br/>      ),<br/>    ReasonReact.Router.unwatchUrl<br/>  )<br/>],</span></pre><p id="5e0e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated"><strong class="jt ir">导航</strong>是一个<a class="ae kp" href="https://reasonml.github.io/reason-react/docs/en/state-actions-reducer.html" rel="noopener ugc nofollow" target="_blank">动作</a>，接受一个<strong class="jt ir"> routeWithTitle </strong>并设置app当前<strong class="jt ir"> route </strong> &amp;页面标题。</p><pre class="kr ks kt ku gt nm mv nn no aw np bi"><span id="677a" class="nq lc iq mv b gy nr ns l nt nu">type <strong class="mv ir">routeWithTitle</strong> = (<strong class="mv ir">route</strong>, string);</span></pre><p id="7c48" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">正如您可能已经怀疑的那样，<strong class="jt ir"> routeWithTitle </strong>是一个<a class="ae kp" href="https://reasonml.github.io/docs/en/tuple.html" rel="noopener ugc nofollow" target="_blank">元组</a>，它将<strong class="jt ir">路由</strong>类型与页面标题配对。这保证了我们在导航到一条路线时不会忘记设置页面标题。</p><blockquote class="jn jo jp"><p id="1add" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">到目前为止，我们只更改了应用程序状态。现在让我们更新使用该状态的渲染函数。</p></blockquote><ul class=""><li id="159f" class="me mf iq jt b ju jv jy jz ky mg kz mh la mi ko mj mk ml mm bi translated">定制渲染功能，根据当前<strong class="jt ir">路径</strong>有条件地渲染组件。</li></ul><pre class="kr ks kt ku gt nm mv nn no aw np bi"><span id="09c5" class="nq lc iq mv b gy nr ns l nt nu">&lt;main&gt;<br/>  (<br/>    switch <strong class="mv ir">route</strong> {<br/>    | Home =&gt; &lt;Home /&gt;<br/>    | Page1 =&gt; &lt;Page1 /&gt;<br/>    | Page2 =&gt; &lt;Page2 /&gt;<br/>    | Page3 =&gt; &lt;Page3 /&gt;<br/>    }<br/>  )<br/>&lt;/main&gt;</span></pre><blockquote class="jn jo jp"><p id="ba66" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">注意:按理说，<code class="fe ms mt mu mv b">&lt;Home /&gt;</code>映射到一个名为<code class="fe ms mt mu mv b">home.re</code>的文件，不需要手动“包含”<code class="fe ms mt mu mv b">home.re</code>。</p></blockquote><ul class=""><li id="333b" class="me mf iq jt b ju jv jy jz ky mg kz mh la mi ko mj mk ml mm bi translated">自定义渲染功能以更改导航抽屉中的菜单。</li></ul><pre class="kr ks kt ku gt nm mv nn no aw np bi"><span id="6f7b" class="nq lc iq mv b gy nr ns l nt nu">&lt;label&gt; (ReasonReact.stringToElement("home")) &lt;/label&gt;<br/>&lt;ul&gt; &lt;li&gt; &lt;<strong class="mv ir">Link</strong> <strong class="mv ir">href</strong>="/" <strong class="mv ir">label</strong>="Home" /&gt; &lt;/li&gt; &lt;/ul&gt;<br/>&lt;label&gt; (ReasonReact.stringToElement("pages")) &lt;/label&gt;<br/>&lt;ul&gt;<br/>  &lt;li&gt; &lt;<strong class="mv ir">Link</strong> <strong class="mv ir">href</strong>="/page1" <strong class="mv ir">label</strong>="Page1" /&gt; &lt;/li&gt;<br/>  &lt;li&gt; &lt;<strong class="mv ir">Link</strong> <strong class="mv ir">href</strong>="/page2" <strong class="mv ir">label</strong>="Page2" /&gt; &lt;/li&gt;<br/>  &lt;li&gt; &lt;<strong class="mv ir">Link</strong> <strong class="mv ir">href</strong>="/page3" <strong class="mv ir">label</strong>="Page3" /&gt; &lt;/li&gt;<br/>&lt;/ul&gt;</span></pre><blockquote class="jn jo jp"><p id="d422" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><code class="fe ms mt mu mv b">&lt;Link href="..." label="..." /&gt;</code>组件使用一个点击处理程序呈现一个<code class="fe ms mt mu mv b">&lt;a href={href}&gt;{label}&lt;/a&gt;</code>,该处理程序调用<a class="ae kp" href="https://reasonml.github.io/reason-react/docs/en/router.html" rel="noopener ugc nofollow" target="_blank"> ReasonReact。Router.push(href) </a>并更新URL。</p></blockquote><p id="39fe" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">就是这样！</p><p id="19b1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">随意用你的自定义风格编辑<code class="fe ms mt mu mv b">app.scss</code>，或者项目的任何其他部分。创建您的定制组件(<em class="js">例如</em> <code class="fe ms mt mu mv b">&lt;Page1 /&gt;</code>)，并享受构建您的web应用程序的乐趣！</p><p id="8ca2" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">我很想听听你是如何根据自己的需求定制的。如果你想帮助改进这个项目，我们非常欢迎<a class="ae kp" href="https://github.com/persianturtle/reason-app-shell-starter-kit" rel="noopener ugc nofollow" target="_blank">拉请求。</a></p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="f523" class="lb lc iq bd ld le nd lg lh li ne lk ll lm nf lo lp lq ng ls lt lu nh lw lx ly bi translated">让我们建造它！</h1><p id="96d6" class="pw-post-body-paragraph jq jr iq jt b ju lz jw jx jy ma ka kb ky mb ke kf kz mc ki kj la md km kn ko ij bi translated">我们将从<a class="ae kp" href="https://github.com/reasonml-community/reason-scripts" rel="noopener ugc nofollow" target="_blank">创建React App </a>开始，一起构建这个项目。</p><p id="85be" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">首先，我们将构建一个不响应触摸的基本应用程序外壳，然后我们将致力于触摸功能。触摸功能包括:</p><ul class=""><li id="5bd6" class="me mf iq jt b ju jv jy jz ky mg kz mh la mi ko mj mk ml mm bi translated">打开时，导航抽屉应响应触摸移动事件(如<a class="ae kp" href="https://s3.amazonaws.com/persianturtle/demo.gif" rel="noopener ugc nofollow" target="_blank">演示</a>所示)</li><li id="fc6d" class="me mf iq jt b ju mn jy mo ky mp kz mq la mr ko mj mk ml mm bi translated">如果用户在50%阈值(半开)后移动导航抽屉，抽屉应该关闭，否则保持打开</li><li id="2fa5" class="me mf iq jt b ju mn jy mo ky mp kz mq la mr ko mj mk ml mm bi translated">如果用户以某个最小速度滑动，抽屉应该关闭——即使还没有达到50%的阈值</li></ul><p id="dcaa" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">我们现在要开发的功能包括:</p><ul class=""><li id="df19" class="me mf iq jt b ju jv jy jz ky mg kz mh la mi ko mj mk ml mm bi translated">激活导航抽屉</li><li id="5cc0" class="me mf iq jt b ju mn jy mo ky mp kz mq la mr ko mj mk ml mm bi translated">当导航抽屉打开时，动画显示隐藏主要内容的覆盖图</li><li id="4d48" class="me mf iq jt b ju mn jy mo ky mp kz mq la mr ko mj mk ml mm bi translated">导航抽屉打开时防止正文滚动</li><li id="1a47" class="me mf iq jt b ju mn jy mo ky mp kz mq la mr ko mj mk ml mm bi translated">当路线改变时，关闭导航抽屉</li><li id="b2c7" class="me mf iq jt b ju mn jy mo ky mp kz mq la mr ko mj mk ml mm bi translated">在外部点击时关闭导航抽屉</li></ul><blockquote class="jn jo jp"><p id="7fcb" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">注意:如果您还没有，<a class="ae kp" href="https://reasonml.github.io/docs/en/global-installation.html" rel="noopener ugc nofollow" target="_blank">安装原因-cli </a> &amp; <a class="ae kp" href="https://reasonml.github.io/docs/en/editor-plugins.html" rel="noopener ugc nofollow" target="_blank">设置您的编辑器</a>。另外，通过<code class="fe ms mt mu mv b">npm install -g bs-platform</code>安装BuckleScript。</p></blockquote><h2 id="f844" class="nq lc iq bd ld nv nw dn lh nx ny dp ll ky nz oa lp kz ob oc lt la od oe lx of bi translated">用<a class="ae kp" href="https://github.com/reasonml-community/reason-scripts" rel="noopener ugc nofollow" target="_blank"> Create React App </a>初始化你的开发者环境</h2><p id="d1c3" class="pw-post-body-paragraph jq jr iq jt b ju lz jw jx jy ma ka kb ky mb ke kf kz mc ki kj la md km kn ko ij bi translated"><code class="fe ms mt mu mv b">yarn create react-app my-app --scripts-version reason-scripts</code></p><h2 id="a102" class="nq lc iq bd ld nv nw dn lh nx ny dp ll ky nz oa lp kz ob oc lt la od oe lx of bi translated">移除<code class="fe ms mt mu mv b">index.re</code>中<App/>的信息道具</h2><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">在第5行，<app message="”…”"/>变成了<app/></figcaption></figure><h2 id="a83e" class="nq lc iq bd ld nv nw dn lh nx ny dp ll ky nz oa lp kz ob oc lt la od oe lx of bi translated">用以下内容替换app.re:</h2><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">现在这是一个有状态的组件，它只是呈现:<div class="”App”"/></figcaption></figure><p id="d851" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">此处包含<code class="fe ms mt mu mv b">app.scss</code><a class="ae kp" href="https://gist.github.com/persianturtle/6b25cb84b7348649e037340a30ff27a4" rel="noopener ugc nofollow" target="_blank"/>(<a class="ae kp" href="https://github.com/persianturtle/reason-app-shell-starter-kit" rel="noopener ugc nofollow" target="_blank">回购</a>已经配置为使用SASS)。</p><p id="4919" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">这里包括<code class="fe ms mt mu mv b">index.css</code><a class="ae kp" href="https://gist.github.com/persianturtle/0121a1dfdda62206babf9e9144ecdf3e" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="17cd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">运行<code class="fe ms mt mu mv b">npm run start</code>，我们应该会看到一个空白页。太好了！让我们回顾一下<code class="fe ms mt mu mv b">app.re</code>里发生了什么。</p><blockquote class="jn jo jp"><p id="3db6" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">在继续之前，确保你已经阅读了<a class="ae kp" href="https://reasonml.github.io/reason-react/docs/en/state-actions-reducer.html" rel="noopener ugc nofollow" target="_blank">有状态组件文档</a>。</p></blockquote><p id="7ac4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">目前有两种可能的操作:</p><ol class=""><li id="0f2e" class="me mf iq jt b ju jv jy jz ky mg kz mh la mi ko nl mk ml mm bi translated"><strong class="jt ir">导航(路径宽度标题)</strong></li><li id="e39d" class="me mf iq jt b ju mn jy mo ky mp kz mq la mr ko nl mk ml mm bi translated"><strong class="jt ir">切换菜单(bool) </strong></li></ol><p id="0db9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">在国务院，我们关心两件事:</p><pre class="kr ks kt ku gt nm mv nn no aw np bi"><span id="c448" class="nq lc iq mv b gy nr ns l nt nu">type <strong class="mv ir">routeWithTitle</strong> = (<strong class="mv ir">route</strong>, string);</span><span id="ad87" class="nq lc iq mv b gy om ns l nt nu">type <strong class="mv ir">nav</strong> = {isOpen: bool};</span><span id="793c" class="nq lc iq mv b gy om ns l nt nu">...</span><span id="d63e" class="nq lc iq mv b gy om ns l nt nu">type <strong class="mv ir">state</strong> = {<br/>  ...,<br/>  <strong class="mv ir">routeWithTitle</strong>,<br/>  <strong class="mv ir">nav</strong><br/>};</span></pre><p id="f4dd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">首先，<strong class="jt ir"> routeWithTitle </strong>包含当前路径和页面标题。第二，<strong class="jt ir"> nav </strong>包含导航抽屉的状态。</p><p id="1abe" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">我们的<strong class="jt ir">减速器</strong>和<strong class="jt ir">渲染</strong>字段目前大部分是占位符。让我们现在解决这些问题。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="1599" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">这看起来很多，但这可能是因为我已经内联了SVG。让我们来关注一下亮点:</p><pre class="kr ks kt ku gt nm mv nn no aw np bi"><span id="313e" class="nq lc iq mv b gy nr ns l nt nu">let (<strong class="mv ir">route</strong>, title) = self.state.<strong class="mv ir">routeWithTitle</strong>;</span></pre><p id="7acd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">还记得<strong class="jt ir"> routeWithTitle </strong>是一个元组吗？我们可以就这样破坏当前的<strong class="jt ir">路线</strong>和标题。</p><pre class="kr ks kt ku gt nm mv nn no aw np bi"><span id="9a93" class="nq lc iq mv b gy nr ns l nt nu">className=("App" ++ (self.state.<strong class="mv ir">nav</strong>.isOpen ? " overlay" : ""))</span></pre><p id="15f3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">就像在ReactJS中，我们可以基于状态有条件地添加CSS类。在这种情况下，<code class="fe ms mt mu mv b">app.re</code>呈现以下两种情况之一:</p><p id="6193" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated"><code class="fe ms mt mu mv b">&lt;div class=”App”&gt;</code></p><p id="3315" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">或者</p><p id="de4b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated"><code class="fe ms mt mu mv b">&lt;div class=”App overlay”&gt;</code></p><p id="12cd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">以及相应的CSS:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="4e6e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">因此，当导航抽屉打开时，<code class="fe ms mt mu mv b">&lt;App /&gt;</code>获得了<code class="fe ms mt mu mv b">overlay</code>类，这导致一个覆盖淡入到<code class="fe ms mt mu mv b">&lt;App/&gt;</code>的内容上。</p><blockquote class="jn jo jp"><p id="9465" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">注意:对于<code class="fe ms mt mu mv b">overlay</code>类，<strong class="jt ir">变换不在<code class="fe ms mt mu mv b">.App:after</code>上转换</strong>。但是，如果没有<code class="fe ms mt mu mv b">overlay</code>类，它就是——有一个延迟。这是因为我们希望覆盖图在导航抽屉关闭之前保持正确。否则，覆盖将突然消失，而不是很好地淡出。</p></blockquote><p id="53c9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">当导航抽屉应该打开时，<code class="fe ms mt mu mv b">&lt;nav /&gt;</code>元素获取<code class="fe ms mt mu mv b">active</code>类。</p><pre class="kr ks kt ku gt nm mv nn no aw np bi"><span id="5a0f" class="nq lc iq mv b gy nr ns l nt nu">&lt;nav className=(self.state.<strong class="mv ir">nav</strong>.isOpen ? "active" : "")</span></pre><p id="5557" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">在标题中，单击锚标记会调度一个动作:</p><pre class="kr ks kt ku gt nm mv nn no aw np bi"><span id="5692" class="nq lc iq mv b gy nr ns l nt nu">&lt;header&gt;<br/>  &lt;a<br/>    <strong class="mv ir">onClick</strong>=(<br/>      <strong class="mv ir">event</strong> =&gt; {<br/>        ReactEventRe.Mouse.stopPropagation(event);<br/>        <strong class="mv ir">self.send</strong>(<strong class="mv ir">ToggleMenu</strong>(! self.state.<strong class="mv ir">nav</strong>.isOpen));<br/>      }<br/>    )&gt;</span></pre><p id="c5c8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">动作是<strong class="jt ir"> ToggleMenu(！self.state.nav.isOpen) </strong>。接下来会发生什么？就像Redux中一样，reducer处理所有的状态变化。您向<strong class="jt ir">减速器</strong>发送一个<strong class="jt ir">动作</strong>，然后，基于该动作，<strong class="jt ir">状态</strong>发生变化。</p><p id="c108" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">我们可以采取什么行动？它们是在我们的动作类型中定义的。</p><pre class="kr ks kt ku gt nm mv nn no aw np bi"><span id="b84d" class="nq lc iq mv b gy nr ns l nt nu">type <strong class="mv ir">action</strong> =<br/>  | <strong class="mv ir">Navigate</strong>(<strong class="mv ir">routeWithTitle</strong>)<br/>  | <strong class="mv ir">ToggleMenu</strong>(bool);</span></pre><p id="dc8d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">在<strong class="jt ir">渲染</strong>功能中，我们<code class="fe ms mt mu mv b">self.send(...)</code>了一个动作，它调用了我们的<strong class="jt ir">减速器</strong>:</p><pre class="kr ks kt ku gt nm mv nn no aw np bi"><span id="3d8f" class="nq lc iq mv b gy nr ns l nt nu"><strong class="mv ir">reducer</strong>: (<strong class="mv ir">action</strong>, <strong class="mv ir">state</strong>) =&gt;<br/>  switch <strong class="mv ir">action</strong> {<br/>  | <strong class="mv ir">Navigate</strong>(_routeWithTitle) =&gt; <strong class="mv ir">ReasonReact.NoUpdate</strong><br/>  | <strong class="mv ir">ToggleMenu</strong>(isOpen) =&gt;<br/>    ReasonReact.Update({<br/>      ...state,<br/>      nav: {<br/>        isOpen: isOpen<br/>      }<br/>    })<br/>  },</span></pre><p id="5e56" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">如果<strong class="jt ir">动作</strong>是<strong class="jt ir">切换菜单</strong>，我们将<strong class="jt ir"> state.nav.isOpen </strong>设置为<strong class="jt ir">切换菜单</strong>的参数。</p><p id="a012" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">但是——我们可以做得更好！让我们在导航抽屉打开时防止正文滚动。</p><p id="32e8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">在正常的HTML5世界中，这意味着在<code class="fe ms mt mu mv b">&lt;html&gt;</code>元素上设置<code class="fe ms mt mu mv b">overflow: hidden</code>。但我们不能理智地这么做，对吗？</p><p id="f0e4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">我们可以。</p><blockquote class="on"><p id="e1d6" class="oo op iq bd oq or os ot ou ov ow ko dk translated">ReasonML太神奇了。为什么？因为尽管它适合复杂的应用程序，但当你想构建简单的东西时，它不会妨碍你。</p></blockquote><p id="fe4d" class="pw-post-body-paragraph jq jr iq jt b ju ox jw jx jy oy ka kb ky oz ke kf kz pa ki kj la pb km kn ko ij bi translated">让我们看看解决这个问题的两种方法。</p><p id="123a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated"><strong class="jt ir">解决方案1 </strong> : <em class="js"> Raw </em> JavaScript</p><p id="b903" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">而不是<strong class="jt ir"> ReasonReact。更新</strong>，我们将使用<strong class="jt ir"> ReasonReact。UpdateWithSideEffects </strong>，采用回调做副作用。点击了解更多关于<a class="ae kp" href="https://reasonml.github.io/reason-react/docs/en/state-actions-reducer.html#state-update-through-reducer" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="c86d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">在回调中，我们将根据导航的状态设置<code class="fe ms mt mu mv b">&lt;html&gt;</code>元素的样式。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="141c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">什么？我们是不是在Reason里面写了原始的JavaScript？是的。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/665ccdc2f97969d3721339d82cbf4dde.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*HM9jGjprumjRM96Lsxr91Q.gif"/></div></figure><p id="410d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated"><strong class="jt ir">解决方案2 </strong>:类型安全</p><p id="bfc1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">当运行原始JavaScript时，我们把类型安全扔出了窗外。有时候这很好，有时候不太理想。理由让你来决定。</p><p id="8475" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">此外，有时只使用JavaScript并在以后弄清楚如何转换成类型安全的方法也不错。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="7fb2" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">这里，我们通过BuckleScript的<strong class="jt ir">外部</strong>声明绑定到<code class="fe ms mt mu mv b">documentElement</code>。在reducer中，我们使用<a class="ae kp" href="https://reasonml.github.io/docs/en/object.html" rel="noopener ugc nofollow" target="_blank"> Reason的对象语法</a>来设置<code class="fe ms mt mu mv b">documentElement</code>的样式。</p><blockquote class="jn jo jp"><p id="f80a" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">注意:Reason/OCaml通过BuckleScript与JavaScript有极好的互操作性。点击了解更多关于那个<a class="ae kp" href="https://bucklescript.github.io/" rel="noopener ugc nofollow" target="_blank">的信息。</a></p></blockquote><p id="bbab" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">好了，让我们实现减速器的<strong class="jt ir">导航</strong>箱。</p><pre class="kr ks kt ku gt nm mv nn no aw np bi"><span id="e53e" class="nq lc iq mv b gy nr ns l nt nu">| <strong class="mv ir">Navigate</strong>(<strong class="mv ir">routeWithTitle</strong>) =&gt;<br/>  <strong class="mv ir">ReasonReact</strong>.<strong class="mv ir">UpdateWithSideEffects</strong>(<br/>    {...state, <strong class="mv ir">routeWithTitle</strong>},<br/>    (self =&gt; <strong class="mv ir">self</strong>.<strong class="mv ir">send</strong>(<strong class="mv ir">ToggleMenu</strong>(false)))<br/>  )</span></pre><p id="6545" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">我们用当前的路线和页面标题更新状态，并再次调用一个副作用，在这里我们调度另一个动作来关闭导航。</p><p id="0596" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">我们也可以像这样直接更新导航状态:</p><pre class="kr ks kt ku gt nm mv nn no aw np bi"><span id="8108" class="nq lc iq mv b gy nr ns l nt nu">| <strong class="mv ir">Navigate</strong>(<strong class="mv ir">routeWithTitle</strong>) =&gt;<br/>  <strong class="mv ir">ReasonReact</strong>.<strong class="mv ir">Update</strong>({<br/>    ...state,<br/>    <strong class="mv ir">routeWithTitle</strong>,<br/>    <strong class="mv ir">nav</strong>: {<br/>      isOpen: false<br/>    }<br/>  })</span></pre><p id="d3e1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">而且，由于我们正在应用程序状态中更改当前路由，我们可以基于该状态有条件地呈现组件。</p><pre class="kr ks kt ku gt nm mv nn no aw np bi"><span id="a152" class="nq lc iq mv b gy nr ns l nt nu">&lt;main&gt;<br/>  (<br/>    switch <strong class="mv ir">route</strong> {<br/>    | Home =&gt; &lt;Home /&gt;<br/>    | Page1 =&gt; &lt;Page1 /&gt;<br/>    | Page2 =&gt; &lt;Page2 /&gt;<br/>    | Page3 =&gt; &lt;Page3 /&gt;<br/>    }<br/>  )<br/>&lt;/main&gt;</span></pre><p id="857d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">只要确保您已经在<code class="fe ms mt mu mv b">home.re</code>、<code class="fe ms mt mu mv b">page1.re</code>、<code class="fe ms mt mu mv b">page2.re</code>和<code class="fe ms mt mu mv b">page3.re</code>中定义了组件。</p><p id="d26e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">这里有一个简单的无状态<code class="fe ms mt mu mv b">&lt;Page1 /&gt;</code>组件:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="b946" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">恭喜你。我们现在有一个简单的应用程序外壳，带有一个导航抽屉和一个路由器。应用程序外壳根据当前路线呈现一个“主”组件。此外，如果你想<em class="js">比如说</em>在每条路线上渲染多个组件，你可以在你的渲染函数中使用任何你想要的逻辑。</p><blockquote class="jn jo jp"><p id="a5fc" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">注意:因为我们对<strong class="jt ir"> routeWithTitle </strong>使用了一个元组，所以我们保证我们的路由和页面标题永远不会不同步(当然，除非我们在分派<code class="fe ms mt mu mv b">self.send(Navigate((Home, "Wrong Title")))</code>时简单地包含了错误的标题)。但是<code class="fe ms mt mu mv b">self.send(Navigate(Home))</code>将在编译时失败——因为<strong class="jt ir"> Navigate </strong>只接受类型为<strong class="jt ir"> routeWithTitle </strong>的参数。</p></blockquote><p id="b428" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">只要有可能，就使用对你有利的类型系统来为你提供更强的保证。关于这方面的更多信息，请查看以下讲座:</p><ul class=""><li id="5ab9" class="me mf iq jt b ju jv jy jz ky mg kz mh la mi ko mj mk ml mm bi translated">理查德·费尔德曼的《让不可能的国家变得不可能》</li><li id="e6ab" class="me mf iq jt b ju mn jy mo ky mp kz mq la mr ko mj mk ml mm bi translated"><a class="ae kp" href="https://youtu.be/P7dTPoxCg4w" rel="noopener ugc nofollow" target="_blank"> Patrick Stapfer:让不合理的状态成为不可能</a></li><li id="b6cb" class="me mf iq jt b ju mn jy mo ky mp kz mq la mr ko mj mk ml mm bi translated"><a class="ae kp" href="https://youtu.be/-J8YyfrSwTk" rel="noopener ugc nofollow" target="_blank">有效毫升</a></li></ul></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="f628" class="lb lc iq bd ld le nd lg lh li ne lk ll lm nf lo lp lq ng ls lt lu nh lw lx ly bi translated">让我们添加触摸功能！</h1><p id="98cb" class="pw-post-body-paragraph jq jr iq jt b ju lz jw jx jy ma ka kb ky mb ke kf kz mc ki kj la md km kn ko ij bi translated">现在来看看酷的东西。</p><p id="19bf" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">让我们想想我们想要什么。我们希望导航抽屉能对触摸做出反应，但具体是如何做到的呢？</p><p id="e486" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">我们知道，当用户在打开的抽屉上滑动时，我们希望导航抽屉移动。让我们从那里开始，重新审视。</p><p id="43cf" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">将以下字段添加到<strong class="jt ir"> state.nav </strong>中:</p><pre class="kr ks kt ku gt nm mv nn no aw np bi"><span id="8a2b" class="nq lc iq mv b gy nr ns l nt nu">type <strong class="mv ir">nav</strong> = {<br/>  isOpen: bool,<br/>  <strong class="mv ir">isSwiping</strong>: ref(bool),<br/>  <strong class="mv ir">position</strong>: list(float)<br/>};</span></pre><blockquote class="jn jo jp"><p id="0585" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">注意:请务必更新您的<strong class="jt ir">初始状态</strong>以反映这些新字段。</p></blockquote><p id="56bb" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">注意<code class="fe ms mt mu mv b">isSwiping: ref(bool)</code> — <strong class="jt ir">中的<code class="fe ms mt mu mv b">ref</code>是一个<em class="js">实例变量</em>。更新此变量不会导致React重新渲染。点击了解更多关于<a class="ae kp" href="https://reasonml.github.io/reason-react/docs/en/instance-variables.html" rel="noopener ugc nofollow" target="_blank">的信息。</a></strong></p><p id="d1b8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated"><strong class="jt ir">位置</strong>是一个<a class="ae kp" href="https://reasonml.github.io/docs/en/list-and-array.html" rel="noopener ugc nofollow" target="_blank">列表</a>，我们将用它来跟踪触摸事件的<strong class="jt ir"> clientX </strong>。</p><p id="f838" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">添加以下<strong class="jt ir">动作</strong>变型:</p><pre class="kr ks kt ku gt nm mv nn no aw np bi"><span id="163a" class="nq lc iq mv b gy nr ns l nt nu">type <strong class="mv ir">action</strong> =<br/>  | Navigate(routeWithTitle)<br/>  | ToggleMenu(bool)<br/>  | <strong class="mv ir">TouchStart</strong>(float)<br/>  | <strong class="mv ir">TouchMove</strong>(float)<br/>  | <strong class="mv ir">TouchEnd</strong>(float);</span></pre><p id="b3bc" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">在我们的减速器中，我们将设置<strong class="jt ir">状态。当导航抽屉打开时，在<strong class="jt ir">触摸开始</strong>动作时，导航正在擦拭</strong>为<strong class="jt ir">真</strong>，在<strong class="jt ir">触摸结束</strong>动作时，设置<strong class="jt ir">假</strong>。</p><p id="eb18" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">在<strong class="jt ir">触摸开始</strong>动作时，我们会将<strong class="jt ir"> state.nav.position </strong>设置为一个只包含一个<strong class="jt ir"> clientX </strong>值的列表。在<strong class="jt ir">触摸移动</strong>动作上，我们将把<strong class="jt ir"> clientX </strong>值添加到列表中。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">部分来自<strong class="ak">减速器</strong>场</figcaption></figure><p id="a9d7" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">既然我们现在有了一个<strong class="jt ir"> clientX </strong>的列表，我们可以用<code class="fe ms mt mu mv b">List.hd(...)</code>得到第一个元素，用<code class="fe ms mt mu mv b">List.hd(List.rev(...))</code>得到最后一个元素。</p><p id="e302" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">我们称<code class="fe ms mt mu mv b">x</code>为第一项(第一次触摸)，称<code class="fe ms mt mu mv b">x'</code> ( <em class="js"> x </em> <em class="js">质数</em>)为最后一次触摸。那么，<code class="fe ms mt mu mv b">x’ -. x</code>就是用户滑动的距离。我们将使用这个距离通过CSS的<code class="fe ms mt mu mv b">translateX</code>来转换导航抽屉。</p><p id="8ada" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">然而，如果用户向右滑动，我们不希望翻译导航抽屉，因为它已经被打开到最大。</p><p id="670f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">因此，我们首先检查<code class="fe ms mt mu mv b">x' -. x</code>是否为正(向右滑动)，如果是，则返回<code class="fe ms mt mu mv b">0.0</code>。</p><p id="66cd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated"><code class="fe ms mt mu mv b">x’ -. x &gt; 0.0 ? 0.0 : x’ -. x</code></p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">部分来自<strong class="ak">渲染</strong>字段</figcaption></figure><p id="7624" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">瞧啊。我们现在翻译导航抽屉与用户的滑动同步。多酷啊！</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/715fb3905cfb4a2e68638df1e275a44b.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*CkNeh6EPff5dgcDTcKl_fg.gif"/></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">…但是，它关不上！</figcaption></figure></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="1bd8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">现在，我们希望当用户的滑动达到或超过“半闭”标记时，导航抽屉关闭。那很简单！现在让我们假设导航抽屉的宽度是300像素。</p><blockquote class="jn jo jp"><p id="e62b" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">注意:除了硬编码宽度，您还可以使用ReactRef in Reason 来获取对DOM中导航抽屉的引用，并读取它的clientWidth属性。</p></blockquote><p id="9631" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">我们可以只更新我们的<strong class="jt ir"> TouchEnd </strong>动作来检查最新的clientX是否小于导航抽屉宽度的一半，如果是，则将<strong class="jt ir"> state.nav.isOpen </strong>设置为<strong class="jt ir"> false </strong>。</p><pre class="kr ks kt ku gt nm mv nn no aw np bi"><span id="3ca3" class="nq lc iq mv b gy nr ns l nt nu">| <strong class="mv ir">TouchEnd</strong>(<strong class="mv ir">clientX</strong>) =&gt;<br/>  state.nav.isSwiping := false;<br/>  if (<strong class="mv ir">clientX</strong> &lt; <strong class="mv ir">300.0 /. 2.0</strong>) {<br/>    ReasonReact.Update({<br/>      ...state,<br/>      <strong class="mv ir">nav</strong>: {<br/>        ...state.nav,<br/>        <strong class="mv ir">isOpen</strong>: <strong class="mv ir">false</strong><br/>      }<br/>    });<br/>  } else {<br/>    ReasonReact.Update(state);<br/>  };</span></pre></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="9c27" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">快好了！最后一个目标是当用户用力滑动，但没有滑过“半闭”标记时，能够关闭导航。</p><p id="c9a4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">为此，我们需要记录时间。</p><p id="eadd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">我们更新我们的位置列表以跟踪<strong class="jt ir"> clientX </strong>以及<strong class="jt ir">时间</strong>。</p><pre class="kr ks kt ku gt nm mv nn no aw np bi"><span id="c7fc" class="nq lc iq mv b gy nr ns l nt nu">type <strong class="mv ir">nav</strong> = {<br/>  isOpen: bool,<br/>  isSwiping: ref(bool),<br/>  <strong class="mv ir">position</strong>: list(<strong class="mv ir">(float, float)</strong>)<br/>};</span></pre><blockquote class="jn jo jp"><p id="1b41" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">注意:列表的参数是一个元组，所以我们需要双括号。</p></blockquote><p id="67f6" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">我们绑定JavaScript的<code class="fe ms mt mu mv b">performance.now()</code>，并更新我们的<strong class="jt ir">缩减器</strong>。</p><p id="e299" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">在<strong class="jt ir"> TouchEnd </strong>中，我们将使用以下公式计算最新两个位置对的速度:</p><p id="aba6" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated"><code class="fe ms mt mu mv b">velocity = <strong class="jt ir">Δx / Δt = </strong>(x' -. x) / (t' -. t)</code></p><p id="d685" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">事实证明，<code class="fe ms mt mu mv b">-0.3 px/ms</code>或更小的速度是我觉得合适的阈值。同样，这是一个负数，因为用户应该只在左滑动时关闭导航抽屉。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="f816" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">我遇到的一个“陷阱”是当我试图做这样的事情时:</p><pre class="kr ks kt ku gt nm mv nn no aw np bi"><span id="086d" class="nq lc iq mv b gy nr ns l nt nu">| <strong class="mv ir">TouchEnd</strong>(<strong class="mv ir">clientX</strong>) =&gt;<br/>  let <strong class="mv ir">x'</strong> = clientX;<br/>  let <strong class="mv ir">t'</strong> = now();<br/>  let velocity =<br/>    switch state.nav.position {<br/>    | [] =&gt; 0.0<br/>    | [(<strong class="mv ir">x</strong>, <strong class="mv ir">t</strong>), ..._] =&gt; <strong class="mv ir">(x' -. x) /. (t' -. t)</strong><br/>    };</span></pre><p id="37f8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">问题是<strong class="jt ir"> TouchEnd </strong>的<strong class="jt ir"> clientX </strong>和最后一个<strong class="jt ir"> TouchMove </strong>的<strong class="jt ir"> clientX </strong>是一样的，这样总会导致<strong class="jt ir">速度</strong>为<strong class="jt ir"> 0.0 </strong>。</p><p id="edb7" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">使用位置列表中的最后两个元素效果很好。</p><pre class="kr ks kt ku gt nm mv nn no aw np bi"><span id="315a" class="nq lc iq mv b gy nr ns l nt nu">| TouchEnd(clientX) =&gt;<br/>  let velocity =<br/>    switch state.nav.position {<br/>    | [] =&gt; 0.0<br/>    | [_] =&gt; 0.0<br/>    | [(<strong class="mv ir">x'</strong>, <strong class="mv ir">t'</strong>), (<strong class="mv ir">x</strong>, <strong class="mv ir">t</strong>), ..._] =&gt; <strong class="mv ir">(x' -. x) /. (t' -. t)</strong><br/>    };</span></pre></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="a668" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">现在你知道了！用Reason和ReasonReact构建的支持离线的应用程序外壳。尽情享受吧！</p><p id="34d4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">检查<a class="ae kp" href="https://github.com/persianturtle/reason-app-shell-starter-kit" rel="noopener ugc nofollow" target="_blank">源代码</a>以查看最新的实现。</p><p id="f427" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">一如既往，敬请期待更多！</p></div></div>    
</body>
</html>