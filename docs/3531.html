<html>
<head>
<title>gRPC GO Microservices on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes上的gRPC GO微服务</h1>
<blockquote>原文：<a href="https://itnext.io/grpc-go-microservices-on-kubernetes-bcb6267e9f53?source=collection_archive---------2-----------------------#2020-01-04">https://itnext.io/grpc-go-microservices-on-kubernetes-bcb6267e9f53?source=collection_archive---------2-----------------------#2020-01-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/></div><div class="ab cl jq jr hx js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="im in io ip iq"><h1 id="2b78" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">介绍</h1><p id="317e" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">最近，我正在研究在云上运行<a class="ae lt" href="https://en.wikipedia.org/wiki/Microservices" rel="noopener ugc nofollow" target="_blank"><strong class="kx iu"/></a>微服务的<strong class="kx iu">最具成本效益的方式</strong>。两个流行的选项是<a class="ae lt" href="https://en.wikipedia.org/wiki/Serverless_computing" rel="noopener ugc nofollow" target="_blank"> <strong class="kx iu">无服务器</strong> </a>云函数和<a class="ae lt" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx iu"> Kubernetes </strong> </a>上的容器。我计划将来写一篇关于无服务器与Kubernetes的文章，但简单地说，与非常复杂的<strong class="kx iu"> Kubernetes </strong>相比，像<a class="ae lt" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx iu"> AWS Lambda </strong> </a>这样的无服务器功能运行起来非常<strong class="kx iu">便宜</strong>并且<strong class="kx iu">容易</strong>上手。无服务器的一个问题是，这些功能与许多其他云服务集成，并以这种方式工作，随着应用程序的扩展，其中一些服务可能会变得非常昂贵。这就是为什么一些公司从无服务器转向Kubernetes，以更好地控制成本和减少开支。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/6a85d02df32945df5af2b3addac259c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/0*upEX3s5PVPZsp7E1"/></div></figure><p id="7c83" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated">我已经谈到了Quarkus，这是一个很好的框架，可以用来编写在Kubernetes上非常高效运行的云原生Java应用程序。Quarkus的内存占用更少，因此您可以以更低的成本获得更多的计算能力，也就是说，在集群中运行更多的容器。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mh"><img src="../Images/34cf89f19a1a49ec1334d1084c320db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kvqgXO6gjr01qGcx"/></div></div></figure><p id="3bd1" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated">但是，我们能做得更好吗？有两个方面需要考虑:一个是通信协议，另一个是编程语言。</p><h1 id="bc55" class="jx jy it bd jz ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku bi translated">gRPC</h1><p id="f37b" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我已经在<a class="ae lt" href="https://medium.com/@javier.ramos1/service-mesh-vs-kafka-f60c00044f20" rel="noopener">之前的一篇文章</a>中谈到过<strong class="kx iu">休息</strong>vs<strong class="kx iu">卡夫卡</strong>。我知道比较这两种技术听起来有点疏远，但是有两种流行的通信方式。<strong class="kx iu"> Kafka </strong>用于<strong class="kx iu">事件驱动的</strong>微服务和异步处理，特别是流处理。REST或HTTP服务主要用于同步通信。为了更容易部署、运行和维护您的服务，创建了<a class="ae lt" href="https://en.wikipedia.org/wiki/Service_mesh" rel="noopener ugc nofollow" target="_blank">服务网格</a>。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/f6759cc929538eeacef1a55e102438a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*mqCmxlAUvwA55P4o"/></div></figure><p id="dc44" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated"><strong class="kx iu"> Google </strong>提出了另一个解决方案，即<a class="ae lt" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx iu"> gRPC </strong> </a>，现在由云原生基金会维护。这个想法并不新鲜，它类似于CORBA或Java<a class="ae lt" href="https://en.wikipedia.org/wiki/Enterprise_JavaBeans" rel="noopener ugc nofollow" target="_blank"><strong class="kx iu">EJB</strong></a>，它们是<a class="ae lt" href="https://en.wikipedia.org/wiki/Remote_procedure_call" rel="noopener ugc nofollow" target="_blank">远程过程调用</a>。但在相当多的方面是独一无二的。<strong class="kx iu">主要部件</strong>有:</p><ul class=""><li id="9846" class="ms mt it kx b ky mc lc md lg mu lk mv lo mw ls mx my mz na bi translated"><a class="ae lt" href="https://en.wikipedia.org/wiki/Protocol_Buffers" rel="noopener ugc nofollow" target="_blank"> <strong class="kx iu"> Protobuf </strong> </a>(协议缓冲区):gRPC使用该协议进行通信，这是Google为了克服REST架构中使用JSON的局限性而创建的二进制通信协议。它是二进制的，这意味着它需要更少的CPU和内存，因此性能更好。它还具有语义意义，因此模式在定义中允许我们有更多的灵活性。</li><li id="4300" class="ms mt it kx b ky nb lc nc lg nd lk ne lo nf ls mx my mz na bi translated"><a class="ae lt" href="https://en.wikipedia.org/wiki/HTTP/2" rel="noopener ugc nofollow" target="_blank"> <strong class="kx iu"> HTTP/2 </strong> </a> : gRPC采用新的HTTP规范，支持双向通信、服务器数据推送、压缩和复用。这使我们能够使用HTTP协议以更有效的方式实时传输数据。</li></ul><p id="7357" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated">gRPC可以跨多种编程语言工作，非常高效。从REST迁移到gRPC可以减少所需的资源量，并允许我们在集群中运行更多的容器，从而消耗更少的资源。这是提高性能和降低成本的好方法。请注意，HTTP/2仍然没有得到广泛的支持，特别是在web浏览器中，尽管已经开发了<a class="ae lt" href="https://github.com/grpc/grpc-web" rel="noopener ugc nofollow" target="_blank"> <strong class="kx iu"> gRPC Web </strong> </a>来解决这个问题。<a class="ae lt" href="https://github.com/grpc-ecosystem/grpc-gateway" rel="noopener ugc nofollow" target="_blank"> <strong class="kx iu"> gRPC Gateway </strong> </a>是一个工具，它允许我们生成具有相同定义的REST和gRPC服务，允许我们支持旧客户端。gRPC还支持使用反射的服务发现，您可以使用<em class="ng"> cli </em>交互地查询您的服务。一般来说，建议开始将内部服务迁移到gRPC，并使用REST提供面向外部的API，因为REST提供了更多工具，如服务网格和API管理。</p><p id="ebd1" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated">它的工作方式是:你创建一个<em class="ng">。proto </em>文件，然后使用protobuf编译器为给定的语言生成存根文件(调用服务的代码)。您可以为多种语言创建存根，它们都可以相互通信。</p><h1 id="7b6e" class="jx jy it bd jz ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku bi translated">去</h1><p id="1b82" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><a class="ae lt" href="https://en.wikipedia.org/wiki/Go_(programming_language)" rel="noopener ugc nofollow" target="_blank"> <strong class="kx iu"> Go </strong> </a>是谷歌出于并发和并行的考虑而创造的一种编程语言。它是一种强类型语言，使得并发微服务的开发变得非常容易和高效。它还被编译成高效的二进制代码，这使得它成为在容器中运行的最佳选择。随意尝试他们网站上的<a class="ae lt" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx iu">教程</strong> </a>来熟悉这门语言。事实证明，Go可能是继C++之后更高效的语言，但它使用起来要简单得多。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nh"><img src="../Images/dfaac149453d18137a810afef128ae4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rwvtao5HGOfGLI-U"/></div></div></figure><p id="b0bb" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated">我相信gRPC和Go的<strong class="kx iu">组合是在Kubernetes上运行应用程序的一个非常好的工具包，非常高效和便宜</strong>。与使用常规的Spring Boot容器或node.js相比，您可以在相同的硬件上运行更多的服务</p><h1 id="33e9" class="jx jy it bd jz ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku bi translated">把手举起来。</h1><p id="924a" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">那么，我如何使用gRPC构建Go微服务呢？这很简单。首先，您需要使用协议缓冲区来定义对象和服务。这是一个简单的服务定义:</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">gRPC服务</figcaption></figure><p id="e5d1" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated">您需要定义一个包，在Go中生成服务存根时将使用这个包。然后定义protobuf消息，它有一个类型和名称，然后是一个序列号。然后定义一个简单的服务。</p><p id="1ae9" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated">然后需要安装<a class="ae lt" href="https://github.com/golang/protobuf" rel="noopener ugc nofollow" target="_blank"> <strong class="kx iu">编译器</strong> </a>并运行:</p><pre class="lv lw lx ly gt no np nq nr aw ns bi"><span id="0c83" class="nt jy it np b gy nu nv l nw nx">protoc grpcapi.proto --go_out=plugins=grpc:.</span></pre><p id="ecd3" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated">要为Go服务生成代码，您也可以为其他语言生成存根。这将生成一个<em class="ng"> grpcapi.pb.go </em>文件，其中包含与服务交互所需的go代码，服务器和客户端都需要这个文件。你可以在这里找到API <a class="ae lt" href="https://github.com/javiramos1/grpcapi" rel="noopener ugc nofollow" target="_blank">的源代码</a>。</p><p id="2f83" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated">一旦你有了服务，你需要做的就是编写服务器和客户端。我不会深入代码的细节，因为它实际上很容易理解。我们所做的就是实现在<em class="ng"> grpcapi.pb.go </em>文件中定义的接口。</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">Go服务器</figcaption></figure><p id="0227" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated">我们所做的就是实现GrpcService方法，然后启动服务器。我们使用一个通道来检测服务何时存在，以关闭连接。我们还使用了环境变量，因此我们可以从Kubernetes设置主机和端口，尽管为了简单起见我跳过了这一步。你可以在这里找到服务器代码<a class="ae lt" href="https://github.com/javiramos1/grpc_server" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="c0a2" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated"><strong class="kx iu">客户端</strong>也很简单:</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">转到客户端</figcaption></figure><p id="f8f3" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated">客户端还导入API并进行RPC调用。如果我们愿意，我们还可以通过保持连接开放来实时传输数据。你可以在这里找到源代码<a class="ae lt" href="https://github.com/javiramos1/grpc_client" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="17be" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated">要测试服务器运行:</p><pre class="lv lw lx ly gt no np nq nr aw ns bi"><span id="cd54" class="nt jy it np b gy nu nv l nw nx">go run server.go</span></pre><p id="ef60" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated">要测试在另一个终端上运行的客户端:</p><pre class="lv lw lx ly gt no np nq nr aw ns bi"><span id="4876" class="nt jy it np b gy nu nv l nw nx">go run client.go</span></pre><h1 id="a588" class="jx jy it bd jz ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku bi translated">库伯内特斯</h1><p id="1e94" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在Kubernetes中运行服务器非常简单。首先，我们需要构建源代码来创建二进制文件:</p><pre class="lv lw lx ly gt no np nq nr aw ns bi"><span id="ac0c" class="nt jy it np b gy nu nv l nw nx">CGO_ENABLED=0 GOOS=linux go build -o grpc_server -ldflags "-s -w -a -installsuffix cgo server.go</span></pre><p id="ba15" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated">这将为Linux创建一个没有依赖关系的二进制文件。</p><p id="2de6" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated">然后创建并推送映像:</p><pre class="lv lw lx ly gt no np nq nr aw ns bi"><span id="5f52" class="nt jy it np b gy nu nv l nw nx">docker build -t javierramos1/grpc_server .                       docker push javierramos1/grpc_server</span></pre><p id="357e" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated">现在我们已经有了存储库中的图像，我们可以将它部署到Kubernetes。可以用<a class="ae lt" href="https://microk8s.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx iu"> MicroK8s </strong> </a>来测试一下。您可以首先在Docker中运行以下命令来测试它:</p><pre class="lv lw lx ly gt no np nq nr aw ns bi"><span id="0c61" class="nt jy it np b gy nu nv l nw nx">docker run --rm -p 50051:50051 javierramos1/grpc_server</span></pre><p id="4bf0" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated">使用客户端再次测试。</p><p id="ab3a" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated">一旦你安装了MicroK8s。您可以运行以下命令将它部署到Kubernetes:</p><pre class="lv lw lx ly gt no np nq nr aw ns bi"><span id="3728" class="nt jy it np b gy nu nv l nw nx">kubectl run grpcserver --image=javierramos1/grpc_server --port=50051 --expose</span></pre><p id="4273" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated">这将创建一个部署和一个服务。使用:</p><pre class="lv lw lx ly gt no np nq nr aw ns bi"><span id="fe82" class="nt jy it np b gy nu nv l nw nx">kubectl get services</span></pre><p id="60f5" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated">获取部署的IP地址并相应地更改客户端来测试服务。</p><p id="dbee" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated">这就是你在Kubernetes上运行的微服务。您可以将其扩展到数千个单元，以检查gRPC和Go的效率和速度。</p><p id="a65b" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated">如果您有任何问题，请告诉我，并随时在Twitter上关注我。</p></div><div class="ab cl jq jr hx js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="im in io ip iq"><p id="7721" class="pw-post-body-paragraph kv kw it kx b ky mc la lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls im bi translated">我希望你喜欢这篇文章。欢迎发表评论或分享这篇文章。跟随<a class="ae lt" href="https://twitter.com/JavierRamosRod7" rel="noopener ugc nofollow" target="_blank"><strong class="kx iu"><em class="ng">me</em></strong></a><em class="ng">进行未来的帖子。</em></p></div></div>    
</body>
</html>