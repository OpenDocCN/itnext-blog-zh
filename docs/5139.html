<html>
<head>
<title>A beginner’s guide to deploying a Docker application to production using Docker Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker Compose将Docker应用程序部署到生产环境的初学者指南</h1>
<blockquote>原文：<a href="https://itnext.io/a-beginners-guide-to-deploying-a-docker-application-to-production-using-docker-compose-de1feccd2893?source=collection_archive---------0-----------------------#2020-12-20">https://itnext.io/a-beginners-guide-to-deploying-a-docker-application-to-production-using-docker-compose-de1feccd2893?source=collection_archive---------0-----------------------#2020-12-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="c499" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Docker: Docker撰写</h2><div class=""/><div class=""><h2 id="0f97" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">在这一课中，我们将学习Docker Compose如何工作，以及如何在生产环境中使用它来部署和管理多个容器。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/43ccdb4d60022a20ca08e39d8ea35f7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5MAdb24J-ON0IxFPg-uS_w.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(来源:<a class="ae lh" href="https://unsplash.com/photos/Z-HBjM62f6M" rel="noopener ugc nofollow" target="_blank"><strong class="bd li">unsplash.com</strong></a>)</figcaption></figure><p id="75b8" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在<a class="ae lh" href="https://medium.com/sysf/docker/home" rel="noopener"> <strong class="ll jd">之前的课程</strong> </a>中，我们讨论了Docker的基础知识。我们学习了Docker容器的构造，Docker文件的结构，如何创建图像，如何管理容器，等等。这只是我们操作Docker需要知道的基本信息。</p><p id="ad15" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果我们的应用程序像HTTP服务器一样简单，我们可以在一个Docker容器中运行它。您可以创建一个定制的Docker映像，将应用程序代码复制到映像中，并从中运行一个容器。您可以安装一个用于永久数据存储的卷，并将主机上的一个端口绑定到容器上的端口，以公开您的服务。就是这样。之后，我们需要手动监控容器，以防它关闭。</p><p id="be12" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">然而，实际上，我们的应用程序是由不同的服务组成的。例如，我们可能有一个为web应用程序服务的前端服务，一个为前端提供REST API的后端服务，以及一个存储用户数据的数据库服务。</p><p id="0ba9" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这些服务可以相互依赖。例如，前端服务依赖于后端服务，后端服务依赖于数据库服务。除非我们启动并运行所有的服务，否则我们的应用程序将无法正常运行。它们可能需要以正确的顺序启动，才能顺利进行。</p><p id="c187" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">手动操作很麻烦。不是团队中的每个人都知道整个应用程序的上下文。这是一个很大的元数据，你不能把事情搞砸。你需要某种<strong class="ll jd">编排工具</strong>来自动管理你的服务。您希望这个工具配置您的服务、管理启动和关闭以及处理故障。这就是<strong class="ll jd"> Docker Compose </strong>的用武之地。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="946f" class="mm mn it bd li mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">Docker撰写</h1><p id="392f" class="pw-post-body-paragraph lj lk it ll b lm nd kd lo lp ne kg lr ls nf lu lv lw ng ly lz ma nh mc md me im bi translated">Docker Compose是一个管理多容器应用程序的工具，比如我们上面讨论的web应用程序。每个<strong class="ll jd">容器充当一个服务</strong>，为应用程序的整个功能提供贡献。这个模型被称为<a class="ae lh" href="https://blog.back4app.com/caas-container-as-a-service/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd"> CaaS </strong> </a>(容器即服务)。</p><blockquote class="ni nj nk"><p id="8fb7" class="lj lk nl ll b lm ln kd lo lp lq kg lr nm lt lu lv nn lx ly lz no mb mc md me im bi translated"><em class="it">💡</em>如果您使用Docker for Desktop，例如macOS和Windows操作系统，那么您已经安装了Docker Compose，否则您可以从<a class="ae lh" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">此</strong> </a>页面手动下载。</p></blockquote><p id="46f2" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">Docker Compose不是Docker Engine的一部分，因此必须单独安装。像Docker Engine一样，Docker Compose为我们提供了一个命令行界面(CLI)来与之交互。您可以通过运行<code class="fe np nq nr ns b">$ docker-compose --version</code>命令来验证它的安装。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/d23e78fac739fd8b10e42e9d6f67e00e.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*H89qsREKjiZvmhH0d7PPOQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker-撰写-版本</figcaption></figure><p id="2212" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">那么Docker是如何作曲的呢？Docker Compose只是一个编排工具，仅此而已。作为一个人，您会做些什么来构建映像、启动、停止和监控容器、对运行中的容器进行健康检查、处理故障等。，Docker Compose会为您做到这一点。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/ea9e5dfaef8bdba4b9719df910b89bf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*elSgXXdVPeHNN5rDoCNviw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker-撰写-帮助</figcaption></figure><p id="316f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在构建Docker映像时，<code class="fe np nq nr ns b">$ docker build</code>命令查看<code class="fe np nq nr ns b">Dockerfile</code>并逐层构建映像。类似地，<code class="fe np nq nr ns b">$ docker-compose</code>子命令查看<code class="fe np nq nr ns b">docker-compose.yml</code>文件并运行指令。这些指令配置要运行的服务(<em class="nl">容器</em>)。</p><p id="5fb3" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe np nq nr ns b">docker-compose.yml</code>文件被称为<strong class="ll jd">合成文件</strong>，因为它使用Docker Compose来合成服务。与Dockerfile不同，该文件遵循<a class="ae lh" href="https://en.wikipedia.org/wiki/YAML" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd"> YAML </strong> </a>语法，这就是为什么您也可以对该文件使用<code class="fe np nq nr ns b">.yaml</code>扩展名。</p><blockquote class="ni nj nk"><p id="f683" class="lj lk nl ll b lm ln kd lo lp lq kg lr nm lt lu lv nn lx ly lz no mb mc md me im bi translated"><em class="it">💡</em>当我们运行<code class="fe np nq nr ns b">$ docker-compose</code>命令时，Docker Compose默认在当前目录中查找名为<code class="fe np nq nr ns b">docker-compose.yml/.yaml</code>的文件，但是，您可以使用<code class="fe np nq nr ns b">-f</code>或<code class="fe np nq nr ns b">--file</code>标志覆盖文件路径。也可以使用JSON文件(。json)，因为YAML是JSON的超集。</p></blockquote><p id="059c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">合成文件包含服务列表。服务包含要运行的容器的配置。该配置可以指定哪个Docker映像用于容器、安装什么卷、暴露什么端口等。Docker Compose还可以在启动服务时动态构建Docker映像(<em class="nl">来自Dockerfile </em>)。</p><p id="2786" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">合成文件还可以创建服务可以使用的卷。它还可以配置服务可能加入的网络。我们还可以定义每个服务必须启动和关闭的启动顺序。Docker Compose是一个非常强大的工具，它将我们从手动管理容器的负担中解放出来。所以让我们开始吧。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="8f78" class="mm mn it bd li mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">撰写文件</h1><p id="1b77" class="pw-post-body-paragraph lj lk it ll b lm nd kd lo lp ne kg lr ls nf lu lv lw ng ly lz ma nh mc md me im bi translated">合成文件是一个YAML文件，它提供服务以及网络、卷、环境变量等的配置。由服务使用(<em class="nl">它们的容器</em>)。这个文件通常被命名为<code class="fe np nq nr ns b">docker-compose.yml</code>，放在项目目录中。当我们从项目目录中运行<code class="fe np nq nr ns b">$ docker-compose [options] &lt;subcommand&gt; [suboptions]</code>命令时，Docker Compose将读取这个文件来分析服务，以便它可以启动、停止服务或对它们做其他事情。</p><blockquote class="ni nj nk"><p id="e81c" class="lj lk nl ll b lm ln kd lo lp lq kg lr nm lt lu lv nn lx ly lz no mb mc md me im bi translated"><em class="it">💡</em>与Dockerfile不同，Compose file提供了大量选项，这就是为什么很难在一篇文章中描述每一件小事。我会尽力报道重要的话题。要了解更多信息，您可以随时按照<a class="ae lh" href="https://docs.docker.com/compose/compose-file" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">本</strong> </a>官方文档进行撰写文件参考。</p></blockquote><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(来源:<a class="ae lh" href="https://gist.github.com/thatisuday/e68b4003629da23bb317c009cb34ba14" rel="noopener ugc nofollow" target="_blank"><strong class="ak">gist.github.com</strong></a>)</figcaption></figure><p id="eabc" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">一个典型的<code class="fe np nq nr ns b">docker-compose.yml</code>文件看起来如上。<code class="fe np nq nr ns b">version</code>键指定要使用的合成文件的版本。目前最新版本是<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/compose-file/" rel="noopener ugc nofollow" target="_blank">3.9</a></code>(<em class="nl">2020年12月</em>)。特定的合成文件版本与特定的Docker引擎版本兼容，<a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-versioning/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">这里的</strong> </a>是兼容性矩阵。</p><blockquote class="ni nj nk"><p id="195d" class="lj lk nl ll b lm ln kd lo lp lq kg lr nm lt lu lv nn lx ly lz no mb mc md me im bi translated"><em class="it">💡</em>典型的合成文件版本是以<code class="fe np nq nr ns b">&lt;major&gt;:&lt;minor&gt;</code>发布的形式。如果我们省略了<code class="fe np nq nr ns b">:&lt;minor&gt;</code>部分，Docker Compose会自动假定为<code class="fe np nq nr ns b">0</code>次要版本，这就是为什么我们应该明确提到次要版本。</p></blockquote><p id="5943" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">使用<code class="fe np nq nr ns b">services</code>字段，我们定义Docker编写应该启动的容器(<em class="nl">服务</em>)。在上面的组合文件中，我们有三个服务，即<code class="fe np nq nr ns b">database</code>、<code class="fe np nq nr ns b">frontend</code>和<code class="fe np nq nr ns b">backend</code>。Docker Compose将使用这些服务名来命名将要创建的映像、容器或卷。</p><p id="6bc7" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe np nq nr ns b">database</code>服务(<em class="nl">容器</em>)使用了<code class="fe np nq nr ns b">mysql:latest</code>图像。我们使用服务的<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#image" rel="noopener ugc nofollow" target="_blank">image</a></code>字段定义应该从哪个图像创建容器。Docker从Docker Hub下载这个映像并创建一个容器。默认情况下，该容器将公开<code class="fe np nq nr ns b">3306</code>端口，并按照其<a class="ae lh" href="https://github.com/docker-library/mysql/blob/ee33a2144a0effe9459abf02f20a6202ae645e94/8.0/Dockerfile.debian" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>的指定运行MySQL服务器。这是合成文件中服务的最低配置。</p><p id="0a9d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe np nq nr ns b">backend</code>服务使用来自Docker Hub的<code class="fe np nq nr ns b">node:latest</code>图像。然而，我们为容器启动做了一些额外的配置。首先，我们使用<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#domainname-hostname-ipc-mac_address-privileged-read_only-shm_size-stdin_open-tty-user-working_dir" rel="noopener ugc nofollow" target="_blank">working_dir</a></code>字段将<code class="fe np nq nr ns b">/app</code>设置为容器的工作目录。然后，我们使用<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#volumes" rel="noopener ugc nofollow" target="_blank">volumes</a></code>字段将主机的<code class="fe np nq nr ns b">./backend</code>目录挂载到容器的<code class="fe np nq nr ns b">/app</code>目录。然后我们使用<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#command" rel="noopener ugc nofollow" target="_blank">command</a></code>字段执行<code class="fe np nq nr ns b">node ./server.js</code>命令，这将启动一个HTTP服务器，而<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#expose" rel="noopener ugc nofollow" target="_blank">expose</a></code>字段指定要公开的容器端口。</p><blockquote class="ni nj nk"><p id="28cf" class="lj lk nl ll b lm ln kd lo lp lq kg lr nm lt lu lv nn lx ly lz no mb mc md me im bi translated"><em class="it">💡</em>合成文件中使用的所有(主机的)相对路径将相对于<code class="fe np nq nr ns b">docker-compose.yml</code>文件。<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#entrypoint" rel="noopener ugc nofollow" target="_blank">entrypoint</a></code>、<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#domainname-hostname-ipc-mac_address-privileged-read_only-shm_size-stdin_open-tty-user-working_dir" rel="noopener ugc nofollow" target="_blank">working_dir</a></code>、<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#command" rel="noopener ugc nofollow" target="_blank">command</a></code>和<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#expose" rel="noopener ugc nofollow" target="_blank">expose</a></code>字段值会覆盖从其创建容器的映像的<code class="fe np nq nr ns b">ENTRYPOINT</code>、<code class="fe np nq nr ns b">WORKDIR</code>、<code class="fe np nq nr ns b">CMD</code>和<code class="fe np nq nr ns b">EXPOSE</code>指令。</p></blockquote><p id="9ff3" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">服务不使用公共图像。我们不使用<code class="fe np nq nr ns b">image</code>字段，而是使用<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#build" rel="noopener ugc nofollow" target="_blank">build</a></code>字段指定上下文目录的路径。Docker Compose将为该服务的容器动态创建一个图像。您还可以使用对象配置指定自定义Dockerfile路径和上下文目录，如这里的<a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#build" rel="noopener ugc nofollow" target="_blank">所述</a>。</p><p id="1aca" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#ports" rel="noopener ugc nofollow" target="_blank">ports</a></code>字段将主机端口与暴露的容器端口绑定在一起。该字段提供了更多配置选项，如本文中<a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#ports" rel="noopener ugc nofollow" target="_blank">所述。<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#depends_on" rel="noopener ugc nofollow" target="_blank">depends_on</a></code>字段控制服务如何启动。在上面的例子中，由于<code class="fe np nq nr ns b">frontend</code>服务依赖于<code class="fe np nq nr ns b">database</code>和<code class="fe np nq nr ns b">backend</code>服务，所以它们被首先启动。一旦这些服务(<em class="nl">容器</em>)被启动，<code class="fe np nq nr ns b">frontend</code>服务(<em class="nl">容器</em>)将被创建。</a></p><h2 id="7f02" class="nx mn it bd li ny nz dn mr oa ob dp mv ls oc od mx lw oe of mz ma og oh nb iz bi translated">覆盖合成文件</h2><p id="f3ad" class="pw-post-body-paragraph lj lk it ll b lm nd kd lo lp ne kg lr ls nf lu lv lw ng ly lz ma nh mc md me im bi translated">通常，我们的应用程序会经历多种环境。首先，我们在本地机器上开发应用程序，然后我们将它放在QA的试运行环境中，然后放在CI服务器上进行测试，最后它进入生产环境。</p><p id="9535" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在这些环境中运行应用程序服务的配置不会总是相同的。例如，您可能希望在开发环境中公开服务的不同端口，如<code class="fe np nq nr ns b">8080</code>，而在生产环境中，您的理想选择是<code class="fe np nq nr ns b">80</code>。</p><p id="118e" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们可以使用构建参数或环境变量来控制这些值(下一个中讨论的<em class="nl">，但是有时你需要一个配置变更，而使用这些变量是无法实现的。所以理想的选择是每个环境有多个合成文件，并使用<code class="fe np nq nr ns b">--file</code>或<code class="fe np nq nr ns b">-f</code>标志来决定使用哪个配置文件。</em></p><p id="9f0c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">然而，如果您的配置文件很大，并且您需要在多个环境中部署您的应用程序，那么管理多个配置文件就成了一项单调乏味的任务。有更好的出路。使用<code class="fe np nq nr ns b">-f</code>标志，我们可以指定多个合成文件。Docker Compose将从右到左合并这些文件，并准备最终的合成配置。</p><pre class="ks kt ku kv gt oi ns oj ok aw ol bi"><span id="028d" class="nx mn it ns b gy om on l oo op">$ docker-compose -f compose.yml -f compose.dev.yml ...</span></pre><p id="0818" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe np nq nr ns b">$ docker-compose</code>命令可以接受多个合成文件。然后，它将从右到左合并配置。在上述情况下，<code class="fe np nq nr ns b">compose.dev.yml</code>文件会覆盖<code class="fe np nq nr ns b">compose.yml</code>文件的配置。</p><blockquote class="ni nj nk"><p id="1235" class="lj lk nl ll b lm ln kd lo lp lq kg lr nm lt lu lv nn lx ly lz no mb mc md me im bi translated"><em class="it">💡</em>我们可以有多个覆盖文件。只需在<code class="fe np nq nr ns b">$ docker-compose</code>命令中使用<code class="fe np nq nr ns b">-f</code>标志指定额外的覆盖文件，结果配置将通过从右到左合并文件来创建。</p></blockquote><p id="e805" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果没有提供<code class="fe np nq nr ns b">-f</code>标志，Docker Compose将在当前目录中查找<code class="fe np nq nr ns b">docker-compose.yml</code>文件。它还会在当前目录中查找<code class="fe np nq nr ns b">docker-compose.override.yml</code>文件，如果存在，它会覆盖<code class="fe np nq nr ns b">docker-compose.yml</code>文件。</p><p id="3bd3" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在覆盖文件中，配置的结构应该与它所覆盖的文件几乎一致。例如，如果我们想要覆盖一个服务的几个字段，那么<code class="fe np nq nr ns b">services &gt; service_name</code>字段应该在那里。如果我们在覆盖文件中引入一个新服务，它将被添加到最终配置中。让我们看看覆盖是如何工作的。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(来源:<a class="ae lh" href="https://gist.github.com/thatisuday/b0dca85227a2a0ca4a4bfb6950597c9d" rel="noopener ugc nofollow" target="_blank">gist.github.comT21</a>)</figcaption></figure><p id="9688" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">要验证并打印结果配置，您应该使用<code class="fe np nq nr ns b">$ docker-compose [options] <a class="ae lh" href="https://docs.docker.com/compose/reference/config/" rel="noopener ugc nofollow" target="_blank">config</a></code>命令。最终配置( <code class="fe np nq nr ns b"><em class="nl">result.yml</em></code>指示的<em class="nl">)由下面的命令生成。</em></p><pre class="ks kt ku kv gt oi ns oj ok aw ol bi"><span id="3f7b" class="nx mn it ns b gy om on l oo op">$ docker-compose -f docker-compose.yml -f docker-compose.prod.yml config</span></pre><p id="ab49" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们来分析一下结果。服务保持原样，因为我们没有覆盖它。<code class="fe np nq nr ns b">cache</code>服务进入最终配置，因为它是在覆盖文件中定义的。<code class="fe np nq nr ns b">backend</code>服务中的<code class="fe np nq nr ns b">image</code>字段被替换，因为它是单值字段。</p><p id="a125" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe np nq nr ns b">frontend</code>服务配置最有趣。新的<code class="fe np nq nr ns b">command</code>属性被添加到覆盖的最终配置中。多值字段不会被覆盖。相反，它们的值将被合并，如您在<code class="fe np nq nr ns b">depends_on</code>和<code class="fe np nq nr ns b">ports</code>字段中所见。但是，在<code class="fe np nq nr ns b">volumes</code>的情况下，如果容器目录相同，则只能存在一个挂载点。</p><blockquote class="ni nj nk"><p id="70fe" class="lj lk nl ll b lm ln kd lo lp lq kg lr nm lt lu lv nn lx ly lz no mb mc md me im bi translated"><em class="it">💡</em>要了解更多关于覆盖的信息，请阅读本 文档。</p></blockquote><h2 id="22fb" class="nx mn it bd li ny nz dn mr oa ob dp mv ls oc od mx lw oe of mz ma og oh nb iz bi translated">使用环境变量</h2><p id="2977" class="pw-post-body-paragraph lj lk it ll b lm nd kd lo lp ne kg lr ls nf lu lv lw ng ly lz ma nh mc md me im bi translated">环境变量可以用来替换<code class="fe np nq nr ns b">docker-compose.yml</code>文件中的变量。这在针对特定于环境的配置更改时非常有用。我们来看一个小例子。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(来源:<a class="ae lh" href="https://gist.github.com/thatisuday/17f261dcc2cbc46e8c87247f182277ff" rel="noopener ugc nofollow" target="_blank"><strong class="ak">gist.github.com</strong></a>)</figcaption></figure><p id="b928" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在上面的<code class="fe np nq nr ns b">docker-compose.yml</code>文件中，<code class="fe np nq nr ns b">${NGINX_VERSION}</code>、<code class="fe np nq nr ns b">${NGINX_WWW_DIR}</code>和<code class="fe np nq nr ns b">$NGINX_PORT</code>的值将被同名的环境变量提供的值所替代。</p><blockquote class="ni nj nk"><p id="fec6" class="lj lk nl ll b lm ln kd lo lp lq kg lr nm lt lu lv nn lx ly lz no mb mc md me im bi translated"><em class="it">💡</em>如果<code class="fe np nq nr ns b">NGINX_VERSION</code>环境变量不存在或为空，您可以使用<code class="fe np nq nr ns b">${NGINX_VERSION:-latest}</code>语法回退到<code class="fe np nq nr ns b">latest</code>值。要了解更多关于此类语法的信息，请阅读本 文档。</p></blockquote><p id="5f14" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">运行<code class="fe np nq nr ns b">$ docker-compose</code>命令时，将从shell环境中获取这些变量的值。如果shell环境中不存在某个环境变量，那么Docker会在合成文件的目录中查找该环境变量在<code class="fe np nq nr ns b">.env</code>文件中的值(如果存在，则查找<em class="nl">)。</em></p><pre class="ks kt ku kv gt oi ns oj ok aw ol bi"><span id="f195" class="nx mn it ns b gy om on l oo op"># .env file<br/>NGINX_WWW_DIR=./www<br/>NAME_WITH_QUOTES="John Doe"</span></pre><p id="7a2f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">该文件包含合成文件的默认环境变量。这是一个简单的文本文件，包含多对环境变量。因为shell不处理这个文件，所以双引号或单引号将被用作值的一部分，例如上面示例中的<code class="fe np nq nr ns b">"John Doe"</code>。</p><blockquote class="ni nj nk"><p id="c7d2" class="lj lk nl ll b lm ln kd lo lp lq kg lr nm lt lu lv nn lx ly lz no mb mc md me im bi translated"><em class="it">💡</em>你可以使用<code class="fe np nq nr ns b">--env-file</code>标志和<code class="fe np nq nr ns b">$ docker-compose</code>命令指定自定义<code class="fe np nq nr ns b">.env</code>文件的路径(<em class="it">如</em> <code class="fe np nq nr ns b"><em class="it">.prod.env</em></code>)。要了解更多<code class="fe np nq nr ns b">.env</code>文件格式，请阅读<a class="ae lh" href="https://docs.docker.com/compose/env-file/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">本</strong> </a>文档。</p></blockquote><p id="3f3c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe np nq nr ns b">docker-compose.yml</code>中的环境变量对于服务的容器不是自动可用的。因此，如果您想要传递在执行<code class="fe np nq nr ns b">$ docker-compose</code>命令期间出现的环境变量，您需要使用服务的<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#environment" rel="noopener ugc nofollow" target="_blank">environment</a></code>配置将它们手动传递给容器。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(来源:<a class="ae lh" href="https://gist.github.com/thatisuday/4d16688aa1461a58817a0e85cdf12736" rel="noopener ugc nofollow" target="_blank"><strong class="ak">gist.github.com</strong></a>)</figcaption></figure><p id="5769" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在上面的<code class="fe np nq nr ns b">docker-compose.yml</code>文件中，<code class="fe np nq nr ns b">environment</code>字段向容器提供环境变量值。由于<code class="fe np nq nr ns b">LOG_DIRECTORY</code>的值是固定的，所以不会改变。<code class="fe np nq nr ns b">LOG_PREFIX</code>的值取自合成文件可用的环境变量。如果我们没有为环境变量提供值，比如<code class="fe np nq nr ns b">LOG_LEVEL</code>，那么它的值也将从合成文件可用的环境变量中获取。</p><p id="2e87" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">您还可以使用服务配置的<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#env_file" rel="noopener ugc nofollow" target="_blank">env_file</a></code>字段来提供服务级别的<code class="fe np nq nr ns b">.env</code>文件。正如您所看到的，有多种方法可以为正在运行的服务提供环境变量(<em class="nl">容器</em>)。当同一个环境变量的值在多个上下文中可用时，Docker Compose决定使用哪个值。</p><pre class="ks kt ku kv gt oi ns oj ok aw ol bi"><span id="b320" class="nx mn it ns b gy om on l oo op">1. Value from the compose file (<em class="nl">environment</em>)<br/>2. Value from the shell environment (<em class="nl">of container</em>)<br/>3. Environment (.env) file (<em class="nl">env_file</em>)<br/>4. Dockerfile (<em class="nl">ENV instruction</em>)<br/>5. Value is not defined</span></pre><blockquote class="ni nj nk"><p id="4eed" class="lj lk nl ll b lm ln kd lo lp lq kg lr nm lt lu lv nn lx ly lz no mb mc md me im bi translated"><em class="it">💡</em>要了解Docker compose中的环境变量，请阅读<a class="ae lh" href="https://docs.docker.com/compose/environment-variables/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">本</strong> </a>文档。</p></blockquote><p id="0556" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果服务的映像是使用<code class="fe np nq nr ns b">build</code>字段而不是<code class="fe np nq nr ns b">image</code>字段动态构建的，那么通过<code class="fe np nq nr ns b">environment</code>字段提供的环境变量在构建期间不可用。这意味着如果Dockerfile正在进行一些变量替换，变量值将为空。为此，我们使用<strong class="ll jd">构建参数</strong>。</p><h2 id="345b" class="nx mn it bd li ny nz dn mr oa ob dp mv ls oc od mx lw oe of mz ma og oh nb iz bi translated">使用生成参数</h2><p id="6049" class="pw-post-body-paragraph lj lk it ll b lm nd kd lo lp ne kg lr ls nf lu lv lw ng ly lz ma nh mc md me im bi translated">构建参数是构建时环境变量。这些仅在从Dockerfile文件构建映像时可用。我们在Dockerfile文件中使用<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/engine/reference/builder/#arg" rel="noopener ugc nofollow" target="_blank">ARG</a></code>指令指定一个构建参数。</p><pre class="ks kt ku kv gt oi ns oj ok aw ol bi"><span id="2abf" class="nx mn it ns b gy om on l oo op"><em class="nl"># Dockerfile</em><br/>ARG tag=latest<br/>FROM node:<strong class="ns jd">$tag</strong></span><span id="8dc6" class="nx mn it ns b gy oq on l oo op">ARG working_directory<br/>WORKDIR <strong class="ns jd">$working_directory</strong></span></pre><p id="7d76" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这些可以用docker文件中的缺省值<code class="fe np nq nr ns b">ARG=VAL</code>来定义，或者只用名称来定义。在构建映像时，我们使用带有<code class="fe np nq nr ns b">$ docker build</code>命令的<code class="fe np nq nr ns b">--build-arg &lt;key&gt;=&lt;val&gt;</code>标志来覆盖或提供这些变量的值。在<code class="fe np nq nr ns b">docker-compose.yml</code>中，我们使用<code class="fe np nq nr ns b">build</code>对象的<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#args" rel="noopener ugc nofollow" target="_blank">args</a></code>字段来提供这些值。您可以为构建参数提供一个固定值，也可以从环境变量中替换它的值。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(来源:<a class="ae lh" href="https://gist.github.com/thatisuday/6973d29dfa2c9e8e181539e1b7ac1a79" rel="noopener ugc nofollow" target="_blank"><strong class="ak">gist.github.com</strong></a>)</figcaption></figure><p id="be2d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在上面的例子中，我们为<code class="fe np nq nr ns b">tag</code>构建参数提供了一个固定的<code class="fe np nq nr ns b">12.10.0</code>值，然而，<code class="fe np nq nr ns b">working_directory</code>的值取自<code class="fe np nq nr ns b">FRONTEND_WORDIR</code>环境变量的值。如果我们没有为一个构建参数(比如<code class="fe np nq nr ns b">log_level</code>)提供一个值，那么它的值也将从环境变量中获取。</p><blockquote class="ni nj nk"><p id="c0cc" class="lj lk nl ll b lm ln kd lo lp lq kg lr nm lt lu lv nn lx ly lz no mb mc md me im bi translated"><em class="it">💡</em>如果覆盖的合成文件在<code class="fe np nq nr ns b">environment</code>或<code class="fe np nq nr ns b">args</code>中有一个变量，该变量也存在于它所覆盖的合成文件中，那么它的值将被替换，而不是复制环境变量或构建参数。</p></blockquote></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="2aa3" class="mm mn it bd li mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">运行Docker撰写</h1><p id="5162" class="pw-post-body-paragraph lj lk it ll b lm nd kd lo lp ne kg lr ls nf lu lv lw ng ly lz ma nh mc md me im bi translated">到目前为止，我们已经讨论了合成文件的结构和语法。现在是时候看看Docker Compose在现实生活中是如何工作的了。为此，我们将创建一个由三个服务组成的示例web应用程序。使用<strong class="ll jd"> PHP-Apache </strong>服务器为浏览器中的web应用程序提供服务的<code class="fe np nq nr ns b">frontend</code>服务，使用<strong class="ll jd"> ExpressJS </strong> HTTP服务器为REST API提供服务的<code class="fe np nq nr ns b">backend</code>服务，以及使用<strong class="ll jd"> Redis </strong>服务器缓存API响应的<code class="fe np nq nr ns b">cache</code>服务。</p><pre class="ks kt ku kv gt oi ns oj ok aw ol bi"><span id="bfe0" class="nx mn it ns b gy om on l oo op"><strong class="ns jd">docker-compose-example/</strong><br/>├── .gitignore<br/>├── backend/<br/>|  ├── .dockerignore<br/>|  ├── Dockerfile<br/>|  ├── package-lock.json<br/>|  ├── package.json<br/>|  └── server.js<br/>├── docker-compose.yml<br/>└── www/<br/>   └── index.php</span></pre><blockquote class="ni nj nk"><p id="a123" class="lj lk nl ll b lm ln kd lo lp lq kg lr nm lt lu lv nn lx ly lz no mb mc md me im bi translated"><em class="it">💡</em>你可以在<a class="ae lh" href="https://github.com/course-one/docker-compose-example" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">这个</strong> </a> GitHub资源库中找到本文用到的上述文件和例子。</p></blockquote><p id="13c3" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe np nq nr ns b">docker-compose.yml</code>文件为我们的应用程序定义了服务。因为我们使用默认文件名，所以我们不需要在<code class="fe np nq nr ns b">$ docker-compose</code>命令中使用<code class="fe np nq nr ns b">-f</code>标志。为了使事情看起来简单，我们没有用其他合成文件覆盖这个文件。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(docker-compose.yml /来源:<a class="ae lh" href="https://gist.github.com/thatisuday/2abf8c5a4a49fcc11c12adfc66b84641" rel="noopener ugc nofollow" target="_blank"><strong class="ak">gist.github.com</strong></a>)</figcaption></figure><p id="20e2" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe np nq nr ns b">www/</code>目录包含网站的文件，我们将在其中显示用户列表。<code class="fe np nq nr ns b">index.php</code>是使用<code class="fe np nq nr ns b">&lt;ul&gt;&lt;li&gt;</code> HTML标签呈现这个列表的页面。对于这个服务，我们将使用<code class="fe np nq nr ns b"><a class="ae lh" href="https://hub.docker.com/_/php" rel="noopener ugc nofollow" target="_blank">php:8.0.0-apache-buster</a></code>映像创建一个<code class="fe np nq nr ns b">frontend</code>服务。默认情况下，该图像公开端口<code class="fe np nq nr ns b">80</code>，并提供来自<code class="fe np nq nr ns b">/var/www/html</code>目录的web内容。因此，我们将项目的<code class="fe np nq nr ns b">./www</code>目录(<em class="nl">主机目录</em>)挂载到容器的<code class="fe np nq nr ns b">/var/www/html</code>目录中。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(index.php/来源:<a class="ae lh" href="https://gist.github.com/thatisuday/fbdce0a853d1615459f4a321f64b4313" rel="noopener ugc nofollow" target="_blank"><strong class="ak">gist.github.com</strong></a>)</figcaption></figure><p id="4185" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe np nq nr ns b">frontend</code>服务中的<code class="fe np nq nr ns b">index.php</code>文件通过向<code class="fe np nq nr ns b">/users</code>端点上的<code class="fe np nq nr ns b">backend</code>服务发出GET请求来请求<code class="fe np nq nr ns b">users</code>。<code class="fe np nq nr ns b">backend</code>服务通过运行在Node上的Express服务器提供REST API。为此，我们将从<code class="fe np nq nr ns b">backend/</code>目录构建一个自定义映像。该自定义图像的父图像是<code class="fe np nq nr ns b"><a class="ae lh" href="https://hub.docker.com/_/node" rel="noopener ugc nofollow" target="_blank">node:15.4.0-alpine3.10</a></code>。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(docker file/source:<a class="ae lh" href="https://gist.github.com/thatisuday/6f35f28fa5c4b6c1c7f4d7bd23d3ad5d" rel="noopener ugc nofollow" target="_blank"><strong class="ak">gist.github.com</strong></a>)</figcaption></figure><p id="5baa" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">当<code class="fe np nq nr ns b">backend</code>服务在<code class="fe np nq nr ns b">/users</code>端点上收到GET请求时，它从<code class="fe np nq nr ns b"><a class="ae lh" href="https://jsonplaceholder.typicode.com/users" rel="noopener ugc nofollow" target="_blank">jsonplaceholder.typicode.com/users</a></code>公共URL获取用户列表，并请求<code class="fe np nq nr ns b">cache</code>服务存储它。下次它收到相同的请求时，它将使用缓存，而不是发出外部HTTP请求。</p><p id="d768" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe np nq nr ns b">cache</code>服务使用<code class="fe np nq nr ns b"><a class="ae lh" href="https://hub.docker.com/_/redis" rel="noopener ugc nofollow" target="_blank">redis:6.0.9-alpine</a></code>图像为其服务创建一个容器。默认情况下，该图像显示端口<code class="fe np nq nr ns b">6379</code>。因此，我们启动HTTP服务器的<code class="fe np nq nr ns b">server.js</code>脚本如下所示。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(server . js/source:<a class="ae lh" href="https://gist.github.com/thatisuday/c286d1f52437c53d64639330f2c6f791" rel="noopener ugc nofollow" target="_blank"><strong class="ak">gist.github.com</strong></a></figcaption></figure><p id="c159" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们看看上面的<code class="fe np nq nr ns b">server.js</code>文件。首先，我们在URL <code class="fe np nq nr ns b">redis://cache:6379</code>处连接一个Redis服务器(在节点上使用 <code class="fe np nq nr ns b"><a class="ae lh" href="https://github.com/NodeRedis/node-redis" rel="noopener ugc nofollow" target="_blank"><em class="nl">node-redis</em></a></code> <em class="nl">客户端的<em class="nl">)。好好看看网址。通常，Redis连接URL具有<code class="fe np nq nr ns b">redis://&lt;host&gt;:&lt;port&gt;</code>方案，其中<code class="fe np nq nr ns b">host</code>是Redis服务器的IP地址或<code class="fe np nq nr ns b">domain.name</code>，而<code class="fe np nq nr ns b">port</code>是Redis服务器监听传入请求的端口。</em></em></p><p id="c7c1" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在“<a class="ae lh" href="https://medium.com/sysf/a-beginners-guide-to-networking-in-docker-ca5b822fb935" rel="noopener"><strong class="ll jd">Docker</strong></a>”课程中，我们学习了Docker网络以及Docker如何使用主机名解析其他容器的IP地址。我们还使用了带有<code class="fe np nq nr ns b">$ docker run</code>的<code class="fe np nq nr ns b">--net-alias=&lt;alias&gt;</code>标志来为IP地址的解析提供一个定制的网络别名。</p><p id="c5be" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">当Docker Compose启动服务时，它将使用网络别名为每个服务创建一个容器。在这种情况下，网络别名将与服务名相同。因此，我们可以使用<code class="fe np nq nr ns b">redis://cache:6379</code> URL和<code class="fe np nq nr ns b">cache</code>，因为<code class="fe np nq nr ns b">host</code>将被解析为<code class="fe np nq nr ns b">cache</code>服务容器的IP地址。</p><blockquote class="ni nj nk"><p id="4c65" class="lj lk nl ll b lm ln kd lo lp lq kg lr nm lt lu lv nn lx ly lz no mb mc md me im bi translated"><em class="it">💡</em>同样的逻辑也适用于<code class="fe np nq nr ns b">frontend</code>服务中的<code class="fe np nq nr ns b">index.php</code>文件，我们从解析为<code class="fe np nq nr ns b">http://&lt;backend-container-ip&gt;/users</code>的<code class="fe np nq nr ns b"><a class="ae lh" href="http://backend/users" rel="noopener ugc nofollow" target="_blank">http://backend/users</a></code>端点提取来自<code class="fe np nq nr ns b">backend</code>服务的用户列表。</p></blockquote><p id="1ba2" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在<code class="fe np nq nr ns b">backend</code>服务中，我们已经将<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#init" rel="noopener ugc nofollow" target="_blank">init</a></code>字段设置为<code class="fe np nq nr ns b">true</code>。它将使用<code class="fe np nq nr ns b">--init</code>标志启动一个服务容器。我们已经在<a class="ae lh" href="https://medium.com/sysf/creating-your-first-docker-application-b0ce40ac67d1" rel="noopener"> <strong class="ll jd">这节</strong> </a>课中讨论了这个标志。它应该在运行Node.js应用程序时使用。</p><p id="c875" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们来讨论一下<code class="fe np nq nr ns b">depends_on</code>字段。<code class="fe np nq nr ns b">frontend</code>服务依赖于<code class="fe np nq nr ns b">backend</code>和<code class="fe np nq nr ns b">cache</code>服务，而<code class="fe np nq nr ns b">backend</code>服务依赖于<code class="fe np nq nr ns b">cache</code>服务。服务中的<code class="fe np nq nr ns b">depends_on</code>字段将帮助Docker构建一个<strong class="ll jd">启动订单</strong>。在我们的例子中，首先会启动<code class="fe np nq nr ns b">cache</code>服务，然后是<code class="fe np nq nr ns b">backend</code>服务，最后是<code class="fe np nq nr ns b">frontend</code>服务。</p><blockquote class="ni nj nk"><p id="fee3" class="lj lk nl ll b lm ln kd lo lp lq kg lr nm lt lu lv nn lx ly lz no mb mc md me im bi translated"><em class="it">💡</em>一个<strong class="ll jd">启动命令</strong>不是必须的，而是一个好的实践。例如，如果<code class="fe np nq nr ns b">backend</code>服务没有启动，那么<code class="fe np nq nr ns b">frontend</code>服务向<code class="fe np nq nr ns b">backend</code>服务发出的请求将会失败，这可能会导致<code class="fe np nq nr ns b">frontend</code>服务容器崩溃。</p></blockquote><p id="dab1" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">从上面的<code class="fe np nq nr ns b">docker-compose.yml</code>文件中，我们只将主机的端口<code class="fe np nq nr ns b">8080</code>绑定到<code class="fe np nq nr ns b">frontend</code>服务的端口<code class="fe np nq nr ns b">80</code>。这意味着我们将能够从浏览器中的<code class="fe np nq nr ns b">http://localhost:8080</code> URL访问<code class="fe np nq nr ns b">frontend</code>服务的Apache web服务器。</p><h2 id="e346" class="nx mn it bd li ny nz dn mr oa ob dp mv ls oc od mx lw oe of mz ma og oh nb iz bi translated">启动服务</h2><p id="9caf" class="pw-post-body-paragraph lj lk it ll b lm nd kd lo lp ne kg lr ls nf lu lv lw ng ly lz ma nh mc md me im bi translated">为了从<code class="fe np nq nr ns b">docker-compose.yml</code>文件启动服务，我们使用<code class="fe np nq nr ns b">$ docker-compose <a class="ae lh" href="https://docs.docker.com/compose/reference/up/" rel="noopener ugc nofollow" target="_blank">up</a></code>命令。该命令读取当前目录下<code class="fe np nq nr ns b">docker-compose.yml</code>文件的内容，并按照正确的启动顺序启动服务。您还可以使用<code class="fe np nq nr ns b">-f</code>标志来提供一个定制的<code class="fe np nq nr ns b">docker-compose.yml</code>文件及其覆盖。</p><p id="573f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">该命令首先从Docker Hub获取<code class="fe np nq nr ns b">redis</code>和<code class="fe np nq nr ns b">php</code>图像，并为<code class="fe np nq nr ns b">backend</code>服务构建一个定制图像。然后，它为每个服务创建一个容器，并将终端连接到每个容器的运行进程，以打印日志输出。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/64f9283d340972c3d47679ec972a038c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qy673J517Pgfh0bNro4Gsg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker-撰写</figcaption></figure><p id="70b5" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">默认情况下，Docker Compose在前台模式启动服务，就像<code class="fe np nq nr ns b">$ docker run</code>命令一样。要在后台启动服务，我们可以使用带有<code class="fe np nq nr ns b">$ docker-compose <a class="ae lh" href="https://docs.docker.com/compose/reference/up/" rel="noopener ugc nofollow" target="_blank">up</a></code>命令的<code class="fe np nq nr ns b">--detach</code>或<code class="fe np nq nr ns b">-d</code>标志。</p><blockquote class="ni nj nk"><p id="c4b2" class="lj lk nl ll b lm ln kd lo lp lq kg lr nm lt lu lv nn lx ly lz no mb mc md me im bi translated"><em class="it">💡</em>使用<code class="fe np nq nr ns b">$ docker-compose [doptions] up [roptions]</code>时，<code class="fe np nq nr ns b">doptions</code>是<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/reference/overview/" rel="noopener ugc nofollow" target="_blank">docker-compose</a></code>命令的命令行选项，<code class="fe np nq nr ns b">roptions</code>是<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/reference/up/" rel="noopener ugc nofollow" target="_blank">up</a></code>命令的命令行选项。</p></blockquote><p id="9dc3" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们可以看到Docker使用<code class="fe np nq nr ns b">$ docker ps</code>命令创建的容器。我们还可以看到Docker Compose使用<code class="fe np nq nr ns b">$ docker images</code>命令提取或构建的图像。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi os"><img src="../Images/e30dca926685e40c8308af48c2ab3965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YEG6sRIb05_OULf3O4Nsnw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker ps / $ docker图像</figcaption></figure><p id="a807" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">Docker Compose使用<strong class="ll jd">项目目录</strong>名称和服务名称来命名它已经启动的Docker容器。它使用相同的方案来命名可能为服务构建的自定义Docker映像。</p><blockquote class="ni nj nk"><p id="5dc0" class="lj lk nl ll b lm ln kd lo lp lq kg lr nm lt lu lv nn lx ly lz no mb mc md me im bi translated"><em class="it">💡</em>默认情况下，Docker Compose使用<strong class="ll jd">项目目录名</strong>作为项目名。为了提供定制的项目名称，我们可以在<code class="fe np nq nr ns b">$ docker-compose</code>命令中使用<code class="fe np nq nr ns b">--project-name</code>或<code class="fe np nq nr ns b">-p</code>标志。您也可以使用<code class="fe np nq nr ns b">COMPOSE_PROJECT_NAME</code>环境变量来做同样的事情(<a class="ae lh" href="https://docs.docker.com/compose/faq/#how-do-i-run-multiple-copies-of-a-compose-file-on-the-same-host" rel="noopener ugc nofollow" target="_blank"> ref </a>)。</p></blockquote><p id="4186" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们打开浏览器并访问<code class="fe np nq nr ns b">http://localhost:8080</code> URL来访问<code class="fe np nq nr ns b">frontend</code>服务的Apache HTTP服务器。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/c04300ce09ba1419c72814ec106b2d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*nzNa6upziOlWH3p_0BZQVg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(<a class="ae lh" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>)</figcaption></figure><p id="9a61" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">最初，页面不会响应5秒钟，因为我们在<code class="fe np nq nr ns b">server.js</code>文件中添加了一个有意的延迟(<em class="nl">来模拟网络延迟</em>)。但是在连续的页面重新加载中，它会快速响应，因为我们从<code class="fe np nq nr ns b">cache</code>服务中提供用户列表，而不是从外部API中获取。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/8b842dc2e4c2e5afd597d18938e1e2aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*W8WUBZfwTRY9qC-dwObfPA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker网络ls</figcaption></figure><p id="040c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">与<code class="fe np nq nr ns b">$ docker run</code>命令不同，Docker Compose启动的容器不加入默认的<code class="fe np nq nr ns b">bridge</code>网络(<a class="ae lh" href="https://medium.com/sysf/a-beginners-guide-to-networking-in-docker-ca5b822fb935" rel="noopener"> <em class="nl"> more info </em> </a>)。Docker Compose为每个项目创建一个新桥接网络，该项目的所有容器都加入这个网络。该网络的名称也使用项目名称。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ov"><img src="../Images/33971143dd3baaca47ad433bab989d91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sZ2BQgs3M4fvKQMCegZYMQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker网络检查</figcaption></figure><p id="71e2" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果我们检查id为<code class="fe np nq nr ns b">0ac18af6517d</code>或名称为<code class="fe np nq nr ns b">docker-compose-example_default</code>的网络，我们应该能够看到连接到该网络的容器。从上面的日志中，我们可以看到三个容器加入了这个网络，它们是我们的服务容器。你也可以看到他们的IP地址。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/7aced11f58bee7132a4b369641bcc9b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*lLyOzt2xFJUo-YGowJK16g.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker卷ls</figcaption></figure><p id="579a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">Docker Compose还为服务容器安装卷。在我们的<code class="fe np nq nr ns b">docker-compose.yml</code>文件中，我们没有任何Docker管理的卷(<a class="ae lh" href="https://medium.com/sysf/docker-container-as-an-executable-to-process-images-using-go-golang-5233f9bd3bf7" rel="noopener"> <em class="nl">更多信息</em> </a>)，但是<code class="fe np nq nr ns b">redis</code>映像的<code class="fe np nq nr ns b"><a class="ae lh" href="https://github.com/docker-library/redis/blob/7ccc22760cc9b659916678a52654be8f43757551/6.0/alpine/Dockerfile" rel="noopener ugc nofollow" target="_blank">Dockerfile</a></code>有一个<code class="fe np nq nr ns b">VOLUME</code>指令，创建一个匿名卷。这个卷由<code class="fe np nq nr ns b">redis</code>映像用于持久存储和缓存的可重用性。</p><h2 id="d07d" class="nx mn it bd li ny nz dn mr oa ob dp mv ls oc od mx lw oe of mz ma og oh nb iz bi translated">关闭服务</h2><p id="131b" class="pw-post-body-paragraph lj lk it ll b lm nd kd lo lp ne kg lr ls nf lu lv lw ng ly lz ma nh mc md me im bi translated">当<code class="fe np nq nr ns b">$ docker-compse up</code>命令在没有<code class="fe np nq nr ns b">-d</code>或<code class="fe np nq nr ns b">--detach</code>标志的情况下运行时，它在前台运行，我们的终端被阻塞。在这种模式下，所有容器都连接到我们的终端，为了杀死它们，我们使用中断信号。因此，我们可以使用<code class="fe np nq nr ns b">CTRL+C</code>杀死所有的容器并停止所有的服务。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ox"><img src="../Images/51caba771063175d5b7711e3c13062e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jYadWhpzD5ZpSxVpMh_q4Q.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker ps</figcaption></figure><p id="a15b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">从上面的结果中可以看出，Docker Compose以反向启动顺序停止了正在运行的容器，从而优雅地关闭了服务。如果我们现在使用<code class="fe np nq nr ns b">$ docker ps</code>列出容器，将不会有任何正在运行的容器(<em class="nl">除非你在这个项目之外有其他正在运行的容器</em>)。</p><p id="d850" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果服务是使用<code class="fe np nq nr ns b">-d</code>或<code class="fe np nq nr ns b">--detach</code>标志在后台启动的，那么我们就不能再使用<code class="fe np nq nr ns b">CTRL+C</code>了。要停止运行容器，我们需要从项目目录运行<code class="fe np nq nr ns b">$ docker-compose <a class="ae lh" href="https://docs.docker.com/compose/reference/down/" rel="noopener ugc nofollow" target="_blank">down</a></code>命令，在那里可以找到启动服务的<code class="fe np nq nr ns b">docker-compose.yml</code>文件。</p><blockquote class="ni nj nk"><p id="5d01" class="lj lk nl ll b lm ln kd lo lp lq kg lr nm lt lu lv nn lx ly lz no mb mc md me im bi translated"><em class="it">💡</em>如果您在使用<code class="fe np nq nr ns b">up</code>子命令时使用了带有<code class="fe np nq nr ns b">$ docker-compose</code>命令的<code class="fe np nq nr ns b">-p</code>或<code class="fe np nq nr ns b">--project-name</code>标志，那么您需要在使用<code class="fe np nq nr ns b">down</code>子命令关闭服务时使用相同的标志。</p></blockquote><h2 id="1462" class="nx mn it bd li ny nz dn mr oa ob dp mv ls oc od mx lw oe of mz ma og oh nb iz bi translated">配置<code class="fe np nq nr ns b">docker-compose up</code>命令</h2><p id="de84" class="pw-post-body-paragraph lj lk it ll b lm nd kd lo lp ne kg lr ls nf lu lv lw ng ly lz ma nh mc md me im bi translated">关闭服务后，如果我们使用与上一次相同的配置再次运行<code class="fe np nq nr ns b">$ docker-compose up</code>命令，那么Docker Compose将尝试利用上一次运行的资源。</p><p id="7bf4" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">首先，如果<code class="fe np nq nr ns b">docker-compose.yml</code>中的服务配置没有改变，那么它将重用先前启动的容器，而不是重新创建它们。这就像对服务的每个容器使用<code class="fe np nq nr ns b">$ docker start</code>命令。为了在服务的配置没有改变的情况下为其强制创建容器，我们需要使用带有<code class="fe np nq nr ns b">$ docker-compose up</code>的<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/reference/up/" rel="noopener ugc nofollow" target="_blank">--force-recreate</a></code>标志。</p><p id="b09d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">Docker Compose不会为服务构建映像(<em class="nl">带有</em> <code class="fe np nq nr ns b"><em class="nl">build</em></code> <em class="nl">字段</em>)，如果它们的映像已经存在(<em class="nl">见</em> <code class="fe np nq nr ns b"><em class="nl">$ docker images</em></code> <em class="nl">日志</em>)，即使上下文目录的内容已经更改。为了强制构建图像，我们使用带有<code class="fe np nq nr ns b">$ docker-compose up</code>的<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/reference/up/" rel="noopener ugc nofollow" target="_blank">--build</a></code>标志。</p><p id="ce00" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">Docker Compose将以前的容器创建的匿名卷重新用于新容器。这样，新的<code class="fe np nq nr ns b">cache</code>容器可以重用旧容器中的缓存。为了强制Docker Compose为新容器更新匿名卷，我们使用了带有<code class="fe np nq nr ns b">$ docker-compose up</code>的<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/reference/up/" rel="noopener ugc nofollow" target="_blank">--renew-anon-volumes</a></code>或<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/reference/up/" rel="noopener ugc nofollow" target="_blank">-V</a></code>标志。</p><pre class="ks kt ku kv gt oi ns oj ok aw ol bi"><span id="7598" class="nx mn it ns b gy om on l oo op">$ docker-compose up --build --force-recreate -V</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="599f" class="mm mn it bd li mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">增强Docker合成</h1><p id="eb59" class="pw-post-body-paragraph lj lk it ll b lm nd kd lo lp ne kg lr ls nf lu lv lw ng ly lz ma nh mc md me im bi translated">Docker Compose让我们能够配置正在运行的服务及其容器的各个方面。例如，我们可以为服务配置网络，而不是使用默认网络。让我们对当前的项目做一些改进。</p><h2 id="0655" class="nx mn it bd li ny nz dn mr oa ob dp mv ls oc od mx lw oe of mz ma og oh nb iz bi translated">配置网络</h2><p id="8b03" class="pw-post-body-paragraph lj lk it ll b lm nd kd lo lp ne kg lr ls nf lu lv lw ng ly lz ma nh mc md me im bi translated">我们可以手动创建一个或多个服务容器可以加入的网络，而不是要求Docker Compose为服务容器创建一个默认网络。使用合成文件中的顶级<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#network-configuration-reference" rel="noopener ugc nofollow" target="_blank">networks</a></code>字段，我们定义了网络及其配置。在服务配置中，我们使用<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#networks" rel="noopener ugc nofollow" target="_blank">networks</a></code>字段来提供容器将加入的网络，如下所示。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(来源:gist.github.com)</figcaption></figure><p id="b9b3" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">服务级别<code class="fe np nq nr ns b">networks</code>字段可以是一个简单的字符串列表，也可以是一个具有单个网络配置的对象。在上面的合成文件中，我们为<code class="fe np nq nr ns b">cache</code>容器提供了一个网络别名。因此，<code class="fe np nq nr ns b">backend</code>容器也可以使用<code class="fe np nq nr ns b">redis://redis-server:6379</code> URL访问<code class="fe np nq nr ns b">cache</code>容器的Redis服务器。</p><p id="f588" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">您可以配置Docker Compose创建的默认网络，而不是定义新网络。如果你使用<code class="fe np nq nr ns b">default</code>网络名，Docker Compose会认为你是在要求配置它已经启动的那个。这样，您可以添加网络别名，而无需定义新网络。</p><blockquote class="ni nj nk"><p id="fa74" class="lj lk nl ll b lm ln kd lo lp lq kg lr nm lt lu lv nn lx ly lz no mb mc md me im bi translated"><em class="it">💡</em>您还可以使用服务级别和顶级<code class="fe np nq nr ns b">networks</code>字段为容器提供自定义IP地址。欲了解更多信息，请阅读<a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#networks" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">本</strong> </a>文档。</p></blockquote><p id="c90a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">与顶级<code class="fe np nq nr ns b">networks</code>字段类似，我们也可以指定一个顶级<code class="fe np nq nr ns b">volumes</code>字段来创建自定义卷，并使用服务级别<code class="fe np nq nr ns b">volumes</code>字段来附加这些卷。欲了解更多信息，请阅读本 文档。</p><h2 id="e068" class="nx mn it bd li ny nz dn mr oa ob dp mv ls oc od mx lw oe of mz ma og oh nb iz bi translated">处理故障</h2><p id="5c97" class="pw-post-body-paragraph lj lk it ll b lm nd kd lo lp ne kg lr ls nf lu lv lw ng ly lz ma nh mc md me im bi translated">默认情况下，如果服务容器因为失败而停止，它将永远不会再次启动。为了启用服务的自动重启(<em class="nl">容器</em>)，我们需要提供一个<strong class="ll jd">重启策略</strong>。我们使用带有<code class="fe np nq nr ns b">$ docker run</code>命令的<code class="fe np nq nr ns b">--restart</code>标志来提供重启策略。<a class="ae lh" href="https://docs.docker.com/config/containers/start-containers-automatically/#use-a-restart-policy" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">这里的</strong> </a>都是重启策略。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(来源:<a class="ae lh" href="https://gist.github.com/thatisuday/b6c9bfc0430e46950782e0f499cd1425" rel="noopener ugc nofollow" target="_blank"><strong class="ak">gist.github.com</strong></a>)</figcaption></figure><p id="cfe9" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">默认情况下，重启策略是<code class="fe np nq nr ns b">no</code>。如果提供了<code class="fe np nq nr ns b">on-failure</code>重启策略，如果容器(<em class="nl"> PID 1进程在其中</em>)由于容器中的非零退出代码错误而停止，服务将重启。如果提供了<code class="fe np nq nr ns b">always</code>重启策略，它将总是重启，除非手动停止，在这种情况下，它将在Docker守护程序重启时重启。如果提供了<code class="fe np nq nr ns b">unless-stopped</code>重启策略，如果容器没有被手动停止，它将重启。</p><blockquote class="ni nj nk"><p id="3065" class="lj lk nl ll b lm ln kd lo lp lq kg lr nm lt lu lv nn lx ly lz no mb mc md me im bi translated"><em class="it">💡</em>如果使用<code class="fe np nq nr ns b">$ docker <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/stop/" rel="noopener ugc nofollow" target="_blank">stop</a></code>或<code class="fe np nq nr ns b">$ docker <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/kill/" rel="noopener ugc nofollow" target="_blank">kill</a></code>命令停止正在运行的容器，则被视为手动停止。</p></blockquote><p id="f91e" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在<code class="fe np nq nr ns b">docker-compose.yml</code>文件中，我们使用服务级别<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#restart" rel="noopener ugc nofollow" target="_blank">restart</a></code>字段提供重启策略，其中包含一个重启策略。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(docker-compse.yml /来源:<a class="ae lh" href="https://gist.github.com/thatisuday/f5eb8cd277a40166fb3b3ea4f61e8755" rel="noopener ugc nofollow" target="_blank"><strong class="ak">gist.github.com</strong></a>)</figcaption></figure><p id="8eb1" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在上面的合成文件中，<code class="fe np nq nr ns b">backend</code>服务有一个重启策略<code class="fe np nq nr ns b">always</code>。这意味着如果没有手动停止，<code class="fe np nq nr ns b">backend</code>服务(<em class="nl">容器</em>)将一直启动。由于我们不能使用<code class="fe np nq nr ns b">$ docker <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/stop/" rel="noopener ugc nofollow" target="_blank">stop</a></code>和<code class="fe np nq nr ns b">$ docker <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/kill/" rel="noopener ugc nofollow" target="_blank">kill</a></code>命令来查看它是否重启，所以我们必须进入正在运行的容器，自己杀死正在运行的进程(<em class="nl"> PID 1 </em>)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oy"><img src="../Images/39bb3b10692ccaa20de9114b3a4c2609.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UWhxMrVruKDSYWVM_tSGrw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker ps</figcaption></figure><p id="a71e" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在上面的例子中，使用<code class="fe np nq nr ns b">$ docker <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/exec/" rel="noopener ugc nofollow" target="_blank">exec</a></code>命令，我们在运行的<code class="fe np nq nr ns b">backend</code>容器中执行了<code class="fe np nq nr ns b"><a class="ae lh" href="https://man7.org/linux/man-pages/man1/kill.1.html" rel="noopener ugc nofollow" target="_blank">kill</a> 1</code> shell命令。Docker会将此视为失败，并再次重启容器。您可以从现在显示为<code class="fe np nq nr ns b">Up 4 seconds</code>的<code class="fe np nq nr ns b">STATUS</code>栏中验证这一点。</p><blockquote class="ni nj nk"><p id="3656" class="lj lk nl ll b lm ln kd lo lp lq kg lr nm lt lu lv nn lx ly lz no mb mc md me im bi translated"><em class="it">💡您还应该考虑为容器添加一个<code class="fe np nq nr ns b"><a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#healthcheck" rel="noopener ugc nofollow" target="_blank">healthcheck</a></code>配置，用于服务的定期健康检查。</em></p></blockquote><h2 id="c6a7" class="nx mn it bd li ny nz dn mr oa ob dp mv ls oc od mx lw oe of mz ma og oh nb iz bi translated">完美的启动顺序</h2><p id="2061" class="pw-post-body-paragraph lj lk it ll b lm nd kd lo lp ne kg lr ls nf lu lv lw ng ly lz ma nh mc md me im bi translated">通过在服务配置中添加<code class="fe np nq nr ns b">depends_on</code>字段，我们定义了服务的启动和关闭顺序。这样，我们可以确保首先启动父服务。然而，有一个警告。</p><p id="569a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">当启动一个容器时，Docker Compose只等到容器正在运行并且应用程序进程已经启动。它不会等到我们的应用程序准备就绪。例如，如果我们的<code class="fe np nq nr ns b">server.js</code>中有一个<code class="fe np nq nr ns b">setTimeout(start_server, 5000)</code>，那么Docker Compose就不会等待，之后使用<code class="fe np nq nr ns b">backend</code>服务(<em class="nl"> HTTP服务器</em>)就安全了。</p><p id="7529" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">为了解决这个问题，我们可以在启动应用程序的命令上使用一个包装器脚本。要了解更多信息，请遵循<a class="ae lh" href="https://docs.docker.com/compose/startup-order/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">本</strong> </a>文档。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="38b9" class="nx mn it bd li ny nz dn mr oa ob dp mv ls oc od mx lw oe of mz ma og oh nb iz bi translated">资源</h2><ol class=""><li id="ab8f" class="oz pa it ll b lm nd lp ne ls pb lw pc ma pd me pe pf pg ph bi translated">Docker合成文件提供了许多其他选项，与我们在本课中探索的选项不同。你可以从这个<a class="ae lh" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#healthcheck" rel="noopener ugc nofollow" target="_blank">(<em class="nl">v3</em>)的Compose文件中探索其他可用的选项。</a></li><li id="9168" class="oz pa it ll b lm pi lp pj ls pk lw pl ma pm me pe pf pg ph bi translated">要获得Docker Compose的概述，请遵循本 文档的<a class="ae lh" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">。</strong></a></li><li id="8afd" class="oz pa it ll b lm pi lp pj ls pk lw pl ma pm me pe pf pg ph bi translated">Docker Compose CLI提供了其他命令，如从合成文件启动单个服务的<code class="fe np nq nr ns b">$ docker-compose <a class="ae lh" href="https://docs.docker.com/compose/reference/run/" rel="noopener ugc nofollow" target="_blank">run</a></code>，从合成文件列出正在运行的容器的<code class="fe np nq nr ns b">$ docker-compose <a class="ae lh" href="https://docs.docker.com/compose/reference/ps/" rel="noopener ugc nofollow" target="_blank">ps</a></code>，以及许多其他重要命令。要了解更多信息，请遵循<a class="ae lh" href="https://docs.docker.com/compose/reference/overview/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">本</strong> </a>文档。</li><li id="cd24" class="oz pa it ll b lm pi lp pj ls pk lw pl ma pm me pe pf pg ph bi translated">为了在VSCode中获得更好的开发体验，可以考虑安装<a class="ae lh" href="https://github.com/microsoft/vscode-docker" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd"> Docker扩展</strong> </a>和<a class="ae lh" href="https://github.com/redhat-developer/vscode-yaml" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd"> YAML扩展</strong> </a>。</li></ol></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pn"><img src="../Images/e3da3bf1cee07cd997d46904bbbf70b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t4VSpLEAu4Gmg-GweZ3RvA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(<a class="ae lh" href="http://thatisuday.com" rel="noopener ugc nofollow" target="_blank"><strong class="bd li">thatisuday.com</strong></a>/<a class="ae lh" href="https://github.com/thatisuday" rel="noopener ugc nofollow" target="_blank">/<strong class="bd li">GitHub</strong></a>/<a class="ae lh" href="https://twitter.com/thatisuday" rel="noopener ugc nofollow" target="_blank">/<strong class="bd li">Twitter</strong>/</a><a class="ae lh" href="https://stackoverflow.com/users/2790983/uday-hiwarale" rel="noopener ugc nofollow" target="_blank">/<strong class="bd li">stack overflow</strong></a><strong class="bd li"/>/<a class="ae lh" href="https://www.instagram.com/thatisuday/" rel="noopener ugc nofollow" target="_blank"><strong class="bd li">insta gram</strong></a>)</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi po"><img src="../Images/fdebb498630e863a0129025be5b74fb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/1*Cj3GjJSU7reYw49BYdQfpw.gif"/></div></figure></div></div>    
</body>
</html>