<html>
<head>
<title>Isolated end to end tests with docker-compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用docker-compose进行隔离的端到端测试</h1>
<blockquote>原文：<a href="https://itnext.io/isolated-end-to-end-tests-with-docker-compose-b3327877e8b8?source=collection_archive---------0-----------------------#2022-04-26">https://itnext.io/isolated-end-to-end-tests-with-docker-compose-b3327877e8b8?source=collection_archive---------0-----------------------#2022-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/c1edc5539c740ff01a37a5222c4f174c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yTzVS3-6EoyYTuKe9fwhbg.png"/></div></div></figure><div class=""/><p id="6b66" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可能知道我是docker和containers的忠实粉丝，通常会尽可能地从中获益。从开发、测试到部署，拥有可再现的隔离环境是无价的。</p><p id="f341" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">今天我想更详细地谈谈第二点。最近我做了一个项目，我通过docker-compose安装调试了这个项目，它包含了应用程序以及所有需要的依赖项，所以它是完全隔离的。</p><p id="b761" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">鉴于我在开发过程中已经有了一个完全隔离的环境，我真的想利用它进行测试。如果你熟悉测试金字塔，我想使用它的层是E2E层，因为单元测试和集成测试已经包含在代码中编写的常规测试中。</p><p id="c20f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">目标如下:在容器化的环境中运行我们的应用程序和依赖项，并以某种方式向它发送数据以像用户一样触发处理，包括后续的验证。</p><h1 id="1e02" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">应用程序</h1><p id="a9d8" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">出于演示的目的，我编写了一个非常简单的API应用程序，它允许添加和检索TODO项。应用程序使用MongoDb来存储数据。非常简单的东西，用。网</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mc"><img src="../Images/c1bb2085bc38bd5e375e033f571be067.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VanMgcsBJaTlL2kV8vbfQA.png"/></div></div></figure><p id="f1a8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我在https://github.com/Sossenbinder/DockerComposeE2ETest发布了这段代码，如果你想仔细看看的话。</p><p id="b879" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该堆栈还包括一个小的dotnet程序，它通过</p><ol class=""><li id="1043" class="mi mj je kd b ke kf ki kj km mk kq ml ku mm ky mn mo mp mq bi translated">生成新实体</li><li id="32fe" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">将其发布到api</li><li id="2f33" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">用2返回的ID再次检索它</li><li id="359c" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">使用3返回的ID手动查询MongoDb数据库，并将该实体与步骤2中生成的实体进行比较。</li></ol><p id="e663" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过这种方式，我们可以在所有持久层之间进行一次往返，并验证所有东西都完全相同。请记住，这不是一个完美或超级可靠的测试，但它足以用于演示目的。</p><h1 id="0755" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">潜在方法</h1><p id="edd8" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">所以，这个问题本身并不新鲜，在研究过程中，我找到了一些现成的解决方案。</p><p id="b8b8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解决方案一利用基础设施作为代码工具，在Azure / AWS中运行我们的应用程序，以及一个MongoDb实例。部署完所有资源后，it部门很可能会使用一个脚本来验证端点，然后将其拆除。虽然这样做可行，但我真的不想为云部署买单，而且这也不能满足拥有docker专用解决方案的要求，开发人员甚至可以在本地机器上运行该解决方案，以便在推送之前验证代码。</p><p id="ca35" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解决方案二越来越近了，似乎很多人都在这么做。使用这种方法，我们将创建一个docker-compose.yml，其中包含应用程序以及依赖项。这是合成可能的样子:</p><pre class="md me mf mg gt mw mx my mz aw na bi"><span id="fa17" class="nb la je mx b gy nc nd l ne nf">version: "3.4"</span><span id="8959" class="nb la je mx b gy ng nd l ne nf">networks:<br/>  dockerendtoendtestnetwork: {}</span><span id="41e6" class="nb la je mx b gy ng nd l ne nf">services:<br/>  dockerendtoendtest.app:<br/>    build:<br/>      context: .<br/>      dockerfile: DockerComposeEndToEnd.App/Dockerfile<br/>    networks:<br/>      - dockerendtoendtestnetwork<br/>    environment:<br/>      MongoDbEndpoint: "mongodb://dockerendtoendtest.mongodb:27017"<br/>      ASPNETCORE_URLS: "<a class="ae mh" href="http://+" rel="noopener ugc nofollow" target="_blank">http://+</a>"<br/>    ports:<br/>      - 80:80    <br/>    depends_on:<br/>      - dockerendtoendtest.mongodb</span><span id="8b98" class="nb la je mx b gy ng nd l ne nf">dockerendtoendtest.mongodb:<br/>    image: mongo<br/>    networks:<br/>      - dockerendtoendtestnetwork</span></pre><p id="829f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">compose现在代表应用程序本身，一旦用<em class="nh"> docker-compose up </em>启动，它就开始营业了。同样，我们将使用单独的脚本向API发送http请求，并以这种方式测试我们的端点。</p><p id="5d81" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然这已经是一个很好的方法，但是它仍然不能完全满足我的需求。我对这种方法有两个问题:</p><ol class=""><li id="e70a" class="mi mj je kd b ke kf ki kj km mk kq ml ku mm ky mn mo mp mq bi translated">应用程序<strong class="kd jf"> <em class="nh">有</em> </strong>来暴露一个端口，使它可以被运行在docker-compose环境之外的脚本访问。这可能导致端口冲突，因为除非您有一个可预测的环境来运行它，否则人们很可能已经将端口80用于其他容器，任何任意端口都可能不是直观的。</li><li id="464f" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">验证脚本仍然在docker引擎的主机上运行，这可能会对它产生潜在影响。假设一个开发人员想在本地尝试这个脚本。如果他的机器有一个非常奇特的配置，可以任意地使验证脚本HTTP请求失败，该怎么办？这将是不幸的，因为我们的测试应该是可靠的，只有当测试本身相应地行动时才成功或失败，而不是因为环境因素影响过程。</li></ol><p id="05f9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了真正满意这个解决方案，唯一的方法是让验证脚本在docker-compose集群中运行。然而，我一直在纠结该如何协调。这会要求执行主机解析运行脚本的容器的docker日志吗？这个脚本的消费者如何知道这个脚本是否成功呢？</p><p id="bfb8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">只有当我发现docker compose的<em class="nh">-exit-code-from&lt;service name&gt;</em>标志时，我才明白这一点。这个标志将输出一个特定容器的退出代码，作为docker compose本身的退出代码。有了这些信息，现在就有可能向外传递某种信息，运行合成测试的脚本可以利用这些信息工作。</p><p id="4c92" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，从技术上讲，docker wait<em class="nh">也有可能实现类似的功能，但是会涉及到一种更复杂的设置方式，而docker-compose很好地捆绑了所有东西，并且在给定服务完成后关闭环境。</em></p><p id="2e7c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了这些信息，我现在可以在我的脚本中加入不同的退出代码，这样我就可以很容易地将其转换成CI/CD管道中的成功或失败，或者类似的情况:</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ni"><img src="../Images/9722b9ee49a95e2ccfdc21d9f205775c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fM1OJm7Nc4HsOFD6S3v9vw.png"/></div></div></figure><p id="99ed" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以我继续将我的验证添加到我的docker-compose设置中:</p><pre class="md me mf mg gt mw mx my mz aw na bi"><span id="6b33" class="nb la je mx b gy nc nd l ne nf">version: "3.4"</span><span id="9271" class="nb la je mx b gy ng nd l ne nf">networks:<br/>  dockerendtoendtestnetwork: {}</span><span id="a997" class="nb la je mx b gy ng nd l ne nf">services:<br/>  dockerendtoendtest.app:<br/>    build:<br/>      context: .<br/>      dockerfile: DockerComposeEndToEnd.App/Dockerfile<br/>    networks:<br/>      - dockerendtoendtestnetwork<br/>    environment:<br/>      MongoDbEndpoint: "mongodb://dockerendtoendtest.mongodb:27017"<br/>      ASPNETCORE_URLS: "<a class="ae mh" href="http://+" rel="noopener ugc nofollow" target="_blank">http://+</a>"<br/>    depends_on:<br/>      - dockerendtoendtest.mongodb</span><span id="2543" class="nb la je mx b gy ng nd l ne nf">dockerendtoendtest.verifier:<br/>    build:<br/>      context: .<br/>      dockerfile: DockerComposeEndToEnd.Verifier/Dockerfile<br/>    networks:<br/>      - dockerendtoendtestnetwork<br/>    environment:<br/>      ApiEndpoint: "<a class="ae mh" href="http://dockerendtoendtest.app" rel="noopener ugc nofollow" target="_blank">http://dockerendtoendtest.app</a>"<br/>      MongoDbEndpoint: "mongodb://dockerendtoendtest.mongodb:27017"<br/>      OverriddenTodoId: ${OverriddenTodoId}<br/>    depends_on:<br/>      - dockerendtoendtest.app</span><span id="c33c" class="nb la je mx b gy ng nd l ne nf">dockerendtoendtest.mongodb:<br/>    image: mongo<br/>    networks:<br/>      - dockerendtoendtestnetwork</span></pre><p id="aa68" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，我们现在添加了验证脚本，但反过来也去掉了应用本身的端口部分。</p><p id="8ed9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意<em class="nh">OverriddenTodoId:$ { OverriddenTodoId }</em>部分。为了解释这是怎么回事，我应该解释两件事:</p><ol class=""><li id="9bc6" class="mi mj je kd b ke kf ki kj km mk kq ml ku mm ky mn mo mp mq bi translated">我不希望我的测试只检查快乐路径。在我看来，不仅重要的是在输入数据或参数时验证测试成功，而且重要的是在输入无效参数时验证测试正确地失败而不是成功。我的验证脚本将处理这个环境变量，这将导致无效的数据查询，并最终导致测试失败。</li><li id="ba6b" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">为了能够方便地更改这个参数的值，我添加了两个*。包含具体值为<em class="nh">的env文件覆盖了denTodoId </em>。这些可以通过- <em class="nh"> env-file </em>标志传递给docker compose，以便动态替换占位符。</li></ol><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/405400fe7f5c5da26d0bd5c01a8ed7ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*vtKWkqIw5oa_UV1uAi16QQ.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">失败案例的id无效</figcaption></figure><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi no"><img src="../Images/e30cceed016da8ef4821ffaa0c52df81.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/1*kG2JPA-pAyZ0K2jdQgIrCw.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">快乐路径将忽略的Id(导致我的验证脚本完全忽略这个注入)</figcaption></figure><p id="d336" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一切就绪后，我们现在需要做的就是编写一个脚本来运行我们的docker compose测试管道。因为我使用windows，所以我选择了Powershell脚本，但是在这里一切都正常。看起来是这样的:</p><pre class="md me mf mg gt mw mx my mz aw na bi"><span id="a0cb" class="nb la je mx b gy nc nd l ne nf">docker compose --env-file .\e2etestfailurepath.env up --attach dockerendtoendtest.verifier --abort-on-container-exit --exit-code-from dockerendtoendtest.verifier</span><span id="6168" class="nb la je mx b gy ng nd l ne nf">Write-Host $LASTEXITCODE;<br/>if ($LASTEXITCODE -eq 0)<br/>{<br/> throw "Failing test unexpectedly passed";<br/>}</span><span id="7682" class="nb la je mx b gy ng nd l ne nf">docker compose --env-file .\e2etesthappypath.env up --attach dockerendtoendtest.verifier --abort-on-container-exit --exit-code-from dockerendtoendtest.verifier</span><span id="09ac" class="nb la je mx b gy ng nd l ne nf">Write-Host $LASTEXITCODE;<br/>if ($LASTEXITCODE -ne 0)<br/>{<br/> throw "Successful test did not pass";<br/>}</span><span id="1688" class="nb la je mx b gy ng nd l ne nf">Write-Host "Script finished with success"</span></pre><p id="4387" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如你所见，非常简单:</p><ol class=""><li id="7ef0" class="mi mj je kd b ke kf ki kj km mk kq ml ku mm ky mn mo mp mq bi translated">我们运行docker compose设置，仅出于可读性目的附加我们的验证脚本的日志，等待我们的验证脚本的退出代码，然后检查它是否表示0。在这种情况下，错误代码0表示错误测试，因为我们测试错误输入是否导致退出，所以成功的测试是不寻常的。请注意，错误代码代表我们的验证脚本的退出代码。</li><li id="fd19" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">现在我们测试快乐之路。在这种情况下，返回值<strong class="kd jf">必须</strong>为0。</li></ol><p id="9c8e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">仅此而已。现在，每个开发人员都可以简单地在本地运行这个脚本，在部署之前验证他们自己的代码更改，或者我们可以将这个脚本转移到jenkins / gitops管道中。</p><p id="9831" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们已经构建了一个完全隔离的端到端测试，完全通过短暂的docker容器运行，我们只在需要时启动/关闭这些容器。我们不再受环境的影响。完美！</p></div></div>    
</body>
</html>