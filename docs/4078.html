<html>
<head>
<title>Feature flags — an explainer and interactive demo using React and Mavo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">特性标志——使用React和Mavo的解释器和交互式演示</h1>
<blockquote>原文：<a href="https://itnext.io/feature-flags-an-explainer-and-interactive-demo-using-react-and-mavo-5f84eed3d111?source=collection_archive---------1-----------------------#2020-04-23">https://itnext.io/feature-flags-an-explainer-and-interactive-demo-using-react-and-mavo-5f84eed3d111?source=collection_archive---------1-----------------------#2020-04-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/04de80bbab2b3d097c1c6980c0e8cfe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sHoN4VeJjdoQo_041gVpZw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">演示仪表板的屏幕截图</figcaption></figure><p id="5b3e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这里，我将讨论特性标志的使用和一些相关的设计模式。此外，我还描述了一个演示实现，其中一个原型应用程序使用标志(React)和一个功能标志仪表板(Mavo)来管理标志。我还展示了错误处理/报告和分析是如何与特性标记一起实现的，使用了我称之为特性边界<em class="ld">的东西。</em></p><p id="60f8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">马丁·福勒将特征标志<a class="ae le" href="https://martinfowler.com/articles/feature-toggles.html" rel="noopener ugc nofollow" target="_blank">描述为“一套模式，可以帮助团队快速而安全地向用户交付新功能”。其思想是将新功能或更新的功能隐藏在功能标志之后，这些功能标志可以根据情况打开或关闭。功能标志被集成到软件中，并通过使用标志作为开关临时覆盖主要设计的控制流来工作。</a></p><p id="aac5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当沿着连续的东西轴移动时，这是一个非常有用的工具。它可以让您:</p><ol class=""><li id="1d5a" class="lf lg it kh b ki kj km kn kq lh ku li ky lj lc lk ll lm ln bi translated">经常在flags后面部署，而不用半生不熟的东西打扰最终用户(将部署与发布分开)，</li><li id="e1ba" class="lf lg it kh b ki lo km lp kq lq ku lr ky ls lc lk ll lm ln bi translated">如果在发布/部署后出现了一些问题(类似于kill switch/断路器，自动或手动关闭标志——但稍后当我讨论<em class="ld">功能边界</em>时会有更多关于这一点的内容),</li><li id="8b2d" class="lf lg it kh b ki lo km lp kq lq ku lr ky ls lc lk ll lm ln bi translated">尝试新的特性(例如，通过使用它来进行A/B测试，或者通过为一个选择的测试组发布一个新的特性来提供有用的反馈)。</li></ol><p id="8146" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">特性标记的灵活性和实用性来自于将它们作为软件的一部分来实现。但这显然也是反对的主要理由，因为它增加了应用程序和服务的复杂性和不稳定性风险。所以需要小心处理。你通常需要某种抽象，让你在你的软件中添加、维护和删除标志，并具有可预测性。当然，在React中，这意味着创建一些合适的组件，以声明的方式处理这些标志。这是在演示中完成的，我将展示如何实现。</p><ul class=""><li id="fd11" class="lf lg it kh b ki kj km kn kq lh ku li ky lj lc lt ll lm ln bi translated">带有功能标志的应用程序演示:<a class="ae le" href="https://easy-peasy-features.now.sh/" rel="noopener ugc nofollow" target="_blank">https://easy-peasy-features.now.sh/</a></li><li id="34de" class="lf lg it kh b ki lo km lp kq lq ku lr ky ls lc lt ll lm ln bi translated">功能标志仪表板演示:<a class="ae le" href="https://easy-peasy-features.now.sh/features" rel="noopener ugc nofollow" target="_blank">https://easy-peasy-features.now.sh/features</a></li><li id="b73a" class="lf lg it kh b ki lo km lp kq lq ku lr ky ls lc lt ll lm ln bi translated">Github回购:<a class="ae le" href="https://github.com/kjartanm/easy-peasy-features" rel="noopener ugc nofollow" target="_blank">https://github.com/kjartanm/easy-peasy-features</a></li></ul><p id="ac8d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">功能标志和基于管道的策略之间也有一些重叠，但我认为这真的是一件非常重要的事情，基于软件和基于管道的模式应该被视为互补的策略，使您能够以尽可能小的风险部署和发布。</p><h1 id="287e" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">什么是旗帜？</h1><p id="acbf" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">基本的特征标志功能类似于:</p><p id="6c32" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe mx my mz na b">if check('flag-x') then enable someFunctionality</code></p><p id="9532" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">该检查通常是检查标志是否已启用，并结合用户对象上的属性与标志上的一些预设属性的匹配，以查看用户是否在标志的范围内。在演示中，一个用户对象看起来像这样:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="7cc8" class="nj lv it na b gy nk nl l nm nn">{<br/>    "userid": "user3",<br/>    "name": "Cilla Customer, DK",<br/>    "country": "dk",<br/>    "role": "customer"<br/>}</span></pre><p id="9e36" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">旗帜看起来像这样:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="0c20" class="nj lv it na b gy nk nl l nm nn">{<br/>    "label": "Add customer profile-page",<br/>    "flag": "profile-page-v1",<br/>    "description": "A customer profile-page to improve metrics by ...",<br/>    "threshold": 100,<br/>    "self-select": false,<br/>    "enabled": true,<br/>    "deprecated": false,<br/>    "expires": "2020-12-01",<br/>    "selectors": {<br/>        "country": [<br/>            "all"<br/>        ],<br/>        "role": [<br/>            "customer"<br/>        ],<br/>        "userid": [<br/>            "all"<br/>        ]<br/>    }<br/>}</span></pre><p id="f81e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里的标志将是上的<em class="ld">，因为它已启用，并且是一个可接受的角色。这里的其他选择器更像通配符，但是您可以缩小标志的范围，将其限制在某个国家或有限的一组用户id。标志的粒度取决于用户对象的粒度。如果您有完整的地址，您可以将该功能限制到特定的邮政编码，或者如果您有您老板的用户id，您最终可以给他想要的闪亮的老板按钮，而不会打扰其他人！😉</em></p><h2 id="4b48" class="nj lv it bd lw no np dn ma nq nr dp me kq ns nt mi ku nu nv mm ky nw nx mq ny bi translated">随机子集</h2><p id="cfba" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">除了属性选择器，该标志还有一个阈值属性，可用于选择原始选择器范围的随机子集，如20%的挪威客户。在演示中，我只使用了一个存储在localStorage中的随机数，但是如果可以将userId视为一个数字，那么可以使用模操作符来获取这个数字(userid % 100)。“释放”使用了这种技术。</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ca"><img src="../Images/c61e91c2a6bb1767cc80167598ebb74a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*csJteRVRZQPRdixe4ugKNw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">从旗帜仪表板演示。</figcaption></figure><h2 id="c131" class="nj lv it bd lw no np dn ma nq nr dp me kq ns nt mi ku nu nv mm ky nw nx mq ny bi translated">标志存储和编辑</h2><p id="9eb8" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">变得更复杂的是如何编辑和在哪里存储你的标志的问题。最简单的方法是将这些标志作为JSON捆绑到您的应用程序中，并从那里获取。另一方面，你有一些托管服务，比如Launch Darkly、Configcat、Unleash (Unleash也有开源版本)等等。托管服务的好处在于，它们通常带有一个仪表板UI，允许您以一种用户友好的方式创建和管理标志。但是它们可能很贵！</p><p id="6e5b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个演示/原型开始是希望探索一些中间地带，在那里你可以有一个很好的仪表板，但仍然有它集成到您的项目中。这就是为什么我使用<a class="ae le" href="https://mavo.io/" rel="noopener ugc nofollow" target="_blank"> Mavo </a>。Mavo是创建可编辑前端的一个很好的工具，它提供了使用不同存储机制的可能性。其中之一是GitHub，这意味着您可以使用Mavo为存储库中的JSON文件创建漂亮的UI。在演示中，我使用Mavo为标志创建一个仪表板。然后可以将生成的JSON捆绑到构建中，或者作为简单的独立API进行部署，甚至可以作为更高级API的一部分。由于标志可能是潜在的隐私泄漏，因此有必要将标志检查转移到受保护的API中，而不是从端点提供整个flag-JSON。</p><p id="7c9d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">下面是编辑特性、创建上面的ui以及之前的JSON-example的标记。使用Mavo，您可以使用property-attribute加上一些命名空间辅助属性来定义可编辑的属性。然后在保存时序列化为JSON(也可能是其他格式)。下面是一个标记的例子。wired-prefix来自<a class="ae le" href="https://wiredjs.com/" rel="noopener ugc nofollow" target="_blank"> <em class="ld"> wiredjs </em> </a>，一组创建粗略感觉和外观的ui组件:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="154e" class="nj lv it na b gy nk nl l nm nn">&lt;wired-card class="card--main"&gt;<br/>    &lt;div class="card feature-details"&gt;<br/>        &lt;div class="feature-summary"&gt;<br/>            &lt;div&gt;Show/edit [flag]&lt;/div&gt;<br/>            &lt;h3&gt;Flag&lt;/h3&gt;<br/>            &lt;div property="flag" class="card-property-editor"&gt;&lt;/div&gt;<br/>            &lt;h3&gt;Label&lt;/h3&gt;<br/>            &lt;div property="label" class="card-property-editor"&gt;&lt;/div&gt;<br/>            &lt;h3&gt;Description&lt;/h3&gt;<br/>            &lt;div property="description"&gt;&lt;/div&gt;<br/>        &lt;/div&gt;<br/>        &lt;div class="feature-editor"&gt;<br/>            &lt;div&gt;<br/>                &lt;label&gt;Self select:&lt;/label&gt;<br/>                &lt;wired-toggle onchange="this.setAttribute('aria-checked', this.checked)" mv-mode="edit"<br/>                    property="self-select" class="mv-editor" mv-attribute="aria-checked"&gt;&lt;/wired-toggle&gt;<br/>            &lt;/div&gt;<br/>            &lt;div&gt;<br/>                &lt;label&gt;Deprecated:&lt;/label&gt;<br/>                &lt;wired-toggle onchange="this.setAttribute('aria-checked', this.checked)" mv-mode="edit"<br/>                    property="deprecated" class="mv-editor" mv-attribute="aria-checked"&gt;&lt;/wired-toggle&gt;<br/>            &lt;/div&gt;<br/>            &lt;div&gt;<br/>                &lt;label&gt;AB-threshold:&lt;/label&gt;<br/>                &lt;wired-slider class="feature-threshold" onclick="this.wiredRender(true)"<br/>                    onchange="this.render();this.setAttribute('aria-valuenow', this.value)"<br/>                    knobradius="12" mv-attribute="aria-valuenow" property="threshold"<br/>                    aria-valuenow="100"&gt;&lt;/wired-slider&gt;<br/>            &lt;/div&gt;<br/>            &lt;h3&gt;Selectors&lt;/h3&gt;<br/>            &lt;ul property="selectors"&gt;<br/>                &lt;li&gt;<br/>                    &lt;label class="card-label"&gt;Countries:&lt;/label&gt;&lt;br&gt;<br/>                    &lt;span class="selector" property="country" mv-multiple mv-edit="#countries"&gt;&lt;/span&gt;<br/>                &lt;/li&gt;<br/>                &lt;li&gt;<br/>                    &lt;label class="card-label"&gt;Roles:&lt;/label&gt;&lt;br&gt;<br/>                    &lt;span class="selector" property="role" mv-multiple mv-edit="#roles"&gt;&lt;/span&gt;<br/>                &lt;/li&gt;<br/>                &lt;li&gt;<br/>                    &lt;label class="card-label"&gt;Users:&lt;/label&gt;&lt;br&gt;<br/>                    &lt;span class="selector" property="userid" mv-multiple&gt;&lt;/span&gt;<br/>                &lt;/li&gt;<br/>            &lt;/ul&gt;<br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/>&lt;/wired-card&gt;</span></pre><blockquote class="nz oa ob"><p id="384e" class="kf kg ld kh b ki kj kk kl km kn ko kp oc kr ks kt od kv kw kx oe kz la lb lc im bi translated"><strong class="kh iu"> NB！</strong>在演示中，我使用localStorage作为存储机制，而不是GitHub，因为它让我创建了一种沙箱，您可以在浏览器的隐私中测试仪表板和演示应用程序。当您在仪表板中修改标记时，应用程序会立即更新(如果它在另一个选项卡中打开)，因为它正在侦听localStorage-updates。这是由标志上下文处理的，因此更改它不会影响其余的组件。</p></blockquote><h1 id="93cf" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">标志防护、标志开关和自我选择</h1><p id="f43e" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">在演示/原型中，我实现了三种与旗帜相关的设计模式:</p><ul class=""><li id="0760" class="lf lg it kh b ki kj km kn kq lh ku li ky lj lc lt ll lm ln bi translated">国旗护卫队</li><li id="d456" class="lf lg it kh b ki lo km lp kq lq ku lr ky ls lc lt ll lm ln bi translated">标志开关</li><li id="68d8" class="lf lg it kh b ki lo km lp kq lq ku lr ky ls lc lt ll lm ln bi translated">标志自选</li></ul><p id="4a4d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="ld">标志守卫</em>是简单的构造，只是隐藏了功能。在演示实现中，可以用以下方式在React中表示标志保护:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="de03" class="nj lv it na b gy nk nl l nm nn">&lt;FlagGuard flag="support-chat-v1"&gt;<br/>    &lt;ChatButton /&gt;<br/>&lt;/FlagGuard&gt;</span></pre><p id="614d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这种情况下，如果用户不在<strong class="kh iu"> support-chat-v1 </strong>标志的范围内，标志保护会隐藏聊天按钮。演示的保护实现非常简单:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="eda5" class="nj lv it na b gy nk nl l nm nn">export const FlagGuard = ({ flag, children }) =&gt; {<br/>    const { checkFlag, user, timeStamp } = useContext(FlagContext);<br/>    const [hasError, setHasError] = useState(false);<br/>    const checkedFlag = useMemo(() =&gt; checkFlag(flag, user, timeStamp), [flag, user, timeStamp, checkFlag]);<br/>    if (checkedFlag &amp;&amp; checkedFlag.value &amp;&amp; !hasError) {<br/>        return &lt;FeatureBoundary setHasError={setHasError} flag={flag}&gt;{children}&lt;/FeatureBoundary&gt;;<br/>    } else {<br/>        return &lt;NoAccess flag={flag} status={checkedFlag.status}/&gt;<br/>    }<br/>}</span></pre><p id="1772" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">通用标志功能可从<em class="ld"> FlagContext </em>中获得。如果用户在范围内，它就呈现出<em class="ld"> FeatureBoundary </em>内的孩子，如果不在，它就呈现一些隐藏的注释。</p><p id="62c5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="ld">标志开关</em>是if-else-construction，可在替换现有功能、A/B-experiments或其他用户不在标志范围内时需要显示其他内容的用例中使用。在演示实现中，它看起来像这样:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="0c4c" class="nj lv it na b gy nk nl l nm nn">&lt;FlagSwitch flag="profile-page-v1"&gt;<br/>    &lt;FlagSwitch.On&gt;<br/>        &lt;Link to="/profile"&gt;&lt;UserIcon /&gt;&lt;b&gt;Profile&lt;/b&gt;&lt;/Link&gt;<br/>    &lt;/FlagSwitch.On&gt;<br/>    &lt;FlagSwitch.Off&gt;<br/>        &lt;UserIcon /&gt;<br/>    &lt;/FlagSwitch.Off&gt;<br/>&lt;/FlagSwitch&gt;</span></pre><p id="76c3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这种情况下，如果用户在<strong class="kh iu"> profile-page-v1 </strong>标志的范围内，则标志会创建一个到个人资料页面的链接。然后，可以在React路由器设置中使用类似的标志开关进行补充:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="d3fb" class="nj lv it na b gy nk nl l nm nn">&lt;FlagSwitch.On&gt;<br/>    &lt;Switch&gt;<br/>        &lt;Route path="/" exact &gt;<br/>            &lt;PseudoPage pageTitle="Landing" /&gt;<br/>        &lt;/Route&gt;<br/>        &lt;Route path="/about" &gt;<br/>            &lt;PseudoPage pageTitle="About" /&gt;<br/>        &lt;/Route&gt;<br/>        &lt;Route path="/shop" &gt;<br/>            &lt;PseudoPage pageTitle="Shopping" /&gt;<br/>        &lt;/Route&gt;<br/>        &lt;Route path="/profile" &gt;<br/>            &lt;PseudoPage pageTitle="Profile" /&gt;<br/>        &lt;/Route&gt;<br/>        &lt;Route&gt;<br/>            &lt;PseudoPage pageTitle="404!!" /&gt;<br/>        &lt;/Route&gt;<br/>    &lt;/Switch&gt;<br/>&lt;/FlagSwitch.On&gt;<br/>&lt;FlagSwitch.Off&gt;<br/>    &lt;Switch&gt;<br/>        &lt;Route path="/" exact &gt;<br/>            &lt;PseudoPage pageTitle="Landing" /&gt;<br/>        &lt;/Route&gt;<br/>        &lt;Route path="/about" &gt;<br/>            &lt;PseudoPage pageTitle="About" /&gt;<br/>        &lt;/Route&gt;<br/>        &lt;Route path="/shop" &gt;<br/>            &lt;PseudoPage pageTitle="Shopping" /&gt;<br/>        &lt;/Route&gt;<br/>        &lt;Route&gt;<br/>            &lt;PseudoPage pageTitle="404!!" /&gt;<br/>        &lt;/Route&gt;<br/>    &lt;/Switch&gt;<br/>&lt;/FlagSwitch.Off&gt;</span></pre><p id="3565" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">效果是，如果您在配置文件范围内的用户(最初是Cilla客户)和配置文件范围外的用户(最初是所有其他用户)之间切换，您将看到“/profile”上的页面在配置文件页面和404页面之间切换。</p><p id="2df4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">演示实现基于复合组件模式，即上下文API版本(<a class="ae le" href="https://kentcdodds.com/blog/compound-components-with-react-hooks" rel="noopener ugc nofollow" target="_blank">https://kentcdodds . com/blog/compound-components-with-react-hooks</a>)。除此之外，它非常类似于FlagGuard实现:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="4575" class="nj lv it na b gy nk nl l nm nn">const FlagSwitchContext = createContext();</span><span id="847f" class="nj lv it na b gy of nl l nm nn">const FlagSwitch = ({ flag, children }) =&gt; {<br/>    const [hasError, setHasError] = useState(false);<br/>    const { checkFlag, user, timeStamp } = useContext(FlagContext);<br/>    const checkedFlag = useMemo(() =&gt; checkFlag(flag, user, timeStamp), [flag, user, timeStamp, checkFlag]);<br/>    return (&lt;FlagSwitchContext.Provider value={{ flag, status: checkedFlag.status, on: checkedFlag.value, hasError, setHasError }}&gt;{children}&lt;/FlagSwitchContext.Provider&gt;);<br/>}</span><span id="a5cc" class="nj lv it na b gy of nl l nm nn">function On({ children }) {<br/>    const { on, flag, status, hasError, setHasError } = useContext(FlagSwitchContext);<br/>    return (on &amp;&amp; !hasError) ? &lt;FeatureBoundary flag={flag} setHasError={setHasError} switchState="On"&gt;{children}&lt;/FeatureBoundary&gt; : &lt;NoAccess flag={flag} status={status} switchState="On" /&gt;;<br/>}</span><span id="abb8" class="nj lv it na b gy of nl l nm nn">function Off({ children }) {<br/>    const { on, flag, status, hasError, setHasError } = useContext(FlagSwitchContext)<br/>    return (on &amp;&amp; !hasError) ? &lt;NoAccess flag={flag} status={status} switchState="Off" /&gt; : &lt;FeatureBoundary setHasError={setHasError} flag={flag} switchState="Off"&gt;{children}&lt;/FeatureBoundary&gt;;<br/>}</span><span id="bd9d" class="nj lv it na b gy of nl l nm nn">FlagSwitch.On = On;<br/>FlagSwitch.Off = Off;</span><span id="63fa" class="nj lv it na b gy of nl l nm nn">export { FlagSwitch };</span></pre><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div class="gh gi og"><img src="../Images/5323669f4f4ae1df1e195e29a186bc1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*lhXt5mgLPYVJqL0RaP51vw.png"/></div></figure><p id="2b6b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="ld">标志自选</em>是你可以自选测试新功能的用例。我还没有在其他地方的功能标志上下文中看到过这种情况。这通常是基于管道的策略，而不是基于标志的策略。但我认为它也应该是特性标志工具箱的一部分，因为在对应用程序的模块和部分进行实验时，完全可以使用这种模式——而不仅仅是在重写整个程序时。</p><p id="651b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">自我选择给出了一个有偏差的用户样本，但有时这实际上非常有用。自我选择的群体可能主要是<a class="ae le" href="https://en.wikipedia.org/wiki/Early_adopter" rel="noopener ugc nofollow" target="_blank">创新者/早期采用者</a>——和/或对当前功能不满意的用户。如果这个团队给出了负面的反馈，你可能就应该终止这个特性——至少在它当前的实现中，然后重新开始。</p><p id="bc88" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果用户在该标志的范围内并且该标志被标记为self-self-self-select，则通过显示切换来工作:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="dd22" class="nj lv it na b gy nk nl l nm nn">&lt;FlagToggle flag="shiny-frontend-v1" label="Try my shiny new look and feel!" /&gt;</span></pre><p id="6174" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">实现方式如下:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="1eb5" class="nj lv it na b gy nk nl l nm nn">export const FlagToggle = ({ flag, label }) =&gt; {<br/>    const { checkFlag, userSettings, setUserSettings, user, timeStamp } = useContext(FlagContext);<br/>    const checkedFlag = useMemo(() =&gt; checkFlag(flag, user, timeStamp), [flag, user, timeStamp, checkFlag]);<br/>    const [isSelected] = useState(userSettings[flag] &amp;&amp; userSettings[flag].isSelected)<br/>    const handleChange = useCallback(() =&gt; {<br/>        const isSelected = !(userSettings[flag] &amp;&amp; userSettings[flag].isSelected)<br/>        const currentFlagSetting = userSettings[flag] ? userSettings[flag] : {};<br/>        const newFlagSetting = { ...currentFlagSetting, isSelected };<br/>        setUserSettings({ ...userSettings, [flag]: newFlagSetting });<br/>    }, [flag, userSettings, setUserSettings])</span><span id="6e26" class="nj lv it na b gy of nl l nm nn">if (checkedFlag.isSelfSelect) {<br/>        return (<br/>            &lt;div className="toggle-container"&gt;<br/>                &lt;input className="toggle-check" id="toggle" type="checkbox" onChange={handleChange} checked={isSelected}&gt;&lt;/input&gt;<br/>                &lt;label className="toggle-label" htmlFor="toggle"&gt;{label}&lt;/label&gt;<br/>            &lt;/div&gt;<br/>        );<br/>    } else {<br/>        return (<br/>            &lt;NoAccess flag={flag} status={checkedFlag.status}&gt;&lt;/NoAccess&gt;<br/>        )<br/>    }<br/>}</span></pre><p id="c210" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">即使用户在标志范围内，在用户自行选择标志之前，标志保护或标志开关中的标志检查也不会返回true:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="84b4" class="nj lv it na b gy nk nl l nm nn">ReactDOM.render(<br/>    &lt;FlagProvider&gt;<br/>        &lt;BrowserRouter&gt;<br/>            &lt;FlagSwitch flag="shiny-frontend-v1"&gt;<br/>                &lt;FlagSwitch.On&gt;<br/>                    &lt;App version="shiny"/&gt;<br/>                &lt;/FlagSwitch.On&gt;<br/>                &lt;FlagSwitch.Off&gt;<br/>                    &lt;App version="tired"/&gt;<br/>                &lt;/FlagSwitch.Off&gt;<br/>            &lt;/FlagSwitch&gt;<br/>        &lt;/BrowserRouter&gt;<br/>    &lt;/FlagProvider&gt;, <br/>    document.getElementById('root'));</span></pre><p id="5e95" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在演示中，效果是模拟两个版本的应用程序。您可以通过选择shiny-frontend范围内的用户(最初是Ada Admin和Cilla Customer)来测试这一点。首先切换显示，然后您可以通过切换self-select来自启用<strong class="kh iu"> shiny-frontend-v1 </strong>。self-select toggle也可以用于从用户那里获得再次关闭它的反馈，但这在演示/原型中没有实现。</p><h1 id="39c4" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">累积范围</h1><p id="fe12" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">在演示/原型中，标志检查:</p><ol class=""><li id="6649" class="lf lg it kh b ki kj km kn kq lh ku li ky lj lc lk ll lm ln bi translated">首先检查标志是否启用，</li><li id="b767" class="lf lg it kh b ki lo km lp kq lq ku lr ky ls lc lk ll lm ln bi translated">然后将属性与用户对象进行匹配，</li><li id="1e97" class="lf lg it kh b ki lo km lp kq lq ku lr ky ls lc lk ll lm ln bi translated">然后对照随机化的用户属性检查阈值，</li><li id="f83a" class="lf lg it kh b ki lo km lp kq lq ku lr ky ls lc lk ll lm ln bi translated">最后，它检查该标志是否被标记为自选择，如果是这样选择的。</li></ol><p id="4f3f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这产生了一种累积效应，使您能够为那些在您的系统中某个组的随机x%中进行自我选择的人开放该特性。这意味着你既可以做很小的实验，也可以做很大的实验，尤其是不同类型的实验，而且风险尽可能小。添加一个<em class="ld">特征边界</em>将进一步降低风险并有助于实验。</p><h1 id="ebbe" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">功能边界:错误处理，带标志的报告和分析</h1><p id="243c" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">如果新特性中有一个bug，比如说导致脚本执行崩溃的那种错误，应该如何处理？React有一个叫做<a class="ae le" href="https://reactjs.org/docs/error-boundaries.html" rel="noopener ugc nofollow" target="_blank">错误边界</a>的东西。错误边界是一个React组件(它需要一个类组件),用于实现某些生命周期方法。它创建了一种声明性的try/catch，您可以使用它来封装React模块，并阻止该模块中的错误破坏整个应用程序的执行。在演示中，我将它实现为一个<em class="ld">特征边界</em>，我用它来包装一个有效标志的子标志。</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="a72d" class="nj lv it na b gy nk nl l nm nn">export class FeatureBoundary extends React.Component {</span><span id="7bba" class="nj lv it na b gy of nl l nm nn">    constructor(props) {<br/>        super(props);<br/>        this.state = { hasError: false };<br/>    }</span><span id="376c" class="nj lv it na b gy of nl l nm nn">    static getDerivedStateFromError(error) {<br/>        return { hasError: true };<br/>    }</span><span id="fd21" class="nj lv it na b gy of nl l nm nn">    componentDidCatch(error, errorInfo) {<br/>        if (this.props.setHasError) {<br/>            this.props.setHasError.call(null, true);<br/>        }</span><span id="3078" class="nj lv it na b gy of nl l nm nn">        console.log(`This is error reporting for '${this.props.flag}': ${error}`);<br/>    }</span><span id="db6b" class="nj lv it na b gy of nl l nm nn">    doAnalytics = (msg) =&gt; {<br/>        console.log(`This is analytics for '${this.props.flag}': ${msg}`);<br/>    }</span><span id="7464" class="nj lv it na b gy of nl l nm nn">    render() {<br/>        if (this.state.hasError) {<br/>            return (&lt;NoAccess flag={this.props.flag} status="error-caught-by-boundary" /&gt;);<br/>        }<br/>        return (&lt;AnalyticsContext.Provider value={{ doAnalytics: this.doAnalytics }}&gt;{this.props.children}&lt;/AnalyticsContext.Provider&gt;);<br/>    }<br/>}</span></pre><p id="c644" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">重复一遍，这是它在旗杆上的用法。如果该标志打开，则在要素边界内渲染子要素:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="e72e" class="nj lv it na b gy nk nl l nm nn">export const FlagGuard = ({ flag, children }) =&gt; {<br/>    const { checkFlag, user, timeStamp } = useContext(FlagContext);<br/>    const [hasError, setHasError] = useState(false);<br/>    const checkedFlag = useMemo(() =&gt; checkFlag(flag, user, timeStamp), [flag, user, timeStamp, checkFlag]);<br/>    if (checkedFlag &amp;&amp; checkedFlag.value &amp;&amp; !hasError) {<br/>        return &lt;FeatureBoundary setHasError={setHasError} flag={flag}&gt;{children}&lt;/FeatureBoundary&gt;;<br/>    } else {<br/>        return &lt;NoAccess flag={flag} status={checkedFlag.status}/&gt;<br/>    }<br/>}</span></pre><p id="6454" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">特征边界有三个用途:</p><ol class=""><li id="793d" class="lf lg it kh b ki kj km kn kq lh ku li ky lj lc lk ll lm ln bi translated">它充当一种<a class="ae le" href="https://martinfowler.com/bliki/CircuitBreaker.html" rel="noopener ugc nofollow" target="_blank">断路器</a>。如果特性中的某个地方有触发错误，它就关闭它。<em class="ld">因此，对最终用户的影响将与禁用标记的影响相同</em>。</li><li id="add8" class="lf lg it kh b ki lo km lp kq lq ku lr ky ls lc lk ll lm ln bi translated">但是您仍然可以将错误报告给服务，比如sentry.io，将flag-id附加到报告/上下文中。因此，如果通知在部署后突然出现，您将立即看到这是否是因为新功能——希望在任何最终用户注意到任何事情之前，您的支持系统不会受到影响😬。然后，您可以在修复时禁用该功能(在从报告中获得足够有用的数据之后)。然后以前滚的方式重新部署修复，小心地再次启用该标志。</li><li id="e48c" class="lf lg it kh b ki lo km lp kq lq ku lr ky ls lc lk ll lm ln bi translated">特征边界也可以作为分析的定位点。在演示中，它设置了一个带有必要标志信息的<em class="ld">分析提供者</em>，功能模块中的子组件可以使用这些标志信息来发送相关数据。这在A/B场景或类似的实验中应该很有用:</li></ol><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="b1c0" class="nj lv it na b gy nk nl l nm nn">export const ShinyButton = () =&gt; {<br/>    const { doAnalytics } = useContext(AnalyticsContext);<br/>    const pressMyButton = () =&gt; {<br/>        doAnalytics("add 1 for 'press my shiny button'")<br/>    }<br/>    return (&lt;button className="btn--shiny-very" onClick={pressMyButton}&gt;PRESS MY SHINY BUTTON&lt;/button&gt;);<br/>}</span></pre><h1 id="6b67" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">其他问题</h1><p id="f7ed" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">演示/原型中有一些细节。功能标志的一个问题是它们是有时间限制的。当然，Fowler提到了“权限切换”，使用标志(或者他称之为切换)来实现一个更持久的权限系统。我非常理解为什么。以这种方式将许可系统移动到它自己的层，当然有一些好处。并且使用React将权限转移到声明性组件中给出了一个非常好的关注点分离。但我仍然认为，它不应该是你用于试验，部分推出等相同的系统。在功能、设计模式、属性方面有明显的重叠，但也有一些显著的差异。因此，虽然有一些重叠，我将持有功能标记范围之外的权限切换。</p><p id="3d67" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所以，在我看来，旗帜是不会长久的。它们过期了，需要从代码中重构出来。这就是我在标志上添加“过期日期”和“不推荐使用”属性的原因。“过期日期”背后的想法是，旗帜可以在特定时间自动关闭，而无需有人在场来关闭它。或许还应该有一个补充的“开始日期”。总之，这意味着你可以使用标志卫士来为你的应用程序添加限时功能。可以独立于发布日期/周期安排的特性。在这种时候，这是一件好事，冠状病毒和一切。</p><p id="4fc6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">标志中的deprecated-属性可能是一种方式，表示是时候从代码中移除该标志了。结合环境变量，您可以让它在开发中抛出一个错误，并在生产中报告一个警告。这给了你一个主动淘汰标志的方法。首先你可以让它过期，然后你弃用它，然后你删除它。通过适当的日志记录/报告，应该有足够的时间和机会从代码中移除标志。</p></div></div>    
</body>
</html>