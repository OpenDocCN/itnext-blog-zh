<html>
<head>
<title>Working with image registries and containerd in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes中使用图像注册表和容器</h1>
<blockquote>原文：<a href="https://itnext.io/working-with-image-registries-and-containerd-in-kubernetes-63c311b86368?source=collection_archive---------2-----------------------#2019-05-13">https://itnext.io/working-with-image-registries-and-containerd-in-kubernetes-63c311b86368?source=collection_archive---------2-----------------------#2019-05-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a115" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes管理容器化的应用程序。容器映像可以在本地找到，也可以从远程注册中心获取。我们最近发布了<a class="ae kl" href="https://microk8s.io" rel="noopener ugc nofollow" target="_blank"> MicroK8s </a>，并注意到我们的一些用户对配置带有图像注册表的containerd感到不舒服。在这篇博客中，我们将介绍一些大多数人都在遵循的工作流程。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/4a7e90990668bf1cdac497ce5cd1d111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JVxJ8RyfDSksoA_gZYz6gQ.png"/></div></div></figure><h2 id="4da9" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">你应该已经知道的</h2><p id="05e2" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我们讨论如何使用本地图像，或者从配置了containerd 的<a class="ae kl" href="https://kubernetes.io/blog/2018/05/24/kubernetes-containerd-integration-goes-ga/" rel="noopener ugc nofollow" target="_blank"> Kubernetes中的公共和私有注册中心获取的图像。</a></p><p id="825a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要获得这样一个集群，只需:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="6c04" class="ky kz iq lx b gy mb mc l md me">sudo snap install microk8s --classic</span></pre><p id="a956" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">熟悉构建、推送和标记容器图像将会有所帮助。下面的例子使用Docker，但是你也可以使用你喜欢的容器工具链。</p><p id="0a21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要在Ubuntu 18.04上安装Docker:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="4558" class="ky kz iq lx b gy mb mc l md me">sudo apt-get install docker.io</span></pre><p id="4093" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将用户添加到docker组:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="3f62" class="ky kz iq lx b gy mb mc l md me">sudo usermod -aG docker ${USER}</span></pre><p id="c9e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用更新的组成员身份为用户打开新的shell:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="5209" class="ky kz iq lx b gy mb mc l md me">su - ${USER}</span></pre><p id="5dcf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用的<code class="fe mf mg mh lx b">Dockerfile</code>是:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="ba25" class="ky kz iq lx b gy mb mc l md me">FROM nginx:alpine</span></pre><p id="7f37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要构建标记有<code class="fe mf mg mh lx b">mynginx:local</code>的映像，转到<code class="fe mf mg mh lx b">Dockerfile</code>所在的目录并运行:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="673f" class="ky kz iq lx b gy mb mc l md me">docker build . -t mynginx:local</span></pre></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h2 id="3bbf" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">在没有注册表的情况下使用本地构建的映像</h2><p id="f165" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">构建映像时，它被缓存在构建期间使用的Docker守护进程中。运行完<code class="fe mf mg mh lx b">docker build . -t mynginx:local</code>命令后，您可以通过运行以下命令来查看新构建的映像:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="eefa" class="ky kz iq lx b gy mb mc l md me">docker images</span></pre><p id="f02c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将列出Docker当前已知的图像，例如:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="0ba3" class="ky kz iq lx b gy mb mc l md me">REPOSITORY          TAG                 IMAGE ID             SIZE<br/>mynginx             local               0be75340bd9b         16.1MB</span></pre><p id="ff7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们创造的形象为Docker所知。Kubernetes不知道新构建的映像，因为您的本地Docker守护进程不是MicroK8s Kubernetes集群的一部分。我们可以从本地Docker守护进程导出构建的图像，并将其“注入”到MicroK8s图像缓存中，如下所示:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="1cd4" class="ky kz iq lx b gy mb mc l md me">docker save mynginx &gt; myimage.tar<br/>microk8s.ctr -n k8s.io image import myimage.tar</span></pre><p id="463a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，当我们将图像导入到MicroK8s时，我们是在<em class="mp"> k8s.io </em>名称空间下进行的(<em class="mp"> -n k8s.io </em>参数)。</p><p id="1442" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以列出MicroK8s中存在的图像:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="acfa" class="ky kz iq lx b gy mb mc l md me">microk8s.ctr -n k8s.io images ls</span></pre><p id="7f9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时我们准备用这张图片对<code class="fe mf mg mh lx b">microk8s.kubectl apply -f</code>进行部署:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="8de3" class="ky kz iq lx b gy mb mc l md me">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: nginx-deployment<br/>  labels:<br/>    app: nginx<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: nginx<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: nginx<br/>    spec:<br/>      containers:<br/>      - name: nginx<br/>        image: mynginx:local<br/>        ports:<br/>        - containerPort: 80</span></pre><p id="ae26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们用<code class="fe mf mg mh lx b">image: mynginx:local</code>指代该图像。Kubernetes将表现得好像docker . io(docker hub注册表)中已经有一个图像的缓存副本。请注意，containerd不会缓存带有<code class="fe mf mg mh lx b">latest</code>标签的图像，所以请确保不要使用该标签。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h2 id="d5da" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">使用公共注册表</h2><p id="3714" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">在用<code class="fe mf mg mh lx b">docker build . -t mynginx:local</code>构建一个映像之后，它可以被推送到一个主流的公共注册中心。您需要创建一个帐户，并向注册服务提供商注册一个用户名。在这个例子中，我们用<a class="ae kl" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/</a>创建了一个账户，我们以<em class="mp"> kjackal </em>的身份登录。</p><p id="3232" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们运行登录命令:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="efc7" class="ky kz iq lx b gy mb mc l md me">docker login</span></pre><p id="9a55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Docker将要求输入Docker ID和密码来完成登录。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="27a0" class="ky kz iq lx b gy mb mc l md me">Login with your Docker ID to push and pull images from Docker Hub. If you don’t have a Docker ID, head over to <a class="ae kl" href="https://hub.docker.com" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com</a> to create one.<br/>Username: kjackal<br/>Password: *******</span></pre><p id="c22a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">推送到注册表要求图像用<code class="fe mf mg mh lx b">your-hub-username/image-name:tag</code>标记。我们可以在构建期间添加适当的标记:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="734c" class="ky kz iq lx b gy mb mc l md me">docker build . -t kjackal/mynginx:public</span></pre><p id="2e2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者使用图像ID标记已经存在的图像。通过运行以下命令获取ID:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="59b7" class="ky kz iq lx b gy mb mc l md me">docker images</span></pre><p id="7c39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出中列出了ID:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="6643" class="ky kz iq lx b gy mb mc l md me">REPOSITORY          TAG                 IMAGE ID            SIZE<br/>mynginx             local               0be75340bd9b        16.1MB</span></pre><p id="9eee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后使用tag命令:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="457e" class="ky kz iq lx b gy mb mc l md me">docker tag 0be75340bd9b kjackal/mynginx:public</span></pre><p id="4a33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然图像已被正确标记，就可以将其推送到注册表中:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="cc78" class="ky kz iq lx b gy mb mc l md me">docker push kjackal/mynginx</span></pre><p id="ff0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时我们准备用我们的形象对<code class="fe mf mg mh lx b">microk8s.kubectl apply -f</code>进行一次部署:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="8d3f" class="ky kz iq lx b gy mb mc l md me">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: nginx-deployment<br/>  labels:<br/>    app: nginx<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: nginx<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: nginx<br/>    spec:<br/>      containers:<br/>      - name: nginx<br/>        image: kjackal/mynginx:public<br/>        ports:<br/>        - containerPort: 80</span></pre><p id="5115" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将该图像称为<code class="fe mf mg mh lx b">image:kjackal/mynginx:public</code>。Kubernetes将在其默认注册表中搜索图像。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h2 id="7246" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">使用MicroK8s的注册表插件</h2><p id="c9d5" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">拥有一个私人的Docker注册表可以减少上传和下载图片的时间，从而显著提高你的工作效率。MicroK8s附带的注册表托管在Kubernetes集群中，并作为本地主机的端口<em class="mp"> 32000 </em>上的<em class="mp">节点端口</em>服务公开。请注意，这是一个不安全的注册表，您可能需要采取额外的步骤来限制对它的访问。</p><p id="4c86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用以下工具安装注册表:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="1a5a" class="ky kz iq lx b gy mb mc l md me">microk8s.enable registry</span></pre><p id="6bc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">附加注册表由声称用于存储图像的<em class="mp"> 20Gi </em>永久卷备份。为了满足这一要求，还启用了存储插件和注册表。</p><p id="8461" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">MicroK8s使用的containerd守护进程被配置为信任这个不安全的注册表。要上传图片，我们必须在推送前给它们贴上<code class="fe mf mg mh lx b">localhost:32000/your-mage</code>标签:</p><p id="d519" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以在构建期间添加适当的标记:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="2889" class="ky kz iq lx b gy mb mc l md me">docker build . -t localhost:32000/mynginx:registry</span></pre><p id="0b0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者使用图像ID标记已经存在的图像。通过运行以下命令获取ID:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="74d4" class="ky kz iq lx b gy mb mc l md me">docker images</span></pre><p id="22a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出中列出了ID:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="9e5a" class="ky kz iq lx b gy mb mc l md me">REPOSITORY                TAG             IMAGE ID       SIZE<br/>localhost:32000/mynginx   registry        0be75340bd9b   16.1MB</span></pre><p id="5654" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后使用tag命令:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="9089" class="ky kz iq lx b gy mb mc l md me">docker tag 0be75340bd9b localhost:32000/mynginx:registry</span></pre><p id="850c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然图像已被正确标记，就可以将其推送到注册表中:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="c889" class="ky kz iq lx b gy mb mc l md me">docker push localhost:32000/mynginx</span></pre><p id="9797" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Docker的某些版本中，推送这个不安全的注册表可能会失败，除非守护程序被明确配置为信任它。为了解决这个问题，我们需要编辑<code class="fe mf mg mh lx b">/etc/docker/daemon.json</code>并添加:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="63f1" class="ky kz iq lx b gy mb mc l md me">{<br/> "insecure-registries" : ["localhost:32000"]<br/>}</span></pre><p id="9d09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">新配置应该通过Docker守护程序重启来加载:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="00a1" class="ky kz iq lx b gy mb mc l md me">sudo systemctl restart docker</span></pre><p id="a07b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，我们已经准备好使用我们的映像进行部署:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="5eba" class="ky kz iq lx b gy mb mc l md me">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: nginx-deployment<br/>  labels:<br/>    app: nginx<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: nginx<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: nginx<br/>    spec:<br/>      containers:<br/>      - name: nginx<br/>        image: localhost:32000/mynginx:registry<br/>        ports:<br/>        - containerPort: 80</span></pre><p id="e5da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如果MicroK8s运行在虚拟机中会怎样？通常MicroK8s放在VM中，而开发过程在主机上进行。在这个设置中，将容器映像推送到VM中的注册表需要一些额外的配置。</strong></p><p id="068f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们假设运行MicroK8s的VM的IP是<em class="mp"> 10.141.241.175 </em>。当我们在主机上时，Docker注册表是<em class="mp">而不是<em class="mp"> localhost:32000 </em>上的<em class="mp"> 10.141.241.175:32000 </em>上的</em>。因此，我们需要做的第一件事是用正确的注册表端点标记我们在主机上构建的映像:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="29bd" class="ky kz iq lx b gy mb mc l md me">docker build . -t 10.141.241.175:32000/mynginx:registry</span></pre><p id="f9a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们立即尝试推送mynginx映像，我们将会失败，因为本地Docker不信任VM中的注册表。如果我们尝试推送，会发生以下情况:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="aa2f" class="ky kz iq lx b gy mb mc l md me">&gt; docker push 10.141.241.175:32000/mynginx<br/>The push refers to repository [10.141.241.175:32000/mynginx]<br/>Get <a class="ae kl" href="https://10.141.241.175:32000/v2/" rel="noopener ugc nofollow" target="_blank">https://10.141.241.175:32000/v2/</a>: http: server gave HTTP response to HTTPS client</span></pre><p id="ccd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要明确地配置运行在主机上的Docker守护进程，以信任VM中不安全的注册表。在<code class="fe mf mg mh lx b">/etc/docker/daemon.json</code>中添加注册表端点:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="148b" class="ky kz iq lx b gy mb mc l md me">{<br/> "insecure-registries" : ["10.141.241.175:32000"]<br/>}</span></pre><p id="6212" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后重新启动主机上的docker守护程序来加载新的配置:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="ec99" class="ky kz iq lx b gy mb mc l md me">sudo systemctl restart docker</span></pre><p id="af50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以看到图片被上传。在推送期间，我们的Docker客户端指示主机内Docker守护程序将新构建的映像上传到由映像上的标签所标记的<em class="mp">端点。Docker守护进程看到(在<code class="fe mf mg mh lx b">/etc/docker/daemon.jason</code>上)它信任注册表，并继续上传图像。</em></p><p id="8874" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从虚拟机内部使用映像不涉及任何更改:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="e29f" class="ky kz iq lx b gy mb mc l md me">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: nginx-deployment<br/>  labels:<br/>    app: nginx<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: nginx<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: nginx<br/>    spec:<br/>      containers:<br/>      - name: nginx<br/>        image: localhost:32000/mynginx:registry<br/>        ports:<br/>        - containerPort: 80</span></pre><p id="dbc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们用<em class="mp">localhost:32000/mynginx:registry</em>来引用这个映像，因为注册表在VM内部运行，所以它在<em class="mp"> localhost:32000 </em>上。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h2 id="a461" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">使用私有注册表</h2><p id="6d76" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">通常，组织都有自己的私有注册表，以帮助协作和加速开发。Kubernetes(以及MicroK8s)在能够提取容器图像之前需要知道注册表端点。</p><p id="94da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">不安全注册表</strong> <br/>让我们假设私有不安全注册表位于端口<em class="mp"> 32000 </em>上的<em class="mp"> 10.141.241.175 </em>。我们构建的映像需要用注册表端点进行标记:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="d65e" class="ky kz iq lx b gy mb mc l md me">docker build . -t 10.141.241.175:32000/mynginx:registry</span></pre><p id="3bb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时推送<em class="mp"> mynginx </em>映像将会失败，因为本地Docker不信任私有的不安全注册表。用于构建映像的docker守护程序应该配置为信任私有的不安全注册表。这是通过在<code class="fe mf mg mh lx b">/etc/docker/daemon.json</code>中标记注册表端点来完成的:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="72f4" class="ky kz iq lx b gy mb mc l md me">{<br/> "insecure-registries" : ["10.141.241.175:32000"]<br/>}</span></pre><p id="da27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重新启动主机上的Docker守护程序以加载新配置:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="bbb3" class="ky kz iq lx b gy mb mc l md me">sudo systemctl restart docker</span></pre><p id="4712" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在运行</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="b0a5" class="ky kz iq lx b gy mb mc l md me">docker push 10.141.241.175:32000/mynginx</span></pre><p id="352c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">…应该可以成功地将图像上传到注册表。</p><p id="9514" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时尝试在MicroK8s中提取图像将导致如下错误:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="50b5" class="ky kz iq lx b gy mb mc l md me">Warning Failed 1s (x2 over 16s) kubelet, jackal-vgn-fz11m Failed to pull image “10.141.241.175:32000/mynginx:registry”: rpc error: code = Unknown desc = failed to resolve image “10.141.241.175:32000/mynginx:registry”: no available registry endpoint: failed to do request: Head <a class="ae kl" href="https://10.141.241.175:32000/v2/mynginx/manifests/registry" rel="noopener ugc nofollow" target="_blank">https://10.141.241.175:32000/v2/mynginx/manifests/registry</a>: http: server gave HTTP response to HTTPS client</span></pre><p id="8ad5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要编辑<code class="fe mf mg mh lx b">/var/snap/microk8s/current/args/containerd-template.toml</code>，在<em class="mp">【插件】- &gt;【插件. cri .注册表】- &gt;【插件. cri .注册表.镜像】</em>下添加以下内容:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="b6d9" class="ky kz iq lx b gy mb mc l md me">  [plugins.cri.registry.mirrors.”10.141.241.175:32000"]<br/>     endpoint = [“<a class="ae kl" href="http://10.141.241.175:32000" rel="noopener ugc nofollow" target="_blank">http://10.141.241.175:32000</a>"]</span></pre><p id="f742" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看完整文件<a class="ae kl" href="https://microk8s.io/docs/containerd-template.toml" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="2995" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重启MicroK8s以加载新的配置:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="0c23" class="ky kz iq lx b gy mb mc l md me">microk8s.stop<br/>microk8s.start</span></pre><p id="2bda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该映像现在可以通过以下方式部署:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="ae11" class="ky kz iq lx b gy mb mc l md me">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: nginx-deployment<br/>  labels:<br/>    app: nginx<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: nginx<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: nginx<br/>    spec:<br/>      containers:<br/>      - name: nginx<br/>        image: 10.141.241.175:32000/mynginx:registry<br/>        ports:<br/>        - containerPort: 80</span></pre><p id="e9a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，该图像引用了<code class="fe mf mg mh lx b">10.141.241.175:32000/mynginx:registry</code>。</p><p id="906c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有很多方法可以设置一个私有的安全注册表，这可能会稍微改变你与它交互的方式。我们在这里提供两个关于如何与Kubernetes集成的提示，而不是深入每个设置的细节。</p><ul class=""><li id="999b" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated">Kubernetes官方文档描述了如何从Docker登录凭证中创建一个秘密，并使用它来访问安全注册表。为了实现这一点，<em class="mp"> imagePullSecrets </em>被用作容器规范的一部分。</li><li id="8f37" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">MicroK8s <em class="mp"> v1.14 </em>及更高版本使用containerd。<a class="ae kl" href="https://github.com/containerd/cri/blob/master/docs/registry.md" rel="noopener ugc nofollow" target="_blank">如本文所述</a>配置容器涉及编辑<code class="fe mf mg mh lx b">/var/snap/microk8s/current/args/containerd-template.toml</code>并通过<em class="mp">微k8s.stop、微k8s.start </em>循环重新加载新配置。</li></ul></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h2 id="87df" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">进一步阅读</h2><ul class=""><li id="3f0e" class="mq mr iq jp b jq lr ju ls jy ne kc nf kg ng kk mv mw mx my bi translated">MicroK8s </li><li id="43c7" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><a class="ae kl" href="https://containerd.io/" rel="noopener ugc nofollow" target="_blank">集装箱</a></li><li id="d937" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><a class="ae kl" href="https://kubernetes.io/blog/2018/05/24/kubernetes-containerd-integration-goes-ga/" rel="noopener ugc nofollow" target="_blank">Kubernetes container d Integration正式上市</a></li><li id="3d81" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><a class="ae kl" href="https://docs.docker.com/registry/insecure/" rel="noopener ugc nofollow" target="_blank">测试不安全的注册表</a></li><li id="cf5f" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><a class="ae kl" href="https://github.com/containerd/cri/blob/master/docs/registry.md" rel="noopener ugc nofollow" target="_blank">配置容器</a></li><li id="df38" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><a class="ae kl" href="https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/" rel="noopener ugc nofollow" target="_blank">上游Kubernetes关于从私有注册中心提取图像的文档</a></li></ul></div></div>    
</body>
</html>