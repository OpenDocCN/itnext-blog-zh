<html>
<head>
<title>A Complete Guide to gRPC-Web with Angular and .NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">gRPC-Web带角度和角度的完全指南。网</h1>
<blockquote>原文：<a href="https://itnext.io/a-complete-guide-to-grpc-web-with-angular-and-net-c4ae2500bd24?source=collection_archive---------0-----------------------#2022-05-19">https://itnext.io/a-complete-guide-to-grpc-web-with-angular-and-net-c4ae2500bd24?source=collection_archive---------0-----------------------#2022-05-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/00fe9d3f50b6b6889ff43797a3410bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wmjrR1fmiUZf9umQn4QOiA.png"/></div></div></figure><p id="67f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本帖中，我们将创建一个gRPC演示，其中包含一个使用网关的服务器和两个客户端。净，有角)。我们还将讨论在构建gRPC服务器和客户机时可能会遇到的一些常见问题。</p><h2 id="c3b6" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated"><strong class="ak">什么是gRPC？</strong></h2><p id="14f8" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">如果您正在寻找一种提高应用程序性能的方法，您可能会考虑使用gRPC。gRPC是一个高性能、开源的通用RPC框架，可以在任何环境中运行。gRPC基于远程过程调用(RPC)的概念。RPC是两个系统之间允许它们交换信息的一种通信方法。它也是语言不可知的，因此您可以将它用于任何编程语言，并使构建连接系统变得容易。</p><p id="6a1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GRPC使用HTTP/2作为它的传输层，与传统的HTTP/1.1相比，它有几个优点。HTTP/2是一种二进制协议，它通过单个连接多路传输请求和响应，并使用报头压缩来减少开销。这使得它比HTTP/1.1更有效，并允许更低的延迟和更高的吞吐量。</p><p id="125d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另外，GRPC使用<a class="ae lu" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">协议缓冲区</strong> </a>作为其接口描述语言。这允许进行强类型检查和高效的数据序列化。它还使得API随着时间的推移而发展变得容易，而不会破坏向后兼容性。</p><p id="3752" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用Grpc有许多好处，但其中一些最显著的好处包括:</p><blockquote class="lv lw lx"><p id="1715" class="jy jz ly ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated"><strong class="ka ir">轻量级消息。</strong>根据调用的类型，特定于gRPC的消息在大小上比JSON消息小30%<a class="ae lu" href="https://auth0.com/blog/beating-json-performance-with-protobuf/#:~:text=JSON%20messages%20are%20exchanged%20in,define%20and%20exchange%20these%20messages." rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"/></a>。</p><p id="2ea4" class="jy jz ly ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated"><strong class="ka ir">高性能</strong>。通过不同的评测，gRPC比REST+JSON通信快<a class="ae lu" href="https://dzone.com/articles/is-protobuf-5x-faster-than-json" rel="noopener ugc nofollow" target="_blank"> 5 </a>、<a class="ae lu" href="https://medium.com/@EmperorRXF/evaluating-performance-of-rest-vs-grpc-1b8bdf0b22da" rel="noopener"> 7 </a>，甚至<a class="ae lu" href="https://docs.microsoft.com/en-us/dotnet/architecture/cloud-native/grpc" rel="noopener ugc nofollow" target="_blank"> 8 </a>倍。</p><p id="343c" class="jy jz ly ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated"><strong class="ka ir">内置代码生成</strong>。gRPC拥有不同编程语言的自动化代码生成，包括<a class="ae lu" href="https://www.altexsoft.com/blog/engineering/pros-and-cons-of-java-programming/" rel="noopener ugc nofollow" target="_blank"> Java </a>，C++，Python，Go，<a class="ae lu" href="https://www.altexsoft.com/blog/engineering/pros-and-cons-of-flutter-app-development/" rel="noopener ugc nofollow" target="_blank"> Dart </a>，<a class="ae lu" href="https://www.altexsoft.com/blog/engineering/swift-vs-objective-c-out-with-the-old-in-with-the-new/" rel="noopener ugc nofollow" target="_blank"> Objective-C </a>，Ruby等等。"</p><p id="9fd8" class="jy jz ly ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated"><strong class="ka ir">更多连接选项</strong>。REST关注于请求-响应架构，而gRPC通过事件驱动的架构为<a class="ae lu" href="https://www.altexsoft.com/blog/real-time-analytics/" rel="noopener ugc nofollow" target="_blank">数据流</a>提供支持:服务器端流、客户端流和双向流</p></blockquote><p id="4cfc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来源:<a class="ae lu" href="https://www.altexsoft.com/blog/what-is-grpc/" rel="noopener ugc nofollow" target="_blank">https://www.altexsoft.com/blog/what-is-grpc/</a></p><p id="19fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将构建一个gRPC服务器。NET和两个客户端(Angular，。NET)在本文中。</p><p id="dcf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为许多浏览器的客户端不支持gRPC，我们将为gRPC-web配置我们的服务器和客户端，这与gRPC不同。它只存在于浏览器中，在浏览器中充当gRPC和您的应用程序之间的转换层。gRPC-web中的“Web”客户机通过HTTP 1.1或HTTP/2接收请求，然后通过代理发送请求。你可以在<a class="ae lu" href="https://blog.getambassador.io/understanding-grpc-and-grpc-web-8a4d43f58480" rel="noopener ugc nofollow" target="_blank">这篇</a>帖子中找到更多细节。</p><h2 id="c9dd" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated"><strong class="ak">用构建gRPC服务器。网络</strong></h2><p id="014d" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">首先，让我们创建一个新的。NET应用程序，代码写在下面。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="59f6" class="kw kx iq mh b gy ml mm l mn mo">dotnet new web -o gRPC.Web.Server</span></pre><p id="98bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们需要安装Grpc。AspNetCore和Grpc。AspNetCore打包到我们的项目中，以便能够使用Grpc特性。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="da67" class="kw kx iq mh b gy ml mm l mn mo">dotnet add gRPC.Web.Server.csproj package Grpc.AspNetCore<br/>dotnet add gRPC.Web.Server.csproj package Grpc.AspNetCore.Web</span></pre><h2 id="453e" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated"><strong class="ak">创建原型文件</strong></h2><p id="1c76" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">众所周知，gRPC使用。proto文件，所以我们需要定义我们的protobuf文件，供客户端和服务器端使用。让我们创建一个名为“Protos”的目录，并在那里创建一个名为“stream.proto”的简单protobuf文件，如下所示:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="90d1" class="kw kx iq mh b gy ml mm l mn mo">syntax = "proto3";<br/><br/>service StreamService {<br/>  rpc FetchResponse (Request) returns (stream Response) {}<br/>}<br/><br/>message Request {<br/>  int32 id = 1;<br/>}<br/><br/>message Response {<br/>  string result = 1;<br/>}</span></pre><p id="5c55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想了解更多关于proto文件的信息，你可以访问这个资源。</p><p id="cf81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建原型文件后，我们需要将其定义到我们的。csproj文件将能够使用自动生成的代码，我们可以继承和覆盖。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="81e9" class="kw kx iq mh b gy ml mm l mn mo">&lt;ItemGroup&gt;</span><span id="c760" class="kw kx iq mh b gy mp mm l mn mo">    &lt;Protobuf Include="Protos\stream.proto" GrpcServices="Server" /&gt;</span><span id="6b1a" class="kw kx iq mh b gy mp mm l mn mo">&lt;/ItemGroup&gt;</span></pre><blockquote class="lv lw lx"><p id="1370" class="jy jz ly ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated">注意:默认情况下，<code class="fe mq mr ms mh b">&lt;Protobuf&gt;</code>引用生成一个具体的客户端和一个服务基类。引用元素的<code class="fe mq mr ms mh b">GrpcServices</code>属性可以用来限制C#资产的生成。有效的<code class="fe mq mr ms mh b">GrpcServices</code>选项有:两者(不存在时默认)、服务器、客户端和无。</p></blockquote><p id="b316" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在执行了<strong class="ka ir"> dotnet build </strong>命令后，我们应该会看到obj/Debug/net*文件夹下生成的类，如下所示。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/c4c43c62aa33bc550ae28bfa9f3bfa28.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*GhAiGxdHWp14L4zevOL0Rw.png"/></div></figure><h2 id="ba69" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">实现生成的类</h2><p id="708b" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">让我们创建实现我们的服务方法的<code class="fe mq mr ms mh b">StreamImplService</code>。<code class="fe mq mr ms mh b">FetchResponse</code>是一个服务器端的流RPC，所以我们需要向我们的客户端发回多个<code class="fe mq mr ms mh b">Response</code>协议缓冲区。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="23b6" class="kw kx iq mh b gy ml mm l mn mo">using Grpc.Core;<br/><br/>public class StreamImplService: StreamService.StreamServiceBase {<br/>    <br/>    private readonly List&lt;string&gt; _messages = new List&lt;string&gt;()<br/>    {<br/>      "Hello",<br/>      "World",<br/>      "!"<br/>    };<br/>    <br/>    public override async Task FetchResponse(<br/>        Request request, <br/>        IServerStreamWriter&lt;Response&gt; responseStream, <br/>        ServerCallContext context)<br/>    {<br/>        while (!context.CancellationToken.IsCancellationRequested)<br/>        {<br/>            foreach (var message in _messages)<br/>            {<br/>                await responseStream.WriteAsync(new Response()<br/>                {<br/>                    Result = message<br/>                });<br/><br/>                Thread.Sleep(750);<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="5379" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，我们没有返回简单的响应，而是使用异步方法<code class="fe mq mr ms mh b">WriteAsync</code>将响应写入异步流<code class="fe mq mr ms mh b">IServerStreamWriter</code>，同时不请求取消令牌。我们的请求模型包含一个Id属性，但是此时我不会对这个值做任何事情。</p><p id="32fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要如下配置Program.cs(以前版本为Startup.cs)。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="ace7" class="kw kx iq mh b gy ml mm l mn mo">var builder = WebApplication.CreateBuilder(args);<br/><br/>builder.Services.AddGrpc();</span><span id="9609" class="kw kx iq mh b gy mp mm l mn mo">var app = builder.Build();</span><span id="22f0" class="kw kx iq mh b gy mp mm l mn mo">app.UseGrpcWeb();<br/><br/>app.MapGrpcService&lt;StreamImplService&gt;().EnableGrpcWeb();<br/><br/>app.Run();</span></pre><blockquote class="lv lw lx"><p id="fea6" class="jy jz ly ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated">对于以前的版本:</p></blockquote><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="07df" class="kw kx iq mh b gy ml mm l mn mo">services.AddGrpc();</span><span id="9f5e" class="kw kx iq mh b gy mp mm l mn mo">app.UseGrpcWeb();</span><span id="f61c" class="kw kx iq mh b gy mp mm l mn mo">app.UseEndpoints(endpoints =&gt;<br/>            {</span><span id="18e7" class="kw kx iq mh b gy mp mm l mn mo">                endpoints.MapGrpcService&lt;StreamImplService&gt;().EnableGrpcWeb();</span><span id="db56" class="kw kx iq mh b gy mp mm l mn mo">           });</span></pre><blockquote class="lv lw lx"><p id="2dd1" class="jy jz ly ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated"><a class="ae lu" href="https://docs.microsoft.com/en-Us/aspnet/core/grpc/troubleshoot?view=aspnetcore-6.0#unable-to-start-aspnet-core-grpc-app-on-macos" rel="noopener ugc nofollow" target="_blank">根据微软</a> gRPC模板默认使用TLS，而Kestrel在macOS系统上不支持带TLS的HTTP/2，因此我们可以说macOS不支持带TLS的ASP.NET核心gRPC，需要额外的配置才能使用HTTP2。<strong class="ka ir">注意:如果你想使用gRPC-web，这个配置只适用于gRPC，因为在这篇文章中没有必要这样做。</strong></p></blockquote><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="9273" class="kw kx iq mh b gy ml mm l mn mo">using Microsoft.AspNetCore.Server.Kestrel.Core;<br/><br/>var builder = WebApplication.CreateBuilder(args);<br/><br/>builder.Services.AddGrpc();<br/><br/>builder.WebHost.ConfigureKestrel(options =&gt;<br/>{<br/>    <em class="ly">// Setup a HTTP/2 endpoint without TLS.<br/>    </em>options.ListenLocalhost(7264, o =&gt; o.Protocols =  HttpProtocols.<strong class="mh ir">Http2</strong>);<br/>});<br/><br/>var app = builder.Build();<br/><br/>app.UseGrpcWeb();<br/><br/>app.MapGrpcService&lt;StreamImplService&gt;().EnableGrpcWeb();<br/><br/>app.Run();</span></pre><blockquote class="lv lw lx"><p id="6131" class="jy jz ly ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated">💡生产中不要这样！这仅用于本地开发目的。</p></blockquote><p id="11d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要配置SSL信任:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="04da" class="kw kx iq mh b gy ml mm l mn mo">dotnet dev-certs https --trust</span></pre><p id="fc0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们准备好接受请求。</p><h2 id="abff" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated"><strong class="ak">用Kreya调用gRPC API</strong></h2><p id="9ceb" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">因为我们不能用Postman或其他传统的方法向gRPC APIs发送请求，所以你可能在寻找一个像Postman一样可以帮助你测试/调试的工具，在这种情况下，Kreya可能是一个不错的选择。</p><p id="0742" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先你需要从下面写的网址下载Kreya。<br/><a class="ae lu" href="https://kreya.app/downloads/" rel="noopener ugc nofollow" target="_blank">https://kreya.app/downloads/</a></p><p id="bd32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装后，点击创建项目按钮</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/9fcaf7cade8367baf9b7b4554d13b319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rz9LQFWOUTSj2F1Tj1YmBg.png"/></div></div></figure><p id="9b35" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后为项目文件选择一个位置，并根据需要填写其他输入。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/b72a69caf26b34a7670121c739b6b541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jf6djgfe_VwMtv1jA8bQfw.png"/></div></div></figure><p id="fdab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">单击项目/进口商设置类型为gRPC proto文件，并在。NET项目作为原型目录。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/1dc404f75f64b95c468c6381ea920f69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5bIJd0k5tSnbzOwuzoJcjQ.png"/></div></div></figure><p id="8aa5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以从目录设置部分设置端点。如果你想使用<strong class="ka ir"> gRPC </strong>你应该设置HTTP端口配置为HTTP2支持，如果你想使用<strong class="ka ir"> gRPC-Web </strong>你可以在Mac设备上设置HTTP和HTTPS端口，否则你应该设置项目的HTTPS端口。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/e55fd4e09f9f45e6df27c9f0a90fd888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EDT7j3LynTuW63gIn18CWg.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">对于gRPC-网络模式MAC</figcaption></figure><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/cc762699aabcab53f302a97b6d2aea84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y9IXJxYf1UPykoMgtWNpLg.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">对于gRPC模式MAC</figcaption></figure><p id="ff0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，您可以通过单击FetchReponse标签发送请求，该标签来自我们的原型文件，并且可能会因您的原型文件而异。</p><p id="7ae7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，回复会一直持续到取消。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/3f85b3e4f8f268d8e3f2db71470dfc7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*URRrwD2lJUmNmTfjNXIP-g.png"/></div></div></figure><p id="5994" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果不喜欢Kreya，可以看看<a class="ae lu" href="https://github.com/fullstorydev/grpcurl" rel="noopener ugc nofollow" target="_blank"> gRPCurl </a>。</p><h2 id="f1f8" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated"><strong class="ak">用YARP构建gRPC-Web网关</strong></h2><p id="14d8" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">我们将面临的另一个挑战是，如果你想将gRPC-Web与网关一起使用，或者如果你想在已经使用网关的项目中使用gRPC，你应该知道Ocelot目前不支持gRPC。使用微软开发的<a class="ae lu" href="https://microsoft.github.io/reverse-proxy/" rel="noopener ugc nofollow" target="_blank"> YARP </a>会是一个不错的选择。</p><p id="d9a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从创建一个新项目并安装Yarp开始。使用下面的命令反转Proxy。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="7f82" class="kw kx iq mh b gy ml mm l mn mo">dotnet new web -o gRPC.Web.Gateway<br/>dotnet add gRPC.Web.Gateway.csproj package Yarp.ReverseProxy</span></pre><p id="1560" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">YARP是作为一个. NET组件实现的，所以大部分示例代码都在Program.cs中(以前版本是Startup.cs)。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="f48a" class="kw kx iq mh b gy ml mm l mn mo">var builder = WebApplication.CreateBuilder(args);</span><span id="5064" class="kw kx iq mh b gy mp mm l mn mo">// Add the reverse proxy to capability to the server<br/>var proxyBuilder = builder.Services.AddReverseProxy();</span><span id="525e" class="kw kx iq mh b gy mp mm l mn mo">// Initialize the reverse proxy from the "ReverseProxy" section of configuration<br/>proxyBuilder.LoadFromConfig(builder.Configuration.GetSection("ReverseProxy"));</span><span id="10a6" class="kw kx iq mh b gy mp mm l mn mo">var app = builder.Build();</span><span id="454a" class="kw kx iq mh b gy mp mm l mn mo">// Enable endpoint routing, required for the reverse proxy<br/>app.UseRouting();</span><span id="9476" class="kw kx iq mh b gy mp mm l mn mo">// Register the reverse proxy routes<br/>app.MapReverseProxy();</span><span id="c762" class="kw kx iq mh b gy mp mm l mn mo">app.Run();</span></pre><p id="8cc0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，appsettings.json文件应该如下所示。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="6487" class="kw kx iq mh b gy ml mm l mn mo">{<br/>  "Logging": {<br/>    "LogLevel": {<br/>      "Default": "Information",<br/>      "Microsoft.AspNetCore": "Warning"<br/>    }<br/>  },<br/>  "ReverseProxy": {<br/>    "routes": {<br/>      "grpc-web-service": {<br/>        "clusterId": "grpc-web-service",<br/>        "match": {<br/>          "path": "grpc/grpc-web-service/{**catch-all}"<br/>        },<br/>        "transforms": [<br/>          {<br/>            "pathPattern": "{**catch-all}"<br/>          },<br/>          { "RequestHeadersCopy": "true" },<br/>          { "RequestHeaderOriginalHost": "true" }<br/>        ]<br/>      }<br/>    },<br/>    "clusters": {<br/>      "grpc-web-service": {<br/>        "destinations": {<br/>          "destination1": {<br/>            "address": "<a class="ae lu" href="http://localhost:5019" rel="noopener ugc nofollow" target="_blank">http://localhost:</a>5019"<br/>          }<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="1a77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想深入了解YARP，学习高级/详细的用法，你可以访问这篇文章。</p><p id="31cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您想查看带有HTTP2的gRPC配置示例，请访问这篇文章。</p><p id="9f3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个阶段，您应该能够通过网关端点向我们的gRPC服务发送请求。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/4a96073a1ba9c5fafccf7c91297138de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*451FmpJius4a4WQb9KJ--g.png"/></div></div></figure><h2 id="3313" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated"><strong class="ak">建筑。NET gRPC-Web客户端</strong></h2><p id="c07d" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">让我们使用下面编写的命令创建另一个项目作为gRPC客户机。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="95f3" class="kw kx iq mh b gy ml mm l mn mo">dotnet new console -o gRPC.Console.Client</span></pre><p id="a09c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们应该创建一个包含我们的原型文件的文件夹，并将原型文件移动到其中。</p><p id="fe23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们依赖谷歌。Protobuf，Grpc。Net客户端。Net.Client.Web和Grpc。用. NET构建客户端的工具包</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="9efb" class="kw kx iq mh b gy ml mm l mn mo">dotnet add gRPC.Console.Client.csproj package Google.Protobuf<br/>dotnet add gRPC.Console.Client.csproj package Grpc.Tools <br/>dotnet add gRPC.Console.Client.csproj package Grpc.Net.Client<br/>dotnet add gRPC.Console.Client.csproj package Grpc.Net.Client.Web</span></pre><p id="2251" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装完这些包之后，我们需要在我们的。csproj文件将能够使用自动生成的代码。这个配置与我们的服务器几乎相同，但是我们这次将“GrpcServices”值设置为“Client”而不是“server”。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="a680" class="kw kx iq mh b gy ml mm l mn mo">&lt;ItemGroup&gt;<br/> &lt;Protobuf Include="Protos\stream.proto" GrpcServices="Client" /&gt;<br/>&lt;/ItemGroup&gt;</span></pre><blockquote class="lv lw lx"><p id="7710" class="jy jz ly ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated">进行gRPC调用时，会忽略gRPC通道地址的路径部分。例如，<code class="fe mq mr ms mh b">GrpcChannel.ForAddress("https://localhost:5001/ignored_path")</code>在为服务路由gRPC呼叫时不会使用<code class="fe mq mr ms mh b">ignored_path</code>。</p><p id="acbd" class="jy jz ly ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated">地址路径被忽略，因为gRPC有一个标准化的、规定的地址结构。gRPC地址结合了包、服务和方法名:<code class="fe mq mr ms mh b"><a class="ae lu" href="https://localhost:5001/PackageName.ServiceName/MethodName." rel="noopener ugc nofollow" target="_blank">https://localhost:5001/PackageName.ServiceName/MethodName</a></code> <a class="ae lu" href="https://localhost:5001/PackageName.ServiceName/MethodName." rel="noopener ugc nofollow" target="_blank">。</a></p><p id="7662" class="jy jz ly ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated">在某些情况下，应用程序需要包含gRPC调用的路径。例如，当ASP.NET核心gRPC应用程序托管在IIS目录中，并且该目录需要包含在请求中时。当需要一个路径时，可以使用自定义的<code class="fe mq mr ms mh b">SubdirectoryHandler</code>将它添加到gRPC调用中</p></blockquote><p id="636d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来源:<a class="ae lu" href="https://docs.microsoft.com/en-us/aspnet/core/grpc/troubleshoot?view=aspnetcore-6.0#calling-grpc-services-hosted-in-a-sub-directory" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/aspnet/core/grpc/troubleshoot？view = aspnetcore-6.0 # calling-grpc-services-hosted-in-a-sub-directory</a></p><p id="cc71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据微软的说法，如果您想为gRPC调用使用网关或其他前缀，我们需要创建一个子目录Handler，如下所示。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="b494" class="kw kx iq mh b gy ml mm l mn mo">namespace gRPC.Console.Client.Handlers<br/>{</span><span id="53e2" class="kw kx iq mh b gy mp mm l mn mo">/// &lt;summary&gt;<br/>    /// A delegating handler that adds a subdirectory to the URI of gRPC requests.<br/>    /// &lt;/summary&gt;<br/>    public class SubdirectoryHandler : DelegatingHandler<br/>    {<br/>        private readonly string _subdirectory;</span><span id="a309" class="kw kx iq mh b gy mp mm l mn mo">public SubdirectoryHandler(HttpMessageHandler innerHandler, string subdirectory)<br/>            : base(innerHandler)<br/>        {<br/>            _subdirectory = subdirectory;<br/>        }</span><span id="951c" class="kw kx iq mh b gy mp mm l mn mo">protected override Task&lt;HttpResponseMessage&gt; SendAsync(<br/>            HttpRequestMessage request, CancellationToken cancellationToken)<br/>        {<br/>            var old = request.RequestUri;</span><span id="102e" class="kw kx iq mh b gy mp mm l mn mo">var url = $"{old.Scheme}://{old.Host}:{old.Port}";<br/>            url += $"{_subdirectory}{request.RequestUri.AbsolutePath}";<br/>            request.RequestUri = new Uri(url, UriKind.Absolute);</span><span id="9bd5" class="kw kx iq mh b gy mp mm l mn mo">return base.SendAsync(request, cancellationToken);<br/>        }<br/>    }<br/>}</span></pre><p id="0c27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最终的结构应该如下所示。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/4188da737aa902460045911693e76446.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*ATq10EsU9a2g-qrpYoq-Tg.png"/></div></figure><p id="f7f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一步，我们应该将我们的逻辑编写到Program.cs中，如下所示。</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/c1a696424fc3b94a00fe03cf06122698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*diOZTt6cdfdKJxqj0AGoFw.png"/></div></figure><h2 id="8484" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated"><strong class="ak">构建Angular gRPC-Web客户端</strong></h2><p id="9bf6" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">我们必须安装protocol，它是一个协议编译器，可以帮助我们从。作为第一步的原型文件。</p><blockquote class="lv lw lx"><p id="1dc4" class="jy jz ly ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated"><strong class="ka ir">本文是用protobuf的</strong> <a class="ae lu" href="https://github.com/protocolbuffers/protobuf/releases/tag/v3.19.4" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> v3.19.4编写的。</strong>T13】</a></p></blockquote><p id="1e78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">按照以下URL中的说明在<strong class="ka ir"> Windows </strong>设备上安装。<br/><a class="ae lu" href="https://www.geeksforgeeks.org/how-to-install-protocol-buffers-on-windows/" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/how-to-install-protocol-buffers-on-windows/</a></p><blockquote class="lv lw lx"><p id="b180" class="jy jz ly ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated"><strong class="ka ir">不要选择Javascript版本，因为我们会使用TypeScript。</strong></p></blockquote><p id="c642" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于<strong class="ka ir"> Mac </strong>设备:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="8f23" class="kw kx iq mh b gy ml mm l mn mo">brew install protobuf</span></pre><p id="c151" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们用下面的命令创建一个角度项目。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="3ac4" class="kw kx iq mh b gy ml mm l mn mo">ng new gRPC.Angular.Client --routing=false --style=scss</span></pre><p id="a2cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为protocol不支持TypeScript，我们需要将ts-protocol-gen插件添加到我们的项目中。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="68a5" class="kw kx iq mh b gy ml mm l mn mo">npm install --save ts-protoc-gen</span></pre><p id="76e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要安装<a class="ae lu" href="https://github.com/improbable-eng/grpc-web" rel="noopener ugc nofollow" target="_blank">不可能的gRPC-web </a>库和<a class="ae lu" href="https://www.npmjs.com/package/google-protobuf" rel="noopener ugc nofollow" target="_blank"> google-protobuf </a>包(+its types<a class="ae lu" href="https://www.npmjs.com/package/@types/google-protobuf" rel="noopener ugc nofollow" target="_blank">@ types/Google-proto buf</a>):</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="f5ac" class="kw kx iq mh b gy ml mm l mn mo">npm install --save google-protobuf</span><span id="a033" class="kw kx iq mh b gy mp mm l mn mo">npm install --save-dev @types/google-protobuf</span><span id="5853" class="kw kx iq mh b gy mp mm l mn mo">npm install --save @improbable-eng/grpc-web</span></pre><p id="4993" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们应该创建一个包含我们的原型文件的目录。我创建了一个名为“protos”的目录，并将stream.proto文件复制到那里。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/0008e46abe15cf6fd5968a5591c130d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*EBGmTFJBCym96Ggl8SWotg.png"/></div></figure><p id="9279" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们将目录更改为“protos”文件夹，并创建自动生成的文件，如带有协议的服务和客户端。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="993e" class="kw kx iq mh b gy ml mm l mn mo">protoc --plugin=protoc-gen-ts="../../../node_modules/.bin/protoc-gen-ts" --js_out="import_style=commonjs,binary:../generated" --ts_out="service=grpc-web:../generated" stream.proto</span></pre><blockquote class="lv lw lx"><p id="7b9b" class="jy jz ly ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated"><strong class="ka ir">对于Windows </strong>设备，protocol-gen-ts路径应该是绝对路径，而不是protocol-gen-ts，您应该使用protocol-gen-ts . cmd。</p></blockquote><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="ca5c" class="kw kx iq mh b gy ml mm l mn mo">protoc --plugin=protoc-gen-ts="{ABSOLUTEPATH}\node_modules\.bin\protoc-gen-ts.cmd" --js_out="import_style=commonjs,binary:{OUTPUTPATH}" --ts_out="service=grpc-web:{OUTPUTPATH}" {PROTO_FILE_PATH]</span></pre><p id="53bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在执行上面的命令后，我们应该会看到4个生成的文件。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/0f5a92a99c8e62ed95d3b8d89db5cdae.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*1rL6QsSCjiezQYTrv5mWoA.png"/></div></figure><p id="c49b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们将grpc-web实现到app.component.ts中。</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><blockquote class="lv lw lx"><p id="abc1" class="jy jz ly ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated"><strong class="ka ir">不要忘记添加一个允许gRPC使用4200端口的cors策略。Web.Server项目。</strong></p></blockquote><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/d0043e9ef13df3d5d2b9171604da0196.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*SC2KrnVg-UrqbH6ubgyj2Q.png"/></div></figure><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/11ba46c0b6c8bce9df79aeb31b4f5ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PIahBAa5N8l4AjOS5cVd8w.gif"/></div></div></figure><h2 id="1baf" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated"><strong class="ak">为服务器和客户端添加JWT认证</strong></h2><p id="9280" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">您可能需要在grpc应用程序中使用JWT认证，这很容易实现。您只需要在服务器端添加[Authorize]属性。</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1154" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，您可以从Kreya的元数据部分添加您的令牌。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/a8606d030e8a1d050daec50359bbfbc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xMm2lcDLopNkwNaVNTaBTQ.png"/></div></div></figure><p id="cd3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将令牌添加到元数据部分对于Angular来说就足够了。</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="adcd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">。网络客户端:</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="947e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GitHub网址:<a class="ae lu" href="https://github.com/edisnezir/grpc-demo" rel="noopener ugc nofollow" target="_blank">https://github.com/edisnezir/grpc-demo</a></p></div></div>    
</body>
</html>