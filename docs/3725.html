<html>
<head>
<title>Deploy A Ceph Cluster On Kubernetes With Rook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Rook在Kubernetes上部署一个Ceph集群</h1>
<blockquote>原文：<a href="https://itnext.io/deploy-a-ceph-cluster-on-kubernetes-with-rook-d75a20c3f5b1?source=collection_archive---------1-----------------------#2020-02-11">https://itnext.io/deploy-a-ceph-cluster-on-kubernetes-with-rook-d75a20c3f5b1?source=collection_archive---------1-----------------------#2020-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="30eb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们来看看这个伟大的CNCF项目的概况</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3787da07a38ce477ae6bc2e5bc6ab626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ghwSZO9JS1Bzxl6ZGtKW4A.png"/></div></div></figure><h1 id="826f" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="c94d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在本指南中，您将使用Rook在Kubernetes集群中设置Ceph存储。然后，您将使用Ceph的块存储为MongoDB数据库持久化数据。</p><p id="18d7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">完成后，您将知道什么是Rook，以及如何使用它来部署Ceph。您还将了解如何使用Rook在Kubernetes中部署其他一些存储后端。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="b353" class="ku kv it bd kw kx mu kz la lb mv ld le jz mw ka lg kc mx kd li kf my kg lk ll bi translated">先决条件</h1><p id="3204" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在开始阅读本指南之前，您需要具备以下条件:</p><ul class=""><li id="02b6" class="mz na it lo b lp mi ls mj lv nb lz nc md nd mh ne nf ng nh bi translated">一个包含4个节点的Kubernetes集群:1个主节点和3个工作节点。每个节点都是一个至少有4GB内存的Ubuntu 18.04服务器。在本教程中，我们使用在数字海洋上用官方<a class="ae ni" href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/" rel="noopener ugc nofollow" target="_blank"> kubeadm </a>工具创建的集群。主节点命名为<strong class="lo iu"> master </strong>，工作节点命名为<strong class="lo iu"> node-01 </strong>、<strong class="lo iu"> node-02 </strong>和<strong class="lo iu"> node-03 </strong>。</li><li id="a839" class="mz na it lo b lp nj ls nk lv nl lz nm md nn mh ne nf ng nh bi translated">被配置为与上述集群通信的kubectl实用程序</li></ul><p id="9094" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi no translated"><span class="l np nq nr bm ns nt nu nv nw di"> N </span>注意:拥有一个HA集群至少需要2个主节点和3个etcd实例，但是这里使用的设置对于本例来说已经足够了</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="ecc4" class="ku kv it bd kw kx mu kz la lb mv ld le jz mw ka lg kc mx kd li kf my kg lk ll bi translated">步骤1 -创建块卷存储</h1><p id="286a" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在此步骤中，我们将创建3个数据块卷，并将它们分别连接到一个工作节点。这些卷将在以后用于持久存储Ceph集群的数据。</p><p id="a8e1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">对于每个卷，我们将执行以下步骤:</p><p id="7907" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">首先，我们进入数字海洋控制面板的音量菜单，点击<strong class="lo iu">添加音量</strong>按钮。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/73efd6773255cdfbe50850504d0054fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rmLtL7k4lXIkUF1yjIFcdA.png"/></div></div></figure><p id="3197" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">接下来，我们在表格中填入以下信息:</p><ul class=""><li id="cd67" class="mz na it lo b lp mi ls mj lv nb lz nc md nd mh ne nf ng nh bi translated">我们设置了30GB的自定义大小</li><li id="a78a" class="mz na it lo b lp nj ls nk lv nl lz nm md nn mh ne nf ng nh bi translated">我们为卷提供一个名称(第一个卷命名为<strong class="lo iu"> vol-01 </strong>，下一个卷命名为<strong class="lo iu"> vol-02 </strong>，…)</li><li id="d7cc" class="mz na it lo b lp nj ls nk lv nl lz nm md nn mh ne nf ng nh bi translated">我们选择一个液滴来附加卷(<strong class="lo iu"> vol-01 </strong>将附加到<strong class="lo iu"> node-01 </strong>，<strong class="lo iu"> vol-02 </strong>到<strong class="lo iu"> node-02 </strong>，…)</li><li id="eee9" class="mz na it lo b lp nj ls nk lv nl lz nm md nn mh ne nf ng nh bi translated">我们选择<strong class="lo iu">手动格式化&amp;挂载</strong>选项</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/eb45e6b5721c049438020527623d283a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p8QubDsMAn-zCfCTt5hzww.png"/></div></div></figure><p id="8686" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最后，我们点击<strong class="lo iu">创建卷</strong>按钮创建每个卷。</p><p id="cfac" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi no translated"><span class="l np nq nr bm ns nt nu nv nw di"> N </span>注意:我们可以忽略创建每个卷后出现的配置说明</p><p id="eeb2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">一旦创建了3个卷并将其连接到工作节点，我们就有了一个类似于下图的映射。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/9981d054a3e9735a487771eb604c8298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BRH1x0TF6cd77eSorEqhKw.png"/></div></div></figure><p id="8766" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在我们已经设置了存储基础设施，我们将在Kubernetes集群上部署Rook。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="85b9" class="ku kv it bd kw kx mu kz la lb mv ld le jz mw ka lg kc mx kd li kf my kg lk ll bi translated"><strong class="ak">第2步——为Ceph存储部署Rook操作员</strong></h1><p id="5da9" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Rook是【云原生计算基金会(CNCF)】(<a class="ae ni" href="https://cncf.io" rel="noopener ugc nofollow" target="_blank">https://cncf . io</a>)的孵化项目。它专门用于存储协调，并允许在Kubernetes集群中部署多个存储解决方案。在本文中，我们将重点关注Ceph存储，但也有其他存储解决方案。</p><p id="a95a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi no translated"><span class="l np nq nr bm ns nt nu nv nw di"> N </span>注:Ceph和EdgeFS目前是Rook支持的两家存储提供商，处于<em class="ny">稳定状态</em>。其他存储提供商，如Cassandra、Minio、NFS、CockroachDB、YugabyteDB都处于<em class="ny"> Alpha </em>状态</p><p id="1554" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">首先，我们克隆GitHub存储库并使用1.2版(迄今为止的最后一个版本)</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="884a" class="oe kv it oa b gy of og l oh oi">$ git clone <a class="ae ni" href="https://github.com/rook/rook.git" rel="noopener ugc nofollow" target="_blank">https://github.com/rook/rook.git</a><br/>$ cd rook<br/>$ git checkout release-1.2</span></pre><p id="619d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">对于Rook支持的每个存储解决方案，都有一个Kubernetes <strong class="lo iu">操作员</strong>。简而言之，操作符是一个在Pod中运行的进程，它包含管理复杂应用程序的所有逻辑。运算符通常用于管理有状态的应用程序。</p><p id="b236" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">首先，我们将进入包含Ceph所需的所有资源的文件夹。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="e09b" class="oe kv it oa b gy of og l oh oi">$ cd cluster/examples/kubernetes/ceph</span></pre><p id="f970" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">接下来，我们部署车的Ceph操作符所需的所有资源。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="5ffb" class="oe kv it oa b gy of og l oh oi">$ kubectl create -f common.yaml</span></pre><p id="59e2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">那些资源主要是<strong class="lo iu">CustomRessourceDefinitions</strong>，也称为CRDs。它们用于定义操作员将使用的新资源(读取Kubernetes中默认不存在的资源)。创建的其他资源主要与访问权限相关，因此操作员可以与集群的<strong class="lo iu"> API服务器</strong>通信:</p><ul class=""><li id="91e5" class="mz na it lo b lp mi ls mj lv nb lz nc md nd mh ne nf ng nh bi translated">服务帐户</li><li id="b18e" class="mz na it lo b lp nj ls nk lv nl lz nm md nn mh ne nf ng nh bi translated">作用</li><li id="ee75" class="mz na it lo b lp nj ls nk lv nl lz nm md nn mh ne nf ng nh bi translated">角色绑定</li><li id="c333" class="mz na it lo b lp nj ls nk lv nl lz nm md nn mh ne nf ng nh bi translated">集群角色</li><li id="9cbf" class="mz na it lo b lp nj ls nk lv nl lz nm md nn mh ne nf ng nh bi translated">ClusterRoleBinding</li></ul><p id="99f3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">接下来，我们部署Ceph操作员，他将负责Ceph集群的设置和编排。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="c88d" class="oe kv it oa b gy of og l oh oi">$ kubectl create -f operator.yaml</span></pre><p id="baa1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">操作员需要几秒钟才能启动并运行。它的状态可以用下面的命令来验证。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="8622" class="oe kv it oa b gy of og l oh oi">$ kubectl get pod -n rook-ceph</span></pre><p id="df76" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">一旦操作员准备好了，它就触发一个<strong class="lo iu"> DaemonSet </strong>的创建，负责在Kubernetes集群的每个worker节点上部署一个<strong class="lo iu"> rook-discover </strong>代理。</p><p id="ee4d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最后，一旦一切都设置好了，上面命令的结果类似于下面的输出。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="0ebe" class="oe kv it oa b gy of og l oh oi">NAME READY STATUS RESTARTS AGE<br/>rook-ceph-operator-75d95cb868-s7m5z 1/1 Running 0 78s<br/>rook-discover-44dq9 1/1 Running 0 43s<br/>rook-discover-7gxn7 1/1 Running 0 43s<br/>rook-discover-xfqmk 1/1 Running 0 43s</span></pre><p id="a93f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">注意:标识符在您的环境中会有所不同</p><p id="e801" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在已经准备好使用操作符部署Ceph集群了。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="ca79" class="ku kv it bd kw kx mu kz la lb mv ld le jz mw ka lg kc mx kd li kf my kg lk ll bi translated">步骤3 -创建Ceph集群</h1><p id="1575" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们现在将在我们的Kubernetes集群中创建一个Ceph集群。</p><p id="0aa0" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">下图显示了将在集群中作为pod运行的所有Ceph相关流程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/56e9468997e7013e95b841ef44064b67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zc-Y143F5SLo5Dlshg1Q6w.png"/></div></div><figcaption class="ok ol gj gh gi om on bd b be z dk translated">Ceph集群中的白嘴鸦豆荚</figcaption></figure><ul class=""><li id="7ce8" class="mz na it lo b lp mi ls mj lv nb lz nc md nd mh ne nf ng nh bi translated"><strong class="lo iu"> mgr </strong>是一个<strong class="lo iu">管理器</strong>守护进程，负责跟踪运行时指标和Ceph集群的当前状态。对于高可用性集群，至少需要2个Ceph管理器</li><li id="3b80" class="mz na it lo b lp nj ls nk lv nl lz nm md nn mh ne nf ng nh bi translated"><strong class="lo iu"> mon </strong>是一个<strong class="lo iu">监视器</strong>，负责维护Ceph守护进程相互协调所需的集群状态图。对于高可用性集群，至少需要三台监视器</li><li id="28b9" class="mz na it lo b lp nj ls nk lv nl lz nm md nn mh ne nf ng nh bi translated"><strong class="lo iu"> osd </strong>是一个对象存储守护进程，负责存储数据，处理数据复制、恢复、再平衡。对于HA Ceph集群，至少需要3个Ceph OSDs</li></ul><p id="bb12" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">首先，我们使用下面的规范定义一个<strong class="lo iu"> CephCluster </strong>资源。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="91e8" class="oe kv it oa b gy of og l oh oi">apiVersion: ceph.rook.io/v1<br/>kind: CephCluster<br/>metadata:<br/>  name: rook-ceph<br/>  namespace: rook-ceph<br/>spec:<br/>  cephVersion:<br/>    image: ceph/ceph:v14.2<br/>  allowUnsupported: false<br/>  dataDirHostPath: /var/lib/rook<br/>  skipUpgradeChecks: false<br/>  mon:<br/>    count: 3<br/>    allowMultiplePerNode: false<br/>  dashboard:<br/>    enabled: true<br/>    ssl: true<br/>  monitoring:<br/>    enabled: false<br/>    rulesNamespace: rook-ceph<br/>  network:<br/>    hostNetwork: false<br/>  rbdMirroring:<br/>    workers: 0<br/>  storage:<br/>    useAllNodes: true<br/>    useAllDevices: true</span></pre><p id="ba7e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">它基本上定义了如何配置集群。属性<strong class="lo iu"> useAllNodes </strong>和<strong class="lo iu"> useAllDevices </strong>被设置为<strong class="lo iu"> true </strong>，这样Kubernetes集群的每个worker节点都将用于部署Ceph的进程，所有连接到这些节点的设备都将用于持久存储Ceph集群的数据。</p><p id="4118" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后，我们创建集群:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="757e" class="oe kv it oa b gy of og l oh oi">$ kubectl apply -f cluster.yaml</span></pre><p id="f075" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这个新的<strong class="lo iu"> CephCluster </strong>资源的创建将通知Ceph操作员，并且Ceph操作员将向<strong class="lo iu"> API服务器</strong>发送请求，以便创建所有与Ceph相关的pod。</p><p id="d9f6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">接下来，我们确保负责Ceph集群的所有pod都已启动并运行。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="516c" class="oe kv it oa b gy of og l oh oi">$ kubectl get pod -n rook-ceph</span></pre><p id="cf06" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">创建集群通常需要几分钟时间。完成后，我们应该会得到一个类似于以下输出的列表。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="4e7a" class="oe kv it oa b gy of og l oh oi">NAME READY STATUS RESTARTS AGE<br/>csi-cephfsplugin-fnpm9                        3/3 Running 0 10m<br/>csi-cephfsplugin-hxml9                        3/3 Running 0 10m<br/>csi-cephfsplugin-provisioner-7c44c4ff49-k8z9t 4/4 Running 0 10m<br/>csi-cephfsplugin-provisioner-7c44c4ff49-kmdp9 4/4 Running 1 10m<br/>csi-cephfsplugin-qwm6m                        3/3 Running 0 10m<br/>csi-rbdplugin-dgmv8                           3/3 Running 0 10m<br/>csi-rbdplugin-provisioner-7458d98547-xg7x8    5/5 Running 1 10m<br/>csi-rbdplugin-provisioner-7458d98547-xz2kg    5/5 Running 1 10m<br/>csi-rbdplugin-qxx26                           3/3 Running 0 10m<br/>csi-rbdplugin-s2mxj                           3/3 Running 0 10m<br/>rook-ceph-mgr-a-5d8bf85bb7-nnnxc              1/1 Running 0 7m5s<br/>rook-ceph-mon-a-7678858484–5txtz              1/1 Running 0 8m<br/>rook-ceph-mon-b-6b6f697f94–577z8              1/1 Running 0 7m44s<br/>rook-ceph-mon-c-89c78d866–4w5sb               1/1 Running 0 7m25s<br/>rook-ceph-operator-75d95cb868-s7m5z           1/1 Running 0 13m<br/>rook-ceph-osd-prepare-node-01-dj9tm           0/1 Completed 0 6m33s<br/>rook-ceph-osd-prepare-node-02–49d5c           0/1 Completed 0 6m33s<br/>rook-ceph-osd-prepare-node-03-md22x           0/1 Completed 0 6m33s<br/>rook-discover-44dq9                           1/1 Running 0 12m<br/>rook-discover-7gxn7                           1/1 Running 0 12m<br/>rook-discover-xfqmk                           1/1 Running 0 12m</span></pre><p id="20bc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi no translated">注意:在您的环境中，标识符会有所不同</p><p id="ab28" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">Ceph可以提供几种存储方式:</p><ul class=""><li id="cafa" class="mz na it lo b lp mi ls mj lv nb lz nc md nd mh ne nf ng nh bi translated">文件系统</li><li id="5768" class="mz na it lo b lp nj ls nk lv nl lz nm md nn mh ne nf ng nh bi translated">目标</li><li id="0cc8" class="mz na it lo b lp nj ls nk lv nl lz nm md nn mh ne nf ng nh bi translated">街区</li></ul><p id="bc0e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在下文中，我们将创建使用数据块存储所需的资源。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="efab" class="ku kv it bd kw kx mu kz la lb mv ld le jz mw ka lg kc mx kd li kf my kg lk ll bi translated">步骤4 -从Ceph获取块存储</h1><p id="32d6" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">文件<em class="ny">cluster/examples/Kubernetes/ceph/CSI/rbd/storage class . YAML</em>定义了一个<strong class="lo iu"> ReplicaPool </strong>和一个<strong class="lo iu"> StorageClass </strong>来自动创建由Ceph块存储备份的Kubernetes<strong class="lo iu">persistent volume</strong>。</p><p id="2e31" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">首先，我们创建这些资源:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="11d6" class="oe kv it oa b gy of og l oh oi">$ kubectl apply -f ./csi/rbd/storageclass.yaml</span></pre><p id="36cd" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">接下来，我们定义一个<strong class="lo iu"> PersistentVolumeClaim </strong>，一个用于请求存储的资源。由于它使用之前创建的<em class="ny">rook-ceph-block</em><strong class="lo iu">storage class</strong>，因此它将自动从Ceph集群中调配块存储。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="51e9" class="oe kv it oa b gy of og l oh oi">apiVersion: v1<br/>kind: PersistentVolumeClaim<br/>metadata:<br/>  name: mongo-pvc<br/>spec:<br/>  storageClassName: rook-ceph-block<br/>  accessModes:<br/>  - ReadWriteOnce<br/>  resources:<br/>    requests:<br/>      storage: 5Gi</span></pre><p id="ca98" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">接下来，我们用下面的命令创建<strong class="lo iu"> PersistentVolumeClaim </strong>。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="133c" class="oe kv it oa b gy of og l oh oi">$ kubectl apply -f pvc-rook-ceph-block.yaml</span></pre><p id="9b35" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后，我们验证<strong class="lo iu">持续卷声明</strong>已经触发了<strong class="lo iu">持续卷</strong>的创建。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="792e" class="oe kv it oa b gy of og l oh oi">$ kubectl get pvc,pv</span></pre><p id="d9e6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们应该得到一个列表，显示自动配置的<strong class="lo iu">持久卷声明</strong>和<strong class="lo iu">持久卷</strong>之间的绑定。</p><p id="e983" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在幕后，<strong class="lo iu">持久卷</strong>存储在连接到工作节点的卷上。</p><p id="cec1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在接下来的步骤中，我们将使用这个存储来持久化MongoDB数据库的数据。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="66df" class="ku kv it bd kw kx mu kz la lb mv ld le jz mw ka lg kc mx kd li kf my kg lk ll bi translated">步骤5——创建MongoDB数据库</h1><p id="c331" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们现在将部署一个数据库工作负载，并使用在上一步中调配的存储来保存Pod的数据。</p><p id="2ac7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">首先，我们定义一个包含以下内容的规范:</p><ul class=""><li id="eca7" class="mz na it lo b lp mi ls mj lv nb lz nc md nd mh ne nf ng nh bi translated">一个基于<em class="ny"> mongo:4.0 </em> Docker映像的<strong class="lo iu">部署</strong>运行1个容器。这个容器使用上面创建的<strong class="lo iu">PersistentVolumeClaim</strong><em class="ny">mongo-PVC</em>。关联的<strong class="lo iu">持久卷</strong>安装在容器文件系统中的<em class="ny"> /data/db </em>上</li><li id="2350" class="mz na it lo b lp nj ls nk lv nl lz nm md nn mh ne nf ng nh bi translated">NodePort类型的<strong class="lo iu">服务</strong>公开了集群中每个节点的端口<em class="ny"> 31017 </em>上的<em class="ny"> mongo </em> Pod</li></ul><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="10b5" class="oe kv it oa b gy of og l oh oi">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: mongo<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: mongo<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: mongo<br/>    spec:<br/>      containers:<br/>      - image: mongo:4.0<br/>        name: mongo<br/>        ports:<br/>        - containerPort: 27017<br/>          name: mongo<br/>        volumeMounts:<br/>        - name: mongo-persistent-storage<br/>          mountPath: /data/db<br/>      volumes:<br/>      - name: mongo-persistent-storage<br/>        persistentVolumeClaim:<br/>          claimName: mongo-pvc<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: mongo<br/>  labels:<br/>    app: mongo<br/>spec:<br/>  selector:<br/>    app: mongo<br/>  type: NodePort<br/>  ports:<br/>    - port: 27017<br/>      nodePort: 31017</span></pre><p id="73b3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后我们创造这些资源。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="2c8e" class="oe kv it oa b gy of og l oh oi">$ kubectl apply -f mongo.yaml</span></pre><p id="0164" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">接下来，我们可以验证<strong class="lo iu"> Pod </strong>和<strong class="lo iu">服务</strong>是否被正确创建。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="ac8d" class="oe kv it oa b gy of og l oh oi">$ kubectl get pods,svc</span></pre><p id="41ac" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们有一个数据库<strong class="lo iu"> Pod </strong>将它的数据保存在底层的Ceph存储中。在接下来的步骤中，我们将使用一个MongoDB客户端并进行连接，确保一切正常。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="5ef5" class="ku kv it bd kw kx mu kz la lb mv ld le jz mw ka lg kc mx kd li kf my kg lk ll bi translated">步骤6 -连接到数据库</h1><p id="7b58" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们现在将使用一个MongoDB客户机，并连接到上一步中部署的数据库。</p><p id="c075" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">注意:在这一步我们将使用MongoDB Compass，但是任何其他客户端都可以</p><p id="e5a3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">由于数据库是通过类型为<strong class="lo iu"> NodePort </strong>的服务公开的，因此可以从集群的任何节点通过特定端口(在本例中为31017)访问它。</p><p id="53be" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">首先，我们得到节点列表和它们的外部IP</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="cc07" class="oe kv it oa b gy of og l oh oi">$ kubectl get nodes -o wide</span></pre><p id="9195" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">接下来，我们选择一个工作节点IP地址，并使用它来连接我们的客户端。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/3a4cc7d0fe7994369d303fcf24b06954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xFf4k9Do6D87Xhi9P5GDzw.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/88cbff0fb8017217a94e72e8bf6ed192.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e725Q7pN4mGGLwAgbvYbMw.png"/></div></div></figure><p id="56a8" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后我们可以访问数据库并添加一些数据。这些数据将保存在底层Ceph存储中，并跨数据块卷进行复制。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="697f" class="ku kv it bd kw kx mu kz la lb mv ld le jz mw ka lg kc mx kd li kf my kg lk ll bi translated">结论</h1><p id="e166" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在本文中，您使用了一个Rook操作符来部署在Kubernetes中运行Ceph集群所需的所有流程。现在，您可以使用Ceph(对象、块、文件系统)提供的存储解决方案，以一种安全的方式持久存储工作负载的数据。</p><p id="c362" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果你想探索Rook，了解更多可用的存储后端，那么[Rook GitHub repository](<a class="ae ni" href="https://github.com/rook/rook" rel="noopener ugc nofollow" target="_blank">https://github.com/rook/rook</a>)是一个很好的起点。</p></div></div>    
</body>
</html>