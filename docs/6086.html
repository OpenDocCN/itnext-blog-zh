<html>
<head>
<title>Leaner Dependency Injection pattern in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中更精简的依赖注入模式</h1>
<blockquote>原文：<a href="https://itnext.io/lean-dependency-injection-in-typescript-fb2101c70419?source=collection_archive---------2-----------------------#2021-08-12">https://itnext.io/lean-dependency-injection-in-typescript-fb2101c70419?source=collection_archive---------2-----------------------#2021-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4ec2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从Java风格的OOP到更…类型化的感觉？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3aa06415c70cff397090d7c918a53ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KKFO41Gd6E49E06lTQn3OA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">什么时候咖啡图片在编程文章中不起作用？</figcaption></figure><p id="e4e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">解耦代码、消除隐式依赖、支持可测试性都很棒，而依赖注入是实现这些的<em class="lu">模式。然而，传统的类实例为其他类实例获取接口的DI方法有点太… Java？OOP？进取心？当然，我们可以摆脱过于复杂的结构，做一些简单的事情来代替？</em></p><h1 id="4e5d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">问题是</h1><p id="f747" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">让我们定义一堆接口、一个服务、一些数据访问对象(Dao)和简短使用示例(在测试代码中)。假设我们已经定义了一些用户和组织类型。我们现在也让它保持无聊。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">服务注入了几个DAOs，易于测试！</figcaption></figure><p id="ee84" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像上面这样写代码并没有什么大的错误，这完全是一个可以很好伸缩的工作模式。然而，我确实有一些问题。</p><ul class=""><li id="a267" class="mu mv it la b lb lc le lf lh mw ll mx lp my lt mz na nb nc bi translated"><strong class="la iu">类意味着易变的状态。</strong> <em class="lu">或至少是它的一种潜力。看到课有点害怕是个好习惯。如果不需要可变状态，为什么要使用它？</em></li><li id="991c" class="mu mv it la b lb nd le ne lh nf ll ng lp nh lt mz na nb nc bi translated"><strong class="la iu">啰嗦，样板。这显然是一个品味问题，但我有一种感觉，我们可以让一切更简洁。</strong></li><li id="a0d2" class="mu mv it la b lb nd le ne lh nf ll ng lp nh lt mz na nb nc bi translated"><strong class="la iu">接口意味着继承或声明合并。</strong> <em class="lu">或者至少对他们来说有潜力。</em> <strong class="la iu"> </strong> <em class="lu">为什么不用</em> <code class="fe ni nj nk nl b"><em class="lu">type</em></code> <em class="lu">代替？这感觉像是一个更受限制的事情，我觉得很好。如果你一定要使用一个界面，只需要在需要的时候翻转它。</em></li></ul><h1 id="5975" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">更精简的方法</h1><p id="cf22" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">相同的代码:DAOs、服务、示例用法。但是一切都更受限制，更简短，我们更多地使用函数和对象文字。让我们看看进展如何:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">仍然有一个注入了一些Dao的服务，所以其实都是一样的。</figcaption></figure><p id="2f19" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是怎么回事？</p><ul class=""><li id="0e98" class="mu mv it la b lb lc le lf lh mw ll mx lp my lt mz na nb nc bi translated"><strong class="la iu">使用</strong> <code class="fe ni nj nk nl b"><strong class="la iu">type</strong></code> <strong class="la iu">结束接口。这是一个更严格的限制，对我来说是一件好事。</strong></li><li id="87e2" class="mu mv it la b lb nd le ne lh nf ll ng lp nh lt mz na nb nc bi translated">服务现在是闭包而不是类。 <em class="lu">函数返回一个对象文字量。没有隐藏可变状态的可能性，坦率地说，它只是简单得多，甚至可能更容易看。</em></li><li id="e4b0" class="mu mv it la b lb nd le ne lh nf ll ng lp nh lt mz na nb nc bi translated"><strong class="la iu">Dao已经没有接口了。</strong> <em class="lu">有点明白了。Dao或者它们应该是连接器或者API/DB客户端，甚至可能完全不同，这取决于它们具体做什么。</em></li><li id="c378" class="mu mv it la b lb nd le ne lh nf ll ng lp nh lt mz na nb nc bi translated">测试实现只是对象文字。他们真的需要比这更多的东西吗？</li><li id="6c0e" class="mu mv it la b lb nd le ne lh nf ll ng lp nh lt mz na nb nc bi translated">一切都感觉更像是打字稿。还有现代？ <em class="lu">完全是口味问题，所以让我知道你的想法。</em></li></ul><h1 id="0ffd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="b6f9" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">很明显，我更喜欢某种风格。但是我相信我已经尽力用好的论据来证明我的观点。值得注意的是，这里的区别并不在于依赖注入，而在于一般的类型脚本。我倾向于相信，用函数和记录代替基于面向对象类/实例的结构通常更好(我喜欢把对象文字看作记录，而不是单例)。</p><p id="8a73" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尝试不同的方法，看看你更喜欢用什么和看什么。</p></div></div>    
</body>
</html>