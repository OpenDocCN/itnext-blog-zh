<html>
<head>
<title>New JSON/YAML handling way = OPA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">新的JSON/YAML处理方式= OPA</h1>
<blockquote>原文：<a href="https://itnext.io/new-json-handling-way-opa-7806caa15efa?source=collection_archive---------2-----------------------#2021-03-14">https://itnext.io/new-json-handling-way-opa-7806caa15efa?source=collection_archive---------2-----------------------#2021-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="46aa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">“opa eval”的通用JSON/YAML运算</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7882a16c54e36f141b0e111fe139a0bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4YcrntTzRvb_5dAO"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@kaufmann_mercantile?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">考夫曼商业</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h2 id="9f55" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">[更新于2021年4月12日]</h2><p id="701c" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">我注意到<strong class="lu ir">这个方法也可以应用到YAML……</strong>这篇文章关注的是JSON处理，但是YAML之类的<code class="fe ml mm mn mo b">kubectl</code>输出可以传递给<code class="fe ml mm mn mo b">jr</code>命令。我会写另一篇关于这个的文章。</p><h2 id="5524" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="0c8e" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">使用OPA可以进行以下JSON处理。<code class="fe ml mm mn mo b">jr</code>包括<code class="fe ml mm mn mo b">opa eval</code>。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="e2bc" class="kw kx iq mo b gy mt mu l mv mw">$ data='{"name":"chris", "friends":["alice", "bob"]}'<br/>$ echo $data | <strong class="mo ir">jr 'i.friends' | jr 'i[0]'</strong><br/>"alice"</span></pre><h1 id="5b20" class="mx kx iq bd ky my mz na lb nb nc nd le jw ne jx li jz nf ka lm kc ng kd lq nh bi translated">处理JSON的现有方法</h1><p id="d92b" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">当我处理JSON数据时，我使用了许多命令工具:<code class="fe ml mm mn mo b">cat</code>、<code class="fe ml mm mn mo b">grep</code>和<code class="fe ml mm mn mo b">jq</code>。<code class="fe ml mm mn mo b">jq</code>有一个用于处理JSON的语法(比如创建一个新的对象或数组，从输入中过滤掉一些值)。下面的<code class="fe ml mm mn mo b">jq</code>命令提取部分JSON对象。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="38e8" class="kw kx iq mo b gy mt mu l mv mw">$ data='{"name":"chris", "friends":["alice", "bob"]}'<br/>$ echo $data | <strong class="mo ir">jq '.name'</strong><br/>"chris"<br/>$ echo $data | <strong class="mo ir">jq '.friends'</strong><br/>[<br/>  "alice",<br/>  "bob"<br/>]</span></pre><h1 id="b8be" class="mx kx iq bd ky my mz na lb nb nc nd le jw ne jx li jz nf ka lm kc ng kd lq nh bi translated">OPA是什么？</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/2dd3434a9e2e6d48730a70c1ece64e25.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*T1E3VRdEfVVGvtXYjIdtMg.png"/></div></figure><p id="0770" class="pw-post-body-paragraph ls lt iq lu b lv nj jr lx ly nk ju ma lf nl mc md lj nm mf mg ln nn mi mj mk ij bi translated"><a class="ae kv" href="https://www.openpolicyagent.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lu ir"> OPA(开放策略代理)</strong> </a>是通用策略引擎。“策略引擎”听起来像一个复杂的工具，但它不是。</p><p id="b8a6" class="pw-post-body-paragraph ls lt iq lu b lv nj jr lx ly nk ju ma lf nl mc md lj nm mf mg ln nn mi mj mk ij bi translated">OPA很简单。OPA接收一些JSON输入，根据定义的规则修改它，并回复一个JSON输出。就是这样。事实上，OPA拥有强大的规则解析器，可以解决复杂的规则。这就是OPA被称为“策略引擎”的原因。但是我们不需要部署复杂的规则。</p><p id="15cb" class="pw-post-body-paragraph ls lt iq lu b lv nj jr lx ly nk ju ma lf nl mc md lj nm mf mg ln nn mi mj mk ij bi translated">我们可以按照<a class="ae kv" href="https://www.openpolicyagent.org/docs/latest/#running-opa" rel="noopener ugc nofollow" target="_blank">正式文件</a>安装<code class="fe ml mm mn mo b">opa</code>命令行工具。当您使用MacOS时，只需运行以下命令。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="950e" class="kw kx iq mo b gy mt mu l mv mw"><strong class="mo ir">brew install opa</strong></span></pre><h1 id="f7ff" class="mx kx iq bd ky my mz na lb nb nc nd le jw ne jx li jz nf ka lm kc ng kd lq nh bi translated">作为JSON/YAML处理工具的“opa eval”命令</h1><p id="843b" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">我们可以使用<code class="fe ml mm mn mo b">opa</code>命令来处理JSON数据。请看这个例子。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="a843" class="kw kx iq mo b gy mt mu l mv mw">$ data='{"name":"chris", "friends":["alice", "bob"]}'<br/>$ echo $data | <strong class="mo ir">opa eval -I --format=raw 'input.name'</strong><br/>"chris"<br/>$ echo $data | <strong class="mo ir">opa eval -I --format=raw 'input.friends'</strong><br/>[<br/>  "alice",<br/>  "bob"<br/>]</span></pre><p id="52de" class="pw-post-body-paragraph ls lt iq lu b lv nj jr lx ly nk ju ma lf nl mc md lj nm mf mg ln nn mi mj mk ij bi translated">令人惊讶的是，这些命令返回的结果与<code class="fe ml mm mn mo b">jq</code>相同。</p><p id="940b" class="pw-post-body-paragraph ls lt iq lu b lv nj jr lx ly nk ju ma lf nl mc md lj nm mf mg ln nn mi mj mk ij bi translated">让我们简化这些命令。用了一招之后，我们可以这样写<code class="fe ml mm mn mo b">opa eval</code>。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="e12e" class="kw kx iq mo b gy mt mu l mv mw">$ data='{"name":"chris", "friends":["alice", "bob"]}'<br/>$ echo $data | <strong class="mo ir">jr 'i.name'</strong><br/>"chris"<br/>$ echo $data | <strong class="mo ir">jr 'i.friends' | jp i</strong><br/>[<br/>  "alice",<br/>  "bob"<br/>]</span></pre><p id="7b0c" class="pw-post-body-paragraph ls lt iq lu b lv nj jr lx ly nk ju ma lf nl mc md lj nm mf mg ln nn mi mj mk ij bi translated">可以看到用法更类似于<code class="fe ml mm mn mo b">jq</code>。<code class="fe ml mm mn mo b">jr</code>和<code class="fe ml mm mn mo b"><strong class="lu ir">jp</strong></code>只是以下命令的别名。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="4a64" class="kw kx iq mo b gy mt mu l mv mw">opa eval -I --import 'input as i' [--format=pretty / --format=raw]</span></pre><p id="51e1" class="pw-post-body-paragraph ls lt iq lu b lv nj jr lx ly nk ju ma lf nl mc md lj nm mf mg ln nn mi mj mk ij bi translated">让我们配置您的终端以允许这些别名。</p><h1 id="90b5" class="mx kx iq bd ky my mz na lb nb nc nd le jw ne jx li jz nf ka lm kc ng kd lq nh bi translated">配置jp / jr命令</h1><p id="0141" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">如果你使用zsh，在<code class="fe ml mm mn mo b">~/.zshrc</code>中写下下面几行</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="f2f0" class="kw kx iq mo b gy mt mu l mv mw">alias jo="opa eval -I --import 'input as i'"<br/># The above line works after v0.27.1. Before v0.27.0, the next works<br/># <!-- -->alias jo=”opa eval -I --import ‘input as i’” --package p<br/>alias jp="jo --format=pretty"<br/>alias jr="jo --format=raw"</span></pre><h2 id="9ff2" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">含义</strong></h2><ul class=""><li id="0e53" class="no np iq lu b lv lw ly lz lf nq lj nr ln ns mk nt nu nv nw bi translated"><code class="fe ml mm mn mo b">opa eval</code><br/><code class="fe ml mm mn mo b">opa</code>的强大子命令。它评估类似<code class="fe ml mm mn mo b">'input.name'</code>的任意策略。</li><li id="7ea3" class="no np iq lu b lv nx ly ny lf nz lj oa ln ob mk nt nu nv nw bi translated"><code class="fe ml mm mn mo b">-I</code> <br/>该选项表示JSON输入来自标准输入。</li><li id="7b6a" class="no np iq lu b lv nx ly ny lf nz lj oa ln ob mk nt nu nv nw bi translated"><code class="fe ml mm mn mo b">--import 'input as i'</code> <br/>该选项将<code class="fe ml mm mn mo b">input</code>缩短为<code class="fe ml mm mn mo b">'i'</code>。<code class="fe ml mm mn mo b">input</code>是指JSON输入数据的特殊关键字。使用该选项后，我们可以用<code class="fe ml mm mn mo b">i</code>指定输入数据。</li><li id="aed1" class="no np iq lu b lv nx ly ny lf nz lj oa ln ob mk nt nu nv nw bi translated"><code class="fe ml mm mn mo b">--format=pretty / --format=raw</code> <br/>该选项使<code class="fe ml mm mn mo b">opa eval</code>生成JSON输出。</li></ul><h1 id="94b3" class="mx kx iq bd ky my mz na lb nb nc nd le jw ne jx li jz nf ka lm kc ng kd lq nh bi translated">基本用法</h1><h2 id="9c66" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">准备:设置一个输入数据</h2><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="d539" class="kw kx iq mo b gy mt mu l mv mw">$ data='{"people":[{"name":"chris", "friends":["alice", "bob"]}, {"name":"elena", "friends":["dave"]}]}'<br/>$ echo $data | jp i<br/>{<br/>  "people": [<br/>    {<br/>      "friends": [<br/>        "alice",<br/>        "bob"<br/>      ],<br/>      "name": "chris"<br/>    },<br/>    {<br/>      "friends": [<br/>        "dave"<br/>      ],<br/>      "name": "elena"<br/>    }<br/>  ]<br/>}</span></pre><h2 id="5554" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">用法1:过滤一些字段</h2><p id="2ba0" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">基本用法是<code class="fe ml mm mn mo b">i.&lt;some field&gt;</code>选择单个字段。<br/>这个语法和<code class="fe ml mm mn mo b">i.&lt;some&gt;.&lt;child&gt;</code>一样是递归的。<br/>或者我们可以使用管道<code class="fe ml mm mn mo b">|</code>来连接不同的<code class="fe ml mm mn mo b">jr</code>命令。当你想以美化的格式打印输出时，<code class="fe ml mm mn mo b">jp</code>命令很有用。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="7b77" class="kw kx iq mo b gy mt mu l mv mw">$ echo $data | jr <strong class="mo ir">'i.people[1]' | jp i</strong><br/>{<br/>  "friends": [<br/>    "dave"<br/>  ],<br/>  "name": "elena"<br/>}</span><span id="77f6" class="kw kx iq mo b gy oc mu l mv mw">$ echo $data | jr <strong class="mo ir">'i.people[1].friends'</strong><br/>["dave"]</span><span id="2926" class="kw kx iq mo b gy oc mu l mv mw">$ echo $data | jr <strong class="mo ir">'i.people[1]' | jr 'i.friends'</strong><br/>["dave"]</span></pre><blockquote class="od oe of"><p id="51e9" class="ls lt og lu b lv nj jr lx ly nk ju ma oh nl mc md oi nm mf mg oj nn mi mj mk ij bi translated"><strong class="lu ir">技术#1 </strong>。<code class="fe ml mm mn mo b">i.&lt;some field&gt;</code> <em class="iq"> ( </em>选择单个字段)</p></blockquote><h2 id="7ab7" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">用法#2:检查是否包含一些值(条件)</h2><p id="a73f" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">这种用法用于检查JSON数据是否满足某些条件。<br/>最常用的运算符是<code class="fe ml mm mn mo b">==</code>，当<strong class="lu ir">单值等于另一个值</strong>时，返回<code class="fe ml mm mn mo b">true</code>。<br/>并且当<strong class="lu ir">候选包括单个值</strong>时，它也返回<code class="fe ml mm mn mo b">true</code>。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="2b88" class="kw kx iq mo b gy mt mu l mv mw">$ echo $data | jr <strong class="mo ir">'"chris" == i.people[0].name' </strong><br/>true</span><span id="8520" class="kw kx iq mo b gy oc mu l mv mw">$ echo $data | jr <strong class="mo ir">'"chris" == i.people[1].name' </strong><br/>false</span><span id="dedc" class="kw kx iq mo b gy oc mu l mv mw">$ echo $data | jr <strong class="mo ir">'"chris" == i.people[_].name'<br/></strong> # this means any elements have name "chris"<br/>true</span><span id="80dd" class="kw kx iq mo b gy oc mu l mv mw">$ echo $data | jr <strong class="mo ir">'"dave" == i.people[_].friends[_]'</strong><br/>true</span><span id="9b6d" class="kw kx iq mo b gy oc mu l mv mw">$ echo $data | jr <strong class="mo ir">'"dave" == i.people[x].friends[y]'</strong><br/>true</span></pre><blockquote class="od oe of"><p id="5a85" class="ls lt og lu b lv nj jr lx ly nk ju ma oh nl mc md oi nm mf mg oj nn mi mj mk ij bi translated"><strong class="lu ir">技术#2 </strong> : <code class="fe ml mm mn mo b">[_], <em class="iq">[x], [&lt;arbitrary&gt;]</em></code>(指所有考生)</p></blockquote><h2 id="9c17" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">用法3:向上列表</h2><p id="454a" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">第三种常见用法是列出所有元素。<br/>在之前的技术中，显示了<code class="fe ml mm mn mo b">[_]</code>。这也可以用于列表。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="f892" class="kw kx iq mo b gy mt mu l mv mw">$ echo $data | jr <strong class="mo ir">'i.people[_]'</strong><br/>{"friends":["alice","bob"],"name":"chris"}<br/>{"friends":["dave"],"name":"elena"}<br/>$ echo $data | jr <strong class="mo ir">'i.people[_].friends[_]'</strong><br/>alice<br/>bob<br/>dave</span></pre><h2 id="7968" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">用法#4:格式化字符串</h2><p id="699c" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">当我们想创建一个格式化的字符串时，<code class="fe ml mm mn mo b">sprintf</code>在许多编程语言中都会用到。OPA也不例外。我们可以在表达式中使用<code class="fe ml mm mn mo b">sprintf</code>。出于类似的原因，<code class="fe ml mm mn mo b">concat</code>可以用来从许多字符串数据中创建一个字符串数据。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="83e2" class="kw kx iq mo b gy mt mu l mv mw">$ echo $data | jr <strong class="mo ir">'sprintf("name=%s, friends=%s", [i.people[1].name, i.people[1].friends])'<br/></strong>"name=elena, friends=[\"dave\"]"</span><span id="8a5c" class="kw kx iq mo b gy oc mu l mv mw"># Change 1 to x<br/>$ echo $data | jr <strong class="mo ir">'sprintf("name=%s, friends=%s", [i.people[x].name, i.people[x].friends])'</strong><br/>name=chris, friends=["alice", "bob"]<br/>name=elena, friends=["dave"]</span><span id="1a10" class="kw kx iq mo b gy oc mu l mv mw">$ echo $data | jr <strong class="mo ir">'concat(" and ", [i.people[0].friends[0], i.people[0].friends[1]])'</strong><br/>alice and bob</span></pre><blockquote class="od oe of"><p id="e1bb" class="ls lt og lu b lv nj jr lx ly nk ju ma oh nl mc md oi nm mf mg oj nn mi mj mk ij bi translated"><strong class="lu ir">技术#3 </strong> : <code class="fe ml mm mn mo b">sprintf</code>(格式化)<code class="fe ml mm mn mo b">concat</code>(加入数组)<br/>其他内置函数见<a class="ae kv" href="https://www.openpolicyagent.org/docs/latest/policy-reference/#strings" rel="noopener ugc nofollow" target="_blank">官方文档</a> t。</p></blockquote><h2 id="f9bd" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">用法#5:展平到数组</h2><p id="0bfa" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">技术#2 <code class="fe ml mm mn mo b">[_]</code>允许我们获得所有的元素，但是不足以将所有的元素组合在一起。看下面这个例子。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="e140" class="kw kx iq mo b gy mt mu l mv mw">$ echo $data | <strong class="mo ir">jr 'i.people[_].name'</strong><br/>chris<br/>elena</span></pre><p id="f64d" class="pw-post-body-paragraph ls lt iq lu b lv nj jr lx ly nk ju ma lf nl mc md lj nm mf mg ln nn mi mj mk ij bi translated">这个结果不是单个数组对象，而是字符串类型的独立结果。<br/>如果你想得到一个数组，你需要稍微改变一下策略。<br/> <code class="fe ml mm mn mo b">[&lt;any name&gt;|&lt;operation&gt;]</code>返回。另一种语法是<code class="fe ml mm mn mo b">{&lt;any name&gt;|&lt;condition&gt;}</code>。严格来说，这两种语法有不同的含义(第一种生成数组，第二种生成集合)。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="82c0" class="kw kx iq mo b gy mt mu l mv mw">$ echo $data | <strong class="mo ir">jr '[r|r := i.people[_].name]'</strong><br/>["chris","elena"]</span><span id="c188" class="kw kx iq mo b gy oc mu l mv mw">$ echo $data | <strong class="mo ir">jr '[r|r := i.people[_].friends[_]]'</strong><br/>["alice","bob","dave"]</span></pre><blockquote class="od oe of"><p id="fb47" class="ls lt og lu b lv nj jr lx ly nk ju ma oh nl mc md oi nm mf mg oj nn mi mj mk ij bi translated"><strong class="lu ir">技巧四:</strong> <code class="fe ml mm mn mo b">[&lt;any&gt;| &lt;any&gt; := &lt;operation&gt;]</code>(生成数组)</p><p id="de87" class="ls lt og lu b lv nj jr lx ly nk ju ma oh nl mc md oi nm mf mg oj nn mi mj mk ij bi translated"><strong class="lu ir">技巧#5: </strong> <code class="fe ml mm mn mo b"><em class="iq">{&lt;any&gt;| &lt;any&gt; := &lt;operation&gt;}</em></code>(生成一组)</p></blockquote><h2 id="75d6" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">用法#6:条件过滤器</h2><p id="44e1" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">如果你有一个数组或者一个集合，通过执行用法#5，你可以更进一步到高级用法。<br/>高级用法之一是条件过滤器。这是技术#2和技术#4，5的结合。在生成数组的过程中，您可以收集选择性元素。<br/>以下示例在集合生成<code class="fe ml mm mn mo b">{|}</code>中使用了条件表达式<code class="fe ml mm mn mo b">==</code>。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="31ed" class="kw kx iq mo b gy mt mu l mv mw">$ echo $data | <strong class="mo ir">jr '{rtn|rtn := i.people[_]; rtn.name == "chris"}'</strong><br/>[{"friends":["alice","bob"],"name":"chris"}]</span></pre><p id="93db" class="pw-post-body-paragraph ls lt iq lu b lv nj jr lx ly nk ju ma lf nl mc md lj nm mf mg ln nn mi mj mk ij bi translated"><code class="fe ml mm mn mo b">rtn.name == "chris"</code>是过滤<code class="fe ml mm mn mo b">people[_]</code>元素的条件。您可以像这样添加任意数量的条件。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="6af7" class="kw kx iq mo b gy mt mu l mv mw">echo $data | <strong class="mo ir">jr '{rtn|rtn := i.people[_].friends[_]; rtn != "dave"; rtn != "peter"}'</strong><br/>["alice","bob"]</span></pre><p id="e801" class="pw-post-body-paragraph ls lt iq lu b lv nj jr lx ly nk ju ma lf nl mc md lj nm mf mg ln nn mi mj mk ij bi translated">一个更高级的例子是</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="0c6b" class="kw kx iq mo b gy mt mu l mv mw">$ echo $data | jr <strong class="mo ir">'{rtn|<br/>  a := i.people[_]<br/>  a.name == "chris"<br/>  rtn := a.friends[_]<br/>  rtn != "alice"}'</strong><br/>["bob"]</span></pre><p id="6b01" class="pw-post-body-paragraph ls lt iq lu b lv nj jr lx ly nk ju ma lf nl mc md lj nm mf mg ln nn mi mj mk ij bi translated">我们使用<code class="fe ml mm mn mo b">;</code>来分隔多个表达式。但是<code class="fe ml mm mn mo b">breakline</code>也一样工作。<br/>而且上一个例子和下一个例子没有区别。条件行位于不同的位置。这也是OPA强大的原因之一。OPA说它具有声明性。<strong class="lu ir">“声明性”是指规则只需要声明，不需要考虑处理的顺序。</strong></p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="afc3" class="kw kx iq mo b gy mt mu l mv mw">$ echo $data | jr <strong class="mo ir">'{rtn|<br/>  a := i.people[_]<br/>  rtn := a.friends[_] # switched<br/>  a.name == "chris" # switched<br/>  rtn != "alice"}'<br/></strong>["bob"]</span><span id="7dd4" class="kw kx iq mo b gy oc mu l mv mw">$ echo $data | jr <strong class="mo ir">'{rtn|<br/>  a := i.people[_]<br/>  rtn := a.friends[_]<br/>  rtn != "alice" #switched<br/>  a.name == "chris"}' #switched<br/></strong>["bob"]</span></pre><h1 id="3689" class="mx kx iq bd ky my mz na lb nb nc nd le jw ne jx li jz nf ka lm kc ng kd lq nh bi translated">OPA的高级用途和通往深层世界的大门</h1><h2 id="87a4" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">高级用法#1:多个字段</h2><p id="9326" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">当技术#2、3、4结合起来时，我们可以为JSON中的多个元素自动化一个模板化工作。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="3b84" class="kw kx iq mo b gy mt mu l mv mw">echo $data | jr <strong class="mo ir">'{r|<br/> a := i.people[x].name;<br/> b := i.people[x].friends;<br/> c := concat(", ", b)<br/> r := sprintf("(name=%s, friends=%s)", [a,c])}'</strong><br/>["(name=chris, friends=alice, bob)","(name=elena, friends=dave)"]</span></pre><h2 id="74a6" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">高级用法#2:创建新函数(=规则)</h2><p id="b501" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">上面的例子很有用。但是我们可以走得更远。当我深入使用这些技术时，我不想在命令中重复输入相同的行。我想创建一个函数来避免重复。<br/>是我们创建一个<code class="fe ml mm mn mo b">.rego</code>文件的时间。</p><p id="02be" class="pw-post-body-paragraph ls lt iq lu b lv nj jr lx ly nk ju ma lf nl mc md lj nm mf mg ln nn mi mj mk ij bi translated">创建一个<code class="fe ml mm mn mo b">filter.rego</code>并写下这几行。最后6行与高级用法#1相同。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="d497" class="kw kx iq mo b gy mt mu l mv mw">package f<br/>import input as i<br/>format = {r |<br/>  a := i.people[x].name<br/>  b := i.people[x].friends<br/>  c := concat(", ", b)<br/>  r := sprintf("(name=%s, friends=%s)", [a,c])<br/>}</span></pre><p id="5d95" class="pw-post-body-paragraph ls lt iq lu b lv nj jr lx ly nk ju ma lf nl mc md lj nm mf mg ln nn mi mj mk ij bi translated">现在，我们可以运行以下命令。我们将得到与上一个没有内联策略编写的例子相同的结果。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="0b99" class="kw kx iq mo b gy mt mu l mv mw">echo $data | jr <strong class="mo ir">-d filter.rego</strong> <strong class="mo ir">'data.f.format'</strong><br/>["(name=chris, friends=alice, bob)","(name=elena, friends=dave)"]</span></pre><p id="b620" class="pw-post-body-paragraph ls lt iq lu b lv nj jr lx ly nk ju ma lf nl mc md lj nm mf mg ln nn mi mj mk ij bi translated">含义</p><ul class=""><li id="d794" class="no np iq lu b lv nj ly nk lf ok lj ol ln om mk nt nu nv nw bi translated"><code class="fe ml mm mn mo b">-d &lt;file&gt;</code> : <br/>这是<code class="fe ml mm mn mo b">opa eval</code>选项。它允许导入rego文件或json数据文件。这个选项可以重复。这些文件中的每个规则或数据都存储在<code class="fe ml mm mn mo b">data.&lt;label&gt;</code>中。对于rego文件，<code class="fe ml mm mn mo b">&lt;label&gt;</code>与rego文件的第一行相同。上面写的是<code class="fe ml mm mn mo b">package f</code>，所以我们可以把函数<code class="fe ml mm mn mo b">format</code>称为<code class="fe ml mm mn mo b">data.f.format</code>。</li></ul><p id="d75a" class="pw-post-body-paragraph ls lt iq lu b lv nj jr lx ly nk ju ma lf nl mc md lj nm mf mg ln nn mi mj mk ij bi translated">我们可以在一个文件中定义多个函数(OPA世界中的=“rules”)。<br/>创建rego文件后，我们可以重用现有的规则。</p><h1 id="84b7" class="mx kx iq bd ky my mz na lb nb nc nd le jw ne jx li jz nf ka lm kc ng kd lq nh bi translated">更进一步</h1><p id="c7cb" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">如果你有兴趣，这里有一些先进的技术。<br/><a class="ae kv" href="https://gist.github.com/onelittlenightmusic/dae68899fee9ec967e56cdfd49985d6c" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/onelittle night music/DAE 68899 fee 9 EC 967 e 56 cdfd 49985 d6c</a></p><h1 id="dc28" class="mx kx iq bd ky my mz na lb nb nc nd le jw ne jx li jz nf ka lm kc ng kd lq nh bi translated">摘要</h1><p id="0527" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated"><code class="fe ml mm mn mo b">jp</code>和<code class="fe ml mm mn mo b">jr</code>只是简单的命令别名，因此<code class="fe ml mm mn mo b">opa</code>可以用于任何JSON操作。原来，<code class="fe ml mm mn mo b">opa eval</code>命令在处理JSON对象上是如此强大。尤其是，<code class="fe ml mm mn mo b">--format=raw</code>选项使这种想法成为可能。<a class="ae kv" href="https://github.com/open-policy-agent/opa/pull/3207" rel="noopener ugc nofollow" target="_blank">这个增强版</a>是由<br/> <a class="ae kv" href="https://github.com/jaspervdj-luminal" rel="noopener ugc nofollow" target="_blank">贾斯珀·范德耶乌特</a>在两周前创作的，并由<a class="ae kv" href="https://github.com/srenatus" rel="noopener ugc nofollow" target="_blank">斯蒂芬·雷纳图斯</a>和<br/> <a class="ae kv" href="https://github.com/tsandall" rel="noopener ugc nofollow" target="_blank">托林·桑德尔</a>进行了讨论。不仅如此，<code class="fe ml mm mn mo b">opa</code>也在积极研发中。为了JSON的处理，我还写了<code class="fe ml mm mn mo b">opa</code>的<a class="ae kv" href="https://github.com/open-policy-agent/opa/pull/3240" rel="noopener ugc nofollow" target="_blank">一点点增强</a>。任何人都可以投稿<code class="fe ml mm mn mo b">opa</code>。<br/> OPA旨在成为微服务、Kubernetes、CI/CD管道、API网关中的通用策略实施(<a class="ae kv" href="https://www.openpolicyagent.org/docs/latest/" rel="noopener ugc nofollow" target="_blank">官方文件</a>)。多亏了它，OPA在JSON处理中有了这么多有用的函数。浏览这些文档是开始OPA的好方法。<br/>如果这篇文章对任何人的JSON操作的套路有所帮助，我很乐意。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/43d8ac361775cc5c6267b225e7d5fc00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*meQE-FKYIb_NDYVh"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">马库斯·斯皮斯克在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure></div></div>    
</body>
</html>