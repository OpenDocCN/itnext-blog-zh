<html>
<head>
<title>How to use implicit and explicit waits in Selenium.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Selenium中使用隐式和显式等待？</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-using-implicit-and-explicit-waits-in-selenium-d1ba53de5e15?source=collection_archive---------0-----------------------#2019-10-14">https://itnext.io/how-to-using-implicit-and-explicit-waits-in-selenium-d1ba53de5e15?source=collection_archive---------0-----------------------#2019-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a86e08768e785b17e5a86f592f0bfa78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2dSFFBGWqk5Du2SF1-LEJA.jpeg"/></div></div></figure><p id="a75c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在使用Selenium WebDriver时，定位器可以说是需要掌握的最重要的技能之一。根据locators，你需要掌握的不是WebDriver命令，而是理解和建模你的应用程序以获得正确的等待策略。如果你弄错了，你可能会在执行中有无意义的长时间延迟，或者由于等待的不确定性而有一个古怪的检查。</p><p id="a24b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Selenium Web驱动程序中有显式和隐式等待。</p><p id="6f7f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">等待是让自动任务执行经过一段时间后再继续下一步。您应该选择使用显式或隐式等待。</p><p id="5d99" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">警告</strong>:不要混合隐式和显式等待。这样做会导致不可预测的等待时间。例如，将隐式等待时间设置为10秒，显式等待时间设置为15秒，可能会导致20秒后超时。这可能会导致不可预测的等待时间。例如，设置10秒的隐式等待和15秒的显式等待会导致20秒的超时。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi kz"><img src="../Images/633149052e50f5b8c2a99d26151167ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ipRHqkUZNqjq7jtFmLmX3A.png"/></div></div></figure><p id="b80e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi le translated"><span class="l lf lg lh bm li lj lk ll lm di"> T </span> <strong class="kd iu"> hread。睡眠()</strong></p><p id="b0a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">特别是，这种<strong class="kd iu">睡眠</strong>模式是显式等待的一个例子。因此，这实际上并不是Selenium WebDriver的一个特性，但它是大多数编程语言中的一个常见特性。</p><p id="3426" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">线程。Sleep()做了你认为它会做的事情，它让线程休眠。所以当你的程序运行时，在大多数情况下，程序会被自动检查，它们运行在一个线程上。<br/>所以当我们调用线程时。我们指示我们的程序在一段时间内什么也不做，只是睡觉。<br/>测试中的应用程序要做什么并不重要，我们不在乎，我们的检查正在打盹！</p><pre class="la lb lc ld gt ln lo lp lq aw lr bi"><span id="845e" class="ls lt it lo b gy lu lv l lw lx">Thread.sleep(5000);</span></pre><p id="57c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">提供的值以毫秒为单位，因此这段代码将使检查休眠5秒钟。</p><p id="a035" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我不鼓励你使用Thread.sleep()，但是你必须意识到这一点。</p><p id="14cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">不过这些都不重要，不要用这个！为什么？</strong></p><p id="fee7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有3个主要原因:</p><p id="e45b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">1.动作执行得更快，其余时间在垃圾桶里。<br/> 2。这一行动花费了更长时间，测试也失败了。<br/> 3。我会放1 slip，因为这样更快更容易。这里不会痛…我甚至会把它包在一个方法里，命名为…稳定超时(Time)。之后，破窗规则将发挥作用，稳定超时的失误将充斥我们的生活。</p><p id="c2d1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi le translated"><span class="l lf lg lh bm li lj lk ll lm di">I</span>T21【implicit】等待— 全球。</p><p id="bb4d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">隐式(间接、隐藏)等待在搜索操作之外的代码中设置一次，在更改之前一直有效。默认值为0，表示不等待。隐式等待隐式地应用于所有后续的搜索操作(也就是说，隐式地，而不是在搜索方法中直接指定)。</p><pre class="la lb lc ld gt ln lo lp lq aw lr bi"><span id="0236" class="ls lt it lo b gy lu lv l lw lx"><em class="ly">/**<br/> * The class Waiter.<br/> */<br/></em><strong class="lo iu">public class </strong>Waiter {<br/><br/>    <em class="ly">/**<br/>     * The value for WebDriver.<br/>     */<br/>    </em><strong class="lo iu">private </strong>WebDriver <strong class="lo iu">driver</strong>;<br/><br/>    <em class="ly">/**<br/>     * The constant DELAY.<br/>     */<br/>    </em><strong class="lo iu">private static final int <em class="ly">DELAY </em></strong>= 10;<br/><br/>   <em class="ly">/**<br/>     * Method startDriver.<br/>     */<br/>    </em>@BeforeTest(alwaysRun = <strong class="lo iu">true</strong>)<br/>    <strong class="lo iu">public void </strong>startDriver() {<br/>        <strong class="lo iu">driver </strong>= <strong class="lo iu">new </strong>ChromeDriver();<br/>        <strong class="lo iu">driver</strong>.manage().timeouts().implicitlyWait(<strong class="lo iu"><em class="ly">DELAY</em></strong>, TimeUnit.<strong class="lo iu"><em class="ly">SECONDS</em></strong>);<br/>        <strong class="lo iu">driver</strong>.get(<strong class="lo iu">"example url"</strong>);<br/>    }<br/><br/>    <em class="ly">/**<br/>     * Method Example testing.<br/>     */<br/>    </em>@Test(description = <strong class="lo iu">"Will be executed until the element is found or until the allotted timeout value is 10 seconds."</strong>)<br/>    <strong class="lo iu">public void </strong>exampleTesting() {<br/>        <strong class="lo iu">driver</strong>.findElement(By.<em class="ly">id</em>(<strong class="lo iu">"bestLocator"</strong>));<br/>    }<br/><br/>    <em class="ly">/**<br/>     * Method stop driver.<br/>     */<br/>    </em>@AfterTest(alwaysRun = <strong class="lo iu">true</strong>)<br/>    <strong class="lo iu">public void </strong>stopDriver() {<br/>        <strong class="lo iu">if </strong>(<strong class="lo iu">driver </strong>!= <strong class="lo iu">null</strong>) {<br/>            <strong class="lo iu">driver</strong>.quit();<br/>        }<br/>    }</span></pre><p id="55dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本例中，<strong class="kd iu"> driver.findElement() </strong>将被执行，直到找到该元素，或者直到分配的超时值为10秒。</p><p id="def8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi le translated"><span class="l lf lg lh bm li lj lk ll lm di"> E </span>特别是，即使是“睡眠”模式(等待和什么都不做)也是显式等待的一个例子，但是不鼓励使用它。</p><p id="a0b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实际上，我们建议您将Web驱动程序等待与减少等待的Expected Conditions类的方法结合使用。如果元素在Web驱动程序等待初始化期间指定的时间之前出现，Selenium将不会等待，而是继续执行测试。</p><pre class="la lb lc ld gt ln lo lp lq aw lr bi"><span id="cab1" class="ls lt it lo b gy lu lv l lw lx"><strong class="lo iu">public class </strong>Waiter {</span><span id="0d7f" class="ls lt it lo b gy lz lv l lw lx">    <em class="ly">/**<br/>     * The value for WebDriver.<br/>     */<br/>    </em><strong class="lo iu">private </strong>WebDriver <strong class="lo iu">driver</strong>;</span><span id="894b" class="ls lt it lo b gy lz lv l lw lx">    <em class="ly">/**<br/>     * The value for WebDriverWait with initialization.<br/>     */<br/>    </em><strong class="lo iu">private final </strong>Wait&lt;WebDriver&gt; <strong class="lo iu">webDriverWait </strong>= <strong class="lo iu">new </strong>WebDriverWait(<strong class="lo iu">driver</strong>, 5, 1000);</span><span id="4d71" class="ls lt it lo b gy lz lv l lw lx">}</span></pre><p id="1fef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> 5 </strong> —第二个参数以秒为单位指定超时时间。</p><p id="15d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> 1000 </strong> —第三个参数指定在下一次调用之前等待的时间(以毫秒为单位)，以检查元素是否存在(默认为500)。</p><p id="c1ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，您还可以修改等待调用，并在等待失败时显示一条消息。</p><pre class="la lb lc ld gt ln lo lp lq aw lr bi"><span id="c648" class="ls lt it lo b gy lu lv l lw lx"><strong class="lo iu">public class </strong>Waiter {</span><span id="424c" class="ls lt it lo b gy lz lv l lw lx">    <em class="ly">/**<br/>     * The value for WebDriver.<br/>     */<br/>    </em><strong class="lo iu">private </strong>WebDriver <strong class="lo iu">driver</strong>;</span><span id="4c1d" class="ls lt it lo b gy lz lv l lw lx">    <em class="ly">/**<br/>     * The value for WebDriverWait with initialization.<br/>     */<br/>    </em><strong class="lo iu">private final </strong>Wait&lt;WebDriver&gt; <strong class="lo iu">webDriverWait </strong>= <strong class="lo iu">new </strong>WebDriverWait(<strong class="lo iu">driver</strong>, 5).withMessage(<strong class="lo iu">"Element was not found"</strong>);<br/></span><span id="5bf1" class="ls lt it lo b gy lz lv l lw lx">}</span></pre><p id="38ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您还可以使用另一个选项来创建等待对象:</p><pre class="la lb lc ld gt ln lo lp lq aw lr bi"><span id="9816" class="ls lt it lo b gy lu lv l lw lx"><em class="ly">/**<br/> * The class Waiter.<br/> */<br/></em><strong class="lo iu">public class </strong>Waiter {</span><span id="9120" class="ls lt it lo b gy lz lv l lw lx">    <em class="ly">/**<br/>     * The value for WebDriver.<br/>     */<br/>    </em><strong class="lo iu">private </strong>WebDriver <strong class="lo iu">driver</strong>;</span><span id="e65e" class="ls lt it lo b gy lz lv l lw lx">    <em class="ly">/**<br/>     * The value for WebDriverWait with initialization.<br/>     */<br/>    </em><strong class="lo iu">private final </strong>Wait&lt;WebDriver&gt; <strong class="lo iu">wait </strong>= <strong class="lo iu">new </strong>FluentWait&lt;WebDriver&gt;(<strong class="lo iu">driver</strong>);<br/>}</span></pre><p id="028c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi le translated">在搜索过程中，WebDriver定期在浏览器中轮询DOM模型中的元素。有许多例外情况:</p><ul class=""><li id="12c2" class="ma mb it kd b ke kf ki kj km mc kq md ku me ky mf mg mh mi bi translated">StaleElementReferenceException—如果在搜索时DOM中有一个项目，但是过了一段时间，在调用它时，DOM已经更改。</li><li id="d05c" class="ma mb it kd b ke mj ki mk km ml kq mm ku mn ky mf mg mh mi bi translated">NoSuchElementException —如果调用时该项不在DOM中。</li><li id="a3c8" class="ma mb it kd b ke mj ki mk km ml kq mm ku mn ky mf mg mh mi bi translated">ElementNotVisibleException如果在DOM中找到该项，但在页面上不可见。</li><li id="b3b8" class="ma mb it kd b ke mj ki mk km ml kq mm ku mn ky mf mg mh mi bi translated">MoveTargetOutOfBoundsException-如果项目已更改坐标。</li></ul><p id="4e8d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了避免这些异常，必须将异常的描述传递给ignition方法:</p><pre class="la lb lc ld gt ln lo lp lq aw lr bi"><span id="764c" class="ls lt it lo b gy lu lv l lw lx"><strong class="lo iu">final </strong>Wait&lt;WebDriver&gt; <strong class="lo iu">wait </strong>= <strong class="lo iu">new </strong>WebDriverWait(driver, 5).ignoring(StaleElementReferenceException.<strong class="lo iu">class</strong>, ElementNotVisibleException.<strong class="lo iu">class</strong>);</span></pre><p id="37e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">预期条件</strong>包含默认实现的预期规则列表:</p><ul class=""><li id="a67b" class="ma mb it kd b ke kf ki kj km mc kq md ku me ky mf mg mh mi bi translated">可见性元素定位(通过定位器)</li><li id="cc08" class="ma mb it kd b ke mj ki mk km ml kq mm ku mn ky mf mg mh mi bi translated">(WebElement元素)的可见性</li><li id="fb70" class="ma mb it kd b ke mj ki mk km ml kq mm ku mn ky mf mg mh mi bi translated">textToBePresentInElement(按定位器，字符串文本)</li><li id="a014" class="ma mb it kd b ke mj ki mk km ml kq mm ku mn ky mf mg mh mi bi translated">titleContains(字符串标题)</li><li id="5810" class="ma mb it kd b ke mj ki mk km ml kq mm ku mn ky mf mg mh mi bi translated">presenceOfElementLocated(按定位器)</li><li id="4af5" class="ma mb it kd b ke mj ki mk km ml kq mm ku mn ky mf mg mh mi bi translated">presenceOfAllElementsLocatedBy(按定位器)</li><li id="5731" class="ma mb it kd b ke mj ki mk km ml kq mm ku mn ky mf mg mh mi bi translated">不可见元素定位(通过定位器)</li><li id="230d" class="ma mb it kd b ke mj ki mk km ml kq mm ku mn ky mf mg mh mi bi translated">invisibilityOfElementWithText(按定位器，字符串文本)</li><li id="ffb0" class="ma mb it kd b ke mj ki mk km ml kq mm ku mn ky mf mg mh mi bi translated">elementToBeClickable(按定位器)</li><li id="8604" class="ma mb it kd b ke mj ki mk km ml kq mm ku mn ky mf mg mh mi bi translated">stalensesof(web element元素)</li><li id="3e10" class="ma mb it kd b ke mj ki mk km ml kq mm ku mn ky mf mg mh mi bi translated">alertIsPresent()</li></ul><p id="5bb0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有功能的完整描述可在<a class="ae mo" href="https://seleniumhq.github.io/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html" rel="noopener ugc nofollow" target="_blank">链接</a>获得</p><pre class="la lb lc ld gt ln lo lp lq aw lr bi"><span id="946e" class="ls lt it lo b gy lu lv l lw lx">wait.until(ExpectedConditions.presenceOfElementLocated(By.id(<strong class="lo iu">"smth"</strong>)));</span></pre><p id="6696" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的例子中，我们期望元素出现在id定位器等于<strong class="kd iu"> smth </strong>的<strong class="kd iu"> DOM </strong>模型中。</p><p id="a951" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">等待项目的另一种方法可以如下实现:</p><pre class="la lb lc ld gt ln lo lp lq aw lr bi"><span id="18e8" class="ls lt it lo b gy lu lv l lw lx"><em class="ly">/**<br/> * The class WaitCondition.<br/> */<br/></em><strong class="lo iu">public class </strong>WaitCondition {<br/><br/>    <em class="ly">/**<br/>     * The constant DELAY. This is delay for WebDriverWait is seconds.<br/>     */<br/>    </em><strong class="lo iu">private static final int <em class="ly">DELAY </em></strong>= 5;<br/><br/>    <em class="ly">/**<br/>     * The private value webDriverWait.<br/>     */<br/>    </em><strong class="lo iu">private </strong>WebDriverWait <strong class="lo iu">webDriverWait</strong>;</span><span id="7a37" class="ls lt it lo b gy lz lv l lw lx"><em class="ly">    /**<br/>     * The value for WebDriver.<br/>     */<br/>    </em><strong class="lo iu">private </strong>WebDriver <strong class="lo iu">driver</strong>;</span><span id="9c72" class="ls lt it lo b gy lz lv l lw lx">    <em class="ly">/**<br/>     * The constructor.<br/>     */<br/>    </em><strong class="lo iu">public </strong>WaitCondition() {<br/>        <strong class="lo iu">webDriverWait </strong>= <strong class="lo iu">new </strong>WebDriverWait(driver, <strong class="lo iu"><em class="ly">DELAY</em></strong>);<br/>    }<br/><br/>    <em class="ly">/**<br/>     * Wait for visibility of element located by web element.<br/>     *<br/>     * </em><strong class="lo iu"><em class="ly">@param locator </em></strong><em class="ly">the locator.<br/>     * </em><strong class="lo iu"><em class="ly">@return </em></strong><em class="ly">the web element.<br/>     */<br/>    </em><strong class="lo iu">public </strong>WebElement waitForVisibilityOfElementLocatedBy(<strong class="lo iu">final </strong>By locator) {<br/>        <strong class="lo iu">return webDriverWait</strong>.until(ExpectedConditions.<em class="ly">visibilityOfElementLocated</em>(locator));<br/>    }</span></pre><p id="39b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">并且可以被调用如下:</p><pre class="la lb lc ld gt ln lo lp lq aw lr bi"><span id="a9f4" class="ls lt it lo b gy lu lv l lw lx"><em class="ly">/**<br/> * The constant SELECT_WEEKEND. This is css selector for ui automation script.<br/> */<br/></em><strong class="lo iu">private static final </strong>By <strong class="lo iu"><em class="ly">SELECT_WEEKEND </em></strong>= By.<em class="ly">cssSelector</em>(<strong class="lo iu">"td[class='calendarWeekend']"</strong>);</span><span id="2f25" class="ls lt it lo b gy lz lv l lw lx"><em class="ly"><br/>/**<br/> * Select weekend current convert page.<br/> *<br/> * </em><strong class="lo iu"><em class="ly">@return </em></strong><em class="ly">the current convert page.<br/> */<br/></em><strong class="lo iu">public </strong>CurrentConvertPage selectWeekend() {<br/><br/>    <strong class="lo iu">final </strong>WaitCondition waitCondition = <strong class="lo iu">new </strong>WaitCondition();<br/>    waitCondition.waitForVisibilityOfElementLocatedBy(<strong class="lo iu"><em class="ly">SELECT_WEEKEND</em></strong>).click();<br/><br/>    <strong class="lo iu">return this</strong>;<br/>}</span></pre><p id="d493" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">负面状态可以被<strong class="kd iu">而不是</strong>捕捉到:</p><pre class="la lb lc ld gt ln lo lp lq aw lr bi"><span id="c36b" class="ls lt it lo b gy lu lv l lw lx"><strong class="lo iu">public boolean </strong>waitForNotPresenceOfElementLocated(By locator){<br/>    <strong class="lo iu">return webDriverWait</strong>.until(ExpectedConditions.<em class="ly">not</em>(ExpectedConditions.<em class="ly">presenceOfElementLocated</em>(locator)));<br/>}</span></pre><p id="ec4d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi le translated">对于web应用程序测试自动化中常见的情况，ebDriver API有非常丰富的不同种类的期望。为了简化等待时间值的配置，它们通常在启动参数中执行，或者存储在属性文件中。</p><p id="7684" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在您的功能测试中使用这些例子来提高它们的性能和稳定性。</p><p id="ab84" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi le translated"><span class="l lf lg lh bm li lj lk ll lm di">最后，我想给你举几个有用的例子:</span></p><p id="0d29" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有时我们需要等待页面加载。通过等待文档状态来等待页面加载。</p><ol class=""><li id="4b19" class="ma mb it kd b ke kf ki kj km mc kq md ku me ky mp mg mh mi bi translated">使用Java和AssertEquals实现。</li></ol><pre class="la lb lc ld gt ln lo lp lq aw lr bi"><span id="be7e" class="ls lt it lo b gy lu lv l lw lx"><em class="ly">/**<br/> * The class Waiter.<br/> */<br/></em><strong class="lo iu">public class </strong>Waiter {<br/><br/>    <em class="ly">/**<br/>     * The value for webDriver.<br/>     */<br/>    </em>WebDriver <strong class="lo iu">driver</strong>;<br/><br/>    <em class="ly">/**<br/>     * Method checkThatPageIsCompletelyLoaded.<br/>     */<br/>    </em><strong class="lo iu">public void </strong>checkThatPageIsCompletelyLoaded() {<br/><br/>        JavascriptExecutor javascriptExecutor = (JavascriptExecutor) <strong class="lo iu">driver</strong>;<br/>        <em class="ly">assertEquals</em>(<strong class="lo iu">"complete"</strong>, javascriptExecutor.executeScript(<strong class="lo iu">"return document.readyState"</strong>));<br/>    }<br/><br/>}</span></pre><p id="21ac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2)使用WebDriver实现。</p><p id="5d9f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Webdriver中有一个用于此目的的方法pageLoadTimeout。</p><p id="15b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它的用法示例如下:</p><pre class="la lb lc ld gt ln lo lp lq aw lr bi"><span id="bce0" class="ls lt it lo b gy lu lv l lw lx"><em class="ly">/**<br/> * The class Waiter.<br/> */<br/></em><strong class="lo iu">public class </strong>Waiter {<br/><br/>    <em class="ly">/**<br/>     * The private valuer driver.<br/>     */<br/>    </em><strong class="lo iu">private </strong>WebDriver <strong class="lo iu">driver</strong>;<br/><br/>    <em class="ly">/**<br/>     * The constant DELAY.<br/>     */<br/>    </em><strong class="lo iu">private static final long <em class="ly">DELAY </em></strong>= 60;<br/><br/>    <em class="ly">/**<br/>     * Method start.<br/>     * This method wait page load at 60 second.<br/>     * If the DOM does not load within 60 seconds, you will get a TimeoutException.<br/>     */<br/>    </em>@BeforeTest<br/>    <strong class="lo iu">public void </strong>start() {<br/>        <strong class="lo iu">driver</strong>.manage().timeouts().pageLoadTimeout(<strong class="lo iu"><em class="ly">DELAY</em></strong>, TimeUnit.<strong class="lo iu"><em class="ly">SECONDS</em></strong>);<br/>    }<br/><br/><br/>}</span></pre><p id="c58e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">WebDriver API提供了在网页上设置JavaScript执行预期的能力。</p><p id="aad6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它的用法示例如下:</p><pre class="la lb lc ld gt ln lo lp lq aw lr bi"><span id="8b51" class="ls lt it lo b gy lu lv l lw lx"><em class="ly">/**<br/> * The class Waiter.<br/> */<br/></em><strong class="lo iu">public class </strong>Waiter {<br/><br/>    <em class="ly">/**<br/>     * The value for webDriver.<br/>     */<br/>    </em>WebDriver <strong class="lo iu">driver</strong>;<br/><br/>    <em class="ly">/**<br/>     * The constant DELAY.<br/>     */<br/>    </em><strong class="lo iu">private static final long <em class="ly">DELAY </em></strong>= 30;<br/><br/>    <em class="ly">/**<br/>     * Method Start. This method sets the query completion timeout limit for executeAsyncScript.<br/>     */<br/>    </em><strong class="lo iu">public void </strong>start() {<br/>        <strong class="lo iu">driver</strong>.manage().timeouts().setScriptTimeout(<strong class="lo iu"><em class="ly">DELAY</em></strong>, TimeUnit.<strong class="lo iu"><em class="ly">SECONDS</em></strong>);<br/>    }<br/><br/>}</span></pre><p id="66c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，项目中的所有等待者都可以用作一个<strong class="kd iu">枚举</strong>:</p><pre class="la lb lc ld gt ln lo lp lq aw lr bi"><span id="2dbb" class="ls lt it lo b gy lu lv l lw lx"><em class="ly">/**<br/> * The enum Wait condition.<br/> */<br/></em>@RequiredArgsConstructor<br/><strong class="lo iu">public enum </strong>WaitCondition {<br/><br/>    <em class="ly">/**<br/>     * Visible wait condition.<br/>     */<br/>    </em><strong class="lo iu"><em class="ly">visible</em></strong>(ExpectedConditions::<em class="ly">visibilityOfElementLocated</em>),<br/>    <br/>     <em class="ly">/**<br/>     * Enabled wait condition.<br/>     */<br/>    </em><strong class="lo iu"><em class="ly">enabled</em></strong>((Function&lt;By, ExpectedCondition&lt;?&gt;&gt;) ExpectedConditions::<em class="ly">elementToBeClickable</em>),<br/>     <br/>     <em class="ly">/**<br/>     * Present wait condition.<br/>     */<br/>    </em><strong class="lo iu"><em class="ly">present</em></strong>(ExpectedConditions::<em class="ly">presenceOfElementLocated</em>),<br/>    <br/>     <em class="ly">/**<br/>     * All visible wait condition.<br/>     */<br/>    </em><strong class="lo iu"><em class="ly">allVisible</em></strong>(ExpectedConditions::<em class="ly">visibilityOfAllElementsLocatedBy</em>),<br/>    <br/>     <em class="ly">/**<br/>     * All present wait condition.<br/>     */<br/>    </em><strong class="lo iu"><em class="ly">allPresent</em></strong>(ExpectedConditions::<em class="ly">presenceOfAllElementsLocatedBy</em>),<br/><br/>    <em class="ly">/**<br/>     * Value to be wait condition.<br/>     */<br/>    </em><strong class="lo iu"><em class="ly">valueToBe</em></strong>((BiFunction&lt;By, String, ExpectedCondition&lt;?&gt;&gt;) ExpectedConditions::<em class="ly">textToBe</em>);<br/><br/><br/>    <strong class="lo iu">private </strong>BiFunction&lt;?, ?, ExpectedCondition&lt;?&gt;&gt; <strong class="lo iu">type</strong>;<br/><br/>    &lt;T, V&gt; WaitCondition(<strong class="lo iu">final </strong>Function&lt;T, ExpectedCondition&lt;?&gt;&gt; type) {<br/>        <strong class="lo iu">this</strong>((T arg1, V arg2) -&gt; type.apply(arg1));<br/>    }<br/><br/>    <em class="ly">/**<br/>     * Method getType.<br/>     *<br/>     * </em><strong class="lo iu"><em class="ly">@param &lt;T&gt; </em></strong><em class="ly">the type parameter.<br/>     * </em><strong class="lo iu"><em class="ly">@param &lt;V&gt; </em></strong><em class="ly">the type parameter.<br/>     * </em><strong class="lo iu"><em class="ly">@param &lt;R&gt; </em></strong><em class="ly">the type parameter.<br/>     * </em><strong class="lo iu"><em class="ly">@return </em></strong><em class="ly">the type.<br/>     */<br/>    </em>@SuppressWarnings(<strong class="lo iu">"unchecked"</strong>)<br/>    <strong class="lo iu">public </strong>&lt;T, V, R&gt; BiFunction&lt;T, V, R&gt; getType() {<br/>        <strong class="lo iu">return </strong>(BiFunction&lt;T, V, R&gt;) <strong class="lo iu">type</strong>;<br/>    }<br/>}</span></pre><p id="a9f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">并且可以被调用如下:</p><pre class="la lb lc ld gt ln lo lp lq aw lr bi"><span id="5f2b" class="ls lt it lo b gy lu lv l lw lx"><strong class="lo iu">public void </strong>click(<strong class="lo iu">final </strong>By locator) {<br/>    click(locator, <strong class="lo iu"><em class="ly">visible</em></strong>);<br/>}</span></pre></div></div>    
</body>
</html>