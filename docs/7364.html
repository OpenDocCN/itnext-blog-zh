<html>
<head>
<title>JSON Object Signature and Encryption (JWS, JWE, JWT) with the Inverno Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Inverno框架的JSON对象签名和加密(JWS、JWE、JWT)</h1>
<blockquote>原文：<a href="https://itnext.io/json-object-signature-and-encryption-jws-jwe-jwt-with-inverno-framework-5e6900091504?source=collection_archive---------3-----------------------#2022-09-01">https://itnext.io/json-object-signature-and-encryption-jws-jwe-jwt-with-inverno-framework-5e6900091504?source=collection_archive---------3-----------------------#2022-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/24315f79df29ba8033e55c01664acac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ndgpDF1WEYqGgMJZsbMFQ.png"/></div></div></figure><p id="925a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">致力于安全性的<a class="ae kw" href="https://inverno.io" rel="noopener ugc nofollow" target="_blank"> Inverno Framework </a>的最新版本包括JSON对象签名和加密(JOSE)规范的完整Java实现，包括JSON Web Key ( <a class="ae kw" href="https://datatracker.ietf.org/doc/html/rfc7517" rel="noopener ugc nofollow" target="_blank"> JWK </a>)、JSON Web Signature ( <a class="ae kw" href="https://datatracker.ietf.org/doc/html/rfc7515" rel="noopener ugc nofollow" target="_blank"> JWS </a>)、JSON Web Encryption ( <a class="ae kw" href="https://datatracker.ietf.org/doc/html/rfc7516" rel="noopener ugc nofollow" target="_blank"> JWE </a>)和JSON Web Token ( <a class="ae kw" href="https://datatracker.ietf.org/doc/html/rfc7519" rel="noopener ugc nofollow" target="_blank"> JWT </a>)。</p><p id="bd05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JOSE对象主要用于传送数字签名(完整性)和/或加密(隐私)的内容。他们对实现基于JSON Web令牌的简单分布式身份验证越来越感兴趣，其中包含一组不能伪造的声明的数字签名令牌用于对资源服务器的请求进行身份验证。这种技术被广泛记录并在多个标准中使用，如<a class="ae kw" href="https://oauth.net/2/" rel="noopener ugc nofollow" target="_blank"> OAuth2 </a>和<a class="ae kw" href="https://openid.net/connect/" rel="noopener ugc nofollow" target="_blank"> OpenID Connect </a>。</p><p id="6106" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Inverno security <a class="ae kw" href="https://search.maven.org/artifact/io.inverno.mod/inverno-security-jose" rel="noopener ugc nofollow" target="_blank"> JOSE模块</a>允许创建、验证或解密遵循上述规范的数字保护内容。它是一个Inverno模块，可以很容易地集成到一个Inverno应用程序中，但由于Inverno框架的非普适性，它也可以用作任何Java应用程序中的独立库。</p><p id="aa74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将概述JOSE模块中公开的四个服务，分别用于操作JSON Web密钥(JWK)、JSON Web签名(JWS)对象、JSON Web加密(JWE)对象和JSON Web令牌(JWT)。该模块相当完整，并提供了多种功能，如果您想深入了解，请参考<a class="ae kw" href="https://inverno.io/docs/release/reference/html/index.html#json-object-signing-and-encryption" rel="noopener ugc nofollow" target="_blank"> Inverno框架参考文档</a>。</p><h1 id="fd5f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">初始化何塞模块</h1><p id="e72b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在Inverno应用程序中，声明对模块的依赖就足以在需要的地方注入JOSE服务。在常规的Java应用程序中，模块必须像任何Java对象一样进行初始化。</p><p id="f399" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下代码显示了如何获得标准的<code class="fe ma mb mc md b">Jose</code>模块实例:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="8ba6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，JSON和文本转换器是由Inverno <a class="ae kw" href="https://search.maven.org/artifact/io.inverno.mod/inverno-boot" rel="noopener ugc nofollow" target="_blank"> boot </a>模块提供的，它们用于根据内容类型自动转换JSON和文本有效载荷。使用媒体类型转换器初始化模块不是强制性的，因为在创建或解析JOSE对象时也可以指定特定的编码器或解码器，但是强烈建议这样做，因为这样可以大大简化有效载荷的编码和解码。</p><p id="8188" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样得到的<code class="fe ma mb mc md b">Jose</code>实例暴露了<code class="fe ma mb mc md b">JWKService</code>、<code class="fe ma mb mc md b">JWSService</code>、<code class="fe ma mb mc md b">JWEService</code>和<code class="fe ma mb mc md b">JWTService</code>:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="f746" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些服务可以用来操作JOSE对象。</p><h1 id="204a" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">JWK服务</h1><p id="9305" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">JWK服务用于管理由<a class="ae kw" href="https://datatracker.ietf.org/doc/html/rfc7517" rel="noopener ugc nofollow" target="_blank"> RFC7517 </a>和<a class="ae kw" href="https://datatracker.ietf.org/doc/html/rfc7518" rel="noopener ugc nofollow" target="_blank"> RFC7518 </a>指定的加密密钥，它可以从JWK密钥库、Java密钥库、JWK集合URL或原始密钥值加载密钥。它还能够为JOSE规范中定义的各种算法生成密钥。</p><p id="15f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下示例显示了如何生成简单的对称密钥:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="578d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以使用一个<code class="fe ma mb mc md b">ObjectMapper</code>将密钥序列化为JSON，得到下面的JSON对象:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="fd4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样获得的JWK然后可以用于使用JWS、JWE或JWT服务来签名或加密JOSE对象。</p><p id="6420" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JWK服务目前支持对称、RSA、椭圆曲线、Edward曲线和PBES2密钥类型。通过在初始化JOSE模块时提供定制的JWK工厂实现，可以添加对额外的或定制的键类型的支持。</p><p id="7418" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下示例显示了如何从原始密钥值加载RSA密钥:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="50d8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">JWS服务</h1><p id="62fc" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">现在我们有了一个密钥，我们可以创建和读取JSON Web Signature (JWS)对象，这些对象提供由<a class="ae kw" href="https://datatracker.ietf.org/doc/html/rfc7515" rel="noopener ugc nofollow" target="_blank"> RFC7515 </a>定义的完整性保护。</p><p id="3b46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下示例显示了如何使用<code class="fe ma mb mc md b">HS512</code>算法创建一个简单的JSON Web签名，并使用JWS紧凑符号对其进行序列化:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="0104" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">内容类型在JOSE头中指定，这允许JWS服务确定使用哪个转换器来编码有效载荷。用于对JWS进行数字签名的JWK是显式指定的，但是当密钥存储在模块的JWK存储或Java密钥存储中时，它也可以通过id来解析。</p><p id="99e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，可以将压缩的JWS传送给接收者，接收者可以使用相同的密钥来验证数字签名。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="54a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我使用了对称算法，这意味着双方必须知道密钥，非对称签名算法，如RSA或椭圆曲线算法显然也可以使用。</p><p id="c4a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该规范还规定了高度不安全的<code class="fe ma mb mc md b">NONE</code>算法。必须特别注意防止应用程序用这种算法接受JWS对象，因为JOSE模块遵循规范，在这种情况下不会产生任何错误。</p><h1 id="1256" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">JWE服务</h1><p id="5dd0" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">JSON Web Encryption (JWE)对象除了完整性之外还提供机密性，如<a class="ae kw" href="https://datatracker.ietf.org/doc/html/rfc7516" rel="noopener ugc nofollow" target="_blank"> RFC7516 </a>所定义的。它通常使用两种算法:一种是加密、包装或导出生成的内容加密密钥(CEK ),另一种是使用CEK实际签署和加密JWE。</p><p id="300d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下示例显示了如何使用<code class="fe ma mb mc md b">RSA-OAEP</code>密钥管理算法和<code class="fe ma mb mc md b">A256GCM</code>加密算法创建JSON Web加密对象，并使用JWE紧凑符号对其进行序列化:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="74de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，在JOSE报头中没有指定内容类型，但是当构建JWE以选择用于编码有效载荷的转换器时，可以明确地指定特定的编码器来绕过媒体类型转换器。至于JWS，用于加密生成的内容加密密钥的JWK是显式指定的，但是当密钥存储在模块的JWK存储或Java密钥存储中时，它也可以通过id来解析。</p><p id="9a94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，可以将紧凑的JWE传送给接收方，接收方可以使用私钥来验证和解密内容:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="abff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我使用了一个非对称密钥管理算法，因此只需要公钥来创建只能用私钥解密的JWE。</p><h1 id="10b7" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">JWT服务</h1><p id="3698" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">根据RFC7519 的定义，JSON Web令牌只不过是一个JWS或JWE，其有效载荷是JWT声明集。它提供了一组标准声明和自定义声明，可用于传递有效性信息:过期时间，而不是之前，受众…以及身份信息:发布者，主题…</p><p id="f2b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JSON Web令牌被广泛用于在无状态分布式环境中实现认证，其通过使用可信密钥来验证只能由可信机构生成的数字签名，并验证限制令牌有效性的JWT声明集，以防止基于被盗令牌的攻击。</p><p id="1b51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的例子显示了如何创建一个由<code class="fe ma mb mc md b">joe</code>发布的JSON Web令牌，并在一天内作为JWS对象到期:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="7a74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，可以将紧凑的JWT传送给接收者，该接收者可以使用可信密钥来验证数字签名，并验证JWT声明集:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="940a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的代码中，JWS签名在读取JWT契约表示时被验证，JWT声明集在使用前被验证。默认情况下，过期时间是有效的，我们在发行者上显式添加了一个必须是<code class="fe ma mb mc md b">bob</code>的检查，当JWT无效时，会抛出一个错误。</p><h1 id="2e0a" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">摘要</h1><p id="cd33" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">本文展示了如何使用Inverno security JOSE模块来操作JOSE对象，尤其是JSON Web令牌。该模块完全集成在Inverno框架中，特别用于基于令牌的身份验证，但是您也可以在任何Java应用程序中使用它，例如Spring Boot应用程序，对于该应用程序，很容易将上述服务作为可注入的beans公开。</p><p id="54fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该库相当完整，并严格实现了以下规范:</p><ul class=""><li id="188c" class="mk ml iq ka b kb kc kf kg kj mm kn mn kr mo kv mp mq mr ms bi translated"><a class="ae kw" href="https://datatracker.ietf.org/doc/html/rfc7515" rel="noopener ugc nofollow" target="_blank"> RFC 7515 </a> JSON网络签名(JWS)</li><li id="8ffb" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated"><a class="ae kw" href="https://datatracker.ietf.org/doc/html/rfc7516" rel="noopener ugc nofollow" target="_blank"> RFC 7516 </a> JSON网页加密(JWE)</li><li id="c0a9" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated"><a class="ae kw" href="https://datatracker.ietf.org/doc/html/rfc7517" rel="noopener ugc nofollow" target="_blank"> RFC 7517 </a> JSON Web Key (JWK)</li><li id="c1c1" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">JSON网络算法(JWA)</li><li id="f5ba" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">JSON网络令牌(JWT)</li><li id="b115" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated"><a class="ae kw" href="https://datatracker.ietf.org/doc/html/rfc7638" rel="noopener ugc nofollow" target="_blank"> RFC 7638 </a> JSON Web密钥(JWK)指纹</li><li id="1a92" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated"><a class="ae kw" href="https://datatracker.ietf.org/doc/html/rfc7797" rel="noopener ugc nofollow" target="_blank"> RFC 7797 </a> JSON Web签名(JWS)未编码有效负载选项</li><li id="19f9" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated"><a class="ae kw" href="https://datatracker.ietf.org/doc/html/rfc8037" rel="noopener ugc nofollow" target="_blank"> RFC 8037 </a> CFRG椭圆曲线Diffie-Hellman (ECDH)和JSON对象签名和加密(JOSE)中的签名</li><li id="bbb1" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated"><a class="ae kw" href="https://datatracker.ietf.org/doc/html/rfc8812" rel="noopener ugc nofollow" target="_blank"> RFC 8812 </a>针对Web认证(WebAuthn)算法的CBOR对象签名和加密(COSE)以及JSON对象签名和加密(JOSE)注册</li></ul><p id="3b9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它还提供了一些有趣的功能，例如:</p><ul class=""><li id="d479" class="mk ml iq ka b kb kc kf kg kj mm kn mn kr mo kv mp mq mr ms bi translated">使用媒体类型转换器的自动有效载荷编码和解码</li><li id="5d4f" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">通过来自JWK存储、Java密钥存储或JWK集合URL的密钥id或指纹自动解析密钥</li><li id="2d69" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">证书路径验证</li></ul><p id="eea1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它是可扩展的，允许实现对附加密钥类型和算法的支持。还可以定义特定的验证器来验证JWT声明集。</p><p id="cec5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请参考<a class="ae kw" href="https://inverno.io/docs/release/reference/html/index.html#json-object-signing-and-encryption" rel="noopener ugc nofollow" target="_blank"> Inverno框架参考文档</a>以全面了解如何在您的应用中使用该模块。</p></div></div>    
</body>
</html>