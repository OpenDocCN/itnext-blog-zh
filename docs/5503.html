<html>
<head>
<title>Using Rook On A K3s Cluster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在K3s集群上使用车</h1>
<blockquote>原文：<a href="https://itnext.io/using-rook-on-a-k3s-cluster-8a97a75ba25e?source=collection_archive---------0-----------------------#2021-03-19">https://itnext.io/using-rook-on-a-k3s-cluster-8a97a75ba25e?source=collection_archive---------0-----------------------#2021-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8a78" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在本地机器上发现和玩车的简单方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/69f1f54898635f09d6a094e689d9c049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9v95gn_opSu8U_HISAtCsw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="/s/photos/storage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@jannerboy62?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">尼克·费因斯</a>拍摄</figcaption></figure><p id="7533" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/deploy-a-ceph-cluster-on-kubernetes-with-rook-d75a20c3f5b1">的上一篇文章</a>中，我们展示了<a class="ae ky" href="https://rook.io" rel="noopener ugc nofollow" target="_blank">车</a>，并使用它建立了一个HA Ceph集群。在这篇新文章中，我们将在单节点<a class="ae ky" href="https://k3s.io" rel="noopener ugc nofollow" target="_blank"> K3s </a>集群上安装Rook，因为这是开始这个伟大的<a class="ae ky" href="https://cncf.io" rel="noopener ugc nofollow" target="_blank"> CNCF </a>项目的好方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="6cfa" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated"><strong class="ak">k3s集群的设置</strong></h2><p id="1aac" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">出于本文的目的，我们将使用在<a class="ae ky" href="https://virtualbox.org" rel="noopener ugc nofollow" target="_blank"> VirtualBox </a>上通过<a class="ae ky" href="https://vagrantup.com" rel="noopener ugc nofollow" target="_blank">vagger</a>提供的本地虚拟机。下面的流浪者文件定义了:</p><ul class=""><li id="e402" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">将要创建的虚拟机的配置:使用的Linux发行版、其IP地址(192.168.33.10)、RAM的数量(2G)、添加一个容量为10G的磁盘</li><li id="a3a8" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">设置K3s并恢复相关的kubeconfig文件</li></ul><p id="2653" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">🔥重要的是将一个未格式化的磁盘(原始设备)连接到将要创建的虚拟机。下面我们将告诉Rook使用这个磁盘来保存Ceph集群的数据。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="0c83" class="mc md it np b gy nt nu l nv nw"># -*- mode: ruby -*-<br/># vi: set ft=ruby :<br/><br/>Vagrant.configure("2") do |config|<br/>  config.vm.box = "hashicorp/bionic64"<br/>  config.vm.network "private_network", ip: "192.168.33.10"<br/>  config.vm.disk :disk, size: "10GB", name: "osd"<br/>  config.vm.provider "virtualbox" do |vb|<br/>    vb.memory = "2048"<br/>  end<br/>  config.vm.provision "shell", inline: &lt;&lt;-SHELL<br/>    curl https://get.k3s.io | sh<br/>    sudo cp /etc/rancher/k3s/k3s.yaml /vagrant/kubeconfig.k3s<br/>    sed -i "s/127.0.0.1/192.168.33.10/" /vagrant/kubeconfig.k3s<br/>  SHELL<br/>end</span></pre><p id="0eee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">🔥config.vm.disk指令是一个实验性的特性，需要使用环境变量lavour _ EXPERIMENTAL来创建这个虚拟机:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="47e3" class="mc md it np b gy nt nu l nv nw">$ VAGRANT_EXPERIMENTAL="disks" vagrant up</span></pre><p id="175f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦创建了VMs并设置了集群，我们就可以使用在本地文件夹中创建的kubeconfig.k3s文件来配置本地kubectl二进制文件:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="0c42" class="mc md it np b gy nt nu l nv nw">$ export KUBECONFIG=$PWD/kubeconfig.k3s</span></pre><p id="7e2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以与群集通信并列出其节点(在本例中只有一个):</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="4cc9" class="mc md it np b gy nt nu l nv nw">$ kubectl get nodes<br/>NAME      STATUS   ROLES                  AGE   VERSION<br/>vagrant   Ready    control-plane,master   31s   v1.20.4+k3s1</span></pre><p id="1e59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，我们确保10G磁盘已经连接到虚拟机。该磁盘应该显示为device /dev/sdb，如以下命令所示:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="40a8" class="mc md it np b gy nt nu l nv nw">$ vagrant ssh -- sudo fdisk -l | grep 'Disk /dev/sd*'<br/>Disk /dev/sda: 64 GiB, 68719476736 bytes, 134217728 sectors<br/>Disk /dev/sdb: 10 GiB, 10737418240 bytes, 20971520 sectors</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="f5d1" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated"><strong class="ak">车安装</strong></h2><p id="93ad" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">首先，需要检索GitHub上Rook项目最后一个标签对应的分支，并导航到<em class="nx">Rook/cluster/examples/kubernetes/ceph</em>目录:</p><p id="f7e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注:Rook目前的最新版本是v 1 . 5 . 8(2021年3月)</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="c3de" class="mc md it np b gy nt nu l nv nw">$ git clone --branch v1.5.8 <a class="ae ky" href="https://github.com/rook/rook.git" rel="noopener ugc nofollow" target="_blank">https://github.com/rook/rook.git</a></span><span id="9f51" class="mc md it np b gy ny nu l nv nw">$ cd rook/cluster/examples/kubernetes/ceph</span></pre><p id="87ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们部署专门用于设置Ceph集群的操作器以及它所依赖的资源:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="db73" class="mc md it np b gy nt nu l nv nw">kubectl apply -f crds.yaml -f common.yaml</span><span id="6a47" class="mc md it np b gy ny nu l nv nw">kubectl apply -f operator.yaml</span></pre><blockquote class="nz oa ob"><p id="19ae" class="kz la nx lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated">注意:operator是一个在Pod中运行的进程，它将负责根据稍后提供的规范配置Ceph集群</p></blockquote><p id="4232" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们确保操作员的Pod处于<strong class="lb iu">运行</strong>状态:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="80b5" class="mc md it np b gy nt nu l nv nw">$ kubectl get pod -n rook-ceph<br/>NAME                                 READY  STATUS  RESTARTS   AGE<br/>rook-ceph-operator-6b8b9958c5-2xf5z  1/1    Running 0          48s</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="39ff" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated"><strong class="ak"> Ceph集群创建</strong></h2><p id="8f90" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们现在将创建一个类型为<strong class="lb iu"> CephCluster </strong>的资源。我们之前部署的操作符将自动检测这个资源，并从中创建一个Ceph集群。对于这个例子，我们使用<em class="nx"> cluster-test.yaml </em>中可用的规范来创建<strong class="lb iu"> CephCluster </strong>资源:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="0342" class="mc md it np b gy nt nu l nv nw">$ kubectl apply -f cluster-test.yaml</span></pre><blockquote class="nz oa ob"><p id="c6c3" class="kz la nx lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated">注:cluster-test.yaml中指定的资源用于在测试环境中建立一个Ceph集群。对于生产环境，我们将使用cluster.yaml文件以及多节点Kubernetes集群</p></blockquote><p id="e0eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几分钟后，负责Ceph存储的吊舱将被部署。然后，我们可以使用以下命令检查它们是否运行正常:</p><blockquote class="nz oa ob"><p id="c25e" class="kz la nx lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated">注意:所有与Ceph相关的元素都是在名称空间rook-ceph中创建的</p></blockquote><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="24ad" class="mc md it np b gy nt nu l nv nw">$ kubectl get pod -n rook-ceph<br/>NAME                                 READY  STATUS   RESTARTS   AGE<br/>rook-ceph-operator-6b8b9958c5-2xf5z  1/1    Running   0          12m<br/>rook-ceph-mon-a-6d6fd795f6-bqqj2     1/1    Running   0          71s<br/>rook-ceph-mgr-a-67fd7cdf4-vggs7      1/1    Running   0          59s<br/>rook-ceph-osd-prepare-vagrant-kh44x  0/1    Completed 0          57s<br/>rook-ceph-osd-0-84f59c9898-wkk8l     1/1    Running   0          33s<br/>csi-cephfsplugin-dwptn               3/3    Running   0          20s<br/>csi-rbdplugin-vj7zt                  3/3    Running   0          21s<br/>csi-rbdplugin-provisioner-6b...      6/6    Running   0          20s<br/>csi-cephfsplugin-provisioner-86...   6/6    Running   0          19s</span></pre><p id="29aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">🔥在安装过程中，Rook能够检测到连接到虚拟机的未格式化驱动器。它自动使用这个磁盘作为Ceph集群的存储介质。我们可以通过查看Pod日志来确认这一点。</p><p id="8fc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在几个命令行中，我们部署了一个Rook操作符，并使用它在K3s中建立了一个Ceph集群！很酷，对吧？</p><p id="dd9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Ceph是一种广泛使用的解决方案，提供不同类型的存储:</p><ul class=""><li id="2c40" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">分时用外存储器系统</li><li id="031d" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">存储对象</li><li id="5f24" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">块存储器</li></ul><p id="defb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下文中，我们将使用块存储为一个简单的应用程序保存数据。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="6e93" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated"><strong class="ak">存储类</strong></h2><p id="64d7" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">为了能够自动调配块存储，我们首先创建一个StorageClass。为此，我们使用在<em class="nx">cluster/examples/kubernetes/ceph/CSI/rbd/storage class . YAML-test</em>中定义的规范:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="5451" class="mc md it np b gy nt nu l nv nw"><strong class="np iu">$ kubectl apply -f ./csi/rbd/storageclass-test.yaml<br/></strong>cephblockpool.ceph.rook.io/replicapool created<br/>storageclass.storage.k8s.io/rook-ceph-block created</span></pre><blockquote class="nz oa ob"><p id="e30f" class="kz la nx lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated">注意:顾名思义，storageclass-test.yaml文件适用于测试环境。不应在生产环境中使用它，因为此配置不允许数据复制。文件storageclass.yaml专用于为生产设置storageclass，即允许不同节点之间的数据复制</p></blockquote><p id="88e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们的集群中定义了两个存储类:</p><ul class=""><li id="9798" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">local-path:这是在k3s安装期间创建的，如果在PersistentVolumeClaim中没有指定StorageClass，则默认使用它</li><li id="0cf5" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">rook-ceph-block:这个是刚刚创建的</li></ul><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="fcb6" class="mc md it np b gy nt nu l nv nw">$ kubectl get sc<br/>NAME                   PROVISIONER ...<br/>local-path <strong class="np iu">(default)</strong>   rancher.io/local-path<br/>rook-ceph-block        rook-ceph.rbd.csi.ceph.com</span></pre><p id="5862" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用以下命令，我们将使<strong class="lb iu"> rook-ceph-block </strong>成为默认的存储类，而不是本地路径。这只是在每个资源中修改注释的问题:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="8c2a" class="mc md it np b gy nt nu l nv nw">$ kubectl patch storageclass local-path -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"false"}}}'</span><span id="c7fe" class="mc md it np b gy ny nu l nv nw">$ kubectl patch storageclass rook-ceph-block -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'</span></pre><p id="0462" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以检查是否进行了更改:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="39a0" class="mc md it np b gy nt nu l nv nw">$ kubectl get sc<br/>NAME                        PROVISIONER ...<br/>local-path                  rancher.io/local-path<br/>rook-ceph-block <strong class="np iu">(default)</strong>   rook-ceph.rbd.csi.ceph.com</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="3d7c" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">测试应用</h2><p id="08f1" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们现在将基于Ghost部署一个简单的应用程序，Ghost是一个开源的博客平台。该应用程序由以下3种资源组成:</p><ul class=""><li id="949f" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">基于Ghost映像的部署</li><li id="8197" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">NodePort类型的服务，在端口31005上公开应用程序</li><li id="278e" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">使用默认存储类请求1G存储的PersistentVolumeClaim</li></ul><p id="8f39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该应用的规格定义如下。在ghost部署中使用了PersistentVolumeClaim<em class="nx">ghost-PV-claim</em>:与此PVC关联的存储将挂载在ghost容器中的<em class="nx"> /var/lib/ghost/content </em>中，这是Ghost保存其数据的目录。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="1519" class="mc md it np b gy nt nu l nv nw">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: ghost<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: ghost<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: ghost<br/>    spec:<br/>      containers:<br/>      - name: ghost<br/>        image: ghost<br/>        ports:<br/>        - containerPort: 2368<br/>        volumeMounts:<br/>        - name: ghost-data<br/>          mountPath: /var/lib/ghost/content<br/>      volumes:<br/>      - name: ghost-data<br/>        persistentVolumeClaim:<br/>          claimName: ghost-pv-claim<br/>---<br/>apiVersion: v1<br/>kind: PersistentVolumeClaim<br/>metadata:<br/>  name: ghost-pv-claim<br/>spec:<br/>  accessModes:<br/>    - ReadWriteOnce<br/>  resources:<br/>    requests:<br/>      storage: 1Gi<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: ghost<br/>spec:<br/>  selector:<br/>    app: ghost<br/>  type: NodePort<br/>  ports:<br/>  - port: 80<br/>    targetPort: 2368<br/>    nodePort: 31005</span></pre><p id="3b9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用以下命令安装应用程序:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="c2f0" class="mc md it np b gy nt nu l nv nw"><strong class="np iu">$ kubectl apply -f https://luc.run/ghost-with-pvc.yaml<br/></strong>deployment.apps/ghost created<br/>persistentvolumeclaim/ghost-pv-claim created<br/>service/ghost created</span></pre><p id="1007" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几秒钟后，我们可以看到已经创建了一个PersistentVolume，并将其与之前创建的PersistentVolumeClaim相关联:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/92a863d9e03933fbdd5e3cd83b72ed73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ipWKOfS0yCZfCq9PKGZp_Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">一个新的PV被创建并绑定到PVC</figcaption></figure><p id="4f13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Ghost应用程序在端口31005上可用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/0599e4cbf660e14f1dec3b43dc88bf14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*poGnSgVcFkJM8cDjhYzHEg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Ghost界面</figcaption></figure><p id="dfbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有ghost Pod数据都存储在连接到集群节点的附加磁盘中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="8b9b" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">Ceph仪表板和车工具箱</h2><p id="88a2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Ceph的安装还设置了一个web管理界面。可以针对<em class="nx"> rook-ceph-mgr-dashboard </em>服务使用<strong class="lb iu"> port-forward </strong>命令来访问它:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="df46" class="mc md it np b gy nt nu l nv nw">$ kubectl port-forward svc/rook-ceph-mgr-dashboard 7000:7000 -n rook-ceph</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/df4a89797e37af98fdab4bd9ebc2f243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KyPeK2n3cIz6Z6BBSql5NA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Ceph仪表板</figcaption></figure><p id="501e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户名是<strong class="lb iu"> admin，</strong>可以使用以下命令检索密码:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="4e44" class="mc md it np b gy nt nu l nv nw">$ kubectl -n rook-ceph get secret rook-ceph-dashboard-password \<br/>  -o jsonpath="{['data']['password']}" | base64 --decode &amp;&amp; echo</span></pre><p id="4b01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过该界面，我们可以非常详细地了解存储集群，如下面的屏幕截图所示。不要犹豫导航，这是一个伟大的信息来源。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/9ba3110b735dd7d6ea5e54c0fcf4e7d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*awmyGVvOGYGIiIAlBwAAUQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Ceph集群的详细视图</figcaption></figure><p id="3407" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rook还提供了一个工具箱，允许您从命令行与Ceph集群进行交互。我们可以使用以下命令安装该工具箱:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="e742" class="mc md it np b gy nt nu l nv nw">$ kubectl apply -f <a class="ae ky" href="https://luc.run/rook/toolbox.yaml" rel="noopener ugc nofollow" target="_blank">https://luc.run/rook/toolbox.yaml</a></span></pre><p id="e0a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正确创建Pod后，我们可以在其中启动shell:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="a4bc" class="mc md it np b gy nt nu l nv nw">$ kubectl -n rook-ceph exec -it deploy/rook-ceph-tools -- bash</span></pre><p id="31b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Ceph集群中可以使用许多命令，例如:</p><ul class=""><li id="7c8c" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">ceph状态</li><li id="cf8d" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">ceph osd状态</li><li id="44fe" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">ceph df</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="8fc5" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated"><strong class="ak">关键要点</strong></h2><p id="3827" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Rook使得在我们的Kubernetes集群中建立Ceph集群只需要几分钟的时间。我们还能够使用块存储来保存来自Ghost应用程序的数据。</p><p id="2222" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们使用了一个节点来说明Rook的设置。但是，在生产环境中，有必要使用几个节点来确保它们之间的数据复制。</p><p id="6b5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rook允许协调不同的储物解决方案，包括:</p><ul class=""><li id="c629" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">Ceph(稳定)</li><li id="7070" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">卡桑德拉(阿尔法)</li><li id="4751" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">NFS(阿尔法)</li></ul><p id="5383" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是CNCF的毕业项目，请不要犹豫，用提供的其他存储解决方案之一来测试它。</p></div></div>    
</body>
</html>