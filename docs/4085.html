<html>
<head>
<title>Source Maps from top to bottom</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从上到下的源地图</h1>
<blockquote>原文：<a href="https://itnext.io/source-maps-from-top-to-bottom-597bbc07436?source=collection_archive---------2-----------------------#2020-04-24">https://itnext.io/source-maps-from-top-to-bottom-597bbc07436?source=collection_archive---------2-----------------------#2020-04-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9870" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇文章涵盖了JS代码生成器和源代码映射机制的基本概述和深入解释。从零开始建造我们自己的，因此它是相当长的。</p><p id="bfdf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对大多数人来说，源地图有点神秘。它们存在于大多数基于web的编译场景中；从类型系统到网络捆扎机。但是它们实际上是如何构建的细节往往不是100%透明的，因为它们的使用本身就足够复杂了。今天，我们将从它们是什么以及如何使用它们的简要概述开始。然后通过较低层次的机制继续前进；通过构建我们自己的编译器，它将生成一些代码，并生成自己的源地图供浏览器使用。</p><p id="d637" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我的<a class="ae ko" href="https://craigtaub.dev/introducing-my-under-the-hood-of-series" rel="noopener ugc nofollow" target="_blank">“引擎盖下”系列</a>的一部分:</p><ul class=""><li id="8a31" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated"><a class="ae ko" href="https://craigtaub.dev/under-the-hood-of-web-bundlers" rel="noopener ugc nofollow" target="_blank">网络捆扎机(如网络包)</a></li><li id="7b56" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><a class="ae ko" href="https://craigtaub.dev/under-the-hood-of-type-systems" rel="noopener ugc nofollow" target="_blank">类型系统(如TypeScript) </a></li><li id="6d84" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><a class="ae ko" href="https://craigtaub.dev/under-the-hood-of-test-runners" rel="noopener ugc nofollow" target="_blank">测试跑步者(如摩卡)</a></li><li id="78c7" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><a class="ae ko" href="https://craigtaub.dev/under-the-hood-of-vscode-auto-formatters" rel="noopener ugc nofollow" target="_blank"> VSCode自动格式化程序(例如更漂亮)</a></li><li id="f21a" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><a class="ae ko" href="https://craigtaub.dev/under-the-hood-of-react-hooks" rel="noopener ugc nofollow" target="_blank">反应钩</a></li><li id="f430" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/under-the-hood-of-apollo-6d8642066b28">阿波罗</a></li></ul><p id="bf6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇文章的完整视频浏览在<a class="ae ko" href="https://www.youtube.com/watch?v=nUV4t5V16I4" rel="noopener ugc nofollow" target="_blank">这里</a>。我的“<a class="ae ko" href="https://www.youtube.com/channel/UCYi23MnKBKn0yLZKBrz5Bfw" rel="noopener ugc nofollow" target="_blank"><em class="ld"/></a>的幕后部分”视频系列。</p><p id="432b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">今天的计划(如有帮助，请使用链接跳过):</p><h2 id="403d" class="le lf it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated"><a class="ae ko" href="#b420" rel="noopener ugc nofollow">A部分:源代码和编译器简介</a></h2><ol class=""><li id="9117" class="kp kq it js b jt lx jx ly kb lz kf ma kj mb kn mc kv kw kx bi translated">什么是源地图，为什么它们有用？</li><li id="a7b7" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn mc kv kw kx bi translated"><a class="ae ko" href="#12f4" rel="noopener ugc nofollow">使用流行工具制作源地图</a></li><li id="fa23" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn mc kv kw kx bi translated"><a class="ae ko" href="#b26c" rel="noopener ugc nofollow">什么是AST？</a></li><li id="e375" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn mc kv kw kx bi translated"><a class="ae ko" href="#4e78" rel="noopener ugc nofollow">转换JavaScript的步骤</a></li><li id="3a78" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn mc kv kw kx bi translated"><a class="ae ko" href="#e91b" rel="noopener ugc nofollow">编译器如何构建源代码图</a></li></ol><h2 id="0f6a" class="le lf it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated"><a class="ae ko" href="#8dad" rel="noopener ugc nofollow">B部分:构建我们自己的编译器</a></h2><ol class=""><li id="85c1" class="kp kq it js b jt lx jx ly kb lz kf ma kj mb kn mc kv kw kx bi translated"><a class="ae ko" href="#3b8f" rel="noopener ugc nofollow">构建JavaScript代码生成器</a></li><li id="6041" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn mc kv kw kx bi translated">什么是Base64 VLQ？</li><li id="01a9" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn mc kv kw kx bi translated"><a class="ae ko" href="#9de9" rel="noopener ugc nofollow">增加源地图支持</a></li><li id="61da" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn mc kv kw kx bi translated"><a class="ae ko" href="#4340" rel="noopener ugc nofollow">测试我们的源图</a></li></ol><p id="a454" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们开始吧💪</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="b420" class="mk lf it bd lg ml mm mn lj mo mp mq lm mr ms mt lp mu mv mw ls mx my mz lv na bi translated">A部分:源代码映射和编译器简介</h1><h2 id="b375" class="le lf it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated"><strong class="ak"> 1。什么是源地图，为什么它们有用？</strong></h2><p id="a4e9" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">首先让我们看看为什么人们编写需要编译成本地JavaScript的一些原因:</p><ul class=""><li id="0935" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">使用类型系统，</li><li id="4b46" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">使用最新的ES 8–9–10功能，</li><li id="5a48" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">代码优化(例如缩小)</li><li id="8896" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">捆绑包优化(例如，供应商与应用程序捆绑包)</li></ul><p id="2872" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现代编译器架构如下所示:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi ne"><img src="../Images/d052ce70d007bfc4d52b7b6874bd7345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xFAUhqm4xSgpMzeu"/></div></div></figure><p id="4ea0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">问题是，在将模块转化为资产的过程中，代码本身变得不可读，因为它的重点是放在计算机(通常是浏览器或服务器)上阅读。</p><p id="b2bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是一些通过编译器编译的示例代码。如果出现问题，几乎不可能推理，甚至更难调试。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nq"><img src="../Images/782a41f104a93bb8356052c190101060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KT1ZE7LIv0bYKdOY"/></div></div></figure><p id="ffa9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是源地图的用武之地！！</p><p id="adf2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">源映射的基本定义是:</p><blockquote class="nr"><p id="6b22" class="ns nt it bd nu nv nw nx ny nz oa kn dk translated"><em class="ob">“源映射提供了一种将压缩文件中的代码映射回其在源文件中的原始位置的方法”</em></p></blockquote><p id="8243" class="pw-post-body-paragraph jq jr it js b jt oc jv jw jx od jz ka kb oe kd ke kf of kh ki kj og kl km kn im bi translated">目的非常明确。现代浏览器会自动解析源地图，让它看起来好像你在运行未缩小或未合并的文件。</p><p id="6737" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面的例子显示了在浏览器中调试TypeScript，这是由于源映射才有可能实现的。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/d5660e6a568e1e41228bf5e2a3f52c9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/0*NSZrJpwnA0dKG0i6"/></div></figure><p id="58f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样，您现在可以在代码中放置一个断点，并在浏览器中检查调用堆栈、变量和任何运行时状态，所有这些都是通过预编译的TypeScript代码完成的。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h2 id="12f4" class="le lf it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated"><strong class="ak"> 2。使用流行工具的源地图</strong></h2><p id="492a" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated"><strong class="js iu">将浏览器连接到源地图</strong></p><p id="1866" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有两种方法通知浏览器有可用的源地图。</p><ol class=""><li id="4af6" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn mc kv kw kx bi translated">在JavaScript文件的页脚添加</li></ol><pre class="nf ng nh ni gt oi oj ok ol aw om bi"><span id="b624" class="le lf it oj b gy on oo l op oq"><em class="ld">//# sourceMappingURL=/path/to/file.js.map</em></span></pre><p id="e70b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.在JavaScript文件的“头”中添加</p><pre class="nf ng nh ni gt oi oj ok ol aw om bi"><span id="f24b" class="le lf it oj b gy on oo l op oq"><em class="ld">X-SourceMap: /path/to/file.js.map</em></span></pre><p id="2842" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有几点需要注意</p><ul class=""><li id="fc08" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">Chrome只有在DevTools开放的情况下才会下载源地图(因为它们可能非常大)</li><li id="6d4d" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">源映射不会显示为网络请求(在网络选项卡内)</li><li id="5944" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">一旦有了源映射，就可以在“源”代码中添加断点(可以在sources选项卡下找到)。</li></ul><p id="dc0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">源地图规格</strong></p><p id="d917" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当前的源映射必须遵循最新版本的源映射规范。这是第3版，可以在这里找到完整的版本<a class="ae ko" href="https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit" rel="noopener ugc nofollow" target="_blank"/>，它主要是由Mozilla和Google的工程师编写的。版本3对其整体大小进行了改进，这将加快下载和解析的速度。</p><p id="c849" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面显示了一个源代码映射的例子，重要的一点是“<em class="ld">映射</em>”，这些是Base64 VLQ字符串，包含从源代码到生成代码的实际映射。稍后，我们将制作自己的产品。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi or"><img src="../Images/a50a68f52cce9af3e84ef203c6844742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9o2CElSsgv8WULcwTMWOXA.png"/></div></div></figure><p id="667c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">在流行工具中的用法:</strong></p><p id="b7e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Node.js </strong></p><p id="82c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过标志"<em class="ld"> —启用-源-地图"</em></p><p id="6585" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">发生异常时，缓存源映射并用于堆栈跟踪。</p><p id="f48c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">巴别塔</strong></p><p id="cdb5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，Babel会在每个生成的包的底部添加一个源地图位置</p><pre class="nf ng nh ni gt oi oj ok ol aw om bi"><span id="6923" class="le lf it oj b gy on oo l op oq"><em class="ld">//# sourceMappingURL=file.map.js</em></span></pre><p id="ff76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是通过标志"<em class="ld"> — source-maps — inline" </em>你可以告诉Babel使用一个inline source map，如下所示(即base64编码内容字符串)。</p><pre class="nf ng nh ni gt oi oj ok ol aw om bi"><span id="5f31" class="le lf it oj b gy on oo l op oq">//# sourceMappingURL=data:application/json;charset=utf-8;base64,....</span></pre><p id="7f0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">网络包</strong></p><p id="3e79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过配置属性<em class="ld"> devtool: 'source-map' </em></p><p id="250a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">值得注意的是，因为像Webpack这样的工具经常一次使用许多处理器执行多个转换(例如Babel和TypeScript ),所以它仍然可以生成单个源地图。每个处理器都会生成自己的源映射，但是有一些库可以连接JavaScript文件，同时合并相应的源映射文件。一个例子叫做<a class="ae ko" href="https://www.npmjs.com/package/mapcat" rel="noopener ugc nofollow" target="_blank"> mapcat </a>。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h2 id="b26c" class="le lf it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated">3.AST是什么？</h2><p id="7fd1" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">在我们继续深入之前，我们需要快速了解一下JavaScript编译器中的一个重要机制，AST。</p><p id="a121" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">AST代表“<em class="ld">抽象语法树</em>”，它基本上是一个由“<em class="ld">节点</em>组成的树，代表一个程序的代码。一个"<em class="ld">节点</em>"是最小的可能单元，基本上是一个POJO(即普通的旧js对象)，具有"<em class="ld">类型"</em>和"<em class="ld">位置"</em>属性。所有节点都有这两个属性，但是基于"<em class="ld">类型"</em>，它们还可以有各种其他属性。</p><p id="e42b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在AST表单中，代码非常容易操作，所以像添加、删除甚至替换这样的操作。</p><p id="f85a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面的代码就是一个例子:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi os"><img src="../Images/d0037a01c2b647c17ceff0e40eb92041.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/0*U0AAjMYD7M5XCWU6"/></div></figure><p id="755b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将成为以下AST:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/100c5c9db0c16aa14cae9cd6d771dc02.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/0*V6Ye3n_4EeNwvbLr"/></div></figure><p id="3865" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有一些网站，比如https://astexplorer.net/网站，可以让你很好地编写JavaScript代码并立即看到它的AST。</p><p id="7fb9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">树遍历</strong></p><p id="6f2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">处理AST最重要的部分是理解有不同的方法，每种方法都有优点和缺点。</p><p id="62f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个流行类型的例子(也是我们今天要用的类型)叫做“<strong class="js iu"> <em class="ld">深度优先搜索</em> </strong>”，它的工作方式是从根开始，在回溯之前沿着每个分支尽可能向左探索。因此，它将按以下顺序处理一棵树:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi ou"><img src="../Images/21d42e01fd3b4d4ba13a435883b3c8a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/0*ZszQ8ZcwFWkQY3-2"/></div></div></figure><p id="3545" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以如果我们有一段代码，比如</p><pre class="nf ng nh ni gt oi oj ok ol aw om bi"><span id="64ad" class="le lf it oj b gy on oo l op oq">2 + 3 * 1</span></pre><p id="12f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它将生成以下树:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/539cac7400882df7b97d258049784b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:232/0*hhM4256HcsnlFHKd"/></div></figure></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h2 id="4e78" class="le lf it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated">4.转换JavaScript的步骤</h2><p id="40e9" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">转换JavaScript有3个步骤:</p><p id="0a44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 1)将源代码解析成AST </strong></p><ul class=""><li id="2de3" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated"><em class="ld">词法分析</em> - &gt;把代码串变成令牌流(即数组)。</li><li id="453b" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><em class="ld">语法分析</em> - &gt;将令牌流转换成其AST表示</li></ul><p id="b65b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">2)AST上的变换节点</strong> - &gt; <strong class="js iu"> </strong>操作AST节点(任何库插件都可以在这里运行，例如Babel)</p><p id="e8d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3)生成源代码</strong>-&gt;-<strong class="js iu">-</strong>将<strong class="js iu">-</strong>AST转换成字符串的JavaScript源代码</p><p id="a891" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ld">今天我们来关注一下发电机的工作岗位！！</em> </strong></p><p id="c7e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">库在只做步骤1和做所有3个步骤之间是不同的。</p><p id="3e08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完成以下3项任务的库示例:</p><ul class=""><li id="1e2f" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated"><a class="ae ko" href="https://www.npmjs.com/package/@babel/cli" rel="noopener ugc nofollow" target="_blank">巴别塔</a></li><li id="ed20" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><a class="ae ko" href="https://www.npmjs.com/package/recast" rel="noopener ugc nofollow" target="_blank">重铸</a></li><li id="bb16" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><a class="ae ko" href="https://github.com/facebook/codemod" rel="noopener ugc nofollow" target="_blank">Facebook code mod</a></li></ul><p id="7a04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">仅执行1:</p><ul class=""><li id="f35e" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated"><a class="ae ko" href="https://www.npmjs.com/package/esprima" rel="noopener ugc nofollow" target="_blank"> Esprima </a>(进行解析)</li><li id="8bc9" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><a class="ae ko" href="https://www.npmjs.com/package/ast-types" rel="noopener ugc nofollow" target="_blank"> ast-types </a>(进行ast节点操作)</li><li id="fb55" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><a class="ae ko" href="https://www.npmjs.com/package/escodegen" rel="noopener ugc nofollow" target="_blank"> Escodegen </a>(礼部代)</li></ul></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h2 id="e91b" class="le lf it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated">5.编译器如何构建源地图</h2><p id="07aa" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">生成源映射有3个部分，所有这些都是编译器必须完成的:</p><p id="cfa4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">1)转换代码并注意新生成的源位置</p><p id="9fee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2)检查原始代码和生成代码之间的位置差异</p><p id="5d76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3)使用这些映射建立一个源映射</p><p id="489d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一种过度简化，我们将在下面的<strong class="js iu">B部分</strong>中更深入地了解它的具体细节。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="8dad" class="mk lf it bd lg ml mm mn lj mo mp mq lm mr ms mt lp mu mv mw ls mx my mz lv na bi translated">第二部分:构建我们自己的编译器</h1><h2 id="3b8f" class="le lf it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated">1.构建JavaScript代码生成器</h2><p id="aa53" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">我们将从下面的架构开始。目的是在编译后产生转换后的文件(<em class="ld"> index.es5.js </em>)和源映射(<em class="ld"> index.es5.js.map </em>)。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/a0fa0a17cf36358cfeb965c2e6b7141f.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*oPHmXo_GBY1Zycq06OV-WA.png"/></div></figure><p id="7bf6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的<code class="fe ox oy oz oj b">src/index.es6.js</code>会是这样的(一个简单的<em class="ld">加</em>的函数):</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="34cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们有了预编译的源代码。我们想开始看看编译器。</p><h1 id="40e6" class="mk lf it bd lg ml pc mn lj mo pd mq lm mr pe mt lp mu pf mw ls mx pg mz lv na bi translated">该过程</h1><p id="9da8" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">我们的编译器必须执行几个步骤:</p><p id="b515" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 1。解析代码到AST </strong></p><p id="977a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于本文的重点不是解析，我们将为此使用一个基本的第三方工具(<a class="ae ko" href="https://www.npmjs.com/package/esprima" rel="noopener ugc nofollow" target="_blank"> esprima </a>或<a class="ae ko" href="https://www.npmjs.com/package/escodegen" rel="noopener ugc nofollow" target="_blank"> escodegen </a>)</p><p id="3a7c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 2。将每个节点的浅层克隆添加到AST上</strong></p><p id="c95f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个想法是从《T4》的《T3》中借鉴来的。其思想是每个节点将持有自身以及自身的克隆(即原始)。克隆用于检查节点是否已更改。稍后会详细介绍。</p><p id="4bcf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3。变形</strong></p><p id="9344" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将手动执行此操作。我们可以使用像<a class="ae ko" href="https://www.npmjs.com/package/ast-types" rel="noopener ugc nofollow" target="_blank"> ast-types </a>或<a class="ae ko" href="https://www.npmjs.com/package/@babel/types" rel="noopener ugc nofollow" target="_blank"> @babel/types </a>这样的库，因为它们有有用的API。</p><p id="d7a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 4。生成源代码</strong></p><p id="6c62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">把我们的AST变成JavaScript。</p><p id="91d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 5。添加源地图支持</strong></p><p id="97d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4和5和上面一样同时做。这将涉及到遍历树并检测AST节点在哪里用它的“<em class="ld">原始的</em>属性改变了。对于那些实例，存储“<em class="ld">原始</em>”和“<em class="ld">生成的</em>”代码之间的映射。</p><p id="5c23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 6。写信给<em class="ld">build/</em>T24】</strong></p><p id="c982" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，将我们生成的源代码及其源代码映射写入适当的文件。</p><h1 id="2fef" class="mk lf it bd lg ml pc mn lj mo pd mq lm mr pe mt lp mu pf mw ls mx pg mz lv na bi translated">代码</h1><p id="fee1" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">让我们再来看一下这些步骤，但这次要更详细一些。</p><ol class=""><li id="7e91" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn mc kv kw kx bi translated"><strong class="js iu">解析代码到AST </strong></li></ol><p id="654a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用一个基本的第三方工具(我选择了一个简单的叫做<a class="ae ko" href="https://www.npmjs.com/package/abstract-syntax-tree" rel="noopener ugc nofollow" target="_blank"> ast </a>的工具)，我们获取我们的文件内容并将它们传递给库解析器。</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="4f68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 2。将每个节点的浅层克隆添加到AST上</strong></p><p id="6bd7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们定义一个名为“<em class="ld"> visit </em>的函数，其任务是遍历树并在每个节点上执行我们的回调函数。</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="7710" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们做一个上面提到的<strong class="js iu"> <em class="ld">深度优先搜索</em> </strong>。对于给定的节点，它将:</p><ol class=""><li id="3d3f" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn mc kv kw kx bi translated">执行回调</li><li id="f037" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn mc kv kw kx bi translated">检查位置属性，如果是，则提前返回</li><li id="8726" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn mc kv kw kx bi translated">检查是否有任何属性是数组，如果有，用每个子元素调用它自己</li><li id="1f48" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn mc kv kw kx bi translated">检查是否有任何属性是AST节点，如果有，用该节点调用自身。</li></ol><p id="71e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来我们继续生产我们的克隆体。</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="4db6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的<code class="fe ox oy oz oj b">cloneOriginalAst </code>函数生成节点的克隆，并将其附加到原始节点上。</p><p id="b067" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于我们的克隆，我们使用<code class="fe ox oy oz oj b">Object.assign</code>，所以它是一个<strong class="js iu">浅层克隆</strong>，并复制顶级属性。嵌套的道具仍然通过<strong class="js iu">按引用传递</strong>连接，即改变它们将改变克隆体。我们也可以在这里使用<strong class="js iu">扩展操作符</strong>,因为它可以做同样的事情。我们将使用顶层进行比较，这足以比较2个AST节点，并确定该节点是否发生了变化。</p><p id="647f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总的来说，我们的代码将返回相同的树，除了在每个节点上都有“<em class="ld"> original </em>”属性。</p><p id="dbdb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3。转换</strong></p><p id="3d65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们将进行节点操作。我们将保持简单，所以我们将只从我们的程序交换2个节点。因此，我们将从以下内容开始:</p><pre class="nf ng nh ni gt oi oj ok ol aw om bi"><span id="39a0" class="le lf it oj b gy on oo l op oq">number + 1</span></pre><p id="36c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结尾是:</p><pre class="nf ng nh ni gt oi oj ok ol aw om bi"><span id="cf0d" class="le lf it oj b gy on oo l op oq">1 + number</span></pre><p id="4f3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">理论上简单没错！</p><p id="66cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们进行交换的代码如下:</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="31f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们没有使用干净的API来做这件事(许多库都提供了),因为我们已经手动交换了2个节点。</p><p id="66f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个使用带有有用API的库的例子可能看起来像下面这样，由关于<a class="ae ko" href="https://github.com/benjamn/ast-types" rel="noopener ugc nofollow" target="_blank"> ast-types </a>的文档提供。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/650f9308b7c0b38d2ea0b3953b0c8387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/0*eb24-32VjegA5eQr"/></div></figure><p id="b565" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方式当然更安全，更容易遵循，开发起来也更快。所以一般来说，我会推荐使用它来处理任何复杂的AST操作，大多数知名编译器都这么做。</p><p id="e158" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 4。生成源代码</strong></p><p id="e4f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码生成器通常存放在一个文件中，有几千行长。例如，escodegen的编译器有2619行代码(参见<a class="ae ko" href="https://github.com/estools/escodegen/blob/master/escodegen.js" rel="noopener ugc nofollow" target="_blank">这里的</a>)。那是相对于其他人来说较小的一面(疯狂的权利！)</p><p id="6903" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我在我们的编译器中使用了很多相同的代码(因为大多数生成器需要非常相似的逻辑来将AST处理成JavaScript ),除了我们处理来自“<em class="ld"> index.es6.js </em>文件的代码所绝对需要的<strong class="js iu"><em class="ld"/></strong>。</p><p id="128c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面我定义了编译器中的三种代码。</p><p id="ff44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> a)节点处理器和角色实用程序</strong></p><p id="3f04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些是用于处理AST节点(取决于类型，例如函数声明将有一个标识符)和构建源代码的通用实用函数。它还包括一些常见的字符常量(如“<em class="ld">空格</em>”)。在下一节中，我们将从代码“类型语句”中调用它们。</p><p id="9c66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我不会太担心这里的细节，除非你打算写一个编译器。这很大程度上是借用了<a class="ae ko" href="https://github.com/estools/escodegen/blob/master/escodegen.js#L788" rel="noopener ugc nofollow" target="_blank"> escodegen这里</a>的发电机。</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="5cc3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> b)类型报表</strong></p><p id="b98f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个包含与AST节点类型相关的函数的对象。每个都包含处理AST节点类型和生成源代码所需的逻辑。例如，对于一个函数声明，它包含了参数、标识符、逻辑和返回类型的所有可能的变化。这里有一个常见的递归层次，即一个类型语句触发另一个类型语句，后者可能触发另一个类型语句，等等。</p><p id="d9eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们<strong class="js iu">只有</strong>有必要的语句函数来处理我们的“<em class="ld"> index.es6.js </em>文件，所以它是相当有限的。您可以看到仅处理我们的AST树的3-4行代码就需要多少代码(除了上一节的代码之外)。</p><p id="f56c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这再次借用了“<a class="ae ko" href="https://github.com/estools/escodegen/blob/master/escodegen.js#L1020" rel="noopener ugc nofollow" target="_blank"> escodegen here </a>”所以请随意忽略细节，除非你打算编写自己的编译器。</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="29fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> c)过程代码语句</strong></p><p id="697f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们将迭代程序体(即每一行代码)并开始运行我们的生成器。这将返回一个名为“<em class="ld"> code </em>的数组，其中包含我们新生成的源代码的每一行。</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="32a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 6。写入<em class="ld">构建/</em>T13】</strong></p><p id="e1c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在将跳过<strong class="js iu">步骤5 </strong>，完成我们编译器的核心元素。因此，对于这一步，我们将</p><ul class=""><li id="ceda" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">将一个源地图位置添加到我们生成的代码中(我们将在下一节构建它)</li><li id="27c4" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">为生成的代码生成一个包(将我们的代码数组连接在一起)，并复制原始代码，以便浏览器可以看到它(这只是一种方法)。</li></ul><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="031e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 5。添加源地图支持</strong></p><p id="1795" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">构建源地图有4个要求:</p><ol class=""><li id="e077" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn mc kv kw kx bi translated">源文件的存储记录</li><li id="39df" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn mc kv kw kx bi translated">存储生成文件的记录</li><li id="6f88" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn mc kv kw kx bi translated">存储行/列的映射</li><li id="8417" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn mc kv kw kx bi translated">使用规范版本3在源映射文件中显示</li></ol><p id="0a79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了快速取胜，我们可以使用几乎每个JavaScript代码生成器都使用的库，名为<a class="ae ko" href="https://github.com/mozilla/source-map/" rel="noopener ugc nofollow" target="_blank"> source-map </a>。它来自Mozilla，处理点1–3的存储，以及处理映射到Base64 VLQ的过程(步骤4)。</p><p id="e46a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">稍微提醒一下突出显示映射的源映射是什么样子的(从上面看):</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/9f18de9e328a1ae60e22aa2d0dda8a3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*IQnaxETv0ohx8W6spASTKA.png"/></div></figure><p id="cefd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">映射是Base64 VLQ，但那是什么呢？</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h2 id="913b" class="le lf it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated">2.什么是Base64 VLQ？</h2><p id="f81e" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">首先简单介绍一下Base64和VLQ。</p><p id="60fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Base64 </p><p id="073d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解决了处理没有完整ASCII字符集的语言的ASCII问题。Base64只有ASCII的子集，更容易在不同语言中处理。</p><p id="b759" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> VLQ(可变长度数量)</strong></p><p id="a0ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将整数的二进制表示形式分解为一组小的可变位块。</p><p id="d5d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Base64 VLQ </p><p id="e712" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">经过优化，使源文件中的大数字和相应信息之间的映射变得容易。</p><p id="f2c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一行代码由一系列“段”表示。数字“1”应该是:</p><pre class="nf ng nh ni gt oi oj ok ol aw om bi"><span id="f052" class="le lf it oj b gy on oo l op oq">AAAA =&gt; 0000</span></pre><p id="5874" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是数字如何相互关联以构建“<em class="ld">段</em>的示例:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi pj"><img src="../Images/ff02dfbe02c82866a8b73908eec70f6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ET5Mg3DQ5ctKJ_MG"/></div></div></figure><p id="f15b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用JavaScript构建一个基本的映射应该是这样的:</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="45bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，这并不处理行和段的分离(这可能非常棘手)，所以使用Mozilla的库仍然更有效。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h2 id="9de9" class="le lf it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated">3.添加源地图支持</h2><p id="77d3" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">回到我们的编译器！！</p><p id="ebb5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">使用莫扎特<em class="ld">SourceMapGenerator</em>T5】</strong></p><p id="1db6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了充分利用Mozillas库，我们将:</p><ul class=""><li id="83d1" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">创建一个sourceMap实例来保存和构建我们的映射</li><li id="c3b8" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">初始化并存储本地映射</li></ul><p id="d41e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，当一个节点发生变化时，我们会这样做；构建位置，然后将其添加到我们的本地映射和SourceMap实例中。我们保存一个本地实例，这样我们就可以记录当前位置的开始和结束，因为这对构建下一个位置至关重要。</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="ce70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要一个实际处理更新这些映射实例的函数。下面的"<em class="ld"> buildLocation </em>"函数处理所有的位置生成逻辑。大多数库都有类似的功能，使用调用者给定的列和行的<em class="ld">偏移量</em>。</p><p id="3173" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它的工作是计算出新的行号和列号的开始以及行号和列号的结束。只有当一个节点发生变化时，它才会添加一个映射，这就限制了我们要存储的映射。</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="1721" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们有了“<em class="ld"> buildLocation </em>”，我们必须在代码中引入它。下面是几个例子。对于“<em class="ld"> generateIdentifier </em>”处理器实用程序和“<em class="ld">Literal</em>”AST类型语句，您可以看到我们是如何合并“<em class="ld"> buildLocation </em>”的。</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="eaab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要在整个代码生成器中应用这一点(即所有节点处理器和AST类型语句函数)。</p><p id="06c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我发现这很棘手，因为节点到字符的映射并不总是1–2–1。例如，一个函数可能在它的参数的两边都有括号，当涉及到字符行的位置时，必须考虑到这一点。所以:</p><pre class="nf ng nh ni gt oi oj ok ol aw om bi"><span id="e718" class="le lf it oj b gy on oo l op oq">(one) =&gt;</span></pre><p id="32c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">具有不同的字符位置:</p><pre class="nf ng nh ni gt oi oj ok ol aw om bi"><span id="5a8d" class="le lf it oj b gy on oo l op oq">one =&gt;</span></pre><p id="25da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">大多数库所做的是使用AST节点上的信息引入逻辑和防御检查，因此所有场景都可以涵盖。我会遵循同样的做法，除了我只是为我们的"<em class="ld"> index.es6.js </em>"添加了绝对必要的代码</p><p id="d176" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完整的用法请参见库中我的生成器的<a class="ae ko" href="https://github.com/craigtaub/our-own-babel-sourcemap/blob/master/compiler/ast-util.mjs" rel="noopener ugc nofollow" target="_blank">代码。它缺少大的部分，但是它完成了工作，并且是真正的代码生成器的构建块。</a></p><p id="8d70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后一部分是将我们的源地图内容写入源地图文件。这对于Mozillas库来说非常容易，因为他们公开了一个“<em class="ld"> toString() </em>”方法，该方法将处理Base64 VLQ编码并将所有映射构建到一个符合v3规范的文件中。<strong class="js iu">好看的</strong>！！</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="5e84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们参考<em class="ld">。/build/index.es5.js </em>"之前会有一个文件存在。</p><p id="3368" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的编译器现在完成了！！！！🤩</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/dd670bb57e07a7f9197fed7c9439e71f.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*fl6pEdJi7wgMckcZ"/></div></figure><p id="5397" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对编译器来说就是这样了，最后一部分是确认它已经工作了。</p><p id="16a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们编译代码，它应该产生我们的构建文件夹，里面有3个文件。</p><p id="6cca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ld"> &gt; npm运行编译</em></p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/26184a097f26e97c752ad1459c2887ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/0*f9jo1tszz_pfP7iB"/></div></figure><p id="9018" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">即原始、生成和源地图。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h2 id="4340" class="le lf it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated">4.测试我们的源地图</h2><p id="2da7" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">在https://sokra.github.io/source-map-visualization/<a class="ae ko" href="https://sokra.github.io/source-map-visualization/" rel="noopener ugc nofollow" target="_blank">有一个很棒的网站，可以让你看到源地图。</a></p><p id="180b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">页面是这样开始的:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/0d22f57b2fe86ebc51c21215b9782ed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DD0dJt33p8e2HvHj"/></div></figure><p id="4180" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将我们的3个文件放入其中，我们现在可以看到:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi or"><img src="../Images/5f6a0884b91f7989c66b45ee1bd93b62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*c8JkwNcnNe5GuEXu"/></div></div></figure><p id="a278" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很鲜艳吧！</p><p id="7886" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它包含原始代码、生成的代码和解码的映射(在底部)。</p><p id="0bcb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">稍微提醒一下我们之前的转变:</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="1a8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们交换了:</p><pre class="nf ng nh ni gt oi oj ok ol aw om bi"><span id="0ce9" class="le lf it oj b gy on oo l op oq">number + 1</span></pre><p id="5d21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">变成:</p><pre class="nf ng nh ni gt oi oj ok ol aw om bi"><span id="26a8" class="le lf it oj b gy on oo l op oq">1 + number</span></pre><p id="ce9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们能确认地图已经工作了吗？</p><p id="feb9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们将鼠标悬停在字符或映射上，它会高亮显示该映射及其在生成位置和原始位置中的相应位置。</p><p id="e0b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该屏幕截图显示了当我将鼠标悬停在文字数字“<em class="ld"> 1 </em>”字符上时会发生什么。它清楚地表明有一个映射。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/cba6a1edc16911e5746b979ce1862db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*LSJWmJkKqqN8IBzi_fMe9A.png"/></div></figure><p id="30b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该屏幕截图显示了当我将鼠标悬停在变量标识符“<em class="ld">数字</em>单词上时会发生什么。它清楚地表明有一个映射。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi po"><img src="../Images/8601e7a2d8b4766a4998706ce00c0d05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*GuFus6L4zQwq4ewjXMISIA.png"/></div></figure><p id="b098" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">成功了！！💪</strong></p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="7c83" class="mk lf it bd lg ml mm mn lj mo mp mq lm mr ms mt lp mu mv mw ls mx my mz lv na bi translated">我们错过了什么？</h1><p id="96ec" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">那么构建这样的编译器有什么局限性呢？</p><ul class=""><li id="1103" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">并不是所有的JavaScript语句都包括在内(只是我们的文件需要的)</li><li id="d6ea" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">目前它只能处理1个文件。Web bundlers将遵循该应用程序构建一个依赖图，并对这些文件应用转换(参见我的“<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/under-the-hood-of-web-bundlers-e-g-webpack-926e868f7f5e">under-the-hood of web bundlers</a>”文章了解更多信息)。</li><li id="4a74" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">输出文件与包。Web bundlers将生成在特定的JavaScript环境中可运行的代码包，我们的非常有限(再次参见我的“web bundlers的内幕”了解更多)。</li><li id="d74c" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">基本转换。如果没有大量的新代码，执行额外的优化并不容易。</li></ul></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><p id="9fc1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">非常感谢你的阅读。这个话题意义深远，在研究过程中我学到了很多。我真的希望这有助于阐明JavaScript编译器和源码图是如何一起工作的，包括其中涉及的机制。</p><p id="cc74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个的源代码可以在craigtaub/our-own-babel-source map找到，如果你喜欢这个，请鼓掌。</p><p id="e1bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">谢谢，克雷格😃</p></div></div>    
</body>
</html>