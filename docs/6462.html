<html>
<head>
<title>Fundamental tips for testing React components with Enzyme</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试组分与酶反应的基本技巧</h1>
<blockquote>原文：<a href="https://itnext.io/fundamental-tips-for-testing-react-components-with-enzyme-2c56e73de951?source=collection_archive---------3-----------------------#2021-11-22">https://itnext.io/fundamental-tips-for-testing-react-components-with-enzyme-2c56e73de951?source=collection_archive---------3-----------------------#2021-11-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a74491c64ff748d45791fe136c4b648f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gAJfCk7jnCQYSxemr3AzMQ.png"/></div></div></figure><p id="3d4f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你不熟悉所有可用的工具，用酶测试反应成分是很棘手的。这篇文章将涵盖Enzyme提供的帮助编写React组件单元测试的基本技巧和实用程序。</p><h1 id="070c" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">#1查看HTML输出</h1><p id="c711" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在用Enzyme编写测试时，能够看到组件的HTML输出是很方便的。为此，您可以在挂载的元素上使用<code class="fe mc md me mf b">debug</code>方法:</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mg"><img src="../Images/37cf04aa3908f710dcf1602778daec7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hlmQirqSN0g4otZXTTAJ_A.png"/></div></div></figure><h1 id="f1ab" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">#2向组件传递上下文</h1><p id="fe82" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">用于浅层渲染组件的<code class="fe mc md me mf b">shallow</code>方法接受第二个选项参数，让您指定<code class="fe mc md me mf b">context</code>选项。<a class="ae ml" href="https://enzymejs.github.io/enzyme/docs/api/shallow.html#shallownode-options--shallowwrapper" rel="noopener ugc nofollow" target="_blank">库文档</a>声明您可以使用该选项将上下文传递给React组件。然而，它有一个问题。这种方法只适用于遗留的<code class="fe mc md me mf b">context</code>对象，不适用于现代的上下文API。</p><p id="1ffc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么现代API的工作方式是什么呢？更好的方法是使用<code class="fe mc md me mf b">wrappingComponent</code>选项将上下文提供者指定为包装器:</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mg"><img src="../Images/49636afc24297d42324af1ad9ba615ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*v2gBfwYLtRI0xjnR.png"/></div></div></figure><p id="cd1c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以这种方式提供上下文确保了<code class="fe mc md me mf b">shallow</code>方法的返回值仍然是您的目标测试组件。</p><h1 id="c978" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">#3选择器类型</h1><p id="4a1c" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">人们通常使用CSS选择器来寻找酶中的成分。但是，您还可以使用其他类型的选择器，具体来说有五种。</p><h2 id="203e" class="mm la it bd lb mn mo dn lf mp mq dp lj km mr ms ln kq mt mu lr ku mv mw lv mx bi translated">半铸钢ˌ钢性铸铁(Cast Semi-Steel)</h2><p id="f8c1" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我们讨论过的常规CSS选择器:</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/8019fb1f9a7020590eb96d1fa880ca3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vcDhnFtLH5dBasxH.png"/></div></div></figure><h2 id="b359" class="mm la it bd lb mn mo dn lf mp mq dp lj km mr ms ln kq mt mu lr ku mv mw lv mx bi translated">支柱</h2><p id="fa43" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">该选择器基于组件属性的值来定位组件。语法与CSS属性选择器相同:</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mg"><img src="../Images/2902b6c1775720df070785facd6e3a90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NcAbmkE73Vp-98xf.png"/></div></div></figure><h2 id="95f2" class="mm la it bd lb mn mo dn lf mp mq dp lj km mr ms ln kq mt mu lr ku mv mw lv mx bi translated">组件构造器</h2><p id="d179" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">使用组件的构造函数查找组件。只需将引用传递给构造函数:</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/7d9c1defc2140d3b6aa91e219e80e09b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EmscQaUVHu6lFol1.png"/></div></div></figure><h2 id="ac38" class="mm la it bd lb mn mo dn lf mp mq dp lj km mr ms ln kq mt mu lr ku mv mw lv mx bi translated">组件显示名称</h2><p id="405c" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我们可以简单地传递组件的显示名称来找到它。需要注意的一点是:<code class="fe mc md me mf b">displayName</code>必须以大写字母开头，否则Enzyme会将其解释为CSS选择器。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mg"><img src="../Images/293f09801883411dc35329590c6c960d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gFOt2Bgb7VdOeqKj.png"/></div></div></figure><h2 id="288a" class="mm la it bd lb mn mo dn lf mp mq dp lj km mr ms ln kq mt mu lr ku mv mw lv mx bi translated">HTML属性选择器</h2><p id="28b6" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我们可以使用这个选择器根据HTML属性的值来查找目标元素。我们所需要做的就是传递一个对象，该对象与我们试图寻找的HTML元素的属性相匹配。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mg"><img src="../Images/0fda54ac7b544a416ce0ee789a143980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jdbl0GzLRKXIWX-2.png"/></div></div></figure><h1 id="c1fc" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">#4访问道具</h1><p id="806b" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">对于酶，有两种不同的<code class="fe mc md me mf b">props</code>方法可以使用。您可以直接在挂载的组件上调用props，或者您可以使用<code class="fe mc md me mf b">instance().props.</code>在组件的实例上调用props。正如您可能猜到的，它们的返回值之间存在差异:</p><ul class=""><li id="dd90" class="na nb it kd b ke kf ki kj km nc kq nd ku ne ky nf ng nh ni bi translated"><code class="fe mc md me mf b">instance().props</code>返回React组件本身的道具。</li><li id="d12f" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">直接在包装器上调用<code class="fe mc md me mf b">props</code>将返回底层HTML节点的属性。</li></ul><h1 id="45bd" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">#5模拟事件</h1><p id="fe57" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated"><code class="fe mc md me mf b">simulate</code>函数模拟包装器根节点上的事件。您可以用它来模拟点击、滚动、输入和其他用户动作。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/fce3945b3568c6a42b9754d8270a63f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pSua_Qm5P-16-5Hk.png"/></div></div></figure><p id="57ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最重要的是，<code class="fe mc md me mf b">simulate</code>接受可选的事件参数，这允许您模拟事件对象:</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/063dccc8cfa13440b3e0b049b0e9d412.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*H7YRk_Zq8NNjsAiZ.png"/></div></div></figure><h1 id="614d" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">#6测试连接到Redux的组件的简单方法</h1><p id="ed4f" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">测试连接到Redux的酶组件通常很棘手。一种广泛使用的方法是用Redux provider包装React组件并挂载它，或者使用<a class="ae ml" href="https://github.com/reduxjs/redux-mock-store" rel="noopener ugc nofollow" target="_blank"> redux-mock-store </a>:</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/7a951ade4f74d92bcbcf844f05402b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QJXtWGL6rlcZ47A8.png"/></div></div></figure><p id="93d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是通常，您想要测试的只是组件是否正确地响应事件并触发正确的动作。为此，您不一定需要包含Redux本身。相反，您可以直接使用您试图测试的组件，而不是连接到Redux的高阶组件。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/fc409f420bbb9df7d83c218b90313475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9ssJrnknSoIBid3Z.png"/></div></div></figure><p id="9954" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种方法有两个主要好处:</p><ul class=""><li id="3a8f" class="na nb it kd b ke kf ki kj km nc kq nd ku ne ky nf ng nh ni bi translated">我们可以用<code class="fe mc md me mf b">shallow</code>代替<code class="fe mc md me mf b">mount</code>。使用前面的方法，您经常需要使用<code class="fe mc md me mf b">mount</code>来访问连接的组件。这样做会渲染所有的组件树，而我们通常不需要这样做。</li><li id="5b7b" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">您不再需要模仿Redux存储，也不再需要关心它的实现细节。相反，只需提供组件直接使用的道具来模拟HOC如何注入相同的道具。</li></ul><h1 id="0689" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">#7检查您的组件是否启动功能</h1><p id="42ea" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">您可以使用<code class="fe mc md me mf b">toHaveBeenCalled</code>和<code class="fe mc md me mf b">toHaveBeenCalledWith</code>来测试您的组件是否按照您期望的方式触发功能。</p><p id="b4f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">两者的区别在于<code class="fe mc md me mf b">toHaveBeenCalledWith</code>允许您指定您期望函数接收的确切参数:</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/ae54dc7aaf28728ce81bb121f944e98d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uht2ZSg1DEhz-68G.png"/></div></div></figure><p id="2a0a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是这篇文章的全部内容。在这里，我们简要介绍了用酶编写React组件单元测试的基本技巧和实践。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="b273" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nw">原载于2021年11月22日https://isamatov.com</em><a class="ae ml" href="https://isamatov.com/react-enzyme-tips/" rel="noopener ugc nofollow" target="_blank"><em class="nw"/></a><em class="nw">。</em></p></div></div>    
</body>
</html>