<html>
<head>
<title>Abstraction in Reflex and CodeWorld</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反射和代码世界中的抽象</h1>
<blockquote>原文：<a href="https://itnext.io/abstraction-in-reflex-and-codeworld-a1b42ad36923?source=collection_archive---------1-----------------------#2021-08-14">https://itnext.io/abstraction-in-reflex-and-codeworld-a1b42ad36923?source=collection_archive---------1-----------------------#2021-08-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6432" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我最近整理了一个使用FRP ( <a class="ae kl" href="https://en.wikipedia.org/wiki/Functional_reactive_programming" rel="noopener ugc nofollow" target="_blank">函数式反应式编程</a>)来清晰地分离和建模交互应用程序各部分的交互的简洁例子:在这个例子中，是一个RPN ( <a class="ae kl" href="https://en.wikipedia.org/wiki/Reverse_Polish_notation" rel="noopener ugc nofollow" target="_blank">反向波兰符号</a>)计算器。在本文中，我使用<a class="ae kl" href="https://reflex-frp.org/" rel="noopener ugc nofollow" target="_blank"> Reflex FRP库</a>和<a class="ae kl" href="https://code.world/haskell" rel="noopener ugc nofollow" target="_blank"> CodeWorld </a>图形API展示了这个应用程序的Haskell代码。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/7b912316f7125e214c55514cfdc70ecf.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*sin_TIYlye-kx02I_CjAmQ.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">RPN计算器</figcaption></figure><p id="a06d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为CodeWorld是一个相对低级的图形API，我们将重新发明像数字输入字段这样的抽象。不要以为那是玻璃钢的基础部分！事实上，像reflex-dom这样的库为您提供了使用相同FRP的传统高级组件库的所有功能。但是我认为从零开始是一个很好的学习经历；我们可以看到如何从非常简单的原语开始构建更高级别的组件，并且您可以在自己的代码中应用相同的抽象技术来构建特定于应用程序的抽象。</p><p id="29f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在本系列结束时获得的计算器位于以下链接:</p><div class="ky kz gp gr la lb"><a href="https://code.world/haskell#PP_y0l9mQepdeIvwDXWfNOQ" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd ir gy z fp lg fr fs lh fu fw ip bi translated">Reflex和CodeWorld中的RPN计算器</h2><div class="li l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">代码.世界</p></div></div></div></a></div><p id="93fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它肯定有一些不足之处:</p><ul class=""><li id="bcf8" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">缺乏非常精确的数字。</li><li id="e732" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">您不能输入负数。</li><li id="359c" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">许多重要的操作都丢失了。</li></ul><p id="4d49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为感兴趣的读者考虑这些练习。我只实现了足够的抽象技术，从来没有打算把它变成一个产品质量计算器！</p><h2 id="7035" class="lx ly iq bd lz ma mb dn mc md me dp mf jy mg mh mi kc mj mk ml kg mm mn mo mp bi translated">基本定义</h2><p id="d20c" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">如果你不熟悉FRP，这个想法是根据两个抽象来建模你的软件的交互部分:<em class="mv">事件</em>和<em class="mv">行为</em>。<em class="mv">事件</em>是发生在离散时刻的事情，例如按键或鼠标点击。(如果你习惯于传统的GUI编程，请注意:在FRP中，一个事件不是一件事情的单次<em class="mv">发生</em>，而是可能发生多次的整个<em class="mv">事件。)一个<em class="mv">行为</em>是一个随时间变化的值，比如鼠标位置。(同样，一个行为并不是某个特定的</em>时间的值，而是整个<em class="mv">概念，就像鼠标位置会随着时间而变化。)</em></p><p id="cf35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Reflex增加了第三种抽象，是两者的混合体。<em class="mv">动态</em>值是仅在离散时间点改变的值。因为它确实随时间变化，所以它的当前值形成了一种<em class="mv">行为</em>。但是因为它在离散的时间点改变，它的更新形成了一个<em class="mv">事件</em>。</p><h2 id="345b" class="lx ly iq bd lz ma mb dn mc md me dp mf jy mg mh mi kc mj mk ml kg mm mn mo mp bi translated">从按钮开始</h2><p id="98b4" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">我们需要一个CodeWorld没有提供的计算器，那就是按钮！一方面，按钮是非常简单的东西:你点击它们，它们就会做一些事情。然而，正如我们将会看到的，获得一个直观和用户友好的按钮体验是不平凡的，值得抽象出来！</p><p id="b05e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个使用CodeWorld创建简单(不太用户友好)按钮的Reflex程序。</p><div class="ky kz gp gr la lb"><a href="https://code.world/haskell#Px5T48q9KCouvmkmmyGNHig" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd ir gy z fp lg fr fs lh fu fw ip bi translated">Reflex和CodeWorld中的简单按钮</h2><div class="li l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">代码.世界</p></div></div></div></a></div><p id="a464" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">源代码是:</p><pre class="kn ko kp kq gt mw mx my mz aw na bi"><span id="7461" class="lx ly iq mx b gy nb nc l nd ne">{-# LANGUAGE OverloadedStrings #-}</span><span id="9891" class="lx ly iq mx b gy nf nc l nd ne">import CodeWorld.Reflex<br/>import Control.Monad.IO.Class<br/>import Data.Functor (($&gt;))<br/>import Data.Text (Text)<br/>import Reflex</span><span id="280f" class="lx ly iq mx b gy nf nc l nd ne">button :: ReflexCodeWorld t m =&gt; Text -&gt; m (Event t ())<br/>button label =<br/>  do<br/>    draw (pure (rectangle 5 2 &lt;&gt; lettering label))<br/>    clicks &lt;- getPointerClick<br/>    return (ffilter inButton clicks $&gt; ())<br/>  where<br/>    inButton (x, y) = abs x &lt; 2.5 &amp;&amp; abs y &lt; 1</span><span id="639b" class="lx ly iq mx b gy nf nc l nd ne">foreign import javascript "window.alert('clicked!');"<br/>  notify :: IO ()</span><span id="3ac0" class="lx ly iq mx b gy nf nc l nd ne">app :: ReflexCodeWorld t m =&gt; m ()<br/>app = do<br/>  clicks &lt;- button "Click me!"<br/>  performEvent (clicks $&gt; liftIO notify)<br/>  return ()</span><span id="cc04" class="lx ly iq mx b gy nf nc l nd ne">main :: IO ()<br/>main = reflexOf app</span></pre><p id="907d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您已经做到这一步，您可能对OverloadedStrings很熟悉，它只是让我们在Haskell中为文本值编写字符串文字。其余的我现在会解释。</p><p id="6461" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，<em class="mv">按钮</em>的类型说你必须提供一个标签，你得到一个<em class="mv">事件</em>，它的发生是按钮点击。ReflexCodeWorld只是一个类，它封装了编写与CodeWorld交互的Reflex程序所需的所有约束。任何时候你需要使用CodeWorld类型访问基本的绘图和事件处理，你都需要这个类。按钮被吸引到屏幕上并监听鼠标点击，所以这里需要这个类。</p><p id="2ce9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mv">按钮</em>的实现通过使用一个名为<em class="mv"> draw </em>的函数在屏幕上绘制按钮。如果你查一下<em class="mv">画</em>的类型，就是<code class="fe ng nh ni mx b">ReflexCodeWorld t m =&gt; Dynamic t Picture -&gt; m ()</code>。<em class="mv">动态</em>图意味着你可以画一幅随时间变化的图。但在这种情况下，我们的按钮没有变化，所以我们使用<em class="mv">纯</em>绘制一个矩形和刻字的不变图片。下一个任务是确定按钮何时被单击。我们使用<em class="mv"> getPointerClick </em>来检索一个告诉我们鼠标何时被点击的事件，然后只过滤那些发生在按钮边界内的点击(使用<em class="mv"> ffilter </em>)，并用()(使用<code class="fe ng nh ni mx b">$&gt;</code>仿函数运算符)替换指针事件中的点，因为客户端并不关心哪个特定像素被点击。</p><p id="618c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一点上，你可能开始想知道所有这些组合子是从哪里来的。与绘图和UI事件直接相关的事件来自代码世界。Reflex模块，其文档可以在<a class="ae kl" href="https://hackage.haskell.org/package/codeworld-api-0.6.0/docs/CodeWorld-Reflex.html" rel="noopener ugc nofollow" target="_blank">https://hackage . haskell . org/package/codeworld-API-0 . 6 . 0/docs/code world-reflex . html</a>中找到，或者通过单击code world选项卡中的Guide按钮找到。事件和行为的通用组合器来自Reflex，一个很好的参考是<a class="ae kl" href="https://github.com/reflex-frp/reflex/blob/develop/Quickref.md" rel="noopener ugc nofollow" target="_blank"> Reflex快速参考</a>。请记住，也有实例:事件、行为和动态都是函子，行为和动态也是适用的函子和单子。(注意，动态的monad实例可能很昂贵，所以尽可能避免它！)</p><p id="001a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就完成了按钮的一般实现。接下来，我使用JavaScript FFI定义一个简单的动作，这样我们就可以知道按钮事件何时触发，并使用<em class="mv"> performEvent </em>(另一个反射组合器)将IO动作附加到从<em class="mv">按钮</em>返回的事件。总而言之，<em class="mv"> reflexOf </em>是一个CodeWorld函数，它在CodeWorld环境中运行ReflexCodeWorld网络。</p><h2 id="c9f9" class="lx ly iq bd lz ma mb dn mc md me dp mf jy mg mh mi kc mj mk ml kg mm mn mo mp bi translated">打造更好的按钮</h2><p id="4784" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">这个按钮起作用了，但是它很丑而且功能有限。它总是相同的大小和位置，对用户按下它完全没有反应，并且通常不像用户习惯于现代用户界面中的按钮那样工作。我们可以做得更好！</p><p id="42f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，为了使大小和位置可配置，我们应该为按钮配置属性定义一个类型，并将所有这些选项捆绑在一起。看起来像这样:</p><pre class="kn ko kp kq gt mw mx my mz aw na bi"><span id="1e61" class="lx ly iq mx b gy nb nc l nd ne">data ButtonConfig = ButtonConfig<br/>  { buttonLocation :: Point,<br/>    buttonWidth :: Double,<br/>    buttonHeight :: Double,<br/>    buttonText :: Text<br/>  }</span></pre><p id="053a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重写<em class="mv">按钮</em>来获取一个ButtonConfig并在任意大小和位置呈现它自己是一个很简单的练习。看起来是这样的。</p><div class="ky kz gp gr la lb"><a href="https://code.world/haskell#PbmFTi_WhFj_mRHnwqGn3DQ" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd ir gy z fp lg fr fs lh fu fw ip bi translated">Reflex和CodeWorld中的可配置按钮</h2><div class="li l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">代码.世界</p></div></div></div></a></div><p id="328e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个按钮的源代码是:</p><pre class="kn ko kp kq gt mw mx my mz aw na bi"><span id="77de" class="lx ly iq mx b gy nb nc l nd ne">button :: ReflexCodeWorld t m =&gt; ButtonConfig -&gt; m (Event t ())<br/>button (ButtonConfig (x, y) w h label) =<br/>  do<br/>    draw (pure pic)<br/>    clicks &lt;- getPointerClick<br/>    return (ffilter inButton clicks $&gt; ())<br/>  where<br/>    inButton (xx, yy) = abs (xx - x) &lt; w / 2 &amp;&amp; abs (yy - y) &lt; h / 2<br/>    pic =<br/>      translated x y $<br/>        clipped w h (lettering label)<br/>          &lt;&gt; rectangle w h</span></pre><p id="5808" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我使用了名为<em class="mv">的CodeWorld函数翻译了</em>和<em class="mv">剪辑了</em>来移动按钮的视觉外观，并确保标签不会超出现在可配置的大小。除此之外，这都是直截了当的。</p><p id="40d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更复杂的是让按钮响应用户输入，并表现出现代用户界面中按钮的行为。如果您在您最喜欢的GUI程序中尝试一些按钮，您可能会注意到它们的行为如下:</p><ul class=""><li id="e129" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">当您的指针在按钮上时，可能有也可能没有悬停效果来指示。</li><li id="fd3b" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">当您按下指针时，按钮被按住，但是它的动作还没有被触发。</li><li id="86d6" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">如果您在释放前将指针拖离按钮，则动作是由<em class="mv">而不是</em>触发的。类似地，如果你点击其他地方并拖动到按钮上，动作是<em class="mv">而不是</em>触发的。</li><li id="48e7" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">只有当<em class="mv">在</em>按钮上<em class="mv">释放</em>指针，并且<em class="mv">和</em>在按钮上被按下时，按钮的动作才被触发。但是，无论指针被按住时是否暂时离开按钮，该操作都会触发。</li></ul><p id="cabd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那是一个复杂的行为！但最终，考虑到人类使用按钮的体验，每个细节都是合理的。我们希望在我们的按钮中复制这种行为。</p><p id="b286" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当处理这样一个复杂的问题时，我喜欢从命名开始！我以下面的代码结束，我将逐行解释。</p><pre class="kn ko kp kq gt mw mx my mz aw na bi"><span id="ca0a" class="lx ly iq mx b gy nb nc l nd ne">do<br/>  over &lt;- fmap inButton &lt;$&gt; getPointerPosition<br/>  down &lt;- isPointerDown<br/>  click &lt;- getPointerClick<br/>  lastAnchored &lt;- holdDyn False $ fmap inButton click<br/>  let anchored = (&amp;&amp;) &lt;$&gt; down &lt;*&gt; lastAnchored<br/>  let releases = ffilter not (updated anchored) $&gt; ()<br/>  let triggers = gate (current over) releases</span></pre><p id="1555" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事情是这样的:</p><ul class=""><li id="e967" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated"><em class="mv"> over </em>是一个动态布尔值，指示指针是否位于按钮上。我们从<em class="mv"> getPointerPosition </em>开始，这是一个动态指针，然后从上面fmap<em class="mv">in button</em>函数得到一个动态Bool。</li><li id="b529" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><em class="mv"> down </em>是一个动态布尔值，指示指针当前是否被按住，而不管它是否在按钮上。这是使用<em class="mv"> isPointerDown </em>定义的，它是一个CodeWorld反射原语。</li><li id="e2a5" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><em class="mv">点击</em>是指示指针被按下的事件，不管它是否在按钮上。与每个事件关联的值是指针被单击的点。这是使用<em class="mv"> getPointerClick </em>定义的，这也是一个CodeWorld反射原语。</li><li id="410b" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><em class="mv"> lastAnchored </em>是一个动态布尔值，它记住最后一次指针按压是否发生在按钮上。我们从所有的指针按下(<em class="mv"> click </em>)、fmap <em class="mv"> inButton </em>开始获取一个Bool值而不是Point值的事件，最后使用<em class="mv"> holdDyn </em>(一个标准的反射操作)来构建一个动态值，它会记住最近发生的事件。</li><li id="44fc" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><em class="mv"> anchored </em>是<em class="mv"> lastAnchored </em>和<em class="mv"> down </em>的组合，一个动态布尔值，它告诉是否有一个正在进行的指针按下开始于按钮之上。它使用应用运算符来组合两个更简单的值。</li><li id="6167" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><em class="mv"> releases </em>是一个事件，它将所有对<em class="mv">锚定的</em>的更新，然后只过滤掉那些将其更改为False的更新。这里，<em class="mv"> updated </em>是一个标准的反射组合器，它将更新事件提取为一个动态值。</li><li id="2b02" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">最后，<em class="mv">触发</em>门<em class="mv">释放</em>，只保留那些在按钮上发生的释放。在这里，<em class="mv"> current </em>是一个标准的反射组合器，它获取表示动态值的当前样本的行为。然后<em class="mv"> gate </em>是另一个标准的反射组合器，通过一个行为选通一个事件。</li></ul><p id="d7ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mv">触发</em>事件是我们想要的:一个代表按钮的效果应该被触发的精确时间的事件。</p><p id="8300" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们希望按钮的呈现根据状态而有所不同。具体来说，我们希望根据锚定在上的<em class="mv">和锚定在</em>上的<em class="mv">进行不同的渲染。为了实现这一点，我们将使用应用组合器向渲染函数传递参数，而不是使用纯<em class="mv">和<em class="mv">绘制</em>。</em></em></p><pre class="kn ko kp kq gt mw mx my mz aw na bi"><span id="8a63" class="lx ly iq mx b gy nb nc l nd ne">draw (render &lt;$&gt; anchored &lt;*&gt; over)</span></pre><p id="d4e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我选择的渲染函数使用这两个参数来选择按钮的背景颜色。</p><pre class="kn ko kp kq gt mw mx my mz aw na bi"><span id="37c2" class="lx ly iq mx b gy nb nc l nd ne">render anchored over =<br/>  translated x y $<br/>    clipped w h (lettering label)<br/>      &lt;&gt; rectangle w h<br/>      &lt;&gt; colored (color anchored over) (solidRectangle w h)</span><span id="b745" class="lx ly iq mx b gy nf nc l nd ne">color _ False = white<br/>color False True = RGB 0.9 0.9 0.9<br/>color True True = RGB 0.8 0.8 0.8</span></pre><p id="d77f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里玩“完成”按钮:</p><div class="ky kz gp gr la lb"><a href="https://code.world/haskell#Pmls2_rsLWm34f2wcF9CWmw" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd ir gy z fp lg fr fs lh fu fw ip bi translated">Reflex和CodeWorld中的高级按钮</h2><div class="li l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">代码.世界</p></div></div></div></a></div><p id="623e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个按钮的好处是API和之前的可配置按钮完全一样。使按钮行为更加用户友好的逻辑变化完全封装在可重用组件的实现中。尽管有一些非常激进的改变，比如触发鼠标释放的效果而不是鼠标按下的效果，但事实就是如此！这种抽象是可能的，因为事件抽象可用于用户定义的事件。</p><h2 id="ad19" class="lx ly iq bd lz ma mb dn mc md me dp mf jy mg mh mi kc mj mk ml kg mm mn mo mp bi translated">输入数字</h2><p id="d43c" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">下一个挑战是数字输入字段。因为这是一个计算器，所以输入数字是你能做的最重要的事情之一，这项任务变得有点复杂并不奇怪。我们确定了以下要求。</p><ul class=""><li id="0de5" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">如果还没有输入数字，我们可以输入一个带或不带小数点的数字，来输入这个数字。</li><li id="4794" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">我们可以将当前输入的数字设置为我们想要的任何数字。例如，数字输入字段有时充当堆栈的顶部元素，所以当我们从堆栈中弹出一个数字时，我们会将输入字段设置为该数字。</li><li id="14fa" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">也有可能没有输入数字。例如，在执行数学运算后，没有数字被输入。</li></ul><p id="e14e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据前面从button示例中学到的经验，我们将从一个配置结构开始，该结构给出了关于数字输入字段的配置选项。不过，还有一个新问题:</p><pre class="kn ko kp kq gt mw mx my mz aw na bi"><span id="5134" class="lx ly iq mx b gy nb nc l nd ne">data NumFieldConfig t = NumFieldConfig<br/>  { numFieldLocation :: Point,<br/>    numFieldWidth :: Double,<br/>    numFieldHeight :: Double,<br/>    setNumField :: Event t (Maybe Rational)<br/>  }</span></pre><p id="c6f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">什么是<em class="mv"> setNumField </em>？与按钮不同，我们需要能够在字段本身之外设置数字字段的值。我们在反射中这样做的方式是在中传递<em class="mv">控件需要知道的关于外部世界的信息，比如当外部世界希望它改变当前值时。附加到事件上的值是一个可能值，因为外界有可能(事实上，这是最常见的情况)想要将字段重置为根本不输入数字。</em></p><p id="8ab8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，构建数字字段的函数具有以下类型:</p><pre class="kn ko kp kq gt mw mx my mz aw na bi"><span id="7eb8" class="lx ly iq mx b gy nb nc l nd ne">numField ::<br/>  ReflexCodeWorld t m =&gt;<br/>  NumFieldConfig t -&gt;<br/>  m (Dynamic t (Maybe Rational))</span></pre><p id="336d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也就是说，您传入一个NumFieldConfig(包括一个用于设置该值的事件)，然后您得到一个动态的当前值(该值可能不存在，因此有可能)。</p><p id="22ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的一种方法可能是实现一个任意的文本输入字段，然后在需要值时从中解析一个数字。相反，我们将采取不同的策略:只要有当前的数字被编辑，就保持一个流水号。为了输入小数，除了数字本身之外，我们还需要跟踪是否输入了小数点，如果输入了小数点之后还有多少位小数(双关语)。因此，我们可以为数字字段的内部状态定义一个状态类型，如下所示:</p><pre class="kn ko kp kq gt mw mx my mz aw na bi"><span id="8d93" class="lx ly iq mx b gy nb nc l nd ne">data NumFieldState = NumFieldState<br/>  { numFieldValue :: Rational,<br/>    numFieldDecimalPlaces :: Maybe Int<br/>  }</span></pre><p id="6fe6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们需要实现这一点。我们将转向Reflex中状态机的一个非常常见的技巧:使用<em class="mv"> foldDyn </em>(一个标准的Reflex组合器)和函数应用操作符将状态转换函数的事件应用到初始状态。通过用函数组合合并许多较小的事件来构建事件。这一次是这样的:</p><pre class="kn ko kp kq gt mw mx my mz aw na bi"><span id="0b4c" class="lx ly iq mx b gy nb nc l nd ne">numField (NumFieldConfig (x, y) w h set) =<br/>  do<br/>    text &lt;- getTextEntry<br/>    key &lt;- getKeyPress<br/>    state &lt;-<br/>      foldDyn ($) Nothing $<br/>        mergeWith<br/>          (.)<br/>          [ const . fmap initState &lt;$&gt; set,<br/>            ffilter (== "0") text $&gt; digit 0,<br/>            ffilter (== "1") text $&gt; digit 1,<br/>            ffilter (== "2") text $&gt; digit 2,<br/>            ffilter (== "3") text $&gt; digit 3,<br/>            ffilter (== "4") text $&gt; digit 4,<br/>            ffilter (== "5") text $&gt; digit 5,<br/>            ffilter (== "6") text $&gt; digit 6,<br/>            ffilter (== "7") text $&gt; digit 7,<br/>            ffilter (== "8") text $&gt; digit 8,<br/>            ffilter (== "9") text $&gt; digit 9,<br/>            ffilter (== ".") text $&gt; dot,<br/>            ffilter (== "Backspace") key $&gt; backspace<br/>          ]<br/>    draw (render &lt;$&gt; state)<br/>    return (fmap numFieldValue &lt;$&gt; state)</span></pre><p id="15d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们过滤掉任何输入数字或点号、按退格键或使用配置中的事件设置当前值的时间。如上所述，当这些事情发生时，我们构造一个状态转移函数，并使用<em class="mv"> mergeWith </em>从合并的事件中产生它，使用函数组合来组合同时发生的事件。然后我们使用<em class="mv"> foldDyn </em>来折叠状态转换函数的事件，以获得一个动态的当前状态。</p><p id="8a49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里使用了四个辅助函数来构造状态转换:<em class="mv"> initState </em>、<em class="mv"> digit </em>、<em class="mv"> dot </em>和<em class="mv"> backspace </em>。还有一个辅助的<em class="mv">渲染</em>函数用于调用<em class="mv">绘制</em>。这些根本不使用任何反射功能，因为它们只是状态上的普通函数，并且它们也不使用任何新的CodeWorld函数。所以我不会一一解释，而是链接到一个包含完整代码的演示，您可以在闲暇时查看。</p><div class="ky kz gp gr la lb"><a href="https://code.world/haskell#PLvBvf4iLvSAXMz_rw9LXUA" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd ir gy z fp lg fr fs lh fu fw ip bi translated">Reflex和CodeWorld中的数字字段演示</h2><div class="li l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">代码.世界</p></div></div></div></a></div><p id="0f79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">stack display组件根本没有引入任何新概念，实际上是同一模式的一个更简单的应用程序，因为除了配置中的setter函数之外，它没有任何输入。我在这里省略了，但是你可以在最终的计算器程序中浏览它的代码。</p><h2 id="c069" class="lx ly iq bd lz ma mb dn mc md me dp mf jy mg mh mi kc mj mk ml kg mm mn mo mp bi translated">操作</h2><p id="9fe9" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">现在我们已经有了基本的组件，我们将开始把它们连接在一起。这里我们还可以定义一个特定于应用程序的抽象来使这个过程更加可组合:<em class="mv"> operations </em>。运算包括加法、减法等。但是它们也包括将值压入堆栈，将它们弹出堆栈，也许将来会更像dup、swap等。</p><p id="4516" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终，一个操作有两种效果:设置当前数量，和设置当前堆栈。</p><pre class="kn ko kp kq gt mw mx my mz aw na bi"><span id="a0bb" class="lx ly iq mx b gy nb nc l nd ne">data OpEffect t = OpEffect<br/>  { entryEffect :: Event t (Maybe Rational),<br/>    stackEffect :: Event t [Rational]<br/>  }</span></pre><p id="ec58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以开始看到这些是如何被设置为连接到数字字段和堆栈显示组件的，但是我们还有一些工作要做。一个操作只是影响数字字段和堆栈的一种方式，一个完整的计算器需要将许多不同的可能操作连接在一起。幸运的是，OpEffect形成了一个幺半群，这让我们可以将它们组合在一起！</p><pre class="kn ko kp kq gt mw mx my mz aw na bi"><span id="db01" class="lx ly iq mx b gy nb nc l nd ne">instance Reflex t =&gt; Semigroup (OpEffect t) where<br/>  OpEffect c1 s1 &lt;&gt; OpEffect c2 s2 =<br/>    OpEffect (leftmost [c1, c2]) (leftmost [s1, s2])</span><span id="d05b" class="lx ly iq mx b gy nf nc l nd ne">instance Reflex t =&gt; Monoid (OpEffect t) where<br/>  mempty = OpEffect never never</span></pre><p id="7455" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">空的OpEffect根本不会设置任何东西。为了合并两个操作效果，我们使用最左边的<em class="mv">来合并它们的效果。(如果两个效果同时触发，这个实现将优先选择左边的一个，放弃右边的一个，但是在这种情况下，不清楚什么是正确的行为，所以这是一个很好的选择。)</em></p><p id="8561" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一点值得一提:这里没有ReflexCodeWorld类；只是反射。这是因为我们已经超越了处理低级图形API的层次，正在构建与堆栈和数字交互的逻辑层。从这些RPN计算器的概念到绘图和指针事件的转换已经在前面实现了。缺少ReflexCodeWorld是我们在抽象方面成功的标志。</p><p id="afba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至此，我们可以开始实施操作了。例如，将当前数字字段值推送到堆栈上:</p><pre class="kn ko kp kq gt mw mx my mz aw na bi"><span id="4635" class="lx ly iq mx b gy nb nc l nd ne">pushStack ::<br/>  Reflex t =&gt;<br/>  Event t a -&gt;<br/>  Dynamic t (Maybe Rational) -&gt;<br/>  Dynamic t [Rational] -&gt;<br/>  OpEffect t<br/>pushStack occurred entryVal stackVal =<br/>  OpEffect<br/>    { entryEffect = occurred $&gt; Nothing,<br/>      stackEffect =<br/>        tag<br/>          ( (:)<br/>              &lt;$&gt; (fromMaybe 0 &lt;$&gt; current entryVal)<br/>              &lt;*&gt; current stackVal<br/>          )<br/>          occurred<br/>    }</span></pre><p id="231a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，<em class="mv">发生</em>是一个事件，表示我们希望<em class="mv">推栈</em>发生的时间。为了推送，我们需要访问以前的数字条目和堆栈，并且我们产生一个相应地设置新的数字条目和堆栈的操作效果。Reflex combinator <em class="mv">标签</em>在这里非常有用:它让我们获取事件的所有出现，并用一些行为替换事件值，我们可以从当前的数字输入字段和堆栈中构建这些行为。</p><p id="3bb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以从堆栈中弹出顶部的值，并用它替换数字输入字段。这是<em class="mv">标签</em>的另一个简单用法。请注意，我们需要以前的堆栈，但不需要以前的数字字段，因为我们将用一个新的字段清除它的值。</p><pre class="kn ko kp kq gt mw mx my mz aw na bi"><span id="2a91" class="lx ly iq mx b gy nb nc l nd ne">popStack ::<br/>  Reflex t =&gt;<br/>  Event t a -&gt;<br/>  Dynamic t [Rational] -&gt;<br/>  OpEffect t<br/>popStack occurred stackVal =<br/>  OpEffect<br/>    { entryEffect = tag (listToMaybe &lt;$&gt; current stackVal) occurred,<br/>      stackEffect = tag (drop 1 &lt;$&gt; current stackVal) occurred<br/>    }</span></pre><p id="47d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们将有许多修改堆栈的操作。我们希望它们以一致的方式工作:如果输入了一个当前的数字，首先将它压入堆栈并清除数字输入字段，然后在堆栈上执行操作。我们可以这样概括地说:</p><pre class="kn ko kp kq gt mw mx my mz aw na bi"><span id="cc3a" class="lx ly iq mx b gy nb nc l nd ne">stackOp ::<br/>  Reflex t =&gt;<br/>  ([Rational] -&gt; [Rational]) -&gt;<br/>  Event t a -&gt;<br/>  Dynamic t (Maybe Rational) -&gt;<br/>  Dynamic t [Rational] -&gt;<br/>  OpEffect t<br/>stackOp f occurred entryVal stackVal =<br/>  OpEffect<br/>    { entryEffect = occurred $&gt; Nothing,<br/>      stackEffect = tag (f &lt;$&gt; input) occurred<br/>    }<br/>  where<br/>    input =<br/>      (\s -&gt; maybe s (: s))<br/>        &lt;$&gt; current stackVal &lt;*&gt; current entryVal</span></pre><p id="53a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将需要一些二元运算(如加法和减法)和一些一元运算(如平方根)。让我们为它们制作包装器，这样我们可以更容易地定义具体的操作。</p><pre class="kn ko kp kq gt mw mx my mz aw na bi"><span id="1a9f" class="lx ly iq mx b gy nb nc l nd ne">binaryOp ::<br/>  Reflex t =&gt;<br/>  (Rational -&gt; Rational -&gt; Rational) -&gt;<br/>  Event t a -&gt;<br/>  Dynamic t (Maybe Rational) -&gt;<br/>  Dynamic t [Rational] -&gt;<br/>  OpEffect t<br/>binaryOp op = stackOp f<br/>  where<br/>    f (x : y : xs) = op y x : xs<br/>    f other = other</span><span id="9055" class="lx ly iq mx b gy nf nc l nd ne">unaryOp ::<br/>  Reflex t =&gt;<br/>  (Rational -&gt; Rational) -&gt;<br/>  Event t a -&gt;<br/>  Dynamic t (Maybe Rational) -&gt;<br/>  Dynamic t [Rational] -&gt;<br/>  OpEffect t<br/>unaryOp op = stackOp f<br/>  where<br/>    f (x : xs) = op x : xs<br/>    f other = other</span></pre><p id="8339" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这给了我们连接计算器所需的所有部件。</p><h2 id="d314" class="lx ly iq bd lz ma mb dn mc md me dp mf jy mg mh mi kc mj mk ml kg mm mn mo mp bi translated">把所有的放在一起</h2><p id="fbac" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">现在是时候将所有这些连接在一起了。因为我们的组件之间存在循环数据依赖，所以我们需要RecursiveDo语言扩展来实现这一点。这个扩展只是让我们定义do符号的递归块，其中绑定的值可以相互引用。然后我们把它全部插上:</p><pre class="kn ko kp kq gt mw mx my mz aw na bi"><span id="90ce" class="lx ly iq mx b gy nb nc l nd ne">calculator :: ReflexCodeWorld t m =&gt; m ()<br/>calculator = do<br/>  key &lt;- getKeyPress<br/>  text &lt;- getTextEntry</span><span id="99ab" class="lx ly iq mx b gy nf nc l nd ne">  sqrtButton &lt;- button (ButtonConfig (-3.5, -3) 3 1.25 "sqrt")<br/>  sinButton &lt;- button (ButtonConfig (0, -3) 3 1.25 "sin")<br/>  cosButton &lt;- button (ButtonConfig (3.5, -3) 3 1.25 "cos")</span><span id="d995" class="lx ly iq mx b gy nf nc l nd ne">  rec let OpEffect entryEff stackEff =<br/>            mconcat<br/>              [ pushStack (ffilter (== "Enter") key) num stk,<br/>                popStack (ffilter (== "Esc") key) stk,<br/>                binaryOp (+) (ffilter (== "+") text) num stk,<br/>                binaryOp (-) (ffilter (== "-") text) num stk,<br/>                binaryOp (*) (ffilter (== "*") text) num stk,<br/>                binaryOp (/) (ffilter (== "/") text) num stk,<br/>                unaryOp (approx sqrt) sqrtButton num stk,<br/>                unaryOp (approx sin) sinButton num stk,<br/>                unaryOp (approx cos) cosButton num stk<br/>              ]<br/>      num &lt;- numField (NumFieldConfig (0, 5) 10 1.5 entryEff)<br/>      stk &lt;- stack (StackConfig (0, 1) 10 6 stackEff)</span><span id="476b" class="lx ly iq mx b gy nf nc l nd ne">  return ()</span></pre><p id="1cf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">mconcat将所有单独的操作组合成一个组合效果，然后连接到数字字段和堆栈组件。为了证明这是可能的，我将一些操作绑定到了按键上，将一些操作绑定到了屏幕上的按钮上。操作代码不关心它的事件来自哪里，这就是为什么事件是一个很好的抽象。这将所有这些都结合到一个大计算器中，只剩下一个步骤:</p><pre class="kn ko kp kq gt mw mx my mz aw na bi"><span id="793a" class="lx ly iq mx b gy nb nc l nd ne">main :: IO ()<br/>main = reflexOf calculator</span></pre><p id="3025" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们完事了。</p><p id="e226" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里阅读最终的计算器代码:</p><div class="ky kz gp gr la lb"><a href="https://code.world/haskell#PP_y0l9mQepdeIvwDXWfNOQ" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd ir gy z fp lg fr fs lh fu fw ip bi translated">Reflex和CodeWorld中的RPN计算器</h2><div class="li l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">代码.世界</p></div></div></div></a></div></div></div>    
</body>
</html>