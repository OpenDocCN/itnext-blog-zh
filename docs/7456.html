<html>
<head>
<title>The new test framework built-in to Node.js 18.8.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js 18.8.0中内置的新测试框架</h1>
<blockquote>原文：<a href="https://itnext.io/the-new-test-framework-built-in-to-node-js-18-8-0-1d78315ac9f9?source=collection_archive---------0-----------------------#2022-09-29">https://itnext.io/the-new-test-framework-built-in-to-node-js-18-8-0-1d78315ac9f9?source=collection_archive---------0-----------------------#2022-09-29</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="c564" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph">节点。JS测试</h2><div class=""/><div class=""><h2 id="ff34" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">为Node.js应用程序创建测试套件的不依赖于需求的方式</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/acb1f01395fbd219dd9110a30b0870fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NB3iWEXq-T8uNWXs.png"/></div></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">图片由作者提供，使用官方Node.js徽标</figcaption></figure><p id="0de8" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><strong class="lk je">node . js v 18 . 8 . 0中新增的是一个高度令人想起Mocha的测试框架。它被标记为<em class="me">实验性的</em>,但是它指出了一个未来，我们的单元测试将不再需要像Mocha那样的外部依赖。</strong></p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><p id="f377" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">多年来，我一直在使用Mocha单元测试框架，以及Chai的断言风格。这是一个非常有用的组合，但是当设置一个测试套件时，你必须记住将这些包作为依赖项来安装。此外，您必须记住更新您的依赖关系，以捕捉更新。</p><p id="b324" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">如果有更简单的方法，比如在编程平台中内置一个测试框架，会怎么样？如果不需要安装任何额外的东西来编写单元测试，这可能会简化您的工作。</p><p id="7810" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">最近，我在Node.js中遇到了这样一个包。在为我正在开发的新包创建测试时，我键入了<code class="fe mm mn mo mp b">describe('test description')</code>，Visual Studio代码立即自动导入了以下内容:</p><pre class="kt ku kv kw gu mq mp mr ms aw mt bi"><span id="a441" class="mu mv iu mp b gz mw mx l my mz">import { describe } from 'node:test';</span></pre><p id="110d" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">这可能发生在许多其他开发人员身上，他们会想知道<code class="fe mm mn mo mp b">node:test</code>是什么。由于Visual Studio代码自动完成了这一点，当我们期望使用来自Mocha的<code class="fe mm mn mo mp b">describe</code>时，我们可能会最终使用它。有了摩卡，没有什么需要<code class="fe mm mn mo mp b">import</code>来获得<code class="fe mm mn mo mp b">describe</code>和<code class="fe mm mn mo mp b">it</code>功能。如果我们没有注意到这个新的导入，我们的测试输出会突然变得奇怪，导致混乱。</p><p id="2029" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">一种选择是简单地删除这个虚假的<code class="fe mm mn mo mp b">import</code>语句，继续使用Mocha。但是，同样的事情发生在<code class="fe mm mn mo mp b">it</code>函数上，并且每次我输入<code class="fe mm mn mo mp b">describe</code>或<code class="fe mm mn mo mp b">it</code>函数时都会发生。对于这篇文章，让我们看看发生了什么，看看<code class="fe mm mn mo mp b">node:test</code>框架是否有用。</p><p id="a4d0" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">这可能是您第一次看到带有<code class="fe mm mn mo mp b">node:</code>前缀的包名。这是Node.js中的新特性，似乎在Node.js 14中已经开始使用。它是烘焙到Node.js中的包的包名前缀。因为ES6 <code class="fe mm mn mo mp b">import</code>语句采用URL，所以<code class="fe mm mn mo mp b">node:</code>前缀被视为URL协议。结果就是你可以导入<code class="fe mm mn mo mp b">node:path</code>而不是<code class="fe mm mn mo mp b">path</code>。</p><p id="0967" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">这意味着存在一个新的内置模块<code class="fe mm mn mo mp b">node:test</code>。相关文档如下:</p><ul class=""><li id="01d2" class="na nb iu lk b ll lm lo lp lr nc lv nd lz ne md nf ng nh ni bi translated">试跑者:【https://nodejs.org/api/test.html】T21</li><li id="e442" class="na nb iu lk b ll nk lo nl lr nm lv nn lz no md nf ng nh ni bi translated">断言:<a class="ae nj" href="https://nodejs.org/api/assert.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/api/assert.html</a></li></ul><p id="8b35" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><code class="fe mm mn mo mp b">node:assert</code>模块一直在Node.js中。不依赖任何测试框架，用那个包编写单元测试总是可能的。测试框架的价值在于报告。例如，Mocha支持几种测试结果报告格式。新的<code class="fe mm mn mo mp b">node:test</code>框架支持TAP，一种古老的报告测试结果的格式。</p><p id="c6e6" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">与Mocha和Chai或其他第三方测试框架相比，<code class="fe mm mn mo mp b">node:assert</code>和<code class="fe mm mn mo mp b">node:test</code>的功能非常少。好处是这些都是内置的。</p><h1 id="56b9" class="np mv iu bd nq nr ns nt nu nv nw nx ny kj nz kk oa km ob kn oc kp od kq oe of bi translated">用<code class="fe mm mn mo mp b">node:test</code>和<code class="fe mm mn mo mp b">node:assert</code>设置测试</h1><p id="a1bd" class="pw-post-body-paragraph li lj iu lk b ll og ke ln lo oh kh lq lr oi lt lu lv oj lx ly lz ok mb mc md in bi translated">为了了解这一点，让我们创建几个虚拟测试。</p><p id="b443" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">下面显示的代码可以在GitHub上找到:<a class="ae nj" href="https://github.com/robogeek/node-test-examples" rel="noopener ugc nofollow" target="_blank">https://github.com/robogeek/node-test-examples</a></p><p id="c963" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">安装程序(确保安装了Node.js 18.8或更高版本之后):</p><pre class="kt ku kv kw gu mq mp mr ms aw mt bi"><span id="60b0" class="mu mv iu mp b gz mw mx l my mz">$ mkdir node-test<br/>$ npm init -y</span></pre><p id="b8c8" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">第一个优点是我们不需要安装任何其他东西。</p><p id="c314" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">创建一个名为<code class="fe mm mn mo mp b">test1.mjs</code>的文件，并键入以下内容:</p><pre class="kt ku kv kw gu mq mp mr ms aw mt bi"><span id="ba8f" class="mu mv iu mp b gz mw mx l my mz">import test from 'node:test';<br/>import * as assert from 'node:assert';</span></pre><p id="1b09" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">你现在用的是ES6模块格式，是吗？如果您愿意，Node.js文档显示了CJS模块格式。</p><p id="df21" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">注意一定要用<code class="fe mm mn mo mp b">node:test</code>而不是<code class="fe mm mn mo mp b">test</code>，因为后者不行。</p><pre class="kt ku kv kw gu mq mp mr ms aw mt bi"><span id="3124" class="mu mv iu mp b gz mw mx l my mz">test('simple-test', function() {<br/>    assert.strictEqual(1, 1);<br/>});<br/><br/>test('fail-test', function() {<br/>    assert.strictEqual(1, 2);<br/>});<br/><br/>test('async test', async () =&gt; {<br/>    let result = await new Promise((resolve, reject) =&gt; {<br/>        setImmediate(() =&gt; {<br/>          resolve(1);<br/>        });<br/>    });<br/>    assert.strictEqual(1, result);<br/>});</span></pre><p id="c734" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">我之前说过这个API类似于Mocha，它描述了使用<code class="fe mm mn mo mp b">describe</code>和<code class="fe mm mn mo mp b">it</code>函数的测试。这里我们使用一个名为<code class="fe mm mn mo mp b">test</code>的函数来描述测试。结构类似于Mocha <code class="fe mm mn mo mp b">it</code>函数，但函数名为<code class="fe mm mn mo mp b">test</code>。我们后面会看到<code class="fe mm mn mo mp b">describe</code>和<code class="fe mm mn mo mp b">it</code>的使用。</p><p id="e6af" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">除了使用这里显示的<code class="fe mm mn mo mp b">test</code>,您可以选择导入包，如下所示:</p><pre class="kt ku kv kw gu mq mp mr ms aw mt bi"><span id="0110" class="mu mv iu mp b gz mw mx l my mz">import * as test from 'node:test';<br/>import * as assert from 'node:assert';</span></pre><p id="5b99" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">如果这样做，执行<code class="fe mm mn mo mp b">node:test</code>包中的函数需要在函数前加上前缀<code class="fe mm mn mo mp b">test.</code>，所以在本例中，您将使用<code class="fe mm mn mo mp b">test.test(...)</code>而不是<code class="fe mm mn mo mp b">test(...)</code>。</p><p id="8371" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">一个明显的区别是这个框架允许使用轻量级的箭头函数，而Mocha要求使用普通函数。</p><p id="9397" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">要执行这些测试:</p><pre class="kt ku kv kw gu mq mp mr ms aw mt bi"><span id="1a1e" class="mu mv iu mp b gz mw mx l my mz">$ node --test test1.mjs<br/>TAP version 13<br/># Subtest: /home/david/Projects/nodejs/node-test/test1.mjs<br/>not ok 1 - /home/david/Projects/nodejs/node-test/test1.mjs<br/>  ---<br/>  duration_ms: 0.071377364<br/>  failureType: 'subtestsFailed'<br/>  exitCode: 1<br/>  stdout: |-<br/>    TAP version 13<br/>    # Subtest: simple-test<br/>    ok 1 - simple-test<br/>      ---<br/>      duration_ms: 0.001492959<br/>      ...<br/>    # Subtest: fail-test<br/>    not ok 2 - fail-test<br/>      ---<br/>      duration_ms: 0.001347439<br/>      failureType: 'testCodeFailure'<br/>      error: |-<br/>        Expected values to be strictly equal:<br/>        <br/>        1 !== 2<br/>        <br/>      code: 'ERR_ASSERTION'<br/>      stack: |-<br/>        TestContext.&lt;anonymous&gt; (file:///home/david/Projects/nodejs/node-test/test1.mjs:10:12)<br/>        Test.runInAsyncScope (node:async_hooks:203:9)<br/>        Test.run (node:internal/test_runner/test:483:25)<br/>        Test.processPendingSubtests (node:internal/test_runner/test:249:27)<br/>        Test.postRun (node:internal/test_runner/test:553:19)<br/>        Test.run (node:internal/test_runner/test:511:10)<br/>      ...<br/>    # Subtest: async test<br/>    ok 3 - async test<br/>      ---<br/>      duration_ms: 0.002986099<br/>      ...<br/>    1..3<br/>    # tests 3<br/>    # pass 2<br/>    # fail 1<br/>    # cancelled 0<br/>    # skipped 0<br/>    # todo 0<br/>    # duration_ms 0.057180525<br/>    <br/>  stderr: |-<br/>    (node:1638685) ExperimentalWarning: The test runner is an experimental feature. This feature could change at any time<br/>    (Use `node --trace-warnings ...` to show where the warning was created)<br/>    <br/>  error: 'test failed'<br/>  code: 'ERR_TEST_FAILURE'<br/>  ...<br/>1..1<br/># tests 1<br/># pass 0<br/># fail 1<br/># cancelled 0<br/># skipped 0<br/># todo 0<br/># duration_ms 0.134320729</span></pre><p id="862e" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">运行测试需要<code class="fe mm mn mo mp b">--test</code>标志。使用这个选项，Node.js将搜索测试模块。但是我已经在命令行中明确地命名了测试模块。在这种情况下，Node.js将只执行指定的测试模块。</p><p id="0638" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">测试结果以TAP格式打印。TAP代表<em class="me">测试任何东西协议</em>，在<a class="ae nj" href="https://en.wikipedia.org/wiki/Test_Anything_Protocol" rel="noopener ugc nofollow" target="_blank">维基百科</a>上有一篇很好的文章。</p><p id="10df" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">TAP输出格式对人不友好，其设计目的是向报告软件提供测试结果数据。我发现很难处理这些结果，尤其是失败。</p><p id="3c23" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">到目前为止，这些测试都是顶级的。我们经常想增加层次来帮助理解:</p><pre class="kt ku kv kw gu mq mp mr ms aw mt bi"><span id="0704" class="mu mv iu mp b gz mw mx l my mz">test('test container', () =&gt; {<br/>    test('test 1', () =&gt; { assert.equal(1, 1); });<br/>    test('test 2', () =&gt; { assert.equal(2, 2); });<br/>});</span></pre><p id="f1a0" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">另一个我不知道我想要但由<code class="fe mm mn mo mp b">node:test</code>框架提供的东西是跳过测试的能力。</p><pre class="kt ku kv kw gu mq mp mr ms aw mt bi"><span id="2bb6" class="mu mv iu mp b gz mw mx l my mz">test('SKIP', { skip: true }, () =&gt; { assert.equal(1, 1); });<br/>test.skip('SKIP2', () =&gt; { assert.equal(1, 1); });</span></pre><p id="cfd8" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">在第一种形式中，在测试名称和测试函数之间传递的对象用于传递选项。其中一个选项<code class="fe mm mn mo mp b">skip</code>表示忽略(跳过)这个测试。使用<code class="fe mm mn mo mp b">.skip</code>达到同样的目的。</p><h1 id="df8d" class="np mv iu bd nq nr ns nt nu nv nw nx ny kj nz kk oa km ob kn oc kp od kq oe of bi translated">使用<code class="fe mm mn mo mp b">describe</code>和<code class="fe mm mn mo mp b">it</code>，就像使用摩卡一样</h1><p id="dea5" class="pw-post-body-paragraph li lj iu lk b ll og ke ln lo oh kh lq lr oi lt lu lv oj lx ly lz ok mb mc md in bi translated">如前所述，<code class="fe mm mn mo mp b">node:test</code>有<code class="fe mm mn mo mp b">describe</code>和<code class="fe mm mn mo mp b">it</code>功能，类似于摩卡提供的功能。</p><p id="60ee" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">创建一个名为<code class="fe mm mn mo mp b">test-describe.mjs</code>的新文件，包含:</p><pre class="kt ku kv kw gu mq mp mr ms aw mt bi"><span id="ec43" class="mu mv iu mp b gz mw mx l my mz">import { describe, it } from 'node:test';<br/>import * as assert from 'node:assert';<br/><br/>describe('Describe Container', function() {<br/><br/>    it('should equal 1 and 1', () =&gt; { assert.equal(1, 1); });<br/>    it('should equal 2 and 2', () =&gt; { assert.equal(2, 2); });<br/>    it('should FAIL equal 1 and 3', () =&gt; { assert.equal(1, 3); });<br/>});</span></pre><p id="a83d" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">将<code class="fe mm mn mo mp b">import</code>语句改为导入这些函数，而不是导入整个<code class="fe mm mn mo mp b">test</code>包。</p><p id="4c71" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">一个有趣的实验是注释掉<code class="fe mm mn mo mp b">node:test</code>的<code class="fe mm mn mo mp b">import</code>，然后使用Mocha运行测试套件。除了使用轻量级函数进行测试之外，测试套件将在Mocha下工作。</p><p id="c65d" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">例如，options对象可用于<code class="fe mm mn mo mp b">describe</code>和<code class="fe mm mn mo mp b">it</code>，以支持跳过测试。您也可以根据需要使用<code class="fe mm mn mo mp b">describe.skip</code>和<code class="fe mm mn mo mp b">it.skip</code>。</p><h1 id="888d" class="np mv iu bd nq nr ns nt nu nv nw nx ny kj nz kk oa km ob kn oc kp od kq oe of bi translated">试图使用<code class="fe mm mn mo mp b">before</code>、<code class="fe mm mn mo mp b">beforeEach</code>、<code class="fe mm mn mo mp b">after</code>和<code class="fe mm mn mo mp b">afterEach</code></h1><p id="253a" class="pw-post-body-paragraph li lj iu lk b ll og ke ln lo oh kh lq lr oi lt lu lv oj lx ly lz ok mb mc md in bi translated">Mocha中另一组有用的测试函数是<code class="fe mm mn mo mp b">before</code>、<code class="fe mm mn mo mp b">beforeEach</code>、<code class="fe mm mn mo mp b">after</code>和<code class="fe mm mn mo mp b">afterEach</code>。这些函数在测试函数之前和之后执行，对于设置和删除测试条件非常有用。</p><p id="d3e0" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">根据Node.js文档，可以创建一个名为<code class="fe mm mn mo mp b">test-before.mjs</code>的文件，如下所示:</p><pre class="kt ku kv kw gu mq mp mr ms aw mt bi"><span id="001e" class="mu mv iu mp b gz mw mx l my mz">import {<br/>    describe, it, before, beforeEach, after, afterEach<br/>} from 'node:test';<br/>import * as assert from 'node:assert';<br/><br/>let did_before = false;<br/>let did_before_each = 0;<br/>let did_after = false;<br/>let did_after_each = 0;<br/><br/>function print_status(stage) {<br/>    console.log(`${stage}: before ${did_before} before_each ${did_before_each} after ${did_after} after_each ${did_after_each}`);<br/>}<br/><br/>describe('Describe Container', function() {<br/>    before(() =&gt; {<br/>        did_before = true;<br/>        print_status('BEFORE');<br/>        // console.log('IN BEFORE');<br/>    });<br/>    beforeEach(() =&gt; {<br/>        did_before_each++;<br/>        print_status('BEFORE EACH');<br/>        // console.log('IN BEFORE EACH');<br/>    });<br/><br/>    after(() =&gt; {<br/>        did_after = true;<br/>        print_status('AFTER');<br/>        // console.log('IN AFTER');<br/>    });<br/>    afterEach(() =&gt; {<br/>        did_after_each++;<br/>        print_status('AFTER EACH');<br/>        // console.log('IN AFTER EACH');<br/>    });<br/><br/>    it('should equal 1 and 1', () =&gt; {<br/>        console.log('1 and 1');<br/>        assert.equal(1, 1);<br/>        // assert.equal(did_before, true);<br/>        // assert.equal(did_before_each &gt; 1, true);<br/>    });<br/>    it('should equal 2 and 2', () =&gt; {<br/>        console.log('2 and 2');<br/>        assert.equal(2, 2);<br/>        // assert.equal(did_after, false);<br/>        // assert.equal(did_after_each &gt; 1, true);<br/>    });<br/><br/>});<br/><br/>print_status('FINISH');</span></pre><p id="0dbe" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">根据文档，这应该可以工作。但是，困惑仍然存在，尤其是如果所有测试都成功的话。因此，这个测试有过多的代码一次演示几件事情。</p><p id="07f0" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">首先，输出非常简洁，没有显示来自子测试的任何信息:</p><pre class="kt ku kv kw gu mq mp mr ms aw mt bi"><span id="a77e" class="mu mv iu mp b gz mw mx l my mz">$ node --test test-before.mjs <br/>TAP version 13<br/># Subtest: /home/david/Projects/nodejs/node-test/test-before.mjs<br/>ok 1 - /home/david/Projects/nodejs/node-test/test-before.mjs<br/>  ---<br/>  duration_ms: 0.069937654<br/>  ...<br/>1..1<br/># tests 1<br/># pass 1<br/># fail 0<br/># cancelled 0<br/># skipped 0<br/># todo 0<br/># duration_ms 0.130741092</span></pre><p id="c6d1" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">这可能与TAP结果格式有关。它似乎只显示顶级测试的结果。但是，我相信我们想要知道每个测试套件运行中每个测试用例的状态。</p><p id="de90" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">其次，<code class="fe mm mn mo mp b">console.log</code>输出怎么了？在Mocha中<code class="fe mm mn mo mp b">console.log</code>被简单地打印到终端，但是这里没有显示。</p><p id="f3c8" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">我们如何知道<code class="fe mm mn mo mp b">before</code> / <code class="fe mm mn mo mp b">after</code>函数被执行了？在这个例子中，我添加了额外的状态变量，我们可以插入<code class="fe mm mn mo mp b">assert</code>函数来检查状态。取消对这些<code class="fe mm mn mo mp b">assert</code>调用的注释让我们看到状态变量确实发生了变化，表明<code class="fe mm mn mo mp b">before</code> / <code class="fe mm mn mo mp b">after</code>函数确实执行了。</p><p id="ca71" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">如果<code class="fe mm mn mo mp b">console.log</code>输出刚打印出来不是更方便吗？见本期问题队列:【https://github.com/nodejs/node/issues/44372 T21】</p><p id="5b34" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">您可以取消注释的断言之一确实失败了:<code class="fe mm mn mo mp b">assert.equal(did_after_each &gt; 1, true)</code>，这使我们有机会看到输出包含了<code class="fe mm mn mo mp b">console.log</code>输出。具体来说，子测试的数据只有在测试失败时才可见。如果测试失败，<code class="fe mm mn mo mp b">node:test</code>打印所有子测试的结果，包括<code class="fe mm mn mo mp b">console.log</code>输出。</p><pre class="kt ku kv kw gu mq mp mr ms aw mt bi"><span id="85c1" class="mu mv iu mp b gz mw mx l my mz">TAP version 13<br/># Subtest: /home/david/Projects/nodejs/node-test/test-before.mjs<br/>not ok 1 - /home/david/Projects/nodejs/node-test/test-before.mjs<br/>  ---<br/>  duration_ms: 75.884131<br/>  failureType: 'subtestsFailed'<br/>  exitCode: 1<br/>  stdout: |-<br/>    FINISH: before false before_each 0 after false after_each 0<br/>    BEFORE: before true before_each 0 after false after_each 0<br/>    BEFORE EACH: before true before_each 1 after false after_each 0<br/>    1 and 1<br/>    AFTER EACH: before true before_each 1 after false after_each 1<br/>    BEFORE EACH: before true before_each 2 after false after_each 1<br/>    2 and 2<br/>    AFTER: before true before_each 2 after true after_each 1<br/>    TAP version 13<br/>    # Subtest: Describe Container<br/>        # Subtest: should equal 1 and 1<br/>        ok 1 - should equal 1 and 1<br/>          ---<br/>          duration_ms: 0.729738<br/>          ...<br/>        # Subtest: should equal 2 and 2<br/>        not ok 2 - should equal 2 and 2<br/>          ---<br/>          duration_ms: 1.389875<br/>          failureType: 'testCodeFailure'<br/>          error: 'false == true'<br/>          code: 'ERR_ASSERTION'<br/>          stack: |-<br/>            Object.&lt;anonymous&gt; (file:///home/david/Projects/nodejs/node-test/test-before.mjs:49:16)<br/>            ItTest.runInAsyncScope (node:async_hooks:203:9)<br/>            ItTest.run (node:internal/test_runner/test:483:25)<br/>            async Suite.processPendingSubtests (node:internal/test_runner/test:249:7)<br/>          ...<br/>        1..2<br/>    not ok 1 - Describe Container<br/>      ---<br/>      duration_ms: 6.009156<br/>      failureType: 'subtestsFailed'<br/>      error: '1 subtest failed'<br/>      code: 'ERR_TEST_FAILURE'<br/>      ...<br/>    1..1<br/>    # tests 1<br/>    # pass 0<br/>    # fail 1<br/>    # cancelled 0<br/>    # skipped 0<br/>    # todo 0<br/>    # duration_ms 13.041273<br/>    <br/>  stderr: |-<br/>    (node:2457472) ExperimentalWarning: The test runner is an experimental feature. This feature could change at any time<br/>    (Use `node --trace-warnings ...` to show where the warning was created)<br/>    <br/>  error: 'test failed'<br/>  code: 'ERR_TEST_FAILURE'<br/>  ...<br/>1..1<br/># tests 1<br/># pass 0<br/># fail 1<br/># cancelled 0<br/># skipped 0<br/># todo 0<br/># duration_ms 79.742712</span></pre><p id="de19" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">请注意，<code class="fe mm mn mo mp b">stdout |-</code>行之后是我们期望从<code class="fe mm mn mo mp b">console.log</code>语句中得到的输出。</p><p id="9af7" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">对于成功的测试，我们只看到一行读数<code class="fe mm mn mo mp b">duration_ms</code>。对于失败的测试，将打印更多信息，包括堆栈跟踪。</p><p id="a41e" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">只有当测试失败时，<code class="fe mm mn mo mp b">console.log</code>输出才可用。当测试失败时，测试结果会包含更多数据。</p><p id="439b" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">我想要的是在测试用例中插入跟踪的简单方法。当在Mocha中调试测试时，我插入<code class="fe mm mn mo mp b">console.log</code>语句来查看测试中有什么可用的。并不是说我是一个毫无头绪的新手程序员，因为我做这个已经几十年了。<code class="fe mm mn mo mp b">print</code>语句是一个非常有用的调试工具。你只需要记住在发送给客户之前删除所有的调试打印输出，等等。</p><p id="c260" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">原来<code class="fe mm mn mo mp b">console.log</code>未必是正确的做法。稍后我们将研究<code class="fe mm mn mo mp b">TestContext.diagnostic</code>函数。该功能允许我们将TAP结果中正确捕获的消息打印为诊断信息。这可能更正确地与TAP结果格式集成在一起。</p><h1 id="2be6" class="np mv iu bd nq nr ns nt nu nv nw nx ny kj nz kk oa km ob kn oc kp od kq oe of bi translated">如果所有测试都成功，为什么不打印<code class="fe mm mn mo mp b">it</code>结果？</h1><p id="be00" class="pw-post-body-paragraph li lj iu lk b ll og ke ln lo oh kh lq lr oi lt lu lv oj lx ly lz ok mb mc md in bi translated">前一节还有一个问题。TAP结果仅输出顶级测试的数据，不打印子测试的结果。为了理解我的意思，让我们回到前面显示的测试的修改版本。</p><pre class="kt ku kv kw gu mq mp mr ms aw mt bi"><span id="7611" class="mu mv iu mp b gz mw mx l my mz">import { describe, it } from 'node:test';<br/>import * as assert from 'node:assert';<br/><br/>describe('Describe Container', function() {<br/><br/>    it('should equal 1 and 1', () =&gt; { assert.equal(1, 1); });<br/>    it('should equal 2 and 2', () =&gt; { assert.equal(2, 2); });<br/>    /* it('should FAIL equal 1 and 3', () =&gt; {<br/>        assert.equal(1, 3); <br/>    }); */<br/>});</span></pre><p id="4d13" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">这里的每个<code class="fe mm mn mo mp b">it</code>测试都会成功，除了被注释掉的那个。运行该测试，您将看到以下输出:</p><pre class="kt ku kv kw gu mq mp mr ms aw mt bi"><span id="ae5f" class="mu mv iu mp b gz mw mx l my mz">$ npm run test:describe<br/><br/>&gt; node-test-examples@1.0.0 test:describe<br/>&gt; node --test test-describe.mjs<br/><br/>TAP version 13<br/># Subtest: /home/david/Projects/nodejs/node-test/test-describe.mjs<br/>ok 1 - /home/david/Projects/nodejs/node-test/test-describe.mjs<br/>  ---<br/>  duration_ms: 68.194493<br/>  ...<br/>1..1<br/># tests 1<br/># pass 1<br/># fail 0<br/># cancelled 0<br/># skipped 0<br/># todo 0<br/># duration_ms 71.352425</span></pre><p id="f404" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">我们被告知有一个测试，并且那个测试成功了，但是那是不准确的。有一个<code class="fe mm mn mo mp b">describe</code>包含两个<code class="fe mm mn mo mp b">it</code>测试。这难道不是一个包含两个测试的测试容器吗？那不应该是作为输出打印出来的吗？</p><p id="1c2e" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">取消对失败测试的注释，您会看到以下输出:</p><pre class="kt ku kv kw gu mq mp mr ms aw mt bi"><span id="fc10" class="mu mv iu mp b gz mw mx l my mz">TAP version 13<br/># Subtest: /home/david/Projects/nodejs/node-test/test-describe.mjs<br/>not ok 1 - /home/david/Projects/nodejs/node-test/test-describe.mjs<br/>  ---<br/>  duration_ms: 72.890198<br/>  failureType: 'subtestsFailed'<br/>  exitCode: 1<br/>  stdout: |-<br/>    TAP version 13<br/>    # Subtest: Describe Container<br/>        # Subtest: should equal 1 and 1<br/>        ok 1 - should equal 1 and 1<br/>          ---<br/>          duration_ms: 0.530474<br/>          ...<br/>        # Subtest: should equal 2 and 2<br/>        ok 2 - should equal 2 and 2<br/>          ---<br/>          duration_ms: 0.213345<br/>          ...<br/>        # Subtest: should FAIL equal 1 and 3<br/>        not ok 3 - should FAIL equal 1 and 3<br/>          ---<br/>          duration_ms: 1.318011<br/>          failureType: 'testCodeFailure'<br/>          error: '1 == 3'<br/>          code: 'ERR_ASSERTION'<br/>          stack: |-<br/>            Object.&lt;anonymous&gt; (file:///home/david/Projects/nodejs/node-test/test-describe.mjs:10:16)<br/>            ItTest.runInAsyncScope (node:async_hooks:203:9)<br/>            ItTest.run (node:internal/test_runner/test:483:25)<br/>            Suite.processPendingSubtests (node:internal/test_runner/test:249:27)<br/>            ItTest.postRun (node:internal/test_runner/test:567:19)<br/>            ItTest.run (node:internal/test_runner/test:511:10)<br/>            async Suite.processPendingSubtests (node:internal/test_runner/test:249:7)<br/>          ...<br/>        1..3<br/>    not ok 1 - Describe Container<br/>      ---<br/>      duration_ms: 5.370754<br/>      failureType: 'subtestsFailed'<br/>      error: '1 subtest failed'<br/>      code: 'ERR_TEST_FAILURE'<br/>      ...<br/>    1..1<br/>    # tests 1<br/>    # pass 0<br/>    # fail 1<br/>    # cancelled 0<br/>    # skipped 0<br/>    # todo 0<br/>    # duration_ms 11.093222<br/>    <br/>  stderr: |-<br/>    (node:2435157) ExperimentalWarning: The test runner is an experimental feature. This feature could change at any time<br/>    (Use `node --trace-warnings ...` to show where the warning was created)<br/>    <br/>  error: 'test failed'<br/>  code: 'ERR_TEST_FAILURE'<br/>  ...<br/>1..1<br/># tests 1<br/># pass 0<br/># fail 1<br/># cancelled 0<br/># skipped 0<br/># todo 0<br/># duration_ms 77.252073</span></pre><p id="787e" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">这一次打印子测试信息，包括失败的测试。子测试信息不应该总是打印出来吗？</p><p id="4181" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">我对TAP不是很熟悉，可能这就是TAP的设计用途。但是看这个用户体验，我想一直知道所有测试用例的状态。如果测试结果被输入到报告系统中，这一点尤其正确。</p><h1 id="6ba8" class="np mv iu bd nq nr ns nt nu nv nw nx ny kj nz kk oa km ob kn oc kp od kq oe of bi translated">测试诊断允许跟踪执行和数据值</h1><p id="5797" class="pw-post-body-paragraph li lj iu lk b ll og ke ln lo oh kh lq lr oi lt lu lv oj lx ly lz ok mb mc md in bi translated">之前我们看到<code class="fe mm mn mo mp b">console.log</code>输出没有像我预期的那样被处理。它不会简单地出现在控制台上，只有当测试失败时，您才能查看它。</p><p id="bfad" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><code class="fe mm mn mo mp b">node:test</code>框架包含一个与<code class="fe mm mn mo mp b">console.log</code>大致相当的特性，但是与TAP结果格式集成得更好。</p><p id="831e" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">考虑:</p><pre class="kt ku kv kw gu mq mp mr ms aw mt bi"><span id="559f" class="mu mv iu mp b gz mw mx l my mz">import { test } from 'node:test';<br/>import * as assert from 'node:assert';<br/><br/>test('Describe Container', async function(t) {<br/><br/>    t.beforeEach((t) =&gt; {<br/>        t.diagnostic(`DIAG before ${t.name}`);<br/>    });<br/><br/>    t.afterEach((t) =&gt; {<br/>        t.diagnostic(`DIAG after ${t.name}`);<br/>    });<br/><br/>    await t.test('should equal 1 and 1', () =&gt; { assert.equal(1, 1); });<br/>    await t.test('should equal 2 and 2', () =&gt; { assert.equal(2, 2); });<br/>    /* await t.test('should FAIL equal 1 and 3', (t) =&gt; {<br/>        t.diagnostic(`In FAIL test ${t.name}`);<br/>        assert.equal(1, 3); <br/>    }); */<br/><br/>});</span></pre><p id="61d3" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><code class="fe mm mn mo mp b">test</code>函数回调的参数<code class="fe mm mn mo mp b">t</code>是<code class="fe mm mn mo mp b">TestContext</code>类的一个实例。文档说这个类不能被测试作者实例化。相反，<code class="fe mm mn mo mp b">test</code>函数回调将它作为参数接收。<code class="fe mm mn mo mp b">t</code>参数不适用于<code class="fe mm mn mo mp b">it</code>功能，仅适用于<code class="fe mm mn mo mp b">test</code>功能。</p><p id="455e" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><code class="fe mm mn mo mp b">t.beforeEach</code>和<code class="fe mm mn mo mp b">t.afterEach</code>功能等同于<code class="fe mm mn mo mp b">beforeEach</code>和<code class="fe mm mn mo mp b">afterEach</code>，意味着它们在每次测试调用之前和之后被执行。并且，不嵌套<code class="fe mm mn mo mp b">it</code>或<code class="fe mm mn mo mp b">test</code>调用，而是使用<code class="fe mm mn mo mp b">t.test</code>。还要注意，对于一个<code class="fe mm mn mo mp b">async</code>外部函数，我们必须在<code class="fe mm mn mo mp b">t.test</code>函数调用中使用<code class="fe mm mn mo mp b">await</code>。</p><p id="adc5" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><code class="fe mm mn mo mp b">t.diagnosic</code>功能允许我们将TAP诊断写入输出。换句话说，它类似于我通常用<code class="fe mm mn mo mp b">console.log</code>做的事情，但是集成了TAP输出。</p><p id="f91e" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">要查看诊断输出，必须有一个失败的测试。正如我们前面所说的，要看到完整的测试结果，必须有一个失败的测试。这也控制是否打印诊断输出。取消对此处显示的失败测试的注释，您将看到以下输出:</p><pre class="kt ku kv kw gu mq mp mr ms aw mt bi"><span id="9c83" class="mu mv iu mp b gz mw mx l my mz">TAP version 13<br/># Subtest: /home/david/Projects/nodejs/node-test/test-diagnostic.mjs<br/>not ok 1 - /home/david/Projects/nodejs/node-test/test-diagnostic.mjs<br/>  ---<br/>  duration_ms: 75.932386<br/>  failureType: 'subtestsFailed'<br/>  exitCode: 1<br/>  stdout: |-<br/>    TAP version 13<br/>    # Subtest: Describe Container<br/>        # Subtest: should equal 1 and 1<br/>        ok 1 - should equal 1 and 1<br/>          ---<br/>          duration_ms: 1.290981<br/>          ...<br/>        # DIAG before should equal 1 and 1<br/>        # DIAG after should equal 1 and 1<br/>        # Subtest: should equal 2 and 2<br/>        ok 2 - should equal 2 and 2<br/>          ---<br/>          duration_ms: 0.365355<br/>          ...<br/>        # DIAG before should equal 2 and 2<br/>        # DIAG after should equal 2 and 2<br/>        # Subtest: should FAIL equal 1 and 3<br/>        not ok 3 - should FAIL equal 1 and 3<br/>          ---<br/>          duration_ms: 1.349598<br/>          failureType: 'testCodeFailure'<br/>          error: '1 == 3'<br/>          code: 'ERR_ASSERTION'<br/>          stack: |-<br/>            TestContext.&lt;anonymous&gt; (file:///home/david/Projects/nodejs/node-test/test-diagnostic.mjs:20:16)<br/>            Test.runInAsyncScope (node:async_hooks:203:9)<br/>            Test.run (node:internal/test_runner/test:483:25)<br/>            async TestContext.&lt;anonymous&gt; (file:///home/david/Projects/nodejs/node-test/test-diagnostic.mjs:18:5)<br/>            async Test.run (node:internal/test_runner/test:484:9)<br/>          ...<br/>        # DIAG before should FAIL equal 1 and 3<br/>        # In FAIL test should FAIL equal 1 and 3<br/>        1..3<br/>    not ok 1 - Describe Container<br/>      ---<br/>      duration_ms: 6.449412<br/>      failureType: 'subtestsFailed'<br/>      error: '1 subtest failed'<br/>      code: 'ERR_TEST_FAILURE'<br/>      ...<br/>    1..1<br/>    # tests 1<br/>    # pass 0<br/>    # fail 1<br/>    # cancelled 0<br/>    # skipped 0<br/>    # todo 0<br/>    # duration_ms 12.896941<br/>    <br/>  stderr: |-<br/>    (node:2436416) ExperimentalWarning: The test runner is an experimental feature. This feature could change at any time<br/>    (Use `node --trace-warnings ...` to show where the warning was created)<br/>    <br/>  error: 'test failed'<br/>  code: 'ERR_TEST_FAILURE'<br/>  ...<br/>1..1<br/># tests 1<br/># pass 0<br/># fail 1<br/># cancelled 0<br/># skipped 0<br/># todo 0<br/># duration_ms 81.035372</span></pre><p id="2675" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">诊断输出打印有<code class="fe mm mn mo mp b">#</code>前缀。我们只能看到失败测试用例的诊断输出，而不能看到成功测试用例的诊断输出。以前<code class="fe mm mn mo mp b">console.log</code>输出以<code class="fe mm mn mo mp b">stdout |-</code>开始分段打印。</p><p id="1f18" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">因此,<code class="fe mm mn mo mp b">t.diagnostic</code>调用的行为类似于<code class="fe mm mn mo mp b">console.log</code>,但看起来与TAP的集成更加正确。</p><h1 id="e074" class="np mv iu bd nq nr ns nt nu nv nw nx ny kj nz kk oa km ob kn oc kp od kq oe of bi translated">摘要</h1><p id="d462" class="pw-post-body-paragraph li lj iu lk b ll og ke ln lo oh kh lq lr oi lt lu lv oj lx ly lz ok mb mc md in bi translated">将<code class="fe mm mn mo mp b">node:test</code>添加到Node.js给了我们一个最小的测试框架。虽然它不像摩卡和柴那样功能齐全，但它可以立即使用。</p><p id="a804" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">为什么要把这个特性带入Node.js的核心？我在Bun项目中看到了类似的问题，有人提议在Bun中添加一个YAML解析器/序列化器。像Node.js，或者Bun，或者PHP，或者Python这样的平台，应该增加每一个可能的特性吗？每个添加的特性都会使平台变得更大，并为项目团队带来更多的管理开销，因为他们必须维护/测试/更新/升级该特性。</p><p id="1851" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">为什么测试框架应该内置到核心平台中？我不太明白其中的道理。在核心平台中包含YAML支持的理由更加充分，因为许多应用程序需要读/写YAML文件。但是，我仍然不明白为什么在有大量YAML实现的情况下还必须添加YAML。这同样适用于测试框架，因为安装一个充满特性的框架很容易。</p><p id="ed77" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">对PHP、Java和Python文档的快速检查并没有显示内置的测试框架。在某些情况下，有<code class="fe mm mn mo mp b">assert</code>语句，但是没有组织测试的框架。</p><p id="f3a0" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">作为Node.js或者Bun的用户，我希望平台尽可能的健壮。这意味着项目团队应该关注最重要的特性。添加一个测试框架足够重要吗？或者添加一个测试框架会分散注意力吗？</p><p id="2131" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">我相信Node.js团队已经讨论过这个问题了。他们选择将一个简单的测试框架整合到平台中，这说明这样做是有道理的。</p><p id="8dca" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">用过这个之后，我发现还缺少什么:</p><ul class=""><li id="bb90" class="na nb iu lk b ll lm lo lp lr nc lv nd lz ne md nf ng nh ni bi translated">选择<code class="fe mm mn mo mp b">console.log</code>输出或其他调试输出，简单地显示在终端上。</li><li id="dbd0" class="na nb iu lk b ll nk lo nl lr nm lv nn lz no md nf ng nh ni bi translated">其他测试结果格式的第三方插件系统。我特别想要一种人类可读的结果格式，就像Mocha提供的默认格式。这应该由第三方提供，以最小化Node.js平台上的膨胀。</li></ul><p id="3636" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">应该放弃Mocha或其他现有的测试框架吗？这不太可能，因为现有的框架提供了更多的功能。由于<code class="fe mm mn mo mp b">node:test</code>框架应该保持最小化以最小化平台膨胀，它不太可能获得足够的特性来与第三方框架竞争。这意味着现有的第三方框架将保持相关性，因为它们有更多的自由来添加任何所需的功能。</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h2 id="57c0" class="mu mv iu bd nq ol om dn nu on oo dp ny lr op oq oa lv or os oc lz ot ou oe ja bi translated">关于作者</h2><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj ov"><img src="../Images/6cdaaeee8f95f8538c0b4ef57f68c14b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*byPxSLlNJPwEr91s.jpg"/></div></figure><p id="bb6c" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><a class="ae nj" href="https://davidherron.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lk je">大卫·赫伦</strong> </a> <strong class="lk je"> </strong>:大卫·赫伦是一名作家和软件工程师，专注于技术的明智使用。他对太阳能、风能和电动汽车等清洁能源技术特别感兴趣。David在硅谷从事了近30年的软件工作，包括电子邮件系统、视频流和Java编程语言，并出版了几本关于Node.js编程和电动汽车的书籍。</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><p id="2907" class="pw-post-body-paragraph li lj iu lk b ll lm ke ln lo lp kh lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><em class="me">最初发表于</em><a class="ae nj" href="https://techsparx.com/nodejs/testing/node-test.html" rel="noopener ugc nofollow" target="_blank"><em class="me">https://techsparx.com</em></a><em class="me">。</em></p></div></div>    
</body>
</html>