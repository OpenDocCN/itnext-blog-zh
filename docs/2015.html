<html>
<head>
<title>How To Validate HTTP Requests Before They Reach Lambda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在HTTP请求到达Lambda之前验证它们</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-validate-http-requests-before-they-reach-lambda-2fff68bfe93b?source=collection_archive---------1-----------------------#2019-03-17">https://itnext.io/how-to-validate-http-requests-before-they-reach-lambda-2fff68bfe93b?source=collection_archive---------1-----------------------#2019-03-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/875be1cbc22c8b8eea72a50a0857e6d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H4NJOl-yek-cysg_7MvUUA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">阿萨埃尔·培尼亚在<a class="ae kc" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="ff1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">如今，我正在写</em> <a class="ae kc" href="https://themirrorworld.substack.com" rel="noopener ugc nofollow" target="_blank"> <em class="lb">子栈</em> </a> <em class="lb">。</em></p><p id="4f77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将应用程序设计为无服务器功能的众多吸引力之一是，您可以花更多的时间编写核心应用程序逻辑。然而，默认情况下，当涉及到<a class="ae kc" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambdas </a>时，您仍然负责编写验证传递给Lambda函数的请求的功能。让我们看看如何将它交给<a class="ae kc" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank"> AWS API Gateway </a>，这样您就可以避免在您的函数中编写相同的样板验证代码。</p><p id="ab27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇简短的指南中，我将演示如何使用API Gateway和Lambda验证API请求。我们将建立一个简单的Lambda函数，将其连接到API Gateway，并在请求到达我们的函数之前对其进行验证。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="2102" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们想要创建一个API，用于查询您正在操作的不同自动驾驶车辆的状态。</p><p id="a027" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">抬头！本文中使用的代码片段可以通过这个要点</em>  <em class="lb">获得</em> <a class="ae kc" href="https://gist.github.com/tiivik/cf43b96357f28407fdcfc06179561673" rel="noopener ugc nofollow" target="_blank"> <em class="lb">。</em></a></p><h2 id="b982" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">设置Lambda函数</h2><ol class=""><li id="ce95" class="mc md iq kf b kg me kk mf ko mg ks mh kw mi la mj mk ml mm bi translated">从AWS Lambda控制台，点击<em class="lb">创建功能</em>并从头选择<em class="lb">作者</em>。在这种情况下，我们调用我们的函数<em class="lb"> Fleet </em>，选择<em class="lb"> Python 3.6 </em>作为我们的运行时环境，并为AWS创建一个名为<em class="lb">λrole</em>的新角色来设置该函数的权限。</li></ol><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/a86b2d3cdbb6fc3ae96571cd53e5f75e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rRDzchbTtzeh2aGz3v-Txw.png"/></div></div></figure><p id="1201" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.创建函数时，您会看到一些模板代码:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/eec1ed8d1d47713b635957f25a9608a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BR7t4S_QewvceGsjzE26cQ.png"/></div></div></figure><p id="f823" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.添加一些预先制作的数据。</p><p id="0a04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">出于本教程的目的，Lambda将包括一个带有一些预制数据的字典。我们可以看到，我们的车队中有两辆轿车和两辆卡车，每一类都有一辆<em class="lb">在途中</em>，另一辆<em class="lb">在待命</em>。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/035618eb8920a8bdc381a83adea9c750.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5DaEK_KgSlW1iwpcSFEPXw.png"/></div></div></figure><p id="dd8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4.获取请求的类别。</p><p id="e9f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们修改模板代码，以返回关于所请求类别的信息。我们的函数代码现在看起来像这样:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/4a66e7c5c314c8d6ef0776be207888b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mzWQL6agc558KY-hWLPhlw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">最终功能代码</figcaption></figure><p id="e2d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">5.在Lambda控制台中设置测试事件。点击<em class="lb">配置测试事件</em>。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/ec4726672dc1322947aef1a77fbea779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JMxpa3cz5AEsChcybW6GWw.png"/></div></div></figure><p id="ed5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在API Gateway中使用Lambda代理集成，它将把所有内容作为一个JSON文档传递给我们的后端资源(在本例中是我们的Lambda函数),包括整个资源路径，而不仅仅是事件体本身。这就是为什么我们在测试事件中包含“<em class="lb">body”</em>key:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/3209c28da0622423e9dbdda437c8fadc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KavJ41vUG0F3da7pcFpNDQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">λ测试事件</figcaption></figure><p id="fe22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们试着通过点击<em class="lb">测试</em>按钮来查询所有汽车的状态。您应该会看到以下响应，它向我们提供了车队中属于<em class="lb">【汽车】</em>类别的所有车辆的状态:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/3c7abe8f6e1dc5084239c94077c8c1cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7U7RKB57rz7eTghvrAyOiA.png"/></div></div></figure><p id="01ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们继续设置API网关之前，让我们查询一个在我们的数据字典中不存在的类别。</p><p id="2365" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">修改测试事件，改为查询类别<em class="lb">“列车”</em>:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/1e2d209dff6dd976497e7f25cf8890e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ANx6maK0ha_s1XKdZmSBA.png"/></div></div></figure><p id="1d1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">点击<em class="lb">测试</em>按钮，Lambda用Python <em class="lb"> KeyError </em>进行响应，因为<em class="lb">“trains”</em>键在我们的数据字典中不存在:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/d52bbd4e18cb3dbca610e215d683bf09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KzWAIgYhqD9GQCLsL1oBTA.png"/></div></div></figure><p id="21e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以编写应用程序逻辑来检查是否有一个KeyError，并在我们的函数中处理这个问题，或者我们可以探索如何首先验证什么到达我们的Lambda函数。让我们做后者。(<em class="lb">当然，在严重的情况下，您也可以在函数中进行异常处理)。</em></p><h2 id="7b36" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">设置API网关</h2><ol class=""><li id="7a96" class="mc md iq kf b kg me kk mf ko mg ks mh kw mi la mj mk ml mm bi translated">从AWS API网关控制台，点击<em class="lb">创建API </em>。选择<em class="lb"> REST </em>作为API类型，并将其命名为<em class="lb"> FleetAPI </em>:</li></ol><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/04cecd07dae002fe77d044de887c8c05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B4QRm2nQoZKhwr7WYcVjdQ.png"/></div></div></figure><p id="794c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.设置发布方法。</p><p id="8bb0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将<em class="lb">集成类型</em>设置为<em class="lb"> Lambda功能</em>，并确保点击<em class="lb">使用Lambda代理集成</em>。这使得与Lambda的集成变得无缝，因为它使请求能够被代理到Lambda，请求细节在我们的处理函数的事件中可用。在您创建函数的<em class="lb"> Lambda区域</em>中选择<em class="lb"> Lambda函数</em>。点击<em class="lb">保存</em>。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/7be6282a72df2951451ae86038225491.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rXQ6vXN8pbcu7EaKOXkJAQ.png"/></div></div></figure><p id="e85a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们在部署API之前测试它。</p><p id="82dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">点击API Gateway中的<em class="lb">客户端测试</em>按钮，并提供一个样本请求主体(注意这是主体本身的json对象)，您应该会收到Lambda的响应，向我们提供所有汽车的状态:</p><div class="mo mp mq mr gt ab cb"><figure class="mw jr mx my mz na nb paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/678924c25f10891141e5e338327c6f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*NxJG1obyFQKo3ZDeNEUdGQ.png"/></div></figure><figure class="mw jr nc my mz na nb paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/ce67b52e87164a2ff001f63630844415.png" data-original-src="https://miro.medium.com/v2/resize:fit:136/format:webp/1*m0KwMDLGFLKC0znci6mcvA.jpeg"/></div></figure><figure class="mw jr nd my mz na nb paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/14e2c2588f5c2e9f59b2778f15262ef8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*CFTrWT3eR2LwzHHYTib-mw.png"/></div></figure></div><p id="4098" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和以前一样，如果我们请求一个不存在的类别，Lambda函数将不能为我们提供一个成功的响应，而是用一个<em class="lb">内部服务器错误</em>来响应。</p><p id="bfe6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了避免这种情况，我们需要创建一个模型模式来定义API可以接受的主体结构。</p><h2 id="c11d" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">构建模型架构</h2><p id="083c" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">这将是一个JSON对象，它定义了HTTP请求体的预期结构。截至撰写本文时，AWS API Gateway使用的是<a class="ae kc" href="http://json-schema.org/" rel="noopener ugc nofollow" target="_blank"> JSON模式<em class="lb"> draft-04 </em> </a> <em class="lb">。</em></p><p id="6f88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在API Gateway控制台中选择<em class="lb"> Models </em>并创建一个名为<em class="lb"> FleetSchema </em>的新模型，其内容如下。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/656767d6973cef6b1f93b00e478f3f7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7BrrCXLP9QhrrEbalKOvgw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">模型模式</figcaption></figure><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/4db2f29f6f1325d4de3cca26dcd8585e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PKTsuSgPIdXnSNM6BsTD1g.png"/></div></div></figure><p id="07ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以看到<em class="lb"> enum </em>键定义了接受的类别— <em class="lb">“汽车”</em>和<em class="lb">“卡车”</em>。</p><p id="7206" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">值为<em class="lb">类别</em>的<em class="lb">必需</em>键定义了<em class="lb">类别</em>键必须在请求体中传递。</p><p id="afb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">导航到<em class="lb"> POST方法请求</em>，设置<em class="lb">请求主体</em>接受<em class="lb">申请/json </em>，并选择我们刚刚创建的<em class="lb"> FleetSchema </em>模型:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/d68394584c1630641f9de77d2917528e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ubNGMm-rpa6zuN2OLcaasg.png"/></div></div></figure><p id="875d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<em class="lb"> HTTP请求头</em>下设置<em class="lb">请求中需要的内容类型</em>头:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/43bb912a7661e99b45af232445cf6709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bvui-hE6u-g-0kx_plUDiA.png"/></div></div></figure><p id="902f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<em class="lb">请求验证器</em>下设置验证方法为<em class="lb">验证主体，查询字符串参数和头</em>:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/cfb81fdcc8e4bf93c01b7be8256c51e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kRCx1xehTp1A_m5HZ8Z59g.png"/></div></div></figure><p id="eb1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果您通过提供<em class="lb">“trains”</em>作为类别来测试API，请求主体将得到验证，而不是<em class="lb">内部服务器错误</em>，我们将得到<em class="lb">无效的请求主体</em>消息。请求没有传递给我们的Lambda函数。</p><div class="mo mp mq mr gt ab cb"><figure class="mw jr nl my mz na nb paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/5b74072fa800977357004b7eada78811.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*6GFIYYvsZ0i4vaPshvPLTQ.png"/></div></figure><figure class="mw jr nm my mz na nb paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/9a39d1c86fc35b814c5179c55c9023c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1462/format:webp/1*tvi4u7l_QCaR9zBAXFZSwg.png"/></div></figure></div><p id="0ee4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过一个可接受的类别(<em class="lb">“轿车”</em>或<em class="lb">“卡车”</em>)为我们提供了所需的信息。太好了！</p><div class="mo mp mq mr gt ab cb"><figure class="mw jr nn my mz na nb paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/c66d40967305b950c97bcef7da353738.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*j2maPz78_1N-ImVY04T8Ag.png"/></div></figure><figure class="mw jr no my mz na nb paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/b07ec0331bef725024a31b1b806b6966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*AFpQsmbDgAVX6hWIhTt2AA.png"/></div></figure></div></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="e27c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们通过点击<em class="lb">动作</em> &gt; <em class="lb">部署API来部署我们的API。</em></p><p id="a509" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个新的<em class="lb">部署阶段</em>，在本例中我们将其命名为<em class="lb">开发</em>。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/8ae816949e0b6e2ac28bed6db862cdfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WsN-WTztuKiEJUX3_N8_nw.png"/></div></div></figure><p id="169b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">部署之后，我们会得到一个链接来调用我们的API。</p><p id="a0be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://bi01sockuh.execute-api.eu-central-1.amazonaws.com/development" rel="noopener ugc nofollow" target="_blank">https://XXXX.execute-api.XXXX.amazonaws.com/development</a></p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="1663" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">让我们测试部署的API</h2><p id="dd39" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">我们将使用curl调用API。</p><p id="4a32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过一个接受的类别，我们得到了所请求车辆的状态:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/ea9246210275ee40ac89fea2e9f68c88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iYiCLd7ysv6DQ1tAKLL_Dg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">成功查询</figcaption></figure><p id="70d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">传递未接受的类别会导致请求被拒绝:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/5e8e109a26310e9e3f5e6eb7770b9327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dcW_s-TJ8miXZiMs3GShDQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">不成功的查询</figcaption></figure></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="72cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就这些，希望你觉得这个指南有用！如果你有，你可以在这里订阅未来的文章<a class="ae kc" href="https://medium.com/@tiivik" rel="noopener">或者在</a><a class="ae kc" href="https://twitter.com/tiivik" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上找到我。👏</p></div></div>    
</body>
</html>