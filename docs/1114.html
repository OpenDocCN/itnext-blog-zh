<html>
<head>
<title>Async Retries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步重试</h1>
<blockquote>原文：<a href="https://itnext.io/blog-md-3f9801f99454?source=collection_archive---------9-----------------------#2018-07-23">https://itnext.io/blog-md-3f9801f99454?source=collection_archive---------9-----------------------#2018-07-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d2f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近想到一个好玩的问题。如果您想构建一种方法来重试某些异步调用(例如，长时间轮询最终到达的资产的url或重试HTTP调用)，该怎么办呢？我四处摸索，想出了一个我认为非常酷的解决方案。</p><blockquote class="kl km kn"><p id="4847" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">我知道有些图书馆是这样做的，但是建筑很有趣，而且对我的大脑有好处！</p></blockquote><p id="a311" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我之前想到的解决方案。我使用<code class="fe ks kt ku kv b">Promises</code>来处理这个问题的异步本质。</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="71bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是将<a class="ae ld" href="http://bluebirdjs.com/docs/api-reference.html" rel="noopener ugc nofollow" target="_blank"> Bluebird.js </a>用于<code class="fe ks kt ku kv b">reflect</code> API。我们使用递归来重试，直到达到预定的尝试次数。<code class="fe ks kt ku kv b">Promises</code>一实例化就开始运行。通常，当使用<code class="fe ks kt ku kv b">Promises</code>时，我们会启动该功能，然后我们可以根据需要传递那个<code class="fe ks kt ku kv b">Promise</code>来附加东西。不幸的是，如果我们想要重试这个承诺，我们需要这个函数和<code class="fe ks kt ku kv b">args</code>，这样我们就可以在需要的时候重启它。这就是为什么我们需要分别传入异步函数和<code class="fe ks kt ku kv b">args</code>。</p><p id="03fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Bluebird <code class="fe ks kt ku kv b">reflect()</code>函数接受一个承诺，并将其包装在一个<code class="fe ks kt ku kv b">Promise Inspection</code>中。<code class="fe ks kt ku kv b">Promise Inspection</code>模仿了一个已解决的<code class="fe ks kt ku kv b">Promise</code>，但也揭示了一些有用的方法。即<code class="fe ks kt ku kv b">.isFulfilled()</code>和<code class="fe ks kt ku kv b">.value()</code>。我们可以用这些方法来检查内部<code class="fe ks kt ku kv b">Promise</code>。如果内部的<code class="fe ks kt ku kv b">Promise</code>满足，那么我们返回值。如果不满足，那么我们将错误推送到一个数组中，并在可用的重试次数少1次的情况下递归。</p><p id="4260" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是它的作用:</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="1505" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">过了一会儿，我正在做一个使用<a class="ae ld" href="https://github.com/fluture-js/Fluture" rel="noopener ugc nofollow" target="_blank"> Flutures </a>的项目，需要一个类似的解决方案，所以我拼凑了这段代码:</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="ce62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ks kt ku kv b">Futures</code>(由<code class="fe ks kt ku kv b">Fluture</code>实现)有一些有趣的属性。与承诺不同的一个特别之处是<code class="fe ks kt ku kv b">Futures</code>不执行，直到你附加了一个<code class="fe ks kt ku kv b">.fork</code>调用。查看签名，该函数采用退避策略函数、多次重试和一个<code class="fe ks kt ku kv b">Future</code>。</p><p id="c857" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你会注意到，<code class="fe ks kt ku kv b">retry</code>函数接受一个完整的<code class="fe ks kt ku kv b">Future</code>，而不是一个函数和参数。这是因为<code class="fe ks kt ku kv b">Futures</code>的懒惰。这意味着我们可以将函数和参数包装在一起，并在准备好的时候运行它。但是，在我们运行它之前，我们想设置这些重试。</p><p id="da99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们想要做的每一次重试，我们添加一个<code class="fe ks kt ku kv b">chainRej()</code>调用。因此，如果我们要重试2次，那么我们做一些类似于<code class="fe ks kt ku kv b">task.chainRej(...).chainRej(...)</code>的事情。我们使用递归来实现这一点。我们传递给<code class="fe ks kt ku kv b">chainRej</code>的函数只有在<code class="fe ks kt ku kv b">Future</code>拒绝(失败)时才会被调用。当发生这种情况时，我们将错误添加到一个列表中，增加我们的重试计数器，然后我们进行决策。如果我们已经重试了最大次数，那么我们拒绝整个<code class="fe ks kt ku kv b">Future</code>。如果我们没有使用所有的重试，那么我们使用退避函数和<code class="fe ks kt ku kv b">Future.after()</code>将新的尝试次数传递回我们的递归函数。</p><p id="09f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中一件很酷的事情是有一种方法可以传递回退策略。所以我们可以用不同的方式使用相同的重试功能。我们可以创建一个线性或指数回退，并将其中任何一个传递给重试函数。</p><p id="3b32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它以全新的方式解决了同样的问题。这两种解决方案的唯一共同点是我们使用了递归。</p><p id="e1b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是该函数的用法:</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="da73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这两种情况下，构建一些解决这个问题所需的工具而不是下载另一个库是很有趣的。我发现这些作为精神的形，帮助我理解我正在使用的工具。经历这些动作也帮助我更有信心解决棘手的问题。</p></div></div>    
</body>
</html>