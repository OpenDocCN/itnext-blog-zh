<html>
<head>
<title>Creating a chat with Node.js from the scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始用Node.js创建聊天</h1>
<blockquote>原文：<a href="https://itnext.io/creating-a-chat-with-node-js-from-the-scratch-707896d64593?source=collection_archive---------1-----------------------#2018-05-09">https://itnext.io/creating-a-chat-with-node-js-from-the-scratch-707896d64593?source=collection_archive---------1-----------------------#2018-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="212f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实时消息应用程序在web世界中并不是一个新事物，但在商业社区中已经聚集了更多的空间，特别是在需要以更加灵活和个性化的方式与他们的顾客/客户集成的应用程序中。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/9ff5e10f7919f2b6de179982fa2da8a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*xuRPALyqQogI-OtVrkDxow.jpeg"/></div></figure><p id="a4ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Chats架构通常被认为是基于服务器端应用程序的，该应用程序将支持来自客户端的请求(在本例中是一些JavaScript/Ajax ),并处理业务逻辑以及数据库存储、事件处理、队列等。</p><p id="fbe9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们谈到前端解决方案时，它的所有魅力都基于WebSockets，这是一种浏览器广泛支持的通信协议，旨在建立浏览器和服务器之间的双向实时通信，实现更快的消息交换，而无需页面刷新或耗时的等待。</p><p id="707b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于并非所有版本的浏览器(旧版本)都支持WebSockets，<strong class="jp ir"> Node.js </strong>创建了一个模块，负责所有的传输协议，可以作为旧版本浏览器的B计划。它们将如下(按此顺序):Adobe Flash Socket、Ajax long polling、Ajax multipart streaming、Forever iframe和JSONP Polling。有很多选项，所以模块本身负责通过最方便的传输协议与服务器通信。</p><p id="1d0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，在本文中，我们将创建一个项目来了解Socket的基础知识。IO和它能为我们提供什么，不需要使用数据库、Ajax或其他后端语言…只需要JavaScript、Node.js和jQuery。</p><h1 id="74e6" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">关于插座。超正析象管(Image Orthicon)</h1><p id="7cec" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">这个Node.js模块提供了一种从客户端浏览器直接连接到应用服务器的方法。该库通过事件工作，即服务器或客户端将触发事件，以便有来自其中一方的响应，参见<strong class="jp ir">图1 </strong>中的示例。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lw"><img src="../Images/762f5900df164053b1317ae5936c84e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eW0-hImI79HgcsU6u-itgA.jpeg"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated"><strong class="bd kv">图一。</strong>客户端和服务器之间的消息交换。</figcaption></figure><p id="c13b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">某种程度上，我们用两个非常基本的方法，分别是<code class="fe mf mg mh mi b">emit</code>和<code class="fe mf mg mh mi b">on</code>。一个用于发出事件，另一个用于接收事件的响应。因此，应用程序的每一端都有套接字。IO库已添加。</p><p id="72db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了允许两个设备之间直接交换消息之外，套接字。IO还允许消息广播，向所有其他连接的用户发送事件。广播可以来自客户端和服务器。</p><p id="5cc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当用户访问页面时，服务器会创建一个套接字，客户端和服务器之间的消息交换就是通过这个套接字进行的。反过来，这可以向单个套接字或连接到它的所有套接字发出一个事件，我们称之为消息广播。</p><h1 id="6559" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">设置环境</h1><p id="832f" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">如果您还没有准备好Node.js环境，让我们在本节中一起看看如何准备好开始开发这样的应用程序。这一切都归结为一个简单的文本编辑器和一个适用于您的操作系统的终端(或提示符)。</p><h2 id="9ae3" class="mj ku iq bd kv mk ml dn kz mm mn dp ld jy mo mp lh kc mq mr ll kg ms mt lp mu bi translated">Windows / MAC</h2><p id="e013" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">访问<a class="ae mv" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank">官方Node.js网站</a>并下载适用于您的Windows类型(32或64位)的<em class="mw"> msi </em>安装文件，或<em class="mw">。Mac的pkg </em>文件。打开文件并正常运行安装。最后，访问终端(或命令提示符)并运行命令<code class="fe mf mg mh mi b">node -v</code>。如果答案是Node.js的安装版本，这意味着环境已经准备好了。</p><h2 id="e778" class="mj ku iq bd kv mk ml dn kz mm mn dp ld jy mo mp lh kc mq mr ll kg ms mt lp mu bi translated">Linux操作系统</h2><p id="43bd" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">对于Linux，在Debian和Fedora发行版中，过程非常简单:安装由应用程序库执行。让我们首先看看在Ubuntu终端上运行的命令(对Debian发行版也有效)，如清单1 所示。在<strong class="jp ir">清单2 </strong>中，我们可以看到Fedora发行版的命令。</p><p id="1732" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">清单1。</strong>在Ubuntu (Debian发行版)中安装的命令。</p><pre class="km kn ko kp gt mx mi my mz aw na bi"><span id="7587" class="mj ku iq mi b gy nb nc l nd ne">sudo apt-get update<br/>sudo apt-get install Node.js<br/>sudo apt-get install npm</span></pre><p id="e12b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">清单2。</strong>Fedora发行版的安装命令。</p><pre class="km kn ko kp gt mx mi my mz aw na bi"><span id="e6a9" class="mj ku iq mi b gy nb nc l nd ne">sudo curl —silent —location <a class="ae mv" href="https://rpm.nodesource.com/setup" rel="noopener ugc nofollow" target="_blank">https://rpm.nodesource.com/setup</a> | bash -<br/>sudo yum -y install Node.js<br/>sudo yum -y install npm</span></pre><p id="7196" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在过程结束时，只需访问终端并输入命令<code class="fe mf mg mh mi b">Node.js -v</code>。如果答案是Node.js的安装版本，那么我们的环境就可以开始了。</p><p id="4a01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Node.js之后的第二个安装命令是指<strong class="jp ir"> NPM </strong> ( <em class="mw"> Node.js包管理器</em>)，一个在Node.js应用开发中非常重要的包管理的系统。</p><h1 id="a36d" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">该项目</h1><p id="bd77" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">现在让我们创建一个名为<code class="fe mf mg mh mi b">\ChatJs</code>的目录，在其中，我们将创建一个名为app.js的文件，这将是我们服务器的主文件。作为第一部分，我们将创建一个相当简单的服务器，它只会在浏览器屏幕上显示一条成功的消息，如清单3所示。</p><p id="43f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">清单3。</strong>创建单个应用程序。</p><pre class="km kn ko kp gt mx mi my mz aw na bi"><span id="87b6" class="mj ku iq mi b gy nb nc l nd ne">var app = require('http').createServer(response);</span><span id="c808" class="mj ku iq mi b gy nf nc l nd ne">app.listen(3000);<br/>console.log("App running…");</span><span id="728c" class="mj ku iq mi b gy nf nc l nd ne">function response(req, res) {<br/> res.writeHead(200);<br/> res.end("Hi, your server is working!");<br/>}</span></pre><p id="694b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该脚本创建了一个HTTP服务器(将在端口3000上监听)，该服务器有一个被请求的主方法<code class="fe mf mg mh mi b">response()</code>函数，该函数又有两个参数:<code class="fe mf mg mh mi b">req</code>(请求)和<code class="fe mf mg mh mi b">res</code>(响应)。在这个函数中，我们定义了一个成功代码(200)，并以一个警告服务器正常的字符串结束。</p><p id="cd96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不久之后，只需运行以下命令，它将在提示符下运行我们的应用程序:</p><pre class="km kn ko kp gt mx mi my mz aw na bi"><span id="9b80" class="mj ku iq mi b gy nb nc l nd ne">node app.js</span></pre><p id="737e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，当您在提示符下运行这段代码时，终端会显示<code class="fe mf mg mh mi b">console.log</code>函数的内容，警告应用程序正在运行。但是，它不会打印任何其他行，这表明我们的应用程序当前正在运行。</p><p id="67db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，我们只有Node.js服务器在运行。如果您在<a class="ae mv" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>访问浏览器，您将看到我们在<code class="fe mf mg mh mi b">end</code>方法中传递的消息，正如我们在<strong class="jp ir">图2 </strong>中看到的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/c96e8678d6f0607da32ca903d7fdc3a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*MxfPFsB50A2deKN4h12BUQ.png"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated"><strong class="bd kv">图二。</strong>浏览器响应。</figcaption></figure><p id="d13a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将让我们的服务器呈现一个HTML响应，它将成为我们聊天的主页。为此，我们必须加载<code class="fe mf mg mh mi b">FileSystem</code>模块，因为我们将浏览项目目录并打开一个文件。因此，让我们改变我们的<code class="fe mf mg mh mi b">app.js</code>，就像我们在<strong class="jp ir">清单4 </strong>中看到的那样。在进行更改之前，进入提示符并按下<code class="fe mf mg mh mi b">Ctrl + C</code>(或<code class="fe mf mg mh mi b">command + C</code>)来停止服务器上的应用程序。</p><p id="e793" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">清单4。</strong>介绍一个HTML页面。</p><pre class="km kn ko kp gt mx mi my mz aw na bi"><span id="4468" class="mj ku iq mi b gy nb nc l nd ne">var app = require('http').createServer(response);<br/>var fs = require('fs');</span><span id="426a" class="mj ku iq mi b gy nf nc l nd ne">app.listen(3000);<br/>console.log("App running…");</span><span id="88ec" class="mj ku iq mi b gy nf nc l nd ne">function response(req, res) {<br/> fs.readFile(__dirname + '/index.html',<br/> function (err, data) {<br/> if (err) {<br/>   res.writeHead(500);<br/>   return res.end('Failed to load file index.html');<br/> }</span><span id="f4f0" class="mj ku iq mi b gy nf nc l nd ne"> res.writeHead(200);<br/>   res.end(data);<br/> });<br/>}</span></pre><p id="5887" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这些更改之后，我们将再次执行命令<code class="fe mf mg mh mi b">node app.js</code>，当再次访问地址<a class="ae mv" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>时，您将会看到消息“<em class="mw">加载index.html文件时出错”</em>，这只是因为我们的项目中还没有index.html文件。</p><p id="cc9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样重要的是要记住，我们到目前为止创建的服务器并没有区分路径，也就是说，你可以在<a class="ae mv" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>之后放置任何东西，它总是以同样的方式响应，因为我们还没有实现它如何处理这些路径。很快，你就可以调出类似<a class="ae mv" href="http://localhost:3000/chat" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/chat</a>、<a class="ae mv" href="http://localhost:3000/error" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/error</a>、<a class="ae mv" href="http://localhost:3000/potato" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/potato</a>等地址。</p><p id="30ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们为我们的聊天创建一个简单的界面。在项目根目录下创建一个<code class="fe mf mg mh mi b">index.html</code>文件。在该文件中输入一个与清单5 中所示代码相同的代码。</p><p id="1219" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">清单5。</strong>聊天HTML代码。</p><pre class="km kn ko kp gt mx mi my mz aw na bi"><span id="b307" class="mj ku iq mi b gy nb nc l nd ne">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/> &lt;title&gt;ChatJS&lt;/title&gt;<br/> &lt;link rel="stylesheet" type="text/css" href="/css/style.css" /&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/> &lt;div id="history"&gt;&lt;/div&gt;<br/> &lt;form id="chat"&gt;<br/> &lt;input type="text" id="msg_text" name="msg_text" /&gt;<br/> &lt;input type="submit" value="Send!" /&gt; <br/> &lt;/form&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="646c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目前，我们的索引将只处理一个名为<code class="fe mf mg mh mi b">history</code>的div，聊天中交换的所有消息都将在这里进行排列。然后，我们很快就有了一个带有文本框和消息发送按钮的表单。到目前为止非常简单的聊天结构。</p><p id="fb33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，如果您现在尝试访问地址<a class="ae mv" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>，您将会收到相同的错误消息。这是因为我们没有重启我们的服务器应用程序，然后我们再次进入提示符，按下<code class="fe mf mg mh mi b">Ctrl + C</code>然后重新执行应用程序。</p><p id="1495" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能已经注意到，我们已经在应用程序的<code class="fe mf mg mh mi b">&lt;head&gt;</code>中留下了一个链接标签来加载我们的CSS。在我们项目的目录中，创建另一个名为<code class="fe mf mg mh mi b">css</code>的目录，并在其中创建与清单6 中所示内容相同的<code class="fe mf mg mh mi b">style.css</code>文件。</p><p id="7ff6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">清单6。</strong> style.css文件。</p><pre class="km kn ko kp gt mx mi my mz aw na bi"><span id="5b4e" class="mj ku iq mi b gy nb nc l nd ne">html, body, input {<br/> font-family: Georgia, Tahoma, Arial, sans-serif;<br/> margin: 0;<br/> padding: 0;<br/>}</span><span id="d5a5" class="mj ku iq mi b gy nf nc l nd ne">body {<br/> background: #302F31;<br/> padding: 10px;<br/>}</span><span id="f44f" class="mj ku iq mi b gy nf nc l nd ne">form {<br/> margin: 15px 0;<br/>}</span><span id="febe" class="mj ku iq mi b gy nf nc l nd ne">form input[type='text'] {<br/> border: 2px solid #eb5424;<br/> border-radius: 5px;<br/> padding: 5px;<br/> width: 75%;<br/>}</span><span id="aaa8" class="mj ku iq mi b gy nf nc l nd ne">form input[type='submit'] {<br/> background: #eb5424;<br/> border: none;<br/> border-radius: 5px;<br/> color: #FFF;<br/> cursor: pointer;<br/> font-weight: bold;<br/> padding: 7px 5px;<br/> width: 19%;<br/>}</span><span id="0b10" class="mj ku iq mi b gy nf nc l nd ne">#history {<br/> background: #FFF;<br/> border: 2px solid #eb5424;<br/> height: 550px;<br/>}</span></pre><p id="4518" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们重新启动应用程序，该样式还没有应用到索引页面。原因是我们的app.js到目前为止只处理一个请求路径。为了解决这个问题，我们将更改我们的app.js文件，以便它加载在请求URL中传递的文件，而不是手动放置每个URL。让我们仔细看看清单7 中列出的变化。</p><p id="3af5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">清单7。</strong>app . js中的路径变化</p><pre class="km kn ko kp gt mx mi my mz aw na bi"><span id="02d1" class="mj ku iq mi b gy nb nc l nd ne">var app = require('http').createServer(response);<br/>var fs = require('fs');</span><span id="fb32" class="mj ku iq mi b gy nf nc l nd ne">app.listen(3000);<br/>console.log("App running...");</span><span id="ee4f" class="mj ku iq mi b gy nf nc l nd ne">function response(req, res) {<br/>    var file = "";<br/>    if (req.url == "/") {<br/>        file = __dirname + '/index.html';<br/>    } else {<br/>        file = __dirname + req.url;<br/>    }</span><span id="14ac" class="mj ku iq mi b gy nf nc l nd ne">    fs.readFile(file, function(err, data) {<br/>        if (err) {<br/>            res.writeHead(404);<br/>            return res.end('Page or file not found');<br/>        }</span><span id="2eee" class="mj ku iq mi b gy nf nc l nd ne">    res.writeHead(200);<br/>        res.end(data);<br/>    });<br/>}</span></pre><p id="0785" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重启应用程序后，您将看到与图3 中相同的内容。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi nh"><img src="../Images/6a3111d1952b07d61513ba3a1d5c63f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zAmjYBvfmO-lL4WuhkHTCw.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated"><strong class="bd kv">图3。</strong>风格化聊天页面</figcaption></figure><h1 id="5024" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">发送消息</h1><p id="1be7" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我们现在将研究消息传递机制。我们的应用程序将通过Socket的客户端库与Node.js服务器进行通信。而jQuery发生在与页面的交互中。</p><p id="b936" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们将修改app.js文件，如清单8 中所示，并在文件开头包含一行命令，声明我们正在包含Socket。应用程序中的IO。</p><p id="0e28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">清单8。</strong>包括插座。IO模块。</p><pre class="km kn ko kp gt mx mi my mz aw na bi"><span id="4f22" class="mj ku iq mi b gy nb nc l nd ne">var app = require('http').createServer(response);<br/>var fs = require('fs');<br/>var io = require('socket.io')(app);<br/>…</span></pre><p id="72dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了在模块中使用<code class="fe mf mg mh mi b">require</code>功能，我们需要首先为我们的应用安装它。因此，停止应用程序并运行以下命令来完成此操作:</p><pre class="km kn ko kp gt mx mi my mz aw na bi"><span id="441d" class="mj ku iq mi b gy nb nc l nd ne">npm install socket.io</span></pre><p id="20e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成后，转到您的index.html页面，在文件末尾添加清单9 中所示的代码片段。</p><p id="111f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">清单9。</strong>消息发送事件。</p><pre class="km kn ko kp gt mx mi my mz aw na bi"><span id="0fee" class="mj ku iq mi b gy nb nc l nd ne">…<br/> &lt;script type="text/javascript" src="<a class="ae mv" href="https://code.jquery.com/jquery-3.3.1.min.js" rel="noopener ugc nofollow" target="_blank">https://code.jquery.com/jquery-3.3.1.min.js</a>"&gt;&lt;/script&gt;<br/> &lt;script type="text/javascript" src="/socket.io/socket.io.js"&gt;&lt;/script&gt;<br/> &lt;script type="text/javascript"&gt;<br/> var socket = io.connect();<br/> $("form#chat").submit(function(e) {<br/>   e.preventDefault();<br/> <br/>   socket.emit("send message", $(this).find("#msg_text").val(), function() {<br/>     $("form#chat #msg_text").val("");<br/>   });<br/> });<br/> &lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="58f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们声明了一个引用套接字的<code class="fe mf mg mh mi b">socket</code>变量。IO库，它将负责所有套接字功能。接下来，我们在jQuery中声明表单的一个<code class="fe mf mg mh mi b">submit</code>事件，并传递一个<code class="fe mf mg mh mi b">preventDefault</code>，这样表单就不会进入它的<code class="fe mf mg mh mi b">action</code>，因为我们是负责表单响应的人。</p><p id="aaa7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，调用了库的<code class="fe mf mg mh mi b">emit</code>方法，其中我们传递了三个参数:事件名称(这在服务器上很有用)、我们正在发送的数据(在本例中，我们只发送了<code class="fe mf mg mh mi b">message</code>字段的内容)以及最后的<code class="fe mf mg mh mi b">callback</code>，这是一个一旦事件发出就会执行的函数。尤其是后者，将仅用于清除消息字段，因此用户不必在发送消息后删除它。</p><p id="68ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们现在测试我们的应用程序，消息发送将不工作，甚至清除消息字段的回调也不工作，因为我们还没有设置服务器在接收到该事件时必须做的功能。为此，编辑app.js文件，并将清单11 中所示的代码放在它的末尾。</p><p id="5229" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">清单11。</strong>接收来自客户端的消息。</p><pre class="km kn ko kp gt mx mi my mz aw na bi"><span id="54ea" class="mj ku iq mi b gy nb nc l nd ne">io.on("connection", function(socket) {<br/>    socket.on("send message", function(sent_msg, callback) {<br/>        sent_msg = "[ " + getCurrentDate() + " ]: " + sent_msg;<br/>        io.sockets.emit("update messages", sent_msg);<br/>        callback();<br/>    });<br/>});</span><span id="c215" class="mj ku iq mi b gy nf nc l nd ne">function getCurrentDate() {<br/>    var currentDate = new Date();<br/>    var day = (currentDate.getDate() &lt; 10 ? '0' : '') + currentDate.getDate();<br/>    var month = ((currentDate.getMonth() + 1) &lt; 10 ? '0' : '') + (currentDate.getMonth() + 1);<br/>    var year = currentDate.getFullYear();<br/>    var hour = (currentDate.getHours() &lt; 10 ? '0' : '') + currentDate.getHours();<br/>    var minute = (currentDate.getMinutes() &lt; 10 ? '0' : '') + currentDate.getMinutes();<br/>    var second = (currentDate.getSeconds() &lt; 10 ? '0' : '') + currentDate.getSeconds();<br/>    return year + "-" + month + "-" + day + " " + hour + ":" + minute + ":" + second;<br/>}</span></pre><p id="f8e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经创建了一个方法来响应客户端到服务器的连接。当客户端访问页面时，它在服务器上触发这个方法，当这个套接字接收到一个<code class="fe mf mg mh mi b">send message</code>时，我们触发一个方法，该方法将发送的数据(<code class="fe mf mg mh mi b">message</code>字段)和我们在客户端创建的回调作为参数。</p><p id="fee6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个方法中，我们放入了功能的第二部分:模块将向连接到服务器的套接字(所有用户)发送<code class="fe mf mg mh mi b">update messages</code>事件，并且还将通过特定的日期时间格式传递发送了哪个新消息。为了提供日期和时间，我们创建了一个单独的函数，因为在整个开发过程中我们还会多次使用这个方法。马上，我们调用我们在客户端创建的回调，这是清除字段的方法。</p><p id="3d92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，还要编辑index.html文件，并创建为用户更新消息的方法。想法很简单:让我们在<code class="fe mf mg mh mi b">history</code> div中给出一个<code class="fe mf mg mh mi b">append</code>(变化在<strong class="jp ir">清单12 </strong>)。提交表单后，应立即输入以下行。</p><p id="c375" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">清单12。</strong>更新消息历史。</p><pre class="km kn ko kp gt mx mi my mz aw na bi"><span id="d75e" class="mj ku iq mi b gy nb nc l nd ne">socket.on("update messages", function(msg){<br/>var final_message = $("&lt;p /&gt;").text(msg);<br/>   $("#history").append(final_message);<br/>});</span></pre><p id="a647" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上，服务器和客户端之间的对话在两端是相同的，即两者分别有一个<code class="fe mf mg mh mi b">emit</code>和<code class="fe mf mg mh mi b">on</code>函数用于发出和接收事件。</p><p id="c8fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，重启并在两个选项卡中访问应用程序，然后发送一条消息来查看Socket的强大功能。木卫一在行动。应用程序应显示如图<strong class="jp ir">图4 </strong>所示的信息。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi nh"><img src="../Images/f5f13460288a6b771a74973fb5d5fb9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RToj_taDhtJ55QEuPVwObw.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated"><strong class="bd kv">图四。</strong>发送和接收消息。</figcaption></figure><h1 id="19c0" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="e209" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">通过这个非常简单的项目和一些依赖项，我们成功地用几行代码创建了一个非常实用的应用程序。</p><p id="7fef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管如此，插座的力量。IO扩展到更多以前依赖后端页面的解决方案。现在，入站/出站服务器响应时间可以依靠WebSocket协议实现更灵活的信息交换，使系统能够跟踪监控结果，甚至为用户设置实时价格。</p><p id="a3c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里找到完整的源代码。</p></div></div>    
</body>
</html>