<html>
<head>
<title>Integrate Kafka and OpenFuction to Realize Elastic Kubernetes Log Alerts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">集成Kafka和OpenFuction实现弹性Kubernetes日志提醒</h1>
<blockquote>原文：<a href="https://itnext.io/integrate-kafka-and-openfuction-to-realize-elastic-kubernetes-log-alerts-30c38967b710?source=collection_archive---------1-----------------------#2021-11-12">https://itnext.io/integrate-kafka-and-openfuction-to-realize-elastic-kubernetes-log-alerts-30c38967b710?source=collection_archive---------1-----------------------#2021-11-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ffef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何处理消息服务器收集的容器日志？您可能会面临一个困境:部署一个专用的日志处理工作负载可能成本很高，而且当日志数量大幅波动时，很难评估所需的备用日志处理工作负载的数量。这篇博客文章提供了无服务器日志处理的想法，在提高灵活性的同时降低了链接成本。</p><p id="c1c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的总体设计思想是添加一个Kafka服务器作为日志接收器，然后使用Kafka服务器的日志输入作为事件来驱动无服务器工作负载处理日志。大致包括以下步骤:</p><ol class=""><li id="272f" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">设置Kafka服务器作为Kubernetes集群的日志接收器。</li><li id="30af" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">部署OpenFunction，为日志处理工作负载提供无服务器功能。</li><li id="ec59" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">编写日志处理函数来抓取特定的日志以生成警报消息。</li><li id="54e3" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">配置<a class="ae kz" href="https://github.com/kubesphere/notification-manager/" rel="noopener ugc nofollow" target="_blank">通知管理器</a>向Slack发送警报。</li></ol><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi la"><img src="../Images/8b420ce7fd8cce709703da3fbbd60f59.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/0*0l5B8eVbH_vgqD27"/></div></figure><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi li"><img src="../Images/910edb433ad8b92ec19bd8a741a84079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*J03e-I--cjIrE8o2.png"/></div></div></figure><p id="52cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个场景中，我们将利用<a class="ae kz" href="https://github.com/OpenFunction/OpenFunction" rel="noopener ugc nofollow" target="_blank"> OpenFunction </a>的无服务器功能。</p><blockquote class="ln lo lp"><p id="fd48" class="jn jo lq jp b jq jr js jt ju jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj kk ij bi translated"><a class="ae kz" href="https://github.com/OpenFunction/OpenFunction" rel="noopener ugc nofollow" target="_blank"><em class="iq">open function</em></a><em class="iq">是由KubeSphere社区发起的开源FaaS(无服务器)项目。它旨在允许用户专注于他们的业务逻辑，而不必担心底层的操作环境和基础设施。目前，该项目提供了以下关键能力:</em></p></blockquote><ul class=""><li id="45aa" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk lu kr ks kt bi translated"><em class="lq">从Dockerfile或Buildpacks构建OCI映像。</em></li><li id="3b78" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk lu kr ks kt bi translated"><em class="lq">使用Knative Serving或OpenFunctionAsync(由KEDA + Dapr支持)作为运行时运行无服务器工作负载。</em></li><li id="3eb3" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk lu kr ks kt bi translated"><em class="lq">内置事件驱动框架。</em></li></ul><h1 id="7f57" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">使用卡夫卡作为日志接收器</h1><p id="9622" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">首先，为KubeSphere平台启用<strong class="jp ir">日志</strong>组件(更多信息，请参考<a class="ae kz" href="https://kubesphere.io/docs/pluggable-components/" rel="noopener ugc nofollow" target="_blank">启用可插拔组件</a>)。接下来，我们可以使用<a class="ae kz" href="https://github.com/strimzi/strimzi-kafka-operator" rel="noopener ugc nofollow" target="_blank"> strimzi-kafka-operator </a>构建一个最小的kafka服务器。</p><ol class=""><li id="7ef0" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">在<code class="fe my mz na nb b">default</code>名称空间中，安装<a class="ae kz" href="https://github.com/strimzi/strimzi-kafka-operator" rel="noopener ugc nofollow" target="_blank"> strimzi-kafka-operator。</a></li></ol><p id="69e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe my mz na nb b">helm repo add strimzi https://strimzi.io/charts/ helm install kafka-operator -n default strimzi/strimzi-kafka-operator</code></p><p id="875e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.运行以下命令在<code class="fe my mz na nb b">default</code>名称空间中创建一个Kafka集群和一个Kafka主题。创建的Kafka和ZooKeeper集群的存储类型是<strong class="jp ir">短暂的</strong>。在这里，我们用<code class="fe my mz na nb b">emptyDir</code>进行演示。</p><blockquote class="ln lo lp"><p id="57d4" class="jn jo lq jp b jq jr js jt ju jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj kk ij bi translated"><em class="iq">注意，我们已经创建了一个名为</em> <code class="fe my mz na nb b"><em class="iq">logs</em></code> <em class="iq">的主题供后续使用。</em></p></blockquote><pre class="lb lc ld le gt nc nb nd ne aw nf bi"><span id="bad1" class="ng lw iq nb b gy nh ni l nj nk">cat &lt;&lt;EOF | kubectl apply -f -<br/>apiVersion: kafka.strimzi.io/v1beta2<br/>kind: Kafka<br/>metadata:<br/>  name: kafka-logs-receiver<br/>  namespace: default<br/>spec:<br/>  kafka:<br/>    version: 2.8.0<br/>    replicas: 1<br/>    listeners:<br/>      - name: plain<br/>        port: 9092<br/>        type: internal<br/>        tls: false<br/>      - name: tls<br/>        port: 9093<br/>        type: internal<br/>        tls: true<br/>    config:<br/>      offsets.topic.replication.factor: 1<br/>      transaction.state.log.replication.factor: 1<br/>      transaction.state.log.min.isr: 1<br/>      log.message.format.version: '2.8'<br/>      inter.broker.protocol.version: "2.8"<br/>    storage:<br/>      type: ephemeral<br/>  zookeeper:<br/>    replicas: 1<br/>    storage:<br/>      type: ephemeral<br/>  entityOperator:<br/>    topicOperator: {}<br/>    userOperator: {}<br/>---<br/>apiVersion: kafka.strimzi.io/v1beta1<br/>kind: KafkaTopic<br/>metadata:<br/>  name: logs<br/>  namespace: default<br/>  labels:<br/>    strimzi.io/cluster: kafka-logs-receiver<br/>spec:<br/>  partitions: 10<br/>  replicas: 3<br/>  config:<br/>    retention.ms: 7200000<br/>    segment.bytes: 1073741824<br/>EOF</span></pre><p id="9a60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.运行以下命令检查Pod的状态，并等待Kafka和ZooKeeper运行并启动。</p><pre class="lb lc ld le gt nc nb nd ne aw nf bi"><span id="f77a" class="ng lw iq nb b gy nh ni l nj nk">$ kubectl get po<br/>NAME                          READY   STATUS        RESTARTS   AGE<br/>kafka-logs-receiver-entity<br/>-operator-568957ff84-nmtlw    3/3     Running       0          8m42s<br/>kafka-logs-receiver-kafka-0   1/1     Running       0          9m13s<br/>kafka-logs-receiver<br/>-zookeeper-0                  1/1     Running       0          9m46s<br/>strimzi-cluster-operator<br/>-687fdd6f77-cwmgm             1/1     Running       0          11m</span></pre><p id="7622" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行以下命令查看Kafka集群的元数据:</p><pre class="lb lc ld le gt nc nb nd ne aw nf bi"><span id="f698" class="ng lw iq nb b gy nh ni l nj nk"># Starts a utility pod.<br/>$ kubectl run utils --image=arunvelsriram/utils -i --tty --rm<br/># Checks metadata of the Kafka cluster.<br/>$ kafkacat -L -b kafka-logs-receiver-kafka-brokers:9092</span></pre><p id="c275" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将此Kafka服务器添加为日志接收器。</p><ol class=""><li id="20d1" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">以管理员<strong class="jp ir">身份</strong>登录KubeSphere的web控制台。在左上角选择<strong class="jp ir">平台</strong> &gt; <strong class="jp ir">集群管理</strong>。</li></ol><blockquote class="ln lo lp"><p id="6f3b" class="jn jo lq jp b jq jr js jt ju jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj kk ij bi translated"><em class="iq">如果您已经启用了</em> <a class="ae kz" href="https://kubesphere.io/docs/multicluster-management/" rel="noopener ugc nofollow" target="_blank"> <em class="iq">多集群功能</em> </a> <em class="iq">，您需要选择一个集群。</em></p></blockquote><p id="bd76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.在<strong class="jp ir">集群管理</strong>页面中，点击<strong class="jp ir">集群设置</strong>下的<strong class="jp ir">日志收集</strong>。</p><p id="c1d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.点击<strong class="jp ir">添加日志接收器，</strong>然后点击<strong class="jp ir"> Kafka </strong>。输入Kafka的服务地址和端口号，然后点击<strong class="jp ir">确定</strong>。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi la"><img src="../Images/4607b61629bc6177056b57d70982af89.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/0*gTa7MZmqiwIqjjMC"/></div></figure><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi nl"><img src="../Images/eab693f7ace214ab3d17fb8affe09509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_Ae3OB6CmNmMmtLa.png"/></div></div></figure><p id="4d57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.运行以下命令来验证Kafka集群可以从Fluent Bit收集日志。</p><pre class="lb lc ld le gt nc nb nd ne aw nf bi"><span id="5031" class="ng lw iq nb b gy nh ni l nj nk"># Starts a utility pod.<br/>$ kubectl run utils --image=arunvelsriram/utils -i --tty --rm <br/># Checks logs in the `logs` topic<br/>$ kafkacat -C -b kafka-logs-receiver-kafka-0.kafka-logs-receiver-kafka-brokers.default.svc:9092 -t logs</span></pre><h1 id="fb84" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">部署OpenFunction</h1><p id="cc3b" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">根据概述中的设计，我们需要首先部署OpenFunction。由于OpenFunction引用了多个第三方项目，如Knative、Tekton、ShipWright、Dapr、KEDA等，如果手动部署会很麻烦。建议您参考<a class="ae kz" href="https://github.com/OpenFunction/OpenFunction#prerequisites" rel="noopener ugc nofollow" target="_blank">先决条件</a>快速部署OpenFunction的依赖项。</p><blockquote class="ln lo lp"><p id="d25f" class="jn jo lq jp b jq jr js jt ju jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj kk ij bi translated"><em class="iq">在命令中，</em> <code class="fe my mz na nb b"><em class="iq">--with-shipwright</em></code> <em class="iq">表示Shipwright被部署为该功能的构建驱动程序；</em> <code class="fe my mz na nb b"><em class="iq">--with-openFuncAsync</em></code> <em class="iq">表示将OpenFuncAsync运行时部署为函数的加载驱动。当你对GitHub和Google的访问受限时，可以添加</em> <code class="fe my mz na nb b"><em class="iq">--poor-network</em></code> <em class="iq">参数下载相关组件。</em></p></blockquote><pre class="lb lc ld le gt nc nb nd ne aw nf bi"><span id="6166" class="ng lw iq nb b gy nh ni l nj nk">sh hack/deploy.sh --with-shipwright --with-openFuncAsync --poor-network</span></pre><p id="6656" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">部署OpenFunction。</p><blockquote class="ln lo lp"><p id="f729" class="jn jo lq jp b jq jr js jt ju jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj kk ij bi translated"><em class="iq">我们在这里安装最新的稳定版本。或者，您可以使用开发版本。更多信息，请参考</em> <a class="ae kz" href="https://github.com/OpenFunction/OpenFunction#install" rel="noopener ugc nofollow" target="_blank"> <em class="iq">安装OpenFunction </em> </a> <em class="iq">章节。</em></p><p id="2133" class="jn jo lq jp b jq jr js jt ju jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj kk ij bi translated">为了确保Shipwright正常工作，我们提供了一个默认的构建策略，您可以运行以下命令来设置该策略。</p></blockquote><pre class="lb lc ld le gt nc nb nd ne aw nf bi"><span id="2d64" class="ng lw iq nb b gy nh ni l nj nk">kubectl apply -f <a class="ae kz" href="https://raw.githubusercontent.com/OpenFunction/OpenFunction/main/config/strategy/openfunction.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/OpenFunction/OpenFunction/main/config/strategy/openfunction.yaml</a>kubectl apply -f <a class="ae kz" href="https://github.com/OpenFunction/OpenFunction/releases/download/v0.3.0/bundle.yaml" rel="noopener ugc nofollow" target="_blank">https://github.com/OpenFunction/OpenFunction/releases/download/v0.3.0/bundle.yaml</a></span></pre><h1 id="4ad9" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">写一个日志处理函数</h1><p id="a197" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">在这个例子中，我们安装WordPress作为日志生成器。应用程序的工作负载驻留在<code class="fe my mz na nb b">demo-project</code>名称空间中，Pod的名称是<code class="fe my mz na nb b">wordpress-v1-f54f697c5-hdn2z</code>。</p><p id="433c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当请求返回<strong class="jp ir"> 404 </strong>时，日志内容如下:</p><pre class="lb lc ld le gt nc nb nd ne aw nf bi"><span id="a2ae" class="ng lw iq nb b gy nh ni l nj nk">{"@timestamp":1629856477.226758,"log":"*.*.*.* - - [25/Aug/2021:01:54:36 +0000] \"GET /notfound HTTP/1.1\" 404 49923 \"-\" \"curl/7.58.0\"\n","time":"2021-08-25T01:54:37.226757612Z","kubernetes":{"pod_name":"wordpress-v1-f54f697c5-hdn2z","namespace_name":"demo-project","container_name":"container-nrdsp1","docker_id":"bb7b48e2883be0c05b22c04b1d1573729dd06223ae0b1676e33a4fac655958a5","container_image":"wordpress:4.8-apache"}}</span></pre><p id="2e82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我们的需求:当一个请求返回<strong class="jp ir"> 404 </strong>时，通知管理器向接收者发送一个通知(根据<a class="ae kz" href="https://kubesphere.io/docs/cluster-administration/platform-settings/notification-management/configure-slack/" rel="noopener ugc nofollow" target="_blank">配置松弛通知</a>配置一个松弛警报接收者，并记录名称空间、Pod名称、请求路径、请求方法和其他信息。因此，我们编写一个简单的函数:</p><blockquote class="ln lo lp"><p id="4289" class="jn jo lq jp b jq jr js jt ju jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj kk ij bi translated"><em class="iq">可以从</em> <a class="ae kz" href="https://github.com/OpenFunction/functions-framework/blob/main/docs/OpenFunction-context-specs.md" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> OpenFunction上下文规范、</em> </a> <em class="iq">学习如何使用</em> <code class="fe my mz na nb b"><em class="iq">openfunction-context</em></code> <em class="iq">，这是OpenFunction提供的一个编写函数的工具库。您可以从</em> <a class="ae kz" href="https://github.com/OpenFunction/samples" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> OpenFunction示例中了解更多关于OpenFunction函数的信息。</em> </a></p></blockquote><pre class="lb lc ld le gt nc nb nd ne aw nf bi"><span id="476f" class="ng lw iq nb b gy nh ni l nj nk">package logshandlerimport (<br/>	"encoding/json"<br/>	"fmt"<br/>	"log"<br/>	"regexp"<br/>	"time"	ofctx "github.com/OpenFunction/functions-framework-go/openfunction-context"<br/>	alert "github.com/prometheus/alertmanager/template"<br/>)const (<br/>	HTTPCodeNotFound = "404"<br/>	Namespace        = "demo-project"<br/>	PodName          = "wordpress-v1-[A-Za-z0-9]{9}-[A-Za-z0-9]{5}"<br/>	AlertName        = "404 Request"<br/>	Severity         = "warning"<br/>)// The ctx parameter of the LogHandler function provides a context handle for user functions in the cluster. For example, ctx.SendTo is used to send data to a specified destination.<br/>// The in parameter in the LogsHandle function is used to pass byte data (if any) from the input to the function.<br/>func LogsHandler(ctx *ofctx.OpenFunctionContext, in []byte) int {<br/>	content := string(in)<br/>	// We set three regular expressions here for matching the HTTP status code, resource namespace, and Pod name of resources, respectively.<br/>	matchHTTPCode, _ := regexp.MatchString(fmt.Sprintf(" %s ", HTTPCodeNotFound), content)<br/>	matchNamespace, _ := regexp.MatchString(fmt.Sprintf("namespace_name\":\"%s", Namespace), content)<br/>	matchPodName := regexp.MustCompile(fmt.Sprintf(`(%s)`, PodName)).FindStringSubmatch(content)	if matchHTTPCode &amp;&amp; matchNamespace &amp;&amp; matchPodName != nil {<br/>		log.Printf("Match log - Content: %s", content)		// If the input data matches all three regular expressions above, we need to extract some log information to be used in the alert.<br/>		// The alert contains the following information: HTTP method of the 404 request, HTTP path, and Pod name.<br/>		match := regexp.MustCompile(`([A-Z]+) (/\S*) HTTP`).FindStringSubmatch(content)<br/>		if match == nil {<br/>			return 500<br/>		}<br/>		path := match[len(match)-1]<br/>		method := match[len(match)-2]<br/>		podName := matchPodName[len(matchPodName)-1]		// After we collect major information, we can use the data struct of altermanager to compose an alert.<br/>		notify := &amp;alert.Data{<br/>			Receiver:          "notification_manager",<br/>			Status:            "firing",<br/>			Alerts:            alert.Alerts{},<br/>			GroupLabels:       alert.KV{"alertname": AlertName, "namespace": Namespace},<br/>			CommonLabels:      alert.KV{"alertname": AlertName, "namespace": Namespace, "severity": Severity},<br/>			CommonAnnotations: alert.KV{},<br/>			ExternalURL:       "",<br/>		}<br/>		alt := alert.Alert{<br/>			Status: "firing",<br/>			Labels: alert.KV{<br/>				"alertname": AlertName,<br/>				"namespace": Namespace,<br/>				"severity":  Severity,<br/>				"pod":       podName,<br/>				"path":      path,<br/>				"method":    method,<br/>			},<br/>			Annotations:  alert.KV{},<br/>			StartsAt:     time.Now(),<br/>			EndsAt:       time.Time{},<br/>			GeneratorURL: "",<br/>			Fingerprint:  "",<br/>		}<br/>		notify.Alerts = append(notify.Alerts, alt)<br/>		notifyBytes, _ := json.Marshal(notify)		// Use ctx.SendTo to send the content to the "notification-manager" output (you can find its definition in the following logs-handler-function.yaml function configuration file.<br/>		if err := ctx.SendTo(notifyBytes, "notification-manager"); err != nil {<br/>			panic(err)<br/>		}<br/>		log.Printf("Send log to notification manager.")<br/>	}<br/>	return 200<br/>}</span></pre><p id="82fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将该函数上传到代码库中，记录代码库的<strong class="jp ir"> URL和代码库</strong>中代码的<strong class="jp ir">路径，这些将在<strong class="jp ir">创建函数</strong>步骤中使用。</strong></p><blockquote class="ln lo lp"><p id="0e0d" class="jn jo lq jp b jq jr js jt ju jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj kk ij bi translated"><em class="iq">你可以在</em> <a class="ae kz" href="https://github.com/OpenFunction/samples/tree/main/functions/OpenFuncAsync/logs-handler-function" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> OpenFunction示例</em> </a> <em class="iq">中找到这个案例。</em></p></blockquote><h1 id="beb3" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">创建一个函数</h1><p id="c333" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">使用OpenFunction构建上述函数。首先，设置一个密钥文件<code class="fe my mz na nb b">push-secret</code>来访问映像库(在使用代码构建了OCI映像之后，OpenFunction会将映像上传到映像库，以便后续的加载启动。):</p><pre class="lb lc ld le gt nc nb nd ne aw nf bi"><span id="efcb" class="ng lw iq nb b gy nh ni l nj nk">REGISTRY_SERVER=https://index.docker.io/v1/ REGISTRY_USER=&lt;your username&gt; REGISTRY_PASSWORD=&lt;your password&gt;<br/>kubectl create secret docker-registry push-secret \<br/>    --docker-server=$REGISTRY_SERVER \<br/>    --docker-username=$REGISTRY_USER \<br/>    --docker-password=$REGISTRY_PASSWORD</span></pre><p id="c240" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用功能配置文件<code class="fe my mz na nb b">logs-handler-function.yaml</code>。</p><blockquote class="ln lo lp"><p id="5c0c" class="jn jo lq jp b jq jr js jt ju jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj kk ij bi translated"><em class="iq">功能定义解释了两个关键组件的使用:</em></p><p id="0f97" class="jn jo lq jp b jq jr js jt ju jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj kk ij bi translated"><a class="ae kz" href="https://dapr.io/" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> Dapr </em> </a> <em class="iq">将复杂的中间件屏蔽于应用程序之外，使得</em> <code class="fe my mz na nb b"><em class="iq">logs-handler</em></code> <em class="iq">函数可以轻松处理Kafka事件。</em></p><p id="078d" class="jn jo lq jp b jq jr js jt ju jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj kk ij bi translated"><a class="ae kz" href="https://keda.sh/" rel="noopener ugc nofollow" target="_blank"><em class="iq"/></a><em class="iq">通过监控消息服务器中的事件流量来驱动</em> <code class="fe my mz na nb b"><em class="iq">logs-handler</em></code> <em class="iq">功能的启动，并基于Kafka消息的消费延迟来动态扩展</em> <code class="fe my mz na nb b"><em class="iq">logs-handler</em></code> <em class="iq">实例。</em></p></blockquote><pre class="lb lc ld le gt nc nb nd ne aw nf bi"><span id="1e2a" class="ng lw iq nb b gy nh ni l nj nk">apiVersion: core.openfunction.io/v1alpha1<br/>kind: Function<br/>metadata:<br/>  name: logs-handler<br/>spec:<br/>  version: "v1.0.0"<br/>  # Defines the upload path for the built image.<br/>  image: openfunctiondev/logs-async-handler:v1<br/>  imageCredentials:<br/>    name: push-secret<br/>  build:<br/>    builder: openfunctiondev/go115-builder:v0.2.0<br/>    env:<br/>      FUNC_NAME: "LogsHandler"<br/>    # Defines the path of the source code.<br/>    # url specifies the URL of the above-mentioned code repository.<br/>    # sourceSubPath specifies the path of the code in the repository.<br/>    srcRepo:<br/>      url: "https://github.com/OpenFunction/samples.git"<br/>      sourceSubPath: "functions/OpenFuncAsync/logs-handler-function/"<br/>  serving:<br/>    # OpenFuncAsync is an event-driven, asynchronous runtime implemented in OpenFunction by using KEDA_Dapr.<br/>    runtime: "OpenFuncAsync"<br/>    openFuncAsync:<br/>      # This section defines the function input (kafka-receiver) and the output (notification-manager), which correspond to definitions in the components section.<br/>      dapr:<br/>        inputs:<br/>          - name: kafka-receiver<br/>            type: bindings<br/>        outputs:<br/>          - name: notification-manager<br/>            type: bindings<br/>            params:<br/>              operation: "post"<br/>              type: "bindings"<br/>        annotations:<br/>          dapr.io/log-level: "debug"<br/>        # This section defines the above-mentioned input and output (that is, Dapr Components).<br/>        components:<br/>          - name: kafka-receiver<br/>            type: bindings.kafka<br/>            version: v1<br/>            metadata:<br/>              - name: brokers<br/>                value: "kafka-logs-receiver-kafka-brokers:9092"<br/>              - name: authRequired<br/>                value: "false"<br/>              - name: publishTopic<br/>                value: "logs"<br/>              - name: topics<br/>                value: "logs"<br/>              - name: consumerGroup<br/>                value: "logs-handler"<br/>          # This is the URL of KubeSphere notification-manager.<br/>          - name: notification-manager<br/>            type: bindings.http<br/>            version: v1<br/>            metadata:<br/>              - name: url<br/>                value: <a class="ae kz" href="http://notification-manager-svc.kubesphere-monitoring-system.svc.cluster.local:19093/api/v2/alerts" rel="noopener ugc nofollow" target="_blank">http://notification-manager-svc.kubesphere-monitoring-system.svc.cluster.local:19093/api/v2/alerts</a><br/>      keda:<br/>        scaledObject:<br/>          pollingInterval: 15<br/>          minReplicaCount: 0<br/>          maxReplicaCount: 10<br/>          cooldownPeriod: 30<br/>          # This section defines the trigger of the function, that is, the log topic of the Kafka server.<br/>          # This section also defines the message lag threshold (the value is 10), which means that when the number of lagged messages exceeds 10, the number of logs-handler instances will automatically scale out.<br/>          triggers:<br/>            - type: kafka<br/>              metadata:<br/>                topic: logs<br/>                bootstrapServers: kafka-logs-receiver-kafka-brokers.default.svc.cluster.local:9092<br/>                consumerGroup: logs-handler<br/>                lagThreshold: "10"</span></pre><h1 id="7730" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">展示结果</h1><p id="a62d" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">先关闭Kafka日志接收器:在<strong class="jp ir">日志收藏</strong>页面，点击<strong class="jp ir"> Kafka </strong>进入详情页，选择<strong class="jp ir">更多</strong> &gt; <strong class="jp ir">更改状态</strong> &gt; <strong class="jp ir">关闭</strong>。</p><p id="1f15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">等待一会儿，然后可以观察到<code class="fe my mz na nb b">logs-handler</code>函数的实例数量已经减少到0。</p><p id="2476" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后将Kafka日志接收器的状态设置为<strong class="jp ir">收集</strong>，同时<code class="fe my mz na nb b">logs-handler</code>也开始。</p><pre class="lb lc ld le gt nc nb nd ne aw nf bi"><span id="c5a3" class="ng lw iq nb b gy nh ni l nj nk">~# kubectl get po --watch<br/>NAME                           READY STATUS        RESTARTS    AGE<br/>kafka-logs-receiver-entity<br/>-operator-568957ff84-tdrrx     3/3    Running      0          7m27s<br/>kafka-logs-receiver-kafka-0    1/1    Running      0          7m48s<br/>kafka-logs-receiver<br/>-zookeeper-0                   1/1    Running      0          8m12s<br/>logs-handler-serving-kpngc<br/>-v100-zcj4q-5f46996f8c-b9d6f   2/2    Terminating  0          34s<br/>strimzi-cluster-operator<br/>-687fdd6f77-kc8cv              1/1    Running      0          10m<br/>logs-handler-serving-kpngc<br/>-v100-zcj4q-5f46996f8c-b9d6f   2/2    Terminating  0          36s<br/>logs-handler-serving<br/>-kpngc-v100-zcj4q-5f46996f8c<br/>-b9d6f                         0/2    Terminating   0         37s<br/>logs-handler-serving-kpngc<br/>-v100-zcj4q-5f46996f8c-b9d6f   0/2    Terminating   0         38s<br/>logs-handler-serving-kpngc<br/>-v100-zcj4q-5f46996f8c-b9d6f   0/2    Terminating   0         38s<br/>logs-handler-serving-kpngc<br/>-v100-zcj4q-5f46996f8c-9kj2c   0/2    Pending       0         0s<br/>logs-handler-serving-kpngc<br/>-v100-zcj4q-5f46996f8c-9kj2c   0/2    Pending       0         0s<br/>logs-handler-serving-kpngc<br/>-v100-zcj4q-5f46996f8c-9kj2c   0/2    ContainerCreating   0   0s<br/>logs-handler-serving-kpngc<br/>-v100-zcj4q-5f46996f8c-9kj2c   0/2    ContainerCreating   0   2s<br/>logs-handler-serving-kpngc<br/>-v100-zcj4q-5f46996f8c-9kj2c   1/2     Running      0         4s<br/>logs-handler-serving-kpngc<br/>-v100-zcj4q-5f46996f8c-9kj2c   2/2     Running      0         11s</span></pre><p id="dacd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，初始化一个不存在的WordPress应用程序路径请求:</p><pre class="lb lc ld le gt nc nb nd ne aw nf bi"><span id="7c68" class="ng lw iq nb b gy nh ni l nj nk">curl http://&lt;wp-svc-address&gt;/notfound</span></pre><p id="3d7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以看到Slack收到了这条消息(当我们正常访问WordPress站点时，Slack不会收到提醒消息)。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi la"><img src="../Images/033ae809a1d5186f59b3746722ed1a07.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/0*xuhSbWHif1I34Z6m"/></div></figure><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi nm"><img src="../Images/3d8ed3c0b7400b13146f9d07b05e1c90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*njpt8i66uo6v-CEl.png"/></div></div></figure><h1 id="1922" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">探索更多可能性</h1><p id="7592" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">我们可以进一步讨论使用同步函数的解决方案:</p><p id="524d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了正确使用Knative服务，我们需要设置其网关的负载平衡器地址。(您可以使用本地地址作为解决方法。)</p><pre class="lb lc ld le gt nc nb nd ne aw nf bi"><span id="fdf1" class="ng lw iq nb b gy nh ni l nj nk"># Repalce the following "1.2.3.4" with the actual values.<br/>$ kubectl patch svc -n kourier-system kourier \<br/>-p '{"spec": {"type": "LoadBalancer", "externalIPs": ["1.2.3.4"]}}'$ kubectl patch configmap/config-domain -n knative-serving \<br/>-type merge --patch '{"data":{"1.2.3.4.sslip.io":""}}'</span></pre><p id="7412" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">OpenFunction通过两种方式驱动<code class="fe my mz na nb b">Knative</code>函数的运行:(1)以异步方式使用Kafka服务器；(2)使用自己的事件框架连接Kafka服务器，然后以Sink模式运行。可以参考<a class="ae kz" href="https://github.com/OpenFunction/samples/tree/main/functions/Knative/logs-handler-function" rel="noopener ugc nofollow" target="_blank"> OpenFunction样例</a>中的案例。</p><p id="836b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种解决方案中，同步函数的处理速度低于异步函数。我们也可以用KEDA来触发Knative Serving的并发机制，但是没有异步函数那么方便。(未来我们会对OpenFunction事件框架进行优化，弥补同步函数的不足。)</p><p id="db89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以看出，根据任务场景的不同，不同类型的无服务器功能有其独特的优势。例如，在处理有序的控制流函数时，同步函数比异步函数更好。</p><h1 id="9d66" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">摘要</h1><p id="21c8" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">无服务器符合我们对业务场景快速拆解和重构的期望。</p><p id="0c97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您在本例中所看到的，OpenFunction不仅通过使用无服务器技术增加了日志处理和警报通知链接的灵活性，还使用了一个函数框架来将连接Kafka通常所需的复杂设置简化为语义清晰的代码。此外，我们还在不断开发OpenFunction，以便在后续版本中，组件可以由我们自己的无服务器功能提供支持。</p><h1 id="f5ca" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">关于KubeSphere</h1><p id="4322" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">KubeSphere是一个基于Kubernetes的开源容器平台，其核心是应用程序。它提供全栈It自动化操作和简化的开发运维工作流。</p><p id="c23a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kz" href="https://kubesphere.io/" rel="noopener ugc nofollow" target="_blank"> KubeSphere </a>已被全球数千家企业采用，如<strong class="jp ir"> Aqara、新浪、奔来、中国太平、华夏银行、国药控股、微众银行、Geko Cloud、VNG公司、Radore </strong>。KubeSphere为运维提供向导界面和各种企业级功能，包括Kubernetes资源管理、<a class="ae kz" href="https://kubesphere.io/devops/" rel="noopener ugc nofollow" target="_blank">、DevOps (CI/CD) </a>、应用生命周期管理、服务网格、多租户管理、<a class="ae kz" href="https://kubesphere.io/observability/" rel="noopener ugc nofollow" target="_blank">监控</a>、日志记录、警报、通知、存储和网络管理以及GPU支持。有了KubeSphere，企业能够快速建立一个强大且功能丰富的容器平台。</p><p id="c906" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欲了解更多信息，请访问<a class="ae kz" href="https://kubesphere.io/" rel="noopener ugc nofollow" target="_blank"> https://kubesphere.io </a></p></div></div>    
</body>
</html>