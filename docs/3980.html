<html>
<head>
<title>Caching in a PWA: When to use Optimistic vs Pessimistic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PWA中的缓存:何时使用乐观还是悲观</h1>
<blockquote>原文：<a href="https://itnext.io/caching-in-a-pwa-when-to-use-optimistic-vs-pessimistic-d627a5943990?source=collection_archive---------4-----------------------#2020-04-05">https://itnext.io/caching-in-a-pwa-when-to-use-optimistic-vs-pessimistic-d627a5943990?source=collection_archive---------4-----------------------#2020-04-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bbbc1cf7a79d204e53074e6769f84d0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qpc8gHdUKlMwwWUVWWCWAQ.jpeg"/></div></div></figure><p id="742c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让任何应用程序成为渐进式Web应用程序的第一步是通过ServiceWorkers引入一个离线页面。服务人员带来了许多附加功能，其中很大一部分与缓存有关。无论是在页面级、资产级甚至是字体级，所有类型和场景的缓存都有自己的策略。今天我们将只讨论其中的两个。它们是乐观缓存和悲观缓存。我们将在后续的文章中讨论实现细节，所以这里只关注策略本身。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="0ef5" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">乐观缓存</h1><p id="16fd" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">你可以认为“网络”是战略的重点。因此，乐观的缓存是当您最初检查网络，然后回退到任何缓存存储时，所以这是一种<em class="mg">网络优先</em>的方法。</p><p id="f366" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以这个过程应该是:</p><ol class=""><li id="c5e0" class="mh mi iq ka b kb kc kf kg kj mj kn mk kr ml kv mm mn mo mp bi translated"><em class="mg">用户是否拥有有效的网络连接</em></li><li id="6e6c" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated"><em class="mg">如果是- &gt;从网络请求数据</em></li><li id="db94" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated"><em class="mg">如果否- &gt;从缓存中请求数据</em></li></ol><p id="4ee3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您的数据经常变化，并且向用户显示陈旧的数据会带来负面的用户体验(甚至可能更糟)时，这是非常有用的。</p><p id="e29e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可能有用的一些例子是:</p><ul class=""><li id="f0d0" class="mh mi iq ka b kb kc kf kg kj mj kn mk kr ml kv mv mn mo mp bi translated">用户资料页面:如果用户更新了内容，而此时内容显示不正确，这会令人非常沮丧和担忧</li><li id="7d39" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mv mn mo mp bi translated">库存水平:给出一个不正确的可用数量可能会导致非常混乱的情况，浪费客户和卖家的时间和金钱。</li></ul><p id="03ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于“乐观缓存”要提到的最后一点是，它显然依赖于一种可靠的方法来确定您的用户是否有网络连接，理想情况下不会让他们等待请求失败。现在可以从服务人员内部使用<a class="ae mw" href="https://developer.mozilla.org/en-US/docs/Web/API/Network_Information_API" rel="noopener ugc nofollow" target="_blank">网络信息API </a>。这样支票就变成了1号线:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="d850" class="ng le iq nc b gy nh ni l nj nk">if (navigator.onLine) { <br/>   // user is online<br/>   // ...</span></pre><p id="9aee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是支持不是很好(目前在FireFox和iPhone Safari上缺失)。因此，在运行这个逻辑之前，您可能必须先做一个特性检查。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="a8fe" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">悲观缓存</h1><p id="815c" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">因此，如果乐观使用网络，悲观不使用网络，是一种<em class="mg">缓存优先</em>方法。这种类型的缓存的思想是检查数据的缓存，然后退回到网络。如果网络仍然失败，则显示一个错误。</p><p id="5c15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以这个过程应该是:</p><ol class=""><li id="c70c" class="mh mi iq ka b kb kc kf kg kj mj kn mk kr ml kv mm mn mo mp bi translated"><em class="mg">缓存是否有所需的数据</em></li><li id="3be9" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated"><em class="mg">如果是- &gt;从缓存中返回该数据</em></li><li id="cdc4" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated"><em class="mg">如果否- &gt;从网络请求数据</em></li></ol><p id="73d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您的数据根本不经常更改，并且每次都发出网络请求是浪费资源的时候，这是非常有用的。</p><p id="540c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可能有用的一些例子是:</p><ul class=""><li id="c1d1" class="mh mi iq ka b kb kc kf kg kj mj kn mk kr ml kv mv mn mo mp bi translated">产品页面:如果一个产品的详细信息不经常改变，你可以确信相同的产品ID/SKU内容将在一段时间内保持不变</li><li id="61af" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mv mn mo mp bi translated">产品系列页面:如果一个系列中的产品不经常变化，那么每次都请求详细信息是没有意义的。</li><li id="be01" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mv mn mo mp bi translated">博客内容:如果写的文章不太可能经常改变，那么使用缓存似乎是安全的</li></ul><p id="62e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们看到类似悲观缓存行为的一个真实例子是“乐观UI”的概念。我们在假设远程操作成功的情况下进行本地更改(例如，用户单击保存，会显示一条提示保存完成的消息，即使网络请求尚未回复)。阿波罗文档有很大一部分是关于它的。这类似于悲观缓存，因为它是缓存优先的。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="851f" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">综上</h1><p id="b1c0" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">你可以在上面看到，这两种策略在不同的情况下都是有用的，所以这都是关于对给定的页面/资产/资源等做出正确的调用。我觉得我们有这么多可用的选项真是太好了，因为它真的帮助我们在应用程序上获得尽可能好的体验💪</p><p id="c4ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你觉得这很有用，请鼓掌，谢谢😁</p></div></div>    
</body>
</html>