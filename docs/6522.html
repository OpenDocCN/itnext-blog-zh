<html>
<head>
<title>How to use Stack Views in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在iOS中使用堆栈视图</h1>
<blockquote>原文：<a href="https://itnext.io/ios-stack-views-making-ui-development-easy-f81e0f00c193?source=collection_archive---------1-----------------------#2021-12-09">https://itnext.io/ios-stack-views-making-ui-development-easy-f81e0f00c193?source=collection_archive---------1-----------------------#2021-12-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="36d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我知道堆栈视图从iOS 9开始就可用了，但我还是想写一篇关于它的文章。我真的很感激他们让设计过程变得如此简单。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/9e4500b0c995838156b7f1de332e8cfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zv7VRq5zq709WMBZAg2qCg.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片来自<a class="ae le" href="https://unsplash.com/photos/rS1GogPLVHk" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="877b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在iOS UI开发的早期，有Struts和Springs，它们以各种费力和紧张的方式来组织视图。你将不得不使用自动调整大小蒙版，有时甚至求助于代码来获得由你的团队中的花式设计师提供的复杂视图。</p><p id="e8ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了取代这种可怕的现象，iOS 6中出现了自动布局。就UI开发而言，这是一个巨大的进步。您可以在同级视图之间提供约束，或者添加相对于超级视图的约束。可以相对容易地创建复杂的视图。但是自动布局有它自己的问题。尽管它减少了设计复杂问题的工作量，但仍需要添加许多约束。我们将在下面看到一个例子。</p><p id="04e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">UI的另一个主要改进是iOS 9对堆栈视图的支持。顾名思义，你将视图添加到一个堆栈视图中，它将水平或垂直地堆叠它们。这比听起来要灵活得多。在内部，虽然堆栈视图使用自动布局。</p><p id="ab67" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将看看本文中的一个例子，它将向我们展示堆栈视图的强大功能。</p><h1 id="acb6" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">示例:带有堆栈视图的纵向和横向矩形</h1><p id="3ac5" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们将重新创建<a class="ae le" href="https://www.raywenderlich.com/811496-auto-layout-tutorial-in-ios-getting-started" rel="noopener ugc nofollow" target="_blank">这个</a>教程的屏幕。这是最终的结果。使用自动布局时，最少使用25–30个约束，而使用堆栈视图时，仅使用4个约束。<strong class="js iu">是的！只有4个约束。</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mi"><img src="../Images/a9e1fb189bef40241a6c165acf70fa14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pd_V68VIwHYaIwhjXsnLbQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">最终横向和纵向屏幕</figcaption></figure><p id="fb16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，在你的视图控制器中添加一个垂直堆栈视图，并在所有边上指定20作为该堆栈视图的最近邻的间距。让我们称之为<strong class="js iu">父</strong>堆栈视图。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/1dfeaa35b886378ca0d7d95e8e4f161c.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*OsgxmLUSHCCG-oFzPC6XxQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">唯一需要的4个约束</figcaption></figure><p id="f4e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意:</strong>这是我们将添加的仅有的4个约束。</p><p id="5985" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其次，到属性检查器，设置分布为“平均填充”。这是必要的，这样当我们添加子视图时，它们具有相同的高度。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/0d397123e180e7bbad4b93167f21d51c.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*E-oQ4q7Ugo45dUEm3o379g.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">将分配设置为“平均填充”</figcaption></figure><p id="96ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，在主垂直堆栈视图中添加一个水平堆栈视图(姑且称之为<strong class="js iu">行</strong>)，并将其分布标记为“均匀填充”。顾名思义<strong class="js iu">行</strong>在<strong class="js iu">父</strong>中包含一行。</p><p id="62f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，在<strong class="js iu">行</strong>中添加一个垂直堆栈视图。我们可以将这个垂直堆栈视图命名为<strong class="js iu">容器。</strong>一个单独的<strong class="js iu">容器</strong>里面会有一个图像和一个标签，还有它自己单独的颜色。为了区分<strong class="js iu">容器</strong>,设置背景颜色为系统紫色或任何你喜欢的颜色。稍后我们将添加更多的容器。</p><p id="b2f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，向<strong class="js iu">容器添加一个图像和一个标签。在我们接下来要解决的约束中，你可能会遇到一些冲突。我们不希望标签被垂直拉伸，而是图像应该被拉伸。要实现这一点，选择标签的大小检查器，并标记<em class="ml">垂直内容拥抱优先级</em>为必需或高于图像的优先级，如下所示。所有的冲突现在都应该解决了</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/3c0fbef6d7b808da990a5a97e07a41ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*iQh3YnE0nFcu5eHwujHkPw.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">垂直内容拥抱优先级</figcaption></figure><p id="1993" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在“属性”检查器中，将您喜欢的任何图像设定为图像视图，并将内容模式设定为图像的中心。</p><p id="3c32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您的视图控制器将如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/d382fb4407c30e46d38942d81c300424.png" data-original-src="https://miro.medium.com/v2/resize:fit:368/format:webp/1*UIb63X6yXN0zeqiHygFjVw.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">视图控制器</figcaption></figure><p id="f679" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">主要是缺了一些间距和边距。选择<strong class="js iu">容器</strong>堆栈视图<strong class="js iu"> </strong>并在属性检查器中将间距设置为20。我们还想给<strong class="js iu">容器</strong>添加一些填充，这样图像和标签就不会粘在边框上。转到尺寸检查器，从下拉菜单中设置布局边距为固定。将左、右&amp;上边距设置为20°，下边距设置为30°。您可以根据自己的喜好更改这些内容。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mo"><img src="../Images/7d66e58fe0b59e57951d2e6b5484e40d.png" data-original-src="https://miro.medium.com/v2/resize:fit:372/format:webp/1*9Y5DY88btiieGo8f7YTLNA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">设置边距和间距后查看控制器</figcaption></figure><p id="de53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您的视图控制器结构应该如下所示</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/ab1845d78ad7f5fe478c785787558e95.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*wR7kATz6R6rfdoO9lJMQaQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">视图控制器结构</figcaption></figure><p id="fe33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是时候复制粘贴东西了。这就是栈视图的妙处。因为没有约束，你可以复制过去的视图，而不用担心冲突、警告或者UI错误。</p><p id="e66b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">选择<strong class="js iu">容器</strong>并复制粘贴。您将获得以下结果:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mq"><img src="../Images/b07901ab26058b11a09505a6160989e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*lCB-po9_1YpKVOh-tjmkcw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">复制了容器</figcaption></figure><p id="c016" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后复制<strong class="js iu">行</strong>并粘贴。我们离最终结果如此之近。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/d15d4da24958ab858825ef6f33778671.png" data-original-src="https://miro.medium.com/v2/resize:fit:408/format:webp/1*kBAQboL6Cj_siEY9OGjA8Q.png"/></div></figure><p id="e70e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">改变每个<strong class="js iu">容器</strong>的背景颜色，以获得更漂亮的视图。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/2e069a9ff560f691a76ac8bd113dd539.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/1*KN7Xmnila-yVtUZ3-IGnLg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">每个容器有不同的背景颜色</figcaption></figure><p id="f500" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当你在横向模式下旋转它时，你会得到这个很好的缩放屏幕。要润色本页，请根据需要更改图像和标签。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/4262d0d12d354a385b6f19ad2c1795e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*0ejH5aQoZ2iYGIfPMdie7Q.png"/></div></figure><p id="b90a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我怎么强调堆栈视图让我的生活变得如此简单都不为过。</p><h1 id="1983" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">优点</strong></h1><p id="999a" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">正如我们所见，当视图需要堆叠时，堆叠视图非常有用。</p><ul class=""><li id="5a88" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">使用堆栈视图的一个主要优点是，除了父堆栈视图之外，无需设置约束就可以复制粘贴它。</li><li id="b552" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">堆栈视图也非常容易集成到滚动视图中。只需要设置父堆栈视图的约束。</li><li id="1601" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">如果您从堆栈视图中间移除一个视图，其他视图会自动排列。与约束相比，这是一个巨大的优势。</li></ul><h1 id="184c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">不足之处</h1><p id="c69f" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">就我个人而言，我没有发现使用堆栈视图的任何主要缺点或劣势。我唯一不使用堆栈视图的时候是在视图或屏幕中有太多重叠元素的时候。在这种情况下，堆栈视图没有帮助。</p><h1 id="61d1" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="06ab" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">总之，我喜欢堆栈视图，并且一直在用它来设计我99%的视图。与自动布局甚至Swift UI相比，它们使用起来非常简单灵活，非常直观。苹果这么晚才推出，我有点生气。</p><p id="adc6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">PS:堆栈视图在Android中是以LinearLayout的形式出现的。</p><p id="18e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以在苹果官方网站<a class="ae le" href="https://developer.apple.com/documentation/uikit/uistackview" rel="noopener ugc nofollow" target="_blank">这里</a>找到关于UIStackView的更多细节。</p></div></div>    
</body>
</html>