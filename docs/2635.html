<html>
<head>
<title>🌍 Creating React usePosition() hook for getting browser’s geolocation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">🌍创建React usePosition()挂钩以获取浏览器的地理位置</h1>
<blockquote>原文：<a href="https://itnext.io/creating-react-useposition-hook-for-getting-browsers-geolocation-2f27fc1d96de?source=collection_archive---------0-----------------------#2019-06-30">https://itnext.io/creating-react-useposition-hook-for-getting-browsers-geolocation-2f27fc1d96de?source=collection_archive---------0-----------------------#2019-06-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c4d05ca421aea15921359e1c52c4401e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ja821leVLCOgq3qtdwyg9g.jpeg"/></div></div></figure><h2 id="4822" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="f0f5" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">在本文中，我们将创建一个React <em class="lp"> usePosition() </em>钩子来获取并跟踪浏览器的位置。我们将使用全局对象<em class="lp"> navigator.geolocation </em>提供的<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition" rel="noopener ugc nofollow" target="_blank"><em class="lp">getCurrentPosition</em></a>和<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition" rel="noopener ugc nofollow" target="_blank"> <em class="lp"> watchPosition </em> </a>函数。<em class="lp"> usePosition() </em>钩子的最终版本是<a class="ae lq" href="https://github.com/trekhleb/use-position" rel="noopener ugc nofollow" target="_blank"> <strong class="kw ir"> <em class="lp">发布在GitHub </em> </strong> </a>和<a class="ae lq" href="https://www.npmjs.com/package/use-position" rel="noopener ugc nofollow" target="_blank"><strong class="kw ir"><em class="lp">【NPM】</em></strong></a>上，准备好被你的应用消费。</p><h2 id="234f" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">为什么我们可能需要usePosition()钩子</h2><p id="20bf" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated"><a class="ae lq" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">反应钩子</a>的一个优点是<em class="lp">能够分离关注点</em>。我们可以完全避免使用状态，而只使用两个不同的钩子来为我们处理状态管理，而不是使用一个带有地理位置<strong class="kw ir">和</strong>套接字连接的状态对象。此外，我们可以将这个逻辑分成两个独立的钩子，而不是在同一个<em class="lp">componentidmount()</em>回调中启动浏览器位置监视器<strong class="kw ir">和</strong>打开套接字连接。这给了我们更干净和更易维护的代码。</p><h2 id="6eb2" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">我们将如何使用Position()钩子</h2><p id="6ffd" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">让我们做一些逆向工程，想象我们已经实现了一个<em class="lp"> usePosition() </em>钩子。下面是我们可能想要使用它的方式:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="804b" class="jy jz iq lw b gy ma mb l mc md">import React from 'react';<br/>import {usePosition} from './usePosition';</span><span id="a370" class="jy jz iq lw b gy me mb l mc md">export const UsePositionDemo = () =&gt; {<br/>  const {latitude, longitude, error} = usePosition();</span><span id="ed8b" class="jy jz iq lw b gy me mb l mc md">  return (<br/>    &lt;code&gt;<br/>      latitude: {latitude}&lt;br/&gt;<br/>      longitude: {longitude}&lt;br/&gt;<br/>      error: {error}<br/>    &lt;/code&gt;<br/>  );<br/>};</span></pre><p id="51b2" class="pw-post-body-paragraph ku kv iq kw b kx mf kz la lb mg ld le kh mh lg lh kl mi lj lk kp mj lm ln lo ij bi translated">你看，用<em class="lp"> usePosition() </em>钩子只有一行，你已经有数据了(<em class="lp">纬度</em>和<em class="lp">经度</em>)。我们这里甚至不用<em class="lp"> useState() </em>和<em class="lp"> useEffect() </em>。位置订阅和观察器清理封装在<em class="lp"> usePosition() </em>钩子中。现在，React将为我们处理重绘组件魔术，我们将看到<em class="lp"> &lt;代码&gt;…&lt;/代码&gt; </em>块不断更新浏览器的最新位置值。看起来很整洁干净。</p><h2 id="62f0" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">usePosition()钩子实现</h2><p id="ec51" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">我们自定义的<em class="lp"> usePosition() </em> hook只是一个JavaScript函数，它使用了其他类似<a class="ae lq" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank"> <em class="lp"> useState() </em> </a>和<a class="ae lq" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank"> <em class="lp"> useEffect() </em> </a>的钩子。它看起来会像这样:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="c067" class="jy jz iq lw b gy ma mb l mc md">// imports go here...</span><span id="3492" class="jy jz iq lw b gy me mb l mc md">export const usePosition = () =&gt; {<br/>  // code goes here...<br/>}</span></pre><p id="be22" class="pw-post-body-paragraph ku kv iq kw b kx mf kz la lb mg ld le kh mh lg lh kl mi lj lk kp mj lm ln lo ij bi translated">我们将使用<em class="lp"> useEffect() </em>钩子来钩住组件(将使用我们的钩子)被渲染的时刻，并订阅地理位置的变化。我们还将使用<em class="lp"> useState() </em>钩子来存储<em class="lp">纬度</em>、<em class="lp">经度</em>和<em class="lp">错误</em>消息(以防用户不允许浏览器共享其位置)。所以我们需要首先导入这些钩子:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="9363" class="jy jz iq lw b gy ma mb l mc md">import {useState, useEffect} from 'react';</span><span id="0f1d" class="jy jz iq lw b gy me mb l mc md">export const usePosition = () =&gt; {<br/>  // code goes here...<br/>}</span></pre><p id="9bed" class="pw-post-body-paragraph ku kv iq kw b kx mf kz la lb mg ld le kh mh lg lh kl mi lj lk kp mj lm ln lo ij bi translated">让我们为位置和错误初始化一个存储:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="7e17" class="jy jz iq lw b gy ma mb l mc md">import {useState, useEffect} from 'react';</span><span id="9a9c" class="jy jz iq lw b gy me mb l mc md">export const usePosition = () =&gt; {<br/>  const [position, setPosition] = useState({});<br/>  const [error, setError] = useState(null);<br/>  <br/>  // other code goes here...<br/>}</span></pre><p id="263c" class="pw-post-body-paragraph ku kv iq kw b kx mf kz la lb mg ld le kh mh lg lh kl mi lj lk kp mj lm ln lo ij bi translated">让我们从函数中返回一个理想值。我们还没有它们，但是让我们返回到目前为止的初始值，以后再填充它们:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="5e0a" class="jy jz iq lw b gy ma mb l mc md">import {useState, useEffect} from 'react';</span><span id="ab99" class="jy jz iq lw b gy me mb l mc md">export const usePosition = () =&gt; {<br/>  const [position, setPosition] = useState({});<br/>  const [error, setError] = useState(null);<br/>  <br/>  // other code goes here...</span><span id="b89d" class="jy jz iq lw b gy me mb l mc md">  return {...position, error};<br/>}</span></pre><p id="e6e9" class="pw-post-body-paragraph ku kv iq kw b kx mf kz la lb mg ld le kh mh lg lh kl mi lj lk kp mj lm ln lo ij bi translated">这是我们钩子的一个关键部分——获取浏览器的位置。我们将在组件渲染后执行提取逻辑(useEffect hook)。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="e2d3" class="jy jz iq lw b gy ma mb l mc md">import {useState, useEffect} from 'react';</span><span id="0ceb" class="jy jz iq lw b gy me mb l mc md">export const usePosition = () =&gt; {<br/>  const [position, setPosition] = useState({});<br/>  const [error, setError] = useState(null);<br/>  <br/>  // callbacks will go here...</span><span id="deba" class="jy jz iq lw b gy me mb l mc md">  useEffect(() =&gt; {<br/>    const geo = navigator.geolocation;<br/>    if (!geo) {<br/>      setError('Geolocation is not supported');<br/>      return;<br/>    }</span><span id="cab9" class="jy jz iq lw b gy me mb l mc md">    watcher = geo.watchPosition(onChange, onError);</span><span id="a066" class="jy jz iq lw b gy me mb l mc md">    return () =&gt; geo.clearWatch(watcher);<br/>  }, []);</span><span id="74f0" class="jy jz iq lw b gy me mb l mc md">  return {...position, error};<br/>}</span></pre><p id="a596" class="pw-post-body-paragraph ku kv iq kw b kx mf kz la lb mg ld le kh mh lg lh kl mi lj lk kp mj lm ln lo ij bi translated">在useEffect() hook中，我们首先做一些检查，看看浏览器是否支持<em class="lp"> navigator.geolocation </em>。如果不支持地理定位，我们将设置一个错误并从效果中返回。如果支持<em class="lp"> navigator.geolocation </em>，我们将通过提供<em class="lp"> onChange() </em>和<em class="lp"> onError() </em>回调来订阅位置更改(我们稍后将添加它们)。注意，我们从<em class="lp"> useEffect() </em>返回了一个lambda函数。在lambda函数中，一旦组件被卸载，我们就清除观察器。因此，这个订阅/取消订阅逻辑将由我们的<em class="lp"> usePosition() </em>钩子在内部处理，消费者不必担心。</p><p id="52de" class="pw-post-body-paragraph ku kv iq kw b kx mf kz la lb mg ld le kh mh lg lh kl mi lj lk kp mj lm ln lo ij bi translated">现在让我们添加缺失的回调:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="f324" class="jy jz iq lw b gy ma mb l mc md">import {useState, useEffect} from 'react';</span><span id="6d33" class="jy jz iq lw b gy me mb l mc md">export const usePosition = () =&gt; {<br/>  const [position, setPosition] = useState({});<br/>  const [error, setError] = useState(null);<br/>  <br/>  const onChange = ({coords}) =&gt; {<br/>    setPosition({<br/>      latitude: coords.latitude,<br/>      longitude: coords.longitude,<br/>    });<br/>  };</span><span id="127e" class="jy jz iq lw b gy me mb l mc md">  const onError = (error) =&gt; {<br/>    setError(error.message);<br/>  };</span><span id="be00" class="jy jz iq lw b gy me mb l mc md">  useEffect(() =&gt; {<br/>    const geo = navigator.geolocation;<br/>    if (!geo) {<br/>      setError('Geolocation is not supported');<br/>      return;<br/>    }</span><span id="4556" class="jy jz iq lw b gy me mb l mc md">    watcher = geo.watchPosition(onChange, onError);</span><span id="09a8" class="jy jz iq lw b gy me mb l mc md">    return () =&gt; geo.clearWatch(watcher);<br/>  }, []);</span><span id="cb89" class="jy jz iq lw b gy me mb l mc md">  return {...position, error};<br/>}</span></pre><p id="587e" class="pw-post-body-paragraph ku kv iq kw b kx mf kz la lb mg ld le kh mh lg lh kl mi lj lk kp mj lm ln lo ij bi translated">我们结束了。钩子<em class="lp"> usePosition() </em>可以被使用，它只封装地理位置相关的逻辑。</p><h2 id="b517" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">编后记</h2><p id="c636" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">你可能会在GitHub  上找到一个<a class="ae lq" href="https://trekhleb.github.io/use-position/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw ir">演示</strong> </a>和更详细的<a class="ae lq" href="https://github.com/trekhleb/use-position" rel="noopener ugc nofollow" target="_blank"> <strong class="kw ir"> usePosition()钩子实现。我希望这个例子对你有所启发。编码快乐！</strong></a></p></div></div>    
</body>
</html>