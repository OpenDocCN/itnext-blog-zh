<html>
<head>
<title>Deep Dive to Cluster API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入了解集群API</h1>
<blockquote>原文：<a href="https://itnext.io/deep-dive-to-cluster-api-a0b4e792d57d?source=collection_archive---------3-----------------------#2019-05-22">https://itnext.io/deep-dive-to-cluster-api-a0b4e792d57d?source=collection_archive---------3-----------------------#2019-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6f24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes是一个流行的开源容器编排平台，用于跨主机集群管理云原生应用程序。它可以通过多种方式部署。您可以使用minikube轻松引导Kubernete集群。您也可以从头开始尝试kubeadm、KIND或手动部署Kubernetes集群。但是您不能使用API部署Kubernetes集群。Cluster API是一个开源项目，用于进行基于API的Kubernetes集群部署。本文详细描述了什么是Kubernetes集群API以及它是如何工作的。作为一个具体的基础设施提供者示例，<a class="ae kl" href="https://github.com/kubernetes-sigs/cluster-api-provider-openstack" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes-sigs/Cluster-api-provider-open stack</a>用于集群API介绍。</p><h1 id="7f6b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">什么是Kubernetes集群API？</h1><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="46a5" class="lt kn iq lp b gy lu lv l lw lx"><em class="ly">“The Cluster API is a Kubernetes project to bring declarative, Kubernetes-style APIs to cluster creation, configuration, and management. It provides optional, additive functionality on top of core Kubernetes.”</em></span><span id="11db" class="lt kn iq lp b gy lz lv l lw lx"><a class="ae kl" href="https://github.com/kubernetes-sigs/cluster-api" rel="noopener ugc nofollow" target="_blank">https://github.com/kubernetes-sigs/cluster-api</a></span></pre><p id="6afd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes通过对象和控制器管理不同的资源。控制器通常管理资源，使其对象的实际状态与规范提供的期望状态相匹配。例如，您可以应用带有yaml规范的部署资源。它管理nginx应用程序。部署控制器的功能有助于进行应用程序复制和滚动更新。但是，对于Kubernetes集群本身，没有Kubernetes的方法来管理它。Cluster API将集群作为Kubernetes中的一种资源，并通过一个控制器来管理其状态。</p><p id="3dd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">集群API将管理功能分为代码管理的两个部分。基本集群API是用于所有提供者的框架。它独立维护。集群API提供者为集群API框架实现不同基础设施的操作细节。借助provider，集群API从不同第三方基础设施供应商的操作细节中抽象出集群及其机器的整体管理功能。</p><p id="7cc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目前有很多提供者实现，比如AWS，Azure等。本文使用Openstack作为实现示例。</p><h1 id="b4fe" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">如何部署和使用集群API？</h1><p id="282b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">要使用API部署集群，可以使用特定的集群API提供者代码库。<a class="ae kl" href="https://github.com/kubernetes-sigs/cluster-api-provider-openstack" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes-sigs/cluster-API-provider-openstack</a>中的README显示了在open stack上创建集群的详细步骤。对于您的第一个基于集群API的Kubernetes部署，您可以参考它。每个准备工作完成后，执行一个命令行来引导集群。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="c507" class="lt kn iq lp b gy lu lv l lw lx">clusterctl create cluster — bootstrap-type kind \<br/>                  -provider openstack \<br/>                  -c examples/openstack/out/cluster.yaml \<br/>                  -m examples/openstack/out/machines.yaml \<br/>                  -p examples/openstack/out/provider-components.yaml</span></pre><p id="e8eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些选项可以分为3个部分:</p><ul class=""><li id="6218" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><code class="fe mo mp mq lp b">bootstrap-type</code>指定引导集群的种类。</li></ul><p id="c87f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">引导集群是一个临时集群，用于预配您在相关资源文件中指定的目标集群。目前，您可以使用KIND、minikube和现有的Kubernetes集群作为引导集群。</p><ul class=""><li id="fb7d" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">本例中的<code class="fe mo mp mq lp b">provider</code>是openstack</li></ul><p id="8578" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您使用不同的基础设施提供者时，它可以是任何提供者。</p><ul class=""><li id="2054" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><code class="fe mo mp mq lp b">cluster.yaml</code>、<code class="fe mo mp mq lp b">machines.yaml</code>和<code class="fe mo mp mq lp b">provider-components.yaml</code>描述了管理目标Kubernetes集群所必需的资源。</li></ul><p id="4380" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mo mp mq lp b">cluster.yaml</code>和<code class="fe mo mp mq lp b">machines.yaml</code>描述集群及其成员机的规格。<code class="fe mo mp mq lp b">provider-components.yaml</code>描述必要的CRD、RBAC和控制器。它还存储在由基础设施提供者引导的机器上部署Kubernetes二进制文件所执行的脚本。</p><p id="32c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当目标集群启动时，您可以通过kubectl的集群API来管理它。这与库伯内特的其他资源是一样的。您只需要操纵<code class="fe mo mp mq lp b">Cluster</code>和<code class="fe mo mp mq lp b">Machine</code>资源来管理您的Kubernetes集群。</p><h1 id="a0a5" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">具体是如何工作的？</h1><p id="8d06" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在准备阶段，<code class="fe mo mp mq lp b">generate-yaml.sh</code>根据<code class="fe mo mp mq lp b">clouds.yaml</code>规范和源代码中的模板YAML文件生成YAML文件。yaml描述了提供者认证和访问信息。它不同于提供商。</p><figure class="lk ll lm ln gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mr"><img src="../Images/b4bd0ea8609fc426ae0347c6052a6c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GyW_UByo7mTLr03h"/></div></div></figure><p id="380c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于生成的<code class="fe mo mp mq lp b">machines.yaml</code>，Openstack机器细节仍需要配置。您需要确保您的机器具有预期的风格、映像、网络、安全组、ssh验证数据等。<code class="fe mo mp mq lp b">clusterctl</code>启动一个引导集群，然后在集群中应用<code class="fe mo mp mq lp b">provider-components.yaml</code>、<code class="fe mo mp mq lp b">cluster.yaml</code>和<code class="fe mo mp mq lp b">machines.yaml</code>。当<code class="fe mo mp mq lp b">provider-components.yaml</code>中定义的控制器启动时，它们管理应用于启动的集群和机器资源，并管理目标集群。</p><p id="7736" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实际上，正如我们在一个<code class="fe mo mp mq lp b">clusterctl</code>进程中提到的，有两个Kubernetes集群。它包括创建集群的4个步骤。</p><ol class=""><li id="ec4e" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mz ml mm mn bi translated">创建一个引导集群(如果没有现有的Kubernetes集群，则按需创建)并在集群中应用资源</li><li id="0d5a" class="mf mg iq jp b jq na ju nb jy nc kc nd kg ne kk mz ml mm mn bi translated">为目标群集创建一台控制平面机器。</li><li id="61f9" class="mf mg iq jp b jq na ju nb jy nc kc nd kg ne kk mz ml mm mn bi translated">将所有集群API资源从引导集群转移到目标集群控制平面</li><li id="de99" class="mf mg iq jp b jq na ju nb jy nc kc nd kg ne kk mz ml mm mn bi translated">从目标群集的控制平面创建计算节点</li></ol><figure class="lk ll lm ln gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nf"><img src="../Images/35850e4db214f930a104490d79dca27f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LBVJ2sQE7YnyPzWh"/></div></div></figure><p id="6530" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目标Kubetnetes接管集群API管理工作后，引导集群自动销毁(如果由<code class="fe mo mp mq lp b">clusterctl</code>创建)。</p><h1 id="21e2" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">架构是什么？</h1><p id="4832" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">特定提供者的集群API有3个组件:</p><ul class=""><li id="a39f" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><code class="fe mo mp mq lp b">clusterctl</code>:用于提供Kubernetes集群的命令行工具。它为所有提供者共享公共逻辑。</li><li id="dea0" class="mf mg iq jp b jq na ju nb jy nc kc nd kg ne kk mk ml mm mn bi translated">集群API控制器:相关资源的集群管理功能的控制器。也是集群API核心部分代码。</li><li id="60fd" class="mf mg iq jp b jq na ju nb jy nc kc nd kg ne kk mk ml mm mn bi translated">提供者控制器:群集和机器供应的提供者资源的控制器。它是特定于提供商的代码。您可以从每个提供者实现代码库中获得。</li></ul><p id="65b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">二进制</strong>:集群API控制器</p><p id="d31d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">功能控制器:</strong>机器部署控制器、机组控制器、节点控制器</p><p id="0578" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> CRD </strong> : <code class="fe mo mp mq lp b">MachineDeployment</code>，<code class="fe mo mp mq lp b">MachineSet</code>，-</p><p id="51b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">二进制</strong>:提供商控制器</p><p id="eff6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">功能控制器:</strong>集群控制器，机器控制器</p><p id="c475" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> CRD </strong> : <code class="fe mo mp mq lp b">Cluster</code>，<code class="fe mo mp mq lp b">Machine</code></p><p id="58e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于控制器二进制文件，它包括许多用于管理多种资源的函数。对于每个资源管理功能，我们也称之为资源控制器。因此,“控制器”意味着在不同的上下文中对资源的管理功能。</p><p id="2f4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于资源控制者，传统的方法是协调CRD的事件。协调功能包括资源的定制逻辑。一般来说，它试图使资源的状态符合规范。</p><figure class="lk ll lm ln gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mr"><img src="../Images/a17aed8a78a556f0c3f06e46e75e2df5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qs4lx7DV_MoE1nOZ"/></div></div></figure><p id="2a19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在集群API中，它有进一步的抽象。协调功能是cluster-api项目中常见的管理逻辑。而<code class="fe mo mp mq lp b">Actuator</code>才是真正给提供商打电话的地方。它需要不同的提供者实现。对于Openstack，<code class="fe mo mp mq lp b">Actuator</code>接口实现调用gophercloud API向Openstack cloud请求相关的VM操作。这种详细的操作有助于集群API为提供商基础设施管理Kubernetes集群和机器。所以，如果你想开发自己的基础设施提供者，你需要为它开发执行器代码。</p><figure class="lk ll lm ln gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mr"><img src="../Images/f1456e8262a06bd63c55b02b3b6a725c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R5KXEGxbiBgLw7oa"/></div></div></figure><h1 id="7556" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">代码逻辑是什么？</h1><h1 id="bdc3" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">集群ctl</h1><p id="b519" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">这是用于集群api的命令行工具。最好从不同的提供者处获取，例如，要使用Openstack作为提供者，您应该从cluster-api-provider-openstack项目构建<code class="fe mo mp mq lp b">clusterctl</code>。因为目前，clusterctl是为每个提供者构建的。在这种情况下，cluster-api-provider-openstack中的代码对于使用特定的提供者更有意义。当然，cluster-api总是包含<code class="fe mo mp mq lp b">clusterctl</code>核心进程的最新进展。</p><p id="5afe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">集群部署的主要逻辑位于:</p><p id="85fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mo mp mq lp b">pkg/vendor/sigs.k8s.io/cluster-api/cmd/clusterctl/clusterdeployer/clusterdeployer.go: func (d *ClusterDeployer) Create</code></p><p id="03df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它的工作原理如下:</p><h2 id="4b31" class="lt kn iq bd ko ng nh dn ks ni nj dp kw jy nk nl la kc nm nn le kg no np li nq bi translated">-引导集群运行阶段</h2><ul class=""><li id="6852" class="mf mg iq jp b jq ma ju mb jy nr kc ns kg nt kk mk ml mm mn bi translated"><code class="fe mo mp mq lp b">CreateBootstrapCluster()</code></li></ul><p id="1374" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它在本地主机中创建引导集群。函数返回后，指定类型的引导集群(上面例子中的类型)就可以使用了。您可以使用kubectl来监控引导集群。在<code class="fe mo mp mq lp b">clusterctl</code>的部署过程完成后，它将被自动删除。</p><ul class=""><li id="7e76" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><code class="fe mo mp mq lp b">ApplyClusterAPIComponents()</code></li></ul><p id="044d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它在引导集群中应用<code class="fe mo mp mq lp b">provider-components.yaml</code>。CRD、依赖关系资源和控制器部署是在集群中创建的。目标机器上的启动脚本也作为秘密存储在文件中。</p><ul class=""><li id="fb8d" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><code class="fe mo mp mq lp b">ApplyCluster()</code></li></ul><p id="be29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它在引导集群中应用<code class="fe mo mp mq lp b">cluster.yaml</code>。</p><ul class=""><li id="3bac" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><code class="fe mo mp mq lp b">ApplyMachines()</code> <br/>在引导集群中应用<code class="fe mo mp mq lp b">machines.yaml</code>。注意，它仅应用标签为“set: master”的机器，因为引导集群仅在主节点上启动目标集群控制平面。</li><li id="a3d8" class="mf mg iq jp b jq na ju nb jy nc kc nd kg ne kk mk ml mm mn bi translated"><code class="fe mo mp mq lp b">updateClusterEndpoint()</code></li></ul><p id="0b05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它从控制平面机器对象的“openstack-ip-address”注释中获取IP。然后它使用这个IP来更新集群API端点状态。这并不好，因为状态通常是由控制器管理的。它必须重新考虑这个设计。</p><h2 id="62b8" class="lt kn iq bd ko ng nh dn ks ni nj dp kw jy nk nl la kc nm nn le kg no np li nq bi translated">-目标集群运行阶段</h2><ul class=""><li id="b99e" class="mf mg iq jp b jq ma ju mb jy nr kc ns kg nt kk mk ml mm mn bi translated"><code class="fe mo mp mq lp b">createTargetClusterClient()</code></li></ul><p id="2f07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">等待引导群集的提供者控制器创建目标群集。它创建一个客户端到目标群集。</p><ul class=""><li id="8720" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><code class="fe mo mp mq lp b">applyClusterAPIComponentsWithPivoting()</code></li></ul><p id="17c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它将<code class="fe mo mp mq lp b">provider-components.yaml</code>中的资源应用于目标集群。因此，在目标集群中创建了CRD资源并启动了控制器。之后，集群和机器资源从引导集群转移到目标集群。如果存在，集群API管理的资源MachineDeployment和MachineSet也会在此过程中传输。</p><ul class=""><li id="c0dd" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><code class="fe mo mp mq lp b">saveProviderComponentsToCluster()</code></li></ul><p id="58a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它将provider-components . YAML保存为目标集群中的ConfigMap。</p><ul class=""><li id="d4b7" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><code class="fe mo mp mq lp b">ApplyMachines()</code></li></ul><p id="d2e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这仅适用于标签“集:节点”。所有计算节点都应用于目标集群，并由目标集群中的控制器进行管理。</p><p id="9e06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，<code class="fe mo mp mq lp b">clusterctl</code>完成它的工作。目标集群已启动。</p><h1 id="412e" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">集群API控制器</h1><p id="bf64" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">该控制器管理<code class="fe mo mp mq lp b">MachineDeployment </code>和<code class="fe mo mp mq lp b">MachineSet</code>资源。它们相当于库伯内特斯的<code class="fe mo mp mq lp b">Deployment</code>和<code class="fe mo mp mq lp b">ReplicaSet</code>。一个用于滚动升级，另一个用于复制。他们可以管理Kubernetes中的机器资源，并让供应商特定的控制器在其上进行协调。</p><p id="da46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">社区有一个流程图来描述它是如何工作的。有关详细信息，请参考机器集、机器部署和节点控制器链接:</p><p id="3bad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/kubernetes-sigs/cluster-api/blob/master/docs/book/SUMMARY.md" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes-sigs/cluster-API/blob/master/docs/book/summary . MD</a></p><h1 id="5e0b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">Openstack提供商控制器</h1><p id="5a00" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">这个控制器二进制管理<code class="fe mo mp mq lp b">Cluster</code>和<code class="fe mo mp mq lp b">Machine</code>资源。框架逻辑使用actuator来执行提供者特定的操作。<code class="fe mo mp mq lp b">Cluster</code>和<code class="fe mo mp mq lp b">Machines</code>的执行机构接口如下:</p><p id="3cb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">执行器:</strong> <code class="fe mo mp mq lp b">Cluster</code></p><p id="bb0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">界面:</strong> <code class="fe mo mp mq lp b">Reconcile</code>，<code class="fe mo mp mq lp b">Delete</code></p><p id="6954" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">执行器:</strong> <code class="fe mo mp mq lp b">Machine</code></p><p id="b09e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">界面:</strong><code class="fe mo mp mq lp b">Create</code><code class="fe mo mp mq lp b">Delete</code><code class="fe mo mp mq lp b">Update</code><code class="fe mo mp mq lp b">Exists</code></p><p id="be0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">框架逻辑位于:</p><ul class=""><li id="2741" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><code class="fe mo mp mq lp b">vendor/sigs.k8s.io/cluster-api/pkg/controller/machine/controller.go::ReconcileMachine{}</code></li></ul><p id="9a68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在项目报告中对这部分有详细的解释:<a class="ae kl" href="https://github.com/kubernetes-sigs/cluster-api/blob/master/docs/book/common_code/machine_controller.md" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes-sigs/cluster-API/blob/master/docs/book/common _ code/machine _ controller . MD</a></p><p id="70f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于集群协调，执行器协调提供者特定的任务。对于Openstack，它管理目标集群机器管理的网络和安全组。</p><ul class=""><li id="8101" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><code class="fe mo mp mq lp b">vendor/sigs.k8s.io/cluster-api/pkg/controller/cluster/controller.go::ReconcileCluster{}</code></li></ul><p id="f289" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在项目报告中对这部分有详细的解释:<a class="ae kl" href="https://github.com/kubernetes-sigs/cluster-api/blob/master/docs/book/common_code/cluster_controller.md" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes-sigs/cluster-API/blob/master/docs/book/common _ code/cluster _ controller . MD</a></p><p id="2fc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于机器，创建操作将在Openstack上创建一个新的VM实例。然后，它提取虚拟机实例的引导脚本，以便在主机启动后执行。它在机器上部署Kubernetes依赖项和二进制文件并启动它。该脚本来自base64编码的秘密<code class="fe mo mp mq lp b">master-user-data</code>的<code class="fe mo mp mq lp b">userData</code>。在发送出去执行之前，它被预处理以用脚本中的运行时结果替换模板值。</p><p id="0949" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在源代码中，目录<code class="fe mo mp mq lp b">cmd/clusterctl/examples/openstack/provider-component/user-data</code>包括不同的操作系统脚本模板。对于ubuntu来说，在<code class="fe mo mp mq lp b">ubuntu/templates/</code>之下。主人和奴隶有他们不同的剧本:<code class="fe mo mp mq lp b">master-user-data.sh</code>和<code class="fe mo mp mq lp b">worker-user-data.sh</code>。</p><h1 id="6a5b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">集群API工作序列</h1><figure class="lk ll lm ln gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nu"><img src="../Images/ae8ad888560cfe7eb8d57c1d859a1157.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fwljbOn0fOhFX8L8"/></div></div></figure><h1 id="d52d" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">如何调试集群API？</h1><p id="d9ca" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">通过集群API部署Kubernetes的过程与许多对象实例有关:<code class="fe mo mp mq lp b">clusterctl</code>、集群API控制器、引导集群、目标集群、Openstack、VM实例和主机初始化脚本。如果有任何问题，你可以向社区寻求帮助。但是，如果你想了解更多关于集群API的知识，你最好自己去寻找答案。下面是一些在部署过程中获得有用信息的提示。</p><ul class=""><li id="0a77" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">您可以使用集群命令行选项选项'-v 10 '来打印详细步骤日志。</li><li id="cf87" class="mf mg iq jp b jq na ju nb jy nc kc nd kg ne kk mk ml mm mn bi translated">在bootstrap集群控制器中，可以通过kubectl获得控制器的日志。对于不同的引导类型，您可以使用相关的kubeconfig来访问集群。对于KIND，需要执行:<code class="fe mo mp mq lp b">export KUBECONFIG=$(kind get kubeconfig-path --name=”clusterapi”)</code>。</li><li id="8275" class="mf mg iq jp b jq na ju nb jy nc kc nd kg ne kk mk ml mm mn bi translated">在您调配的虚拟机中，您可以登录到主机</li><li id="447f" class="mf mg iq jp b jq na ju nb jy nc kc nd kg ne kk mk ml mm mn bi translated"><code class="fe mo mp mq lp b">tail -f /var/log/cloud-init-output.log</code>获取初始化脚本输出</li><li id="fa97" class="mf mg iq jp b jq na ju nb jy nc kc nd kg ne kk mk ml mm mn bi translated"><code class="fe mo mp mq lp b">kubectl —-kubeconfig /etc/kubernetes/admin.conf logs</code>查看目标集群控制器日志</li></ul><p id="9189" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅供参考。本文基于当前的开发代码进行介绍。它仍在开发中。代码甚至功能都可能改变。但是，它背后的概念和设计哲学在很长一段时间内都不会过时。</p><h1 id="2776" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">参考</h1><p id="db95" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">[1]<a class="ae kl" href="https://github.com/kubernetes-sigs/cluster-api" rel="noopener ugc nofollow" target="_blank">https://github.com/kubernetes-sigs/cluster-api</a>展示了集群API项目的源代码。</p><p id="9622" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[2]<a class="ae kl" href="https://github.com/kubernetes-sigs/cluster-api-provider-openstack" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes-sigs/Cluster-api-provider-openstack</a>展示了集群API的open stack提供者的源代码。</p><p id="0e4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[3]<a class="ae kl" href="https://kubernetes-sigs.github.io/cluster-api/" rel="noopener ugc nofollow" target="_blank">https://kubernetes-sigs.github.io/cluster-api/</a>展示了如何创建自己的提供商代码库</p><p id="b4dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[4]<a class="ae kl" href="https://developer.ibm.com/articles/cluster-api-manage-your-kubernetes-cluster-in-a-kubernetes-way/" rel="noopener ugc nofollow" target="_blank">https://developer . IBM . com/articles/Cluster-api-Manage-your-kubernetes-Cluster-in-a-kubernetes-way/</a>集群API:以Kubernetes本地方式管理您的Kubernetes集群</p></div></div>    
</body>
</html>