<html>
<head>
<title>We rendered a million web pages to find out what makes the web slow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们渲染了100万个网页，以找出是什么让网络变慢</h1>
<blockquote>原文：<a href="https://itnext.io/we-rendered-a-million-web-pages-to-find-out-what-makes-the-web-slow-72bbba9ade96?source=collection_archive---------0-----------------------#2020-12-22">https://itnext.io/we-rendered-a-million-web-pages-to-find-out-what-makes-the-web-slow-72bbba9ade96?source=collection_archive---------0-----------------------#2020-12-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4f8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在web上呈现了<a class="ae kl" href="https://tranco-list.eu" rel="noopener ugc nofollow" target="_blank">前100万个页面</a>，跟踪每一个可以想到的性能指标，记录每一个错误，记录每一个被请求的URL。据我们所知，这产生了第一个在网络上连接性能、错误和库使用的数据集。在这篇文章中，我们分析了关于创建高性能网站的数据能告诉我们什么。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/5e4bea12b9649607da0012f8f77e3e60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*X-v41G6JWvniNBh43igLYQ.png"/></div></figure><p id="8034" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你能做得比我们的分析更好吗？我们<a class="ae kl" href="https://www.kaggle.com/indexhtml/web-performance-metrics" rel="noopener ugc nofollow" target="_blank">向Kaggle </a>发布了数据集，所以你可以自己处理数据。</p><h1 id="c4e8" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">为什么要渲染一百万个网页？</h1><p id="d501" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">如今一种普遍的感觉是，网络比15年前慢了，也更麻烦了。由于不断增长的JavaScript和框架、web字体和polyfills，我们已经吃掉了更快的计算机、网络和协议给我们带来的所有好处。或者说论点是这样的。我们想验证这是否是真的，并试图找出导致2020年网站运行缓慢和崩溃的常见因素。</p><p id="9f5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">高级计划很简单:编写一个web浏览器脚本，让它呈现前100万个域名的根页面，并记录每一个可以想到的指标:呈现时间、请求计数、重画、JavaScript错误、使用的库等。有了这些数据，我们就可以提出一个因素与另一个因素如何相关的问题。哪些因素对缓慢的渲染时间影响最大？哪些库与长时间交互相关？最常见的错误是什么，是什么导致了这些错误？</p><p id="be4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">收集数据就是写一些代码来使用Puppeteer编写Chrome，启动200个EC2实例，在周末渲染100万个网页，并祈祷你已经真正理解了AWS定价的工作原理。</p><h1 id="e155" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">总人数</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/8c1313e6ff7283ea1ad79dcc0c4f49ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*hnOVn1B80pDXzIT6oQqCJA.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">根HTML文档使用的协议</figcaption></figure><p id="362d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">HTTP 2现在比HTTP 1.1更常见，但HTTP 3仍然很少见。(注意:我们把使用QUIC协议的任何东西都算作HTTP 3，即使Chrome有时会把这种情况报告为HTTP 2 + QUIC。)这是针对根文档的，对于链接的资源，协议号看起来有点不同。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/477d83f716729e0d704b5af69a57deb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*2hFWOGRr6RiW8JGlhIjomQ.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><strong class="bd kw">用于链接资源的协议</strong></figcaption></figure><p id="8b9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于链接资源来说，HTTP 3要普遍100倍。这怎么可能是真的？因为所有的网站都在链接相同的东西:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi md"><img src="../Images/3853ed1b5a3958d63795cfae5daa072e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*SQYFm-4sLCb6A4YQjID8DA.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><strong class="bd kw">顶级链接网址</strong></figcaption></figure><p id="406f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一些脚本链接到大部分网站上。这意味着我们可以预期这些资源在缓存中，对吗？不再是了:从Chrome 86开始，从不同域请求的<a class="ae kl" href="https://developers.google.com/web/updates/2020/10/http-cache-partitioning" rel="noopener ugc nofollow" target="_blank">资源将不会共享一个缓存</a>。Firefox正计划实现同样的功能。Safari多年来一直这样分割缓存。</p><h1 id="d543" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">是什么让网络变慢:预测互动时间</h1><p id="b944" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">给定这个web页面的数据集和它们的加载时间度量，了解一下是什么使web页面变慢会很好。我们将研究dominteractive指标，即文档与用户交互之前所花费的时间。我们可以做的最简单的事情就是查看每个指标与dominteractive的相关性。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mi"><img src="../Images/021b509894a60c320af759f55b3adbd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pRbBwyT21pw_TTdi.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><em class="mj">指标与显性指标的相关性</em></figcaption></figure><p id="b5ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上每个指标都与dominteractive正相关，除了表示HTTP2或更大的0–1变量。这些指标中有许多也是相互正相关的。我们需要一种更复杂的方法来获得导致高交互时间的单个因素。</p><p id="99e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些指标是计时，以毫秒为单位。我们可以通过观察他们的方框图来了解浏览器在哪里花费时间。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/978404be6fce13521fe9c145a4e93754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*PbqRkr4QsHoiZZN0.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><em class="mj">计时指标的箱线图。橙色线是中间值，方框从第25个百分点到第75个百分点。</em></figcaption></figure><p id="f37d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">获得导致高交互时间的单个因素的一种方法是进行线性回归，其中我们从其他指标预测显性交互。这意味着我们为每个指标分配一个权重，并将页面的支配性活动时间建模为其他指标的加权总和，再加上一些常数。优化算法设置权重，以便最小化整个数据集的预测误差。回归得到的权重大小告诉我们每个指标对页面速度的影响有多大。</p><p id="29d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将从回归中排除计时指标。如果我们花费500毫秒建立一个连接，这将增加500毫秒的支配性活动，但这不是一个特别有趣的见解。时间度量从根本上来说是<em class="ml">结果</em>。我们想知道是什么导致了它们。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/e19435e0a32ef2d70ef8c8e2bee4e4c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*8nAJQPaHd-XKOvz5Qy7cyA.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><strong class="bd kw">指标的回归系数，预测显性</strong></figcaption></figure><p id="6489" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">括号中的数字是优化算法学习到的回归系数。你可以把它们解释为以毫秒为单位。虽然确切的数字应持保留态度(见下面的注释)，但有趣的是看到每个功能的规模分配。例如，该模型预测传递主文档所需的每一次重定向的速度会降低354毫秒。每当主HTML文档通过HTTP2或更高版本交付时，该模型预测交互时间减少477毫秒。对于由文档触发的每个请求，它预测额外的16 ms。</p><blockquote class="mn mo mp"><p id="90f8" class="jn jo ml jp b jq jr js jt ju jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj kk ij bi translated">在解释回归系数时，我们需要记住，我们是在现实的简化模型上操作。实际上，交互时间不是由这些输入指标的加权和决定的。很明显，有一些因果因素是这个模型无法发现的。混淆变量显然是一个问题。例如，如果用HTTP2加载主文档与通过HTTP2加载其他请求相关，那么模型将把这种优势转化为main_doc_is_http2_or_greater的权重，即使速度的提高来自于主文档以外的请求。当把模型所说的映射到关于现实的结论上时，我们需要谨慎。</p></blockquote><h1 id="4c57" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">HTTP协议版本对dominteractive有什么影响？</h1><p id="ab17" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">这里有一个有趣的dominteractive split图，它是由用于传递根HTML页面的HTTP协议版本划分的。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/a362968f8d8765c5cb0136a7b0792254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*hxbRcpJAcQnCvfot.png"/></div></figure><blockquote class="mn mo mp"><p id="aff8" class="jn jo ml jp b jq jr js jt ju jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj kk ij bi translated"><em class="iq">Box-plot of dominteractive split by HTTP协议版本的第一个请求。橙色线是中间值，方框从第25个百分点到第75个百分点。括号中的百分比是使用此协议进行请求的比例。</em></p></blockquote><p id="19b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只有极少数网站仍然通过HTTP 0.9和1.0提供服务。而这些网站恰好很快。似乎我们无法解开这样一个事实，即协议已经变得更快，程序员会很高兴地通过向浏览器提供更多的东西来消耗这种加速。</p><p id="12a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是用于传递根HTML页面的协议版本。如果我们看看该协议对该文档中链接的资源的影响会怎样？如果我们对协议版本的请求数量进行回归，我们会得到以下结果。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/9dd64e474119bdc16b82587f1b36d768.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*tHj2hGabofpOfjbBGo6Tpw.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><strong class="bd kw">协议版本请求数量的回归系数，预测支配性</strong></figcaption></figure><p id="3fec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们相信这一点，我们会得出这样的结论:将请求的资源从HTTP 1.1移动到2会带来1.8倍的速度提升，而从HTTP 2移动到3会导致0.6倍的速度降低。HTTP 3真的是一种较慢的协议吗？不:一个更可能的解释是HTTP 3很少见，通过HTTP 3发送的少数资源(例如Google Analytics)对dominteractive的影响大于平均水平。</p><h1 id="f5ff" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">内容类型对互动有什么影响？</h1><p id="4449" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">让我们从传输的字节数来预测交互时间，按传输的数据类型划分。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/e68ac5e814f6edded8e251e947b97951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*P-KlNw5LMk9KDV8SkGQ5qw.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><strong class="bd kw">请求发起者传输的千字节回归系数，预测支配性</strong></figcaption></figure><p id="d4f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个类似的回归，这次查看每个请求发起者类型的请求数量。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/3aeb2b77518e583efcc6efa1c4f5e4f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*6to5zL82mUDlHjdS2o2hZA.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><strong class="bd kw">请求发起者请求数量的回归系数，预测支配性</strong></figcaption></figure><p id="0f69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，请求根据发起请求的内容进行划分。显然，不是所有的要求都是平等的。由链接元素触发的请求(例如CSS、favicons)和由CSS(例如字体、更多CSS)以及脚本和iframes触发的请求会大大降低速度。通过XHR和fetch进行请求预示着比基线更快的主交互时间(可能是因为这些请求几乎总是异步的)。CSS和脚本通常以渲染阻塞的方式加载，所以发现它们与较慢的交互时间相关就不足为奇了。视频相对来说<em class="ml">便宜</em>。</p><h1 id="21aa" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">外卖食品</h1><p id="0001" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">我们在这里没有发现任何新的优化技巧，但是分析确实给出了各种优化的影响程度。以下主张似乎有很好的实证支持:</p><ul class=""><li id="778c" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">尽可能少提要求。请求的数量比传输的千字节数更重要。</li><li id="cfe8" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">对于您必须提出的请求，如果可能的话，通过HTTP2或更高版本来完成。</li><li id="7864" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">尽可能避免呈现阻塞请求，尽可能选择异步加载。</li></ul><h1 id="0479" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">图书馆</h1><p id="ddc6" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">为了弄清楚页面上使用的是什么库，我们采用了以下方法:在每个站点上，我们都记录了全局变量(即窗口对象上的属性)。之后，每一个出现超过6000次的全局变量都与一个JavaScript库相关联。这是一项艰苦的工作，但由于数据集也有每个页面请求的URL，所以可以查看变量出现和URL请求之间的重叠，这通常足以确定哪个库将设置每个全局变量。不能确信与单个库相关联的全局变量被忽略。这种方法在某种程度上会计算不足:JS库没有义务在全局名称空间中留下任何东西。每当不同的库设置相同的属性时，它也会有一些噪声，这一事实在标记时被忽略了。</p><p id="20bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目前最常用的JavaScript库有哪些？根据会议和博客帖子的主题，你会被原谅建议React、Vue和Angular。在这个排名中，他们远未名列前茅。</p><h1 id="c87b" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">使用最多的10个图书馆</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/806470d613ef21d83fcac863ebed0460.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*A9rIo0Q9X23sEztb0ZLDpA.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><a class="ae kl" href="https://catchjs.com/Blog/PerformanceInTheWild#top-libs" rel="noopener ugc nofollow" target="_blank">使用</a>查看完整的库列表</figcaption></figure><p id="937c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，老好人jQuery在最上面。JQuery最早发布于2006年，以人类年计算是14年前，但以JavaScript年计算要长得多。以角度版本来衡量，大概是几百年前的版本。2006年是一个不同的时代。最常用的浏览器叫做Internet Explorer 6，最大的社交网络是MySpace，网页中的圆角是一场革命，以至于人们称之为web 2.0。JQuery的主要用例是跨浏览器兼容性，与2006年相比，这在2020年是一个不同的概念。尽管如此，14年后，我们样本中整整一半的网页加载了jQuery。</p><p id="ecf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有趣的是，<a class="ae kl" href="https://catchjs.com/Docs/ReferenceError" rel="noopener ugc nofollow" target="_blank"> 2.2%的网站抛出了一个错误，因为JQuery是<em class="ml">而不是</em>加载的。</a></p><p id="43fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从这十大浏览器来看，我们的浏览器大多运行分析、广告和代码，以兼容旧浏览器。不知何故，8%的网站定义了set immediate/clear immediate poly fill，用于任何浏览器都无法实现的功能。</p><h1 id="3206" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">从图书馆使用预测互动时间</h1><p id="2968" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">我们将再次运行线性回归，从库的存在预测dominteractive。回归的输入是向量X，其中X.length ==库的数量，其中如果库I存在，X[i] == 1.0，如果不存在，X[i] == 0.0。当然，我们知道dominteractive实际上并不是由某些库的存在与否决定的。然而，将每个库建模为对速度缓慢有额外贡献，并回归成千上万个例子仍然给我们留下有趣的发现。</p><h1 id="afe8" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">交互时间最好和最差的库，通过回归系数</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nk"><img src="../Images/df88672007f57623a45eb8341bb3ea7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VtqLUbI114sdYVfXS4y1Wg.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><a class="ae kl" href="https://catchjs.com/Blog/PerformanceInTheWild#pred-tti2" rel="noopener ugc nofollow" target="_blank">通过回归系数预测优势互动查看完整的库列表</a></figcaption></figure><p id="47a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的负系数意味着当这些库存在时，模型预测的交互时间比没有库存在时要短。当然，这并不意味着添加那些库会使你的网站更快，这只是意味着有那些库的网站恰好比模型建立的一些基线更快。这里的结果可能既是技术性的，也是社会学的。例如，用于延迟加载的库预测低交互时间。这可能是因为使用这些库的页面是由花时间优化快速页面加载的程序员制作的，因为这是由延迟加载直接导致的。我们无法用这种结构来理清这些因素。</p><h1 id="7d63" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">加载时间最好和最差的库，通过回归系数</h1><p id="1362" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">我们可以重复上面的练习，但是这次预测onloadtime。Onloadtime是窗口的“load”事件触发所需的时间，也就是页面上所有资源加载所需的时间。我们用和以前一样的方法做线性回归。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/5e52ad82f23a78ac1097a01d38237efd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*4CUI9dNz8bG1gTHiA9xE0Q.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><a class="ae kl" href="https://catchjs.com/Blog/PerformanceInTheWild#pred-onl" rel="noopener ugc nofollow" target="_blank">通过预测加载时间的回归系数查看完整的库列表</a></figcaption></figure><h1 id="d53b" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">jsheapusedsize的最佳和最差库，按回归系数</h1><p id="b4af" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">这里预测的是JavaScript使用的堆大小，以兆字节为单位。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/36a42f6b77eed9147bd7d224dec6bc2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*pSW7X-_RJ-HBqFfujkZ5OQ.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><a class="ae kl" href="https://catchjs.com/Blog/PerformanceInTheWild#pred-jsh" rel="noopener ugc nofollow" target="_blank">通过回归系数预测jsheapusedsize查看完整的库列表</a></figcaption></figure><p id="3bb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">互联网评论者喜欢说相关性不等于因果关系，事实上我们无法通过这些模型直接得到因果关系。在解释这些系数时应该非常小心，特别是因为可能涉及许多混淆因素。然而，肯定有足够的东西让你“嗯”了一声。事实上，该模型将982毫秒的交互时间与jQuery的存在联系起来，并且有一半的站点加载该脚本，这应该引起我们的一些关注。如果你正在优化你自己的站点，交叉引用它的依赖列表和这里的等级和系数应该会给你一个体面的指示，哪个依赖移除可以让你得到最大的回报。</p><p id="64d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能也会对我们对爬行中发现的错误的深入探究感兴趣。参见我们关于<a class="ae kl" href="https://catchjs.com/Blog/ErrorsInTheWild" rel="noopener ugc nofollow" target="_blank">野生JavaScript错误</a>的文章，我们分析了发现的错误，并讨论了它们能告诉我们关于web技术如何发展以创造更少错误的未来。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="4013" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ml">原载于</em><a class="ae kl" href="https://catchjs.com/Blog/PerformanceInTheWild" rel="noopener ugc nofollow" target="_blank"><em class="ml">https://catchjs.com</em></a><em class="ml">。</em></p></div></div>    
</body>
</html>