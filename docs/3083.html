<html>
<head>
<title>Minimalistic state management. (React)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">极简状态管理。(反应)</h1>
<blockquote>原文：<a href="https://itnext.io/minimalist-state-management-react-only-41606cf8f843?source=collection_archive---------4-----------------------#2019-09-30">https://itnext.io/minimalist-state-management-react-only-41606cf8f843?source=collection_archive---------4-----------------------#2019-09-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5e09314be9ca1bc4b747cb1b75edcbba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N_kmVuxcYovDHR6cbk0B7A.jpeg"/></div></div></figure><p id="45ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">16.3版react引入了新的上下文API。在我看来，这个新特性对于中小型应用的状态管理来说已经足够好了。最近我写了一个小项目，其中我使用上下文作为前端的主要数据源。在这篇文章中，我想分享我学到的知识和方法。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="2fd0" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">新API</h2><p id="c116" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">让我们快速提醒自己新的API。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="9c5b" class="ld le iq mg b gy mk ml l mm mn">const Context = React.createContext(initialData)</span></pre><p id="9ca6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建新的上下文。可能有多个包含不同数据的上下文。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="bad2" class="ld le iq mg b gy mk ml l mm mn">&lt;Context.Provider value={data}/&gt;;</span></pre><p id="6010" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接受“值”属性。当数据更改时，将重新呈现所有相关的使用者。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="1755" class="ld le iq mg b gy mk ml l mm mn">&lt;Context.Consumer/&gt;</span></pre><p id="b285" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有权访问提供商的数据。消费者可以通过两种方式访问数据:</p><p id="d9f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 1: </strong></p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="c420" class="ld le iq mg b gy mk ml l mm mn">class Modal extends React.Component {<br/>    static contextType = AppContext;<br/>    //…<br/>}</span><span id="0a8b" class="ld le iq mg b gy mo ml l mm mn">class Cmp extends Component {</span><span id="a4c4" class="ld le iq mg b gy mo ml l mm mn">render() {<br/>     console.log(this.context);<br/>     //...</span><span id="f957" class="ld le iq mg b gy mo ml l mm mn">}<br/>}</span></pre><p id="c2c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 2: </strong></p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="258d" class="ld le iq mg b gy mk ml l mm mn">render() {<br/>  return (<br/>      &lt;Consumer&gt;<br/>        {data =&gt; &lt;div&gt;{data.title}&lt;/div&gt;}<br/>      &lt;/Consumer&gt;<br/>   )<br/>}</span></pre></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="a9e7" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">新旧API之间的差异</h2><p id="163a" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在旧的API PureComponents和Components中，当道具或状态改变时，实现的shouldComponentUpdate会重新呈现。React不考虑上下文的值。这种行为会导致上下文中的数据过时。<br/>下面是一个使用旧API的例子:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="cd90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更改标题组件以扩展PureComponent。多次单击增量。<Title/>不会重新呈现，但上下文值已更改。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="ce97" class="mr le iq bd lf ms mt mu li mv mw mx ll my mz na lo nb nc nd lr ne nf ng lu nh bi translated">最小状态管理</h1><p id="bc0d" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">如前所述，我在项目中使用了新的React Context API进行状态管理。为什么我没有用redux？<br/>首先，对于小型项目，减少过度冗余。请记住—操作、减少器、e2e通信的redux-thunk、connect()、组合减少器。我喜欢只用一个React来构建应用的想法。一开始，我将所有数据和更新程序放在一个文件存储中。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="f84e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样的实现满足了我的所有需求。但是在某些时候，我意识到有300多行代码已经足够了。<br/>所以我决定根据数据的类型——用户、信息、产品和主题——来划分数据。我将尽可能保持我的例子简单。首先，我将所有用户数据从存储状态转移到单独的类:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="223d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个模型接收两个重要参数。getState该方法返回商店组件的“this.state”。<br/> rootUpdater —是Store组件的“this.setState”方法。然后我修改了我的商店组件:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="f16c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想象这样一种情况，其中一个模型需要根据另一个模型内部的值进行一些计算。绕过this.getState方法，每个模型都可以访问所有数据树。<br/>这里有一个完整的例子:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="a496" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">记住这个的每个调用。_rootUpdater将重新呈现每个连接的消费者。考虑使用多个上下文来避免不必要的重新渲染。</p></div></div>    
</body>
</html>