<html>
<head>
<title>Acceptance Test Driven Development with React/Redux — Part 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React/Redux的验收测试驱动开发—第4部分</h1>
<blockquote>原文：<a href="https://itnext.io/acceptance-test-driven-development-with-react-redux-part-4-5db545953ed3?source=collection_archive---------2-----------------------#2018-03-15">https://itnext.io/acceptance-test-driven-development-with-react-redux-part-4-5db545953ed3?source=collection_archive---------2-----------------------#2018-03-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="03e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">更新1 </em> </strong> : <em class="kl">本文是一个系列的一部分，查看完整系列:</em> <a class="ae km" href="https://medium.com/@juntao.qiu/acceptance-test-driven-test-with-react-redux-part-1-7ae8cb4fab00" rel="noopener">第一部分</a>、<em class="kl"> </em> <a class="ae km" href="https://medium.com/@juntao.qiu/acceptance-test-driven-test-with-react-redux-part-2-127949a6e47e" rel="noopener">第二部分</a>、<a class="ae km" href="https://medium.com/@juntao.qiu/acceptance-test-driven-test-with-react-redux-part-3-903e1e58e706" rel="noopener">第三部分</a>、<a class="ae km" href="https://medium.com/@juntao.qiu/acceptance-test-driven-development-with-react-redux-part-4-5db545953ed3" rel="noopener">第四部分</a>和<a class="ae km" href="https://medium.com/@juntao.qiu/acceptance-test-driven-development-with-react-redux-part-5-995577d28eff" rel="noopener">第五部分</a>。</p><p id="d68d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">更新2 </em> </strong>:我出版了一本名为<a class="ae km" href="https://leanpub.com/build-react-app-with-atdd" rel="noopener ugc nofollow" target="_blank"> <em class="kl">用验收测试驱动开发构建React应用</em> </a>的书，涵盖了更多关于ATDD和React的话题和实践，<a class="ae km" href="https://leanpub.com/build-react-app-with-atdd" rel="noopener ugc nofollow" target="_blank">请查看</a>！</p><h1 id="1a61" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">书籍详细信息</h1><p id="6301" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">对于图书列表中的每一项，我们希望有一个超链接，当用户点击这个链接时，浏览器将重定向到详细页面。详细页面包含更多详细内容，如图书封面图片、图书描述、评论等。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lq"><img src="../Images/9eec036b8499a0acc9d11c9fb0706e7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qAAaG6pCNQFYzufU."/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">由<a class="ae km" href="https://unsplash.com/@spacex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> SpaceX </a>在<a class="ae km" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="b68e" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">接收试验</h1><p id="3fb1" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我们可以把这个需求描述成这样一个验收测试:</p><pre class="lr ls lt lu gt mg mh mi mj aw mk bi"><span id="d0b7" class="ml ko iq mh b gy mm mn l mo mp">test('Goto book detail page', async () =&gt; {<br/>    await page.goto(`${appUrlBase}/`)<br/>    await page.waitForSelector('a.view-detail')</span><span id="3e6d" class="ml ko iq mh b gy mq mn l mo mp">    const links = await page.evaluate(() =&gt; {<br/>      return [...document.querySelectorAll('a.view-detail')].map(el =&gt; el.getAttribute('href'))<br/>    })</span><span id="f5cf" class="ml ko iq mh b gy mq mn l mo mp">    await Promise.all([<br/>      page.waitForNavigation({waitUntil: 'networkidle2'}),<br/>      page.goto(`${appUrlBase}${links[0]}`)<br/>    ])</span><span id="d39d" class="ml ko iq mh b gy mq mn l mo mp">    const url = await page.evaluate('location.href')<br/>    expect(url).toEqual(`${appUrlBase}/books/1`)<br/>  })</span></pre><p id="38d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行测试，它失败了。我们还没有<code class="fe mr ms mt mh b">/books</code>路线，也没有链接。为了让测试通过，我们只需在<code class="fe mr ms mt mh b">BookList</code>组件中添加一个超链接:</p><pre class="lr ls lt lu gt mg mh mi mj aw mk bi"><span id="7981" class="ml ko iq mh b gy mm mn l mo mp">books.map(book =&gt; {<br/>     return (&lt;div className="book" key={book.id}&gt;<br/>       &lt;h2 className="title"&gt;{book.name}&lt;/h2&gt;<br/>+          &lt;a href={`/books/${book.id}`} className="view-detail"&gt;View Detail&lt;/a&gt;<br/>     &lt;/div&gt;)<br/>   })<br/> }</span></pre><p id="48d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了确保页面在导航后显示预期的内容，我们需要在<code class="fe mr ms mt mh b">e2e.test.js</code>中添加这些行:</p><pre class="lr ls lt lu gt mg mh mi mj aw mk bi"><span id="bd18" class="ml ko iq mh b gy mm mn l mo mp">const url = await page.evaluate('location.href')<br/>     expect(url).toEqual(`${appUrlBase}/books/1`)<br/>+<br/>+    await page.waitForSelector('.description')<br/>+    const result = await page.evaluate(() =&gt; {<br/>+      return document.querySelector('.description').innerText<br/>+    })<br/>+    expect(result).toEqual('Refactoring')</span></pre><p id="bf25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这确保页面有<code class="fe mr ms mt mh b">.description</code>部分，并且它的内容是<code class="fe mr ms mt mh b">Refactoring</code>。测试再次失败，让我们通过在应用程序中添加客户端路由来解决这个问题。</p><h1 id="19b9" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">按指定路线发送</h1><p id="b63e" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">首先，我们需要添加<code class="fe mr ms mt mh b">react-router</code>和<code class="fe mr ms mt mh b">react-router-dom</code>作为依赖项，它们为我们提供客户端路由机制。</p><pre class="lr ls lt lu gt mg mh mi mj aw mk bi"><span id="9f3f" class="ml ko iq mh b gy mm mn l mo mp">yarn add react-router react-router-dom</span></pre><p id="e337" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mr ms mt mh b">index.js</code>中，我们导入<code class="fe mr ms mt mh b">BrowserRouter</code>并用它包装<code class="fe mr ms mt mh b">&lt;App /&gt;</code>。然后整个应用程序可以共享全局<code class="fe mr ms mt mh b">Router</code>配置。</p><pre class="lr ls lt lu gt mg mh mi mj aw mk bi"><span id="fe95" class="ml ko iq mh b gy mm mn l mo mp">-ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));<br/>+import {BrowserRouter as Router} from 'react-router-dom'<br/>+<br/>+ReactDOM.render(&lt;Router&gt;<br/>+  &lt;App /&gt;<br/>+&lt;/Router&gt;, document.getElementById('root'));</span></pre><p id="a6b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们在<code class="fe mr ms mt mh b">App.js</code>定义两条路线:</p><pre class="lr ls lt lu gt mg mh mi mj aw mk bi"><span id="6acf" class="ml ko iq mh b gy mm mn l mo mp">+import BookDetailContainer from './BookDetailContainer'<br/>+<br/>+import {Route} from 'react-router-dom'<br/> <br/> function App() {<br/>   return (<br/>     &lt;div className="App"&gt;<br/>       &lt;h1&gt;Bookish&lt;/h1&gt;<br/>-      &lt;BookListContainer /&gt;<br/>+      &lt;main&gt;<br/>+        &lt;Route exact path="/" component={BookListContainer} /&gt;<br/>+        &lt;Route path="/books/:id" component={BookDetailContainer} /&gt;<br/>+      &lt;/main&gt;<br/>     &lt;/div&gt;<br/>   )<br/> }</span></pre><p id="5dce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们需要创建一个新文件<code class="fe mr ms mt mh b">BookDetailContainer.js</code>，它与<code class="fe mr ms mt mh b">BookListContainer.js</code>非常相似，除了书的<code class="fe mr ms mt mh b">id</code>将通过<code class="fe mr ms mt mh b">match.params.id</code>中的<code class="fe mr ms mt mh b">react-router</code>传递。一旦我们有了id，我们就可以发送HTTP请求来加载book detail，并将获取代码放在<code class="fe mr ms mt mh b">componentDidMount</code>钩子中:</p><pre class="lr ls lt lu gt mg mh mi mj aw mk bi"><span id="c26a" class="ml ko iq mh b gy mm mn l mo mp">import React, {Component} from 'react'<br/>import axios from 'axios'</span><span id="5046" class="ml ko iq mh b gy mq mn l mo mp">class BookDetailContainer extends Component {<br/>  constructor(props) {<br/>    super(props)<br/>    this.state = {<br/>      book: {}<br/>    }<br/>  }</span><span id="076e" class="ml ko iq mh b gy mq mn l mo mp">  componentDidMount() {<br/>    const id = this.props.match.params.id<br/>    axios.get(`http://localhost:8080/books/${id}`).then((res) =&gt; {<br/>      this.setState({<br/>        book: res.data<br/>      })<br/>    })<br/>  }</span><span id="0119" class="ml ko iq mh b gy mq mn l mo mp">  render() {<br/>    const {book} = this.state<br/>    return (&lt;div className="detail"&gt;<br/>      &lt;div className="description"&gt;{book.description}&lt;/div&gt;<br/>    &lt;/div&gt;)<br/>  }<br/>}</span><span id="6f68" class="ml ko iq mh b gy mq mn l mo mp">export default BookDetailContainer</span></pre><p id="e1e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有一点，我们需要在端到端测试的<code class="fe mr ms mt mh b">beforeEach</code>块中为夹具添加<code class="fe mr ms mt mh b">description</code>字段:</p><pre class="lr ls lt lu gt mg mh mi mj aw mk bi"><span id="3ac1" class="ml ko iq mh b gy mm mn l mo mp">beforeEach(() =&gt; {<br/>    const books = [<br/>      {"name": "Refactoring", "id": 1, "description": "Refactoring"},<br/>      {"name": "Domain-driven design", "id": 2, "description": "Domain-driven design"},<br/>      {"name": "Building Micro-service", "id": 3, "description": "Building Micro-service"}<br/>    ]</span><span id="034e" class="ml ko iq mh b gy mq mn l mo mp">    return books.map(item =&gt; axios.post('http://localhost:8080/books', item, {headers: { 'Content-Type': 'application/json' }}))<br/>  })</span></pre><p id="eba8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了，我们的测试通过了！</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mu"><img src="../Images/762421f08975eb06e97ad387c8b9f60d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MO8KkIEQeO08x03dsGFqVQ.png"/></div></div></figure><h1 id="356f" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">单元测试</h1><p id="941d" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">在端到端测试中，我们只需确保页面中有一个<code class="fe mr ms mt mh b">.description</code>部分。如果我们想要验证所有的字段都被正确地呈现在页面上，我们可以将它们添加到较低层次的测试单元测试中。单元测试运行速度快，检查比端到端测试更具体。</p><p id="034d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们为<code class="fe mr ms mt mh b">BookDetailContainer</code>添加单元测试之前，让我们先做一个小的重构，因为<code class="fe mr ms mt mh b">BookDetailContainer</code>是和<code class="fe mr ms mt mh b">axios.get</code>结合在一起的，我们不想在单元级测试中涉及这个。</p><p id="ad06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们先从<code class="fe mr ms mt mh b">BookDetailContainer</code>中提取一个<code class="fe mr ms mt mh b">BookDetail</code>组件:</p><pre class="lr ls lt lu gt mg mh mi mj aw mk bi"><span id="2430" class="ml ko iq mh b gy mm mn l mo mp">import React from 'react'</span><span id="7f14" class="ml ko iq mh b gy mq mn l mo mp">function BookDetail({book}) {<br/>  return (&lt;div className="detail"&gt;<br/>    &lt;div className="description"&gt;{book.description}&lt;/div&gt;<br/>  &lt;/div&gt;)<br/>}</span><span id="b1a9" class="ml ko iq mh b gy mq mn l mo mp">export default BookDetail</span></pre><p id="f902" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而<code class="fe mr ms mt mh b">BookDetailContainer</code>的<code class="fe mr ms mt mh b">render</code>方法则简化为:</p><pre class="lr ls lt lu gt mg mh mi mj aw mk bi"><span id="463c" class="ml ko iq mh b gy mm mn l mo mp">render() {<br/>    return &lt;BookDetail {...this.state}/&gt;<br/>  }</span></pre><p id="b50f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以轻松地在文件<code class="fe mr ms mt mh b">BookDetail.test.js</code>中添加单元测试，并尝试驱动实现:</p><pre class="lr ls lt lu gt mg mh mi mj aw mk bi"><span id="bee9" class="ml ko iq mh b gy mm mn l mo mp">it('Shows book name', () =&gt; {<br/>    const props = {<br/>      book: {<br/>        name: "Refactoring",<br/>        description: "The book about how to do refactoring"<br/>      }<br/>    }<br/>    const wrapper = shallow(&lt;BookDetail {...props}/&gt;)<br/>    expect(wrapper.find('.name').text()).toEqual("Refactoring")<br/>  })</span></pre><p id="34ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实现可能非常容易:</p><pre class="lr ls lt lu gt mg mh mi mj aw mk bi"><span id="eb1b" class="ml ko iq mh b gy mm mn l mo mp">import React from 'react'</span><span id="0b6b" class="ml ko iq mh b gy mq mn l mo mp">function BookDetail({book}) {<br/>  return (&lt;div className="detail"&gt;<br/>    &lt;h2 className="name"&gt;{book.name}&lt;/h2&gt;<br/>    &lt;div className="description"&gt;{book.description}&lt;/div&gt;<br/>  &lt;/div&gt;)<br/>}</span><span id="b279" class="ml ko iq mh b gy mq mn l mo mp">export default BookDetail</span></pre><h1 id="694f" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">文件结构</h1><p id="0ede" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">目前，文件结构非常扁平，根本没有层次结构，所有文件都在一个文件夹中。这是某种不好的味道，它让我们很难找到我们要找的东西，让我们重新构建它们。</p><pre class="lr ls lt lu gt mg mh mi mj aw mk bi"><span id="4390" class="ml ko iq mh b gy mm mn l mo mp">src<br/>├── App.css<br/>├── App.js<br/>├── BookDetail.js<br/>├── BookDetail.test.js<br/>├── BookDetailContainer.js<br/>├── BookList.js<br/>├── BookList.test.js<br/>├── BookListContainer.js<br/>├── e2e.test.js<br/>├── index.css<br/>├── index.js<br/>└── setupTests.js</span></pre><p id="e59c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mr ms mt mh b">React</code>社区中，一种非常常见的组件分类模式是将它们分成<code class="fe mr ms mt mh b">container</code>组件和<code class="fe mr ms mt mh b">presentational</code>组件。而<code class="fe mr ms mt mh b">container</code>组件负责获取和转换数据，而<code class="fe mr ms mt mh b">presentational</code>组件只渲染外部传来的数据。</p><p id="9519" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将所有的<code class="fe mr ms mt mh b">containers</code>放到<code class="fe mr ms mt mh b">containers</code>文件夹中，对于<code class="fe mr ms mt mh b">presentational</code>组件，我们简单地将它们放到一个名为<code class="fe mr ms mt mh b">components</code>的文件夹中:</p><pre class="lr ls lt lu gt mg mh mi mj aw mk bi"><span id="a46f" class="ml ko iq mh b gy mm mn l mo mp">src<br/>├── App.css<br/>├── App.js<br/>├── components<br/>│   ├── BookDetail<br/>│   │   ├── index.js<br/>│   │   └── index.test.js<br/>│   └── BookList<br/>│       ├── index.js<br/>│       └── index.test.js<br/>├── containers<br/>│   ├── BookDetailContainer.js<br/>│   └── BookListContainer.js<br/>├── e2e.test.js<br/>├── index.css<br/>├── index.js<br/>└── setupTests.js</span></pre><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mu"><img src="../Images/acba962d8ddea4ea0eba1e7d80cdf791.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Irh-Hy-_L3WD7QNUyxqotg.png"/></div></div></figure><h1 id="c3b6" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">用户界面</h1><p id="1213" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">到目前为止，我们已经完成了两个有趣且具有挑战性的功能。但是用户界面过于简单和丑陋，让我们添加一些风格。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mv"><img src="../Images/0bcb59b8e978f77e491f7038226d8ee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uo7fQB3VRfe-EAbx7xLYyA.png"/></div></div></figure><p id="aa4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在<code class="fe mr ms mt mh b">App.css</code>中定义一些布局相关的东西:</p><pre class="lr ls lt lu gt mg mh mi mj aw mk bi"><span id="eaf9" class="ml ko iq mh b gy mm mn l mo mp">.container {<br/>    max-width: 720px;<br/>    margin: 20px auto;<br/>}</span><span id="f575" class="ml ko iq mh b gy mq mn l mo mp">h1 {<br/>    background: limegreen;<br/>    color: white;<br/>    padding: 6px 8px;<br/>}</span></pre><p id="d964" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后在<code class="fe mr ms mt mh b">BookList/index.css</code>中列出相关的书单样式</p><pre class="lr ls lt lu gt mg mh mi mj aw mk bi"><span id="9cde" class="ml ko iq mh b gy mm mn l mo mp">.book {<br/>    border: 1px solid lightgreen;<br/>    margin-bottom: 12px;<br/>    padding: 6px 8px;<br/>    box-shadow: 0 0 2px #ccc;<br/>}</span><span id="d901" class="ml ko iq mh b gy mq mn l mo mp">h2 {<br/>    margin: 10px 0;<br/>    color: #333;<br/>}</span><span id="8aad" class="ml ko iq mh b gy mq mn l mo mp">.view-detail {<br/>    color: limegreen;<br/>    text-decoration: none;<br/>}</span></pre><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mv"><img src="../Images/c01cf3aff10c3b409816978723672b6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dt0ZP6Ml967iWMIxf3qMFw.png"/></div></div></figure><h1 id="82c6" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">处理默认值</h1><p id="ca41" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">嗯，有一个需求调整:由于后端服务提供的数据可能在一些字段中包含一些意外的空值。例如，不能保证<code class="fe mr ms mt mh b">description</code>字段总是出现(它可能只是一个空字符串或null值)，在这种情况下，我们需要使用图书名称作为描述作为后备。</p><p id="0f44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以添加一个测试来描述这种情况，注意props对象根本不包含<code class="fe mr ms mt mh b">description</code>字段:</p><pre class="lr ls lt lu gt mg mh mi mj aw mk bi"><span id="3aeb" class="ml ko iq mh b gy mm mn l mo mp">it('Shows the book name when no description was given', () =&gt; {<br/>    const props = {<br/>      book: {<br/>        name: "Refactoring"<br/>      }<br/>    }<br/>    const wrapper = shallow(&lt;BookDetail {...props}/&gt;)<br/>    expect(wrapper.find('.description').text()).toEqual("Refactoring")<br/>  })</span></pre><p id="8876" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们的测试又失败了:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mu"><img src="../Images/572edc52d47e069d214590133505ee40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9PLqKYFJ46Z0rJV5IMEljA.png"/></div></div></figure><p id="d41c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过条件运算符来解决这个问题:</p><pre class="lr ls lt lu gt mg mh mi mj aw mk bi"><span id="31de" class="ml ko iq mh b gy mm mn l mo mp">function BookDetail({book}) {<br/>  return (&lt;div className="detail"&gt;<br/>    &lt;h2 className="name"&gt;{book.name}&lt;/h2&gt;<br/>    &lt;div className="description"&gt;{book.description ? book.description : book.name}&lt;/div&gt;<br/>  &lt;/div&gt;)<br/>}</span></pre><h1 id="514d" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">又一个变化</h1><p id="8936" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">很快又有一个新的变化来了:如果<code class="fe mr ms mt mh b">description</code>的长度大于300，我们需要将内容截断到300个字符，并显示一个<code class="fe mr ms mt mh b">show more...</code>链接。当用户单击该链接时，将显示完整的内容。</p><p id="34da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以为这种情况添加一个新的测试:</p><pre class="lr ls lt lu gt mg mh mi mj aw mk bi"><span id="af5a" class="ml ko iq mh b gy mm mn l mo mp">it('Shows *more* link when description is too long', () =&gt; {<br/>    const props = {<br/>      book: {<br/>        name: "Refactoring",<br/>        description: "The book about how to do refactoring ...."<br/>      }<br/>    }<br/>    const wrapper = shallow(&lt;BookDetail {...props}/&gt;)<br/>    expect(wrapper.find('a.show-more').length).toEqual(1)<br/>    expect(wrapper.find('.description').text()).toEqual("The book about how to do refactoring ....")<br/>  })</span></pre><p id="7d2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这促使我们编写/修改代码以满足需求，一旦所有测试通过，我们就可以进行重构:提取新方法，创建新文件，移动方法/类，重命名变量或更改文件夹结构，等等。</p><p id="d843" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个无止境的过程，总会有一些改进，当我们有足够的时间时，我们可以一次又一次地保持这个过程，直到我们达到代码清晰和自我解释的程度。</p></div></div>    
</body>
</html>