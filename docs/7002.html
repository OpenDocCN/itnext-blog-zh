<html>
<head>
<title>Network Policies in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes中的网络策略</h1>
<blockquote>原文：<a href="https://itnext.io/network-policies-in-kubernetes-c983c1b5eee9?source=collection_archive---------2-----------------------#2022-05-12">https://itnext.io/network-policies-in-kubernetes-c983c1b5eee9?source=collection_archive---------2-----------------------#2022-05-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6735" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用<a class="ae kl" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> terraform </a>和<a class="ae kl" href="https://terragrunt.gruntwork.io/" rel="noopener ugc nofollow" target="_blank"> terragrunt </a>将我们的整个基础设施定义为代码，作为我们<a class="ae kl" href="https://azure.microsoft.com/" rel="noopener ugc nofollow" target="_blank"> Azure </a>迁移的一部分。这包括Azure Kubernetes服务和所有的资源。我在以前的一篇帖子中提到，我们使用Linkerd 的<a class="ae kl" href="https://linkerd.io/2.11/features/automatic-mtls/" rel="noopener ugc nofollow" target="_blank"> mTLS成功设置了pod到pod的通信加密，但我们希望确保在名称空间中的不同pod之间有一个额外的通信权限层，它只允许pod之间通过允许的协议和端口进行通信，同时限制其他一切。进入</a><a class="ae kl" href="https://kubernetes.io/docs/concepts/services-networking/network-policies/" rel="noopener ugc nofollow" target="_blank"> Kubernetes网络策略</a>，它允许更多的自定义控制来允许/限制CIDR块、名称空间和协议相互通信。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/c4971ce7728091202cfc55b4e0327bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wOMtZQ4cb_gxIZ1HkiKOfw.png"/></div></div></figure><p id="be6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes网络策略使用Linux <a class="ae kl" href="https://linux.die.net/man/8/iptables" rel="noopener ugc nofollow" target="_blank"> <em class="ky"> IP表</em> </a>来执行策略，该策略被翻译成允许/不允许规则集的<a class="ae kl" href="https://docs.microsoft.com/en-us/azure/aks/use-network-policies#network-policy-options-in-aks" rel="noopener ugc nofollow" target="_blank">形式，然后被应用为<em class="ky"> IP表</em>过滤规则。网络策略</a>的<a class="ae kl" href="https://kubernetes.io/docs/concepts/services-networking/network-policies/#prerequisites" rel="noopener ugc nofollow" target="_blank">先决条件是拥有一个网络插件，在Kubernetes行话中被称为CNI或</a><a class="ae kl" href="https://kubernetes.io/docs/concepts/cluster-administration/networking/" rel="noopener ugc nofollow" target="_blank">集群网络接口</a>，它作为控制器来执行这些规则。有很多选择，在Azure上，Azure CNI是我们的自然选择。</p><div class="kz la gp gr lb lc"><a href="https://docs.microsoft.com/en-us/azure/virtual-network/container-networking-overview" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd ir gy z fp lh fr fs li fu fw ip bi translated">使用Azure虚拟网络的容器网络</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">通过利用相同的软件定义的网络堆栈，将丰富的Azure网络功能集引入容器…</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">docs.microsoft.com</p></div></div><div class="ll l"><div class="lm l ln lo lp ll lq kw lc"/></div></div></a></div><p id="dfcb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们希望将通信限制在名称空间级别，而不是pod级别。网络策略主页上有一个很好的例子，描述了网络策略资源的不同组件。之后，我不得不坐下来思考一个更好的方法来把这些信息转化成我的方式。我们这边的要求基本上是限制入站流量，允许所有出站流量，并且只允许来自某些IP地址的流量。我们还希望允许来自基础应用程序名称空间的流量，例如Linkerd、<a class="ae kl" href="https://cert-manager.io/" rel="noopener ugc nofollow" target="_blank"> cert-manager </a>等。，以便各个名称空间中的pod可以利用不同的服务，同时保持应用程序之间的隔离。</p><div class="kz la gp gr lb lc"><a href="https://cert-manager.io/" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd ir gy z fp lh fr fs li fu fw ip bi translated">证书管理器</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">2022证书管理器作者。2022 Linux基金会。保留所有权利。Linux基金会已经注册了…</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">cert-manager.io</p></div></div><div class="ll l"><div class="lr l ln lo lp ll lq kw lc"/></div></div></a></div><p id="b854" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">网络策略的地形代码如下:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">我不得不说，我花了一些时间来表达from块，但是当它工作的时候是非常值得的。</figcaption></figure><p id="d00e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而其各自的terragrunt配置为:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="e3c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一切看起来都很棒，是时候对它进行测试了！为此，我使用了两种不同的服务；一个<a class="ae kl" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> nginx </a>容器，部署在默认名称空间中，作为一个简单的http服务器，一个<a class="ae kl" href="https://busybox.net/" rel="noopener ugc nofollow" target="_blank"> busy box </a>容器作为一个控制模块，我将在不同的名称空间中运行。想法是将网络策略应用到默认的名称空间，并从不同的名称空间访问运行在该名称空间中的nginx容器。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="03c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来的事情是启动我的<a class="ae kl" href="https://iterm2.com/" rel="noopener ugc nofollow" target="_blank"> iTerm </a>终端的另一个面板，并开始测试过程。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><pre class="kn ko kp kq gt mc mb md me aw mf bi"><span id="f1e7" class="mg mh iq mb b gy mi mj l mk ml">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br/>[...]</span></pre><p id="0e43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有趣的是，我访问了nginx容器，这很奇怪，因为根据网络策略配置，它不应该让请求通过。我通过linkerd名称空间进行了尝试，并且成功了(这并不奇怪，因为这是允许的)。我意识到我可能搞砸了一些事情，于是跑回文档。我可以断定一切都按照预期的方式进行了配置，但是为什么网络策略不能工作并过滤来自测试名称空间的请求。</p><p id="9556" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我又开始看配置，我在设置匹配表情的部分引起了我的注意。我开始<a class="ae kl" href="https://kubernetes.io/docs/concepts/services-networking/network-policies/#behavior-of-to-and-from-selectors" rel="noopener ugc nofollow" target="_blank">更深入地阅读</a>关于【matchExpression和matchLabel如何工作。我发现我是在以正确的方式使用它，但是还有一些事情是不正确的…</p><pre class="kn ko kp kq gt mc mb md me aw mf bi"><span id="a427" class="mg mh iq mb b gy mi mj l mk ml">ingress_from_namespace_selector_match_expressions = [{<br/>  "key" : "name",<br/>  "operator" : "In"<br/>  "value" : ["cert-manager", "linkerd"]<br/>}]</span></pre><p id="cfa4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我做的另一件事是描述默认的名称空间，并分析它的标签和注释，以确保万无一失。那里有一件特别的东西引起了我的注意。我意识到标签中名称空间的名称与我传递的完全不同…</p><pre class="kn ko kp kq gt mc mb md me aw mf bi"><span id="277c" class="mg mh iq mb b gy mi mj l mk ml">kubectl describe ns default<br/>Name:         default<br/>Labels:       kubernetes.io/metadata.name=default<br/>Annotations:  &lt;none&gt;<br/>Status:       Active</span></pre><p id="9233" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只是为了它，我更新了匹配表达式配置中的名称，以具有完整的Kubernetes标签名称…</p><pre class="kn ko kp kq gt mc mb md me aw mf bi"><span id="2342" class="mg mh iq mb b gy mi mj l mk ml">ingress_from_namespace_selector_match_expressions = [{<br/>  "key" : "kubernetes.io/metadata.name",<br/>  "operator" : "In"<br/>  "value" : ["cert-manager", "linkerd"]<br/>}]</span></pre><p id="6023" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">…通过<code class="fe ly lz ma mb b">terragrunt apply</code>应用更改，从测试名称空间返回并执行繁忙框中的命令，并ping nginx容器，瞧！请求被过滤了！</p><pre class="kn ko kp kq gt mc mb md me aw mf bi"><span id="6b54" class="mg mh iq mb b gy mi mj l mk ml">kubectl run --rm -it busybox --image=busybox:stable --namespace test </span><span id="2846" class="mg mh iq mb b gy mm mj l mk ml"># send a request to the nginx container running in the default namespace<br/>wget -O- --timeout=2 --tries=1 <a class="ae kl" href="http://backend.default" rel="noopener ugc nofollow" target="_blank">http://backend.default</a><br/></span><span id="0949" class="mg mh iq mb b gy mm mj l mk ml">wget: download timed out</span></pre><p id="a552" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个相当令人讨厌的发现，当然，我已经忽略了当事情不像预期的那样工作时，很自然会出现的揪头发和诅咒宇宙的步骤。然而，令人悲伤的是，将<code class="fe ly lz ma mb b">namespaceSelector</code>中的<code class="fe ly lz ma mb b">matchExpression</code>的键设置为与标签完全相同是非常矛盾的<a class="ae kl" href="https://www.merriam-webster.com/dictionary/oxymoron" rel="noopener ugc nofollow" target="_blank">IMHO。</a></p></div></div>    
</body>
</html>