<html>
<head>
<title>Enhancing reliability by distributing your APP into multiple OpenShift clusters — Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过将您的应用程序分布到多个OpenShift集群来增强可靠性—第二部分</h1>
<blockquote>原文：<a href="https://itnext.io/enhancing-reliability-by-distributing-your-app-into-multiple-openshift-clusters-part-ii-2d01d80f41db?source=collection_archive---------2-----------------------#2022-02-01">https://itnext.io/enhancing-reliability-by-distributing-your-app-into-multiple-openshift-clusters-part-ii-2d01d80f41db?source=collection_archive---------2-----------------------#2022-02-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b54a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于在多个Kubernetes / OpenShift集群中部署分布式应用程序的想法。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/da166240b668b1c1733eca545ac89f98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SmhPs0pAV9KgrxRZ"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">图片来自<a class="ae lf" href="https://unsplash.com/@mbaumi" rel="noopener ugc nofollow" target="_blank">米卡·鲍梅斯特</a></figcaption></figure><p id="8e6f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们在第一部分中所看到的，有时将您的微服务部署到多个Kubernetes集群中可能是一个好主意，因为它增强了可靠性，但也为您提供了更多选择使用哪个基础架构/公共云的自由，它为您提供了更好的可扩展性和执行云爆发的机会，允许在地理分布式解决方案中灵活放置工作负载，简化了灾难恢复和故障转移，支持新的用例(即边缘计算部署)等…不仅如此…前几天与<a class="ae lf" href="https://www.nethopper.io/" rel="noopener ugc nofollow" target="_blank"> Nethopper </a>(多云应用网络解决方案)的首席执行官克里斯·芒福德(Chris Munford)交谈时，他给了我另一个暗示，为什么公司会对多云部署感兴趣:监管。</p><p id="d6ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你认为在监管非常严格的行业，比如FSI，有时需要在多个云中构建环境，由于当地的主权法律，甚至可能每个国家或地区一个。这意味着他们将需要在多个云/集群上部署应用程序，即使上述任何原因适用于该客户。</p><div class="lg lh gp gr li lj"><a href="https://luis-javier-arizmendi-alonso.medium.com/enhancing-reliability-by-distributing-your-app-into-multiple-openshift-clusters-part-i-a506d90f00f2" rel="noopener follow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd iu gy z fp lo fr fs lp fu fw is bi translated">通过将您的应用程序分布到多个OpenShift集群来增强可靠性—第一部分</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">关于在多个OpenShift集群中部署分布式应用的思考。</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">luis-javier-arizmendi-alonso.medium.com</p></div></div><div class="ls l"><div class="lt l lu lv lw ls lx kz lj"/></div></div></a></div><p id="9180" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，遵循在多个集群中部署应用的方法，我们需要克服一些挑战，主要是关于“如何提供通用网络和存储”，以及“如何管理多集群应用”</p><p id="c4dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将探索一些可用的选项，我们必须将运行在不同Kubernetes集群上的微服务相互连接，更具体地说是在OpenShift中，以解决“公共网络”问题。</p><p id="5599" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我不会讨论所需的外部设置(全局负载平衡器、DNS等)，因为我将重点讨论如何允许在一个OpenShift集群上运行的微服务访问在另一个集群上运行的微服务，这是允许多集群应用部署所需要的。</p><p id="b982" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一次，我将不再赘述我以前在文章中提到的技术细节(部署和测试),因为否则的话，这篇文章会太长。如果人们觉得有趣，我可能会写额外的文章展示每个选项的测试。</p><p id="2c80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为第一点，我将介绍在集群之间提供东西“互连”的最简单方法，然后<strong class="js iu">我将回顾Submariner、Skupper和Service Mesh (ISTIO)联盟背后的思想</strong>，并以这三个选项的简短回顾结束本文。</p><h1 id="3fd7" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">“容易的道路”以及为什么你不应该走这条路。</h1><p id="b4d4" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">为什么互联互通会如此混乱？将任何东西连接到我的集群上运行的微服务都很容易，不是吗？您可以只创建一个“入口”(您可以在OpenShift中选择“路由”对象)或配置NodePorts、ExternalIP或负载平衡器类型的Kubernetes服务…</p><p id="f0b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你是对的！，即使有更多的选择，你也可以使用<em class="ko"> Multus </em>在你的微服务中配置一个额外的网络，让它们使用VLAN直接连接…但这不是重点…想想那些不应该对外“发布”的微服务，内部数据库会怎么样？，还是内部消息系统？，还是与关键的微服务？…</p><blockquote class="nb nc nd"><p id="4a57" class="jq jr ko js b jt ju jv jw jx jy jz ka ne kc kd ke nf kg kh ki ng kk kl km kn im bi translated">注意:如果您将Multus与SR-IOV结合使用，以获得与裸机节点相同的网络性能，那么在多集群部署中使用Multus仍然有意义。如果你想了解更多，可以看看我写的这篇文章:</p></blockquote><div class="lg lh gp gr li lj"><a href="https://medium.com/swlh/enhanced-platform-awareness-epa-in-openshift-part-iv-sr-iov-dpdk-and-rdma-1cc894c4b7d0" rel="noopener follow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd iu gy z fp lo fr fs lp fu fw is bi translated">OpenShift中增强的平台意识(EPA)——第四部分，SR——IOV、DPDK和RDMA</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">在本文中，我们将回顾一些有助于最小化随机延迟和提高网络性能的概念…</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">medium.com</p></div></div><div class="ls l"><div class="nh l lu lv lw ls lx kz lj"/></div></div></a></div><p id="d170" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您创建路由、外部服务，或者使用Multus来提供对应用程序中必须由外部组件访问的部分的外部访问，那么您可能会在您的体系结构中造成安全威胁。您需要将访问权限仅限于允许的配对。您可以通过在Kubernetes中配置安全策略规则来实现这一点(除非您使用Multus方法),但是安全策略特性主要是为了实施内部网络访问而设计的，因此您目前可能不具备您可能需要的功能，也不具备您在外部防火墙中针对这种情况所具备的功能(此外，您还会使您的应用程序的生命周期变得复杂)。</p><p id="ed3e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您也可以使用外部系统，但这并不总是容易的，例如，认为入口/路由在TCP第7层工作，因此您不能使用常规的第4层防火墙，您需要配置第7层防火墙或其间的HTTP/S代理，或者如果您配置Kubernetes服务，如您需要打开的节点端口(更多？)所有Kubernetes工作节点中的端口…</p><p id="1200" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不仅如此，想想那些不应该从外部世界到达的组件之间交换的流量，当那些被设计为“内部”的服务很可能在其通信中没有任何加密时，如何确保没有人“查看”该流量(中间人)。</p><p id="3b36" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">希望我在安全部分说服了你，但还有更多。</p><p id="9ddb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您看到了Kubernetes/OpenShift的价值，同时提供了一个平台来实现您的(有希望的)创新想法，因此您努力移动您的流程、应用程序架构和第2天的操作，以便更好地适应“Kubernetes的做事方式”(一切都是代码)，为什么要通过引入您需要“像过去一样”管理的部分来消除一切呢？按照Kubernetes的方法，你如何管理你放在服务之间的这些部分？(当我们讨论如何管理您的多集群应用程序时，这将非常重要)</p><p id="489b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">…还有更多要讨论的。您正在考虑让您的应用程序成为多集群，以便获得更多好处，但是您希望通过在Kubernetes中运行您的应用程序来保持您已经获得的好处，所以请考虑一件事…如果您使用这种“外部访问方法”，您如何提供一种简单的方法来创建一个Kubernetes服务，在多个不同的Kubernetes集群中使用副本，而无需在涉及智能负载平衡器的复杂架构中进行中继？或者说，您如何在所有通信中提供特性一致性？(即。考虑一些不能用于外部连接的Kubernetes特性，或者考虑应用程序指标和监控)</p><p id="a312" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">“简单的道路”可能看起来很方便，但是，如果你开始思考使用它的含义，你可能会意识到你需要别的东西。</p><h1 id="ce5f" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">OpenShift多集群网络连接选项:Submariner、Skupper和Istio</h1><p id="6d77" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">有多种解决方案可以弥补上述差距。在本文中，我将重点介绍可以在OpenShift中使用的工具。</p><blockquote class="nb nc nd"><p id="c762" class="jq jr ko js b jt ju jv jw jx jy jz ka ne kc kd ke nf kg kh ki ng kk kl km kn im bi translated">注意:当我说“您可以使用”时，我指的是OpenShift中支持的方法。如您所知，由于OpenShift的核心是Kubernetes，您可能会使用任何其他基于社区的集成，但在这种情况下，该架构的特定部分将只使用<strong class="js iu">一种“尽力而为”的方法</strong>来支持，不支持SLA。</p></blockquote></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="da7f" class="ly lz it bd ma mb np md me mf nq mh mi mj nr ml mm mn ns mp mq mr nt mt mu mv bi translated">潜水艇人员</h1><blockquote class="nb nc nd"><p id="b898" class="jq jr ko js b jt ju jv jw jx jy jz ka ne kc kd ke nf kg kh ki ng kk kl km kn im bi translated">注意:技术预览功能在这一刻</p></blockquote><p id="f5f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae lf" href="https://submariner.io/" rel="noopener ugc nofollow" target="_blank"> Submariner </a>带来了一种在Kubernetes集群之间提供第3层连接和服务发现的方式，而与您使用的CNI网络无关。Submariner可以直接在Kubernetes集群上配置，但是当与OpenShift一起使用时，您必须使用<em class="ko">高级集群管理器</em>(检查ACM使用的附加组件下方)以便与支持兼容。</p><div class="lg lh gp gr li lj"><a href="https://github.com/stolostron/submariner-addon" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd iu gy z fp lo fr fs lp fu fw is bi translated">GitHub-stolostron/submariner-addon:ocm中submariner的一个插件，提供网络连接…</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">ACM与潜艇兵的结合。Submariner使不同的吊舱和服务之间能够直接联网…</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">github.com</p></div></div><div class="ls l"><div class="nu l lu lv lw ls lx kz lj"/></div></div></a></div><p id="c0d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然Submariner有多个部分(网关节点、路由代理、代理、服务发现等等)，但您可以在上面找到一个数据和控制平面。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nv"><img src="../Images/607fae79c857b35943e0f163789b79aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2DSS2_mOBbUPIRGu.jpg"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">来自<a class="ae lf" href="https://submariner.io/getting-started/architecture/" rel="noopener ugc nofollow" target="_blank">https://submariner.io/getting-started/architecture/</a>的潜艇结构图</figcaption></figure><h2 id="6fa6" class="nw lz it bd ma nx ny dn me nz oa dp mi kb ob oc mm kf od oe mq kj of og mu oh bi translated">数据平面</h2><p id="dd85" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">数据平面主要由两部分组成:网关节点和路由代理。</p><p id="856e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">网关节点负责执行创建隧道的集群网络的实际连接。如果你看一下Submariner的“社区版本”,你会看到Submariner是如何提供多种选项来创建这些隧道的:WireGuard、带有Libreswan的IPsec和未加密的VXLAN设置。<strong class="js iu">当你使用带有OpenShift的Submariner时，你的网关引擎将使用Libreswan IPsec隧道来连接你的集群</strong>。也可以部署不止一个网关，以便在主动/被动模式下获得高可用性。</p><p id="695b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">网关还向控制平面(代理)通告集群端点信息，以便其他集群知道它的存在。</p><p id="066f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">值得一提的是，您将需要<strong class="js iu">允许集群之间的通信，这包括打开的IP可达性和(非HTTP/S) TCP/UDP端口</strong>。Submariner网关节点需要能够接受UDP端口4500上的IPsec流量，因为它们使用该端口创建IPsec隧道，但它们还需要UDP端口4800来封装使用VXLAN的流量，为什么？。</p><p id="51fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Submariner被设计为独立于您的Kubernetes集群中使用的CNI插件，因此它需要一种独立的方式来与不在运行网关节点的同一个工作节点上运行的pod进行通信(再次检查上面的绘图，并寻找“VX-submariner”连接)。这就是为什么您需要打开一个端口来创建工作节点之间的VXLAN隧道。</p><p id="5e26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了IPsec和VXLAN端口，OpenShift中的Submariner将使用TCP端口8080来共享网关节点导出的一些指标:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/f531e59886d14938573d291421175eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*Y2-WRK0Q4ymAzzuOJjIcSA.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">https://access . red hat . com/documentation/en-us/red _ hat _ advanced _ cluster _ management _ for _ kubernetes/2.4/html-single/services/index中的端口列表</figcaption></figure><p id="3a87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果在AWS或GCP上运行OpenShift，配置会自动完成，否则，必须执行一些手动步骤来允许集群之间的所有这些连接，包括创建负载平衡或节点端口服务。</p><p id="4c1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在为Submariner配置可达性时，还有另一点需要考虑。因为在OpenShift Submariner中是使用IPsec配置的，所以可以使用一个名为“preferred-server”的功能。这一特性使得在公共或私有IP地址和防火墙配置上，只有一个集群端可以到达一对一连接(假设其中一个集群没有发布所需的端口)。</p><p id="63c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于用于创建隧道的IP，通信利用NAT穿越，这允许检测连接是否可以使用私有IP(这是默认的)或者它必须使用公共IP。如果您想了解更多关于NAT遍历如何与Submariner一起使用的信息，您可以在文档中仔细检查这个页面:</p><div class="lg lh gp gr li lj"><a href="https://submariner.io/operations/nat-traversal/" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd iu gy z fp lo fr fs lp fu fw is bi translated">NAT穿越</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">默认情况下，Submariner通过端口4500/UDP在集群之间建立数据平面隧道。此端口可以是…</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">潜艇兵</p></div></div></div></a></div><p id="2160" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">数据平面的另一个重要部分是路由代理。代理是在配置了Submariner的集群的每个节点(DaemonSet)上运行的POD。<strong class="js iu">路由代理是Submariner和集群</strong>中已配置的CNI插件之间的“桥梁”。根据所选的CNI，有多种不同的实施方式，例如，许多CNI(包括OpenShift SDN)使用<em class="ko"> iptables </em>来配置节点内部的Kubernetes服务对象路由(将对Kubernetes服务的请求路由到POD IP)，但在OpenShift中，我们还有CNI开放虚拟网络(OVN)，它使用直接在Open vSwitch中配置的流。由于路由代理是一个把CNI插件和潜艇的其余部分放在一起的组件，代理需要能够处理，在这种情况下，<em class="ko"> iptables </em>和OVN流。路由代理pod了解本地端点，并使用这些<em class="ko"> iptables </em>或OVN集成来配置基础架构，从而可以将流量从所有节点路由到活动网关引擎节点。</p><h2 id="881b" class="nw lz it bd ma nx ny dn me nz oa dp mi kb ob oc mm kf od oe mq kj of og mu oh bi translated">控制平面</h2><p id="0c05" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">控制平面的<strong class="js iu"> </strong>主要部分是代理，它是架构的集中部分。它拥有每个网关发送的信息，并在集群之间交换这些信息，以使其他网关能够发现这些信息。</p><p id="d3be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">“经纪人”是什么？一个豆荚？。代理实际上是包含在“中央”Kubernetes集群的Kubernetes API中的一组自定义资源定义，所有其他子集群都必须可以访问这些定义。如果您对这些cdr感兴趣，可以看看包含Helm图表的Git repo，以部署Submariner代理:</p><div class="lg lh gp gr li lj"><a href="https://github.com/submariner-io/submariner-charts/blob/devel/submariner-k8s-broker/crds/crd.yaml" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd iu gy z fp lo fr fs lp fu fw is bi translated">submariner-charts/CRD . YAML at devel submariner-io/submariner-charts</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">此文件包含双向Unicode文本，其解释或编译可能与下面显示的不同…</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">github.com</p></div></div><div class="ls l"><div class="oj l lu lv lw ls lx kz lj"/></div></div></a></div><p id="5c0b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有一件重要的事情要提一下。正如我所说的，代理“运行”的Kubernetes API必须可以被所有其他集群访问……但是如果这个集中的部分出现任何故障，会发生什么呢？。如果代理不可用，这并不意味着数据平面受到影响，因此未受影响的群集之间的连接将继续工作，这也是事实，因为它们将使用代理工作时从代理获得的最后信息，在代理恢复之前，不可能使用新端点或已连接群集的状态等信息来更新该信息。</p><p id="a686" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">控制平面不仅必须提供一种方法来创建不同集群网络之间的连接(我们已经介绍过了)，而且还必须提供一种方法来共享和发现不同的Kubernetes服务，以便在Submariner网络中包含的任何集群上运行的pod能够知道将它们的请求推到哪里。</p><p id="742b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">为了使一个集群中的服务对其他集群可见，Submariner提供了一个名为ServiceExport </strong>的特定CRD(您可以在上面显示的Git repo中找到它)。发布服务时，您将能够使用以下格式从Submariner网络的任何其他集群部分使用服务:</p><p id="719f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ok ol om on b">&lt;service&gt;.&lt;namespace&gt;.svc.<strong class="js iu">clusterset</strong>.local</code></p><p id="2096" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为Submariner控制平面的一部分，我们发现另一个值得一提的部分正在开发中(这意味着它还不是OpenShift支持的功能的一部分):Globalnet控制器</p><p id="17f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个组件试图解决Submariner的一个主要限制:集群中有重叠的CIDRs。如果您在部署集群时没有考虑到这一点，这可能会是一个大问题(可能是因为那时您甚至不知道需要使用Submariner)。Kubernetes集群通常有两个主要网络，一个用于Kubernetes服务，另一个用于“集群网络”(用于PODs的IPs)。在OpenShift中，可以配置这些CIDRs，但大多数情况下，如果您没有发现可能需要从集群中的pod访问的IP与外部系统重叠的问题，您通常不会接触它们。这意味着您的集群可能具有相同的CIDRs，这将导致潜艇控制平面不知道如何将流量路由到正确的集群/服务/POD。</p><p id="a8eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，如果你仔细想想，这种具有非重叠网络的模型并不能很好地扩展，因此Globalnet控制器通过(简化它)在每个集群的当前CIDR之上分配一个新的来解决这一限制，为潜艇控制平面提供一种区分它们的方法。这就像如果集群网络是“专用网络”,而Globalnet IP是“公共网络”,并且在两者之间有一个NAT/映射。</p><p id="b675" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想提到的最后一点是可观察性和监控。Submariner提供了一些端点，Prometheus可以使用这些端点来获取平台的指标,但是，正如您在下面的列表中看到的，仍然有一些对可观察性和跟踪建议有用的信息是不可用的(还没有？)，这意味着如果您需要手动将应用程序分散到多个集群中，故障排除可能会有点困难(这也再次强调了这样一个信息，即在所有集群之上有一个适当的管理层，为您提供可见性和自动化，这是您采用多云/多集群时“必须的”)。</p><div class="lg lh gp gr li lj"><a href="https://submariner.io/operations/monitoring/" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd iu gy z fp lo fr fs lp fu fw is bi translated">监视</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">Submariner提供了许多Prometheus指标，并设置了允许这些指标…</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">潜艇兵</p></div></div></div></a></div></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="3f9a" class="ly lz it bd ma mb np md me mf nq mh mi mj nr ml mm mn ns mp mq mr nt mt mu mv bi translated">斯库伯</h1><blockquote class="nb nc nd"><p id="003e" class="jq jr ko js b jt ju jv jw jx jy jz ka ne kc kd ke nf kg kh ki ng kk kl km kn im bi translated">注意:技术预览功能在这一刻</p></blockquote><p id="7ea3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae lf" href="https://skupper.io/" rel="noopener ugc nofollow" target="_blank"> Skupper </a>采用了与Submariner不同的方法，不是像Submariner一样提供一个集中式节点/路由器来执行集群之间的IPsec隧道，而是使用一个分散模型，其中Kubernetes名称空间中的一个类似代理的服务器执行第7层服务互连。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi oo"><img src="../Images/5a7db6ef995e5b823d90314ec6c5d340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QX7Z26mbpaVnZde0AEMIpg.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">图片来自https://skupper.io/docs/overview/index.html<a class="ae lf" href="https://skupper.io/docs/overview/index.html" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="f8da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Skupper背后的想法是让用户自己创建所谓的“虚拟应用网络”(VAN)，这是一个覆盖在集群网络之上的网络，而不是依赖于集群管理员设置的互连性，这是一个关键的优势:</p><blockquote class="nb nc nd"><p id="ffb7" class="jq jr ko js b jt ju jv jw jx jy jz ka ne kc kd ke nf kg kh ki ng kk kl km kn im bi translated">“…VAN部署在应用程序层，目的是为单个分布式应用程序提供服务。它不需要成为网络基础设施的一部分，开发人员或运营商可以快速轻松地创建VAN，而无需访问管理权限或特殊的网络基础设施，如VPN、IPSec、SDN、防火墙映射规则等……”</p></blockquote><div class="lg lh gp gr li lj"><a href="https://netprototalk.wordpress.com/2019/11/12/virtual-application-networks-for-hybrid-cloud-interconnect/" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd iu gy z fp lo fr fs lp fu fw is bi translated">面向混合云互连的虚拟应用网络</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">多云和混合云计算是最近的热门话题。在…的便携性方面取得了良好的进展</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">netprototalk.wordpress.com</p></div></div><div class="ls l"><div class="op l lu lv lw ls lx kz lj"/></div></div></a></div><h2 id="76a0" class="nw lz it bd ma nx ny dn me nz oa dp mi kb ob oc mm kf od oe mq kj of og mu oh bi translated">数据平面</h2><p id="656f" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated"><strong class="js iu"> Skupper proxy </strong>，将数据从一个名称空间移动到另一个名称空间(可能在另一个集群中)，<strong class="js iu">基于</strong> <a class="ae lf" href="http://qpid.apache.org/components/dispatch-router/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> Apache Qpid调度路由器</strong> </a>，这是一个轻量级的无状态消息路由器，使用<strong class="js iu"> AMQP </strong>(发布/订阅架构)与其他Qpid路由器通信。请记住，虽然Skupper代理是一个AMQP路由器，但它不像典型的AMQ消息服务用例，在那里您的应用程序需要与消息服务一起工作，有了Skupper，您可以继续使用您的应用程序而无需修改，因为使用消息协议的是Qpid路由器，而不是应用程序。</p><p id="b102" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Qpid不像Submariner那样基于IP地址进行路由，而是使用服务名称，这使得避免集群之间的重叠更加简单，并且还实现了多播连接或负载平衡。</p><p id="0f46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这也意味着，如果您的应用程序协商要使用的TCP/UDP端口(如FTP ),您将无法在Skupper端之间创建这样的通信，因为协商不会发生。</p><p id="a167" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Skupper代理还<strong class="js iu">使用它们之间的MTL</strong>保护与其他代理的连接(使用它自己的CA)。</p><p id="3152" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">谈到简单性，在Skupper路由器之间授权连接还有另一个值得注意的地方。当我们回顾<em class="ko"> Submariner </em>数据平面时，我们看到了我们如何需要允许在我们的集群上运行的应用程序的非HTTP端口连接，这意味着使用负载平衡器或节点端口服务。与Skupper不同，您可以遵循这种方法，但是<strong class="js iu">您也可以使用OpenShift Route/Ingress来访问Skupper代理</strong>。当您使用"<em class="ko"> skupper init </em>"命令执行Skupper初始化时，将在您的OpenShift集群中创建一个新的路由对象(类型" Edge ")，并绑定到该名称空间中部署的skupper代理。您可以使用该URL来连接远程Skupper代理。</p><p id="fed6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于这种虚拟网络可以由非特权用户轻松设置，并且由于其简单性，这对于例如开发人员来说是小菜一碟，不仅可以在不同集群上运行的微服务之间设置连接，还可以在他们开发微服务时，甚至从他们自己的笔记本电脑上运行的环境到中央OpenShift集群设置连接，这可以非常方便地简化微服务开发，而不必使用云上IDE(如OpenShift代码就绪工作区)。请点击此处查看示例:</p><div class="lg lh gp gr li lj"><a href="https://developers.redhat.com/blog/2020/01/01/skupper-io-let-your-services-communicate-across-kubernetes-clusters#use_case__a_local_service_exporter_with_skupper" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd iu gy z fp lo fr fs lp fu fw is bi translated">io:让您的服务在Kubernetes集群之间进行通信</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">在过去的几年中，容器的普及和采用飞速发展，Kubernetes容器…</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">developers.redhat.com</p></div></div><div class="ls l"><div class="oq l lu lv lw ls lx kz lj"/></div></div></a></div><p id="e7ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于高可用性，Qpid路由器的多个副本的使用正在开发和测试中，并将在不久的将来可用，此时Skupper路由器的HA由Kubernetes自修复功能提供。</p><h2 id="a228" class="nw lz it bd ma nx ny dn me nz oa dp mi kb ob oc mm kf od oe mq kj of og mu oh bi translated">控制平面</h2><p id="251e" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">控制平面的分布原理与我们在传统网络中发现的原理相同，在传统网络中，您依赖路由协议来做出路由决策。Apache <strong class="js iu"> Qpid路由器使用类似于OSPF </strong>的链路状态路由协议来了解网络拓扑，并使用网络中两点之间成本最低的路径进行路由。</p><p id="ee51" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与其它链路状态路由协议一样，您可以通过将“内部”角色分配给需要入口和出口连接的路由器，将“边缘”角色分配给不需要入口连接的路由器，来控制路由表的复杂性并改进最佳路径的计算。</p><p id="4c7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">控制平面中还有另一个部分，<strong class="js iu"> skupper-controller </strong>(也运行在启动skupper的名称空间上)。它管理部署在运行Skupper的名称空间中的资源，以及关于Skupper网络中公开的服务的信息。说到这个…和<em class="ko">潜艇兵</em>一起，我们决定使用CRD共享哪些服务，Skupper是如何做到的？</p><p id="9ba8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用Skupper更容易，您只需要在Kubernetes服务中添加一个注释:</p><pre class="kq kr ks kt gt or on os ot aw ou bi"><span id="b20b" class="nw lz it on b gy ov ow l ox oy">skupper.io/proxy: tcp</span></pre><p id="5b6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦服务发布，它将出现在另一个Kubernetes集群中，就像它是一个本地Kubernetes服务一样。</p><p id="5d01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">潜艇覆盖的另一点是可观察性。对于Skupper，我们有两个控制台，一个是Apache Qpid调度控制台，另一个是Skupper控制台。Skupper控制台稍微简单一点，但它可以让您很好地了解Skupper中存在的站点和连接，但如果您需要更详细的信息，可以查看Qpid控制台，它可以为您提供有关网络中发生的连接的多个方面的更多详细信息。</p><p id="e7b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，在OpenShift中，我们默认启用s upper控制台，但不启用Qpid控制台，可以通过更改s upper初始化时创建的s upper-site config map中的参数来激活它(您可以在初始化期间使用命令"<em class="ko">s upper init-enable-router-Console</em>")来启用它</p><blockquote class="nb nc nd"><p id="7628" class="jq jr ko js b jt ju jv jw jx jy jz ka ne kc kd ke nf kg kh ki ng kk kl km kn im bi translated">注意:configmap还管理其他重要方面，例如，它向Skupper指出，在初始化时，它必须创建一个入口对象类型“Route”。</p></blockquote><p id="e162" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想看看Skupper的实际操作，包括控制台的可观察性，看看这个由Ted Ross(Nethopper的首席技术专家)和Burr Sutter(Red Hat的开发者体验总监)主持的演示:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="oz pa l"/></div></figure></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="5897" class="ly lz it bd ma mb np md me mf nq mh mi mj nr ml mm mn ns mp mq mr nt mt mu mv bi translated">服务网格(Istio)联盟</h1><p id="9966" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">服务网格是OpenShift中Istio实现的特性的名称。我过去已经写了一些关于它的文章，所以我不会详细介绍它试图解决什么问题或者它的架构是什么样子的，如果你想看一看的话，这是该系列的第一篇:</p><div class="lg lh gp gr li lj"><a href="https://medium.com/swlh/openshift-service-mesh-essentials-part-i-the-why-and-what-of-it-a3ef09bf8aa8" rel="noopener follow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd iu gy z fp lo fr fs lp fu fw is bi translated">open shift Service Mesh Essentials—第一部分—原因和内容</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">在第一篇文章中，我们将讨论一些关于OpenShift服务网格的介绍性问题，包括它的特性…</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">medium.com</p></div></div><div class="ls l"><div class="pb l lu lv lw ls lx kz lj"/></div></div></a></div><p id="404c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我将把重点放在我发表这些文章时还没有准备好的一个特性上，即Istio Federation，因为它也可以帮助多个不同的Kubernetes集群相互连接。</p><blockquote class="nb nc nd"><p id="23f2" class="jq jr ko js b jt ju jv jw jx jy jz ka ne kc kd ke nf kg kh ki ng kk kl km kn im bi translated">注意:服务网格联合可以用同一个集群上的多个服务网格来完成(可以用OpenShift来部署)，但是这里我将着重于联合不同OpenShift集群中的服务网格。</p></blockquote><p id="1279" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想在这里强调一些非常重要的事情，这也是我每次谈到ISTIO时都会给出的建议。如果您只是在寻找ISTIO的单一功能(在这种情况下是集群互连，但您也可以将此评论应用于其他功能，例如，如果您只想在应用中设置MTL，并且不打算使用服务网格提供的更多其他功能……可能您不应该选择此选项，因为它增加了一层复杂性，应该通过一系列超越集群之间东西可达性的优势来平衡。</p><p id="b3d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于支持，您还可以在文档中找到一些值得一提的内容:</p><blockquote class="nb nc nd"><p id="8c58" class="jq jr ko js b jt ju jv jw jx jy jz ka ne kc kd ke nf kg kh ki ng kk kl km kn im bi translated">Red Hat OpenShift服务网格联合方法连接网格有以下限制:</p><p id="41f1" class="jq jr ko js b jt ju jv jw jx jy jz ka ne kc kd ke nf kg kh ki ng kk kl km kn im bi translated">* open shift专用版不支持网格联盟。</p><p id="7a14" class="jq jr ko js b jt ju jv jw jx jy jz ka ne kc kd ke nf kg kh ki ng kk kl km kn im bi translated">* Microsoft Azure Red Hat open shift(ARO)不支持网格联盟。</p><p id="842a" class="jq jr ko js b jt ju jv jw jx jy jz ka ne kc kd ke nf kg kh ki ng kk kl km kn im bi translated">* AWS(ROSA)上的Red Hat OpenShift服务不支持网格联盟。</p></blockquote><div class="lg lh gp gr li lj"><a href="https://docs.openshift.com/container-platform/4.9/service_mesh/v2x/ossm-federation.html" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd iu gy z fp lo fr fs lp fu fw is bi translated">联合—服务网格2.x |服务网格| OpenShift容器平台4.9</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">跨云和内部基础架构构建、部署和管理应用</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">docs.openshift.com</p></div></div></div></a></div><h2 id="83e3" class="nw lz it bd ma nx ny dn me nz oa dp mi kb ob oc mm kf od oe mq kj of og mu oh bi translated">数据平面</h2><p id="5225" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">专用于服务网格互连的数据平面的主要部分是网关，它将用于路由它们之间的所有流量</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi pc"><img src="../Images/161cdaad6e8c9885dc5c0320137275d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ONu5IGmXZJih_yVnSEij2g.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">图片来自<a class="ae lf" href="https://docs.openshift.com/container-platform/4.9/service_mesh/v2x/ossm-federation.html" rel="noopener ugc nofollow" target="_blank">https://docs . open shift . com/container-platform/4.9/service _ mesh/v2x/ossm-Federation . html</a></figcaption></figure><p id="bbae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通常，服务网格网关将管理网格的入口和出口流量。当您联合多个服务网格时，您将有特定的网关用于连接到其他网格，这里的一个好方法(为了避免对象重叠的问题)是每个网格对有特定的网关，所以如果您有三个想要直接连接的服务网格，您将为每个连接创建不同的网关(即网关A-C和网关A-B)。</p><p id="2da6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建完成后，您使用特定的CRD ( <em class="ko"> ServiceMeshPeer </em>)配置远程网关连接，然后您将在不同的服务网格之间使用TLS获得一个<strong class="js iu">加密的TCP连接，但是首先，您需要确保不同网关之间的连通性。您应该通过运行在第4层的负载平衡器(用于h a)来公开它们。</strong></p><p id="d810" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">提供这种负载平衡连接的方式将取决于您的OpenShift在哪里运行，以及您可以用于该平台的服务是什么，例如，如果您在内部运行Kubernetes服务类型<em class="ko"> LoadBalancer </em>(可能使用MetalLB？).在无法使用<em class="ko">负载平衡器</em>类型的情况下，您可以配置服务节点端口，以便将网关直接发布到您的集群之外，并使它们可以从其他网关到达。</p><p id="421a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于使用<em class="ko">负载平衡器</em>类型的网关发布，还有另一点需要考虑:负载平衡模式应该是第4层平衡，这在一些公共云中，如AWS，不是默认的(您需要添加一个注释:<em class="ko">service.beta.kubernetes.io/aws-load-balancer-type: NLB</em>)。</p><p id="038d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">联盟流量由用于发现的HTTPS和用于服务流量的加密TCP组成。请记住允许TLS通信(默认情况下使用端口TCP 15443)以及在网关之间使用TCP端口8188进行的发现请求。</p><p id="fcbd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于内部流量的数据平面的最后一句话，请考虑当流量从一个网状网跨越到另一个网状网时，<strong class="js iu">它会丢失来自发起连接的源的有趣信息(</strong>因为目的地服务从入口网关而不是原始源<strong class="js iu"> ) </strong>获得请求，因此目的地将无法知道发起工作负载的身份。这可能会影响一些依赖这些信息做出决策的应用程序，如果这是你的情况，所有的部分都将在同一个服务网格控制平面下。</p><h2 id="7876" class="nw lz it bd ma nx ny dn me nz oa dp mi kb ob oc mm kf od oe mq kj of og mu oh bi translated">控制平面</h2><p id="6ce8" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">当使用多个集群时，基本上有两种不同的社区Istio部署模型:</p><ul class=""><li id="a5c1" class="pd pe it js b jt ju jx jy kb pf kf pg kj ph kn pi pj pk pl bi translated">集群中同时拥有控制平面和数据平面</li><li id="6d4f" class="pd pe it js b jt pm jx pn kb po kf pp kj pq kn pi pj pk pl bi translated">您要么拥有控制平面，要么拥有数据平面</li></ul><p id="3717" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，您可以有两个群集，一个包含控制平面和数据平面，另一个仅包含数据平面(由位于远程群集中的控制平面管理)。</p><p id="9bab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您想查看一些图表并获得更多关于community Istio部署方法的信息，您可以阅读下面的页面。</p><div class="lg lh gp gr li lj"><a href="https://istio.io/latest/docs/ops/deployment/deployment-models/" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd iu gy z fp lo fr fs lp fu fw is bi translated">部署模型</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">在配置Istio的生产部署时，您需要回答许多问题。网格会被限制吗…</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">istio.io</p></div></div></div></a></div><p id="5b84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> OpenShift目前仅支持一种模型，其中每个集群拥有自己的服务网格控制平面以及服务网格数据平面</strong>，因此目前您无法配置一个控制平面来管理位于不同集群中的多个数据平面。这是目前正在调查的事情(有几个安全性和可用性方面必须审查)，它可能会在未来作为与<em class="ko">高级集群管理器的集成包括在内。</em></p><p id="3acd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该方法不需要打开从一个集群到其他集群的Kubernetes API的连接，这提供了一种共享一些资源的方式，而不必向其他集群公开Kubernetes控制平面，从而提高了安全性。它还保证了，潜在地，<strong class="js iu">每个网格可以由不同的独立管理员组管理</strong>。</p><p id="8191" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与潜在的不同管理员维护独立的控制平面也使您有机会维护不同的信任域，或者决定您想要共享哪些服务以及您想要从其他人那里将哪些服务导入到您的网格中。您可以<strong class="js iu">使用CRD <em class="ko"> ExportServiceSet </em> </strong>选择想要导出的服务，并使用<em class="ko"> ImportedServiceSet </em>选择要在您的集群中导入哪些服务，这些服务可以通过使用以这种方式形成的名称来访问:</p><pre class="kq kr ks kt gt or on os ot aw ou bi"><span id="82b5" class="nw lz it on b gy ov ow l ox oy">&lt;export-name&gt;.&lt;export-namespace&gt;.svc.&lt;ServiceMeshPeer.name&gt;-exports.local</span></pre><p id="215b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于可观察性，您得到的或多或少与本地服务网格服务相同。您甚至可以在您的Kiali仪表板中看到远程服务(已经在您的控制面板中导出和导入),以下是一个示例:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/c52294479cb12cbe7f11b8ff065f2ccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/0*D_DjTRmk_13KBBNV.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">图片来自<a class="ae lf" href="https://cloud.redhat.com/blog/introducing-openshift-service-mesh-2.1-federation-has-arrived" rel="noopener ugc nofollow" target="_blank">https://cloud . red hat . com/blog/introducing-open shift-service-mesh-2.1-Federation-has-arrival</a></figcaption></figure></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="6e3f" class="ly lz it bd ma mb np md me mf nq mh mi mj nr ml mm mn ns mp mq mr nt mt mu mv bi translated">摘要</h1><p id="e66b" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">我们已经看到了三种不同的选择，您可以采取这三种选择来创建在不同集群中运行的pod之间的东西向通信。虽然最终目标是相同的，但实现和方法是不同的，我们已经看到了一些差异，使每个选项都是独特的。在这最后一部分，我将尝试重述所有这些要点，并对我们所涉及的内容做一些总结。</p><p id="6759" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">集中式vs分布式</strong></p><p id="9fdb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们有三种选择，事实上有三种不同的模式。</p><p id="07d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先我们有<strong class="js iu">潜航员</strong>，它有一个完整的集中式模型。位于“中枢”集群中的潜艇代理将拥有网络的信息。我还提供了一个集中的管理点，集群管理员可以在这里控制如何使用和配置这些网络扩展。该模型与<em class="ko">高级集群管理器</em>解决方案所采用的方法非常匹配，这也是该产品支持该模型的原因。</p><p id="a3dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，我们有<strong class="js iu"> Skupper </strong>有相反的做法。一个完整的分布式体系结构，遵循与众所周知的路由协议相同的思想，其中网络信息在该网络中涉及的所有节点之间共享。在这种情况下，Skupper的设计使互连没有单一的集群管理级别的管理员，而是每个应用程序管理员成为其管理域的互连管理员，换句话说，应用程序管理员将负责他们自己的应用程序在集群之间的通信。</p><p id="3b32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们有<strong class="js iu">服务网状联盟</strong>，我认为它是集中式和分布式解决方案的混合体。它可以被视为集中式解决方案，因为我们有一个管理网络的集中式服务网格控制平面，但它也采用分布式方法，因为我们有多个控制平面参与交换有关其自己网络的信息的服务网格联盟。借助服务网格，我们可以为每个网格网络配备一名差异化的管理员，因此我们在这里采用了与Skupper相同的方法，管理应用程序的人员也将拥有网络管理，这样，如果您有一个应用程序(或一组应用程序)，管理员将能够完全控制其应用程序的所有方面，包括集群之间的互连，而无需依赖全局集群管理员。</p><p id="06dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">集群之间的连接</strong></p><p id="53a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们已经看到了这方面的一些差异。向使用非HTTP/S协议的解决方案(如Submariner或Service Mesh)授予集群之间所需的互连可能会稍微困难一些，因为您需要利用基础架构来提供连接和负载平衡方法，以便能够到达每个网络所需的入口点。如果我们在集群之间有NAT(尽管Submariner，因为它创建了一个IPsec隧道，所以利用NAT-T在连接中设置正确的IP ),或者如果您在集群中有重叠的网络(在OpenShift中Submariner还不支持，需要更多的测试),这可能会更加复杂。相比之下，在像Skupper这样的解决方案中，我们甚至可以使用Ingress/Route对象来发布网关，实现所需的互连变得容易得多。</p><p id="c130" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于每个解决方案所隐含的连接，还必须审查其他方面，以便了解该方法对于您的架构和应用程序是否有效，例如不同pod的负载平衡方式，或者互连解决方案可能影响的特定使用情形，例如，请记住应用程序协商端口不能与Skupper解决方案一起使用，或者在使用服务网状联盟时连接源的id在集群间连接中丢失。</p><p id="82a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">遗言</strong></p><p id="166f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">集中式解决方案在管理和可观察性方面有一些好处，因为您可以从一个点控制和检查网络。这里我们有Submariner，它允许与全局云管理器元素(<em class="ko">高级集群管理器</em>)轻松集成，但仍然需要利用集中化的优势稍微提高一点可观察性。</p><p id="2aa0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，Skupper具有良好的“每链路”可见性，但我们缺乏开箱即用的集中功能，无法让您全面了解您的网络中发生了什么，并选择哪些是共享的，哪些不是(一些其他产品正在向Skupper提供这一缺失的功能)。</p><p id="01c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">选择一个或另一个解决方案的关键点是，关于谁拥有互连的管理，你想要采取的方法。</strong>问题是谁在集群之间建立“桥梁”,在什么级别(集群全局或每个名称空间/应用程序),谁决定共享什么服务，谁维护连接，等等</p><p id="3956" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的模型中，集群管理员拥有一切(Submariner ),其余的人使用它，我们有一个不同的想法，终端用户拥有并创建这些连接(Skupper ),每个应用程序/命名空间一个(请记住，与Submariner创建的唯一隧道相比，要考虑更大的资源消耗),我们有服务网状联盟，您可以在其中基于位置和应用程序集创建管理区域。</p><p id="8dbe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，总而言之，如果您已经很好地定义了您的管理模型，您可能会马上找到正确的解决方案。如果您不在那个位置，我建议您考虑一下，不仅要管理集群内部连接，还要管理应用程序的任何其他OpenShift功能。</p><p id="932f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在一些组织中，让用户/开发人员对某些方面进行高度控制是不可取的，他们更喜欢将管理保持在一个更集中的点上(集群管理管理员)，但对于其他组织来说，如果您有一组管理应用程序的人员，那么允许该组也负责影响其应用程序的其他方面是有意义的，例如在这种情况下，集群之间的互连性…归根结底，我们不都主张遵循DevOps方法吗？</p></div></div>    
</body>
</html>