<html>
<head>
<title>Driving your testing efforts with code coverage tools</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用代码覆盖工具推动您的测试工作</h1>
<blockquote>原文：<a href="https://itnext.io/driving-your-testing-efforts-with-code-coverage-tools-616eadc7c2ca?source=collection_archive---------5-----------------------#2022-12-21">https://itnext.io/driving-your-testing-efforts-with-code-coverage-tools-616eadc7c2ca?source=collection_archive---------5-----------------------#2022-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="eee6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用TypeScript中的真实示例</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/1500c14dea2cd10e54547a14b8912e34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0ItY2_7IeUN1Z_E8"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">由<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae lb" href="https://unsplash.com/@numoonchld?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Raghavendra Saralaya </a>拍摄的照片</figcaption></figure><p id="8e29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，您将学习如何设置您的IDE来使用代码覆盖率来驱动您的测试工作。我们将在TypeScript中看到一个真实的例子。</p><blockquote class="lc ld le"><p id="7fab" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated"><em class="iq">你可以查看</em> <a class="ae lb" href="https://github.com/agualis/mock-extended-demo" rel="noopener ugc nofollow" target="_blank"> <em class="iq">这个回购</em> </a> <em class="iq">或者玩</em> <a class="ae lb" href="https://stackblitz.com/github/agualis/mock-extended-demo/tree/main?file=src%2FtimeMachineGPT.spec.ts" rel="noopener ugc nofollow" target="_blank"> <em class="iq">这个互动例子</em> </a> <em class="iq">来了解这个帖子的真实代码。</em></p></blockquote><h1 id="98e1" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">IDE中的覆盖率</h1><p id="3f13" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">代码覆盖工具非常流行。它们允许您在运行测试时创建一个覆盖率报告。大概是这样的:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mm"><img src="../Images/da9044ad2f1652f0aa8cc55930dd5089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*98HxPYSsTj02vAjnzT8peA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">典型覆盖率输出</figcaption></figure><p id="0efc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几乎每种语言都有自己的工具来生成不同格式的覆盖率报告:<em class="lf"> text，json，xml，html… </em>但是有一个特性我认为特别有趣:<strong class="jp ir">使用你的编辑器/IDE用覆盖率颜色高亮显示打开的文件的行(或者左边的空白)。</strong></p><p id="f5c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是<em class="lf"> vscode </em>中的一个例子:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mn"><img src="../Images/d04d808ca19df83d45ee0811853d157b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IvO9NKS0dLMfHqBf7INNEQ.png"/></div></div></figure><p id="bd44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每行上的典型颜色代码表示:</p><ul class=""><li id="c51a" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated"><strong class="jp ir"> <em class="lf">绿色(全覆盖)</em> </strong> <em class="lf"> : </em>该行被最后一个测试套件执行覆盖。</li><li id="1c91" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><strong class="jp ir"> <em class="lf">红色(无覆盖)</em> </strong>:该行未被最后一次测试套件执行覆盖。</li><li id="dfa7" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><strong class="jp ir"> <em class="lf">黄色(部分覆盖)</em> </strong>:该行被部分覆盖，表示该行没有覆盖所有可能的组合。例如，带有<em class="lf">布尔表达式</em>的行必须用<em class="lf">真值</em>和<em class="lf">假值</em>运行，以完全覆盖(<em class="lf">绿色</em>)。</li></ul><p id="0901" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我发现这个工具在有许多未测试行的遗留环境中，或者当你不熟悉被测代码时特别有用。</p><p id="9ca7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，如果您首先编写您的测试(遵循TDD或不遵循TDD ),它也是有用的，因为它帮助您确认您是在正确的道路上。</p><h1 id="3e81" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">为TypeScript设置代码覆盖率</h1><p id="a3c2" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">你可以在大多数语言和测试框架中找到这个工具，但是我们将把它与<em class="lf"> Typescript </em>和<em class="lf"> jest/vitest </em>一起使用。</p><p id="6ba1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数流行的ide都能打开覆盖率报告，但我更熟悉<a class="ae lb" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> vscode </a>和<a class="ae lb" href="https://www.jetbrains.com/es-es/webstorm/" rel="noopener ugc nofollow" target="_blank"> webstorm </a>。两者都支持<a class="ae lb" href="https://wiki.documentfoundation.org/Development/Lcov" rel="noopener ugc nofollow" target="_blank"> lcov </a>格式，所以<strong class="jp ir">确保您设置了您的测试运行程序，以便用<em class="lf"> lcov生成覆盖报告。</em>T9】</strong></p><h2 id="f7ba" class="nc lk iq bd ll nd ne dn lp nf ng dp lt jy nh ni lx kc nj nk mb kg nl nm mf nn bi translated"><strong class="ak">笑话</strong></h2><p id="babc" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">它有一个默认的保险设置。</p><p id="9b99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Jest默认包含<em class="lf"> lcov </em> reporter。</p><h2 id="c041" class="nc lk iq bd ll nd ne dn lp nf ng dp lt jy nh ni lx kc nj nk mb kg nl nm mf nn bi translated"><strong class="ak"> Vitest </strong></h2><p id="8f95" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">这是我测试Typescript的首选框架。</p><p id="5acd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Vitest默认使用<a class="ae lb" href="https://github.com/bcoe/c8" rel="noopener ugc nofollow" target="_blank"> c8 </a>(节点本机代码覆盖率)。但是您需要安装它:</p><pre class="km kn ko kp gt no np nq bn nr ns bi"><span id="8e71" class="nt lk iq np b be nu nv l nw nx">npm i -D c8</span></pre><p id="9407" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir"> vitest </strong>中你需要在<a class="ae lb" href="https://vitest.dev/guide/coverage.html" rel="noopener ugc nofollow" target="_blank">中明确指定记者<em class="lf">记者</em> </a> <em class="lf"> </em>选项。示例:</p><pre class="km kn ko kp gt no np nq bn nr ns bi"><span id="bc74" class="nt lk iq np b be nu nv l nw nx">import { defineConfig } from 'vitest/config'<br/>export default defineConfig({<br/>    test: {<br/>      globals: true,<br/>      environment: 'node',<br/>      coverage: { reporter: ['text', 'lcov'] }, // lcov reporter is used by IDE coverage extensions<br/>      include: [<br/>        'src/**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}',<br/>      ],<br/>    },<br/>});</span></pre><h2 id="e4b7" class="nc lk iq bd ll nd ne dn lp nf ng dp lt jy nh ni lx kc nj nk mb kg nl nm mf nn bi translated">覆盖率脚本</h2><p id="aa83" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">在<em class="lf"> jest </em>和<em class="lf"> vitest </em>中，你只需要在<strong class="jp ir"> package.json: </strong>中添加一个新的脚本</p><pre class="km kn ko kp gt no np nq bn nr ns bi"><span id="41a9" class="nt lk iq np b be nu nv l nw nx">//package.json<br/>...<br/>"scripts": {<br/>...<br/> "test:coverage": "jest --coverage",<br/>...<br/>}<br/>...</span></pre><p id="77c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后用覆盖率运行您的测试:</p><pre class="km kn ko kp gt no np nq bn nr ns bi"><span id="1880" class="nt lk iq np b be nu nv l nw nx">npm run test:coverage</span></pre><p id="beab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将在<em class="lf">中生成带有默认记者的报道输出。/coverage ( </em>别忘了<em class="lf">。gitignore </em>那个文件夹)。</p><blockquote class="lc ld le"><p id="5bb0" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">检查<a class="ae lb" href="https://github.com/agualis/jest-coverage-demo" rel="noopener ugc nofollow" target="_blank">这个回购</a>看它与<strong class="jp ir"> jest的作用。</strong></p><p id="43b7" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">使用<strong class="jp ir">测试</strong>检查<a class="ae lb" href="https://github.com/agualis/mock-extended-demo" rel="noopener ugc nofollow" target="_blank">这个回购</a>以查看它的运行情况</p></blockquote><h2 id="8dbd" class="nc lk iq bd ll nd ne dn lp nf ng dp lt jy nh ni lx kc nj nk mb kg nl nm mf nn bi translated">设置您的IDE</h2><p id="b0e2" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">一旦您为lcov覆盖率设置了测试运行程序，您就可以:</p><p id="d3a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">✅用覆盖率来运行你的测试</p><p id="0b3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">👀用你最喜欢的IDE打开测试文件，检查被覆盖的行</p><p id="d051" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" href="https://www.jetbrains.com/help/webstorm/code-coverage.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> Webstorm </strong>默认支持的是</a>。</p><p id="cbf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于<strong class="jp ir"> vscode </strong>，需要安装扩展。我最喜欢的是<a class="ae lb" href="https://marketplace.visualstudio.com/items?itemName=ryanluker.vscode-coverage-gutters" rel="noopener ugc nofollow" target="_blank">覆盖水槽</a>。</p><h1 id="caf4" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">真实的例子</h1><p id="6d12" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">在<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/mocking-typescript-objects-in-legacy-projects-773b38b9b4f7">之前关于<em class="lf">嘲讽对象的</em></a>帖子中，我们看到了一个虚构的项目，其中有复杂的未经测试的逻辑。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ny"><img src="../Images/0b6d8af95c7ec7407aa57ad5a2c760f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2sxUsBOMOCI7FHLn"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://unsplash.com/@mohamedosama?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">穆罕默德·乌萨马</a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="d010" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🤖我用<a class="ae lb" href="https://openai.com/blog/chatgpt/" rel="noopener ugc nofollow" target="_blank">聊天GPT </a>在打字稿中生成一个时间旅行机器，这是我得到的:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nz"><img src="../Images/be1c5b148e19823ccac9e986b9bfeafe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vH1m0F2rxkLOQZN-eGDk2w.png"/></div></div></figure><p id="f959" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有趣的🤔但是我们想在用真人做实验之前加入自动化测试。让我们试着用我们的覆盖工具的视觉确认一步一步地覆盖它。</p><h2 id="72e4" class="nc lk iq bd ll nd ne dn lp nf ng dp lt jy nh ni lx kc nj nk mb kg nl nm mf nn bi translated">时间旅行功能</h2><pre class="km kn ko kp gt no np nq bn nr ns bi"><span id="e8ed" class="nt lk iq np b be nu nv l nw nx">import {<br/>  TimeMachine,<br/>  TimeMachineDestination,<br/>  OnchainDestinationData,<br/>} from './types';<br/><br/>/**<br/> * ⚠️ This function was created by GPT chat. Please use it at your own risk.<br/> */<br/>export function timeTravel(<br/>  timeMachine: TimeMachine,<br/>  destination: TimeMachineDestination<br/>): void {<br/>  if (!timeMachine.timeTravelEnabled) {<br/>    throw new Error(<br/>      `Time travel is not enabled for time machine "${timeMachine.id}".`<br/>    );<br/>  }<br/><br/>  if (!timeMachine.destinations.includes(destination)) {<br/>    throw new Error(<br/>      `Invalid destination "${destination}" for time machine "${timeMachine.id}".`<br/>    );<br/>  }<br/><br/>  const destinationData = getDestinationData(timeMachine, destination);<br/>  if (!destinationData) {<br/>    throw new Error(<br/>      `Destination data not found for destination "${destination}" of time machine "${timeMachine.id}".`<br/>    );<br/>  }<br/><br/>  console.log(<br/>    `Time traveling to ${destinationData.name} (${destinationData.symbol}) at speed ${destinationData.speed}...`<br/>  );<br/>}<br/><br/>function getDestinationData(<br/>  timeMachine: TimeMachine,<br/>  destination: TimeMachineDestination<br/>): OnchainDestinationData | undefined {<br/>  return timeMachine.onchain?.destinations[destination];<br/>}</span></pre><p id="5a3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们开始测试快乐之路。如果我们使用有效的参数运行<em class="lf"> timeTravel </em>函数<em class="lf"> </em>，我们应该会看到一个<em class="lf"> console.log </em>来确认时间旅行。我们将使用<em class="lf">构建器函数+模拟扩展的</em>(正如我们在<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/mocking-typescript-objects-in-legacy-projects-773b38b9b4f7">上一篇文章</a>中看到的)来使测试更加清晰:</p><pre class="km kn ko kp gt no np nq bn nr ns bi"><span id="62f9" class="nt lk iq np b be nu nv l nw nx">import { aDestination, aTimeMachine } from './builders';<br/>import { timeTravel } from './timeMachineGPT';<br/><br/>it('travels in time 🚀', () =&gt; {<br/>  const machineMock = aTimeMachine();<br/><br/>  const logSpy = vi.spyOn(console, 'log').mockImplementationOnce(()=&gt; {});<br/><br/>  timeTravel(machineMock, aDestination('Woodstock, 1969'));<br/><br/>  expect(logSpy).toHaveBeenCalledWith(<br/>    "Time traveling to Woodstock, 1969 (☮️) at speed 600000..."<br/>  )}<br/>);</span></pre><p id="c768" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有测试绿色🎉</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oa"><img src="../Images/d3772141947616158e93aa0a8f79598f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DndP1NCXdmCDEiGVNjDL6g.png"/></div></div></figure><p id="9bfb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是让我们用我们的<a class="ae lb" href="https://marketplace.visualstudio.com/items?itemName=ryanluker.vscode-coverage-gutters" rel="noopener ugc nofollow" target="_blank"> <em class="lf"> vscode </em> <em class="lf">扩展</em> </a>来确认一下:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ob"><img src="../Images/939f85521dc5de535ef359cf5c490428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tN1jSJUUlETReZ1hySXG0A.png"/></div></div></figure><p id="fb9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的第一个快乐路径测试覆盖了72%的文件。还不错。但是<strong class="jp ir">覆盖工具为我们指出了一些未覆盖的边缘案例，这样我们就可以决定接下来测试什么。</strong></p><p id="2f7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看第一个<em class="lf">如果</em>在时间机器被禁用时抛出错误<em class="lf"> (timeTravelEnabled为假):</em></p><pre class="km kn ko kp gt no np nq bn nr ns bi"><span id="95ad" class="nt lk iq np b be nu nv l nw nx">if (!timeMachine.timeTravelEnabled) {<br/>    throw new Error(<br/>      `Time travel is not enabled for time machine "${timeMachine.id}".`<br/>    );<br/>  }</span></pre><p id="e569" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">新测试:</p><pre class="km kn ko kp gt no np nq bn nr ns bi"><span id="ab15" class="nt lk iq np b be nu nv l nw nx">it('Throws error when machine is disabled', () =&gt; {<br/>  const machineMock = aTimeMachine({timeTravelEnabled: false, id: 'delorean'});<br/><br/>  expect(() =&gt; timeTravel(machineMock, aDestination())).toThrowError(<br/>    'Time travel is not enabled for time machine "delorean".'<br/>  );<br/>});</span></pre><p id="9168" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们再次检查覆盖率(如果您在观察模式下运行测试，它将会自动刷新):</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/8ba50a87077b2c23501cde5cb42a569d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8pUBnSaW2hqORzxqiM5G4g.png"/></div></div></figure><p id="ab88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很好，我们将覆盖率从72%提高到了81%。但是，最重要的是，我们涵盖了一个对我们很重要的边缘案例特性。我们可以重复这个过程，直到我们覆盖了最重要的路径，从而足够自信💪。</p><h1 id="1f9c" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">我如何开始测试一个遗留项目？</h1><p id="dc57" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">假设您有一个低覆盖率的遗留项目。您决定扭转局面，开始添加有价值的测试。</p><p id="3bd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">团队是一致的，有动力的，你将开始增加你的项目的覆盖面。从哪里开始？</p><p id="dd46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">一些想法</strong></p><ul class=""><li id="c81c" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">在修复bug之前，一定要写一个测试。</li><li id="3fb2" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">向所有新特性添加测试(以及向受它们影响的旧代码添加测试)。</li><li id="1e2e" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">创建包含最关键路径的列表。万一它们停止工作，会对你的公司产生影响(金钱、声誉或其他关键指标)。对它们进行优先排序和测试。小步前进总是更好，因为花费整个迭代/冲刺/周期而没有交付价值可能不是一个好主意，因为你只是增加了测试。</li><li id="f738" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">回顾上一点。三思而后行。这个关键但遗留的特性会受到当前代码变更的影响吗？我可以用一个简单的(虽然很慢)e2e/集成测试来测试这条完整的路径吗？</li></ul><p id="1e7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每一个环境都是不同的，所以你总是要通过投资回报率来驱动你的努力。我希望这个工具可以帮助你推动你的决定。</p><p id="72fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快乐测试✌️</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="157b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">记住你在<a class="ae lb" href="https://github.com/agualis/mock-extended-demo" rel="noopener ugc nofollow" target="_blank">这个回购</a>里有下面的例子，你也可以和<a class="ae lb" href="https://stackblitz.com/github/agualis/mock-extended-demo/tree/main?file=src%2FtimeMachineGPT.spec.ts" rel="noopener ugc nofollow" target="_blank">这个互动例子</a>一起玩。</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="16cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">出于好奇，我让聊天GPT在完成这篇文章后测试同样的<em class="lf"> timeTravel </em>功能，它的回答是有效的100%覆盖套件🤯测试不是很干净(不安全，因为我没有提供类型),但它仍然令人惊讶😬欢迎艾🤖</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ok"><img src="../Images/e95a69fdd7d383ed85220581cd97e6de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FN5Gj9dTgoAp3tkefJrurw.png"/></div></div></figure></div></div>    
</body>
</html>