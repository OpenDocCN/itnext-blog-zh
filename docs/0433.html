<html>
<head>
<title>Make a simple custom EventEmitter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">制作一个简单的自定义事件发射器</h1>
<blockquote>原文：<a href="https://itnext.io/make-an-simple-custom-eventemitter-aa4ad2915334?source=collection_archive---------6-----------------------#2018-03-09">https://itnext.io/make-an-simple-custom-eventemitter-aa4ad2915334?source=collection_archive---------6-----------------------#2018-03-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3058740061a2d6b5576e49a1998aa761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q7nb-owwLC4MMYZTlyFZ7w.png"/></div></div></figure><h1 id="890e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">思想</h1><p id="4aef" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">最近我一直在读一本关于JS异步的书<a class="ae lu" href="https://www.amazon.com/Async-JavaScript-Responsive-Pragmatic-Express-ebook/dp/B00AKM4RVG" rel="noopener ugc nofollow" target="_blank"> Async JavaScript </a>，JS event是这个问题的一个有用的解决方案。为了更深入地理解事件是如何工作的，我创建了一个定制的EventEmitter，它包含了<a class="ae lu" href="https://nodejs.org/api/events.html" rel="noopener ugc nofollow" target="_blank">节点EventEmitter </a>的大部分工作功能。<a class="ae lu" href="https://github.com/n0ruSh/the-art-of-reading/blob/master/javascript/Async%20Javascript/event.js" rel="noopener ugc nofollow" target="_blank">源代码</a>不超过60行。</p><h1 id="e12f" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">一般想法</h1><p id="70f6" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">总的想法是用一个对象(<em class="lv"> this.handlers </em>)来保存从事件名称(类型:字符串)到其相关侦听器/处理程序(类型:数组&lt;函数&gt;)的映射。当每个事件被触发时，遍历相关的侦听器/处理程序并执行它们。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="b823" class="mf jz iq mb b gy mg mh l mi mj">class Emitter {<br/>    constructor(){<br/>        /**<br/>         * keep mapping information。<br/>         * e.g. <br/>         *   {<br/>         *      'event1': [fn1, fn2],<br/>         *      'event2': [fn3, fn4, fn5]<br/>         *   }<br/>         */<br/>        this.handlers = {};<br/>    }<br/>}</span></pre><h1 id="0466" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">关于这些方法的一些细节</h1><h1 id="a968" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">on —事件绑定</h1><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="6219" class="mf jz iq mb b gy mg mh l mi mj">on(evt, handler) {<br/>    this.handlers[evt] = this.handlers[evt] || [];<br/>    let hdl = this.handlers[evt];<br/>    hdl.push(handler);<br/>    return this;<br/>}</span></pre><p id="ed0b" class="pw-post-body-paragraph kw kx iq ky b kz mk lb lc ld ml lf lg lh mm lj lk ll mn ln lo lp mo lr ls lt ij bi translated">为了简单起见，我们在绑定处理程序时不检查重复项。也就是说，如果你对同一个函数调用上的<em class="lv">两次，那么当事件被触发时，它就会被调用两次。该方法返回<em class="lv"> this </em>以允许方法链接.</em></p><h1 id="ea94" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">关-取消事件绑定</h1><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="99ed" class="mf jz iq mb b gy mg mh l mi mj">removeListener(evt, handler) {<br/>    this.handlers[evt] = this.handlers[evt] || [];<br/>    let hdl = this.handlers[evt];<br/>    let index = hdl.indexOf(handler);<br/>    if(index &gt;= 0) {<br/>        hdl.splice(index, 1);<br/>    }<br/>    return this;<br/>}</span></pre><p id="dc73" class="pw-post-body-paragraph kw kx iq ky b kz mk lb lc ld ml lf lg lh mm lj lk ll mn ln lo lp mo lr ls lt ij bi translated">请注意，这里我们在解除函数绑定时将函数引用与严格比较进行了比较。JavaScript中的函数通过它们的引用进行比较，就像对象比较的工作方式一样。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="40d4" class="mf jz iq mb b gy mg mh l mi mj">function f1() {<br/>    console.log('hi');<br/>}</span><span id="8f0c" class="mf jz iq mb b gy mp mh l mi mj">function f2() {<br/>    console.log('hi');<br/>}</span><span id="bbe6" class="mf jz iq mb b gy mp mh l mi mj">let f3 = f1;<br/>console.log(f1 === f2); //false<br/>console.log(f1 === f3); //true</span></pre><h1 id="c170" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">一次-绑定，但只能触发一次</h1><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="90c1" class="mf jz iq mb b gy mg mh l mi mj">once(evt, handler) {<br/>    this.handlers[evt] = this.handlers[evt] || [];<br/>    let hdl = this.handlers[evt];<br/>    hdl.push(function f(...args){<br/>        handler.apply(this, args);<br/>        this.removeListener(evt, f);<br/>    });<br/>    return this;<br/>}</span></pre><p id="4952" class="pw-post-body-paragraph kw kx iq ky b kz mk lb lc ld ml lf lg lh mm lj lk ll mn ln lo lp mo lr ls lt ij bi translated">它与方法上的<em class="lv">类似。但是我们需要用另一个函数包装处理程序，这样一旦处理程序被执行，我们就可以移除绑定，以实现<strong class="ky ir">只被触发一次</strong>。</em></p><h1 id="30cb" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">发出—触发事件</h1><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="369e" class="mf jz iq mb b gy mg mh l mi mj">emit(evt, ...args) {<br/>    this.handlers[evt] = this.handlers[evt] || [];<br/>    let hdl = this.handlers[evt];<br/>    hdl.forEach((it) =&gt; {<br/>        it.apply(this, args);<br/>    });<br/>    return this;<br/>}</span></pre><p id="f54f" class="pw-post-body-paragraph kw kx iq ky b kz mk lb lc ld ml lf lg lh mm lj lk ll mn ln lo lp mo lr ls lt ij bi translated">当一个事件被触发时，找到所有相关的处理程序(即this.handlers[evt])并执行它们。</p><h1 id="55f5" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">eventNames —获取具有活动(即非空)处理程序的已注册事件的列表</h1><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="c169" class="mf jz iq mb b gy mg mh l mi mj">eventNames() {<br/>    return Object.keys(this.handlers).reduce((arr, evt) =&gt; {<br/>        if(this.listenerCount(evt)) {<br/>            arr.push(evt);<br/>        }<br/>        return arr;<br/>    }, []);<br/>}</span></pre><p id="1812" class="pw-post-body-paragraph kw kx iq ky b kz mk lb lc ld ml lf lg lh mm lj lk ll mn ln lo lp mo lr ls lt ij bi translated">这里我们不简单地返回所有<em class="lv"> this.handlers </em>的键，因为一些事件可以与一些处理程序绑定，然后再移除它们。在这种情况下，事件名称作为有效键存在于<em class="lv"> this.handlers </em>中，但没有活动的处理程序。例如</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="0d52" class="mf jz iq mb b gy mg mh l mi mj">let server = new Emitter();<br/>let fn = function(){};<br/>server.on('connection', fn);<br/>server.removeListener('connection', fn);<br/>server.handlers.connection; //[]</span></pre><p id="e19c" class="pw-post-body-paragraph kw kx iq ky b kz mk lb lc ld ml lf lg lh mm lj lk ll mn ln lo lp mo lr ls lt ij bi translated">因此，我们需要过滤掉句柄为空的事件。这里我们使用了<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce?v=example" rel="noopener ugc nofollow" target="_blank"> Array.prototype.reduce </a>来使代码更简洁。在很多情况下，<em class="lv"> reduce </em>都是有用的，比如计算一个数组的和:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="8a80" class="mf jz iq mb b gy mg mh l mi mj">function sumWithForEach(arr) { // with forEach<br/>    let sum = 0;<br/>    arr.forEach(it =&gt; {<br/>        sum += it;<br/>    })<br/>    return sum;<br/>}</span><span id="7801" class="mf jz iq mb b gy mp mh l mi mj">function sumWithReduce(arr) { // with reduce<br/>    return arr.reduce((sum, current) =&gt; {<br/>        return sum + current;<br/>    })<br/>}</span></pre><h1 id="7cc7" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">参考</h1><ul class=""><li id="1564" class="mq mr iq ky b kz la ld le lh ms ll mt lp mu lt mv mw mx my bi translated"><a class="ae lu" href="https://www.amazon.com/Async-JavaScript-Responsive-Pragmatic-Express-ebook/dp/B00AKM4RVG" rel="noopener ugc nofollow" target="_blank">异步JavaScript </a></li></ul><h1 id="9f5c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">通知；注意</h1><ul class=""><li id="42f4" class="mq mr iq ky b kz la ld le lh ms ll mt lp mu lt mv mw mx my bi translated">如果您想了解最新的新闻/文章，请点击<a class="ae lu" href="https://github.com/n0ruSh/the-art-of-reading" rel="noopener ugc nofollow" target="_blank">【观看】</a>订阅。</li></ul></div></div>    
</body>
</html>