<html>
<head>
<title>How React’s useEffect Hook Works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React的useEffect钩子如何工作</h1>
<blockquote>原文：<a href="https://itnext.io/the-useeffect-hook-makes-sense-if-you-think-differently-333c2d775400?source=collection_archive---------2-----------------------#2019-11-05">https://itnext.io/the-useeffect-hook-makes-sense-if-you-think-differently-333c2d775400?source=collection_archive---------2-----------------------#2019-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7a3f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不一样，但是更好</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/11ff4acd0af6f4c9498e58f05b757817.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDJa89eWA-NRI-G8JQgzlA.png"/></div></div></figure><p id="3c40" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于那些通过有状态组件学习React的人来说，<code class="fe lq lr ls lt b">useEffect</code>可能是最难学的一个钩子。对我来说当然是。今天的框架正在简化它们的API，这就是<code class="fe lq lr ls lt b">useEffect</code>正在尝试做的事情。它确实简化了事情，但也改变了很多。</p><h1 id="5eaf" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">停止思考生命周期</h1><p id="cce7" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">当我第一次学习反应时，我记住了这些循环。<a class="ae ms" href="https://miro.medium.com/max/4516/1*552z6hbX_b648DjpTLHZNg.png" rel="noopener">这个组件生命周期图</a>是一个常用的方法。这似乎使跟踪我的组件的渲染变得简单明了，但这有点多，不是吗？与其跟踪生命周期方法来确保组件的行为，不如我们只关心呈现状态，而生命周期并不重要？</p><h1 id="5fd1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">专注于渲染</h1><p id="fe5d" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">这就是范式的转变:我们现在真的只关心<strong class="kw iu">渲染</strong>。组件挂载后有原始的渲染，以及所有额外的重新渲染。我们只是希望这些与我们的状态同步，就是这样。<code class="fe lq lr ls lt b">useEffect</code>这样做只有两个参数:副作用回调和一组要观察的状态:</p><pre class="kj kk kl km gt mt lt mu mv aw mw bi"><span id="30ae" class="mx lw it lt b gy my mz l na nb"><strong class="lt iu">useEffect</strong>(<strong class="lt iu">sideEffectFunction</strong>, [<strong class="lt iu">stateToTrack</strong>]);</span></pre><blockquote class="nc nd ne"><p id="fcb5" class="ku kv lu kw b kx ky ju kz la lb jx lc nf le lf lg ng li lj lk nh lm ln lo lp im bi translated">(还有卸载的细节，不过这个不太常见的最后阶段我们就不多说了。C <a class="ae ms" href="https://reactjs.org/docs/hooks-effect.html#effects-with-cleanup" rel="noopener ugc nofollow" target="_blank">查看文档了解更多关于清理的信息</a></p></blockquote><h2 id="ad6b" class="mx lw it bd lx ni nj dn mb nk nl dp mf ld nm nn mh lh no np mj ll nq nr ml ns bi translated">副作用回调函数</h2><p id="3062" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">这就是<code class="fe lq lr ls lt b">useEffect</code>得名的原因；它负责管理状态变化产生的副作用。当它跟踪的状态改变时，它调用副作用函数。这就是它的全部功能。回调不应该返回任何东西，<a class="ae ms" href="https://reactjs.org/docs/hooks-effect.html#effects-with-cleanup" rel="noopener ugc nofollow" target="_blank">除非你正在卸载</a>。</p><h2 id="abc9" class="mx lw it bd lx ni nj dn mb nk nl dp mf ld nm nn mh lh no np mj ll nq nr ml ns bi translated">跟踪状态</h2><p id="adce" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">该阵列有3条主要途径:</p><ol class=""><li id="feb1" class="nt nu it kw b kx ky la lb ld nv lh nw ll nx lp ny nz oa ob bi translated"><strong class="kw iu">省去</strong>:每次组件重新渲染时效果都会运行。我一般不推荐这个选项。</li><li id="265f" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated"><strong class="kw iu">包含一个空数组</strong>:这告诉React没有要跟踪的状态，所以它会在第一次渲染后运行一次回调函数<strong class="kw iu">，这就是<em class="lu">它</em>。</strong></li><li id="da84" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">使用填充数组:你可以传递一个或多个状态给<code class="fe lq lr ls lt b">useEffect</code>来跟踪。这样，就不会在每次渲染后都运行回调，它只会在那些特定的状态改变后运行。</li></ol><blockquote class="oh"><p id="88b1" class="oi oj it bd ok ol om on oo op oq lp dk translated">useEffect真正做的只是在某些渲染之后调用副作用函数。</p></blockquote><p id="523c" class="pw-post-body-paragraph ku kv it kw b kx or ju kz la os jx lc ld ot lf lg lh ou lj lk ll ov ln lo lp im bi translated">这是最基本的，现在让我们编码一些东西，好吗？首先，让我们用它来完成两个非常常见的任务:初始数据抓取和记录状态变化。先说数据部分。</p><h1 id="e0ea" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">新的组件安装模式</h1><p id="4dfc" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">在下面的代码中，我们从<a class="ae ms" href="https://jsonplaceholder.typicode.com/guide.html" rel="noopener ugc nofollow" target="_blank"> JSON占位符</a>中获取一个用户。我们没有设置默认状态，因为我喜欢在渲染任何东西之前等待真实数据的模式。我们还使用了<code class="fe lq lr ls lt b">useState</code>钩子，所以如果你还不熟悉的话，可以查看一下<a class="ae ms" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank">教程。下面是完整的组件和适配器:</a></p><pre class="kj kk kl km gt mt lt mu mv aw mw bi"><span id="b6cb" class="mx lw it lt b gy my mz l na nb">import <strong class="lt iu">React</strong>, {<br/>  <strong class="lt iu">useEffect</strong>,<br/>  <strong class="lt iu">useState</strong>,<br/>} from '<em class="lu">react</em>';</span><span id="3867" class="mx lw it lt b gy ow mz l na nb">const <strong class="lt iu">UserAdapter</strong> = {<br/>  get: (<strong class="lt iu">id</strong>) =&gt; {<br/>    const <strong class="lt iu">url</strong> = '<em class="lu">https://jsonplaceholder.typicode.com/users</em>';<br/>    return <strong class="lt iu">fetch</strong>(`<em class="lu">${</em><strong class="lt iu"><em class="lu">url</em></strong><em class="lu">}/${</em><strong class="lt iu"><em class="lu">id</em></strong><em class="lu">}</em>`)<br/>      .then(<strong class="lt iu">res</strong> =&gt; <strong class="lt iu">res</strong>.json());<br/>  },<br/>};</span><span id="60ce" class="mx lw it lt b gy ow mz l na nb">const <strong class="lt iu">App</strong> = () =&gt; {<br/>  const [<br/>    <strong class="lt iu">user</strong>, <br/>    <strong class="lt iu">setUser</strong>,<br/>  ] = useState(<strong class="lt iu">null</strong>);</span><span id="db7b" class="mx lw it lt b gy ow mz l na nb">  <strong class="lt iu">useEffect</strong>(() =&gt; {<br/>    <strong class="lt iu">UserAdapter</strong><br/>      .get(1)<br/>      .then((<strong class="lt iu">dbUser</strong>) =&gt; {<br/>        <strong class="lt iu">setUser</strong>(<strong class="lt iu">dbUser</strong>);<br/>      });<br/>  }, []);<br/>  <br/>  <strong class="lt iu"><em class="lu">return</em></strong> (<br/>    &lt;<em class="lu">div</em>&gt; <br/>    {<br/>      <strong class="lt iu">user</strong><br/>        ? &lt;<em class="lu">h1</em>&gt;<br/>            {<strong class="lt iu">user</strong>.name}<br/>        &lt;/<em class="lu">h1</em>&gt;<br/>        : &lt;<em class="lu">p</em>&gt;<br/>            loading...<br/>        &lt;/<em class="lu">p</em>&gt;<br/>    }<br/>    &lt;/<em class="lu">div</em>&gt;<br/>  );<br/>};</span><span id="eef0" class="mx lw it lt b gy ow mz l na nb">export default <strong class="lt iu">App</strong>;</span></pre><p id="c8c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里是<code class="fe lq lr ls lt b">useEffect</code>部分，特写:</p><pre class="kj kk kl km gt mt lt mu mv aw mw bi"><span id="f55d" class="mx lw it lt b gy my mz l na nb"><strong class="lt iu">useEffect</strong>(() =&gt; {<br/>  <strong class="lt iu">UserAdapter</strong><br/>    .get(1)<br/>    .then((<strong class="lt iu">dbUser</strong>) =&gt; {<br/>      <strong class="lt iu">setUser</strong>(<strong class="lt iu">dbUser</strong>);<br/>    });<br/>}, []); </span></pre><p id="8da1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们包含了空数组，以确保我们的副作用只在第一次渲染后运行一次。在这种情况下，效果函数只是将我们的第一个用户加载到状态中。在现实世界中，您可能会从您的url参数中提取ID，但现在这样做是可行的。</p><p id="2db2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好了，这和<code class="fe lq lr ls lt b">componentDidMount</code>基本一样，没什么可怕的。</p><h1 id="bddb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">检查更新</h1><p id="980b" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">只需在你的组件中加入另一个<code class="fe lq lr ls lt b">useEffect</code>，不需要<code class="fe lq lr ls lt b">componentDidUpdate</code>。让我们将相关的状态放入数组，以便养成这样做的习惯:</p><pre class="kj kk kl km gt mt lt mu mv aw mw bi"><span id="dcba" class="mx lw it lt b gy my mz l na nb"><strong class="lt iu">useEffect</strong>(() =&gt; {<br/>  <strong class="lt iu">console</strong>.log(<strong class="lt iu">user</strong>);<br/>}, [<strong class="lt iu">user</strong>]);</span></pre><p id="9340" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要查看实际情况，让我们添加一个按钮来进行另一个db查询:</p><pre class="kj kk kl km gt mt lt mu mv aw mw bi"><span id="ed31" class="mx lw it lt b gy my mz l na nb"><em class="lu">// initial code ...</em><br/><strong class="lt iu">useEffect</strong>(() =&gt; {<br/>  <strong class="lt iu">console</strong>.log(<strong class="lt iu">user</strong>);<br/>}, [<strong class="lt iu">user</strong>]);</span><span id="f49f" class="mx lw it lt b gy ow mz l na nb">const <strong class="lt iu">handleClick</strong> = () =&gt; {<br/>  <strong class="lt iu">UserAdapter</strong><br/>    .getOne(<strong class="lt iu">user</strong>.id + 1)<br/>    .then(<strong class="lt iu">dbUser </strong>=&gt; {<br/>      <strong class="lt iu">setUser</strong>(<strong class="lt iu">dbUser</strong>);<br/>    });<br/>};</span><span id="f1ba" class="mx lw it lt b gy ow mz l na nb"><strong class="lt iu"><em class="lu">return</em></strong> (<br/>  &lt;div&gt;<br/>    { user stuff }<br/>    &lt;<em class="lu">button</em><br/>      onClick={<strong class="lt iu">handleClick</strong>}<br/>    &gt;<br/>      Get New User<br/>    &lt;/<em class="lu">button</em>&gt;<br/><em class="lu">// rest of code ...</em></span></pre><p id="1a7c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每次你点击按钮，我们的第二个<code class="fe lq lr ls lt b">useEffect</code>注销当前用户的状态。顺便说一下，这是记录状态变化的方法(<code class="fe lq lr ls lt b"><a class="ae ms" href="https://stackoverflow.com/questions/56247433/how-to-use-setstate-callback-on-react-hooks" rel="noopener ugc nofollow" target="_blank">useState</a></code> <a class="ae ms" href="https://stackoverflow.com/questions/56247433/how-to-use-setstate-callback-on-react-hooks" rel="noopener ugc nofollow" target="_blank">没有像</a> <code class="fe lq lr ls lt b"><a class="ae ms" href="https://stackoverflow.com/questions/56247433/how-to-use-setstate-callback-on-react-hooks" rel="noopener ugc nofollow" target="_blank">setState</a></code>那样的回调)，所以在开发过程中您会经常使用这种模式。相信我。</p><h1 id="f44b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">更小的函数===更干净的代码</h1><p id="8761" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">通过选择专注于渲染，而不是将我们所有的工作锁定在生命周期中，<code class="fe lq lr ls lt b">useEffect</code>允许我们将逻辑分解成更小的功能。你有4件不相关的事情要检查更新吗？现在，您可以将它们分解成各自独立的功能。不可否认<code class="fe lq lr ls lt b">useEffect</code>是一种新的思维方式；但是一旦你习惯了，我希望你会同意这是一种进步。</p><p id="0959" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大家编码快乐，</p><p id="adb5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">麦克风</p></div></div>    
</body>
</html>