<html>
<head>
<title>Reducing bandwidth and number of requests on REST APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">减少REST APIs上的带宽和请求数量</h1>
<blockquote>原文：<a href="https://itnext.io/reducing-bandwidth-and-number-of-requests-on-rest-apis-ec418b5fd82a?source=collection_archive---------0-----------------------#2021-07-16">https://itnext.io/reducing-bandwidth-and-number-of-requests-on-rest-apis-ec418b5fd82a?source=collection_archive---------0-----------------------#2021-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a2e0e54c7c11ca44f8a5f927e8906b58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*67jyRgRTUeblpW-2t6T5Iw.png"/></div></div></figure><p id="86e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">REST APIs已经成为软件行业的标准，任何参与其中的人都为之开发或与之交互。虽然出现了其他选项，如GraphQL，但它们通常更复杂，需要不同的工具和不同的方法，不适合许多用例。因此，REST是事实上的标准。</p><p id="946d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管如此，REST APIs也有缺点。当我们请求一个特定的资源时，我们通常不能选择我们想要检索的字段，相反，我们得到所有可用的字段，尽管我们只需要几个。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="08a0" class="lg lh iq lc b gy li lj l lk ll">GET /users/10<br/>---<br/>{<br/>    "id": 10,<br/>    "name": "John Doe",<br/>    "dob": "1990-01-23",<br/>    "phoneNumber": "55000000000",<br/>    "email": "<a class="ae lm" href="mailto:johndoe@email.com" rel="noopener ugc nofollow" target="_blank">johndoe@email.com</a>",<br/>    "address": {<br/>        "street": "fake road 121",<br/>        "city": "London",<br/>        "country": "United Kingdom"<br/>    },<br/>    "preferences": {<br/>        ...<br/>    }<br/>}</span></pre><p id="5ac0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个问题是，如果您想获得与第一个请求相关的额外数据，您需要做一个新的请求来收集它，这可以快速累积我们的应用程序发出的请求的数量。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="424d" class="lg lh iq lc b gy li lj l lk ll">GET /users/10/teams<br/>---<br/>[{<br/>    "id": 13,<br/>    "name": "Team A"<br/>},<br/>{<br/>    "id": 18,<br/>    "name": "Team B"<br/>}]</span></pre><p id="f38c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了解决这个问题，编写了<a class="ae lm" href="https://github.com/goncalo-oliveira/rest-schema-spec" rel="noopener ugc nofollow" target="_blank"> REST模式</a>规范。它描述了一组扩展，允许我们准确地告诉API我们希望从请求中得到什么。其思想是，它的实现是通用的、一致的，跨越整个API，而不是特定于某个特定的资源。</p><p id="b163" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">规范本身是语言不可知的，因为它描述了一个可以在多种编程语言或框架中实现的概念。在编写<a class="ae lm" href="https://github.com/goncalo-oliveira/rest-schema-spec" rel="noopener ugc nofollow" target="_blank">时，REST模式</a>规范在版本<code class="fe ln lo lp lc b">0.1</code>中。</p><h1 id="8799" class="lq lh iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">模式映射</h1><p id="da63" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">假设我们想要检索一个用户列表，但是我们只对用户的<code class="fe ln lo lp lc b">id</code>和<code class="fe ln lo lp lc b">name</code>感兴趣，其他的都不感兴趣。如果不使用<code class="fe ln lo lp lc b">Schema-Mapping</code>，请求将类似于</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="2323" class="lg lh iq lc b gy li lj l lk ll">GET /users</span></pre><p id="4d66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种反应可能会给我们提供比我们需要的更多的信息</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="ee22" class="lg lh iq lc b gy li lj l lk ll">[{<br/>    "id": 10, <br/>    "name": "John Doe",<br/>    "dob": "1990-01-23",<br/>    "phoneNumber": "55000000000",<br/>    "email": "<a class="ae lm" href="mailto:johndoe@email.com" rel="noopener ugc nofollow" target="_blank">johndoe@email.com</a>"<br/>},<br/>{<br/>    "id": 10, <br/>    "name": "John Doe",<br/>    "dob": "1990-01-23",<br/>    "phoneNumber": "55000000000",<br/>    "email": "<a class="ae lm" href="mailto:johndoe@email.com" rel="noopener ugc nofollow" target="_blank">johndoe@email.com</a>"<br/>}]</span></pre><p id="4c43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了定义我们想要接收的数据，我们需要用JSON或YAML编写一个模式规范。我将使用JSON，因为产生的base64更小(如果先缩小，甚至更小)。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="299f" class="lg lh iq lc b gy li lj l lk ll">{<br/>    "spec": {<br/>        "_": ["id", "name"]<br/>    }<br/>}</span></pre><p id="323b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，这个模式被编码为base64或base64Url字符串，并在<code class="fe ln lo lp lc b">X-Schema-Map</code>头中传递。我将再次使用base64Url，因为结果字符串更小(不需要在末尾填充<code class="fe ln lo lp lc b">=</code>)。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="b799" class="lg lh iq lc b gy li lj l lk ll">GET /users<br/>X-Schema-Map: eyJzcGVjIjp7Il8iOlsiaWQiLCJuYW1lIl19fQ</span></pre><p id="c325" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将给我们以下小得多的响应</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="4b07" class="lg lh iq lc b gy li lj l lk ll">[{<br/>    "id": 10, <br/>    "name": "John Doe"<br/>},<br/>{<br/>    "id": 10, <br/>   "name": "John Doe"<br/>}]</span></pre><p id="9306" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，假设原始示例没有带来那么多数据，但它减少了70%,任何使用过真实场景的人都知道，这可以大幅减少带宽，提高请求速度，甚至提高客户端的数据处理速度。</p><h1 id="4867" class="lq lh iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">架构-包含</h1><p id="707a" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">现在，假设我们想要检索特定用户的数据，但是我们还想要检索他所属的团队。正如我们前面看到的，这有两种不同的资源。首先我们会得到用户</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="c920" class="lg lh iq lc b gy li lj l lk ll">GET /users/10<br/>---<br/>{<br/>    "id": 10, <br/>    "name": "John Doe",<br/>    "dob": "1990-01-23",<br/>    "phoneNumber": "55000000000",<br/>    "email": "<a class="ae lm" href="mailto:johndoe@email.com" rel="noopener ugc nofollow" target="_blank">johndoe@email.com</a>"<br/>}</span></pre><p id="1430" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后是用户的团队</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="2a31" class="lg lh iq lc b gy li lj l lk ll">GET /users/10/teams<br/>---<br/>[{<br/>    "id": 13,<br/>    "name": "Team A"<br/>},<br/>{<br/>    "id": 18,<br/>    "name": "Team B"<br/>}]</span></pre><p id="5811" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以通过使用<code class="fe ln lo lp lc b">Schema-Mapping</code>来实现这一点，并定义我们想要从用户那里检索的所有属性，包括团队。然而，因为我们想从用户那里获得所有的默认数据，加上团队，我们可以定义额外的属性来检索默认属性之外的内容。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="8676" class="lg lh iq lc b gy li lj l lk ll">{<br/>    "spec": {<br/>        "_": ["teams"]<br/>    }<br/>}</span></pre><p id="f714" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和以前一样，我们将模式编码为base64Url字符串，但是这次我们在<code class="fe ln lo lp lc b">X-Schema-Include</code>头中传递它。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="8adc" class="lg lh iq lc b gy li lj l lk ll">GET /users/10<br/>X-Schema-Include: eyJzcGVjIjp7Il8iOlsidGVhbXMiXX19</span></pre><p id="bd0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只需一个请求，我们就能获得用户的所有详细信息</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="73d6" class="lg lh iq lc b gy li lj l lk ll">{<br/>    "id": 10, <br/>    "name": "John Doe",<br/>    "dob": "1990-01-23",<br/>    "phoneNumber": "55000000000",<br/>    "email": "<a class="ae lm" href="mailto:johndoe@email.com" rel="noopener ugc nofollow" target="_blank">johndoe@email.com</a>",<br/>    "teams": [{<br/>        "id": 13,<br/>        "name": "Team A"<br/>    },<br/>    {<br/>        "id": 18,<br/>        "name": "Team B"<br/>    }]<br/>}</span></pre><h1 id="866f" class="lq lh iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">铆钉铆合</h1><p id="08c6" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">使用相同的标准REST APIs，有可能提出减少带宽和应用程序需要处理的请求数量的策略。<a class="ae lm" href="https://github.com/goncalo-oliveira/rest-schema-spec" rel="noopener ugc nofollow" target="_blank"> REST模式</a>规范试图描述这一点，我相信这是一个有趣的想法，尽管获得您的反馈会很好，所以请随意留下您的评论。</p><p id="c427" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于那些在. NET环境中工作的人来说，ASP.NET已经有了一个<a class="ae lm" href="https://github.com/goncalo-oliveira/rest-schema-aspnet" rel="noopener ugc nofollow" target="_blank">c#实现，而且功能齐全，尽管你应该记住它仍然是一项正在进行的工作。如果你是喜欢冒险的人，请随意看看或者贡献自己的一份力量。</a></p></div></div>    
</body>
</html>