<html>
<head>
<title>Extending third-party APIs in different languages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用不同的语言扩展第三方API</h1>
<blockquote>原文：<a href="https://itnext.io/extending-third-party-apis-978203b35c2d?source=collection_archive---------4-----------------------#2021-11-07">https://itnext.io/extending-third-party-apis-978203b35c2d?source=collection_archive---------4-----------------------#2021-11-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1339164c6e41d4c84d584f0eae8d444e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C___DvxCNIaI3aXRD-SPCg.jpeg"/></div></div></figure><p id="81eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">越来越短的上市时间要求集成越来越多的第三方库。如果曾经有过的话，现在已经没有时间治疗T4国立卫生研究院综合症了。虽然大多数时候，该库的API都是现成可用的，但有时需要“调整”它以适应代码库。改编的难易程度很大程度上取决于语言。</p><p id="972b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，在JVM中，有几个反应式编程库:RxJava、Project Reactor、哗变和协程。您可能需要一个使用一个库的类型的库，但是您的项目基于另一个库。</p><p id="9aab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我想描述如何给现有的对象/类型添加新的行为。我不会使用任何反应型来使它更通用，而是将<code class="fe kx ky kz la b">toTitleCase()</code>添加到<code class="fe kx ky kz la b">String</code>。当它存在时，继承是<strong class="ka ir">而不是</strong>一个解决方案，因为它创建了一个新的类型。</p><p id="0b34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我提前道歉，下面的实现非常简单:它们旨在强调我的观点，而不是处理角落情况，<em class="lb">例如</em>，空字符串，非UTF 8，等等。</p><h1 id="4438" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">Java Script语言</h1><p id="6595" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">JavaScript是一种动态解释的弱类型语言，在WASM接管之前，它运行着万维网？据我所知，它的设计很独特，因为它是基于原型的。原型是该类型的新“实例”的模型。</p><p id="3d68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以很容易地向原型添加属性，无论是状态还是行为。</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="e941" class="mn ld iq la b gy mo mp l mq mr">Object.defineProperty(String.prototype, "toTitleCase", {<br/>    value: function toTitleCase() {<br/>        return this.replace(/\w\S*/g, function(word) {<br/>            return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();<br/>        });<br/>    }<br/>});</span><span id="e1c9" class="mn ld iq la b gy ms mp l mq mr">console.debug("OncE upOn a tImE in thE WEst".toTitleCase());</span></pre><p id="e7aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，在对<code class="fe kx ky kz la b">defineProperty</code>的调用之后，从这个原型<em class="lb">创建的对象将提供新的属性；在</em>之前<em class="lb">创建的对象不会。</em></p><h1 id="61d2" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">红宝石</h1><p id="17cf" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">Ruby是一种解释型动态强类型语言。虽然没有Ruby On Rails框架那么受欢迎，但我仍然在Jekyll系统中使用它，这是这篇博客的动力。</p><p id="0b65" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Ruby生态系统中，向现有类添加方法或属性是相当标准的。我发现了两种在Ruby中向现有类型添加方法的机制:</p><ol class=""><li id="b651" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated">Use <a class="ae kw" href="https://apidock.com/ruby/Module/class_eval" rel="noopener ugc nofollow" target="_blank"> class_eval </a> : <br/>"在mod的上下文中计算字符串或块，除了给定块时，常量/类变量查找不受影响。这可用于向类添加方法”</li><li id="33d2" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">只需在现有类上实现该方法。</li></ol><p id="5640" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是第二种方法的代码:</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="58dc" class="mn ld iq la b gy mo mp l mq mr">class String<br/>  def to_camel_case()<br/>    return self.gsub(/\w\S*/) {|word| word.capitalize()}<br/>  end<br/>end</span><span id="fde5" class="mn ld iq la b gy ms mp l mq mr">puts "OncE upOn a tImE in thE WEst".to_camel_case()</span></pre><h1 id="14f4" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">计算机编程语言</h1><p id="d796" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">Python是一种解释型动态强类型语言。我想现在每个开发者都听说过Python。</p><p id="793a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Python允许向现有类型添加函数，但有限制。<a class="ae kw" href="https://www.online-python.com/yv52IK4Mux" rel="noopener ugc nofollow" target="_blank">让我们试试<code class="fe kx ky kz la b">str</code>内置型的</a>:</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="9c62" class="mn ld iq la b gy mo mp l mq mr">import re</span><span id="778a" class="mn ld iq la b gy ms mp l mq mr">def to_title_case(string):<br/>    return re.sub(<br/>        r'\w\S*',<br/>        lambda word: word.group(0).capitalize(),<br/>        string)</span><span id="d95b" class="mn ld iq la b gy ms mp l mq mr">setattr(str, 'to_title_case', to_title_case)</span><span id="7003" class="mn ld iq la b gy ms mp l mq mr">print("OncE upOn a tImE in thE WEst".to_title_case())</span></pre><p id="d64a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是，上面的代码在执行过程中失败了:</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="2c6d" class="mn ld iq la b gy mo mp l mq mr">Traceback (most recent call last):<br/>  File "&lt;string&gt;", line 9, in &lt;module&gt;<br/>TypeError: can't set attributes of built-in/extension type 'str'</span></pre><p id="039c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为<code class="fe kx ky kz la b">str</code>是<em class="lb">内置的</em>类型，所以我们不能动态添加行为。我们可以更新<a class="ae kw" href="https://www.online-python.com/w4G0We7EYh" rel="noopener ugc nofollow" target="_blank">代码</a>来应对这个限制:</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="e23a" class="mn ld iq la b gy mo mp l mq mr">import re</span><span id="a1e4" class="mn ld iq la b gy ms mp l mq mr">def to_title_case(string):<br/>    return re.sub(<br/>        r'\w\S*',<br/>        lambda word: word.group(0).capitalize(),<br/>        string)</span><span id="c142" class="mn ld iq la b gy ms mp l mq mr">class String(str):<br/>    pass</span><span id="2b8d" class="mn ld iq la b gy ms mp l mq mr">setattr(String, 'to_title_case', to_title_case)</span><span id="7e34" class="mn ld iq la b gy ms mp l mq mr">print(String("OncE upOn a tImE in thE WEst").to_title_case())</span></pre><p id="543e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在扩展<code class="fe kx ky kz la b">String</code>成为可能，因为它是我们创建的一个类。当然，这违背了最初的目的:我们首先必须扩展<code class="fe kx ky kz la b">str</code>。因此，它可以与第三方库一起工作。</p><p id="d750" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用解释型语言，向类型添加行为相当容易。然而，Python已经触及了极限，因为内置类型是用c实现的。</p><h1 id="0cf1" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">Java 语言(一种计算机语言，尤用于创建网站)</h1><p id="210d" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">Java是运行在JVM上的静态和强类型编译语言。它的静态性质使得不可能向类型添加行为。</p><p id="09a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解决方法是使用<code class="fe kx ky kz la b">static</code>方法。如果你已经做了很长时间的Java开发人员，我相信你可能在职业生涯的早期见过定制的<code class="fe kx ky kz la b">StringUtils</code>和<code class="fe kx ky kz la b">DateUtils</code>类。这些类看起来像这样:</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="57a8" class="mn ld iq la b gy mo mp l mq mr">public class StringUtils {</span><span id="975e" class="mn ld iq la b gy ms mp l mq mr">    public static String toCamelCase(String string) {<br/>        // The implementation is not relevant<br/>    }</span><span id="e333" class="mn ld iq la b gy ms mp l mq mr">    // Other string transformations here<br/>}</span></pre><p id="f556" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望到现在为止，使用Apache Commons和Guava已经取代了所有这些类:</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="5108" class="mn ld iq la b gy mo mp l mq mr">System.out.println(<br/>    WordUtils.capitalize("OncE upOn a tImE in thE WEst")<br/>);</span></pre><p id="ff0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这两种情况下，<em class="lb">静态方法的使用阻止了流畅的API使用</em>，从而损害了开发人员的体验。但是其他JVM语言确实提供了令人兴奋的选择。</p><h1 id="b1a3" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">斯卡拉</h1><p id="9cc4" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">像Java一样，Scala是一种编译过的、静态的、强类型的语言，运行在JVM上。它最初被设计为面向对象编程和函数式编程之间的桥梁。Scala提供了许多强大的特性。其中，<em class="lb">隐式</em>类允许向现有类添加行为和状态。<a class="ae kw" href="https://scastie.scala-lang.org/razUhHKRRcqamn9qlA0mhw" rel="noopener ugc nofollow" target="_blank">这里的</a>是如何给<code class="fe kx ky kz la b">String</code>添加<code class="fe kx ky kz la b">toCamelCase()</code>功能:</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="8d61" class="mn ld iq la b gy mo mp l mq mr">import Utils.StringExtensions</span><span id="bd46" class="mn ld iq la b gy ms mp l mq mr">object Utils {<br/>  implicit class StringExtensions(thiz: String) {<br/>    def toCamelCase() = "\\w\\S*".r.replaceAllIn(<br/>      thiz,<br/>      { it =&gt; it.group(0).toLowerCase().capitalize }<br/>    )<br/>  }<br/>}</span><span id="1ae6" class="mn ld iq la b gy ms mp l mq mr">println("OncE upOn a tImE in thE WEst".toCamelCase())</span></pre><p id="7dc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然我对Scala略有涉猎，但我从来都不是一个粉丝。作为一名开发人员，我总是说我工作的很大一部分是使<em class="lb">隐式</em>需求<em class="lb">显式</em>。因此，我不赞成故意使用<code class="fe kx ky kz la b">implicit</code>关键字。有趣的是，似乎我并不孤单。Scala 3使用更合适的语法保持了<a class="ae kw" href="https://scastie.scala-lang.org/18abIFMKSvWiz8gpbVx2gg" rel="noopener ugc nofollow" target="_blank">相同的功能</a>:</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="61be" class="mn ld iq la b gy mo mp l mq mr">extension(thiz: String)<br/>  def toCamelCase() = "\\w\\S*".r.replaceAllIn(<br/>    thiz,<br/>    { it =&gt; it.group(0).toLowerCase().capitalize }<br/>  )</span></pre><p id="ef8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，在这两种情况下，<em class="lb">字节码</em>有点类似于Java的<em class="lb">静态</em>方法。然而，API的使用是流畅的，因为您可以一个接一个地链接方法调用。</p><h1 id="67a6" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">科特林</h1><p id="15dc" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">像Java和Scala一样，Kotlin是一种编译过的、静态的、强类型的语言，运行在JVM上。包括Scala在内的其他几种语言启发了它的设计。</p><p id="b2b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的看法是Scala比Kotlin更强大，但代价是额外的认知负荷。相反，科特林有一个轻量级的方法，更加务实。下面是<a class="ae kw" href="https://pl.kotl.in/b67HIw06t" rel="noopener ugc nofollow" target="_blank">科特林版本</a>:</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="c4b7" class="mn ld iq la b gy mo mp l mq mr">fun String.toCamelCase() = "\\w\\S*"<br/>    .toRegex()<br/>    .replace(this) {<br/>        it.groups[0]<br/>            ?.value<br/>            ?.lowercase()<br/>            ?.replaceFirstChar { char -&gt; char.titlecase(Locale.getDefault()) }<br/>            ?: this<br/>    }</span><span id="c8d0" class="mn ld iq la b gy ms mp l mq mr">println("OncE upOn a tImE in thE WEst".toCamelCase())</span></pre><p id="9ecf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想知道为什么Kotlin代码比Scala代码更冗长，尽管我之前说过，这里有两个原因:</p><ol class=""><li id="ab75" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated">我对Scala不够了解，所以没有管理好角落案例(空捕获等。)，但科特林让你别无选择</li><li id="b4b0" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">Kotlin团队从Kotlin 1.5的<code class="fe kx ky kz la b">stdlib</code>中移除了<code class="fe kx ky kz la b">capitalize()</code>函数</li></ol><h1 id="83eb" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">锈</h1><p id="17e3" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">最后但同样重要的是，Rust是一种编译语言，静态和强类型。它最初被设计用来产生本地二进制文件。然而，通过相关配置，它还允许生成Wasm。如果你感兴趣的话，我在学习语言的时候做了link:/focus/start-rust/[几个笔记]。</p><p id="66b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有趣的是，尽管是静态类型的，Rust也允许扩展第三方API，如<a class="ae kw" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=8d1daecd7bd46d6352c131cbf8186839" rel="noopener ugc nofollow" target="_blank">下面的代码显示了</a>:</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="d662" class="mn ld iq la b gy mo mp l mq mr">trait StringExt {                                               // 1<br/>    fn to_camel_case(&amp;self) -&gt; String;<br/>}</span><span id="c295" class="mn ld iq la b gy ms mp l mq mr">impl StringExt for str {                                        // 2<br/>    fn to_camel_case(&amp;self) -&gt; String {<br/>        let re = Regex::new("\\w\\S*").unwrap();<br/>        re.captures_iter(self)<br/>            .map(|capture| {<br/>                let word = capture.get(0).unwrap().as_str();<br/>                let first = &amp;word[0..1].to_uppercase();<br/>                let rest = &amp;word[1..].to_lowercase();<br/>                first.to_owned() + rest<br/>            })<br/>            .collect::&lt;Vec&lt;String&gt;&gt;()<br/>            .join(" ")<br/>    }<br/>}</span><span id="e181" class="mn ld iq la b gy ms mp l mq mr">println!("{}", "OncE upOn a tImE in thE WEst".to_camel_case());</span></pre><ol class=""><li id="7597" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated">创建抽象来保存函数引用。这被称为铁锈的一个特征。</li><li id="a08c" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">为现有结构实现trait。</li></ol><p id="cbdc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Trait实现有一个限制:我们的代码必须声明trait或structure中的至少一个。您不能为现有结构实施现有特征。</p><h1 id="7c4d" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="549c" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">在写这篇文章之前，我认为解释语言允许扩展外部API，而编译语言不允许——kot Lin是个例外。收集材料后，我的理解发生了巨大的变化。</p><p id="9b1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我意识到所有主流语言都提供了这样一个特性。虽然我没有包含C#部分，但它也包含了。我的结论是可悲的，因为Java是唯一一种在这方面没有提供任何东西的语言。</p><p id="9751" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我经常说Kotlin相对于Java最大的好处是扩展属性/方法。虽然Java团队继续为这种语言添加特性，但它仍然没有提供接近上述任何一种语言的开发人员体验。由于我已经使用Java二十年了，我觉得这个结论有点悲哀，但不幸的是，事实就是如此。</p><p id="7652" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更进一步:</strong></p><ul class=""><li id="8285" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv nh mz na nb bi translated"><a class="ae kw" href="https://docs.scala-lang.org/scala3/reference/contextual/extension-methods.html" rel="noopener ugc nofollow" target="_blank"> Scala 3语言参考:扩展方法</a></li><li id="c4eb" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv nh mz na nb bi translated"><a class="ae kw" href="https://kotlinlang.org/docs/extensions.html" rel="noopener ugc nofollow" target="_blank">科特林扩展</a></li></ul></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="f09d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lb">原载于</em> <a class="ae kw" href="https://blog.frankel.ch/extending-third-party-apis/" rel="noopener ugc nofollow" target="_blank"> <em class="lb">一个Java怪胎</em></a><em class="lb">2021年11月7日</em></p></div></div>    
</body>
</html>