<html>
<head>
<title>Metrics From k8s Logs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">k8s日志中的指标</h1>
<blockquote>原文：<a href="https://itnext.io/metrics-from-kubernetes-logs-82cb1dcb3551?source=collection_archive---------0-----------------------#2019-02-20">https://itnext.io/metrics-from-kubernetes-logs-82cb1dcb3551?source=collection_archive---------0-----------------------#2019-02-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c95f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何将k8s日志转换成指标的分步指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/504f6ba64864a5682fb47179cab69afe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f0owcQYnaN7BnDq0_L_3AA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">来自内核和kubernetes的系统日志严重性直方图。📊</figcaption></figure><blockquote class="kv kw kx"><p id="6f79" class="ky kz la lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这是“从日志到度量”系列博文的第二篇博文。它将引导读者完成一个设置，从Kubernetes组件(以及它们所在的内核)发出的syslog消息中获取指标，并从中获得可视化和绘图的乐趣。</p><p id="806a" class="ky kz la lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如果您是那种想知道细节、上下文、为什么以及如何解析syslog消息的人，请跳回到第一篇博文。</p></blockquote></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="c7bd" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">在本系列的第一篇博文中，我用syslog RFCs、格式和传输的细节让每个人感到厌烦。但是我还介绍了一种使用<a class="ae lv" href="http://github.com/influxdata/go-syslog" rel="noopener ugc nofollow" target="_blank"> go-syslog </a>库解析syslog消息的有效而快速的方法。</p><div class="mg mh gp gr mi mj"><a href="https://medium.com/@leodido/from-logs-to-metrics-f38854e3441a" rel="noopener follow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd ir gy z fp mo fr fs mp fu fw ip bi translated">从日志到指标</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">为什么以及如何解析系统日志消息</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">medium.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx kp mj"/></div></div></a></div><p id="9fef" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">在此基础上，这个故事打算展示从日志和<a class="my mz ep" href="https://medium.com/u/9267f20e80cf?source=post_page-----82cb1dcb3551--------------------------------" rel="noopener" target="_blank"> InfluxData </a>栈中提取指标的<strong class="lb ir">完整管道。</strong></p><p id="8391" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">为此，这篇博文附带了一些<a class="ae lv" href="http://bit.ly/logs-2-metrics-influx-code" rel="noopener ugc nofollow" target="_blank">伴随代码</a>(主要是YAML😒)演示了<em class="la">如何在Kubernetes </em>中检测和计数内存不足(OOM)被终止进程的数量。</p><p id="c051" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">也就是说，它表明:</p><ol class=""><li id="bde2" class="na nb iq lb b lc ld lf lg md nc me nd mf ne lu nf ng nh ni bi translated">如何通过<a class="ae lv" href="https://github.com/influxdata/telegraf" rel="noopener ugc nofollow" target="_blank"> Telegraf </a>的<a class="ae lv" href="https://github.com/influxdata/telegraf/tree/master/plugins/inputs/syslog" rel="noopener ugc nofollow" target="_blank"> <strong class="lb ir"> syslog输入插件</strong> </a>将syslog消息解析成指标并将其存储到<a class="ae lv" href="http://github.com/influxdata/influxdb" rel="noopener ugc nofollow" target="_blank"> InfluxDB </a></li><li id="9c72" class="na nb iq lb b lc nj lf nk md nl me nm mf nn lu nf ng nh ni bi translated">如何通过<a class="ae lv" href="https://github.com/influxdata/influxdb/tree/master/chronograf" rel="noopener ugc nofollow" target="_blank"> Chronograf </a>的新日志查看器和/或仪表盘自动、无障碍地可视化和绘制这些指标</li><li id="2be1" class="na nb iq lb b lc nj lf nk md nl me nm mf nn lu nf ng nh ni bi translated">如何通过<a class="ae lv" href="https://github.com/influxdata/kapacitor" rel="noopener ugc nofollow" target="_blank"> Kapacitor </a> <a class="ae lv" href="https://docs.influxdata.com/kapacitor/v1.5/guides/socket_udf/" rel="noopener ugc nofollow" target="_blank"> UDF </a>得出新的有意义的指标(例如被杀死的进程OOM的数量)。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/2b0e0a3f8f59ce3ac526f442b31fa8ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j9g0fQfSt1fv_MCupodOPg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">一个用吉祥物代表我们的日志处理管道的漂亮草图🐯🐦🦒🐨。</figcaption></figure><p id="4665" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">让我们一步一步来。</p><h1 id="c66b" class="np nq iq bd nr ns nt nu nv nw nx ny nz jw oa jx ob jz oc ka od kc oe kd of og bi translated">烘烤环境🍮</h1><p id="706a" class="pw-post-body-paragraph ky kz iq lb b lc oh jr le lf oi ju lh md oj lk ll me ok lo lp mf ol ls lt lu ij bi translated">在深入研究之前，我们需要设置我们的本地环境，因为我们假装在本地实验管道。</p><p id="da95" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">所以首先我们需要一个当地的Kubernetes。</p><p id="1be7" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">但是如何告诉它将其日志消息转发到我们管道的第一部分呢？我们可以将它的<a class="ae lv" href="https://docs.docker.com/config/containers/logging/syslog" rel="noopener ugc nofollow" target="_blank"> docker系统日志记录驱动</a>指向我们系统日志接收器的端口(即。一个Telegraf syslog输入插件，被配置为通过TCP在端口6514上监听)。，<code class="fe om on oo op b">--log-opt syslog-format=rfc5424</code>)。</p><p id="ee5a" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">然而<em class="la">这样的想法在实践中是行不通的</em>，因为我们希望我们的Telegraf由Kubernetes运行，而docker syslog日志记录驱动程序无法在不破坏一切的情况下等待它启动。此外，这种驱动程序不能用八位字节计数帧传输日志，我们想要它，因为我们喜欢在做复杂的事情时使我们的生活复杂化。😌</p><p id="b245" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">所以让我们为此安排一个计划…</p><p id="e706" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">我想到的计划是让Kubernetes(及其主机的内核)将日志转发到<strong class="lb ir"> journald </strong>。不幸的是，journald不发出RFC 5424系统日志消息。因此，我们将使用具有以下设置的<strong class="lb ir"> rsyslog </strong>边车来解决所有问题:</p><ol class=""><li id="62d2" class="na nb iq lb b lc ld lf lg md nc me nd mf ne lu nf ng nh ni bi translated"><strong class="lb ir"> imjournal </strong>模块<a class="ae lv" href="https://www.rsyslog.com/doc/master/configuration/modules/imjournal.html" rel="noopener ugc nofollow" target="_blank">从journald中抓取消息</a></li><li id="0321" class="na nb iq lb b lc nj lf nk md nl me nm mf nn lu nf ng nh ni bi translated"><strong class="lb ir"> mmkubernetes </strong> <a class="ae lv" href="https://www.rsyslog.com/doc/master/configuration/modules/mmkubernetes.html" rel="noopener ugc nofollow" target="_blank">模块</a>将其转换为有效的RFC 5424系统日志消息</li><li id="88de" class="na nb iq lb b lc nj lf nk md nl me nm mf nn lu nf ng nh ni bi translated"><strong class="lb ir"> omfwd </strong>模块使用八位字节计数技术将它们发送到我们的系统日志接收器。</li></ol><p id="3bd4" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">这三个步骤转化成了代码，我把它放在了勇士队这篇文章末尾的<a class="ae lv" href="#6293" rel="noopener ugc nofollow">附录中。</a></p><p id="fef1" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">现在我们只需要启动我们的<strong class="lb ir"> minikube </strong>告诉它使用<strong class="lb ir">journal和</strong>作为日志驱动程序。就是这样。</p><pre class="kg kh ki kj gt oq op or os aw ot bi"><span id="9036" class="ou nq iq op b gy ov ow l ox oy">minikube start --docker-opt log-driver=journald</span></pre><p id="82f9" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">耶！✌</p><h1 id="781f" class="np nq iq bd nr ns nt nu nv nw nx ny nz jw oa jx ob jz oc ka od kc oe kd of og bi translated">Telegraf的系统日志输入插件</h1><p id="b54a" class="pw-post-body-paragraph ky kz iq lb b lc oh jr le lf oi ju lh md oj lk ll me ok lo lp mf ol ls lt lu ij bi translated">如前所述，我们管道的第一个<a class="my mz ep" href="https://medium.com/u/9267f20e80cf?source=post_page-----82cb1dcb3551--------------------------------" rel="noopener" target="_blank"> InfluxData </a>组件是<strong class="lb ir"> Telegraf。它是一个插件驱动的服务器代理，用于收集和报告指标。</strong></p><p id="bc0f" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">我们为它创建了一个<strong class="lb ir"> syslog输入插件</strong>，它使用了<a class="ae lv" href="http://github.com/influxdata/go-syslog" rel="noopener ugc nofollow" target="_blank"> go-syslog </a>库。目的是将其用作syslog接收器，以监听通过<a class="ae lv" href="https://tools.ietf.org/html/rfc5426" rel="noopener ugc nofollow" target="_blank"> UDP </a>或<a class="ae lv" href="https://tools.ietf.org/html/rfc6587" rel="noopener ugc nofollow" target="_blank"> TCP </a>或<a class="ae lv" href="https://tools.ietf.org/html/rfc5425" rel="noopener ugc nofollow" target="_blank"> TLS </a>、<em class="la">带</em>或<em class="la">不带</em>八位字节计数帧传输的syslog消息。</p><p id="59f9" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">缺点是我们(目前)只支持根据<a class="ae lv" href="https://tools.ietf.org/html/rfc5424" rel="noopener ugc nofollow" target="_blank"> RFC 5424 </a>格式化的syslog消息。因此，我们不支持<a class="ae lv" href="https://tools.ietf.org/html/rfc3164.html" rel="noopener ugc nofollow" target="_blank"> RFC 3164 </a>遗留消息，原因在本系列的第一篇博文中已经解释过。</p><p id="9da8" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">无论如何，给定一个输入系统日志消息，该插件将在<em class="la">系统日志测量</em>中创建以下指标。</p><p id="349c" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">标签:</p><ul class=""><li id="41d7" class="na nb iq lb b lc ld lf lg md nc me nd mf ne lu oz ng nh ni bi translated">严重程度(根据<a class="ae lv" href="https://github.com/torvalds/linux/blob/master/tools/include/linux/kern_levels.h" rel="noopener ugc nofollow" target="_blank"> Linux内核</a>其<a class="ae lv" href="https://github.com/influxdata/go-syslog/blob/develop/rfc5424/syslog_message.go#L195-L205" rel="noopener ugc nofollow" target="_blank">简称</a>)—<code class="fe om on oo op b">string</code></li><li id="2992" class="na nb iq lb b lc nj lf nk md nl me nm mf nn lu oz ng nh ni bi translated">设施(其<a class="ae lv" href="https://github.com/influxdata/go-syslog/blob/develop/rfc5424/syslog_message.go#L235-L256" rel="noopener ugc nofollow" target="_blank">简称</a>按<code class="fe om on oo op b">man syslog 3</code>)——<code class="fe om on oo op b">string</code></li><li id="a101" class="na nb iq lb b lc nj lf nk md nl me nm mf nn lu oz ng nh ni bi translated">主机名— <code class="fe om on oo op b">string</code></li><li id="79cc" class="na nb iq lb b lc nj lf nk md nl me nm mf nn lu oz ng nh ni bi translated">appname — <code class="fe om on oo op b">string</code></li></ul><p id="4bfd" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">字段:</p><ul class=""><li id="fb3a" class="na nb iq lb b lc ld lf lg md nc me nd mf ne lu oz ng nh ni bi translated">版本— <code class="fe om on oo op b">integer</code></li><li id="4a63" class="na nb iq lb b lc nj lf nk md nl me nm mf nn lu oz ng nh ni bi translated">severity_code(根据<a class="ae lv" href="https://tools.ietf.org/html/rfc5424.html#section-6.2.1" rel="noopener ugc nofollow" target="_blank">表2，第6.2.1节</a> )— <code class="fe om on oo op b">integer</code></li><li id="839a" class="na nb iq lb b lc nj lf nk md nl me nm mf nn lu oz ng nh ni bi translated">设施_代码(根据<a class="ae lv" href="https://tools.ietf.org/html/rfc5424.html#section-6.2.1" rel="noopener ugc nofollow" target="_blank">表1，第6.2.1节</a> ) — <code class="fe om on oo op b">integer</code></li><li id="3114" class="na nb iq lb b lc nj lf nk md nl me nm mf nn lu oz ng nh ni bi translated">时间戳(syslog消息中记录的时间)——<code class="fe om on oo op b">integer</code></li><li id="2d4f" class="na nb iq lb b lc nj lf nk md nl me nm mf nn lu oz ng nh ni bi translated">procid — <code class="fe om on oo op b">string</code></li><li id="034b" class="na nb iq lb b lc nj lf nk md nl me nm mf nn lu oz ng nh ni bi translated">msgid — <code class="fe om on oo op b">string</code></li><li id="f27b" class="na nb iq lb b lc nj lf nk md nl me nm mf nn lu oz ng nh ni bi translated">消息— <code class="fe om on oo op b">string</code></li><li id="8297" class="na nb iq lb b lc nj lf nk md nl me nm mf nn lu oz ng nh ni bi translated">sdid(结构化数据是否有ID)——<code class="fe om on oo op b">bool</code></li><li id="b2f8" class="na nb iq lb b lc nj lf nk md nl me nm mf nn lu oz ng nh ni bi translated">结构化数据— <code class="fe om on oo op b">string</code></li></ul><p id="cb15" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">现在，简单地说，一些值得解释的事情可以避免你头痛和头晕。</p><p id="21c6" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">该点的时间戳对应于消息被接收的时间。它不同于上面列出的度量的时间戳，后者实际上代表syslog消息中显示的度量(如果有)。</p><p id="2fe2" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">此外，结构化数据(如果存在于日志消息中)通过组合结构化数据标识符(即、<code class="fe om on oo op b">sdid</code>)和使用配置字段<code class="fe om on oo op b">sdparam_separator</code>(默认为<code class="fe om on oo op b">_</code>)的结构化数据元素名称。</p><p id="9f72" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">最后，提醒您，消息部分可能包含UTF-8，我邀请您在您的syslog消息中使用表情符号，使所有这些更具吸引力！😎</p><p id="8bec" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">对了，一个例子胜过千言万语。因此，以下系统日志消息(通过八位字节计数帧传输)…</p><pre class="kg kh ki kj gt oq op or os aw ot bi"><span id="c203" class="ou nq iq op b gy ov ow l ox oy">173 &lt;165&gt;1 2018–10–01:14:15.000Z mymachine.example.com evntslog — ID47[exampleSDID@32473 iut="3" eventSource="Application" eventID="1011"] An application event log entry ✨</span></pre><p id="aafe" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">…根据<a class="ae lv" href="https://docs.influxdata.com/influxdb/v1.7/write_protocols/line_protocol_reference/" rel="noopener ugc nofollow" target="_blank">线路协议</a>会导致这种结果:</p><pre class="kg kh ki kj gt oq op or os aw ot bi"><span id="2386" class="ou nq iq op b gy ov ow l ox oy">syslog,appname=evntslog,facility=local4,hostname=mymachine.example.com,severity=notice exampleSDID@32473_eventID="1011",exampleSDID@32473_eventSource="Application",exampleSDID@32473_iut="3",facility_code=20i,message="An application event log entry ✨",msgid="ID47",severity_code=5i,timestamp=1065910455003000000i,version=1i 1538421339749472344</span></pre><p id="310a" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">我们现在已经准备好为我们的Telegraf配置这样的插件了。它有各种配置选项<a class="ae lv" href="https://github.com/influxdata/telegraf/tree/master/plugins/inputs/syslog#configuration" rel="noopener ugc nofollow" target="_blank"/>,但我们希望保持简单:我们希望在端口6514上通过TCP接收syslog消息，并在最大努力模式下解析它们。这是其配置的核心部分。</p><pre class="kg kh ki kj gt oq op or os aw ot bi"><span id="f8be" class="ou nq iq op b gy ov ow l ox oy">[[inputs.syslog]]<br/>  server = "tcp://:6514"<br/>  best_effort = true</span></pre><h1 id="e66f" class="np nq iq bd nr ns nt nu nv nw nx ny nz jw oa jx ob jz oc ka od kc oe kd of og bi translated">统计OOMs看syslogs 🧮</h1><p id="d413" class="pw-post-body-paragraph ky kz iq lb b lc oh jr le lf oi ju lh md oj lk ll me ok lo lp mf ol ls lt lu ij bi translated">我们假装能够简单地通过查看传入的syslog消息流来计算内存不足(OOM)终止进程的数量，以便能够在仪表板中绘制它们。</p><p id="81ea" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">我们所知道的是，OOMs将在主机内核中生成日志(我们也将收到日志)，其中的消息部分将包含这种短语:</p><pre class="kg kh ki kj gt oq op or os aw ot bi"><span id="c023" class="ou nq iq op b gy ov ow l ox oy">... Kill process &lt;PID&gt; (&lt;PROCESS NAME&gt;) score &lt;OOM SCORE&gt; or sacrifice child</span></pre><p id="fad5" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">该计划(非常简单，仅用于演示目的)是有一个用户定义的函数(UDF ),给定一个日志输入流，它将检测其消息与该格式匹配的日志，并按进程区分计数它们的出现次数，还存储OOM分数。</p><p id="5ccf" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">简单来说:我们的流处理器(即Kapacitor)需要接受一个syslog消息流，并通过一个UDF保留那些与以下正则表达式匹配的消息。</p><pre class="kg kh ki kj gt oq op or os aw ot bi"><span id="6b00" class="ou nq iq op b gy ov ow l ox oy">(?m).*Kill process (?P&lt;pid&gt;\d+) (?P&lt;proc&gt;\(.*\)) score (?P&lt;score&gt;\d+)</span></pre><p id="982b" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">简易柠檬榨汁机。🍋🍑</p><p id="3c5a" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">让我们写一些伪代码来说明我们的<em class="la">例子</em> UDF的逻辑。</p><pre class="kg kh ki kj gt oq op or os aw ot bi"><span id="5e13" class="ou nq iq op b gy ov ow l ox oy">r := regexp.MustCompile(`...`)          <br/>message, ok := p.FieldsString["message"]<br/>if ok {<br/>  m := r.FindStringSubmatch(message)<br/>  data := mapSubexpNames(m, r.SubexpNames())<br/>  proc := strings.Trim(data["proc"], "()")<br/>  state := h.state[proc]<br/>  if state == nil {<br/>    // initialize state<br/>    state := &amp;myState{Counter: 0}<br/>    // index it by process<br/>    h.state[proc] = state<br/>  }<br/>  h.state[proc].Counter++<br/>  // create point<br/>  newpoint := &amp;agent.Point{<br/>    Time: time.Now().UnixNano(),<br/>    Tags: map[string]string{<br/>      "proc": string(proc),<br/>      "pid":  string(data["pid"])<br/>    },<br/>    FieldsInt: map[string]int64{<br/>      "count": h.state[proc].Counter,<br/>    },<br/>  }<br/>  // send point ...<br/>}</span></pre><p id="7daa" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">如果你想深入了解Kapacitor UDF，<a class="ae lv" href="https://github.com/leodido/logs2metrics-talk/blob/master/main.go" rel="noopener ugc nofollow" target="_blank">这里</a>你可以找到它的代码。</p><p id="b1c4" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">最后，我们需要:</p><ul class=""><li id="500e" class="na nb iq lb b lc ld lf lg md nc me nd mf ne lu oz ng nh ni bi translated">为我们的UDF定义输入点的来源(即，数据库<code class="fe om on oo op b">telegraf</code>，保留策略<code class="fe om on oo op b">autogen</code>，测量<code class="fe om on oo op b">syslog</code>)；</li><li id="a4c7" class="na nb iq lb b lc nj lf nk md nl me nm mf nn lu oz ng nh ni bi translated">将它们限制在我们关心的集合中(<em class="la"> appname </em>等于<code class="fe om on oo op b">kernel</code>并且<em class="la">消息</em>包含<code class="fe om on oo op b">sacrifice</code>字)；</li><li id="93ee" class="na nb iq lb b lc nj lf nk md nl me nm mf nn lu oz ng nh ni bi translated">来定义它应该将结果输出点流回哪里(即，数据库<code class="fe om on oo op b">telegraf</code>，测量<code class="fe om on oo op b">k8s</code>。</li></ul><p id="2eb7" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">下面是翻译这些需求所需的<a class="ae lv" href="https://github.com/leodido/logs2metrics-talk/blob/master/kapacitor/tasks/example.tick" rel="noopener ugc nofollow" target="_blank"> TICK脚本</a>。</p><pre class="kg kh ki kj gt oq op or os aw ot bi"><span id="03a9" class="ou nq iq op b gy ov ow l ox oy">dbrp "telegraf"."autogen"<br/>stream<br/>  |from() <br/>    .measurement('syslog')<br/>    .truncate(1ms)<br/>    .where(lambda: "appname" == 'kernel')<br/>    .where(lambda: "message" =~ /sacrifice/)<br/>  @example()<br/>  |influxDBOut()<br/>    .database('telegraf')<br/>    .measurement('k8s')</span></pre><p id="b1af" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">我知道，我知道你在想什么…对于UDF来说，会有许多其他(更好的)用例适合这个管道。但显然这只是一个演示，我关心的是概念，而不是呈现它们的具体用例，所以请不要怪我，也不要怪我在这种情况下缺乏想象力。<a class="ae lv" href="https://apps.timwhitlock.info/emoji/tables/unicode#emoji-modal" rel="noopener ugc nofollow" target="_blank">🙏</a></p><h1 id="ccf3" class="np nq iq bd nr ns nt nu nv nw nx ny nz jw oa jx ob jz oc ka od kc oe kd of og bi translated">部署管道</h1><p id="fff9" class="pw-post-body-paragraph ky kz iq lb b lc oh jr le lf oi ju lh md oj lk ll me ok lo lp mf ol ls lt lu ij bi translated">现在让我们把所有的碎片放在一起，来计算我们的假Kubernetes集群中发生的OOMs。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/f99eb9899dd0b89cf367cb9f72b6625a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z02fEF3h2liFnjY5T2ZUGg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">我在做YAML，而不是像过去那样做严肃的事情。🥺</figcaption></figure><p id="80af" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">为了简单起见，我们将在单个Kubernetes名称空间(名称为<code class="fe om on oo op b">logging</code>)中做所有事情。应用下面的<a class="ae lv" href="https://github.com/leodido/logs2metrics-talk/blob/master/namespace.yaml" rel="noopener ugc nofollow" target="_blank">命名空间YAML </a>文件。</p><pre class="kg kh ki kj gt oq op or os aw ot bi"><span id="32a6" class="ou nq iq op b gy ov ow l ox oy">---<br/># Section: logging namespace<br/>apiVersion: v1<br/>kind: Namespace<br/>  metadata:<br/>    name: logging</span></pre><blockquote class="kv kw kx"><p id="8f71" class="ky kz la lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">从现在开始，由于YAML文件非常冗长，我只报告应用它们的命令。您可以点击YAML文件的名称来查看它们(包含一个到git库的链接)。</p></blockquote><p id="4970" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">我们还想存储度量，所以我们需要部署我们惊人的时间序列数据库。</p><pre class="kg kh ki kj gt oq op or os aw ot bi"><span id="bfd6" class="ou nq iq op b gy ov ow l ox oy">kubectl apply -f <a class="ae lv" href="https://github.com/leodido/logs2metrics-talk/blob/master/influxdb.yaml" rel="noopener ugc nofollow" target="_blank">influxdb.yaml</a></span></pre><p id="8b9c" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">现在是Telegraf plus Rsyslog的时候了(此时您肯定已经明白为什么了)，它提供了所有额外的东西(例如，也向InfluxDB发送指标，共享日志路径，角色使mmkubernetes能够调用Kubernetes APIs，等等)。</p><pre class="kg kh ki kj gt oq op or os aw ot bi"><span id="95a2" class="ou nq iq op b gy ov ow l ox oy">kubectl apply -f <a class="ae lv" href="https://github.com/leodido/logs2metrics-talk/blob/master/telelog.yaml" rel="noopener ugc nofollow" target="_blank">telelog.yaml</a><br/>kubectl apply -f <a class="ae lv" href="https://github.com/leodido/logs2metrics-talk/blob/master/roles.yaml" rel="noopener ugc nofollow" target="_blank">roles.yaml</a></span></pre><p id="eebe" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">要设置日志查看器，没有什么特别的需要。</p><p id="af2b" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">部署Chronograf就足够了。然后，我们可以手动创建尽可能多的漂亮仪表板。</p><pre class="kg kh ki kj gt oq op or os aw ot bi"><span id="02b4" class="ou nq iq op b gy ov ow l ox oy">kubectl apply -f <a class="ae lv" href="https://github.com/leodido/logs2metrics-talk/blob/master/chronograf.yaml" rel="noopener ugc nofollow" target="_blank">chronograf.yaml</a></span></pre><p id="8e29" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">此时，我们可以将浏览器指向<a class="ae lv" href="http://localhost:8888" rel="noopener ugc nofollow" target="_blank"> localhost:8888 </a>，欣赏系统日志指标的展示，并创建一个令人惊叹的直方图。</p><p id="94f7" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">顺便说一下，如果需要，不要忘记转移Chronograf服务。</p><pre class="kg kh ki kj gt oq op or os aw ot bi"><span id="39bf" class="ou nq iq op b gy ov ow l ox oy">kubectl port-forward svc/chronograf -n logging 8888:80</span></pre><p id="2181" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">你应该能在这篇文章的标题中看到类似图片的东西！</p><p id="63a4" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">此外，您可以(也应该)使用浏览器来探索syslog消息导致的指标。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/4b7d050291d8dd75428b6e74923a3319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XQKcbP5pNOzGX8LAUTD_zw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">通过Chronograf的浏览器探索系统日志指标。</figcaption></figure><p id="7f93" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">所以<em class="la">时间到了</em>:让我们用我们编写的UDF部署我们的流处理器。</p><pre class="kg kh ki kj gt oq op or os aw ot bi"><span id="b105" class="ou nq iq op b gy ov ow l ox oy">kubectl apply -f <a class="ae lv" href="https://github.com/leodido/logs2metrics-talk/blob/master/kapacitor.yaml" rel="noopener ugc nofollow" target="_blank">kapacitor.yaml</a></span></pre><p id="490b" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">为了生成OOM典型的syslog消息，我们最终部署了一个包含压力工具的pod(在这方面，我选择了<a class="ae lv" href="https://hub.docker.com/r/polinux/stress" rel="noopener ugc nofollow" target="_blank"> polinux/stress </a>)。</p><pre class="kg kh ki kj gt oq op or os aw ot bi"><span id="55d1" class="ou nq iq op b gy ov ow l ox oy">kubectl apply -f <a class="ae lv" href="https://github.com/leodido/logs2metrics-talk/blob/master/stress.yaml" rel="noopener ugc nofollow" target="_blank">stress.yaml</a></span></pre><p id="84d0" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">至此，我们的管道已经完成！🎉</p><p id="813b" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">它将开始在系统日志流中寻找OOM消息，将它们转换成存储在<code class="fe om on oo op b">telegraf.k8s</code>中的指标。</p><p id="1c89" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">现在是时候享受通过浏览器查询它们，然后创建一些奇特的仪表板来看看了！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/4156b598eeb838cc0493e3b00186a7b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x2nd0noety8JHxiLu86R_A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">查询OOM终止的进程。📈</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/a24e25a6953e4eb041827d0da721c73f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YeR4p2fXZv4iIc3sfSgppA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">绘制流程图。📈</figcaption></figure><blockquote class="kv kw kx"><p id="2623" class="ky kz la lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><a class="ae lv" href="https://git.io/k8s-logs-to-metrics-tick" rel="noopener ugc nofollow" target="_blank">在这里</a>您可以找到包含该演示完整代码的git存储库，以及一些开发/调试工具。</p><p id="3c4c" class="ky kz la lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">随时给我发拉请求…有人想更新到InfluxDB 2.0吗？😊</p></blockquote></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="6293" class="np nq iq bd nr ns pd nu nv nw pe ny nz jw pf jx ob jz pg ka od kc ph kd of og bi translated">附录</h1><p id="7ead" class="pw-post-body-paragraph ky kz iq lb b lc oh jr le lf oi ju lh md oj lk ll me ok lo lp mf ol ls lt lu ij bi translated">正如所承诺的，这里有<strong class="lb ir"> RainerScript </strong> ( <a class="ae lv" href="https://www.rsyslog.com/doc/v8-stable/rainerscript/index.html" rel="noopener ugc nofollow" target="_blank">文档</a>)来配置<a class="ae lv" href="https://github.com/rsyslog/rsyslog" rel="noopener ugc nofollow" target="_blank"> rsyslog </a>从journald获取syslog消息，将它们转换为RFC5424 syslog格式，并将其与八位位组计数帧一起发送到syslog接收器。</p><p id="2ad6" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh md lj lk ll me ln lo lp mf lr ls lt lu ij bi translated">这个脚本提供了一些好处:</p><ol class=""><li id="bcc6" class="na nb iq lb b lc ld lf lg md nc me nd mf ne lu nf ng nh ni bi translated">合适时，<em class="la"> appname </em>匹配<code class="fe om on oo op b">namespace/pod</code>格式</li><li id="a79b" class="na nb iq lb b lc nj lf nk md nl me nm mf nn lu nf ng nh ni bi translated"><em class="la">消息</em>结尾没有最终误导换行，并使用固定的UTF-8字符</li><li id="5980" class="na nb iq lb b lc nj lf nk md nl me nm mf nn lu nf ng nh ni bi translated">一个<em class="la">结构化的</em> <em class="la">数据</em>段，其<em class="la"> sdid </em>等于<code class="fe om on oo op b">id</code>，包含<code class="fe om on oo op b">container=&lt;container id&gt;</code>、<code class="fe om on oo op b">namespace=&lt;namespace id&gt;</code>和<code class="fe om on oo op b">pod=&lt;pod id&gt;</code></li><li id="13de" class="na nb iq lb b lc nj lf nk md nl me nm mf nn lu nf ng nh ni bi translated">一个<em class="la">结构化的</em> <em class="la">数据</em>段，其<em class="la"> sdid </em>等于<code class="fe om on oo op b">label</code>，包含<code class="fe om on oo op b">component=&lt;component label&gt;</code>和<code class="fe om on oo op b">controller-revision-hash=&lt;controller-revision-hash label&gt;</code></li><li id="0f39" class="na nb iq lb b lc nj lf nk md nl me nm mf nn lu nf ng nh ni bi translated">限速</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pi pj l"/></div></figure></div></div>    
</body>
</html>