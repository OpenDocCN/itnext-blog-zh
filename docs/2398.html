<html>
<head>
<title>Easy patterns: Command</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单模式:命令</h1>
<blockquote>原文：<a href="https://itnext.io/easy-patterns-command-15733a2b56f0?source=collection_archive---------7-----------------------#2019-05-17">https://itnext.io/easy-patterns-command-15733a2b56f0?source=collection_archive---------7-----------------------#2019-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9ffbc8ac1147c7866954c07d966eba9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xQ2peVm9CmcIgYY2UyyBYg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">命令模式的结构</figcaption></figure><p id="df24" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">本文是easy patterns系列描述的延续，介绍了一个名为Command的行为模式，它有助于参数化具有不同请求的客户机，并支持可撤销的操作。</p><p id="4011" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">也请参考其他模式文章:</p><h2 id="bf5d" class="la lb iq bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">创作模式:</h2><blockquote class="lt lu lv"><p id="fa0f" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-simple-factory-b946a086fd7e"> <strong class="ke ir">简易工厂</strong> </a></p><p id="2004" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-factory-method-5f27385ac5c"> <strong class="ke ir">工厂法</strong> </a></p><p id="8fab" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-builder-d85655bcf8aa"> <strong class="ke ir">构建器</strong> </a></p><p id="0e6b" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-singleton-283356fb29bf"> <strong class="ke ir">单个</strong> </a></p><p id="73db" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-abstract-factory-2325cb398fc6"> <strong class="ke ir">抽象工厂</strong> </a></p><p id="9d90" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-prototype-e03ec6962f89"> <strong class="ke ir">原型</strong> </a></p></blockquote><h2 id="b2ad" class="la lb iq bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">结构模式:</h2><blockquote class="lt lu lv"><p id="4425" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-adapter-9b5806cb346f"> <strong class="ke ir">适配器</strong> </a></p><p id="5343" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-decorator-eaa96c0550ea"> <strong class="ke ir">装饰者</strong> </a></p><p id="a7f3" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-bridge-28d50dc25f9f"> <strong class="ke ir">桥</strong> </a></p><p id="2353" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-composite-8b28aa1f158"> <strong class="ke ir">复合</strong> </a></p><p id="2cca" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-facade-8cb185f4f44f"> <strong class="ke ir">立面</strong> </a></p><p id="9d1e" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-flyweight-dab4c018f7f5"> <strong class="ke ir">飞锤</strong> </a></p><p id="797a" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-proxy-45fc3a648020"> <strong class="ke ir">代理</strong> </a></p></blockquote><h2 id="c975" class="la lb iq bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">行为模式:</h2><blockquote class="lt lu lv"><p id="052a" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-visitor-b8ef57eb957"> <strong class="ke ir">来访者</strong> </a></p><p id="8f4d" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-mediator-e0bf18fefdf9"> <strong class="ke ir">调解员</strong> </a></p><p id="ee43" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-observer-63c832d41ffd"> <strong class="ke ir">观察者</strong> </a></p><p id="2da6" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-memento-ce966cec7478"> <strong class="ke ir">纪念品</strong> </a></p><p id="e199" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-iterator-f5c0dd85957"> <strong class="ke ir">迭代器</strong> </a></p><p id="f257" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-chain-of-responsibility-9a84307ad837"> <strong class="ke ir">责任链</strong> </a></p><p id="e67d" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-strategy-ecb6f6fc0ef3"> <strong class="ke ir">策略</strong> </a></p><p id="f43d" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-state-ec87a1a487b4"> <strong class="ke ir">状态</strong> </a></p><p id="1ff3" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><strong class="ke ir">命令</strong>命令<em class="iq">(此条)</em></p></blockquote><h1 id="783f" class="mb lb iq bd lc mc md me lf mf mg mh li mi mj mk ll ml mm mn lo mo mp mq lr mr bi translated">主要本质</h1><p id="ea78" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated">有时有必要向对象发出请求，而不知道请求接收者正在请求的操作。例如一些按钮部分有一个按钮。单击时应该处理一些请求，但是按钮部分不能显式地实现请求，它应该由应用程序本身来完成。我们不知道请求的接收者或执行请求的操作，只有应用程序知道这一点。</p><p id="b0a0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这种模式也称为动作或事务。</p><p id="e8f7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这种模式包括四个主要角色:</p><ul class=""><li id="71d4" class="mx my iq ke b kf kg kj kk kn mz kr na kv nb kz nc nd ne nf bi translated"><strong class="ke ir">命令</strong> —定义一个接收者对象和一个动作之间的绑定。通过调用接收器上的相应操作来实现一个<code class="fe ng nh ni nj b">.execute</code>方法。</li><li id="d60f" class="mx my iq ke b kf nk kj nl kn nm kr nn kv no kz nc nd ne nf bi translated"><strong class="ke ir">调用者</strong> —要求命令执行请求。</li><li id="972b" class="mx my iq ke b kf nk kj nl kn nm kr nn kv no kz nc nd ne nf bi translated"><strong class="ke ir">接收者</strong> —知道如何执行与执行请求相关的操作。</li><li id="8750" class="mx my iq ke b kf nk kj nl kn nm kr nn kv no kz nc nd ne nf bi translated"><strong class="ke ir">客户端</strong> —创建一个命令对象并设置其接收者</li></ul><p id="c06a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">关于角色协作的一些话。</p><figure class="nq nr ns nt gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/9cdf6640058209ce489e17121d47a67e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*61YdHI0Sp8fcG2KRM1ZNWg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">模式角色之间的协作(UML表示)</figcaption></figure><ol class=""><li id="bec0" class="mx my iq ke b kf kg kj kk kn mz kr na kv nb kz nu nd ne nf bi translated">客户端创建一个命令对象并指定它的接收者。</li><li id="a15f" class="mx my iq ke b kf nk kj nl kn nm kr nn kv no kz nu nd ne nf bi translated">调用程序对象存储命令对象。</li><li id="45f0" class="mx my iq ke b kf nk kj nl kn nm kr nn kv no kz nu nd ne nf bi translated">调用程序通过调用命令上的<code class="fe ng nh ni nj b">.execute</code>发出请求。</li><li id="9c57" class="mx my iq ke b kf nk kj nl kn nm kr nn kv no kz nu nd ne nf bi translated">如果命令<code class="fe ng nh ni nj b">.execute</code>是可撤销的，命令在调用<code class="fe ng nh ni nj b">.execute</code>之前存储撤销命令的状态。</li><li id="5dd4" class="mx my iq ke b kf nk kj nl kn nm kr nn kv no kz nu nd ne nf bi translated">命令对象调用其接收者上的操作来执行请求。</li></ol><p id="dcf6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">命令是面向对象的回调替代物(在某个地方注册的函数，在以后的某个时间被调用)。</p><p id="5abc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">可以将这样的操作发送到其他独立的地方执行，例如不同的进程。</p><p id="7568" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">命令<code class="fe ng nh ni nj b">.execute</code>操作可以在内部存储状态用于反转其效果。所以，基本上你得到的不仅仅是封装在里面的执行逻辑，还有一个<code class="fe ng nh ni nj b">.undo</code>逻辑。</p><p id="e9bf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果系统崩溃，也可以重新应用逻辑。它的发生是由于日志的支持。在系统中保持一个持久的变化日志是可能的。</p><h1 id="b6f2" class="mb lb iq bd lc mc md me lf mf mg mh li mi mj mk ll ml mm mn lo mo mp mq lr mr bi translated">使用示例</h1><p id="8e08" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated">在这个例子中，我们将创建一个咖啡机。我们还将创建一个名为ControlPanel的Invoker类，它将通过调用它的<code class="fe ng nh ni nj b">.execute</code>方法为我们调用一个特定的命令。Command类的每个实例都接受一个CoffeeMachine实例，以便以后操作。Action类已经知道执行所需的一切。但是执行本身被延迟了，直到ControlPanel类决定做些什么(用户按钮按下，等等)。</p><p id="e954" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我在这里用抽象方法创建了命令类，只是为了展示一些特定命令的结构(每个特定的命令类都是从这个命令类扩展而来的)。</p><figure class="nq nr ns nt gt jr"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="48a5" class="mb lb iq bd lc mc md me lf mf mg mh li mi mj mk ll ml mm mn lo mo mp mq lr mr bi translated">利润</h1><p id="a649" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated">命令模式将调用操作的对象与知道如何执行操作的对象分离开来。</p><p id="6e72" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">命令通常是一级对象(它们可以像任何其他对象一样被操作和扩展)。</p><p id="ecc6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">可以将命令组合成一个复合命令(宏命令)。所以同时执行一组命令是可能的。</p><p id="6cf7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">新命令很容易添加，因为您不必更改现有的类。</p><h1 id="2264" class="mb lb iq bd lc mc md me lf mf mg mh li mi mj mk ll ml mm mn lo mo mp mq lr mr bi translated">薄弱的地方</h1><p id="67a0" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated">当调用方与接收方的解耦在非常简单的逻辑中没有意义时，这可能是一种开销。在某些情况下，<a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-observer-63c832d41ffd"> PubSub </a>模式足以执行基于事件监听的回调。</p><h1 id="9caa" class="mb lb iq bd lc mc md me lf mf mg mh li mi mj mk ll ml mm mn lo mo mp mq lr mr bi translated">结论</h1><p id="4885" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated">有几种相关的模式可以与命令模式一起使用:</p><ul class=""><li id="e566" class="mx my iq ke b kf kg kj kk kn mz kr na kv nb kz nc nd ne nf bi translated">一个<a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-composite-8b28aa1f158">复合</a>模式可以用来从简单的命令类中生成一个宏命令。</li><li id="33d9" class="mx my iq ke b kf nk kj nl kn nm kr nn kv no kz nc nd ne nf bi translated">为了帮助<code class="fe ng nh ni nj b">.undo</code>实现回滚到之前的状态，如果出现问题，可以使用<a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-memento-ce966cec7478"> Memento </a>模式。</li></ul><p id="0670" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">复合模式有助于围绕基于原语操作的高层操作构建系统。这种结构在支持事务的系统中很常见。每个事务封装了一组对数据的更改。基本上事务可以用命令类来完成。命令有一个公共接口，允许您以相同的方式调用所有事务。这种模式使得用新的事务扩展系统变得容易，只需实现新的命令类。</p><p id="1946" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您觉得这篇文章有帮助，请点击👏按钮并在下面随意评论！</p></div></div>    
</body>
</html>