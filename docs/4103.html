<html>
<head>
<title>A NodeJS boilerplate for GraphQL, Sequelize &amp; PostgreSQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于GraphQL、Sequelize和PostgreSQL的NodeJS样板文件</h1>
<blockquote>原文：<a href="https://itnext.io/a-boilerplate-for-graphql-sequilize-postgresql-on-node-4eb68c9596bc?source=collection_archive---------2-----------------------#2020-04-27">https://itnext.io/a-boilerplate-for-graphql-sequilize-postgresql-on-node-4eb68c9596bc?source=collection_archive---------2-----------------------#2020-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b764" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将关系数据公开为文档的一种令人信服的方式</h2></div><p id="66b6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated"><span class="l lf lg lh bm li lj lk ll lm di">在</span>这篇文章中，您将看到一个NodeJS应用程序，它集成了连接到PostgreSQL的GraphQL和Sequelize，以将规范化的关系数据(以1-n、m-n基数表示)连接到基于文档的数据表示。我将提供GraphQL只读查询的例子，并展示如何通过对象关系映射器<a class="ae ln" href="https://sequelize.org/" rel="noopener ugc nofollow" target="_blank"> Sequelize </a>将它们转换成有效的SQL语句。</p><p id="3657" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了快速入门，本文提供了一个关于此<a class="ae ln" href="https://github.com/thomasreinecke/graphql-sequelize-pg" rel="noopener ugc nofollow" target="_blank"> GH repo </a>的工作示例。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/eb4da770ab98c16267a1019684ba0f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KBL8OZrjwCujG7owx8sWGw.png"/></div></div></figure><h1 id="d52a" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">项目设置</h1><div class="ms mt gp gr mu mv"><a href="https://github.com/thomasreinecke/graphql-sequelize-pg" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">托马斯雷内克/graphql-sequelize-pg</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">用于GraphQL、Sequelize &amp; PostgreSQL-thomasreincke/graph QL-Sequelize-pg的NodeJS样板文件</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">github.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj ly mv"/></div></div></a></div><ul class=""><li id="ffd1" class="nk nl it kk b kl km ko kp kr nm kv nn kz no ld np nq nr ns bi translated">克隆<code class="fe nt nu nv nw b"><strong class="kk iu">graphql-sequelize-pg</strong></code>项目:<br/><code class="fe nt nu nv nw b"><strong class="kk iu">git clone </strong><a class="ae ln" href="https://github.com/thomasreinecke/graphql-sequilize-pg.git" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">https://github.com/thomasreinecke/graphql-sequelize-pg.git</strong></a><strong class="kk iu"> </strong></code>——该项目将被克隆到您的<code class="fe nt nu nv nw b"><strong class="kk iu">ROJECT_HOME</strong></code>目录中</li><li id="0dcf" class="nk nl it kk b kl nx ko ny kr nz kv oa kz ob ld np nq nr ns bi translated">在<code class="fe nt nu nv nw b"><strong class="kk iu">PROJECT_HOME</strong></code>上运行<code class="fe nt nu nv nw b">yarn</code>来安装节点依赖项</li><li id="909d" class="nk nl it kk b kl nx ko ny kr nz kv oa kz ob ld np nq nr ns bi translated">安装一个PostgreSQL数据库服务器，确保它正在运行并且可以访问(本教程不涉及这个主题，但是你可以在网上找到大量的资源)</li><li id="6ff4" class="nk nl it kk b kl nx ko ny kr nz kv oa kz ob ld np nq nr ns bi translated">在<code class="fe nt nu nv nw b"><strong class="kk iu">PROJECT_HOME</strong></code>上编辑<code class="fe nt nu nv nw b"><strong class="kk iu">.env</strong></code> <strong class="kk iu"> </strong>文件并应用您的数据库设置</li></ul><pre class="lp lq lr ls gt oc nw od oe aw of bi"><span id="52fd" class="og mb it nw b gy oh oi l oj ok">NODE_ENV=development<br/>PORT=9000<br/>DB_HOST=127.0.0.1<br/>DB_PORT=5432<br/>DB_DATABASE=its-my-database<br/>DB_USERNAME=its-me<br/>DB_PASSWORD=its-my-password<br/>DB_SCHEMA=its-my-schema<br/>DB_DIALECT=postgres</span></pre><ul class=""><li id="10d7" class="nk nl it kk b kl km ko kp kr nm kv nn kz no ld np nq nr ns bi translated">创建数据库模式<code class="fe nt nu nv nw b"><strong class="kk iu">yarn cleandb</strong></code>，您应该看到数据库模型和一些正在创建的示例数据</li><li id="e5ce" class="nk nl it kk b kl nx ko ny kr nz kv oa kz ob ld np nq nr ns bi translated">现在是启动服务器的时候了<code class="fe nt nu nv nw b"><strong class="kk iu">yarn dev</strong></code></li></ul><pre class="lp lq lr ls gt oc nw od oe aw of bi"><span id="39d1" class="og mb it nw b gy oh oi l oj ok">🚀 Sequelize ORM connected to postgres @ 127.0.0.1:5432<br/>🚀 Server ready at <a class="ae ln" href="http://localhost:4000/" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/</a><br/>🚀 Subscriptions ready at ws://localhost:4000/graphql</span></pre><p id="f80e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您看到这个，那么恭喜您——您已经将Sequelize ORM连接到了PostgreSQL服务器，并且在您的本地机器上暴露了一个GraphQL端点。</p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><h1 id="4e99" class="ma mb it bd mc md os mf mg mh ot mj mk jz ou ka mm kc ov kd mo kf ow kg mq mr bi translated">对象模型</h1><p id="1d8c" class="pw-post-body-paragraph ki kj it kk b kl ox ju kn ko oy jx kq kr oz kt ku kv pa kx ky kz pb lb lc ld im bi translated">该模型提供了只属于一个<strong class="kk iu">组织</strong>的<strong class="kk iu">用户</strong>(一对多关系)，可以有多个<strong class="kk iu">角色</strong>(多对多关系)</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi pc"><img src="../Images/c9a5faae8daec91f501365ce518f0cb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Ql-rmYtcmbEshANQeiGmw.png"/></div></div></figure><p id="76ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated">从<strong class="kk iu"> GraphQL </strong>的角度来看，模式描述如下。您将意识到每个GraphQL模式文件都包含对象定义本身、两个输入定义(一个创建新记录<code class="fe nt nu nv nw b"><strong class="kk iu">&lt;Object&gt;Input</strong></code>，另一个查询对象<code class="fe nt nu nv nw b"><strong class="kk iu">&lt;Object&gt;RecordInput</strong></code>的一个记录)和一个输出对象，该输出对象能够传递一个或多个对象记录和附加元数据。稍后我们将在GraphQL操场上使用这些定义。</p><h2 id="29fd" class="og mb it bd mc pd pe dn mg pf pg dp mk kr ph pi mm kv pj pk mo kz pl pm mq pn bi translated">GraphQL对象:组织</h2><p id="f8a7" class="pw-post-body-paragraph ki kj it kk b kl ox ju kn ko oy jx kq kr oz kt ku kv pa kx ky kz pb lb lc ld im bi translated">一个非常简单的组织表示，多个用户可以关联到该组织。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="po pp l"/></div></figure><h2 id="999d" class="og mb it bd mc pd pe dn mg pf pg dp mk kr ph pi mm kv pj pk mo kz pl pm mq pn bi translated">GraphQL对象:角色</h2><p id="7f53" class="pw-post-body-paragraph ki kj it kk b kl ox ju kn ko oy jx kq kr oz kt ku kv pa kx ky kz pb lb lc ld im bi translated">另一个简单的对象，用于保存可以关联到多个用户的角色。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="po pp l"/></div></figure><h2 id="c01d" class="og mb it bd mc pd pe dn mg pf pg dp mk kr ph pi mm kv pj pk mo kz pl pm mq pn bi translated">GraphQL对象:用户</h2><p id="addc" class="pw-post-body-paragraph ki kj it kk b kl ox ju kn ko oy jx kq kr oz kt ku kv pa kx ky kz pb lb lc ld im bi translated">用户对象包含几个描述用户的基本字段，并引用组织以及与用户相关联的多个潜在角色。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="po pp l"/></div></figure></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><p id="26fd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated"><span class="l lf lg lh bm li lj lk ll lm di">我们</span>还必须描述<strong class="kk iu">序列化</strong>的对象模型。我们将使用这个模型来管理PostgreSQL中的模式，例如，最初我们通过这个模型创建我们需要的数据库表，并且我们将把数据的关系表示匹配到JSON中。好吧，想象一下，这一切都是顺序化的，为我们做的。有关Sequelize的更多信息:</p><div class="ms mt gp gr mu mv"><a href="https://sequelize.org/master/manual/getting-started.html" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">序列</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">在本教程中，你将学习制作一个简单的序列设置。Sequelize可通过npm(或yarn)获得。</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">sequelize.org</p></div></div><div class="ne l"><div class="pq l ng nh ni ne nj ly mv"/></div></div></a></div><h2 id="fc15" class="og mb it bd mc pd pe dn mg pf pg dp mk kr ph pi mm kv pj pk mo kz pl pm mq pn bi translated">顺序化对象:组织</h2><p id="6b4c" class="pw-post-body-paragraph ki kj it kk b kl ox ju kn ko oy jx kq kr oz kt ku kv pa kx ky kz pb lb lc ld im bi translated">我们将创建一个表org，其中一个<code class="fe nt nu nv nw b"><strong class="kk iu">id</strong></code>字段作为UUID字段，一个<code class="fe nt nu nv nw b"><strong class="kk iu">name</strong></code>字段作为唯一字符串(100) +一个额外的名称索引，以便通过基于名称的查询更有效地访问数据。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="po pp l"/></div></figure><h2 id="1e5d" class="og mb it bd mc pd pe dn mg pf pg dp mk kr ph pi mm kv pj pk mo kz pl pm mq pn bi translated">顺序化对象:角色</h2><p id="7a71" class="pw-post-body-paragraph ki kj it kk b kl ox ju kn ko oy jx kq kr oz kt ku kv pa kx ky kz pb lb lc ld im bi translated">这个对象看起来非常相似，我们将在这里为<code class="fe nt nu nv nw b"><strong class="kk iu">name</strong></code>创建一个额外的索引。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="po pp l"/></div></figure><h2 id="ba3c" class="og mb it bd mc pd pe dn mg pf pg dp mk kr ph pi mm kv pj pk mo kz pl pm mq pn bi translated">Sequelize对象:用户</h2><p id="becc" class="pw-post-body-paragraph ki kj it kk b kl ox ju kn ko oy jx kq kr oz kt ku kv pa kx ky kz pb lb lc ld im bi translated">您将意识到，用户对象通过字段orgId和通过Sequelize创建的外键约束来保存对Org表的引用。这代表了用户和组织之间的一对多关系。同样，我们将在<code class="fe nt nu nv nw b"><strong class="kk iu">serial</strong></code>字段上创建一个额外的索引，以便针对这个唯一的字段进行更有效的查询。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="po pp l"/></div></figure></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi pr"><img src="../Images/eaa582065ea8e3a188763004d2b5bbd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Im_Ht1IMyzjTBsLClcqdAw.png"/></div></div><figcaption class="ps pt gj gh gi pu pv bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ln" href="https://unsplash.com/s/photos/data?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="260f" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">数据管理</h1><p id="6c3d" class="pw-post-body-paragraph ki kj it kk b kl ox ju kn ko oy jx kq kr oz kt ku kv pa kx ky kz pb lb lc ld im bi translated">让我们快速浏览一下PostgreSQL上刚刚创建的数据库表:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi pw"><img src="../Images/78e7989bdbcddaf5a7930a28d09437ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZOFp3lAA0lDjjQM_MywMaQ.png"/></div></div></figure><p id="b7da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated"><span class="l lf lg lh bm li lj lk ll lm di">等等……我们还没有描述<code class="fe nt nu nv nw b"><strong class="kk iu">userrole</strong></code>表的数据模型，对吗？幸运的是，我们不必这样做，因为Sequelize很好地处理了这些关系…</span></p><pre class="lp lq lr ls gt oc nw od oe aw of bi"><span id="0833" class="og mb it nw b gy oh oi l oj ok"><em class="px">// from src/db/model/index.js:<br/>// define the relationships between the entities</em></span><span id="97fd" class="og mb it nw b gy py oi l oj ok">db.user.belongsTo(db.org);<br/>db.user.belongsToMany(db.role, { through: 'userrole' });<br/>db.role.belongsToMany(db.user, { through: 'userrole' });</span></pre><p id="63cc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们明确地告诉sequelize，<code class="fe nt nu nv nw b"><strong class="kk iu">org</strong></code>与<code class="fe nt nu nv nw b"><strong class="kk iu">user</strong></code>有一对多的关系，并且<code class="fe nt nu nv nw b"><strong class="kk iu">user</strong></code> <strong class="kk iu"> </strong>和<strong class="kk iu"> </strong> <code class="fe nt nu nv nw b"><strong class="kk iu">role</strong></code>通过表<code class="fe nt nu nv nw b"><strong class="kk iu">userrole</strong></code>处于多对多的关系。这就是sequelize处理数据规范化所需的全部工作，这意味着将交叉引用存储在<code class="fe nt nu nv nw b"><strong class="kk iu">userrole</strong></code>表中。</p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><h1 id="77a1" class="ma mb it bd mc md os mf mg mh ot mj mk jz ou ka mm kc ov kd mo kf ow kg mq mr bi translated">获取数据</h1><p id="0ccc" class="pw-post-body-paragraph ki kj it kk b kl ox ju kn ko oy jx kq kr oz kt ku kv pa kx ky kz pb lb lc ld im bi translated">该项目提供了GraphQL playground，可以在<a class="ae ln" href="http://localhost:4000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:4000 </a>访问。在这里，我们现在可以利用GraphQL的能力从我们之前创建的表中请求非常具体的数据。</p><h2 id="2ea5" class="og mb it bd mc pd pe dn mg pf pg dp mk kr ph pi mm kv pj pk mo kz pl pm mq pn bi translated">查询数据自:组织</h2><p id="383e" class="pw-post-body-paragraph ki kj it kk b kl ox ju kn ko oy jx kq kr oz kt ku kv pa kx ky kz pb lb lc ld im bi translated">要显示所有已知的<strong class="kk iu">组织</strong>，请使用以下graphQL查询:</p><pre class="lp lq lr ls gt oc nw od oe aw of bi"><span id="9d6d" class="og mb it nw b gy oh oi l oj ok">query {<br/>  org {<br/>    count<br/>    data {<br/>      id<br/>      name<br/>    }<br/>  }<br/>}</span></pre><p id="b4a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到了一个很好的数据回复(组织数组)和一个计数:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi pz"><img src="../Images/651b9f4df63ec17860441c4b533e1a64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GlO7v3CDMgqsk5W69RWJSg.png"/></div></div></figure><p id="2a5c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本例中对PostgreSQL的查询如下所示:</p><pre class="lp lq lr ls gt oc nw od oe aw of bi"><span id="49e3" class="og mb it nw b gy oh oi l oj ok">SELECT “id”, “name” FROM “public”.”org” AS “org” WHERE 1=1;</span></pre><h2 id="75c3" class="og mb it bd mc pd pe dn mg pf pg dp mk kr ph pi mm kv pj pk mo kz pl pm mq pn bi translated">查询数据来源:角色</h2><p id="eb98" class="pw-post-body-paragraph ki kj it kk b kl ox ju kn ko oy jx kq kr oz kt ku kv pa kx ky kz pb lb lc ld im bi translated">让我们对<strong class="kk iu">角色做同样的事情，</strong>但是这里我们跳过检索数据的计数和id:</p><pre class="lp lq lr ls gt oc nw od oe aw of bi"><span id="0eea" class="og mb it nw b gy oh oi l oj ok">query {<br/>  role {<br/>    data {<br/>      name<br/>    }<br/>  }<br/>}</span></pre><p id="f02b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在数据阵列中获得了一组非常具体的角色名称:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi qa"><img src="../Images/00c14873bfbf09f2f1e37cd6a3232c96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Xtp7WTqD_YnWqQmomHjYw.png"/></div></div></figure><p id="3dbf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本例中对PostgreSQL的查询如下:</p><pre class="lp lq lr ls gt oc nw od oe aw of bi"><span id="0cfc" class="og mb it nw b gy oh oi l oj ok">SELECT "name" FROM "public"."role" AS "role" WHERE 1=1;</span></pre><p id="dc94" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相当整洁，但还没有太花哨。让我们看一下<strong class="kk iu">用户</strong>，这里我们与<strong class="kk iu">组织</strong>和<strong class="kk iu">角色</strong>的1-n和n-m关系汇集在一起:</p><h2 id="81d4" class="og mb it bd mc pd pe dn mg pf pg dp mk kr ph pi mm kv pj pk mo kz pl pm mq pn bi translated">查询数据来源:用户</h2><p id="c582" class="pw-post-body-paragraph ki kj it kk b kl ox ju kn ko oy jx kq kr oz kt ku kv pa kx ky kz pb lb lc ld im bi translated">以下查询将请求用户的详细信息，包括组织名称和用户拥有的角色列表:</p><pre class="lp lq lr ls gt oc nw od oe aw of bi"><span id="c8c1" class="og mb it nw b gy oh oi l oj ok">query {<br/>  user {<br/>    count<br/>    data {<br/>      serial<br/>      firstName<br/>      lastName<br/>      org {<br/>        name<br/>      }<br/>      roles {<br/>        name<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="8d24" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在看到，<strong class="kk iu"> org </strong>和<strong class="kk iu"> roles </strong>作为嵌套对象嵌入到用户记录中，然而<strong class="kk iu"> org </strong>由一个JSON对象表示，因为<strong class="kk iu">用户</strong>只能与一个组织相关联，而<strong class="kk iu"> roles </strong>作为一个JSON对象数组出现，因为一个用户可以有多个角色(就像Tina一样):</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi qb"><img src="../Images/0fb6bd5636bbe583b1c33db5d1fcaacd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cy7w6Y9JOPRsaM9CgHywWQ.png"/></div></div></figure><p id="32c1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本例中对PostgreSQL的查询如下:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="po pp l"/></div></figure><h1 id="1fa1" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">摘要</h1><p id="86b9" class="pw-post-body-paragraph ki kj it kk b kl ox ju kn ko oy jx kq kr oz kt ku kv pa kx ky kz pb lb lc ld im bi translated">我们已经看到了如何管理一个非常简单的关系数据模型，并通过Sequelize将它从PostgreSQL映射到JSON。为了方便用户，JSON数据通过GraphQL传递给用户。</p><p id="47eb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，重点是只读操作。我计划提供另一篇关于完整CRUD操作的文章。敬请关注…</p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><p id="2a12" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你喜欢这个故事，并想在medium上阅读成千上万个这样的故事，你可以成为medium会员，每月仅需5美元。如果你愿意支持我的写作，请使用我下面的推荐链接，我将免费获得你的一部分会员资格。</p><p id="4f2d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae ln" href="https://medium.com/@thomas.reinecke/membership" rel="noopener"><strong class="kk iu">https://medium.com/@thomas.reinecke/membership</strong></a></p></div></div>    
</body>
</html>