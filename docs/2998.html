<html>
<head>
<title>Simplify your npm publish workflow using Github Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Github操作简化您的npm发布工作流程</h1>
<blockquote>原文：<a href="https://itnext.io/simplify-your-npm-publish-workflow-using-github-actions-691249bc7e59?source=collection_archive---------3-----------------------#2019-09-13">https://itnext.io/simplify-your-npm-publish-workflow-using-github-actions-691249bc7e59?source=collection_archive---------3-----------------------#2019-09-13</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><p id="612d" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">Github最近增加的新功能Github Actions向我们承诺了一个强大的工作流系统来处理大量的任务。我们这些发布Node.js包的人可以使用动作来自动运行测试，然后将包发布到npm。让我们看看如何使用Github操作来简化我们的生活。</p><p id="3d01" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">目前，Github Actions处于公开测试阶段，只对注册用户开放——参见:<a class="ae kp" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank">https://github.com/features/actions</a>注册，并阅读文档。</p><p id="75cd" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">Github动作的基本概念是一个动作由一个事件触发。每个<em class="kq">动作</em>都是使用YAML文件编写的一组潜在的非常复杂的步骤。在这种情况下，我们将创建一个由<em class="kq"> push </em>事件触发的动作，或者每当一个新的提交被推送到存储库时触发的动作。该脚本将运行我们的单元测试，然后尝试运行<code class="fe kr ks kt ku b">npm publish</code>。</p><p id="11e0" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">一旦您的帐户启用了操作功能，您将在每个存储库中找到一个<em class="kq">操作</em>选项卡。</p><figure class="kw kx ky kz gu la gi gj paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gi gj kv"><img src="../Images/982f27f89be5a5606f5b876d15829ecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZV5QbRXq1vUi765u.jpg"/></div></div></figure><p id="9404" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">有很多可用的文档，也许有一天阅读一下会很有用。但是让我们直接开始创建一个工作流。您会发现启动工作流列表中有一个是Node.js的，单击它为我们提供一个起点。</p><p id="9681" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在这篇教程中，我使用了我的一个包，<a class="ae kp" href="https://github.com/robogeek/globfs" rel="noopener ugc nofollow" target="_blank"> Globfs </a>。你可以检查那个包裹来更全面地检查我做了什么。</p><p id="cce9" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我做了很多修改，所以我们不要担心他们提供的动作脚本，但看看这个:</p><pre class="kw kx ky kz gu lh ku li lj aw lk bi"><span id="e866" class="ll lm iu ku b gz ln lo l lp lq">name: Build and test Globfs  </span><span id="45c6" class="ll lm iu ku b gz lr lo l lp lq">on: [push]  </span><span id="01f7" class="ll lm iu ku b gz lr lo l lp lq">jobs:<br/>   build:</span><span id="0376" class="ll lm iu ku b gz lr lo l lp lq">      runs-on: ubuntu-latest</span><span id="0daa" class="ll lm iu ku b gz lr lo l lp lq">      strategy:<br/>        matrix:<br/>         node-version: [12.x]</span><span id="6ade" class="ll lm iu ku b gz lr lo l lp lq">      steps:<br/>      - uses: actions/checkout@v1<br/>      - name: Use Node.js ${{ matrix.node-version }}<br/>        uses: actions/setup-node@v1<br/>        with:<br/>          node-version: ${{ matrix.node-version }}<br/>      - name: npm install and npm test<br/>        run: |<br/>          npm run setup-test<br/>          npm run test<br/>      - name: npm publish<br/>        run: |<br/>          npm config set //registry.npmjs.org/:_authToken=$NODE_AUTH_TOKEN<br/>          npm run trypublish<br/>        env:<br/>          CI: true<br/>          NODE_AUTH_TOKEN: ${{ secrets.NPM_AUTH_TOKEN }}</span></pre><p id="2ff2" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">当您创建这个脚本时，Github会自动将其添加到您的存储库中，命名为<code class="fe kr ks kt ku b">.github/workflows/workflow-name.yml</code>。在我的例子中，我将其命名为<code class="fe kr ks kt ku b">push.yml</code>,因为它处理<code class="fe kr ks kt ku b">push</code>事件。</p><h1 id="562f" class="ls lm iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">走过<code class="fe kr ks kt ku b">push.yml</code>动作脚本</h1><p id="baba" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated"><code class="fe kr ks kt ku b">name</code>字段只是给出了一个人类可读的名称，所以可以使用任何您喜欢的名称。<code class="fe kr ks kt ku b">on</code>字段声明这将触发的事件，在这种情况下，动作在<code class="fe kr ks kt ku b">push</code>事件上触发。</p><p id="c1a0" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">当事件触发时，执行<code class="fe kr ks kt ku b">jobs</code>字段。这个任务在一个名为<code class="fe kr ks kt ku b">ubuntu-latest</code>的Docker容器上运行，这个容器非常适合我们的目的。</p><p id="3475" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><code class="fe kr ks kt ku b">steps</code>字段是要执行的步骤列表。第一个是<code class="fe kr ks kt ku b">actions/checkout@v1</code>，简单地签出工作区。</p><p id="04c4" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我将顺便提一下，Github Actions允许我们重用其他现有的动作。在本例中，我们重用了Github工作区<code class="fe kr ks kt ku b">actions/checkout</code>中定义的一个动作，您会发现它签出了Git存储库。</p><p id="cd6e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">下一步是设置Node.js。<code class="fe kr ks kt ku b">strategy/matrix</code>字段让我们设置一个node . js发布的数组来运行操作。在这种情况下，我们只想在Node.js 12上运行，因为这是这个包所支持的。运行时<code class="fe kr ks kt ku b">actions/setup-node</code>设置相应的Node.js运行时。</p><p id="56e6" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">下一步，<em class="kq"> npm安装和npm测试</em>，处理软件包的测试。为了支持这一点，我在顶层<code class="fe kr ks kt ku b">package.json</code>中添加了以下脚本:</p><pre class="kw kx ky kz gu lh ku li lj aw lk bi"><span id="9c8f" class="ll lm iu ku b gz ln lo l lp lq">"scripts": {<br/>     "setup-test": "cd test &amp;&amp; npm run setup",<br/>     "test": "cd test &amp;&amp; npm run test" <br/>}</span></pre><p id="484e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">每个都简单地进入<code class="fe kr ks kt ku b">test</code>目录，并在那里运行相应的脚本。在<code class="fe kr ks kt ku b">test</code>目录中，我添加了这个<code class="fe kr ks kt ku b">package.json</code>:</p><pre class="kw kx ky kz gu lh ku li lj aw lk bi"><span id="9304" class="ll lm iu ku b gz ln lo l lp lq">{<br/>   "name": "globfs-test",<br/>   "version": "1.0.0",<br/>   "description": "Test suite for globfs",<br/>   "main": "index.js",<br/>   "scripts": {<br/>     "test": "mocha ./index",<br/>     "setup": "npm install &amp;&amp; cd .. &amp;&amp; npm install"<br/>   },<br/>   "author": "",<br/>   "license": "ISC",<br/>   "dependencies": {<br/>     "chai": "^4.1.2",<br/>     "mocha": "^5.2.0"<br/>   }<br/>}</span></pre><p id="2d87" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">显然<code class="fe kr ks kt ku b">test</code>脚本需要<code class="fe kr ks kt ku b">index.js</code>中的测试套件。我使用Mocha和Chai断言库创建了一个，如果您愿意，可以在Globfs存储库中阅读。重要的是<code class="fe kr ks kt ku b">test</code>脚本可靠地执行测试套件，并且如果测试套件失败，它可靠地显示错误状态。</p><p id="749f" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">如果测试失败，动作脚本就会失败，Github会通过电子邮件将错误日志发送给我们。如果测试脚本成功了，那太好了，动作脚本将进入下一阶段。</p><p id="caa3" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">动作脚本的最后一个阶段，<em class="kq"> npm publish </em>，是我们发布包的地方。理论上这只是运行<code class="fe kr ks kt ku b">npm publish</code>的问题，但是有几个问题需要考虑。例如，如果您在已经发布的包目录上运行<code class="fe kr ks kt ku b">npm publish</code>, NPM服务器将会抛出一个错误，提示您不能在现有的包上发布包。</p><p id="e446" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我的策略是，如果测试成功，总是运行<code class="fe kr ks kt ku b">npm publish</code>。如果<code class="fe kr ks kt ku b">package.json</code>中的版本字符串已经改变，那么一切正常，因为<code class="fe kr ks kt ku b">npm publish</code>会将包推送到存储库。相反，如果版本号没有改变，将会抛出一个错误，看起来好像作业失败了。但是因为我们不关心<code class="fe kr ks kt ku b">npm publish</code>命令是否失败，我们可以用这个古老的奇怪的shell脚本技巧来避免失败。</p><p id="1ccd" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在顶层<code class="fe kr ks kt ku b">package.json</code>中，我添加了这个脚本:</p><pre class="kw kx ky kz gu lh ku li lj aw lk bi"><span id="8381" class="ll lm iu ku b gz ln lo l lp lq">"scripts": {<br/>     ...<br/>     "trypublish": "npm publish || true"<br/>},</span></pre><p id="e9f8" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">使用<code class="fe kr ks kt ku b">trypublish</code>我们尝试运行<code class="fe kr ks kt ku b">npm publish</code>，如果失败，则使用<code class="fe kr ks kt ku b">|| true</code>抑制错误。看看这个shell脚本技术，它是20世纪70年代发明的一个了不起的东西。</p><p id="1ba0" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">但是仔细看看<code class="fe kr ks kt ku b">push.yml</code>中的<em class="kq"> npm发布</em>阶段。这里有更多的东西涉及到一个<code class="fe kr ks kt ku b">npm config</code>命令。这是怎么回事？</p><p id="ce83" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">为了发布到npm，我们需要一个授权令牌。让它发挥作用需要一个额外的旅程，我希望能帮助你避免。</p><h1 id="5f3d" class="ls lm iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">设置npm令牌进行身份验证，以便从Github操作工作流脚本发布到npm</h1><p id="1a4b" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated">据说为了认证<code class="fe kr ks kt ku b">npm publish</code>，我们简单地将一个npm令牌放入一个环境变量中，然后神奇地一切都正常了。根据<a class="ae kp" href="https://blog.npmjs.org/post/118393368555/deploying-with-npm-private-modules" rel="noopener ugc nofollow" target="_blank"> npm博客</a>的说法，验证npm的标准方法是将这一行添加到<code class="fe kr ks kt ku b">~/.npmrc</code>。</p><pre class="kw kx ky kz gu lh ku li lj aw lk bi"><span id="0c73" class="ll lm iu ku b gz ln lo l lp lq">//registry.npmjs.org/:_authToken=00000000-0000 -0000 -0000 -000000000000</span></pre><p id="5393" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">但是在上面的动作脚本里那就不方便了。博客文章接着说我们可以做到这一点:</p><pre class="kw kx ky kz gu lh ku li lj aw lk bi"><span id="99aa" class="ll lm iu ku b gz ln lo l lp lq">$ export NPM_TOKEN="00000000-0000-0000-0000-000000000000"</span></pre><p id="9cde" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">但是我没有找到有效的环境变量。在<code class="fe kr ks kt ku b">actions/setup-node</code>行动的文档中也没有这个咒语:</p><pre class="kw kx ky kz gu lh ku li lj aw lk bi"><span id="16f9" class="ll lm iu ku b gz ln lo l lp lq">- run: npm publish<br/>   env:<br/>     NODE_AUTH_TOKEN: ${{ secrets.NPM_AUTH_TOKEN }}</span></pre><p id="4657" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">相反，我花了几个小时寻找建议。我遇到了其他几个人，他们也浪费了几个小时的时间来解决同样的问题。</p><p id="6992" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">但是经过足够的阅读，我找到了一个可行的解决方案。</p><p id="4a35" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">让我们一步一步来，从创建npm令牌开始。</p><figure class="kw kx ky kz gu la gi gj paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gi gj mu"><img src="../Images/503affaead1af14a4417304c1af88873.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/0*pb6BrblubXmGm6Et.jpg"/></div></div></figure><p id="f1f7" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">登录<code class="fe kr ks kt ku b">npmjs.com</code>后，您会在帐户菜单中找到该选项。这会将您带到一个页面，您可以在其中创建(和撤销)令牌。</p><p id="0d89" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">只需点击<em class="kq">创建新令牌</em>按钮。它会问你几个问题，然后带你到一个显示新令牌的页面。一定要把这个令牌复制到一个安全的地方，因为这是你在这个宇宙中唯一一次看到这个令牌。</p><figure class="kw kx ky kz gu la gi gj paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gi gj mv"><img src="../Images/992c23b5f10ef2baeb5eea4e78e9dfaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Cd97_OfU9tsWpxTN.jpg"/></div></div></figure><p id="2952" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">下一步是转到Github存储库的Settings选项卡，添加一个包含给定令牌的密码。一旦使用Github创建了这个秘密，你将永远无法检查它的内容。</p><p id="3a11" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在Github Actions脚本中，我们通过以下方式访问这个秘密并将其添加到环境中:</p><pre class="kw kx ky kz gu lh ku li lj aw lk bi"><span id="6e22" class="ll lm iu ku b gz ln lo l lp lq">env:<br/>     NPM_TOKEN: ${{ secrets.NPM_AUTH_TOKEN }}</span></pre><p id="a326" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">但是这还不够，尽管关于认证令牌的<a class="ae kp" href="https://docs.npmjs.com/about-authentication-tokens" rel="noopener ugc nofollow" target="_blank"> npm文档是这么说的</a>。无论我使用什么环境变量，<code class="fe kr ks kt ku b">npm publish</code>都无法识别这个标记。只有在添加该命令时，它才起作用:</p><pre class="kw kx ky kz gu lh ku li lj aw lk bi"><span id="2f9c" class="ll lm iu ku b gz ln lo l lp lq">npm config set //registry.npmjs.org/:_authToken=$NPM_TOKEN</span></pre><p id="1f85" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这是必须添加到<code class="fe kr ks kt ku b">.npmrc</code>文件中的相同配置。该命令在Github为处理这项工作而开发的Docker容器中运行。</p><p id="2a98" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">一旦你这样做了，<code class="fe kr ks kt ku b">npm publish</code>命令就会像预期的那样工作。</p><h1 id="0696" class="ls lm iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">结论</h1><p id="3f7f" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated">这是Github行动的早期阶段。设置这个所涉及的工作比我们听说的关于Github动作的故事更难。有几个粗糙的边缘可以被理顺，使这项工作更加顺利。</p><p id="eb11" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这种自动化将帮助开发人员保持理智。考虑一下，如果测试Node.js包并将其发布到npm注册中心不是自动化的，您的生活会是什么样子。对于一个版本的每一次发布，您都需要在终端中键入所需的命令。如果您忘记了一个命令，或者忘记了一个参数，该怎么办？如果您忘记发布新版本，该怎么办？</p><p id="0e30" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">可能会发生各种各样的错误。自动化这一切肯定更可靠，这样您就有了可重复的过程。</p><p id="3d28" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">有一点是肯定的——Gitlab到目前为止比Github有优势，因为git lab早就有了CI/CD子系统。使用该系统，您可以将描述CI/CD工作流的YAML文件添加到存储库中，瞧，您已经实现了自动化。Github Actions特性更加灵活，可以让Gitlab的资金发挥作用。</p><p id="26c7" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><em class="kq">最初发表于</em><a class="ae kp" href="https://techsparx.com/nodejs/tools/publish-github.html" rel="noopener ugc nofollow" target="_blank">T5【https://techsparx.com】</a><em class="kq">。</em></p></div></div>    
</body>
</html>