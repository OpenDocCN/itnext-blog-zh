<html>
<head>
<title>Moving a company to microfront-end environment (kind of)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将公司转移到微前端环境(某种程度上)</h1>
<blockquote>原文：<a href="https://itnext.io/moving-a-company-to-microfront-end-environment-kind-of-ae1587dc103c?source=collection_archive---------5-----------------------#2021-11-14">https://itnext.io/moving-a-company-to-microfront-end-environment-kind-of-ae1587dc103c?source=collection_archive---------5-----------------------#2021-11-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/8bf472c7a31622b49099d967fd40c9f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*XwszRu3kC-MpuVLoP6fDbQ.png"/></div></figure><p id="4d4d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">随着公司的成长，它的用户界面也在成长，成为一个巨大的庞然大物，有如此多的移动部件和纠缠不清的东西，以至于令人难以忍受，开发体验很糟糕，开发团队害怕接触代码库。开发经验是我们在计算机环境(IDE/终端/等等)中寻找的东西，但通常不是在我们的代码库中。<br/>迁移到微前端架构将极大地改善我们的开发体验。负责一个更小的领域使得改变更容易，开发更快。但是一个大公司可能看不到你所看到的，像“<em class="ks">这样的说法是有效的…为什么改它</em>“经常被扔来扔去。<br/>我们该怎么办？</p><h1 id="6ada" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">假装直到你成功</h1><p id="f98a" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">当我们开发代码的新部分时，我们喜欢模仿数据结构，以使我们的生活更容易，并使您的代码尽可能快地运行。<br/> <strong class="jw ir"> <em class="ks">同样的想法也可以在项目的架构层面上实现。</em></strong><em class="ks"><br/></em><a class="ae lw" href="https://nx.dev/" rel="noopener ugc nofollow" target="_blank">NX</a>是一个神奇的项目，它的存在主要是为了管理你的monolith。<br/>它能够轻松创建多个角度/反应/Vue项目。为什么这很重要？<br/>我们可以创建新的小部件(域驱动)作为新的应用程序。这些组件封装有自己的逻辑和UI组件。每个应用程序导出所需的类/函数/任何东西，以便被其他人使用。<br/> <strong class="jw ir">本质上是一个没有remoteEntry部分的微前端。</strong></p><h1 id="63a0" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">好处</strong></h1><ol class=""><li id="b675" class="lx ly iq jw b jx lr kb ls kf lz kj ma kn mb kr mc md me mf bi translated">多个团队可以在不同的领域中开发同一个monolith，并且永远不会(几乎永远不会)发生冲突(git合并冲突)。</li><li id="b01c" class="lx ly iq jw b jx mg kb mh kf mi kj mj kn mk kr mc md me mf bi translated">允许我们重构旧代码，一个部件一个部件地改进我们的应用程序行为。</li><li id="0986" class="lx ly iq jw b jx mg kb mh kf mi kj mj kn mk kr mc md me mf bi translated">这是<strong class="jw ir">而不是</strong>一种“全有或全无”的心态，为了看到和测试结果，这可以逐渐完成。</li><li id="0266" class="lx ly iq jw b jx mg kb mh kf mi kj mj kn mk kr mc md me mf bi translated">生产仅构建已更改的应用程序，因此，如果仅更改了特定领域的应用程序，构建时间将会缩短。</li><li id="c2b0" class="lx ly iq jw b jx mg kb mh kf mi kj mj kn mk kr mc md me mf bi translated">过渡到使用实际的remoteEntry很简单</li><li id="7e1f" class="lx ly iq jw b jx mg kb mh kf mi kj mj kn mk kr mc md me mf bi translated">每个应用程序都可以作为独立的应用程序运行，并被其他应用程序使用。</li></ol><h1 id="bc95" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">所以为什么要这么麻烦呢？</h1><p id="9d0c" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">大公司中的活动部件移动缓慢，有许多区域没有考虑到，并且我们可能会被部门化。但是我们希望作为开发者和团队成长，不断推动自己前进。拥有一个没人想碰的庞然大物不会很快消失，但是我们可以开始将我们的应用程序分成域和小部件，以使开发周期更容易，并且不容易在周五/周四中断生产…</p><h1 id="6a40" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">领域驱动的应用</h1><p id="dd94" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">每个应用程序都有一个自己负责的领域，逻辑/服务/接口都包含在该领域的应用程序中，并输出给其他人使用。</p><p id="22d5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">例如:</strong> <br/>我们的应用程序有3页:<br/> 1。所有用户的列表。<br/> 2。单用户视图。<br/> 3。设置页面。</p><p id="fe04" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这个非常简单的webApp中，我们有3个领域应用程序。<br/> 1。shell(我们应用程序的入口点，主路由，高级布局在这里完成)<br/> 2。用户—列表和单一视图<br/> 3。设置</p><p id="d298" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">用户和设置页面之间没有联系，它们在同一个应用程序中只是巧合。因此它们可以彼此完全独立。他们不了解对方。一个团队可以开发用户应用程序，另一个团队可以开发设置应用程序，两者之间没有冲突。<br/>团队1可以不关心团队2所做的工作(在完美的世界中)。<br/>当第2组完成任务并希望推动他们的工作时。测试可以在领域驱动的应用程序级别上进行，因为只有一个应用程序受到了更改的影响，所以我们增加了对更新的信心。</p><h1 id="1edb" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="548c" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">将我们的整体结构分解成专注于领域的应用程序将会带来微前端带给我们的许多好处。虽然不一样，但我认为90%相似。<br/>更重要的是，通过摆脱束缚和DevOps，我们可以创建我们希望从mfe获得的同样简单的开发体验，并且当团队乐于修复/添加/删除领域应用程序中的内容而不用担心可能会受到影响(或者至少不那么担心)时，证明对它的需求。<br/>代码交付信心是这些年来经常被谈论的话题。你的领域越小，你对他们的信心就越大。</p><h1 id="d76e" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">灵感</h1><p id="46db" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">我强烈建议阅读<a class="ae lw" href="http://The Micro-Frontend Chaos (and how to solve it)" rel="noopener ugc nofollow" target="_blank">奥雷·巴利提<br/> <em class="ks">的《微前端的混乱(以及如何解决)】【T15》。</em> <br/>这篇文章讨论了微前端为什么不像基本演示看起来那样有用，以及如何解决这个问题以使生产就绪项目可以扩展。</a></p></div></div>    
</body>
</html>