<html>
<head>
<title>Git concepts for newcomers — Part 3: Commits, log and amend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">新人的Git概念—第3部分:提交、记录和修改</h1>
<blockquote>原文：<a href="https://itnext.io/git-concepts-for-newcomers-part-3-commits-log-and-amend-6dcbb05370c?source=collection_archive---------2-----------------------#2020-06-02">https://itnext.io/git-concepts-for-newcomers-part-3-commits-log-and-amend-6dcbb05370c?source=collection_archive---------2-----------------------#2020-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="72f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我的初学者Git概念系列的第三篇文章。如果你错过了<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/git-concepts-for-newcomers-part-1-what-is-a-dvcs-bc873076c424">关于什么是DVCS的第一篇文章</a>，或者第二篇关于<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/git-concepts-for-newcomers-part-2-git-repository-working-tree-and-staging-area-a2e720bf3528">不同区域的Git库的文章</a>，请先阅读这些文章。</p><ul class=""><li id="4c58" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">第一部分—什么是DVCS:<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/git-concepts-for-newcomers-part-1-what-is-a-dvcs-bc873076c424">https://it next . io/git-concepts-for-new York-part-1-What-is-a-dvcs-BC 873076 c 424</a></li><li id="5839" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">第2部分—工作树和暂存区:<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/git-concepts-for-newcomers-part-2-git-repository-working-tree-and-staging-area-a2e720bf3528">https://it next . io/git-concepts-for-new York-part-2-git-repository-Working-tree-and-staging-area-a2e 720 BF 3528</a></li><li id="48b3" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">第三部分—提交、记录和修改:<a class="ae ko" href="https://medium.com/@dSebastien/git-concepts-for-newcomers-part-3-commits-log-and-amend-6dcbb05370c" rel="noopener">https://medium . com/@ dSebastien/git-concepts-for-new York-part-3-Commits-log-and-amend-6 dcbb 05370 c</a></li><li id="89a7" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">part # 4-Branches:<a class="ae ko" href="https://medium.com/@dSebastien/git-concepts-for-newcomers-part-4-branches-52aee1da4385" rel="noopener">https://medium . com/@ dSebastien/git-concepts-for-新人-part-4-Branches-52 aee 1 da 4385</a></li></ul><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/c34b8a962b9211e5dd25da1e6b556bda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PxhZJ9kxVmIUbBbFtB4-8Q.jpeg"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">图片由<a class="ae ko" href="https://unsplash.com/@yancymin" rel="noopener ugc nofollow" target="_blank"> Yancy Min </a>提供</figcaption></figure><p id="6532" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本系列的第三篇文章中，我们将探索如何用Git创建和修改提交，以及如何查看提交日志。</p><h1 id="42e5" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">什么是提交？</h1><p id="c238" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated"><strong class="js iu">提交</strong>在Git中(以及任何版本控制系统，真的)超级重要。为了实际保存您的更改，您需要创建提交(即提交您的代码)。如果您不<em class="mw">提交</em>您的更改，那么它们可能会在任何时候丢失(例如，因为您的工作树中的错误操作或者如果您覆盖了您的临时区域的内容)。提交是Git的基本工作单元。</p><p id="fd0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，没有提交，你将无法与他人<em class="mw">分享</em>你的作品。</p><p id="4bf2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上一篇文章中，我已经解释了Git的staging area是如何工作的，并且我已经告诉你添加到这个区域的所有东西都是由Git跟踪的。</p><p id="0737" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您还记得，在使用了<code class="fe mx my mz na b">git add</code>命令之后，我们的“hello.txt”文件被添加到了临时区域(也就是索引)。一旦完成，<code class="fe mx my mz na b">git status</code>命令告诉我们以下内容:</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="ff49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我在上一篇文章中所说的，Git认为暂存区的任何部分都是接下来应该提交的内容。在上面的示例中，“hello.txt”文件已经准备好提交，因为它是临时区域的一部分。</p><p id="5372" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们一起看到Git的暂存区存储了添加到其中的文件/行的“快照”。但是我坚持认为，即使您可以从暂存区恢复文件(就像我们在上一篇文章中所做的那样)，它也不过是一个<em class="mw">临时</em>工作区；这是<em class="mw">而不是</em>你实际上<em class="mw">一劳永逸地保存</em>你的工作。</p><p id="4f1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">staging area只是一个工具，你可以用它来保存你的工作的快照和组装<em class="mw">提交。“组装”这个术语在这里非常重要。您可以选择在下一次提交中包含哪些文件，甚至哪些行，从而允许您创建仅包含相关内容的提交。</em></p><p id="4755" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是将文件添加到暂存区/索引<em class="mw">不会</em>创建提交，它只会<em class="mw">准备</em>您的下一次提交；记住这一区别很重要。要创建提交，您需要使用<code class="fe mx my mz na b">git commit</code>命令；我们很快就会知道了。</p><p id="db1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦基于登台区中的内容创建了提交，该内容就被添加/移动到存储库(我们在上一篇文章中讨论过的第三个区域)，并因此存储在。git "目录(即存储库)。因此，一旦创建了提交，暂存区将为空。</p><p id="fb7e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦创建了提交，即使工作树被完全删除(除了“.git文件夹)，即使临时区域被清除，您的内容仍然可以被恢复。</p><p id="9e97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以将提交视为存储在Git存储库中的长期且稳定的快照。提交是稳定的，因为Git永远不会修改提交<em class="mw">的内容，除非您明确要求它修改</em>(我们将在本文后面看到如何修改)。</p><h1 id="d56b" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">Git日志</h1><p id="1035" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">在我们创建第一个提交之前，让我们首先发现<strong class="js iu">提交日志</strong>。了解它是很有用的，因为你会一直用到它。</p><p id="e937" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">提交日志是Git存储库中所有提交的日志，首先显示最近的提交(除非您添加参数来更改内容/顺序)。</p><p id="9a67" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要显示日志，可以使用<code class="fe mx my mz na b">git log</code> <a class="ae ko" href="https://git-scm.com/docs/git-log" rel="noopener ugc nofollow" target="_blank">命令</a>。</p><p id="32b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是一个来自官方文档的提交日志示例:</p><pre class="le lf lg lh gt nd na ne nf aw ng bi"><span id="2476" class="nh lu it na b gy ni nj l nk nl">$ git log<br/>commit ca82a6dff817ec66f44342007202690a93763949<br/>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br/>Date:   Mon Mar 17 21:52:11 2008 -0700<br/><br/>    Change version number<br/><br/>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7<br/>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br/>Date:   Sat Mar 15 16:40:33 2008 -0700<br/><br/>    Remove unnecessary test<br/><br/>commit a11bef06a3f659402fe7563abf99ad00de2209e6<br/>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br/>Date:   Sat Mar 15 10:31:28 2008 -0700<br/><br/>    Initial commit<!-- --> </span></pre><p id="950d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如您在上面看到的，默认情况下，每个提交都列出了:</p><ul class=""><li id="2285" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated"><strong class="js iu">提交哈希:</strong>唯一标识本次提交，对应提交内容的哈希</li><li id="becb" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><strong class="js iu">提交作者</strong></li><li id="9a17" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><strong class="js iu">创建日期/时间</strong></li><li id="4167" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><strong class="js iu">提交消息</strong></li></ul><p id="58bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们把(大量的)技术细节放在一边，那么您现在知道了提交由最重要的信息组成；除了实际的修改。</p><p id="aba4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在后面的文章中，我将分享一些bash别名，您可以使用它们来查看更实用的日志。</p><p id="d4ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您查看我们的测试存储库的提交日志，就不会这么有趣了:</p><pre class="le lf lg lh gt nd na ne nf aw ng bi"><span id="6097" class="nh lu it na b gy ni nj l nk nl">$ git log<br/>fatal: your current branch 'master' does not have any commits yet</span></pre><p id="a676" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实上，因为我们还没有创建一个提交，所以这里没什么可看的。让我们现在就解决这个问题！</p><p id="6260" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以在这里了解更多关于git log命令<a class="ae ko" href="https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><h1 id="5e47" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">如何创建提交</h1><p id="0b61" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">一旦使用<code class="fe mx my mz na b">git add</code>命令进行了修改，创建提交就非常容易了；你只需要调用<code class="fe mx my mz na b">git commit</code> <a class="ae ko" href="https://git-scm.com/docs/git-commit" rel="noopener ugc nofollow" target="_blank">命令</a>。这个命令是你最常用的命令，还有<code class="fe mx my mz na b">git add</code>。</p><p id="e3c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">像大多数Git命令一样，<a class="ae ko" href="https://git-scm.com/docs/git-commit" rel="noopener ugc nofollow" target="_blank"> git commit </a>有许多选项。这里我们只探讨几个基本的。</p><p id="e6dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">继续从您的工作树中执行<code class="fe mx my mz na b">git commit</code>命令(假设您仍然将我们之前所做的修改添加到登台区):</p><pre class="le lf lg lh gt nd na ne nf aw ng bi"><span id="633e" class="nh lu it na b gy ni nj l nk nl">git commit</span></pre><p id="11e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦您这样做了，Git将打开默认编辑器(在我的例子中是vim)让您输入<strong class="js iu">提交消息</strong>。提交消息应该描述您提交到存储库的一组变更:</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="7f93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完成后，保存文件并关闭编辑器。之后，Git将在存储库中实际创建提交:</p><pre class="le lf lg lh gt nd na ne nf aw ng bi"><span id="ac0d" class="nh lu it na b gy ni nj l nk nl">$ git commit<br/>[master (root-commit) d0f8595] Added the hello world example<br/> 1 file changed, 1 insertion(+)<br/> create mode 100644 hello.txt</span></pre><p id="749a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如你在上面看到的:</p><ul class=""><li id="edb2" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">Git创建了一个commit，它改变了一个新创建的文件:“hello.txt”</li><li id="f2c1" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">该提交有一个特定的消息:“添加了hello world示例”</li><li id="3f82" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">那个commit有一个特定的hash: d0f8595(注意实际的hash要长得多，但是Git通常只显示短的7个字符的版本；你可以在这里<a class="ae ko" href="https://stackoverflow.com/questions/43665836/in-git-what-is-the-difference-between-long-and-short-hashes#:~:text=A%20short%20hash%20is%20just,c26cf8af130955c5c67cfea96f9532680b963628%20you%20were%20looking%20for.&amp;text=The%20short%20hash%20shows%20the%20first%20seven%20characters%20of%20the%20hash." rel="noopener ugc nofollow" target="_blank">了解更多信息</a></li></ul><p id="7e34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">既然您的提交已经创建，您可以使用<code class="fe mx my mz na b">git status</code>来查看状态:</p><pre class="le lf lg lh gt nd na ne nf aw ng bi"><span id="c544" class="nh lu it na b gy ni nj l nk nl">$ git status<br/>On branch master<br/>nothing to commit, working tree clean</span></pre><p id="e971" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">既然已经创建了提交:</p><ul class=""><li id="cf58" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">我们的工作树是“干净的”；它与存储库的内容完全匹配</li><li id="0edd" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">暂存区是空的，因为我们放在那里的快照现在已经作为提交的一部分被移动到存储库中</li></ul><p id="22e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太好了！最后但同样重要的是，我们现在可以再次查看提交日志:</p><pre class="le lf lg lh gt nd na ne nf aw ng bi"><span id="50a3" class="nh lu it na b gy ni nj l nk nl">$ git log<br/>commit d0f8595d422d8c9dd5c55afd88a3052b19af6e5a (HEAD -&gt; refs/heads/master)<br/>Author: Seb &lt;<a class="ae ko" href="mailto:seb@dsebastien.net" rel="noopener ugc nofollow" target="_blank">seb@developassion</a>.be&gt;<br/>Date:   Tue Jun 2 15:15:17 2020 +0200</span><span id="402a" class="nh lu it na b gy nm nj l nk nl">Added the hello world example</span></pre><p id="f767" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这次的日志更有趣；我们现在看到我们的提交确实已经被添加到Git存储库中，因此安全地存储在。git文件夹。</p><p id="0c34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">附注:在日志的第一行，您可以看到我们提交的完整散列。之后还有一个“隐晦”的提及:<code class="fe mx my mz na b">(HEAD -&gt; refs/heads/master)</code>。我会在下一篇文章中解释清楚，当我们发现什么分支是T8，它们是如何工作的，以及分支的“头”是什么。</p><p id="d622" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">额外的好处:如果你想在头脑中已经有一个好的心智模型，那么接受我们的提交已经被添加到“主”分支的想法，因为它是当前被检出并显示在我们的工作树中的分支。除非我们切换到不同的分支，否则我们的提交将是该分支的一部分。此外，通过创建提交，我们已经向前移动了分支的头部(也称为<em class="mw"> tip </em>);它现在指向我们新创建的提交。这意味着，如果我们切换到不同的分支并再次签出主文件，我们将处于历史中完全相同的点。如果这还不清楚，不要担心；很正常。我将在下一篇文章中回到这个问题。</p><p id="6dc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有一些关于<code class="fe mx my mz na b">git commit</code>命令的有用提示:</p><ul class=""><li id="ba63" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">你可以这样直接传递消息:<code class="fe mx my mz na b">git commit -m 'Insert your message here'</code></li><li id="350a" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">您可以添加<code class="fe mx my mz na b">— dry-run</code>参数来查看提交将会做什么，而不用实际去做</li><li id="b828" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">如果你意识到你犯了一个错误，你可以在创建一个提交后立即使用<code class="fe mx my mz na b">git reset</code> <a class="ae ko" href="https://git-scm.com/docs/git-reset" rel="noopener ugc nofollow" target="_blank">命令</a>。这将删除提交并将相应的更改放回临时区域。请注意，只有在分支中至少有两次提交时，该命令才会起作用。你可以在这里找到更多关于这个<a class="ae ko" href="https://devconnected.com/how-to-undo-last-git-commit/" rel="noopener ugc nofollow" target="_blank">的信息</a></li><li id="bd21" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">可以用<code class="fe mx my mz na b">git commit --all</code>让git自动检测修改/删除(不是新的！)文件，将它们添加到索引中，然后提交它们；一步到位。虽然，我真的不建议这样。精确地选择应该添加的内容会更安全、更干净，这样您的提交会更干净、更切题。当你迭代你的代码时，这个选项可能是有用的，但是如果你真的使用它，那么你绝对应该在与他人分享之前重做你的提交；否则你会把你的Git日志弄得一团糟(这是一个非常普遍的问题)</li><li id="cd3f" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">您可以使用<code class="fe mx my mz na b">git commit --patch</code>交互地选择提交中包含的内容。我提到了它，但实际上我建议使用可视化Git工具，它对用户友好得多</li><li id="0280" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">您可以使用<code class="fe mx my mz na b">— no-verify</code>标志绕过预提交和提交消息挂钩。我们将在本系列的后面学习钩子，因为它是一个高级主题。在创建提交之前具有自动行为的项目中，或者在验证提交消息符合特定约定时，该标志通常是有用的，因为在某些情况下，您不需要/不希望整个shabang运行</li></ul><p id="76a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，现在继续创建数百万个提交。不要担心，在你工作的时候，尽可能多的创建一些。正如我将在接下来的文章中向您展示的，您可以使用Git轻松地修改/重组/重新排序/等等您的提交(稍后我会告诉您一些注意事项)。</p><h1 id="3de3" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">SVN提交与Git提交</h1><p id="73af" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">对于那些来自SVN的人，我想花点时间来澄清一些你们可能对Git提交的误解。</p><p id="fc38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Git提交和SVN提交根本不是一回事。以下是一些需要记住的主要区别:</p><ul class=""><li id="c70b" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">使用SVN，提交是在中央存储库上创建的，并且需要它可用才能提交；Git就不是这样了。Git提交是在本地创建/存储的，不依赖于任何其他系统/服务器/存储库的可用性</li><li id="d90f" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">SVN跟踪差异(即，提交代表前一版本和下一版本之间的差异)，而Git创建整个文件的快照。如果您创建了3个对同一个文件的不同修改的提交，Git实际上将保存该文件三次。这对性能非常有益，因为Git不需要像SVN那样通过一次又一次地应用diff来重组文件。相反，它总是有完整的文件随时可用。不要担心性能；它工作得非常好。顺便说一下，这种基于快照的设计对Git中的许多事情都有巨大的影响(例如，在分支之间切换时的性能)</li></ul><h1 id="e422" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">用修正来修正错误</h1><p id="ab20" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">如果你创建了一个提交并意识到你犯了一个错误；例如，如果您忘记在提交中添加一个文件，那么您可以使用<code class="fe mx my mz na b">git commit</code>的<code class="fe mx my mz na b">--amend</code>标志轻松修改最后一次提交。</p><p id="303c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，您只需使用<code class="fe mx my mz na b">git add</code>发布您的附加变更(或者取消先前变更的变更)。然后执行<code class="fe mx my mz na b">git commit --amend</code>。</p><p id="2606" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们试一试。目前，你的工作树应该是干净的。让我们对“hello.txt”做一些修改:</p><pre class="le lf lg lh gt nd na ne nf aw ng bi"><span id="1e8d" class="nh lu it na b gy ni nj l nk nl">$ echo "Git is cool" &gt;&gt; hello.txt<br/>$ cat hello.txt<br/>Hello world<br/>Git is cool</span></pre><p id="740b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，检查新状态:</p><pre class="le lf lg lh gt nd na ne nf aw ng bi"><span id="d003" class="nh lu it na b gy ni nj l nk nl">$ git status<br/>On branch master<br/>Changes not staged for commit:<br/> modified:   hello.txt</span><span id="f2cd" class="nh lu it na b gy nm nj l nk nl">no changes added to commit</span></pre><p id="e2f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，将更改添加到索引中，并再次显示状态:</p><pre class="le lf lg lh gt nd na ne nf aw ng bi"><span id="9e32" class="nh lu it na b gy ni nj l nk nl">$ git add -A<br/>$ git status<br/>On branch master<br/>Changes to be committed:<br/> modified:   hello.txt</span></pre><p id="d5aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好的，在这一点上我们可以创建一个新的提交，但是我们想要的是更新我们之前的提交，以包含我们的阶段性变化。我们可以使用<code class="fe mx my mz na b">--amend</code>标志轻松做到这一点:</p><pre class="le lf lg lh gt nd na ne nf aw ng bi"><span id="7600" class="nh lu it na b gy ni nj l nk nl">$ git commit --amend<br/>[master 7750f16] Added the hello world example<br/> Date: Tue Jun 2 15:15:17 2020 +0200<br/> 1 file changed, 2 insertions(+)<br/> create mode 100644 hello.txt<br/>$ git status<br/>On branch master<br/>nothing to commit, working tree clean</span></pre><p id="afe3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，工作树现在又干净了。如果我们要求Git向我们展示由我们的提交引入的差异，我们可以看到我们的新行确实包含在我们的提交中:</p><pre class="le lf lg lh gt nd na ne nf aw ng bi"><span id="7d04" class="nh lu it na b gy ni nj l nk nl">$ git log -c<br/>commit 7750f167330c17ae08193cbe03d5c5c89a91bb4c (HEAD -&gt; refs/heads/master)<br/>Author: Seb &lt;<a class="ae ko" href="mailto:seb@dsebastien.net" rel="noopener ugc nofollow" target="_blank">seb@d</a>evelopassion.be&gt;<br/>Date:   Tue Jun 2 15:15:17 2020 +0200</span><span id="d5d7" class="nh lu it na b gy nm nj l nk nl">Added the hello world example</span><span id="4b1e" class="nh lu it na b gy nm nj l nk nl">diff --git a/hello.txt b/hello.txt<br/>new file mode 100644<br/>index 0000000..cf3b027<br/>--- /dev/null<br/>+++ b/hello.txt<br/>@@ -0,0 +1,2 @@<br/>+Hello world<br/>+Git is cool</span></pre><p id="42d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很酷，对吧？</p><p id="e049" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">修复提交非常有用，但是在这样做的时候，您必须始终保持谨慎，因为它确实会改变您的git存储库的历史。</p><p id="45b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还有一些其他git命令也可以重写历史；我将在后面的系列文章中告诉您这些内容。</p><p id="8dbb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">改变历史本身并不是一个问题，但这是你丢失改变的一种方式。老实说，通常有一些方法仍然可以恢复你的数据，但是这样做可能会变得很难。</p><p id="2630" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更重要的是，如果相关的分支/提交已经被其他人共享，你永远不应该重写Git存储库的历史，因为这会导致各种令人讨厌的问题。就像时间旅行一样。你可以回到过去，但永远不要改变历史，否则一切都会失控^^.</p><h1 id="0a12" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">结论</h1><p id="b294" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">在本文中，我向您介绍了几个新的Git命令，它们允许您真正保存您的工作并查看您的存储库的历史。我还向您展示了可以用来改写历史的第一个工具。</p><p id="6903" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于Git还有很多东西需要学习，但是你已经取得了很大的进步。速度没那么重要；重要的是理解。如果你对正在发生的事情有一个清晰的认识，一步一步，那么你将很快成为Git大师！</p><p id="ad1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本系列的下一篇文章中，我将最后介绍分支，Git最酷的特性之一。</p><p id="7a80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">今天到此为止！</p><h1 id="f905" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">喜欢这篇文章吗？点击下面“喜欢”按钮查看更多内容，并确保其他人也能看到！</h1><p id="984f" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">PS:如果你想学习大量关于软件/Web开发、TypeScript、Angular、React、Vue、Kotlin、Java、Docker/Kubernetes和其他很酷的主题的其他很酷的东西，那么不要犹豫<a class="ae ko" href="https://www.amazon.com/Learn-TypeScript-Building-Applications-understanding-ebook/dp/B081FB89BL" rel="noopener ugc nofollow" target="_blank">拿一本我的书</a>并订阅<a class="ae ko" href="https://mailchi.mp/fb661753d54a/developassion-newsletter" rel="noopener ugc nofollow" target="_blank">我的时事通讯</a>！</p></div></div>    
</body>
</html>