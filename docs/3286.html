<html>
<head>
<title>Seccomp in Kubernetes — Part I: 7 things you should know before you even start!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes中的Seccomp第一部分:开始之前你应该知道的7件事！</h1>
<blockquote>原文：<a href="https://itnext.io/seccomp-in-kubernetes-part-i-7-things-you-should-know-before-you-even-start-97502ad6b6d6?source=collection_archive---------0-----------------------#2019-11-14">https://itnext.io/seccomp-in-kubernetes-part-i-7-things-you-should-know-before-you-even-start-97502ad6b6d6?source=collection_archive---------0-----------------------#2019-11-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/12fdf7c3b9e666d1725a9fb2601f779b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fNqW6bkjbsq627DyfwPQgw.png"/></div></div></figure><div class=""/><div class=""><h2 id="8e5d" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">这是关于如何在不使用魔法或巫术的情况下以SecDevOpsy方式获得优秀seccomp个人资料的系列文章中的第一篇。在第一部分中，我将介绍Kubernetes seccomp实现的基础和内部原理。</h2></div><p id="e64f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">Kubernetes生态系统有相当多的安全特性来保持你的容器安全和隔离。在这里，我将讨论安全计算模式(又名<strong class="ks jc"> seccomp </strong>)特性，它主要限制容器能够执行的系统调用。</p><p id="9fa6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为什么这很重要？嗯，容器实际上只是一个在给定机器内部运行的进程。它与所有其他应用程序共享内核。如果所有容器都能够进行任何系统调用，那么恶意程序很快就会绕过容器隔离并影响其他应用程序—窃听信息、更改系统级设置等。</p><p id="13ac" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">您的seccomp配置文件定义了应该允许或阻止哪些系统调用，容器运行时将在容器启动时应用，以便内核可以强制执行。一旦应用，您就有效地减少了您的攻击面，并限制了在您的容器内的任何东西(即，您的依赖项，或它们的依赖项……)开始做它们不应该被允许做的事情时的损害。</p><h1 id="f9a0" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">了解基本情况</h1><p id="1824" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">一个基本秒钟有三个关键要素:第<code class="fe mj mk ml mm b">defaultAction</code>、<code class="fe mj mk ml mm b">architectures</code>(或<code class="fe mj mk ml mm b">archMap</code>)和<code class="fe mj mk ml mm b">syscalls</code>:</p><figure class="mn mo mp mq gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="821a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe mj mk ml mm b">defaultAction</code>定义了对于没有在<code class="fe mj mk ml mm b">syscalls</code>部分列出的任何系统调用，默认情况下会发生什么。为了简单起见，让我们把重点放在您将使用的两个主要值上:<code class="fe mj mk ml mm b">SCMP_ACT_ERRNO</code>将阻止系统调用的执行，而<code class="fe mj mk ml mm b">SCMP_ACT_ALLOW</code>执行它在tin中所说的内容。</p><p id="229a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">元素<code class="fe mj mk ml mm b">architectures</code>定义了你的目标架构。这很重要，因为在内核级应用的实际过滤器是基于系统调用id，而不是您在配置文件中定义的名称。容器运行时会在应用它之前将其转换成id。这一点的重要性在于，系统调用可能有不同的id，这取决于它们运行的架构。例如，用于从套接字接收信息的系统调用<code class="fe mj mk ml mm b">recvfrom</code>在x64系统中是id <code class="fe mj mk ml mm b">45</code>，而在x86系统中是id <code class="fe mj mk ml mm b">517</code>。<a class="ae mt" href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl" rel="noopener ugc nofollow" target="_blank">这里的</a>是x86-x64的所有系统调用的列表。</p><p id="76aa" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe mj mk ml mm b">syscalls</code>是您列出所有系统调用和与它们相关的动作的地方。例如，您可以通过将<code class="fe mj mk ml mm b">defaultAction</code>设置为<code class="fe mj mk ml mm b">SCMP_ACT_ERRNO</code>并将syscalls部分中的动作设置为<code class="fe mj mk ml mm b">SCMP_ACT_ALLOW</code>来创建一个白名单。通过这种方式，你可以将所有你列举的呼叫列入白名单，并阻止其他所有呼叫。对于黑名单方法，恢复<code class="fe mj mk ml mm b">defaultAction</code>和<code class="fe mj mk ml mm b">action</code>的值。</p><p id="6781" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现在让我们换个话题，讨论一下那些可能不太明显的部分。但是在此之前，请注意下面的建议假设您正在将业务线应用程序部署到Kubernetes中，并且以最小特权运行对您来说非常重要。</p><h1 id="23fd" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">1.AllowPrivilegeEscalation = false</h1><p id="4634" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">在容器的SecurityContext中有一个名为AllowPrivilegeEscalation的设置。当这个设置为<code class="fe mj mk ml mm b">false</code>时，你的容器将使用<a class="ae mt" href="https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt" rel="noopener ugc nofollow" target="_blank"> no_new_priv </a>位<code class="fe mj mk ml mm b">on</code>运行。这有效地做了它在tin中所说的，它阻止容器跨越比它自己有更多特权的新进程。</p><p id="a152" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当这个设置为<code class="fe mj mk ml mm b">true</code>(默认设置)时的另一个副作用是，容器运行时将在容器启动过程的早期应用您的seccomp概要文件。因此，运行时内部流程运行所需的所有系统调用，比如设置容器用户/组id和删除功能，都必须在您的配置文件中加入白名单。</p><p id="8039" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">所以对于一个简单执行<code class="fe mj mk ml mm b">echo hi</code>的容器，你需要这样:</p><figure class="mn mo mp mq gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="0881" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">而不是这个:</p><figure class="mn mo mp mq gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="0894" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">不过话说回来，为什么这是个问题？嗯，我个人会避免将这些系统调用列入白名单，如果我不使用它们的话:<code class="fe mj mk ml mm b">capset</code>、<code class="fe mj mk ml mm b">set_tid_address</code>、<code class="fe mj mk ml mm b">setgid</code>、<code class="fe mj mk ml mm b">setgroups</code>和<code class="fe mj mk ml mm b">setuid</code>。然而，真正的问题是需要将您完全无法控制的进程列入白名单，将您的概要文件与容器运行时实现联系起来。也就是说，您(或者很可能是您的云提供商)更新了您的容器运行时，突然之间您的容器不能再启动了。</p><p id="c243" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc">专业提示#1 </strong>:使用<code class="fe mj mk ml mm b">AllowPrivilegeEscaltion=false</code>运行容器。这将使您的seccomp概要文件变得更小，受容器运行时变化影响的可能性更小。</p><h1 id="ae24" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">2.在容器级别设置seccomp配置文件</h1><p id="8417" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">设置seccomp配置文件时，您可以选择在pod级别进行设置:</p><pre class="mn mo mp mq gt mu mm mv mw aw mx bi"><span id="a972" class="my ln jb mm b gy mz na l nb nc">annotations:<br/>  seccomp.security.alpha.kubernetes.io/pod: "localhost/profile.json"</span></pre><p id="0d90" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">或者在容器级别:</p><pre class="mn mo mp mq gt mu mm mv mw aw mx bi"><span id="fb7a" class="my ln jb mm b gy mz na l nb nc">annotations:<br/>  container.security.alpha.kubernetes.io/&lt;container-name&gt;: "localhost/profile.json"</span></pre><p id="50f2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="nd">请注意，当Kubernetes sec comp</em><a class="ae mt" href="https://github.com/kubernetes/enhancements/pull/1148" rel="noopener ugc nofollow" target="_blank"><em class="nd">变成GA </em> </a> <em class="nd">时，上面的语法会发生变化。</em></p><p id="c57a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">一件不太为人所知的事情是，历史上Kubernetes总是有一个<a class="ae mt" href="https://github.com/kubernetes/kubernetes/issues/84623" rel="noopener ugc nofollow" target="_blank">错误</a>，它迫使seccomp配置文件应用于<a class="ae mt" href="https://www.ianlewis.org/en/almighty-pause-container" rel="noopener ugc nofollow" target="_blank">暂停容器</a>。虽然这被运行时抽象掉了，但是您的pod确实有这个容器，因为它是用来设置pod基础设施的。</p><p id="9d44" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">问题是，这个容器总是用<code class="fe mj mk ml mm b">AllowPrivilegeEscalation=true</code>来执行，这导致了我们在第一点上讨论过的同样的问题，你没有办法改变这一点。</p><p id="0e54" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">通过在容器级别设置您的seccomp，您可以避免这个陷阱，并且能够创建一个主要关注您的容器的概要文件。在bug被修复并推出新版本(可能是1.18？)广泛提供给用户。</p><p id="0d84" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc"> Pro tip #2 </strong>:在容器级别设置您的seccomp配置文件。</p><p id="0da6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">根据经验，这一点通常是对以下问题的一个很好的回答:“为什么我的seccomp概要文件可以与<code class="fe mj mk ml mm b">docker run</code>一起工作，但在部署到Kubernetes集群中时却不能？”</p><h1 id="20a4" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">3.使用运行时/默认作为最后手段</h1><p id="8742" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">Kubernetes目前有两个内置概要文件选项:<code class="fe mj mk ml mm b">runtime/default</code>和<code class="fe mj mk ml mm b">docker/default</code>。两者都是由容器运行时实现的，而不是由Kubernetes实现的。因此，它们可能会根据您使用的运行时/版本而有所不同。</p><p id="57c1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因此，通过简单地改变运行时，你的容器可能有一组不同的系统调用，它可能使用也可能不使用。docker <a class="ae mt" href="https://github.com/moby/moby/blob/master/profiles/seccomp/default.json" rel="noopener ugc nofollow" target="_blank">实现</a>是大多数运行时使用的，如果你想使用这个概要文件，确保你对它所包含的内容感到满意。</p><p id="7b36" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">从Kubernetes 1.11开始，不推荐使用概要文件<code class="fe mj mk ml mm b">docker/default</code>，所以请避免使用它。</p><p id="3cdb" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在我看来，<code class="fe mj mk ml mm b">runtime/default</code>概要文件对于它的创建目的来说是很棒的:保护用户在他们自己的机器上运行<code class="fe mj mk ml mm b">docker run</code>命令，并潜在地危害他们的机器。然而，当涉及到在Kubernetes集群中运行的业务线应用程序时，我认为这种配置文件过于开放，开发人员应该专注于创建特定于应用程序(或应用程序类型)的配置文件。</p><p id="04d9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc"> Pro tip #3 </strong>:创建特定应用的seccomp配置文件。如果做不到这一点，可以使用应用程序类型seccomp配置文件，例如创建一个包含所有golang web api应用程序的超集配置文件。万不得已使用<code class="fe mj mk ml mm b">runtime/default</code>。</p><p id="c3af" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在以后的文章中，我将介绍如何以一种SecDevOpsy的方式创建seccomp概要文件，并通过您的管道自动化和测试它们。这样你就没有借口不去找特定应用的资料了。；)</p><h1 id="ab52" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">4.不受限制不应该是一个选项</h1><p id="4413" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">Kubernetes的第一次安全审计发现的一件事是<a class="ae mt" href="https://github.com/kubernetes/kubernetes/issues/81115" rel="noopener ugc nofollow" target="_blank"> seccomp默认被禁用</a>。这意味着，除非您创建一个<a class="ae mt" href="https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/restricted-psp.yaml" rel="noopener ugc nofollow" target="_blank"> PodSecurityPolicy </a>在您的集群中启用它，否则所有未指定seccomp配置文件的pods将自动与<code class="fe mj mk ml mm b">seccomp=unconfined</code>一起运行。</p><p id="0d35" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这种模式下运行意味着保护集群的隔离层减少了一层，安全社区建议不要这样做。</p><p id="524c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc"> Pro tip #4 </strong>:集群中的任何容器都不应该作为<code class="fe mj mk ml mm b">seccomp=unconfined</code>运行，特别是在生产环境中。</p><h1 id="1110" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">5."审计模式"</h1><p id="90f3" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">这一点并不是Kubernetes独有的，但它属于“你甚至在开始之前就应该知道的事情”。:)</p><p id="c9f8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">从历史上看，创建seccomp配置文件是一件痛苦的事情，而且很大程度上是基于反复试验。这并不是说它发生了很大的变化，而是您根本没有办法在生产环境中测试它而不冒破坏您的应用程序的风险。</p><p id="5515" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">从linux内核4.14开始，现在可以定义部分配置文件在<em class="nd">审计模式</em>下运行，将所有需要的系统调用记录到系统日志中，而不会阻塞它们。为此，您可以使用动作<code class="fe mj mk ml mm b">SCMT_ACT_LOG</code>:</p><blockquote class="ne nf ng"><p id="c83d" class="kq kr nd ks b kt ku kc kv kw kx kf ky nh la lb lc ni le lf lg nj li lj lk ll ij bi translated"><strong class="ks jc">SCMP _行为_日志:</strong>如果不匹配任何已配置的seccomp <br/>过滤器规则，seccomp过滤器将不会对调用<br/>系统调用的线程产生影响，但是系统调用将被记录。</p></blockquote><p id="4f42" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">使用它的一个好策略是:</p><ol class=""><li id="a49c" class="nk nl jb ks b kt ku kw kx kz nm ld nn lh no ll np nq nr ns bi translated">允许您知道需要的系统调用。</li><li id="06fe" class="nk nl jb ks b kt nt kw nu kz nv ld nw lh nx ll np nq nr ns bi translated">阻止您知道不需要的系统调用。</li><li id="1680" class="nk nl jb ks b kt nt kw nu kz nv ld nw lh nx ll np nq nr ns bi translated">记录其他一切。</li></ol><p id="e2ad" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">一个简单的例子是这样的:</p><figure class="mn mo mp mq gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="a38d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">但是请记住，您必须阻止所有您知道不会使用并且可能会对您的集群造成潜在危害的调用。一个很好的列表来源是官方docker <a class="ae mt" href="https://docs.docker.com/engine/security/seccomp/" rel="noopener ugc nofollow" target="_blank">文档</a>，其中他们解释了在默认配置文件中阻塞了哪些系统调用以及为什么阻塞。</p><p id="78c6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">但是有一个问题！虽然<code class="fe mj mk ml mm b">SCMT_ACT_LOG</code>从2017年的ebd开始就得到kernel的支持，但直到最近才进入Kubernetes生态系统。所以要使用它，你至少需要运行Linux内核4.14和runC版本<a class="ae mt" href="https://github.com/opencontainers/runc/releases/tag/v1.0.0-rc9" rel="noopener ugc nofollow" target="_blank"> v1.0.0-rc9 </a>。</p><p id="1a87" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc"> Pro tip #5 </strong>:通过混合黑名单和白名单并记录所有异常，创建审计模式配置文件以在生产中进行测试。</p><h1 id="0106" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">6.首选白名单</h1><p id="7d30" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">白名单在这个过程中增加了额外的工作，因为您需要识别您的应用程序可能执行的每个系统调用，以便获得您的配置文件，但它确实增加了额外的安全层:</p><blockquote class="ne nf ng"><p id="9d45" class="kq kr nd ks b kt ku kc kv kw kx kf ky nh la lb lc ni le lf lg nj li lj lk ll ij bi translated">强烈建议尽可能使用白名单方法，因为这种方法更加可靠和简单。每当添加一个潜在危险的系统调用(或者一个危险的标志或选项，如果它们被列入黑名单的话)时，黑名单就必须被更新，并且通常可以改变一个值的表示而不改变它的含义，从而导致绕过黑名单。</p></blockquote><p id="2105" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">对于go应用程序，我开发了一个工具来遍历执行路径，并提取所有的系统调用。对于下面的应用:</p><figure class="mn mo mp mq gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="4b8c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">通过运行<code class="fe mj mk ml mm b">gosystract</code>来反对它:</p><figure class="mn mo mp mq gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="e42e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">以下是您得到的结果:</p><pre class="mn mo mp mq gt mu mm mv mw aw mx bi"><span id="e4e6" class="my ln jb mm b gy mz na l nb nc">"sched_yield",<br/>"futex",<br/>"write",<br/>"mmap",<br/>"exit_group",<br/>"madvise",<br/>"rt_sigprocmask",<br/>"getpid",<br/>"gettid",<br/>"tgkill",<br/>"rt_sigaction",<br/>"read",<br/>"getpgrp",<br/>"arch_prctl",</span></pre><p id="ee13" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我将在后面介绍更多的工具，这只是一个开始。:)</p><p id="56ef" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc">专业提示#6 </strong>:允许你知道你需要的系统调用，阻止其他任何调用。</p><h1 id="60db" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">7.做好基本工作，否则将面临意想不到的行为</h1><p id="d340" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">无论您在seccomp配置文件中定义什么，内核都会执行它。即使这不是你想要的。例如，如果您阻止对诸如<code class="fe mj mk ml mm b">exit</code>或<code class="fe mj mk ml mm b">exit_group</code>之类的调用的访问，您的容器可能无法退出，简单的“echo hi”可能会使容器无限期地陷入<a class="ae mt" href="https://github.com/kubernetes/kubernetes/issues/85191" rel="noopener ugc nofollow" target="_blank">退出循环</a>。导致集群的高CPU使用率:</p><figure class="mn mo mp mq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ny"><img src="../Images/e39fcddd0d42192b21aab44f58ff0f73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kIVJ37wq0qCfzAee.png"/></div></div></figure><p id="486b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这种情况下，<code class="fe mj mk ml mm b">strace</code>可以派上用场，会向你展示问题可能是什么:</p><figure class="mn mo mp mq gt is gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/24ff20ac8f3cc522a929e8508e9f2844.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/0*IE_IzUZcDzKkwAoS.png"/></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">sudo strace -c -p 9331</figcaption></figure><p id="64fc" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">确保您的配置文件很好地反映了应用程序执行路径中的所有系统调用。</p><p id="787c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">专业提示#7 :要全面，确保所有的基本系统调用都被列入白名单。</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><p id="1fc5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这是关于以SecDevOpsy方式在Kubernetes中实现seccomp的第一部分，请继续关注以了解更多关于“为什么这很重要？”以及如何自动化这个过程。</p></div></div>    
</body>
</html>