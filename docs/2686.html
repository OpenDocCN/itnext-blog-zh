<html>
<head>
<title>20 Useful Python Tips and Trick You Didn’t Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您不知道的20个有用的Python技巧和诀窍</h1>
<blockquote>原文：<a href="https://itnext.io/20-useful-python-tips-and-trick-you-didnt-know-e13157a7d6f4?source=collection_archive---------0-----------------------#2019-07-11">https://itnext.io/20-useful-python-tips-and-trick-you-didnt-know-e13157a7d6f4?source=collection_archive---------0-----------------------#2019-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ce5d0f911a1688c3aa679428c2a7f687.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-6ATYG4fF3xtxY2og3v1rQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://www.duomly.com" rel="noopener ugc nofollow" target="_blank"> Duomly —编程在线课程</a></figcaption></figure><p id="a1f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文原载:<a class="ae kc" href="https://www.blog.duomly.com/20-essential-python-tips-and-tricks-you-should-know/" rel="noopener ugc nofollow" target="_blank">https://www . blog . duomly . com/20-essential-python-tips-and-tricks-you-should-know/</a></p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="6401" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python是一种流行的、通用的、广泛使用的编程语言。它用于数据科学和机器学习、许多领域的科学计算、后端Web开发、移动和桌面应用程序等等。许多知名公司都使用Python:谷歌、Dropbox、脸书、Mozilla、IBM、Quora、亚马逊、Spotify、NASA、网飞、Reddit等等。</p><p id="6bc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python是免费和开源的，与其相关的大部分产品也是如此。此外，它还有一个由程序员和其他用户组成的大型、专注且友好的社区。</p><p id="785f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其语法的设计考虑了简单性、可读性和优雅性。</p><p id="b21b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文介绍了20个可能有用的Python技巧和诀窍。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="675b" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">1.Python的禅</h1><p id="f4d3" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">Python的禅宗(Zen of Python)也称为PEP 20，是Tim Peters的一篇小文章，代表了设计和使用Python的指导原则。它可以在Python网站上找到，但是您也可以在您的终端(控制台)或Jupyter笔记本上用一条语句获得它:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="c8bc" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; import this<br/>The Zen of Python, by Tim Peters</span><span id="5f38" class="mu lj iq mq b gy mz mw l mx my">Beautiful is better than ugly.<br/>Explicit is better than implicit.<br/>Simple is better than complex.<br/>Complex is better than complicated.<br/>Flat is better than nested.<br/>Sparse is better than dense.<br/>Readability counts.<br/>Special cases aren't special enough to break the rules.<br/>Although practicality beats purity.<br/>Errors should never pass silently.<br/>Unless explicitly silenced.<br/>In the face of ambiguity, refuse the temptation to guess.<br/>There should be one-- and preferably only one --obvious way to do it.<br/>Although that way may not be obvious at first unless you're Dutch.<br/>Now is better than never.<br/>Although never is often better than *right* now.<br/>If the implementation is hard to explain, it's a bad idea.<br/>If the implementation is easy to explain, it may be a good idea.<br/>Namespaces are one honking great idea -- let's do more of those!</span></pre><h1 id="8c68" class="li lj iq bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">2.链式分配</h1><p id="2581" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">如果需要多个变量引用同一个对象，可以使用链式赋值:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="e52d" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; x = y = z = 2<br/>&gt;&gt;&gt; x, y, z<br/>(2, 2, 2)</span></pre><p id="c06d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">逻辑优雅对吧？</p><h1 id="56c8" class="li lj iq bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">3.链式比较</h1><p id="053b" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">通过链接比较运算符，可以将多个比较合并到一个Python表达式中。如果所有比较都正确，则该表达式返回True，否则返回False:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="df92" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; x = 5<br/>&gt;&gt;&gt; 2 &lt; x ≤ 8<br/>True<br/>&gt;&gt;&gt; 6 &lt; x ≤ 8<br/>False</span></pre><p id="640c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这类似于(2 &lt; x)和(x ≤ 8)以及(6 &lt; x)和(x ≤ 8 ),但更紧凑，并且只需要对x求值一次。</p><p id="5ab1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这也是合法的:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="1ca6" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; 2 &lt; x &gt; 4<br/>True</span></pre><p id="fdd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以链接两个以上的比较:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="c8ea" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; x = 2<br/>&gt;&gt;&gt; y = 8<br/>&gt;&gt;&gt; 0 &lt; x &lt; 4 &lt; y &lt; 16<br/>True</span></pre><h1 id="22b5" class="li lj iq bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">4.多重赋值</h1><p id="bbe7" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">您可以使用元组解包在单个语句中分配多个变量:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="23eb" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; x, y, z = 2, 4, 8<br/>&gt;&gt;&gt; x<br/>2<br/>&gt;&gt;&gt; y<br/>4<br/>&gt;&gt;&gt; z<br/>8</span></pre><p id="2a08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，第一条语句中的2，4，8是一个等价于(2，4，8)的元组。</p><h1 id="cf6b" class="li lj iq bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">5.更高级的多重赋值</h1><p id="7f68" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">普通的多重赋值不是Python能做的全部。您不需要左侧和右侧的元素数量相同:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="6e5f" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; x, *y, z = 2, 4, 8, 16<br/>&gt;&gt;&gt; x<br/>2<br/>&gt;&gt;&gt; y<br/>[4, 8]<br/>&gt;&gt;&gt; z<br/>16</span></pre><p id="604c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，x取第一个值(2 ),因为它最先出现。z是最后一个，取最后一个值(8)。y接受打包在列表中的所有其他值，因为它有星号(*y)。</p><h1 id="6df6" class="li lj iq bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">6.交换变量</h1><p id="08af" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">您可以应用多重赋值以简洁优雅的方式交换任意两个变量，而无需引入第三个变量:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="ad21" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; x, y = 2, 8<br/>&gt;&gt;&gt; x<br/>2<br/>&gt;&gt;&gt; y<br/>8<br/>&gt;&gt;&gt; x, y = y, x<br/>&gt;&gt;&gt; x<br/>8<br/>&gt;&gt;&gt; y<br/>2</span></pre><h1 id="97df" class="li lj iq bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">7.合并词典</h1><p id="839d" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">合并两个或更多字典的一种方法是将它们解压成一个新字典:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="8fe2" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; x = {'u': 1}<br/>&gt;&gt;&gt; y = {'v': 2}<br/>&gt;&gt;&gt; z = {**x, **y, 'w': 4}<br/>&gt;&gt;&gt; z<br/>{'u': 1, 'v': 2, 'w': 4}</span></pre><h1 id="1215" class="li lj iq bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">8.连接字符串</h1><p id="29de" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">如果需要连接多个字符串，最终它们之间有相同的字符或一组字符，可以使用str.join()方法:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="a17c" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; x = ['u', 'v', 'w']<br/>&gt;&gt;&gt; y = '-*-'.join(x)<br/>&gt;&gt;&gt; y<br/>'u-*-v-*-w'</span></pre><h1 id="f848" class="li lj iq bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">9.高级迭代</h1><p id="9c6e" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">如果要遍历一个序列，并且需要序列元素和相应的索引，应该使用enumerate:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="7db1" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; for i, item in enumerate(['u', 'v', 'w']):<br/>...     print('index:', i, 'element:', item)<br/>... <br/>index: 0 element: u<br/>index: 1 element: v<br/>index: 2 element: w</span></pre><p id="a922" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在每次迭代中，您将获得一个元组，其中包含索引和序列的相应元素。</p><h1 id="0ea8" class="li lj iq bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">10.反向迭代</h1><p id="ff95" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">如果要以相反的顺序遍历序列，应该使用reversed:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="9438" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; for item in reversed(['u', 'v', 'w']):<br/>...     print(item)<br/>... <br/>w<br/>v<br/>u</span></pre><h1 id="c698" class="li lj iq bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">11.聚集元素</h1><p id="d01c" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">如果您要聚合来自几个序列的元素，您应该使用zip:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="8a5d" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; x = [1, 2, 4]<br/>&gt;&gt;&gt; y = ('u', 'v', 'w')<br/>&gt;&gt;&gt; z = zip(x, y)<br/>&gt;&gt;&gt; z<br/>&lt;zip object at 0x7f9e98df3148&gt;<br/>&gt;&gt;&gt; list(z)<br/>[(1, 'u'), (2, 'v'), (4, 'w')]</span></pre><p id="7ae8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以遍历获得的zip对象，或者将其转换为列表或元组。</p><h1 id="3773" class="li lj iq bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">12.转置矩阵</h1><p id="8083" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">虽然人们在处理矩阵时通常使用NumPy(或类似的库),但是您可以用zip获得矩阵的转置:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="d50f" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; x = [(1, 2, 4), ('u', 'v', 'w')]<br/>&gt;&gt;&gt; y = zip(*x)<br/>&gt;&gt;&gt; z = list(y)<br/>&gt;&gt;&gt; z<br/>[(1, 'u'), (2, 'v'), (4, 'w')]</span></pre><h1 id="af1b" class="li lj iq bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">13.独特的价值观</h1><p id="f907" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">如果元素的顺序不重要，可以通过将列表转换为集合来删除列表中的重复项，从而获得唯一值:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="ed29" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; x = [1, 2, 1, 4, 8]<br/>&gt;&gt;&gt; y = set(x)<br/>&gt;&gt;&gt; y<br/>{8, 1, 2, 4}<br/>&gt;&gt;&gt; z = list(y)<br/>&gt;&gt;&gt; z<br/>[8, 1, 2, 4]</span></pre><h1 id="5b09" class="li lj iq bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">14.排序序列</h1><p id="c374" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">默认情况下，序列按其第一个元素排序:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="588d" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; x = (1, 'v')<br/>&gt;&gt;&gt; y = (4, 'u')<br/>&gt;&gt;&gt; z = (2, 'w')<br/>&gt;&gt;&gt; sorted([x, y, z])<br/>[(1, 'v'), (2, 'w'), (4, 'u')]</span></pre><p id="fa81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果您想要根据它们的第二个(或其他)元素对它们进行排序，您可以使用参数键和一个适当的lambda函数作为相应的参数:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="48d5" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; sorted([x, y, z], key=lambda item: item[1])<br/>[(4, 'u'), (1, 'v'), (2, 'w')]</span></pre><p id="3037" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想获得相反的顺序，情况类似:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="969f" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; sorted([x, y, z], key=lambda item: item[1], reverse=True)<br/>[(2, 'w'), (1, 'v'), (4, 'u')]</span></pre><h1 id="dc8e" class="li lj iq bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">15.分类词典</h1><p id="3438" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">您可以使用类似的方法对通过。items()方法:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="d75c" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; x = {'u': 4, 'w': 2, 'v': 1}<br/>&gt;&gt;&gt; sorted(x.items())<br/>[('u', 4), ('v', 1), ('w', 2)]</span></pre><p id="77f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们是根据关键字排序的。如果您希望根据它们的值对它们进行排序，您应该指定对应于key并最终反转的参数:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="0fe1" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; sorted(x.items(), key=lambda item: item[1])<br/>[('v', 1), ('w', 2), ('u', 4)]<br/>&gt;&gt;&gt; sorted(x.items(), key=lambda item: item[1], reverse=True)<br/>[('u', 4), ('w', 2), ('v', 1)]</span></pre><h1 id="0054" class="li lj iq bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">16.原始格式化字符串</h1><p id="9781" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">PEP 498和Python 3.6引入了所谓的格式化字符串或f字符串。您可以在这样的字符串中嵌入表达式。把一个字符串既当作原始的又当作格式化的是可能的和直接的。您需要包括两个前缀:fr。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="9d0e" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; fr'u \ n v w={2 + 8}'<br/>'u \\ n v w=10'</span></pre><h1 id="e417" class="li lj iq bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">17.获取当前日期和时间</h1><p id="7968" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">Python有一个内置的模块datetime，它是处理日期和时间的通用模块。它的方法之一是。now()返回当前日期和时间:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="db78" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; import datetime<br/>&gt;&gt;&gt; datetime.datetime.now()<br/>datetime.datetime(2019, 5, 20, 1, 12, 31, 230217)</span></pre><p id="9fab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此结果对应于2019年5月20日凌晨01:12:31。</p><h1 id="ac76" class="li lj iq bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">18.获取最大(或最小)元素的索引</h1><p id="3b25" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">Python不提供直接获取列表或元组中最大或最小元素的索引的例程。幸运的是，(至少)有两种优雅的方法可以做到这一点:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="f1cd" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; x = [2, 1, 4, 16, 8]<br/>&gt;&gt;&gt; max((item, i) for i, item in enumerate(x))[1]<br/>3</span></pre><p id="1a45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果有两个或多个元素具有最大值，此方法将返回最后一个元素的索引:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="382e" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; y = [2, 1, 4, 8, 8]<br/>&gt;&gt;&gt; max((item, i) for i, item in enumerate(y))[1]<br/>4</span></pre><p id="6fb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要获得第一个匹配项的索引，您需要稍微修改一下前面的语句:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="05c7" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; -max((item, -i) for i, item in enumerate(y))[1]<br/>3</span></pre><p id="56e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一种方式可能更优雅:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="d1b9" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; x = [2, 1, 4, 16, 8]<br/>&gt;&gt;&gt; max(range(len(x)), key=lambda i: x[i])<br/>3<br/>&gt;&gt;&gt; y = [2, 1, 4, 8, 8]<br/>&gt;&gt;&gt; max(range(len(y)), key=lambda i: x[i])<br/>3</span></pre><p id="6aa1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要查找最小元素的索引，请使用函数min而不是max。</p><h1 id="4315" class="li lj iq bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">19.获得笛卡尔积</h1><p id="b7d5" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">内置模块itertools提供了许多潜在有用的类。其中之一是用于获得笛卡尔积的乘积:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="5a28" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; import itertools<br/>&gt;&gt;&gt; x, y, z = (2, 8), ['u', 'v', 'w'], {True, False}<br/>&gt;&gt;&gt; list(itertools.product(x, y, z))<br/>[(2, 'u', False), (2, 'u', True), (2, 'v', False), (2, 'v', True),<br/> (2, 'w', False), (2, 'w', True), (8, 'u', False), (8, 'u', True),<br/> (8, 'v', False), (8, 'v', True), (8, 'w', False), (8, 'w', True)]</span></pre><h1 id="f051" class="li lj iq bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">20.矩阵乘法运算符</h1><p id="6fa2" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">PEP 465和Python 3.5引入了矩阵乘法专用的中缀运算符。您可以使用__matmul__ 、__rmatmul__、和__imatmul_方法为您的类实现它。这就是向量或矩阵相乘的代码看起来有多优雅:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="121f" class="mu lj iq mq b gy mv mw l mx my">&gt;&gt;&gt; import numpy as np<br/>&gt;&gt;&gt; x, y = np.array([1, 3, 5]), np.array([2, 4, 6])<br/>&gt;&gt;&gt; z = x @ y<br/>&gt;&gt;&gt; z<br/>44</span></pre><h1 id="e171" class="li lj iq bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">结论</h1><p id="321b" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">您已经看到了20个让它变得有趣而优雅的Python技巧和诀窍。还有很多其他的语言特性值得探索。</p><p id="9b30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编码快乐！</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d5ee4c5640193ff931b57af57d9cd1d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3VTFJp7Yhh3Ky9Fm2dj-8w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://www.duomly.com" rel="noopener ugc nofollow" target="_blank"> Duomly —编程在线课程</a></figcaption></figure><p id="68d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您的阅读！</p><p id="b295" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的队友米尔科准备了一篇文章。</p></div></div>    
</body>
</html>