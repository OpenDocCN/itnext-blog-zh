<html>
<head>
<title>Programmable Completion for Bash on macOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">macOS上Bash的可编程完成</h1>
<blockquote>原文：<a href="https://itnext.io/programmable-completion-for-bash-on-macos-f81a0103080b?source=collection_archive---------1-----------------------#2019-01-14">https://itnext.io/programmable-completion-for-bash-on-macos-f81a0103080b?source=collection_archive---------1-----------------------#2019-01-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c07596db65cd150f6959edcbab21ac02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iaC_zrKuCvWH75Qf9ghanA.png"/></div></div></figure><p id="b954" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">大多数人都熟悉默认的Bash完成功能。你开始输入一个命令，点击<em class="kz">键</em>，命令自动完成。如果有多个命令与您到目前为止键入的内容相匹配，您可以按两次<em class="kz">键</em>，Bash会显示所有可能完成的命令的列表。这同样适用于变量和文件名。</p><p id="6e64" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，许多人不知道Bash支持更高级的完成类型，称为<em class="kz">可编程完成</em>。这允许定义特定于<em class="kz">命令的</em>完成逻辑，使用户能够以特定于上下文的方式自动完成子命令、选项和命令的其他参数。想象一下输入<code class="fe la lb lc ld b">cmd -[tab][tab]</code>，然后看到该命令所有适用选项的列表。</p><p id="ec5d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不幸的是，默认情况下，可编程Bash完成在macOS上无法顺利工作。然而，这些障碍很容易克服。本文解释了如何做到这一点，以及如何在macOS上充分利用可编程Bash完成。</p><h1 id="b2db" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">默认完成</h1><p id="ae34" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">默认的Bash完成功能基本上适用于Bash的每个版本。这里简单介绍一下<a class="ae mh" href="https://www.gnu.org/software/bash/manual/html_node/Commands-For-Completion.html" rel="noopener ugc nofollow" target="_blank"/>(上图)。本质上，它允许自动完成命令名、变量和文件名，如下所示:</p><pre class="mi mj mk ml gt mm ld mn mo aw mp bi"><span id="d0ca" class="mq lf it ld b gy mr ms l mt mu">$ <strong class="ld iu">ec[tab] </strong>            # Completes to<em class="kz"> </em><strong class="ld iu">echo</strong><br/>$ <strong class="ld iu">echo $PA[tab]</strong>       # Completes to<em class="kz"> </em><strong class="ld iu">echo $PATH</strong><br/>$ <strong class="ld iu">cat myfile[tab]</strong>     # Completes to<em class="kz"> </em><strong class="ld iu">cat myfile.txt</strong></span></pre><p id="c312" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果到目前为止您输入的内容有多种可能的完成方式，您可以按两次<em class="kz">选项卡</em>，将显示一个包含所有可能完成方式的列表:</p><pre class="mi mj mk ml gt mm ld mn mo aw mp bi"><span id="d792" class="mq lf it ld b gy mr ms l mt mu">$ <strong class="ld iu">e[tab][tab]</strong>          # Lists all commands starting with "e"<br/>$ <strong class="ld iu">echo $P[tab][tab]</strong>    # Lists all variables starting with "P"<br/>$ <strong class="ld iu">cat my[tab][tab]</strong>     # Lists all files starting with "my"</span></pre><h1 id="6976" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">可编程完成</h1><p id="3d00" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">在Bash版本<a class="ae mh" href="http://freshmeat.sourceforge.net/projects/bashcompletion" rel="noopener ugc nofollow" target="_blank"> 2.04 </a>(大约从2000年开始)中，可编程完成作为一个新特性被引入。Bash文档的<a class="ae mh" href="https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion.html" rel="noopener ugc nofollow" target="_blank">可编程完成</a>部分对此有详细描述。顾名思义，它是一种<em class="kz">可编程</em>类型的完成，这意味着它允许创建适合各个命令的完成逻辑。</p><p id="af5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，它允许做这样的事情:</p><pre class="mi mj mk ml gt mm ld mn mo aw mp bi"><span id="e914" class="mq lf it ld b gy mr ms l mt mu">$ <strong class="ld iu">cmd [tab][tab]</strong>        # Lists all sub-commands of "cmd"<br/>$ <strong class="ld iu">cmd --[tab][tab]</strong>      # Lists all options applicable to "cmd"<br/>$ <strong class="ld iu">cmd sub --[tab][tab]</strong>  # Lists all options applicable to "sub"<br/>$ <strong class="ld iu">cmd sub [tab][tab]</strong>    # Lists all arguments applicable to "sub"<br/>$ <strong class="ld iu">cmd su[tab]</strong>           # Completes to <strong class="ld iu">cmd sub</strong><br/>$ <strong class="ld iu">cmd --opt[tab] </strong>       # Completes to <strong class="ld iu">cmd --option</strong></span></pre><p id="593f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如您所看到的，补全不是通用的，比如默认Bash补全的命令名、文件名和变量，而是特定于正在键入的命令(上例中的<code class="fe la lb lc ld b">cmd</code>)。</p><p id="71cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么Bash如何知道在每种情况下什么完成是适用的呢？答案是必须为每个命令定义一个<em class="kz">完成规范</em>。下一小节将对此进行进一步阐述。</p><h2 id="5d59" class="mq lf it bd lg mv mw dn lk mx my dp lo km mz na ls kq nb nc lw ku nd ne ma nf bi translated">完工规范</h2><p id="83ed" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">完成规范(“compspec”)为命令的自变量标记定义了适用的完成。这些参数标记可以是子命令、选项或其他值，包括特定于上下文的值。完成规范负责检查命令行的当前状态，并返回一组可能的完成。</p><p id="951c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果一个命令有一个完成规范，并且用户点击这个命令的参数标记中的<em class="kz">标签</em>，那么Bash调用完成规范并向用户显示返回的完成。这些完成的含义(例如，它们是子命令还是选项)对Bash是透明的，只有完成规范和命令本身知道。</p><p id="c9a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建一个完成规范，并将其与内置的<code class="fe la lb lc ld b">complete</code>命令绑定在一起。<code class="fe la lb lc ld b">complete</code>内置是Bash可编程完成特性的主要工具。有两个称为<code class="fe la lb lc ld b">compgen</code>和<code class="fe la lb lc ld b">compopt</code>的辅助内置组件帮助定义完井规范。Bash手册的<a class="ae mh" href="https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">可编程完成内建</strong> </a>部分描述了这三个内建。</p><p id="846a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">大致来说，<code class="fe la lb lc ld b">complete</code>内建就是这样被用来创建一个完成规范并将其绑定到一个命令上的:</p><pre class="mi mj mk ml gt mm ld mn mo aw mp bi"><span id="9f10" class="mq lf it ld b gy mr ms l mt mu">$ <strong class="ld iu">complete [compspec] [cmd]</strong></span></pre><p id="2c21" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，如果您键入<code class="fe la lb lc ld b">cmd [tab]</code>，Bash将调用完成规范<code class="fe la lb lc ld b">compspec</code>并向您显示返回的完成(在本例中可能是子命令、文件名或其他值)。</p><p id="557c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我不会在本文中描述如何创建一个完成规范，但是可以在<code class="fe la lb lc ld b"><a class="ae mh" href="https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html" rel="noopener ugc nofollow" target="_blank">complete</a></code>内建的文档中找到相关的主要信息。更好的是，有一个非常好的教程叫做<a class="ae mh" href="https://iridakos.com/tutorials/2018/03/01/bash-programmable-completion-tutorial.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">创建Bash完成脚本</strong> </a>。</p><p id="a2e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实际上，<code class="fe la lb lc ld b">complete</code>很少在命令行上执行，而是包含在一个所谓的<strong class="kd iu">完成脚本</strong>中。完成脚本基本上是一个普通的Bash脚本，包含一个或多个针对特定命令的<code class="fe la lb lc ld b">complete</code>语句。因此，如果您提供一个完成脚本，那么<code class="fe la lb lc ld b">complete</code>命令将在当前的shell中执行，并且相应命令的完成将被激活。</p><h2 id="2c38" class="mq lf it bd lg mv mw dn lk mx my dp lo km mz na ls kq nb nc lw ku nd ne ma nf bi translated">在现实世界中</h2><p id="ae44" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">现在最大的问题是，所有命令的完成脚本来自哪里？答案是，它们通常是由命令的创建者提供的。</p><p id="657d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，Git为其<code class="fe la lb lc ld b">git</code>命令行工具提供了一个Bash完成脚本。它叫做<code class="fe la lb lc ld b"><a class="ae mh" href="https://github.com/git/git/blob/master/contrib/completion/git-completion.bash" rel="noopener ugc nofollow" target="_blank">git-completion.bash</a></code>。如果您看一下这个脚本，您会看到它定义了许多函数，最后它调用了<code class="fe la lb lc ld b">complete</code>内置函数。这些函数定义了实际的完成规范，它们被<code class="fe la lb lc ld b">complete</code>语句引用。您还可以看到该脚本使用了<code class="fe la lb lc ld b">compgen</code>和<code class="fe la lb lc ld b">compopt</code>内置代码。这是大多数Bash完成脚本的样子。</p><p id="8adf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以下载这个脚本并在您的shell中找到它:</p><pre class="mi mj mk ml gt mm ld mn mo aw mp bi"><span id="9dff" class="mq lf it ld b gy mr ms l mt mu">$ <strong class="ld iu">source git-completion.bash</strong></span></pre><p id="068b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在那之后，你应该马上就能看到<code class="fe la lb lc ld b">git</code>惊人的自动完成功能。这看起来像下面这样:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ng"><img src="../Images/c3c24e75139525babf37879a965537ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RF7_ntrdi4mvqxEji1Rp-A.gif"/></div></div></figure><p id="2006" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，Git完成脚本提供的完成功能非常有用。它不仅可以节省您的打字时间，还可以节省您在文档中查找子命令或选项名称的时间。</p><p id="09e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意在<code class="fe la lb lc ld b">git add</code>上下文中点击<em class="kz">标签</em>是如何显示未被跟踪的<em class="kz">文件列表，而不是被跟踪的文件或在<code class="fe la lb lc ld b">.gitignore</code>中的文件。或者在<code class="fe la lb lc ld b">git remote remove</code>上下文中点击<em class="kz">标签</em>如何显示作为可能完成的现有遥控器列表。这些是<em class="kz">上下文特定的</em>完成的例子，使得可编程完成如此强大。可编程完成逻辑可以任意复杂。</em></p><p id="ce89" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Git只是众多提供Bash完成脚本的命令行工具之一。例如，<code class="fe la lb lc ld b">docker</code>提供了一个Bash完成脚本，可以在<a class="ae mh" href="https://github.com/docker/cli/blob/master/contrib/completion/bash/docker" rel="noopener ugc nofollow" target="_blank">这里</a>找到。或者<code class="fe la lb lc ld b">kubectl</code>也有Bash完成脚本，它甚至允许用<code class="fe la lb lc ld b">kubectl</code>命令:<code class="fe la lb lc ld b">kubectl completion bash</code>直接生成。</p><h2 id="8c72" class="mq lf it bd lg mv mw dn lk mx my dp lo km mz na ls kq nb nc lw ku nd ne ma nf bi translated">一些并发症</h2><p id="1ecd" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">你可能认为你所要做的就是在你的<code class="fe la lb lc ld b">.bashrc</code>文件中找到这些补全脚本，你就可以对这些命令使用补全。不幸的是，这并不容易，因为我们现在遇到了一些首先需要解决的复杂问题。特别是，我们需要讨论两点:</p><ol class=""><li id="56ec" class="nh ni it kd b ke kf ki kj km nj kq nk ku nl ky nm nn no np bi translated">许多完成脚本无法在MAC OS<strong class="kd iu">上使用Bash的默认版本</strong></li><li id="a255" class="nh ni it kd b ke nq ki nr km ns kq nt ku nu ky nm nn no np bi translated">许多完成脚本依赖于名为<strong class="kd iu"> </strong> <a class="ae mh" href="https://github.com/scop/bash-completion" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> <em class="kz">的第三方项目bash-completion </em> </strong> </a></li></ol><p id="81e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这方面，上面的Git完成脚本是一个例外。它在macOS上开箱即用。然而，如果你试图找到<code class="fe la lb lc ld b">docker</code>或<code class="fe la lb lc ld b">kubectl</code>完成脚本，你将会很不幸。您至少会得到一个<code class="fe la lb lc ld b">command not found</code>错误，并且决不会得到任何有用的完成功能。</p><p id="3237" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两点都将在下面的两节中讨论。它们可以被视为小障碍，但很容易克服。一旦完成了这些，我将在本文的最后介绍在macOS上充分利用编程完成功能的最佳方式。</p><h1 id="3182" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">macOS有什么问题？</h1><p id="9120" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">苹果在macOS中包含了一个完全过时的Bash版本。准确地说，这是2007年的GNU Bash3.2版本。如果执行以下命令，您可以看到这一点:</p><pre class="mi mj mk ml gt mm ld mn mo aw mp bi"><span id="b4a8" class="mq lf it ld b gy mr ms l mt mu">$ <strong class="ld iu">bash --version</strong><br/>GNU bash, version 3.2.57(1)-release (x86_64-apple-darwin18)<br/>Copyright (C) 2007 Free Software Foundation, Inc.</span></pre><p id="e732" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">苹果不想包含Bash的更新版本，因为GNU Bash 4+(3.2的继承者)使用<a class="ae mh" href="https://www.gnu.org/licenses/quick-guide-gplv3.en.html" rel="noopener ugc nofollow" target="_blank"> GPLv3 </a>许可，这与苹果的许可政策相冲突。</p><p id="f979" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">问题是Bash的可编程补全特性自3.2版本以来已经有所发展，今天许多补全脚本利用了Bash 3.2不支持的新特性。这意味着这些补全脚本不能在Bash 3.2中使用。例如，<code class="fe la lb lc ld b">docker</code>和<code class="fe la lb lc ld b">kubectl</code>的完成脚本在Bash 3.2中不能正常工作。</p><p id="ea40" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这当然是个问题。拥有可编程完成的无忧体验的最佳方式是升级Mac的默认外壳。这其实很简单，我写了一整篇文章，叫做<a class="ae mh" href="https://medium.com/@weibeld/upgrading-bash-on-macos-7138bd1066ba" rel="noopener"> <strong class="kd iu">在macOS上升级Bash</strong></a>。</p><p id="c3ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在阅读本文之前，我强烈建议您将Mac的默认shell升级到Bash的新版本。只有这样才能确保第三方完成脚本按预期工作。在撰写本文时，最新版本是<a class="ae mh" href="https://tiswww.case.edu/php/chet/bash/bashtop.html#CurrentStatus" rel="noopener ugc nofollow" target="_blank"> GNU Bash 5.0 </a>。</p><p id="a8eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，让我们来讨论实践中关于可编程补全的第二个要点。</p><h1 id="c61e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">bash完成项目</h1><p id="dcb7" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">bash-completion 项目是一个独立的项目，几乎和可编程Bash completion本身一样早就存在了(至少从2003年开始)。它独立于Bash，但已经成为一种标准。它在GitHub上维护:</p><blockquote class="nv nw nx"><p id="d814" class="kb kc kz kd b ke kf kg kh ki kj kk kl ny kn ko kp nz kr ks kt oa kv kw kx ky im bi translated"><a class="ae mh" href="https://github.com/scop/bash-completion" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">【https://github.com/scop/bash-completion】T21</strong></a></p></blockquote><p id="9bdc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是它有什么用呢？它实际上做了两件事。</p><p id="da54" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，它提供了一个名为<code class="fe la lb lc ld b">bash_completion</code>的脚本。你可以在GitHub上的这里找到<a class="ae mh" href="https://github.com/scop/bash-completion/blob/master/bash_completion" rel="noopener ugc nofollow" target="_blank">。它是一个Bash脚本，为其他完成脚本提供了便利的功能。</a></p><p id="4382" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其次，它在<code class="fe la lb lc ld b">completions</code>目录中为常用工具提供了一组完成脚本，如<code class="fe la lb lc ld b">ssh</code>、<code class="fe la lb lc ld b">wget</code>、<code class="fe la lb lc ld b">curl</code>、<code class="fe la lb lc ld b">gzip</code>等。你可以在GitHub的这里看到完整的完成脚本列表<a class="ae mh" href="https://github.com/scop/bash-completion/tree/master/completions" rel="noopener ugc nofollow" target="_blank">。这些完成脚本通常使用在<code class="fe la lb lc ld b">bash_completion</code>脚本中定义的函数。</a></p><p id="b093" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实际上，<code class="fe la lb lc ld b">bash_completion</code>脚本也是<code class="fe la lb lc ld b">completions</code>目录中所有完成脚本的来源。这意味着，如果您在您的系统上安装了<em class="kz"> bash-completion </em>项目，并获得了<code class="fe la lb lc ld b">bash_completion</code>脚本(例如，在您的<code class="fe la lb lc ld b">.bashrc</code>文件中)，那么您将立即启用<code class="fe la lb lc ld b">completions</code>目录中的所有完成脚本。</p><p id="cd52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如前所述，<em class="kz"> bash-completion </em>变成了一个标准。这意味着今天不仅项目自己的完成脚本使用在<code class="fe la lb lc ld b">bash_completion</code>脚本中定义的函数，而且第三方完成脚本也使用。</p><p id="363d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这意味着这些第三方补全脚本依赖于<em class="kz"> bash补全</em>。换句话说，只有在先前已经获得了<code class="fe la lb lc ld b">bash_completion</code>的情况下，获得依赖于<em class="kz"> bash-completion </em>的第三方完成脚本才有效。否则，您将得到一个<code class="fe la lb lc ld b">command not found</code>错误，因为脚本调用了Bash未知的<code class="fe la lb lc ld b">bash_completion</code>函数。</p><p id="8990" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，上面提到的<code class="fe la lb lc ld b">docker</code>和<code class="fe la lb lc ld b">kubectl</code>完成脚本就是这种情况。它们调用了几个在<code class="fe la lb lc ld b">bash_completion</code>脚本中定义的函数。因此，这些完成脚本依赖于<em class="kz"> bash-completion </em>。</p><p id="2321" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以将<em class="kz"> bash-completion </em>视为bash中可编程完成的“操作系统”,并且在真正尝试使用可编程完成之前，您应该在您的机器上安装它。</p><p id="7bbb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一节解释如何安装<em class="kz"> bash-completion。</em>接下来的部分解释了如何最好地使用第三方命令的完成脚本，以便它们能够与<em class="kz"> bash-completion </em>一起正常工作。</p><h1 id="53dd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">安装bash-完成</h1><p id="fb25" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">从<em class="kz">bash-completion</em><a class="ae mh" href="https://github.com/scop/bash-completion" rel="noopener ugc nofollow" target="_blank">GitHub库</a>的自述文件可以看出，<em class="kz"> bash-completion </em>可以通过各种包管理器进行安装。其中有<a class="ae mh" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank">家酿</a>，我强烈推荐用它在macOS上安装软件。</p><p id="23a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用自制软件安装<em class="kz"> bash-completion </em>非常容易:</p><pre class="mi mj mk ml gt mm ld mn mo aw mp bi"><span id="ca71" class="mq lf it ld b gy mr ms l mt mu">$ <strong class="ld iu">brew install bash-completion@2</strong></span></pre><blockquote class="nv nw nx"><p id="d0e2" class="kb kc kz kd b ke kf kg kh ki kj kk kl ny kn ko kp nz kr ks kt oa kv kw kx ky im bi translated"><strong class="kd iu"> <em class="it">注意:</em></strong><em class="it"/><code class="fe la lb lc ld b"><em class="it">@2</em></code><em class="it">标记表示bash-completion的主要版本2(在撰写本文时，最新版本是2.8)，必须用于Bash 4.1和更高版本。如果您(希望)将Mac上的默认shell升级到Bash的最新版本，那么这是可以使用的正确版本。如果您仍然使用Bash 4.0或更低版本，您必须使用bash-completion的版本1(</em><code class="fe la lb lc ld b"><em class="it">brew install bash-completion</em></code><em class="it">)，但是，请记住，在这种情况下，许多完成脚本将无法在您的系统上工作！</em></p></blockquote><p id="af81" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要完成安装，您需要采取一些额外的步骤。注意，<code class="fe la lb lc ld b">brew install</code>命令的输出包括以下内容:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/9cdc8148066337b76801556b3537f569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5M3Wr7ezpM7hZrVJkDv9GQ.png"/></div></div></figure><p id="10fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一行来源于<code class="fe la lb lc ld b">bash_completion.sh</code>脚本，该脚本又来源于上一节提到的<code class="fe la lb lc ld b">bash_completion</code>脚本(该脚本提供了<em class="kz"> bash-completion </em>提供的所有功能)。</p><p id="ac5e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您需要将这一行添加到您的<code class="fe la lb lc ld b">.bashrc</code>或<code class="fe la lb lc ld b">.bash_profile</code>文件中，以便实际使用<em class="kz"> bash-completion </em>。如果你不这样做，就好像你根本没有安装<em class="kz"> bash-completion </em>。</p><p id="e84f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面输出中的第二行将<code class="fe la lb lc ld b">BASH_COMPLETION_COMPAT_DIR</code>环境变量设置为<code class="fe la lb lc ld b">/usr/local/etc/bash_completion.d</code>。这允许您继续为版本1的<em class="kz"> bash-completion </em>使用家酿公式的遗留约定。</p><p id="cca7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">约定是<code class="fe la lb lc ld b">bash_completion</code>脚本在<code class="fe la lb lc ld b">/usr/local/etc/bash_completion.d</code>目录中获得所有的完成脚本。因此，许多家酿公式简单地将它们的完成脚本放到这个目录中，并假设它们将由<code class="fe la lb lc ld b">bash_completion</code>提供(如果<em class="kz"> bash-completion </em>也已经随家酿一起安装)。执行此操作的公式通常使用以下形式的输出来表明这一事实:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/3726c0c0db47fe24a7bc22cd5eea7e3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*Hlo2YHgjcqAe9lkjwWQOJw.png"/></div></div></figure><p id="2a47" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这非常实用，因为新的自制公式的完成脚本立即开始工作，用户不必在他们的<code class="fe la lb lc ld b">.bashrc</code>或<code class="fe la lb lc ld b">.bash_profile</code>文件中放入任何东西。但是在<em class="kz"> bash-completion </em>的版本2中，由于<a class="ae mh" href="https://github.com/Homebrew/homebrew-core/issues/36377" rel="noopener ugc nofollow" target="_blank">某些原因</a>这个默认行为被删除了(这里是<a class="ae mh" href="https://github.com/Homebrew/homebrew-core/pull/35992" rel="noopener ugc nofollow" target="_blank"> pull request </a>删除了这个特性)。然而，幸运的是，现在有了<code class="fe la lb lc ld b">BASH_COMPLETION_COMPAT_DIR</code>变量，如果你将它设置为<code class="fe la lb lc ld b">/usr/local/etc/bash_completion.d</code>，它允许你重新启用这个特性，如上面<code class="fe la lb lc ld b">brew install</code>的输出所示。</p><p id="9464" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果这样做，只需注意在您的<code class="fe la lb lc ld b">.bashrc</code>文件中，第二行必须在第一行之前(您必须在获取<code class="fe la lb lc ld b">bash_completion</code>脚本之前设置<code class="fe la lb lc ld b">BASH_COMPLETION_COMPAT_DIR</code>变量，否则它将不起作用)。因此，您应该将以下内容添加到您的<code class="fe la lb lc ld b">.bashrc</code>文件中:</p><pre class="mi mj mk ml gt mm ld mn mo aw mp bi"><span id="a74d" class="mq lf it ld b gy mr ms l mt mu"><strong class="ld iu">export BASH_COMPLETION_COMPAT_DIR="/usr/local/etc/bash_completion.d"<br/>[[ -r "/usr/local/etc/profile.d/bash_completion.sh" ]] &amp;&amp; . "/usr/local/etc/profile.d/bash_completion.sh"</strong></span></pre><p id="163e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看<code class="fe la lb lc ld b">brew install</code>命令实际上安装在您的系统上。<em class="kz"> bash-completion </em>安装的基础目录是<code class="fe la lb lc ld b">/usr/local/share/bash-completion</code>(假设你的自制前缀是<code class="fe la lb lc ld b">/usr/local</code>，可以用<code class="fe la lb lc ld b">brew --prefix</code>找到)。</p><p id="20d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe la lb lc ld b">/usr/local/share/bash-completion</code>目录的内容应包含以下内容:</p><ul class=""><li id="4943" class="nh ni it kd b ke kf ki kj km nj kq nk ku nl ky od nn no np bi translated"><code class="fe la lb lc ld b">bash_completion</code>(文件)</li><li id="95ac" class="nh ni it kd b ke nq ki nr km ns kq nt ku nu ky od nn no np bi translated"><code class="fe la lb lc ld b">completions</code>(目录)</li></ul><p id="af4c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一项是上面提到的<code class="fe la lb lc ld b">bash_completion</code>脚本。第二项是包含所有由<em class="kz"> bash-completion </em>为常用命令提供的完成脚本的目录，比如<code class="fe la lb lc ld b">ssh</code>、<code class="fe la lb lc ld b">wget</code>、<code class="fe la lb lc ld b">curl</code>以及许多其他命令。</p><p id="38e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于<code class="fe la lb lc ld b">bash_completion</code>在<code class="fe la lb lc ld b">completions</code>目录中提供完成脚本，这些完成功能现在应该已经可以工作了。例如，您可以通过键入<code class="fe la lb lc ld b">wget --f[tab][tab]</code>来使用<code class="fe la lb lc ld b">wget</code>进行测试，这将显示以<code class="fe la lb lc ld b">f</code>开头的所有<code class="fe la lb lc ld b">wget</code>选项的列表。</p><p id="f858" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为您向您的<code class="fe la lb lc ld b">.bashrc</code>文件添加了一个获取<code class="fe la lb lc ld b">bash_completion</code>脚本的代码片段，它将在您启动的每个shell中获取。这意味着<code class="fe la lb lc ld b">bash_completion</code>中定义的函数现在可以用于您安装的任何工具的任何完成脚本。下一节将解释获取和管理这种完成脚本的最佳方式。</p><h1 id="6457" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用完成脚本</h1><p id="8e52" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">一旦安装了<em class="kz"> bash-completion </em>，使用依赖于<em class="kz"> bash-completion </em>的第三方补全脚本就很容易了。实际上有多种方法可以做到这一点，在下面的小节中按照用户友好性的递增顺序解释了其中的三种方法。</p><h2 id="7d7c" class="mq lf it bd lg mv mw dn lk mx my dp lo km mz na ls kq nb nc lw ku nd ne ma nf bi translated">简单地找到它</h2><p id="9b8d" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">让我们以<code class="fe la lb lc ld b">kubectl</code>命令的完成脚本为例。这个完成脚本可以通过运行<code class="fe la lb lc ld b">kubectl completion bash</code>用<code class="fe la lb lc ld b">kubectl</code>命令本身方便地生成。</p><p id="ce10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上一节中，我声称在安装了<em class="kz"> bash-completion </em>之后，您的系统已经设置好了，因此依赖于<em class="kz"> bash-completion </em>的第三方补全脚本可以成功使用。如果这是真的，那么提供<code class="fe la lb lc ld b">kubectl completion bash</code>的输出现在应该能够完成<code class="fe la lb lc ld b">kubectl</code>。让我们来测试一下:</p><pre class="mi mj mk ml gt mm ld mn mo aw mp bi"><span id="be37" class="mq lf it ld b gy mr ms l mt mu">$ <strong class="ld iu">source &lt;(kubectl completion bash)</strong></span></pre><p id="1934" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在尝试自动完成<code class="fe la lb lc ld b">kubectl</code>命令:</p><pre class="mi mj mk ml gt mm ld mn mo aw mp bi"><span id="3826" class="mq lf it ld b gy mr ms l mt mu">$ <strong class="ld iu">kubectl [tab][tab]</strong>       # Lists sub-commands of "kubectl"<br/>$ <strong class="ld iu">kubectl -[tab][tab]</strong>      # Lists applicable options for "kubectl"<br/>$ <strong class="ld iu">kubectl get -[tab][tab]</strong>  # Lists applicable options for "get"</span></pre><p id="27a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有用！</p><p id="22cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，您可以对任何完成脚本进行同样的操作。只要找到它(最好给你的<code class="fe la lb lc ld b">.bashrc</code>添加一个<code class="fe la lb lc ld b">source</code>命令)，这个命令的完成应该开始工作。</p><p id="50be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，如果您用Homebrew安装了<em class="kz"> bash-completion </em>，并且如果您还设置了<code class="fe la lb lc ld b">BASH_COMPLETION_COMPAT_DIR</code>变量，则有一种更简单的方法来使用第三方完成脚本，如下一节所述。</p><h2 id="225e" class="mq lf it bd lg mv mw dn lk mx my dp lo km mz na ls kq nb nc lw ku nd ne ma nf bi translated">简单地放弃它</h2><p id="e723" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">正如我们已经看到的，<code class="fe la lb lc ld b">bash_completion</code>脚本在几个位置提供完成脚本。首先，这是<em class="kz"> bash-completion </em>项目中的<code class="fe la lb lc ld b">completions</code>目录(包含基本命令的完成脚本)。此外，如果您设置了<code class="fe la lb lc ld b">BASH_COMPLETION_COMPAT_DIR</code>变量，这也包括您分配给这个变量的目录。</p><p id="5a8c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果像推荐的那样，您将<code class="fe la lb lc ld b">BASH_COMPLETION_COMPAT_DIR</code>设置为<code class="fe la lb lc ld b">/usr/local/etc/bash_completion.d</code>，那么<code class="fe la lb lc ld b">bash_completion</code>将在这个目录中获得所有的完成脚本(不管它们是如何到达那里的)。因此，您可以将任何完成脚本放到这个目录中，一旦获得了<code class="fe la lb lc ld b">bash_completion</code>脚本(当您的<code class="fe la lb lc ld b">.bashrc</code>文件获得源代码时就会发生这种情况)，它就会开始工作。</p><p id="9076" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这意味着您可以完成一个命令，而不必向您的<code class="fe la lb lc ld b">.bashrc</code>文件添加任何东西！</p><p id="ad76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们通过将<code class="fe la lb lc ld b">kubectl</code>完成脚本放到这个目录来测试它，而不是将它放在<code class="fe la lb lc ld b">.bashrc</code>文件中:</p><pre class="mi mj mk ml gt mm ld mn mo aw mp bi"><span id="09d0" class="mq lf it ld b gy mr ms l mt mu">$ <strong class="ld iu">kubectl completion bash &gt;/usr/local/etc/bash_completion.d/kubectl</strong></span></pre><blockquote class="nv nw nx"><p id="0ab4" class="kb kc kz kd b ke kf kg kh ki kj kk kl ny kn ko kp nz kr ks kt oa kv kw kx ky im bi translated">注意，目标目录中的文件名无关紧要。</p></blockquote><p id="1038" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，重新启动您的shell(或来源您的<code class="fe la lb lc ld b">.bashrc</code>文件)，并且<code class="fe la lb lc ld b">kubectl</code>完成应该工作了！</p><p id="8a0e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在这很容易，但是您仍然需要手动将完成脚本放到<code class="fe la lb lc ld b">/usr/local/etc/bash_completion.d</code>目录中。正如我们已经看到的，许多自制公式按照惯例将它们的完成脚本放在这个目录中，这给我们带来了管理完成脚本的最方便的方式。</p><h2 id="4174" class="mq lf it bd lg mv mw dn lk mx my dp lo km mz na ls kq nb nc lw ku nd ne ma nf bi translated">简单地使用自制</h2><p id="d221" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">由于自制公式按照惯例将命令的完成脚本放在<code class="fe la lb lc ld b">/usr/local/etc/bash_completion.d</code>中，您甚至不用手动将完成脚本移动到那里。</p><p id="f79e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这意味着，如果您安装了这样一个自制公式，那么完成会立即开始工作(也就是说，在重新启动您的shell或找到您的<code class="fe la lb lc ld b">.bashrc</code>文件之后)，而无需您进行任何进一步的操作！</p><p id="7a0c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是请记住，这只有在您在<code class="fe la lb lc ld b">.bashrc</code>文件中设置了<code class="fe la lb lc ld b">BASH_COMPLETION_COMPAT_DIR</code>变量时才有效，如<code class="fe la lb lc ld b">brew install bash-completion@2</code>命令的输出所示。</p><h1 id="a549" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">摘要</h1><p id="ec98" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">在这篇文章中，我们涉及了相当多的内容。<a class="ae mh" href="https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion.html" rel="noopener ugc nofollow" target="_blank">可编程完成</a>是Bash的一个特性，它允许定义特定于命令的自动完成。这是通过<code class="fe la lb lc ld b"><a class="ae mh" href="https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html" rel="noopener ugc nofollow" target="_blank">complete</a></code>内置的方式与命令绑定的完成规范来工作的。实际上，完成支持通常由命令创建者以完成脚本的形式提供。</p><p id="95c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">macOS包括一个Bash的旧版本，它不支持许多现代完成脚本使用的可编程完成特性。因此，在使用可编程补全之前，在Mac上安装一个新版本的Bash 是至关重要的。</p><p id="7f8a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，许多完成脚本依赖于<a class="ae mh" href="https://github.com/scop/bash-completion/blob/master/bash_completion" rel="noopener ugc nofollow" target="_blank"> <em class="kz"> bash-completion </em> </a>项目，因此您必须安装该项目。安装<em class="kz"> bash-completion </em>的最佳方式是使用<a class="ae mh" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank">自制软件</a>。这允许简单地将第三方完成脚本放到<code class="fe la lb lc ld b">/usr/local/etc/bash_completion.d</code>文件夹中，在那里它们被<em class="kz"> bash-completion </em>获取并自动开始工作。</p><p id="fcf2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认情况下，家酿公式将其命令的完成脚本放入<code class="fe la lb lc ld b">/usr/local/etc/bash_completion.d</code>，这意味着对于这些命令，如果您还安装了带有家酿的<em class="kz"> bash-completion </em>，完成会立即开始工作。</p><h1 id="6d86" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">参考</h1><h2 id="e3e8" class="mq lf it bd lg mv mw dn lk mx my dp lo km mz na ls kq nb nc lw ku nd ne ma nf bi translated">可编程完成</h2><ul class=""><li id="1592" class="nh ni it kd b ke mc ki md km oe kq of ku og ky od nn no np bi translated"><a class="ae mh" href="https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion.html" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">https://www . GNU . org/software/bash/manual/html _ node/Programmable-completion . html</strong></a></li><li id="8783" class="nh ni it kd b ke nq ki nr km ns kq nt ku nu ky od nn no np bi translated"><a class="ae mh" href="https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">https://www . GNU . org/software/bash/manual/html _ node/Programmable-Completion-builtins . html</strong></a></li><li id="b3a8" class="nh ni it kd b ke nq ki nr km ns kq nt ku nu ky od nn no np bi translated"><a class="ae mh" href="https://www.gnu.org/software/bash/manual/html_node/A-Programmable-Completion-Example.html" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">https://www . GNU . org/software/bash/manual/html _ node/A-Programmable-Completion-example . html</strong></a></li><li id="a624" class="nh ni it kd b ke nq ki nr km ns kq nt ku nu ky od nn no np bi translated"><a class="ae mh" href="http://freshmeat.sourceforge.net/projects/bashcompletion" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"/>http://freshmeat.sourceforge.net/projects/bashcompletion</a></li><li id="7413" class="nh ni it kd b ke nq ki nr km ns kq nt ku nu ky od nn no np bi translated">【https://www.tldp.org/LDP/abs/html/tabexpansion.html】T5<a class="ae mh" href="https://www.tldp.org/LDP/abs/html/tabexpansion.html" rel="noopener ugc nofollow" target="_blank">T6</a></li></ul><h2 id="3365" class="mq lf it bd lg mv mw dn lk mx my dp lo km mz na ls kq nb nc lw ku nd ne ma nf bi translated"><strong class="ak"> GNU Bash </strong></h2><ul class=""><li id="5bc5" class="nh ni it kd b ke mc ki md km oe kq of ku og ky od nn no np bi translated"><a class="ae mh" href="https://www.gnu.org/software/bash/" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">https://www.gnu.org/software/bash/</strong></a></li><li id="9f5a" class="nh ni it kd b ke nq ki nr km ns kq nt ku nu ky od nn no np bi translated"><a class="ae mh" href="https://www.gnu.org/software/bash/manual/html_node/" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">https://www.gnu.org/software/bash/manual/html_node/</strong></a></li><li id="4d0a" class="nh ni it kd b ke nq ki nr km ns kq nt ku nu ky od nn no np bi translated"><a class="ae mh" href="https://tiswww.case.edu/php/chet/bash/bashtop.html" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">https://tiswww.case.edu/php/chet/bash/bashtop.html</strong></a></li></ul><h2 id="d36e" class="mq lf it bd lg mv mw dn lk mx my dp lo km mz na ls kq nb nc lw ku nd ne ma nf bi translated"><strong class="ak">痛击-完成</strong></h2><ul class=""><li id="a8cc" class="nh ni it kd b ke mc ki md km oe kq of ku og ky od nn no np bi translated"><a class="ae mh" href="https://github.com/scop/bash-completion" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">https://github.com/scop/bash-completion</strong></a></li></ul><h2 id="2fc2" class="mq lf it bd lg mv mw dn lk mx my dp lo km mz na ls kq nb nc lw ku nd ne ma nf bi translated"><strong class="ak">特定命令完成</strong></h2><ul class=""><li id="e257" class="nh ni it kd b ke mc ki md km oe kq of ku og ky od nn no np bi translated"><a class="ae mh" href="https://github.com/git/git/blob/master/contrib/completion/git-completion.bash" rel="noopener ugc nofollow" target="_blank">T31】https://github . com/git/git/blob/master/contrib/completion/git-completion . bashT33】</a></li><li id="4b18" class="nh ni it kd b ke nq ki nr km ns kq nt ku nu ky od nn no np bi translated"><a class="ae mh" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#enabling-shell-autocompletion" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">https://kubernetes . io/docs/tasks/tools/install-kubectl/# enabling-shell-autocompletion</strong></a></li><li id="758a" class="nh ni it kd b ke nq ki nr km ns kq nt ku nu ky od nn no np bi translated"><a class="ae mh" href="https://docs.docker.com/docker-for-mac/#install-shell-completion" rel="noopener ugc nofollow" target="_blank">T39】https://docs . docker . com/docker-for-MAC/# install-shell-completion</a></li><li id="b6dc" class="nh ni it kd b ke nq ki nr km ns kq nt ku nu ky od nn no np bi translated"><a class="ae mh" href="https://github.com/docker/cli/blob/master/contrib/completion/bash/docker" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">https://github . com/docker/CLI/blob/master/contrib/completion/bash/docker</strong></a></li></ul><h1 id="424f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">附录</h1><h2 id="a569" class="mq lf it bd lg mv mw dn lk mx my dp lo km mz na ls kq nb nc lw ku nd ne ma nf bi translated">启用和禁用可编程完成</h2><p id="941d" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">默认情况下，Bash中启用了可编程完成，可以使用以下命令显式地打开和关闭它:</p><pre class="mi mj mk ml gt mm ld mn mo aw mp bi"><span id="fbaf" class="mq lf it ld b gy mr ms l mt mu">$ <a class="ae mh" href="https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html" rel="noopener ugc nofollow" target="_blank"><strong class="ld iu">shopt</strong></a><strong class="ld iu"> -s progcomp</strong>    # Enable programmable completion<br/>$ <a class="ae mh" href="https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html" rel="noopener ugc nofollow" target="_blank"><strong class="ld iu">shopt</strong></a><strong class="ld iu"> -u progcomp</strong>    # Disable programmable completion</span></pre><p id="0cf7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您禁用它，那么所有的完成规范都会被忽略，但是默认的Bash完成(如上所述)仍然是活动的。</p></div></div>    
</body>
</html>