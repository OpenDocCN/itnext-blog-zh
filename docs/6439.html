<html>
<head>
<title>Kubernetes for dummies: Life of a Pod</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">假人的Kubernetes:豆荚的生活</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-for-dummies-life-of-a-pod-fc8158e27aa?source=collection_archive---------0-----------------------#2021-11-17">https://itnext.io/kubernetes-for-dummies-life-of-a-pod-fc8158e27aa?source=collection_archive---------0-----------------------#2021-11-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="400f" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">KUBERNETES |云概念</h2><div class=""/><div class=""><h2 id="39ed" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">第三部分——豆荚和其他东西？</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/610f5ebf790135d498e1c77491a7318c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jdBWDI2n38l5YT0pm3WMsg.png"/></div></div></figure><p id="a643" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">欢迎回来，年轻的学徒！现在，您已经了解了k8s集群中的组件(<a class="ae lw" href="http://bit.ly/fawix-k8s-p2" rel="noopener ugc nofollow" target="_blank">第2部分</a>)。今天我们来看看我们最基本的构造之一:豆荚。当我们运行应用程序时，我们将看到它们是如何参与的。</p><h1 id="d6e2" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">Pod #WTF</h1><p id="4df0" class="pw-post-body-paragraph la lb iq lc b ld mp ka lf lg mq kd li lj mr ll lm ln ms lp lq lr mt lt lu lv ij bi translated">pod是Kubernetes中最基本的构建模块之一。它们是最小的可展开物体。他们的目标是为你的容器提供一个运行时环境。尽管Pods需要其他对象才能真正有用，但它们是Kubernetes中代表您的应用程序的部分。其他几个物体将建立在吊舱所提供的能力上。今天，我们将重点讨论他们如何运行我们的工作负载。在下一篇文章中，我们将关注那些与pod交互的其他对象，以使它们更加健壮和通用。</p><p id="7b94" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">也许你希望我说最小的Kubernetes对象是容器？不是这样的，年轻的学徒！k8s集群中每个正在运行的容器都在一个Pod中。实际上，你永远不会让容器自己运行。</p><p id="7847" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">Pod为容器提供了一个运行环境，包括网络和存储。如有必要，一个Pod可以有多个容器。同一Pod中的容器紧密耦合并共享资源(网络和存储、安全规则等。).</p><p id="5edb" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">从概念上讲，Pod如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mu"><img src="../Images/cab096920f6360e96155cfd077c32c18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GYlS2shkBs8-yvk_"/></div></div></figure><p id="596a" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">一个Pod只能分配一个IP，不管它有多少个容器。也就是说，在一个Pod中，容器共享相同的网络名称空间(IP和端口)。结果是Pod中的容器可以通过localhost (127.0.0.1)进行通信。或者，Pod还可以指定一种或多种存储方法，称为卷。Pod中的所有容器都可以访问已装载的卷。豆荚也可以共享存储，但这是另一篇文章。</p><p id="7a0b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">有趣的是，Pod这个名字来自鲸鱼的统称。它暗指里面的容器，主要是与Docker(Docker标志是一条鲸鱼！).</p><p id="8a35" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">当然，现在我们来看看一个实际的物体是什么样子的:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="0c44" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这些是安装Pod所需的必填字段。随着我们的发展，我们将会看到其他物体使用豆荚来建立更多的能力，然后扩展到其他领域。</p><p id="2733" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">上面需要注意的一件重要事情是字段<code class="fe mx my mz na b">spec.containers</code>，它是一个您可以定义的容器数组。<code class="fe mx my mz na b">image</code>字段是实际容器的名称及其存储库(省略时，默认为DockerHub)和一个标签。容器标记只是管理您的版本和发布的一种方式。有了这个，你就可以瞄准容器的一个特定版本。在上面的例子中，我们在DockerHub中使用带有stable-alpine标签的<a class="ae lw" href="https://hub.docker.com/layers/nginx/library/nginx/stable-alpine/images/sha256-415f060bbd6fbabb39d19b604247204b5429f340fa571bfdd12f724dbff2839a?context=explore" rel="noopener ugc nofollow" target="_blank"> nginx容器(因为我们省略了存储库位)。</a></p><h1 id="c381" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">并非所有容器都是生而平等的</h1><p id="1112" class="pw-post-body-paragraph la lb iq lc b ld mp ka lf lg mq kd li lj mr ll lm ln ms lp lq lr mt lt lu lv ij bi translated">当我们谈到容器时，首先想到的是运行我们的应用程序的容器。通常是一个长期运行的进程，它会一直运行，直到我们终止它或出现问题。但是，我想快速介绍一下Pod中的另外两种容器，以及它们的用途:</p><p id="9373" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja"> Init容器:</strong>顾名思义，Init容器适用于初始化和设置。它们在pod中的常规容器启动之前运行。与常规容器不同，这些容器应该总是运行到完成并成功退出，否则Pod将进入失败状态(下面将详细介绍)。</p><p id="ee10" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">短暂容器:</strong>这是一种相当新的(1.22中的alpha)容器类型。它对资源或执行没有任何保证，它们永远不会自动重启(不要用它们来构建应用程序)。这对于故障排除和短期操作的交互式shells非常有用。</p><p id="8ccc" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为了保持一致，每当我谈到“容器”时，它就是您的常规工作负载容器。当我们谈论其他两种类型时，我将特别指出它们。</p><h1 id="b72a" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">豆荚的生命</h1><p id="bdbe" class="pw-post-body-paragraph la lb iq lc b ld mp ka lf lg mq kd li lj mr ll lm ln ms lp lq lr mt lt lu lv ij bi translated">如您所见，Pods提供了运行容器所需的基本组件。现在让我们来看看一个荚果是如何产生生命并最终死亡的:荚果生命周期。</p><p id="407b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">从高层次上来说，概念化很简单:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nb"><img src="../Images/346e4595719203875a5346d8c4ce2cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_IEYpJCoURZm_pkO"/></div></div></figure><p id="fe38" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">首先，我们创建Pod。在这个阶段，Kubernetes从注册中心获取容器。然后k8s让一个节点运行Pod这导致围绕网络和存储创建必要的结构。然后它在那个空间运行容器。如果提取容器失败，Pod将呈现“未知”状态。</p><p id="f6ce" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">容器中的进程将处于前台，直到完成或外部命令终止它。这就是跑步状态。如果Pod失败，则状态设置为失败。如果运行成功，它将呈现终止状态。</p><p id="08ec" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">好，让我们创建一个POD！如果你想继续下去，年轻学徒，抓取上面的示例对象并将其保存为<code class="fe mx my mz na b">pod.yaml</code>！PS:如果你还没有k8s安装，可以随意使用<a class="ae lw" href="https://www.katacoda.com/courses/kubernetes/playground" rel="noopener ugc nofollow" target="_blank">奥赖利的Katacoda互动游乐场</a>。</p><p id="827c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为此，我们将简单地运行<code class="fe mx my mz na b">kubectl create -f pod.yaml</code></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/8f7fc0d7688f24a6928ee92ca21ef790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pDmR86rrOwiBYWEH"/></div></div></figure><p id="4bbb" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">还记得我们在第二部分中描述的组件吗？你已经可以放弃原力了，年轻的学徒。你认为引擎盖下发生了什么？在你继续阅读以获得最大经验值之前，好好想想吧！</p><p id="2803" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">好了，准备好了！？<br/> <br/>让我们检查运行该命令时发生的详细情况:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nd"><img src="../Images/0daa0923e666dace9e69a171d3561f45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EiGASjd_UXLJJeL8"/></div></div></figure><ol class=""><li id="04f5" class="ne nf iq lc b ld le lg lh lj ng ln nh lr ni lv nj nk nl nm bi translated">用户运行kubectl create命令来创建对象</li><li id="9e50" class="ne nf iq lc b ld nn lg no lj np ln nq lr nr lv nj nk nl nm bi translated">kubectl调用API服务器来创建对象</li><li id="8438" class="ne nf iq lc b ld nn lg no lj np ln nq lr nr lv nj nk nl nm bi translated">API服务器将对象保存在etcd中</li><li id="6e7c" class="ne nf iq lc b ld nn lg no lj np ln nq lr nr lv nj nk nl nm bi translated">调度程序检测到新的Pod已创建，并且未分配给节点</li><li id="4c6c" class="ne nf iq lc b ld nn lg no lj np ln nq lr nr lv nj nk nl nm bi translated">然后，调度程序用选择的节点更新Pod对象。它考虑了几个约束来定义哪个节点获得Pod。这些标签和污点定义了相似性(一起运行pod组)或反相似性(避免将pod安排在一起)规则。</li><li id="d11a" class="ne nf iq lc b ld nn lg no lj np ln nq lr nr lv nj nk nl nm bi translated">kube-controller-manager随后检测到Pod所需的状态与当前状态不匹配，并对API服务器进行必要的调用(这是一个双向流程)；在这一点上，正确的控制器将作出反应，做这些变化</li><li id="eb3c" class="ne nf iq lc b ld nn lg no lj np ln nq lr nr lv nj nk nl nm bi translated">这又触发了从API服务器到选定节点中的kubelet的API调用，以创建实际的Pod</li><li id="282f" class="ne nf iq lc b ld nn lg no lj np ln nq lr nr lv nj nk nl nm bi translated">作为设置Pod的一部分，联网kube-proxy通过包过滤层对操作系统进行所需的更改</li></ol><p id="c71b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这样，你的豆荚就创建好了！任何对象创建都像这样工作，根据需要涉及不同的控制器。</p><p id="82fc" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">此时，您只能通过本地网络访问工作负载。这意味着，您需要连接到Pod:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/9f5ce283f95b5a39bd0e651c318763ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XNLwMfnLvUKBbsla"/></div></div></figure><p id="5cb8" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如果你创造了我们的豆荚，你应该花些时间玩它。检查运行<code class="fe mx my mz na b">kubectl describe pod nginx</code>时会发生什么，或者尝试从Pod内部发送一个<code class="fe mx my mz na b">SIGKILL</code>到nginx进程。看看会发生什么！好奇！</p><p id="b5bf" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在，你可能会想:我不能用本地主机访问运行我的应用程序！？正确你是！这对于工作负载来说并不理想，我们将在第4部分使用服务来解决这个问题。然而，此时此刻，您实际上已经在kubernetes中运行了您的工作负载！需要注意的一点是，一旦Pod被终止或遇到故障，它将只是处于终止或故障状态，不会重新启动。这是部署解决的问题，我们将在下一篇文章<a class="ae lw" href="https://bit.ly/fawix-k8s-p4" rel="noopener ugc nofollow" target="_blank">中看到。</a></p><p id="c8ee" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在<a class="ae lw" href="https://twitter.com/fawix" rel="noopener ugc nofollow" target="_blank"> Twitter (@fawix) </a>或<a class="ae lw" href="https://www.linkedin.com/in/fatimasilv/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上关注我，这样你就不会错过更新了！愿集装箱与你同在！</p></div></div>    
</body>
</html>