<html>
<head>
<title>CQRS Pattern &amp; NestJS (Node.js)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CQRS模式&amp; NestJS (Node.js)</h1>
<blockquote>原文：<a href="https://itnext.io/cqrs-pattern-nestjs-node-js-cf20fd9bb07?source=collection_archive---------0-----------------------#2020-01-04">https://itnext.io/cqrs-pattern-nestjs-node-js-cf20fd9bb07?source=collection_archive---------0-----------------------#2020-01-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d31d" class="pw-subtitle-paragraph jr is it bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">有指导的介绍</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/a29227c58e89f4c9d854f381490310a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*duvh8Axq_UO0fA96nMVFZQ.png"/></div></div></figure><p id="7f54" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当设计一个遵循传统架构的应用程序时，读和写操作经常使用相同的数据模型。尽管它可能在小型应用程序或依赖简单逻辑的应用程序上工作得很好，但是当我们有一个更复杂的环境时，我们最终需要更复杂的解决方案。</p><p id="87d7" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在这篇文章中，我们将探索CQRS <em class="lr">设计模式</em>的基础，它的优点和缺点。此外，我们将深入探讨如何通过使用Node.js的<a class="ae ls" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> NestJS框架</a>来实现这种模式</p><p id="3f13" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="lr"> obs:如果你还没有检查过</em> <a class="ae ls" href="https://docs.nestjs.com/" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> NestJS框架</em> </a> <em class="lr">的话，我会全力推荐它。受Angular架构的启发，它是一个简单、高效且可扩展的Node.js框架。</em></p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="9e80" class="ma mb it bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">CQRS模式</h1><blockquote class="ms mt mu"><p id="9a12" class="kv kw lr kx b ky kz jv la lb lc jy ld mv lf lg lh mw lj lk ll mx ln lo lp lq im bi translated">“在大多数情况下，没有理由让中小型应用程序变得更复杂。然而，有时这还不够，当我们的需求变得更加复杂时，我们希望拥有具有简单数据流的可扩展系统。”<br/> <strong class="kx iu">内斯特·CQRS</strong></p></blockquote><p id="58a6" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当从服务器请求数据时，应用程序可能会执行多个查询，并根据请求的数据使用dto(数据传输对象)。此外，当需要更改数据或向数据库添加数据时，也可以使用d to执行一些操作。</p><p id="0c38" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在更大的应用程序中，映射这些对象并掌握其不同的格式会成为一个真正的问题。当执行一个写操作时，您可能还会得到实现多个验证和业务逻辑的复杂模型。</p><p id="e8cc" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">读取和写入操作之间的数据表示经常不匹配，这也使得控制在每个上下文中公开什么数据变得更加困难。因此，这种方法可能会对应用程序的性能、复杂性和安全性产生负面影响。</p><p id="3060" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">CQRS模式地址将读取和写入分离到不同的模型中，使用<strong class="kx iu">命令</strong>更新数据，使用<strong class="kx iu">查询</strong>读取数据。</p><p id="12f6" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">命令应该面向它们应该完成的任务。<br/> <strong class="kx iu">命令</strong>可能被放入队列进行异步处理。</p><p id="8bfc" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">查询</strong>从不修改数据库。<br/> <strong class="kx iu">查询</strong>返回<em class="lr">没有任何领域知识的dto</em>。</p><h2 id="55f6" class="my mb it bd mc mz na dn mg nb nc dp mk le nd ne mm li nf ng mo lm nh ni mq nj bi translated"><em class="jq">优点</em></h2><p id="1b0b" class="pw-post-body-paragraph kv kw it kx b ky nk jv la lb nl jy ld le nm lg lh li nn lk ll lm no lo lp lq im bi translated"><strong class="kx iu">离析。通过分离关注点——读(查询)和写(命令)操作——它有助于拥有更灵活的模型，有助于开发速度和便于维护。</strong></p><p id="b17c" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">可扩展性</strong>。<strong class="kx iu"> </strong>它允许您的查询和命令独立伸缩，从而减少锁争用。</p><p id="be65" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">优化模式</strong>。读写操作的模式针对其目的进行了优化，也更容易理解和维护。</p><p id="e02f" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">安全</strong>。更容易确保只有正确上下文中的正确实体能够访问数据的读写操作。</p><h2 id="6d10" class="my mb it bd mc mz na dn mg nb nc dp mk le nd ne mm li nf ng mo lm nh ni mq nj bi translated">面向连接的网络服务(Connection Oriented Network Service)</h2><p id="62d7" class="pw-post-body-paragraph kv kw it kx b ky nk jv la lb nl jy ld le nm lg lh li nn lk ll lm no lo lp lq im bi translated"><strong class="kx iu">复杂</strong>。CQRS的mais问题是，尽管CQRS的基本原则很简单，但其实施可能很复杂，而且成本很高。所以，应该只有在有意义的时候才使用；当可伸缩性是应用程序的一个重要问题时，当您处理复杂的模型和业务逻辑时，等等。否则，你实际上不是在简化，而是给应用程序带来了不必要的复杂性。</p><p id="4c3e" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">一致性。</strong>通过对查询和命令使用不同的模型，保持它们之间的一致性可能会变得更加困难，尤其是在处理复杂数据时。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="8a80" class="ma mb it bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">在NestJS中实施CQRS模式</h1><p id="18e7" class="pw-post-body-paragraph kv kw it kx b ky nk jv la lb nl jy ld le nm lg lh li nn lk ll lm no lo lp lq im bi translated">好了，现在让我们深入研究如何实现这个模式，以便更好地理解它是如何工作的。我们将通过使用NestJS框架来实现它。NestJS为我们提供了一个<strong class="kx iu">预建的CQRS模块</strong>，为了在NestJS中使用这种模式，这将使我们的生活变得更加容易。</p><p id="2ca7" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">首先，让我们安装NestJS的CLI，用它创建一个新项目，并将Nest的CQRS模块添加到我们的项目中。</p><pre class="kk kl km kn gt np nq nr ns aw nt bi"><span id="d541" class="my mb it nq b gy nu nv l nw nx">npm install -g @nestjs/cli<br/>nest new project-cqrs<br/>cd project-cqrs<br/>npm install @nestjs/cqrs --save<br/>npm run start</span></pre><p id="a812" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为了演示，我们将实现一个简单的用户CRUD特性。我们将创建一个用户控制器，其中我们将使用CQRS模式。让我们把<em class="lr">用户</em>分离出来作为一个特性，为它创建一个<em class="lr">模块</em>，这个<em class="lr">控制器</em>本身和两个文件夹:<em class="lr">命令</em>和<em class="lr">查询</em>。然后，我们将创建我们需要的每个<em class="lr">查询</em>和<em class="lr">命令</em>。</p><p id="17a7" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面是我们的项目结构和文件将如何。<br/>我们将深入研究所有的<em class="lr">用户</em>特性。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/1508035268e3c8b34141c98c9e7c598b.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*wZ6BCHGuSUaqjBFBMJxw9A.png"/></div></figure><h2 id="747b" class="my mb it bd mc mz na dn mg nb nc dp mk le nd ne mm li nf ng mo lm nh ni mq nj bi translated">问题</h2><p id="a9d1" class="pw-post-body-paragraph kv kw it kx b ky nk jv la lb nl jy ld le nm lg lh li nn lk ll lm no lo lp lq im bi translated">让我们以逐步构建我们的<em class="lr"> ListUsersQuery </em>为例。<br/>首先，我们定义一个类作为我们的<em class="lr">查询</em>，它将包含其<em class="lr">处理程序</em>所需的信息。因为我们要列出用户，所以知道请求的页码和页面大小很重要。</p><pre class="kk kl km kn gt np nq nr ns aw nt bi"><span id="51ad" class="my mb it nq b gy nu nv l nw nx">export class ListUsersQuery {<br/>  constructor(<br/>    public page: number = 1,<br/>    public pageSize: number = 10<br/>  ) { }<br/>}</span></pre><p id="e298" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">接下来，我们创建我们的处理程序，当这个<em class="lr">查询</em>在<em class="lr">查询总线中被调用时，它将被触发。</em></p><p id="1784" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="lr"> QueryBus </em>是一个查询流。当被请求时，它将查询委托给它的对等处理程序。每个<em class="lr">查询</em>必须有其对应的<em class="lr">处理程序</em>。这种关联是通过使用<em class="lr"> @QueryHandler </em>装饰器来实现的。</p><pre class="kk kl km kn gt np nq nr ns aw nt bi"><span id="c4ef" class="my mb it nq b gy nu nv l nw nx">@QueryHandler(ListUsersQuery)<br/>export class ListHandler implements IQueryHandler&lt;ListUsersQuery&gt; {}</span></pre><p id="48bf" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们现在已经创建了<em class="lr"> ListHandler，</em>，它将处理我们之前创建的查询<em class="lr"> ListUsersQuery </em>。稍后我们将看到这个<em class="lr">查询</em>如何被<em class="lr">查询总线调用。</em></p><p id="a459" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在我们要做的是在我们的<em class="lr">处理程序</em>中包含我们的逻辑。当<em class="lr">查询</em>被调用时，它将调用<em class="lr">处理程序的</em> <strong class="kx iu"> <em class="lr">执行</em> </strong>方法。我们的<em class="lr">处理程序</em>逻辑将驻留在那里。</p><pre class="kk kl km kn gt np nq nr ns aw nt bi"><span id="0e33" class="my mb it nq b gy nu nv l nw nx">@QueryHandler(ListUsersQuery)<br/>export class ListHandler implements IQueryHandler&lt;ListUsersQuery&gt; {</span><span id="d3ca" class="my mb it nq b gy nz nv l nw nx">  constructor(<br/>    // Here we would inject what is necessary to retrieve our data<br/>  ) { }</span><span id="db50" class="my mb it nq b gy nz nv l nw nx">  public async execute(query: ListUsersQuery): Promise&lt;User[]&gt; {<br/>    // Here we are going to have any necessary logic related<br/>    // to that Query and return the requested information<br/>    // such as a service method call<br/>  }<br/>}</span></pre><p id="8dd7" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最后，这就是我们的<em class="lr">列表用户查询</em>的样子:</p><pre class="kk kl km kn gt np nq nr ns aw nt bi"><span id="872d" class="my mb it nq b gy nu nv l nw nx">export class ListQuery {<br/>  constructor(<br/>    public page: number = 1,<br/>    public pageSize: number = 10<br/>  ) { }<br/>}</span><span id="ff89" class="my mb it nq b gy nz nv l nw nx">@QueryHandler(ListUsersQuery)<br/>export class ListHandler implements IQueryHandler&lt;ListUsersQuery&gt; {</span><span id="e51d" class="my mb it nq b gy nz nv l nw nx">  constructor(<br/>    // Here we would inject what is necessary to retrieve our data<br/>  ) { }</span><span id="a6b7" class="my mb it nq b gy nz nv l nw nx">  public async execute(query: ListUsersQuery): Promise&lt;User[]&gt; {<br/>    // Here we are going to have any necessary logic related<br/>    // to that Query and return the request information<br/>    // such as a service method call<br/>  }<br/>}</span></pre><p id="06f3" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面是我们的另一个查询，<em class="lr"> GetUserById </em> one，<em class="lr"> </em>的样子；现在添加一些示例代码<a class="ae ls" href="https://docs.nestjs.com/techniques/database" rel="noopener ugc nofollow" target="_blank">，使用TypeORM 访问<em class="lr">存储库来检索数据。</em></a></p><pre class="kk kl km kn gt np nq nr ns aw nt bi"><span id="6ab5" class="my mb it nq b gy nu nv l nw nx">// All we need is the id of the user we want to retrieve the data<br/>export class GetUserByIdQuery {<br/>  constructor(<br/>    public id: number<br/>  ) { }<br/>}</span><span id="19b5" class="my mb it nq b gy nz nv l nw nx">@QueryHandler(GetUserByIdQuery)<br/>export class GetUserByIdHandler implements<br/>  IQueryHandler&lt;GetUserByIdQuery&gt; {</span><span id="8417" class="my mb it nq b gy nz nv l nw nx">  // We inject our TypeORM repository to fetch the user data<br/>  constructor(<br/>    @InjectRepository(User)<br/>    private readonly _repository: Repository&lt;User&gt;<br/>  ) { }</span><span id="6fec" class="my mb it nq b gy nz nv l nw nx">  public async execute(query: GetUserByIdQuery): Promise&lt;User&gt; {<br/>    // We fetch user data and return it on the execute method       <br/>    return await this._repository.findOne(query.id);<br/>  }<br/>}</span></pre><h2 id="ea1a" class="my mb it bd mc mz na dn mg nb nc dp mk le nd ne mm li nf ng mo lm nh ni mq nj bi translated">命令</h2><p id="2406" class="pw-post-body-paragraph kv kw it kx b ky nk jv la lb nl jy ld le nm lg lh li nn lk ll lm no lo lp lq im bi translated">让我们以逐步构建我们的<em class="lr"> AddUserCommand </em>为例。<br/>这与我们如何创建<em class="lr">查询</em>非常相似。<br/>首先，我们将一个类定义为我们的<em class="lr">命令</em>，它将包含其<em class="lr">处理程序</em>所需的信息。这里我们需要添加新的用户信息。</p><pre class="kk kl km kn gt np nq nr ns aw nt bi"><span id="985b" class="my mb it nq b gy nu nv l nw nx">export class AddUserCommand {<br/>  constructor(<br/>    public name: string,<br/>    public email: string,<br/>    public birthdate: Date<br/>  ) { }<br/>}</span></pre><p id="c460" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">接下来，我们创建我们的<em class="lr">处理程序</em>，它将在<em class="lr">命令总线中调用<em class="lr">命令</em>时被触发。</em></p><p id="5d2b" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="lr">命令总线</em>是一串命令。当被请求时，它将命令委托给它的对等处理程序。每个<em class="lr">命令</em>必须有对应的<em class="lr">处理程序</em>。这种关联是通过使用<em class="lr"> @CommandHandler </em>装饰器来实现的。</p><pre class="kk kl km kn gt np nq nr ns aw nt bi"><span id="eb94" class="my mb it nq b gy nu nv l nw nx">@CommandHandler(AddUserCommand)<br/>export class AddUserHandler implements IQueryHandler&lt;AddUserCommand&gt; {}</span></pre><p id="5bf9" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们现在已经创建了<em class="lr"> AddUserHandler，</em>，它将处理我们之前创建的命令<em class="lr"> AddUserCommand </em>。稍后我们将看到<em class="lr">命令</em>如何被<em class="lr">命令总线调用。</em></p><p id="1e70" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在我们要做的是在我们的<em class="lr">处理程序</em>中包含我们的逻辑。当<em class="lr">命令</em>被调用时，它将调用<em class="lr">处理程序的</em> <strong class="kx iu"> <em class="lr">执行</em> </strong>方法。我们的<em class="lr">处理程序</em>逻辑将驻留在那里。</p><pre class="kk kl km kn gt np nq nr ns aw nt bi"><span id="e977" class="my mb it nq b gy nu nv l nw nx">@CommandHandler(AddUserCommand)<br/>export class AddUserHandler implements IQueryHandler&lt;AddUserCommand&gt; {<br/>    constructor(<br/>      // Here we would inject what is necessary to persist our data<br/>    ) { }</span><span id="c50f" class="my mb it nq b gy nz nv l nw nx">    public async execute(query: ListUsersQuery): Promise&lt;User&gt; {<br/>      // Here we are going to have any necessary logic related<br/>      // to that Command and do any change operations<br/>    }<br/>}</span></pre><p id="6a7d" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最后，这就是我们的<em class="lr"> AddUserCommand </em>的样子:</p><pre class="kk kl km kn gt np nq nr ns aw nt bi"><span id="2060" class="my mb it nq b gy nu nv l nw nx">export class AddUserCommand {<br/>  constructor(<br/>    public name: string,<br/>    public email: string,<br/>    public birthdate: Date<br/>  ) { }<br/>}</span><span id="e7c2" class="my mb it nq b gy nz nv l nw nx">@CommandHandler(AddUserCommand)<br/>export class AddUserHandler implements IQueryHandler&lt;AddUserCommand&gt; {<br/>    constructor(<br/>      // Here we would inject what is necessary to persist our data<br/>    ) { }</span><span id="90dd" class="my mb it nq b gy nz nv l nw nx">    public async execute(query: ListUsersQuery): Promise&lt;User&gt; {<br/>      // Here we are going to have any necessary logic related<br/>      // to that Command and do any change operations<br/>    }<br/>}</span></pre><p id="fa07" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面是我们的其他<em class="lr">命令</em>、<em class="lr"> UpdateUser </em>和<em class="lr"> DeleteUser、</em>的样子，现在添加一些示例代码<a class="ae ls" href="https://docs.nestjs.com/techniques/database" rel="noopener ugc nofollow" target="_blank">来访问一个<em class="lr">库，使用TypeORM </em>对数据库进行更改。</a></p><p id="f899" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> <em class="lr">更新用户命令</em> </strong></p><pre class="kk kl km kn gt np nq nr ns aw nt bi"><span id="9f37" class="my mb it nq b gy nu nv l nw nx">export class UpdateUserCommand {<br/>  constructor(<br/>    public id: number,<br/>    public name?: string,<br/>    public email?: string,<br/>    public birthdate?: Date<br/>  ) { }<br/>}</span><span id="38d9" class="my mb it nq b gy nz nv l nw nx">@CommandHandler(UpdateUserCommand)<br/>export class UpdateUserHandler implements IQueryHandler&lt;UpdateUserCommand&gt;<br/>{<br/>    constructor(<br/>      @InjectRepository(User)<br/>      private readonly _repository: Repository&lt;User&gt;<br/>    ) { }</span><span id="3fa8" class="my mb it nq b gy nz nv l nw nx">    public async execute(request: UpdateUserCommand): Promise&lt;User&gt;<br/>    {<br/>      const user = await this._repository.findOne(request.id);</span><span id="1987" class="my mb it nq b gy nz nv l nw nx">      if (!user)<br/>        throw new NotFoundException('User does not exist');</span><span id="6b03" class="my mb it nq b gy nz nv l nw nx">      user.name = request.name || user.name;<br/>      user.email = request.email || user.email;<br/>      user.birthdate = request.birthdate|| user.birthdate;</span><span id="db12" class="my mb it nq b gy nz nv l nw nx">      return await this._repository.save( user );<br/>    }<br/>}</span></pre><p id="2621" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> <em class="lr">删除用户命令</em> </strong></p><pre class="kk kl km kn gt np nq nr ns aw nt bi"><span id="ff61" class="my mb it nq b gy nu nv l nw nx">export class DeleteUserCommand {<br/>  constructor(<br/>    public id: number<br/>  ) { }<br/>}</span><span id="6c9e" class="my mb it nq b gy nz nv l nw nx">@CommandHandler(DeleteUserCommand)<br/>export class DeleteUserHandler implements IQueryHandler&lt;DeleteUserCommand&gt;<br/>{<br/>    constructor(<br/>      @InjectRepository(User)<br/>      private readonly _repository: Repository&lt;User&gt;<br/>    ) { }</span><span id="fa61" class="my mb it nq b gy nz nv l nw nx">    public async execute(request: DeleteUserCommand):<br/>      Promise&lt;DeleteResult&gt;<br/>    {<br/>      return await this._repository.delete({<br/>        'id': request.id<br/>      });<br/>    }<br/>}</span></pre><h2 id="485b" class="my mb it bd mc mz na dn mg nb nc dp mk le nd ne mm li nf ng mo lm nh ni mq nj bi translated">控制器</h2><p id="7ab1" class="pw-post-body-paragraph kv kw it kx b ky nk jv la lb nl jy ld le nm lg lh li nn lk ll lm no lo lp lq im bi translated">既然我们已经构建了我们的查询和命令，我们需要把它们放在一起，为我们的用户CRUD端点创建我们的<em class="lr"> UserController </em>。</p><p id="f21e" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">首先，我们创建我们的<em class="lr"> UserController </em>类，使用<strong class="kx iu"> @Controller decorator </strong>并为我们的控制器指定我们的<strong class="kx iu"><em class="lr">‘user’</em>路由前缀</strong>。然后，我们<strong class="kx iu">在<strong class="kx iu">构造器</strong>上为</strong>提供<strong class="kx iu">查询总线</strong>和<strong class="kx iu">命令总线</strong>。</p><pre class="kk kl km kn gt np nq nr ns aw nt bi"><span id="614a" class="my mb it nq b gy nu nv l nw nx">@Controller('user')<br/>export class UserController {</span><span id="25a6" class="my mb it nq b gy nz nv l nw nx">  constructor(<br/>    private readonly commandBus: CommandBus,<br/>    private readonly queryBus: QueryBus<br/>  ) { }</span><span id="1615" class="my mb it nq b gy nz nv l nw nx">}</span></pre><p id="f51e" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在我们能够创建我们的端点，它们将相应地调用<em class="lr"> QueryBus </em>和<em class="lr"> CommandBus </em>。</p><pre class="kk kl km kn gt np nq nr ns aw nt bi"><span id="0c3f" class="my mb it nq b gy nu nv l nw nx">@Controller('user')<br/>export class UserController {</span><span id="5540" class="my mb it nq b gy nz nv l nw nx">  constructor(<br/>    private readonly commandBus: CommandBus,<br/>    private readonly queryBus: QueryBus<br/>  ) { }</span><span id="2266" class="my mb it nq b gy nz nv l nw nx">  @Get()<br/>  public async getAllOngs(<br/>    @Query() request: ListUsersQuery,<br/>    @Res() response<br/>  ) {<br/>  <br/>    const users = await this.queryBus.execute(<br/>      new ListUsersQuery(<br/>        request.page,<br/>        request.pageSize<br/>      )<br/>    );</span><span id="14cb" class="my mb it nq b gy nz nv l nw nx">    response.status(HttpStatus.OK).json(users);<br/>  }</span><span id="c19c" class="my mb it nq b gy nz nv l nw nx">}</span></pre><p id="6f18" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们已经定义了@Get、@Post、@Put和@Delete装饰器来指定所需的HTTP请求方法。同样，我们使用了<strong class="kx iu"> @Query </strong> decorator从请求中检索<strong class="kx iu">查询参数</strong>，使用<strong class="kx iu"> @Param </strong> decorator从请求中检索<strong class="kx iu">路由参数</strong>，使用<strong class="kx iu"> @Body </strong> decorator检索<strong class="kx iu">请求体。</strong></p><p id="c297" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后，我们所要做的就是根据端点目的调用<strong class="kx iu"> QueryBus </strong>或<strong class="kx iu"> CommandBus </strong>，调用其<strong class="kx iu"> execute </strong>方法，<strong class="kx iu">向</strong>提供所需的<strong class="kx iu">查询或命令</strong>，并传递必要的信息。有了操作结果，我们就可以返回一个<strong class="kx iu">响应</strong>，其中包含操作结果和任何需要的数据。我们完了。</p><h2 id="525b" class="my mb it bd mc mz na dn mg nb nc dp mk le nd ne mm li nf ng mo lm nh ni mq nj bi translated">组件</h2><p id="e801" class="pw-post-body-paragraph kv kw it kx b ky nk jv la lb nl jy ld le nm lg lh li nn lk ll lm no lo lp lq im bi translated">现在，剩下要做的就是在用户模块中注册它。首先我们为<em class="lr">命令</em>创建一个<strong class="kx iu"> <em class="lr">索引文件</em> </strong>，为<em class="lr">查询</em>创建另一个。这将使它更容易可视化并在模块中提供。<em class="lr">索引</em>文件将如下所示:</p><pre class="kk kl km kn gt np nq nr ns aw nt bi"><span id="cffc" class="my mb it nq b gy nu nv l nw nx">// commands &gt; _index.ts<br/>export const CommandHandlers = [<br/>  AddUserHandler,<br/>  UpdateUserHandler,<br/>  DeleteUserHandler<br/>];</span><span id="4e7b" class="my mb it nq b gy nz nv l nw nx">// queries &gt; _index.ts<br/>export const QueryHandlers = [<br/>  ListHandler,<br/>  GetUserByIdHandler<br/>];</span></pre><p id="3589" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在我们可以创建我们的<em class="lr">用户模块</em>，声明我们的<em class="lr">用户控制器</em>，并提供我们的<em class="lr">查询</em>和<em class="lr">命令</em>。然后，我们将它导入到我们的<em class="lr"> AppModule </em>中，我们就可以开始了！</p><pre class="kk kl km kn gt np nq nr ns aw nt bi"><span id="8a5d" class="my mb it nq b gy nu nv l nw nx">@Module({<br/>  imports: [<br/>    CqrsModule,<br/>    ...<br/>    // Here might be included other Modules, such as<br/>    // the TypeOrmModule<br/>  ],<br/>  controllers: [<br/>    UserController<br/>  ],<br/>  providers: [<br/>    ...QueryHandlers,<br/>    ...CommandHandlers<br/>  ]<br/>})<br/>export class UserModule { }</span></pre></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="8595" class="ma mb it bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">活动采购和CQRS</h1><p id="5e1e" class="pw-post-body-paragraph kv kw it kx b ky nk jv la lb nl jy ld le nm lg lh li nn lk ll lm no lo lp lq im bi translated">CQRS的一些实现使用了<a class="ae ls" href="https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing" rel="noopener ugc nofollow" target="_blank">事件源模式</a>。在这种模式下，应用程序的<strong class="kx iu">状态</strong>被<strong class="kx iu">存储</strong>为<strong class="kx iu">事件</strong>的<strong class="kx iu">序列</strong>，其中每个事件<strong class="kx iu">代表</strong>对数据的一组<strong class="kx iu">变化</strong>。通过使用事件流，它<strong class="kx iu">避免了更新冲突</strong>和<strong class="kx iu">最大化了性能</strong>和<strong class="kx iu">可伸缩性</strong>。然而，事件源<strong class="kx iu">给应用程序设计增加了</strong>甚至<strong class="kx iu">更多的复杂性</strong>，应用程序设计在这种模式下已经很复杂了。</p><p id="8205" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">值得注意的是，基于事件源模式的应用程序只有<strong class="kx iu">最终与</strong>一致，因为在发生的<strong class="kx iu">事件</strong>和正在更新的<strong class="kx iu">数据存储</strong>之间有一些<strong class="kx iu">延迟</strong>。此外，持续处理特定实体或实体集合的事件可能需要<strong class="kx iu">大量处理时间</strong>和<strong class="kx iu">资源使用</strong>。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><p id="f7f2" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">像CQRS这样的设计模式在正确应用时可以帮助我们在应用程序中编写和维护高质量的代码。这是一个非常有用的模式，了解它的基本原理非常重要。此外，正如我们所探讨的，NestJS使实现这种模式变得非常容易，允许我们创建可伸缩的高效应用程序。</p><p id="8ca6" class="pw-post-body-paragraph kv kw it kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">希望有帮助！😉</p><h2 id="8a04" class="my mb it bd mc mz na dn mg nb nc dp mk le nd ne mm li nf ng mo lm nh ni mq nj bi translated">参考资料:</h2><div class="oa ob gp gr oc od"><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">命令和查询责任分离(CQRS)模式——云设计模式</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">通过使用不同的接口，将读取数据的操作与更新数据的操作分开。这样可以最大化…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">docs.microsoft.com</p></div></div><div class="om l"><div class="on l oo op oq om or kt od"/></div></div></a></div><div class="oa ob gp gr oc od"><a href="https://docs.nestjs.com/recipes/cqrs" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">文档| NestJS——一个渐进的Node.js web框架</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">最简单的CRUD应用程序的流程可以使用以下步骤来描述:控制器层句柄HTTP…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">docs.nestjs.co</p></div></div><div class="om l"><div class="os l oo op oq om or kt od"/></div></div></a></div></div></div>    
</body>
</html>