<html>
<head>
<title>Next Generation Node &amp; Express MVC Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">下一代节点&amp;快速MVC模式</h1>
<blockquote>原文：<a href="https://itnext.io/a-new-and-better-mvc-pattern-for-node-express-478a95b09155?source=collection_archive---------1-----------------------#2018-11-23">https://itnext.io/a-new-and-better-mvc-pattern-for-node-express-478a95b09155?source=collection_archive---------1-----------------------#2018-11-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2a7cb4f2d499fe291a93c040e9c448d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WaxX2pZ28CvrYzy8"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@milkovi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米尔科维</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="0bd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">似乎是很久以前的事了，我曾经写过关于<a class="ae kc" href="https://medium.com/@TaylorAckley/simple-and-minimalist-mvc-architecture-pattern-for-node-express-cb542287a144" rel="noopener">的文章，这是一个简单易用的MVC模式，可以用于Node和Express。随着时间的推移，我已经开始发展这种模式来模仿企业框架中的模式，比如。NET Web API 2。</a></p><p id="e880" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先是一些免责声明。</p><p id="2b19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，这真的不是MVC模式，因为没有视图。它更像是一个MCS模式，或者模型&gt;控制器&gt;商店。也就是说，我们将不讨论MCS的模型部分，只讨论控制器和商店。</p><p id="c726" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二，关注模式，而不是代码。为了简洁起见，对其进行了剪裁和编辑，然而，大部分内容被留了下来，以更清楚地说明数据是如何从模型上升到商店、控制器并被发送到以太网的。不管怎样，这些代码并不意味着要在实际的应用程序中使用。</p><h1 id="c3d3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="a0e0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">您可以在这个<a class="ae kc" href="https://github.com/TaylorAckley/NodeNgXBoilerPlate/tree/master/api/lib" rel="noopener ugc nofollow" target="_blank">示例存储库</a>中看到所讨论概念的示例</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="fc74" class="lb lc iq bd ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly bi translated">概观</h1><p id="14f7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">该模式的总体思想是创建灵活的路由模式，通过所需的中间件功能对路由进行分组。</p><p id="d967" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦路由收到请求，它就通过管道传递给控制器方法，该方法决定如何处理请求，并负责返回响应。</p><p id="6989" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，控制器将把请求对象分派给一个存储，存储处理我们的CRUD和业务逻辑操作。有一个商店来处理沉重的负担意味着我们可以保持我们的控制器轻，我们的商店是免费的不必要的混乱。这种解耦也使得我们的存储高度可测试。</p><p id="4db1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了进一步保持我们的语法尽可能的简洁，我们利用了本地ES6类。这并没有什么真正的优势，除了它有助于编写易于阅读的高度可组合的代码</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="220f" class="mz lc iq mv b gy na nb l nc nd">// meh</span><span id="8ea1" class="mz lc iq mv b gy ne nb l nc nd">const dataStore = {};</span><span id="0b22" class="mz lc iq mv b gy ne nb l nc nd">dataStore.getData = async (a) =&gt; {</span><span id="e211" class="mz lc iq mv b gy ne nb l nc nd">// get some data<br/>};</span><span id="6ff9" class="mz lc iq mv b gy ne nb l nc nd">dataStore.createData = async (a, b) =&gt; {</span><span id="c9c2" class="mz lc iq mv b gy ne nb l nc nd">// create some data<br/>};</span><span id="cf2f" class="mz lc iq mv b gy ne nb l nc nd">module.exports = dataStore;</span></pre><p id="1822" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相对</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="62fb" class="mz lc iq mv b gy na nb l nc nd">// much cleaner!</span><span id="d813" class="mz lc iq mv b gy ne nb l nc nd">class DataStore {</span><span id="839c" class="mz lc iq mv b gy ne nb l nc nd">static async getData(a) {</span><span id="5569" class="mz lc iq mv b gy ne nb l nc nd">//.....get some data<br/>    }</span><span id="78fc" class="mz lc iq mv b gy ne nb l nc nd">static async createData(a, b) {</span><span id="e18a" class="mz lc iq mv b gy ne nb l nc nd">//.....create some data<br/>    }<br/>}</span><span id="9466" class="mz lc iq mv b gy ne nb l nc nd">module.exports = DataStore;  // or module.exports = new DataStore() if you are not using static methods.</span></pre><p id="3ea8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第一个块中，你会注意到我在类名前使用了<code class="fe nf ng nh mv b">static</code>关键字。<code class="fe nf ng nh mv b">static</code>关键字仅仅意味着我不需要实例化一个新的类实例来使用这些方法，但是因为我不需要构造函数，所以我可以跳过实例化，直接访问我的类方法。</p><blockquote class="ni nj nk"><p id="ff82" class="kd ke nl kf b kg kh ki kj kk kl km kn nm kp kq kr nn kt ku kv no kx ky kz la ij bi translated">关键字<code class="fe nf ng nh mv b"><strong class="kf ir"><em class="iq">static</em></strong></code>定义了一个类的静态方法。静态方法不会在类的实例上调用。相反，它们在类本身上被调用。这些通常是实用函数，例如创建或克隆对象的函数。<br/>T10】https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Classes/static</p></blockquote><p id="4b83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在其他语言中，如。NET Core中，静态的使用可能会导致问题，因为依赖注入主要是通过构造函数来处理的。因为NodeJS不像那样使用DI，所以我们可以随意使用statics，这实际上只涉及到风格问题。</p><h1 id="490f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结构</h1><p id="123e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们的目录结构大致如下所示。目录结构也模拟了模式的流程。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="0557" class="mz lc iq mv b gy na nb l nc nd">- server.js // Startup logic<br/>--  /routes<br/>---   routes.index.js  // index of Routers <br/>---   routes.unauth.js // route definitions for anonymous routes<br/>---   routes.auth.js   // route definitions for authenticated routes<br/>-  /controllers<br/>--   account.controller.js // pipe request objects to  the account store, send response<br/>-  /stores<br/>--   account.store.js  // receive the request object, handle CRUD.<br/>--   auth.store.js     // middleware to authenticate.</span></pre><p id="dc5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从我们的<code class="fe nf ng nh mv b">server.js</code>文件开始，开始监听请求和服务响应。这里没什么特别的！</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="5e85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来是我们的路由索引文件，它在前面的部分中被引用。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7ecb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们导出一个函数，该函数将Express <code class="fe nf ng nh mv b">app</code>实例作为一个参数，我们可以用它来创建一些通过中间件(如果需要，还有版本)将路由分组在一起的<a class="ae kc" href="https://expressjs.com/en/api.html#express.router" rel="noopener ugc nofollow" target="_blank"> Express路由器</a>。</p><p id="4a24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你看一下<code class="fe nf ng nh mv b">app.use()</code>，我们会给它一个签名:</p><ul class=""><li id="d9a1" class="nr ns iq kf b kg kh kk kl ko nt ks nu kw nv la nw nx ny nz bi translated">路线前缀(<code class="fe nf ng nh mv b">api/v1)</code></li><li id="0c2c" class="nr ns iq kf b kg oa kk ob ko oc ks od kw oe la nw nx ny nz bi translated">基于授权头的存在、它们的角色等，允许用户通过的一系列中间件功能。</li><li id="9409" class="nr ns iq kf b kg oa kk ob ko oc ks od kw oe la nw nx ny nz bi translated">包含在另一个文件中的路由定义。</li></ul><p id="26e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使得很容易看出哪些路由获得了哪些中间件，并保持事物的逻辑分组。如果您不仅想按中间件或版本对路由进行分组，还想按资源对路由进行分组，那么这种模式具有很强的适应性。</p><p id="02ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是路由索引中引用的身份验证中间件的示例。这篇文章实际上不是关于认证或者中间件如何工作的，但是为了清楚起见，我把它包括进来了。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="73ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的主要内容是<code class="fe nf ng nh mv b">req</code>和<code class="fe nf ng nh mv b">res</code>对象通过管道传输到中间件，您可以根据需要对它们进行操作，通过调用<code class="fe nf ng nh mv b">next()</code>让请求通过，或者选择拒绝请求并在请求到达路由处理器之前返回响应。为了方便起见，我将解码后的授权头中的信息附加到了<code class="fe nf ng nh mv b">req</code>对象上，这样用户的标识符就可以在路由处理程序中使用了。</p><p id="ab51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们设置未授权的路由，这些路由不需要对用户进行身份验证。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0683" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个参数是在<code class="fe nf ng nh mv b">routes.index.js</code>中定义的父路由器中指定的根之后的路由模式。第二个参数是一个控制器方法(或函数)，它通过管道将<code class="fe nf ng nh mv b">req</code>和<code class="fe nf ng nh mv b">res</code>参数传递给控制器方法。我们还可以在每条路由的基础上指定一个中间件数组，将它作为第二个参数添加，并将方法定义推送到第三个参数。</p><p id="2a4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您不熟悉如何指定一个需要参数而不指定所述参数的函数，基本的解释是，只要接收函数的签名匹配，参数就能通过。</p><p id="2e01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，和上面一样，这里的区别是我们在<code class="fe nf ng nh mv b">routes.index.js</code>中指定了认证中间件，这意味着这些路由是受保护的。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="9fb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们进入正题，定义我们的控制器。下面我们有一个包含两个静态方法的类。我们可以走老路，在一个对象中声明我们所有的函数，但是类方法会产生更干净的代码。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="bfdc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用静态方法并导出类定义，这意味着我们不需要类的实例。这是一种风格偏好，我们也可以初始化该类的一个实例，然后导出该实例。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="3cc8" class="mz lc iq mv b gy na nb l nc nd">module.exports = new AccountController();</span></pre><p id="ad8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">控制器的作用是将资源集合在一起，组装一个响应并发送出去。我倾向于保持我的控制器方法最少，只负责弄清楚做什么和发送回一个响应。</p><p id="d158" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在这里使用了<code class="fe nf ng nh mv b">async</code>关键词，但是你也可以使用基于承诺的方法。</p><p id="f22d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">终于——我们到达了商店。这是所有业务逻辑、垃圾和魔法发生的地方。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b342" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">存储负责组装将返回给请求者的“有效负载”或可用数据。我们简单地将整个<code class="fe nf ng nh mv b">req</code>对象管道化，这样所有重要的东西，比如参数和用户，在我们需要的时候都是可用的。</p><p id="9e28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">商店可以根据我们的需要而变得复杂或简单，你的大部分代码应该在商店里。我的方法倾向于保持方法小，并根据需要从同一个类中调用兄弟方法。这使得事情变得美好、整洁和可测试。</p><p id="675d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nl">就这样。完成了。非常感谢任何反馈。</em></p></div></div>    
</body>
</html>