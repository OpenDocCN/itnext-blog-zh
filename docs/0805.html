<html>
<head>
<title>Smart table for Angular — part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度智能表—第2部分</h1>
<blockquote>原文：<a href="https://itnext.io/smart-table-for-angular-part-2-31ea5bd0c383?source=collection_archive---------8-----------------------#2018-05-31">https://itnext.io/smart-table-for-angular-part-2-31ea5bd0c383?source=collection_archive---------8-----------------------#2018-05-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5673" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上一部分中，我们已经成功地以完全声明的方式创建了一个智能表格组件。在这一部分中，我们将探讨如何将工厂与角度依赖注入一起使用，以完成不同的需求。</p><p id="4160" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数<strong class="jp ir">智能表-ng </strong>属性指令依赖于注入的智能表实例。幸运的是，一旦在我们的组件层次结构中提供了实例，Angular就会在任何需要的地方为我们注入实例。</p><p id="d839" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们之前的教程中，由于“ 工厂的<strong class="jp ir"> <em class="km">”，实例是从一个静态数组创建的，并在用户表容器组件中提供。</em></strong></p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="5871" class="kw kx iq ks b gy ky kz l la lb">import { Component } from ‘@angular/core’;<br/>import { SmartTable, of, SortDirection } from ‘smart-table-ng’;<br/>import { users, User } from ‘./users’;</span><span id="e0af" class="kw kx iq ks b gy lc kz l la lb">const providers = [<br/>  {provide: SmartTable, useValue: of&lt;User&gt;(users)}<br/>];</span><span id="eefe" class="kw kx iq ks b gy lc kz l la lb">@Component({<br/>  selector: ‘user-list’,<br/>  templateUrl: ‘./user-list.component.html’,<br/>  providers<br/>})export class UserListComponent {<br/>}</span></pre><h2 id="6df5" class="kw kx iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">异步获取数据</h2><blockquote class="lu"><p id="7308" class="lv lw iq bd lx ly lz ma mb mc md kk dk translated">作为一名开发人员，我希望在将数据插入智能表之前从服务器异步加载数据。</p></blockquote><p id="c367" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">数据通常不会在运行之前可用，您更有可能将从服务器获取数据的责任委托给一个专用的服务。考虑下面的服务。</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="4ad5" class="kw kx iq ks b gy ky kz l la lb">import { Injectable } from ‘@angular/core’;<br/>import { users, User } from ‘./users’;</span><span id="c227" class="kw kx iq ks b gy lc kz l la lb">@Injectable({<br/>  providedIn: ‘root’<br/>})<br/>export class UsersService {<br/>  <br/>  fetchUsers(): Promise&lt;User[]&gt; {<br/>    return new Promise(resolve =&gt; {<br/>      setTimeout(() =&gt; resolve(users), 2000);<br/>    });<br/>  }</span><span id="f6b7" class="kw kx iq ks b gy lc kz l la lb">}</span></pre><p id="72c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该服务公开了一个<strong class="jp ir"><em class="km">fetchUsers</em></strong><em class="km"/>，其中<em class="km"> </em>返回<em class="km"> </em>一个承诺，该承诺最终将与用户列表一起解析。这里的实现是一个细节，但是通过使用两秒钟的超时伪造了到服务器的往返。</p><p id="ab3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的一面是我们根本不需要改变组件，我们只需要改变智能表格的提供方式。</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="4167" class="kw kx iq ks b gy ky kz l la lb">import { Component } from ‘@angular/core’;<br/>import { SmartTable, from } from ‘smart-table-ng’;<br/>import { UsersService } from ‘./users.service’;</span><span id="d5e4" class="kw kx iq ks b gy lc kz l la lb">const providers = [{<br/>  provide: SmartTable,<br/>  useFactory: (Users: UsersService) =&gt; from(Users.fetchUsers()),<br/>  deps: [UsersService]<br/>}];</span><span id="53de" class="kw kx iq ks b gy lc kz l la lb">@Component({<br/>  selector: ‘user-list’,<br/>  templateUrl: ‘./user-list.component.html’,<br/>  providers<br/>})<br/>export class UserListComponent {<br/>}</span></pre><p id="d4ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在用的是<strong class="jp ir"><em class="km"/></strong>智能表厂。我们使用angular<a class="ae kl" href="https://angular.io/api/core/FactoryProvider" rel="noopener ugc nofollow" target="_blank">factory provider</a>模式，这样我们可以要求注入器向负责创建智能表实例的函数注入可用的UsersService。</p><div class="mj mk gp gr ml mm"><a href="https://stackblitz.com/edit/smart-table-ng-tutorial-1?embed=1&amp;file=src/users/user-list.component.ts" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd ir gy z fp mr fr fs ms fu fw ip bi translated">smart-table-ng-tutorial-1-stack blitz</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">本教程展示了如何使用基于Promise的API从服务器加载数据</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">stackblitz.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na nb mm"/></div></div></a></div><blockquote class="lu"><p id="9b15" class="lv lw iq bd lx ly nc nd ne nf ng kk dk translated">但是我的服务依赖于一个HttpClient，它使用了一个基于Observables的API</p></blockquote><p id="e401" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">角度框架在很大程度上依赖于可观察的抽象。当涉及到产生和消费随时间产生的多个值时，Observables非常方便，但是它也可以用于处理异步代码。这就是<a class="ae kl" href="https://angular.io/guide/http" rel="noopener ugc nofollow" target="_blank"> HttpClient </a>所做的事情。</p><p id="7cef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们改变我们的服务，让它使用一个基于可观察的API和一个后端的假交互。</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="d682" class="kw kx iq ks b gy ky kz l la lb">import { Injectable } from ‘@angular/core’;<br/>import { users, User } from ‘./users’;<br/>import { of, Observable } from ‘rxjs/index’;<br/>import { delay } from ‘rxjs/operators’;</span><span id="c6e7" class="kw kx iq ks b gy lc kz l la lb">@Injectable({<br/>  providedIn: ‘root’<br/>})<br/>export class UsersService {<br/>  <br/>  fetchUsers(): Observable&lt;User[]&gt; {<br/>    return of(users)<br/>      .pipe(delay(2000));<br/>  }</span><span id="874a" class="kw kx iq ks b gy lc kz l la lb">}</span></pre><p id="e3f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，这里的实现是一个细节，只是帮助我们假装与服务器交互。</p><p id="5a5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">来自 工厂的智能表<strong class="jp ir"> <em class="km">对承诺起作用，但也对可观察到的东西起作用，所以<strong class="jp ir">我们没有什么要改变的</strong> e</em></strong></p><h2 id="e4e4" class="kw kx iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">为我们的指令使用默认值/初始值</h2><blockquote class="lu"><p id="530d" class="lv lw iq bd lx ly lz ma mb mc md kk dk translated">我希望我的用户在默认情况下按balance属性排序。我还想过滤掉所有余额高于2000美元的用户，这样我就可以优先关注余额较低的用户。</p></blockquote><p id="db86" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">在某些情况下，您可能希望将默认设置应用到智能表，或者从存储系统(如区域存储)恢复以前的状态。</p><p id="09a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"> 的<strong class="jp ir"> <em class="km">和</em> </strong>工厂的<strong class="jp ir"> <em class="km">都将初始<a class="ae kl" href="https://smart-table.github.io/www/dist/table-state.html" rel="noopener ugc nofollow" target="_blank">表状态</a>作为第二个自变量。</em></strong></p><p id="f167" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们改变我们的提供商来满足我们的用户故事的需求。</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="7eb9" class="kw kx iq ks b gy ky kz l la lb">import { Component } from ‘@angular/core’;<br/>import { SmartTable, from } from ‘smart-table-ng’;<br/>import { UsersService } from ‘./users.service’;</span><span id="e3b5" class="kw kx iq ks b gy lc kz l la lb">const providers = [{<br/>  provide: SmartTable,<br/>  useFactory: (Users: UsersService) =&gt; from(Users.fetchUsers(),{<br/>    search: {},<br/>    slice: { page: 1, size: 10 },<br/>    filter: {<br/>      balance: [{ operator: ‘lt’, type: ‘number’, value: 2000 }]<br/>    },<br/>    sort: {<br/>      pointer: ‘balance’,<br/>      direction: ‘asc’<br/>    }}),<br/>    deps: [UsersService]<br/> }];</span><span id="2d98" class="kw kx iq ks b gy lc kz l la lb">@Component({<br/>  selector: ‘user-list’,<br/>  templateUrl: ‘./user-list.component.html’,<br/>  providers<br/>})<br/>export class UserListComponent {<br/>}</span></pre><p id="65c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">细心的读者会注意到我们使用了一个<em class="km">硬编码的</em>初始表状态。但是我们可能需要它作为对注入器的依赖，或者从专用服务中获取它。类似于:</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="36fc" class="kw kx iq ks b gy ky kz l la lb">const providers = [{<br/>  provide: SmartTable,<br/>  useFactory: (Users: UsersService, config: SmartTableConfigService) =&gt; from(Users.fetchUsers(),config.getFor('users')),<br/>    deps: [UsersService, SmartTableConfigService]<br/> }];</span></pre><p id="9fa9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的stackblitz中可以看到类似的方法:</p><div class="mj mk gp gr ml mm"><a href="https://stackblitz.com/edit/smart-table-ng-tutorial-2c?embed=1&amp;file=src/users/user-list.component.ts" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd ir gy z fp mr fr fs ms fu fw ip bi translated">智能表-ng-教程-2c - StackBlitz</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">导出到Angular CLI的Angular应用程序的启动项目</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">stackblitz.com</p></div></div><div class="mv l"><div class="nh l mx my mz mv na nb mm"/></div></div></a></div><p id="f7fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是依赖注入的美妙之处，我们可以非常容易地交换提供的实体，并保持我们的组件/服务松散耦合。</p><h2 id="aab4" class="kw kx iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">将整个逻辑移至服务器</h2><blockquote class="lu"><p id="e60d" class="lv lw iq bd lx ly lz ma mb mc md kk dk translated">很好，但是我们的数据集已经显著增长，在用户的浏览器中加载所有数据已经没有意义了。我们的后端团队刚刚完成了处理过滤、搜索、排序和分页的灵活端点的开发。我想，我将不得不改变我的组件。</p></blockquote><p id="e044" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">而答案是<strong class="jp ir">没有</strong>！</p><p id="1f85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你读过之前的教程或<a class="ae kl" href="https://smart-table.github.io/www/dist/extend.html" rel="noopener ugc nofollow" target="_blank">智能表核心</a>文档，你就会知道智能表核心实例可以很容易地扩展，而且已经有相当多的扩展可用。幸运的是，我们可以在smart-table-ng中使用这些扩展(或者构建我们自己的扩展)。对于我们的用例，我们可能需要<a class="ae kl" href="https://github.com/smart-table/smart-table-server" rel="noopener ugc nofollow" target="_blank">智能表服务器</a>扩展。</p><blockquote class="ni nj nk"><p id="454f" class="jn jo km jp b jq jr js jt ju jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj kk ij bi translated">注意:smart-table-server扩展更多的是概念验证，但是您可以基于这个模型开发自己的服务器接口。</p></blockquote><p id="14ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以让我们回顾一下我们的组件文件。</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="64d9" class="kw kx iq ks b gy ky kz l la lb">import { Component } from '@angular/core';<br/>import { SmartTable, of, TableState } from 'smart-table-ng';<br/>import { UsersService } from './users.service';<br/>import { DefaultSettingsService } from './default-settings.service';<br/>import server from 'smart-table-server';</span><span id="6b51" class="kw kx iq ks b gy lc kz l la lb">const providers = [{<br/>  provide: SmartTable,<br/>  useFactory: (Users: UsersService, settings: TableState) =&gt; of([], settings, server({<br/>  query: (tableState) =&gt; Users.queryUsers(tableState)})),<br/>  deps: [UsersService, DefaultSettingsService]<br/>}];<br/>@Component({<br/>  selector: 'user-list',<br/>  templateUrl: './user-list.component.html',<br/>  providers<br/>})<br/>export class UserListComponent {<br/>}</span></pre><p id="94c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">专注于提供者部分。</p><figure class="kn ko kp kq gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi no"><img src="../Images/581f410aa6ff20e0f6fbdf4699fd8e0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rqvDa6_ICZOnh4oQhVy17g.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">提供者部分的代码片段</figcaption></figure><p id="9d3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用“ 智能表工厂的<strong class="jp ir"> <em class="km">”和一个空数组(实际上我们没有任何数据集，因为一切都将在服务器端完成)。第二个参数保持默认的表状态。然后你可以像处理<a class="ae kl" href="https://github.com/smart-table/smart-table-core/" rel="noopener ugc nofollow" target="_blank">智能表格核心</a>包一样传递一个智能表格扩展列表。</em></strong></p><p id="35e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，我们使用智能表服务器扩展，它需要一个具有查询功能的对象作为参数。这个查询功能依赖于注入的<em class="km"> UsersService。</em><em class="km">query users</em>函数的实现与我们的教程无关，但在实践中，它应该将表状态转换为服务器可以理解的查询，并解析响应，以智能表可以理解的格式转换数据。</p><p id="fc23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在下面的stackblitz中看到结果:</p><div class="mj mk gp gr ml mm"><a href="https://stackblitz.com/edit/smart-table-ng-tutorial-2d?embed=1&amp;file=src/users/user-list.component.ts" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd ir gy z fp mr fr fs ms fu fw ip bi translated">智能表格-ng-教程-2d - StackBlitz</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">导出到Angular CLI的Angular应用程序的启动项目</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">stackblitz.com</p></div></div><div class="mv l"><div class="nz l mx my mz mv na nb mm"/></div></div></a></div><h2 id="0ffc" class="kw kx iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">结论</h2><p id="1598" class="pw-post-body-paragraph jn jo iq jp b jq oa js jt ju ob jw jx jy oc ka kb kc od ke kf kg oe ki kj kk ij bi translated">在本教程中，我们建立在我们在上一个教程中开发的组件之上。使用智能表工厂和依赖注入，我们能够满足广泛的不同需求… <strong class="jp ir">而无需更改组件中的一行代码。</strong></p><p id="7b56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一集，我们将使用Observables来探索更高级的用例。</p></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><p id="2684" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">智能餐桌的发展仍在继续，在不久的将来你可能会看到一些突破性的变化。我还要感谢<a class="ae kl" href="https://www.spudsoftware.com/" rel="noopener ugc nofollow" target="_blank"><em class="km">spud software</em></a><em class="km">在开发过程中对我的赞助。</em></p><figure class="kn ko kp kq gt np gh gi paragraph-image"><div class="gh gi om"><img src="../Images/d3d62c0dacc3d7d12eaedf90607f10a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*ZUxScLiErMnYGoyoT18OtA.png"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">spudsoftware徽标</figcaption></figure></div></div>    
</body>
</html>