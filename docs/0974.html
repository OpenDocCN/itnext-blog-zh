<html>
<head>
<title>NodeJS MS-SQL integration testing with Docker/Mocha</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NodeJS MS-SQL与Docker/Mocha的集成测试</h1>
<blockquote>原文：<a href="https://itnext.io/nodejs-ms-sql-integration-testing-with-docker-mocha-111fd6b91f25?source=collection_archive---------4-----------------------#2018-06-26">https://itnext.io/nodejs-ms-sql-integration-testing-with-docker-mocha-111fd6b91f25?source=collection_archive---------4-----------------------#2018-06-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="7e17" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">集成测试与单元测试</h1><p id="c8ea" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">单元测试对于测试一个函数的特定行为来说是很棒的，如果你正确地编码并且正确地创建了你的“模拟”依赖项，你就可以合理地保证你的代码的行为。</p><p id="7a36" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">但是我们的代码并不是孤立存在的，我们需要确保所有的“部分”都是相互连接的，并且以我们期望的方式一起工作。这就是集成测试发挥作用的地方。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/d5304daf0e24dafb4aa48f12790241e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*3_e4tyEr0AG8g7Wo.jpg"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">查理·西恩没有编写单元测试，看看他现在的处境</figcaption></figure><p id="a376" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">解释这种差异的一个好方法是，单元测试将测试一个值(为了简单起见，我们假设是一封电子邮件)是否通过了业务逻辑测试(可能是正则表达式之类的——可能检查URL ),电子邮件和规则将在测试中作为模拟/存根/硬编码提供，而这种集成测试将检查相同的逻辑，还从数据库中检索规则和值——从而检查所有部分是否匹配和工作。</p><p id="0c6a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果你想要更多的例子或者想在这方面多读一点，介质上有很多资源，还有栈溢出等等。本文的其余部分将假设您熟悉NodeJS并测试它(这里我们使用Mocha——但是您可以随意使用您喜欢的任何东西)。</p><h1 id="37ec" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">提取MS-SQL映像</h1><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/1e3f7dec1c5252cb5b4495d344d7d4cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*pz4IgqZQlioduwYF.jpg"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">他使用Linux容器:)</figcaption></figure><p id="9b2d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">首先，你需要提取Docker镜像，只需运行命令<code class="fe ma mb mc md b">docker pull microsoft/mssql-server-linux:2017-latest</code> <em class="me">(如果你还没有安装Docker，你可能也想这样做</em>😃<em class="me"> ) </em></p><p id="6dd8" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这可能需要几分钟的时间，取决于您在Docker缓存中安装了什么。</p><p id="d707" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">完成后，请确保右键单击，进入“<em class="me">设置… </em>”并启用:“<em class="me">显示tcp://localhost:2375 </em>上的守护程序”。正如我们将在几节中看到的，这需要设置为<code class="fe ma mb mc md b">process.env.DOCKER_HOST</code>才能使Docker调制解调器正确运行。</p><h1 id="48f0" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">推迟摩卡的安装</h1><p id="2c5a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因为我们需要一些时间来启动容器和部署模式，所以我们将对Mocha使用<code class="fe ma mb mc md b">--delay</code>标志。</p><p id="1a53" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这增加了一个全局函数<code class="fe ma mb mc md b">run()</code>，当设置完成时需要调用这个函数。</p><p id="8d55" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">你也应该使用<code class="fe ma mb mc md b">--exit</code>标志，它将在测试运行后杀死Mocha，即使一个套接字是打开的。</p><h1 id="a2e2" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">准备运行</h1><p id="501b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这个例子中，我们使用<code class="fe ma mb mc md b">--require</code>标志在测试运行之前要求一个文件。在这个文件中使用了IIFE(立即调用函数表达式),因为我们需要调用一些异步函数并等待它们，然后从上面调用<code class="fe ma mb mc md b">done()</code>函数。这可以通过回调来实现，但是不太干净。</p><p id="ff96" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">生活最终应该是这样的:</p><pre class="lp lq lr ls gt mf md mg mh aw mi bi"><span id="9e00" class="mj jo iq md b gy mk ml l mm mn">(async () =&gt; {<br/>    const container = require('./infra/container');<br/>    await container.createAsync();<br/>    await container.initializeDbAsync();<br/>    run(); // this kicks off Mocha<br/>    beforeEach(async () =&gt; {<br/>        console.log('Clearing db!');<br/>        await container.clearDatabaseAsync();<br/>    });<br/>    after(async () =&gt; {<br/>        console.log('Deleting container!');<br/>        await container.deleteAsync();<br/>    });<br/>})();</span></pre><h1 id="9a31" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">从节点旋转容器</h1><p id="2c65" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在上面的生命中，我们有负责设置容器的方法<code class="fe ma mb mc md b">container.createAsync();</code>。</p><pre class="lp lq lr ls gt mf md mg mh aw mi bi"><span id="37ac" class="mj jo iq md b gy mk ml l mm mn">const { Docker } = require('node-docker-api');<br/>const docker = new Docker();</span><span id="29e3" class="mj jo iq md b gy mo ml l mm mn">...</span><span id="96d4" class="mj jo iq md b gy mo ml l mm mn">async function createAsync() {<br/>    const container = await docker.container.create({<br/>        Image: 'microsoft/mssql-server-linux:2017-latest',<br/>        name: 'mssqltest',<br/>        ExposedPorts: { '1433/tcp': {} },<br/>        HostConfig: {<br/>            PortBindings: {<br/>                '1433/tcp': [{ HostPort: '&lt;EXPOSED_PORT&gt;' }]<br/>            }<br/>        },<br/>        Env: ['SA_PASSWORD=&lt;S00p3rS3cUr3&gt;', 'ACCEPT_EULA=Y']<br/>    });<br/>    console.log('Container built.. starting..');<br/>    await container.start();<br/>    console.log('Container started... waiting for boot...');<br/>    sqlContainer = container;<br/>    await checkSqlBootedAsync();</span><span id="8eb6" class="mj jo iq md b gy mo ml l mm mn">    console.log('Container booted!');<br/>}</span></pre><p id="8525" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">容器是从<code class="fe ma mb mc md b">async</code>方法<code class="fe ma mb mc md b">docker.container.create</code>创建的，<code class="fe ma mb mc md b">docker</code>实例需要设置<code class="fe ma mb mc md b">process.env.DOCKER_HOST</code>，在我们的例子中，我们有一个本地Docker服务器正在运行(参见:提取MS-SQL映像),所以我们将使用它。</p><p id="3492" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">选项来自调制解调器<a class="ae mp" href="https://github.com/apocas/dockerode" rel="noopener ugc nofollow" target="_blank"> dockerode </a>，它使用<a class="ae mp" href="https://docs.docker.com/engine/api/v1.24/" rel="noopener ugc nofollow" target="_blank"> Docker API </a>。</p><p id="df25" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">容器启动后，我们需要检查SQL是否运行完毕，我们的端口是<em class="me"> &lt; EXPOSED_PORT &gt; </em>，密码是<em class="me">&lt;s 00 P3 RS 3 cur 3&gt;</em><strong class="kn ir">(这些是占位符，所以请确保您输入了有效的内容)。</strong></p><p id="679e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果你想了解更多关于EULA期权的信息，等等。点击这里查看微软的指南<a class="ae mp" href="https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-linux-2017" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="6fc3" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">由于SQL server启动需要几秒钟的时间，我们希望在测试套件启动之前确保它正在运行。我们在这里想出的一个解决方案是每1/2秒持续尝试连接15秒，当它连接时，退出。</p><p id="93a8" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果它不能在15秒内连接，一定是出了问题，我们应该进一步调查。<code class="fe ma mb mc md b">masterDb.config</code>选项应该与您托管Docker的位置和您将<code class="fe ma mb mc md b">1433</code>暴露给主机的端口一致。还要记住你为<code class="fe ma mb mc md b">sa</code>设置的密码。</p><pre class="lp lq lr ls gt mf md mg mh aw mi bi"><span id="1481" class="mj jo iq md b gy mk ml l mm mn">async function checkSqlBootedAsync() {<br/>    const timeout = setTimeout(async () =&gt; {<br/>        console.log('Was not able to connect to SQL container in 15000 ms. Exiting..');<br/>        await deleteAndExitAsync();<br/>    }, 15000);<br/>    let connecting = true;<br/>    const mssql = require('mssql');<br/>    console.log('Attempting connection... ');<br/>    while (connecting) {<br/>        try {<br/>            mssql.close();</span><span id="868e" class="mj jo iq md b gy mo ml l mm mn">// don't use await! It doesn't play nice with the loop <br/>            mssql.connect(masterDb.config).then(() =&gt; {<br/>                clearTimeout(timeout);<br/>                connecting = false;<br/>            }).catch();<br/>        }<br/>        catch (e) {<br/>            // sink<br/>        }<br/>        await sleep(500);<br/>    }<br/>    mssql.close();<br/>}</span></pre><h1 id="14d5" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">使用序列部署数据库模式</h1><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/2325983afc727346f5d2033e827e785a.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/0*0YK-0rqr1HtvFpK1.jpg"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">有趣的事实:连姆·尼森也用Docker发布了北海巨妖。</figcaption></figure><p id="f022" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我们可以通过使用<code class="fe ma mb mc md b">sync</code>函数快速使用Sequelize来部署模式，然后正如我们将在下面看到的，建议设置某种标志来防止擦除非测试数据库。</p><p id="a55e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">首先，我们希望使用主连接实际创建db。代码最终看起来会像这样:</p><pre class="lp lq lr ls gt mf md mg mh aw mi bi"><span id="3b5c" class="mj jo iq md b gy mk ml l mm mn">async function initializeDbAsync() {<br/>    const sql = 'CREATE DATABASE [MySuperIntegrationTestDB];';<br/>    await masterDb.queryAsync(sql, {});<br/>    await sequelize.sync();<br/>    return setTestingDbAsync();<br/>}</span></pre><h1 id="fd5d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">安全检查</h1><p id="f21e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们面对现实吧，如果你从事专业编程已经有一段合理的时间了——你可能已经放弃了一个数据库或文件系统。</p><p id="779d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><em class="me">如果你没有跑出去买一张乐透彩票，因为你是幸运的。</em></p><p id="ff66" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这就是为备份和其他类似的事情建立基础设施的原因，如果你愿意，可以设置路障，以防止人为错误。虽然您刚刚在这里完成的集成测试基础设施非常好，但是您可能错误地配置了环境变量等等。</p><p id="061c" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我将在这里提出一个可能的解决方案，但是请随意使用你自己的(或者在评论中提出更多建议！).</p><p id="28de" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这里我们将使用SystemConfiguration表，并在键<code class="fe ma mb mc md b">TestDB</code>上有一个键值对，该值需要为true，表才会被截断。同样，在多个步骤中，我建议将<code class="fe ma mb mc md b">NODE_ENV</code>环境变量检查为<code class="fe ma mb mc md b">test</code>，这可以确保您不会意外地在非测试环境中运行这段代码。</p><p id="e58f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在上一节的最后我们看到了对<code class="fe ma mb mc md b">setTestingDbAsync</code>的调用，内容如下:</p><pre class="lp lq lr ls gt mf md mg mh aw mi bi"><span id="43fa" class="mj jo iq md b gy mk ml l mm mn">async function setTestingDbAsync() {<br/>    const configSql =<br/>        "INSERT INTO [SystemConfiguration] ([key], [value]) VALUES (?, '1')";<br/>    return sequelize.query(configSql, {replacements: [systemConfigurations.TestDB]});<br/>}</span></pre><p id="f066" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这将设置数据库中的值，我们将在下一个脚本中检查该值。下面是一段代码，它将检查我们刚刚设置的键<code class="fe ma mb mc md b">TestDB</code>(由一个常量文件提供)上的值是否存在。</p><pre class="lp lq lr ls gt mf md mg mh aw mi bi"><span id="a11e" class="mj jo iq md b gy mk ml l mm mn">const result = await SystemConfiguration.findOne({ where: {key: systemConfigurations.TestDB }});<br/>    if (!result) {<br/>        console.log('Not test environment, missing config key!!!!');<br/>        // bail out and clean up here<br/>    }<br/>// otherwise continue</span></pre><h1 id="74c5" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">每次运行前擦拭测试</h1><p id="eed4" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">将上面的代码与清除数据库的内容结合起来，我们得到了下面的函数:</p><pre class="lp lq lr ls gt mf md mg mh aw mi bi"><span id="6722" class="mj jo iq md b gy mk ml l mm mn">const useSql = 'USE [MySuperIntegrationTestDB];';<br/> <br/>async function clearDatabaseAsync() {<br/>    const result = await SystemConfiguration.findOne({ where: {key: systemConfigurations.TestDB }});<br/>    if (!result || !result.value) {<br/>        console.log('Not test environment, missing config key!!!!');<br/>        await deleteAndExitAsync();<br/>    }<br/>    const clearSql = `${useSql}<br/>       EXEC sp_MSForEachTable 'DISABLE TRIGGER ALL ON ?'<br/>       EXEC sp_MSForEachTable 'ALTER TABLE ? NOCHECK CONSTRAINT ALL'<br/>       EXEC sp_MSForEachTable 'DELETE FROM ?'<br/>       EXEC sp_MSForEachTable 'ALTER TABLE ? CHECK CONSTRAINT ALL'<br/>       EXEC sp_MSForEachTable 'ENABLE TRIGGER ALL ON ?'`;</span><span id="e9fb" class="mj jo iq md b gy mo ml l mm mn">    await sequelize.query(clearSql);<br/>    return setTestingDbAsync();<br/>}</span><span id="65c1" class="mj jo iq md b gy mo ml l mm mn">async function setTestingDbAsync() {<br/>    const configSql = "INSERT INTO [SystemConfiguration] ([key], [value]) VALUES (?, '1')";<br/>    return sequelize.query(configSql, {replacements: [systemConfigurations.TestDB]});<br/>}</span></pre><p id="6867" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这将在继续之前检查<code class="fe ma mb mc md b">SystemConfiguration</code>表中键<code class="fe ma mb mc md b">TestDB</code>的值是否存在。如果不存在，它将退出进程。</p><p id="d143" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">那么这在摩卡的环境中是如何运行的呢？</p><p id="92a8" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果你还记得在生活中我们调用了<code class="fe ma mb mc md b">beforeEach</code>，这是你想要有这个钩子的地方，这样你就有一个干净的数据库用于每个测试。</p><pre class="lp lq lr ls gt mf md mg mh aw mi bi"><span id="a94a" class="mj jo iq md b gy mk ml l mm mn">beforeEach(async () =&gt; {<br/>        console.log('Clearing db!');<br/>        await container.clearDatabaseAsync();<br/>    });</span></pre><h1 id="0587" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">关闭/拆卸</h1><p id="1f29" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">你不想让码头工人处于未知状态，所以在运行结束时简单地杀死集装箱，你也会想使用武力。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/6864641cd6a2f6575c569367f6af1f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*Lu1C3zcglD6S3pPx.jpg"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">Docker联系我们说他们不使用排气口</figcaption></figure><p id="0cb9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">之后的外观如下所示:</p><pre class="lp lq lr ls gt mf md mg mh aw mi bi"><span id="7f2b" class="mj jo iq md b gy mk ml l mm mn">after(async () =&gt; {<br/>        console.log('Deleting container!');<br/>        await container.deleteAsync();<br/>    });</span></pre><p id="5720" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">而<code class="fe ma mb mc md b">container.deleteAsync();</code>里面的代码看起来是这样的:</p><pre class="lp lq lr ls gt mf md mg mh aw mi bi"><span id="9a3c" class="mj jo iq md b gy mk ml l mm mn">async function deleteAsync() {<br/>    return sqlContainer.delete({ force: true });<br/>}</span></pre><h1 id="f721" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">把所有的放在一起</h1><p id="cb30" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因为这篇文章有点罗嗦，而且跳来跳去，所以下面是让它工作的要点:</p><ul class=""><li id="2eaf" class="ms mt iq kn b ko lj ks lk kw mu la mv le mw li mx my mz na bi translated">使用<code class="fe ma mb mc md b">--delay</code>延迟摩卡</li><li id="4e1b" class="ms mt iq kn b ko nb ks nc kw nd la ne le nf li mx my mz na bi translated">需要一个设置脚本并使用IIFE来设置容器/数据库</li><li id="0a2b" class="ms mt iq kn b ko nb ks nc kw nd la ne le nf li mx my mz na bi translated">启动Docker容器实例，等待SQL启动</li><li id="6605" class="ms mt iq kn b ko nb ks nc kw nd la ne le nf li mx my mz na bi translated">使用Sequelize部署模式，并进行安全检查，这样我们就不会删除非测试数据库。</li><li id="c3a6" class="ms mt iq kn b ko nb ks nc kw nd la ne le nf li mx my mz na bi translated">将擦拭逻辑钩入<code class="fe ma mb mc md b">beforeEach</code>钩</li><li id="e552" class="ms mt iq kn b ko nb ks nc kw nd la ne le nf li mx my mz na bi translated">将拆卸逻辑钩入<code class="fe ma mb mc md b">after</code>钩</li><li id="aee6" class="ms mt iq kn b ko nb ks nc kw nd la ne le nf li mx my mz na bi translated">创建惊人的codez并测试它们</li></ul><p id="cdd6" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我希望你喜欢这篇文章，建议，评论，更正和更多的迷因总是受欢迎的。</p><h2 id="33bd" class="mj jo iq bd jp ng nh dn jt ni nj dp jx kw nk nl kb la nm nn kf le no np kj nq bi translated">祝好运，测试愉快！</h2></div></div>    
</body>
</html>