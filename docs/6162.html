<html>
<head>
<title>Advanced TypeScript: reinventing lodash.get</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级类型脚本:重塑lodash.get</h1>
<blockquote>原文：<a href="https://itnext.io/advanced-typescript-reinventing-lodash-get-db82eac3345e?source=collection_archive---------4-----------------------#2021-09-05">https://itnext.io/advanced-typescript-reinventing-lodash-get-db82eac3345e?source=collection_archive---------4-----------------------#2021-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2071cc323d00e39b7c62720ca538a754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_3H4_N835ibl6QdX1GuRug.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">TypeScript能够使用属性路径推断正确的类型</figcaption></figure><p id="7142" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">作为Revolut后勤团队的一员，我必须处理大量复杂的数据结构:客户个人数据、交易，应有尽有。有时，您需要呈现一个深藏在数据对象内部的值。为了使生活更简单，我可以使用<a class="ae la" href="https://lodash.com/docs/#get" rel="noopener ugc nofollow" target="_blank"> lodash.get </a>，它允许我通过路径访问一个值，并避免无休止的<code class="fe lb lc ld le b">obj.foo &amp;&amp; obj.foo.bar</code>条件(尽管在可选链接出现后就不再是这样了)。</p><h1 id="3efa" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">这种方法有什么问题？</h1><p id="cb22" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">虽然<code class="fe lb lc ld le b">_.get</code>在运行时工作得非常好，但是当与TypeScript一起使用时，它有一个巨大的缺点:在大多数情况下，它不能推断值类型，这可能导致重构期间的各种问题。</p><p id="9efe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">假设一个服务器向我们发送数据，其中存储了客户的地址</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="dfb0" class="mq lg iq le b gy mr ms l mt mu">type Address = {<br/>  postCode: string<br/>  street: [string, string | undefined]<br/>}</span><span id="5b91" class="mq lg iq le b gy mv ms l mt mu">type UserInfo = {<br/>  address: Address<br/>  previousAddress?: Address<br/>}</span><span id="33ea" class="mq lg iq le b gy mv ms l mt mu">const data: UserInfo = {<br/>  address: {<br/>    postCode: "SW1P 3PA",<br/>    street: ["20 Deans Yd", undefined]<br/>  }<br/>}</span></pre><p id="d5ab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们想要渲染它</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="d87b" class="mq lg iq le b gy mr ms l mt mu">import { get } from 'lodash'</span><span id="5cd8" class="mq lg iq le b gy mv ms l mt mu">type Props = {<br/>  user: UserInfo<br/>}<br/>export const Address = ({ user }: Props) =&gt; (<br/>  &lt;div&gt;{get(user, 'address.street').filter(Boolean).join(', ')}&lt;/div&gt;<br/>)</span></pre><p id="6d68" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">稍后，在某个时候，我们想要重构这个数据结构，并使用稍微不同的地址表示</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="9cc1" class="mq lg iq le b gy mr ms l mt mu">type Address = {<br/>  postCode: string<br/>  street: {<br/>    line1: string<br/>    line2?: string<br/>  }<br/>}</span></pre><p id="fa28" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">由于<code class="fe lb lc ld le b">_.get</code>总是为路径字符串返回<code class="fe lb lc ld le b">any</code>，TypeScript不会注意到任何问题，而代码将在运行时抛出，因为<code class="fe lb lc ld le b">filter</code>方法在我们的新<code class="fe lb lc ld le b">Address</code>对象上不存在。</p><h1 id="3903" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">添加类型</h1><p id="3195" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">自2020年11月发布的v4.1以来，TypeScript有一个名为<a class="ae la" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types" rel="noopener ugc nofollow" target="_blank">模板文字类型</a>的特性。它允许我们用文字和其他类型来构建模板。让我们看看它能如何帮助我们。</p><h1 id="ef8c" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">解析点分隔的路径</h1><p id="527f" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">对于最常见的场景，我们希望TypeScript通过对象内部的给定路径来正确地推断值类型。对于上面的例子，我们想知道一种类型的<code class="fe lb lc ld le b">address.street</code>，以便能够及早发现更新数据结构的问题。我还将使用<a class="ae la" href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html" rel="noopener ugc nofollow" target="_blank">条件类型</a>。如果你不熟悉条件类型，就把它想象成一个简单的三元运算符，它告诉你一个类型是否匹配另一个。</p><p id="0520" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，让我们检查我们的路径是否实际上是一组用点分隔的字段</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="0a12" class="mq lg iq le b gy mr ms l mt mu">type IsDotSeparated&lt;T extends string&gt; = T extends `${string}.${string}`<br/>  ? true<br/>  : false</span><span id="feda" class="mq lg iq le b gy mv ms l mt mu">type A = IsDotSeparated&lt;'address.street'&gt; // true<br/>type B = IsDotSeparated&lt;'address'&gt; // false</span></pre><p id="826c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">看起来很简单，对吧？但是我们如何提取真正的密钥呢？这里有一个神奇的关键字<a class="ae la" href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types" rel="noopener ugc nofollow" target="_blank"> infer </a>，它将帮助我们获取字符串的各个部分</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="41e6" class="mq lg iq le b gy mr ms l mt mu">type GetLeft&lt;T extends string&gt; = T extends `${infer Left}.${string}`<br/>  ? Left<br/>  : undefined</span><span id="4717" class="mq lg iq le b gy mv ms l mt mu">type A = GetLeft&lt;'address.street'&gt; // 'address'<br/>type B = GetLeft&lt;'address'&gt; // undefined</span></pre><p id="0ad4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，是时候添加我们的对象类型了。让我们从一个简单的案例开始</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="dd6a" class="mq lg iq le b gy mr ms l mt mu">type GetFieldType&lt;Obj, Path&gt; = Path extends `${infer Left}.${string}`<br/>  ? Left extends keyof Obj<br/>    ? Obj[Left]<br/>    : undefined<br/>  : Path extends keyof Obj<br/>    ? Obj[Path]<br/>    : undefined<br/></span><span id="8be3" class="mq lg iq le b gy mv ms l mt mu">type A = GetFieldType&lt;UserInfo, 'address.street'&gt; // Address, for now we only taking a left part of a path<br/>type B = GetFieldType&lt;UserInfo, 'address'&gt; // Address<br/>type C = GetFieldType&lt;UserInfo, 'street'&gt; // undefined</span></pre><p id="c320" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，我们检查我们传递的路径是否匹配<code class="fe lb lc ld le b">string.string</code>模板。如果是这样，我们取它的左边部分，检查它是否存在于我们对象的键中，并返回一个字段类型。</p><p id="2044" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果路径与模板不匹配，它可能是一个简单的键。对于这种情况，我们正在做类似的检查并返回字段类型，或作为后备的<code class="fe lb lc ld le b">undefined</code>。</p><h1 id="bcd0" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">添加递归</h1><p id="f3ec" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">好了，我们得到了顶级字段的正确类型。但是它给了我们一点价值。让我们改进我们的效用类型，并沿着所需的值前进。</p><p id="8f68" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将:</p><ol class=""><li id="e2c7" class="mw mx iq ke b kf kg kj kk kn my kr mz kv na kz nb nc nd ne bi translated">查找顶级密钥</li><li id="34c8" class="mw mx iq ke b kf nf kj ng kn nh kr ni kv nj kz nb nc nd ne bi translated">通过给定的键获取值</li><li id="8406" class="mw mx iq ke b kf nf kj ng kn nh kr ni kv nj kz nb nc nd ne bi translated">把这把钥匙从我们的道路上拿走</li><li id="0bb3" class="mw mx iq ke b kf nf kj ng kn nh kr ni kv nj kz nb nc nd ne bi translated">对我们解析的值和其余的键重复整个过程，直到没有匹配的<code class="fe lb lc ld le b">Left.Right</code></li></ol><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="cc77" class="mq lg iq le b gy mr ms l mt mu">export type GetFieldType&lt;Obj, Path&gt; =<br/>  Path extends `${infer Left}.${infer Right}`<br/>    ? Left extends keyof Obj<br/>      ? GetFieldType&lt;Obj[Left], Right&gt;<br/>      : undefined<br/>    : Path extends keyof Obj<br/>      ? Obj[Path]<br/>      : undefined</span><span id="61da" class="mq lg iq le b gy mv ms l mt mu">type A = GetFieldType&lt;UserInfo, 'address.street'&gt; // { line1: string; line2?: string | undefined; }<br/>type B = GetFieldType&lt;UserInfo, 'address'&gt; // Address<br/>type C = GetFieldType&lt;UserInfo, 'street'&gt; // undefined</span></pre><p id="aae7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">完美！看来这正是我们想要的。</p><h1 id="7ec0" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">处理可选属性</h1><p id="93b2" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">嗯，我们还有一个需要考虑的情况。<code class="fe lb lc ld le b">UserInfo</code>类型有一个可选的<code class="fe lb lc ld le b">previousAddress</code>字段。让我们试着得到<code class="fe lb lc ld le b">previousAddress.street</code>型</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="81f0" class="mq lg iq le b gy mr ms l mt mu">type A = GetFieldType&lt;UserInfo, 'previousAddress.street'&gt; // undefined</span></pre><p id="9513" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">哎哟！但是在<code class="fe lb lc ld le b">previousAddress</code>被设置的情况下，<code class="fe lb lc ld le b">street</code>肯定不会未定义。</p><p id="9914" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们看看这里发生了什么。由于<code class="fe lb lc ld le b">previousAddress</code>是可选的，所以它的类型是<code class="fe lb lc ld le b">Address | undefined</code>(我假设你已经打开了<code class="fe lb lc ld le b">strictNullChecks</code>)。显然，<code class="fe lb lc ld le b">street</code>在<code class="fe lb lc ld le b">undefined</code>上是不存在的，所以没有办法推断出一个正确的类型。</p><p id="db8b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们需要改进我们的<code class="fe lb lc ld le b">GetField</code>。要检索正确的类型，我们需要移除<code class="fe lb lc ld le b">undefined</code>。然而，我们需要在最终类型上保留它，因为该字段是可选的，并且该值实际上可能是未定义的。</p><p id="87c2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以用两个TypeScript内置实用程序类型来实现这一点:<code class="fe lb lc ld le b">Exclude</code>从给定的联合中移除类型，而<code class="fe lb lc ld le b">Extract</code>从给定的联合中提取类型，或者在没有匹配的情况下返回<code class="fe lb lc ld le b">never</code>。</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="8e65" class="mq lg iq le b gy mr ms l mt mu">export type GetFieldType&lt;Obj, Path&gt; = Path extends `${infer Left}.${infer Right}`<br/>  ? Left extends keyof Obj<br/>    ? GetFieldType&lt;Exclude&lt;Obj[Left], undefined&gt;, Right&gt; | Extract&lt;Obj[Left], undefined&gt;<br/>    : undefined<br/>  : Path extends keyof Obj<br/>    ? Obj[Path]<br/>    : undefined</span><span id="be6e" class="mq lg iq le b gy mv ms l mt mu">// { line1: string; line2?: string | undefined; } | undefined<br/>type A = GetFieldType&lt;UserInfo, 'previousAddress.street'&gt;</span></pre><p id="6a07" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当<code class="fe lb lc ld le b">undefined</code>出现在值类型中时，<code class="fe lb lc ld le b">| Extract&lt;&gt;</code>将其添加到结果中。否则，<code class="fe lb lc ld le b">Extract</code>返回<code class="fe lb lc ld le b">never</code>,它将被忽略。</p><p id="d0da" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是了！现在我们有了一个很好的实用程序类型，这将有助于使我们的代码更加安全。</p><h1 id="19ff" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">实现效用函数</h1><p id="abf1" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">既然我们已经教会了TypeScript如何获得正确的值类型，那么让我们添加一些运行时逻辑。我们希望我们的函数将一个用点分隔的路径分成几部分，并简化这个列表以获得最终值。功能本身真的很简单。</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="a4da" class="mq lg iq le b gy mr ms l mt mu">export function getValue&lt;<br/>  TData,<br/>  TPath extends string,<br/>  TDefault = GetFieldType&lt;TData, TPath&gt;<br/>&gt;(<br/>  data: TData,<br/>  path: TPath,<br/>  defaultValue?: TDefault<br/>): GetFieldType&lt;TData, TPath&gt; | TDefault {<br/>  const value = path<br/>    .split('.')<br/>    .reduce&lt;GetFieldType&lt;TData, TPath&gt;&gt;(<br/>      (value, key) =&gt; (value as any)?.[key],<br/>      data as any<br/>    );</span><span id="0f27" class="mq lg iq le b gy mv ms l mt mu">  return value !== undefined ? value : (defaultValue as TDefault);<br/>}</span></pre><p id="f95f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们必须添加一些难看的<code class="fe lb lc ld le b">as any</code>型铸件，因为</p><ol class=""><li id="28f1" class="mw mx iq ke b kf kg kj kk kn my kr mz kv na kz nb nc nd ne bi translated">中间值实际上可以是任何类型；</li><li id="0b0f" class="mw mx iq ke b kf nf kj ng kn nh kr ni kv nj kz nb nc nd ne bi translated"><code class="fe lb lc ld le b">Array.reduce</code>期望初始值为相同类型的结果。然而，这里的情况并非如此。此外，尽管有三个泛型类型参数，我们不需要在那里提供任何类型。由于所有泛型都映射到函数参数，因此TypeScript在函数调用时从实际值中推断出这些参数。</li></ol><h1 id="c1f5" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使组件类型安全</h1><p id="03ad" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">让我们重新看看我们的组件。在最初的实现中，我们使用了<code class="fe lb lc ld le b">lodash.get</code>，它不会对不匹配的类型产生错误。但是有了我们的新<code class="fe lb lc ld le b">getValue</code>，TypeScript将立即开始抱怨</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/eddeb8e8b17687e89e0be610628ae0df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nLyY7uN0g0iqrHjz"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">TypeScript“属性筛选器不存在”错误</figcaption></figure><h1 id="ab9b" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">添加对[]符号的支持</h1><p id="bf55" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated"><code class="fe lb lc ld le b">_.get</code>支持<code class="fe lb lc ld le b">list[0].foo</code>等按键。让我们在我们的类型中实现同样的功能。同样，文字模板类型将帮助我们从方括号中获取索引键。这次我不会一步一步来，而是将最终类型和一些评论贴在下面。</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="dd84" class="mq lg iq le b gy mr ms l mt mu">type GetIndexedField&lt;T, K&gt; = K extends keyof T <br/>  ? T[K]<br/>  : K extends `${number}`<br/>    ? '0' extends keyof T<br/>      ? undefined<br/>      : number extends keyof T<br/>        ? T[number]<br/>        : undefined<br/>    : undefined</span><span id="62bc" class="mq lg iq le b gy mv ms l mt mu">type FieldWithPossiblyUndefined&lt;T, Key&gt; =<br/>  | GetFieldType&lt;Exclude&lt;T, undefined&gt;, Key&gt;<br/>  | Extract&lt;T, undefined&gt;</span><span id="7e54" class="mq lg iq le b gy mv ms l mt mu">type IndexedFieldWithPossiblyUndefined&lt;T, Key&gt; =<br/>  | GetIndexedField&lt;Exclude&lt;T, undefined&gt;, Key&gt;<br/>  | Extract&lt;T, undefined&gt;</span><span id="800a" class="mq lg iq le b gy mv ms l mt mu">export type GetFieldType&lt;T, P&gt; = P extends `${infer Left}.${infer Right}`<br/>  ? Left extends keyof T<br/>    ? FieldWithPossiblyUndefined&lt;T[Left], Right&gt;<br/>    : Left extends `${infer FieldKey}[${infer IndexKey}]`<br/>      ? FieldKey extends keyof T<br/>        ? FieldWithPossiblyUndefined&lt;IndexedFieldWithPossiblyUndefined&lt;T[FieldKey], IndexKey&gt;, Right&gt;<br/>        : undefined<br/>      : undefined<br/>  : P extends keyof T<br/>    ? T[P]<br/>    : P extends `${infer FieldKey}[${infer IndexKey}]`<br/>      ? FieldKey extends keyof T<br/>        ? IndexedFieldWithPossiblyUndefined&lt;T[FieldKey], IndexKey&gt;<br/>        : undefined<br/>      : undefined</span></pre><p id="c91c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了从元组或数组中检索值，有一个新的<code class="fe lb lc ld le b">GetIndexedField</code>实用程序类型。它通过给定的键返回元组值，如果键超出元组范围，则返回undefined，或者返回常规数组的元素类型。<code class="fe lb lc ld le b">'0' extends keyof T</code> condition检查一个值是否是一个元组，因为数组没有字符串键。<em class="nl">如果你知道更好的区分元组和数组的方法，请告诉我。</em></p><p id="0711" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们使用<code class="fe lb lc ld le b">${infer FieldKey}[${infer IndexKey}]</code>模板来解析<code class="fe lb lc ld le b">field[0]</code>部件。然后，使用与之前相同的<code class="fe lb lc ld le b">Exclude | Extract</code>技术，我们检索关于可选属性的值类型。</p><p id="d5f5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们需要稍微修改一下我们的<code class="fe lb lc ld le b">getValue</code>函数。为了简单起见，我将用<code class="fe lb lc ld le b">.split(/[.[\]]/).filter(Boolean)</code>代替<code class="fe lb lc ld le b">.split('.')</code>来支持新的符号。这可能不是理想的解决方案，但是更复杂的解析超出了本文的范围。</p><p id="0f4a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是最终的实现</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="7e62" class="mq lg iq le b gy mr ms l mt mu">export function getValue&lt;<br/>  TData,<br/>  TPath extends string,<br/>  TDefault = GetFieldType&lt;TData, TPath&gt;<br/>&gt;(<br/>  data: TData,<br/>  path: TPath,<br/>  defaultValue?: TDefault<br/>): GetFieldType&lt;TData, TPath&gt; | TDefault {<br/>  const value = path<br/>    .split(/[.[\]]/)<br/>    .filter(Boolean)<br/>    .reduce&lt;GetFieldType&lt;TData, TPath&gt;&gt;(<br/>      (value, key) =&gt; (value as any)?.[key],<br/>      data as any<br/>    );</span><span id="7e72" class="mq lg iq le b gy mv ms l mt mu">  return value !== undefined ? value : (defaultValue as TDefault);<br/>}</span></pre><h1 id="391f" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="4ace" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">现在，我们不仅有了一个很好的提高代码类型安全性的实用函数，而且对如何在实践中应用模板文本和条件类型有了更好的理解。</p><p id="6f39" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我希望这篇文章是有帮助的。感谢您的阅读。</p><p id="f3d7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所有代码都可以在<a class="ae la" href="https://codesandbox.io/s/typed-get-value-wmcmm?file=/src/getValue.ts" rel="noopener ugc nofollow" target="_blank">这个代码沙箱</a>中获得</p></div></div>    
</body>
</html>