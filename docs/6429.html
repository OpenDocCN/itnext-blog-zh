<html>
<head>
<title>WebSocket — 1 Million Connections using Appwrite</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebSocket —使用Appwrite的100万个连接</h1>
<blockquote>原文：<a href="https://itnext.io/websocket-1-million-connections-using-appwrite-2d2a2c363a37?source=collection_archive---------0-----------------------#2021-11-15">https://itnext.io/websocket-1-million-connections-using-appwrite-2d2a2c363a37?source=collection_archive---------0-----------------------#2021-11-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/fd29334c304c4f00b3d561b1a1c45950.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z6NR9KRuFXulxq0priq-rQ.jpeg"/></div></div></figure><div class=""/><p id="c282" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们最近的博客文章中，我们谈到了我们从构建WebSocket服务器中学到的东西。现在，我们希望收获我们努力的成果，并检查我们的服务器在恶劣条件下的表现。</p><div class="ip iq gp gr ir kx"><a rel="noopener  ugc nofollow" target="_blank" href="/lessons-learned-from-building-a-websocket-server-e9bc0bd3ef80"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd jc gy z fp lc fr fs ld fu fw ja bi translated">构建WebSocket服务器的经验教训</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">Appwrite是一个开源、自托管的后端即服务，旨在通过SDK简化应用程序开发…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">itnext.io</p></div></div><div class="lg l"><div class="lh l li lj lk lg ll ix kx"/></div></div></a></div><h2 id="b30c" class="lm ln jb bd lo lp lq dn lr ls lt dp lu kj lv lw lx kn ly lz ma kr mb mc md me bi translated">Appwrite是什么？</h2><p id="0b39" class="pw-post-body-paragraph jy jz jb ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated"><a class="ae kw" href="https://appwrite.io" rel="noopener ugc nofollow" target="_blank"> Appwrite </a>是一个开源、自托管的后端即服务，旨在通过各种编程语言提供的SDK简化应用开发。</p><p id="5a6a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Appwrite中使用的WebSocket服务器为一个非常灵活的<a class="ae kw" href="https://appwrite.io/docs/realtime" rel="noopener ugc nofollow" target="_blank">实时API </a>提供动力，用Appwrite的所有服务为你的应用增压！这样，当文档更新、用户创建新会话或功能执行完成时，您会得到通知。所有订阅都受到Appwrite的身份验证和权限系统的保护，这意味着用户只能收到他拥有读取权限的资源的更新。</p><p id="fca1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的目标是达到100万并发连接数。</p><h1 id="b171" class="mk ln jb bd lo ml mm mn lr mo mp mq lu mr ms mt lx mu mv mw ma mx my mz md na bi translated">设置</h1><p id="b32c" class="pw-post-body-paragraph jy jz jb ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">对于WebSocket服务器，我们使用了DigitalOcean的通用Droplet，它有32个内核和128的内存。对于客户端，我们使用了16个较小的微滴，每个微滴有4个内核和16gb的内存。</p><figure class="nc nd ne nf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nb"><img src="../Images/d04706974a32bb6f27bbfc24af02c501.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tkzoU3fJF5SYwMQ9Q4sgcA.png"/></div></div></figure><p id="3181" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了避免任何外部干扰，所有的水滴都是在同一个数据中心创建的，基准测试是在一个内部隔离网络(<a class="ae kw" href="https://www.digitalocean.com/products/vpc/" rel="noopener ugc nofollow" target="_blank"> VPC </a>)中运行的——因此没有流量流出。</p><p id="02e6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于实际的基准测试，我们使用了<a class="ae kw" href="https://github.com/processone/tsung" rel="noopener ugc nofollow" target="_blank"> Tsung </a>，一个开源的多协议分布式负载测试工具来模拟用户，以测试基于IP的客户端/服务器应用程序的可伸缩性和性能。事实上，我们可以轻松地将负载分布在一个客户机集群上，这使得这个工具非常强大。</p><div class="ip iq gp gr ir kx"><a href="https://github.com/processone/tsung" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd jc gy z fp lc fr fs ld fu fw ja bi translated">processone/tsung: Tsung是各种协议的高性能基准框架。</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">这个文档给出了关于这个包的信息的指针，这个包是在GNU通用公共许可证下发布的…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">github.com</p></div></div><div class="lg l"><div class="ng l li lj lk lg ll ix kx"/></div></div></a></div><p id="976b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下面几节中，我们将把客户机称为客户机，把运行Appwrite的服务器称为管理器。</p><h1 id="46ad" class="mk ln jb bd lo ml mm mn lr mo mp mq lu mr ms mt lx mu mv mw ma mx my mz md na bi translated">配置</h1><p id="e894" class="pw-post-body-paragraph jy jz jb ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">为了让Tsung通过SSH与其所有的客户机通信，我们需要在每台充当基准客户机的机器上执行以下步骤:</p><p id="58fe" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">添加一个SSH密钥。</strong></p><p id="72fe" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">设置特定的主机名:</strong></p><ul class=""><li id="92ac" class="nh ni jb ka b kb kc kf kg kj nj kn nk kr nl kv nm nn no np bi translated">实时-工作人员-1</li><li id="5312" class="nh ni jb ka b kb nq kf nr kj ns kn nt kr nu kv nm nn no np bi translated">实时-工人-2</li><li id="a1e7" class="nh ni jb ka b kb nq kf nr kj ns kn nt kr nu kv nm nn no np bi">…</li><li id="b0b7" class="nh ni jb ka b kb nq kf nr kj ns kn nt kr nu kv nm nn no np bi translated">实时-工人-16</li></ul><p id="1d49" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">安宗。</strong></p><p id="fadd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加的SSH密钥稍后将在运行Appwrite的机器上使用，该机器也将使用Tsung来执行基准测试并协调所有客户端。请注意，该计算机不会与实时服务器建立任何连接。</p><p id="1c51" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于Tsung需要配置中每个客户机的主机名，而不是IP，所以我们已经将所有机器添加到<code class="fe nv nw nx ny b">/etc/hosts</code>中，包括其主机名和来自内部网络的相关IP地址。</p><pre class="nc nd ne nf gt nz ny oa ob aw oc bi"><span id="8203" class="lm ln jb ny b gy od oe l of og">10.114.0.x realtime-worker-1<br/>10.114.0.x realtime-worker-2<br/>….<br/>10.114.0.x realtime-worker-15<br/>10.114.0.x realtime-worker-16</span></pre><p id="8c87" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">设置好所有客户端后，我们从管理器手动连接到每个客户端，将它们添加到<code class="fe nv nw nx ny b">known_hosts</code>文件中。这是必需的，因为否则Tsung将无法连接。</p><p id="f09a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们修改了Tsung的配置文件，并添加了所有的客户端。</p><pre class="nc nd ne nf gt nz ny oa ob aw oc bi"><span id="84eb" class="lm ln jb ny b gy od oe l of og">&lt;?xml version="1.0"?&gt;&lt;tsung loglevel="debug" version="1.0"&gt;<br/>  &lt;clients&gt;<br/>    &lt;client host="realtime-worker-1" cpu="4" use_controller_vm="false" maxusers="64000"/&gt;<br/>    &lt;client host="realtime-worker-2" cpu="4" use_controller_vm="false" maxusers="64000"/&gt;<br/>    &lt;client host="realtime-worker-3" cpu="4" use_controller_vm="false" maxusers="64000"/&gt;<br/>    &lt;client host="realtime-worker-4" cpu="4" use_controller_vm="false" maxusers="64000"/&gt;<br/>    &lt;client host="realtime-worker-5" cpu="4" use_controller_vm="false" maxusers="64000"/&gt;<br/>    &lt;client host="realtime-worker-6" cpu="4" use_controller_vm="false" maxusers="64000"/&gt;<br/>    &lt;client host="realtime-worker-7" cpu="4" use_controller_vm="false" maxusers="64000"/&gt;<br/>    &lt;client host="realtime-worker-8" cpu="4" use_controller_vm="false" maxusers="64000"/&gt;<br/>    &lt;client host="realtime-worker-9" cpu="4" use_controller_vm="false" maxusers="64000"/&gt;<br/>    &lt;client host="realtime-worker-10" cpu="4" use_controller_vm="false" maxusers="64000"/&gt;<br/>    &lt;client host="realtime-worker-11" cpu="4" use_controller_vm="false" maxusers="64000"/&gt;<br/>    &lt;client host="realtime-worker-12" cpu="4" use_controller_vm="false" maxusers="64000"/&gt;<br/>    &lt;client host="realtime-worker-13" cpu="4" use_controller_vm="false" maxusers="64000"/&gt;<br/>    &lt;client host="realtime-worker-14" cpu="4" use_controller_vm="false" maxusers="64000"/&gt;<br/>    &lt;client host="realtime-worker-15" cpu="4" use_controller_vm="false" maxusers="64000"/&gt;<br/>    &lt;client host="realtime-worker-16" cpu="4" use_controller_vm="false" maxusers="64000"/&gt;<br/>   &lt;/clients&gt;</span><span id="1122" class="lm ln jb ny b gy oh oe l of og">&lt;servers&gt;<br/>    &lt;server host="10.114.0.x" port="9505" type="tcp"/&gt;<br/>  &lt;/servers&gt;</span><span id="a041" class="lm ln jb ny b gy oh oe l of og">&lt;load&gt;<br/>    &lt;arrivalphase phase="1" duration="10000" unit="second"&gt;<br/>      &lt;users maxnumber="2000000" arrivalrate="2000" unit="second"/&gt;<br/>    &lt;/arrivalphase&gt;<br/>  &lt;/load&gt;</span><span id="20b5" class="lm ln jb ny b gy oh oe l of og">&lt;options&gt;<br/>    &lt;option name="ports_range" min="1025" max="65535"/&gt;<br/>  &lt;/options&gt;</span><span id="3a03" class="lm ln jb ny b gy oh oe l of og">&lt;sessions&gt;<br/>    &lt;session name="websocket" probability="100" type="ts_websocket"&gt;<br/>      &lt;request&gt;<br/>        &lt;websocket type="connect" path="/v1/realtime?project=console&amp;amp;channels[]=files"/&gt;<br/>      &lt;/request&gt;<br/>      &lt;for var="i" from="1" to="1000" incr="1"&gt;<br/>        &lt;thinktime value="30"/&gt;<br/>      &lt;/for&gt;<br/>    &lt;/session&gt;<br/>  &lt;/sessions&gt;<br/>&lt;/tsung&gt;</span></pre><p id="c451" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你在<code class="fe nv nw nx ny b">&lt;load&gt;</code>标签中看到的，<code class="fe nv nw nx ny b">maxnumber</code>属性被设置为200万，这样做的原因是我们在实时服务器上设置了100万个连接的限制，我们不想成为瓶颈。</p><p id="c47e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基于GitHub的一个问题，当时我们的印象是，我们的PHP框架只允许每个实例最多100万个连接。后来我们在Swoole社区Slack中被告知，这实际上是不正确的，在64位机器上的实际限制是2，147，483，584。</p><p id="1d8a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">唯一需要配置的就是操作系统本身。Linux的网络栈为许多工作负载提供了相同的缺省值，但是该栈没有针对100多万个并发连接进行调整。</p><p id="e31f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们预计会面临某种形式的<a class="ae kw" href="https://en.wikipedia.org/wiki/C10k_problem" rel="noopener ugc nofollow" target="_blank"> C10k问题</a>，因此我们提前准备了我们的系统:</p><ul class=""><li id="0977" class="nh ni jb ka b kb kc kf kg kj nj kn nk kr nl kv nm nn no np bi translated">增加了系统的默认TCP缓冲区大小</li><li id="2c84" class="nh ni jb ka b kb nq kf nr kj ns kn nt kr nu kv nm nn no np bi translated">增加了默认IPv4端口范围</li><li id="5988" class="nh ni jb ka b kb nq kf nr kj ns kn nt kr nu kv nm nn no np bi translated">增加了打开文件和文件句柄的限制</li><li id="d1c8" class="nh ni jb ka b kb nq kf nr kj ns kn nt kr nu kv nm nn no np bi translated">更多</li></ul><p id="dc06" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些配置允许我们每个客户端进行大约64，000次连接，最终达到100万次:</p><pre class="nc nd ne nf gt nz ny oa ob aw oc bi"><span id="427f" class="lm ln jb ny b gy od oe l of og"># increasing maximum number of open files<br/>ulimit -n 4000000<br/>sysctl -w fs.file-max=12000500 <br/>sysctl -w fs.nr_open=20000500<br/>echo “root soft nofile 4000000” &gt;&gt; /etc/security/limits.conf<br/>echo “root hard nofile 4000000” &gt;&gt; /etc/security/limits.conf<br/>echo 20000500 &gt; /proc/sys/fs/nr_open</span><span id="681a" class="lm ln jb ny b gy oh oe l of og"># increasing size of the TCP socket buffer.<br/>sysctl -w net.ipv4.tcp_mem=”10000000 10000000 10000000"<br/>sysctl -w net.ipv4.tcp_rmem=”1024 4096 16384"<br/>sysctl -w net.ipv4.tcp_wmem=”1024 4096 16384"<br/>sysctl -w net.core.rmem_max=16384<br/>sysctl -w net.core.wmem_max=16384</span><span id="fe8d" class="lm ln jb ny b gy oh oe l of og"># disable TCP receive buffer auto-tuning<br/>sysctl -w net.ipv4.tcp_moderate_rcvbuf=”0"</span><span id="acd7" class="lm ln jb ny b gy oh oe l of og"># increasing local port range that is used by TCP and UDP<br/>sysctl -w net.ipv4.ip_local_port_range=”500 65535"</span></pre><p id="38aa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们用来解决这些限制的资源:</p><ul class=""><li id="60eb" class="nh ni jb ka b kb kc kf kg kj nj kn nk kr nl kv nm nn no np bi translated"><a class="ae kw" href="https://www.ibm.com/support/pages/tuning-and-debugging-maximum-connections-accepted-messagesight-v20" rel="noopener ugc nofollow" target="_blank">https://www . IBM . com/support/pages/tuning-and-debugging-maximum-connections-accepted-message sight-v 20</a></li><li id="8333" class="nh ni jb ka b kb nq kf nr kj ns kn nt kr nu kv nm nn no np bi translated"><a class="ae kw" href="https://www.linkedin.com/pulse/ec2-tuning-1m-tcp-connections-using-linux-stephen-blum/" rel="noopener ugc nofollow" target="_blank">https://www . LinkedIn . com/pulse/ec2-tuning-1m-TCP-connections-using-Linux-Stephen-Blum/</a></li><li id="0af0" class="nh ni jb ka b kb nq kf nr kj ns kn nt kr nu kv nm nn no np bi translated"><a class="ae kw" href="https://cromwell-intl.com/open-source/performance-tuning/tcp.html" rel="noopener ugc nofollow" target="_blank">https://Cromwell-intl . com/open-source/performance-tuning/TCP . html</a></li></ul><h1 id="8cda" class="mk ln jb bd lo ml mm mn lr mo mp mq lu mr ms mt lx mu mv mw ma mx my mz md na bi translated">准备</h1><p id="353d" class="pw-post-body-paragraph jy jz jb ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">由于所有提到的步骤都需要在我们使用的所有液滴上完成，手动完成所有这些步骤会花费太多时间。为了自动化这项任务，我们使用了<a class="ae kw" href="https://www.ansible.com/" rel="noopener ugc nofollow" target="_blank"> Ansible </a>并创建了一个剧本，负责安装我们使用的所有必要工具，以及操作系统的配置。</p><pre class="nc nd ne nf gt nz ny oa ob aw oc bi"><span id="09a3" class="lm ln jb ny b gy od oe l of og">- name: apt update and upgrade<br/>  hosts: all<br/>  tasks:<br/>  - name: Update and upgrade apt packages<br/>    apt:<br/>      upgrade: yes<br/>      update_cache: yes<br/>      cache_valid_time: 86400</span><span id="4d2f" class="lm ln jb ny b gy oh oe l of og">- name: Run tsung setup<br/>    ansible.builtin.script: ./setup.sh</span><span id="29a4" class="lm ln jb ny b gy oh oe l of og">- name: Setup manager server<br/>  hosts: manager<br/>  tasks:</span><span id="c16b" class="lm ln jb ny b gy oh oe l of og">- name: Install Docker<br/>    ansible.builtin.script: ./get-docker.sh</span><span id="eaff" class="lm ln jb ny b gy oh oe l of og">- name: Install Docker Compose<br/>    get_url: <br/>      url : "<a class="ae kw" href="https://github.com/docker/compose/releases/download/1.29.2/docker-compose-Linux-x86_64" rel="noopener ugc nofollow" target="_blank">https://github.com/docker/compose/releases/download/1.29.2/docker-compose-Linux-x86_64</a>"<br/>      dest: /usr/local/bin/docker-compose<br/>      mode: 'a+x'<br/>      force: yes</span><span id="dc0a" class="lm ln jb ny b gy oh oe l of og">- name: Copy private key<br/>    ansible.builtin.copy:<br/>      src: ./id_rsa<br/>      dest: /root/.ssh/id_rsa<br/>      owner: root<br/>      group: root<br/>      mode: '0600'</span><span id="a937" class="lm ln jb ny b gy oh oe l of og">- name: Copy tsung config<br/>    ansible.builtin.copy:<br/>      src: ./bench.xml<br/>      dest: /root/bench.xml<br/>      owner: root<br/>      group: root<br/>      mode: '0644'</span><span id="5992" class="lm ln jb ny b gy oh oe l of og">- name: Copy etchosts<br/>    ansible.builtin.copy:<br/>      src: ./etchosts<br/>      dest: /root/etchosts<br/>      owner: root<br/>      group: root<br/>      mode: '0600'</span><span id="93cf" class="lm ln jb ny b gy oh oe l of og">- name: Append etchosts to /etc/hosts<br/>    ansible.builtin.shell: cat /root/etchosts &gt;&gt; /etc/hosts</span><span id="1372" class="lm ln jb ny b gy oh oe l of og">- name: Clone Appwrite repo<br/>    ansible.builtin.git:<br/>      repo: <a class="ae kw" href="https://github.com/appwrite/appwrite.git" rel="noopener ugc nofollow" target="_blank">https://github.com/appwrite/appwrite.git</a><br/>      dest: /root/appwrite</span><span id="33c6" class="lm ln jb ny b gy oh oe l of og">- name: Copy sshkeys to workers<br/>  hosts: workers<br/>  tasks:<br/>    - name: add manager public key to workers<br/>      authorized_key:<br/>        user: root<br/>        state: present<br/>        key: "{{ lookup('file', './id_rsa.pub') }}"</span></pre><p id="8c99" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第一部分中，我们升级到所有软件包的最新版本，安装了Tsung，并在所有Droplets上使用<code class="fe nv nw nx ny b">setup.sh</code>脚本调整了操作系统。</p><p id="a14c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装Tsung需要我们编译它并安装依赖项，为此我们使用了以下脚本:</p><pre class="nc nd ne nf gt nz ny oa ob aw oc bi"><span id="a83d" class="lm ln jb ny b gy od oe l of og"># install dependencies<br/>apt-get install elixir build-essential gnuplot libtemplate-perl make erlang erlang-base libyaml-dev python python3-pip libssl-dev autoconf</span><span id="3bc2" class="lm ln jb ny b gy oh oe l of og"># download and compile tsung<br/>wget <a class="ae kw" href="http://tsung.erlang-projects.org/dist/tsung-1.7.0.tar.gz" rel="noopener ugc nofollow" target="_blank">http://tsung.erlang-projects.org/dist/tsung-1.7.0.tar.gz</a><br/>tar -xvf tsung-1.7.0.tar.gz<br/>cd tsung-1.7.0/<br/>./configure<br/>make<br/>make install</span></pre><p id="3d7d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二步是让经理做好准备，并采取以下行动:</p><ul class=""><li id="aa4f" class="nh ni jb ka b kb kc kf kg kj nj kn nk kr nl kv nm nn no np bi translated">安装Docker</li><li id="d4ad" class="nh ni jb ka b kb nq kf nr kj ns kn nt kr nu kv nm nn no np bi translated">安装Docker撰写</li><li id="8ec3" class="nh ni jb ka b kb nq kf nr kj ns kn nt kr nu kv nm nn no np bi translated">复制私有SSH密钥</li><li id="4af5" class="nh ni jb ka b kb nq kf nr kj ns kn nt kr nu kv nm nn no np bi translated">复制Tsung的配置文件</li><li id="ebe3" class="nh ni jb ka b kb nq kf nr kj ns kn nt kr nu kv nm nn no np bi translated">将所有客户端添加到<code class="fe nv nw nx ny b">/etc/hosts</code>文件中</li><li id="6939" class="nh ni jb ka b kb nq kf nr kj ns kn nt kr nu kv nm nn no np bi translated">安装Appwrite</li></ul><p id="fc43" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第三步也是最后一步是将公共SSH密钥复制到所有客户端，以便管理器能够连接。</p><p id="b51d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Ansible处理完所有任务后，我们就可以开始实际的基准测试了。</p><h1 id="7cc7" class="mk ln jb bd lo ml mm mn lr mo mp mq lu mr ms mt lx mu mv mw ma mx my mz md na bi translated">基准</h1><figure class="nc nd ne nf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oi"><img src="../Images/7d82866d57130c2e04e3328ac03fc81f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nWyfeldV6CH1By6K8b50yw.png"/></div></div><figcaption class="oj ok gj gh gi ol om bd b be z dk translated">管理器上的htop</figcaption></figure><p id="9808" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看着管理器中的<code class="fe nv nw nx ny b">htop</code>拥有32个内核和128 GB的内存，随时可以加载工作，这已经是一个非常美好的景象了。然后，我们用下面的命令启动了Tsung:</p><pre class="nc nd ne nf gt nz ny oa ob aw oc bi"><span id="d0e1" class="lm ln jb ny b gy od oe l of og">tsung -f bench.xml -k start</span></pre><p id="3ad0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦基准开始运行，我们就会得到一个更加令人兴奋的16个客户端的<code class="fe nv nw nx ny b">htop</code>汇编。</p><figure class="nc nd ne nf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi on"><img src="../Images/9678a949e0f37f83ce7e11aa64bf643e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z0fP6BlFQR2FKTD8JVnyhA.png"/></div></div></figure><p id="1ada" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Tsung自己提供了一个关于<code class="fe nv nw nx ny b">8091</code>港的公共网站，它为我们提供了一个对基准本身的简单监控。遗憾的是，页面没有实时更新，所以我们发现自己每隔一秒钟就刷新一次页面，兴奋地看着连接的并发用户数量上升。</p><p id="dd5c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们将Tsung配置为每秒建立2000个连接，所以我们正好需要500秒才能达到神奇的一百万。</p><p id="cdbd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大约500秒后，我们做到了。我们有100万个并发连接到一个连接的实时服务器！</p><figure class="nc nd ne nf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oo"><img src="../Images/a615b7fe0aa7c54afea82dd3d4de3834.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WxW86r9g3F1Kd_OHo15iGg.png"/></div></div></figure><p id="205d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们对这个数字非常满意，特别是因为在生产中，没有一个实时实例可以容纳那么多的连接。尤其是管理器的负载让我们很开心，仅仅是<strong class="ka jc"> 16 GB的内存</strong>和<strong class="ka jc"> 7%的CPU </strong>负载就被用来维护已经建立的连接。</p><p id="29ef" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，该基准测试仅测试连接的并发用户数量，而不是具有许多不同通道和发送的消息的真实场景。我们确实有一些想法，在未来对不同的场景进行基准测试，这些场景反映了典型的用例以及200万个连接。</p><h1 id="eb22" class="mk ln jb bd lo ml mm mn lr mo mp mq lu mr ms mt lx mu mv mw ma mx my mz md na bi translated">结果</h1><p id="f116" class="pw-post-body-paragraph jy jz jb ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">由于Appwrite是开源的，我们希望提供尽可能多的透明度，所以我们提供所有结果、配置和脚本供下载。我们还准备了<a class="ae kw" href="https://realtime-1-million-auig4.ondigitalocean.app/" rel="noopener ugc nofollow" target="_blank">网页</a>，在那里所有的结果都很容易获得。</p><div class="ip iq gp gr ir kx"><a href="https://realtime-1-million-auig4.ondigitalocean.app" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd jc gy z fp lc fr fs ld fu fw ja bi translated">app write-100万基准</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">一段时间内同时连接的用户数量。同时用户的数量。通过…连接的用户数量</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">real time-100万-auig4.ondigitalocean.app</p></div></div><div class="lg l"><div class="op l li lj lk lg ll ix kx"/></div></div></a></div><p id="71a4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你也可以在<a class="ae kw" href="https://github.com/appwrite/realtime-1-million" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>里找到所有文件。</p></div></div>    
</body>
</html>