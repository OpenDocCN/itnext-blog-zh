# 征服高速缓存狂潮

> 原文：<https://itnext.io/conquering-the-cache-stampede-3a4c9feb691c?source=collection_archive---------5----------------------->

![](img/d7b45fb70235e367f135e246dd7a1cbf.png)

照片由 [Jorge Tung](https://unsplash.com/@jorgetung?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

# 雷鸣般的兽群

您听从了每个人的建议，构建了一个无状态的应用程序。数据不在你的应用服务器中，因此当你收到请求时，你查询数据库。为了简单起见，您的代码看起来像下面这样，其中数据库被交换了:

我们可以用一个快速的 curl 命令来测试服务器。

随着时间的推移，您的服务规模不断扩大，您开始收到许多请求。每个请求都会导致一次数据库查询，有些查询很慢。在足够的负载下，您的延迟是不可接受的。您可以尝试通过添加索引、重写和基准测试查询、迁移数据模型等来优化数据层的查询执行时间。这可能是对时间的有益和有价值的利用，但是有一个更简单的解决方案。您可以在应用服务器中缓存数据库中给定查询的结果。在一段时间内，对相同数据的后续请求将由内存中的缓存提供服务，从而减少数据库的负载和延迟。问题解决了对吗？您的代码看起来会像这样:

为了测试服务器，我们可以编写一个简单的 bash 一行程序来请求数据并观察结果。

当应用程序和数据库负载不足时，这种方法可能在低流量下工作。然而，有一个问题。当多个并发请求针对相同的数据，而数据没有被缓存时会发生什么？值得注意的是，http 库将在单独的 goroutines 中运行请求处理程序，因此对数据库的多个调用有可能同时发生。现实与你的预期不同。您可能认为第一个请求从数据库填充缓存，其他请求从缓存提供服务。实际情况是，我们有 5 个对数据库的相同数据的请求。

注意，我在下面的 curl 命令中添加了一个`&`来同时运行它们。

所有的 go routine 检查缓存，值不存在，所有的 go routine 查询数据库来填充缓存。这被称为“雷霆一族”或[缓存踩踏](https://en.wikipedia.org/wiki/Cache_stampede)。更不幸的是，这个问题出现在足够的负载下，因此当数据层无法承担额外的工作时，它会收到对相同数据的多个请求。脸书[几年前发布了一个关于这个话题的视频](https://www.facebook.com/watch/?v=10153675295382200)，值得一看。

# 解决方案

我们如何解决这个问题？我们需要协调并发的 go 例程，使得一次只有一个例程为给定的键填充缓存。其他例程应该等待缓存填充，然后从缓存提供服务。为了使这更容易，我们将把填充逻辑推到缓存中，因为它已经被多个例程共享。我们将接受一个加载函数，该函数在给定一个键的情况下查询数据库。我们可以对调用者隐藏关于从数据库加载或从缓存读取的决定，并提供一个单独的`Get`方法。

在我们深入实现之前，让我们回顾一下高层次的想法。我们将在填充缓存条目时创建一个通道。如果该通道存在，其他 go 例程将等待我们完成值的填充。一旦我们填充了这个值，关闭通道，所有其他的 goroutines 将从缓存中返回这个值。

缓存的代码比以前长了，因此我把它分成了自己的文件。`Get`方法包含主要逻辑。

如果直接将其投入生产，这种缓存实现会有一些问题，即没有驱逐策略，以及潜在的严重锁争用。如果你想了解更多，请查看[这篇关于 go 缓存的文章](https://dgraph.io/blog/post/caching-in-go/)。也就是说，这个缓存说明了解决问题的方法。

我们的服务器的 main 方法现在需要将数据库查询设置为 loader 函数的一部分。它应该看起来像这样。

如果我们运行并发 curl 命令，我们将看到只有第一个请求从数据库中查询数据！

我们解决了单个流程的问题。在具有外部缓存的分布式设置中，如 Redis，解决方案是类似的。Redis 实验室已经有一篇关于这个问题的[文章](https://redislabs.com/blog/caches-promises-locks/)。

感谢您的阅读，请在评论中告诉我您的想法。

*原载于*[*sidneyw.com*](https://www.sidneyw.com/conquering-the-cache-stampede/)*。*