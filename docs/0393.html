<html>
<head>
<title>Cookbook: Java -&gt; Maven -&gt; Docker -&gt; AWS ECR -&gt; AWS ECS (Fargate)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">菜谱:Java-&gt; Maven-&gt; Docker-&gt; AWS ECR-&gt; AWS ECS(Fargate)</h1>
<blockquote>原文：<a href="https://itnext.io/cookbook-java-maven-docker-aws-ecr-aws-ecs-fargate-e12cfc126050?source=collection_archive---------4-----------------------#2018-03-04">https://itnext.io/cookbook-java-maven-docker-aws-ecr-aws-ecs-fargate-e12cfc126050?source=collection_archive---------4-----------------------#2018-03-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="4c65" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">实用开发工具</h2><div class=""/><div class=""><h2 id="2219" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">如何将Java应用程序自动部署到无服务器容器</h2></div><h2 id="c086" class="ko kp iq bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li iw bi translated">TL；DR；</h2><p id="474f" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr kx ls lt lu lb lv lw lx lf ly lz ma mb ij bi translated">在这篇文章中，我将展示如何在Jenkins中建立一个管道来构建一个Java应用程序的Docker映像，并将其上传到您的(私有)AWS ECR存储库中，然后部署到AWS Fargate上</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/64203242720574616979877ee55c8028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yw_r3llsgI43QYFJfxP0XA.png"/></div></div></figure><h2 id="1064" class="ko kp iq bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li iw bi translated">背景</h2><p id="057c" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr kx ls lt lu lb lv lw lx lf ly lz ma mb ij bi translated">我四处寻找一些关于如何建立一个管道的资料，这个管道将我从IntelliJ IDEA中的Java代码带到Amazon Web Services (AWS)上正在运行的docker容器。而且有很多信息是过时的、不完整的或者很难找到的。所以我想分享一下我的概念验证的设置，以及一些如何让它工作的脚本。</p><p id="d2cd" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">警告:这个管道对我正在进行的一个小型概念验证非常有用。对于一个大规模的管道，你可能想要更多的自动化，也许对你的SCM中的事件作出反应，自动开始构建，而不是在本地运行Jenkins等等。</p><p id="5bee" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">所有代码/示例都可以从<a class="ae mt" href="https://gitlab.com/NiclasG/cookbook/tree/master/jenkins-ecr" rel="noopener ugc nofollow" target="_blank">gitlab.com/NiclasG/cookbook</a>下载</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mu"><img src="../Images/ac85529c7c17ce47c037e336f944c510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jEzGkv4Qtg-Qs9NN-L4LDw.png"/></div></div></figure><p id="3c25" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">我们将经历几个步骤。首先，我将提到一些必要的先决条件。然后，我们将进行一些AWS配置，这将允许我们远程访问我们的存储库。接下来是主要部分:设置Jenkins和助手脚本来完成实际工作。最后，我们将看看一旦我们使用新的AWS Fargate特性将docker容器上传到AWS，如何启动它。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mu"><img src="../Images/de3e347db5a01865c402cd65ffde8d41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o7WtnvvTdbA8tAB1NZRLPg.png"/></div></div></figure><h2 id="f226" class="ko kp iq bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li iw bi translated">本地环境先决条件和设置</h2><p id="c505" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr kx ls lt lu lb lv lw lx lf ly lz ma mb ij bi translated">我用的是Macbook Pro，但我相信在Win/Linux环境下做这些应该没有问题。路径和其他细节当然可能不同。请在下面的评论中告诉我你是否成功地尝试过(或者失败得很惨)。</p><ul class=""><li id="7dd8" class="mv mw iq ll b lm mo lp mp kx mx lb my lf mz mb na nb nc nd bi translated">Docker——我们都将使用docker来创建图像，并旋转容器来进行实际的编译。<a class="ae mt" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank"> Docker可在此获得。</a></li><li id="4933" class="mv mw iq ll b lm ne lp nf kx ng lb nh lf ni mb na nb nc nd bi translated">AWS CLI工具，<a class="ae mt" href="https://docs.aws.amazon.com/cli/latest/userguide/cli-install-macos.html" rel="noopener ugc nofollow" target="_blank">可从AWS </a>获得。</li><li id="920b" class="mv mw iq ll b lm ne lp nf kx ng lb nh lf ni mb na nb nc nd bi translated">Java项目:不用说，您将需要一些Java源代码来运行这个项目。—我不会提供它，所以带你最喜欢的GitHub项目出去转转吧。我们将进一步配置Jenkins的SCM部分，以检查代码并构建它。</li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mu"><img src="../Images/61b343292dfeb238b71ba7a9488aaacb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yeaO2y-vy0lVUE7URH1WQA.png"/></div></div></figure><h1 id="296e" class="nj kp iq bd kq nk nl nm kt nn no np kw kf nq kg la ki nr kj le kl ns km li nt bi translated">AWS设置</h1><h2 id="529e" class="ko kp iq bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li iw bi translated">IAM访问</h2><p id="9462" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr kx ls lt lu lb lv lw lx lf ly lz ma mb ij bi translated">为了能够将图像推送到AWS，我们将设置一个具有受限访问权限的新IAM用户。对于生产系统，您可能希望启用2FA (MFA ),但现在我们将禁用它。如果您使用多个ECR存储库，您可能还需要限制用户可以访问哪个ECR存储库。</p><ul class=""><li id="8c0f" class="mv mw iq ll b lm mo lp mp kx mx lb my lf mz mb na nb nc nd bi translated">登录您的AWS管理控制台，前往<a class="ae mt" href="https://console.aws.amazon.com/iam/home" rel="noopener ugc nofollow" target="_blank"> AWS IAM部分</a>并创建一个新用户，我将我的用户命名为“ecr-remote-pusher”。确保勾选标有<em class="nu">“程序化访问”的方框。</em></li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nv"><img src="../Images/452f103fefb0d616bcbf99b0d9393643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k7h0EDwg-zQK1ybykhomyQ.png"/></div></div></figure><ul class=""><li id="41a5" class="mv mw iq ll b lm mo lp mp kx mx lb my lf mz mb na nb nc nd bi translated">将<strong class="ll ja">ContainerRegistryPowerUser</strong>策略附加到IAM用户。</li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nw"><img src="../Images/249cba9e6a0bc42b51cd7d3584196a0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cEQzUYD5F1pkZOg5Br5DGQ.png"/></div></div></figure><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nx"><img src="../Images/37dc4bce24d134d0f0026a5ff0f8746d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*guZuIz1rgK8mM734bREbsw.png"/></div></div></figure><p id="0acb" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">将访问ID/密钥对以及您选择的地区添加到您的~/中。AWS/凭据文件。为了我自己的健康，我将使用与IAM用户同名的概要文件。</p><pre class="md me mf mg gt ny nz oa ob aw oc bi"><span id="e14d" class="ko kp iq nz b gy od oe l of og">[ecr-remote-pusher]</span><span id="e0c9" class="ko kp iq nz b gy oh oe l of og">aws_access_key_id = AKIAIXXXXXXXXXXXXX</span><span id="67a7" class="ko kp iq nz b gy oh oe l of og">aws_secret_access_key = jPXXXXXbErVkw+ZfU6XXXXXr</span><span id="6250" class="ko kp iq nz b gy oh oe l of og">region=us-east-1</span></pre><h2 id="6db9" class="ko kp iq bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li iw bi translated">创建AWS ECR存储库</h2><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/1f2ab5b97c4901aae936bbbf6589b0b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*6maNTgDk4QsAlyK5tu1eww.png"/></div></figure><p id="9780" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated"><strong class="ll ja">注意:Fargate功能目前仅在us-east-1地区可用。如果你想尝试一下，我建议在同一个地区建立ECR库。</strong></p><p id="527d" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">转到<strong class="ll ja"> AWS弹性容器服务</strong>，选择存储库链接并创建一个新的存储库:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/78ac1a95f8d439b9a1f7daa4923f67c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*7sT5TC1hTjdn8AVc0GiXXA.png"/></div></figure><p id="1245" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">给你的存储库起一个有意义的名字，并记下<strong class="ll ja">存储库URI。</strong></p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ok"><img src="../Images/bec0cf4e5b5727df2cba708211dcbe77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rc1bifLEHiyEjrV4durtwA.png"/></div></div></figure><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mu"><img src="../Images/ad76226a203b5330e52f0266aff4d379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zO61Jd_LEuXpm4NUc9WTKQ.png"/></div></div></figure><h1 id="f242" class="nj kp iq bd kq nk nl nm kt nn no np kw kf nq kg la ki nr kj le kl ns km li nt bi translated">詹金斯</h1><h2 id="af64" class="ko kp iq bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li iw bi translated">设置Jenkins环境</h2><p id="2f56" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr kx ls lt lu lb lv lw lx lf ly lz ma mb ij bi translated">对于本指南，我们将使用运行Jenkins的docker容器。我使用的版本是我写作时的最新版本(2.109)。我使用alpine映像(jenkins/jenkins-2.109-alpine)作为基础，并通过添加AWS CLI工具和Docker对其进行“修补”，然后我<a class="ae mt" href="https://hub.docker.com/r/ngmg/jaws/" rel="noopener ugc nofollow" target="_blank">将完成的映像上传到Docker Hub。</a></p><p id="b765" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">要下载图像，请使用以下内容:</p><pre class="md me mf mg gt ny nz oa ob aw oc bi"><span id="cba0" class="ko kp iq nz b gy od oe l of og"><strong class="nz ja">$ </strong>docker pull ngmg/jaws:2.109-alpine</span></pre><p id="2a13" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">或者从<a class="ae mt" href="https://gitlab.com/NiclasG/cookbook/blob/master/jaws/Dockerfile" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>构建自己的:</p><pre class="md me mf mg gt ny nz oa ob aw oc bi"><span id="edda" class="ko kp iq nz b gy od oe l of og">FROM jenkins/jenkins:2.109-alpine</span><span id="2c17" class="ko kp iq nz b gy oh oe l of og">MAINTAINER Niclas Gustafsson &lt;hiniclas@gmail.com&gt;</span><span id="e0a6" class="ko kp iq nz b gy oh oe l of og">USER root</span><span id="ec72" class="ko kp iq nz b gy oh oe l of og">RUN apk add --update python py-pip docker &amp;&amp; \</span><span id="f5c2" class="ko kp iq nz b gy oh oe l of og">pip install awscli &amp;&amp; \</span><span id="0ec0" class="ko kp iq nz b gy oh oe l of og">rm -rf /var/cache/apk/*</span></pre><p id="4241" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">要开始，请运行以下命令:</p><pre class="md me mf mg gt ny nz oa ob aw oc bi"><span id="018b" class="ko kp iq nz b gy od oe l of og"><strong class="nz ja">$ </strong>docker run \<br/>   -p 8080:8080 \ <br/>   -v jenkins_home:/var/jenkins_home \<br/>   -v $HOME:/home \<br/>   -v /var/run/docker.sock:/var/run/docker.sock \<br/>   ngmg/jaws:2.109-alpine</span></pre><p id="df21" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">这将设置docker将端口8080转发到容器，并公开三个目录/文件:</p><ul class=""><li id="1080" class="mv mw iq ll b lm mo lp mp kx mx lb my lf mz mb na nb nc nd bi translated">容器中的/var/jenkins_home映射到一个卷“jenkins ”,以保持数据的持久性，而不管容器发生了什么。</li><li id="3241" class="mv mw iq ll b lm ne lp nf kx ng lb nh lf ni mb na nb nc nd bi translated">/home映射到您的主目录，用于存储运行之间的信息和访问您的AWS凭证(~/。AWS/凭证)</li><li id="94c0" class="mv mw iq ll b lm ne lp nf kx ng lb nh lf ni mb na nb nc nd bi translated">/var/run/docker.sock用于在jenkins内部的docker客户端与您的主机上运行的docker守护进程之间进行通信。</li></ul><p id="61f0" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">启动后，<a class="ae mt" href="https://jenkins.io/doc/book/installing/#setup-wizard" rel="noopener ugc nofollow" target="_blank">使用推荐的插件进行初始配置。</a></p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/982a82c4e153aa24266cb3479b5498be.png" data-original-src="https://miro.medium.com/v2/resize:fit:320/format:webp/1*zyonLJjPJ1RxPWP4m9Px_A.png"/></div></figure><h2 id="a248" class="ko kp iq bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li iw bi translated">添加Jenkins插件</h2><p id="26ab" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr kx ls lt lu lb lv lw lx lf ly lz ma mb ij bi translated">一旦启动并运行，用你的管理员帐户登录并启用我们需要的几个插件。<a class="ae mt" href="http://127.0.0.1:8080/pluginManager/" rel="noopener ugc nofollow" target="_blank"> Jenkins - &gt;管理Jenkins - &gt;管理插件</a></p><p id="61a7" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">添加以下插件:</p><p id="775f" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">https://plugins.jenkins.io/docker-plugin</p><p id="b9c0" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">Docker步骤插件:<a class="ae mt" href="https://wiki.jenkins.io/display/JENKINS/Docker+build+step+plugin" rel="noopener ugc nofollow" target="_blank">https://wiki . JENKINS . io/display/JENKINS/Docker+build+step+插件</a></p><p id="baaa" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">如果你打算使用GitLab，你可能需要GitLab插件:【https://wiki.jenkins-ci.org/display/JENKINS/GitLab+Plugin】T2</p><h2 id="d428" class="ko kp iq bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li iw bi translated">建设管道</h2><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mu"><img src="../Images/59c8806b361a9ef6c33458cdb242f62f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l0zJ4PEs013b2v9-SdOVKQ.png"/></div></div></figure><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi om"><img src="../Images/8c50930b3f52292ff5dbe79e56912a06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iqCBYHQHKLqx_BNMybvo9Q.jpeg"/></div></div></figure><p id="cca9" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">我们将构建一个docker映像，它将被标记上Jenkins条目/项目的名称和构建号，所以选择一个小写<strong class="ll ja">的名称</strong>，否则docker构建将会失败。在一个更现实的场景中，图像的名称可能是其他的，但是对于这个练习来说，它就可以了。</p><p id="9257" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">创建新项目时选择管道选项。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi on"><img src="../Images/af81b104df4d832cadd4546398ca031d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZBX4CZQW5gk9ADaGBtdgow.png"/></div></div></figure><p id="48a1" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">接下来要做的是将Jenkins作业设置为一个<em class="nu">参数化项目</em>。这使我们能够在Jenkins内部提供一些(特定于作业的)配置，而不必修改脚本，然后我们可以重用这些脚本。</p><ul class=""><li id="aee1" class="mv mw iq ll b lm mo lp mp kx mx lb my lf mz mb na nb nc nd bi translated">检查顶部中的<em class="nu">“该项目已参数化”</em></li></ul><p id="f441" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">首先，我们添加一个<strong class="ll ja">字符串</strong>参数，它定义了我们希望将图像推送到哪个AWS存储库。格式如下(替换为您在上一步中的具体信息)。</p><pre class="md me mf mg gt ny nz oa ob aw oc bi"><span id="79ba" class="ko kp iq nz b gy od oe l of og">Name:          aws_repository<br/>Default Value: &lt;AWS Account Id&gt;.dkr.ecr.&lt;Region&gt;.amazonaws.com/&lt;your repo&gt;</span></pre><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi oo"><img src="../Images/9b4ad0eb0c484a1f436a62c098155841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w8Ax2zkhNnqR1Vqwwv-GFw.png"/></div></div></figure><p id="0ace" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">我们将添加的第二个参数是AWS凭据配置文件，Jenkins将使用它通过AWS CLI访问AWS ECR。</p><pre class="md me mf mg gt ny nz oa ob aw oc bi"><span id="02dc" class="ko kp iq nz b gy od oe l of og">Name:          aws_profile<br/>Default Value: &lt;id from credentials file&gt;</span></pre><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi op"><img src="../Images/1008647575834f1739c199bb3b4db3df.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*ZE5_wTZU589KuZpqvH56og.png"/></div></figure><p id="04c9" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">接下来，设置your Jenkins项目，像平常一样获取源代码。我使用了一个像这样的<a class="ae mt" href="https://medium.com/@teeks99/continuous-integration-with-jenkins-and-gitlab-fa770c62e88a" rel="noopener">设置来使用我个人的Gitlab库。然而，由于我们不会在本指南中使用web挂钩或任何外部触发器，请确保您不会使用<em class="nu"> ${gitlabSourceBranch} </em>参数，因为这些参数不会被正确计算。</a></p><p id="35b1" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">简而言之，要访问GitLab repo，您需要设置Jenkins系统，然后才能配置实际的项目/物品:</p><ol class=""><li id="78ab" class="mv mw iq ll b lm mo lp mp kx mx lb my lf mz mb oq nb nc nd bi translated">设置SSH密钥(<a class="ae mt" href="http://127.0.0.1:8080/credentials/store/system/domain/_/" rel="noopener ugc nofollow" target="_blank">凭证</a>)</li><li id="7e7e" class="mv mw iq ll b lm ne lp nf kx ng lb nh lf ni mb oq nb nc nd bi translated">设置登录令牌(<a class="ae mt" href="http://127.0.0.1:8080/credentials/store/system/domain/_/" rel="noopener ugc nofollow" target="_blank">凭证</a>)</li><li id="d6e5" class="mv mw iq ll b lm ne lp nf kx ng lb nh lf ni mb oq nb nc nd bi translated">配置GitLab连接(<a class="ae mt" href="http://127.0.0.1:8080/configure" rel="noopener ugc nofollow" target="_blank">管理Jenkins /配置系统</a></li></ol><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi or"><img src="../Images/ddb08261e19f347acc39342b4e2d62c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9CymuRmhsu-CnyAIlovt8A.png"/></div></div></figure><p id="e49b" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">要么直接指向您的在线(Github/Gitlab)存储库，要么提供一个到磁盘上的项目的本地路径，如果您正在进行尝试时不想提交的更改。请记住，提供路径是Jenkins docker映像中的路径。即以/home开始路径(如果您的repo在主机上的＄HOME中)。(记住上面docker rum的-v选项)</p><h2 id="a01e" class="ko kp iq bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li iw bi translated">脚本和配置</h2><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mu"><img src="../Images/bbb3f0cfe23a5b6d21c892486f9ca882.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fYWxqYgbUunXIjWzXxdi3A.png"/></div></div></figure><p id="58f6" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">接下来的事情包括在你的项目中设置一些脚本。我在这里提供了例子:<a class="ae mt" href="https://gitlab.com/NiclasG/cookbook/tree/master/jenkins-ecr/scripts" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/NiclasG/cookbook</a></p><ul class=""><li id="cd9f" class="mv mw iq ll b lm mo lp mp kx mx lb my lf mz mb na nb nc nd bi translated">。/Jenkinsfile —描述管道中的步骤</li><li id="e6aa" class="mv mw iq ll b lm ne lp nf kx ng lb nh lf ni mb na nb nc nd bi translated">。/POM . XML—maven配置文件。</li><li id="9d71" class="mv mw iq ll b lm ne lp nf kx ng lb nh lf ni mb na nb nc nd bi translated">。/Dockerfile —描述如何构建docker映像</li><li id="c101" class="mv mw iq ll b lm ne lp nf kx ng lb nh lf ni mb na nb nc nd bi translated">。/scripts/build-maven.sh —运行mvn命令进行编译和打包。</li><li id="bd35" class="mv mw iq ll b lm ne lp nf kx ng lb nh lf ni mb na nb nc nd bi translated">。/scripts/aws-ecr-push.sh —处理AWS ECR登录并将映像推送到AWS ECR存储库的脚本。</li></ul><p id="c190" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">首先是上面Jenkins配置中引用的文件，<strong class="ll ja">Jenkins file</strong>——它描述了管道。将它添加到项目的根目录中。</p><p id="6953" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">(<a class="ae mt" href="https://gitlab.com/NiclasG/cookbook/blob/master/jenkins-ecr/Jenkinsfile" rel="noopener ugc nofollow" target="_blank">下载链接</a>)</p><pre class="md me mf mg gt ny nz oa ob aw oc bi"><span id="3860" class="ko kp iq nz b gy od oe l of og">node {<br/>    checkout scm<br/>    stage('Build Maven') {<br/>        docker.image('maven:3-alpine').inside('-v $HOME/.m2:/root/.m2') {<br/>            sh './scripts/build-maven.sh'<br/>        }<br/>    }<br/>    stage('Build Docker Image') {<br/>        docker.build("${env.JOB_NAME}:${env.BUILD_NUMBER}")<br/>    }<br/>    stage('Push to AWS'){<br/>        sh "./scripts/aws-ecr-push.sh ${env.JOB_NAME}:${env.BUILD_NUMBER} /home/.aws/credentials"<br/>    }<br/>}</span></pre><p id="8198" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">我们有一个包含三个步骤的小管道:</p><ol class=""><li id="9b6d" class="mv mw iq ll b lm mo lp mp kx mx lb my lf mz mb oq nb nc nd bi translated">构建Java代码</li><li id="992c" class="mv mw iq ll b lm ne lp nf kx ng lb nh lf ni mb oq nb nc nd bi translated">构建Docker映像</li><li id="3098" class="mv mw iq ll b lm ne lp nf kx ng lb nh lf ni mb oq nb nc nd bi translated">将其发送至AWS ECR</li></ol><p id="47e4" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">其次是Maven <strong class="ll ja"> pom.xml </strong>文件，它描述了您的依赖项和构建过程。这些脚本需要的关键元素包括如下:</p><pre class="md me mf mg gt ny nz oa ob aw oc bi"><span id="3a89" class="ko kp iq nz b gy od oe l of og">.<br/>.<br/>.<br/>&lt;<strong class="nz ja">build</strong>&gt;<br/>    &lt;<strong class="nz ja">plugins</strong>&gt;<br/>        &lt;<strong class="nz ja">plugin</strong>&gt;<br/>            &lt;<strong class="nz ja">groupId</strong>&gt;org.apache.maven.plugins&lt;/<strong class="nz ja">groupId</strong>&gt;<br/>            &lt;<strong class="nz ja">artifactId</strong>&gt;maven-jar-plugin&lt;/<strong class="nz ja">artifactId</strong>&gt;<br/>            &lt;<strong class="nz ja">version</strong>&gt;3.0.2&lt;/<strong class="nz ja">version</strong>&gt;<br/>            &lt;<strong class="nz ja">configuration</strong>&gt;<br/>                &lt;<strong class="nz ja">archive</strong>&gt;<br/>                    &lt;<strong class="nz ja">manifest</strong>&gt;<br/>                        &lt;<strong class="nz ja">addClasspath</strong>&gt;true&lt;/<strong class="nz ja">addClasspath</strong>&gt;<br/>                        &lt;<strong class="nz ja">classpathPrefix</strong>&gt;lib/&lt;/<strong class="nz ja">classpathPrefix</strong>&gt;<br/>                        &lt;<strong class="nz ja">mainClass</strong>&gt;YOUR-CLASS-HERE&lt;/<strong class="nz ja">mainClass</strong>&gt;       <br/>                        &lt;<strong class="nz ja">useUniqueVersions</strong>&gt;false&lt;/<strong class="nz ja">useUniqueVersions</strong>&gt;<br/>                    &lt;/<strong class="nz ja">manifest</strong>&gt;<br/>                &lt;/<strong class="nz ja">archive</strong>&gt;<br/>            &lt;/<strong class="nz ja">configuration</strong>&gt;<br/>        &lt;/<strong class="nz ja">plugin</strong>&gt;<br/>        &lt;<strong class="nz ja">plugin</strong>&gt;<br/>            &lt;<strong class="nz ja">groupId</strong>&gt;org.apache.maven.plugins&lt;/<strong class="nz ja">groupId</strong>&gt;<br/>            &lt;<strong class="nz ja">artifactId</strong>&gt;maven-dependency-plugin&lt;/<strong class="nz ja">artifactId</strong>&gt;<br/>            &lt;<strong class="nz ja">version</strong>&gt;3.0.2&lt;/<strong class="nz ja">version</strong>&gt;<br/>            &lt;<strong class="nz ja">executions</strong>&gt;<br/>                &lt;<strong class="nz ja">execution</strong>&gt;<br/>                    &lt;<strong class="nz ja">id</strong>&gt;copy-dependencies&lt;/<strong class="nz ja">id</strong>&gt;<br/>                    &lt;<strong class="nz ja">phase</strong>&gt;package&lt;/<strong class="nz ja">phase</strong>&gt;<br/>                    &lt;<strong class="nz ja">goals</strong>&gt;<br/>                        &lt;<strong class="nz ja">goal</strong>&gt;copy-dependencies&lt;/<strong class="nz ja">goal</strong>&gt;<br/>                    &lt;/<strong class="nz ja">goals</strong>&gt;<br/>                    &lt;<strong class="nz ja">configuration</strong>&gt;<br/>                        &lt;<strong class="nz ja">outputDirectory</strong>&gt;${project.build.directory}/lib&lt;/<strong class="nz ja">outputDirectory</strong>&gt;<br/>                        &lt;<strong class="nz ja">overWriteReleases</strong>&gt;false&lt;/<strong class="nz ja">overWriteReleases</strong>&gt;<br/>                        &lt;<strong class="nz ja">overWriteSnapshots</strong>&gt;false&lt;/<strong class="nz ja">overWriteSnapshots</strong>&gt;<br/>                        &lt;<strong class="nz ja">overWriteIfNewer</strong>&gt;true&lt;/<strong class="nz ja">overWriteIfNewer</strong>&gt;<br/>                    &lt;/<strong class="nz ja">configuration</strong>&gt;<br/>                &lt;/<strong class="nz ja">execution</strong>&gt;<br/>            &lt;/<strong class="nz ja">executions</strong>&gt;<br/>        &lt;/<strong class="nz ja">plugin</strong>&gt;<br/>    &lt;/<strong class="nz ja">plugins</strong>&gt;<br/>&lt;/<strong class="nz ja">build</strong>&gt;<br/>.<br/>.<br/>.</span></pre><p id="88dc" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">本质上，它创建了一个执行我们在docker文件的入口点中指定的方式所需的清单文件，并将所需的库依赖项的副本安装到lib/目录中。</p><p id="9e40" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">第三，在<strong class="ll ja"> build-maven.sh </strong>中，我们执行Maven (mvn)来进行实际的Java编译，并将结果jar重命名为我们在下一步中选择的名称。</p><pre class="md me mf mg gt ny nz oa ob aw oc bi"><span id="a4e4" class="ko kp iq nz b gy od oe l of og">.<br/>.<br/>.<br/>mvn -B clean package -DskipTests</span><span id="87e7" class="ko kp iq nz b gy oh oe l of og">echo 'Install into the local Maven repository'<br/>mvn jar:jar install:install<br/><br/>NAME=`mvn help:evaluate -Dexpression=project.name | grep "^[^\[]"`<br/>VERSION=`mvn help:evaluate -Dexpression=project.version | grep "^[^\[]"`<br/><br/>mv  target/${NAME}-${VERSION}.jar <strong class="nz ja">target/entrypoint.jar</strong></span></pre><p id="210e" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">第四个是描述如何构建docker映像的<strong class="ll ja">docker文件</strong>，我们将使用一个公开可用的映像<strong class="ll ja"> openjdk:8-jre </strong>并将我们的JAR和库安装到。</p><pre class="md me mf mg gt ny nz oa ob aw oc bi"><span id="c6ad" class="ko kp iq nz b gy od oe l of og"><strong class="nz ja">FROM </strong>openjdk:8-jre<br/><br/><strong class="nz ja">ENTRYPOINT </strong>[<strong class="nz ja">"/usr/bin/java"</strong>, <strong class="nz ja">"-jar"</strong>, <strong class="nz ja">"/usr/local/javapkg/entrypoint.jar"</strong>]<br/><br/><strong class="nz ja">ADD </strong>target<strong class="nz ja">/</strong>lib <strong class="nz ja">/</strong>usr<strong class="nz ja">/</strong>local<strong class="nz ja">/</strong>javapkg<strong class="nz ja">/</strong>lib<strong class="nz ja">/<br/>ADD </strong>target<strong class="nz ja">/</strong>entrypoint.jar <strong class="nz ja">/</strong>usr<strong class="nz ja">/</strong>local<strong class="nz ja">/</strong>javapkg<strong class="nz ja">/</strong>entrypoint.jar</span></pre><p id="0a53" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">最后一个是将图像发送到AWS ECR的逻辑，即aws-ecr-push.sh脚本。我不会在这里包括整个长的东西，但它可以在上面的gitlab链接上找到。</p><pre class="md me mf mg gt ny nz oa ob aw oc bi"><span id="cc10" class="ko kp iq nz b gy od oe l of og">.<br/>.<br/>.<br/>#  Set up paths<br/>AWS="/usr/bin/aws --profile $aws_profile"<br/><br/>DOCKER_IMAGE=$1<br/><br/># Step 1 Get login  snippet from AWS<br/>DOCKER_LOGIN=$($AWS <strong class="nz ja">ecr get-login</strong> --no-include-email)<br/><br/># Disable output as we have passwords here<br/>set +x<br/><br/># Step 2 Execute docker login against AWS.<br/>eval $DOCKER_LOGIN<br/><br/># Step 3 Tag image with AWS Specifics<br/>docker <strong class="nz ja">tag $DOCKER_IMAGE $aws_reposito</strong>ry<br/><br/># Tag with Maven build release so we can track it<br/>docker tag $DOCKER_IMAGE $aws_repository:$JOB_NAME.$BUILD_NUMBER<br/><br/># Step 4 Push docker image to ECR<br/>docker <strong class="nz ja">push</strong> $aws_repository</span></pre><p id="befd" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">基本上，它执行以下操作:</p><ol class=""><li id="2451" class="mv mw iq ll b lm mo lp mp kx mx lb my lf mz mb oq nb nc nd bi translated">从AWS获取登录命令(aws ecr get-login命令)</li><li id="917f" class="mv mw iq ll b lm ne lp nf kx ng lb nh lf ni mb oq nb nc nd bi translated">然后它执行命令，类似于“docker log in-u AWS-p XXXXX<a class="ae mt" href="https://YOUR-AWS-ACCOUNT-ID.dkr.ecr.your-region.amazonaws.com'" rel="noopener ugc nofollow" target="_blank">https://YOUR-AWS-ACCOUNT-id . dkr . ECR . YOUR-region . Amazon AWS . com’</a></li><li id="1c47" class="mv mw iq ll b lm ne lp nf kx ng lb nh lf ni mb oq nb nc nd bi translated">然后，它用存储库的名称标记新创建的docker映像。</li><li id="313a" class="mv mw iq ll b lm ne lp nf kx ng lb nh lf ni mb oq nb nc nd bi translated">此外，我们用构建的名称和编号标记图像，以便能够更容易地跟踪它。您可以在此处添加其他标签，一些对您的环境有意义的标签。提交散列等。每个图像可能有多个标签。</li><li id="a0bd" class="mv mw iq ll b lm ne lp nf kx ng lb nh lf ni mb oq nb nc nd bi translated">然后，我们执行docker push命令，将图像实际发送到AWS ECR。</li></ol><p id="43b1" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">就是这样。如果需要，提交文件，然后前往Jenkins，使用参数进行构建:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi os"><img src="../Images/0f34f0313319664348e641237e7cda1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*0bXUIRMY1JkCB26yx3c_hA.png"/></div></figure><p id="4692" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">验证aws_repository和aws_profile参数是否正确，然后按“构建”。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ot"><img src="../Images/8e55eb027ff19062e46f940eeabb4f28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dT0FS116dofNB70HTyJ0Ow.png"/></div></div></figure><p id="d059" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">就是这样。现在，我们已经将图像上传到AWS。</p><h1 id="4c00" class="nj kp iq bd kq nk nl nm kt nn no np kw kf nq kg la ki nr kj le kl ns km li nt bi translated">AWS ECR</h1><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mu"><img src="../Images/13247fb6a47eabc24c27754602301bc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*otqBakNpUV2ffZqPIhANTQ.png"/></div></div></figure><p id="5fc8" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">前往AWS ECS / Repository部分，验证您的图像是否已被推过并被相应标记。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ou"><img src="../Images/f6d392ea5fbd16a6dc283b0718e014e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vCjNIEPmYirqMkcwZ_NrpA.png"/></div></div></figure><p id="f34b" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">当流程自动运行时，有时似乎会产生无穷无尽的素材，如工件和图像。因为我们在亚马逊是按字节付费的，所以他们引入了一个叫做生命周期政策的功能。使用此生命周期策略，您可以根据图像数量、图像年龄和标签定义清除哪些图像的简单规则。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ov"><img src="../Images/4fa5194ac9aebf572baca65b4c9823d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5uV2pKG57fcWTbY5WVp7Qw.png"/></div></div></figure><p id="b39a" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">因为我们在这篇文章中并没有很好的利用标签，所以除了“保留X张最新图片”之外，做其他事情就没有什么意义了。但是在更高级的设置中，给每张图片加上对你的项目有意义的东西，失败的测试等等，可能是个好主意。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mu"><img src="../Images/943cf9bda7a24800284319fae10c5fb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZT0uLcnbrTT_hsoXd6d0GA.png"/></div></div></figure><h1 id="5a4e" class="nj kp iq bd kq nk nl nm kt nn no np kw kf nq kg la ki nr kj le kl ns km li nt bi translated">AWS Fargate</h1><p id="5720" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr kx ls lt lu lb lv lw lx lf ly lz ma mb ij bi translated">亚马逊最近宣布了Fargate的可用性，这有可能在运行容器时去除一层管理。尽管这也带来了一些限制，但是您不再能够访问运行Docker守护进程的主机，因此对您的应用程序进行故障排除可能会有点棘手。</p><blockquote class="ow ox oy"><p id="e6d5" class="lj lk nu ll b lm mo ka lo lp mp kd lr oz mq lt lu pa mr lw lx pb ms lz ma mb ij bi translated">AWS Fargate是一种部署和管理容器的技术，无需管理任何底层基础设施。Fargate使您的应用程序易于扩展。您不再需要担心为您的容器应用程序提供足够的计算资源。你可以在几秒钟内发射几万或几万个集装箱。</p><p id="ac8a" class="lj lk nu ll b lm mo ka lo lp mp kd lr oz mq lt lu pa mr lw lx pb ms lz ma mb ij bi translated">使用Fargate，计费是以每秒的粒度进行的，您只需为您使用的内容付费。您需要为您的容器化应用程序请求的vCPU和内存资源量付费。vCPU和内存资源是从提取容器映像开始计算的，直到Amazon ECS任务终止，四舍五入到最近的秒。</p></blockquote><p id="d314" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">目前，Fargate仅在美国东部1区可用，但我猜它不会很快推广到你附近的地区。</p><p id="ebec" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">使用Fargate在AWS ECS上部署相当简单。您确实需要在容器运行之前设置一些边界。您需要指定一个集群来运行它，创建任务定义，并确保您拥有有效的VPC/子网结构来支持您的应用程序。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi pc"><img src="../Images/54f1379bf83f5485de99d06463d994db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zns5KaUGb67sX1dW6D8eRA.png"/></div></div></figure><p id="b13e" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">为了这篇文章的目的，我创建了一个基本的VPC和一个子网。(任何远程生产状态都需要比这更强大的设置。)我还创建了一个Internet网关，并设置了默认路由(0.0.0.0/0)来访问这个IG，以便我的应用程序可以访问Internet。</p><p id="be4f" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">下面是为这篇文章设置环境的脚本。如果你不熟悉Terraform，我真的可以推荐它来处理你的基础设施代码。</p><pre class="md me mf mg gt ny nz oa ob aw oc bi"><span id="8ffa" class="ko kp iq nz b gy od oe l of og">provider "aws" {<br/>  access_key = ""<br/>  secret_key = ""<br/>  region = "us-east-1"<br/>}<br/><br/>resource "aws_vpc" "vpc" {<br/>  cidr_block           = "172.22.0.0/16"<br/>  enable_dns_support   = true<br/>  enable_dns_hostnames = true<br/>}<br/><br/>resource "aws_subnet" "subnet_a" {<br/>  vpc_id            = "${aws_vpc.vpc.id}"<br/>  cidr_block        = "172.22.0.0/24"<br/>  availability_zone = "us-east-1a"<br/>}<br/><br/>resource "aws_internet_gateway" "ig" {<br/>  vpc_id = "${aws_vpc.vpc.id}"<br/>}<br/><br/>resource "aws_route_table" "public_routetable" {<br/>  vpc_id = "${aws_vpc.vpc.id}"<br/>  route {<br/>    cidr_block = "0.0.0.0/0"<br/>    gateway_id = "${aws_internet_gateway.ig.id}"<br/>  }<br/>}<br/><br/>resource "aws_route_table_association" "subnet_a" {<br/>  subnet_id      = "${aws_subnet.subnet_a.id}"<br/>  route_table_id = "${aws_route_table.public_routetable.id}"<br/>}</span></pre><p id="b103" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">VPC就绪后，转向弹性容器服务并创建一个集群(仅限网络)</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi pd"><img src="../Images/c5e1d0d5cd9924b30905cc0db97d2d66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a4MGxpPDo-sKhoV8FycGxQ.png"/></div></div></figure><p id="21e9" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">集群只需要一个名称作为参数。</p><p id="9742" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">接下来要做的事情是为docker映像创建任务定义。您可以在这里指定想要使用Fargate。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi pe"><img src="../Images/595481147a210c96a9809b1f422a0166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vk2m1hGcZD8xvmAqFvwu3g.png"/></div></div></figure><p id="e450" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">在下一步中，您将指定启动容器所需的细节。首先，您指定外层，即任务。默认的ecsTaskExecutionRole支持将容器输出记录到Cloudwatch以及访问ECR。</p><p id="2899" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">在这里，您还可以指定该任务处理的所有容器所需的总内存和vCPU单元数量。这是为AWS Fargate计算成本的基础。</p><blockquote class="ow ox oy"><p id="b198" class="lj lk nu ll b lm mo ka lo lp mp kd lr oz mq lt lu pa mr lw lx pb ms lz ma mb ij bi translated">定价基于任务所需的vCPU和内存资源。这两个维度可以独立配置。</p><p id="70a5" class="lj lk nu ll b lm mo ka lo lp mp kd lr oz mq lt lu pa mr lw lx pb ms lz ma mb ij bi translated">对于Amazon ECS，AWS Fargate定价是根据从您开始下载容器映像(docker pull)到Amazon ECS Task*终止所使用的vCPU和内存资源计算的，四舍五入到最近的秒。最低收费为1分钟。</p><p id="4356" class="lj lk nu ll b lm mo ka lo lp mp kd lr oz mq lt lu pa mr lw lx pb ms lz ma mb ij bi translated">每个vCPU的价格为每秒0.00001406美元(每小时0.0506美元)，每GB内存的价格为每秒0.00000353美元(每小时0.0127美元)。</p><p id="9708" class="lj lk nu ll b lm mo ka lo lp mp kd lr oz mq lt lu pa mr lw lx pb ms lz ma mb ij bi translated">*任务是作为应用程序一起运行的容器的集合。</p></blockquote><p id="f8fe" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">在任务定义中，您还可以指定可用于容器的持久存储或容器间共享存储的卷。</p><p id="dc43" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">最后一步是实际添加一个或多个容器定义，这是要执行的Docker映像的实际规范。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi pf"><img src="../Images/ce98243a8646e5a71e1722d82566ed45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ohbtQvkghSyy3R75i83d7w.png"/></div></div></figure><p id="77a7" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">一旦任务定义完成，您就可以把容器拿出来兜一圈了。转到Amazon ECS / Clusters并选择Task选项卡。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi pf"><img src="../Images/0ae54064f2503cf1e26e192bae237ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KA3sEbHeUjQHRySg4vO2LA.png"/></div></div></figure><p id="e0aa" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">选择运行新任务，然后选择新创建的任务定义和集群。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi pg"><img src="../Images/b6df786934f3a283eb59b5e279c71acf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OjaDxsv3gdrq9sokp1NDfg.png"/></div></div></figure><p id="23eb" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">提供您的VPC，子网和安全组，并按下运行任务，瞧！您的docker映像应该正在启动。默认情况下，日志会发送到CloudWatch。</p><p id="9f39" class="pw-post-body-paragraph lj lk iq ll b lm mo ka lo lp mp kd lr kx mq lt lu lb mr lw lx lf ms lz ma mb ij bi translated">运行任务只启动任务中指定的容器，并运行它们，直到它们完成或由于某种原因终止。如果您希望保持容器运行，并且可能随着工作负载的增加而扩展，那么您需要使用ECS服务，但这是另一个故事了。</p></div></div>    
</body>
</html>