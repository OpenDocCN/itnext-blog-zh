<html>
<head>
<title>GraphQL (microservices) architecture by Apollo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">阿波罗的GraphQL(微服务)架构</h1>
<blockquote>原文：<a href="https://itnext.io/graphql-microservices-architecture-by-apollo-8b6eb557c5e2?source=collection_archive---------3-----------------------#2020-01-15">https://itnext.io/graphql-microservices-architecture-by-apollo-8b6eb557c5e2?source=collection_archive---------3-----------------------#2020-01-15</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj jr"><img src="../Images/2b491bd091e8e095fd515c3c07216b30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*toEWBcbiUAFslVsZUNyACA.jpeg"/></div></div></figure><h1 id="650b" class="kc kd iu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">为什么使用GraphQL而不使用REST</h1><p id="6595" class="pw-post-body-paragraph la lb iu lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">如果从客户端(前端)的角度来看，REST API在获取数据时会面临一些挑战。</p><h1 id="be7e" class="kc kd iu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">休息挑战</h1><p id="0e2b" class="pw-post-body-paragraph la lb iu lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">多年来，我们一直在使用REST API，因为它们比从服务器获取数据并与HTML同时呈现更方便，这导致了不断地重新加载应用程序的页面。</p><p id="ac69" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">但是REST有很多优点，也有一些缺点。</p><ol class=""><li id="811b" class="md me iu lc b ld ly lh lz ll mf lp mg lt mh lx mi mj mk ml bi translated">执行REST调用会给客户端提供比所需更多的数据，因此需要下载更多的数据</li><li id="139b" class="md me iu lc b ld mm lh mn ll mo lp mp lt mq lx mi mj mk ml bi translated">REST端点的数据结构在前端应用程序中是不可预测的</li><li id="cf49" class="md me iu lc b ld mm lh mn ll mo lp mp lt mq lx mi mj mk ml bi translated">在向用户显示屏幕之前，调用多个端点来合并数据</li></ol></div><div class="ab cl mr ms hy mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="in io ip iq ir"><h1 id="6586" class="kc kd iu bd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz bi translated">GraphQL来拯救</h1><blockquote class="nd ne nf"><p id="37e0" class="la lb ng lc b ld ly lf lg lh lz lj lk nh ma ln lo ni mb lr ls nj mc lv lw lx in bi translated"><em class="iu"> GraphQL是一种用于API的查询语言，也是一种服务器端运行时，通过使用您为数据定义的类型系统来执行查询</em></p></blockquote><p id="8b7e" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">在我们严重依赖REST API的时候，我们学到了很多可以做得更好的东西。</p><p id="ae8c" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">使用GraphQL，我们在客户机中描述我们想要哪些数据，而不仅仅是询问所有的数据。</p><p id="a02e" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated"><strong class="lc iv"> GraphQL查询</strong></p><pre class="nk nl nm nn gu no np nq nr aw ns bi"><span id="339f" class="nt kd iu np b gz nu nv l nw nx">{<br/>      me {<br/>        name<br/>      }<br/>    }</span></pre><p id="e15f" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated"><strong class="lc iv"> JSON结果</strong></p><pre class="nk nl nm nn gu no np nq nr aw ns bi"><span id="b63d" class="nt kd iu np b gz nu nv l nw nx">{<br/>      "me": {<br/>        "name": "Luke Skywalker"<br/>      }<br/>    }</span></pre><p id="6b65" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">在后端或API网关中，我们已经定义了将形成我们的模式的类型。这些模式可以在前端使用，使数据高度可预测。</p><p id="89a6" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated"><strong class="lc iv">类型</strong></p><pre class="nk nl nm nn gu no np nq nr aw ns bi"><span id="40f1" class="nt kd iu np b gz nu nv l nw nx">type Query {<br/>      me: User<br/>    }</span><span id="1006" class="nt kd iu np b gz ny nv l nw nx">    type User {<br/>      id: ID<br/>      name: String<br/>    }</span></pre><p id="8fc0" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated"><strong class="lc iv">每个字段类型的功能</strong></p><pre class="nk nl nm nn gu no np nq nr aw ns bi"><span id="388a" class="nt kd iu np b gz nu nv l nw nx">function Query_me(request) {<br/>      return request.auth.user;<br/>    }</span><span id="e9f5" class="nt kd iu np b gz ny nv l nw nx">    function User_name(user) {<br/>      return user.getName();<br/>    }</span></pre><h1 id="c2b6" class="kc kd iu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">GraphQL解决了哪些问题</h1><ol class=""><li id="0ea3" class="md me iu lc b ld le lh li ll nz lp oa lt ob lx mi mj mk ml bi translated">只将数据返回给客户机，这是客户机所要求的</li><li id="1417" class="md me iu lc b ld mm lh mn ll mo lp mp lt mq lx mi mj mk ml bi translated">只有一个从多个数据源获取数据的请求。</li><li id="9cd1" class="md me iu lc b ld mm lh mn ll mo lp mp lt mq lx mi mj mk ml bi translated">不再需要检查您需要从哪个端点获取数据。</li><li id="6ed3" class="md me iu lc b ld mm lh mn ll mo lp mp lt mq lx mi mj mk ml bi translated">需要下载的数据更少</li><li id="21c9" class="md me iu lc b ld mm lh mn ll mo lp mp lt mq lx mi mj mk ml bi translated">架构在前端应用程序中使用，用于为前端生成数据类型(Typescript)</li><li id="e01c" class="md me iu lc b ld mm lh mn ll mo lp mp lt mq lx mi mj mk ml bi translated">数据结构变得更加可预测</li></ol><p id="38de" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">这是我们可以用GraphQL解决的一些挑战🙌</p></div><div class="ab cl mr ms hy mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="in io ip iq ir"><h1 id="f198" class="kc kd iu bd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz bi translated">Apollo默认的对话方式GraphQL</h1><p id="42a3" class="pw-post-body-paragraph la lb iu lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">您可以在没有库的情况下使用GraphQL，但大多数组织将使用库来完成繁重的工作，并使开发人员更容易使用GraphQL</p><p id="f4b5" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">其中最大的或者可能是最大的是<a class="ae oc" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank">阿波罗</a>。Apollo有一个<a class="ae oc" href="https://www.apollographql.com/docs/react/#community-integrations" rel="noopener ugc nofollow" target="_blank">客户端库</a>用于许多JavaScript (TypeScript)库和框架。接下来是Apollo服务器，这是一个在NodeJS中构建API(网关)的工具。接下来，他们构建了Apollo Federation来更容易地处理多个团队的单个图。</p><p id="c61c" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">如果你在谷歌上搜索几次，你很快就会发现Apollo几乎是GraphQL的默认使用方式，所以这就是我选择深入研究它的原因。</p><h1 id="8534" class="kc kd iu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">阿波罗客户端</h1><p id="85a4" class="pw-post-body-paragraph la lb iu lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">Apollo客户端是一个帮助你在前端使用GraphQL的工具。它有助于将查询作为UI组件的一部分来编写，并允许您以声明性的方式编写查询。</p><p id="9835" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">除了查询之外，它还有助于状态管理，这在大型应用程序中非常有用。</p><p id="15ea" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">Apollo客户端集成了多个JavaScript库和框架。React，React Native，Vue，Angular和Web组件。对于iOS和Android，也有可能使用Apollo客户端。</p><p id="2ece" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">Apollo客户机可以与任何GraphQL服务器一起工作，因此它不必是Apollo服务器，它只需理解GraphQL。</p><h1 id="8864" class="kc kd iu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">阿波罗服务器(API网关)</h1><figure class="nk nl nm nn gu jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj od"><img src="../Images/cb73d4db8efe2915b73e351e5f465723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l2UZCuUv0v-KIIBp.png"/></div></div></figure><p id="b150" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">要让一个端点理解您的GraphQL查询，您需要一个API网关或一个可以处理GraphQL的服务。</p><p id="d6cd" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">Apollo附带了Apollo服务器包，供您自己构建。您可以使用它作为您的主要API来直接与您的数据库对话，或者它可以作为API网关。</p><p id="00b9" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">API网关是我觉得有趣的地方。如果你有一些基于REST的(微)服务，你可以让它们保持原样。只需启动Apollo服务器，让它与您所有的REST服务对话。</p><p id="d1ea" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">使用Apollo服务器作为网关，您可以组合多个数据源。服务器在返回请求的数据之前处理所有不同的请求。当所有数据都被解析后，Apollo服务器将数据发送回客户机。</p><p id="7c98" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">通过这个API网关，任何服务都不需要理解GraphQL。积极的一面是，当将来有比GraphQL更好的技术时，我们只需交换API网关和Apollo客户端，并构建一个新的网关。</p><p id="38a3" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">甚至阿波罗也在推荐使用<a class="ae oc" href="https://principledgraphql.com/operations#10-separate-the-graphql-layer-from-the-service-layer" rel="noopener ugc nofollow" target="_blank">阿波罗服务器作为网关</a>。</p></div><div class="ab cl mr ms hy mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="in io ip iq ir"><h1 id="d1ec" class="kc kd iu bd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz bi translated">GraphQL本地微服务</h1><p id="9a46" class="pw-post-body-paragraph la lb iu lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">根据组织和架构的需要，创建GraphQL(微)服务也是非常合适的。</p><p id="00d5" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">根据您使用的语言，有几个库可以帮助您构建它们。</p><ul class=""><li id="2c9c" class="md me iu lc b ld ly lh lz ll mf lp mg lt mh lx oe mj mk ml bi translated">NodeJS: <a class="ae oc" href="https://www.apollographql.com/docs/apollo-server/" rel="noopener ugc nofollow" target="_blank"> Apollo Server </a>，<a class="ae oc" href="https://graphql.org/graphql-js/" rel="noopener ugc nofollow" target="_blank"> GraphQL.js </a>，<a class="ae oc" href="https://graphql.org/graphql-js/running-an-express-graphql-server/" rel="noopener ugc nofollow" target="_blank"> express-graphql </a></li><li id="e137" class="md me iu lc b ld mm lh mn ll mo lp mp lt mq lx oe mj mk ml bi translated">Python: <a class="ae oc" href="https://graphene-python.org/" rel="noopener ugc nofollow" target="_blank">石墨烯Python </a></li><li id="ca7b" class="md me iu lc b ld mm lh mn ll mo lp mp lt mq lx oe mj mk ml bi translated">PHP: <a class="ae oc" href="https://github.com/webonyx/graphql-php" rel="noopener ugc nofollow" target="_blank"> GraphQL-php </a>，<a class="ae oc" href="https://github.com/ivome/graphql-relay-php" rel="noopener ugc nofollow" target="_blank"> GraphQL-relay-php </a>，<a class="ae oc" href="https://github.com/railt/railt" rel="noopener ugc nofollow" target="_blank"> Railt </a>，<a class="ae oc" href="https://github.com/nuwave/lighthouse" rel="noopener ugc nofollow" target="_blank"> Lighthouse </a>，<a class="ae oc" href="https://github.com/overblog/GraphQLBundle" rel="noopener ugc nofollow" target="_blank"> GraphQLBundle (Symfony) </a></li><li id="010b" class="md me iu lc b ld mm lh mn ll mo lp mp lt mq lx oe mj mk ml bi translated">Java: <a class="ae oc" href="https://github.com/graphql-java/graphql-java" rel="noopener ugc nofollow" target="_blank"> GraphQL-java </a></li><li id="23a8" class="md me iu lc b ld mm lh mn ll mo lp mp lt mq lx oe mj mk ml bi translated">Go: <a class="ae oc" href="https://github.com/graphql-go/graphql" rel="noopener ugc nofollow" target="_blank"> Graphql-go </a></li><li id="14c6" class="md me iu lc b ld mm lh mn ll mo lp mp lt mq lx oe mj mk ml bi translated">。Net: <a class="ae oc" href="https://github.com/graphql-dotnet/graphql-dotnet" rel="noopener ugc nofollow" target="_blank"> GraphQL-dotnet </a>，<a class="ae oc" href="https://github.com/ckimes89/graphql-net" rel="noopener ugc nofollow" target="_blank"> GraphQL-net </a>，<a class="ae oc" href="https://hotchocolate.io/" rel="noopener ugc nofollow" target="_blank">热巧克力</a></li><li id="68a5" class="md me iu lc b ld mm lh mn ll mo lp mp lt mq lx oe mj mk ml bi translated">。Net Core: <a class="ae oc" href="https://github.com/lukemurray/EntityGraphQL" rel="noopener ugc nofollow" target="_blank">实体GraphQL </a>，<a class="ae oc" href="https://github.com/lukemurray/DotNetGraphQLQueryGen" rel="noopener ugc nofollow" target="_blank"> DotNetGraphQLQueryGen </a>，<a class="ae oc" href="https://hotchocolate.io/" rel="noopener ugc nofollow" target="_blank">热巧克力</a></li><li id="e755" class="md me iu lc b ld mm lh mn ll mo lp mp lt mq lx oe mj mk ml bi translated">科特林:<a class="ae oc" href="https://expediagroup.github.io/graphql-kotlin/docs/getting-started.html" rel="noopener ugc nofollow" target="_blank"> GraphQL科特林</a></li><li id="3406" class="md me iu lc b ld mm lh mn ll mo lp mp lt mq lx oe mj mk ml bi translated">斯威夫特:<a class="ae oc" href="https://github.com/GraphQLSwift/Graphiti" rel="noopener ugc nofollow" target="_blank">图形</a></li><li id="fb4d" class="md me iu lc b ld mm lh mn ll mo lp mp lt mq lx oe mj mk ml bi translated">Ruby: <a class="ae oc" href="https://github.com/rmosolgo/graphql-ruby" rel="noopener ugc nofollow" target="_blank"> GraphQL-ruby </a></li></ul><p id="9cf3" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">你可以在GrapQL.org找到一个更大的列表。</p><h1 id="df76" class="kc kd iu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">微服务世界中的GraphQL后端</h1><p id="73d5" class="pw-post-body-paragraph la lb iu lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">出于多种原因，越来越多的公司选择微服务架构用于其应用。它在可伸缩性方面非常有效，但也带来了一些挑战。</p><p id="82a9" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">但是如果要在微服务架构中使用GraphQL呢？Apollo为“<a class="ae oc" href="https://www.apollographql.com/docs/apollo-server/federation/introduction/" rel="noopener ugc nofollow" target="_blank"> Apollo Federation </a>”提供了一个解决方案，它可以与比JavaScript更多的语言一起工作👍</p><h2 id="1d77" class="nt kd iu bd ke of og dn ki oh oi dp km ll oj ok kq lp ol om ku lt on oo ky op bi translated">GraphQL和微服务面临的挑战</h2><p id="2a17" class="pw-post-body-paragraph la lb iu lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">有了GraphQL，您只需要让<a class="ae oc" href="https://principledgraphql.com/integrity#1-one-graph" rel="noopener ugc nofollow" target="_blank"> 1个图形</a>有一个端点，客户端可以调用该端点来获取数据。但是与多人甚至多个团队一起工作，在同一个Graph存储库中工作可能会非常困难。我预见到大量的合并冲突将会遍布各地。</p><h2 id="3f53" class="nt kd iu bd ke of og dn ki oh oi dp km ll oj ok kq lp ol om ku lt on oo ky op bi translated">如何让一个图表分布在多个团队中</h2><p id="c17b" class="pw-post-body-paragraph la lb iu lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">好吧，我们可以将我们的图划分到多个域中，这些域最终将合并到一个图中，即所谓的<a class="ae oc" href="https://principledgraphql.com/integrity#2-federated-implementation" rel="noopener ugc nofollow" target="_blank">联邦实现</a>。</p><p id="f939" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">阿波罗联盟提出了这个解决方案。</p><h2 id="8876" class="nt kd iu bd ke of og dn ki oh oi dp km ll oj ok kq lp ol om ku lt on oo ky op bi translated">阿波罗联邦核心概念</h2><p id="7d03" class="pw-post-body-paragraph la lb iu lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">例如，我们想象中的应用程序有两个微服务。</p><ul class=""><li id="aa28" class="md me iu lc b ld ly lh lz ll mf lp mg lt mh lx oe mj mk ml bi translated">帐户微服务</li><li id="0a44" class="md me iu lc b ld mm lh mn ll mo lp mp lt mq lx oe mj mk ml bi translated">查看微服务</li></ul><p id="4606" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">有了这些服务，我们有2种类型的数据<code class="fe oq or os np b">User</code>和<code class="fe oq or os np b">Review</code>。但是他们需要共享部分数据，即使它们是两个独立的服务。</p><h2 id="5c41" class="nt kd iu bd ke of og dn ki oh oi dp km ll oj ok kq lp ol om ku lt on oo ky op bi translated">类型引用</h2><p id="f4c2" class="pw-post-body-paragraph la lb iu lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">有了Apollo federation，我们可以引用不同模式中的类型。</p><pre class="nk nl nm nn gu no np nq nr aw ns bi"><span id="831c" class="nt kd iu np b gz nu nv l nw nx">type User @key(fields: "id") {<br/>   id: ID!<br/>   username: String<br/>}</span></pre><p id="4167" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">通过<code class="fe oq or os np b">@key</code>指令，我们将<code class="fe oq or os np b">User</code>类型转换为实体。这表明您可以在其他模式中共享这个实体。</p><p id="a22d" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">在评论模式中，我们希望通过参考<code class="fe oq or os np b">User</code>实体来显示评论的作者是谁。</p><pre class="nk nl nm nn gu no np nq nr aw ns bi"><span id="d335" class="nt kd iu np b gz nu nv l nw nx">type Review {<br/>   author: User<br/>}</span></pre><p id="8130" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">如果客户想得到评论，GraphQL查询将如下所示。</p><pre class="nk nl nm nn gu no np nq nr aw ns bi"><span id="80ae" class="nt kd iu np b gz nu nv l nw nx">query GetReviews {<br/>  reviews {<br/>    author {<br/>      username<br/>    }<br/>  }<br/>}</span></pre><p id="8f2a" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">有了类型引用，我们可以将所有的模式彼此分开，但仍然在我们需要的地方共享它们。</p><h2 id="25f6" class="nt kd iu bd ke of og dn ki oh oi dp km ll oj ok kq lp ol om ku lt on oo ky op bi translated">类型扩展</h2><p id="65a2" class="pw-post-body-paragraph la lb iu lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">如果您想扩展在不同服务中定义的类型以在其中添加新字段，那么您可以通过<code class="fe oq or os np b">extend</code>来完成。</p><p id="7719" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">例如，我们想将accounts服务中定义的<code class="fe oq or os np b">User</code>扩展到review services，并添加新的字段，我们可以通过这样定义来实现。</p><pre class="nk nl nm nn gu no np nq nr aw ns bi"><span id="6ed0" class="nt kd iu np b gz nu nv l nw nx">extend type User @key(fields: "id") {<br/>   id: ID! @external<br/>   reviews: [Review]<br/>}</span></pre><p id="5b99" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">通过这种方式，客户可以通过这样的查询请求用户的评论。</p><pre class="nk nl nm nn gu no np nq nr aw ns bi"><span id="f3ca" class="nt kd iu np b gz nu nv l nw nx">query GetReviewsByUser($userId: String!) {<br/>  user(id: $userId) {<br/>    reviews(first: 10) {<br/>        edges {<br/>        node {<br/>          id<br/>          text<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre></div><div class="ab cl mr ms hy mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="in io ip iq ir"><h1 id="476f" class="kc kd iu bd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz bi translated">阿波罗联邦建筑公司</h1><figure class="nk nl nm nn gu jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj od"><img src="../Images/85852125ddf4ac0aad179f51059c0647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bDKGeD6wqSQeQ5vo.png"/></div></div></figure><p id="6b7e" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">为了实现阿波罗联盟，我们需要两个组件。</p><ul class=""><li id="743a" class="md me iu lc b ld ly lh lz ll mf lp mg lt mh lx oe mj mk ml bi translated">一个<strong class="lc iv">网关</strong>来展示完整的图形并执行联邦查询</li><li id="a6ff" class="md me iu lc b ld mm lh mn ll mo lp mp lt mq lx oe mj mk ml bi translated"><strong class="lc iv">联邦服务</strong>，它们是独立的GraphQL APIs，可以通过扩展类型和创建引用来连接它们的数据。</li></ul><p id="3e8c" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">使用阿波罗服务器作为联盟将很快发生。只需在您的Apollo Server应用程序中包含<code class="fe oq or os np b">@apollo/gateway</code>，并定义一个所有联合服务所在的服务列表。</p><p id="560b" class="pw-post-body-paragraph la lb iu lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx in bi translated">最棒的是，这为多个团队开发图形提供了高度的灵活性，但是GraphQL客户端将只看到一个模式。</p></div><div class="ab cl mr ms hy mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="in io ip iq ir"><h1 id="d619" class="kc kd iu bd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz bi translated">谢谢</h1><p id="34e0" class="pw-post-body-paragraph la lb iu lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">谢谢你一直读到这里🙌。我希望它给了你一些通过<a class="ot ou ep" href="https://medium.com/u/9360eb7d79eb?source=post_page-----8b6eb557c5e2--------------------------------" rel="noopener" target="_blank"> Apollo </a>使用GraphQL的新知识。</p></div><div class="ab cl mr ms hy mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="in io ip iq ir"><h1 id="6d2f" class="kc kd iu bd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz bi translated">阅读更多</h1><div class="ov ow gq gs ox oy"><a href="https://betterprogramming.pub/7-web-development-guidelines-to-speed-up-page-loading-e8f0e13a53b" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fp"><div class="pa ab pb cl cj pc"><h2 class="bd iv gz z fq pd fs ft pe fv fx it bi translated">加速页面加载的7个Web开发指南</h2><div class="pf l"><h3 class="bd b gz z fq pd fs ft pe fv fx dk translated">为了你的访问者的爱，改善用户体验</h3></div><div class="pg l"><p class="bd b dl z fq pd fs ft pe fv fx dk translated">better编程. pub</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm ka oy"/></div></div></a></div><div class="ov ow gq gs ox oy"><a href="https://medium.com/dev-together/use-cli-tools-from-mac-linux-on-windows-subsystem-for-linux-37d16f012489" rel="noopener follow" target="_blank"><div class="oz ab fp"><div class="pa ab pb cl cj pc"><h2 class="bd iv gz z fq pd fs ft pe fv fx it bi translated">在适用于Linux的Windows子系统上使用Mac/Linux中的CLI工具</h2><div class="pf l"><h3 class="bd b gz z fq pd fs ft pe fv fx dk translated">WSL2如此强大，使得从Mac到wsl 2的转换轻而易举。</h3></div><div class="pg l"><p class="bd b dl z fq pd fs ft pe fv fx dk translated">medium.com</p></div></div><div class="ph l"><div class="pn l pj pk pl ph pm ka oy"/></div></div></a></div><div class="ov ow gq gs ox oy"><a href="https://medium.com/dev-together/3-todos-before-applying-for-a-junior-developer-job-26fc0d8ba2b9" rel="noopener follow" target="_blank"><div class="oz ab fp"><div class="pa ab pb cl cj pc"><h2 class="bd iv gz z fq pd fs ft pe fv fx it bi translated">申请初级开发人员工作前的3件事</h2><div class="pf l"><h3 class="bd b gz z fq pd fs ft pe fv fx dk translated">我见过很多初级开发人员的求职申请。大多数申请都是出于好意…</h3></div><div class="pg l"><p class="bd b dl z fq pd fs ft pe fv fx dk translated">medium.com</p></div></div><div class="ph l"><div class="po l pj pk pl ph pm ka oy"/></div></div></a></div><div class="ov ow gq gs ox oy"><a href="https://medium.com/better-programming/why-tutorials-wont-make-you-a-professional-developer-271108c74ddb" rel="noopener follow" target="_blank"><div class="oz ab fp"><div class="pa ab pb cl cj pc"><h2 class="bd iv gz z fq pd fs ft pe fv fx it bi translated">为什么教程不能让你成为专业的开发者</h2><div class="pf l"><h3 class="bd b gz z fq pd fs ft pe fv fx dk translated">精通不仅仅来自于做教程。尝试，失败，学习，重复！</h3></div><div class="pg l"><p class="bd b dl z fq pd fs ft pe fv fx dk translated">medium.com</p></div></div><div class="ph l"><div class="pp l pj pk pl ph pm ka oy"/></div></div></a></div><div class="ov ow gq gs ox oy"><a href="https://medium.com/better-programming/tips-to-create-developer-tutorials-62cb3a25b8e5" rel="noopener follow" target="_blank"><div class="oz ab fp"><div class="pa ab pb cl cj pc"><h2 class="bd iv gz z fq pd fs ft pe fv fx it bi translated">创建开发人员教程的技巧</h2><div class="pf l"><h3 class="bd b gz z fq pd fs ft pe fv fx dk translated">想写更多的教程，但你不知道从哪里开始？从这里开始</h3></div><div class="pg l"><p class="bd b dl z fq pd fs ft pe fv fx dk translated">medium.com</p></div></div><div class="ph l"><div class="pq l pj pk pl ph pm ka oy"/></div></div></a></div></div></div>    
</body>
</html>