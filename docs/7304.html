<html>
<head>
<title>How to Use Machine Learning to Build a Pokémon Search Engine — pt. 2 — let’s code!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何利用机器学习建立一个神奇宝贝搜索引擎— pt。2 —我们来编码吧！</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-use-machine-learning-to-build-a-pok%C3%A9mon-search-engine-pt-2-lets-code-f44cd22c912f?source=collection_archive---------2-----------------------#2022-08-16">https://itnext.io/how-to-use-machine-learning-to-build-a-pok%C3%A9mon-search-engine-pt-2-lets-code-f44cd22c912f?source=collection_archive---------2-----------------------#2022-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="f8e3" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">机器学习/项目</h2><div class=""/><div class=""><h2 id="353f" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">神奇宝贝、机器学习、Python:胜利三重奏</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/c78f4b0c217f394bcb5379e136fe9946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hO5hPUFZeoovpKCB"/></div></div></figure><p id="4ece" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在我的上一篇文章中，我介绍了我们在<a class="ae lw" href="https://datamasters.it/" rel="noopener ugc nofollow" target="_blank"> Datamasters </a>为Pycon 22准备的研讨会的算法部分。TLDR:提出了一个使用机器学习KNN算法的神奇宝贝搜索引擎。你可以在这里阅读文章<a class="ae lw" href="https://medium.com/itnext/how-to-use-machine-learning-to-build-a-pok%C3%A9mon-search-engine-pt-1-2db1f8551426" rel="noopener"/>。让我们快速回顾一下:</p><ol class=""><li id="4657" class="lx ly iq lc b ld le lg lh lj lz ln ma lr mb lv mc md me mf bi translated">从用户那里拿6个数字，然后把它们分配给一个“假的”神奇宝贝</li><li id="f37a" class="lx ly iq lc b ld mg lg mh lj mi ln mj lr mk lv mc md me mf bi translated">计算假神奇宝贝和存储在<a class="ae lw" href="https://www.kaggle.com/datasets/abcsds/pokemon" rel="noopener ugc nofollow" target="_blank">的每个神奇宝贝之间的欧几里德距离，你可以在Kaggle上轻松找到许多数据集</a></li><li id="6357" class="lx ly iq lc b ld mg lg mh lj mi ln mj lr mk lv mc md me mf bi translated">在一个新的数据结构中存储一个长度为N(数据集中神奇宝贝的数量)的列表，其中每个元素存储2个数字:<br/>数据集中神奇宝贝的索引<br/>第I个神奇宝贝和我们的假神奇宝贝之间的欧几里德距离</li><li id="05e6" class="lx ly iq lc b ld mg lg mh lj mi ln mj lr mk lv mc md me mf bi translated">我们现在有了一个长度等于数据集中神奇宝贝数量的数据结构；每个元素包含一个唯一的索引和一个表示距离的数字；我们希望按照每个元素的“距离”值对这个结构进行排序</li><li id="8f45" class="lx ly iq lc b ld mg lg mh lj mi ln mj lr mk lv mc md me mf bi translated">在输出中只显示这个排序的数据结构的前K个元素(例如，如果K = 3，我们只取最接近的3个神奇宝贝，因此最类似于用户插入的神奇宝贝)</li></ol><p id="4315" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">就是这样。这个想法并不难。如果你遗漏了什么，再读一遍这篇文章。</p><p id="cb93" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在本文中，我们将使用Python实现我们的搜索引擎。作为名为“初学者日”的研讨会的一部分，我们决定不使用任何第三方库，甚至不使用Python臭名昭著的超级常用和超级酷的机器学习库(pandas，matplotlib，numpy等)。我们从零开始构建这个搜索引擎<strong class="lc ja"/>。我们唯一使用的包是CSV，它是Python标准库的一部分；这意味着你不需要安装任何东西就可以使用这个包。一旦你安装了Python，你就可以使用这个包了。让我们从导入这个包并使用它来读取数据集开始，数据集(不出所料)是一个CSV文件。注意:数据集的第一行包含列名，而不是实际的神奇宝贝数据:</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="be66" class="mq mr iq mm b gy ms mt l mu mv">import csv</span><span id="e2dc" class="mq mr iq mm b gy mw mt l mu mv">columns <strong class="mm ja">=</strong> []<br/>pokemon_dataset <strong class="mm ja">=</strong> []<br/><strong class="mm ja">with</strong> open('pokemon.csv') <strong class="mm ja">as</strong> file:<br/>    print(type(file))<br/>    reader <strong class="mm ja">=</strong> csv<strong class="mm ja">.</strong>reader(file)<br/>    columns <strong class="mm ja">=</strong> next(reader)<br/>    <strong class="mm ja">for</strong> row <strong class="mm ja">in</strong> reader:<br/>        pokemon_dataset<strong class="mm ja">.</strong>append(row)</span></pre><p id="7a78" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们在这几行代码中所做的就是读取CSV文件的内容，并将读取的值存储在两个列表中。第一个将包含列名(#、name、type 1、type 2等)，而后者将保存实际的数据集。请注意，<code class="fe mx my mz mm b">columns</code>是一个一维列表，而<code class="fe mx my mz mm b">pokemon_dataset</code>是一个<strong class="lc ja">二维列表</strong>，也称为<strong class="lc ja">矩阵</strong>或者如果你喜欢<strong class="lc ja">表</strong>:访问一个神奇宝贝我们将使用单个索引，而如果我们想要访问一个神奇宝贝的属性，我们将使用2个索引:</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="0231" class="mq mr iq mm b gy ms mt l mu mv">print(pokemon_dataset[0]) # Prints the row with Bulbasaur data, the first Pokémon of the dataset<br/>print(pokemon_dataset[0][1]) # Prints the name(index 1) of the Pokémon with index 0 (always Bulbasaur)</span></pre><p id="aa36" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">让我们通过打印第一个神奇宝贝妙蛙种子的所有可用字段、字段类型和值来探索数据集:</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="1546" class="mq mr iq mm b gy ms mt l mu mv"><strong class="mm ja">for</strong> k, v <strong class="mm ja">in</strong> zip(columns, pokemon_dataset[0]):<br/>    print(f"{k:10} -&gt; {v:15} ({type(v)})")</span><span id="7cd4" class="mq mr iq mm b gy mw mt l mu mv">#          -&gt; 1               (&lt;class 'str'&gt;)<br/>Name       -&gt; Bulbasaur       (&lt;class 'str'&gt;)<br/>Type 1     -&gt; Grass           (&lt;class 'str'&gt;)<br/>Type 2     -&gt; Poison          (&lt;class 'str'&gt;)<br/>Total      -&gt; 318             (&lt;class 'str'&gt;)<br/>HP         -&gt; 45              (&lt;class 'str'&gt;)<br/>Attack     -&gt; 49              (&lt;class 'str'&gt;)<br/>Defense    -&gt; 49              (&lt;class 'str'&gt;)<br/>Sp. Atk    -&gt; 65              (&lt;class 'str'&gt;)<br/>Sp. Def    -&gt; 65              (&lt;class 'str'&gt;)<br/>Speed      -&gt; 45              (&lt;class 'str'&gt;)<br/>Generation -&gt; 1               (&lt;class 'str'&gt;)<br/>Legendary  -&gt; False           (&lt;class 'str'&gt;)</span></pre><p id="441d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">注意所有字段都是<strong class="lc ja">字符串(类型</strong> <code class="fe mx my mz mm b"><strong class="lc ja">str</strong></code> <strong class="lc ja">)，甚至是包含数值的字段</strong>(分数列、代、总数)。当然，将欧几里德距离应用于字符串是不可能的，除了完全是无意义的；我们需要做的是将我们感兴趣的数值存储在另一个数据结构中，但是使用<code class="fe mx my mz mm b">float</code>类型:</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="38f4" class="mq mr iq mm b gy ms mt l mu mv">num_indexes <strong class="mm ja">=</strong> [5, 6, 7, 8, 9, 10]</span><span id="65c8" class="mq mr iq mm b gy mw mt l mu mv">numerical_data <strong class="mm ja">=</strong> []<br/><strong class="mm ja">for</strong> i <strong class="mm ja">in</strong> range(len(pokemon_dataset)):<br/>    row <strong class="mm ja">=</strong> pokemon_dataset[i]<br/>    num_row <strong class="mm ja">=</strong> []<br/>    <strong class="mm ja">for</strong> col <strong class="mm ja">in</strong> num_indexes:<br/>        num_row<strong class="mm ja">.</strong>append(float(row[col]))</span><span id="cc85" class="mq mr iq mm b gy mw mt l mu mv">    numerical_data<strong class="mm ja">.</strong>append(num_row)</span><span id="76da" class="mq mr iq mm b gy mw mt l mu mv"><strong class="mm ja">for</strong> k, v <strong class="mm ja">in</strong> zip(columns[5:11], numerical_data[0]):<br/>    print(f"{k:10} -&gt; {v:5} ({type(v)})")</span><span id="ea5e" class="mq mr iq mm b gy mw mt l mu mv"># the last for loop would print:<br/>HP         -&gt;  45.0 (&lt;class 'float'&gt;)<br/>Attack     -&gt;  49.0 (&lt;class 'float'&gt;)<br/>Defense    -&gt;  49.0 (&lt;class 'float'&gt;)<br/>Sp. Atk    -&gt;  65.0 (&lt;class 'float'&gt;)<br/>Sp. Def    -&gt;  65.0 (&lt;class 'float'&gt;)<br/>Speed      -&gt;  45.0 (&lt;class 'float'&gt;)</span></pre><p id="bd39" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在<code class="fe mx my mz mm b">numerical_data</code>中，我们现在可以找到<strong class="lc ja">和</strong>包含我们将用来计算欧几里德距离的数据的列。最后，为了确保我们做得好，让我们打印数据集中第一个神奇宝贝的值和类型，仔细检查它们是<code class="fe mx my mz mm b">float</code>。</p><p id="e598" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在:让我们编写将成为我们的KNN版本的真正核心的函数。首先，N维两点间的欧氏距离:</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="4e16" class="mq mr iq mm b gy ms mt l mu mv"><strong class="mm ja">def</strong> euclidean_distance(p1, p2):<br/>  dim <strong class="mm ja">=</strong> len(p1)<br/>  distance <strong class="mm ja">=</strong> 0<br/>  <strong class="mm ja">for</strong> d <strong class="mm ja">in</strong> range(dim):<br/>    distance <strong class="mm ja">+=</strong> abs(p1[d] <strong class="mm ja">-</strong> p2[d]) <strong class="mm ja">**</strong> 2<br/>  <br/>  distance <strong class="mm ja">=</strong> distance<strong class="mm ja">**</strong>(1<strong class="mm ja">/</strong>2)</span><span id="9ac0" class="mq mr iq mm b gy mw mt l mu mv">  <strong class="mm ja">return</strong> distance</span></pre><p id="092e" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><code class="fe mx my mz mm b">p1</code> e <code class="fe mx my mz mm b">p2</code>是列表，两者具有相同数量的元素(即具有相同的<em class="na">长度</em>)。欧几里德距离起作用的强制性要求是:点<em class="na">必须</em>属于同一个<strong class="lc ja">欧几里德空间</strong>；这是一个有趣的说法，如果我们有二维的点，我们将计算平面中的欧氏距离。如果我们有一个三维的点，我们将计算在空间中的欧几里德距离。计算2D点和3D点之间的欧几里德距离是没有意义的，不是吗？回到代码:在<code class="fe mx my mz mm b">for</code>循环中，我们遍历这些点的坐标，我们计算它们的差的绝对值，我们对其求平方，并将其添加到一个名为<code class="fe mx my mz mm b">distance</code>的变量中，该变量最初设置为0。在循环之外，我们将<code class="fe mx my mz mm b">distance</code>提升到0.5的幂，这意味着(我想提醒你)计算<code class="fe mx my mz mm b">distance</code>的平方根。</p><p id="d2ab" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">下一个函数将完成算法的剩余部分，即数据结构的创建和排序:</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="1b8b" class="mq mr iq mm b gy ms mt l mu mv"><strong class="mm ja">def</strong> get_k_neighbors(k, dataset, fake_pokemon):<br/>    <br/>    distances <strong class="mm ja">=</strong> []</span><span id="65e7" class="mq mr iq mm b gy mw mt l mu mv">    <strong class="mm ja">for</strong> i <strong class="mm ja">in</strong> range(len(dataset)):<br/>        row <strong class="mm ja">=</strong> dataset[i]<br/>        d <strong class="mm ja">=</strong> euclidean_distance(fake_pokemon, row)<br/>        distances<strong class="mm ja">.</strong>append((i, d))<br/></span><span id="c377" class="mq mr iq mm b gy mw mt l mu mv">    distances<strong class="mm ja">.</strong>sort(key<strong class="mm ja">=lambda</strong> tup: tup[1])</span><span id="7d20" class="mq mr iq mm b gy mw mt l mu mv">    <strong class="mm ja">return</strong> distances[:k]</span></pre><p id="1f2d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">该函数有三个参数:</p><ul class=""><li id="42f8" class="lx ly iq lc b ld le lg lh lj lz ln ma lr mb lv nb md me mf bi translated"><code class="fe mx my mz mm b">k</code>，一个数字，代表返回给用户的结果数</li><li id="aab1" class="lx ly iq lc b ld mg lg mh lj mi ln mj lr mk lv nb md me mf bi translated"><code class="fe mx my mz mm b">dataset</code>，包含所有神奇宝贝数值的表格</li><li id="a548" class="lx ly iq lc b ld mg lg mh lj mi ln mj lr mk lv nb md me mf bi translated"><code class="fe mx my mz mm b">fake_pokemon</code>，填充了用户值的列表</li></ul><p id="f6bb" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">接下来，该函数创建一个名为<code class="fe mx my mz mm b">distances</code>的空数据结构，对于数据集中由<code class="fe mx my mz mm b">i</code>索引标识的每个神奇宝贝，使用前面定义的函数计算<code class="fe mx my mz mm b">fake_pokemon</code>和第I个数据集行之间的欧几里德距离。对于每个计算的距离，一个新的元组被插入到<code class="fe mx my mz mm b">distances</code>结构中:元组的第一个元素是变量<code class="fe mx my mz mm b">i</code>，而第二个(也是最后一个)元素是计算的距离。在循环之后，这是我们将得到的数据结构:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/ec96f5d2e5ad9e46702e2b63e388003f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YLRE0T0THWaXQQ-9"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">未排序的数据结构。作者图片</figcaption></figure><p id="f94d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们所要做的就是<strong class="lc ja">整理</strong>这个数据结构。在Python中对一个列表进行排序相当容易:我们可以在我们想要排序的列表上使用<code class="fe mx my mz mm b">.sort</code>方法，所有数据将立即按升序排序。这种方法速度很快，并且适用于<strong class="lc ja">一维列表</strong>，而在这种情况下，我们有一个<code class="fe mx my mz mm b">Nx2</code>结构，其中N是神奇宝贝的数量。但是不要害怕！我们可以使用sort方法，作为第一个参数传递一个<strong class="lc ja">回调函数</strong>，其中我们可以<strong class="lc ja">指定我们想要用来对我们的原始数据结构</strong>进行排序的元素。这个函数将在列表的每个元素上被调用，并且只有一个参数:数据结构的第I个元素。为了简洁起见，我们使用了一个<strong class="lc ja"> lambda函数</strong>，但是我们可以使用一个老式的函数来获得相同的结果，就像这样:</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="f1c2" class="mq mr iq mm b gy ms mt l mu mv">def which_element(tup):<br/>    return tup[1]</span><span id="5a7b" class="mq mr iq mm b gy mw mt l mu mv">distances.sort(which_element)</span></pre><p id="f29d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">注意返回值(在lambda函数和传统函数中)仅仅是元组索引为1的值，即我们的数据结构的第二列:距离。</p><p id="766f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">下面是整理后的<code class="fe mx my mz mm b">distances</code>:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/83b2a3c204637b4364ca5cdc37bd2c2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fij93HRGnYdaXRW8"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">包含神奇宝贝索引和与用户神奇宝贝的距离的有序列表</figcaption></figure><p id="307d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在我们可以使用<strong class="lc ja">切片</strong>来返回第一个<strong class="lc ja"> k个</strong>元素，距离<strong class="lc ja">最短的k个元素</strong>，或者如果你喜欢的话，<strong class="lc ja">与用户神奇宝贝</strong>最相似的k个神奇宝贝。</p><p id="aba5" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">最后，我们创建了一个函数来打印神奇宝贝的信息。</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="89a1" class="mq mr iq mm b gy ms mt l mu mv"><strong class="mm ja">def</strong> print_pokemon_info(i):<br/>    s <strong class="mm ja">=</strong> f"{pokemon_dataset[i][0]} - {pokemon_dataset[i][1]}, of type {pokemon_dataset[i][2]} (gen. {pokemon_dataset[i][<strong class="mm ja">-</strong>2]})"<br/>    <strong class="mm ja">if</strong> pokemon_dataset[i][<strong class="mm ja">-</strong>1] <strong class="mm ja">==</strong> "True":<br/>        s <strong class="mm ja">+=</strong> f"\n - LEGENDARY"<br/>    <strong class="mm ja">return</strong> s</span></pre><p id="a991" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">该函数只接受一个输入参数:Pokémon数据集中该行的索引。我们只是使用一个Python f函数:</p><ul class=""><li id="b1dd" class="lx ly iq lc b ld le lg lh lj lz ln ma lr mb lv nb md me mf bi translated">神奇宝贝指数</li><li id="775c" class="lx ly iq lc b ld mg lg mh lj mi ln mj lr mk lv nb md me mf bi translated">神奇宝贝名称</li><li id="ae06" class="lx ly iq lc b ld mg lg mh lj mi ln mj lr mk lv nb md me mf bi translated">神奇宝贝类型</li><li id="217a" class="lx ly iq lc b ld mg lg mh lj mi ln mj lr mk lv nb md me mf bi translated">神奇宝贝世代(为了检索世代，我们使用index -2来获取<strong class="lc ja">倒数第二个</strong>元素)</li><li id="577e" class="lx ly iq lc b ld mg lg mh lj mi ln mj lr mk lv nb md me mf bi translated">如果神奇宝贝是传奇的消息(为了检索“传奇”字段，我们使用index -1来获取行的最后一个元素)</li></ul><p id="76e0" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">最后，我们返回生成的字符串。</p><p id="c889" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">最后，我们使用创建的函数编写代码行，要求用户输入:</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="732e" class="mq mr iq mm b gy ms mt l mu mv">user_row <strong class="mm ja">=</strong> []</span><span id="bd57" class="mq mr iq mm b gy mw mt l mu mv">k <strong class="mm ja">=</strong> 5</span><span id="3a65" class="mq mr iq mm b gy mw mt l mu mv"><strong class="mm ja">for</strong> i <strong class="mm ja">in</strong> range(len(num_indexes)):<br/>    col_index <strong class="mm ja">=</strong> num_indexes[i]<br/>    v <strong class="mm ja">=</strong> input(f"Inserisci il tuo valore di {columns[col_index]}\n")<br/>    user_row<strong class="mm ja">.</strong>append(float(v))</span><span id="f1da" class="mq mr iq mm b gy mw mt l mu mv"><strong class="mm ja">for</strong> k, v <strong class="mm ja">in</strong> zip(columns[5:11], user_row):<br/>    print(f"{k:10} -&gt; {v:15} ({type(v)})")</span><span id="3d1a" class="mq mr iq mm b gy mw mt l mu mv">print("Looking for the most similar Pokémon...")</span><span id="44de" class="mq mr iq mm b gy mw mt l mu mv">l <strong class="mm ja">=</strong> get_k_neighbors(k, numerical_data, user_row)<br/>print(l)</span><span id="39c9" class="mq mr iq mm b gy mw mt l mu mv"><strong class="mm ja">for</strong> p <strong class="mm ja">in</strong> l:<br/>    print(print_pokemon_info(p[0]))</span></pre><p id="8cae" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们创建一个对应于我们的假神奇宝贝的空列表；我们将k设置为5(我们将获得距离最短的5个神奇宝贝)，并向用户询问6个数字(我们还将使用我们在第一个单元格中创建的<code class="fe mx my mz mm b">columns</code>列表，向用户显示分数名称)；我们打印这些值是为了提高程序的可用性；我们调用函数得到K个最相似的神奇宝贝；我们使用最后一个函数来显示我们的算法返回了哪些神奇宝贝。下面是程序输出的一个例子:</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="598a" class="mq mr iq mm b gy ms mt l mu mv">Insert a HP value<br/>40<br/>Insert a Attack value<br/>40<br/>Insert a Defense value<br/>40<br/>Insert a Sp.Attack value<br/>40<br/>Insert a Sp.Defense value<br/>40<br/>Insert a Speed value<br/>40<br/>HP         -&gt;            40.0 (&lt;class 'float'&gt;)<br/>Attack     -&gt;            40.0 (&lt;class 'float'&gt;)<br/>Defense    -&gt;            40.0 (&lt;class 'float'&gt;)<br/>Sp. Atk    -&gt;            40.0 (&lt;class 'float'&gt;)<br/>Sp. Def    -&gt;            40.0 (&lt;class 'float'&gt;)<br/>Speed      -&gt;            40.0 (&lt;class 'float'&gt;)</span><span id="ad02" class="mq mr iq mm b gy mw mt l mu mv">Looking for the most similar Pokémon...</span><span id="f0da" class="mq mr iq mm b gy mw mt l mu mv">236 - Tyrogue, of type Fighting (gen. 2)<br/>300 - Skitty, of type Normal (gen. 3)<br/>29 - Nidoran♀, of type Poison (gen. 1)<br/>504 - Patrat, of type Normal (gen. 5)<br/>412 - Burmy, of type Bug (gen. 4)</span></pre><p id="6281" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">就在那里！我们可以插入我们想要的任何值，我们的软件将使用前面实现的KNN算法来返回与用户插入的数字最相似的神奇宝贝。很简单，不是吗？通常，一旦你有了一个好的设计，编码就不会那么难了。</p><p id="6b42" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们的存储库，可在<a class="ae lw" href="https://github.com/Datamasters-it/pycon-22-beginners-day" rel="noopener ugc nofollow" target="_blank">这个URL </a>找到，你可以找到一个Jupyter笔记本，上面有神奇宝贝图像的可视化，取自<a class="ae lw" href="https://veekun.com/dex/downloads" rel="noopener ugc nofollow" target="_blank">一个有神奇宝贝数据的网站</a>。</p><p id="2525" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">稍后见，还有其他ML文章和教程！</p></div></div>    
</body>
</html>