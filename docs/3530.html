<html>
<head>
<title>Using Redux for Bluetooth communication in a React Native App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React本地应用中使用Redux进行蓝牙通信</h1>
<blockquote>原文：<a href="https://itnext.io/using-a-raspberry-pi-to-control-leds-part-iii-react-native-app-29ee3f4afb8c?source=collection_archive---------1-----------------------#2020-01-04">https://itnext.io/using-a-raspberry-pi-to-control-leds-part-iii-react-native-app-29ee3f4afb8c?source=collection_archive---------1-----------------------#2020-01-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="dab4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文重点介绍如何在React Native中构建一个移动应用程序，该应用程序将与支持蓝牙的控制器通信，重点是连接到可以改变led灯条颜色和亮度的BLE设备。本文重点介绍如何设置Redux Store，使用thunks控制蓝牙设备管理器，以及控制应用程序的UI组件。我不打算集中讨论创建新的React本机应用程序、安装特定组件或设置特定设备的一步一步的过程，我提供的每个链接都涵盖了这些内容。您将学习如何通过蓝牙扫描、连接、发现、监听和发送命令到您的设备。为了演示这一点，我主要使用颜色选择器向蓝牙设备发送颜色。如果你对我在构建这个时使用的设备感兴趣，我有一篇关于使用树莓Pi作为BLE LED控制器的文章，它将与这个应用一起工作。</p><h1 id="2bd4" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">如何与React Native蓝牙</strong></h1><p id="8c5a" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在react原生应用中获得蓝牙的最简单方法是使用Polidea提供的库。因为它需要本机代码，所以我选择使用react本机CLI来构建React本机应用程序。该过程的第一步是创建一个应用程序，并将其加载到您的手机上。在这个过程中，有两个主要步骤，首先是根据您使用的是iOS还是Android来遵循“入门”步骤。它们概述如下:</p><div class="lp lq gp gr lr ls"><a href="https://facebook.github.io/react-native/docs/getting-started" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab fo"><div class="lu ab lv cl cj lw"><h2 class="bd ir gy z fp lx fr fs ly fu fw ip bi translated">开始反应原生</h2><div class="lz l"><h3 class="bd b gy z fp lx fr fs ly fu fw dk translated">该页面将帮助您安装和构建您的第一个React本机应用程序。如果您已经安装了React Native，您…</h3></div><div class="ma l"><p class="bd b dl z fp lx fr fs ly fu fw dk translated">facebook.github.io</p></div></div><div class="mb l"><div class="mc l md me mf mb mg mh ls"/></div></div></a></div><p id="fbb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二步是让应用程序在您的设备上运行。为了测试该应用程序，你必须有一个实际的设备来连接，因为iOS和Android的模拟器已经禁用了蓝牙支持。虽然它比使用Expo启动更复杂，但是一旦您让它工作起来，开发和调试它就很容易了。</p><div class="lp lq gp gr lr ls"><a href="https://facebook.github.io/react-native/docs/running-on-device" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab fo"><div class="lu ab lv cl cj lw"><h2 class="bd ir gy z fp lx fr fs ly fu fw ip bi translated">在设备上运行React Native</h2><div class="lz l"><h3 class="bd b gy z fp lx fr fs ly fu fw dk translated">在发布给用户之前，在实际设备上测试你的应用总是一个好主意。这份文件将…</h3></div><div class="ma l"><p class="bd b dl z fp lx fr fs ly fu fw dk translated">facebook.github.io</p></div></div><div class="mb l"><div class="mi l md me mf mb mg mh ls"/></div></div></a></div><p id="99fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成初始安装并在设备上运行应用程序后，下一步是设置React原生蓝牙低能耗库。这是对存储库中每个设备的详细描述:</p><div class="lp lq gp gr lr ls"><a href="https://github.com/Polidea/react-native-ble-plx#configuration--installation" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab fo"><div class="lu ab lv cl cj lw"><h2 class="bd ir gy z fp lx fr fs ly fu fw ip bi translated">Polidea/react-native-ble-plx</h2><div class="lz l"><h3 class="bd b gy z fp lx fr fs ly fu fw dk translated">这是React原生蓝牙低能耗库，使用了引擎盖下的RxBluetoothKit和RxAndroidBle。它支持…</h3></div><div class="ma l"><p class="bd b dl z fp lx fr fs ly fu fw dk translated">github.com</p></div></div><div class="mb l"><div class="mj l md me mf mb mg mh ls"/></div></div></a></div><p id="9eec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，您可以开始安装应用程序的其余组件了。这个应用程序使用以下组件:<a class="ae kl" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>用于状态管理和组件之间的通信，<a class="ae kl" href="https://github.com/reduxjs/redux-thunk" rel="noopener ugc nofollow" target="_blank"> Redux Thunk </a>用于控制蓝牙管理器和设备并与之交互，<a class="ae kl" href="https://nativebase.io/" rel="noopener ugc nofollow" target="_blank">本机Base </a>用于UI元素，<a class="ae kl" href="https://github.com/jemise111/react-native-swipe-list-view" rel="noopener ugc nofollow" target="_blank"> React本机滑动列表视图</a>用于显示BLE设备列表，<a class="ae kl" href="https://reactnavigation.org/" rel="noopener ugc nofollow" target="_blank"> React导航</a>用于管理我的应用程序屏幕，<a class="ae kl" href="https://github.com/instea/react-native-color-picker" rel="noopener ugc nofollow" target="_blank"> React本机颜色选择器</a>用于选择led的颜色。</p><p id="d08c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本流程是，在启动时，应用程序将开始扫描手机附近所有可连接的蓝牙设备，并创建一个列表供您选择。一旦您选择了您的设备，应用程序将尝试连接它，一旦成功，它将加载一个颜色选择器供您选择颜色。当你选择了一种颜色，应用程序将发送请求到你的BLE设备，这将改变你的LED灯条的颜色。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mk"><img src="../Images/0ef7d0663f267e3d3bdfbd26219b7a60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WdYaENMBYc-1gEjcQTBuJA.png"/></div></div></figure><p id="1f13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我使用React导航来控制应用程序的流程。在此基础上，我做了一些流程决策，比如在我的thunks中控制导航，但这需要将导航集成到redux中，由于不推荐，我选择通过带有滑动列表视图的UI来控制这些更改。具体来说，当设备成功侦听时，我希望导航到颜色选择器，但是将导航调度功能添加到我的操作中需要使用<a class="ae kl" href="https://github.com/react-navigation/redux-helpers" rel="noopener ugc nofollow" target="_blank"> react本机导航助手</a>将导航添加到redux中，然而，对于这样一个小用例来说，这似乎违背了导航库的目的。</p><p id="81e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用导航模块可以很容易地让应用程序切换UI组件。它从应用程序的根目录开始，在我的例子中是App.js，在这里我为我的导航创建了一个AppContainer和Stack Navigator。</p><pre class="ml mm mn mo gt mv mw mx my aw mz bi"><span id="5a41" class="na kn iq mw b gy nb nc l nd ne">import {createAppContainer} from 'react-navigation';<br/>import {createStackNavigator} from 'react-navigation-stack';</span><span id="774e" class="na kn iq mw b gy nf nc l nd ne"><strong class="mw ir">//add your UI components to the stack (Home is the first screen)</strong></span><span id="97a6" class="na kn iq mw b gy nf nc l nd ne">const MainNavigator = createStackNavigator({<br/>  Home: {screen: BLEList},<br/>  ColorPicker: {screen:LEDColorPicker}<br/>});</span><span id="5495" class="na kn iq mw b gy nf nc l nd ne"><strong class="mw ir">//create the App Container using your Stack Navigator</strong><br/> <br/>let Navigation = createAppContainer(MainNavigator);</span><span id="24da" class="na kn iq mw b gy nf nc l nd ne">const App: () =&gt; React$Node = () =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;Provider store={ store }&gt;<br/>        &lt;Navigation /&gt; <strong class="mw ir">//Render the App Container</strong><br/>      &lt;/Provider&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</span></pre><p id="908f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">导航模块的工作方式非常像Redux，并且将在您的组件道具中可用。如果您希望在子组件中使用导航模块，您将需要使用withNavigation特性，我将在UI组件一节中概述该特性。</p><h1 id="b44d" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak"> Redux设置</strong></h1><p id="ba4d" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">应用程序的状态保存在Redux中，初始状态如下:</p><pre class="ml mm mn mo gt mv mw mx my aw mz bi"><span id="9996" class="na kn iq mw b gy nb nc l nd ne">const INITIAL_STATE = {<br/>  BLEList: [], //An Array of Discovered Devices<br/>  color: '#800080', //the Current Color of the LED strip<br/>  connectedDevice: {}, // the current connected BLE device<br/>  status: 'disconnected' // the status of the BLE connection<br/>};</span></pre><p id="5be1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">减速器非常简单，唯一需要注意的是，我只添加了可连接且有名称的设备。这将有助于保持设备列表的可管理性，因为你会发现(没有双关语)你身边有很多ble设备！</p><pre class="ml mm mn mo gt mv mw mx my aw mz bi"><span id="7da4" class="na kn iq mw b gy nb nc l nd ne">const BLEReducer = (state =INITIAL_STATE, action) =&gt; {<br/>  switch (action.type) {<br/>    case 'ADD_BLE':<br/>      if(state.BLEList.some(device =&gt; device.id === action.device.id) || !action.device.isConnectable || action.device.name === null){<br/>        return state;<br/>      } else {<br/>        const newBLE = [<br/>              ...state.BLEList,<br/>              action.device<br/>            ]<br/>         return {<br/>           BLEList: newBLE,<br/>           color: state.color,<br/>           connectedDevice: state.connectedDevice,<br/>           status: action.status<br/>          };<br/>      }<br/>    case 'CHANGED_COLOR':<br/>      return {<br/>        BLEList: state.BLEList,<br/>        color: action.newColor,<br/>        connectedDevice: state.connectedDevice,<br/>        status: action.status<br/>      };<br/>    case 'CONNECTED_DEVICE':<br/>      console.log("Reducer connected device", action);<br/>      return {<br/>        BLEList: state.BLEList,<br/>        color: state.color,<br/>        connectedDevice: action.connectedDevice,<br/>        status: action.status<br/>       };<br/>    case 'CHANGE_STATUS':<br/>      console.log("change status:", action.status)<br/>      return {<br/>        BLEList: state.BLEList,<br/>        color: state.color,<br/>        connectedDevice: action.connectedDevice,<br/>        status: action.status}<br/>    default:<br/>      return state;<br/>  }<br/>};</span></pre><h1 id="057e" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">Redux Thunk</h1><p id="4bf3" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我想要一个不包含在组件或助手类中的全局蓝牙管理器对象，所以我使用Redux Thunk来管理它。在我的App.js中，我添加了以下内容:</p><pre class="ml mm mn mo gt mv mw mx my aw mz bi"><span id="7b8a" class="na kn iq mw b gy nb nc l nd ne">import { Provider } from 'react-redux';<br/>import { createStore,applyMiddleware } from 'redux';<br/>import rootReducer from './reducers/index';<br/>import thunk from 'redux-thunk';<br/><br/>import { <br/>  BleManager,<br/>  BleError <br/>} from 'react-native-ble-plx';</span><span id="6375" class="na kn iq mw b gy nf nc l nd ne">...</span><span id="837f" class="na kn iq mw b gy nf nc l nd ne">const DeviceManager = new BleManager();<br/><br/>const store = createStore(rootReducer, applyMiddleware(thunk.withExtraArgument(DeviceManager)));</span></pre><p id="f5d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过在应用程序的根目录下创建BleManager，我能够使用“withExtraArgument”选项将对象传递到我的Thunk函数中。这将允许我将DeviceManager作为一个参数与dispatch和getState一起访问。所有未来的管理和与BLE设备管理器的通信将通过Thunk进行。我创建了四个不同的Thunk函数:startScan、Scan、connectDevice和updateColor。</p><p id="2a17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> startScan </strong>用于使ble管理器扫描所有可用的BLE设备。它的主要功能是等待设备管理器处于“通电”状态，然后它将调度扫描功能。</p><pre class="ml mm mn mo gt mv mw mx my aw mz bi"><span id="6852" class="na kn iq mw b gy nb nc l nd ne">export const startScan = () =&gt; {<br/>    return (dispatch, getState, DeviceManager) =&gt; {<br/>        const subscription = DeviceManager.onStateChange((state) =&gt; {<br/>            if (state === 'PoweredOn') {<br/>                dispatch(scan());<br/>                subscription.remove();<br/>            }<br/>        }, true);<br/>      };<br/>}</span></pre><p id="4da5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">一旦设备处于“通电”状态，就使用扫描</strong>，设备管理器准备寻找设备。该函数调用BLE库中的startDeviceScan函数，然后调度设置当前状态的<strong class="jp ir"> changeStatus </strong>动作，以及当发现设备时的<strong class="jp ir"> addBLE </strong>动作。</p><pre class="ml mm mn mo gt mv mw mx my aw mz bi"><span id="2fc5" class="na kn iq mw b gy nb nc l nd ne">export const scan = () =&gt; {<br/>    return (dispatch, getState, DeviceManager) =&gt; {<br/>        DeviceManager.startDeviceScan(null, null, (error, device) =&gt; {<br/>           dispatch(changeStatus("Scanning"));<br/>          if (error) {<br/>            console.log(error);<br/>          }<br/>          if(device !== null){<br/>            dispatch(addBLE(device));<br/>        }<br/>        });<br/>    }<br/>}</span></pre><p id="a1c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> connectDevice </strong>当用户在主屏幕上选择应用程序中显示为列表的设备时，将调用该设备。该功能首先在DeviceManager上禁用扫描，然后执行连接功能，以及发现特征、设置通知，然后监听事件。在这一过程中，它调度状态更新，当最终连接并侦听时，它调度<strong class="jp ir"> connectedDevice </strong>动作，该动作更新Redux存储。</p><pre class="ml mm mn mo gt mv mw mx my aw mz bi"><span id="4901" class="na kn iq mw b gy nb nc l nd ne">export const connectDevice = (device) =&gt; {<br/>    return (dispatch, getState, DeviceManager) =&gt; {<br/>           dispatch(changeStatus("Connecting"));<br/>           DeviceManager.stopDeviceScan()<br/>            device.connect()<br/>              .then((device) =&gt; {<br/>                dispatch(changeStatus("Discovering"));<br/>                let characteristics = device.discoverAllServicesAndCharacteristics()<br/>                return characteristics;<br/>              })<br/>              .then((device) =&gt; {<br/>                dispatch(changeStatus("Setting Notifications"));<br/>                return device;<br/>              })<br/>              .then((device) =&gt; {<br/>                dispatch(changeStatus("Listening"));<br/>                dispatch(connectedDevice(device))<br/>                return device;<br/>              }, (error) =&gt; {<br/>                console.log(this._logError("SCAN", error));<br/>                //return null;<br/>              })<br/>    }<br/>}</span></pre><p id="c521" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> updateColor </strong>在用户编辑颜色选择器并从味觉中选择新颜色时使用。这个函数要求我们使用<strong class="jp ir"> getState </strong>参数，这样我们就可以从Redux存储中找到<strong class="jp ir"> connectedDevice </strong>。它还使用一个库将十六进制字符串转换成base64字符串，该字符串将通过蓝牙发送。同样，任何状态更改都将通过<strong class="jp ir"> changeStatus </strong>动作进行调度。完成后，它会调度<strong class="jp ir"> changedColor </strong>动作来更新Redux存储。</p><pre class="ml mm mn mo gt mv mw mx my aw mz bi"><span id="2a5c" class="na kn iq mw b gy nb nc l nd ne">export const updateColor = (newcolor) =&gt; {<br/>    return (dispatch, getState, DeviceManager) =&gt; {<br/>        const state = getState();<br/>        try {<br/>            let base64 = Base64.btoa(unescape(encodeURIComponent(newcolor)));<br/>            let LEDResponse = state.BLEs.connectedDevice.writeCharacteristicWithResponseForService("00010000-89BD-43C8-9231-40F6E305F96D", "00010001-89BD-43C8-9231-40F6E305F96D", base64 )<br/>            dispatch(changeStatus("Changing Color"));<br/>            dispatch(changedColor(newcolor));<br/>            return true;<br/>          } catch(error){<br/>            console.log("update Error:", error)<br/>            return false;<br/>          }<br/>    }<br/>}</span></pre><p id="cd9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其余的动作如下所述，相应的减速器如上所述。</p><pre class="ml mm mn mo gt mv mw mx my aw mz bi"><span id="2c11" class="na kn iq mw b gy nb nc l nd ne">export const addBLE = (device) =&gt; ({<br/>    type: "ADD_BLE",<br/>    device<br/>})<br/><br/>export const changedColor = (color) =&gt; ({<br/>    type: "CHANGED_COLOR",<br/>    newColor: color<br/>})<br/><br/>export const connectedDevice = (device) =&gt; ({<br/>    type: "CONNECTED_DEVICE",<br/>    connectedDevice: device<br/>});<br/><br/>export const changeStatus = (status) =&gt; ({<br/>    type: "CHANGE_STATUS",<br/>    status: status<br/>});</span></pre><h1 id="7250" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">UI组件</h1><p id="ec41" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">应用程序中只使用了三个组件，其中只有两个是导航模块使用的主屏幕。这些是BLEList、ColorPicker和BLE。状态由Redux管理，蓝牙由thunks管理，这些组件纯粹用于用户交互和查看数据。</p><p id="7183" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">BLEList 是主屏幕，在应用程序启动时显示。它的目的是控制设备管理器，并在SwipeListView组件中列出它找到的任何BLE设备。SwipeListView组件需要大量的代码，所以我将在这里突出显示该组件的特定方面，您可以去存储库查看全部内容。该组件对容器、页眉、内容和页脚使用本机基础。因为Native Base已经移除了对可滑动列表的支持，所以我使用他们推荐的react原生滑动列表视图的解决方案，该解决方案基于react原生平面列表。该组件使用redux BLEList作为SwipeListView中的数据属性，这就是我使用redux中的BLEList的地方。这些在下面的函数中定义</p><pre class="ml mm mn mo gt mv mw mx my aw mz bi"><span id="558f" class="na kn iq mw b gy nb nc l nd ne">function mapStateToProps(state){<br/>  return{<br/>    BLEList : state.BLEs['BLEList']<br/>  };<br/>}<br/><br/>const mapDispatchToProps = dispatch =&gt; ({<br/>  connectDevice: device =&gt; dispatch(connectDevice(device)),<br/>  startScan: () =&gt; dispatch(startScan())<br/>})</span><span id="3975" class="na kn iq mw b gy nf nc l nd ne">export default connect(mapStateToProps,mapDispatchToProps)(BLEList);</span></pre><p id="7544" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在构造函数中，我调用了startScan操作</p><pre class="ml mm mn mo gt mv mw mx my aw mz bi"><span id="de73" class="na kn iq mw b gy nb nc l nd ne">constructor(props){<br/>    super(props);<br/>    <strong class="mw ir">this.props.startScan();</strong><br/>    ...<br/>  }</span></pre><p id="b31e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当点击一个项目时，我用handleClick函数调用connectDevice操作</p><pre class="ml mm mn mo gt mv mw mx my aw mz bi"><span id="2fa4" class="na kn iq mw b gy nb nc l nd ne">handleClick = (device) =&gt; {<br/>    <strong class="mw ir">this.props.connectDevice(device);</strong><br/>}</span></pre><p id="dd3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该函数附加到SwipeListView的renderItem prop中的TouchableHighlight元素，该元素遍历Redux stores BLEList</p><pre class="ml mm mn mo gt mv mw mx my aw mz bi"><span id="1059" class="na kn iq mw b gy nb nc l nd ne">data={<strong class="mw ir">this.props.BLEList</strong>}<br/>renderItem={data =&gt; (<br/>                &lt;TouchableHighlight<br/>                    onPress={() =&gt; <strong class="mw ir">this.handleClick(data.item)</strong>}<br/>                    style={styles.rowFront}<br/>                    underlayColor={'#AAA'}<br/>                &gt;<br/>                    &lt;View&gt;<br/>                        &lt;Text&gt;<br/>                            Tap to connect to: {data.item.name}<br/>                        &lt;/Text&gt;<br/>                    &lt;/View&gt;<br/>                &lt;/TouchableHighlight&gt;<br/>            )}</span></pre><p id="c201" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> BLE </strong>是一个容器，用来显示BLE设备管理器的状态，比如设备管理器状态，当前连接的设备，以及设备的当前颜色。需要注意的一点是，这个组件嵌套在BLEList组件的页脚中，所以我使用withNavigation模块来启用子组件中的导航属性。</p><pre class="ml mm mn mo gt mv mw mx my aw mz bi"><span id="2430" class="na kn iq mw b gy nb nc l nd ne">import React from 'react';<br/>import { connect } from 'react-redux';<br/>import { Container, Text} from 'native-base';<br/><strong class="mw ir">import { withNavigation } from 'react-navigation';</strong><br/>import { SegmentedControlIOSComponent } from 'react-native';<br/><br/>class BLE extends React.Component {<br/>    constructor(props) {<br/>        super(props);<br/>    };<br/><br/>    render() {<br/>        return ( <br/>            &lt;Container&gt;<br/>                &lt;Text style={{backgroundColor: <strong class="mw ir">this.props.color</strong>}}&gt;<br/>                    Status: {<strong class="mw ir">this.props.status</strong>} <br/>                &lt;/Text&gt;<br/>                &lt;Text&gt;Color: {<strong class="mw ir">this.props.color</strong>}&lt;/Text&gt;<br/>                {this.props.connectedDevice &amp;&amp; &lt;Text&gt;Device: {<strong class="mw ir">this.props.connectedDevice.name</strong>}&lt;/Text&gt;}<br/>            &lt;/Container&gt;<br/>        );<br/>    }<br/>}<br/><br/>function mapStateToProps(state){<br/>  return{<br/>    BLEList : state.BLEs.BLEList,<br/>    color:state.BLEs.color,<br/>    connectedDevice: state.BLEs.connectedDevice,<br/>    status: state.BLEs.status<br/>  };<br/>}<br/><br/>const mapDispatchToProps = dispatch =&gt; ({<br/>  addBLE: device =&gt; dispatch(addBLE(device))<br/>})<br/><br/>export default connect(mapStateToProps,mapDispatchToProps,null,{ forwardRef: true })(<strong class="mw ir">withNavigation(BLE)</strong>);</span></pre><p id="0356" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> ColorPicker </strong>用于选择led的颜色。和BLEList一样，它使用了原生Base的容器、页眉和页脚，颜色选择器是react原生颜色选择器的标准颜色选择器。我不想在用户挂起颜色时不断更新redux，所以我在这里使用一个状态对象来帮助设置颜色选择器的默认状态。该组件使用Redux中的颜色以及updateColor操作在设备上设置新颜色。颜色选择器使用HSV颜色，所以我使用toHSV和fromHSV中包含的函数将它们转换成十六进制表示字符串，然后再转换回来。</p><pre class="ml mm mn mo gt mv mw mx my aw mz bi"><span id="7ff6" class="na kn iq mw b gy nb nc l nd ne">import React, { Component } from 'react';<br/>import { Container, Header, Footer} from 'native-base';<br/>import {connect} from 'react-redux';<br/>import {updateColor} from './actions';<br/>import { ColorPicker,toHsv,fromHsv } from 'react-native-color-picker'<br/><br/>class LEDColorPicker extends Component {<br/>  constructor() {<br/>    super()<br/>    this.onColorChange = this.onColorChange.bind(this)<br/>    this.state = {slider:0,color:toHsv('purple'),BLEcolor:toHsv('purple')}<br/>  }<br/><br/>  componentDidMount(){<br/>    this.setState({<strong class="mw ir">color:toHsv(this.props.color)</strong>});<br/>  }<br/><br/>  onColorChange(color) {<br/>    this.setState({"color": color })<br/>    <strong class="mw ir">this.props.updateColor(fromHsv(color));</strong><br/>  }<br/><br/>  render() {           <br/>    return (<br/>      &lt;Container&gt;<br/>        &lt;Header /&gt;<br/>        &lt;ColorPicker<br/>            color={<strong class="mw ir">toHsv(this.state.color)</strong>}<br/>            onColorChange={<strong class="mw ir">(colorval) =&gt; this.setState({color: colorval})</strong>}<br/>            onColorSelected={<strong class="mw ir">this.onColorChange</strong>}<br/>            hideSliders={false}<br/>            style={{flex: 1}}<br/>          /&gt;<br/>          &lt;Footer&gt;<br/>        &lt;/Footer&gt;<br/>      &lt;/Container&gt;<br/>    );<br/>  }<br/>}<br/><br/>function mapStateToProps(state){<br/>  return{<br/>    color : state.BLEs.color<br/>  };<br/>}<br/><br/>const mapDispatchToProps = dispatch =&gt; ({<br/>  updateColor: color =&gt; dispatch(updateColor(color))<br/>})<br/><br/>export default connect(mapStateToProps,mapDispatchToProps)(LEDColorPicker);</span></pre><h1 id="ab40" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">最后的想法</h1><p id="c980" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">现在，随着蓝牙在如此多的微控制器上的可用性，能够将您的手机用作设备控制器非常有意义，并打开了新的可能性之门，同时降低了设备功能的复杂性。使用React Native可以轻松构建跨平台的移动应用程序。困难的部分是创建全局蓝牙设备管理器，使用redux和redux thunks通过动作来控制它，允许您创建关注用户交互而不是管理复杂状态的轻量级组件。</p><h1 id="34bc" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">参考</h1><div class="lp lq gp gr lr ls"><a href="https://github.com/momolarson/ReactNativeLEDController" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab fo"><div class="lu ab lv cl cj lw"><h2 class="bd ir gy z fp lx fr fs ly fu fw ip bi translated">momo Larson/ReactNativeLEDController</h2><div class="lz l"><h3 class="bd b gy z fp lx fr fs ly fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ma l"><p class="bd b dl z fp lx fr fs ly fu fw dk translated">github.com</p></div></div><div class="mb l"><div class="ng l md me mf mb mg mh ls"/></div></div></a></div><h1 id="0fac" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">关于我</h1><div class="lp lq gp gr lr ls"><a href="https://www.linkedin.com/in/gregglarson/" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab fo"><div class="lu ab lv cl cj lw"><h2 class="bd ir gy z fp lx fr fs ly fu fw ip bi translated">Gregg Larson -员工工程师-外部| LinkedIn</h2><div class="lz l"><h3 class="bd b gy z fp lx fr fs ly fu fw dk translated">查看Gregg Larson在世界上最大的职业社区LinkedIn上的个人资料。葛雷格在他们的……</h3></div><div class="ma l"><p class="bd b dl z fp lx fr fs ly fu fw dk translated">www.linkedin.com</p></div></div><div class="mb l"><div class="nh l md me mf mb mg mh ls"/></div></div></a></div></div></div>    
</body>
</html>