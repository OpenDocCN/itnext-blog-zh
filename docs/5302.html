<html>
<head>
<title>Refactoring Go4Data using Interfaces and Benchmarks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用接口和基准重构Go4Data</h1>
<blockquote>原文：<a href="https://itnext.io/refactoring-go4data-using-interfaces-and-benchmarks-19affdf94079?source=collection_archive---------7-----------------------#2021-02-04">https://itnext.io/refactoring-go4data-using-interfaces-and-benchmarks-19affdf94079?source=collection_archive---------7-----------------------#2021-02-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="71a1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一步一步的指导你如何在Go中使用接口来重构并使你的代码非常模块化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/544a7326bc4a76de03e04a132c17a2e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQ3RRF_79gzKFPm-AUqYpg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Go4Data可以用来做什么的例子。</figcaption></figure><p id="7477" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将介绍我如何使用Golang接口的能力来替换<a class="ae lu" href="https://github.com/percybolmer/go4data" rel="noopener ugc nofollow" target="_blank"> Go4Data </a>中的一个主要部分。我们还将使用基准测试来比较旧解决方案和新解决方案。</p><p id="a813" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望这篇文章聚焦于<strong class="la iu">如何正确使用接口，以及基准</strong>而不是我正在改变的代码。因为我们将会改变很多代码，我不期望你自己编码，而是试着接受使用接口的过程和心态。</p><p id="62fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">先来解释一下Go4Data是什么，或者说我希望它变成什么样子。Go4Data是一款数据处理工具。它专注于处理数据，目前正在进行中。这个想法是，您可以设置输入，比如Redis队列或目录中的文件。然后，您可以通过发布/订阅引擎将数据传递到下一个数据处理器。这个想法来自于我的第100个项目，在对数据进行过滤和转换后，必须读取CSV文件并将其放入数据库。</p><p id="c722" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这都是由Go4Data加载的YAML配置文件完成的，不需要编码。</p><p id="ff64" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们今天要重构的部分是Go4Data使用的发布/订阅系统。在开发过程中，我创建了一个定制的内存发布/订阅系统。这工作得很好，但是它的可伸缩性不是很好，因为它依赖于当前应用程序使用的内存。<strong class="la iu">允许用户通过创建一个发布/订阅接口来配置Go4Data使用的发布/订阅引擎</strong>将会非常酷，让我们开始吧。我还将实现该接口的Redis实现。</p><p id="7bee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当Redis实现完成时，我们将对两者进行基准测试，看哪一个性能最好。如果你不熟悉Redis如何与Pub/Sub一起工作，请阅读我的另一篇<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/redis-as-a-pub-sub-engine-in-go-10eb5e6699cc">文章</a>。</p><p id="bdf4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们将允许用户通过简单地调用方法NewEngine在Go4Datas自定义发布/订阅和Redis之间切换。下面的要点显示了如何进行改变。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在Redis和Default之间切换将是一个简单的配置。</figcaption></figure><h2 id="a4ec" class="lx ly it bd lz ma mb dn mc md me dp mf lh mg mh mi ll mj mk ml lp mm mn mo mp bi translated">从回顾当前存在的东西开始</h2><p id="085c" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">因此，我想做的第一件事是看看当前的实现，我们将努力使界面适合这一点，以便我们可以允许用户在不修改任何其他代码的情况下交换整个发布/订阅引擎。</p><p id="faad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当前的发布/订阅引擎公开了一些全局方法，整个Go4Data使用这些方法来发布和订阅数据。这些方法是<strong class="la iu">发布、发布主题和订阅</strong>。因此，如果我们在将要创建的接口中使用这3个方法，我们应该能够替换整个逻辑，而不会破坏其余的包。</p><h2 id="685e" class="lx ly it bd lz ma mb dn mc md me dp mf lh mg mh mi ll mj mk ml lp mm mn mo mp bi translated">创建界面</h2><p id="22e0" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">我将把这3个方法提取到一个名为Engine的接口中。该引擎将通过三个相同的方法由公共API公开使用。这允许用户非常容易地重新配置所使用的引擎，而不破坏所有其他包。</p><p id="998b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望在运行Go4Data时将旧的实现作为默认实现，因为我们不想强迫用户安装Redis。所以我们还必须创建一个默认的结构来实现引擎接口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">这是我们在Go4Data中需要的接口。</figcaption></figure><h2 id="03b1" class="lx ly it bd lz ma mb dn mc md me dp mf lh mg mh mi ll mj mk ml lp mm mn mo mp bi translated">全局公开所需的方法</h2><p id="daca" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">由于Go4Data中的其余包依赖于可用的方法，我将创建一些与API匹配的包装函数，但它们将只调用底层选定引擎的真正方法来运行。</p><p id="05ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们公开的方法将依赖于我们即将创建的接口实现，所以我们需要创建一个init函数，在导入包后立即运行。这里我们将创建一个DefaultEngine对象，这样如果没有设置引擎，Go4Data就不会崩溃。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">完整的PubSub代码，公开方法并包装引擎。</figcaption></figure><p id="9766" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是发布/订阅的样子，它将API暴露给其余的包，所以当我们改变底层的发布/订阅引擎时，它不会崩溃。</p><p id="8423" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意我是如何创建一个具有类型引擎接口的<strong class="la iu">引擎变量的？这是当用户选择引擎时我们将重新配置的变量，也是每当调用API方法时我们调用方法的变量。这允许我们对go4数据包的其余部分保持全局方法，但是可以很容易地切换调用的逻辑。</strong></p><h2 id="0a26" class="lx ly it bd lz ma mb dn mc md me dp mf lh mg mh mi ll mj mk ml lp mm mn mo mp bi translated">实现DefaultEngine</h2><p id="3e26" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">DefaultEngine是我在开发过程中使用的旧实现。完整的代码很长，你可以滚动过去，如果你想。我们要做的是获取其中存在的所有方法，并将它们作为一个名为DefaultEngine的结构上的方法接收器。</p><p id="7b03" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里重要的是，我们希望确保DefaultEngine实现了引擎接口。如果是的话，我们应该可以马上在整个应用程序中使用它。这就是接口的美妙之处，只要我们匹配它们中定义的API，我们就可以非常容易地用新的逻辑将它们切换进来和切换出去。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">这是我用过的旧的发布/订阅引擎，它是硬编码的，很难在不破坏东西的情况下改变。</figcaption></figure><p id="0c24" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，替换旧引擎中的所有代码，而不是确保实现接口是简单的<strong class="la iu">，我们只是添加一个简单的结构，并使所有方法成为结构</strong>的一部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">向DefaultEngine结构添加方法接收器，使其成为引擎接口的一部分</figcaption></figure><p id="c9a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦我改变了这个。我现在可以运行所有go4数据包的测试了，希望不会出什么问题。</p><p id="4b2b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请记住，这是可能的，因为其他包依赖于发布/订阅包来公开引擎接口中的3个方法。这些方法做什么并不重要，只要它们符合设计模式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/1541e35656f903dbbb0bc312e5a6a223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yzHAq-nmTE5QuIKAEZQeAg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">当重新运行测试时，没有测试失败，因为它们都使用看起来相同的pubsub包公开的方法。</figcaption></figure><p id="cac0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很好，现在我们知道了使用公开的方法来包装我们的引擎是可行的。我们可以开始实现Redis引擎。</p><h2 id="7d10" class="lx ly it bd lz ma mb dn mc md me dp mf lh mg mh mi ll mj mk ml lp mm mn mo mp bi translated">实现RedisEngine</h2><p id="799e" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">现在下一步是创建一个实现引擎接口的新结构。这个将有一个名为<strong class="la iu">的helper函数，带有RedisEngine </strong>，它将引擎变量更改为Redis连接，而不是DefaultEngine。</p><p id="fbef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你不熟悉Redis，你可以在这里阅读我写的关于把它用作<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/redis-as-a-pub-sub-engine-in-go-10eb5e6699cc">酒馆/订阅的文章。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Redis的简单实现，而不是定制的发布/订阅</figcaption></figure><p id="1eb2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这只是128行代码来代替整个项目的整个发布/订阅引擎，非常好！</p><p id="abd0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，由于我们正在使用一个接口来做这件事，如果我们想尝试其他引擎，可能是Kafka或RabbitMQ，我们可以很容易地继续添加Pub/Sub引擎。</p><p id="c363" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你会问，我们为什么要添加其他人？<strong class="la iu">因为它非常有趣！</strong></p><p id="7edc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们有了两个实现，我们也可以对它们进行基准测试。</p><h2 id="b317" class="lx ly it bd lz ma mb dn mc md me dp mf lh mg mh mi ll mj mk ml lp mm mn mo mp bi translated">基准</h2><p id="c02f" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">标杆管理可能很难。限制它们，让你只测试你想测试的东西可能会很难。我真的不擅长，但我会尽力而为。我们想要删除将要推送的对象的初始化，因为这不是我们想要测试的，所以我将把它放在init函数中，在测试之前运行。我们希望测试发布所需的时间，以及发布到订阅者拥有所有项目所需的时间。</p><p id="9f7d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">引擎将在启动时用Go4Data创建，所以我们也将引擎的连接和初始化放在init中。它们的性能并不重要，因为它们是在启动时运行的，所以让我们把重点放在运行时性能上。</p><p id="5a2a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在运行我的基准测试之前，我需要设置一个Redis实例来使用。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="f5e3" class="lx ly it mx b gy nb nc l nd ne">sudo docker run --name redis -p 6379:6379 -d redis</span></pre><p id="52fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，这里的想法是，我们想首先尝试基准测试我们可以多快地发布数据，因此一个基准测试将只使用两个引擎，并发布N个项目。我将使用100、1000和100000作为我的基准来查看低额和高额。这些基准将被命名为BenchmarkEnginePubXAmount。</p><p id="8b4a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我也将有一个基准，将测试发布和等待订阅者收到所有发布的项目。这些基准将被命名为<br/>benchmarkinginesubxamount。</p><p id="a59f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Go中，您可以设置基准运行的次数，并获取这些次数的平均值。在我的例子中，我将坚持每个基准运行一次，这是因为Redis似乎不喜欢被高速上下的连接运行。这是通过添加标志-benchtime=1x来实现的。</p><p id="d7a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是基准测试的样子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">发布和发布/订阅的基准功能的结果。</figcaption></figure><p id="db8d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如你所看到的，Go中的基准测试相当容易，编写好的基准测试很难，我仍在努力学习。我们可以使用<strong class="la iu"> go test -bench </strong>命令简单地运行这个基准测试。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/00dddbe6ca53283b58cd45578fde00cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*eDAwglvbSsCW2g9QVE6VUA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">基准测试结果来自DefaultEngine和RedisEngine。</figcaption></figure><p id="7f84" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基准测试的输出首先显示名称、运行的基准测试数量以及每次操作的纳秒数(ns/op)。</p><p id="718b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如所料，DefaultEngine比Redis运行得更快。这是意料之中的，因为DefaultEngine运行在应用程序使用的内存中，所以它可以直接访问。Redis的优势在于它提供了持久性和跨多个节点运行Go4Data的能力。</p><p id="9577" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在用户可以很容易地替换项目的大部分，因为我们利用了界面的力量。</p><p id="8634" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这次到此为止。感谢您的阅读！</p></div></div>    
</body>
</html>