<html>
<head>
<title>Using SQLite in Expo for Offline React Native Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在博览会中使用SQLite进行离线反应本地应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/using-sqlite-in-expo-for-offline-react-native-apps-a408d30458c3?source=collection_archive---------0-----------------------#2020-02-24">https://itnext.io/using-sqlite-in-expo-for-offline-react-native-apps-a408d30458c3?source=collection_archive---------0-----------------------#2020-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/09ef437497c733f4d5a94d7e5c65f1fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*3o8TOSojT64ChGpjop0USA.png"/></div></figure><div class=""/><p id="eeac" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">决定一个应用程序是否“感觉”本土的最大因素之一是它的速度。很多让应用感觉快速的方法都是优化关键的热门代码路径和拥有正确的动画，但是对于大多数应用来说，至少会有一些部分涉及读写数据。</p><p id="a070" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">虽然用户完全离线变得越来越罕见，但尤其是移动用户，网络连接不良仍然很常见。如果你想让你的应用在网络慢的时候感觉很快，你至少需要让你的应用的某些方面脱机工作。</p><p id="28b0" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">就本文而言，我假设您正在使用<a class="ae kv" href="https://expo.io/" rel="noopener ugc nofollow" target="_blank">世博会</a>。如果你不熟悉Expo，这是一个使用react-native为iOS和Android构建本地应用程序的好方法。它基本上让您免去了为构建本机应用程序而设置环境的所有麻烦，并让您可以直接编写JavaScript/TypeScript。</p><p id="18c7" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，您的应用程序需要存储数据，但也需要(至少部分)脱机工作。这意味着您需要一种在本地存储一些数据的方法。如果您想避免编译本机模块(并离开expo生态系统)，您有3个基本选项:</p><ol class=""><li id="95b3" class="kw kx ja jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated">SecureStore</li><li id="d669" class="kw kx ja jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">AsyncStorage</li><li id="bc42" class="kw kx ja jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">SQLite</li></ol><h1 id="4217" class="lk ll ja bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">安全商店</h1><blockquote class="mi"><p id="4cc3" class="mj mk ja bd ml mm mn mo mp mq mr ku dk translated">expo-secure-store提供了一种在设备本地加密和安全存储密钥-值对的方法</p></blockquote><p id="1d23" class="pw-post-body-paragraph jx jy ja jz b ka ms kc kd ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku im bi translated">如果你需要储存任何秘密钥匙。例如您的API的用户认证令牌，安全存储是唯一明智的选择。这是确保静态数据加密的唯一选择，但也只适用于相当少量的数据。如果您需要加密大量数据，您可以在SecureStore中存储和加密密钥。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="a3f4" class="ng ll ja nc b gy nh ni l nj nk"><strong class="nc jb">import</strong> * <strong class="nc jb">as</strong> SecureStore <strong class="nc jb">from</strong> 'expo-secure-store';</span><span id="4443" class="ng ll ja nc b gy nl ni l nj nk"><strong class="nc jb">await</strong> SecureStore.setItemAsync('token', 'my-token-value');</span><span id="8e25" class="ng ll ja nc b gy nl ni l nj nk"><strong class="nc jb">const </strong>myToken = <strong class="nc jb">await</strong> SecureStore.getItemAsync('token');</span></pre><p id="8d8b" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">根据我在iOS上的经验，如果你的应用程序请求令牌时设备还没有完全解锁，这可能会引发异常。因此，围绕<code class="fe nm nn no nc b">getItemAsync</code>方法增加一次快速重试可能是值得的。如果你想做出不同的安全权衡，你可以选择iOS上的<code class="fe nm nn no nc b">keychainAccessible</code>选项，但是默认是合理的。</p><h1 id="0c8d" class="lk ll ja bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">异步存储</h1><blockquote class="mi"><p id="608c" class="mj mk ja bd ml mm mn mo mp mq mr ku dk translated">AsyncStorage是一个未加密、异步、持久的键值存储系统，对应用程序来说是全局的。</p></blockquote><p id="c3d9" class="pw-post-body-paragraph jx jy ja jz b ka ms kc kd ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku im bi translated">如果您已经在网络上使用了本地存储，异步存储会感觉非常相似。这对于存储相当少量的数据，甚至相当大量的数据非常有用，只要您不需要任何聪明的查询方法。它非常适合存储应用程序的当前导航状态，或者用户将要添加的帖子的草稿。这对于像目前游戏中的高分这样的事情也很有用。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="5990" class="ng ll ja nc b gy nh ni l nj nk"><strong class="nc jb">import</strong> { AsyncStorage } <strong class="nc jb">from</strong> 'react-native';</span><span id="da10" class="ng ll ja nc b gy nl ni l nj nk"><strong class="nc jb">await</strong> AsyncStorage.setItem('token', 'my-token-value');</span><span id="243b" class="ng ll ja nc b gy nl ni l nj nk"><strong class="nc jb">const </strong>myToken = <strong class="nc jb">await</strong> AsyncStorage.getItem('token');</span></pre><p id="f705" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注意，如果您想要存储复杂的JSON对象，您将需要使用<code class="fe nm nn no nc b">JSON.stringify</code>和<code class="fe nm nn no nc b">JSON.parse</code>。这些数据在静态时也没有加密。</p><h1 id="b1ff" class="lk ll ja bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">SQLite</h1><blockquote class="mi"><p id="d2c6" class="mj mk ja bd ml mm mn mo mp mq mr ku dk translated"><a class="ae kv" href="https://www.atdatabases.org/docs/websql" rel="noopener ugc nofollow" target="_blank"> @databases/expo </a>提供了一个SQL数据库，它可以在应用程序重启后保持不变，并支持事务以及高级过滤和查询。</p></blockquote><p id="af01" class="pw-post-body-paragraph jx jy ja jz b ka ms kc kd ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku im bi translated"><a class="ae kv" href="https://docs.expo.io/versions/v36.0.0/sdk/sqlite/" rel="noopener ugc nofollow" target="_blank"> expo-sqlite </a>模块提供了一个基于WebSQL接口的SQL数据库。这非常强大，支持SQLite的几乎所有特性。SQLite也非常适合有离线需求的应用程序。它可以让你在磁盘上存储大量的结构化数据，并把显示当前屏幕所需的部分只读到内存中。</p><p id="f545" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">不幸的是，虽然SQLite有一个不错的API，但WebSQL API太差了，最终被放弃作为web的标准。幸运的是<code class="fe nm nn no nc b"><a class="ae kv" href="https://www.atdatabases.org/docs/websql" rel="noopener ugc nofollow" target="_blank">@databases/expo</a></code>将WebSQL API包装成更有用的东西。</p><p id="2717" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">首先，您需要“连接”到您的数据库:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="b00c" class="ng ll ja nc b gy nh ni l nj nk"><strong class="nc jb">import</strong> connect, {sql} <strong class="nc jb">from</strong> '@databases/expo';</span><span id="81dc" class="ng ll ja nc b gy nl ni l nj nk"><strong class="nc jb">const</strong> db = connect('my-database');</span></pre><p id="f5e6" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您的应用程序可以有多个不同名称的数据库。您不需要显式地创建数据库，如果它不存在，系统会自动为您创建。</p><p id="4666" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe nm nn no nc b"><a class="ae kv" href="https://www.atdatabases.org/docs/websql" rel="noopener ugc nofollow" target="_blank">@databases/expo</a></code>中的交易使用生成器函数。由于expo/websql公开的API的限制，它们不能使用异步函数。这实际上意味着，在一个事务中，你使用<code class="fe nm nn no nc b">function*</code>而不是<code class="fe nm nn no nc b">async function</code>，使用<code class="fe nm nn no nc b">yield</code>而不是<code class="fe nm nn no nc b">await</code>。您也不能在事务中执行任何其他异步操作。</p><p id="8e85" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您要做的第一件事是创建一些表。对数据库模式进行版本化是一个好主意，这样您就可以随时升级到最新版本。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="07c2" class="ng ll ja nc b gy nh ni l nj nk"><strong class="nc jb">const</strong> ready = db.tx(<strong class="nc jb">function</strong>* (tx) {<br/>  <strong class="nc jb">yield</strong> tx.query(sql`<br/>    <strong class="nc jb">CREATE</strong> <strong class="nc jb">TABLE</strong> <strong class="nc jb">IF</strong> <strong class="nc jb">NOT EXISTS</strong> schema_version (<br/>      version <strong class="nc jb">INT</strong> <strong class="nc jb">NOT</strong> <strong class="nc jb">NULL</strong><br/>    );<br/>  `);<br/>  <strong class="nc jb">const</strong> versionRecord = <strong class="nc jb">yield</strong> tx.query(sql`<br/>    <strong class="nc jb">SELECT</strong> version <strong class="nc jb">FROM</strong> schema_version;<br/>  `);<br/>  <strong class="nc jb">const </strong>version = (<br/>    versionRecord.length<br/>      ? versionRecord[0].version<br/>      : 0<br/>  );<br/>  <strong class="nc jb">if</strong> (version &lt; 1) {<br/>    <strong class="nc jb">yield</strong> tx.query(sql`<br/>      <strong class="nc jb">CREATE</strong> <strong class="nc jb">TABLE</strong> tasks (<br/>        id <strong class="nc jb">TEXT NOT NULL PRIMARY KEY</strong>,<br/>        name <strong class="nc jb">TEXT NOT NULL</strong>,<br/>        completed <strong class="nc jb">BOOLEAN NOT NULL</strong><br/>      );<br/>    `);<br/>  }<br/>  // to add other versions in the future,<br/>  // we can just add extra if statements<br/>  // and increase LATEST_VERSION<br/>  <strong class="nc jb">const</strong> LATEST_VERSION = 1;<br/>  <strong class="nc jb">if</strong> (version === 0) {<br/>    <strong class="nc jb">yield</strong> tx.query(sql`<br/>      <strong class="nc jb">INSERT</strong> <strong class="nc jb">INTO</strong> schema_version<br/>      <strong class="nc jb">VALUES</strong> (${LATEST_VERSION});<br/>    `);<br/>  } <strong class="nc jb">else</strong> {<br/>    <strong class="nc jb">yield</strong> tx.query(sql`<br/>      <strong class="nc jb">UPDATE </strong>schema_version<br/>      <strong class="nc jb">SET</strong> version = ${LATEST_VERSION};<br/>    `);<br/>  }<br/>});</span></pre><p id="2321" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后，我们可以公开一个简单的API来读写数据库中的TODOs。<a class="ae kv" href="https://www.atdatabases.org/docs/websql" rel="noopener ugc nofollow" target="_blank"> @databases/expo </a>会隐式地为我们创建事务，只要我们调用<code class="fe nm nn no nc b">db.query</code></p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="c191" class="ng ll ja nc b gy nh ni l nj nk"><strong class="nc jb">async function</strong> setTodo(id, name, completed) {<br/>  <strong class="nc jb">await</strong> db.query(sql`<br/>    <strong class="nc jb">INSERT INTO</strong> tasks (id, name, completed)<br/>    <strong class="nc jb">VALUES</strong> (${id}, ${name}, ${completed})<br/>    <strong class="nc jb">ON CONFLICT</strong> (id) <strong class="nc jb">DO UPDATE</strong><br/>    <strong class="nc jb">SET</strong> name=excluded.name, completed=excluded.completed;<br/>  `);<br/>}</span><span id="ffb9" class="ng ll ja nc b gy nl ni l nj nk"><strong class="nc jb">async function</strong> getTodo(id) {<br/>  <strong class="nc jb">return </strong>(<strong class="nc jb">await</strong> db.query(sql`<br/>    <strong class="nc jb">SELECT</strong> * <strong class="nc jb">FROM</strong> tasks <strong class="nc jb">WHERE</strong> id=${id};<br/>  `))[0] || <strong class="nc jb">undefined</strong>;<br/>}</span></pre><p id="e47e" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注意,“completed”字段将作为<code class="fe nm nn no nc b">0</code>或<code class="fe nm nn no nc b">1</code>返回，因为在存储层，SQLite并不真正区分数字和布尔值。</p><p id="470b" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这一点上，看起来我们有了与AsyncStorage非常相似的东西(即一个简单的键值存储)，但是现在可以编写更高级的查询，因为我们拥有SQL的全部功能。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="3e69" class="ng ll ja nc b gy nh ni l nj nk"><strong class="nc jb">async function</strong> getUnfinishedTodos() {<br/>  <strong class="nc jb">return await</strong> db.query(sql`<br/>    <strong class="nc jb">SELECT</strong> * <strong class="nc jb">FROM</strong> tasks <strong class="nc jb">WHERE</strong> completed=false;<br/>  `);<br/>}</span></pre><h1 id="0eec" class="lk ll ja bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">结论</h1><ul class=""><li id="f2a6" class="kw kx ja jz b ka np ke nq ki nr km ns kq nt ku nu lc ld le bi translated">使用<code class="fe nm nn no nc b"><a class="ae kv" href="https://docs.expo.io/versions/v36.0.0/sdk/securestore/" rel="noopener ugc nofollow" target="_blank">SecureStore</a></code>存储API密钥和加密密钥，因为它经过适当加密，并且在手机锁定时无法从备份/访问。</li><li id="c2c8" class="kw kx ja jz b ka lf ke lg ki lh km li kq lj ku nu lc ld le bi translated">将<code class="fe nm nn no nc b"><a class="ae kv" href="https://docs.expo.io/versions/v36.0.0/react-native/asyncstorage/" rel="noopener ugc nofollow" target="_blank">AsyncStorage</a></code>用于JSON/text的简单blobs。</li><li id="b3b3" class="kw kx ja jz b ka lf ke lg ki lh km li kq lj ku nu lc ld le bi translated">当你需要能够查询你的数据时，使用<code class="fe nm nn no nc b"><a class="ae kv" href="https://www.atdatabases.org/docs/websql" rel="noopener ugc nofollow" target="_blank">@databases/expo</a></code>。(如果你愿意，你可以直接使用<a class="ae kv" href="https://docs.expo.io/versions/v36.0.0/sdk/sqlite/" rel="noopener ugc nofollow" target="_blank"> expo API </a>，但是很难保证它可靠地工作)</li></ul><figure class="mx my mz na gt iv"><div class="bz fp l di"><div class="nv nw l"/></div></figure></div></div>    
</body>
</html>