<html>
<head>
<title>Handling null: optional and nullable types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理null:可选类型和可空类型</h1>
<blockquote>原文：<a href="https://itnext.io/optional-and-nullable-type-b0e58338aeec?source=collection_archive---------3-----------------------#2022-04-03">https://itnext.io/optional-and-nullable-type-b0e58338aeec?source=collection_archive---------3-----------------------#2022-04-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b3bf3bf593a5f485f72676291f571f99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Wxq5T_JQBpODNIk2ZI2Yg.jpeg"/></div></div></figure><p id="d637" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Java一直因其<code class="fe kw kx ky kz b">NullPointerException</code>而声名狼藉。NPE的原因是调用方法或访问尚未初始化的<strong class="ka ir">对象的属性</strong>。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="0054" class="li lj iq kz b gy lk ll l lm ln">var value = foo.getBar().getBaz().toLowerCase();</span></pre><p id="5ae6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行此代码片段可能会产生如下结果:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="1d0a" class="li lj iq kz b gy lk ll l lm ln">Exception in thread "main" java.lang.NullPointerException<br/>  at ch.frankel.blog.NpeSample.main(NpeSample.java:10)</span></pre><p id="041c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，您还不知道调用链中的<code class="fe kw kx ky kz b">null</code>是哪个部分:<code class="fe kw kx ky kz b">foo</code>，还是<code class="fe kw kx ky kz b">getBar()</code>或<code class="fe kw kx ky kz b">getBaz()</code>返回的值？</p><p id="6562" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在JVM的最新版本中，语言设计者改善了这种情况。在JVM 14上，您可以用<code class="fe kw kx ky kz b">-XX:+ShowCodeDetailsInExceptionMessages</code>标志激活“有用的”npe。运行相同的代码片段显示哪个部分是<code class="fe kw kx ky kz b">null</code>:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="e814" class="li lj iq kz b gy lk ll l lm ln">Exception in thread "main" java.lang.NullPointerException: <br/>  Cannot invoke "String.toLowerCase()" because the return value of <br/>"ch.frankel.blog.Bar.getBaz()" is null<br/>  at  ch.frankel.blog.NpeSample.main(NpeSample.java:10)</span></pre><p id="8d60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在JVM 15上，它成为默认行为:您不需要特定的标志。</p><h1 id="29d6" class="lo lj iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">处理NullPointerException</h1><p id="85b7" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">在上面的代码片段中，开发人员假设每个部分都已经初始化。显示<code class="fe kw kx ky kz b">null</code>部分有助于调试和揭穿错误的假设。然而，这并没有解决根本原因:我们需要以某种方式处理<code class="fe kw kx ky kz b">null</code>值。</p><p id="680f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我们需要求助于防御性编程:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="b8d7" class="li lj iq kz b gy lk ll l lm ln">String value = null;<br/>if (foo != null) {<br/>    var bar = foo.getBar();<br/>    if (bar != null) {<br/>        baz = bar.getBaz()<br/>        if (baz != null) {<br/>            value = baz.toLowerCase();<br/>        }<br/>    }<br/>}</span></pre><p id="f63b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它修复了问题，但远非最佳开发人员体验——至少可以这么说:</p><ol class=""><li id="adba" class="mq mr iq ka b kb kc kf kg kj ms kn mt kr mu kv mv mw mx my bi translated">开发人员需要小心他们的编码实践</li><li id="0d01" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">这种模式使得代码更难阅读。</li></ol><h1 id="dbcf" class="lo lj iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">选项包装类型</h1><p id="d8c5" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">在JVM上，Scala的<code class="fe kw kx ky kz b">Option</code>是我所知的第一次尝试sane的<code class="fe kw kx ky kz b">null</code>处理方法，即使这个概念已经融入了函数式编程的基础。<code class="fe kw kx ky kz b">Option</code>背后的概念确实很简单:它是一个包装器，包装一个可能是<code class="fe kw kx ky kz b">null</code>的值。</p><p id="e9eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以在包装器内部的对象上调用类型相关的方法，包装器将充当过滤器。因为<code class="fe kw kx ky kz b">Option</code>有它的方法，我们需要一个作用于包装类型的传递函数:这个函数在Scala中被称为<code class="fe kw kx ky kz b">map()</code>(在其他几种语言中也是如此)。它在代码中翻译为:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="45b1" class="li lj iq kz b gy lk ll l lm ln">def map[B](f: A =&gt; B): Option[B] = if (isEmpty) None else Some(f(this.get))</span></pre><p id="5794" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果包装器为空，<em class="ne">即</em>包含一个<code class="fe kw kx ky kz b">null</code>值，则返回一个空包装器；如果不是，调用底层值上的传递函数并返回包装结果的包装器。</p><p id="e32a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从Java 8开始，JDK提供了一个名为<code class="fe kw kx ky kz b">Optional</code>的包装器类型。有了它，我们可以将上面的空检查代码重写为:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="8cf0" class="li lj iq kz b gy lk ll l lm ln">var option = Optional.ofNullable(foo)<br/>    .map(Foo::getBar)<br/>    .map(Bar::getBaz)<br/>    .map(String::toLowerCase);</span></pre><p id="838b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果调用链中的任何一个值是<code class="fe kw kx ky kz b">null</code>，那么<code class="fe kw kx ky kz b">option</code>就是<code class="fe kw kx ky kz b">null</code>。否则，它返回计算值。无论如何，非公有制经济已经不复存在了。</p><h1 id="51c3" class="lo lj iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">可空类型</h1><p id="fb96" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">不考虑语言，选项类型的主要问题是它的先有鸡还是先有蛋的特性。要使用一个<em class="ne">选项</em>，你首先需要确定它不是<code class="fe kw kx ky kz b">null</code>。考虑以下方法:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="1d54" class="li lj iq kz b gy lk ll l lm ln">void print(Optional&lt;String&gt; optional) {<br/>    optional.ifPresent(str -&gt; System.out.println(str));<br/>}</span></pre><p id="e741" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们执行这段代码会发生什么？</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="78a3" class="li lj iq kz b gy lk ll l lm ln">Optional&lt;String&gt; optional = null;<br/>print(optional);                       // 1</span></pre><ol class=""><li id="ab83" class="mq mr iq ka b kb kc kf kg kj ms kn mt kr mu kv mv mw mx my bi translated">哎呀，回到我们熟悉的NPE</li></ol><p id="e192" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，迷恋于<em class="ne">选项</em>类型的开发人员会告诉你这不应该发生，你不应该这样写代码，等等。这可能是准确的，但不幸的是，这并不能解决问题。为了100%避免npe，我们需要回到防御性编程:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="2fc7" class="li lj iq kz b gy lk ll l lm ln">void print(Optional&lt;String&gt; optional) {<br/>    if (optional != null) {<br/>        optional.ifPresent(str -&gt; System.out.println(str));<br/>    }<br/>}</span></pre><p id="326f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kotlin选择了另一条路线，使用了<strong class="ka ir">可空</strong>类型及其对应的非可空类型。在科特林，每种类型的<code class="fe kw kx ky kz b">T</code>都有两种口味，尾随的<code class="fe kw kx ky kz b">?</code>暗示它可以是<code class="fe kw kx ky kz b">null</code>。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="69b1" class="li lj iq kz b gy lk ll l lm ln">var nullable: String?          // 1<br/>var nonNullable: String        // 2</span></pre><ol class=""><li id="87af" class="mq mr iq ka b kb kc kf kg kj ms kn mt kr mu kv mv mw mx my bi translated"><code class="fe kw kx ky kz b">nullable</code>可以是<code class="fe kw kx ky kz b">null</code></li><li id="2883" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated"><code class="fe kw kx ky kz b">nonNullable</code>不能</li></ol><p id="ea5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kotlin编译器知道这一点，并阻止您直接调用引用上的函数，该引用可能是<code class="fe kw kx ky kz b">null</code>。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="9e2a" class="li lj iq kz b gy lk ll l lm ln">val nullable: String? = "FooBar"<br/>nullable.toLowerCase()</span></pre><p id="552c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码片段在<em class="ne">编译时</em>抛出异常，因为编译器无法断言<code class="fe kw kx ky kz b">nullable</code>不是<code class="fe kw kx ky kz b">null</code>:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="0a6e" class="li lj iq kz b gy lk ll l lm ln">Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type String?</span></pre><p id="a70e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">空安全操作符<em class="ne">即</em>、<code class="fe kw kx ky kz b">?.</code>与<code class="fe kw kx ky kz b">map</code>非常相似:如果对象是<code class="fe kw kx ky kz b">null</code>，停止并保持<code class="fe kw kx ky kz b">null</code>；如果没有，继续函数调用。让我们将代码迁移到Kotlin，用一个空的安全调用替换<code class="fe kw kx ky kz b">Optional</code>:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="230c" class="li lj iq kz b gy lk ll l lm ln">val value = foo?.bar?.baz?.lowercase()</span></pre><h1 id="d2f0" class="lo lj iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">选项还是可空类型？</h1><p id="d8b0" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">如果你正在使用一种编译器不强制空安全的语言，你别无选择。这个问题只在这样的语言范围内提出，<em class="ne">如</em>，科特林。Kotlin的标准库不提供选项类型。然而，<a class="ae nf" href="https://arrow-kt.io/docs/apidocs/arrow-core/arrow.core/-option/" rel="noopener ugc nofollow" target="_blank">箭头</a>库可以。或者，你仍然可以使用Java的<code class="fe kw kx ky kz b">Optional</code>。</p><p id="e1a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是问题仍然存在:如果可以选择，您应该使用可选类型还是可空类型？第一种选择更详细一些:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="7935" class="li lj iq kz b gy lk ll l lm ln">val optional: Foo? = Optional.ofNullable(foo)   // 1<br/>                             .map(Foo::bar)<br/>                             .map(Bar::baz)<br/>                             .map(String::lowercase)<br/>                             .orElse(null)</span><span id="080b" class="li lj iq kz b gy ng ll l lm ln">val option = Some(foo).map(Foo::bar)            // 2<br/>                      .map(Bar::baz)<br/>                      .map(String::lowercase)<br/>                      .orNull()</span></pre><ol class=""><li id="782f" class="mq mr iq ka b kb kc kf kg kj ms kn mt kr mu kv mv mw mx my bi translated">Java API返回平台类型；您需要设置正确的类型，该类型可以为空</li><li id="bf70" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">箭头正确地推断出可空的<code class="fe kw kx ky kz b">Foo?</code>类型</li></ol><p id="a31b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了推断正确的类型，Arrow的<code class="fe kw kx ky kz b">Option</code>还提供:</p><ul class=""><li id="fb19" class="mq mr iq ka b kb kc kf kg kj ms kn mt kr mu kv nh mw mx my bi translated">上面看到的<code class="fe kw kx ky kz b">map()</code>功能</li><li id="3261" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv nh mw mx my bi translated">传统上与单子相关的其他标准函数，<em class="ne">，例如</em>、<code class="fe kw kx ky kz b">flatMap()</code>和<code class="fe kw kx ky kz b">fold()</code></li><li id="fb80" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv nh mw mx my bi translated">附加功能</li></ul><figure class="la lb lc ld gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/b2e68953b6939b02656302149a73af02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*Xnb2-MTvmhRYJkcJ-4XBlA.png"/></div></figure><p id="6483" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，<code class="fe kw kx ky kz b">fold()</code>允许提供两个lambdas，一个在<code class="fe kw kx ky kz b">Option</code>为<code class="fe kw kx ky kz b">Some</code>时运行，另一个在<code class="fe kw kx ky kz b">None</code>时运行:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="48d2" class="li lj iq kz b gy lk ll l lm ln">val option = Some(foo).map(Foo::bar)<br/>                      .map(Bar::baz)<br/>                      .map(String::lowercase)<br/>                      .fold(<br/>                        { println("Nothing to print") },<br/>                        { println("Result is $it") }<br/>                      )</span></pre><h1 id="244c" class="lo lj iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">结论</h1><p id="c2c5" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">如果<code class="fe kw kx ky kz b">null</code>是一个百万美元的错误，现代工程实践和语言可以处理它。在Kotlin中发现的编译器强制空安全是一个很好的开始。然而，为了充分利用函数式编程的强大功能，我们需要一个符合FP标准的Option实现。在这种情况下，问题是强制传递的选项对象永远不要是<code class="fe kw kx ky kz b">null</code>。</p><p id="616f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kotlin的编译器在本地完成这项工作，而Arrow库提供了一个选项实现来满足FP程序员的需求。</p><p id="eb7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更进一步:</strong></p><ul class=""><li id="6efb" class="mq mr iq ka b kb kc kf kg kj ms kn mt kr mu kv nh mw mx my bi translated"><a class="ae nf" href="https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" rel="noopener ugc nofollow" target="_blank">图片中的函子、应用程序和单子</a></li><li id="7731" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv nh mw mx my bi translated"><a class="ae nf" href="https://kotlinlang.org/docs/null-safety.html" rel="noopener ugc nofollow" target="_blank">科特林的零安全</a></li><li id="31d4" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv nh mw mx my bi translated"><a class="ae nf" href="https://stackoverflow.com/questions/48895103/why-use-arrows-options-instead-of-kotlin-nullable" rel="noopener ugc nofollow" target="_blank">为什么使用Arrow的选项而不是Kotlin nullable </a></li></ul></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="ab81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ne">原载于</em> <a class="ae nf" href="https://blog.frankel.ch/optional-nullable-type/" rel="noopener ugc nofollow" target="_blank"> <em class="ne">一个Java怪胎</em></a><em class="ne">2022年4月2日</em></p></div></div>    
</body>
</html>