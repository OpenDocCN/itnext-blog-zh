<html>
<head>
<title>TypeScript web workers with angular-cli 6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用angular-cli 6键入脚本web workers</h1>
<blockquote>原文：<a href="https://itnext.io/typescript-web-workers-with-angular-cli-6-19129b299d69?source=collection_archive---------2-----------------------#2019-05-02">https://itnext.io/typescript-web-workers-with-angular-cli-6-19129b299d69?source=collection_archive---------2-----------------------#2019-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/1ff6395cea6616f792294969c1bc8f55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*BNEmDvpvp-Lc7Cq-SwLGZQ.png"/></div></figure><h1 id="da3e" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">在没有自定义webpack配置的情况下，如何在你的Angular应用中使用用TypeScript编写的web workers？</h1><p id="05bd" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在重构Angular 6应用程序时，需要将普通的旧Javascript web workers迁移到TypeScript。经过一些研究，在撰写本文时，发现没有简单的方法可以用angular-cli做到这一点。</p><blockquote class="lq lr ls"><p id="239a" class="ks kt lt ku b kv lu kx ky kz lv lb lc lw lx lf lg ly lz lj lk ma mb ln lo lp ij bi translated">注意:angular-cli计划在版本8中为web workers提供一些更好的支持</p></blockquote><p id="445e" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">TypeScript web workers需要angular-cli之外的大量webpack配置，如本文<a class="ae mc" href="https://medium.com/@suresh.patidar/running-web-worker-in-angular-6-application-a-step-by-step-guide-74e88c566ba4" rel="noopener"><strong class="ku ir"><em class="lt"/></strong></a>中所述。</p><p id="cc05" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">这是行不通的，因为先决条件是保持原生的angular-cli支持。但愿，正如在<a class="ae mc" href="https://medium.com/@damoresac/using-web-workers-on-angular-6-6fd0490d07b5" rel="noopener"> <strong class="ku ir"> <em class="lt">这篇精彩的故事</em> </strong> </a> <strong class="ku ir"> <em class="lt">，</em> </strong>中发现的那样，通过一些技巧，似乎有可能在没有外部webpack配置的情况下运行一个TypeScript web worker。</p><p id="eb77" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">链接的文章展示了一个具有独特的自包含函数的用例，并且在初始调用之后没有从主线程到工作线程的通信。</p><p id="ebd4" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">对于一个更复杂的用例来说，将worker逻辑分成几个TypeScript文件和双向通信并不完全简单，所以我决定在这里分享一下。</p><blockquote class="lq lr ls"><p id="6dbc" class="ks kt lt ku b kv lu kx ky kz lv lb lc lw lx lf lg ly lz lj lk ma mb ln lo lp ij bi translated">本文引用的例子的完整来源可以在这里找到:<a class="ae mc" href="https://github.com/fleureyf/angular-web-workers" rel="noopener ugc nofollow" target="_blank">https://github.com/fleureyf/angular-web-workers</a></p></blockquote><div class="md me gp gr mf mg"><a href="https://stackblitz.com/github/fleureyf/angular-web-workers" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd ir gy z fp ml fr fs mm fu fw ip bi translated">棱角分明的网络工作者</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">TypeScript Angular web worker的演示应用程序</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">stackblitz.com</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu js mg"/></div></div></a></div></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="5f23" class="ju jv iq bd jw jx nc jz ka kb nd kd ke kf ne kh ki kj nf kl km kn ng kp kq kr bi translated">本文的范围</h1><p id="1ee1" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这篇文章和链接的源代码提供了一个逻辑简化的代码，但仍然是一个完整的用例:</p><ul class=""><li id="b2c4" class="nh ni iq ku b kv lu kz lv ld nj lh nk ll nl lp nm nn no np bi translated">可能使用外部Javascript依赖项</li><li id="5342" class="nh ni iq ku b kv nq kz nr ld ns lh nt ll nu lp nm nn no np bi translated">主线程和工作线程之间完全双向通信</li><li id="fd36" class="nh ni iq ku b kv nq kz nr ld ns lh nt ll nu lp nm nn no np bi translated">Typescript worker实现拆分为单独文件中的几个Typescript类。</li></ul><h1 id="f9a3" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">目录</h1><ul class=""><li id="3fca" class="nh ni iq ku b kv kw kz la ld nv lh nw ll nx lp nm nn no np bi translated"><a class="ae mc" href="https://medium.com/p/19129b299d69#19ee" rel="noopener"> <strong class="ku ir">主线程和工作线程之间的接口</strong> </a></li><li id="0dab" class="nh ni iq ku b kv nq kz nr ld ns lh nt ll nu lp nm nn no np bi translated"><a class="ae mc" href="https://medium.com/p/19129b299d69#d5bc" rel="noopener"> <strong class="ku ir">一个简单的工人</strong> </a></li><li id="2460" class="nh ni iq ku b kv nq kz nr ld ns lh nt ll nu lp nm nn no np bi translated"><a class="ae mc" href="https://medium.com/p/19129b299d69#3d74" rel="noopener"> —工人行动</a></li><li id="69aa" class="nh ni iq ku b kv nq kz nr ld ns lh nt ll nu lp nm nn no np bi translated"><a class="ae mc" href="https://medium.com/p/19129b299d69#9b6a" rel="noopener"> —外部脚本导入</a></li><li id="843f" class="nh ni iq ku b kv nq kz nr ld ns lh nt ll nu lp nm nn no np bi translated"><a class="ae mc" href="https://medium.com/p/19129b299d69#a709" rel="noopener"> <strong class="ku ir">职工服务</strong> </a></li><li id="480d" class="nh ni iq ku b kv nq kz nr ld ns lh nt ll nu lp nm nn no np bi translated"><a class="ae mc" href="https://medium.com/p/19129b299d69#e6a5" rel="noopener"> —棘手的部分:工人对象URL创建</a></li><li id="d9b8" class="nh ni iq ku b kv nq kz nr ld ns lh nt ll nu lp nm nn no np bi translated"><a class="ae mc" href="https://medium.com/p/19129b299d69#9d16" rel="noopener"> —工人实例化</a></li><li id="c2bc" class="nh ni iq ku b kv nq kz nr ld ns lh nt ll nu lp nm nn no np bi translated"><a class="ae mc" href="https://medium.com/p/19129b299d69#9840" rel="noopener"> —向工人发送指令</a></li><li id="b573" class="nh ni iq ku b kv nq kz nr ld ns lh nt ll nu lp nm nn no np bi translated"><a class="ae mc" href="https://medium.com/p/19129b299d69#12d3" rel="noopener"> —接收来自工人的消息</a></li><li id="1e8f" class="nh ni iq ku b kv nq kz nr ld ns lh nt ll nu lp nm nn no np bi translated"><a class="ae mc" href="https://medium.com/p/19129b299d69#de54" rel="noopener"> —工人终止</a></li><li id="814f" class="nh ni iq ku b kv nq kz nr ld ns lh nt ll nu lp nm nn no np bi translated"><a class="ae mc" href="https://medium.com/p/19129b299d69#b826" rel="noopener"> <strong class="ku ir">用法</strong> </a></li><li id="5762" class="nh ni iq ku b kv nq kz nr ld ns lh nt ll nu lp nm nn no np bi translated"><a class="ae mc" href="https://medium.com/p/19129b299d69#7b03" rel="noopener"> <strong class="ku ir">附录</strong> </a></li><li id="2889" class="nh ni iq ku b kv nq kz nr ld ns lh nt ll nu lp nm nn no np bi translated"><a class="ae mc" href="https://medium.com/p/19129b299d69#fbe7" rel="noopener"> —在worker内部使用另一个TypeScript类</a></li><li id="1333" class="nh ni iq ku b kv nq kz nr ld ns lh nt ll nu lp nm nn no np bi translated"><a class="ae mc" href="https://medium.com/p/19129b299d69#8226" rel="noopener"> —限制</a></li></ul></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="19ee" class="ju jv iq bd jw jx nc jz ka kb nd kd ke kf ne kh ki kj nf kl km kn ng kp kq kr bi translated">主线程和工作线程之间的接口</h1><p id="f5b1" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们希望尽可能使用TypeScript来强制类型。我们首先定义一些接口，用于主线程(在我们的例子中是Angular应用程序)和工作线程之间的交换。</p><p id="a5c0" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">后台任务将包装我们希望在工作线程上执行的作业。后台任务消息将由工作线程发送回主线程，以监控状态和进度。</p><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><h1 id="d5bc" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">简单的工人</h1><p id="e7a8" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">让我们从编写一个简单的TypeScript worker开始，所有的逻辑都包含在一个类中。</p><h2 id="3d74" class="oe jv iq bd jw of og dn ka oh oi dp ke ld oj ok ki lh ol om km ll on oo kq op bi translated">工人行动</h2><p id="821a" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们继续利用TypeScript的优势，并实施工人所支持的动作的原型。</p><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="c32c" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">因此工人将实现这个接口并相应地管理它的状态。</p><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="b2d9" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">这里有一点需要注意:我们对所有的类方法都使用ES6胖箭头符号(所以不是方法而是函数)。这对于下面的<strong class="ku ir">很重要</strong>。</p><blockquote class="lq lr ls"><p id="ab86" class="ks kt lt ku b kv lu kx ky kz lv lb lc lw lx lf lg ly lz lj lk ma mb ln lo lp ij bi translated">注意:在编译时,“方法符号”将被添加到<code class="fe oq or os ot b">prototype</code>中，而“粗箭头”(或函数)符号将被添加为一个属性。或者我们将在后面讲述在我们的例子中不支持<code class="fe oq or os ot b">prototype</code>内容的<code class="fe oq or os ot b">toString()</code>函数。</p></blockquote><h2 id="9b6a" class="oe jv iq bd jw of og dn ka oh oi dp ke ld oj ok ki lh ol om km ll on oo kq op bi translated">外部脚本导入</h2><p id="6a93" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">workers中的一个基本需求是用本机<code class="fe oq or os ot b">importScripts</code>函数导入外部Javascript脚本。我们还将使用<code class="fe oq or os ot b">postMessage</code>函数将消息发送回主应用程序。我们可以声明这些类型，因为我们知道它们将在运行时可用。</p><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="b263" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">为了使用我们的架构，<code class="fe oq or os ot b">importScripts</code>参数必须是一个完整的URL，包括应用程序的基本位置(例如<code class="fe oq or os ot b">http://my.domain.org/assets/my_external_js_dependency.js</code>)</p><p id="0756" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">为了获得基位置，<em class="lt">和其他有用的参数，</em>在工人端，我们在构造函数中接受了一个<code class="fe oq or os ot b">WorkerConfig</code>对象。</p><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="723d" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">我们现在有了一个worker，它有一些我们想要调用的函数，这些函数可以发送回我们将从角度方面处理的消息。</p><h1 id="a709" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">工人服务</h1><p id="d2a2" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">Angular服务将负责所有工人管理，包括:</p><ul class=""><li id="ca32" class="nh ni iq ku b kv lu kz lv ld nj lh nk ll nl lp nm nn no np bi translated">工作者实例化</li><li id="0965" class="nh ni iq ku b kv nq kz nr ld ns lh nt ll nu lp nm nn no np bi translated">向工人发送指令</li><li id="b4e2" class="nh ni iq ku b kv nq kz nr ld ns lh nt ll nu lp nm nn no np bi translated">接收来自工人的消息</li><li id="db1c" class="nh ni iq ku b kv nq kz nr ld ns lh nt ll nu lp nm nn no np bi translated">职工解约</li></ul><h2 id="e6a5" class="oe jv iq bd jw of og dn ka oh oi dp ke ld oj ok ki lh ol om km ll on oo kq op bi translated">棘手的部分:worker对象URL的创建</h2><p id="3371" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">首先，我们创建一个包含worker负载的对象URL。这就是允许我们在没有构建配置的情况下使用TypeScript worker的诀窍。它利用了我们可以字符串化任何Javascript符号的事实。</p><blockquote class="lq lr ls"><p id="aa66" class="ks kt lt ku b kv lu kx ky kz lv lb lc lw lx lf lg ly lz lj lk ma mb ln lo lp ij bi translated">注意:这一步也导致了该方法的局限性</p></blockquote><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="9d6d" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">我们必须编写一些纯文本(不幸的是)来实例化我们的worker类并附加事件侦听器。</p><p id="c238" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">所以这不是最好的部分，但是记住我们要在worker构造函数中注入一些属性。我们必须在纯文本工人模板中这样做。</p><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="9d16" class="oe jv iq bd jw of og dn ka oh oi dp ke ld oj ok ki lh ol om km ll on oo kq op bi translated">工作者实例化</h2><p id="9d67" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">当一个任务开始时，一个新的worker被实例化，它的所有消息都将被传输到一个可观察对象，以便于在应用程序中进行最终消费。</p><blockquote class="lq lr ls"><p id="60f2" class="ks kt lt ku b kv lu kx ky kz lv lb lc lw lx lf lg ly lz lj lk ma mb ln lo lp ij bi translated">注意:为了简单起见，演示项目为每个任务生成一个worker，但是没有限制阻止在同一个worker上运行多个任务(有一些小的修改)。</p></blockquote><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="9840" class="oe jv iq bd jw of og dn ka oh oi dp ke ld oj ok ki lh ol om km ll on oo kq op bi translated">向工人发送指令</h2><p id="e949" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">让我们构建一个方法<code class="fe oq or os ot b">notify</code>来向工人发送指令。我们可以强制执行<code class="fe oq or os ot b">action</code>的类型。</p><p id="e588" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">当调用<code class="fe oq or os ot b">notify</code>时，在工作线程上执行一个<code class="fe oq or os ot b">postMessage</code>，我们注册的事件监听器将<code class="fe oq or os ot b">WorkerAction</code>映射到相应的工作函数。</p><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="12d3" class="oe jv iq bd jw of og dn ka oh oi dp ke ld oj ok ki lh ol om km ll on oo kq op bi translated">接收来自工人的消息</h2><p id="9585" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">为了方便使用，我们将把工人收到的所有消息包装在一个<code class="fe oq or os ot b">Observable</code>中。</p><p id="fb12" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">我们只需在worker上附加两个监听器<code class="fe oq or os ot b">message</code>和<code class="fe oq or os ot b">error</code>，并将事件数据发送给可观察对象。我们还将消息类型强制为<code class="fe oq or os ot b">BackgroundTaskMessage</code>。</p><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="0f23" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">一旦连接了监听器，就会将<code class="fe oq or os ot b">start</code>指令发送给工作者。</p><h2 id="de54" class="oe jv iq bd jw of og dn ka oh oi dp ke ld oj ok ki lh ol om km ll on oo kq op bi translated">职工解约</h2><p id="0320" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">当任务结束时，工作人员将发送一条状态为<code class="fe oq or os ot b">TERMINATED</code>的消息。当这个消息被接收时，可观察性被完成并且工作者被终止。</p><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><h1 id="b826" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">使用</h1><p id="2b68" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">现在已经设置好在我们的应用程序中使用我们的worker。演示示例展示了如何启动和监控在worker上执行的一些任务。我们可以与worker交互，并通过调用worker服务接收回它的消息。</p><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><h1 id="7b03" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">附录</h1><h2 id="fbe7" class="oe jv iq bd jw of og dn ka oh oi dp ke ld oj ok ki lh ol om km ll on oo kq op bi translated">在worker内部使用另一个TypeScript类</h2><p id="bf66" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们仍然缺少一个特性:在我们的worker中使用其他的TypeScript类。</p><p id="a890" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">如果我们只是在主worker类中使用另一个类，它在运行时将不可用。记住，我们只是产生了一个符号字符串表示(在我们的例子中主要是T1)，但是没有人(_<em class="lt">[web pack _)</em>来解析我们的依赖关系。所以我们必须给自己“注入”我们想要使用的外部类型脚本符号。</p><p id="c76c" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">好的一面是，我们可以在工人端强制我们的依赖类型。糟糕的是，我们将不得不在Angular服务中添加一些纯文本，就像我们对属性所做的那样。</p><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="8adc" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">现在我们可以在worker构造函数中实例化这些类。我们可以用这个技巧传递任何类或属性。类型是强制的，但我们不能忘记把它写在模板字符串中(没有错别字；)).</p><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="8226" class="oe jv iq bd jw of og dn ka oh oi dp ke ld oj ok ki lh ol om km ll on oo kq op bi translated">限制</h2><p id="9fac" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">对于在工作线程中执行的代码，还有其他一些限制。它包括worker类本身，也包括所有“注入”的依赖项。</p><ul class=""><li id="cfb4" class="nh ni iq ku b kv lu kz lv ld nj lh nk ll nl lp nm nn no np bi translated">正如我们已经提到的，所有方法都必须用ES6粗箭头符号编写，否则在运行时将不可用。</li><li id="c19f" class="nh ni iq ku b kv nq kz nr ld ns lh nt ll nu lp nm nn no np bi translated">不支持异步/等待</li><li id="a031" class="nh ni iq ku b kv nq kz nr ld ns lh nt ll nu lp nm nn no np bi translated">不支持扩展</li></ul></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="c439" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">总的来说，我认为这是一个<em class="lt">好的</em>解决方案，在后台工作人员中使用Typescript，同时保持配置简单并完全支持angular-cli。但如前所述，这是一种权衡，有其局限性。</p></div></div>    
</body>
</html>