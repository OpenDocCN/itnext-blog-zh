<html>
<head>
<title>How to Write Safe Timers With OutSystems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用外部系统编写安全定时器</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-write-safe-timers-with-outsystems-b76ad95ca927?source=collection_archive---------4-----------------------#2018-10-02">https://itnext.io/how-to-write-safe-timers-with-outsystems-b76ad95ca927?source=collection_archive---------4-----------------------#2018-10-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="92a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">OutSystems平台中我最喜欢的特性之一是计时器。我不再编写代码，然后使用外部工具来调度和控制它，而是拥有一个构建调度任务的一站式商店。然而，仅仅坐下来为你的定时器一起猛敲代码会在运行时失败的情况下给你带来一些麻烦。让我们来看看如何编写不会给你带来麻烦的计时器。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/6cce069ab4d823aa9f9bc0f862396a29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HYq7U-MiT3km8WvwfC0VzQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">这是一个字面意义上的外部系统计时器…任何在里斯本参加NextStep 2017的人都会知道为什么</figcaption></figure><h1 id="f996" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">有什么问题？</h1><p id="3576" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">你可能想知道“这有什么关系？OutSystems会自动重试失败的计时器，这没什么大不了的！”</p><p id="f063" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于某些应用程序，这可能没问题！但是想象一下，你正在开发一个系统，每天晚上查看发票，并试图向客户收取每张到期发票的费用。根据您编写代码的方式，您可能会对失败的发票重复收费多次，或者更糟，对成功的发票重复收费多次。呀！或者，您可能正在导入数据。重新导入相同的数据在最好的情况下会降低性能，在最坏的情况下会产生重复的数据。不太好。</p><h1 id="f66d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">跟踪每个记录和每个作业的成功/失败</h1><p id="5914" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">每次运行计时器时，您应该创建一个记录来跟踪正在执行的“作业”(例如“导入数据”或“为客户开账单”)，并为您正在处理的每个记录创建另一个记录(从电子表格导入的数据行、您正在尝试开账单的发票，等等)。</p><p id="d6a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您绝对需要跟踪的数据是:</p><ul class=""><li id="2168" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">开始日期/时间</li><li id="e582" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">停止日期/时间</li><li id="eec7" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">状态(成功、已完成但无错误、已完成但有错误、失败)</li><li id="95ad" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">任何输出或错误消息</li></ul><h1 id="4b9b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">异常处理</h1><p id="9e5a" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">每个记录应该在一个操作中单独处理。该操作应该返回一个成功/失败标志和任何需要的消息，并在其内部处理异常。主定时器应该简单地调用这个动作，处理输出(适当地改变作业的状态)，并且在每个记录被处理后<em class="me">执行一个CommitTransaction】。这样，关于作业和记录的所有状态信息总是被保存。如果作业需要重新运行，您将能够筛选出已经处理过的记录。如果发生异常，您也不会被中断循环，并继续处理剩余的记录。请注意，提交事务会对性能产生影响，在某些情况下，假设允许重试，那么每十条或一百条记录提交一次可能会更好。</em></p><p id="b386" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，如果这个逻辑对您的应用程序没有意义，那么在失败后执行一个commit事务(记录记录历史)并抛出一个异常以退出循环，进入计时器的异常处理程序(将作业标记为失败并退出)。</p><h1 id="4441" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要自动重试</h1><p id="a375" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">现在您正在跟踪作业的状态，获得安全计时器的下一步是阻止它们自动重试。您可以在OutSystems服务中心完成这项工作。将“计时器执行尝试次数”设置为1。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mt"><img src="../Images/f7212a51052e703a8ced082e2fbb63a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zs47ueniqYAn3CITY3Bnkg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">服务中心-&gt;管理</figcaption></figure><h1 id="70a1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如果您需要重试…</h1><p id="fed5" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">但是有时候你真的想在失败的情况下再试一次！在计时器结束时，如果有错误，在您的异常处理程序中，您可以查询您的作业状态历史。如果最近只有几个失败，调用您的计时器的唤醒操作让它重试。您需要为重试次数配置一个合理且安全的设置。例如，如果在过去15分钟内失败的作业不超过五个，则重试。</p><h1 id="87b6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在计时器开始时</h1><p id="85fb" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">现在，我们有了大量的数据来显示我们的计时器的历史，我们可以做一个巧妙的技巧:查询并仔细检查失败历史，看看这个计时器是否真的应该立即运行。如果最后一次执行是成功的，那么忽略其他最近的失败，因为问题似乎已经解决了。这确保了如果调度试图重试计时器，我们不会一次又一次地重复相同的失败。</p><p id="7503" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，当您查询工作(要导入的数据、要处理的发票等)时。)，可以过滤掉那些和失败捆绑在一起的。因此，您不会重试将要失败的记录。这在和钱打交道的时候尤其重要！你最不希望的事情就是因为一个问题或者一个bug导致你重新尝试付款。即使第二次支付失败，继续重试也是不好的。</p><h1 id="241b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">包装它</h1><p id="b1fc" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">OutSystems为我们提供了一个超级有用的工具，用于在预定的基础上运行代码。但是，如果没有良好的编码实践，我们可能会产生一些大问题。遵循这些步骤将确保数据完整性和业务逻辑的正确应用。</p><p id="b790" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">J.是</p></div></div>    
</body>
</html>