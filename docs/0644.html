<html>
<head>
<title>How to Create a Custom Persistent Volume Plugin in Kubernetes via FlexVolume (Part-1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过FlexVolume在Kubernetes中创建自定义持久卷插件(第1部分)</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-create-a-custom-persistent-volume-plugin-in-kubernetes-via-flexvolume-part-1-f6d9d966e123?source=collection_archive---------0-----------------------#2018-04-26">https://itnext.io/how-to-create-a-custom-persistent-volume-plugin-in-kubernetes-via-flexvolume-part-1-f6d9d966e123?source=collection_archive---------0-----------------------#2018-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="2d0a" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">这是一个两部分的系列。<a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/how-to-create-a-custom-persistent-volume-plugin-in-kubernetes-via-flexvolume-part-1-f6d9d966e123"> <strong class="jt ir">第一部分</strong> </a>:司机。<a class="ae kp" href="https://medium.com/@liangrog/how-to-create-a-custom-persistent-volume-plugin-in-kubernetes-via-flexvolume-part-2-c6390f9f94e0" rel="noopener"> <strong class="jt ir">第二部</strong> </a>:置备者</p></blockquote><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/0411a6078084f9056a520a54273b2ca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QOsU_Tk9SbPqfT0OpzKH7w.jpeg"/></div></div></figure><p id="c655" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">Kubernetes提供了丰富的内置<a class="ae kp" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#types-of-persistent-volumes" rel="noopener ugc nofollow" target="_blank">持久卷类型</a>，使用这些类型，您可以轻松地与您的物理或基于云的持久卷挂钩。然而，有时候持久卷(PV)的类型不是Kubernetes中内置的，或者PV的生命周期管理(如提供卷)不是标准的。例如，您必须对第三方供应商执行API调用来配置卷，而API调用会返回Kubernetes的相应PV驱动程序无法处理的安装规格。</p><p id="351b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">从Kubernetes 1.8开始，它已经停止接受“树内”卷插件。对于这个可能暴露自定义存储系统的问题，建议采用两种解决方案:</p><ol class=""><li id="a76b" class="lf lg iq jt b ju jv jy jz lc lh ld li le lj ko lk ll lm ln bi translated"><a class="ae kp" href="https://kubernetes.io/docs/concepts/storage/volumes/#csi" rel="noopener ugc nofollow" target="_blank"> <strong class="jt ir">【集装箱存储接口】</strong></a><strong class="jt ir">【1】</strong>。这种卷类型在kubernetes 1.9中被称为alpha，在1.10中被称为beta。</li><li id="a423" class="lf lg iq jt b ju lo jy lp lc lq ld lr le ls ko lk ll lm ln bi translated"><a class="ae kp" href="https://kubernetes.io/docs/concepts/storage/volumes/#flexvolume" rel="noopener ugc nofollow" target="_blank"><strong class="jt ir">flex volume</strong></a><strong class="jt ir">【2】</strong>。这种卷类型是从kubernetes 1.2开始引入的</li></ol><p id="0596" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">在本文中，我将带您完成使用<strong class="jt ir"> FlexVolume </strong>编写您自己的定制持久卷插件的步骤。</p><p id="201a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">FlexVolume工作的基本要素是一个驱动程序(可执行文件),该驱动程序可以执行附加/分离操作，在主机上装载/卸载永久卷。</p><pre class="kr ks kt ku gt lt lu lv lw aw lx bi"><span id="adc9" class="ly lz iq lu b gy ma mb l mc md">HOST</span><span id="9b71" class="ly lz iq lu b gy me mb l mc md">+------------------+<br/>|                  |<br/>|                  |<br/>|                  |<br/>|                  |<br/>|     Kubelet      |<br/>|        +         |<br/>|        |         |<br/>|        |         |<br/>+------------------+                     +-----------------------+<br/>|        |         |                     |                       |<br/>|        |         +-----------------&gt;   |      Third party      |<br/>|        v         |                     |      persistent       |<br/>|  Custom driver   |  &lt;------------------+      volume           |<br/>|                  |                     |                       |<br/>+------------------+   Attach/Detach     +-----------------------+<br/>                       Mount/Un-mount</span></pre><p id="75db" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">一旦你在你的主机上安装了驱动程序，你就可以<strong class="jt ir">静态地</strong>配置你的PVs。</p><p id="29a9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">如果您想要动态配置PVs，会发生什么情况？为了回答这个问题，在第2部分文章的后面，我还将指导您如何使用<a class="ae kp" href="https://github.com/kubernetes-incubator/external-storage" rel="noopener ugc nofollow" target="_blank">外部存储</a>【4】库来创建动态供应器。</p><p id="814f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">静态和动态供应器之间的差异可以在这里找到<a class="ae kp" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#provisioning" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="d5bc" class="ly lz iq bd mf mg mh dn mi mj mk dp ml lc mm mn mo ld mp mq mr le ms mt mu mv bi translated">司机</h2><p id="c410" class="pw-post-body-paragraph jq jr iq jt b ju mw jw jx jy mx ka kb lc my ke kf ld mz ki kj le na km kn ko ij bi translated">Flexvolume驱动程序可以用任何语言编写，但必须是可执行的，并且必须符合以下调用API规范[2][5]:</p><pre class="kr ks kt ku gt lt lu lv lw aw lx bi"><span id="6006" class="ly lz iq lu b gy ma mb l mc md">----------- Mandatory ------------<br/>&lt;driver executable&gt; init // Performs driver initialisation</span><span id="738c" class="ly lz iq lu b gy me mb l mc md">----------- Implementation option 1 -----------</span><span id="5d0f" class="ly lz iq lu b gy me mb l mc md">&lt;driver executable&gt; attach &lt;json options&gt; &lt;node name&gt; // Attaching persistent volume to the host</span><span id="4c33" class="ly lz iq lu b gy me mb l mc md">&lt;driver executable&gt; waitforattach &lt;mount device&gt; &lt;json options&gt; // Waiting for volume to be attached (10 minutes timeout)</span><span id="91c7" class="ly lz iq lu b gy me mb l mc md">&lt;driver executable&gt; isattached &lt;json options&gt; &lt;node name&gt; // Check if the volume is attached</span><span id="8bdf" class="ly lz iq lu b gy me mb l mc md">&lt;driver executable&gt; detach &lt;mount device&gt; &lt;node name&gt; // Detaching persistent volume from the host</span><span id="0d66" class="ly lz iq lu b gy me mb l mc md">&lt;driver executable&gt; mountdevice &lt;mount dir&gt; &lt;mount device&gt; &lt;json options&gt; // Mount the device to a global path so the pod can bind to it by Kubelet</span><span id="0c57" class="ly lz iq lu b gy me mb l mc md">&lt;driver executable&gt; unmountdevice &lt;mount device&gt; // Un-mount the device from global<!-- --> path</span><span id="557e" class="ly lz iq lu b gy me mb l mc md">----------- Implementation option 2-----------</span><span id="3554" class="ly lz iq lu b gy me mb l mc md">&lt;driver executable&gt; mount &lt;mount dir&gt; &lt;json options&gt; // This call-out implements both attach and mountdevice functions</span><span id="9030" class="ly lz iq lu b gy me mb l mc md">&lt;driver executable&gt; unmount &lt;mount dir&gt; // This call-out implements both unmountdevice and detach functions</span></pre><p id="2881" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">参数如<code class="fe nb nc nd lu b">&lt;mount dir&gt;</code>和<code class="fe nb nc nd lu b">&lt;json options&gt;</code>将由kubelet传入。您基本上使用这些信息来执行您的装载/卸载逻辑。json选项格式将在下面的“PV和PVC清单”一节中详细介绍。</p><p id="015a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">每次调用都必须通过stdout和stderr将具有以下格式的消息返回给kubelet:</p><pre class="kr ks kt ku gt lt lu lv lw aw lx bi"><span id="0b42" class="ly lz iq lu b gy ma mb l mc md">{<br/>	"status": "&lt;Success/Failure/Not supported&gt;",<br/>	"message": "&lt;Reason for success/failure&gt;",<br/>	"device": "&lt;Path to the device attached. This field is valid only for attach &amp; waitforattach call-outs&gt;"<br/>	"volumeName": "&lt;Cluster wide unique name of the volume. Valid only for getvolumename call-out&gt;"<br/>	"attached": &lt;True/False (Return true if volume is attached on the node. Valid only for isattached call-out)&gt;<br/>    "capabilities": &lt;Only included as part of the Init response&gt;<br/>    {<br/>        "attach": &lt;True/False (Return true if the driver implements attach and detach)&gt;<br/>    }<br/>}</span></pre><p id="0fca" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">“init”调出是必需的。返回消息会将“attach”值设置为true或false，以告知kubelet是使用实现选项1(使用单独的attach/detach调用)还是2。</p><p id="388d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">在Kubernetes的卷插件实现中，有多种类型的卷插件，如<code class="fe nb nc nd lu b">RecyclableVolumePlugin</code>和<code class="fe nb nc nd lu b">ProvisionableVolumePlugin</code>(更多详情查看此处<a class="ae kp" href="https://github.com/kubernetes/kubernetes/blob/master/pkg/volume/plugins.go" rel="noopener ugc nofollow" target="_blank">)。FlexVolume实现了两种类型，即<code class="fe nb nc nd lu b">AttachableVolumePlugin</code>和<code class="fe nb nc nd lu b">PersistentVolumePlugin</code>。因此，按照插件接口的要求，有两种驱动程序实现的选择。</a></p><p id="8b11" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">请注意，实现2中只有“<strong class="jt ir"> mount </strong>”方法会在json参数中传递秘密。更多详情可在<a class="ae kp" href="https://github.com/kubernetes/community/blob/master/contributors/devel/flexvolume.md" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="f613" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">如果使用secret，则机密类型必须是“供应商名称/驱动程序名称”。</p><p id="01f6" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">一旦你准备好驱动程序，只需将可执行文件放入每个主机的文件夹<code class="fe nb nc nd lu b">&lt;kubernetes volume plugin-dir&gt;/&lt;vendorname~drivername&gt;/&lt;driver name&gt;</code>。默认的kubernetes卷插件目录是<code class="fe nb nc nd lu b">/usr/libexec/kubernetes/kubelet-plugins/volume/exec/</code>。可以通过配置kubelet的参数<code class="fe nb nc nd lu b">volume-plugin-dir</code>来改变。</p><p id="b089" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">有很多方法可以把你的驱动程序放到主机上，比如使用配置工具，比如Ansible，Puppets。然而，由于集群的动态特性，节点可以上下伸缩，因此使用这些配置工具来维护稳定的集群的开销不容忽视。</p><p id="8380" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">更好的解决方案是使用Daemonset[3]部署驱动程序，它可以:</p><ul class=""><li id="d8d9" class="lf lg iq jt b ju jv jy jz lc lh ld li le lj ko ne ll lm ln bi translated">促进驱动程序更新</li><li id="956e" class="lf lg iq jt b ju lo jy lp lc lq ld lr le ls ko ne ll lm ln bi translated">自动部署到新节点</li><li id="75c8" class="lf lg iq jt b ju lo jy lp lc lq ld lr le ls ko ne ll lm ln bi translated">没有持续开销</li></ul><h2 id="bec3" class="ly lz iq bd mf mg mh dn mi mj mk dp ml lc mm mn mo ld mp mq mr le ms mt mu mv bi translated">PV和PVC货单</h2><p id="34ba" class="pw-post-body-paragraph jq jr iq jt b ju mw jw jx jy mx ka kb lc my ke kf ld mz ki kj le na km kn ko ij bi translated">Flexvolume PV具有以下格式</p><pre class="kr ks kt ku gt lt lu lv lw aw lx bi"><span id="ff26" class="ly lz iq lu b gy ma mb l mc md">apiVersion: v1 <br/>kind: PersistentVolume <br/>metadata:   <br/>  name: pv0001  <br/>spec:   <br/>  capacity:     <br/>    storage: 5Gi    <br/>  accessModes:     <br/>    - ReadWriteOnce<br/>  <!-- -->storageClassName: custom-class<br/>  flexVolume:     <br/>    driver: vendorname/drivername     <br/>    fsType: "ext4"      <br/>    secretRef: <br/>      name: foo-secret      <br/>    readOnly: true      <br/>    options:        <br/>      fooServer: 192.168.0.1:1234       <br/>      fooVolumeName: bar</span></pre><p id="f926" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">“选项”键将允许你传递任何自定义值到你的驱动程序。上述PV将被转换为json，并通过json选项以如下格式传递到您的驱动程序中:</p><pre class="kr ks kt ku gt lt lu lv lw aw lx bi"><span id="b666" class="ly lz iq lu b gy ma mb l mc md">"kubernetes.io/fsType":"ext4",<br/>"kubernetes.io/readwrite":"rwo",<br/>"kubernetes.io/secret/key1":"&lt;secret1&gt;",<br/>...<br/>"kubernetes.io/secret/keyN":"&lt;secretN&gt;",<br/>"fooServer": "192.168.0.1:1234",<br/>"fooVolumeName": "bar"</span></pre><p id="0b80" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">注意:您必须手动设置物理持久性卷，并在“选项”中传递所有必要的信息，以便您的驱动程序了解如何装载和卸载。</p><p id="f08f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">现在，在您创建了具有类名“custom-class”的PV之后，您可以通过指定“storageClassName”或使用标签选择器在您的任何PVC中使用它。举个例子，</p><pre class="kr ks kt ku gt lt lu lv lw aw lx bi"><span id="070b" class="ly lz iq lu b gy ma mb l mc md">kind: PersistentVolumeClaim<br/>apiVersion: v1<br/>metadata:<br/>  name: myclaim<br/>spec: <br/>  <!-- -->storageClassName: <!-- -->custom-class<br/>  accessModes:<br/>    - ReadWriteOnce<br/>  resources:<br/>    requests:<br/>      storage: 5Gi</span></pre><h2 id="36bb" class="ly lz iq bd mf mg mh dn mi mj mk dp ml lc mm mn mo ld mp mq mr le ms mt mu mv bi translated">参考:</h2><p id="701d" class="pw-post-body-paragraph jq jr iq jt b ju mw jw jx jy mx ka kb lc my ke kf ld mz ki kj le na km kn ko ij bi translated">[1] <a class="ae kp" href="https://github.com/container-storage-interface/spec/blob/master/spec.md" rel="noopener ugc nofollow" target="_blank"> Kubernetes容器存储接口(CSI) </a></p><p id="b0f0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">[2] <a class="ae kp" href="https://github.com/kubernetes/community/blob/master/contributors/devel/flexvolume.md" rel="noopener ugc nofollow" target="_blank"> Flexvolume规格</a></p><p id="1820" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">[3] <a class="ae kp" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/flexvolume-deployment.md" rel="noopener ugc nofollow" target="_blank">动态Flexvolume插件发现</a></p><p id="32bd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">[4]<a class="ae kp" href="https://github.com/kubernetes-incubator/external-storage" rel="noopener ugc nofollow" target="_blank">【GitHub】外部存储</a></p><p id="7a0e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">[5] <a class="ae kp" href="https://docs.openshift.org/latest/install_config/persistent_storage/persistent_storage_flex_volume.html" rel="noopener ugc nofollow" target="_blank"> Openshift —使用Flexvolume插件的持久卷</a></p></div></div>    
</body>
</html>