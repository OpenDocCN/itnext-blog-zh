<html>
<head>
<title>Trigger Firebase Storage Image Resize with Cloud Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用云函数触发Firebase存储映像调整大小</h1>
<blockquote>原文：<a href="https://itnext.io/trigger-firebase-storage-image-resize-with-cloud-functions-9dd409ededac?source=collection_archive---------2-----------------------#2019-08-05">https://itnext.io/trigger-firebase-storage-image-resize-with-cloud-functions-9dd409ededac?source=collection_archive---------2-----------------------#2019-08-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/afdc8a871df4c3f959108e3260669d4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hqdj5LN9NESfpcSIiNKJYA.png"/></div></div></figure><figure class="kb kc kd ke gt ju gh gi paragraph-image"><a href="https://www.jsmonday.dev/articles/29/trigger-firebase-storage-image-resize-with-cloud-functions"><div class="gh gi jq"><img src="../Images/e6537356ea1f5f0a5ca99effd13b9bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ph4ke1672cns05b2S7PbMg.png"/></div></a></figure><p id="fd73" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Firebase太棒了。正如之前JSMonday文章 中的<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/running-express-js-on-firebase-cloud-functions-a20b536c6aec"> <strong class="kh iu">所写的，它允许我们编写无服务器的应用程序，认证用户和许多其他事情。</strong></a></p><p id="18d7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Firebase还提供一项名为<strong class="kh iu"> Firebase Storage </strong>的服务，有点类似于<strong class="kh iu"> AWS S3 </strong>。您可以创建一个存储桶，然后在其中插入任何类型的文件。它通常用于存储图像，但问题来了:如果用户正在上传一个令人难以置信的沉重的图像怎么办？你可能想调整它的大小！<br/>让我们看看如何使用<strong class="kh iu"> Firebase函数</strong>来实现。</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/dbc3555360c8656f0e0c56219c5345de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pp0dHjADPsHk_uvQHwrQ8A.png"/></div></div></figure><p id="ca27" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">首先，让我们初始化一个新的<strong class="kh iu"> Firebase Functions </strong>项目。<br/>然后，让我们安装几个<strong class="kh iu"> npm </strong>软件包:</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/b4d35ad3043deb01995030411a4e22a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZTP79VA_i-1CNTA7QGeEUQ.png"/></div></div></figure><p id="a14a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如您所见，我们正在安装这三个软件包:</p><ul class=""><li id="0d51" class="lf lg it kh b ki kj km kn kq lh ku li ky lj lc lk ll lm ln bi translated"><code class="fe lo lp lq lr b">@google-cloud/storage</code>允许您从<strong class="kh iu"> Firebase存储器</strong>中获取图像。</li><li id="ab46" class="lf lg it kh b ki ls km lt kq lu ku lv ky lw lc lk ll lm ln bi translated"><code class="fe lo lp lq lr b">fs-extra</code>，包装Node.js默认<code class="fe lo lp lq lr b">fs</code>模块，用承诺公开其功能。</li><li id="7fea" class="lf lg it kh b ki ls km lt kq lu ku lv ky lw lc lk ll lm ln bi translated"><code class="fe lo lp lq lr b">sharp</code>，Node.js惊人的高性能图像处理库</li></ul><p id="0702" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们现在准备好写我们的图像尺寸！让我们导航到我们的<code class="fe lo lp lq lr b">functions/index.js</code>文件，开始导入我们需要的依赖项:</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/61d70ad68b909c92ea49e034c83ab254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LJCU-UmZmhZOXYugmxstBg.png"/></div></div></figure><p id="3a08" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">太好了！现在我们可以开始编写函数处理程序了:</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/d0a58970894972b4bf25f77de7717211.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4riivkFkuCa5KLvIUp-s2A.png"/></div></div></figure><p id="ce90" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如您所见，我们告诉Firebase函数，我们需要至少2GB的内存和最多120秒的时间来执行我们的函数。我们还声明，一旦图像被上传到我们的桶中，我们就需要触发这个函数(<code class="fe lo lp lq lr b">storage.object().onFinalize</code>)。</p><p id="4d11" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们编写<code class="fe lo lp lq lr b">handler</code>函数:</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/416ff27c33f5bf6c98c7ebea0ebc8096.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-yJSofUZA6dtaGAcJIaZCA.png"/></div></div></figure><p id="575d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们需要从我们的<code class="fe lo lp lq lr b">object</code>参数(它实际上是一个描述我们的图像被上传到哪里的对象)中获得大量信息:</p><ul class=""><li id="2722" class="lf lg it kh b ki kj km kn kq lh ku li ky lj lc lk ll lm ln bi translated"><strong class="kh iu">桶</strong>:我们上传图像的桶。</li><li id="c5a1" class="lf lg it kh b ki ls km lt kq lu ku lv ky lw lc lk ll lm ln bi translated"><strong class="kh iu">文件路径</strong>:我们桶里面的文件路径。</li><li id="e77a" class="lf lg it kh b ki ls km lt kq lu ku lv ky lw lc lk ll lm ln bi translated"><strong class="kh iu">文件名</strong>:上传的文件名。</li><li id="ed88" class="lf lg it kh b ki ls km lt kq lu ku lv ky lw lc lk ll lm ln bi translated"><strong class="kh iu">桶目录</strong>:我们上传图像的目录名。</li></ul><p id="257d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在我们可以创建一个临时目录，在这里我们将执行调整代码。我们还将创建一个临时文件来运行我们的操作。</p><p id="c8a4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在出现了一个问题:每次在我们的桶中创建新文件时，我们的函数都会被触发…但是我们实际上是在创建一个新的调整大小的图像，那么我们如何避免一个无限的调整大小循环呢？</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/cc40c016358d02f7876cad9aa9e5d6ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4tCFfbz3r9fsN6qPYvOLUQ.png"/></div></div></figure><p id="6329" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将为调整后的图像设置一个类似于<code class="fe lo lp lq lr b">myImage@s_1920.jpg</code>的名称(其中<code class="fe lo lp lq lr b">s_</code>代表“大小”)，这样我们就能够检查新创建的图像是否是调整大小的结果。<br/>如果图像本身是一个调整过大小的图像，我们将退出我们的功能。</p><p id="9c8b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在我们只需要下载新创建的图像。我们将把它下载到先前创建的临时文件路径中:</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/fdba66eb079f441d913f63810d064e49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zd9f5lTbYtd_Ak18U1fJQw.png"/></div></div></figure><p id="b925" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在我们准备开始调整大小！假设我们需要创建三种不同的大小:1920像素、720像素、100像素。让我们将这些值包装成一个数组:</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/5b7fad251d15b303f75db2b3e0a914d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fbc45Q6aYbEYQ0pAA3EohA.png"/></div></div></figure><p id="416c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在我们需要运行resizer，所以我们将为数组中的每个大小创建一个承诺:</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/a6c8ad2b0c7ed721096e42be4387d56f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Oq5Xd5RNi8hPXS1nl40pA.png"/></div></div></figure><p id="6c9e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如您所见，这个过程非常简单:</p><ul class=""><li id="389c" class="lf lg it kh b ki kj km kn kq lh ku li ky lj lc lk ll lm ln bi translated">获取图像扩展名。</li><li id="e34d" class="lf lg it kh b ki ls km lt kq lu ku lv ky lw lc lk ll lm ln bi translated">获取原始图像名称。</li><li id="d343" class="lf lg it kh b ki ls km lt kq lu ku lv ky lw lc lk ll lm ln bi translated">创建最终图像名称。</li><li id="080c" class="lf lg it kh b ki ls km lt kq lu ku lv ky lw lc lk ll lm ln bi translated">获取它的路径。</li><li id="658d" class="lf lg it kh b ki ls km lt kq lu ku lv ky lw lc lk ll lm ln bi translated">现在让我们运行<code class="fe lo lp lq lr b">sharp</code>，调整图像大小，然后保存到一个文件中。</li><li id="0969" class="lf lg it kh b ki ls km lt kq lu ku lv ky lw lc lk ll lm ln bi translated">最后但同样重要的是，使用新的文件名将图像上传到原始的bucket。</li></ul><p id="5b9f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在我们只需要运行这三个承诺…但我们不想按顺序运行它们，这可能需要太长时间！因此，我们将使用<code class="fe lo lp lq lr b">Promise.all</code>来并发运行它们:</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/f028d948044f08098fddf0a19c122441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k-JzAvXzKKsYNMjz4eOe8w.png"/></div></div></figure><p id="b474" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们完事了。<br/>让我们部署该功能并进行测试，将文件上传到Firebase存储:</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/a704e29cbbb2c66471c4f69b8503a328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1DaqZZ9p8OF0TpwXD5n7rw.png"/></div></div></figure><p id="eb9e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们现在准备运行我们的resizer！<br/>在<strong class="kh iu"> JSMonday </strong>，我们实际上使用了上面的代码来调整我们图像的大小:</p><div class="lx ly gp gr lz ma"><a href="https://github.com/jsmonday/Daguerre" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd iu gy z fp mf fr fs mg fu fw is bi translated">js Monday/达盖尔</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">github.com</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo jz ma"/></div></div></a></div><p id="b656" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请随意重用上面的代码为您的图像尺寸！</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><a href="https://patreon.com/micheleriva"><div class="gh gi jq"><img src="../Images/aa1c4ca054bf144bee7acff3a937e808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n4vAt_maE02qOdj_fwrqvA.png"/></div></a></figure></div></div>    
</body>
</html>