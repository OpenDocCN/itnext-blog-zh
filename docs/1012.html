<html>
<head>
<title>Multi-server Chat in Node Without a Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无数据库节点中的多服务器聊天</h1>
<blockquote>原文：<a href="https://itnext.io/multi-server-chat-in-node-without-a-database-51bb66e41999?source=collection_archive---------3-----------------------#2018-07-04">https://itnext.io/multi-server-chat-in-node-without-a-database-51bb66e41999?source=collection_archive---------3-----------------------#2018-07-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3c7a77f390ccdb6813cfa72b589ca364.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mMawypMnD9wpQ0wPEnls-A.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">普里西拉·杜·普里兹在<a class="ae kf" href="https://unsplash.com/search/photos/texting?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="f042" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">几年前，我为一个客户提供咨询，这个客户有一个基于节点的即时消息功能，起初运行得很好。但是用户数量增长了，然后就没有了。</p><p id="8796" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管他们运行了许多负载平衡的服务器实例，但他们发现用于跟踪连接用户的Redis数据库是一个很大的瓶颈。无论他们运行多少实例，他们都必须与数据库对话。</p><p id="158a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在可以说，Redis支持复制，并且就在前一年增加了集群支持，所以这个问题可能已经解决了。但是团队领导想知道是否有办法完全消除数据库。我还能怎么回应呢？</p><p id="5f52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">“接受挑战！”</em></p><p id="4082" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我创建了一个小的概念证明，我要求并得到了团队领导的许可，在Github 上分享并在以后写博客。好了，现在是<em class="le">晚了，我想我应该花时间整理一下，写一篇关于它的帖子，希望它能帮助那里的人。</em></p><h1 id="f4ac" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">设计假设</h1><ul class=""><li id="6160" class="md me it ki b kj mf kn mg kr mh kv mi kz mj ld mk ml mm mn bi translated">客户端应该能够连接到任何正在运行的实例，并与任何其他实例上的用户聊天，就像他们连接到同一个实例一样。</li><li id="bff5" class="md me it ki b kj mo kn mp kr mq kv mr kz ms ld mk ml mm mn bi translated">将用户连接到给定实例的机制并不重要。客户端可以从已知列表中随机选择一个实例，或者由负载平衡器分配一个实例。</li><li id="54dc" class="md me it ki b kj mo kn mp kr mq kv mr kz ms ld mk ml mm mn bi translated">给定的用户可以与多个客户端连接，因此当消息发送给他们时，该用户的所有客户端都应该接收到该消息，并且该用户发送的所有消息也需要到达他们的其他客户端，以便消息历史可以反映完整的讨论。</li></ul><p id="0dc1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你会问，解决方案是什么？</p><h1 id="be64" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">网状拓扑</h1><p id="f6e7" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">有了这个服务器，可以在不同的IP/端口组合上启动任意数量的实例，它们将立即建立并维护彼此之间的连接。</p><p id="f706" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在服务器实例连接到一个对等点后，它会发送一个用户列表以及每个用户当前打开的连接数。随后，当用户连接和断开连接时，服务器实例会向所有对等方更新该用户的连接状态。</p><p id="dc53" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为每个服务器实例总是知道哪些用户连接到它的每个对等点，所以不需要数据库。由于每个连接只存储一个用户名和连接数，100k个用户名平均长度为9个字符的用户和一个连接占用的内存不到1MB。客户端负责积累自己的消息历史。</p><h2 id="37c7" class="mw lg it bd lh mx my dn ll mz na dp lp kr nb nc lt kv nd ne lx kz nf ng mb nh bi translated">将邮件发送给收件人</h2><p id="fb72" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">当一个服务器实例收到一个它不认识的收件人的消息时，它会将该消息转发给任何已知与该用户有连接的对等方。</p><h2 id="2ee9" class="mw lg it bd lh mx my dn ll mz na dp lp kr nb nc lt kv nd ne lx kz nf ng mb nh bi translated">保持发送者的客户端同步</h2><p id="284c" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">发件人的消息还必须发送到他们在所有服务器上的所有连接，以便他们的消息历史能够反映完整的讨论。</p><h2 id="f568" class="mw lg it bd lh mx my dn ll mz na dp lp kr nb nc lt kv nd ne lx kz nf ng mb nh bi translated">使用用户列表更新客户端</h2><p id="0b90" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">每当用户连接到服务器实例(或从服务器实例断开连接)时，所有连接到网格的用户都将被发送一个排序的、唯一的当前连接用户列表。</p><h2 id="61a4" class="mw lg it bd lh mx my dn ll mz na dp lp kr nb nc lt kv nd ne lx kz nf ng mb nh bi translated">服务器配置</h2><p id="dd62" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">JSON配置文件包含所有实例的条目，因此它们可以监听正确的端口并连接到它们的对等体。为简单起见，服务器实例被配置为在本地计算机的不同端口上启动，但是实例可以在任何端口/ IP地址组合上运行:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="61b6" class="mw lg it nn b gy nr ns l nt nu">{<br/>  "id": "server-1",<br/>  "ip": "127.0.0.1",<br/>  "port": 3001<br/>},</span></pre><h1 id="8352" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">服务器行为</h1><h2 id="3afd" class="mw lg it bd lh mx my dn ll mz na dp lp kr nb nc lt kv nd ne lx kz nf ng mb nh bi translated">对等连接</h2><p id="2f25" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">当服务器实例启动时，它开始监听分配给它的端口，然后尝试连接到它的对等方。如果在启动时无法联系到对等方，实例将继续重试，直到它变得可用。如果连接的对等体在运行时断开连接，其他实例将尝试重新连接，直到它再次出现。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="528b" class="mw lg it nn b gy nr ns l nt nu">Loading config from: config.json<br/>Config loaded.<br/>My id: server-1<br/>Listening for connections on port:3001<br/>Attempting to connect to peers...<br/>Attempt connection to peer: server-2 at: <a class="ae kf" href="http://127.0.0.1:3002" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:3002</a><br/>Attempt connection to peer: server-3 at: <a class="ae kf" href="http://127.0.0.1:3003" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:3003</a><br/>Attempt connection to peer: server-4 at: <a class="ae kf" href="http://127.0.0.1:3004" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:3004</a><br/>Outbound connection to peer: server-2<br/>Outbound connection to peer: server-3<br/>Outbound connection to peer: server-4</span></pre><p id="0a0b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当服务器实例在连接时收到来自对等方的更新时，它是连接到该对等方的所有用户的列表。然后，它使用新的聚合用户列表更新其所有连接的客户端。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="1b27" class="mw lg it nn b gy nr ns l nt nu">Received update from peer: server-3<br/>Replacing user list for peer: server-3<br/>Updating clients with new user list...</span></pre><p id="efa4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当服务器实例从对等方接收到有关单个用户连接状态的更新时，它会修改其内部用户列表。然后，它使用新的聚合用户列表更新其所有连接的客户端。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="210c" class="mw lg it nn b gy nr ns l nt nu">Received update from peer: server-1<br/>Replacing user Anna in list for peer: server-1<br/>Updating clients with new user list...<br/><br/>Received update from peer: server-3<br/>Adding user Billy to list for peer: server-3<br/>Updating clients with new user list...<br/><br/>Received update from peer: server-2<br/>Removing user Anna from list for peer: server-2<br/>Updating clients with new user list...</span></pre><h2 id="a034" class="mw lg it bd lh mx my dn ll mz na dp lp kr nb nc lt kv nd ne lx kz nf ng mb nh bi translated">客户端连接</h2><p id="b68b" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">当客户机连接到一个实例时，它发送用户名，服务器挂起该连接，将它与该用户相关联。请记住，一个用户可以连接多次，因此会为每个用户保留一个连接集合。此外，当用户连接时，服务器实例用该用户的连接状态更新其所有对等方，然后用新的聚合用户列表更新其所有连接的客户端。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="0024" class="mw lg it nn b gy nr ns l nt nu">User: Anna connected 1 time.<br/>Updating peers with connection count for user: Anna...<br/>Updating clients with new user list...<br/>User: Anna connected 2 times.<br/>Updating peers with connection count for user: Anna...<br/>Updating clients with new user list...</span></pre><p id="6375" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当客户端向不在它们所连接的同一服务器实例上的用户发送消息时，该消息将被转发给已知与该用户有连接的任何对等方。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="42d0" class="mw lg it nn b gy nr ns l nt nu">User: Billy connected 1 times.<br/>Received IM from Billy to Anna: Hi Anna<br/>Recipient Anna not on this server<br/>Forwarding to peer: server-1 ...<br/>Forwarding to peer: server-2 ...</span></pre><p id="84d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当服务器实例收到来自具有一个或多个连接的用户的对等方的转发消息时，它会将该消息发送给该用户的所有连接客户端。它不会转发已转发的消息。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="818f" class="mw lg it nn b gy nr ns l nt nu">Received forwarded IM from Billy to Anna: Hi Anna<br/>Recipient Anna has 2 connection(s) to this server, sending...</span></pre><h2 id="5fce" class="mw lg it bd lh mx my dn ll mz na dp lp kr nb nc lt kv nd ne lx kz nf ng mb nh bi translated">客户行为</h2><p id="b9c1" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">基本客户端有一个下拉列表，其中有两个预定义的用户(Anna和Billy)，另一个下拉列表有四个可能连接的端口，以及一个“连接”按钮。</p><p id="8b0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下特性超出了这个简单客户端的范围，但是已经添加到一个更复杂的基于React的客户端中。</p><ul class=""><li id="2ea5" class="md me it ki b kj kk kn ko kr nv kv nw kz nx ld mk ml mm mn bi translated">客户端消息历史记录。收到的传入和传出信息会显示在显示屏的顶部。</li><li id="51e3" class="md me it ki b kj mo kn mp kr mq kv mr kz ms ld mk ml mm mn bi translated">客户端连接的用户列表。这个客户端只是在收到用户列表时将其记录到控制台。</li></ul><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/d1ac28469b77713963fb0e76560bada9.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/0*qV6mZ7ZTYIoP2qH6.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><strong class="bd lh">未连接的客户端</strong></figcaption></figure><p id="8f75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">选择用户和端口，然后单击“连接”。您的邮件收件人将是您没有选择的用户。启动另一个浏览器，以另一个用户的身份登录，选择相同或不同的端口。来回发消息。</p></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><h2 id="73db" class="mw lg it bd lh mx my dn ll mz na dp lp kr nb nc lt kv nd ne lx kz nf ng mb nh bi translated">具有多个连接的用户在所有客户端接收即时消息</h2><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/92144f948cea9b031de4c15b2607c515.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KnH4l7s_Ryt2OoY9.png"/></div></div></figure><h2 id="6637" class="mw lg it bd lh mx my dn ll mz na dp lp kr nb nc lt kv nd ne lx kz nf ng mb nh bi translated">拥有多个连接的用户发送即时消息，并在所有客户端收到通知，因此消息历史记录可以保持同步</h2><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/741ef062dbb43b417918ee98f4d075e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CBtwolfa2mb657Vg.png"/></div></div></figure></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/fdd7fc72058efeefa4fb6c7309f203d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*j_DfdGns8EB2M_UA.png"/></div></div></figure><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/8e74f2907e6d42949e72be83573bedd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9prWfSi0ZTgvGj5Z.png"/></div></div></figure><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/6096cffffed9f832064282585db31eac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/0*MwOqzTqrHKfSjvv2.png"/></div></figure><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/3c88cb668f07bec0ee76596686b05a99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1161YqX3AXb_gBc0.png"/></div></div></figure><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi om"><img src="../Images/9df04c9e526d2f5b883af1e99cdcbfaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/0*6kb9XEylcSven8U3.png"/></div></figure><h2 id="77b8" class="mw lg it bd lh mx my dn ll mz na dp lp kr nb nc lt kv nd ne lx kz nf ng mb nh bi translated">密码</h2><p id="c707" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">服务器的代码不到300行，简单客户机不到200行，所以不难理解。关键是理解上述策略。</p><p id="2fa9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">库依赖限于Socket.io(这很好，因为如果客户端浏览器不支持websockets，它提供了XHR长期轮询作为后备)和Express(用于服务简单客户端)。</p><p id="497e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看看Github上的项目，并随时给我你的反馈。关于设置项目在本地运行的所有信息都在自述文件中。</p><ul class=""><li id="1e29" class="md me it ki b kj kk kn ko kr nv kv nw kz nx ld mk ml mm mn bi translated">服务器和基本的HTML / JS客户端:【https://github.com/cliffhall/node-multi-server-chat T4】</li><li id="0997" class="md me it ki b kj mo kn mp kr mq kv mr kz ms ld mk ml mm mn bi translated">具有消息历史和连接用户列表的基于React的客户端:<a class="ae kf" href="https://github.com/cliffhall/react-chat-client" rel="noopener ugc nofollow" target="_blank">https://github.com/cliffhall/react-chat-client</a></li></ul></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><p id="f092" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">最初发表于</em> <a class="ae kf" href="http://cliffordhall.com/2018/07/multi-server-chat-node-without-database/" rel="noopener ugc nofollow" target="_blank"> <em class="le">崖堂</em> </a> <em class="le">。</em></p></div></div>    
</body>
</html>