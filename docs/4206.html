<html>
<head>
<title>Blazing fast Fibonacci with Kotlin and Arrow library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Kotlin和Arrow库实现极快的斐波那契运算</h1>
<blockquote>原文：<a href="https://itnext.io/blazing-fast-fibonacci-with-kotlin-and-arrow-library-33c1d7eca0bb?source=collection_archive---------3-----------------------#2020-05-15">https://itnext.io/blazing-fast-fibonacci-with-kotlin-and-arrow-library-33c1d7eca0bb?source=collection_archive---------3-----------------------#2020-05-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/d72fada6d09509645237309bf6cf92d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*dxX9TcMVVg61x6jKaOOFHg.png"/></div></figure><h1 id="2ee9" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">TLDR；</h1><p id="e547" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在本文中，我将向您展示如何通过利用Kotlin的<a class="ae lq" href="https://arrow-kt.io/" rel="noopener ugc nofollow" target="_blank">箭头</a>函数库和‘平方取幂算法’以极快的速度计算斐波那契数。</p><p id="2553" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">这种方法很大程度上受到了All article 的这个<a class="ae lq" href="http://www.haskellforall.com/2020/04/blazing-fast-fibonacci-numbers-using.html" rel="noopener ugc nofollow" target="_blank"> Haskell的启发。你可以在这里</a>找到代码<a class="ae lq" href="https://github.com/cesartl/arrow-fibonacci" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="f785" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">斐波那契数列</strong></h1><p id="cd80" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如果你是一名程序员，你可能不止一次遇到过斐波那契数列，但这里还是有一个快速的提醒。</p><p id="9306" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">该序列定义如下:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="2e46" class="mf jv iq mb b gy mg mh l mi mj">F(0) = 0<br/>F(1) = 1<br/>F(n) = F(n-1) + F(n-2), n &gt; 1</span></pre><h2 id="1146" class="mf jv iq bd jw mk ml dn ka mm mn dp ke ld mo mp ki lh mq mr km ll ms mt kq mu bi translated">双重递归实现</h2><p id="098b" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">实现这个序列的最简单的方法是使用双重递归函数。例如，在科特林:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="3d2c" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">这是一种简单的方法，但效率极低；时间复杂度为<code class="fe mx my mz mb b">O(2^n)</code>。</p><p id="02b5" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">这可以通过记忆前两个值来提高到<code class="fe mx my mz mb b">O(n)</code>。让我们看看我们是否能做得更好。</p><h2 id="75e9" class="mf jv iq bd jw mk ml dn ka mm mn dp ke ld mo mp ki lh mq mr km ll ms mt kq mu bi translated">封闭式的</h2><p id="df19" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">原来有一个数学公式可以计算任何斐波纳契数在<code class="fe mx my mz mb b">O(1)</code>时间和记忆的复杂性:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/bb5d74b6ed2de91f6ed7c2bcd241567c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7P7G5YrYl_4bkiMPfPRwgw.png"/></div></div></figure><blockquote class="nf ng nh"><p id="e047" class="ks kt ni ku b kv lr kx ky kz ls lb lc nj lt lf lg nk lu lj lk nl lv ln lo lp ij bi translated">(你可以在这里看到为什么斐波那契数和黄金分割率𝝋:之间存在联系。如果你将<em class="iq"> f(n+1)/f(n) </em>除以，它收敛于𝝋.)</p></blockquote><p id="ad1c" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">尽管这在理论上确实很快，但由于浮点精度运算，它在实践中并不起作用。</p><h2 id="9160" class="mf jv iq bd jw mk ml dn ka mm mn dp ke ld mo mp ki lh mq mr km ll ms mt kq mu bi translated">矩阵形式</h2><blockquote class="nf ng nh"><p id="22f5" class="ks kt ni ku b kv lr kx ky kz ls lb lc nj lt lf lg nk lu lj lk nl lv ln lo lp ij bi translated">不要被那些看起来很花哨的数学所迷惑，当我们找到代码时，它会变得简单得多。</p></blockquote><p id="676a" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">你也可以用矩阵来表达递归序列，比如斐波那契数列。</p><p id="20b4" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">例如:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="0f1a" class="mf jv iq mb b gy mg mh l mi mj">f(n) = a.f(n-1) + b.f(n-2)</span></pre><p id="f48c" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">你可以写:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nm"><img src="../Images/ea62ee30a16870396aadeecfd52dc9c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CY6davgRqNcR3OfkzDbCxQ.png"/></div></div></figure><p id="1998" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">条件:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="9046" class="mf jv iq mb b gy mg mh l mi mj">f(0) = ⍺<br/>f(1) = β</span></pre><p id="63a6" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">变成:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/579d916a8eb686a42fdc42199d7beb1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:394/format:webp/1*B4BtRn1Xp-HfzlbaIf_vPg.png"/></div></figure><p id="7312" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">所以最终你会得到:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi no"><img src="../Images/9d45d55a3486a55d67b5b287e05686ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zs3-JscxH308-v5Kh3CFDw.png"/></div></div></figure><p id="f8f4" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">或者:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/c9dc2d943dc283c706e8bed0e37bed6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*wMOGxoRyR4n4rxLjamrQYw.png"/></div></figure><blockquote class="nf ng nh"><p id="3207" class="ks kt ni ku b kv lr kx ky kz ls lb lc nj lt lf lg nk lu lj lk nl lv ln lo lp ij bi translated"><em class="iq">注意，这适用于任何线性递归序列，其中f(n)依赖于f(n-1)，f(n-2)，…，f(n-m)。然后你得到一个矩阵。</em></p></blockquote><p id="b163" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">所以我们的斐波那契表达式变成了:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/ff3b68cb637d45ab6c1df7d38c004a87.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*N7-oNhAF4lLyt7Cb2KUQgw.png"/></div></figure><p id="ce77" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">如果你没有完全理解这些矩阵运算，也不要担心，它实际上很容易转化为代码。</p><h1 id="952c" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">平方取幂</h1><p id="9314" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">上面公式的美妙之处在于，所有的工作都是通过矩阵乘法来完成的。如果你有一个形式为<em class="ni"> x⊗ y </em>的二进制运算，并且你想计算<em class="ni"> x⊗ x⊗…⊗ x，n </em>次，你可以使用<a class="ae lq" href="https://en.wikipedia.org/wiki/Exponentiation_by_squaring" rel="noopener ugc nofollow" target="_blank">乘方求幂</a>:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nr"><img src="../Images/ca0605d4fc2f330461dce085b7b10857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5xfnt28HI5k4EdTr3RxR7g.png"/></div></div></figure><p id="6dab" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">直观地说，您可以递归地定义操作<code class="fe mx my mz mb b">pow(x,n)</code>:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="80f0" class="mf jv iq mb b gy mg mh l mi mj">pow(x,n) = <br/>   if(n == 0)      empty()<br/>   else if(n even) pow(x<em class="ni">⊗</em>x, n/2)<br/>   else            x<em class="ni">⊗</em>pow(x<em class="ni">⊗</em>x, (n-1)/2)</span></pre><p id="2f0e" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">这里我们还需要一个中性元素叫做<code class="fe mx my mz mb b">empty()</code>。对于自然数，这只是<code class="fe mx my mz mb b">1</code>。</p><p id="31ef" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">该算法不断将<code class="fe mx my mz mb b">n</code>除以<em class="ni"> 2 </em>，因此时间复杂度为<code class="fe mx my mz mb b">O(log₂(n)).</code></p><h1 id="ecd3" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">输入箭头</h1><p id="8a7e" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">平方取幂不仅适用于整数乘法，还适用于任何具有二进制运算和该运算的中性值(自然数为1)的类型。所以在Java世界里，我们可以有这样一个接口:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="02bc" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">在函数世界里，有一种东西叫做<a class="ae lq" href="https://en.wikipedia.org/wiki/Type_class" rel="noopener ugc nofollow" target="_blank">类型类</a>。有一组标准类型类和<a class="ae lq" href="https://arrow-kt.io/docs/0.10/typeclasses/intro/" rel="noopener ugc nofollow" target="_blank">它们随Arrow </a>一起提供，这是Kotlin的函数库。</p><h2 id="3e15" class="mf jv iq bd jw mk ml dn ka mm mn dp ke ld mo mp ki lh mq mr km ll ms mt kq mu bi translated">半群</h2><p id="879d" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">为类型定义二元运算的类型类称为<a class="ae lq" href="https://arrow-kt.io/docs/0.10/arrow/typeclasses/semigroup/" rel="noopener ugc nofollow" target="_blank">半群</a>。在科特林，它看起来像这样:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">Kotlin中的半群类型类</figcaption></figure><p id="e0f6" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">关于Kotlin实现有趣的一点是，它使用了Kotlin 中的<a class="ae lq" href="https://kotlinlang.org/docs/reference/extensions.html" rel="noopener ugc nofollow" target="_blank">扩展函数。在Java世界中，如果我们有一个<code class="fe mx my mz mb b">Foo</code>类，它将会像这样扩展一个<code class="fe mx my mz mb b">Semigroup</code>接口:</a></p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="cf70" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">在Kotlin中，我们不会让<code class="fe mx my mz mb b">Foo</code>扩展一个接口，我们会创建一个名为<code class="fe mx my mz mb b">FooSemigroup,</code>的新的单例类，它为<code class="fe mx my mz mb b">Foo</code>提供一个扩展函数:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="f631" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">因此，如果我们有两个foo实例:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="2261" class="mf jv iq mb b gy mg mh l mi mj">val foo1 = Foo()<br/>val foo2 = Foo()</span><span id="4311" class="mf jv iq mb b gy nw mh l mi mj">val foo3 = foo1.combine(foo2)    //this does not compile</span><span id="7ff7" class="mf jv iq mb b gy nw mh l mi mj">val foo3 = FooSemigroup().run {<br/>   foo1.combine(foo2)            //this compiles<br/>}</span></pre><p id="450c" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">您可以看到，我们必须在<code class="fe mx my mz mb b">FooSemigroup</code>的上下文中运行代码，让<code class="fe mx my mz mb b">Foo</code>类拥有<code class="fe mx my mz mb b">combine</code>方法。</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="db49" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">接下来，我们需要type类返回一个“空”值的能力，该值是<code class="fe mx my mz mb b">combine</code>方法的标识。幸运的是，已经有了一个类型类。</p><h2 id="ccde" class="mf jv iq bd jw mk ml dn ka mm mn dp ke ld mo mp ki lh mq mr km ll ms mt kq mu bi translated">幺半群</h2><p id="320b" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">幺半群扩展了<code class="fe mx my mz mb b">Semigroup</code>并增加了一个<code class="fe mx my mz mb b">empty</code>元素:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="8cd4" class="mf jv iq bd jw mk ml dn ka mm mn dp ke ld mo mp ki lh mq mr km ll ms mt kq mu bi translated">科特林中的平方幂运算</h2><p id="c55a" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">现在，我们可以通过对任何幺半群求平方来实现幂运算，因为我们只需要<code class="fe mx my mz mb b">empty</code>和<code class="fe mx my mz mb b">combine</code>。这里我使用非递归实现，因为它比“安全”(即尾递归)递归实现更容易理解:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="e68d" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">快速斐波那契</h1><p id="7209" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们即将实现我们的快速斐波那契算法。但是首先我们需要实现一个<code class="fe mx my mz mb b">Matrix22</code>类:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="35cc" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">这只是一个包含4个字段的类，每个字段对应一个2 x2矩阵的元素:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/5fda1ae54751340eef080261db5790ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:318/format:webp/1*NJzVb4utK0DdGdkG0bxVSg.png"/></div></figure></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="64e7" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">然后我们需要为<code class="fe mx my mz mb b">Matrix</code>实现一个幺半群。为此，我们需要知道如何将两个2x2矩阵相乘。如果你不熟悉这种类型的数学不要担心，这只是一个你可以在网上不同地方找到的公式(像<a class="ae lq" href="https://www.mathsisfun.com/algebra/matrix-multiplying.html" rel="noopener ugc nofollow" target="_blank">这里</a>)。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="bc90" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">结尾的最后一点只是一个Kotlin技巧，所以我们可以很容易地访问这个幺半群类。</p><p id="bb40" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">然后，我们最终可以使用我之前提到的公式实现斐波那契:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/ff3b68cb637d45ab6c1df7d38c004a87.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*N7-oNhAF4lLyt7Cb2KUQgw.png"/></div></figure><p id="9fc9" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">为了得到<code class="fe mx my mz mb b">F(n)</code>,我们只需要用乘幂乘平方将斐波那契矩阵乘以n次。比方说</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi of"><img src="../Images/2a8d3c2e4f6de2f0c41b2f3264808156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*Xw9q_EcHgNcrz7MFf_MptQ.png"/></div></figure><p id="5970" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">然后我们有:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi og"><img src="../Images/490c0246a47eb7ec968d73d2d7f7a5c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PGHawdoxAAkwZ7HsLEYZEw.png"/></div></div></figure><p id="49f0" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">简而言之，<code class="fe mx my mz mb b">F(n) = b</code>其中<code class="fe mx my mz mb b">b</code>是乘方幂运算结果的<code class="fe mx my mz mb b">x01</code>元素:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="fa88" class="mf jv iq bd jw mk ml dn ka mm mn dp ke ld mo mp ki lh mq mr km ll ms mt kq mu bi translated">结果</h2><p id="8a15" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我做了一个快速基准测试:第一列是<code class="fe mx my mz mb b">n</code>，第二列是以毫秒为单位计算<code class="fe mx my mz mb b">F(n)</code>所用的时间，最后一列是存储结果所用的位数:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="c929" class="mf jv iq mb b gy mg mh l mi mj">n,       time, bits<br/>100000,  53,   69424<br/>200000,  39,   138848<br/>400000,  118,  277696<br/>800000,  263,  555393<br/>1600000, 516,  1110786</span></pre><p id="de7d" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">您可以看到，该算法计算非常大的n数，并且计算斐波那契数比在控制台中打印它花费的时间要少！</p><h1 id="0758" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">复杂性</h1><p id="ea25" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">现在我们可以看看时间复杂度。</p><h2 id="b25f" class="mf jv iq bd jw mk ml dn ka mm mn dp ke ld mo mp ki lh mq mr km ll ms mt kq mu bi translated">“线性”实施</h2><p id="de06" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在文章的开头，我提到过只要记住最后两个值，就可以为Fibonacci写一个线性实现。可以这样做:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="fb1f" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">我说这是“线性”的，因为循环有<code class="fe mx my mz mb b">n</code>个步骤，然而，我们需要看看每个步骤做了多少工作。这里的工作是通过加法和减法完成的，对于<code class="fe mx my mz mb b">BigInteger</code>，具有线性复杂度。因此，“线性”实现的最终复杂度是<code class="fe mx my mz mb b">O(n²)</code>。这与我为这个实现做的快速基准测试是一致的:当我加倍<code class="fe mx my mz mb b">n</code>时，总时间乘以<code class="fe mx my mz mb b">3.9</code></p><h2 id="a1a1" class="mf jv iq bd jw mk ml dn ka mm mn dp ke ld mo mp ki lh mq mr km ll ms mt kq mu bi translated">“对数”实现</h2><p id="ad7c" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">平方取幂将执行<code class="fe mx my mz mb b">log₂(n)</code>步骤，所以我们可以称之为<em class="ni">对数</em>实现。然而，和前面的例子一样，我们需要看看每一步实际完成了多少工作。</p><p id="7ba7" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">每一步都包括一系列的乘法和加法。加法具有线性时间复杂度，然而乘法，取决于它是如何实现的，可以高达<code class="fe mx my mz mb b">O(n²)</code>。我从Heinz Kabutz那里找到了这篇文章，声称在Java 8之前乘法是在T1中完成的，但是现在乘法是通过T2和T3中两种更快的算法实现的。</p><p id="6731" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">为了便于讨论，我们假设乘法运算在<code class="fe mx my mz mb b">O(n^k)</code>中进行了一段时间<code class="fe mx my mz mb b">1.4 &lt; k &lt; 1.6</code>。我们可以假设在平方乘幂算法的每一步，数字的大小都翻倍。这意味着在<code class="fe mx my mz mb b">i-th </code>步骤，所需的工作量是<code class="fe mx my mz mb b">(2^i)^k</code>。形式上，所有<code class="fe mx my mz mb b">log(n)</code>步骤的总工作量是:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/7eaf728aa47cb5eba08b474b0903c9d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*1ksQSmnbSelkCxgND-KqIw.png"/></div></figure><p id="c1ff" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">在上面的求和中，我们只关心最占优势的项(最后一项)，所以我们有:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/9ac06298c8f335bde955c4b52946daad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*At6rsfCud1AloKSxMvHLLw.png"/></div></figure><p id="2949" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">我做了同样的快速基准测试，我在每一轮都将<code class="fe mx my mz mb b">n</code>翻倍，我测量平均起来，总时间乘以<em class="ni"> 2.79 </em> (x2是<code class="fe mx my mz mb b">O(n)</code>，x4是<code class="fe mx my mz mb b">O(n²)</code>)。这对应的是<code class="fe mx my mz mb b">k=1.48</code>，和亨氏的文章一致。</p><p id="1dac" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">下面是我做的一个比较“线性”(实际上是<code class="fe mx my mz mb b">O(n²)</code>)和“对数”(实际上是~ <code class="fe mx my mz mb b">O(n^1.48)</code>)的快速基准:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="3e0d" class="mf jv iq mb b gy mg mh l mi mj">n,linear(ms),logarithmic(ms)<br/>40000,40,1<br/>80000,146,2<br/>160000,565,7<br/>320000,2325,20<br/>640000,8811,69</span></pre><h1 id="e910" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">平方取幂——其他应用</h1><p id="2e01" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">当你需要多次调用一个二元函数时，你可以通过平方来重用取幂。</p><p id="fec5" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">我很好奇<code class="fe mx my mz mb b">BigInteger</code>是如何实现它的<code class="fe mx my mz mb b">pow</code>方法的，但是看到它使用平方取幂，我并不感到惊讶。不信我查查出处；)</p><p id="ba55" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">我第一次不得不使用平方取幂，是为了代码2019第22天的<a class="ae lq" href="https://adventofcode.com/2019/day/22" rel="noopener ugc nofollow" target="_blank">到来。如果你不知道AOC，我强烈鼓励你尽可能多地做拼图，它教会了我很多有趣的算法和其他编程技巧。关于2019年第22天的警告，这对我来说是写作时所有250个谜题中最具挑战性的谜题。这是因为我对</a><a class="ae lq" href="https://en.wikipedia.org/wiki/Modular_arithmetic" rel="noopener ugc nofollow" target="_blank">模运算</a>不太了解，但现在我知道基本知识了，所以我强烈建议你试一试:)</p><p id="b43a" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">如果你遇到了平方取幂的有趣用例，请在评论中告诉我:)</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="f592" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">我希望你喜欢这篇文章。你可以在这里找到代码<a class="ae lq" href="https://github.com/cesartl/arrow-fibonacci" rel="noopener ugc nofollow" target="_blank"/>。如果你喜欢这个，考虑在推特上关注我</p><div class="oj ok gp gr ol om"><a href="https://twitter.com/@cesarTronLozai" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">塞萨尔·特龙-洛扎伊</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">塞萨尔·特隆-洛扎伊的最新推文(@塞萨尔·特隆洛扎伊)。人类居住在地球上，对科学、物理充满好奇…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">twitter.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa js om"/></div></div></a></div></div></div>    
</body>
</html>