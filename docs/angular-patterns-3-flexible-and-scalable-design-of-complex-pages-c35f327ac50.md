# 角度模式 3:复杂页面的灵活和可伸缩设计

> 原文：<https://itnext.io/angular-patterns-3-flexible-and-scalable-design-of-complex-pages-c35f327ac50?source=collection_archive---------1----------------------->

在现实生活项目中使用 Angular 的经历之后，我开发了自己的一套模式，用于在大型复杂的应用程序上组织可伸缩的 Angular 代码。我认为分享它们会很有用。

我试着把它们分成小文章，尽可能简洁明了。

该系列的其他文章:

*   [1:模块组织](/angular-patterns-1-modules-organisation-d3b2224ec4cf)
*   [2:如何认真编写可复用组件](/angular-patterns-2-how-to-write-seriously-reusable-components-96be16568abc)

![](img/a2c1aa11fa7c242b1bbdb38f22ee0d28.png)

在[我的上一篇文章](/angular-patterns-2-how-to-write-seriously-reusable-components-96be16568abc)中，我谈到了从组件中移除“决策”职责的好处，以便使它们可重用。我说过，将责任委托给其父代的组件可以被视为应用程序的“砖块”，您可以将它们放在任何您想要的地方，并使它们按照您想要的方式运行。

现在是时候看看更高的图片，并尝试在应用程序页面的根组件中捆绑一组这样的“砖块”了。

乍一看，为了实现我们的目标，这些是我们需要解决的问题:

> **问题 1:** 我希望能够实例化我所有的砖块组件，并使它们工作，而不是以一个做所有事情的超级庞大的根组件结束

为了解决这个问题，我们需要在页面的不同“区域”内对砖块组件进行分组；每个区域都应该接收一组不同的数据作为输入，实例化自己的一组砖块组件，使它们工作，并向其他区域(或根组件)发送信号以响应用户交互。

> **问题 2:** 我希望能够轻松设置 OnPush 变化检测策略

“砖块”组件(即不决定任何内部状态的可重用组件)的问题在于，在它们上实现 OnPush 更改检测很棘手，同时又不能将它们绑定到父组件的特定实现(因此，失去了可重用性)。

为什么？让我们看一个例子。

上述要点中的两个组件行为非常相似，但是它们接收输入的方式不同:第一个组件接收一个空数字，而第二个组件接收一个对象，该对象的属性中包含一个数字。

OnPush 变化检测的问题(这也是它的优点，因为它大大提高了性能)是 Angular ***通过引用*** 来检查对象。如果一个对象改变了，但是它的引用没有改变，Angular 不会意识到子组件需要更新。因此，如果您更改第一个组件的输入数字，DOM 就会更新，但是如果您对第二个组件进行同样的操作，DOM 将保持不变。

这个问题有几种解决方法，这取决于您想要实现的目标。其中一个是使用不可变对象(我会把你重定向到[这篇清晰的文章](https://angular-2-training-book.rangle.io/handout/change-detection/enforcing_immutability.html))。

所有这些变通办法的问题是，实现其中的一个或另一个，您会以某种方式将自己绑定到使用该组件的特定上下文中。因此，您在可重用性上有所损失。

让我们看看不可变对象的例子，例如:如果你采用这种策略，你必须在你的组件中硬编码不可变对象的方法。

在输入不是不可变的上下文中，这个组件是不可重用的。

所以，回到我们想要解决的问题列表:实现 OnPush 策略而不丧失我们的“砖块”组件的可重用性肯定是其中之一。

最后，

> 问题 3: 我希望能够将页面的各个部分隔离开来

假设我们有一个代表一篇文章的页面:这个页面很复杂，包含许多不同的区域，有一个侧边栏、一个导航、文章的内容等等。所有这些组件/组件组都由来自 API 的同一个“article”对象提供支持。如果您没有实现 OnPush 变化检测策略，并且您更新了，比如说，文章的标题，那么“文章”对象将在使用它的 DOM 的所有其他部分中同时更新。这是一个页面的例子，其中部分**没有被隔离**。

隔离元件并不总是最重要的事情，这显然取决于你想要达到的目标。*问题在于 Angular 的设计倾向于让所有组件保持最新且彼此同步，因此，如果出于任何原因您需要反其道而行之，并隔离它们，您需要自己找到解决方案。*

让我重新表述一下问题 3:虽然我可以为我希望隔离页面的一部分的每种特定情况找到一种解决方法，但我更希望有一种统一的、标准的方法来强制隔离，以同样的方式，在我需要的“砖块”组件的任何给定子集上。

因此，当将大量的砖块组件捆绑到一个页面中时，这是我们必须面对的三个主要问题。总结:

1.  我必须开发一个复杂的、高度交互的页面，我确定了所有 N 个可重用的、我将使用的“砖块”组件
2.  “砖块”组件不改变它们的内部状态，它们依靠父组件来完成。如果父组件直接是根组件，并且我在那里编写所有的逻辑，那么它将变得巨大且不可维护
3.  在单个砖块组件上实现 OnPush 策略很困难，至少不影响它们的可重用性，所以我希望能够在根组件和“砖块”组件之间建立中间组件，在那里我可以安全地实现 OnPush。
4.  如果需要，我希望能够隔离页面的各个部分，这样它们就不会与根组件的其余部分共享相同的模型

我的方法通常是将页面分成不同的区域，并为每个区域定义一种控制器组件。

控制器组件负责

*   实例化我们需要的所有砖块组件
*   根据页面的上下文使它们工作
*   实施 OnPush 策略
*   与页面的其余部分交互
*   需要时强制隔离

*我个人使用“控制器”这个词，因为我个人认为它正确地描述了一个组件控制其他组件的概念；记住我是* ***不是*** *说的是 MVC 模式中的“控制器”，也不是老 AngularJS 中的“控制器”。*

因此，让我们看一个“控制器”组件的例子:我将从一个非常基本的实现开始，逐步展示我们可以推动这个模式来解决所有三个问题(代码组织、变更检测、隔离)。

上面的简单组件“控制”两个砖块组件:ArticleHeader 和 ListOfContents。

请注意我是如何维护我在几篇文章之前定义的名称空间系统[:我在控制器组件的名称前添加了一个“C”(“C”显然代表“控制器”)。](/angular-patterns-1-modules-organisation-d3b2224ec4cf)

输入是来自 API 的文章 JSON。这个 JSON 被分解，只有相关的部分被传递给子组件。记住[砖块组件，为了通用和可重用，不应该控制它们的内部状态](/angular-patterns-2-how-to-write-seriously-reusable-components-96be16568abc)，这就是我在这个控制器组件中称之为“拼接”的原因。

我们实现了第一级的代码组织:我们从子组件开始管理，而不是从页面的根组件管理所有的砖块组件，所以我们的代码看起来更干净，更易维护。

让我们更进一步，尝试让这个控制器组件与页面的其余部分进行交互。让我们想象一下，在侧边栏中有一个“发布”按钮，它将文章公开，并且必须在页面中触发不同的操作(除了明显地将值“public=true”推送给 API 之外)。

现在，为了完成控制器组件，我们需要某种通信系统来让不同的控制器组件发送和接收信号。

实现它的一种方法是向根组件发送一个规则的角度事件，如下所示:

但是，如果我们这样做，我们将让根组件负责接收该信号，并将其传递给其他控制器组件。我们不希望这样，因为我们不希望根组件负责太多事情，结果变得太大、太复杂而无法调试。

> 控制器组件需要一种方式来相互传递信号，而不必涉及根组件。只有当一些数据必须被推送到 API 时，根组件才应该被通知事件

以下是我个人在所有项目中使用的解决方案:

“调度服务”是包含对 [RxJS 主题](https://blog.angulartraining.com/rxjs-subjects-a-tutorial-4dcce0e9637f)的引用的服务。

同一主体接收和转发不同类型的信号。组件可以注入 dispatcher 服务，向它传递它们希望接收的信号类型列表，并接收回它们可以订阅的经过过滤的可观察对象。

一旦我们在控制器组件中实现了 dispatcher 调用，它们看起来非常简单和直观:

这是组件监听特定信号并作出相应反应的位置:

我们告诉调度程序在每次收到“发布”类型的信号时通知我们。

这是我们向调度员发送信号的地方

现在是注入“DispatcherService”的时候了(否则控制器组件将无法使用它)。**我们将在根组件的级别注入它，所以它将被精确地限定在那个组件中，并且它不会意外地将信号发送到其他地方。**

在组件级别而不是全局注入 DispatcherService 的另一个好处是，这种策略允许我们在本地注入将在特定页面中使用的所有可能的信号类型的白名单:这样我们就不会冒由于信号类型拼写错误而导致的任何难以发现的错误的风险。

*顺便说一句，我不得不说，我通常认为非全局注入器非常有用。Angular 文档倾向于警告不要在懒惰加载的模块上意外注入服务，这将使服务成为局部的而不是全局的；我个人很少使用全局服务，我宁愿警告与文档所说的相反的情况，即通过将本地服务注入模块而不是组件，意外地将本地服务变成全局服务。但这只可能是我个人的想法。*

好了，现在让我们喘口气。到目前为止，我们取得了什么成就，它在可扩展性的大背景下如何定位？

1.  我们收集了页面中需要的所有可重用的“砖块”组件
2.  我们决定侧边栏中使用的所有组件都可以组合在同一个“控制器”组件下；所有操作侧边栏的功能现在都转移到了那个组件中，留下了干净的根组件
3.  我们创建了一个 dispatcher 服务，侧边栏控制器组件使用它来发送信号；这些信号被其他控制器部件接收，从而做出反应
4.  我们的控制器组件也接收来自其他控制器组件的信号:在调度程序可以发送的所有可能的信号中，该组件只过滤它需要的信号

我们现在需要将变更检测和隔离放入图片中。但是，在此之前，我想对控制器组件的最新实现做一个微小但重要的重构:

我所做的是将之前在“deleteContent”中的两行代码分开:控制器现在所做的只是向调度程序发送一个信号，告诉它一个元素被删除了。然后，在构造函数中，组件单独监听相同的信号，并相应地删除内容。

***模型“文章”不直接进行修改，而是在收到信号后进行修改。***

1.  砖块组件发送一个事件，表示某个元素已被删除
2.  控制器组件向调度员发送信号
3.  控制器组件监听它刚刚发送的相同信号，并修改模型“文章”
4.  砖块组件在变化检测标记中相应地更新自身

为什么这是有益的？因为，正如砖块组件一样，将责任委托给其他人会使我们的控制器组件更加可重用。

假设稍后我们需要修改页面，我们想要删除相同的元素，但是这一次是因为页面中其他地方发生了一些事件。由于我们刚刚进行的重构，这种修改非常容易:从外部发出相同的信号就足够了，我们的控制器组件将完全按照预期运行。

我们正在设计的结构是灵活的，也是可伸缩的，因为我们足够聪明，没有在控制器组件中硬编码元素删除。

> 使用这种方法使我们能够在互不干扰的模块化模块中构建我们的应用程序:每个控制器组件只是通过发送和接收信号来与其他组件进行交互。

现在该谈谈 **OnPush** **变化检测策略**和**隔离**了。(同样，我所说的“隔离”是指在两个不同的组件中共享或不共享同一个对象的决定)。

在我看来，这两个概念非常密切相关:如果一个组件有一个对象作为它的输入，这个对象被它的引用检查，正常的 OnPush 策略将不起作用。要使 OnPush 策略起作用，您必须找到一种解决方法，其最终效果总是以某种方式在接收方组件中克隆该对象，即该组件变得孤立，因为它不再与其他组件共享同一个对象。

> 如果一个组件正确地使用了 ChangeDetectionStrategy。OnPush，它的输入对象必须被克隆，因此组件是隔离的。另一方面，如果组件不使用 OnPush，输入对象就不需要被克隆，组件也不会被隔离。

所以，简单来说， **OnPush =孤立的**。

我已经提到过，在砖块组件上实现 OnPush 策略会影响它们的可重用性。既然我们已经定义了“控制器组件”，我相信这些正是实现 OnPush 的正确位置。

*我们将分离控制器组件，而不是从变更检测树中分离砖块组件，控制器组件就是砖块组件组。这样，同一个砖块组件可以在使用 OnPush 的控制器组件和不使用 OnPush 的控制器组件中重用。*

同样，这里的关键词是**可重用性**和**可伸缩性**。

让我们再来看看我们之前的例子，让我们关注它的输入，让我们试着理解我们如何成功地实现 OnChange 策略。

在上面的要点中，我关注的是删除文章内容之一的操作，并且只显示了与变化检测相关的逻辑。

让我们问自己[关于变更检测最重要的问题:](/angular-patterns-2-how-to-write-seriously-reusable-components-96be16568abc)

> 在什么情况下我的可重用组件的 HTML 会改变？

*   首先，当“文章”输入改变时，它也会改变
*   其次，当调度程序发送名为“删除内容”的信号时，它会发生变化

如果我们想在这个组件上实现 OnPush，我们需要找到一种方法将两个事件都作为 Input()传递给**，并绕过这样的 Input()将被引用检查的问题(因为“article”是一个对象而不是一个原生变量)。**

让我们开始做第一个输入:“文章”。

使用不可变对象并不是让 OnPush 在对象上工作的唯一方法:我们将使用一种不同的、聪明的技术，包括将输入对象转化为可观察对象的**。**

我不记得我是在哪第一篇文章中读到这种技术的，但我认为[这篇文章](https://juristr.com/blog/2017/03/angular-tuning-change-detection/#observables)很好地解释了这一点。

基本上，从页面的根组件开始，不是将 article 对象作为常规输入传递，

…我们首先将它转换成一个行为主体，然后将行为主体传递给子控制器组件。

这一次，我们传递给控制器组件的输入是一个**行为主题**，而不是文章本身。在 ngOnInit 中，我们像往常一样订阅路由参数更改，但是这次我们添加了以下步骤

如果这是我们第一次从解析器接收文章，我们必须创建一个行为主题(一个在订阅时将最后存储的值发送给订阅者的主题)。

如果这不是第一次，并且路由器正在刷新组件而没有重新实例化它，那么我们重用相同的行为主题并使用它来流传输新文章。

这是我们的旧控制器组件中的相应实现:

当根组件通过 behaviour subject 推送一个新的文章时，输入的引用不会改变，因此控制器组件不应该更新:这就是为什么我们必须调用“cdRef.markForCheck()”，这将手动触发控制器组件的更改检测。

让我们来看看这个实现的一个重要细节:根和控制器组件初始化的**顺序**。实际上，这个实现工作的一个主要原因是我们选择使用的主题是一个**行为主题**，它包含最新接收到的值，并将其传输给一个新订户。这是事件发生的顺序:

1.  父组件已初始化，并且“商品$”包含初始商品
2.  控制器组件被初始化，获得“article$”作为输入，并订阅它
3.  由于“article$”是一个行为主体，所以它没有丢弃 article 对象，并且它可以将它传递给控制器组件，即使订阅发生在主体被创建之后的

*我们完成了一半的工作:OnPush 策略现在可以很好地处理来自根组件的输入。我们仍然需要处理 dispatcher 事件，我们将在下一步处理。*

*让我们稍微休息一下，思考一下我们刚刚做了什么:为了让 OnPush 工作，使用可观察对象而不是不可变对象值得吗？*

*我认为是这样的:如果不可变对象很简单并且嵌套在一个层次上，那么使用不可变对象来触发变化检测是没问题的(您必须调用类似“parentObject.get('property ')”的方法)，但是对于具有大量嵌套的复杂对象，情况就变得复杂了。*

*通常，我工作过的复杂应用程序必须从 API 中检索大量嵌套数据和元数据，然后根组件将决定每个控制器需要数据的哪一部分，将其从原始数据对象中分离出来，并将其传递给控制器。使用 observables 实现这一点很自然也很容易，而且您不必担心对象引用。*

*当然，支持 observables 的另一点是，我们将使用它们来传递 dispatcher 事件作为输入(您将在下一段中看到):如果根组件和控制器组件之间的整个通信都使用相同的技术来处理，那就更容易了。*

*好了，现在也该处理调度程序事件了。我们将做一些非常类似的事情，并且 ***将它们作为输入*** 从根组件传递到控制器组件。*

*如果在控制器组件直接订阅调度程序的可观察值之前，*

*…我们现在需要在根组件中生成相同的可观察对象，并将其作为输入传递。*

*在根组件中:*

*请看要点的第 19 行:在构造函数调用中，我们从调度程序获取一个可观察对象。*

*然后第 9 行:我们将可观察值传递给控制器组件。*

*现在，让我们最后来看看控制器组件的相应实现:*

*先前在构造函数调用中定义的对“article.contents.splice”的调用现在放在 ngOnInit 中，作为对可观察对象收到的根组件已经通过的信号的反应。*

*当然，我们需要调用“cdRef.markForCheck”，因为我们使用的是 OnPush 策略，可观察对象的引用不变。*

*对象“article”来自根组件，它被人为地变成了一个主题，而“deleteContent”一直是一个可观察对象。不管它们来自哪里，控制器组件都以同样的方式对待它们:它只是在 ngOnInit 中订阅它们。*

*我们的目标达到了！我们的控制器组件从变更检测树中分离出来，并在需要的时候得到更新。*

*让我们看一下我们的控制器组件的可能的生命周期，以理解 ***行为主体输入*** (通过根组件来自 API 的输入)和 ***可观察输入*** (来自调度程序的输入，反过来由其他控制器组件触发)。*

1.  *根组件从 API 获取物品对象，将其转化为行为主体；还有一种可能是，API 负载比文章本身大得多(例如，它可以是一个文章列表)，在这种情况下，根组件必须创建主题，并只将它需要的文章传递给它:无论如何，从控制器组件的角度来看，这并不重要，它只是接收一个可观察的流文章*
2.  *我们开发的控制器组件接收文章，这与根组件持有的对象不同，因此它是独立的*
3.  *属于我们页面的其他控制器组件相互交互，订阅“DELETE_CONTENT”事件的组件将更改它们持有的“article”对象的副本。*
4.  *在 dispatcher 发送和接收了几个信号之后，我们将处于这样一种情况:实现 OnPush 和 isolation 的所有控制器组件都有可能是原始文章的不同版本*
5.  *现在，在这种情况下，如果路由器导航到指向相同根组件的不同路由，并通过从 API 推送新的一组值来重用根组件，则根组件会将新的 article 对象推送到行为主体，并且这个新的 article 将在任何地方替换“article ”,清除对它的每个特定实例所做的所有更改。*

> *行为主体输入=来自 API 的数据的 RxJS 包装器=当路由器获取新数据作为用户离开的响应时，它发生变化*
> 
> *可观察输入=对应于调度员信号的可观察输入=当其他控制器组件相互发送信号时，可观察输入发生变化*

*您可能想知道，拥有同一个原始“article”对象的几个克隆实例的实际用例是什么(上面的第 4 点)？*

*举个例子，如果你正在开发一个文章编辑器:你可能想要一个草稿，你可以在里面添加和删除一些东西，还有一个预览工具来显示文章的样子。草稿可以对应于强制隔离的控制器组件，以便用户可以在页面的该部分做他想做的事情，而不一定影响预览。*

# ***结论***

*我知道，这是一篇很长的文章，我希望它不会太难理解。*

*我试图介绍一种我个人非常熟悉的技术，所以这篇文章的目的是以某种方式传达我感觉到的这种舒适。*

*简单来说，这样做(砖块式可重用组件+控制器组件+ OnPush 和隔离)让我一直觉得自己在控制应用程序，让我觉得最复杂的应用程序也可以很容易地分解成可以按任意顺序开发的模块化块。*

*假设我必须开发一个复杂的交互式页面:*

*   *我将它分成砖块组件，并为每个组件定义签名(输入+输出)*
*   *然后，我将它们分成控制器组件，并定义哪些组件需要隔离，哪些不需要隔离*
*   *对于每个控制器组件，我清楚地写下它们必须发送给调度程序的信号列表，以及它们必须接收的信号列表*
*   *对于每个控制器组件，我还记下了它必须从 API 接收的对象列表:*
*   *现在我有了控制器组件的完整签名，这意味着发送和接收信号的完整列表，加上它们从 API 获得的对象的完整列表*
*   *最后，对于每个控制器组件，我可以画出所有输入和输出的简单图表，并从这个图表开始开发它*
*   *在整个开发过程中，我确信我做的任何事情都是模块化的，最重要的是，我可以以任何顺序开发任何控制器组件，因为我做的任何事情都不太可能破坏现有的代码*