<html>
<head>
<title>City Library — An advanced guide to Circuit Breakers in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">城市图书馆——科特林断路器高级指南</h1>
<blockquote>原文：<a href="https://itnext.io/city-library-an-advanced-guide-to-circuit-breakers-in-kotlin-256393213bdf?source=collection_archive---------3-----------------------#2021-10-26">https://itnext.io/city-library-an-advanced-guide-to-circuit-breakers-in-kotlin-256393213bdf?source=collection_archive---------3-----------------------#2021-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1b286c56110475c6c368a21158c1040a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9TzWV168ukkL7sJLFpgI_Q.jpeg"/></div></div></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="8253" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">我一直对断路器以及它们如何在软件架构中工作非常感兴趣。我还参与过使用这种设计模式的一个实现的项目。即对于网上大型分销店，很多公司都爱用Hystrix。然而，海斯特里克斯已经走到了路的尽头，一种新的替代品被称为<a class="ae lp" href="https://github.com/resilience4j/resilience4j" rel="noopener ugc nofollow" target="_blank"> resilience4j </a>。不管怎样，我已经看到了使用Hystrix的许多方式。可能性是相当广泛的，但是在实践中，在我的职业生涯中，我发现断路器设计模式实现的潜力还不到一半。像<a class="ae lp" href="https://github.com/resilience4j/resilience4j" rel="noopener ugc nofollow" target="_blank">resilie 4j</a>一样，这种软件设计模式有许多不同的实现，如<a class="ae lp" href="https://github.com/failsafe-lib/failsafe" rel="noopener ugc nofollow" target="_blank">故障保护</a>、<a class="ae lp" href="https://github.com/sony/gobreaker" rel="noopener ugc nofollow" target="_blank">断路器</a>、<a class="ae lp" href="https://github.com/FaKod/Circuit-Breaker-for-Scala" rel="noopener ugc nofollow" target="_blank">Scala断路器</a>以及许多其他的实现。</p><p id="1acc" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">提醒我们自己<a class="ae lp" href="https://en.wikipedia.org/wiki/Circuit_breaker" rel="noopener ugc nofollow" target="_blank">断路器</a>的概念自19世纪就已经存在，那时候它与电流增加到不可接受的水平时开关如何切断电路有关。快进到2017年，<a class="ae lp" href="https://twitter.com/mtnygard" rel="noopener ugc nofollow" target="_blank">迈克尔·尼加德</a>出版<strong class="kk iu">发行！设计和部署生产就绪软件(实用程序员)</strong>在这里，他将断路器设计模式的思想带到了软件开发中。</p><p id="cda3" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在本文中，我假设您已经知道断路器到底是什么，以及这种设计模式的基本内容是什么。这种设计模式允许多种类型的配置，在我们进行的过程中，我们将看看其中最重要的一些。我还假设你非常熟悉Spring T1的工作方式，并且对性能测试工具T2蝗虫T3的工作方式有所了解。了解一下<a class="ae lp" href="https://en.wikipedia.org/wiki/Reactive_programming" rel="noopener ugc nofollow" target="_blank">反应式编程</a>在<a class="ae lp" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html" rel="noopener ugc nofollow" target="_blank"> Spring WebFlux </a>中是如何使用的也很重要。我们将要看到的实现位于<a class="ae lp" href="https://github.com/jesperancinha/advanced-library-management" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="41a8" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">1.情况</h1><p id="da48" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated">出于演示的目的，我们将建造一个城市图书馆！。我们本质上是要向图书馆提供一本或多本书，只是为了阅读的目的而在线提供给用户。在我们实际构建我们的库的软件之前，我们马上就要考虑这个库是否能满足弹性期望。由于许多用户将使用图书馆，它必须不断地提供给用户。图书馆有一个完美的服务，已经在云中使用了反应式Spring WebFlux技术。唯一的缺点是，云提供商有时会进入维护模式。不过，图书馆有一个后备服务。阁楼上一台非常旧的服务器也是为高可用性而设计的。虽然它是一个本地安装，但对于普通的库用户来说已经足够好了。如果需要这种回退，预计库用户将会经历一些延迟。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/67157ad25d6af3bcd501e308e42d2029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*yDSUVlkPWR92JGQX5IeXxw.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">案件的草图</figcaption></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="7a96" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">2.断路器</h1><p id="13f7" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">在本节</span>中，我们将通过我设计的单元测试来分析断路器的具体特性。我们将检查断路器状态如何变化，并了解如何通过Spring health端点看到这一点。最后，我们将对一起工作的断路器进行彻底的分析，并对结果进行图形分析。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/84a5459f13d4ddeee98594db345531cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kEqAYyVcpaWmm8TVJ8Wb6w.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">已实施项目概述</figcaption></figure><p id="f1d4" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">为了继续我们的例子，重要的是我们首先看一下一些重要的实现基础。理解以下内容也很重要:在Kotlin代码中，我们的断路器设置实际上没有什么变化，因此，我们将只看一下测试1中断路器实现的实现。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">使用已实施的断路器almr_testcase_1实施案例1服务</figcaption></figure><p id="92e5" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">查看这个类，我们看到测试用例1的断路器名称是<strong class="kk iu"> <em class="nf"> almr_testcase_1 </em> </strong>。这个实现很容易理解。我们只需要看到回退方法能够接收原始方法的输入参数，并且可以在备选方法调用中使用该参数。例如，如果我们试图获取Id=1的书，然后我们得到一个<strong class="kk iu"> <em class="nf"> TimeoutException </em> </strong>，我们将陷入重载方法<strong class="kk iu"> <em class="nf"> getBookByIdJPA </em> </strong>，该方法试图调用我们的JPA服务。在我们的例子中，我们假设JPA服务总是可用的。这一切都是可能的，因为我们已经用<strong class="kk iu"><em class="nf">circuit breaker</em></strong>注释了我们的原始方法，即名为<strong class="kk iu"><em class="nf">getBookCBById</em></strong>的方法。这样，如果我们调用<strong class="kk iu"><em class="nf">getBookViaReactiveServiceById</em></strong>并且成功，我们就不必使用回退方法。然而，如果确实如此，那么我们就陷入了<strong class="kk iu"> <em class="nf">电路断路器</em> </strong>算法，这就是本文的目的。</p><p id="ebe9" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">为了了解这个项目的幕后，我们了解我们的<strong class="kk iu"><em class="nf">webclient interface</em></strong>是做什么的也很重要。在这种情况下，检查在运行容器时发生的实现是很重要的。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="417b" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">正如我们之前看到的，这是我们创建我们的发布者或<strong class="kk iu"> <em class="nf"> Mono的</em> </strong>的地方。它们将调用反应服务或非反应服务，这取决于与断路器算法的交互。</p><p id="073a" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在是时候检查测试中发生了什么。在这种情况下，单元测试非常广泛，所以我不会像往常一样在本文中展示整个类。在这种情况下，为了便于说明，将只显示代码的重要部分。但是可以在<a class="ae lp" href="https://github.com/jesperancinha/advanced-library-management/tree/main/advanced-library-mngmt-gate/src/test/kotlin/org/jesperancinha/management/gate/services" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看代码。</p><h1 id="b627" class="lq lr it bd ls lt ng lv lw lx nh lz ma mb ni md me mf nj mh mi mj nk ml mm mn bi translated"><em class="nl"> 2.1。门1测试— </em> almr_testcase_1 <em class="nl"> —一般属性。</em></h1><p id="6216" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">在</span>这次测试中，我们检查了<code class="fe nm nn no np b">registerHealthIndicator</code>、<code class="fe nm nn no np b">slidingWindowSize</code>、<code class="fe nm nn no np b">slidingWindowSizeType</code>、<code class="fe nm nn no np b">minimumNumberOfCalls</code>、<br/>、<code class="fe nm nn no np b">automaticTransitionFromOpenToHalfOpenEnabled</code>和<code class="fe nm nn no np b">waitDurationInOpenState</code>。</p><pre class="mu mv mw mx gt nq np nr ns aw nt bi"><span id="b0b9" class="nu lr it np b gy nv nw l nx ny"><br/><strong class="np iu">registerHealthIndicator</strong>: true<br/><strong class="np iu">slidingWindowSize</strong>: 10<br/><strong class="np iu">slidingWindowType</strong>: "COUNT_BASED"<br/><strong class="np iu">minimumNumberOfCalls</strong>: 5<br/><strong class="np iu">failureRateThreshold</strong>: 50<br/>slowCallRateThreshold: 50<br/><strong class="np iu">automaticTransitionFromOpenToHalfOpenEnabled</strong>: true<br/><strong class="np iu">waitDurationInOpenState</strong>: 1s<br/><strong class="np iu">recordExceptions</strong>:<br/>  - org.springframework.web.client.HttpServerErrorException<br/>  - java.util.concurrent.TimeoutException<br/>  - java.io.IOException<br/>  - org.jesperancinha.management.gate.exception.ReactiveAccessException<br/><strong class="np iu">ignoreExceptions</strong>:<br/>  - org.jesperancinha.management.gate.exception.IgnoredException<br/></span></pre><p id="a3c9" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">第一步是登记健康指标。该功能对于检查<strong class="kk iu"> <em class="nf">断路器</em> </strong>的状态非常重要。为了实现这一点，我们需要激活Spring actuator提供的正确的管理端点:</p><pre class="mu mv mw mx gt nq np nr ns aw nt bi"><span id="2e85" class="nu lr it np b gy nv nw l nx ny">management:<br/>  endpoints.web.exposure.include: "*"<br/>  endpoint.health.show-details: <em class="nf">always<br/>  </em>health:<br/>    circuitbreakers.enabled: true<br/>    ratelimiters.enabled: true</span></pre><p id="70a4" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这将使我们的致动器端点可用于:</p><pre class="mu mv mw mx gt nq np nr ns aw nt bi"><span id="5fc7" class="nu lr it np b gy nv nw l nx ny"><a class="ae lp" href="http://localhost:8080/api/almg/actuator/health" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/api/almg/actuator/health</a></span></pre><p id="679f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这将产生这样的结果:</p><pre class="mu mv mw mx gt nq np nr ns aw nt bi"><span id="9fab" class="nu lr it np b gy nv nw l nx ny">{<br/>   "status":"UP",<br/>   "components":{<br/>      "circuitBreakers":{<br/>         "status":"UP",<br/>         "details":{<br/>            "almr_testcase_3":{<br/>               "status":"UP",<br/>               "details":{<br/>                  "failureRate":"-1.0%",<br/>                  "failureRateThreshold":"50.0%",<br/>                  "slowCallRate":"-1.0%",<br/>                  "slowCallRateThreshold":"50.0%",<br/>                  "bufferedCalls":3,<br/>                  "slowCalls":0,<br/>                  "slowFailedCalls":0,<br/>                  "failedCalls":0,<br/>                  "notPermittedCalls":0,<br/>                  "state":"CLOSED"<br/>               }<br/>            },<br/>(...)</span><span id="8efb" class="nu lr it np b gy nz nw l nx ny">      },<br/>      "diskSpace":{<br/>         "status":"UP",<br/>         "details":{<br/>            "total":62725623808,<br/>            "free":56340504576,<br/>            "threshold":10485760,<br/>            "exists":true<br/>         }<br/>      },<br/>      "ping":{<br/>         "status":"UP"<br/>      },<br/>      "rateLimiters":{<br/>         "status":"UNKNOWN"<br/>      }<br/>   }<br/>}</span></pre><p id="64c5" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这只是断路器健康状态的简短形式。我们通常可以看到所有断路器的所有状态。在这种情况下，我们只看到almr_testcase_3 <strong class="kk iu"> <em class="nf">断路器</em> </strong>的状态。注意在这种情况下<strong class="kk iu">上升</strong>与<strong class="kk iu">关闭</strong>相同。</p><p id="d860" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">为了使我们的单元测试工作，并且这对我们所有的测试用例都有效，我创建了一个特定于健康状态的域模型，以便获得每个<strong class="kk iu"> <em class="nf">断路器</em> </strong>的状态属性。这位于<a class="ae lp" href="https://github.com/jesperancinha/advanced-library-management/tree/main/advanced-library-mngmt-gate/src/main/kotlin/org/jesperancinha/management/gate/domain" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上。</p><p id="94f2" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们现在可以看看其余的属性。<strong class="kk iu"><em class="nf">sliding window size</em></strong>，<strong class="kk iu"> slidingWindowSizeType </strong>，<strong class="kk iu">minimumnumberofcallows</strong>，<strong class="kk iu">automaticttransitionfromopentohalfopenenabled，failureRateThreshold，</strong>和<strong class="kk iu"> waitDurationInOpenState，</strong>都是我们需要配置的必备属性。Resilience4J团队提供的文档非常广泛，并且很好地记录了这一点。尽管如此，快速浏览这些属性还是很重要的。也许我们需要考虑的第一件事是断路器如何决定我们何时进入<strong class="kk iu">断开</strong>状态。一旦发生故障，它总是进入<strong class="kk iu">打开</strong>状态。随之而来的逻辑问题是它如何知道从<strong class="kk iu">打开</strong>状态回到<strong class="kk iu">关闭</strong>状态？答案是，不会。它首先需要进入一个半开的T21状态。这发生在超时之后。这个超时是由我们的第一个属性决定的:<strong class="kk iu">waitDurationInOpenState</strong><em class="nf">。</em>一旦发生这种情况，状态从<strong class="kk iu">打开</strong>变为<strong class="kk iu">半开</strong>。在那里，<strong class="kk iu">断路器</strong>会将呼叫重定向到原始服务。这里，它可以回到关闭状态<strong class="kk iu">或仅仅回到打开状态</strong>。这是由我们的下一个属性<strong class="kk iu"> failureRateThreshold </strong>决定的。在某些情况下，该失败率也决定了从<strong class="kk iu">关闭</strong>到<strong class="kk iu">打开</strong>的成功请求。故障率是通过使用其他配置参数计算的数字。<strong class="kk iu"> minimumNumberOfCalls </strong>代表开始执行该计算所需的最小调用。<strong class="kk iu"><em class="nf">sliding window size</em></strong><em class="nf"/>既可以用秒来表示，也可以用多个请求来表示。在计算失败请求的比率时，会考虑落在此滑动窗口内的所有请求。到目前为止，我们只知道如何确定一种失败的请求。这些是我们不能忽略的属性<strong class="kk iu"> ignoreExceptions。</strong>最后，我们看到属性<strong class="kk iu">automatictransfroopentohalfopenenabled</strong>为真。这仅仅意味着我们不需要等待一个请求被完成来自动地使开关从<strong class="kk iu">打开</strong>状态变为<strong class="kk iu">半开</strong>状态。它用于拐角情况。</p><p id="d2c5" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在是时候看看第一次测试了。这是对属性<code class="fe nm nn no np b">recordExceptions</code>和<code class="fe nm nn no np b">ignoreExceptions</code>的简单测试。</p><pre class="mu mv mw mx gt nq np nr ns aw nt bi"><span id="e8fd" class="nu lr it np b gy nv nw l nx ny">@Test<br/>fun testGetBookByIdTestWhenIgnoredExceptionThenNull() {<br/>    <em class="nf">every </em><strong class="np iu">{ </strong>webClient.getBookViaReactiveServiceById(100L) <strong class="np iu">} </strong>returns Mono.error(IgnoredException())<br/>    <em class="nf">every </em><strong class="np iu">{ </strong>webClient.getBookViaJpaServiceById(100L) <strong class="np iu">} </strong>returns Mono.just(BookDto(0L, "Solution"))<br/><br/>    val bookById = almG1BookService.getBookById(100L)<br/>    <em class="nf">repeat</em>(10) <strong class="np iu">{<br/>        </strong>val bookById = almG1BookService.getBookCBById(100L)<br/>        bookById.<em class="nf">shouldNotBeNull</em>()<br/>        bookById.blockOptional().ifPresent <strong class="np iu">{ </strong>book <strong class="np iu">-&gt;<br/>            </strong>book.title.<em class="nf">shouldBe</em>("Solution")<br/>            getCBStatus().<em class="nf">shouldBe</em>("UP")<br/>        <strong class="np iu">}<br/>    }<br/>    </strong>getCBStatus().<em class="nf">shouldBe</em>("UP")<br/><br/>    bookById.<em class="nf">shouldNotBeNull</em>()<br/>    bookById.blockOptional().ifPresent <strong class="np iu">{ </strong>book <strong class="np iu">-&gt; </strong>book.title.<em class="nf">shouldBe</em>("Solution") <strong class="np iu">}<br/></strong>}</span></pre><p id="5d5f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这种情况下，我们看到<strong class="kk iu"> <em class="nf">断路器</em> </strong>状态保持<strong class="kk iu">断开</strong>，即使我们抛出了异常。我们的<strong class="kk iu">ignore exception</strong>当然被忽略了。</p><p id="8d63" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们现在可以看看我们的第一个完整的测试。请注意，以下所有测试都将作为该测试的参考。</p><pre class="mu mv mw mx gt nq np nr ns aw nt bi"><span id="67fb" class="nu lr it np b gy nv nw l nx ny"><em class="nf">every </em><strong class="np iu">{ </strong>webClient.getBookViaReactiveServiceById(100L) <strong class="np iu">} </strong>returns Mono.error(ReactiveAccessException())<br/><em class="nf">every </em><strong class="np iu">{ </strong>webClient.getBookViaJpaServiceById(100L) <strong class="np iu">} </strong>returns Mono.just(BookDto(0L, "SolutionOpen"))<br/><br/>getCBStatus().<em class="nf">shouldBe</em>("UP")<br/><em class="nf">repeat</em>(4) <strong class="np iu">{<br/>    </strong>val bookById = almG1BookService.getBookCBById(100L)<br/>    bookById.<em class="nf">shouldNotBeNull</em>()<br/>    bookById.blockOptional().ifPresent <strong class="np iu">{ </strong>book <strong class="np iu">-&gt;<br/>        </strong>book.title.<em class="nf">shouldBe</em>("SolutionOpen")<br/>    <strong class="np iu">}<br/>}</strong></span></pre><p id="75df" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在第一个实例中，我们创建了4个针对被动服务失败的请求。我们从非反应式服务得到预测的响应:<strong class="kk iu"> SolutionOpen。</strong></p><pre class="mu mv mw mx gt nq np nr ns aw nt bi"><span id="c964" class="nu lr it np b gy nv nw l nx ny">getCBStatus().<em class="nf">shouldBe</em>("UP")<br/><em class="nf">every </em><strong class="np iu">{ </strong>webClient.getBookViaReactiveServiceById(100L) <strong class="np iu">} </strong>returns Mono.just(BookDto(0L, "SolutionClosed"))<br/><br/><em class="nf">runBlocking </em><strong class="np iu">{<br/>    </strong>val bookById = almG1BookService.getBookCBById(100L)<br/>    bookById.<em class="nf">shouldNotBeNull</em>()<br/>    bookById.blockOptional().ifPresent <strong class="np iu">{ </strong>book <strong class="np iu">-&gt;<br/>        </strong>book.title.<em class="nf">shouldBe</em>("SolutionClosed")<br/>    <strong class="np iu">}<br/>}</strong></span></pre><p id="88a0" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">此时，我们发出一个请求，该请求通过反应服务顺利通过。如果你还没有注意到，我们只是提出了4个不成功的请求，然后是一个成功的请求。我们的<strong class="kk iu">minimumnumberofcols</strong>设置为5，费率设置为<strong class="kk iu"> 50% </strong> <em class="nf">。</em>我们现在显然已经超过了最低可接受速率。</p><pre class="mu mv mw mx gt nq np nr ns aw nt bi"><span id="1d09" class="nu lr it np b gy nv nw l nx ny">getCBStatus().<em class="nf">shouldBe</em>("CIRCUIT_OPEN")<br/><br/><em class="nf">repeat</em>(3) <strong class="np iu">{<br/>    </strong>val bookById = almG1BookService.getBookCBById(100L)<br/>    bookById.<em class="nf">shouldNotBeNull</em>()<br/>    bookById.blockOptional().ifPresent <strong class="np iu">{ </strong>book <strong class="np iu">-&gt;<br/>        </strong>book.title.<em class="nf">shouldBe</em>("SolutionOpen")<br/>    <strong class="np iu">}<br/>}<br/><br/></strong>getCBStatus().<em class="nf">shouldBe</em>("CIRCUIT_OPEN")</span></pre><p id="bbed" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这就是为什么电路现在对于剩余的3个成功呼叫保持打开。在这个平衡的比率之后，我们应该能够回到<strong class="kk iu">关闭</strong>的状态。</p><pre class="mu mv mw mx gt nq np nr ns aw nt bi"><span id="f0f3" class="nu lr it np b gy nv nw l nx ny"><em class="nf">repeat</em>(40) <strong class="np iu">{<br/>    </strong>val bookById = almG1BookService.getBookCBById(100L)<br/>    bookById.<em class="nf">shouldNotBeNull</em>()<br/>    bookById.blockOptional().ifPresent <strong class="np iu">{ </strong>book <strong class="np iu">-&gt;<br/>        </strong>book.title.<em class="nf">shouldBe</em>("SolutionOpen")<br/>    <strong class="np iu">}<br/>}</strong></span></pre><p id="a79d" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在<strong class="kk iu"> 40调用</strong>后，我们不会回到关闭状态，因为它们都发生在不到1秒钟内，这是我们为<strong class="kk iu"> waitDurationInOpenState配置的。</strong></p><pre class="mu mv mw mx gt nq np nr ns aw nt bi"><span id="a4e4" class="nu lr it np b gy nv nw l nx ny">sleep(1000)<br/>getCBStatus().<em class="nf">shouldBe</em>("CIRCUIT_HALF_OPEN")<br/><em class="nf">repeat</em>(4) <strong class="np iu">{<br/>    </strong>val bookById = almG1BookService.getBookCBById(100L)<br/>    bookById.<em class="nf">shouldNotBeNull</em>()<br/>    bookById.blockOptional().ifPresent <strong class="np iu">{ </strong>book <strong class="np iu">-&gt;<br/>        </strong>book.title.<em class="nf">shouldBe</em>("SolutionClosed")<br/>    <strong class="np iu">}<br/>}</strong></span></pre><p id="ea73" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">等待1秒后，我们现在处于<strong class="kk iu">半开</strong>状态，但是因为我们回来了，所以滑动窗口被重置。我们还需要一个请求来返回到打开状态。</p><pre class="mu mv mw mx gt nq np nr ns aw nt bi"><span id="239c" class="nu lr it np b gy nv nw l nx ny">getCBStatus().<em class="nf">shouldBe</em>("CIRCUIT_HALF_OPEN")<br/><br/><em class="nf">runBlocking </em><strong class="np iu">{<br/>    </strong>val bookById = almG1BookService.getBookCBById(100L)<br/>    bookById.<em class="nf">shouldNotBeNull</em>()<br/>    bookById.blockOptional().ifPresent <strong class="np iu">{ </strong>book <strong class="np iu">-&gt;<br/>        </strong>book.title.<em class="nf">shouldBe</em>("SolutionClosed")<br/>    <strong class="np iu">}<br/>}<br/><br/></strong>getCBStatus().<em class="nf">shouldBe</em>("UP")</span></pre><p id="2d7c" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这个测试展示了如何使用所有这些简单的属性。我们现在要深入研究其他不太为人所知但同样重要的属性。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/6c7c4c4eefba71f3c353a3870ec64406.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0pFRNq0Y226B0LxX5Lu5iw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">断路器的滑动窗口图</figcaption></figure><h1 id="aa1e" class="lq lr it bd ls lt ng lv lw lx nh lz ma mb ni md me mf nj mh mi mj nk ml mm mn bi translated"><em class="nl"> 2.2。门2测试—</em>almr _ test case _ 2—automatictransfroopentohalfopenenabled</h1><p id="38d0" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">通过</span>比较这个测试和测试一，我们只想测试<br/>的<strong class="kk iu">automatictransfroopentohalfopenenabled</strong>属性的效果。</p><pre class="mu mv mw mx gt nq np nr ns aw nt bi"><span id="a67a" class="nu lr it np b gy nv nw l nx ny"><strong class="np iu">registerHealthIndicator</strong>: true<br/><strong class="np iu">slidingWindowSize</strong>: 10<br/><strong class="np iu">slidingWindowType</strong>: "COUNT_BASED"<br/><strong class="np iu">minimumNumberOfCalls</strong>: 5<br/><strong class="np iu">failureRateThreshold</strong>: 50<br/><strong class="np iu">slowCallRateThreshold</strong>: 50<br/><strong class="np iu">automaticTransitionFromOpenToHalfOpenEnabled</strong>: false<br/><strong class="np iu">waitDurationInOpenState</strong>: 1s<br/><strong class="np iu">recordExceptions</strong>:<br/>  - org.springframework.web.client.HttpServerErrorException<br/>  - java.util.concurrent.TimeoutException<br/>  - java.io.IOException<br/>  - org.jesperancinha.management.gate.exception.ReactiveAccessException<br/><strong class="np iu">ignoreExceptions</strong>:<br/>  - org.jesperancinha.management.gate.exception.IgnoredException</span></pre><p id="9d58" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">除了我们没有自动返回到<strong class="kk iu">半开</strong>之外，该测试案例与案例1完全相同。</p><pre class="mu mv mw mx gt nq np nr ns aw nt bi"><span id="29c7" class="nu lr it np b gy nv nw l nx ny"><em class="nf">repeat</em>(40) <strong class="np iu">{<br/>    </strong>val bookById = almG2BookService.getBookCBById(100L)<br/>    bookById.<em class="nf">shouldNotBeNull</em>()<br/>    bookById.blockOptional().ifPresent <strong class="np iu">{ </strong>book <strong class="np iu">-&gt;<br/>        </strong>book.title.<em class="nf">shouldBe</em>("SolutionOpen")<br/>    <strong class="np iu">}<br/>}<br/></strong>sleep(1000)<br/>getCBStatus().<em class="nf">shouldBe</em>("CIRCUIT_OPEN")<br/><em class="nf">repeat</em>(4) <strong class="np iu">{<br/>    </strong>val bookById = almG2BookService.getBookCBById(100L)<br/>    bookById.<em class="nf">shouldNotBeNull</em>()<br/>    bookById.blockOptional().ifPresent <strong class="np iu">{ </strong>book <strong class="np iu">-&gt;<br/>        </strong>book.title.<em class="nf">shouldBe</em>("SolutionClosed")<br/>    <strong class="np iu">}<br/>}</strong></span></pre><p id="f87e" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">当我们在不到一秒钟的时间内发送了40个电话后，我们像前面的例子一样等待一秒钟。然而，这次我们得到一个<strong class="kk iu">打开</strong>的状态。</p><pre class="mu mv mw mx gt nq np nr ns aw nt bi"><span id="b9e1" class="nu lr it np b gy nv nw l nx ny">getCBStatus().<em class="nf">shouldBe</em>("CIRCUIT_HALF_OPEN")<br/><br/><em class="nf">runBlocking </em><strong class="np iu">{<br/>    </strong>val bookById = almG2BookService.getBookCBById(100L)<br/>    bookById.<em class="nf">shouldNotBeNull</em>()<br/>    bookById.blockOptional().ifPresent <strong class="np iu">{ </strong>book <strong class="np iu">-&gt;<br/>        </strong>book.title.<em class="nf">shouldBe</em>("SolutionClosed")<br/>    <strong class="np iu">}<br/>}</strong></span></pre><p id="557e" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在一个或多个请求之后，它最终跳转到<strong class="kk iu">半开</strong>状态。</p><h1 id="f387" class="lq lr it bd ls lt ng lv lw lx nh lz ma mb ni md me mf nj mh mi mj nk ml mm mn bi translated"><em class="nl"> 2.3。闸门3测试— </em> almr_testcase_3 —慢速呼叫</h1><p id="26a3" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">在</span>测试中，我们检查属性<code class="fe nm nn no np b">slowCallDurationThreshold</code>和<code class="fe nm nn no np b">slowCallRateThreshold</code></p><pre class="mu mv mw mx gt nq np nr ns aw nt bi"><span id="7c78" class="nu lr it np b gy nv nw l nx ny"><strong class="np iu">registerHealthIndicator</strong>: true<br/><strong class="np iu">slowCallRateThreshold</strong>: 50f<br/><strong class="np iu">slowCallDurationThreshold</strong>: 100<br/><strong class="np iu">slidingWindowSize</strong>: 10<br/><strong class="np iu">slidingWindowType</strong>: "COUNT_BASED"<br/><strong class="np iu">minimumNumberOfCalls</strong>: 5<br/><strong class="np iu">failureRateThreshold</strong>: 50<br/><strong class="np iu">automaticTransitionFromOpenToHalfOpenEnabled</strong>: true<br/><strong class="np iu">waitDurationInOpenState</strong>: 1s<br/><strong class="np iu">recordExceptions</strong>:<br/>  - org.springframework.web.client.HttpServerErrorException<br/>  - java.util.concurrent.TimeoutException<br/>  - java.io.IOException<br/>  - org.jesperancinha.management.gate.exception.ReactiveAccessException<br/><strong class="np iu">ignoreExceptions</strong>:<br/>  - org.jesperancinha.management.gate.exception.IgnoredException</span></pre><p id="a85b" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们可以计算的另一种错误是基于慢速收集的错误。这通过<strong class="kk iu">slowcallrateshold</strong>和<strong class="kk iu">slowCallDurationThreshold</strong><em class="nf">来管理。</em>这些是以百分比和毫秒来衡量的。</p><pre class="mu mv mw mx gt nq np nr ns aw nt bi"><span id="5657" class="nu lr it np b gy nv nw l nx ny"><em class="nf">every </em><strong class="np iu">{ </strong>webClient.getBookViaReactiveServiceById(100L) <strong class="np iu">} </strong>returns Mono.just(BookDto(0L, "SolutionSlow"))<br/>    .delayElement(<br/>        Duration.ofMillis(200)<br/>    )<br/><em class="nf">every </em><strong class="np iu">{ </strong>webClient.getBookViaJpaServiceById(100L) <strong class="np iu">} </strong>returns Mono.just(BookDto(0L, "SolutionOpen"))<br/><br/>getCBStatus().<em class="nf">shouldBe</em>("UP")<br/><em class="nf">repeat</em>(4) <strong class="np iu">{<br/>    </strong>val bookById = almG3BookService.getBookCBById(100L)<br/>    bookById.<em class="nf">shouldNotBeNull</em>()<br/>    bookById.blockOptional().ifPresent <strong class="np iu">{ </strong>book <strong class="np iu">-&gt;<br/>        </strong>book.title.<em class="nf">shouldBe</em>("SolutionSlow")<br/>    <strong class="np iu">}<br/>}</strong></span></pre><p id="2ee8" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">除此之外，这个测试与测试用例1没有什么不同。唯一的区别是，这一个是基于超时的，我们可以看到，它处理超时的方式与所有其他可接受的异常相同。</p><h1 id="0fe9" class="lq lr it bd ls lt ng lv lw lx nh lz ma mb ni md me mf nj mh mi mj nk ml mm mn bi translated"><strong class="ak">2.4<em class="nl">。门4测试—almr _ test case _ 4—permittednumberofcallsinhalfonstate</em></strong></h1><p id="7cb2" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">在</span>中对比检验我们<code class="fe nm nn no np b">permittedNumberOfCallsInHalfOpenState</code>的财产。</p><pre class="mu mv mw mx gt nq np nr ns aw nt bi"><span id="425d" class="nu lr it np b gy nv nw l nx ny"><strong class="np iu">registerHealthIndicator</strong>: true<br/><strong class="np iu">slidingWindowSize</strong>: 10<br/><strong class="np iu">slidingWindowType</strong>: "COUNT_BASED"<br/><strong class="np iu">minimumNumberOfCalls</strong>: 5<br/><strong class="np iu">failureRateThreshold</strong>: 50<br/><strong class="np iu">slowCallRateThreshold</strong>: 50<br/><strong class="np iu">automaticTransitionFromOpenToHalfOpenEnabled</strong>: true<br/><strong class="np iu">waitDurationInOpenState</strong>: 1s<br/><strong class="np iu">permittedNumberOfCallsInHalfOpenState</strong>: 2<br/><strong class="np iu">recordExceptions</strong>:<br/>  - org.springframework.web.client.HttpServerErrorException<br/>  - java.util.concurrent.TimeoutException<br/>  - java.io.IOException<br/>  - org.jesperancinha.management.gate.exception.ReactiveAccessException<br/><strong class="np iu">ignoreExceptions</strong>:<br/>  - org.jesperancinha.management.gate.exception.IgnoredException</span></pre><p id="c1c2" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">属性<strong class="kk iu">permittednumberofcallsinhalpopenstate，</strong>意味着<strong class="kk iu">半开</strong>状态将保持到所配置的最大调用数。</p><pre class="mu mv mw mx gt nq np nr ns aw nt bi"><span id="3468" class="nu lr it np b gy nv nw l nx ny"><em class="nf">repeat</em>(40) <strong class="np iu">{<br/>    </strong>val bookById = almG4BookService.getBookCBById(100L)<br/>    bookById.<em class="nf">shouldNotBeNull</em>()<br/>    bookById.blockOptional().ifPresent <strong class="np iu">{ </strong>book <strong class="np iu">-&gt;<br/>        </strong>book.title.<em class="nf">shouldBe</em>("SolutionOpen")<br/>    <strong class="np iu">}<br/>}<br/></strong>sleep(1000)<br/>getCBStatus().<em class="nf">shouldBe</em>("CIRCUIT_HALF_OPEN")<br/><em class="nf">repeat</em>(4) <strong class="np iu">{<br/>    </strong>val bookById = almG4BookService.getBookCBById(100L)<br/>    bookById.<em class="nf">shouldNotBeNull</em>()<br/>    bookById.blockOptional().ifPresent <strong class="np iu">{ </strong>book <strong class="np iu">-&gt;<br/>        </strong>book.title.<em class="nf">shouldBe</em>("SolutionClosed")<br/>    <strong class="np iu">}<br/>}<br/></strong>getCBStatus().<em class="nf">shouldBe</em>("UP")</span></pre><p id="2c45" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在我们的例子中，我们配置了两个调用。因为他们成功了，我们通过了2阈值，这意味着我们直接进入<strong class="kk iu">关闭</strong>状态。应该小心使用该属性，因为它可能会绕过我们可能会用到的某些计算。</p><h1 id="1b3e" class="lq lr it bd ls lt ng lv lw lx nh lz ma mb ni md me mf nj mh mi mj nk ml mm mn bi translated"><strong class="ak">2.5<em class="nl">。门5测试— almr_testcase_5 —基于时间</em> </strong></h1><p id="6cdb" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di"> T </span>估计<code class="fe nm nn no np b">slidingWindowType</code>的<code class="fe nm nn no np b">TIME_BASED</code>值。</p><pre class="mu mv mw mx gt nq np nr ns aw nt bi"><span id="7fde" class="nu lr it np b gy nv nw l nx ny"><strong class="np iu">registerHealthIndicator</strong>: true<br/><strong class="np iu">slidingWindowSize</strong>: 1<br/><strong class="np iu">slidingWindowType</strong>: "TIME_BASED"<br/><strong class="np iu">minimumNumberOfCalls</strong>: 5<br/><strong class="np iu">failureRateThreshold</strong>: 50<br/><strong class="np iu">slowCallRateThreshold</strong>: 50<br/><strong class="np iu">automaticTransitionFromOpenToHalfOpenEnabled</strong>: true<br/><strong class="np iu">waitDurationInOpenState</strong>: 1s<br/><strong class="np iu">recordExceptions</strong>:<br/>  - org.springframework.web.client.HttpServerErrorException<br/>  - java.util.concurrent.TimeoutException<br/>  - java.io.IOException<br/>  - org.jesperancinha.management.gate.exception.ReactiveAccessException<br/><strong class="np iu">ignoreExceptions</strong>:<br/>  - org.jesperancinha.management.gate.exception.IgnoredException</span></pre><p id="d8c4" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果<strong class="kk iu">滑动窗口类型</strong>是基于<strong class="kk iu">时间的</strong> <em class="nf"> </em>，那么我们就不能轻易预测将要发生什么。我们基本上只是说我们的窗口以时间的有序方式滑动。时间是一个不容易跟上的变量，因此案例5的单元测试在预期结果方面包含了许多变化。</p><pre class="mu mv mw mx gt nq np nr ns aw nt bi"><span id="db5b" class="nu lr it np b gy nv nw l nx ny">getCBStatus() <em class="nf">shouldBeIn listOf</em>("UP", "CIRCUIT_OPEN")<br/><br/><em class="nf">repeat</em>(40) <strong class="np iu">{<br/>    </strong>val bookById = almG5BookService.getBookCBById(100L)<br/>    bookById.<em class="nf">shouldNotBeNull</em>()<br/>    bookById.blockOptional().ifPresent <strong class="np iu">{ </strong>book <strong class="np iu">-&gt;<br/>        </strong>book.title <em class="nf">shouldBeIn listOf</em>("SolutionClosed", "SolutionOpen")<br/>    <strong class="np iu">}<br/>}<br/></strong>sleep(1000)<br/>getCBStatus() <em class="nf">shouldBeIn listOf</em>("UP", "CIRCUIT_OPEN", "CIRCUIT_HALF_OPEN")<br/><em class="nf">repeat</em>(4) <strong class="np iu">{<br/>    </strong>val bookById = almG5BookService.getBookCBById(100L)<br/>    bookById.<em class="nf">shouldNotBeNull</em>()<br/>    bookById.blockOptional().ifPresent <strong class="np iu">{ </strong>book <strong class="np iu">-&gt;<br/>        </strong>book.title.<em class="nf">shouldBe</em>("SolutionClosed")<br/>    <strong class="np iu">}<br/>}</strong></span></pre></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="db21" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">5.运行示例</h1><p id="51a9" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated">为了让事情变得简单，我创建了一些脚本来运行整个应用程序。它一步到位，然后你要做的就是启动轨迹。</p><ol class=""><li id="34d3" class="ob oc it kk b kl km kp kq kt od kx oe lb of lf og oh oi oj bi translated">启动docker-撰写</li></ol><pre class="mu mv mw mx gt nq np nr ns aw nt bi"><span id="79f9" class="nu lr it np b gy nv nw l nx ny">make docker-clean-build-start</span></pre><p id="2ac5" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">2.开始蝗虫</p><pre class="mu mv mw mx gt nq np nr ns aw nt bi"><span id="dfc1" class="nu lr it np b gy nv nw l nx ny">make locust-start</span></pre><p id="6ae8" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">3.进入蝗虫主页<a class="ae lp" href="http://0.0.0.0:8089/" rel="noopener ugc nofollow" target="_blank"> http://0.0.0.0:8089/ </a></p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/49e3705aeaffa056321038482216ae83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4qlh-na5CaR507smEVV_Lg.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">蝗虫主页</figcaption></figure><p id="841f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">4.做出选择。对我来说，拥有10个用户和每秒10个用户的产卵率会更好。</p><p id="9bac" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">5.您可以选择创建一本书或几本书。查看<a class="ae lp" href="https://github.com/jesperancinha/advanced-library-management" rel="noopener ugc nofollow" target="_blank">回购</a>获取更多示例。</p><pre class="mu mv mw mx gt nq np nr ns aw nt bi"><span id="40cd" class="nu lr it np b gy nv nw l nx ny">curl -X POST -H "Content-Type: application/json" --data '{"id": 1,<br/>    "title": "Wild",<br/>    "authors": [<br/>      "Chery Strayed"<br/>    ],<br/>    "year": 2012,<br/>    "publisher": "Uitgeverij Rainbow B.V."<br/>  }' http://localhost:8080/api/almg/books/g1</span></pre><h1 id="e970" class="lq lr it bd ls lt ng lv lw lx nh lz ma mb ni md me mf nj mh mi mj nk ml mm mn bi translated"><strong class="ak"> 6。蝗虫图形</strong></h1><p id="3843" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di"> L </span> ocust是一个非常容易学习的工具，尤其是对于这个例子来说。请查看<a class="ae lp" href="https://locust.io/" rel="noopener ugc nofollow" target="_blank"> locust文档</a>中的安装说明。我已经进行了一些测试，结果可以在<a class="ae lp" href="https://github.com/jesperancinha/advanced-library-management/tree/main/docs/reports" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/52cb12701a854a0dfd79778fe5c54cfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YahoBThv4GJNHi2C2lRNYw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">waitDurationInOpenState = 1s</figcaption></figure><p id="d696" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们的默认示例运行在一个为1s的<strong class="kk iu"> waitDurationInOpenState </strong>上。这并没有提供很好的结果，纯粹是因为在<strong class="kk iu">打开</strong>状态下的1秒是很难想象的。在我们没有收到任何请求的这段时间里，我关闭了反应式服务，然后是MVC-JPA服务。为了停止这些服务，我为此创建了一些脚本。所以如果想停止反应式服务，可以使用<code class="fe nm nn no np b">make docker-stop-reactive</code>。如果你想停止MVC服务，你可以运行<code class="fe nm nn no np b">make docker-stop-mvc</code>。</p><p id="ddf2" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">过去的结果是我在<strong class="kk iu">docker</strong>Spring<strong class="kk iu">profile中将该值增加到10s的原因。</strong></p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/2c39013726e157495ed323c1fe756abc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tHuKW5FOgjX4fap8X5zrMQ.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">waitDurationInOpenState = 10s</figcaption></figure><p id="a07b" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这张图表分成三个非常明显的部分。左边部分是我启动docker映像和停止反应服务的地方。正如您所看到的，在测试开始时，似乎有一个大约10秒的较高的速率间隔，由一个低速率的小间隔隔开。所有5个断路器仍然彼此相当同步，并且它们都保持在<strong class="kk iu">打开</strong>状态10秒钟，然后返回到<strong class="kk iu">半</strong> - <strong class="kk iu">打开</strong>状态，在那里它们试图达到成功率。这从来没有发生过，相反，他们达到超时。这有助于提高下一个周期的答复率。因为所有这些断路器都有稍微不同的规则，所以它们各自对成功请求的总体比率的贡献在11:10.15和11:11.07之间变得混杂和相当同质。这是我重新激活反应服务的地方。这使得<strong class="kk iu">断路器</strong>回到<strong class="kk iu">闭合</strong>状态。成功消息的比率变高有两个原因。我们现在通过反应服务获得响应，并且电路也是<strong class="kk iu">闭合的。</strong>如果电路是<strong class="kk iu">闭合的</strong>，我们不需要引入任何测试成本。在11:12.37左右的某个时刻，我再次停止了被动服务。发送的大量消息会导致gate在大约20秒内看起来没有反应。在时间戳11:13.02，速率以与开始时相同的模式上下波动。<strong class="kk iu">断路器</strong>再次从<strong class="kk iu">打开</strong>切换到<strong class="kk iu">半开</strong>以及从<strong class="kk iu">半开</strong>切换到<strong class="kk iu">打开。</strong>正如我们之前所看到的，这些都是昂贵的操作，一旦反应服务重新上线，我们需要看看是否能让网关尽可能高效地工作。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">完整执行测试期间零故障(假设内部服务没有故障)</figcaption></figure><p id="a28e" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这张表可能是我们的结果中最令人惊讶的。正如我们所看到的，尽管我们看到了对gate的成功请求率的巨大变化，但是没有一个失败。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/168c47b5404a67293b3184a8a547b2d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*laeQv7PIn1jM8XtDYLThaw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">waitDurationInOpenState =10(没有可用的支持服务)</figcaption></figure><p id="c8e9" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">作为控制测试，我们确实看到，如果gate正在运行，请求确实会失败，但是reactive和MVC服务都关闭了。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="1db8" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">6.结论</h1><p id="b405" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated">在本文中，我们看到了断路器通过不同的配置以多种方式为我们服务。这个例子与真实场景的共同点是对其他服务和数据源的短路。断路器可以让你觉得它很像一个负载平衡器。然而，尽管有一些相似之处，差别还是相当大的。这两种解决方案都可以为我们所知的提供相同信息的数据源提供另一条路径。</p><p id="780b" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">然而，这是相似之处的终点。在断路器的情况下，这实际上取决于需求，但是替代数据源不一定必须提供与原始数据源相同的数据。当主要源头出现问题时，它就会被激活。例如，主要来源可以是一组服务。如果某个连接出了问题，断路器的工作就是检测到这一点，并把所有的流量重定向到新的源头。这时我们说我们的断路器进入状态<strong class="kk iu">打开</strong>。</p><p id="52e9" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">正如我们所看到的，我们也有一个检测算法，一旦它再次可用，就再次返回到主源。反过来，这可能取决于错误频率给定缓慢的请求或只是后端的错误。我们还可以定义重要的错误，以及我们可以忽略的错误。我们也可以将其配置为简单的超时工作。使用超时，我们可以强制断路器尝试连接到原始源。这当然是有成本的，但是它也可以使从<strong class="kk iu">半开</strong>状态回到<strong class="kk iu">关闭</strong>状态更快。</p><p id="bb08" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们的断路器检测的方式可以非常简单，也可以非常复杂。在这种情况下，我们需要使用像<a class="ae lp" href="https://locust.io/" rel="noopener ugc nofollow" target="_blank">蝗虫</a>、<a class="ae lp" href="https://gatling.io/" rel="noopener ugc nofollow" target="_blank">加特林</a>、<a class="ae lp" href="https://jmeter.apache.org/" rel="noopener ugc nofollow" target="_blank"> JMeter </a>或其他工具，精确地研究我们希望这种配置如何对我们最有利。</p><p id="fa87" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我已经把这个应用程序的所有源代码放在了GitHub上</p><p id="54aa" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我希望你能像我喜欢写这篇文章一样喜欢它。我尽量让它简洁明了，并省略了许多小细节。</p><p id="ae27" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我很想听听你的想法，所以请在下面留下你的评论。</p><p id="cace" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">提前感谢您的帮助，感谢您的阅读！</p><h1 id="22c4" class="lq lr it bd ls lt ng lv lw lx nh lz ma mb ni md me mf nj mh mi mj nk ml mm mn bi translated">7.参考</h1><div class="om on gp gr oo op"><a href="https://resilience4j.readme.io/docs" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">介绍</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">Resilience4j是一个轻量级、易于使用的容错库，受Netflix Hystrix的启发，但专为Java 8…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">resilience4j.readme.io</p></div></div></div></a></div><div class="om on gp gr oo op"><a href="https://locust.io/" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">locust——现代负载测试框架</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">编辑描述</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">locust.io</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd jz op"/></div></div></a></div><div class="om on gp gr oo op"><a href="https://www.luminis.eu/blog/building-resilient-connections-using-a-circuit-breaker/" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">使用断路器建立弹性连接-照明</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">软件系统是越来越多的集成系统。它们与数据存储、日志和监控系统相集成…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">www.luminis.eu</p></div></div><div class="oy l"><div class="pe l pa pb pc oy pd jz op"/></div></div></a></div><div class="om on gp gr oo op"><a href="https://www.webagesolutions.com/blog/how-to-use-resilience4j-to-implement-circuit-breaker" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">如何用Resilience4j实现断路器？</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">本课程改编自网络时代课程通过Spring Boot和Spring Cloud掌握微服务。电路…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">www.webagesolutions.com</p></div></div><div class="oy l"><div class="pf l pa pb pc oy pd jz op"/></div></div></a></div><div class="om on gp gr oo op"><a href="https://camel.apache.org/components/latest/eips/resilience4jConfiguration-eip.html" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">Apache Camel帮助您集成300多个不同的系统！</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">配置滑动窗口的类型，当断路器处于…状态时，滑动窗口用于记录呼叫结果</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">camel.apache.org</p></div></div></div></a></div></div></div>    
</body>
</html>