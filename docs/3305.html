<html>
<head>
<title>Angular Universal + Caching (TransferState)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度通用+缓存(传输状态)</h1>
<blockquote>原文：<a href="https://itnext.io/angular-universal-caching-transferstate-96eaaa386198?source=collection_archive---------0-----------------------#2019-11-19">https://itnext.io/angular-universal-caching-transferstate-96eaaa386198?source=collection_archive---------0-----------------------#2019-11-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9b8a237bbe661e87a25322d26923d808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vBZA7FnNGH2VwpyiSkHaKQ.png"/></div></div></figure><p id="9cd0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Angular Universal是服务器端渲染Angular应用程序的一个很好的解决方案。它允许我们为SEO设置元标签，在社交网络上共享，但最重要的是在服务器上呈现我们的页面，这样用户就可以获得已经呈现的页面，这意味着更快更流畅的性能。</p><p id="92df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，大多数时候开发者并没有利用SSR的所有优势。例如，在某些情况下，它们会阻止(isPlatFormBrowser) api调用，因此，服务器会呈现一个没有数据的页面，而客户端会在前端再次呈现数据(数据在前端获取)，这导致了所谓的“闪烁”故障。在其他情况下，服务器(ssr)在呈现页面的同时向API发出请求，但是同样的请求也在前端发出，这意味着对已经从服务器获取的数据的双重请求。</p><p id="07ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">相反，我们应该让服务器上的通用获取所有GET请求，将其存储在某个地方，当客户端(前端)发出请求时，它将获取已经获取的数据，而不会向api服务器发出任何额外的请求。</p><h2 id="8346" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">默认解决方案<em class="ls"> TransferHttpCacheModule </em></h2><p id="8580" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">是的，有一个专门的模块，<code class="fe ly lz ma mb b">TransferHttpCacheModule</code> <em class="mc"> </em>正是我们想要的。它将注册一个拦截器，当SSR获取数据时，它将数据保存在状态中，前端将从状态中获取数据，而无需发出额外的请求。</p><p id="79fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你所需要做的就是将来自<strong class="kd iu"> @nguniversal/common </strong>的<code class="fe ly lz ma mb b">TransferHttpCacheModule</code>添加到你的App模块的imports数组中。</p><p id="c786" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，在你的服务器模块中从<strong class="kd iu">@ angular/platform-Server</strong>导入<code class="fe ly lz ma mb b">ServerTransferStateModule</code>。</p><p id="bd5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在此之后，如果没有像服务器/浏览器检查这样的阻塞部分，您将看到页面得到渲染，但在网络选项卡中没有调用，因为Angular Universal已经获取了数据并作为状态传递给fronted。然而，有一件事需要考虑。这就是它所做的一切，仅此而已。在许多情况下，我们希望编写自己的缓存机制，不幸的是，这在这个模块中是不可能的。然而，最好的部分是我们可以编写自己的拦截器并改变/获得状态。</p><h2 id="50f1" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">问题是</h2><p id="d2af" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">作为一个例子(对我来说这是一个真正的问题),考虑下面的情况。当任何用户想要打开包含公共数据的公共页面时，SSR将向API端点发出请求，获取数据，呈现数据并发送回用户。现在，假设您有一个非常大的用户群，同一页面在一秒钟内被请求10-20次。每隔一秒钟，SSR就会发出一个请求，获得几乎相同的数据，并将其传递给transferState。这已经很糟糕了，因为我们提出了太多的请求，即使我们知道数据很可能是相同的。现在认为SSR将尝试从第三方服务器获取一些公共数据。我们来说一份美国总统的名单。第三方服务器每秒只能从一个IP地址发出10个请求。现在，如果超过10个人同时试图打开该页面，SSR将向第三方api发出10+个请求，很可能会被禁止。事情是，当所有的请求都由服务器处理时，服务器本身只是一台有自己IP地址的计算机，所以所有的请求都来自同一个IP地址。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div class="gh gi md"><img src="../Images/6484867ab8205980c04b364b2260a8a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*rMuMIXLF2s6JUjntqB0-mg.png"/></div></figure><p id="4ef4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了解决这个特殊的问题以及一次又一次请求相同的、未更改的数据的问题，我们需要为transferstate编写自己的逻辑。</p><p id="903b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">缓存和手动管理传输状态</strong></p><p id="43b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先让我们编写与<code class="fe ly lz ma mb b">TransferHttpCacheModule</code>中使用的相同(或非常相似)的拦截器。</p><ol class=""><li id="f61c" class="mi mj it kd b ke kf ki kj km mk kq ml ku mm ky mn mo mp mq bi translated">创建一个新文件<code class="fe ly lz ma mb b">serverstate.interceptor.ts</code></li></ol><figure class="me mf mg mh gt ju"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="4b88" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当SSR从api获得数据时，拦截器将使用请求url作为键，并将实际的响应体存储在一个特殊的对象中(transferState)。</p><p id="ac00" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2.在服务器模块中注册<code class="fe ly lz ma mb b">serverstate.interceptor.ts</code></p><pre class="me mf mg mh gt mt mb mu mv aw mw bi"><span id="3838" class="kz la it mb b gy mx my l mz na">providers: [{<br/>  provide: HTTP_INTERCEPTORS,<br/>  useClass: ServerStateInterceptor,<br/>  multi: <em class="mc">true<br/></em>}],</span></pre><p id="0bf0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">3.现在，来自SSR请求的所有响应都将存储在transferState中。我们需要创建另一个拦截器，这次是为前端创建的，这样它就可以从状态(如果存在的话)中获取数据，而不是重新获取数据。</p><p id="6b77" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建新文件browserstate.interceptor.ts</p><figure class="me mf mg mh gt ju"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="cfe8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们检查请求方法是否是GET，如果不是，我们将请求传递给下一个拦截器或http客户端。</p><p id="43b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们尝试从transferState获取保存的数据。如果有数据，我们用我们的数据创建一个新的HttpResponse对象并返回它，所以没有其他拦截器会拦截这个请求。如果对于给定的键(URL ), transferState中没有任何内容，我们就将请求传递给下一个拦截器或http客户端来实际发出请求。</p><p id="5743" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">4.在您的应用模块中添加<code class="fe ly lz ma mb b">BrowserStateInterceptor</code></p><pre class="me mf mg mh gt mt mb mu mv aw mw bi"><span id="6ad5" class="kz la it mb b gy mx my l mz na">providers: [<br/>  {<br/>    provide: HTTP_INTERCEPTORS,<br/>    useClass: BrowserStateInterceptor,<br/>    multi: <em class="mc">true</em>,<br/>  }<br/>],</span></pre><p id="41a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">5.最后从应用程序模块中删除<code class="fe ly lz ma mb b">TransferHttpCacheModule</code></p><p id="fcdd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，现在我们拥有与<code class="fe ly lz ma mb b">TransferHttpCacheModule</code>几乎相同的功能，但采用了我们的定制解决方案。然而，这并没有解决我们的缓存和频繁请求的问题。</p><p id="5d2a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">缓存</strong></p><p id="b08d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个想法很简单。当用户第一次打开一个页面时，SSR将向API服务器发出请求，获取数据，保存在transferState中，并使用相同的键(请求url)保存在某个本地数据库中。对于下一个用户请求，我们将检查给定的关键字(请求url)在我们的本地数据库中是否有条目。如果是，我们将把它保存在transferState中，并作为HttpResponse返回，这样就不会对API服务器发出实际的请求。如果没有，我们将重复第一步，从API获取，保存在transferState和本地数据库中。</p><p id="a735" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以为本地服务器数据库实现自己的逻辑(甚至可以是简单的数组或对象)。我将使用<code class="fe ly lz ma mb b">memory-cache</code>节点模块。</p><p id="f2d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe ly lz ma mb b">npm i memory-cache</code></p><p id="3149" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可能还想安装<code class="fe ly lz ma mb b">@types/memory-cache</code>来进行更好的类型检查。</p><p id="382b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将它包含在您的<code class="fe ly lz ma mb b">serverstate.interceptor.ts file</code>中</p><pre class="me mf mg mh gt mt mb mu mv aw mw bi"><span id="e9ec" class="kz la it mb b gy mx my l mz na"><em class="mc">import </em>* <em class="mc">as </em>memoryCache <em class="mc">from </em>'memory-cache';</span></pre><p id="238d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，让我们修改<em class="mc"> next.handle() </em>中的逻辑，在本地数据库中添加来自API服务器的响应</p><p id="f81a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">更改以下部分(突出显示新添加的代码)</p><pre class="me mf mg mh gt mt mb mu mv aw mw bi"><span id="3354" class="kz la it mb b gy mx my l mz na"><em class="mc">if </em>(event <em class="mc">instanceof </em>HttpResponse) {<br/>  <em class="mc">this</em>.transferState.set(makeStateKey(req.url), event.body);<br/>  <strong class="mb iu">memoryCache.put(req.url, event.body);</strong><br/>}</span></pre><p id="bd18" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在返回<em class="mc"> next.handle() </em>之前，我们需要检查本地数据库并从那里返回值</p><pre class="me mf mg mh gt mt mb mu mv aw mw bi"><span id="f1e7" class="kz la it mb b gy mx my l mz na"><strong class="mb iu"><em class="mc">const </em>cachedData = memoryCache.get(req.url);<br/><em class="mc">if </em>(cachedData) {<br/>  <em class="mc">this</em>.transferState.set(makeStateKey(req.url), cachedData);<br/>    <em class="mc">return </em>of(<em class="mc">new </em>HttpResponse({ body: cachedData, status: 200 }));<br/>}</strong></span><span id="963d" class="kz la it mb b gy nb my l mz na"><em class="mc">return </em>next.handle(req).pipe(<br/>.....</span></pre><p id="15d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了这个我们就差不多准备好了。现在，只需要从SSR向API服务器发出一个请求，所有用户都将从我们的SSR服务器本地数据库中获得保存的数据。然而，这给我们带来了另一个问题。可能我们不想将这些数据永远保存在本地数据库中。至少我们有时会想更新它。嗯，我们可以创建一个函数，从那里清除所有本地数据库或选定的键。但是我们需要以某种方式触发这个函数(可能是通过api调用)。或者我们可以做得更好。我们可以设置时间，并在该时间后使我们的本地数据无效。<code class="fe ly lz ma mb b">memory-cache</code>模块支持带有效期的密钥。如果您使用自定义解决方案，您可以使用<code class="fe ly lz ma mb b">setTimeout()</code>来实现。</p><p id="c4b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们再次修改代码，以便存储在本地数据库中的每个响应数据在5分钟内有效。在这5分钟内，所有用户都将从我们的本地数据库中获取数据，因此不会进行API调用。在使本地数据无效后，新的请求将触发新的API调用，新的数据将在我们的本地数据库中再存储5分钟，以此类推。</p><pre class="me mf mg mh gt mt mb mu mv aw mw bi"><span id="40c6" class="kz la it mb b gy mx my l mz na"><em class="mc">if </em>(event <em class="mc">instanceof </em>HttpResponse) {<br/>  <em class="mc">this</em>.transferState.set(makeStateKey(req.url), event.body);<br/>  memoryCache.put(req.url, event.body, <strong class="mb iu">6000 * 5</strong>);<br/>}</span></pre><p id="505f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，如果你运行你的应用程序，你会看到没有工作！！！将会有无限的(实际上在这种情况下需要5分钟)加载。</p><p id="8513" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实际上，问题不在于<code class="fe ly lz ma mb b">memory-cache</code>或您的定制解决方案。问题在于角度通用处理异步代码。</p><blockquote class="nc nd ne"><p id="01b1" class="kb kc mc kd b ke kf kg kh ki kj kk kl nf kn ko kp ng kr ks kt nh kv kw kx ky im bi translated">Angular Universal不会完成页面渲染，直到有未完成的异步事件</p></blockquote><p id="ee5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的<code class="fe ly lz ma mb b">memory-cache</code>模块在内部使用<code class="fe ly lz ma mb b">setTimeout()</code>,在我们的例子中，Universal将等待5分钟，这样任务队列将为空，只有在那之后它才会完成它的任务。</p><p id="2e65" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为最后一步，为了解决这个问题，我们可以告诉Angular在Angular区域之外运行这个代码。</p><pre class="me mf mg mh gt mt mb mu mv aw mw bi"><span id="2912" class="kz la it mb b gy mx my l mz na"><em class="mc">constructor</em>(<em class="mc">private </em>transferState: TransferState, <strong class="mb iu"><em class="mc">private </em>ngZone: NgZone</strong>) {}<br/>....</span><span id="7080" class="kz la it mb b gy nb my l mz na"><em class="mc">return </em>next.handle(req).pipe(<br/>  tap(event =&gt; {<br/>    <em class="mc">if </em>(event <em class="mc">instanceof </em>HttpResponse) {<br/>      <em class="mc">this</em>.transferState.set(makeStateKey(req.url), event.body);<br/>      <strong class="mb iu"><em class="mc">this</em>.ngZone.runOutsideAngular(() =&gt; {<br/>        memoryCache.put(req.url, event.body, 1000 * 60);<br/>      })</strong><br/><br/>    }<br/>  })<br/>);</span></pre><p id="9db4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以现在，代替默认的和基本的<code class="fe ly lz ma mb b">TransferHttpCacheModule</code>，我们有了全功能的自定义传输状态机制，可以用很多很多其他方式修改。</p><p id="512e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae ni" href="https://gist.github.com/jacksnipe24/ee3ab674a26862bd44caee75e0774f20" rel="noopener ugc nofollow" target="_blank">服务器状态拦截器</a>和<a class="ae ni" href="https://gist.github.com/jacksnipe24/354048f535966a58cbff98e911e4f563" rel="noopener ugc nofollow" target="_blank">浏览器状态拦截器</a>的最终代码。</p><p id="7a26" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读。</p></div></div>    
</body>
</html>