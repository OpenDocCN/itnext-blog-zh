<html>
<head>
<title>How to use PHP to build microservice?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用PHP搭建微服务？</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-use-php-to-implement-microservice-94957206abc6?source=collection_archive---------0-----------------------#2019-08-10">https://itnext.io/how-to-use-php-to-implement-microservice-94957206abc6?source=collection_archive---------0-----------------------#2019-08-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/da24a6caab4c5815504f64f1e9b14657.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KH-i7gZC9UEUELeMhnAugg.jpeg"/></div></div></figure><p id="8a10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我们主要介绍如何使用PHP构建一个微服务架构。要知道PHP也是与时俱进的，也是有能力支持大型系统的微服务架构的。</p><h1 id="9503" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">服务化的挑战</h1><p id="31cd" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">Php使用<code class="fe mc md me mf b">traditional framework</code> ( <code class="fe mc md me mf b">laravel</code>、<code class="fe mc md me mf b">yii</code>、<code class="fe mc md me mf b">symfony</code>)实现微服务，效果很差。</p><p id="a39a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为什么？</p><p id="5e92" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe mc md me mf b">fpm</code>的开发模式中，由于无法提供常驻内存，每个请求都必须通过开始加载一个进程来退出进程，从零开始，增加了很多无用的开销。</p><p id="cd67" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，数据库连接不能被重用和保护，因为<code class="fe mc md me mf b">fpm</code>是基于进程的，而<code class="fe mc md me mf b">fpm</code>进程的数量也决定了并发的数量。这些都是<code class="fe mc md me mf b">fpm</code>开发的简单给我们出的问题。</p><p id="bbd4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它与docker等微服务工具不够友好，必须依赖nginx提供服务。</p><p id="a495" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以，这些就是为什么<code class="fe mc md me mf b">Java</code>比<code class="fe mc md me mf b">PHP</code>更受欢迎的原因。除了<code class="fe mc md me mf b">PHP non-memory resident</code>，还有很多其他问题需要解决。</p><p id="4e6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们来看看Swoft是如何实现微服务的。</p><h1 id="855a" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">什么是Swoft？</h1><p id="1930" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">Swoft是一个基于Swoole扩展的PHP微服务协程框架。像Go一样，Swoft有一个内置的协程web服务器和一个公共的协程客户端，驻留在内存中，独立于传统的PHP-FPM。</p><p id="120b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有类似Go的语言操作，类似Spring的云框架灵活的注解，强大的全局依赖注入容器，全面的服务治理，灵活强大的AOP，标准的PSR规范实现等等。</p><h1 id="e4a9" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Swoft Github</h1><ul class=""><li id="07e3" class="mg mh it kd b ke lx ki ly km mi kq mj ku mk ky ml mm mn mo bi translated"><a class="ae mp" href="https://github.com/swoft-cloud/swoft" rel="noopener ugc nofollow" target="_blank">https://github.com/swoft-cloud/swoft</a></li></ul><h1 id="f772" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">我们需要什么来建立一个微服务？</h1><ul class=""><li id="39a5" class="mg mh it kd b ke lx ki ly km mi kq mj ku mk ky ml mm mn mo bi translated">高性能应用框架</li><li id="00e4" class="mg mh it kd b ke mq ki mr km ms kq mt ku mu ky ml mm mn mo bi translated">服务注册和发现</li><li id="9f5c" class="mg mh it kd b ke mq ki mr km ms kq mt ku mu ky ml mm mn mo bi translated">服务断路器</li><li id="2b16" class="mg mh it kd b ke mq ki mr km ms kq mt ku mu ky ml mm mn mo bi translated">服务限制</li><li id="353e" class="mg mh it kd b ke mq ki mr km ms kq mt ku mu ky ml mm mn mo bi translated">配置中心</li></ul><p id="f413" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">哦，一切都准备好了</p><h1 id="dd02" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Swoft的高性能</h1><p id="a2a0" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">你可以想象常驻记忆给我们带来的好处。</p><ul class=""><li id="bd5f" class="mg mh it kd b ke kf ki kj km mv kq mw ku mx ky ml mm mn mo bi translated"><strong class="kd iu">仅启动框架初始化一次</strong>我们可以专注于处理请求，因为框架只能在启动时在内存中初始化一次，用于常驻内存</li><li id="b5c0" class="mg mh it kd b ke mq ki mr km ms kq mt ku mu ky ml mm mn mo bi translated"><strong class="kd iu">连接复用</strong>，一些工程师无法理解如果不使用连接池，为每个请求建立连接的后果是什么？它会导致连接中的后端资源过多。对于一些基本服务，如Redis、数据库，连接是一种昂贵的消耗。</li></ul><p id="8d8f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么，有没有好的解决办法呢？答案是肯定的，很多人都在用这个叫做<code class="fe mc md me mf b">Swoft</code>的框架。<code class="fe mc md me mf b">Swoft</code>是一个具有<code class="fe mc md me mf b">Service Governance</code>特性的<a class="ae mp" href="https://en.swoft.org/docs/2.x/en/rpc-server/index.html" rel="noopener ugc nofollow" target="_blank"> RPC </a>框架。<code class="fe mc md me mf b">Swoft</code>是第一个PHP常驻内存协程全栈框架，基于<code class="fe mc md me mf b">Spring Boot</code>的核心概念，约定大于配置。</p><p id="66e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mc md me mf b">Swoft</code>提供了一种更优雅的方式来使用<code class="fe mc md me mf b">RPC</code>服务，如<code class="fe mc md me mf b">Dubbo</code>和<code class="fe mc md me mf b">Swoft</code>具有类似于<code class="fe mc md me mf b">Golang</code>的出色性能。下面是<code class="fe mc md me mf b">Swoft</code>性能发生在我的<code class="fe mc md me mf b">PC</code>上的压力测试结果。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/8c7002d17870a1d98b35359682127773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Okqnl-sOlMLlrfoyBzCAdg.png"/></div></div></figure><p id="7b34" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe mc md me mf b">ab</code>压力测试中处理速度非常惊人。使用<code class="fe mc md me mf b">i7 generation 8</code> CPU和<code class="fe mc md me mf b">16GB</code>内存，<code class="fe mc md me mf b">100000</code>请求仅使用<code class="fe mc md me mf b">5s</code>。时间在<code class="fe mc md me mf b">fpm</code>开发模式下基本不可能达到。</p><p id="fb14" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">测试也足以证明<code class="fe mc md me mf b">Swoft</code>的高性能和稳定性。</p><h1 id="c6bc" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><a class="ae mp" href="https://en.swoft.org/docs/2.x/en/ms/govern/register-discovery.html" rel="noopener ugc nofollow" target="_blank">服务注册和发现</a></h1><p id="7e7e" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在微服务治理过程中，经常会涉及到向第三方集群(如consul/etcd)发起的服务注册。本章使用swoft框架中的swoft-consul组件来实现服务注册和发现。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/78921c76799ec9dafe85119d26e76bff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FqSCaD2DdtjxefYVgTU4Sg.png"/></div></div></figure><p id="aeab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实现逻辑</p><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="2887" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><a class="ae mp" href="https://en.swoft.org/docs/2.x/en/ms/govern/breaker.html" rel="noopener ugc nofollow" target="_blank">服务断路器</a></h1><p id="0be5" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在基本断路器模式中，为了确保在断路器处于打开状态时不会调用供应商，但我们还需要额外的方法在供应商恢复服务后重置断路器。</p><p id="12b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一种可能的解决方案是断路器周期性地检测供应商的服务是否恢复。一旦恢复，状态将设置为关闭。断路器重试时，状态为半开状态。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/a165f61f9354bd942011d4f5ebda6efd.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/0*R3zx2V_JFO0mawxD.png"/></div></figure><p id="e82e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">保险丝的使用简单且功能强大。可以用一个<code class="fe mc md me mf b">@Breaker</code>来注释。<code class="fe mc md me mf b">Swoft</code>的熔丝可以用在任何场景，比如一个服务被调用。当请求第三方服务时，它可以被降级或不被呼叫。</p><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="782d" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><a class="ae mp" href="https://en.swoft.org/docs/2.x/en/ms/govern/limiter.html" rel="noopener ugc nofollow" target="_blank">服务限制</a></h1><p id="ffd1" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">流量限制、断路器、服务降级这些可以反复强调，因为它们真的很重要。当服务不起作用时，它一定是坏了。限流是一种自我保护的工具。如果没有自我保护机制，不管有多少个连接都被接收，那么当流量非常大时前端肯定会挂起，而后端无法处理所有的连接。</p><p id="997a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">流量限制是在访问稀缺资源，如闪购商品时，限制并发数和请求数，从而有效削峰平滑流量曲线。</p><p id="513a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">流量限制的目的是限制并发访问和并发请求的速率，或者在一个时间窗口内限制请求的速度，以保护系统。一旦达到或超过速率限制，请求就会被拒绝或排队。</p><p id="2ba3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mc md me mf b">Swoft</code>的流量限制底层使用令牌桶算法，底层依靠<code class="fe mc md me mf b">Redis</code>实现分布式流量限制。</p><p id="c92c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Swoft流限制不仅限制控制器，还限制任何bean中的方法，并控制方法的访问速率。下面的例子是详细的解释。</p><pre class="mz na nb nc gt nh mf ni nj aw nk bi"><span id="9563" class="nl la it mf b gy nm nn l no np">&lt;?php declare(strict_types=1);</span><span id="396f" class="nl la it mf b gy nq nn l no np">namespace App\Model\Logic;</span><span id="028c" class="nl la it mf b gy nq nn l no np">use Swoft\Bean\Annotation\Mapping\Bean;<br/>use Swoft\Limiter\Annotation\Mapping\RateLimiter;</span><span id="5215" class="nl la it mf b gy nq nn l no np">/**<br/> * Class LimiterLogic<br/> *<br/> * @since 2.0<br/> *<br/> * @Bean()<br/> */<br/>class LimiterLogic<br/>{<br/>    /**<br/>     * @RequestMapping()<br/>     * @RateLimiter(rate=20, fallback="limiterFallback")<br/>     *<br/>     * @param Request $request<br/>     *<br/>     * @return array<br/>     */<br/>    public function requestLimiter2(Request $request): array<br/>    {<br/>        $uri = $request-&gt;getUriPath();<br/>        return ['requestLimiter2', $uri];<br/>    }<br/>    <br/>    /**<br/>     * @param Request $request<br/>     *<br/>     * @return array<br/>     */<br/>    public function limiterFallback(Request $request): array<br/>    {<br/>        $uri = $request-&gt;getUriPath();<br/>        return ['limiterFallback', $uri];<br/>    }<br/>}</span></pre><p id="c8e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这支持了<code class="fe mc md me mf b">symfony/expression-language</code>的表达方式。如果速度受限，将调用<code class="fe mc md me mf b">fallback</code>中定义的<code class="fe mc md me mf b">limiterFallback</code>方法。</p><h1 id="555f" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><a class="ae mp" href="https://en.swoft.org/docs/2.x/en/ms/govern/config.html" rel="noopener ugc nofollow" target="_blank">配置中心</a></h1><p id="c318" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在讨论配置中心之前，我们先来讨论一下配置文件。我们对它并不陌生。它为我们提供了动态修改程序的能力。引用某人的话来说:</p><blockquote class="nr ns nt"><p id="985a" class="kb kc nu kd b ke kf kg kh ki kj kk kl nv kn ko kp nw kr ks kt nx kv kw kx ky im bi translated"><em class="it">系统运行时飞行姿态的动态调整！</em></p></blockquote><p id="ed3e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于单机版，我们称之为配置(文件)；对于分布式集群系统，我们称之为配置中心(系统)；</p><p id="78a7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本章以<code class="fe mc md me mf b">Apollo</code>为例，从远程配置中心获取配置和安全重启服务。如果对<code class="fe mc md me mf b">Apollo</code>不熟悉，可以先看看<code class="fe mc md me mf b">Swoft</code>扩展<code class="fe mc md me mf b"><a class="ae mp" href="https://en.swoft.org/docs/2.x/en/extra/apollo.html" rel="noopener ugc nofollow" target="_blank">Apollo</a></code>组件，阅读<code class="fe mc md me mf b">Apollo </code>官方文档。</p><p id="ff3b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本章以<code class="fe mc md me mf b">Swoft</code>中的<code class="fe mc md me mf b">Apollo</code>为例。当<code class="fe mc md me mf b">Apollo</code>配置改变时，重启服务(http-server/RPC-server/ws-server)。以下是一个代理的示例:</p><pre class="mz na nb nc gt nh mf ni nj aw nk bi"><span id="7d2a" class="nl la it mf b gy nm nn l no np">&lt;?php declare(strict_types=1);<br/></span><span id="5126" class="nl la it mf b gy nq nn l no np">namespace App\Model\Logic;</span><span id="aba1" class="nl la it mf b gy nq nn l no np">use Swoft\Apollo\Config;<br/>use Swoft\Apollo\Exception\ApolloException;<br/>use Swoft\Bean\Annotation\Mapping\Bean;<br/>use Swoft\Bean\Annotation\Mapping\Inject;</span><span id="58b1" class="nl la it mf b gy nq nn l no np">/**<br/> * Class ApolloLogic<br/> *<br/> * @since 2.0<br/> *<br/> * @Bean()<br/> */<br/>class ApolloLogic<br/>{<br/>    /**<br/>     * @Inject()<br/>     *<br/>     * @var Config<br/>     */<br/>    private $config;</span><span id="fa56" class="nl la it mf b gy nq nn l no np">    /**<br/>     * @throws ApolloException<br/>     */<br/>    public function pull(): void<br/>    {<br/>        $data = $this-&gt;config-&gt;pull('application');<br/>        <br/>        // Print data<br/>        var_dump($data);<br/>    }<br/>}</span></pre><p id="bd18" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以上是简单的阿波罗配置拉，除了这个方法，<code class="fe mc md me mf b"><a class="ae mp" href="https://en.swoft.org/docs/2.x/en/extra/apollo.html" rel="noopener ugc nofollow" target="_blank">Swoft-Apollo</a></code>提供了更多的使用方法。</p><h1 id="c8d1" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="70ea" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">至此，我们简单的微服务框架已经构建完成。如果使用传统的PHP框架，是很难实现的。但是使用Swoft非常简单。</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><div class="mz na nb nc gt of"><a href="https://github.com/swoft-cloud/swoft" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">软件云/软件</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">PHP微服务协程框架Swoft是一个基于Swoole扩展的PHP微服务协程框架…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">github.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot jz of"/></div></div></a></div></div></div>    
</body>
</html>