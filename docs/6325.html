<html>
<head>
<title>RRDtool + Prometheus — Optimizing performance and storage efficiency for aggregated metrics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RRDtool + Prometheus —优化聚合指标的性能和存储效率</h1>
<blockquote>原文：<a href="https://itnext.io/rrdtool-prometheus-optimizing-the-storage-and-the-query-performance-for-aggregated-metrics-69986bb8cb1b?source=collection_archive---------6-----------------------#2021-10-17">https://itnext.io/rrdtool-prometheus-optimizing-the-storage-and-the-query-performance-for-aggregated-metrics-69986bb8cb1b?source=collection_archive---------6-----------------------#2021-10-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fe48" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">利用旧的东西让现代变得更好</h2></div><p id="4f3a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">RRDtool是一个开创性的时间序列数据库和监控系统。自1999年以来一直存在。然而，随着监控生态系统中连续的技术炒作，该工具不为许多监控专业人员所知，也没有得到应有的重视，尽管它的强大功能在当今普罗米修斯驱动的可观测性世界中非常有用。在本文中，我们介绍了一种设计方法，其中RRDtool用于优化Prometheus的聚合指标管理。更具体地说，我们将展示这种方法如何允许我们减少Prometheus服务器上的存储，同时在可视化之前提高查询的性能和可伸缩性。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/cb63aabbbd43561623846f12cd721f8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xBq9nzBnClEEHLsmzxYlNQ.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">来自<a class="ae lb" href="https://krossboard.app/" rel="noopener ugc nofollow" target="_blank"> Krossboard </a>的截图——一个Kubernetes使用分析工具，利用了下文描述的概念。</figcaption></figure><blockquote class="ls"><p id="8824" class="lt lu iq bd lv lw lx ly lz ma mb la dk translated">这项工作是一次经验分享，强调了在构建<a class="ae lb" href="https://medium.com/swlh/bringing-prometheus-metrics-and-grafana-dashboard-for-cost-allocation-on-kubernetes-clusters-1ee7f68cd677" rel="noopener">现在流行的开源Kubernetes使用分析工具</a>时所做的设计决策。</p></blockquote></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="fa11" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">介绍</h1><p id="177c" class="pw-post-body-paragraph kf kg iq kh b ki nb jr kk kl nc ju kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">在当今的云原生计算世界中，<a class="ae lb" href="https://radar.cncf.io/2020-09-observability" rel="noopener ugc nofollow" target="_blank">可观察性</a>是监控生产中应用和服务运行的基础构件。可观察性的核心促成因素之一是收集与被监控的应用程序和服务相关的指标的能力。在这种背景下，<a class="ae lb" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank"> Prometheus </a>已经成为一个事实上的标准组件，用于在使用Grafana 等工具进行可视化之前公开、收集和汇总指标。</p><p id="5e2f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在典型的普罗米修斯架构中，每个要监控的组件都由一个<a class="ae lb" href="https://www.metricfire.com/blog/first-contact-with-prometheus/" rel="noopener ugc nofollow" target="_blank">导出器</a>支持，该导出器向普罗米修斯世界公开指标。然后，Prometheus服务器定期检查不同的导出器，以收集公开的指标。有时，收集的指标可能需要在可视化之前进行一些聚合；例如，我们的Prometheus exporters每隔几分钟就会获得更新的样本，而在可视化方面，我们只需要每小时汇总的指标。这种用例通常适用于像<a class="ae lb" href="https://rodrigue-chakode.medium.com/kubernetes-resource-usage-analytics-for-cost-allocation-and-capacity-planning-416800e85d16" rel="noopener"> kube-opex-analytics </a>这样的分析工具，其中每5分钟收集一次原始样本，同时对每小时整合的指标进行可视化。</p><p id="e0eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如上所述，当需要聚合时，人们通常依靠<a class="ae lb" href="https://prometheus.io/docs/prometheus/latest/querying/operators/" rel="noopener ugc nofollow" target="_blank"> PromQL </a> ( <em class="ng">普罗米修斯查询语言)</em>在查询时执行聚合。对于给定的时间范围，<a class="ae lb" href="https://prometheus.io/docs/prometheus/latest/querying/operators/" rel="noopener ugc nofollow" target="_blank"> PromQL操作符</a>支持各种聚合操作(求和、平均、最大、最小等等)。虽然在许多情况下使用这些操作符就足够了，但在某些情况下，这种使用可能会带来一些缺点。</p><p id="2db0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将讨论优化的两个方面:度量样本的存储以及可视化的性能和可伸缩性。</p><h1 id="a6e5" class="mj mk iq bd ml mm nh mo mp mq ni ms mt jw nj jx mv jz nk ka mx kc nl kd mz na bi translated">缺点和优化</h1><h2 id="cf59" class="nm mk iq bd ml nn no dn mp np nq dp mt ko nr ns mv ks nt nu mx kw nv nw mz nx bi translated">高效存储:避免存储无用的指标</h2><p id="9fdc" class="pw-post-body-paragraph kf kg iq kh b ki nb jr kk kl nc ju kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">为了更好地说明，让我们考虑一个用例，其中指标每5分钟收集一次，出于一致性原因，我们只想可视化每小时和每天的整合指标。</p><p id="d062" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，如果所有的5分钟样本都暴露在普罗米修斯世界中，那么<em class="ng">我们将需要单个出口者的以下存储容量:每小时12个样本，每天12 * 24 = 288个样本，每月288 * 30 = 8640个样本</em>。通过考虑每个样本的数据大小、导出者的数量、数据保留期，我们可能会在可视化之前存储和处理大量数据。</p><p id="d0df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，如果在Prometheus world中只显示每小时合并的指标，<em class="ng">我们将需要每小时存储1个样本，每天24个样本，每月24 * 30 = 720个样本</em>。很明显，在这种情况下，存储所有的原始样本是没有效率的。也就是说，随着时间的推移，需要原始样本来计算合并的指标，我们应该找到一种策略来本地处理原始样本，同时向Prometheus世界公开合并的指标。</p><p id="adb5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是RRDtool的用武之地。事实上，原始样本可以被收集并注入到RRD数据库中，该数据库被专门配置为在内部计算和维护目标粗粒度度量(例如，上述用例中的每小时度量)。</p><p id="5d67" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不深入RRDtool的更多细节，让我们举一个实现的例子。如下所示，RRD数据库设置可以配置为保存名为<code class="fe ny nz oa ob b">cpu_usage</code>的数据源，它以5分钟(300秒)的周期存储原始样本，以生成每小时整合的指标(12个原始样本的平均值)。这样，通过我们的Prometheus exporter的适当实现，我们可以只向Prometheus exporter公开每小时的指标，同时在本地维护原始样本。</p><pre class="ld le lf lg gt oc ob od oe aw of bi"><span id="850d" class="nm mk iq ob b gy og oh l oi oj">DS:cpu_usage:GAUGE:300:U:U                         RRA:AVERAGE:0.5:12:1</span></pre><h2 id="af51" class="nm mk iq bd ml nn no dn mp np nq dp mt ko nr ns mv ks nt nu mx kw nv nw mz nx bi translated">可视化性能和可伸缩性:避免重复聚合</h2><p id="f960" class="pw-post-body-paragraph kf kg iq kh b ki nb jr kk kl nc ju kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">为了深入性能和可伸缩性方面，让我们假设一旦数据存储在Prometheus中，我们将使用Grafana进行可视化。如前所述，当需要聚合时，我们通常会在可视化之前使用<a class="ae lb" href="https://prometheus.io/docs/prometheus/latest/querying/operators/" rel="noopener ugc nofollow" target="_blank">普罗米修斯算子</a>来计算聚合指标。这意味着每次在用户定义的时间段(可视化窗口)内刷新可视化时，都会从Prometheus中检索样本，并即时处理以生成整合的指标。</p><p id="0e3f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，让我们重新考虑我们的初始示例，其中每5分钟收集一次原始样本，同时对每小时整合的指标进行可视化(例如，像<a class="ae lb" href="https://github.com/rchakode/kube-opex-analytics" rel="noopener ugc nofollow" target="_blank"> kube-opex-analytics </a>所做的那样)。我们还假设我们只有一个Prometheus exporter，而可视化是在30天的滑动窗口上处理的，刷新周期为15分钟(即每小时刷新四次)。</p><p id="3a23" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第一次尝试中，如果所有的5分钟样本都暴露于普罗米修斯世界，则每次刷新可视化时将查询<em class="ng"> 8640个样本(即每小时4次，24小时96次或30天2880次)。</em></p><p id="07ba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第二次尝试中，通过在本地引入一个RRD数据库来维护原始样本，以便仅将每小时合并的指标导出到Prometheus world，那么每次刷新时将只查询<em class="ng"> 720个样本。</em>这样做可以显著提高可视化的性能和可伸缩性，这得益于每次刷新可视化时查询和聚集的样本数量的<strong class="kh ir">减少。</strong></p><h1 id="49d4" class="mj mk iq bd ml mm nh mo mp mq ni ms mt jw nj jx mv jz nk ka mx kc nl kd mz na bi translated">结论</h1><p id="8f2e" class="pw-post-body-paragraph kf kg iq kh b ki nb jr kk kl nc ju kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">在本文中，我们将描述如何使用RRDtool来优化Prometheus world的聚合指标的处理和展示。我们展示了这种方法如何让我们减少Prometheus服务器上的存储，同时提高可视化过程中查询的性能和可伸缩性。</p><p id="9a7a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这项工作实际上是从设计和构建<a class="ae lb" href="https://github.com/rchakode/kube-opex-analytics" rel="noopener ugc nofollow" target="_blank"> kube-opex-analytics </a>中学到的经验分享，这是一个现在流行的开源Kubernetes使用分析工具。部分由于RRDtool的强大功能，它最初的概念使得这个工具很快被Kubernetes社区所采用。目前，在不到3年的时间里，它总共有330+k的下载点击量。它甚至包含在商业报价中。</p></div></div>    
</body>
</html>