<html>
<head>
<title>Enhance your design of neumorphism in Flutter with inset shadows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用嵌入阴影增强你在扑动中的变形设计</h1>
<blockquote>原文：<a href="https://itnext.io/enhance-your-design-of-neumorphism-in-flutter-with-inset-shadows-1228a3fe4377?source=collection_archive---------4-----------------------#2021-03-17">https://itnext.io/enhance-your-design-of-neumorphism-in-flutter-with-inset-shadows-1228a3fe4377?source=collection_archive---------4-----------------------#2021-03-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a388" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">神经形态是去年最热门的设计话题之一。它为你的用户界面提供了一种柔和自然的感觉。这是对阴影、背景颜色/渐变和周围环境的精心选择。已经有多种在颤振中实现神经变形的包。最著名的是<a class="ae kl" href="https://pub.dev/packages/flutter_neumorphic" rel="noopener ugc nofollow" target="_blank">颤振_神经变形</a>。如果你只是想达到neumorphism的效果，我强烈推荐这个包。这个包的优势在于能够让被“压”在表面下的按钮产生动画效果。Flutter中以前的大多数文章/包都不支持这一点，因为没有像CSS那样内置的嵌入阴影。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/c21337d43249a3347ae2b7ffa187fa93.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/1*atkw9L1L7_F3n9gbrYTm8g.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">一个从抬高到按下的纽形按钮</figcaption></figure><p id="84ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://pub.dev/packages/flutter_neumorphic" rel="noopener ugc nofollow" target="_blank">flutter _ neuro morphic</a>通过扩展BoxPainter类实现了这种内部阴影效果，并使用深度值来确定阴影应该在哪里。我想采取CSS的方法，直接支持嵌入阴影，因为它会给你更多的定制能力。如果你现在看一下<a class="ae kl" href="https://pub.dev/packages/morphable_shape" rel="noopener ugc nofollow" target="_blank"> morphable_shape </a>包，有一个叫做DecoratedShadowedShape的小部件，看起来如下:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="9770" class="ld le iq kz b gy lf lg l lh li">Widget widget = DecoratedShadowedShape(<br/>    shape: shape,<br/>    shadows: shadows,<br/>    insetShadows: insetShadows,<br/>    decoration: decoration,<br/>    child: child<br/>);</span></pre><p id="f9a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它将按照以下顺序绘制自己:阴影-&gt;装饰-&gt; insetShadows -&gt;子元素-&gt;形状的边框，并根据形状参数裁剪自己。</p><p id="73be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但这不是我在本文中要直接使用的。我实际使用的是<a class="ae kl" href="https://pub.dev/packages/animated_styled_widget" rel="noopener ugc nofollow" target="_blank"> animated_styled_widget </a>包。对于这个包的概述，看看这个<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/make-implicit-and-explicit-animations-with-the-responsive-styled-widget-package-7303bffe5c53">中型职位</a>。它基本上允许您定义一个类似于CSS的样式实例，并构造一个响应性的小部件。它还允许您隐式或显式地制作动画。</p><p id="d485" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是使用这个包的神经形态按钮的样子:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/0318c628e911aa54386cd8bb17ebd302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*bA9qDiwAiF2giic2V_gucw.gif"/></div></figure><p id="5585" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相关的代码如下所示:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="25b0" class="ld le iq kz b gy lf lg l lh li">beginStyle = Style(<br/>    width: 400.toPXLength,<br/>    height: 400.toPXLength,<br/>    padding: DynamicEdgeInsets.symmetric(vertical: 20.toPXLength),<br/>    backgroundDecoration: BoxDecoration(<br/>        gradient: LinearGradient(<br/>            begin: Alignment.<em class="lk">topLeft</em>,<br/>            end: Alignment.<em class="lk">bottomRight</em>,<br/>            colors: [Colors.<em class="lk">grey</em>.shade50, Colors.<em class="lk">grey</em>.shade200])),<br/>    shapeBorder: RectangleShapeBorder(<br/>      borderRadius:<br/>          DynamicBorderRadius.all(DynamicRadius.circular(50.toPXLength)),<br/>    ),<br/>    shadows: [<br/>      DynamicShapeShadow(<br/>          blurRadius: 20.toPXLength,<br/>          spreadRadius: -5.toPXLength,<br/>          color: Colors.<em class="lk">grey</em>.shade400,<br/>          offset: DynamicOffset(20.toPXLength, 20.toPXLength)),<br/>      DynamicShapeShadow(<br/>          blurRadius: 20.toPXLength,<br/>          spreadRadius: -5.toPXLength,<br/>          color: Color(0xFFFEFEFE),<br/>          offset: DynamicOffset(-20.toPXLength, -20.toPXLength)),<br/>    ],<br/>    mouseCursor: SystemMouseCursors.<em class="lk">click</em>);</span><span id="d983" class="ld le iq kz b gy ll lg l lh li">endStyle = beginStyle.copyWith(<br/>    backgroundDecoration: BoxDecoration(<br/>        gradient: LinearGradient(<br/>            begin: Alignment.<em class="lk">topLeft</em>,<br/>            end: Alignment.<em class="lk">bottomRight</em>,<br/>            colors: [Colors.<em class="lk">grey</em>.shade50, Colors.<em class="lk">grey</em>.shade200])),<br/>    shadows:[],<br/>    insetShadows: [<br/>      DynamicShapeShadow(<br/>          blurRadius: 20.toPXLength,<br/>          spreadRadius: -5.toPXLength,<br/>          color: Colors.<em class="lk">grey</em>.shade400,<br/>          offset: DynamicOffset(20.toPXLength, 20.toPXLength)),<br/>      DynamicShapeShadow(<br/>          blurRadius: 20.toPXLength,<br/>          spreadRadius: -5.toPXLength,<br/>          color: Color(0xFFFEFEFE),<br/>          offset: DynamicOffset(-20.toPXLength, -20.toPXLength)),<br/>    ]);</span><span id="7a19" class="ld le iq kz b gy ll lg l lh li">...</span><span id="f3f3" class="ld le iq kz b gy ll lg l lh li">@override<br/>Widget build(BuildContext context) {<br/>    return AnimatedStyledContainer(<br/>        duration: Duration(milliseconds: 100),<br/>        style: toggleStyle ? beginStyle : endStyle,<br/>        child: Container());<br/>}</span></pre><p id="ce6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你只需要定义beginStyle和endStyle，框架会自动为你在它们之间制作动画。</p><p id="96b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以将两个异形按钮组合在一起，并协调它们的阴影。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lm"><img src="../Images/58b87e60a77c6e96826028874472a305.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*FNyLCuFJOafdekzB0NQ1_Q.gif"/></div></div></figure><p id="18e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的场景中，光线来自左上角。所以如果大按钮没有被按下，小按钮的左上角不会有较浅的阴影。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lm"><img src="../Images/fd9230dccd8d334c7248960708364323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*G087G-u55RDIQ_kXXHufWg.gif"/></div></div></figure><p id="ec1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者你可以将两个纽形按钮嵌套在一起，使对比度更大。该按钮的侧视图如下所示:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lr"><img src="../Images/c8dea7a0bab5b0acf837919e824da4f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3eBIqObJ9CkKWrfSdasu6A.png"/></div></div></figure><p id="9632" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于有了<a class="ae kl" href="https://pub.dev/packages/morphable_shape" rel="noopener ugc nofollow" target="_blank"> morphable_shape </a>包，你还可以在动画中轻松地改变按钮的形状。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/05afae5797121d5c7f269e6a845fd1e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*KnpQPEwP83AVRUME6e5dDw.gif"/></div></figure><p id="3643" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天就到这里。嵌入阴影支持和一个简单的方法来创建扑动中的neumorphism设计。谢谢大家！</p></div></div>    
</body>
</html>