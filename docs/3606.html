<html>
<head>
<title>Micro In Action, Part 2: An Ultimate Guide For Bootstrap</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Micro In Action，第2部分:Bootstrap终极指南</h1>
<blockquote>原文：<a href="https://itnext.io/micro-in-action-part-2-71230f01d6fb?source=collection_archive---------0-----------------------#2020-01-16">https://itnext.io/micro-in-action-part-2-71230f01d6fb?source=collection_archive---------0-----------------------#2020-01-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1158cd260edb621639a6bda14e41e198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*abXpjXsYfVsCP9QN4F0lkg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">微在行动</figcaption></figure><p id="eed2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是“Micro in Action”系列文章的第2篇，讨论了<a class="ae ld" href="https://micro.mu/" rel="noopener ugc nofollow" target="_blank"> Micro </a>。我们将一步一步地构建微服务，并在此过程中解释Micro的特性。我们将从基本概念和主题开始，然后转向高级功能。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="4f9d" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">项目布局</h1><p id="b96d" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">在上一篇文章中，我们创建了一个简单的项目并运行它。本文继续这个旅程，首先介绍项目结构和每个文件的用途。</p><p id="2bee" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">注意</strong>:由于本系列文章的主题都是微观的，无关的话题将被忽略，比如项目布局的最佳实践、如何连接数据库、依赖注入(如果有兴趣可以看<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/mastering-wire-f1226717bbac">我的另一篇文章</a>)等。因此，我们只对项目内容进行说明，不做任何不相关的调整。</p><p id="5c9f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">项目布局如下:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="794d" class="mx lm it mt b gy my mz l na nb">.<br/>├── main.go<br/>├── generate.go<br/>├── plugin.go<br/>├── proto/hello<br/>│   └── hello.proto<br/>│   └── hello.pb.go<br/>│   └── hello.pb.micro.go<br/>├── handler<br/>│   └── hello.go<br/>├── subscriber<br/>│   └── hello.go<br/>├── Dockerfile<br/>├── README.md<br/>├── .gitignore<br/>└── go.mod</span></pre><p id="dccf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">以下是项目中的文件列表:</p><ul class=""><li id="878b" class="nc nd it kh b ki kj km kn kq ne ku nf ky ng lc nh ni nj nk bi translated"><strong class="kh iu"> main.go </strong>，项目主文件，后面会详细解释</li><li id="8e43" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc nh ni nj nk bi translated"><strong class="kh iu"> generate.go </strong>，只包含一行<code class="fe nq nr ns mt b">//go:generate make proto</code>，与<code class="fe nq nr ns mt b">go generate</code>集成。确保在执行<code class="fe nq nr ns mt b"> go generate </code>期间会自动调用<code class="fe nq nr ns mt b">make proto </code></li><li id="9a49" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc nh ni nj nk bi translated"><strong class="kh iu"> plugins.go </strong>，这个文件目前是空的。按照Micro的惯例，建议在这里管理所有插件的导入，后面会用到。</li><li id="2ed7" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc nh ni nj nk bi translated"><strong class="kh iu">proto/hello/hello . proto</strong>，一个<a class="ae ld" href="https://grpc.io/docs/guides/concepts/" rel="noopener ugc nofollow" target="_blank"> gRPC </a>服务定义文件，定义了一个名为<code class="fe nq nr ns mt b">Hello</code>的RPC服务。在这个服务中，声明了3种典型的RPC方法:一元RPC、服务器流RPC和双向流RPC</li><li id="8fe3" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc nh ni nj nk bi translated"><strong class="kh iu"> proto/hello/hello.pb.go，</strong> golang源文件由<code class="fe nq nr ns mt b">protoc</code>从上述<code class="fe nq nr ns mt b">.proto</code>文件生成</li><li id="e55e" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc nh ni nj nk bi translated"><strong class="kh iu">proto/hello/hello . Pb . micro . go</strong>，golang生成的源文件<code class="fe nq nr ns mt b">protoc-gen-micro</code>，进一步简化了开发者的工作。它定义了<code class="fe nq nr ns mt b">HelloSerivce</code>接口和<code class="fe nq nr ns mt b">HelloHandler</code>接口。后者是我们实现和完成业务逻辑所需的接口</li><li id="d482" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc nh ni nj nk bi translated"><strong class="kh iu"> handler/hello.go </strong>，实现业务逻辑的文件。它定义了一个<code class="fe nq nr ns mt b">Hello</code>对象，该对象实现了<code class="fe nq nr ns mt b">HelloHandler</code>接口。</li><li id="d641" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc nh ni nj nk bi translated"><strong class="kh iu"> subscriber/hello.go </strong>，实现异步消息订阅和处理的文件。它展示了处理消息的两种不同方式，一种是通过对象方法，另一种是通过函数。</li><li id="7ca7" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc nh ni nj nk bi translated"><strong class="kh iu"> Dockerfile </strong>，定义如何构建Docker图像</li><li id="e3ac" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc nh ni nj nk bi translated"><strong class="kh iu"> Makefile </strong>，定义了几个常见的任务，编译、测试、构建Docker镜像等。</li><li id="a284" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc nh ni nj nk bi translated"><strong class="kh iu"> README.md </strong>，包含项目的基本信息</li><li id="e9e2" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc nh ni nj nk bi translated"><strong class="kh iu">。gitignore </strong>，默认忽略hello-service</li><li id="e38e" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc nh ni nj nk bi translated"><strong class="kh iu"> go.mod </strong>，go模块文件</li></ul><p id="13ea" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">注</strong>:文件夹<code class="fe nq nr ns mt b">proto</code>有特殊含义。虽然没有技术上的限制，但是在Micro的约定中，每个项目根目录下的<code class="fe nq nr ns mt b">proto</code>文件夹是用来存储“接口”文件的。这既包括项目需要向外界公开的接口，也包括项目所依赖的其他接口。例如，假设我们需要依赖另一个服务<strong class="kh iu"> foo </strong>来实现业务逻辑。然后我们将创建一个名为<code class="fe nq nr ns mt b">proto/foo</code>的文件夹，并将三个文件<code class="fe nq nr ns mt b">foo.proto, foo.pb.go, foo.pb.micro.go</code>放入其中。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="c0f6" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">自举说明</h1><p id="8edb" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">让我们来看看自举过程，<strong class="kh iu"> main.go </strong>:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="4de9" class="mx lm it mt b gy my mz l na nb">package main<br/><br/>import (<br/>   "github.com/micro/go-micro/v2"<br/>   log "github.com/micro/go-micro/v2/logger"<br/><br/>   "hello/handler"<br/>   "hello/subscriber"<br/><br/>   hello "hello/proto/hello"<br/>)<br/><br/>func main() {<br/>   // New Service<br/>   service := micro.NewService(<br/>      micro.Name("com.foo.service.hello"),<br/>      micro.Version("latest"),<br/>   )<br/><br/>   // Initialise service<br/>   service.Init()<br/><br/>   // Register Handler<br/>   hello.RegisterHelloHandler(service.Server(), new(handler.Hello))<br/><br/>   // Register Struct as Subscriber<br/>   micro.RegisterSubscriber("com.foo.service.hello", service.Server(), new(subscriber.Hello))<br/><br/>   // Run service<br/>   if err := service.Run(); err != nil {<br/>      log.Fatal(err)<br/>   }<br/>}</span></pre><p id="3137" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">代码大致分为4个部分，分别是导入依赖项、创建和初始化服务、注册业务处理处理程序和运行服务。</p><h2 id="a5a0" class="mx lm it bd ln nt nu dn lr nv nw dp lv kq nx ny lz ku nz oa md ky ob oc mh od bi translated">导入依赖关系</h2><p id="1bbe" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">这部分只有一行代码值得单独解释:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="01ca" class="mx lm it mt b gy my mz l na nb">hello "hello/proto/hello"</span></pre><p id="d3b0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将一个显式的包名<code class="fe nq nr ns mt b">hello</code>设置为<code class="fe nq nr ns mt b">hello/proto/hello</code>。这也是Micro的一个约定:为所有接口导入包设置显式包名。这避免了依赖导入代码的原始包名。在实践中，如果不做特殊设置，自动生成代码的包名会比较长。以<code class="fe nq nr ns mt b">hello.pb.go</code>为例，它的包名是<code class="fe nq nr ns mt b">com_foo_srv_hello</code>。显然，设置一个显式的包名是更好的选择。</p><h2 id="e6a0" class="mx lm it bd ln nt nu dn lr nv nw dp lv kq nx ny lz ku nz oa md ky ob oc mh od bi translated">创建和初始化服务</h2><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="a038" class="mx lm it mt b gy my mz l na nb">// New Service<br/>service := micro.NewService(<br/>   micro.Name("com.foo.srv.hello"),<br/>   micro.Version("latest"),<br/>)</span></pre><p id="b683" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们使用方法<code class="fe nq nr ns mt b">micro.NewService(opts …Option) Service</code> <strong class="kh iu"> </strong>来创建一个服务。这个方法接受multiply <code class="fe nq nr ns mt b">micro.Option</code>作为它的参数，然后创建并返回一个<code class="fe nq nr ns mt b">micro.Service</code>的实例</p><p id="b924" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">显然<code class="fe nq nr ns mt b">micro.Option</code>是控制服务的关键。上面的示例代码使用选项分别指定服务名和版本号。</p><p id="fa0d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">目前有29个选项可用于控制服务的所有方面。有些选项可以多次指定，形成叠加效果(后面会介绍)。</p><p id="f010" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然而，如此重要的选项没有任何文档。想学的话，挖<a class="ae ld" href="https://github.com/micro/go-micro/blob/v1.18.0/options.go" rel="noopener ugc nofollow" target="_blank">源码</a>是必经之路。而且大多数<code class="fe nq nr ns mt b">Option</code>的源代码没有任何注释，这进一步增加了学习的难度。</p><p id="5968" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">虽然本文无意成为Micro的终极参考手册，但我决定列出Micro v2.4.0的所有29个选项，并在下面逐一解释。因为这些选项对于理解和使用Micro非常重要，而且没有其他资料可以参考。</p><ol class=""><li id="b0e2" class="nc nd it kh b ki kj km kn kq ne ku nf ky ng lc oe ni nj nk bi translated"><strong class="kh iu">微。Name(n string)选项</strong>，指定服务名。一般命名约定是<code class="fe nq nr ns mt b">$namespace. $type. $name</code>。<code class="fe nq nr ns mt b">$namespace </code>表示项目的命名空间，<code class="fe nq nr ns mt b">$type</code>表示服务类型(如gRPC和web)。gRPC服务类型通常缩写为<code class="fe nq nr ns mt b">srv</code>。服务实例启动后，该名称将自动注册到<code class="fe nq nr ns mt b">Registry</code>中，这将成为服务发现的基础。默认为<code class="fe nq nr ns mt b">go.micro.server</code>。注意:因此，必须指定该选项，否则所有节点都使用相同的默认名称，这将导致混乱</li><li id="bbc2" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。版本(v字符串)选项</strong>，指定服务版本。默认值是启动时的格式化字符串。选择合适的版本号，结合正确的<code class="fe nq nr ns mt b">Selector</code>，可以实现优雅的旋转升级、灰度释放、A / B测试等多种操作。</li><li id="b233" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。地址(addr string)选项</strong>，指定gRPC服务地址。默认是本地主机地址和随机端口的组合。因为客户端通过<code class="fe nq nr ns mt b">Registry</code>发现服务，随机端口不会影响该发现。然而，在实践中，常常指定固定的端口号，这将有利于操作和安全控制。</li><li id="4d9a" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。注册TTL(t时间。Duration)选项</strong>，指定注册表中服务注册信息的TTL。默认值是1分钟</li><li id="894e" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。寄存器间隔(t时间。Duration)选项</strong>，指定服务向注册中心报告其状态的时间间隔。默认值为30秒。当服务遇到意外停机时，这两个与注册表相关的选项有助于避免“无效注册信息”。</li><li id="bf73" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。wrap handler(w…服务器。HandlerWrapper)选项</strong>，包装服务处理程序。它在概念上类似于<a class="ae ld" href="https://github.com/gin-gonic/gin#using-middleware" rel="noopener ugc nofollow" target="_blank"> Gin中间件</a>，并集中控制处理程序的行为。包装器可以在多个层中应用，执行顺序是从外向内(在后面的文章中将提供一个例子)</li><li id="d60e" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。wrap subscriber(w…服务器。SubscriberWrapper)选项</strong>，类似于WrapHandler，只是它用于在异步消息传递中包装订阅者。</li><li id="e8c8" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。wrap call(w…客户端。CallWrapper)选项</strong>，包装来自客户端的每个方法调用。</li><li id="24af" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。WrapClient(w …client。Wrapper)选项</strong>，包装服务客户端，可以多层应用，执行顺序是从内到外。</li><li id="b91f" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。BeforeStart(fn func() error)选项</strong>，在服务启动前设置多个回调函数。</li><li id="8221" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。BeforeStop(fn func() error)选项</strong>，服务停止前设置多个回调函数。</li><li id="705e" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。AfterStart(fn func() error)选项</strong>，服务启动后设置多个回调函数。</li><li id="6492" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。AfterStop(fn func() error)选项</strong>，服务停止后设置多个回调函数</li><li id="4d0f" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。Action(a func(*cli。Context))选项</strong>，处理命令行参数。支持子命令和标志。详见<a class="ae ld" href="https://github.com/micro/cli" rel="noopener ugc nofollow" target="_blank"> micro/cli </a></li><li id="52f6" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。标志(标志…cli。Flag)选项</strong>，处理命令行标志。详见<a class="ae ld" href="https://github.com/micro/cli" rel="noopener ugc nofollow" target="_blank"> micro/cli </a></li><li id="34fd" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。Cmd(c cmd。Cmd)选项</strong>，指定命令行处理对象。默认情况下由<code class="fe nq nr ns mt b"><a class="ae ld" href="https://github.com/micro/go-micro/blob/v2.4.0/config/cmd/cmd.go#L383" rel="noopener ugc nofollow" target="_blank">newCmd</a></code>生成，该对象支持几个默认的环境变量和命令行参数。本质上是cli.Flag的内置集合<strong class="kh iu">注</strong>:至于命令行支持，Micro同时有优点也有缺点。好处是提供了很多默认选项，可以节省开发者的时间。缺点是这种设计对用户程序有很强的侵入性:框架要求开发人员根据micro/cli以统一的方式处理他们的命令行参数。否则，程序将报告错误，并且无法运行。例如，如果我们运行<code class="fe nq nr ns mt b">./hello-service --foo=bar,</code>，我们将得到一个错误:<code class="fe nq nr ns mt b">Incorrect Usage. Flag provided but not defined: --foo=bar</code>。好在<code class="fe nq nr ns mt b">micro.Cmd</code>可以弥补侵扰带来的问题。如果一个现有的项目想要引入Micro，并且它已经有了自己的命令行处理机制，那么你需要使用<code class="fe nq nr ns mt b">micro.Cmd</code>来覆盖默认行为(同时失去默认的命令行处理能力)。关于命令行处理，本文后面将提供进一步的解释。</li><li id="3e2b" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。元数据(md map[string]string)选项</strong>，指定服务元数据。元数据通常用于标记和分组服务，实现定制的负载平衡策略等。</li><li id="3694" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。运输(t运输。Transport)选项</strong>，指定传输协议，默认为HTTP</li><li id="5628" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。选择器(s选择器。Selector)选项</strong>，指定节点选择器实现不同的加载策略。默认为随机选择器</li><li id="e385" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。注册表(r注册表。Registry)选项</strong>，指定用于服务发现的<code class="fe nq nr ns mt b">Registry</code>。默认是mDNS的<code class="fe nq nr ns mt b">Registry</code></li><li id="e017" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。服务器的服务器。服务器)选项</strong>，如果默认选项不符合您的要求，请指定自定义选项<code class="fe nq nr ns mt b">Server</code>。。默认为<code class="fe nq nr ns mt b">rpcServer</code></li><li id="487a" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。HandleSignal(b bool)选项</strong>，切换捕获TERM、INT和QUIT的信号处理程序的自动安装。默认为<code class="fe nq nr ns mt b">true</code></li><li id="2910" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。上下文(ctx上下文。Context)选项</strong>，指定服务的初始上下文。默认为<code class="fe nq nr ns mt b">context.BackGround()</code>，可用于控制使用寿命等</li><li id="155a" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。客户端(c客户端。Client)选项</strong>，指定服务客户端。默认为<code class="fe nq nr ns mt b">rpcClient</code></li><li id="4815" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。经纪人(b经纪人。Broker)选项</strong>，指定发布/订阅使用的消息代理.默认为HTTP代理</li><li id="9e11" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。个人资料(p个人资料。Profile)选项</strong>，用于调试配置文件的配置文件</li><li id="6e3c" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。Tracer(t trace。Tracer)选项</strong>，Tracer为服务设置跟踪器</li><li id="597f" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。Auth(一个auth。Auth)选项</strong>，Auth设置服务的授权。(根据官方的Slask，这个API不够稳定，没有准备好在2.4.0版本中投入生产)</li><li id="e69e" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated"><strong class="kh iu">微。配置(c配置。Config)选项</strong>，Config设置服务的配置</li></ol><p id="7264" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因此，通过指定适当的<code class="fe nq nr ns mt b">Option</code>，服务的行为可以高度定制。例如，要修改服务注册信息的TTL:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="ad5b" class="mx lm it mt b gy my mz l na nb">...<br/>// New Service<br/>service := micro.NewService(<br/>   micro.Name("foo.bar"),<br/>   micro.Version("v1.0"),<br/>   // change default TTL value<br/>   <strong class="mt iu">micro.RegisterTTL(5 * time.<em class="of">Minute</em>),</strong><br/>   ...<br/>)<br/>...</span></pre><p id="95eb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">注</strong>:以上大部分选项可以用多种方式指定。源文件中的硬编码只是其中的一种方式。事实上，Micro建议用户通过环境变量指定选项，因为这提供了更大的灵活性。以<code class="fe nq nr ns mt b">micro.RegisterTTL</code>为例，我们可以在运行时通过环境变量<code class="fe nq nr ns mt b">$ MICRO_REGISTER_TTL=value</code>或者命令行标志<code class="fe nq nr ns mt b"> —-register_ttl=value</code>(值以秒为单位)来指定。目前没有关于这些内置选项的文档。运行<code class="fe nq nr ns mt b">./hello-service -h</code>将显示它们的简要描述。想了解完整的细节，自己去挖<code class="fe nq nr ns mt b"><a class="ae ld" href="https://github.com/micro/go-micro/blob/v2.4.0/config/cmd/cmd.go#L383" rel="noopener ugc nofollow" target="_blank">newCmd</a></code>的出处。本系列的后续文章将进一步解释这个主题。</p><p id="a1f6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">创建后，您可以初始化服务:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="f618" class="mx lm it mt b gy my mz l na nb">// Initialize service<br/>service.Init()</span></pre><p id="fcdf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe nq nr ns mt b">service.Init</code>方法可以接受与<code class="fe nq nr ns mt b">micro.NewService</code>相同的参数。所以以上29个选项也可以用在<code class="fe nq nr ns mt b">service.Init</code>中。它们具有相同的效果，只是时间不同。</p><p id="5047" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因为此时已经创建了服务，所以我们可以从服务实例中检索信息。例如，您可以读取随机端口:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="580b" class="mx lm it mt b gy my mz l na nb">// Initialize service<br/><strong class="mt iu">service</strong>.<strong class="mt iu">Init</strong>(<br/>   // print log after start<br/>   micro.AfterStart(func() error {<br/>      log.Infof("service listening on %s!",<br/>         <strong class="mt iu">service.Options().Server.Options().Address,</strong><br/>      )<br/>      return nil<br/>   }),<br/>)</span></pre><h2 id="5d5b" class="mx lm it bd ln nt nu dn lr nv nw dp lv kq nx ny lz ku nz oa md ky ob oc mh od bi translated">注册业务处理者</h2><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="889d" class="mx lm it mt b gy my mz l na nb">// Register Handler<br/>hello.RegisterHelloHandler(service.Server(), new(handler.Hello))<br/><br/>// Register Struct as Subscriber<br/>micro.RegisterSubscriber("com.foo.service.hello", service.Server(), new(subscriber.Hello))</span></pre><p id="1e5c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">只有在处理程序注册之后，我们的业务代码才能真正对外提供服务。下面是两个典型的注册操作:</p><ol class=""><li id="d1c0" class="nc nd it kh b ki kj km kn kq ne ku nf ky ng lc oe ni nj nk bi translated">注册gRPC处理程序。创建一个<code class="fe nq nr ns mt b">handler.Hello</code>对象，并在<code class="fe nq nr ns mt b">Server</code>上注册它。因为<code class="fe nq nr ns mt b">handler.Hello</code>实现了<code class="fe nq nr ns mt b">HelloHandler</code>接口，所以可以传递给<code class="fe nq nr ns mt b">hello.RegisterHelloHandler</code>，否则会出错。一个<code class="fe nq nr ns mt b">Server</code>可以注册多个<code class="fe nq nr ns mt b">Handlers</code>，提供不同的业务功能。</li><li id="3442" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated">注册消息处理对象。第一个参数是消息主题，第二个参数是<code class="fe nq nr ns mt b">Server</code>，第三个参数是消息处理对象。</li></ol><p id="7c73" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">关于异步消息传递的更多细节，我们将在后面的专门文章中讨论。</p><h2 id="448f" class="mx lm it bd ln nt nu dn lr nv nw dp lv kq nx ny lz ku nz oa md ky ob oc mh od bi translated">运行服务</h2><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="7d6b" class="mx lm it mt b gy my mz l na nb">if err := service.Run(); err != nil {<br/>      log.Fatal(err)<br/>}</span></pre><p id="c0bc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">此时，服务终于开始运行了</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="3202" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">检查运行时状态</h1><p id="b459" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">正如在<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-getting-started-a79916ae3cac">上一篇文章</a>中提到的，命令行工具<code class="fe nq nr ns mt b">micro</code>可以用于在运行时检查和操作服务。让我们试一试。</p><p id="65aa" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">服务启动后，运行<code class="fe nq nr ns mt b">micro web</code>:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="9e29" class="mx lm it mt b gy my mz l na nb">$ micro web</span><span id="4a3d" class="mx lm it mt b gy og mz l na nb">2020-04-02 17:16:48  level=info service=web HTTP API Listening on [::]:8082<br/>2020-04-02 17:16:48  level=info service=web Starting [service] go.micro.web<br/>2020-04-02 17:16:48  level=info service=web Server [grpc] Listening on [::]:60537<br/>2020-04-02 17:16:48  level=info service=web Registry [mdns] Registering node: go.micro.web-dc1270ba-8b1f-4f05-92ec-57fb450efaaa</span></pre><p id="402f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如您所见，一个服务器正在本地主机端口8082上侦听。</p><p id="3201" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">注意</strong>:端口8082是默认值，可以通过环境变量或命令行标志修改。运行<code class="fe nq nr ns mt b">micro web -h</code>获取详细信息。</p><p id="b6d5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后访问<a class="ae ld" href="http://127.0.0.1:8082/service/com.foo.service.hello" rel="noopener ugc nofollow" target="_blank"><strong class="kh iu">http://127 . 0 . 0 . 1:8082/service/com . foo . service . hello</strong></a>查看服务状态。以下是截图:</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/0cfc4d73a59c8d3755c3daf960a3fa0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*joI3N6pYYCCcVm1C1itugw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">微型网络</figcaption></figure><p id="e95b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">从上面的图片中，我们可以查看关于该服务的各种信息:</p><ul class=""><li id="9bfb" class="nc nd it kh b ki kj km kn kq ne ku nf ky ng lc nh ni nj nk bi translated">服务名称</li><li id="e115" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc nh ni nj nk bi translated">服务节点列表。如果多个节点同时运行，您将看到所有节点。</li><li id="ac04" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc nh ni nj nk bi translated">每个节点的信息:版本、唯一id、地址、元数据等。</li><li id="42d7" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc nh ni nj nk bi translated">端点。服务定义、gRPC服务名、方法名、参数信息、数据类型等。</li></ul><p id="4c73" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因此可以通过<code class="fe nq nr ns mt b">micro web</code>轻松检查服务的各种运行时状态。你可能会问，<code class="fe nq nr ns mt b">./hello-service</code>和<code class="fe nq nr ns mt b">micro web</code>互不调用，它是怎么知道这个信息的？答案就在前面提到的服务发现中。Micro内置了对服务发现的支持。在默认设置下，服务发现基于mDNS，因此只要它们在同一个局域网中，它们就会自动发现彼此。</p><p id="5cbf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当然，<code class="fe nq nr ns mt b">micro web</code> <strong class="kh iu">远不止此</strong>。我们只显示与当前主题相关的功能。后续文章将对此进行更多介绍。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="3a9a" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">摘要</h1><p id="7764" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">这是“微在行动”系列文章的第二篇，我们做了几件事:</p><ol class=""><li id="2095" class="nc nd it kh b ki kj km kn kq ne ku nf ky ng lc oe ni nj nk bi translated">介绍了在前一篇文章中创建的项目布局，解释了每个文件的用途。</li><li id="a151" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated">对照源代码逐行分析一个微基础服务的引导过程。</li><li id="892a" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated">考虑到Micro缺乏文档，本文全面介绍了<code class="fe nq nr ns mt b">micro.NewService</code>支持的所有选项。</li><li id="05ff" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc oe ni nj nk bi translated">最后，我们使用<code class="fe nq nr ns mt b">micro web</code>来检查服务的运行状态</li></ol><p id="7ac4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">未完待续。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="1338" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">另请参见:</p><ul class=""><li id="43e2" class="nc nd it kh b ki kj km kn kq ne ku nf ky ng lc nh ni nj nk bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-getting-started-a79916ae3cac"> Micro In Action，第1部分:入门</a></li><li id="ef6e" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc nh ni nj nk bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part-3-calling-a-service-55d865928f11"> Micro在行动，第3部分:调用服务</a></li><li id="fbd7" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc nh ni nj nk bi translated"><a class="ae ld" href="https://medium.com/@dche423/micro-in-action-part4-pub-sub-564f3b054ecd" rel="noopener">微在行动，第4部分:发布/订阅</a></li><li id="b647" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc nh ni nj nk bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part-5-message-broker-a3decf07f26a"> Micro在行动，第5部分:消息代理</a></li><li id="5d4f" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc nh ni nj nk bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part6-service-discovery-f988988e5936">微在行动，第6部分:服务发现</a></li><li id="0472" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc nh ni nj nk bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-7-circuit-breaker-rate-limiter-431ccff6a120">微动在动作，第7部分:断路器&amp;限速器</a></li><li id="f37e" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc nh ni nj nk bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-coda-distributed-cron-job-a2b577885b24#39d6-3ace13696421">微操作，Coda:分布式Cron作业</a></li><li id="a53c" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc nh ni nj nk bi translated"><a class="ae ld" href="https://medium.com/@dche423/micro-in-action-1be29b057f2d" rel="noopener">微在行动的索引页</a></li></ul></div></div>    
</body>
</html>