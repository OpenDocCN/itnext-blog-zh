<html>
<head>
<title>Building a game with TypeScript. Entities and Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TypeScript构建游戏。实体和组件</h1>
<blockquote>原文：<a href="https://itnext.io/entity-component-system-in-action-with-typescript-f498ca82a08e?source=collection_archive---------0-----------------------#2020-07-17">https://itnext.io/entity-component-system-in-action-with-typescript-f498ca82a08e?source=collection_archive---------0-----------------------#2020-07-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a14b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于如何用TypeScript和本地浏览器API从头开始构建游戏的系列教程的第一章</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/4ef822d52ecb71d6acab1748e97c26c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8yUJBI7HOzMz1fHRoQDmAA.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://www.freepik.com/free-photos-vectors/business" rel="noopener ugc nofollow" target="_blank">free pik创建的业务向量</a></figcaption></figure><p id="8a20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎阅读“<strong class="jp ir">用打字稿</strong>构建游戏”系列的第一篇文章！我们从最广泛使用的gamedev模式之一开始我们的旅程:实体组件系统。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="323c" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">目录:</h1><ol class=""><li id="4fb4" class="mh mi iq jp b jq mj ju mk jy ml kc mm kg mn kk mo mp mq mr bi translated">什么是ECS？</li><li id="876e" class="mh mi iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">实现组件</li><li id="afcb" class="mh mi iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">实施实体</li><li id="12cf" class="mh mi iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">测试</li><li id="4993" class="mh mi iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">结论</li></ol></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="5403" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">什么是ECS？</h1><p id="a13d" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">这是一种架构模式，它允许我们组合和合成代码库的元素，而无需创建强大的层次互连。简言之，它支持在运行时将功能附加到系统元素上或从系统元素上分离。</p><p id="e421" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，但是这到底是什么意思，<em class="na">确切的说是</em>？考虑玩家可以施展魔法的RPG游戏。不同的游戏方式取决于玩家选择的角色类别。例如，法师可以施法，圣骑士可以用重剑屠杀敌人。从技术角度来说，所有这些<strong class="jp ir"> <em class="na">行为</em> </strong>都可以在玩家选职业的时候<strong class="jp ir"> <em class="na">附加</em> </strong>。更有甚者，这种情况会在<strong class="jp ir">实时</strong>中发生:当玩家达到一个新的等级，新的行为会变得对他们可用。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nb"><img src="../Images/d2ee4de569a89b594216318d7c7e55a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8nWa5Ohe52qsqg-bGUuv2Q.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://www.freepik.com/free-photos-vectors/book" rel="noopener ugc nofollow" target="_blank">由宏向量创建的书籍向量</a></figcaption></figure><p id="21c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，玩家是一个<em class="na">实体，</em>，而施展法术或用剑战斗的能力是<strong class="jp ir"> <em class="na">组件</em> </strong>。我们可以给一个实体分配不同的组件来提供新的功能，而不需要改变它的代码。</p><p id="676d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="na">一个</em> <strong class="jp ir"> <em class="na">实体</em> </strong>可以是任何东西:玩家、格子、场景、子弹，甚至游戏本身。ECS不会对实体的功能施加任何限制。只有一条规则:一个实体必须能够处理组件。</p><p id="c93a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="na">一个组件</em>可以是任何东西，只要它能附加到一个实体上。有些组件可以被一个实体<em class="na"> required </em>，意思是:没有它实体就不能真正存在。</p><p id="e89e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的游戏中，我们会有相当多的实体和组件。一个例子是船，它可以飞行、攻击、损坏等等。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="139c" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">实现组件</h1><p id="21cb" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">首先，我们应该看看我们的项目。源代码位于<a class="ae lb" href="https://github.com/soloschenko-grigoriy/gamedev-patterns-ts" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中。切换到<code class="fe nc nd ne nf b">init</code>分支，您应该会看到一个完全设置好但为空的项目。</p><p id="ae54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看一下<code class="fe nc nd ne nf b">src</code>文件夹。它只有一个空的<code class="fe nc nd ne nf b">main.ts</code>文件和一个在<code class="fe nc nd ne nf b">main.spec.ts</code>的虚拟测试。既然不再需要<code class="fe nc nd ne nf b">main.spec.ts</code>了，那就杀了吧。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/c499094a8896e35f43f1054a1f59c92a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kQl7qacDkVfKah3XHV8vmg.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://www.freepik.com/free-photos-vectors/background" rel="noopener ugc nofollow" target="_blank">free pik创建的背景矢量</a></figcaption></figure><p id="d2e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我们将创建一些助手来放置实体组件系统。我们将在后面的章节中使用ECS来构建游戏元素:船只、玩家、网格和节点。</p><p id="4cf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，这些助手不依赖于游戏本身，并且可以在其他游戏中重用。让我们首先创建一个文件夹来保存这个项目中所有类似的助手。我就叫它<code class="fe nc nd ne nf b">utils</code>。</p><p id="4fde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ECS由两个元素组成:实体和组件。我们从最简单的开始:组件。如前所述，ECS并不关心实际组件的“内部厨房”。它可以是任何东西，只要<em class="na">是组件</em>。这意味着任何声称是组件的人都必须符合组件的接口。我们来定义一下！</p><p id="715d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe nc nd ne nf b">utils</code>下，我为实体组件系统创建了一个专用文件夹，并将其命名为<code class="fe nc nd ne nf b">ecs</code>。在这个文件夹中，我创建了一个包含<code class="fe nc nd ne nf b">IComponent </code>接口的文件:<code class="fe nc nd ne nf b">component.h.ts</code>。这是我在这个项目中遵循的命名惯例之一。所有只包含类型的文件都会有后缀<code class="fe nc nd ne nf b">.h</code>(读作:<em class="na">头文件</em>)。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="d0da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还将把<em class="na">桶</em> <code class="fe nc nd ne nf b">index.ts</code>文件添加到整个项目的每个文件夹中，以避免循环依赖并简化模块的导入/导出:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1e1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以就此打住，让组件像这样超级通用。但是，它至少应该表明它属于什么实体(如果有的话！记住组件可以在任何时候从实体中分离出来)。所以，让我们稍微调整一下界面:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="52c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这时打字稿抱怨不存在的实体。是时候解决了！</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="820f" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">实施实体</h1><p id="f0cc" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">实体是一种更复杂的动物。它应该能够:</p><ol class=""><li id="5056" class="mh mi iq jp b jq jr ju jv jy ni kc nj kg nk kk mo mp mq mr bi translated">将组件添加到自身</li><li id="b67e" class="mh mi iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">将组件从自身移除</li><li id="1251" class="mh mi iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">如果添加了组件，则按其类型返回组件</li><li id="36ab" class="mh mi iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">回答问题“这个组件加不加？”</li></ol><p id="a805" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了满足所有这些需求，it必须跟踪连接的组件。换句话说，它必须保持自己的<em class="na">状态，</em>它不能成为接口。</p><p id="cfdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个实体将成为真实游戏实体的基础:玩家、子弹、船只。它们中的每一个都有自己的类型和自己的功能。实例化基本实体没有任何意义。所以，我将把它定义为一个抽象类:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><blockquote class="nl nm nn"><p id="1a0b" class="jn jo na jp b jq jr js jt ju jv jw jx no jz ka kb np kd ke kf nq kh ki kj kk ij bi translated"><em class="iq">注意，没有’。文件名中的“h”后缀。那是因为文件中包含了</em> <strong class="jp ir"> <em class="iq">实现</em> </strong> <em class="iq">，而不是一个</em><strong class="jp ir"><em class="iq"/></strong><em class="iq">(读作:类，不是一个接口)</em></p></blockquote><p id="4e76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们不要忘记调整桶文件来重新导出实体:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="a072" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该实体应该跟踪附加的组件。最简单的方法是存储该类的内部成员:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="b58c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们不希望任何外部代码搞乱这个列表，但是我们可以完全访问它的后代；因此成员是<code class="fe nc nd ne nf b">protected</code>。但是，我们可以为外部世界提供只读访问。为此，让我们为该字段添加一个公共getter:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="75ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">漂亮！现在，让我们支持组件的添加。为此，我们创建了一个专用的方法。此方法将组件添加到数组中，并设置对实体的引用:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="c931" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">厉害！接下来是<code class="fe nc nd ne nf b">GetComponent</code>。这个有点棘手。我们可以这样做:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="edf0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是它要求代码的消费者提供一个对特定组件的引用。如果他们已经有了这个参考，那就没有必要去查了。</p><p id="c24b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们应该实现的是一个方法，它通过提供的<em class="na">类型</em>返回一个对特定组件的<em class="na">引用</em>。考虑这个例子:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="f10e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现这一点，我们的GetComponent必须期望一个类型(read: <em class="na"> class </em>)，而不是一个实例(read: <em class="na"> object </em>)，然后返回该类型的组件。当然，这种类型必须符合IComponent:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="4101" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们消化一下。首先，我们定义符合<code class="fe nc nd ne nf b">IComponent</code>的类属:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="d74b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要它来链接参数中的构造函数和返回类型。</p><p id="7522" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们定义一个参数<code class="fe nc nd ne nf b">constr</code>，它必须是这个奇怪的东西的类型:<code class="fe nc nd ne nf b">{ new(...args: any[]): C }</code>这样我们让TypeScript知道我们想要构造函数(注意关键字<code class="fe nc nd ne nf b">new</code>)，它可以有任意数量的任意类型的参数(读:<code class="fe nc nd ne nf b">...args: any[]</code>)，并且产生一个类型为<code class="fe nc nd ne nf b">C</code>的对象</p><p id="44cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实际的搜索很简单:我们遍历数组并返回指定类型的实例组件。如果没有这样的组件，方法会发出错误提示:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="42b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在移除是直接了当的。我们期望组件的类型与我们在GetComponent中期望的一样。唯一的区别是<code class="fe nc nd ne nf b">RemoveComponent</code>不返回任何东西:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1f56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有很多方法可以从数组中移除一个元素。比如我们可以利用<code class="fe nc nd ne nf b">splice</code>。它依赖于要移除的元素的索引，我们可以用<code class="fe nc nd ne nf b">indexOf</code>来标识。问题是<code class="fe nc nd ne nf b">indexOf</code>使用的是<em class="na">值</em>而不是该值的<em class="na">类型</em>。要获得索引，我们必须首先手动遍历数组:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="848a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顺便说一下，我们可以使用另一种方法。我们可以创建一个新数组，简单地遍历旧数组，复制除了要删除的值之外的所有值:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="8ce2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，从性能角度来看，使用<code class="fe nc nd ne nf b">splice</code>的方法更可取，因为它是一种<a class="ae lb" href="https://en.wikipedia.org/wiki/In-place_algorithm" rel="noopener ugc nofollow" target="_blank">就地</a>操作。还要注意，我们不迭代整个数组，我们一找到要找的东西就中断。</p><p id="e167" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，如果消费者想要安全地探索<em class="na">是否有</em>一个特定类型的组件，他们可以使用HasComponent方法。它的工作方式与GetComponent相同，但它返回true/false，而不是抛出错误:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="edf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很好，但是你可能注意到我们重复了很多次<code class="fe nc nd ne nf b">{ new(...args: any[]): C }</code>。让我们稍微简化一下我们的生活，为它定义一个专用类型:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="da97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们不打算在这个模块之外使用它，所以让我们通过省略<code class="fe nc nd ne nf b">export</code>关键字使它成为<em class="na">内部</em>。另外，这次我使用了类型安全版本的<code class="fe nc nd ne nf b">any</code>:<code class="fe nc nd ne nf b">unknown</code>。现在我在方法中引用这种类型:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="df1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一点:让我们给<code class="fe nc nd ne nf b">component.h.ts</code>添加实体依赖，这样它就不会再抱怨了:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="351d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">厉害！如果你运行<code class="fe nc nd ne nf b">npm start</code>，你的代码应该编译无误</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="0fed" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">测试</h1><p id="cb90" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">所有这一切听起来很有趣，但是…我们如何验证任何东西<em class="na">实际上</em>工作？虽然没有游戏，但我们不能只打开浏览器就看到我们的系统在运行。但是我们可以单元测试！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/20946903305be5acdc3e840076b7b5a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ctjf6e9JiQCQbLb8LXmtTw.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://www.freepik.com/free-photos-vectors/circle" rel="noopener ugc nofollow" target="_blank">pikisperstar创建的圆矢量</a></figcaption></figure><p id="7045" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们为我们的实体创建一个单元测试:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="c5bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要建立模拟实体和组件。让它们尽可能简单:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="d66a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们创建了满足所有必要承诺的空类:<code class="fe nc nd ne nf b">E</code>扩展抽象实体，而<code class="fe nc nd ne nf b">C1</code>、<code class="fe nc nd ne nf b">C2</code>和<code class="fe nc nd ne nf b">C3</code>实现IComponent接口并期望附加到<code class="fe nc nd ne nf b">E</code>。</p><p id="ac36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们实例化它们，准备工作已经完成:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><blockquote class="nl nm nn"><p id="d98e" class="jn jo na jp b jq jr js jt ju jv jw jx no jz ka kb np kd ke kf nq kh ki kj kk ij bi translated"><em class="iq">注意，我不用每次都实例化组件。清理一个实体就足够了。</em></p></blockquote><p id="c9bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们测试我们可以从实体中添加、获取和删除组件，并验证组件是否存在:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="c022" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我将简单地调用我们所有的方法并检查实体的状态:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="a5a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们检查实体没有组件。应该是因为我们还没有添加任何东西。然后，我们添加所有三个组件，并期望实体的组件数组将变成三个项目长。此外，我们期望实体包含适当的组件。</p><p id="aee9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们删除了第二个组件，并验证了实体的状态会相应地更新。</p><blockquote class="nl nm nn"><p id="938b" class="jn jo na jp b jq jr js jt ju jv jw jx no jz ka kb np kd ke kf nq kh ki kj kk ij bi translated"><em class="iq">注意，我们提供的是它的类型，而不是引用。幸运的是，我们</em> <strong class="jp ir"> <em class="iq">能够在这种情况下</em> </strong> <em class="iq">提供一个参考。但是，正如你将在以后的章节中看到的，情况并不总是这样。</em></p></blockquote><p id="144c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们检查GetComponent和HasComponent是否按预期工作。</p><p id="68a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们运行<code class="fe nc nd ne nf b">npm t</code>，我们应该看到我们的测试通过了:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nr"><img src="../Images/a44bed700daac1615aa6730f9c6b6345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dUT7u8iXbQVNAlnExflEXQ.png"/></div></div></figure><p id="d1f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们唯一没有提到的是，如果消费者试图访问缺失的组件，GetComponent会抛出一个错误。让我们定义另一种情况:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="49b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们再次运行<code class="fe nc nd ne nf b">npm t</code>并确保所有测试都通过:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nr"><img src="../Images/179d3dc3b06a17bcd1a1ed8d26edd17d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2fEz_uk-s7Xwfk-SFN6RTg.png"/></div></div></figure><blockquote class="nl nm nn"><p id="b167" class="jn jo na jp b jq jr js jt ju jv jw jx no jz ka kb np kd ke kf nq kh ki kj kk ij bi translated">Y <!-- -->你可以在<a class="ae lb" href="https://github.com/soloschenko-grigoriy/gamedev-patterns-ts" rel="noopener ugc nofollow" target="_blank">库</a>的<code class="fe nc nd ne nf b"><em class="iq">ecs</em></code>分支中找到这篇文章的完整源代码。</p></blockquote></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ns"><img src="../Images/90152095013b5ffb230bfeeaf54d0bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aowxfoSKNVqwynrCx3iG3Q.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://www.freepik.com/free-photos-vectors/food" rel="noopener ugc nofollow" target="_blank">由macrovecto </a> r创造的食物媒介</figcaption></figure><p id="ed79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">恭喜你。您已经完成了本系列的第一章！</p><p id="25c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本章中，我们建立了一个项目，学习了什么是<strong class="jp ir">实体组件系统</strong>以及如何使用接口和抽象类用TypeScript实现它！我们还用<em class="na">单元测试</em>覆盖它们，以确保它们按预期工作。</p><p id="94ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae lb" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-with-typescript-game-loop-part-1-2-699919bb9b71" rel="noopener">下篇</a>中，我们要说的是另一种常见的模式:<strong class="jp ir">游戏循环</strong>。保重，到时见！</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="4ea9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="na">这是“用TypeScript构建游戏”系列教程的第一章。其他章节可点击此处:</em></p><ul class=""><li id="3441" class="mh mi iq jp b jq jr ju jv jy ni kc nj kg nk kk nt mp mq mr bi translated"><a class="ae lb" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener">简介</a></li><li id="7ae1" class="mh mi iq jp b jq ms ju mt jy mu kc mv kg mw kk nt mp mq mr bi translated">第一章实体组件系统</li><li id="2b23" class="mh mi iq jp b jq ms ju mt jy mu kc mv kg mw kk nt mp mq mr bi translated">第二章。游戏循环(<a class="ae lb" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-with-typescript-game-loop-part-1-2-699919bb9b71" rel="noopener">第一部</a>，<a class="ae lb" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-game-loop-2-2-c0d57a8e5ec2" rel="noopener">第二部</a>)</li><li id="93c8" class="mh mi iq jp b jq ms ju mt jy mu kc mv kg mw kk nt mp mq mr bi translated">第三章。绘制网格(<a class="ae lb" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-1-5-aaf68797a0bb" rel="noopener">第一部分</a>、<a class="ae lb" href="https://medium.com/javascript-in-plain-english/building-a-game-with-typescript-drawing-grid-2-5-206555719490" rel="noopener">第二部分</a>、<a class="ae lb" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-3-5-1fb94211c4aa" rel="noopener">第三部分</a>、<a class="ae lb" href="https://medium.com/@gregsolo/building-a-game-with-typescript-iii-drawing-grid-4-5-398af1dd638d" rel="noopener">第四部分</a>、<a class="ae lb" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-5-5-49454917b3af" rel="noopener">第五部分</a>)</li><li id="563c" class="mh mi iq jp b jq ms ju mt jy mu kc mv kg mw kk nt mp mq mr bi translated">第四章。舰船(<a class="ae lb" href="https://medium.com/@gregsolo/building-a-game-with-typescript-colors-and-layers-337b0e4d71f" rel="noopener">第一部分</a>、<a class="ae lb" href="https://medium.com/@gregsolo/building-a-game-with-typescript-team-and-fleet-f223d39e9248" rel="noopener">第二部分</a>、<a class="ae lb" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-ship-14e6c19caa38" rel="noopener">第三部分</a>、<a class="ae lb" href="https://gregsolo.medium.com/building-a-game-with-typescript-ship-and-locomotion-4f5969675993" rel="noopener">第四部分</a>)</li><li id="c356" class="mh mi iq jp b jq ms ju mt jy mu kc mv kg mw kk nt mp mq mr bi translated">第五章输入系统(<a class="ae lb" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-1-3-46d0b3dd7662" rel="noopener">第一部分</a>、<a class="ae lb" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-2-3-cd419e36027c" rel="noopener">第二部分</a>、<a class="ae lb" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-3-3-8492552579f1" rel="noopener">第三部分</a>)</li><li id="39cc" class="mh mi iq jp b jq ms ju mt jy mu kc mv kg mw kk nt mp mq mr bi translated">第六章。寻路与移动(<a class="ae lb" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-17-introduction" rel="noopener ugc nofollow" target="_blank">第一部分</a>、<a class="ae lb" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-27-highlighting-locomotion-range" rel="noopener ugc nofollow" target="_blank">第二部分</a>、<a class="ae lb" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-37-graph-and-priority-queue" rel="noopener ugc nofollow" target="_blank">第三部分</a>、<a class="ae lb" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-47-pathfinder" rel="noopener ugc nofollow" target="_blank">第四部分</a>、<a class="ae lb" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-57-finding-the-path" rel="noopener ugc nofollow" target="_blank">第五部分</a>、<a class="ae lb" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-6-instant-locomotion" rel="noopener ugc nofollow" target="_blank">第六部分</a>、<a class="ae lb" href="https://blog.gregsolo.me/articles/pathfinding-and-movement-7-animated-locomotion" rel="noopener ugc nofollow" target="_blank">第七部分</a>)</li><li id="dd68" class="mh mi iq jp b jq ms ju mt jy mu kc mv kg mw kk nt mp mq mr bi translated">第七章。玛奇纳州</li><li id="0682" class="mh mi iq jp b jq ms ju mt jy mu kc mv kg mw kk nt mp mq mr bi translated">第八章。攻击系统:生命和伤害</li><li id="6aa5" class="mh mi iq jp b jq ms ju mt jy mu kc mv kg mw kk nt mp mq mr bi translated">第九章。比赛的输赢</li><li id="fe27" class="mh mi iq jp b jq ms ju mt jy mu kc mv kg mw kk nt mp mq mr bi translated">第十章敌人AI</li></ul></div></div>    
</body>
</html>