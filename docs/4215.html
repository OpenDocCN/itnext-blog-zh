<html>
<head>
<title>Custom Image ProgressBar using SkiaSharp Part1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SkiaSharp Part1自定义图像进度条</h1>
<blockquote>原文：<a href="https://itnext.io/custom-image-progressbar-using-skiasharp-part1-3e0b6d230058?source=collection_archive---------5-----------------------#2020-05-17">https://itnext.io/custom-image-progressbar-using-skiasharp-part1-3e0b6d230058?source=collection_archive---------5-----------------------#2020-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e77a2e8cb94ffaa4d91eae8f493357f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*UgnpvJDzbFzq8C1zBoickw.gif"/></div></div></figure><p id="e1d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">绘制自定义进度图一直是一项具有挑战性的任务，因为它需要一点数学知识，这是很多开发人员不喜欢的。在这篇文章中，我们将看到如何使用c#来制作和平ok蛋糕。</p><h1 id="b7b9" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">步骤1:准备图像</h1><p id="1a63" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们需要将图像表示为一个点的数组，可能有很多在线工具可以将svg转换成这样的点数组</p><div class="lz ma gp gr mb mc"><a href="https://github.com/Shinao/PathToPoints" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd ir gy z fp mh fr fs mi fu fw ip bi translated">石脑/路径点</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">https://shinao.github.io/PathToPoints/从SVG路径中提取点或者生成它们…</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">github.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq jw mc"/></div></div></a></div><p id="2b63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了简单起见，我创建了一个静态类图，其中包含我将使用的图像</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="203f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">步骤2:创建一个静态类</h1><p id="4ad1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在这项任务中，我们将进行大量的映射和对话。保持代码整洁的最佳方式是使用扩展方法。</p><h1 id="cb17" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">步骤3:将点转换成复数</h1><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/365df1495165f06f50447dab66d38577.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*o_CsZH92AKdmL74RIZMUIQ.png"/></div></figure><p id="e847" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">复数是由<strong class="ka ir">吉罗拉莫·卡尔达诺</strong>引入的，作为解三次方程的一种尝试，不用深入细节，你可以把它想象成二维数字，</p><p id="5a82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实数中的第一维(相当于X)，第二维是虚部(相当于Y)。</p><pre class="mr ms mt mu gt my mz na nb aw nc bi"><span id="dba8" class="nd kx iq mz b gy ne nf l ng nh">public static Complex[] ToComplex(this IEnumerable&lt;Point&gt; source)<br/>        {<br/>            var complex = source<br/>              .Select(item =&gt; new Complex(item.x,item.y))<br/>              .ToArray();</span><span id="5a05" class="nd kx iq mz b gy ni nf l ng nh">            return complex;<br/>        }</span></pre><h1 id="5c61" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">步骤4:离散傅立叶变换</h1><p id="e74e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这部分是最有趣的，我们拥有的图像点数据是之前发生的一次绘图活动的结果。</p><p id="0123" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我可以用一个函数来表示这幅画</p><pre class="mr ms mt mu gt my mz na nb aw nc bi"><span id="220f" class="nd kx iq mz b gy ne nf l ng nh">Drawing(Canvas,Point)=Canvas.Points.Add(Point);</span></pre><p id="1365" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据前面的函数，我们可以将DrawingImage函数表示为</p><pre class="mr ms mt mu gt my mz na nb aw nc bi"><span id="628f" class="nd kx iq mz b gy ne nf l ng nh">Drawing(Canvas,Points)=Points.Foreach(point=&gt;Drawing(Canvas,Point));</span></pre><p id="2e86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以循环遍历这些点并一个一个地绘制它们应该会给你带来绘图动画效果吧？</p><p id="b9c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是，事情没有这么简单，因为有一个参数丢失了，那就是你知道这些点是由某人一次一个地绘制的，但是你不知道绘制的顺序和它们之间的时间间隔。</p><p id="4d41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，为了解决这个问题，我们需要从这个离散时间域转移到另一个时间可以一致的域，因此，我们将确定在恒定时间T可以发生多少绘图事件(多少点)，而不是试图确定绘图点之间的时间差，这个新的域被称为<strong class="ka ir">频域</strong>。</p><p id="68d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很可能在这两个域之间有一个众所周知的变换叫做傅立叶变换，在我们的代码中，我们将使用Accord.net库来完成它</p><div class="lz ma gp gr mb mc"><a href="http://accord-framework.net/" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd ir gy z fp mh fr fs mi fu fw ip bi translated">雅阁。NET机器学习框架</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">Accord.NET框架是一个结合了音频和图像处理库的. NET机器学习框架…</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">accord-framework.net</p></div></div><div class="ml l"><div class="nj l mn mo mp ml mq jw mc"/></div></div></a></div><pre class="mr ms mt mu gt my mz na nb aw nc bi"><span id="99dc" class="nd kx iq mz b gy ne nf l ng nh">//Receive a List of Points and return a Frequency of waves<br/>public static Complex[] DFT(this IEnumerable&lt;Point&gt; source)<br/>        {<br/>            var complex = source<br/>           .Select(item =&gt; new Complex(item.x, item.y)).ToArray();<br/>            <br/>           FourierTransform2.DFT(complex,  <br/>                               FourierTransform.Direction.Backward);<br/>            return complex;</span><span id="ade3" class="nd kx iq mz b gy ni nf l ng nh">         }</span></pre><h1 id="38ef" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">步骤5:设置SkiaSharp和绘图循环</h1><p id="c71b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">SkiaSharp是一个强大的c# canvas库，支持大多数平台(xamarin，uwp，Uno，…)。)</p><pre class="mr ms mt mu gt my mz na nb aw nc bi"><span id="a243" class="nd kx iq mz b gy ne nf l ng nh">&lt;forms:SKCanvasView PaintSurface="SKCanvasView_OnPaintSurface"/&gt;</span></pre><p id="eee5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">SkiaSharp仅允许在PaintSurface事件中进行绘制，并且此事件仅在画布第一次准备就绪或使用InvalidateSurface方法无效时触发。</p><pre class="mr ms mt mu gt my mz na nb aw nc bi"><span id="eb77" class="nd kx iq mz b gy ne nf l ng nh">private  async void SKCanvasView_OnPaintSurface(object sender, SKPaintSurfaceEventArgs e)<br/>        {<br/>            time += CONSTANTS<br/>            if (time &gt; 2f * Math.PI)<br/>            {<br/>                time = 0;<br/>                _path.Clear();<br/>            }<br/> <br/>            await Task.Delay(1);<br/>            SkCanvasView.InvalidateSurface();<br/>        }</span></pre><p id="c19f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们有一个无限循环，因为我们在PaintSurface事件处理程序中调用InvaliateSurface。</p><p id="d44a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每次我们将时间增加一个常数值，并且我们将通过(2 <em class="nk"> π) </em>来约束时间，因此图像应该在2 <em class="nk"> π之前完全绘制。</em></p><p id="d024" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">任务。延迟(1)；允许我们控制时间的速度，所以当我们延迟1毫秒时，我们说1毫秒的时间=绘制时间的常数。如果你这样做是为了反映真实的工作进展，你必须改变它，使之更有活力。</p><p id="4fc6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">现在我们需要计算常数</strong></p><blockquote class="nl nm nn"><p id="6d26" class="jy jz nk ka b kb kc kd ke kf kg kh ki no kk kl km np ko kp kq nq ks kt ku kv ij bi translated">如果我们有2个<em class="iq"> π(最大时间)</em>来画N个点，那么我们的常数应该是2 <em class="iq"> π/N. </em></p></blockquote><pre class="mr ms mt mu gt my mz na nb aw nc bi"><span id="a640" class="nd kx iq mz b gy ne nf l ng nh"><strong class="mz ir">CONSTANT =</strong>(2f * Math.PI) / Count;</span></pre><h1 id="f63e" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">步骤6:将波转换为给定时间的点</h1><p id="95ba" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">波和复数是同一事物的不同表现形式。在这一部分中，我将使用复数的表现形式，因为它更直接。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/7b704dbb032269bc26e337bd303c4c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n779mV2x4CxxJJf2JDPERA.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">BY Complex _ number _ illustration . SVG:原上传者为英文维基百科的Wolfkeeper .衍生作品:Kan 8 Edie(talk)—Complex _ number _ illustration . SVG，CC BY-SA 3.0，<a class="ae nw" href="https://commons.wikimedia.org/w/index.php?curid=5922759" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/w/index.php?curid=5922759</a></figcaption></figure><p id="68e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的R代表波的振幅，也就是波的高度。</p><p id="ab81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nk"> φ </em>是波的相位，是同一时刻波与其处理器之间的角度。</p><p id="7d19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以用三角学计算(X，Y)</p><pre class="mr ms mt mu gt my mz na nb aw nc bi"><span id="1e75" class="nd kx iq mz b gy ne nf l ng nh">X=R.cos(<em class="nk">φ);</em></span><span id="1bbb" class="nd kx iq mz b gy ni nf l ng nh">Y=R.sin(<em class="nk">φ);</em></span></pre><p id="51a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际上，给定时间T，前两个方程是正确的，但是在我们的例子中，时间和位置是不断变化的</p><pre class="mr ms mt mu gt my mz na nb aw nc bi"><span id="aadb" class="nd kx iq mz b gy ne nf l ng nh">x = item.Magnitude * Math.Cos(WaveOrder * time + item.Phase);                y = item.Magnitude * Math.Sin(WaveOrder * time +  item.Phase);</span></pre><p id="c016" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以现在可以计算每个波的对应点，我们可以计算这个点对应的全频率给定时间</p><pre class="mr ms mt mu gt my mz na nb aw nc bi"><span id="63f9" class="nd kx iq mz b gy ne nf l ng nh">public static SKPoint ToPoint(this IEnumerable&lt;Complex&gt; drawingData,<br/>            double time, double x, double y)<br/>        {<br/>            for (int i = 0; i &lt; drawingData.Count(); i++)<br/>            {<br/>                var item = drawingData.ElementAt(i);</span><span id="35be" class="nd kx iq mz b gy ni nf l ng nh">                x += item.Magnitude * Math.Cos(i * time + item.Phase);</span><span id="b0a1" class="nd kx iq mz b gy ni nf l ng nh">                y += item.Magnitude * Math.Sin(i * time +  item.Phase);</span><span id="93dd" class="nd kx iq mz b gy ni nf l ng nh">            }</span><span id="11ed" class="nd kx iq mz b gy ni nf l ng nh">return new SKPoint((float)x,(float)y);</span><span id="7420" class="nd kx iq mz b gy ni nf l ng nh">       }</span></pre><h1 id="43c3" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">第七步:画出要点</h1><pre class="mr ms mt mu gt my mz na nb aw nc bi"><span id="a424" class="nd kx iq mz b gy ne nf l ng nh">private  async void SKCanvasView_OnPaintSurface(object sender, SKPaintSurfaceEventArgs e)<br/>        {<br/>            var canvas = e.Surface.Canvas;<br/>            canvas.Clear(SKColors.Black);<br/>            <br/>            var point=  <br/>              _complex.ToPoint(time,this.Width/2+100,this.Height/2);</span><span id="c6c1" class="nd kx iq mz b gy ni nf l ng nh">              _path.Insert(0, point);</span><span id="15b0" class="nd kx iq mz b gy ni nf l ng nh">              canvas.DrawPoints(SKPointMode.Polygon,<br/>              _path.ToArray());</span><span id="2cce" class="nd kx iq mz b gy ni nf l ng nh">            time += (2f * Math.PI) / Count;<br/>            if (time &gt; 2f * Math.PI)<br/>            {<br/>                time = 0;<br/>                _path.Clear();<br/>            } <br/>            await Task.Delay(1);<br/>            SkCanvasView.InvalidateSurface();<br/>        }</span></pre><p id="e38d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以在这里找到功能齐全的代码</p><div class="lz ma gp gr mb mc"><a href="https://github.com/TheFo2sh/DFT/tree/master/DFT" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd ir gy z fp mh fr fs mi fu fw ip bi translated">第二部分/DFT</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">github.com</p></div></div><div class="ml l"><div class="nx l mn mo mp ml mq jw mc"/></div></div></a></div><p id="c532" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我要感谢丹尼尔·希夫曼，因为这段代码只是他的javascript的重构版本，你可以在这里找到他的视频教程</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="oa mw l"/></div></figure><p id="1bca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我强烈推荐你去看看他的书<a class="ae nw" href="https://amzn.to/3dSGTlN" rel="noopener ugc nofollow" target="_blank">代码的本质</a>，这是一本非常棒的书，将有助于理解代码和自然之间的关系以及灵感。</p><p id="b240" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，你可以在<a class="ae nw" href="https://ko-fi.com/ahmedfouad" rel="noopener ugc nofollow" target="_blank">https://ko-fi.com/ahmedfouad</a>与我分享你的咖啡，并请在twitter上关注我以获得最新的更新</p><div class="lz ma gp gr mb mc"><a href="https://twitter.com/MCC_Ahmed" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd ir gy z fp mh fr fs mi fu fw ip bi translated">艾哈迈德·福阿德</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">艾哈迈德·福阿德的最新推文(@MCC_Ahmed)。我是PlanRadar的一名软件工程师，目前住在维也纳…</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">twitter.com</p></div></div><div class="ml l"><div class="ob l mn mo mp ml mq jw mc"/></div></div></a></div><div class="lz ma gp gr mb mc"><a href="https://ko-fi.com/ahmedfouad" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd ir gy z fp mh fr fs mi fu fw ip bi translated">给艾哈迈德·福阿德买杯咖啡。ko-fi.com/ahmedfouad</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">我是PlanRadar的一名软件工程师，目前住在奥地利的维也纳。我的兴趣范围从技术到网络…</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">ko-fi.com</p></div></div><div class="ml l"><div class="oc l mn mo mp ml mq jw mc"/></div></div></a></div><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/936ad0632fb2b1fe809c2d61134b5dc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xJaV8kFUoasvCn6F9mlxKw.gif"/></div></div></figure></div></div>    
</body>
</html>