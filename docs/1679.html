<html>
<head>
<title>SOLID Principles: Explanation and examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚实的原则:解释和例子</h1>
<blockquote>原文：<a href="https://itnext.io/solid-principles-explanation-and-examples-715b975dcad4?source=collection_archive---------0-----------------------#2019-01-01">https://itnext.io/solid-principles-explanation-and-examples-715b975dcad4?source=collection_archive---------0-----------------------#2019-01-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/8505b45ec53b7b58b78ad3f74b011bd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TjDnfpnw4gI8sZ2fvaK9zg.jpeg"/></div></div></figure><div class=""/><p id="439c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">固体</strong>是进行OOP(面向对象编程)时5个重要设计原则的首字母缩写。</p><p id="a2ff" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这5条原则是罗伯特·c·马丁(鲍勃大叔)在他2000年的论文<a class="ae kz" href="https://web.archive.org/web/20150906155800/http://www.objectmentor.com/resources/articles/Principles_and_Patterns.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="la">设计原则和设计模式</em> </a> <em class="la">中介绍的。然而，真正的首字母缩略词是后来由迈克尔·费哲发现的。</em></p><p id="190e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些原则的目的是使软件设计更容易理解，更容易维护，更容易扩展。作为一名软件工程师，这5条原则是必须知道的！</p><p id="6181" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我将介绍这些原则，举例说明它们是如何被违反的，以及如何纠正它们以符合<strong class="kd jf"> SOLID </strong>。<br/>c#中会给出例子，但是适用于任何OOP语言。</p><h1 id="1121" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">s——单一责任原则</h1><p id="3dd7" class="pw-post-body-paragraph kb kc je kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">在编程中，<a class="ae kz" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>规定每个模块或类都应该对软件提供的功能的单一部分负责。</p><p id="3385" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可能听过这句名言:“<em class="la">做一件事，把它做好</em>”。<br/>这是指单一责任原则。<br/>在文章<em class="la">面向对象设计的原则中，</em> Robert C. Martin将责任定义为“改变的原因”，并得出结论，一个类或模块应该有且只有一个改变的原因。</p><p id="1353" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们做一个例子，看看如何写一段违反这个原则的代码。</p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="cafe" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们注意到<code class="fe mk ml mm mn b">CreatePost()</code>方法有太多的责任，因为它既可以创建一个新的post，在数据库中记录一个错误，又可以在本地文件中记录一个错误。这违反了单一责任原则。</p><p id="2458" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试着改正它。</p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="2806" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过抽象处理错误日志的功能，我们不再违反单一责任原则。现在我们有两个类，每个类有一个职责；分别创建帖子和记录错误。</p><h1 id="9411" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">O —开启/关闭原则</h1><p id="fd2f" class="pw-post-body-paragraph kb kc je kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">在编程中，<a class="ae kz" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noopener ugc nofollow" target="_blank">开/关原则</a>规定软件实体(类、模块、函数等。)应该对扩展开放，但对修改关闭。</p><p id="b9d5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你对OOP有一个大致的了解，你可能已经知道了多态性。我们可以通过利用继承和/或实现接口来确保我们的代码符合开放/封闭原则，这些接口使类能够多态地相互替换。</p><p id="326f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这听起来可能令人困惑，所以让我们做一个例子，将非常清楚我的意思。</p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="e764" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这段代码中，每当帖子以字符' # '开头时，我们都需要做一些特定的事情。<br/>然而，上面的实现违反了开放/封闭原则，因为这段代码不同于起始字母上的行为。<br/>如果我们后来想包含以“@”开头的提及，我们必须在<code class="fe mk ml mm mn b">CreatePost()</code>方法中用额外的‘else If’来修改这个类。</p><p id="9dfd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们通过简单地使用继承来尝试使这个代码符合开放/封闭原则。</p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="728f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过使用继承，现在更容易通过覆盖<code class="fe mk ml mm mn b">CreatePost()</code>方法来创建Post对象的扩展行为。<br/>对第一个字符' # '的评估现在将在我们软件的其他地方(可能在更高的层次上)处理，最酷的事情是，如果我们想改变postMessage的评估方式，我们可以在那里改变代码，而不会影响这些底层的行为。</p><h1 id="5652" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">李斯科夫替代原理</h1><p id="0d51" class="pw-post-body-paragraph kb kc je kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">这一条可能是第一次被介绍时最难理解的一条。</p><p id="c24d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在编程中，<a class="ae kz" href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="noopener ugc nofollow" target="_blank"> Liskov替换原则</a>规定，如果<strong class="kd jf"> <em class="la"> S </em> </strong>是<strong class="kd jf"> <em class="la"> T </em> </strong>的子类型，那么<strong class="kd jf"> <em class="la"> T </em> </strong>类型的对象可以被<strong class="kd jf"> <em class="la"> S </em> </strong>类型的对象替换(或替代)。这可以用数学公式表示为</p><p id="c1ad" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="la">设</em><strong class="kd jf"><em class="la">【ϕ(x】</em></strong><em class="la">是关于类型</em><strong class="kd jf"><em class="la"/></strong><em class="la">的对象</em> <strong class="kd jf"> <em class="la"> x </em> </strong> <em class="la">的一个性质可证。<br/>那么</em><strong class="kd jf"><em class="la">【ϕ(y】</em></strong><em class="la">对于类型</em><strong class="kd jf"><em class="la">y</em></strong><em class="la">s</em><em class="la">，其中</em> <strong class="kd jf"> <em class="la"> S </em> </strong> <em class="la">是</em><strong class="kd jf"><em class="la">t<em class="la">的一个子类型</em></em></strong></p><p id="2a01" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">更一般地说，它认为程序中的对象应该可以用其子类型的实例来替换，而不改变程序的正确性。</p><p id="7183" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看一个如何违反这一原则的例子</p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="731d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">观察在子类型<code class="fe mk ml mm mn b">MentionPost</code>的情况下<code class="fe mk ml mm mn b">CreatePost()</code>的调用如何不做它应该做的事情；通知用户并覆盖现有提及。<br/>因为<code class="fe mk ml mm mn b">CreatePost()</code>方法在<code class="fe mk ml mm mn b">MentionPost</code>中没有被覆盖，所以<code class="fe mk ml mm mn b">CreatePost()</code>调用将简单地在类层次结构中向上委托，并从其父类调用<code class="fe mk ml mm mn b">CreatePost()</code>。</p><p id="9158" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们纠正这一点</p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="3101" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过重构<code class="fe mk ml mm mn b">MentionPost</code>类，我们覆盖了<code class="fe mk ml mm mn b">CreatePost()</code>方法，而不是在它的基类上调用它，我们不再违反Liskov替换原则。</p><p id="3e9c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这只是如何纠正违反这一原则的一个简单例子，然而，这种情况可能以各种各样的方式出现，并不总是容易识别。</p><h1 id="075b" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">I——界面分离原则</h1><p id="f0d3" class="pw-post-body-paragraph kb kc je kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">这个原则相当容易理解。事实上，如果你习惯于使用接口，很可能你已经在应用这个原则了。<br/>如果没有，是时候开始做了！</p><p id="fc3f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在编程中，<a class="ae kz" href="https://en.wikipedia.org/wiki/Interface_segregation_principle" rel="noopener ugc nofollow" target="_blank">接口分离原则</a>声明，不应该强迫任何客户端依赖它不使用的方法。<br/>更简单地说:不要通过添加新方法来给现有的接口添加额外的功能。相反，创建一个新的接口，如果需要的话，让你的类实现多个接口。</p><p id="ed0f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看一个如何违反接口隔离原则的例子。</p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="07b4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个例子中，假设我首先有一个带有<code class="fe mk ml mm mn b">CreatePost()</code>方法签名的<code class="fe mk ml mm mn b">IPost</code>接口。<br/>后来，我通过添加一个新方法<code class="fe mk ml mm mn b">ReadPost()</code>来修改这个接口，所以它变得像<code class="fe mk ml mm mn b">IPostNew</code>接口。</p><p id="e811" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是我们违反接口分离原则的地方。相反，只需创建一个新界面。</p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="7986" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果任何一个类可能同时需要<code class="fe mk ml mm mn b">CreatePost()</code>和<code class="fe mk ml mm mn b">ReadPost()</code>方法，它将实现这两个接口。</p><h1 id="07af" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">D -依赖倒置原理</h1><p id="67e8" class="pw-post-body-paragraph kb kc je kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">最后，我们到了D，5个原则中的最后一个。</p><p id="dfc5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在编程中，<a class="ae kz" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="noopener ugc nofollow" target="_blank">依赖倒置原则</a>是一种解耦软件模块的方法。这一原则表明</p><ul class=""><li id="1537" class="mo mp je kd b ke kf ki kj km mq kq mr ku ms ky mt mu mv mw bi translated">高层模块不应该依赖低层模块。两者都应该依赖于抽象。</li><li id="7d31" class="mo mp je kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated">抽象不应该依赖于细节。细节应该依赖于抽象。</li></ul><p id="c4d6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了遵守这个原则，我们需要使用一种被称为<em class="la">依赖倒置模式</em>的设计模式，通常通过使用<a class="ae kz" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank"> <em class="la">依赖注入</em> </a> <em class="la">来解决。依赖注入是一个巨大的话题，可以是复杂的，也可以是简单的。</em></p><p id="4d93" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通常，依赖注入只是通过类的构造函数作为输入参数“注入”类的任何依赖来使用。</p><p id="5aaa" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看一个例子。</p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="4333" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">观察我们如何从<code class="fe mk ml mm mn b">Post</code>类中创建<code class="fe mk ml mm mn b">ErrorLogger</code>实例。<br/>这违反了依赖倒置原则。<br/>如果我们想使用不同种类的日志记录器，我们必须修改Post类。</p><p id="1ad0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们通过使用依赖注入来解决这个问题。</p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="7578" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过使用依赖注入，我们不再依赖<code class="fe mk ml mm mn b">Post</code>类来定义特定类型的记录器。</p><h1 id="211f" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="8a0e" class="pw-post-body-paragraph kb kc je kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">通过应用使<strong class="kd jf">成为可靠的</strong>首字母缩略词的这5个原则，我们可以从可重用、可维护、可扩展和易测试的代码库中获益。<br/>这是全球专业软件工程师使用的5个基本原则，如果你真的想创建“可靠”的软件，你应该从今天开始应用这些原则！</p><p id="fd57" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">就是这样！<br/>如果您有任何问题或反馈，请随时在下方评论。</strong></p></div></div>    
</body>
</html>