<html>
<head>
<title>Flutter: types of widgets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤动:部件的类型</h1>
<blockquote>原文：<a href="https://itnext.io/flutter-types-of-widgets-8d457281ad03?source=collection_archive---------2-----------------------#2022-01-04">https://itnext.io/flutter-types-of-widgets-8d457281ad03?source=collection_archive---------2-----------------------#2022-01-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/75a2b340d5c25c7817fe1bdd78cc494f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*odK3MywHa3T0MAkhfv2_UQ.png"/></div></div></figure><p id="f2cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你曾经在一次激动人心的面试中被问到过关于小部件的类型吗？</p><p id="9a74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我打赌最常见的答案是只有2/3:<code class="fe kw kx ky kz b">StatelessWidget</code>、<code class="fe kw kx ky kz b">StatefulWidget</code>、<code class="fe kw kx ky kz b">InheritedWidget</code>。</p><p id="8de9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但这只是冰山一角。如果我们开始深入到flutter源代码中去理解，例如，小部件<code class="fe kw kx ky kz b">Stack</code>是哪种类型，我们会在层次结构中发现更多的类。</p><p id="8b09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是来自颤振源的一些描述的层次结构。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi la"><img src="../Images/df662176cd308073ca41a35d58ecc5f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wGKXoHo-utIb_qwR6sRO0Q.png"/></div></div></figure><blockquote class="lf lg lh"><p id="252c" class="jy jz li ka b kb kc kd ke kf kg kh ki lj kk kl km lk ko kp kq ll ks kt ku kv ij bi translated"><strong class="ka ir">小部件</strong>描述了一个<code class="fe kw kx ky kz b">Element</code>的配置。小部件是用户界面一部分的不可变描述。</p><p id="f166" class="jy jz li ka b kb kc kd ke kf kg kh ki lj kk kl km lk ko kp kq ll ks kt ku kv ij bi translated"><strong class="ka ir"> StatelessWidget </strong>是一个不需要可变状态的小部件。</p><p id="95cc" class="jy jz li ka b kb kc kd ke kf kg kh ki lj kk kl km lk ko kp kq ll ks kt ku kv ij bi translated"><strong class="ka ir"> StatefulWidget </strong>是一个具有可变状态的小部件。状态是在构建小部件时可以同步读取的信息，在小部件的生命周期中可能会改变。<br/>当状态改变时，确保状态被及时通知是小程序实现者的责任，使用<code class="fe kw kx ky kz b">setState</code>。</p><p id="d07d" class="jy jz li ka b kb kc kd ke kf kg kh ki lj kk kl km lk ko kp kq ll ks kt ku kv ij bi translated"><strong class="ka ir"> ProxyWidget </strong>是一个小部件，它有一个子部件，而不是构建一个新的。</p><p id="41a1" class="jy jz li ka b kb kc kd ke kf kg kh ki lj kk kl km lk ko kp kq ll ks kt ku kv ij bi translated"><strong class="ka ir"> RenderObjectWidget </strong> s为<code class="fe kw kx ky kz b">RenderObjectElement</code> s提供配置，后者包装<code class="fe kw kx ky kz b">RenderObject</code> s，后者提供应用程序的实际渲染。</p><p id="d3ff" class="jy jz li ka b kb kc kd ke kf kg kh ki lj kk kl km lk ko kp kq ll ks kt ku kv ij bi translated">InheritedWidget 是一个窗口小部件的基类，这些窗口小部件可以有效地沿着树向下传播信息。<br/>要从构建上下文中获得特定类型的继承小部件的最近实例，使用<code class="fe kw kx ky kz b">BuildContext.dependOnInheritedWidgetOfExactType</code>。<br/>当以这种方式引用继承的小部件时，当继承的小部件本身改变状态时，将导致消费者重建。</p><p id="79be" class="jy jz li ka b kb kc kd ke kf kg kh ki lj kk kl km lk ko kp kq ll ks kt ku kv ij bi translated"><strong class="ka ir"> ParentDataWidget </strong>是一个将<code class="fe kw kx ky kz b">ParentData</code>信息挂钩到<code class="fe kw kx ky kz b">RenderObjectWidget</code> s的子对象的Widget类。<br/>这可用于为有多个子对象的<code class="fe kw kx ky kz b">RenderObjectWidget</code> s提供每个子对象的配置。例如，<code class="fe kw kx ky kz b">Stack</code>使用<code class="fe kw kx ky kz b">Positioned</code>父数据小部件来定位每个孩子。</p><p id="6e21" class="jy jz li ka b kb kc kd ke kf kg kh ki lj kk kl km lk ko kp kq ll ks kt ku kv ij bi translated"><strong class="ka ir">leavrendeobjectwidget</strong>是RenderObjectWidgets的超类，配置没有子级的RenderObject子类。</p><p id="9aa0" class="jy jz li ka b kb kc kd ke kf kg kh ki lj kk kl km lk ko kp kq ll ks kt ku kv ij bi translated"><strong class="ka ir">singlechildrenobjectwidget</strong>是一个超类，用于配置拥有单个子插槽的<code class="fe kw kx ky kz b">RenderObject</code>子类。</p><p id="3aa8" class="jy jz li ka b kb kc kd ke kf kg kh ki lj kk kl km lk ko kp kq ll ks kt ku kv ij bi translated"><strong class="ka ir">multichildrendenobjectwidget</strong>是<code class="fe kw kx ky kz b">RenderObjectWidget</code>的超类，它配置了<code class="fe kw kx ky kz b">RenderObject</code>子类，这些子类有一个子列表。</p></blockquote><h1 id="c156" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">来源</h1><div class="mk ml gp gr mm mn"><a href="https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/widgets/framework.dart" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd ir gy z fp ms fr fs mt fu fw ip bi translated">颤振/框架。主颤振/颤振处的飞镖</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">此文件包含双向Unicode文本，其解释或编译可能与下面显示的不同…</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">github.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb jw mn"/></div></div></a></div></div></div>    
</body>
</html>