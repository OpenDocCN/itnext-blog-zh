<html>
<head>
<title>Angular Unit Testing 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度单位测试101</h1>
<blockquote>原文：<a href="https://itnext.io/angular-unit-testing-101-c3492ba17e9?source=collection_archive---------5-----------------------#2019-05-23">https://itnext.io/angular-unit-testing-101-c3492ba17e9?source=collection_archive---------5-----------------------#2019-05-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/e206e35525411bb805837bda70238e51.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*itnZYloXc2v7cpwbhMZuTQ.jpeg"/></div></figure><p id="7cb5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">是关于角2+单元测试的。</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="22ff" class="lb lc iq kx b gy ld le l lf lg">Angular: v7.2.3<br/>Karma: v4.0.1<br/>Jasmine-core: v3.1.0</span></pre><p id="6086" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">添加组件</strong></p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="6812" class="lb lc iq kx b gy ld le l lf lg">beforeEach(async(() =&gt; {<br/>    TestBed.configureTestingModule({<br/>      declarations: [<br/>        AppComponent<br/>      ],<br/>    }).compileComponents();<br/>  }));<br/>// compileComponents may not needed if using WebPack</span></pre><p id="0eec" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">创建一个组件</strong></p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="1aaa" class="lb lc iq kx b gy ld le l lf lg">const fixture = TestBed.createComponent(AppComponent);<br/>const app = fixture.debugElement.componentInstance;</span></pre><p id="89aa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">覆盖</strong> <strong class="jw ir">入口组件</strong></p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="c55e" class="lb lc iq kx b gy ld le l lf lg">TestBed.overrideModule(BrowserDynamicTestingModule, {<br/>      set: {<br/>           entryComponents: [SomeComponent]<br/>      }<br/>});</span></pre><p id="8b6a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">创建编译后的HTML组件</strong></p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="02d0" class="lb lc iq kx b gy ld le l lf lg">const fixture = TestBed.createComponent(AppComponent);<br/>fixture.detectChanges();<br/>const compiled = fixture.debugElement.nativeElement;<br/>compiled.querySelector('h1').textContent</span></pre><p id="7f60" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">向组件注入服务</strong></p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="fd92" class="lb lc iq kx b gy ld le l lf lg">const quoteService = fixture.debugElement.injector.get(QuoteService);</span><span id="365e" class="lb lc iq kx b gy lh le l lf lg">fixture.detectChanges();</span></pre><p id="dd0a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">模拟服务</strong></p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="1494" class="lb lc iq kx b gy ld le l lf lg">const data: Sample = new Sample('test');<br/>class MockSampleService {<br/>   // Override test function from SampleService<br/>   test(): Observable&lt;Sample&gt;{<br/>      return of(data);<br/>   }<br/>}</span><span id="c79d" class="lb lc iq kx b gy lh le l lf lg">providers: [{provide: SampleService, useValue: {}]</span><span id="3252" class="lb lc iq kx b gy lh le l lf lg">TestBed.overrideProvider(SampleService, {useValue: new MockSampleService()});</span></pre><p id="8581" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">模仿HttpClient服务的示例</p><p id="82df" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我通常使用这个假的HttpClient调用来避免“<strong class="jw ir">无法从假的异步测试</strong>中生成xhr”的错误。</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="261c" class="lb lc iq kx b gy ld le l lf lg">const httpClientSpy: jasmine.SpyObj&lt;HttpClient&gt; = jasmine.createSpyObj('httpClient', ['get']);</span><span id="022a" class="lb lc iq kx b gy lh le l lf lg">httpClientSpy.get.and.returnValue(of('your-data'}));</span><span id="031d" class="lb lc iq kx b gy lh le l lf lg">...</span><span id="1e0c" class="lb lc iq kx b gy lh le l lf lg">providers: [{provide: HttpClient, useValue: {}]</span><span id="16e9" class="lb lc iq kx b gy lh le l lf lg">TestBed.overrideProvider(HttpClient, { useValue: httpClientSpy });</span></pre><p id="8ab7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">窥探服务功能</strong></p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="9755" class="lb lc iq kx b gy ld le l lf lg">spyOn(SomeService.prototype, 'someFunc').and.returnValue('test');<br/>// commands to be run<br/>expect(SomeService.prototype.someFunc).toHaveBeenCalled()</span></pre><p id="7aab" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">刺探函数时不必添加<strong class="jw ir"> returnValue </strong>函数。</p><p id="ad5a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">模拟组件</strong></p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="2129" class="lb lc iq kx b gy ld le l lf lg"><a class="ae li" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>({<br/>  template: `&lt;app-user [user]="user"&gt;&lt;/app-user&gt;`<br/>})<br/>class MockUser {<br/>  user = {<br/>    name: 'foobar'<br/>  };<br/>}</span></pre><p id="b24f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">模拟异步(fakeAsync) </strong></p><p id="8cab" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果我有一个来自constructor或ngOnInit的异步调用，我将使用fakeAsync来等待所有调用完成。</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="6869" class="lb lc iq kx b gy ld le l lf lg">beforeEach(fakeAsync(() =&gt; {<br/>  fixture = TestBed.createComponent(AppComponent);<br/>  component = fixture.debugElement.componentInstance;</span><span id="bf2e" class="lb lc iq kx b gy lh le l lf lg">  component.ngOnInit();<br/>  tick();<br/>  ...<br/>}));</span></pre><p id="74bc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">故障排除</strong></p><ul class=""><li id="65c0" class="lj lk iq jw b jx jy kb kc kf ll kj lm kn ln kr lo lp lq lr bi translated"><strong class="jw ir">错误:1个定时器仍在队列中。</strong></li></ul><p id="9ea2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果您正在使用<strong class="jw ir"> <em class="ls"> fakeAsync </em> </strong>，请添加<strong class="jw ir"> <em class="ls"> tick() </em> </strong>功能，并尝试增加tick功能中的定时器，以测试其是否工作(如tick(15000) ~ 15s)</p><ul class=""><li id="9225" class="lj lk iq jw b jx jy kb kc kf ll kj lm kn ln kr lo lp lq lr bi translated"><strong class="jw ir">类型错误:无法读取空值</strong>的属性“getComponentFromError”</li></ul><p id="c6ea" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请在每个功能前添加这些<strong class="jw ir">中的重置测试环境</strong></p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="782e" class="lb lc iq kx b gy ld le l lf lg">TestBed.resetTestEnvironment();<br/>TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());</span></pre><ul class=""><li id="666d" class="lj lk iq jw b jx jy kb kc kf ll kj lm kn ln kr lo lp lq lr bi translated">如果要运行单个测试，应该导入区域文件。然后在你运行时删除它们来运行每一个测试用例，否则，你会得到一些错误。</li></ul><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="aa94" class="lb lc iq kx b gy ld le l lf lg">import 'zone.js/dist/zone';<br/>import 'zone.js/dist/long-stack-trace-zone';<br/>import 'zone.js/dist/proxy';<br/>import 'zone.js/dist/sync-test';<br/>import 'zone.js/dist/jasmine-patch';<br/>import 'zone.js/dist/async-test';<br/>import 'zone.js/dist/fake-async-test';</span></pre><p id="fef6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是仅用于运行一个测试的命令。</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="e5f9" class="lb lc iq kx b gy ld le l lf lg">ng test --main path-to-spec.file.js</span></pre><ul class=""><li id="c8f3" class="lj lk iq jw b jx jy kb kc kf ll kj lm kn ln kr lo lp lq lr bi translated">添加<strong class="jw ir"> <em class="ls">浏览器:['ChromeHeadless'] </em> </strong>到<strong class="jw ir"><em class="ls">karma . conf . js</em></strong>以便在无头模式下运行单元测试</li></ul></div></div>    
</body>
</html>