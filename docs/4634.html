<html>
<head>
<title>Animating list reordering with React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React钩子动画列表重新排序</h1>
<blockquote>原文：<a href="https://itnext.io/animating-list-reordering-with-react-hooks-aca5e7eeafba?source=collection_archive---------1-----------------------#2020-08-10">https://itnext.io/animating-list-reordering-with-react-hooks-aca5e7eeafba?source=collection_archive---------1-----------------------#2020-08-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e7f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不久前，我得到了一个很酷的Instagram story风格的泡泡组件设计，当我们从API获得新的订单时，每个泡泡都会平稳地滑入新的位置。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/cbdfa25fab58b2bf446dc6fc0465f766.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/0*ofgpW_7pmx5xMTZB"/></div></figure><p id="425d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然用CSS做一整套动画和过渡很简单，但我花了一段时间才找到一个动画列表项重新排序的例子，尤其是用React。因为我也开始习惯React钩子的概念，所以我想用它们来实现这个动画。</p><p id="dffd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我发现使用React hooks很难做到这一点，因为当我的组件获得新数据时，它会以新的顺序自动重新呈现。我试图在重新渲染之前抓住时机，平稳地从一种状态过渡到另一种状态。如果没有来自类组件的<strong class="jp ir"><em class="kt">componentWillReceiveProps</em></strong>函数调用，这是很难做到的。</p><p id="6434" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我曾经(错误地)认为在野外会有很多React hooks的例子。老实说，我只是想要一个不需要太多改动的复制意大利面解决方案👀。我也不想引入一些巨大的、通常过于灵活的包来重新订购一个小东西。我确实看到了Joshua Comeau的一篇很棒的文章(链接如下)。它解释了如何做我所需要的，但是使用类组件。对于React hooks，我需要重新思考一些概念来让它工作，但是我已经将大部分工作建立在这篇文章的基础上。</p><p id="4a1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们希望发生的事情:</p><ol class=""><li id="9cb6" class="ku kv iq jp b jq jr ju jv jy kw kc kx kg ky kk kz la lb lc bi translated">留意我们的元素列表什么时候会改变</li><li id="afac" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">当它改变时，我们希望在DOM更新之前计算列表中每个元素的先前位置和新位置</li><li id="5b7d" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">此外，在DOM使用列表的新顺序更新之前，我们希望“暂停”更新，并显示列表中每个项目从旧位置到新位置的平滑过渡</li></ol><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi li"><img src="../Images/c0c913732339fee574bb19454cfb8eaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nB-0tkPafPwkKQh-R8XuAA.png"/></div></div></figure><p id="3ff3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从一个父组件开始，它只是呈现传递给它的子组件，<strong class="jp ir"> <em class="kt"> AnimateBubbles </em> </strong>:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="4981" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们可以通过在组件中呈现我们的项目来使用该组件。在我的例子中，我创建了一个<strong class="jp ir"> <em class="kt"> Bubble </em> </strong>组件，它添加了一些样式，使每个图像都变成了一个圆形，<a class="ae lp" href="https://codesandbox.io/s/reorder-elements-with-slide-transition-and-react-hooks-flip-211f2?file=/src/Bubble.js" rel="noopener ugc nofollow" target="_blank">完整的代码在这里</a>。<strong class="jp ir"> <em class="kt">气泡</em> </strong>组件也将ref转发到DOM元素上。这很重要，因为我们可以使用ref来查找元素在DOM中呈现的位置，然后我们可以计算它的位置。另一个重要的道具是<strong class="jp ir"> <em class="kt">键</em> </strong>，这不仅是映射元素时React所需要的，而且我们还可以在以后使用它来唯一地标识每个项目并匹配它在DOM中的新旧位置。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="6bb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了组件的基础，我们可以开始构建我们的<strong class="jp ir"> <em class="kt">动画气泡</em> </strong>组件的逻辑了。</p><h1 id="67e8" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">留意反应堆里的人</h1><p id="7ca8" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">有了React钩子，我们不再能够访问像<strong class="jp ir"><em class="kt">componentWillReceiveProps</em></strong>或<strong class="jp ir"><em class="kt">componentDidUpdate</em></strong>这样的生命周期方法，取而代之的是所有关于效果的东西。如果我们想在道具改变时做些什么，我们可以在<a class="ae lp" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="kt">use effect</em></strong></a>中完成。<strong class="jp ir"> <em class="kt"> useEffect </em> </strong>钩子告诉React我们的组件在渲染之后需要做一些事情。在我们的例子中，如果我们的列表发生变化，新的订单被提交，我们只需要做一些工作。将孩子添加为依赖项允许我们这样做。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ln lo l"/></div></figure><h1 id="954c" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">测量DOM中的每个位置</h1><p id="a189" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">每当子道具改变时，为了计算每个子道具在DOM中的位置，我们可以使用<a class="ae lp" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="kt">getBoundingClientRect</em></strong></a>。为此，我创建了一个单独的助手函数:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="36c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个函数中，我们传入<strong class="jp ir"> <em class="kt">子</em> </strong>作为参数，并在React上使用<strong class="jp ir"> <em class="kt"> forEach </em> </strong>函数。子对象来迭代它们，获取对象中每一项的度量值，稍后我们可以将这些度量值存储在state中。这就是为每个孩子设置一个关键点很重要的地方，因为我们存储每个盒子，并将其关键点作为对象关键点，这样我们就可以在以后用新位置匹配旧位置。这也是为什么为每个子元素创建一个ref很重要，因为我们用它在DOM中找到元素并测量它的边界框。现在，当我们在<strong class="jp ir"> <em class="kt"> useEffect </em> </strong>中调用这个函数时，我们将在每次渲染时为每个孩子更新边界框🎉。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="6e4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在的问题是，我们只得到新的位置，但我们也需要旧的位置，这样我们就可以从旧的位置到新的位置做幻灯片动画。</p><h1 id="3263" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">使用usePrevious挂钩获取上一个状态/属性</h1><p id="5df5" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">我们可以得到孩子的旧位置的一种方法是通过跟踪孩子的先前状态。React文档已经建议了一个名为<strong class="jp ir"> <em class="kt">的钩子，使用先前的</em> </strong>。他们说将来可能会提供开箱即用，因为它被认为是一个常见的用例。使用<a class="ae lp" href="https://reactjs.org/docs/hooks-faq.html#how-to-get-the-previous-props-or-state" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="kt">使用前一个</em> </strong> </a>意味着我们可以像测量新位置一样测量旧位置的边界框。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="ebb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我把这个放到了一个单独的<strong class="jp ir"> <em class="kt"> useEffect </em> </strong>中，因为它们不需要一起完成，而且它们都有不同的依赖关系。这些以前的位置现在将在每次孩子改变时重新计算。</p><p id="6e6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了这两条重要的信息，我们可以继续进行实际的转换了😅</p><h1 id="374a" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">采取行动</h1><p id="b34f" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">在制作真正的动画时，我更多地关注了约书亚·科莫帖子中提到的翻转。FLIP代表First，Last，Invert，Play，由Paul Lewis创造，作为渲染更高性能动画的原则。</p><p id="3611" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以在我们的例子中，我们找到每个孩子的第一个位置。我们将此状态存储在<strong class="jp ir"> <em class="kt">预边界框</em> </strong>中。然后我们找到每个孩子最后的位置。我们在<strong class="jp ir"> <em class="kt">的输入框</em> </strong>中也有这个储存状态。下一步是反转，这是为了找出每个孩子是如何改变的，并对每个孩子应用这些变换，使其看起来像在第一个位置。</p><p id="fc77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以设置一个新的useEffect来实现对<strong class="jp ir"> <em class="kt">子</em> </strong>、<strong class="jp ir"> <em class="kt">边界框</em> </strong>和<strong class="jp ir"> <em class="kt">预边界框</em> </strong>的依赖，因为我们将在效果中使用所有这些值。记住当React重新渲染时，它会立即用新的状态更新视图，但是我们可以使用<a class="ae lp" href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="kt">requestAnimationFrame</em></strong></a>来告诉浏览器我们想要执行一个动画。浏览器会在下次重画之前调用你给它的函数。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="3c8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一点我们可以用<strong class="jp ir"> <em class="kt">倒数=倒值</em> </strong>上<strong class="jp ir"> <em class="kt">左</em> </strong>框的值来实现。因为我们也有一个对DOM节点的引用，所以我们可以将转换直接应用到节点上，转换时间为0秒，这样它就会立即反转。</p><p id="fd5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一步是播放动画。为此，我们等待子元素被反转，然后我们移除变换并应用平滑过渡。然后这些元素滑入它们的新位置💃🏾💃🏾💃🏾。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ln lo l"/></div></figure><h1 id="b07d" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">消除故障</h1><p id="9864" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">当我开始用<strong class="jp ir"> <em class="kt"> useEffect </em> </strong>工作时，我发现它看起来超级故障，然后在React文档中挖掘后，我发现了这个提示:</p><blockquote class="mt mu mv"><p id="3a1c" class="jn jo kt jp b jq jr js jt ju jv jw jx mw jz ka kb mx kd ke kf my kh ki kj kk ij bi translated">"与componentDidMount或componentDidUpdate不同，使用useEffect安排的效果不会阻止浏览器更新屏幕。这让你的应用程序感觉反应更快。大多数影响不需要同时发生。在不常见的情况下(例如测量布局)，有一个单独的useLayoutEffect挂钩，其API与useEffect相同。— <a class="ae lp" href="https://reactjs.org/docs/hooks-effect.html#detailed-explanation" rel="noopener ugc nofollow" target="_blank">反应文件</a></p></blockquote><p id="c0b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然我们的目的是度量DOM中元素的布局，那么我们实际需要的是<a class="ae lp" href="https://reactjs.org/docs/hooks-reference.html#uselayouteffect" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="kt">useLayoutEffect</em></strong></a>。如前所述，<strong class="jp ir"><em class="kt">useLayoutEffect</em></strong>拥有与<strong class="jp ir"> <em class="kt"> useEffect </em> </strong>相同的API，所以我可以很容易地切换两者，这使得整个动画看起来非常流畅😎</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mz lo l"/></div></figure></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><p id="5859" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你走到了最后🎉在推特上找到我，了解更多技术思考😁</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="8361" class="lq lr iq bd ls lt nh lv lw lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn bi translated">临时演员</h1><ul class=""><li id="2c9f" class="ku kv iq jp b jq mo ju mp jy nm kc nn kg no kk np la lb lc bi translated">Joshua Comeau的<a class="ae lp" href="https://medium.com/developers-writing/animating-the-unanimatable-1346a5aab3cd" rel="noopener">动画制作不可想象的</a>帖子是这项工作的基础，所以我推荐阅读，Joshua谈了很多关于DOM渲染和翻转概念的内容。</li><li id="c376" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk np la lb lc bi translated">我最初尝试使用基于Ryan Florence的React.js conf talk 的“Magic Move”概念。这个版本的代码沙箱在这里，但是这个版本相当复杂和不完整。</li></ul></div></div>    
</body>
</html>