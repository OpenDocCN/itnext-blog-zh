<html>
<head>
<title>Using Node to call a GraphQL API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node调用GraphQL API</h1>
<blockquote>原文：<a href="https://itnext.io/call-graphql-api-with-native-node-modules-5e4d088ca969?source=collection_archive---------5-----------------------#2018-03-14">https://itnext.io/call-graphql-api-with-native-node-modules-5e4d088ca969?source=collection_archive---------5-----------------------#2018-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7999" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用本机模块</h2></div><p id="c523" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fcall-graphql-api-with-native-node-modules-5e4d088ca969" rel="noopener ugc nofollow" target="_blank">点击这里在LinkedIn上分享这篇文章</a></p><p id="18f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">乍一看，调用GraphQL API服务器似乎很复杂。有几个不错的选择，比如<a class="ae lb" href="https://github.com/apollographql/apollo-fetch" rel="noopener ugc nofollow" target="_blank">阿波罗取</a>。但是，如果您正在构建一个节点应用程序，并且想要一个使用本机节点模块的简单解决方案，这里是您的解决方案。在Credit Karma，我们希望使用GitHub GraphQL API来搜索我们存储库的某些方面，所以我开发了一个简单的客户端，并想分享我的发现。</p><p id="9b0b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在着手构建应用程序之前，我确立了以下目标:</p><ul class=""><li id="8f34" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated">它应该没有任何依赖性</li><li id="02bd" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">应该能够加载以GraphQL模式语言编写的查询</li><li id="ff4c" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">查询应该能够使用从命令行传递的变量</li><li id="44d7" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">支持在多个查询中使用的片段</li><li id="2604" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">通过多次调用同一查询来支持分页</li><li id="5234" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">用纯函数构建</li><li id="f8ee" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">(音乐)可设定的</li><li id="21cb" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">可流式传输</li></ul><p id="c087" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，我们将调用GitHub GraphQL API来获取一个存储库的观星者列表。我们将发送的主要查询:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="6ffb" class="lz ma iq lv b gy mb mc l md me">query StarGazers($owner: String!, $name: String!, $cursor: String) {<br/>  repository(owner: $owner, name: $name) {<br/>    stargazers(first: 100, after: $cursor) {<br/>      ...starGazerFields<br/>    }<br/>  }<br/>}</span></pre><p id="d679" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不打算讨论GraphQL语言的细节或如何构建查询，但是如果您是GraphQL新手，下面的文章可以提供一些见解:</p><ul class=""><li id="43f1" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated"><a class="ae lb" href="http://graphql.org/learn/" rel="noopener ugc nofollow" target="_blank">graph QL简介</a></li><li id="2d1b" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" href="http://graphql.org/learn/queries/" rel="noopener ugc nofollow" target="_blank">查询和突变</a></li><li id="24f0" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" href="http://graphql.org/graphql-js/passing-arguments/" rel="noopener ugc nofollow" target="_blank">传递参数</a></li><li id="6782" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" href="https://wehavefaces.net/graphql-shorthand-notation-cheatsheet-17cd715861b6" rel="noopener ugc nofollow" target="_blank"> GraphQL模式语言备忘单</a></li></ul><p id="5c24" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从分解我在库中创建的不同函数开始。请记住，目标之一是提供一个纯函数库，将这些函数组合在一起，以便轻松地发出请求。</p><h1 id="88b8" class="mf ma iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">loadQuery</h1><p id="da2c" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">我们的目标之一是使用GraphQL模式语言文件来编写查询。上面的查询示例中展示了其中一个文件的示例。我们需要从构建一个从磁盘加载GraphQL文件的函数开始</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="1a38" class="lz ma iq lv b gy mb mc l md me">const { readFile } = require('fs')<br/>const { resolve } = require('path')<br/><br/>const loadQuery = (fileName) =&gt; new Promise((res, reject) =&gt; {<br/>    readFile(resolve(fileName), 'utf-8', (err, data) =&gt; {<br/>        (err) ? reject(err) : res(data)<br/>    })<br/>})</span></pre><p id="29c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您会注意到，我将标准的文件系统readFile API包装在一个promise中。这样做的好处之一是使用。then()符号。稍后会详细介绍。</p><p id="ce68" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了一个加载查询文件的工具，您应该检查查询中片段的使用:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="d724" class="lz ma iq lv b gy mb mc l md me">...starGazerFields</span></pre><p id="c215" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是这个片段没有在查询文件中定义，因此如果我们将这个查询发送到服务器，它将返回一个错误。下面是这个片段的一个示例:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="81d4" class="lz ma iq lv b gy mb mc l md me">fragment starGazerFields on StargazerConnection {<br/>    pageInfo {<br/>        endCursor<br/>    }<br/>    nodes {<br/>        company<br/>        bio<br/>        name<br/>        location<br/>    }<br/>}</span></pre><h1 id="c466" class="mf ma iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">appendQuery</h1><p id="b99a" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">为了使原始查询能够工作，我们需要在将查询发送到服务器之前将上面的片段附加到查询中。我为这个用例创建了以下函数:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="f4d5" class="lz ma iq lv b gy mb mc l md me">const appendQuery = (fileName) =&gt; (query) =&gt;<br/>    loadQuery(fileName).then((results) =&gt; query + results)</span></pre><p id="07c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种语法可能看起来有点奇怪，但它是我试图实现的可组合性的一部分。appendQuery函数接受一个文件名并返回另一个函数，该函数接受原始查询并将文件追加到该查询中。在本文的后面，我将提供一个例子来说明这些是如何组合在一起的。</p><h1 id="2d1d" class="mf ma iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">建筑主体</h1><p id="79b9" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">现在我们已经加载了查询，我们需要构建将要发送到GitHub的http POST的主体。根据是否需要向查询传递变量，我为此创建了两个不同的函数:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="29cd" class="lz ma iq lv b gy mb mc l md me">const buildBody = (query) =&gt; Promise.resolve({<br/>    body: JSON.stringify({query})<br/>})<br/><br/>const buildBodyWithVariables = (variables) =&gt; (query) =&gt; Promise.resolve({<br/>    body: JSON.stringify({query, variables})<br/>})</span></pre><h1 id="8dde" class="mf ma iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">构建标题</h1><p id="7b4b" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">一旦我们有了一个字符串体，我们就可以构建请求所需的header对象。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="11ea" class="lz ma iq lv b gy mb mc l md me">const buildHeaders = ({user, token}) =&gt; ({body}) =&gt; Promise.resolve({<br/>    body,<br/>    headers: {<br/>        'Content-Type': 'application/json',<br/>        'Content-Length': body.length,<br/>        'User-Agent': `${user}`,<br/>        'Authorization': `token ${token}`<br/>    }<br/>})</span></pre><p id="389f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">观察</strong>:你可能已经注意到，在这个函数以及前两个函数中，我使用了Promise.resolve来立即返回承诺的结果。我继续使用承诺来保持可组合性与查询加载器一致。</p><h1 id="f83b" class="mf ma iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">buildRequestOptions</h1><p id="ef05" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">既然我们已经构建了请求的有效负载，我们可以定义我们想要调用的端点的细节。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="0115" class="lz ma iq lv b gy mb mc l md me">const buildRequestOptions = ({headers, body}) =&gt; Promise.resolve({<br/>    body,<br/>    options: {<br/>        method: 'POST',<br/>        host: 'api.github.com',<br/>        path: '/graphql',<br/>        port: 443,<br/>        headers<br/>    }<br/>})</span></pre><p id="34d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">观察</strong>:我对函数参数使用了对象销毁。这是识别调用该函数所需的对象结构的一个很好的方法。</p><h1 id="abae" class="mf ma iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">生成请求</h1><p id="08aa" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">让我们将请求发送到GraphQL API服务器。我将来自服务器的结果批量处理成一个JSON对象结果。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="2bd7" class="lz ma iq lv b gy mb mc l md me">const { request } = require('https')<br/><br/>const makeRequest = ({options, body}) =&gt; new Promise((resolve, reject) =&gt; {<br/>    request(options, (res) =&gt; {<br/>        let result = ''<br/>        res.on('data', (chunk) =&gt; result += chunk)<br/>        res.on('end', () =&gt; resolve(JSON.parse(result)))<br/>        res.on('error', (err) =&gt; reject(err))<br/>    }).write(body)<br/>})</span></pre><p id="eda2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">观察</strong>:我再次将Node的标准请求方法的细节包装在一个承诺中，使其在用于流时更具可组合性。</p><h1 id="9492" class="mf ma iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">尝试这一切</h1><p id="8208" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">那么，我们如何使用所有这些函数来发出GraphQL请求呢？</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="fa20" class="lz ma iq lv b gy mb mc l md me">loadQuery('./starGazerFragment.gql')<br/>    .then(appendQuery('./searchStarGazers.gql'))<br/>    .then(buildBodyWithVariables({owner: 'hapijs', name: 'hapi'}))<br/>    .then(buildHeaders({user: '...', token: '...'}))<br/>    .then(buildRequestOptions)<br/>    .then(makeRequest)<br/>    .then((results) =&gt; console.dir(results, {depth: null}))</span></pre><p id="6fd0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可能看起来相当复杂，有几个移动的部分，但是，它提供了过程中的任何步骤都很容易被替换的灵活性，使其高度可定制。</p><h1 id="16d9" class="mf ma iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">使其可流动</h1><p id="c7f2" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">这可以使用流式节点本地库轻松完成。下面我把前面的例子变成了一个函数，我正在一个可读的流中使用它。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="69d2" class="lz ma iq lv b gy mb mc l md me">const { Readable } = require('stream')<br/><br/>const sendRequest = () =&gt; loadQuery('./starGazerFragment.gql')<br/>    .then(appendQuery('./searchStarGazers.gql'))<br/>    .then(buildBodyWithVariables({owner: 'hapijs', name: 'hapi'}))<br/>    .then(buildHeaders({user: '...', token: '...'}))<br/>    .then(buildRequestOptions)<br/>    .then(makeRequest)<br/><br/>const createStream = () =&gt; new Readable({<br/>    objectMode: true,<br/>    read(opts) {<br/>        if (!this.requestCompleted) {<br/>            return sendRequest().then((data) =&gt; {<br/>                this.requestCompleted = true<br/>                this.push(data)<br/>            })<br/>        } else {<br/>            this.push(null)<br/>        }<br/>    }<br/>})</span></pre><h1 id="8954" class="mf ma iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">结束语</h1><p id="6780" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">尽管有许多不同的库可用于发出GraphQL请求，但我发现构建一个简单的60行模块而不依赖外部是令人满意的。我已经使用这个小库成功地执行了几个不同的GitHub GraphQL查询。API的可组合性导致了一些样板文件，但是API的灵活性似乎提供了一个很好的平衡。</p><p id="7d6f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请在下面的评论中告诉我你的想法，或者直接在Twitter @nancenick上与我联系。</p></div></div>    
</body>
</html>