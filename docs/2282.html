<html>
<head>
<title>Building a Handwritten Digit Recognizer in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Java构建手写数字识别器</h1>
<blockquote>原文：<a href="https://itnext.io/building-a-handwritten-digit-recognizer-in-java-4eca4014eb2f?source=collection_archive---------1-----------------------#2019-04-30">https://itnext.io/building-a-handwritten-digit-recognizer-in-java-4eca4014eb2f?source=collection_archive---------1-----------------------#2019-04-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="753d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将在Java应用程序中构建一个手写数字识别器。该应用程序将使用开源Java框架Deeplearning4j构建。使用的数据集是手写数字的经典MNIST数据库(<a class="ae ko" href="http://yann.lecun.com/exdb/mnist/" rel="noopener ugc nofollow" target="_blank">http://yann.lecun.com/exdb/mnist/</a>)。训练数据集过大，有60，000幅图像，而测试数据集包含10，000幅图像。这些图像的大小和灰度为28 x 28。</p><p id="2c94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为我们将在本文中创建的应用程序的一部分，我们将实现一个图形用户界面，您可以在其中绘制数字，并让神经网络识别数字。</p><p id="6b93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">直接进入代码，让我们观察如何用Java实现一个神经网络。我们从参数开始；第一个是输出。因为我们有0到9个数字，所以我们有10个类:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="78a7" class="ky kz it ku b gy la lb l lc ld">/**</span><span id="f389" class="ky kz it ku b gy le lb l lc ld">* Number prediction classes.</span><span id="8ce3" class="ky kz it ku b gy le lb l lc ld">* We have 0–9 digits so 10 classes in total.</span><span id="221b" class="ky kz it ku b gy le lb l lc ld">*/</span><span id="90f6" class="ky kz it ku b gy le lb l lc ld">private static final int OUTPUT = 10;</span></pre><p id="7d8f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们有小批量大小，这是我们在更新权重之前看到的图像数量，或者我们将并行处理的图像数量:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="f249" class="ky kz it ku b gy la lb l lc ld">/**</span><span id="b69a" class="ky kz it ku b gy le lb l lc ld">* Mini batch gradient descent size or number of matrices processed in parallel.</span><span id="f0f1" class="ky kz it ku b gy le lb l lc ld">* For CORE-I7 16 is good for GPU please change to 128 and up</span><span id="00c1" class="ky kz it ku b gy le lb l lc ld">*/</span><span id="7565" class="ky kz it ku b gy le lb l lc ld">private static final int MINI_BATCH_SIZE = 16;// Number of training epochs</span><span id="3f00" class="ky kz it ku b gy le lb l lc ld">/**</span><span id="9fcf" class="ky kz it ku b gy le lb l lc ld">* Number of total traverses through data.</span><span id="2f1e" class="ky kz it ku b gy le lb l lc ld">* with 5 epochs we will have 5/@MINI_BATCH_SIZE iterations or weights updates</span><span id="c0ee" class="ky kz it ku b gy le lb l lc ld">*/</span><span id="fe17" class="ky kz it ku b gy le lb l lc ld">private static final int EPOCHS = 5;</span></pre><p id="7d1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们为CPU考虑这一点时，16的批量大小是没问题的，但是对于GPU，这需要根据GPU的能力而改变。当我们遍历所有数据时，就完成了一个时期。</p><p id="881f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">学习率非常重要，因为具有非常低的值会减慢学习，而具有较大的学习率值会导致神经网络实际上发散:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="d771" class="ky kz it ku b gy la lb l lc ld">/**</span><span id="7834" class="ky kz it ku b gy le lb l lc ld">* The alpha learning rate defining the size of step towards the minimum</span><span id="a141" class="ky kz it ku b gy le lb l lc ld">*/</span><span id="a0a8" class="ky kz it ku b gy le lb l lc ld">private static final double LEARNING_RATE = 0.01;</span></pre><p id="58c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了详细理解这一点，在本节的后半部分，我们将通过改变学习率来模拟一个发散的情况。幸运的是，作为该示例的一部分，我们不需要处理MNIST数据集中像素的读取、传输或归一化。我们不需要关心将数据转换成一维向量以适合神经网络。这是因为一切都是由Deeplearning4j封装和提供的。</p><p id="77a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在对象<strong class="js iu">数据集迭代器下，</strong>我们需要指定批量大小，以及我们是否要将其用于训练或测试，这将有助于分类我们是需要从训练数据集加载60，000幅图像，还是从测试数据集加载10，000幅图像:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="00ea" class="ky kz it ku b gy la lb l lc ld">public void train() throws Exception {</span><span id="6590" class="ky kz it ku b gy le lb l lc ld">/*</span><span id="17f4" class="ky kz it ku b gy le lb l lc ld">Create an iterator using the batch size for one iteration</span><span id="e11c" class="ky kz it ku b gy le lb l lc ld">*/</span><span id="5307" class="ky kz it ku b gy le lb l lc ld">log.info(“Load data….”);</span><span id="39cc" class="ky kz it ku b gy le lb l lc ld">DataSetIterator mnistTrain = new MnistDataSetIterator(MINI_BATCH_SIZE, true, SEED);</span><span id="8715" class="ky kz it ku b gy le lb l lc ld">/*</span><span id="e1b5" class="ky kz it ku b gy le lb l lc ld">Construct the neural neural</span><span id="4150" class="ky kz it ku b gy le lb l lc ld">*/</span><span id="7da4" class="ky kz it ku b gy le lb l lc ld">log.info(“Build model….”);</span><span id="1bf6" class="ky kz it ku b gy le lb l lc ld">MultiLayerConfiguration conf = new NeuralNetConfiguration.Builder()</span><span id="4a2a" class="ky kz it ku b gy le lb l lc ld">.seed(SEED)</span><span id="80c9" class="ky kz it ku b gy le lb l lc ld">.learningRate(LEARNING_RATE)</span><span id="d140" class="ky kz it ku b gy le lb l lc ld">.weightInit(WeightInit.XAVIER)</span><span id="9055" class="ky kz it ku b gy le lb l lc ld">//NESTEROVS is referring to gradient descent with momentum</span><span id="bd13" class="ky kz it ku b gy le lb l lc ld">.updater(Updater.NESTEROVS)</span><span id="e6eb" class="ky kz it ku b gy le lb l lc ld">.list()</span></pre><p id="4bd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们开始建立一个神经网络。我们已经指定了学习率，并根据Xavier初始化了权重，这是我们在前面几节中已经学过的。代码中的更新器实际上只是用梯度下降来更新权重的优化算法。NESTEROVS基本上是我们已经熟悉的带动量的梯度下降。</p><p id="326b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看代码，以更好地理解更新程序。我们看这两个公式，实际上和我们已经研究过的没有什么不同。</p><p id="7308" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们配置输入层、隐藏层和输出。输入层的配置相当容易；我们只需要把宽度和重量相乘，我们就有了这个一维向量的大小。代码的下一步是定义隐藏层。实际上，我们有两个隐藏层:一个有128个神经元，另一个有64个神经元，由于效率高，两者都具有激活功能。</p><p id="c845" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了稍微改变一下，我们可以尝试不同的值，尤其是那些由MNIST数据集网页定义的值。尽管如此，这里选择的值是相当有效的，具有较少的训练时间和良好的准确性。</p><p id="3a41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出层使用softmax，因为我们需要10个类而不是2个，所以我们也有成本函数。细节可能与我们之前看到的有所不同。该函数根据真实值衡量假设值的表现。</p><p id="bceb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们初始化并定义函数，因为我们希望看到每100次迭代的成本函数。model.fit (minstTrain)非常重要，因为它实际上是一次又一次地工作，正如许多人所定义的那样，它遍历所有数据。在这之后，我们已经执行了一个时期，并且神经网络已经学会使用好的权重。</p><h1 id="1dca" class="lf kz it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">测试神经网络的性能</h1><p id="3c00" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">为了测试网络的准确性，我们构建了另一个数据集进行测试。我们用目前为止学到的知识评估这个模型，并打印统计数据。如果网络的准确率超过97%，我们就此打住，保存模型，用于我们稍后将研究的图形用户界面。执行以下代码:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="e20e" class="ky kz it ku b gy la lb l lc ld">if (mnistTest == null) {</span><span id="ba14" class="ky kz it ku b gy le lb l lc ld">mnistTest = new MnistDataSetIterator(MINI_BATCH_SIZE, false, SEED);</span><span id="341a" class="ky kz it ku b gy le lb l lc ld">}</span></pre><p id="c63b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">成本函数被打印出来，如果你仔细观察，它会在迭代中逐渐减少。有时，我们在成本函数值上有一个峰值。这是小批量梯度下降的一个特征。第一个历元的最终输出向我们显示，该模型仅在一个历元内就具有96%的准确性，这是非常棒的。这意味着神经网络学习速度很快。</p><p id="eeab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在大多数情况下，它不像这样工作，我们需要调整我们的网络很长一段时间才能获得我们想要的输出。让我们看看第二个纪元的输出:</p><figure class="kp kq kr ks gt mi gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/3006aa6f9cbef98743d1eb5e42475d47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*3mXWFhEYUABqbYwmEDwAdg.png"/></div></figure><p id="3f73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在两个时期内获得了超过97%的准确率。</p><p id="2e53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要注意的另一个方面是，一个简单的模型是如何实现真正伟大的结果的。这是深度学习正在腾飞的一部分原因。很容易获得好的结果，也很容易合作。</p><p id="6f53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如前所述，让我们看看将学习率提高到0.6的发散情况:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="8576" class="ky kz it ku b gy la lb l lc ld">private static final double LEARNING_RATE = 0.01;</span><span id="6a30" class="ky kz it ku b gy le lb l lc ld">/**</span><span id="41f2" class="ky kz it ku b gy le lb l lc ld">* <a class="ae ko" href="https://en.wikipedia.org/wiki/Random_seed" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Random_seed</a></span><span id="ad6d" class="ky kz it ku b gy le lb l lc ld">*/</span><span id="f41d" class="ky kz it ku b gy le lb l lc ld">private static final int SEED = 123;</span><span id="65c1" class="ky kz it ku b gy le lb l lc ld">private static final int IMAGE_WIDTH = 28;</span><span id="8c28" class="ky kz it ku b gy le lb l lc ld">private static final int IMAGE_HEIGHT = 28;</span></pre><p id="dcfa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们现在运行网络，我们将观察到成本函数将继续增加，没有减少的迹象。精度也大受影响。一个时期的成本函数几乎保持不变，尽管有3000次迭代。模型的最终精度约为10%，这清楚地表明这不是最好的方法。</p><p id="4659" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们针对不同的数字运行应用程序，看看它是如何工作的。让我们从数字<strong class="js iu"> 3 </strong>开始:</p><figure class="kp kq kr ks gt mi gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/8d95f6e7821f39ac147aa26c79b2d8c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*UFyTmV2sTz0wXBbGFhErRw.png"/></div></figure><p id="1d26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出是准确的。对0到9之间的任何一个数字运行这个程序，检查你的模型是否工作准确。</p><p id="e6fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同时，记住这个模型还不完善——我们将在下一章用CNN架构来改进它。他们提供最先进的技术和高精确度，我们应该能够达到99%的精确度。</p><p id="b181" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">希望你觉得这篇文章有趣。如果你想用Java实现更多这样的深度学习项目，你必须看看<a class="ae ko" href="https://www.amazon.com/Hands-Java-Learning-Computer-Vision/dp/1789613965?utm_source=https://itnext.io/&amp;utm_medium=referral&amp;utm_campaign=ThirdPartyPromotions" rel="noopener ugc nofollow" target="_blank">的计算机视觉Java深度学习实践</a>。由Klevis Ramo，<a class="ae ko" href="https://www.packtpub.com/big-data-and-business-intelligence/hands-java-deep-learning-computer-vision?utm_source=https://itnext.io/&amp;utm_medium=referral&amp;utm_campaign=ThirdPartyPromotions" rel="noopener ugc nofollow" target="_blank">撰写，面向计算机视觉的实用Java深度学习</a>将带您完成用Java高效训练深度神经网络以完成计算机视觉相关任务的过程。</p></div></div>    
</body>
</html>