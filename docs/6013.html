<html>
<head>
<title>Building GraphQL APIs with Eclipse Vertx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Eclipse Vertx构建GraphQL APIs</h1>
<blockquote>原文：<a href="https://itnext.io/building-graphql-apis-with-eclipse-vertx-2f3a4e584370?source=collection_archive---------1-----------------------#2021-07-24">https://itnext.io/building-graphql-apis-with-eclipse-vertx-2f3a4e584370?source=collection_archive---------1-----------------------#2021-07-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2375" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在之前的<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/building-graphql-apis-with-quarkus-dbbf23f897df"> Quarkus GraphQL帖子</a>中讨论过GraphQL。在本文中，我们将探索Eclipse Vertx中的GraphQL支持。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/f12666d091748b31d5d349aa9c710e4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m_nulmhV7cbLfrp0iAmbcg.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://unsplash.com/@yangshuo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杨烁</a>在<a class="ae kl" href="https://unsplash.com/s/photos/china-mountain?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><blockquote class="lc ld le"><p id="d033" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">Quarkus还包括一个替代的GraphQL扩展，它使用Eclipse Vertx GraphQL特性。</p></blockquote><p id="ec39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按照<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/building-restful-apis-with-eclipse-vertx-4ce89d8eeb74">用Eclipse Vertx </a>构建RESTful APIs中的步骤，创建一个新的Eclipse Vertx项目，不要忘记将<em class="lf"> GraphQL </em>添加到<strong class="jp ir">依赖项</strong>中。</p><p id="b60c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者直接在现有的<em class="lf"> pom.xml </em>文件中添加以下依赖关系。</p><pre class="kn ko kp kq gt lj lk ll lm aw ln bi"><span id="b3b6" class="lo lp iq lk b gy lq lr l ls lt">&lt;dependency&gt;<br/>     &lt;groupId&gt;io.vertx&lt;/groupId&gt;<br/>     &lt;artifactId&gt;vertx-web-graphql&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><h2 id="8400" class="lo lp iq bd lu lv lw dn lx ly lz dp ma jy mb mc md kc me mf mg kg mh mi mj mk bi translated">从我的Github 中查看<a class="ae kl" href="https://github.com/hantsy/vertx-sandbox/tree/master/graphql" rel="noopener ugc nofollow" target="_blank">完整的示例代码。</a></h2><p id="9cd4" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">Vertx提供了一个特定的<code class="fe mq mr ms lk b">GraphQLHandler</code>来处理来自客户端的GraphQL请求。</p><p id="f371" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用以下内容填充<code class="fe mq mr ms lk b">MainVerticle</code>。</p><pre class="kn ko kp kq gt lj lk ll lm aw ln bi"><span id="5daa" class="lo lp iq lk b gy lq lr l ls lt">@Slf4j<br/>public class MainVerticle extends AbstractVerticle {</span><span id="a5eb" class="lo lp iq lk b gy mt lr l ls lt">    static {<br/>        log.info("Customizing the built-in jackson ObjectMapper...");<br/>        var objectMapper = DatabindCodec.mapper();<br/>        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);<br/>        objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS);<br/>        objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);</span><span id="ee1e" class="lo lp iq lk b gy mt lr l ls lt">        JavaTimeModule module = new JavaTimeModule();<br/>        objectMapper.registerModule(module);<br/>    }</span><span id="2654" class="lo lp iq lk b gy mt lr l ls lt">    @Override<br/>    public void start(Promise&lt;Void&gt; startPromise) throws Exception {<br/>        log.info("Starting HTTP server...");<br/>        //setupLogging();</span><span id="8c13" class="lo lp iq lk b gy mt lr l ls lt">        //Create a PgPool instance<br/>        var pgPool = pgPool();</span><span id="633e" class="lo lp iq lk b gy mt lr l ls lt">        // instantiate repos<br/>        var postRepository = new PostRepository(pgPool);<br/>        var commentRepository = new CommentRepository(pgPool);<br/>        var authorRepository = new AuthorRepository(pgPool);</span><span id="e6dc" class="lo lp iq lk b gy mt lr l ls lt">        // Initializing the sample data<br/>        var initializer = new DataInitializer(postRepository, commentRepository, authorRepository);<br/>        initializer.run();</span><span id="b9d6" class="lo lp iq lk b gy mt lr l ls lt">        //assemble PostService<br/>        var postService = new PostService(postRepository, commentRepository, authorRepository);<br/>        var authorService = new AuthorService(authorRepository);</span><span id="40c8" class="lo lp iq lk b gy mt lr l ls lt">        // assemble DataLoaders<br/>        var dataLoaders = new DataLoaders(authorService, postService);</span><span id="8851" class="lo lp iq lk b gy mt lr l ls lt">        //assemble DataFetcher<br/>        var dataFetchers = new DataFetchers(postService);</span><span id="b800" class="lo lp iq lk b gy mt lr l ls lt">        // setup GraphQL<br/>        GraphQL graphQL = setupGraphQLJava(dataFetchers);</span><span id="db92" class="lo lp iq lk b gy mt lr l ls lt">        // Configure routes<br/>        var router = setupRoutes(graphQL, dataLoaders);</span><span id="409d" class="lo lp iq lk b gy mt lr l ls lt">        // enable GraphQL Websocket Protocol<br/>        HttpServerOptions httpServerOptions = new HttpServerOptions()<br/>            .addWebSocketSubProtocol("graphql-ws");<br/>        // Create the HTTP server<br/>        vertx.createHttpServer(httpServerOptions)<br/>            // Handle every request using the router<br/>            .requestHandler(router)<br/>            // Start listening<br/>            .listen(8080)<br/>            // Print the port<br/>            .onSuccess(server -&gt; {<br/>                startPromise.complete();<br/>                log.info("HTTP server started on port " + server.actualPort());<br/>            })<br/>            .onFailure(event -&gt; {<br/>                startPromise.fail(event);<br/>                log.info("Failed to start HTTP server:" + event.getMessage());<br/>            })<br/>        ;<br/>    }</span><span id="1cf7" class="lo lp iq lk b gy mt lr l ls lt">    //create routes<br/>    private Router setupRoutes(GraphQL graphQL, DataLoaders dataLoaders) {</span><span id="5b92" class="lo lp iq lk b gy mt lr l ls lt">        // Create a Router<br/>        Router router = Router.router(vertx);</span><span id="6f74" class="lo lp iq lk b gy mt lr l ls lt">        // register BodyHandler globally.<br/>        router.route().handler(BodyHandler.create());</span><span id="1ebd" class="lo lp iq lk b gy mt lr l ls lt">        // register GraphQL Subscription websocket handler.<br/>        ApolloWSOptions apolloWSOptions = new ApolloWSOptions();<br/>        router.route("/graphql").handler(<br/>            ApolloWSHandler.create(graphQL, apolloWSOptions)<br/>                .connectionInitHandler(connectionInitEvent -&gt; {<br/>                    JsonObject payload = connectionInitEvent.message().content().getJsonObject("payload");<br/>                    log.info("connection init event: {}", payload);<br/>                    if (payload != null &amp;&amp; payload.containsKey("rejectMessage")) {<br/>                        connectionInitEvent.fail(payload.getString("rejectMessage"));<br/>                        return;<br/>                    }<br/>                    connectionInitEvent.complete(payload);<br/>                })<br/>                //.connectionHandler(event -&gt; log.info("connection event: {}", event))<br/>                //.messageHandler(msg -&gt; log.info("websocket message: {}", msg.content().toString()))<br/>                //.endHandler(event -&gt; log.info("end event: {}", event))<br/>        );</span><span id="61db" class="lo lp iq lk b gy mt lr l ls lt">        GraphQLHandlerOptions options = new GraphQLHandlerOptions()<br/>            // enable multipart for file upload.<br/>            .setRequestMultipartEnabled(true)<br/>            .setRequestBatchingEnabled(true);<br/>        // register `/graphql` for GraphQL handler<br/>        // alternatively, use `router.route()` to enable GET and POST http methods<br/>        router.post("/graphql")<br/>            .handler(<br/>                GraphQLHandler.create(graphQL, options)<br/>                    .dataLoaderRegistry(buildDataLoaderRegistry(dataLoaders))<br/>                //.locale()<br/>                //.queryContext()<br/>            );</span><span id="5710" class="lo lp iq lk b gy mt lr l ls lt">        // register `/graphiql` endpoint for the GraphiQL UI<br/>        GraphiQLHandlerOptions graphiqlOptions = new GraphiQLHandlerOptions()<br/>            .setEnabled(true);<br/>        router.get("/graphiql/*").handler(GraphiQLHandler.create(graphiqlOptions));</span><span id="be66" class="lo lp iq lk b gy mt lr l ls lt">        router.get("/hello").handler(rc -&gt; rc.response().end("Hello from my route"));</span><span id="5de5" class="lo lp iq lk b gy mt lr l ls lt">        return router;<br/>    }</span><span id="3fc1" class="lo lp iq lk b gy mt lr l ls lt">    private Function&lt;RoutingContext, DataLoaderRegistry&gt; buildDataLoaderRegistry(DataLoaders dataLoaders) {<br/>        DataLoaderRegistry registry = new DataLoaderRegistry();<br/>        registry.register("commentsLoader", dataLoaders.commentsLoader());<br/>        registry.register("authorsLoader", dataLoaders.authorsLoader());<br/>        return rc -&gt; registry;<br/>    }</span><span id="0835" class="lo lp iq lk b gy mt lr l ls lt">    @SneakyThrows<br/>    private GraphQL setupGraphQLJava(DataFetchers dataFetchers) {<br/>        TypeDefinitionRegistry typeDefinitionRegistry = buildTypeDefinitionRegistry();<br/>        RuntimeWiring runtimeWiring = buildRuntimeWiring(dataFetchers);<br/>        GraphQLSchema graphQLSchema = buildGraphQLSchema(typeDefinitionRegistry, runtimeWiring);<br/>        return buildGraphQL(graphQLSchema);<br/>    }</span><span id="5914" class="lo lp iq lk b gy mt lr l ls lt">    private GraphQL buildGraphQL(GraphQLSchema graphQLSchema) {<br/>        return GraphQL.newGraphQL(graphQLSchema)<br/>            .defaultDataFetcherExceptionHandler(new CustomDataFetchingExceptionHandler())<br/>            //.queryExecutionStrategy()<br/>            //.mutationExecutionStrategy()<br/>            //.subscriptionExecutionStrategy()<br/>            //.instrumentation()<br/>            .build();<br/>    }</span><span id="46fa" class="lo lp iq lk b gy mt lr l ls lt">    private GraphQLSchema buildGraphQLSchema(TypeDefinitionRegistry typeDefinitionRegistry, RuntimeWiring runtimeWiring) {<br/>        SchemaGenerator schemaGenerator = new SchemaGenerator();<br/>        GraphQLSchema graphQLSchema = schemaGenerator.makeExecutableSchema(typeDefinitionRegistry, runtimeWiring);<br/>        return graphQLSchema;<br/>    }</span><span id="1db6" class="lo lp iq lk b gy mt lr l ls lt">    private TypeDefinitionRegistry buildTypeDefinitionRegistry() throws IOException, URISyntaxException {<br/>        var schema = Files.readString(Paths.get(getClass().getResource("/schema/schema.graphql").toURI()));<br/>        //String schema = vertx.fileSystem().readFileBlocking("/schema/schema.graphql").toString();</span><span id="34d0" class="lo lp iq lk b gy mt lr l ls lt">        SchemaParser schemaParser = new SchemaParser();<br/>        TypeDefinitionRegistry typeDefinitionRegistry = schemaParser.parse(schema);<br/>        return typeDefinitionRegistry;<br/>    }</span><span id="7a42" class="lo lp iq lk b gy mt lr l ls lt">    private RuntimeWiring buildRuntimeWiring(DataFetchers dataFetchers) {<br/>        return newRuntimeWiring()<br/>            // the following codes are moved to CodeRegistry, the central place to configure the execution codes.<br/>            /*<br/>            .wiringFactory(new WiringFactory() {<br/>                @Override<br/>                public DataFetcher&lt;Object&gt; getDefaultDataFetcher(FieldWiringEnvironment environment) {<br/>                    return VertxPropertyDataFetcher.create(environment.getFieldDefinition().getName());<br/>                }<br/>            })<br/>            .type("Query", builder -&gt; builder<br/>                .dataFetcher("postById", dataFetchers.getPostById())<br/>                .dataFetcher("allPosts", dataFetchers.getAllPosts())<br/>            )<br/>            .type("Mutation", builder -&gt; builder.dataFetcher("createPost", dataFetchers.createPost()))<br/>            .type("Post", builder -&gt; builder<br/>                .dataFetcher("author", dataFetchers.authorOfPost())<br/>                .dataFetcher("comments", dataFetchers.commentsOfPost())<br/>            )<br/>            */<br/>            .codeRegistry(buildCodeRegistry(dataFetchers))<br/>            .scalar(Scalars.localDateTimeType())<br/>            .scalar(Scalars.uuidType())<br/>            .scalar(UploadScalar.build())// handling `Upload` scalar<br/>            .directive("uppercase", new UpperCaseDirectiveWiring())<br/>            .build();<br/>    }</span><span id="ec31" class="lo lp iq lk b gy mt lr l ls lt">    private GraphQLCodeRegistry buildCodeRegistry(DataFetchers dataFetchers) {<br/>        return GraphQLCodeRegistry.newCodeRegistry()<br/>            .dataFetchers("Query", Map.of(<br/>                "postById", dataFetchers.getPostById(),<br/>                "allPosts", dataFetchers.getAllPosts()<br/>            ))<br/>            .dataFetchers("Mutation", Map.of(<br/>                "createPost", dataFetchers.createPost(),<br/>                "upload", dataFetchers.upload(),<br/>                "addComment", dataFetchers.addComment()<br/>            ))<br/>            .dataFetchers("Subscription", Map.of(<br/>                "commentAdded", dataFetchers.commentAdded()<br/>            ))<br/>            .dataFetchers("Post", Map.of(<br/>                "author", dataFetchers.authorOfPost(),<br/>                "comments", dataFetchers.commentsOfPost()<br/>            ))<br/>            //.typeResolver()<br/>            //.fieldVisibility()<br/>            .defaultDataFetcher(environment -&gt; VertxPropertyDataFetcher.create(environment.getFieldDefinition().getName()))<br/>            .build();<br/>    }</span><span id="cacf" class="lo lp iq lk b gy mt lr l ls lt">    private PgPool pgPool() {<br/>        PgConnectOptions connectOptions = new PgConnectOptions()<br/>            .setPort(5432)<br/>            .setHost("localhost")<br/>            .setDatabase("blogdb")<br/>            .setUser("user")<br/>            .setPassword("password");</span><span id="3fd7" class="lo lp iq lk b gy mt lr l ls lt">        // Pool Options<br/>        PoolOptions poolOptions = new PoolOptions().setMaxSize(5);</span><span id="c082" class="lo lp iq lk b gy mt lr l ls lt">        // Create the pool from the data object<br/>        PgPool pool = PgPool.pool(vertx, connectOptions, poolOptions);</span><span id="cb1e" class="lo lp iq lk b gy mt lr l ls lt">        return pool;<br/>    }</span><span id="e5c9" class="lo lp iq lk b gy mt lr l ls lt">}</span></pre><p id="8016" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mq mr ms lk b">start</code>方法类似于之前帖子中的方法，但是这里它启用了<em class="lf"> graphql-ws </em> WebSocket子协议来激活GraphQL <em class="lf">订阅</em>支持。</p><p id="0a12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="lf"> setupRoutes </em>方法中，添加了route <em class="lf"> /graphql </em>来使用<code class="fe mq mr ms lk b">GraphQLHanlder</code>处理HTTP请求，并通过<em class="lf"> /graphql </em>端点启用WebSocket支持，还添加了route<em class="lf">/graphql</em>来激活graph QL交互式Web UI。</p><p id="2041" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，下面的代码用于创建一个<code class="fe mq mr ms lk b">GraphQLHandler</code>实例。</p><pre class="kn ko kp kq gt lj lk ll lm aw ln bi"><span id="c0b3" class="lo lp iq lk b gy lq lr l ls lt">GraphQLHandler.create(graphQL, options)<br/>                    .dataLoaderRegistry(buildDataLoaderRegistry(dataLoaders))</span></pre><p id="089d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它需要一个<code class="fe mq mr ms lk b">GraphQL</code>实例和可选的<code class="fe mq mr ms lk b">options</code>来初始化一个<code class="fe mq mr ms lk b">GraphQL</code>实例。</p><p id="db8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要构建一个<code class="fe mq mr ms lk b">GraphQL</code>实例，需要一个<code class="fe mq mr ms lk b">GraphQLSchema</code>，它依赖于以下两个基本对象:</p><ul class=""><li id="e7d2" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated">一个<code class="fe mq mr ms lk b">TypeDefinitionRegistry</code>从文件中解析graphql方案定义，参见上面的<code class="fe mq mr ms lk b">buildTypeDefinitionRegistry</code>方法。</li><li id="00cf" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">一个<code class="fe mq mr ms lk b">RuntimeWiring</code>实例组装运行时处理程序来服务GraphQL请求，参见上面的<code class="fe mq mr ms lk b">buildRuntimeWiring</code>方法。</li></ul><p id="68ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在GraphQLHandler中，注册将在每个请求中实例化的全局数据加载器。它用于降低N+1查询中执行查询的频率，并提高应用程序性能。</p><p id="313e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看<em class="lf">main/resources/schema/schema . graphql</em>文件夹下的graph QL模式文件。</p><pre class="kn ko kp kq gt lj lk ll lm aw ln bi"><span id="9e4c" class="lo lp iq lk b gy lq lr l ls lt">directive @uppercase on FIELD_DEFINITION</span><span id="e2d2" class="lo lp iq lk b gy mt lr l ls lt">scalar LocalDateTime<br/>scalar UUID<br/>scalar Upload</span><span id="f1d1" class="lo lp iq lk b gy mt lr l ls lt">type Post {<br/>    id: ID!<br/>    title: String! @uppercase<br/>    content: String<br/>    comments: [Comment]<br/>    status: PostStatus<br/>    createdAt: LocalDateTime<br/>    authorId: String<br/>    author: Author<br/>}</span><span id="e5cf" class="lo lp iq lk b gy mt lr l ls lt">type Author {<br/>    id: ID!<br/>    name: String!<br/>    email: String!<br/>    createdAt: LocalDateTime<br/>    posts: [Post]<br/>}<br/>type Comment {<br/>    id: ID!<br/>    content: String!<br/>    createdAt: LocalDateTime<br/>    postId: String!<br/>}</span><span id="156c" class="lo lp iq lk b gy mt lr l ls lt">input CreatePostInput {<br/>    title: String!<br/>    content: String!<br/>}</span><span id="78d9" class="lo lp iq lk b gy mt lr l ls lt">input CommentInput {<br/>    postId: String!<br/>    content: String!<br/>}</span><span id="5535" class="lo lp iq lk b gy mt lr l ls lt">type Query {<br/>    allPosts: [Post!]!<br/>    postById(postId: String!): Post<br/>}</span><span id="6e08" class="lo lp iq lk b gy mt lr l ls lt">type Mutation {<br/>    createPost(createPostInput: CreatePostInput!): UUID!<br/>    upload(file: Upload!): Boolean<br/>    addComment(commentInput: CommentInput!): UUID!<br/>}</span><span id="c512" class="lo lp iq lk b gy mt lr l ls lt">type Subscription{<br/>    commentAdded: Comment!<br/>}</span><span id="add8" class="lo lp iq lk b gy mt lr l ls lt">enum PostStatus {<br/>    DRAFT<br/>    PENDING_MODERATION<br/>    PUBLISHED<br/>}</span></pre><p id="b105" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个模式文件中，我们声明了3个顶级类型:<em class="lf">查询</em>、<em class="lf">突变</em>和<em class="lf">订阅</em>，它们提供了在我们的应用程序中定义的基本操作。<code class="fe mq mr ms lk b">Post</code>和<code class="fe mq mr ms lk b">Comment</code>是通用类型，表示返回的响应中使用的类型。<code class="fe mq mr ms lk b">CreatePostInput</code>和<code class="fe mq mr ms lk b">CommentInput</code>是输入参数，表示graphql请求的有效负载。<em class="lf">标量</em>关键字定义自定义标量类型。<em class="lf">指令</em>定义了应用于字段的自定义指令<em class="lf">@大写</em>。</p><p id="2915" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mq mr ms lk b">MainVerticle.buildCodeRegistry</code>方法中，它根据模式定义中定义的类型的坐标来组装数据提取器。</p><p id="144e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，当执行一个<em class="lf">查询</em> : <code class="fe mq mr ms lk b">postById</code>时，它将执行<code class="fe mq mr ms lk b">buildCodeRegistry</code>方法中定义的<code class="fe mq mr ms lk b">dataFetchers.postById</code>。</p><pre class="kn ko kp kq gt lj lk ll lm aw ln bi"><span id="7cb5" class="lo lp iq lk b gy lq lr l ls lt">.dataFetchers("Query", Map.of(<br/>                "postById", dataFetchers.getPostById(),<br/>    ...</span></pre><p id="2999" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看<code class="fe mq mr ms lk b">buildRuntimeWiring</code>，还会显示<code class="fe mq mr ms lk b">Scalar</code>、<code class="fe mq mr ms lk b">Directive</code>等。</p><p id="397c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是自定义标量类型的示例。</p><pre class="kn ko kp kq gt lj lk ll lm aw ln bi"><span id="2b1b" class="lo lp iq lk b gy lq lr l ls lt">// LocalDateTimeScalar<br/>public class LocalDateTimeScalar implements Coercing&lt;LocalDateTime, String&gt; {<br/>    @Override<br/>    public String serialize(Object dataFetcherResult) throws CoercingSerializeException {<br/>        if (dataFetcherResult instanceof LocalDateTime) {<br/>            return ((LocalDateTime) dataFetcherResult).format(DateTimeFormatter.ISO_DATE_TIME);<br/>        } else {<br/>            throw new CoercingSerializeException("Not a valid DateTime");<br/>        }<br/>    }</span><span id="97cd" class="lo lp iq lk b gy mt lr l ls lt">    @Override<br/>    public LocalDateTime parseValue(Object input) throws CoercingParseValueException {<br/>        return LocalDateTime.parse(input.toString(), DateTimeFormatter.ISO_DATE_TIME);<br/>    }</span><span id="03be" class="lo lp iq lk b gy mt lr l ls lt">    @Override<br/>    public LocalDateTime parseLiteral(Object input) throws CoercingParseLiteralException {<br/>        if (input instanceof StringValue) {<br/>            return LocalDateTime.parse(((StringValue) input).getValue(), DateTimeFormatter.ISO_DATE_TIME);<br/>        }</span><span id="797a" class="lo lp iq lk b gy mt lr l ls lt">        throw new CoercingParseLiteralException("Value is not a valid ISO date time");<br/>    }<br/>}<br/>//Scalars<br/>public class Scalars {</span><span id="04b6" class="lo lp iq lk b gy mt lr l ls lt">    public static GraphQLScalarType localDateTimeType() {<br/>        return GraphQLScalarType.newScalar()<br/>                .name("LocalDateTime")<br/>                .description("LocalDateTime type")<br/>                .coercing(new LocalDateTimeScalar())<br/>                .build();<br/>    }<br/>}</span><span id="5eb6" class="lo lp iq lk b gy mt lr l ls lt">//register custom scalar type in the MainVertcle buildRuntimeWiring<br/>newRuntimeWiring()<br/>    ...<br/>    .scalar(Scalars.localDateTimeType())</span></pre><p id="50f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Vertx GraphQL提供了一个<code class="fe mq mr ms lk b">UploadScalar</code>用于上传文件。查看源代码并亲自探索<code class="fe mq mr ms lk b">UUIDScalar</code>实现。</p><p id="f5ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似地，在<code class="fe mq mr ms lk b">buildRuntimeWiring</code>中注册一个自定义<em class="lf">指令</em>，例如<code class="fe mq mr ms lk b">@uppercase</code>指令。</p><pre class="kn ko kp kq gt lj lk ll lm aw ln bi"><span id="003a" class="lo lp iq lk b gy lq lr l ls lt">//UpperCaseDirectiveWiring<br/>public class UpperCaseDirectiveWiring implements SchemaDirectiveWiring {<br/>    @Override<br/>    public GraphQLFieldDefinition onField(SchemaDirectiveWiringEnvironment&lt;GraphQLFieldDefinition&gt; env) {</span><span id="382c" class="lo lp iq lk b gy mt lr l ls lt">        var field = env.getElement();<br/>        var parentType = env.getFieldsContainer();</span><span id="2817" class="lo lp iq lk b gy mt lr l ls lt">        var originalDataFetcher = env.getCodeRegistry().getDataFetcher(parentType, field);<br/>        var dataFetcher = DataFetcherFactories.wrapDataFetcher(originalDataFetcher,<br/>                (dataFetchingEnvironment, value) -&gt; {<br/>                    if (value instanceof String s) {<br/>                        return s.toUpperCase();<br/>                    }<br/>                    return value;<br/>                }<br/>        );</span><span id="b8d5" class="lo lp iq lk b gy mt lr l ls lt">        env.getCodeRegistry().dataFetcher(parentType, field, dataFetcher);<br/>        return field;<br/>    }<br/>}<br/>//register custom scalar directive in the MainVertcle buildRuntimeWiring<br/>newRuntimeWiring()<br/>    ...<br/>    .directive("uppercase", new UpperCaseDirectiveWiring())</span></pre><p id="17b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们继续讨论负责在运行时解析类型值的数据获取器。</p><p id="c342" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，在GraphiQL UI页面中，尝试发送一个像这样的预定义查询。</p><pre class="kn ko kp kq gt lj lk ll lm aw ln bi"><span id="1f8c" class="lo lp iq lk b gy lq lr l ls lt">query {<br/>    allPosts{<br/>        id<br/>        title<br/>        content<br/>        author{ name }<br/>        comments{ content }<br/>    }<br/>}</span></pre><p id="8d6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也就是说，它将执行一个<code class="fe mq mr ms lk b">allPosts</code> <em class="lf">查询</em>，并返回一个Post数组，每一项包括字段<code class="fe mq mr ms lk b">id</code>、<code class="fe mq mr ms lk b">title</code>和<code class="fe mq mr ms lk b">content</code>以及一个带有精确<code class="fe mq mr ms lk b">name</code>字段的<code class="fe mq mr ms lk b">author</code>对象，一个<code class="fe mq mr ms lk b">comments</code>数组每一项包括一个单独的<code class="fe mq mr ms lk b">content</code>字段。</p><p id="6a23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当GraphQL请求被发送时，<code class="fe mq mr ms lk b">GraphQLHandler</code>将处理它。</p><ul class=""><li id="b222" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated">验证GraphQL请求，并确保它遵循模式类型定义。</li><li id="305f" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">通过类型坐标、<em class="lf">查询</em>和<em class="lf">all post</em>定位数据获取器。</li><li id="46ac" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">根据请求格式组合返回值。</li><li id="a3b9" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">当解析<code class="fe mq mr ms lk b">author</code>字段时，它将尝试定位<em class="lf"> Post </em>和<em class="lf"> author </em>以找到现有的数据获取器(<code class="fe mq mr ms lk b">dataFetchers.authorOfPost()</code>)来处理它。类似地，它通过<code class="fe mq mr ms lk b">dataFetchers.commentsOfPost()</code>处理<em class="lf">注释</em>。</li><li id="2b6d" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">其他通用字段，使用默认数据提取器直接返回本帖对应字段的值。</li></ul><p id="1749" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mq mr ms lk b">Mutation</code>处理与<code class="fe mq mr ms lk b">Query</code>类似，但它是为执行某些突变而设计的。例如，使用变异<code class="fe mq mr ms lk b">createPost</code>创建一个新的post，它接受一个<code class="fe mq mr ms lk b">CreatePostInput</code>输入参数，然后委托给<code class="fe mq mr ms lk b">dataFecthers.createPost</code>来处理它。</p><p id="54ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">文件上传由<a class="ae kl" href="https://github.com/jaydenseric/graphql-multipart-request-spec" rel="noopener ugc nofollow" target="_blank"> GraphQL多部分请求规范</a>定义，不是标准GraphQL规范的一部分。</p><p id="5591" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是处理文件上传的数据获取器。</p><pre class="kn ko kp kq gt lj lk ll lm aw ln bi"><span id="c4bc" class="lo lp iq lk b gy lq lr l ls lt">public DataFetcher&lt;Boolean&gt; upload() {<br/>    return (DataFetchingEnvironment dfe) -&gt; {</span><span id="1daf" class="lo lp iq lk b gy mt lr l ls lt">        FileUpload upload = dfe.getArgument("file");<br/>        log.info("name: {}", upload.name());<br/>        log.info("file name: {}", upload.fileName());<br/>        log.info("uploaded file name: {}", upload.uploadedFileName());<br/>        log.info("content type: {}", upload.contentType());<br/>        log.info("charset: {}", upload.charSet());<br/>        log.info("size: {}", upload.size());<br/>        //            String fileContent = Vertx.vertx().fileSystem().readFileBlocking(upload.uploadedFileName()).toString();<br/>        //            log.info("file content: {}", fileContent);<br/>        return true;<br/>    };<br/>}</span></pre><p id="9cbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Vertx为上传的文件创建一个临时文件，很容易从本地文件系统读取文件。</p><p id="ea59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于<code class="fe mq mr ms lk b">Subscription</code>，用于跟踪来自后端的更新，如股票交易消息、通知等。GraphQL Java要求它必须返回react vestreams<code class="fe mq mr ms lk b">Publisher</code>类型。</p><p id="84b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是添加注释时发送通知的示例。</p><pre class="kn ko kp kq gt lj lk ll lm aw ln bi"><span id="8bd8" class="lo lp iq lk b gy lq lr l ls lt">public VertxDataFetcher&lt;UUID&gt; addComment() {<br/>    return VertxDataFetcher.create((DataFetchingEnvironment dfe) -&gt; {<br/>        var commentInputArg = dfe.getArgument("commentInput");<br/>        var jacksonMapper = DatabindCodec.mapper();<br/>        var input = jacksonMapper.convertValue(commentInputArg, CommentInput.class);<br/>        return this.posts.addComment(input)<br/>            .onSuccess(id -&gt; this.posts.getCommentById(id.toString())<br/>                       .onSuccess(c -&gt; subject.onNext(c)));<br/>    });<br/>}</span><span id="2b95" class="lo lp iq lk b gy mt lr l ls lt">private ReplaySubject&lt;Comment&gt; subject = ReplaySubject.create(1);</span><span id="d65d" class="lo lp iq lk b gy mt lr l ls lt">public DataFetcher&lt;Publisher&lt;Comment&gt;&gt; commentAdded() {<br/>    return (DataFetchingEnvironment dfe) -&gt; {<br/>        ApolloWSMessage message = dfe.getContext();<br/>        log.info("msg: {}, connectionParams: {}", message.content(), message.connectionParams());<br/>        ConnectableObservable&lt;Comment&gt; connectableObservable = subject.share().publish();<br/>        connectableObservable.connect();<br/>        log.info("connect to `commentAdded`");<br/>        return connectableObservable.toFlowable(BackpressureStrategy.BUFFER);<br/>    };<br/>}</span></pre><p id="4883" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的例子使用RxJava 3的<code class="fe mq mr ms lk b">ReplaySubject</code>作为处理器向连接的客户端发送消息。我们已经在<code class="fe mq mr ms lk b">MainVerticle</code>中配置了使用WebSocket协议来处理订阅。在下一篇文章中，我们将创建一个WebSocket客户端来使用这个消息端点。</p><p id="ef0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们跳过其他类似于前Quarkus GraphQL帖子的代码，查看来自我的Github 的<a class="ae kl" href="https://github.com/hantsy/vertx-sandbox/tree/master/graphql" rel="noopener ugc nofollow" target="_blank">完整示例代码，自己探索一下。</a></p><p id="2e08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与Quarkus不同，Eclipse Vertx不提供特定的GraphQL客户端来简化Java中的GraphQL请求。</p><p id="6535" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要为GraphQL APIs编写测试，您必须切换到使用通用Vertx Http客户端。而且你必须很好地了解HTTP规范上的T2 graph QL。</p><p id="dd76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个使用Vertx HttpClient测试<em class="lf"> allPosts </em>查询和<em class="lf"> createPost </em>变异的例子。</p><pre class="kn ko kp kq gt lj lk ll lm aw ln bi"><span id="bbb2" class="lo lp iq lk b gy lq lr l ls lt">@ExtendWith(VertxExtension.class)<br/>@Slf4j<br/>public class TestMainVerticle {</span><span id="d018" class="lo lp iq lk b gy mt lr l ls lt">    HttpClient client;</span><span id="8ac5" class="lo lp iq lk b gy mt lr l ls lt">    @BeforeEach<br/>    void setup(Vertx vertx, VertxTestContext testContext) {<br/>        vertx.deployVerticle(new MainVerticle(), testContext.succeeding(id -&gt; testContext.completeNow()));<br/>        var options = new HttpClientOptions()<br/>            .setDefaultHost("localhost")<br/>            .setDefaultPort(8080);<br/>        client = vertx.createHttpClient(options);<br/>    }</span><span id="99d3" class="lo lp iq lk b gy mt lr l ls lt">    @Test<br/>    void getAllPosts(Vertx vertx, VertxTestContext testContext) throws Throwable {<br/>        var query = """<br/>            query {<br/>                allPosts{<br/>                    id<br/>                    title<br/>                    content<br/>                    author{ name }<br/>                    comments{ content }<br/>                }<br/>            }""";<br/>        client.request(HttpMethod.POST, "/graphql")<br/>            .flatMap(req -&gt; req.putHeader("Content-Type", "application/json")<br/>                .putHeader("Accept", "application/json")<br/>                .send(Json.encode(Map.of("query", query)))//have to use Json.encode to convert objects to json string.<br/>                .flatMap(HttpClientResponse::body)<br/>            )<br/>            .onComplete(<br/>                testContext.succeeding(<br/>                    buffer -&gt; testContext.verify(<br/>                        () -&gt; {<br/>                            log.info("buf: {}", buffer.toString());<br/>                            JsonArray array = buffer.toJsonObject()<br/>                                .getJsonObject("data")<br/>                                .getJsonArray("allPosts");<br/>                            assertThat(array.size()).isGreaterThan(0);</span><span id="5b32" class="lo lp iq lk b gy mt lr l ls lt">                            var titles = array.getList().stream().map(o -&gt; ((Map&lt;String, Object&gt;) o).get("title")).toList();<br/>                            assertThat(titles).allMatch(s -&gt; ((String) s).startsWith("DGS POST"));<br/>                            testContext.completeNow();<br/>                        }<br/>                    )<br/>                )<br/>            );<br/>    }</span><span id="25b1" class="lo lp iq lk b gy mt lr l ls lt">    @Test<br/>    void createPost(Vertx vertx, VertxTestContext testContext) throws Throwable {<br/>        String TITLE = "My post created by Vertx HttpClient";<br/>        //var creatPostQuery = "mutation newPost($input:CreatePostInput!){ createPost(createPostInput:$input)}";<br/>        var creatPostQuery = """<br/>            mutation newPost($input:CreatePostInput!){<br/>                createPost(createPostInput:$input)<br/>            }""";<br/>        client.request(HttpMethod.POST, "/graphql")<br/>            .flatMap(req -&gt; {<br/>                    String encodedJson = Json.encode(Map.of(<br/>                        "query", creatPostQuery,<br/>                        "variables", Map.of(<br/>                            "input", Map.of(<br/>                                "title", TITLE,<br/>                                "content", "content of my post"<br/>                            )<br/>                        )<br/>                    ));<br/>                    log.info("sending encoded json: {}", encodedJson);<br/>                    return req.putHeader("Content-Type", "application/json")<br/>                        .putHeader("Accept", "application/json")<br/>                        .send(encodedJson)//have to use Json.encode to convert objects to json string.<br/>                        .flatMap(HttpClientResponse::body);<br/>                }<br/>            )<br/>            .flatMap(buf -&gt; {<br/>                Object id = buf.toJsonObject().getJsonObject("data").getValue("createPost");</span><span id="c281" class="lo lp iq lk b gy mt lr l ls lt">                log.info("created post: {}", id);<br/>                assertThat(id).isNotNull();</span><span id="692f" class="lo lp iq lk b gy mt lr l ls lt">                var postById = """<br/>                    query post($id:String!) {<br/>                        postById(postId:$id){id title content}<br/>                    }""";</span><span id="8590" class="lo lp iq lk b gy mt lr l ls lt">                return client.request(HttpMethod.POST, "/graphql")<br/>                    .flatMap(req -&gt; req.putHeader("Content-Type", "application/json")<br/>                        .putHeader("Accept", "application/json")<br/>                        .send(Json.encode(Map.of(<br/>                            "query", postById,<br/>                            "variables", Map.of("id", id.toString())<br/>                        )))//have to use Json.encode to convert objects to json string.<br/>                        .flatMap(HttpClientResponse::body)<br/>                    );<br/>            })<br/>            .onComplete(<br/>                testContext.succeeding(<br/>                    buffer -&gt; testContext.verify(<br/>                        () -&gt; {<br/>                            log.info("buf: {}", buffer.toString());<br/>                            String title = buffer.toJsonObject()<br/>                                .getJsonObject("data")<br/>                                .getJsonObject("postById")<br/>                                .getString("title");<br/>                            assertThat(title).isEqualTo(TITLE.toUpperCase());<br/>                            testContext.completeNow();<br/>                        }<br/>                    )<br/>                )<br/>            );<br/>    }<br/>}</span></pre><p id="2073" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从我的Github 中获取<a class="ae kl" href="https://github.com/hantsy/vertx-sandbox/tree/master/graphql" rel="noopener ugc nofollow" target="_blank">示例代码。</a></p></div></div>    
</body>
</html>