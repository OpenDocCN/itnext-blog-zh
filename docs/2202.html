<html>
<head>
<title>How (and why) to cook equals() and hashCode() in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何(以及为什么)在Java中编写equals()和hashCode()</h1>
<blockquote>原文：<a href="https://itnext.io/how-and-why-to-cook-equals-and-hashcode-in-java-c108fd5b17dd?source=collection_archive---------0-----------------------#2019-04-16">https://itnext.io/how-and-why-to-cook-equals-and-hashcode-in-java-c108fd5b17dd?source=collection_archive---------0-----------------------#2019-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/93d650d5606755adf38917637fc5a820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lmreLNduUQZgdCgp"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">拉奎尔·马丁内斯在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="c9d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你好。</p><p id="35c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天我要讲的是我最喜欢的一个面试问题:<code class="fe le lf lg lh b">equals()</code>和<code class="fe le lf lg lh b">hashCode()</code>Java中的方法。</p><p id="104e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我为什么喜欢这个问题？嗯，我发现这两种方法在开发过程中非常重要，所以如果这个人对它们一无所知，就会在应用程序中引起很多问题，比如散列数据结构中的数据丢失、错误的等式处理结果等。</p><p id="edbe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么，让我们继续探索这两种方法。</p><p id="7148" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能知道，Java中有一个类<code class="fe le lf lg lh b">Object</code>，它是其他类的父类。这意味着，如果我们以这样的方式创建一个新的类<code class="fe le lf lg lh b">Person</code>:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="0108" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它将隐式扩展<code class="fe le lf lg lh b">Object</code>类。这就是为什么，即使我们的<code class="fe le lf lg lh b">Person</code>类看起来是空的，它也有几个继承自<code class="fe le lf lg lh b">Object</code>类的可用方法:</p><ul class=""><li id="f6ca" class="lo lp it ki b kj kk kn ko kr lq kv lr kz ls ld lt lu lv lw bi translated"><code class="fe le lf lg lh b">equals()</code></li><li id="1e1b" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld lt lu lv lw bi translated"><code class="fe le lf lg lh b">hashCode()</code></li><li id="019a" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld lt lu lv lw bi translated"><code class="fe le lf lg lh b">toString()</code></li><li id="0bcf" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld lt lu lv lw bi translated"><code class="fe le lf lg lh b">getClass()</code></li><li id="80f3" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld lt lu lv lw bi translated"><code class="fe le lf lg lh b">notify()</code></li><li id="eed8" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld lt lu lv lw bi translated"><code class="fe le lf lg lh b">notifyAll()</code></li><li id="16c7" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld lt lu lv lw bi translated"><code class="fe le lf lg lh b">wait()</code></li></ul><p id="0c4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于其余的方法已经超出了本文的范围，让我们把重点放在<code class="fe le lf lg lh b">equals()</code>和<code class="fe le lf lg lh b">hashCode()</code>上。</p><h1 id="eb3a" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated"><code class="fe le lf lg lh b">equals()</code></h1><p id="1111" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated"><code class="fe le lf lg lh b">equals(Object o)</code>方法用于指示某个其他对象<code class="fe le lf lg lh b">o</code>是否等于当前对象(该方法已在该对象上被调用)。</p><p id="d156" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解释看起来非常清楚，但是可能会出现一个问题:“等等，如果我们有<code class="fe le lf lg lh b">==</code>操作符，为什么我们需要这个方法？”。<br/>嗯，这是个好问题！正如我的朋友所说:“如果一些看似简单的东西没有复杂性，那就不是Java了”。</p><p id="5dbf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于像<code class="fe le lf lg lh b">int</code>、<code class="fe le lf lg lh b">long</code>、<code class="fe le lf lg lh b">boolean</code>等原始数据类型，操作符可以很好地工作(在这种情况下应该使用)。但是对于非原始(或引用)数据类型<code class="fe le lf lg lh b">==</code>操作符显示的不是对象的相等性，而是它们是否引用内存中的同一个对象。由于Java内存模型(JMM)，它以这样的方式工作:原语和引用对象保存在不同的内存部分(在这篇文章中，我们不打算深入JMM，所以现在让我们认为这是理所当然的，但是如果您希望我写一篇关于JMM的文章，请给我留下评论)。</p><p id="8381" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我用代码演示一下。让我们稍微扩展一下Person类，使它不为空。</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="83a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们运行这段代码，我们将得到以下输出:</p><pre class="li lj lk ll gt nf lh ng nh aw ni bi"><span id="c352" class="nj md it lh b gy nk nl l nm nn">false</span></pre><p id="0163" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果用<code class="fe le lf lg lh b">equals()</code>方法来比较这两个<code class="fe le lf lg lh b">Person</code>实例而不是<code class="fe le lf lg lh b">==</code>运算符，会是什么情况呢？</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="8a0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它会返回<code class="fe le lf lg lh b">true</code>吗？不，输出又是<code class="fe le lf lg lh b">false</code>。怎么会呢？！答案很简单:现在我们正在使用<code class="fe le lf lg lh b">equals()</code>方法的<code class="fe le lf lg lh b">Object</code>类实现，所以让我们看看它看起来像什么:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="97e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们看到的，它调用了幕后的==操作符，所以错误的输出现在看起来更清楚了。</p><p id="9546" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，这个实现不能满足我们的需求，所以我们可以覆盖它。</p><p id="a344" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是首先让我们稍微推迟一下重写过程，来学习几个equals()方法规则，它们将在我们的实现中帮助我们:</p><ol class=""><li id="05c8" class="lo lp it ki b kj kk kn ko kr lq kv lr kz ls ld no lu lv lw bi translated"><strong class="ki iu">反身</strong> : <code class="fe le lf lg lh b">a.equals(a)</code>必须始终返回<code class="fe le lf lg lh b">true</code>(当然如果<code class="fe le lf lg lh b">a != null</code>，否则<code class="fe le lf lg lh b">NullPointerException</code>会被抛出)；</li><li id="eae5" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated"><strong class="ki iu">对称</strong>:如果<code class="fe le lf lg lh b">a.equals(b)</code>返回<code class="fe le lf lg lh b">true</code>，那么<code class="fe le lf lg lh b">b.equals(a)</code>也必须总是返回<code class="fe le lf lg lh b">true</code>(反之亦然)；</li><li id="5f22" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated"><strong class="ki iu">传递</strong>:如果<code class="fe le lf lg lh b">a.equals(b)</code>返回<code class="fe le lf lg lh b">true</code>，<code class="fe le lf lg lh b">a.equals(c)</code>返回<code class="fe le lf lg lh b">true</code>，则意味着<code class="fe le lf lg lh b">b.equals(c)</code>也必须是<code class="fe le lf lg lh b">true</code>；</li><li id="bcfb" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated"><strong class="ki iu">一致</strong>:如果<code class="fe le lf lg lh b">a.equals(b)</code>返回<code class="fe le lf lg lh b">true</code>(或<code class="fe le lf lg lh b">false</code>)，并且<code class="fe le lf lg lh b">a</code>和<code class="fe le lf lg lh b">b</code>都没有改变，<code class="fe le lf lg lh b">a.equals(b)</code>应该总是返回相同的结果。</li></ol><p id="3c9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些规则简单而直观，但无论如何，遵循它们以忽略应用程序中可能出现的问题是极其重要的。</p><p id="7d3f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回到我们的<code class="fe le lf lg lh b">Person</code>对比问题:<br/>我提议先不要急，先看一下方法签名来思考，如何正确的重写。您可能已经注意到，<code class="fe le lf lg lh b">equals()</code>方法接受<code class="fe le lf lg lh b">Object o</code>作为参数，所以不可能编写这样的代码:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="20e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于<code class="fe le lf lg lh b">Object</code>类对name属性一无所知—编译错误。此外，如果<code class="fe le lf lg lh b">name == null</code>或<code class="fe le lf lg lh b">o == null</code>，该代码可能会抛出<code class="fe le lf lg lh b">NullPointerException</code>。是的，我们可以这样写:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="8f45" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但这不是超越，而是超载。<br/>有很多库和API在幕后使用<code class="fe le lf lg lh b">equals()</code>方法，所以，正如你可能已经理解的，它们对我们的<code class="fe le lf lg lh b">equals()</code>方法的重载版本一无所知，但是会从<code class="fe le lf lg lh b">Object</code>类调用那个方法，我们的比较问题又会出现。这意味着重载对于我们的情况来说不是一个合适的解决方案。</p><p id="842f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们通过一步一步来关注重写过程:<br/>正如我们之前看到的，<code class="fe le lf lg lh b">Object</code>类<code class="fe le lf lg lh b">equals()</code>实现使用<code class="fe le lf lg lh b">==</code>操作符来比较对象。听起来合乎逻辑:如果两个对象在内存中指向同一个对象，那么它们肯定是相等的。这是一个很好的切入点:</p><h2 id="8419" class="nj md it bd me np nq dn mi nr ns dp mm kr nt nu mq kv nv nw mu kz nx ny my nz bi translated">1.使用<code class="fe le lf lg lh b">==</code>运算符比较对象。</h2><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="f97f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很好。让我们继续:我们上面提到过，如果<code class="fe le lf lg lh b">Object o</code>等于<code class="fe le lf lg lh b">null</code>，我们可以面对<code class="fe le lf lg lh b">NullPointerException</code>。此外，我们确实知道，我们当前的对象(<code class="fe le lf lg lh b">Person</code>实例，我们将在其上调用<code class="fe le lf lg lh b">equals()</code>方法)肯定不是<code class="fe le lf lg lh b">null</code>，否则<code class="fe le lf lg lh b">NullPoinerException</code>将在<code class="fe le lf lg lh b">null</code> <code class="fe le lf lg lh b">Person</code>实例的方法调用中抛出，但这不是我们现在要做的事情。它伴随着另一个步骤:</p><h2 id="b2ac" class="nj md it bd me np nq dn mi nr ns dp mm kr nt nu mq kv nv nw mu kz nx ny my nz bi translated">2.检查对象o参数是否不为空。如果是，则返回false。</h2><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="fbb6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看起来更好，但还不够。我们之前提到过，还剩下一个难点:<code class="fe le lf lg lh b">o</code>是<code class="fe le lf lg lh b">Object</code>类型，所以无法从中得出<code class="fe le lf lg lh b">Person</code>数据。当然，我们可以把它投射到<code class="fe le lf lg lh b">Person</code>上，看起来我们已经准备好了。但是，不幸的是，它并不安全。看一下代码:</p><ul class=""><li id="1a13" class="lo lp it ki b kj kk kn ko kr lq kv lr kz ls ld lt lu lv lw bi translated">想象一下，我们已经将cast语句添加到我们的<code class="fe le lf lg lh b">equals()</code>实现中:</li></ul><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><ul class=""><li id="b748" class="lo lp it ki b kj kk kn ko kr lq kv lr kz ls ld lt lu lv lw bi translated">我来介绍一下新的班级<code class="fe le lf lg lh b">Dog</code>:</li></ul><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><ul class=""><li id="418d" class="lo lp it ki b kj kk kn ko kr lq kv lr kz ls ld lt lu lv lw bi translated">并向您展示，如何破解我们的<code class="fe le lf lg lh b">equals()</code>实现:</li></ul><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="cf40" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有编译错误，因为even is <code class="fe le lf lg lh b">dog</code>是<code class="fe le lf lg lh b">Dog</code>类型，但它也是<code class="fe le lf lg lh b">Object</code>类型(记住，我已经告诉过你，<code class="fe le lf lg lh b">Object</code>是每个类的父类)，所以它被允许在我们的方法中传递<code class="fe le lf lg lh b">dog</code>。但是如果我们运行这段代码，我们会有一个异常:</p><pre class="li lj lk ll gt nf lh ng nh aw ni bi"><span id="1ad5" class="nj md it lh b gy nk nl l nm nn">Exception in thread "main" java.lang.ClassCastException: Dog cannot be cast to Person</span></pre><p id="a7dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是的，听起来很有逻辑:我们怎么能把一只狗丢给一个人(或者把史酷比丢给荷马·辛普森)？是的，我知道，在<a class="ae kf" href="https://en.wikipedia.org/wiki/Heart_of_a_Dog" rel="noopener ugc nofollow" target="_blank">文学</a>中是这样的故事，但是我们是工程师，我们遵循逻辑。这个异常给了我们一个很好的提示，我们可以用它来进行下一步:</p><h2 id="c15c" class="nj md it bd me np nq dn mi nr ns dp mm kr nt nu mq kv nv nw mu kz nx ny my nz bi translated">3.检查对象o参数是否和我们的实例有相同的类型。如果没有，返回false。</h2><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="a289" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们使用了来自<code class="fe le lf lg lh b">Object</code>类的<code class="fe le lf lg lh b">getClass()</code>方法。这个方法只返回调用它的对象的<code class="fe le lf lg lh b">Class</code>。因此，对于<code class="fe le lf lg lh b">dog.getClass();</code>，它返回<code class="fe le lf lg lh b">Dog</code>，对于<code class="fe le lf lg lh b">person.getClass(); </code> — <code class="fe le lf lg lh b"> Person</code>，以此类推。</p><p id="aa8e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们可以继续下一步生产:</p><h2 id="a5b9" class="nj md it bd me np nq dn mi nr ns dp mm kr nt nu mq kv nv nw mu kz nx ny my nz bi translated">4.将对象o强制转换为当前的类类型。</h2><h2 id="9d21" class="nj md it bd me np nq dn mi nr ns dp mm kr nt nu mq kv nv nw mu kz nx ny my nz bi translated">5.比较所选字段的值。</h2><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="361b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在这里使用了<code class="fe le lf lg lh b">Objects.equals()</code>方法来简化逻辑并省略this.name空检查，因为它已经在<code class="fe le lf lg lh b">Objects</code>类的used方法中实现:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="3a91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="oa"> Offtop </em> </strong>:我确实推荐你去了解这个util类，因为它包含了几个有用的方法。</p><p id="0a5c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们试着检查一下，它是否工作正常:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="5a88" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出最终是可预测的:</p><pre class="li lj lk ll gt nf lh ng nh aw ni bi"><span id="8fe5" class="nj md it lh b gy nk nl l nm nn">person1.equals(person2) is true<br/>person1.equals(dog) is false</span></pre><p id="5101" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们甚至可以检查我们实现的所有4个<code class="fe le lf lg lh b">equals()</code>方法规则:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="c007" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出:</p><pre class="li lj lk ll gt nf lh ng nh aw ni bi"><span id="2ca8" class="nj md it lh b gy nk nl l nm nn">1. Reflexive: a.equals(a) must always return true:<br/>person1.equals(person1) is true</span><span id="3e2a" class="nj md it lh b gy ob nl l nm nn">2. Symmetric: if a.equals(b) returns true, then b.equals(a) must always return true:<br/>person1.equals(person2) is true<br/>person2.equals(person1) is true</span><span id="9a37" class="nj md it lh b gy ob nl l nm nn">3. Transitive: if a.equals(b) returns true and a.equals(c) returns true, it means, that b.equals(c) must be true:<br/>person1.equals(person2) is true<br/>person1.equals(person3) is true<br/>person2.equals(person3) is true</span><span id="1b33" class="nj md it lh b gy ob nl l nm nn">4. Consistent: if a.equals(b) returns true (or false) and neither a nor b has been changed, a.equals(b) should always return the same result:<br/>person1.equals(person2) is true<br/>person1.equals(person2) is true<br/>person1.equals(person2) is true<br/>person1.equals(person2) is true</span></pre><p id="861c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看起来棒极了！</p><p id="ba99" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的<code class="fe le lf lg lh b">equals()</code>实现完成了吗？是的。但是还有一件事让我不太满意:现在我们用名字来比较两个人。但是让我们想象一下，我们正在构建一个应用程序，它将被大量的人使用。例如，让它成为一家银行。我很确定，当几个不同的人有相同的名字时，会有成百上千种情况。例如，可能是来自斯普林菲尔德的荷马·辛普森一家和来自南方公园城的另一个荷马·辛普森一家。如果第一个人使用我们的应用程序，我们的银行会认为这两个家伙是同一个人，所以会引起一些问题:只有其中一个人能够在我们的应用程序中注册，或者他们中的任何一个人都可以访问彼此的数据，等等。这样不好！</p><p id="3e4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想说的是，我们的<code class="fe le lf lg lh b">Person</code>类需要更新以包含一些数据，这对于具体的person实例来说是唯一的。我建议不要重新发明自行车，而使用通常的做法——身份证号码。现在我们的<code class="fe le lf lg lh b">Person</code>类是这样的:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="3a9f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，如果我们知道<code class="fe le lf lg lh b">idNumber</code>对每个人来说总是唯一的，我们可以改变我们的<code class="fe le lf lg lh b">equals()</code>实现，使其使用<code class="fe le lf lg lh b">idNumber</code>而不是<code class="fe le lf lg lh b">name</code>。是的，它可以使用这两个字段，但是由于<code class="fe le lf lg lh b">idNumber</code>的独特保证，它是多余的:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="5a4c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，如果我们测试这个:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="6d95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出如下所示:</p><pre class="li lj lk ll gt nf lh ng nh aw ni bi"><span id="f16a" class="nj md it lh b gy nk nl l nm nn">person1.equals(person2) is true<br/>person1.equals(person3) is false<br/>person1.equals(dog) is false</span></pre><p id="19dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完美！教训是:我们，工程师，应该以这样一种方式设计我们的数据类，它们包含唯一的字段或字段序列，以使比较尽可能严格。</p><p id="2191" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后但同样重要的是，equals方法的重要之处在于，如果我们的类包含一些复杂类型的字段(例如，<code class="fe le lf lg lh b">Person</code>类中的字段<code class="fe le lf lg lh b">private Address address;</code>),并且我们决定将其值包含到<code class="fe le lf lg lh b">equals()</code>方法中:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="408b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该检查<code class="fe le lf lg lh b">equals()</code>是否已经为<code class="fe le lf lg lh b">Address</code>类正确实现，因为它将在幕后被调用，并可能导致意想不到的结果。这就是为什么好的实践是为每个数据对象覆盖<code class="fe le lf lg lh b">equals()</code>和<code class="fe le lf lg lh b">hashCode()</code>(我们很快会谈到这一点)方法。</p><p id="edd9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是的，我知道，实现过程看起来有点庞大，但现在，当我们成功地手动完成并完全理解流程后，让我与您分享这个秘密:我非常确定，您将在一些IDE (IntelliJ IDEA (my #1)、Eclipse、NetBeans、VSCode等)中编写代码，而不是在记事本文本编辑器中。).所有的ide都可以让你通过几次点击(或者快捷方式)来生成equals方法。查看您最喜欢的IDE的文档，找到合适的方法(IntelliJ思想的例子)。</p><p id="2636" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，这是针对<code class="fe le lf lg lh b">equals()</code>方法的，但是我们稍后会回到它。接下来说<code class="fe le lf lg lh b">hashCode()</code>。</p><h1 id="7c86" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">哈希码()</h1><p id="d196" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated"><code class="fe le lf lg lh b">hashCode()</code>方法返回对象的哈希码值。目前，哈希代码是一些int值。仅此而已。<br/> <br/>让我们试着看看它是如何工作的，让它更清晰。为此，我建议使用我们著名的<code class="fe le lf lg lh b">Person</code>类:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="4610" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我的电脑上的输出是<code class="fe le lf lg lh b">250421012</code>。如果你跟着我自己输入代码，我很确定，你的输出和我的不同。怎么可能呢？</p><p id="2432" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要回答这个问题，我们需要记住，我们还没有覆盖<code class="fe le lf lg lh b">hashCode()</code>方法，所以我们现在使用的是<code class="fe le lf lg lh b">Object</code>实现。如果我们转到<code class="fe le lf lg lh b">Object</code>类，我们将看到以下内容:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="5e23" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Java中的关键字<code class="fe le lf lg lh b">native</code>与方法一起使用，表示该方法是在其他语言中实现的(例如，C或C++)。使用<a class="ae kf" href="https://en.wikipedia.org/wiki/Java_Native_Interface" rel="noopener ugc nofollow" target="_blank"> JNI </a>可以调用这样的方法。这种方法用于性能原因或访问系统或硬件资源，使用Java是不可能的。<br/>在该方法的Javadocs中，提到了<code class="fe le lf lg lh b">Object</code> <code class="fe le lf lg lh b">hashCode()</code>是通过将对象的内部地址转换成整数来实现的。这就是为什么我们在不同的虚拟机上有不同的结果。</p><p id="5e5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们通过重写该方法来使其行为可预测:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="27d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如你所料，输出是<code class="fe le lf lg lh b">42</code>。完事了吗？不，这只是我们hashCode故事的开始。</p><p id="673d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">顺便说一句，也许你们中的一些人有一个问题:“为什么我们在一篇文章的范围内谈论<code class="fe le lf lg lh b">equals()</code>和<code class="fe le lf lg lh b">hashCode()</code>？这些方法看起来不相关！”。几年前，我面临同样的问题。让我向你展示几个<code class="fe le lf lg lh b">hashCode()</code>方法规则，我希望你能自己找到答案:</p><ol class=""><li id="3f5c" class="lo lp it ki b kj kk kn ko kr lq kv lr kz ls ld no lu lv lw bi translated">对没有改变的同一个对象每次调用<code class="fe le lf lg lh b">hashCode()</code>方法都必须产生相同的结果。</li><li id="f0d9" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated">如果两个对象通过<code class="fe le lf lg lh b">equals()</code>方法相等，那么在这两个对象上调用<code class="fe le lf lg lh b">hashCode()</code>方法必须产生相同的结果:</li></ol><pre class="li lj lk ll gt nf lh ng nh aw ni bi"><span id="95b5" class="nj md it lh b gy nk nl l nm nn">// if:<br/>a.equals(b) is true<br/>// then:<br/>a.hashCode() == b.hashCode()</span></pre><p id="01d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">3.但是如果在2个对象上调用<code class="fe le lf lg lh b">hashCode()</code>方法产生相同的结果，并不意味着它们相等(通过<code class="fe le lf lg lh b">equals()</code>方法)。</p><p id="69da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">怎么可能呢？简单！正如我们所知，<code class="fe le lf lg lh b">int</code>类型具有有限的值范围:从-2 147 483 648到+2 147 483 647 —因此，大约有40亿个唯一值。让我们想象一下，我们正在构建一个应用程序，它保存着世界上每个人的数据。维基百科称，截至2018年5月，世界人口为76亿。如果我们开始为世界上的每个人逐个调用<code class="fe le lf lg lh b">hashCode()</code>方法，有可能，前40亿个将产生一个唯一的结果，但每个下一个调用将产生一个整数值，这是以前产生的，因为每个int现在都被使用。因此，这可能是一种情况，例如，当来自美国的某个男孩和来自澳大利亚的女孩有相同的hashCode值，但是我们知道，他们不是同一个人。</p><p id="d13d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，正如你已经注意到的，第二条和第三条规则表明<code class="fe le lf lg lh b">equals()</code>和<code class="fe le lf lg lh b">hashCode()</code>是相连的。如果在面试中你会被问到<code class="fe le lf lg lh b">equals() </code>和<code class="fe le lf lg lh b">hashCode()</code>之间的合同，你需要这两条规则。</p><p id="f6d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果现在一切都清楚了，我建议回到我们的<code class="fe le lf lg lh b">Person</code>类，并尝试以正确的方式实现<code class="fe le lf lg lh b">hashCode()</code>方法。但是，打住，我们为什么需要这个？看起来，我们当前的方法实现符合这3条规则。是的，它是。<br/>这些规则是清楚的，但是它们没有解释，为什么我们需要这个<code class="fe le lf lg lh b">hashCode()</code>方法。对于<code class="fe le lf lg lh b">equals()</code>方法，这个问题没有出现，因为它是直接的，该方法应该用于比较目的。</p><p id="da51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你听说过散列集合吗？这样的集合散列它们的每个元素以提供对它们的快速访问(大多数情况下是<a class="ae kf" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank"> O(1) </a>)。最流行的Java散列集合是<code class="fe le lf lg lh b">HashMap</code>。它用于保存“键-值”对。例如，如果你必须收集关于公寓住户的数据，你可以这样做:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="0a41" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在如果你需要得到3号公寓的住户，你需要做:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="8056" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出为<code class="fe le lf lg lh b">Rick Sanchez</code>。</p><p id="f50c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为什么我在当前文章的范围内谈论<code class="fe le lf lg lh b">HashMap</code>？该集合使用<code class="fe le lf lg lh b">hashCode()</code>和<code class="fe le lf lg lh b">equals()</code>方法进行<code class="fe le lf lg lh b">put()</code>和<code class="fe le lf lg lh b">get()</code>操作。</p><p id="dea0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"/></p><p id="3e35" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">HashMap</code>包含几个桶(达到大小时，数量会改变)，可以用来存储键值元素(这样的一对称为<code class="fe le lf lg lh b">Entry</code>)。该桶可以包含零个、一个或几个元素。如果有几个元素，这被称为碰撞，元素被存储在桶内的一个<code class="fe le lf lg lh b">LinkedList</code>(这只是部分正确，但是，我们现在关注的是这个概念)。</p><p id="4ed0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，当调用<code class="fe le lf lg lh b">put(Key key, Value value)</code>方法时，会执行以下步骤:</p><ol class=""><li id="4ee6" class="lo lp it ki b kj kk kn ko kr lq kv lr kz ls ld no lu lv lw bi translated">如果<code class="fe le lf lg lh b">key</code>为<code class="fe le lf lg lh b">null</code>，则将键值对(<code class="fe le lf lg lh b">Entry</code>)放入第一个桶；</li><li id="02a9" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated">如果不是<code class="fe le lf lg lh b">null</code>，则在键上调用<code class="fe le lf lg lh b">hashCode()</code>方法；</li><li id="54a7" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated"><code class="fe le lf lg lh b">HashMap</code>获取密钥哈希值，通过内部计算对其进行处理，以获得要使用的存储桶的编号；</li><li id="9198" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated">如果选择的桶是空的，就把<code class="fe le lf lg lh b">Entry</code>放在那里，就这样；</li><li id="0a0e" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated">如果桶不为空，它遍历桶中所有现有的条目，并使用<code class="fe le lf lg lh b">equals()</code>将它们的键与来自<code class="fe le lf lg lh b">put()</code>方法的键进行比较；</li><li id="0d14" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated">如果<code class="fe le lf lg lh b">equals()</code>每次迭代返回<code class="fe le lf lg lh b">false</code>，则<code class="fe le lf lg lh b">Entry</code>将被存储在当前桶中；</li><li id="4347" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated">如果<code class="fe le lf lg lh b">equals()</code>在某些情况下返回<code class="fe le lf lg lh b">true</code>，那么<code class="fe le lf lg lh b">Entry</code>具有与来自<code class="fe le lf lg lh b">put()</code>方法相同的键，这个<code class="fe le lf lg lh b">Entry</code>值将被新值替换(来自<code class="fe le lf lg lh b">put()</code>方法的参数)。游戏结束。</li></ol><p id="d474" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以解决硬编码的<code class="fe le lf lg lh b">hashCode()</code>实现的第一个可能的问题:在第二步中，<code class="fe le lf lg lh b">Person</code>类的每个非空实例将返回<code class="fe le lf lg lh b">42</code>，因此所有这些实例都被放入同一个桶中，因为第三步计算对相同的输入产生相同的输出。我们将面对碰撞。</p><p id="6474" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">碰撞出了什么问题？在解释<code class="fe le lf lg lh b">get(Key key)</code>方法步骤的机制时，让我向您展示:</p><ol class=""><li id="6033" class="lo lp it ki b kj kk kn ko kr lq kv lr kz ls ld no lu lv lw bi translated">如果<code class="fe le lf lg lh b">key</code>是<code class="fe le lf lg lh b">null</code>，我们到第一个桶，寻找带有<code class="fe le lf lg lh b">key == null</code>的<code class="fe le lf lg lh b">Entry</code>，如果存在，返回其<code class="fe le lf lg lh b">value</code>；</li><li id="ce6c" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated">如果<code class="fe le lf lg lh b">key</code>不是<code class="fe le lf lg lh b">null</code>，则在<code class="fe le lf lg lh b">key</code>上调用<code class="fe le lf lg lh b">hashCode()</code>方法；</li><li id="2c34" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated"><code class="fe le lf lg lh b">HashMap</code>获取<code class="fe le lf lg lh b">key</code>散列值，通过内部计算对其进行处理，以获得要使用的桶的编号；</li><li id="df02" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated">我们使用第3步中提供的数字进入存储桶；</li><li id="b272" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated">如果桶是空的—返回<code class="fe le lf lg lh b">null</code>；</li><li id="2b99" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated">如果那个桶只包含一个<code class="fe le lf lg lh b">Entry</code>，我们比较(<code class="fe le lf lg lh b">equals()</code>)那个<code class="fe le lf lg lh b">Entry</code>键和我们的<code class="fe le lf lg lh b">key</code>:如果<code class="fe le lf lg lh b">true </code> —返回<code class="fe le lf lg lh b">Entry</code> <code class="fe le lf lg lh b">value</code>，如果<code class="fe le lf lg lh b">false </code> —返回<code class="fe le lf lg lh b">null</code>；</li><li id="51b0" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated">如果bucket包含几个元素，我们遍历每个元素，并将每个<code class="fe le lf lg lh b">Entry</code>的键与我们的<code class="fe le lf lg lh b">key</code>进行比较(<code class="fe le lf lg lh b">equals()</code>):if<code class="fe le lf lg lh b">true </code>—返回匹配的<code class="fe le lf lg lh b">Entry</code> <code class="fe le lf lg lh b">value</code>，if <code class="fe le lf lg lh b">false</code> for each —返回<code class="fe le lf lg lh b">null</code>。</li></ol><p id="de94" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的硬编码<code class="fe le lf lg lh b">hashCode()</code>案例中，我们将经历第7步场景。<br/>您可能已经注意到，第5/6步和第7步的场景之间有一个重要的区别:第5步和第6步不包含冲突，因此只需要一次操作(<code class="fe le lf lg lh b">key.equals(entry.getKey()</code>)就可以找到<code class="fe le lf lg lh b">value</code>，但是在第7步，由于冲突，我们必须多次执行这些操作(<code class="fe le lf lg lh b">key.equals(entry.getKey()</code>)(在最坏的情况下是<code class="fe le lf lg lh b">n</code>次，其中<code class="fe le lf lg lh b">n</code>是桶内条目的数量)。<br/>因此，碰撞破坏了<code class="fe le lf lg lh b">HashMap</code>的主要特征——极快的获取操作(一次操作<code class="fe le lf lg lh b">O(1)</code>对<code class="fe le lf lg lh b">n</code>操作<code class="fe le lf lg lh b">O(n)</code>)。</p><p id="21a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果<code class="fe le lf lg lh b">hashCode()</code>每次调用都返回新的哈希值(或者与<code class="fe le lf lg lh b">equals()</code>方法不一致)，那么<code class="fe le lf lg lh b">HashMap</code>中的另一个可能的问题就会发生。在这种情况下，第二步每次都将返回新的int数据，因此第三步将我们引向错误的桶，我们将永远找不到所需的<code class="fe le lf lg lh b">Entry </code> —数据将会丢失，这在当今是一个极其糟糕的问题(想象一下，您的工资支付丢失了，因为银行开发人员忘记为<code class="fe le lf lg lh b">Payment</code>类正确实现<code class="fe le lf lg lh b">hashCode() </code>方法)。</p><p id="17f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，你刚才已经看到了，<code class="fe le lf lg lh b">equals()</code>和<code class="fe le lf lg lh b">hashCode()</code>方法在<code class="fe le lf lg lh b">HashMap</code>中协同工作来获取和放置数据:<code class="fe le lf lg lh b">hashCode()</code>用于计算桶号，<code class="fe le lf lg lh b">equals()</code>用于查找具有相同键的<code class="fe le lf lg lh b">Entry</code>。</p><p id="e9ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们已经知道了足够多的信息来最终实现hashCode()方法。</p><p id="9af5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="oa">提示</em> </strong>:为了符合<code class="fe le lf lg lh b">hashCode()</code>和<code class="fe le lf lg lh b">equals()</code>方法之间的约定，在这两个方法中使用相同的字段被认为是一个好的做法。</p><p id="9eff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，当我们决定使用<code class="fe le lf lg lh b">idNumber</code>进行比较时，我们也可以在<code class="fe le lf lg lh b">hashCode()</code>方法中使用它。但是，正如你所记得的，<code class="fe le lf lg lh b">idNumber</code>是<code class="fe le lf lg lh b">long</code>类型，但是<code class="fe le lf lg lh b">hashCode()</code>返回<code class="fe le lf lg lh b">int</code>。小菜一碟:我们将为此使用<code class="fe le lf lg lh b">Objects.hash()</code>;</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="acc5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">即使<code class="fe le lf lg lh b">idNumber</code>是<code class="fe le lf lg lh b">int</code>(或任何其他数据类型)，使用上述方法对其进行哈希处理也是一个很好的实践，因为哈希算法将负责提供这样的数据，这将更适合于省略冲突。</p><p id="76a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们的<code class="fe le lf lg lh b">Person</code>类最终版本看起来是这样的:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="0f68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">干得好，伙计们！</p><p id="300c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我总结一下这篇文章的所有内容:</p><h2 id="306c" class="nj md it bd me np nq dn mi nr ns dp mm kr nt nu mq kv nv nw mu kz nx ny my nz bi translated">equals()方法:</h2><ol class=""><li id="cc22" class="lo lp it ki b kj na kn nb kr oc kv od kz oe ld no lu lv lw bi translated">用于比较两个非原始对象；</li><li id="03e0" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated">方法规则:<br/> - <strong class="ki iu">自反</strong> : <code class="fe le lf lg lh b">a.equals(a)</code>必须始终返回<code class="fe le lf lg lh b">true</code>；<br/> - <strong class="ki iu">对称</strong>:如果<code class="fe le lf lg lh b">a.equals(b)</code>返回<code class="fe le lf lg lh b">true</code>，那么<code class="fe le lf lg lh b">b.equals(a)</code>必定总是返回<code class="fe le lf lg lh b">true</code>；<br/> - <strong class="ki iu">传递</strong>:如果<code class="fe le lf lg lh b">a.equals(b)</code>返回<code class="fe le lf lg lh b">true</code>，<code class="fe le lf lg lh b">a.equals(c)</code>返回<code class="fe le lf lg lh b">true</code>，则意味着<code class="fe le lf lg lh b">b.equals(c)</code>一定是<code class="fe le lf lg lh b">true</code>；<br/> - <strong class="ki iu">一致</strong>:如果<code class="fe le lf lg lh b">a.equals(b)</code>返回<code class="fe le lf lg lh b">true</code>(或<code class="fe le lf lg lh b">false</code>)，并且<code class="fe le lf lg lh b">a</code>和<code class="fe le lf lg lh b">b</code>都没有改变，<code class="fe le lf lg lh b">a.equals(b)</code>应该总是返回相同的结果。</li><li id="023e" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated">实现步骤:<br/> 1)使用<code class="fe le lf lg lh b">==</code>运算符比较对象；<br/> 2)检查<code class="fe le lf lg lh b">Object o</code>参数是否不是<code class="fe le lf lg lh b">null</code>。如果是，返回<code class="fe le lf lg lh b">false</code>；<br/> 3)检查<code class="fe le lf lg lh b">Object o</code>参数是否与我们的实例具有相同的类型。如果否，返回<code class="fe le lf lg lh b">false</code>；<br/> 4)将<code class="fe le lf lg lh b">Object o</code>转换为当前的类类型；<br/> 5)比较所选字段的值。</li></ol><h2 id="db47" class="nj md it bd me np nq dn mi nr ns dp mm kr nt nu mq kv nv nw mu kz nx ny my nz bi translated">hashCode()方法:</h2><ol class=""><li id="4443" class="lo lp it ki b kj na kn nb kr oc kv od kz oe ld no lu lv lw bi translated">用于哈希目的—为对象提供int值；</li><li id="9311" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated">方法的规则:<br/>——对同一个没有改变的对象每次调用<code class="fe le lf lg lh b">hashCode()</code>方法，每次都必须产生相同的结果；<br/> -如果两个对象通过<code class="fe le lf lg lh b">equals()</code>方法相等，那么在这两个对象上调用<code class="fe le lf lg lh b">hashCode()</code>方法必须产生相同的结果；<br/> -但是如果在2个对象上调用<code class="fe le lf lg lh b">hashCode()</code>方法产生相同的结果，并不意味着它们相等(通过<code class="fe le lf lg lh b">equals()</code>方法)。</li><li id="00be" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated">最后两个规则也被称为<code class="fe le lf lg lh b">equals()</code>和<code class="fe le lf lg lh b">hashCode()</code>方法之间的契约。</li></ol><h2 id="35b2" class="nj md it bd me np nq dn mi nr ns dp mm kr nt nu mq kv nv nw mu kz nx ny my nz bi translated">HashMap和equals()/hashCode()方法用法:</h2><ol class=""><li id="4a5b" class="lo lp it ki b kj na kn nb kr oc kv od kz oe ld no lu lv lw bi translated"><code class="fe le lf lg lh b">HashMap</code>是用于存储键-值对元素的集合，它使用散列来提供极快的get操作；</li><li id="ef29" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated"><code class="fe le lf lg lh b">HashMap</code>的元素存储在桶中；</li><li id="13b4" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated"><code class="fe le lf lg lh b">hashCode()</code>结果用于计算存储桶的数量，元素将存储在那里；</li><li id="4e46" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated"><code class="fe le lf lg lh b">equals()</code>用于比较元素键找到需要的元素；</li><li id="bc7c" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated">如果<code class="fe le lf lg lh b">hashCode()</code>是以硬编码的方式实现的，那么同一个类的所有实例都将被存储在一个桶中，这将会导致性能问题(get进程的<code class="fe le lf lg lh b">n</code>操作而不是<code class="fe le lf lg lh b">1</code>)；</li><li id="cd4e" class="lo lp it ki b kj lx kn ly kr lz kv ma kz mb ld no lu lv lw bi translated">此外，如果<code class="fe le lf lg lh b">hashCode()</code>每次都返回新值或者不符合<code class="fe le lf lg lh b">equals()</code>和<code class="fe le lf lg lh b">hashCode()</code>之间的约定，那么元素可能会丢失。</li></ol><p id="0ab3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一段漫长的旅程，但我们一起走过了。我希望你学到了新的东西，并且在阅读过程中没有睡着。无论如何，谢谢，在评论区和以后的帖子里再见！</p><p id="6f5d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">玩得开心！</p></div></div>    
</body>
</html>