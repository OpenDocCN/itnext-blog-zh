<html>
<head>
<title>Fixing mistakes using git reset and revert</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用git重置和恢复修复错误</h1>
<blockquote>原文：<a href="https://itnext.io/fixing-mistakes-using-git-reset-and-revert-3d68fab3176e?source=collection_archive---------6-----------------------#2020-04-07">https://itnext.io/fixing-mistakes-using-git-reset-and-revert-3d68fab3176e?source=collection_archive---------6-----------------------#2020-04-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/75417b43b85bf863f46bdc2c96e645f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z-2LiQU7BKIDO2dXlp4r3A.jpeg"/></div></div></figure><p id="395c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你听说过“万圣节穿衬衫说<code class="fe kw kx ky kz b">git reset</code>”这句话吗？不，你没有，因为是我做的(但这是一个吓唬开发者的好主意，对吧！！！).理解git reset的概念很重要，因为所有其他命令，如git revert、checkout都基于相同的底层概念，在这之后，您就不必害怕使用它或从堆栈溢出中复制和粘贴它(嗯，您甚至也不需要这样做。)</p><h2 id="4667" class="la lb iq bd lc ld le dn lf lg lh dp li kj lj lk ll kn lm ln lo kr lp lq lr ls bi translated">先决条件</h2><ol class=""><li id="a471" class="lt lu iq ka b kb lv kf lw kj lx kn ly kr lz kv ma mb mc md bi translated">分支、引用和提交是如何工作的，你可以从我之前关于<a class="ae me" href="https://link.medium.com/9GwS0Ppgp5" rel="noopener">理解引用和分支</a>的博客中看到。(更好的营销策略没错！！！)</li></ol><p id="baa5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.你应该知道我们的代码所在的3个区域</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/e690aa3698df068a14aafcf33be9f607.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*qWfnoPKbFWHwcEvWGnk_Xg.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">git的3个阶段</figcaption></figure><ul class=""><li id="5939" class="lt lu iq ka b kb kc kf kg kj mo kn mp kr mq kv mr mb mc md bi translated"><strong class="ka ir">工作区，也叫</strong>这是我们的代码所在的区域，不在暂存区，或者我们可以说“不由git处理”，也叫<code class="fe kw kx ky kz b"><strong class="ka ir">untracked files</strong></code></li><li id="224c" class="lt lu iq ka b kb ms kf mt kj mu kn mv kr mw kv mr mb mc md bi translated"><strong class="ka ir">暂存区，</strong>是git知道在当前和下一次提交之间会发生什么变化的区域。</li></ul><blockquote class="mx my mz"><p id="5fdc" class="jy jz na ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">git add &lt;file&gt;</code>将我们的文件从工作区移动到暂存区</p><p id="4720" class="jy jz na ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">git commit -m ""</code>将我们的文件从暂存区移动到存储库</p></blockquote><ul class=""><li id="7ae9" class="lt lu iq ka b kb kc kf kg kj mo kn mp kr mq kv mr mb mc md bi translated">这个区域包含git知道的文件，这意味着它包含了你提交的所有文件。</li></ul><p id="5529" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">重要提示:</strong>一个“干净的”暂存区不是空的，可以把它看作是上一次提交的精确副本，就像游戏中的一个检查点，你在ram中加载一个检查点(或者一个合适但不同的内存区域，或者我们可以说是工作区)，然后从那里开始玩。</p><p id="c4f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.您应该知道如何隐式引用git提交:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/5a1953dc4497416b80f46431c3aca348.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/1*mFBpi-1lnY6-Wg7RO0SBdA.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">一个例子</figcaption></figure><p id="d0a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，如果<code class="fe kw kx ky kz b">HEAD</code>指向提交“A”，那么，<code class="fe kw kx ky kz b">HEAD~1</code>或者我们可以说<code class="fe kw kx ky kz b">HEAD~</code>将是它的父提交，第一深度级别意味着“B”，而<code class="fe kw kx ky kz b">HEAD~2</code>将是c。因此，它在深度方向上引用父提交。</p><pre class="mg mh mi mj gt nf kz ng nh aw ni bi"><span id="d4cd" class="la lb iq kz b gy nj nk l nl nm">A~1 = A~ = B<br/>A~2 = C</span></pre><p id="291e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">什么是Git重置？</strong></p><p id="a1ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">git复位有3种类型:混合、软和硬。默认情况下，git会<code class="fe kw kx ky kz b"> mixed</code>重置，如果你知道这三个的概念，<strong class="ka ir">没人能阻止你修复错误</strong>，因为它们都很重要。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/9043141a020e2b6a962c873b9d0d5875.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*Oc3N-BEVAs__m-RW8qkTiA.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">克隆回购的初始阶段</figcaption></figure><p id="8c46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我克隆了一个repo，那么在初始阶段，最后一次提交的所有内容(其中<code class="fe kw kx ky kz b">HEAD</code>指向)被复制到暂存和工作区，在这里，<code class="fe kw kx ky kz b">foo.txt</code>是我们最后一次提交的内容，它被复制到这两个区域。</p><p id="1b46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">git reset</code>会将您的<code class="fe kw kx ky kz b">HEAD</code>指向一个特定的提交，并且根据给定的标志完成以下操作，<strong class="ka ir">会将您当前所在的分支的引用与</strong> <code class="fe kw kx ky kz b"><strong class="ka ir">HEAD</strong></code> <strong class="ka ir">一起移动，导致您的提交历史和引用丢失，因为现在分支指向一些其他的提交。</strong></p><ul class=""><li id="de29" class="lt lu iq ka b kb kc kf kg kj mo kn mp kr mq kv mr mb mc md bi translated"><strong class="ka ir">混合标志</strong></li></ul><pre class="mg mh mi mj gt nf kz ng nh aw ni bi"><span id="4bbc" class="la lb iq kz b gy nj nk l nl nm">git reset --mixed HEAD~</span></pre><p id="67ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它将执行以下步骤:</p><ol class=""><li id="4d0c" class="lt lu iq ka b kb kc kf kg kj mo kn mp kr mq kv ma mb mc md bi translated">将<code class="fe kw kx ky kz b">HEAD</code>的指针从“A”移动到“B”(它的父)，现在A将成为一个悬空提交，因为<code class="fe kw kx ky kz b">master</code>分支引用更改为“B”。</li><li id="7ecb" class="lt lu iq ka b kb ms kf mt kj mu kn mv kr mw kv ma mb mc md bi translated">仅将“bar.txt”复制到临时区域(不是工作树)</li></ol><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/c76bb1eea755cb3d8d53b80bf92504d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*to4xLzQ16Wuu65iUYiUwpQ.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">混合标志仅更改中转区，不更改工作区</figcaption></figure><p id="ea33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以在<code class="fe kw kx ky kz b">--mixed</code>标志中，你在工作树中的所有更改(未跟踪的文件)都不会被删除(真是松了一口气！！！).</p><ul class=""><li id="e2d6" class="lt lu iq ka b kb kc kf kg kj mo kn mp kr mq kv mr mb mc md bi translated"><strong class="ka ir">软旗</strong></li></ul><pre class="mg mh mi mj gt nf kz ng nh aw ni bi"><span id="6fbe" class="la lb iq kz b gy nj nk l nl nm">git reset --soft HEAD~1</span></pre><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/1ff9eda63c3962445702f17f110dbe8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*w5vKuusTl1J-ESIi88EwpA.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">用软标志复位git</figcaption></figure><p id="6074" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个大部分时间不用。</p><p id="fe1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">步骤:</p><ol class=""><li id="06b0" class="lt lu iq ka b kb kc kf kg kj mo kn mp kr mq kv ma mb mc md bi translated">仅将<code class="fe kw kx ky kz b">HEAD</code>的指针从“A”移动到“B”(连同当前分支参考)</li></ol><p id="d57a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您在上图中看到的，它不会更改工作区和暂存区中的文件。</p><ul class=""><li id="b0d6" class="lt lu iq ka b kb kc kf kg kj mo kn mp kr mq kv mr mb mc md bi translated"><strong class="ka ir">硬标志</strong></li></ul><pre class="mg mh mi mj gt nf kz ng nh aw ni bi"><span id="332d" class="la lb iq kz b gy nj nk l nl nm">git reset --hard HEAD~</span></pre><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/cdf07addf0060245b8c885645a0571a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*ppZbZ9FsNJPWDd8QEgExTA.png"/></div></figure><p id="c19c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">步骤:</p><ol class=""><li id="e7d6" class="lt lu iq ka b kb kc kf kg kj mo kn mp kr mq kv ma mb mc md bi translated">将<code class="fe kw kx ky kz b">HEAD</code>连同“A”到“B”的分支一起移动。</li><li id="1f69" class="lt lu iq ka b kb ms kf mt kj mu kn mv kr mw kv ma mb mc md bi translated">将“bar.txt”(提交“B”中的文件)复制到暂存区和工作区。</li></ol><p id="e2c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，工作区中所有未跟踪的文件都会被覆盖，所以这是一个非常危险的操作，因为你的数据会丢失。</p><p id="6ba4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">用ORIG_HEAD </strong>撤销复位</p><p id="6104" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在意外重置的情况下，为了安全起见，git将HEAD的前一个值保存在一个名为<code class="fe kw kx ky kz b">ORIG_HEAD</code>的变量中，也就是说，它将指向丢失的悬空提交“A ”,以便将其检索回来</p><pre class="mg mh mi mj gt nf kz ng nh aw ni bi"><span id="ecb5" class="la lb iq kz b gy nj nk l nl nm">git reset ORIG_HEAD</span></pre><p id="6d2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们的区域将更新为:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/9043141a020e2b6a962c873b9d0d5875.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*Oc3N-BEVAs__m-RW8qkTiA.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">原始期</figcaption></figure><p id="d440" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是记住<code class="fe kw kx ky kz b">ORIG_HEAD</code>只指向提交的前一个值，所以如果你做<code class="fe kw kx ky kz b">git reset HEAD~</code>两次，“A”将永久丢失，因为<code class="fe kw kx ky kz b">ORIG_HEAD</code>指向“B”并且没有对“A”的引用。</p><h2 id="bb64" class="la lb iq bd lc ld le dn lf lg lh dp li kj lj lk ll kn lm ln lo kr lp lq lr ls bi translated">GIT恢复—安全重置</h2><p id="7778" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj nq kl km kn nr kp kq kr ns kt ku kv ij bi translated">它创建一个新的提交，引入与指定提交相反的更改，这是撤销您提交的更改的首选方式，因为<code class="fe kw kx ky kz b">git reset</code>可能会弄乱您团队成员的提交历史，因为您的提交历史已被更改并与其他人共享，但<code class="fe kw kx ky kz b">git revert</code>不会更改提交历史。举个例子，</p><pre class="mg mh mi mj gt nf kz ng nh aw ni bi"><span id="c41f" class="la lb iq kz b gy nj nk l nl nm">git revert &lt;commit B&gt;</span></pre><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/c1b2e79d1af3375feb4f41005c12cbc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*5_BqcBzt6DH_iyKPBNV0MQ.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">通过git revert撤消已提交的更改</figcaption></figure><p id="9167" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您的阅读，如果您有任何疑问，请在“写回复”部分提问，因为这也将帮助其他人清除您发现的相同疑问。</p></div></div>    
</body>
</html>