<html>
<head>
<title>How to Use Gitleaks to Prevent Pushing Sensitive Info</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Gitleaks防止推送敏感信息</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-use-gitleaks-to-prevent-pushing-sensitive-info-cdd0355d5f61?source=collection_archive---------1-----------------------#2019-05-10">https://itnext.io/how-to-use-gitleaks-to-prevent-pushing-sensitive-info-cdd0355d5f61?source=collection_archive---------1-----------------------#2019-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9ab95e70c241407552723581c8c948d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e1tybwb_ITD1cU5wV_stwg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Danaï des一家注定要永远把水带到一个总是漏水的浴缸里。</figcaption></figure></div><div class="ab cl kc kd hu ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ij ik il im in"><p id="345a" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">我们都在生命中的某一时刻做过。你刚刚在你的公共回购上实现了一个闪亮的新特性，你结束了你的最后一次提交，运行所有的测试和推送。你去厨房拿一杯当之无愧的咖啡，当你正要喝第一口时，你恍然大悟:你已经把你的(密码| API密钥| API秘密)推送到你的公共存储库。</p><p id="40f3" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">您的第一反应是删除项目中的敏感信息，然后再次推送——众所周知，这是没有用的，因为提交仍然在历史中。唯一要做的就是使暴露的敏感信息无效，并尽快发布新的信息，然后修复存储库。假设你很快意识到自己的错误，那么你可能会毫发无损地离开。但是如果你不这样做呢？</p></div><div class="ab cl kc kd hu ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ij ik il im in"><p id="adbc" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">互联网上充斥着<a class="ae lh" href="https://www.theregister.co.uk/2015/01/06/dev_blunder_shows_github_crawling_with_keyslurping_bots/" rel="noopener ugc nofollow" target="_blank">关于</a> <a class="ae lh" href="https://medium.com/@nagguru/exposing-your-aws-access-keys-on-github-can-be-extremely-costly-a-personal-experience-960be7aad039" rel="noopener">的</a> <a class="ae lh" href="https://medium.com/@selvaganesh93/what-happens-if-you-accidentally-commit-your-aws-access-token-to-public-github-be50d378b4c7" rel="noopener">的故事</a>关于人们错误地提交他们的敏感信息并因此而遭受痛苦。其中大多数涉及恶意的人窃取S3访问令牌，并累积数千美元的法案。你没有太多的时间了——在某些情况下，这些所谓的黑客可以在不到10分钟的时间内获取你的密钥并滥用它们。但是怎么做呢？</p><p id="6ee5" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">事实证明，如果你知道如何使用GitHub，扫描敏感信息是相当容易的。你可以直接<a class="ae lh" href="https://github.com/search?q=remove+api+key&amp;type=Commits" rel="noopener ugc nofollow" target="_blank">搜索在消息</a>中包含“删除API密钥”的提交，你会看到成千上万的提交在diff中包含敏感信息，一目了然。编写一个抓取这些结果的机器人是微不足道的。还有像<a class="ae lh" href="https://github.com/michenriksen/gitrob" rel="noopener ugc nofollow" target="_blank"> gitrob </a>和<a class="ae lh" href="https://github.com/dxa4481/truffleHog" rel="noopener ugc nofollow" target="_blank"> truffleHog </a>这样的工具可以帮你做到这一点。我认为可以肯定地说，只要您推送敏感数据，您就应该认为它受到了威胁。</p></div><div class="ab cl kc kd hu ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ij ik il im in"><p id="2b33" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">我来给你讲讲<a class="ae lh" href="https://github.com/zricethezav/gitleaks" rel="noopener ugc nofollow" target="_blank"> gitleaks </a>。</p><p id="1973" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">Gitleaks是一个扫描本地和远程存储库的工具，可以扫描任何类型的敏感信息。它速度快，易于使用，非常可配置。</p><p id="9175" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">要在远程存储库上运行它:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="0c28" class="lr ls iq ln b gy lt lu l lv lw">gitleaks --repo=https://github.com/path/to/your/repo</span></pre><p id="91f0" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">要在本地运行它:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="3a8d" class="lr ls iq ln b gy lt lu l lv lw">gitleaks --repo-path=path/to/your/repo</span></pre><p id="4df5" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">要查看更多示例，请访问<a class="ae lh" href="https://github.com/zricethezav/gitleaks/wiki" rel="noopener ugc nofollow" target="_blank">维基页面</a>。出于我们的目的，我们希望在每次推送之前在本地存储库上运行它。由于gitleaks实现了非常一致的返回代码(0表示没有泄漏，1表示存在泄漏),这实际上非常容易做到；与其用<em class="lx"> git推</em>，我们可以只做:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="0bde" class="lr ls iq ln b gy lt lu l lv lw">gitleaks --repo-path=path/to/your/repo -v &amp;&amp; git push</span></pre><p id="1c46" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">对于那些不知道bash的人来说，<em class="lx"> &amp; &amp; </em>让您在前面的命令正确完成的情况下运行一个命令。在我们的例子中，<em class="lx"> git push </em>只有在没有发现泄漏的情况下才会运行。我们还将<em class="lx"> -v </em>放在那里，以便能够看到关于任何当前泄漏的更多信息。</p><p id="876f" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">下面是我在一个提交了(假)AWS密钥的存储库上运行它的一个例子:</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="8abf" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">如你所见，自从gitleaks发现一个漏洞(一个AWS键在<em class="lx"> keys.go </em>)之后，<em class="lx"> git push </em>就没有运行。我们安全了！</p><p id="f894" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">下面是我在移除AWS密钥后运行它的一个示例:</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="f6a9" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">因为已经没有敏感信息了，我们可以推送了。</p></div><div class="ab cl kc kd hu ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ij ik il im in"><p id="d092" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">为了尽可能简化这个过程，给我们的新命令起别名<em class="lx"> git push </em>是一个好主意，因为每次要推送时都要键入它是一件麻烦的事情。一种方法是创建一个别名，如下所示:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="a817" class="lr ls iq ln b gy lt lu l lv lw">alias gl="gitleaks --repo-path=path/to/your/repo -v &amp;&amp; git push"</span></pre><p id="20d0" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">这是可行的，但是不是最佳的，因为我们希望我们的命令被嵌入到git push中。我们不应该改变我们的工作流程。因此，更好的选择是围绕<em class="lx"> git </em>命令创建一个包装函数:</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="ly lz l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">将此放入您的~/bash_profile</figcaption></figure><p id="5560" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">现在，这才像话！这将在每次<em class="lx"> git推送</em>之前运行gitleaks，而不会对我们的工作流程造成任何改变。使用这种方法，所有的<em class="lx"> git推送</em>选项(比如<em class="lx"> -f </em>和<em class="lx">-v】)</em>也将工作，因为所有的标志和参数都将被传递。我们知道我们的秘密是安全的，所以我们可以快乐地推送。</p></div><div class="ab cl kc kd hu ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ij ik il im in"><p id="5840" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">这就是你想要的——在每次推送之前，一种简单而又没有麻烦的方式来审计你的存储库。如果你和一个团队一起工作，最好在你的CI工具中设置这个(你<strong class="kl ir">使用CI工具，对吗？).您还可以设置一个git挂钩，如果检测到泄漏，它会拒绝提交。编码快乐！</strong></p></div></div>    
</body>
</html>