<html>
<head>
<title>K8s prevent queue worker Pod from being killed during deployment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">K8s防止队列工作Pod在部署期间被杀死</h1>
<blockquote>原文：<a href="https://itnext.io/k8s-prevent-queue-worker-pod-from-being-killed-during-deployment-4252ea7c13f6?source=collection_archive---------0-----------------------#2020-03-02">https://itnext.io/k8s-prevent-queue-worker-pod-from-being-killed-during-deployment-4252ea7c13f6?source=collection_archive---------0-----------------------#2020-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="be20" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何防止Kubernetes(如RabbitMQ)队列工作Pod在部署过程中处理消息时被杀死？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2dffdf6178047d875d378ae79dd0d4ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9F5TqXDWvjuQUgXBWxT8sA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">https://unsplash.com/photos/_nqApgG-QrY<a class="ae ky" href="https://unsplash.com/photos/_nqApgG-QrY" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="ca9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当为部署设置新的容器映像时，Kubernetes都会替换每个Pod。默认情况下，这是使用滚动策略完成的，其中带有新图像的pod被旋转起来，旧图像被一步一步地删除。</p><p id="f145" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好，但是如果一个带有旧映像的Pod在那个时刻处理一个重要的长期请求或任务呢？在它完成任务之前，有没有可能防止它被终止？</p><h2 id="4646" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="f448" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Kubernetes提供了生命周期挂钩，通过它可以延迟终止。正确实现这一点取决于开发人员。</p><h2 id="18db" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">部件</h2><ol class=""><li id="fe05" class="mt mu it lb b lc mo lf mp li mv lm mw lq mx lu my mz na nb bi translated">(本文)</li><li id="425a" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae ky" href="https://medium.com/@wuestkamp/symfony-messenger-worker-on-kubernetes-77f75725b5ed?sk=c0a38e15d6cca86ffdec1496c075bacc" rel="noopener">使用Symfony Messenger的示例</a></li></ol><h1 id="bfd4" class="nh lw it bd lx ni nj nk ma nl nm nn md jz no ka mg kc np kd mj kf nq kg mm nr bi translated">Pod生命周期</h1><p id="2925" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果一个吊舱被杀死，手动通过<code class="fe ns nt nu nv b">kubectl</code>或任何k8s控制器像在部署期间，它将立即从运行状态变为终止状态。同时，SIGTERM信号将被发送到该容器内的所有容器。</p><h2 id="1bc2" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">处于终止状态的Pod</h2><p id="7716" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">当Pod处于终止状态时，它仍然像以前一样被调度，并使用相同的资源(CPU/内存)。但是没有新的请求被k8s服务重定向到终结点。在终止状态下，Pod可以并且应该正确地自行关闭。</p><p id="0ee2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当处于终止状态时，如果容器结束，容器不会重新启动。每当Pod内的容器在运行状态下停止时，该容器就会重新启动。这样做是因为除非发生错误，否则Pod应该一直运行。</p><p id="15c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pod停留在终止状态的最长时间为terminationGracePeriodSeconds设置的时间，默认情况下为30秒。如果所有Pod的容器都自行结束，则可以提前离开终止状态。一旦Pod离开终止状态，它将被移除并取消计划。</p><h1 id="4a18" class="nh lw it bd lx ni nj nk ma nl nm nn md jz no ka mg kc np kd mj kf nq kg mm nr bi translated">观察到Pod生命周期挂钩</h1><p id="2de8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">可以挂钩到Pod的生命周期事件。我们可以用这个简单的例子来看这些事件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="890a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">旋转Pod并使用<code class="fe ns nt nu nv b">kubectl logs -f runner</code>检查其日志。然后关闭Pod以查看预停止日志输出。</p><h1 id="65d1" class="nh lw it bd lx ni nj nk ma nl nm nn md jz no ka mg kc np kd mj kf nq kg mm nr bi translated">控制Pod生命周期</h1><p id="a574" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们可以延长Pod在被完全杀死之前处于终止状态的时间:</p><pre class="kj kk kl km gt ny nv nz oa aw ob bi"><span id="acd4" class="lv lw it nv b gy oc od l oe of">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  labels:<br/>    run: runner<br/>  name: runner<br/>spec:<br/><strong class="nv iu">  terminationGracePeriodSeconds: 60 # raise to 60 seconds</strong><br/>  containers:<br/>  - command:<br/>    - sh<br/>    - -c<br/>    - 'touch /tmp/messaging &amp;&amp; tail -f /tmp/messaging'<br/>...</span></pre><p id="e126" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们可以简单地将<strong class="lb iu">terminationgraceperiodes</strong>设置为一个值，让我们的队列工作人员有足够的时间来完成任务，比如5个小时。这将是最简单的解决方案。</p><p id="deb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">但这意味着，对于每个部署</strong>，只要设置了terminationGracePeriodSeconds，副本的数量就会再次增加。这会消耗宝贵的资源。</p><h1 id="385d" class="nh lw it bd lx ni nj nk ma nl nm nn md jz no ka mg kc np kd mj kf nq kg mm nr bi translated">只要它还在执行任务，就让它活着</h1><p id="cdd9" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这就是我们想要的。如果我们部署了一个新的镜像版本，我们希望所有不做任何事情的工人舱立即更新，所有其他人应该保持活动。</p><h2 id="a5d4" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">应用程序容器需要监听SIGTERM信号</h2><p id="dd35" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了实现这一点，在容器中运行的主进程需要监听SIGTERM信号并正确地终止自己。当Pod处于终止状态时，如果每个容器都发生这种情况，那么Pod将会被提前终止，即使terminationGracePeriodSeconds仍然处于活动状态。</p><p id="638c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看这个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="078b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">旋转吊舱并用<code class="fe ns nt nu nv b">kubectl logs -f runner</code>检查其日志，然后杀死它。</p><p id="a5e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，只要文件<code class="fe ns nt nu nv b">/tmp/kill_me</code>不存在，容器就会输出文件<code class="fe ns nt nu nv b">/tmp/messaging</code>的内容。休眠10秒后，preStop生命周期钩子将创建文件<code class="fe ns nt nu nv b">/tmp/kill_me</code>。</p><p id="1dc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以将terminationGracePeriodSeconds设置为一个更大的数字，并相信我们的应用程序会尽早正确地结束。</p><h1 id="e664" class="nh lw it bd lx ni nj nk ma nl nm nn md jz no ka mg kc np kd mj kf nq kg mm nr bi translated">任何工作者的伪代码</h1><p id="0d47" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">以下是任何本身可能不处理SIGERM信号的工作进程的Preudo代码示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="846c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的例子假设在<code class="fe ns nt nu nv b">/bin/worker</code>有一个长期运行的工作进程，它从消息队列中接收消息。该过程接受参数来控制它处理多少消息(<code class="fe ns nt nu nv b">--message-count=1</code>)以及在退出前等待新消息的总时间(<code class="fe ns nt nu nv b">--timeout=1m</code>)。</p><p id="7b12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将导致吊舱最多保持活动1小时(3600秒)，只要<code class="fe ns nt nu nv b">/bin/worker</code>正在处理它的任务，活动时间就最短。</p><p id="6347" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的工作进程不提供这些参数，并且它本身不能正确处理SIGTERM信号，那么我现在就没有办法了。</p><h1 id="b74b" class="nh lw it bd lx ni nj nk ma nl nm nn md jz no ka mg kc np kd mj kf nq kg mm nr bi translated">有边车集装箱运行怎么办？</h1><p id="c6ea" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了让一个Pod真正从它的终止状态被终止，所有Pod的容器的主进程都需要处理SIGTERM并正确地终止。如果您有一个不处理SIGTERM的sidecar容器，请检查以下示例方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="90d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，sidecar容器是一个长期运行的Python进程。python sidecar容器规范监听生命周期，如果主工作容器给出了ok，就终止它的主进程。</p><p id="cb49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过创建文件<code class="fe ns nt nu nv b">/tmp/share/kill_sidecar</code>经由共享文件卷传递ok。这只有在包含辅助进程的主容器自身结束后才会发生。</p><h1 id="f88c" class="nh lw it bd lx ni nj nk ma nl nm nn md jz no ka mg kc np kd mj kf nq kg mm nr bi translated">与HPA /水平Pod自动缩放器结合使用</h1><p id="5008" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">应该可以为工作单元的部署实施HPA，并使用自定义队列指标来扩展和缩减这些工作单元。例如，度量可能来自RabbitMQ，这取决于有多少滞后消息。这与正确定义的终止/生命周期处理相结合，可以发挥巨大的作用。</p><h1 id="34d9" class="nh lw it bd lx ni nj nk ma nl nm nn md jz no ka mg kc np kd mj kf nq kg mm nr bi translated">为什么不使用工作或临时豆荚？</h1><p id="4693" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">另一种方法可能是为每个到达队列并需要处理的消息设置单独的pod。一个作业创建一个Pod，它不是要无限期地运行，而是只运行到它的主要任务完成为止。对作业的模板容器映像的更改不会影响该作业的任何正在运行的Pod，只会影响新创建的Pod。</p><p id="ffe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参见<a class="ae ky" href="https://keda.sh/concepts/scaling-jobs/" rel="noopener ugc nofollow" target="_blank">https://keda.sh/concepts/scaling-jobs</a></p><p id="6a49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如果您每秒处理数千条消息，这种方法可能会导致很大开销。为了解决这个问题，您可以定义一个Pod在退出之前处理不止一个而是一定数量的消息。</p><h2 id="f8c3" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">K8s运算符</h2><p id="32d6" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了避免您的工作人员/跑步者在部署期间被杀害，一个好的方法是Kubernetes操作员处理消息的Pod创建。我在为RabbitMQ找东西，发现了<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-workers-autoscaling-based-on-rabbitmq-queue-size-cb0803193cdf">这篇文章</a>。另外:</p><p id="eb28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/argoproj/argo-events" rel="noopener ugc nofollow" target="_blank"> Argo Events </a>看起来很有趣，它可以基于来自RabbitMQ等各种来源的事件创建Kubernetes对象。</p><p id="338b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用于流水线作业的Tekon 还创建了CRD来为特定任务旋转pod。</p><h1 id="b126" class="nh lw it bd lx ni nj nk ma nl nm nn md jz no ka mg kc np kd mj kf nq kg mm nr bi translated">更大的</h1><p id="1022" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated"><a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/pods/pod/#termination-of-pods" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/workloads/pods/pod/# termination-of-pods</a></p><p id="9a32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/containers/container-life cycle-hooks</a></p><h1 id="b61d" class="nh lw it bd lx ni nj nk ma nl nm nn md jz no ka mg kc np kd mj kf nq kg mm nr bi translated">成为Kubernetes认证</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://killer.sh"><div class="gh gi og"><img src="../Images/cf3901a56841fcb55f9e4e17b9f07672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Kbj17_6VncUuoBqNsAzzg.png"/></div></a><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://killer.sh" rel="noopener ugc nofollow" target="_blank"> https://killer.sh </a></figcaption></figure></div></div>    
</body>
</html>