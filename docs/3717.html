<html>
<head>
<title>Get Fluttered : Postman Animation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">被扑腾:邮递员动画</h1>
<blockquote>原文：<a href="https://itnext.io/get-fluttered-postman-animation-d1760416b680?source=collection_archive---------2-----------------------#2020-02-09">https://itnext.io/get-fluttered-postman-animation-d1760416b680?source=collection_archive---------2-----------------------#2020-02-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/b53373be069f7b5a0094f0228c8bdca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*_ZyBPbEsjB59qJo5RTDXjg.gif"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">邮递员加载屏幕动画</figcaption></figure><p id="039e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你们中的很多人以前一定用过Postman。今天我们要构建邮差加载屏幕动画，直接进入吧。</p><p id="d307" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将把这个动画分成三个简单的里程碑—</p><ol class=""><li id="d89f" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">画内圆和同心圆。</li><li id="1ef6" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">在每个同心圆上放置(画出)小球。</li><li id="ed72" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">最后，让球变得疯狂。</li></ol><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="lo lp l"/></div></figure><h1 id="85de" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><strong class="ak">里程碑#1 —画圆</strong></h1><p id="60a7" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">在Flutter中绘制形状最简单的方法是使用<code class="fe mt mu mv mw b">CustomPaint</code>小部件。现在，如何使用CustomPaint绘制一个圆？<br/><code class="fe mt mu mv mw b">CustomPaint</code>接受一个负责绘制形状的<code class="fe mt mu mv mw b">painter</code>参数。使用<code class="fe mt mu mv mw b">CustomPainter</code>类实现了一个<code class="fe mt mu mv mw b">painter</code>。查找我们找到的文件-</p><blockquote class="mx my mz"><p id="06da" class="jy jz na ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated">若要实现自定义画图器，请子类化或实现此接口来定义您的自定义画图委托。<a class="ae ne" href="https://api.flutter.dev/flutter/widgets/CustomPaint-class.html" rel="noopener ugc nofollow" target="_blank"> CustomPaint </a>子类必须实现<a class="ae ne" href="https://api.flutter.dev/flutter/rendering/CustomPainter/paint.html" rel="noopener ugc nofollow" target="_blank"> paint </a>和<a class="ae ne" href="https://api.flutter.dev/flutter/rendering/CustomPainter/shouldRepaint.html" rel="noopener ugc nofollow" target="_blank"> shouldRepaint </a>方法，也可以选择实现<a class="ae ne" href="https://api.flutter.dev/flutter/rendering/CustomPainter/hitTest.html" rel="noopener ugc nofollow" target="_blank"> hitTest </a>和<a class="ae ne" href="https://api.flutter.dev/flutter/rendering/CustomPainter/shouldRebuildSemantics.html" rel="noopener ugc nofollow" target="_blank"> shouldRebuildSemantics </a>方法，以及<a class="ae ne" href="https://api.flutter.dev/flutter/rendering/CustomPainter/semanticsBuilder.html" rel="noopener ugc nofollow" target="_blank">semantics builder</a>getter。</p></blockquote><p id="cc4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们盲目地遵循万能的文献告诉我们的。我们创建一个类，并将其扩展到CustomPainter，实现所需的方法。它看起来像这样-</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="nf lp l"/></div></figure><p id="c5a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如文档中所写，必要的方法是<code class="fe mt mu mv mw b">paint</code>和<code class="fe mt mu mv mw b">shouldRepaint</code>方法。要理解<code class="fe mt mu mv mw b">paint</code>方法是如何工作的，简单地说，就像这样,<code class="fe mt mu mv mw b">paint</code>方法使用一个<code class="fe mt mu mv mw b">Paint</code>对象来绘制固定<code class="fe mt mu mv mw b">Size</code>的<code class="fe mt mu mv mw b">Canvas</code>。让我们按照这些步骤来看看它的实际效果—</p><ol class=""><li id="ef3c" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">创建一个绘画对象(包含如何绘制形状的信息，例如笔画类型、笔画宽度等)</li><li id="5b4c" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">选取固定偏移(包含有关在画布中绘制形状的位置的信息)</li><li id="a0cd" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">调用绘图函数(它包含关于要绘制的形状类型的信息，例如圆、弧、线等)</li></ol><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="nf lp l"/></div></figure><p id="e8a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">屏幕上终于出现了一个圆圈。</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/d51d92d89a574259383634869b47ab00.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*aSF3TcIVxnvmB83TKsyVrA.png"/></div></figure><p id="06c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们继续构建其余的同心圆。如果你仔细观察，这个圆和其他三个同心圆唯一的区别就是半径不同，没有颜色填充。因此，我们又画了三个不同半径的圆。Paint对象的<code class="fe mt mu mv mw b">paintStyle</code>属性负责您想要如何绘制圆。<code class="fe mt mu mv mw b">PaintStyle.stroke</code>只是勾勒形状，不填充。所以我们通过添加以下内容再画三个圆-</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="nf lp l"/></div></figure><p id="53f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了可以放球的圆圈。</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/7a4060130ba1bb1974c9205bce1acc80.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*RDROdMNZoOrsr2gVIR-z3w.png"/></div></figure><h1 id="4e24" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">里程碑#2 —放置小圆圈</h1><p id="9e05" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">这部分是所有三个里程碑中最容易的。创建一个圆，用想要的颜色填充它，并把它放在一个特定的位置，这是我们到目前为止学到的东西。这里，我们只需要创建三个相同的圆，并将它们放置在三个同心圆的半径上。这些圆圈的位置有点棘手。如果你足够努力地思考，小圈子将遵循的路径具有以下逻辑—</p><p id="4adf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">【x = size.width/2+radiusOfPath * math . cos(initial displace+rotation angle * rotation speed)<br/>y = size.height/2+radiusOfPath * math . sin(initial displace+rotation angle * rotation speed)</p><p id="fda2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中，<br/><em class="na">intial displace</em>是我们要开始旋转动画的角度，<em class="na"> rotationAngle </em>是任意给定时刻的旋转角度，<em class="na">rotations speed</em>是小圆绕内圆旋转的速度。现在我们将保持<em class="na">初始位移、旋转角度</em>和<em class="na">旋转速度</em>为零，我们将在实现第三个里程碑时设置它们。</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="nf lp l"/></div></figure><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/4fa9cdcf7c5c35eada433f8e36d09143.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/1*TdoZjX-xP-DRsVhtmK3N0w.png"/></div></figure><h1 id="8c58" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">里程碑#3 —制作圆圈动画</h1><p id="5ab9" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">剩下的就是让这些圆以不同的速度绕着内圈旋转。如果我们能够随时改变<em class="na">旋转角度</em>的值，这就可以实现。因此，这为在Flutter中使用<a class="ae ne" href="https://flutter.dev/docs/development/ui/animations/tutorial" rel="noopener ugc nofollow" target="_blank">补间动画</a>提供了一个完美的例子。如果你有补间动画的经验，你会知道<code class="fe mt mu mv mw b">Animation</code>和<code class="fe mt mu mv mw b">AnimationController</code>是实现它们所需要的两个关键对象。使用这个动画对象，我们将随时改变<em class="na">旋转角度</em>的值。为了将<code class="fe mt mu mv mw b">animation.value</code>从小部件传递到CustomPainter，我们将使用rotationFactor变量。我们的旋转角度现在由以下逻辑定义—</p><p id="0610" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="na">rotation angle = rotation factor * math . pi</em></p><p id="f90b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">剩下的另一件事是圆圈旋转的速度。我个人把最里面一圈的速度设定为中间一圈的两倍，中间一圈的速度是最外面一圈的两倍。</p><p id="be56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是最后一个变化。这是一个非常小的变化，但确实是一个关键的变化。默认情况下，<code class="fe mt mu mv mw b">shouldRepaint</code>方法返回false。我们必须把它改成真的。原因在于理解shouldRepaint方法的作用。本质上，它所做的就是控制CustomPainter小部件的重建。更简单地说，每当调用CustomPainter类的新实例时都会调用它。因此，将其设置为true允许我们在每次创建新实例时构建一个新的CustomPainter。我们正在为<code class="fe mt mu mv mw b">animation.value</code>中的每一个新刻度创建一个新实例。</p><p id="2c83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是整个动画的最终代码—</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="nf lp l"/></div></figure><blockquote class="nj"><p id="32c0" class="nk nl iq bd nm nn no np nq nr ns kv dk translated">非常感谢您阅读这篇文章。我会鼓励你用不同的方法来构建它，或者用你从中学到的东西来构建其他东西。☕ <br/>请在评论中分享你的想法和建议。我会试着每周发表一篇新文章。下次见。🤓<br/>到那时，快乐飘飘。🍺</p></blockquote></div></div>    
</body>
</html>