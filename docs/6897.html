<html>
<head>
<title>Certificate Management for On-premises Cloud-Native Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">本地云原生应用的证书管理</h1>
<blockquote>原文：<a href="https://itnext.io/certificate-management-for-on-premises-cloud-native-apps-dbca82e3c405?source=collection_archive---------0-----------------------#2022-04-07">https://itnext.io/certificate-management-for-on-premises-cloud-native-apps-dbca82e3c405?source=collection_archive---------0-----------------------#2022-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/baabdade5f2f9e4cf44739798a74c01c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y1XmGDGIrhDdlovwZ8daWQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片来自<a class="ae kf" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3037639" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><p id="ef4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本地应用的HTTPS/TLS证书传统上是集中管理的。若要在企业环境中为您的应用获取证书，您需要创建一个证书签名请求，将其提交给证书颁发机构进行签名，然后取回您的证书。通常都很繁琐耗时。不要忘记证书快到期时需要更新，同样的过程需要再次重复。</p><p id="d682" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当采用微服务架构时，这种方法根本无法处理管理所有的证书请求及其更新过程。本文探讨了如何将<a class="ae kf" href="https://cert-manager.io" rel="noopener ugc nofollow" target="_blank">证书管理器</a>用于内部kubernetes应用程序来管理它们的证书生命周期。</p><h2 id="8072" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">证书管理器管理的证书</h2><p id="6649" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">下图显示了我们如何使用cert-manager来管理证书。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/64d93f9e05f6739a9dfff601651e6b5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*Qc-AxF2k9T5Q-QoYxd_bTg.png"/></div></figure><p id="1e95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">按照企业中的典型设置，我们将有根CA和中间CA。使用中间CA创建ClusterIssuer资源。收到证书请求后，集群颁发者资源将创建并签署证书，并将其存储为K8s秘密。然后可以将证书安装到pod上，供应用程序使用。证书管理器监视证书的到期，并在它到期之前更新它。</p><p id="ff66" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们来设置一下。我的测试环境是OpenShift 4.10。证书管理器的安装被跳过，因为在我的例子中，证书管理器已经被其他软件引入。总之，安装简单明了。</p><h2 id="cb09" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">根CA和中间CA</h2><p id="2e57" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">首先，使用<a class="ae kf" href="https://github.com/cloudflare/cfssl" rel="noopener ugc nofollow" target="_blank"> cfssl </a>创建根CA和一个中间CA。</p><p id="f1d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">准备以下myca.json文件，</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="50f6" class="le lf it mi b gy mm mn l mo mp">{<br/>  "CN": "myca",<br/>  "hosts": [ "myca" ],<br/>  "key": {<br/>    "algo": "rsa",<br/>    "size": 4096<br/>  },<br/>  "names": [<br/>    {<br/>      "C": "SG",<br/>      "ST": "SG",<br/>      "L": "Singapore"<br/>    }<br/>  ]<br/>}</span></pre><p id="ea0c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建根CA，</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="0626" class="le lf it mi b gy mm mn l mo mp">cfssl gencert -initca myca.json | cfssljson -bare myca</span></pre><p id="304f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经创建了<code class="fe mq mr ms mi b">myca.pem</code>(证书)和<code class="fe mq mr ms mi b">myca-key.pem</code>(密钥)文件。</p><p id="a27c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建以下JSON文件ca-config.json，以定义不同的概要文件，</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="5211" class="le lf it mi b gy mm mn l mo mp">{<br/>  "signing": {<br/>    "default": {<br/>        "expiry": "43800h"<br/>    },<br/>    "profiles": {<br/>      "server": {<br/>        "expiry": "43800h",<br/>        "usages": [<br/>          "signing",<br/>          "key encipherment",<br/>          "server auth",<br/>          "client auth"<br/>        ]<br/>      },<br/>      "client": {<br/>          "expiry": "43800h",<br/>          "usages": [<br/>            "signing",<br/>            "key encipherment",<br/>            "client auth"<br/>          ]<br/>      },<br/>      "<strong class="mi iu">intermediate</strong>": {<br/>        "usages": ["cert sign", "crl sign"],<br/>        "expiry": "43800h",<br/>        "ca_constraint": {<br/>          "is_ca": true,<br/>          "max_path_len": 0,<br/>          "max_path_len_zero": true<br/>        }<br/>      }<br/>      }<br/>  }<br/>}</span></pre><p id="82fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建中间证书JSON文件intermediate-ca.json，如下所示，</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="ca4c" class="le lf it mi b gy mm mn l mo mp">{<br/>  "CN": "intermediate-ca",<br/>  "hosts": [ "intermediate-ca" ],<br/>  "key": {<br/>    "algo": "rsa",<br/>    "size": 4096<br/>  }<br/>}</span></pre><p id="38b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用以下命令创建由根CA签名的中间CA，</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="47cd" class="le lf it mi b gy mm mn l mo mp">cfssl gencert -ca=myca.pem -ca-key=myca-key.pem -config=ca-config.json -profile=intermediate -hostname=intermediate-ca intermediate-ca.json | cfssljson -bare intermediate-ca</span></pre><p id="3ae6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用ca-config.json文件中定义的中间概要文件来创建中间证书。创建证书后，检查证书及其扩展名的详细信息，</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mt"><img src="../Images/a0b6dbfed99c0804911f4aecad14742a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mBzCM-H9gJUiLUyaXRcRzQ.png"/></div></div></figure><p id="c62a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它是由根证书签名的CA证书。路径长度约束为0，因此它将无法创建任何子CA。</p><h2 id="0fa1" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">设置发行者</h2><p id="4e92" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">通过检查cert-manager-controller pod的命令行参数<code class="fe mq mr ms mi b">cluster-resource-namespace</code>，确定cert-manager设置为群集资源名称空间的名称空间。否则，使用默认名称空间“cert-manager”</p><p id="c3b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建一个TLS secret来保存证书(中间证书和根证书)以及中间CA的密钥。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="11e7" class="le lf it mi b gy mm mn l mo mp">cat intermediate-ca.pem myca.pem &gt; my-ca-chain.pem</span><span id="f0ff" class="le lf it mi b gy mu mn l mo mp">kubectl create secret tls my-ca-chain --cert=my-ca-chain.pem --key=intermediate-ca-key.pem</span></pre><p id="e8c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用此机密创建一个带有CA的ClusterIssuer，</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="f219" class="le lf it mi b gy mm mn l mo mp">apiVersion: cert-manager.io/v1<br/>kind: ClusterIssuer<br/>metadata:<br/>  name: ca-issuer<br/>spec:<br/>  ca:<br/>    secretName: my-ca-chain</span></pre><p id="99ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">颁发者准备好根据请求创建证书。</p><h2 id="2891" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">测试应用程序</h2><p id="16b8" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">让我们创建一个玩具测试应用程序，</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="cffd" class="le lf it mi b gy mm mn l mo mp">package main</span><span id="ace0" class="le lf it mi b gy mu mn l mo mp">import (<br/> "fmt"<br/> "log"<br/> "net/http"<br/> "os"<br/> "time"<br/>)</span><span id="3911" class="le lf it mi b gy mu mn l mo mp">func greet(w http.ResponseWriter, r *http.Request) {<br/> fmt.Fprintf(w, "Hello World! %s", time.Now())<br/>}</span><span id="fc1f" class="le lf it mi b gy mu mn l mo mp">func main() {<br/> http.HandleFunc("/", greet)<br/> port := os.Getenv("APP_PORT")<br/> if port == "" {<br/>  port = "8443"<br/> }</span><span id="ca7b" class="le lf it mi b gy mu mn l mo mp"> certFile := os.Getenv("APP_CERT_FILE")<br/> keyFile := os.Getenv("APP_KEY_FILE")</span><span id="cf7a" class="le lf it mi b gy mu mn l mo mp"> err := http.ListenAndServeTLS(":"+port, certFile, keyFile, nil)<br/> if err != nil {<br/>  log.Fatalf("Could not start server: %v", err)<br/> }<br/>}</span></pre><p id="6f18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将为应用程序提供证书及其配对的密钥文件。</p><p id="5241" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">构建映像并将其推入私有注册表。使用以下YAML部署它，</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="8237" class="le lf it mi b gy mm mn l mo mp">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: app<br/>  labels:<br/>    app: app<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: app<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: app<br/>    spec:<br/>      containers:<br/>      - name: app<br/>        image: image-registry.openshift-image-registry.svc:5000/cert-demo-onprem/app:v1.0<br/>        ports:<br/>        - containerPort: 8443<br/>        env:<br/>        - name: APP_PORT<br/>          value: "8443"<br/>        - name: APP_CERT_FILE<br/>          value: /certs/tls.crt<br/>        - name: APP_KEY_FILE<br/>          value: /certs/tls.key<br/>        volumeMounts:<br/>        - name: cert<br/>          mountPath: /certs<br/>      volumes:<br/>      - name: cert<br/>        secret:<br/>          secretName: myapp-tls</span></pre><p id="f33d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">证书是从一个名为<code class="fe mq mr ms mi b">myapp-tls</code>的秘密中挂载的，这个秘密将由证书管理器自动创建。</p><h2 id="d26b" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">证书</h2><p id="3997" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">创建以下证书资源YAML，</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="f90e" class="le lf it mi b gy mm mn l mo mp">apiVersion: cert-manager.io/v1<br/>kind: Certificate<br/>metadata:<br/>  name: myapp<br/>  namespace: cert-demo-onprem<br/>spec:<br/>  secretName: myapp-tls<br/>  dnsNames:<br/>    - myapp-service.cert-demo-onprem.svc<br/>    - myapp-cert-demo-onprem.apps.dev-ocp410.ibmcloud.io.cpak<br/>  issuerRef:<br/>    name: ca-issuer<br/>    kind: ClusterIssuer</span></pre><p id="79e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">dnsName是要包含在证书中的SAN条目。(<em class="mv">我按照OpenShift路由名称模式给出DNS名称</em>)。定义指向所创建的集群发布者的issuerRef。secretName是由证书管理器控制器创建的机密的名称。</p><p id="3149" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">应用它并观察在目标名称空间中创建的秘密。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="b4af" class="le lf it mi b gy mm mn l mo mp">$ oc get certificate<br/>NAME    READY   SECRET      AGE   EXPIRATION<br/>myapp   True    myapp-tls   36h   2022-07-06T02:22:34Z</span><span id="8020" class="le lf it mi b gy mu mn l mo mp">$ oc describe secret myapp-tls<br/>Name:         myapp-tls<br/>Namespace:    cert-demo-onprem<br/>Labels:       &lt;none&gt;<br/>Annotations:  cert-manager.io/alt-names: myapp-service.cert-demo-onprem.svc,myapp-cert-demo-onprem,myapp-cert-demo-onprem.apps.dev-ocp410.ibmcloud.io.cpak<br/>              cert-manager.io/certificate-name: myapp<br/>              cert-manager.io/common-name:<br/>              cert-manager.io/ip-sans:<br/>              cert-manager.io/issuer-group:<br/>              cert-manager.io/issuer-kind: ClusterIssuer<br/>              cert-manager.io/issuer-name: ca-issuer<br/>              cert-manager.io/uri-sans:</span><span id="fcf4" class="le lf it mi b gy mu mn l mo mp">Type:  kubernetes.io/tls</span><span id="9ab2" class="le lf it mi b gy mu mn l mo mp">Data<br/>====<br/>ca.crt:   1895 bytes<br/>tls.crt:  3489 bytes<br/>tls.key:  1679 bytes</span></pre><p id="88c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦创建了秘密，应用程序的部署就可以正常运行了。tls.crt是证书和它的singing CA cert。ca.crt是根ca证书。tls.key是证书的配对密钥。一旦秘密被装载到pod上，这些文件就可供应用程序获取了。</p><h2 id="f0b6" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">测试</h2><p id="c460" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">创建K8s服务来公开应用程序，</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="11ca" class="le lf it mi b gy mm mn l mo mp">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: myapp-service<br/>  namespace: cert-demo-onprem<br/>spec:<br/>  selector:<br/>    app: myapp<br/>  ports:<br/>    - protocol: TCP<br/>      port: 8443<br/>      targetPort: 8443</span></pre><p id="c01c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后创建一个OpenShift路径来访问应用程序。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="57a0" class="le lf it mi b gy mm mn l mo mp">oc create route passthrough myapp --service=myapp-service</span></pre><p id="232d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将创建一个直通路由，以便由证书管理器创建的证书将直接服务于该请求。主机名URL创建如下，当我们创建证书资源YAML时，它被用作dnsName。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="29c9" class="le lf it mi b gy mm mn l mo mp">myapp-cert-demo-onprem.apps.dev-ocp410.ibmcloud.io.cpak</span></pre><p id="841e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">启动浏览器以验证应用程序和证书是否正常工作。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mw"><img src="../Images/613c62dc07fcc2ce6df46311061e78d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hiL2BHLNEGyBt2ooLZ3sNw.png"/></div></div></figure><p id="be76" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们对证书做进一步的检查，<code class="fe mq mr ms mi b">oc describe certificate myapp</code>我们将会看到证书将会在过期之前被更新(默认情况下，是在证书有效期的2/3时)</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="347e" class="le lf it mi b gy mm mn l mo mp">...<br/>Status:<br/>  Conditions:<br/>    Last Transition Time:  2022-04-07T02:22:36Z<br/>    Message:               Certificate is up to date and has not expired<br/>    Observed Generation:   3<br/>    Reason:                Ready<br/>    Status:                True<br/>    Type:                  Ready<br/>  Not After:               2022-07-06T02:22:34Z<br/>  Not Before:              2022-04-07T02:22:34Z<br/>  Renewal Time:            2022-06-06T02:22:34Z</span></pre><h2 id="d608" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">结论</h2><p id="c3e0" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">Cert-manager自动管理证书生命周期。它极大地减少了从证书申请、签名、分发到续订的手动工作。</p></div></div>    
</body>
</html>