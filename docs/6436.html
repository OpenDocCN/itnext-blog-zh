<html>
<head>
<title>Coroutines, Distributed Cache, Resilience, and Replication in Kotlin — Making a VMA’s application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin中的协程、分布式缓存、弹性和复制——制作VMA的应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/coroutines-distributed-cache-resilience-and-replication-in-kotlin-making-a-vmas-application-df563edf8fe8?source=collection_archive---------1-----------------------#2021-11-16">https://itnext.io/coroutines-distributed-cache-resilience-and-replication-in-kotlin-making-a-vmas-application-df563edf8fe8?source=collection_archive---------1-----------------------#2021-11-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/791da54286bb3454a010081561e442fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GZjyW0OgWX8GqtI6cQ029g.png"/></div></div></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="9077" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di"/><strong class="kk iu">协程</strong>是一个至少从1958年就已经存在的概念。它是由Melvin Conway提出的，本质上意味着我们可以从一个线程中创建并执行协程。<strong class="kk iu">协程</strong>可以像线程一样暂停和恢复，但最重要的区别是线程创建自己的上下文，而协程<strong class="kk iu">使用线程上下文</strong>并可以与其他线程同时运行。从技术上讲，这不是并行运行。相反，他们被视为只是免费运行。协同程序还可以在运行时切换上下文，并使用另一个<strong class="kk iu">线程上下文</strong>。这被称为<strong class="kk iu">协同多任务</strong>。虽然这是一个非常古老的概念，但它目前与我们如何进行反应式编程非常相关。原因在于，通过允许协程利用上下文并同时从一个上下文切换到另一个上下文，系统可以在运行时执行更好的优化。这反过来意味着更有效地使用内存和CPU。</p><p id="72ab" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">从大约4年前开始，Kotlinx的团队就一直忙于重新引入这种范式。</p><p id="eae8" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在像往常一样进入<a class="ae lp" href="https://github.com/jesperancinha/vma-archiver" rel="noopener ugc nofollow" target="_blank">示例</a>之前，我想先讨论一下我们要看的概念。我们构建应用程序的方式必须考虑诸如<strong class="kk iu">可伸缩性</strong>、<strong class="kk iu">弹性</strong>、<strong class="kk iu">反应性</strong>、<strong class="kk iu">容量</strong>和<strong class="kk iu">性能、</strong>等等概念。</p><p id="2f29" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">协程非常神奇，但并不是万能的。因此，我们需要意识到，当我们决定使用它们时，我们知道我们在谈论什么。</p><p id="672e" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在我们将要看到的<a class="ae lp" href="https://github.com/jesperancinha/vma-archiver" rel="noopener ugc nofollow" target="_blank">项目</a>中，我尽了最大努力<strong class="kk iu">不发明轮子，</strong>但是我也必须确保有足够的逻辑来解释在<strong class="kk iu">现实世界项目</strong>中使用<strong class="kk iu">协程</strong>的重要概念。现在，让我们简短地分析一下我们想要调查什么以及期望什么。</p><h1 id="7f14" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">1.一个解决方案</h1><p id="d521" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated">当考虑可伸缩性时，我们希望确保我们的应用程序能够支持我们系统的弹性，能够支持我们原始资源的任何扩展。我们应该能够增加<strong class="kk iu">内存</strong>和<strong class="kk iu"> CPU </strong>，而不必对我们的应用程序进行修改。否则，我们的应用程序就会被认为是僵化的，很难维护。容器允许我们定义可以给应用程序多少资源。</p><p id="9820" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在我们使用<strong class="kk iu">容器</strong>和一些应用技巧来最大化资源用户的效率。<strong class="kk iu">反应式编程</strong>在这方面很有帮助，我们将会看到它如何与<strong class="kk iu">协程</strong>相结合来获得更好的结果。</p><p id="f3cf" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">对于像我们将要看到的这样的应用程序，我们需要提供一种方法来扩大我们可以支持的流量。每个容器只能支持这么多流量。通常，市场上实现更好的系统升级的一个很好的解决方案是使用<strong class="kk iu">负载平衡器</strong>。它们的伟大之处在于，它们不仅可以分配负载，而且如果我们的应用程序的一个实例失败了，它可以立即切换到下一个可用的实例。通过这样做，我们确保我们的应用程序变得不可用的可能性大大降低，直到它变得完全不重要。这样，我们就接近了一个高度可用的应用程序。这些通常被称为<strong class="kk iu">高可用性负载平衡器</strong>。</p><p id="98ca" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">想到这一点后，我们立即面临的另一件事是，如果我们想使用<strong class="kk iu">缓存</strong>，我们会受到这种方式的限制。引入<strong class="kk iu">缓存</strong>意味着我们引入状态，如果我们引入状态，意味着我们所有的副本需要共享相同的状态。这就是分布式缓存系统如<strong class="kk iu"> Hazelcast </strong>和<strong class="kk iu"> Reddis </strong>发挥作用的地方。如果我们在每台机器上创建一个缓存实例，并允许它将自己绑定到一个由所有缓存实例组成的集群，我们就可以保证在每次更新时在所有实例之间共享该状态。就像负载平衡器一样，我们可以微调分布式缓存系统来满足我们的日常需求。</p><p id="87d4" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">同样，我们有应用程序负载平衡器，也可以有数据库负载平衡器。在这种情况下，我们可以设计一个只读数据库集群和一个只写数据库集群。如果我们实现了写和读操作的完全分离，那么对数据库的请求进行负载平衡并确保避免不一致就变得容易多了。我们可以实现一个<strong class="kk iu"> CQRS </strong>(命令查询请求分离)一样的实现。</p><p id="58ba" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在我们的例子中，我们还会看到在某个时候我们需要高可用性。尽管使用协同程序和<strong class="kk iu"> R2DBC </strong>反应式库的反应式编程确实有助于使我们的应用程序更加<strong class="kk iu">反应式</strong>，并且通过这种方式<strong class="kk iu">变得更加快速可用</strong>，但是正如前面提到的，这并不是解决所有问题的方法。如果我们收到大量的请求，反应式系统仍然会面临容量问题。也就是说，<strong class="kk iu">正在进行的进程</strong>的数量可能会迅速增加，因此我们希望确保在某些情况下不会处理任何东西。在这些情况下，我们只想注册一个请求，让系统在后台处理它们。我们仍然让我们的应用程序是反应式的，但是用户将得到一个不同于典型的<strong class="kk iu"> ok </strong>的响应。相反，用户得到请求正在进行的响应。</p><h1 id="3e6b" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">2.案例解释</h1><p id="107e" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated">在我们进入图表之前，让我们先看看我们的目标。想要创建一个投票系统来支持<strong class="kk iu"> VMA的</strong> ( <strong class="kk iu"> MTV的音乐录影带大奖</strong>)。任何一种VMA氏症。像这样的奖项总是不同的，每年，类别可能会发生变化。例如，2020年首次出现了与流行病相关的奖项。我们希望能够使奖项类别尽可能地动态化。对于<strong class="kk iu"> MVP </strong> ( <strong class="kk iu">最低可行产品</strong>)或<strong class="kk iu"> POC </strong> ( <strong class="kk iu">概念验证</strong>)，无论我们能尽快做出什么<strong class="kk iu"/>，我们都希望投票者能够在不同的类别中为他们最喜爱的艺术家或歌曲投票。对于我们的需求列表，我们希望进一步了解</p><ul class=""><li id="a1d9" class="mt mu it kk b kl km kp kq kt mv kx mw lb mx lf my mz na nb bi translated">投票应该被计算在内，并且应该按照用户Id在一个表格上进行登记。</li><li id="7e71" class="mt mu it kk b kl nc kp nd kt ne kx nf lb ng lf my mz na nb bi translated">每个用户只能注册<strong class="kk iu">一次投票。</strong></li><li id="c7f2" class="mt mu it kk b kl nc kp nd kt ne kx nf lb ng lf my mz na nb bi translated"><strong class="kk iu">异常处理，在这种情况下，</strong>并不重要，只要相关异常出现在<strong class="kk iu">日志</strong>中。</li><li id="8f1e" class="mt mu it kk b kl nc kp nd kt ne kx nf lb ng lf my mz na nb bi translated">艺术家和歌曲可能会获得<strong class="kk iu">额外投票</strong>，但这一票将只给予类别中的艺术家，而不管用户投票。</li><li id="be5b" class="mt mu it kk b kl nc kp nd kt ne kx nf lb ng lf my mz na nb bi translated">额外的投票将根据<strong class="kk iu">乐观锁定算法</strong>给出。实际上，为了获得额外的投票，协程将从数据库中读取数据，添加一票并尝试保存它。如果在此期间发生了来自另一个用户的保存，那么应该抛出一个异常。</li><li id="b263" class="mt mu it kk b kl nc kp nd kt ne kx nf lb ng lf my mz na nb bi translated">在投票过程结束时，甚至在投票过程中，总票数应计为投票表中的行数和成功给出的额外票数的<strong class="kk iu">之和。</strong></li><li id="f841" class="mt mu it kk b kl nc kp nd kt ne kx nf lb ng lf my mz na nb bi translated">获胜者应该很容易在<strong class="kk iu">结果页面</strong>上查看</li><li id="5dc8" class="mt mu it kk b kl nc kp nd kt ne kx nf lb ng lf my mz na nb bi translated">为了让<strong class="kk iu"> PO </strong> ( <strong class="kk iu">产品负责人</strong>)理解<strong class="kk iu">背景</strong>，应该构建一个<strong class="kk iu">前端页面</strong>来给出每个用户会发生什么的感觉</li><li id="8617" class="mt mu it kk b kl nc kp nd kt ne kx nf lb ng lf my mz na nb bi translated"><strong class="kk iu">安全</strong>对于演示来说<strong class="kk iu">不是必需的</strong></li><li id="5ee7" class="mt mu it kk b kl nc kp nd kt ne kx nf lb ng lf my mz na nb bi translated"><strong class="kk iu">演示需要高可用性</strong>。除了<strong class="kk iu">落选的多余票</strong>外，其他票都不应丢失。</li><li id="052d" class="mt mu it kk b kl nc kp nd kt ne kx nf lb ng lf my mz na nb bi translated">整个系统应该支持高投票率。最终产品设定为<strong class="kk iu">全球通用</strong>。</li></ul><p id="9a14" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">就像我们得到的任何第一个需求列表一样，这些需求中的一些一开始可能很难理解或阅读，但是有这样的背景是很重要的。正是基于这种特殊的投票系统及其工作方式，我们将实施我们的解决方案。</p><h1 id="03bb" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><strong class="ak"> 3。第一张草图和示意图</strong></h1><p id="e48a" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated">为了理解我们将要实现的内容，让我们先来看看下面的图表，并花几分钟时间来理解它。仔细看看所有被描述和描绘的东西。然后，我们将从左到右对每一个架构部分进行分析。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/8c20d38f7d6c8e5df87307319abe0fa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kv3e4-RcOkipTzvyf5xYXQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">一般系统概述</figcaption></figure><p id="d19e" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">从左到右，我们可以看到我们的应用程序需要4个部分。我所创建的组是基于我们系统所必需的4个元素。</p><p id="f1e6" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如上所述，我们需要一个应用程序和一个面向前端的应用程序。在我们的示例中，我们使用一个角度应用程序和两个反应式服务来实现这一点。Ngnix为两个反应式应用程序副本提供角度应用程序和负载平衡请求。我们将进一步看到添加了一个名为<strong class="kk iu"> Hazelcast </strong>的额外元素，这是创建分布式缓存集群的一种非常方便快捷的方式。这包括<strong class="kk iu">应用部分</strong>。</p><p id="d6fb" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">为了注册我们的投票，但不处理它们，我们需要某种流框架。在这种情况下，我选择了卡夫卡。不仅如此，在这种情况下，我们还将使用<strong class="kk iu"> Avro串行器。</strong>我们将进一步了解这是如何使用的，以及当我们希望通过流序列化对象时，这可能会有什么帮助。这是<strong class="kk iu">流媒体部分。</strong></p><p id="70ce" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在<strong class="kk iu">监听器部分</strong>，我们将使用2个spring boot反应服务。反应式流程不是作为一个集群工作的。相反，他们只是信息流的两个消费者。有两个会有帮助。这样，我们可以更快地处理流上的请求，并且它提供了一个<strong class="kk iu">故障安全机制</strong>。</p><p id="66a9" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">最后，为了提供<strong class="kk iu">数据库集群部分</strong>，纯粹因为我们想在本地运行所有这些，我们将利用<strong class="kk iu"> Patroni </strong>，以便允许我们的数据库启动通过<strong class="kk iu"> Etcd </strong>加入两个<strong class="kk iu"> PostgreSQL </strong>集群。</p><h1 id="3f16" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">4.关注这些部分</h1><p id="8d76" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">正如我们在上面看到的</span>，我们有不同的部分，它们的实现非常详细。通过概述，我们已经看到了构建该架构所涉及的所有部分。现在，我们将详细了解一下这些实现。我们将看到代码，它是如何实现的，以及它提供了什么。这个项目的所有参与者都可以通过端口映射到外部，但是我们只对通过端口<strong class="kk iu"> 8080 </strong>发送请求感兴趣，然后这些请求被<strong class="kk iu"> NGINX </strong>重新路由到适当的服务。</p><p id="df6e" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">理解这一点也很重要，尽管本文包含了很多技术，但重点是展示一些使用带有协程的反应式编程的应用程序。因此，提到我们将要使用的库也是非常重要的。</p><p id="f268" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">对于协程，我们使用:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="31ab" class="nv lr it nr b gy nw nx l ny nz">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.jetbrains.kotlinx&lt;/groupId&gt;<br/>    &lt;artifactId&gt;kotlinx-coroutines-reactor&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.jetbrains.kotlinx&lt;/groupId&gt;<br/>    &lt;artifactId&gt;kotlinx-coroutines-core&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.jetbrains.kotlinx&lt;/groupId&gt;<br/>    &lt;artifactId&gt;kotlinx-coroutines-core-jvm&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="2b65" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">对于卡夫卡，我们使用:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="3e50" class="nv lr it nr b gy nw nx l ny nz">&lt;dependency&gt;<br/>    &lt;groupId&gt;io.projectreactor.kafka&lt;/groupId&gt;<br/>    &lt;artifactId&gt;reactor-kafka&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="8309" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">对于我们正在使用的Avro串行器:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="ba5b" class="nv lr it nr b gy nw nx l ny nz">&lt;dependency&gt;<br/>    &lt;groupId&gt;io.confluent&lt;/groupId&gt;<br/>    &lt;artifactId&gt;kafka-avro-serializer&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.apache.avro&lt;/groupId&gt;<br/>    &lt;artifactId&gt;avro&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="2001" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">对于Hazelcast，我们使用:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="e0b1" class="nv lr it nr b gy nw nx l ny nz">&lt;dependency&gt;<br/>    &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;<br/>    &lt;artifactId&gt;hazelcast&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="b677" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">还有运行Spring Boot所需的所有库、存储库、rest方法和服务等等。这些都是标准，超出了本文的范围。</p><h1 id="7c47" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">4.1.应用部分</h1><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/3272f6aedbe9f1dbfa1890b21d6e4376.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*00FmaADMj5SsJJRLDXIiSQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">应用程序与流部分的交互</figcaption></figure><p id="d087" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">在</span>应用中我们将看到一个前端应用在<strong class="kk iu"> Angular </strong>中。该应用程序通过<strong class="kk iu"> NGINX </strong>直接提供服务。此外，我们将<strong class="kk iu"> NGINX </strong>配置为在另外两个弹簧引导进程之间进行负载平衡。这是通过以下方式实现inf NGINX来实现的:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="bedf" class="nv lr it nr b gy nw nx l ny nz">server {<br/>    listen 8080;<br/>    listen [::]:8080;<br/><br/>    root /usr/share/nginx/html;<br/><br/>    server_name _;<br/><br/>    location / {<br/>        root   /usr/share/nginx/html;<br/>        try_files $uri $uri/ /index.html?$args;<br/>    }<br/><br/>    location /result {<br/>        root   /usr/share/nginx/html;<br/>        try_files $uri $uri/ /index.html?$args;<br/>    }<br/><br/>    location /api/vma/ {<br/>     proxy_pass http://apps;<br/>    }<br/><br/>    location /api/vma/broker {<br/>      proxy_pass http://apps;<br/>      proxy_http_version 1.1;<br/>      proxy_set_header Upgrade $http_upgrade;<br/>      proxy_set_header Connection "upgrade";<br/>      proxy_set_header Host $http_host;<br/>      proxy_set_header Access-Control-Allow-Origin 192.168.0.120;<br/>      proxy_set_header X-Real-IP $remote_addr;<br/>      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br/>      proxy_set_header X-NginX-Proxy true;<br/>    }<br/><br/>}</span></pre><p id="49a7" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这个实现中，我们看到了一些重要的配置。所有根流量都被重定向到<strong class="kk iu"> /usr/share/nginx </strong>文件夹。我们应用程序的所有代码都将驻留在那里。对于所有的API路由，我们使用一个<strong class="kk iu"> proxy_pass </strong>，它负责将流量转移到<strong class="kk iu"> http//:apps </strong>。这个网址不是一个真正的普通网址。而是被NGINX认定为上游。我们有两条重新路由路径。一个重路由<strong class="kk iu"> /api/vma </strong>，另一个重路由<strong class="kk iu"> /api/vma/broker </strong>。第一个为<strong class="kk iu"> REST </strong>服务调用将流量重定向到一个实例。后者将入站和出站重新路由到实例<strong class="kk iu"> websockets </strong>。这就是我们在前端不断更新应用程序的方式:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="957c" class="nv lr it nr b gy nw nx l ny nz">http {<br/><br/>    upstream apps {<br/>        server 192.168.0.21:8081;<br/>        server 192.168.0.22:8082;</span><span id="e144" class="nv lr it nr b gy ob nx l ny nz">    }<br/>...</span><span id="0a74" class="nv lr it nr b gy ob nx l ny nz">}</span></pre><p id="00d6" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">既然我们已经了解了负载平衡是如何在应用程序级别上使用<strong class="kk iu"> NGINX </strong>工作的，那么现在让我们来看看协程实际上是如何工作的。在继续之前，回顾一下协程到底是什么和不是什么可能是个好主意。协程不是线程。它们使用并可以共享线程上下文。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/45697108ec1a1693b4270bbb4b415c14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I5cZjQjbFurq9WD4hEHm3w.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">协程过于简单</figcaption></figure><p id="e12d" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">上图与代码没有直接关系。我想展示的是协程是通过使用一个协程上下文来工作的，这个上下文是由我们决定它应该运行的线程给出的。我们可以用<strong class="kk iu"> <em class="od"> launch </em> </strong>以编程方式启动一个协同计算，并为它决定一个在第一个参数上运行的上下文。我们经常想决定哪个线程对完成这项工作是重要的。我们也可以决定一个新的上下文来运行代码块，例如<strong class="kk iu"> <em class="od">和</em> </strong>上下文。但是上下文是不变的。这意味着我们不能改变协程最初运行的上下文。我们可以让它切换上下文，但是协程仍然依赖于创建它的原始上下文，并且可以从该上下文中取消。</p><p id="96dc" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们的应用程序有很多以被动方式实现的REST方法。投票是通过使用POST请求来完成的，这些请求确保选票进入Kafka流。我们还有一个websocket代理，如前所述，它确保我们的应用程序得到实时更新。解释所有这些方法和实现投票系统背后的完整逻辑不是本文的目的。我们想了解协程是如何工作的，所以让我们开始吧。</p><p id="0244" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">一个很好的例子是<strong class="kk iu"><em class="od">registry controller</em></strong>类中的方法<strong class="kk iu"><em class="od">getCurrentVma</em></strong>:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="d111" class="nv lr it nr b gy nw nx l ny nz">@GetMapping("/current")<br/>fun getCurrentVma(@CookieValue("votingId") votingKey: String?): Flow&lt;CategoryDto&gt; =<br/>    categoryService.findAll(votingKey)</span></pre><p id="66f9" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这个例子中我们使用了协程<strong class="kk iu"> <em class="od">流</em> </strong>类。这个<strong class="kk iu"> <em class="od">流</em> </strong>是实现<strong class="kk iu"> <em class="od">类别到</em> </strong>的流动流的抽象。<strong class="kk iu"> <em class="od"> </em> </strong>这是一个<strong class="kk iu">数据传输对象</strong> (DTO)，代表奖项的类别。它包含类别的名称，候选人名单，投票完成后的获胜者，以及是否已被某个用户投票淘汰。在任何情况下，它提供了一个连续的流动。它<strong class="kk iu"> <em class="od">利用<strong class="kk iu"> <em class="od">发射器</em> </strong>收集</em> </strong>传入的数据。如果我们查看原始源代码，我们会发现:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="9235" class="nv lr it nr b gy nw nx l ny nz">package kotlinx.coroutines.flow<br/><br/>public interface FlowCollector&lt;in T&gt; {<br/>    public abstract suspend fun emit(value: T): kotlin.Unit<br/>}</span></pre><p id="30ad" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这里要认识到的重要一点是<strong class="kk iu"> <em class="od"> emit </em> </strong>是一个暂停函数抽象。单独使用<strong class="kk iu"> <em class="od"> suspend </em> </strong>意味着代码将作为协程运行，当前线程作为其线程上下文。在我们的例子中，我们让流中的这些协程在<strong class="kk iu"><em class="od"/></strong>主线程上下文中运行<strong class="kk iu"><em class="od"/></strong>。</p><p id="7d26" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">一个很好的例子是位于<strong class="kk iu"><em class="od">port controller</em></strong>类中的协程。这是<strong class="kk iu"><em class="od">getWelcomeMessage</em></strong>的功能:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="bdba" class="nv lr it nr b gy nw nx l ny nz">@GetMapping<br/>suspend fun getWelcomeMessage() =<br/>    "Welcome to the VMA Voting System Test App! This one is running on port $port"</span></pre><p id="54f0" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们简单地返回一个<strong class="kk iu"> <em class="od">字符串。我创建这个方法只是为了验证<strong class="kk iu"> NGINX </strong>的<strong class="kk iu">负载平衡</strong>功能。</em></strong></p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/26d24ffea010ce4756f8f21fbd99f57f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CBoXeiVGe23fhNDDOTeXBg.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">黑兹尔卡斯特星团</figcaption></figure><p id="8b80" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这个应用程序中，正如引言中提到的，我们需要缓存投票过程的进度。复制实例中的缓存也必须复制。一方必须知道另一方给予了什么，反之亦然。最简单的方法是使用一个带有<strong class="kk iu"> <em class="od">自动发现</em> </strong>的分布式缓存系统。在我们的示例中，我们使用了Hazelcast。我们使用Java实现替代方案，甚至不需要启动容器。为此，我们在两个实例上创建一个<strong class="kk iu"><em class="od">HazelcastInstance</em></strong>bean:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="5ebb" class="nv lr it nr b gy nw nx l ny nz">@Bean<br/>fun hazelcastInstance(): HazelcastInstance {<br/>    val worldConfig = Config();<br/>    worldConfig.<em class="od">clusterName </em>= "vma-world";<br/>    return Hazelcast.newHazelcastInstance(worldConfig)<br/>}</span></pre><p id="5096" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">然后我们可以在下面的例子中使用它:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="018d" class="nv lr it nr b gy nw nx l ny nz">private val cache: MutableMap&lt;String, VotingStatus&gt; = hazelcastInstance.getMap("vma-cache")</span></pre><p id="a88e" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">最后，我们通过以下方法将数据发送给kafka:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="3767" class="nv lr it nr b gy nw nx l ny nz">suspend fun publishArtistVote(key: String, artistVotingDto: ArtistVotingDto): Mono&lt;Void&gt; {<br/>     val producerRecord: ProducerRecord&lt;String, ArtistVotingDto&gt; =<br/>         ProducerRecord(kafkaConfigProperties.createArtistVoteRequestTopic, key, artistVotingDto)<br/><br/>     return voteArtistRequestRequestKafkaSender.createOutbound()<br/>         .send(Mono.just(producerRecord))<br/>         .then()<br/>         .doOnSuccess <strong class="nr iu">{ </strong>logger.info("Vote Created with id $key") <strong class="nr iu">}<br/> </strong>}</span></pre><p id="83c1" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这也是一种挂起方法。即使只是将物体放入<strong class="kk iu">卡夫卡</strong>流中，我们也希望以<strong class="kk iu">反应</strong>的方式完成。也许我们不会在一些请求上看到明显的差异，但是当同时发出许多请求时，我们应该会看到更多的请求被同时处理。在流中，我们将使用<strong class="kk iu"><em class="od">artistvodingto</em></strong>和<strong class="kk iu"><em class="od">songvodingto</em></strong>类型。我们aso使用一个<strong class="kk iu"> <em class="od">单声道</em> </strong>作为返回值。我们使用库<strong class="kk iu"> <em class="od">反应器——卡夫卡</em> </strong>进行所有<strong class="kk iu">卡夫卡</strong>的互动。</p><p id="97d4" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这个项目的所有方法要么是<strong class="kk iu"> <em class="od">暂停</em> </strong>要么是返回一个<strong class="kk iu"> <em class="od">流&lt;&gt;</em></strong>对象。这两者都保证了应用程序尽可能地可用，并且可以继续接收到来的请求。我们的应用程序变得无阻塞，负载均衡器的使用保证了我们获得良好的容错能力和弹性。负载平衡器与应用程序分离。如果担心负载平衡器本身的可用性，我们可以通过在系统中引入备份负载平衡器来轻松应对。因为缓存也是分布式的，所以这意味着所有的实例都必须关闭才能删除缓存。这意味着我们可以说在<strong class="kk iu">应用程序部分</strong>上可以有<strong class="kk iu">容错</strong>到<strong class="kk iu">负载平衡故障</strong>、<strong class="kk iu">应用程序故障</strong>和<strong class="kk iu">缓存故障</strong>。</p><h1 id="920a" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">4.2.溪流部分</h1><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi of"><img src="../Images/1229323f224ace2d1e863e3d744afa1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4YxCGyyzUrxpsGpoc93qrQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">流与监听器部分的交互</figcaption></figure><p id="7895" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">在</span>应用程序的这一部分，我们使用了3个不同的播放器。一个是端口<strong class="kk iu"> 2181 </strong>上的<strong class="kk iu"> Zookeeper </strong>，另一个是端口<strong class="kk iu"> 8088 </strong>上的<strong class="kk iu"> Avro可序列化对象</strong>的<strong class="kk iu">模式注册表</strong>，最后是端口<strong class="kk iu"> 29092 </strong>上的<strong class="kk iu"> Kafka broker </strong>或<strong class="kk iu"> Kafka流</strong>。我们在听众开始时创建两个主题，名称分别为<strong class="kk iu">create-artist-vote-request-topic</strong>和<strong class="kk iu">create-song-vote-request-topic</strong>。一个接收艺术家的投票，另一个接收歌曲的投票。Avro序列化器本身并不是一个需求，但是我发现加入它很有趣。Avro对象的示例可以在类的公共模块中找到:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="29b0" class="nv lr it nr b gy nw nx l ny nz">data class ArtistVotingDto(<br/>    val userId: String,<br/>    val idC: String,<br/>    val idA: String<br/>) : IndexedRecord {<br/>    override fun getSchema(): Schema =<br/>        SchemaBuilder.record("ArtistVotingDto")<br/>            .namespace("org.jesperancinha.vma.common.dto")<br/>            .fields()<br/>            .requiredString("userId")<br/>            .requiredString("idC")<br/>            .requiredString("idA")<br/>            .endRecord();<br/><br/>    override fun put(i: Int, v: Any?) {<br/>        <em class="od">println</em>("$i + $v")<br/>    }<br/><br/>    override fun get(i: Int) = when (i) {<br/>        0 -&gt; userId<br/>        1 -&gt; idC<br/>        2 -&gt; idA<br/>        else -&gt; ""<br/>    }<br/>}</span></pre><p id="5033" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这是我们创建一个简单的Avro对象的方法。乍看起来，这样做的好处是，我们不需要共享流中运行的类型。参数被索引并通过流发送。在接收端，我们会发现我们并不是在真正地选角。我们将最终只对给定的值进行转换。这非常类似于拆卸家具，用卡车装运，然后在目的地重新组装。结构不被维护，但值被维护。我们可以在最后重组元数据和数据。需要<strong class="kk iu">模式</strong> <strong class="kk iu">注册中心</strong> <strong class="kk iu">服务</strong>来保存主题模式，以保证发送消息的一致性。</p><p id="61cf" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在图中，我们看到被跟踪的卡夫卡经纪人。本地<strong class="kk iu"> Kafka </strong>消耗大量资源，所以我只使用了一个单独的<strong class="kk iu"> Kafka </strong> <strong class="kk iu"> broker </strong>，但是我们可以并且应该在生产中使用更多。</p><h1 id="6771" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">4.3.听众部分</h1><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/f1540ae4041a8156f022b74bb10f7ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JV01tdl0X-TXPsCO2MM3pw.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">监听器与数据库集群的交互</figcaption></figure><p id="7702" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated">听众部分由两个Spring Boot服务部门组成。如前所述，他们是卡夫卡流的消费者，默认情况下，他们属于同一个消费者群体。它们在端口<strong class="kk iu"> 9001 </strong>和端口<strong class="kk iu"> 9002 </strong>上运行。这不是必要的要求。我使用这些端口进行了一些测试。一旦数据被使用，它就会被重新创建并保存到数据库中。这是登记选票的地方。</p><p id="722f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在开始研究监听器数据模型如何工作之前，我们首先应该看看集群是如何实现的。对于这个集群，我使用了5个重要的参与者。我们需要一个端口<strong class="kk iu"> 5000 </strong>上的<strong class="kk iu"> HAProxy </strong>，一个端口<strong class="kk iu"> 2379 </strong>上的Etdc服务器，<strong class="kk iu"> Patroni </strong>启动模式应用于端口<strong class="kk iu"> 5432 </strong>上的三个数据库<strong class="kk iu"> PostgreSQL </strong>容器。<strong class="kk iu"> Etdc </strong>服务器作为集群管理工作。HAProxy 对此毫不知情。数据库通过<strong class="kk iu"> Patroni </strong>连接到<strong class="kk iu"> Etdc </strong>，通过HAProxy连接到数据库的连接由Etdc管理。如果你喜欢这种方式，<strong class="kk iu"> Etdc </strong>是被<strong class="kk iu"> Patroni屏蔽的数据库的协调器。</strong></p><p id="bcb9" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在监听器实现中，我们创建了一个监听器:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="a74e" class="nv lr it nr b gy nw nx l ny nz">@Bean<br/>private fun votingRequestListener(): Disposable {<br/>    return KafkaReceiver.create(receiverOptions)<br/>        .receive()<br/>        .concatMap <strong class="nr iu">{ </strong>record <strong class="nr iu">-&gt;<br/>            </strong>createVoteRequestHandler<br/>                .handleCreateVoteRequest(record.value())<br/>                .then(record.receiverOffset().commit())<br/>                .doOnError <strong class="nr iu">{<br/>                    </strong>logger.error(<br/>                        "Error while creating Vote",<br/>                        <strong class="nr iu">it<br/>                    </strong>)<br/>                <strong class="nr iu">}<br/>        }<br/>        </strong>.subscribe()<br/>}</span></pre><p id="cdc4" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">对于这个特定的例子，我们没有使用暂停功能。我们只是创建一个<strong class="kk iu"> <em class="od"> Bean </em> </strong>，它将在后台运行。由于我们使用的是<strong class="kk iu"> reactor-kafka </strong>库，我们需要确保out <strong class="kk iu"> <em class="od">事件处理程序</em> </strong>返回<strong class="kk iu"> Flux </strong>相关的反应对象:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="b2e7" class="nv lr it nr b gy nw nx l ny nz">fun handleCreateVoteRequest(request: Record): Mono&lt;Job&gt; {<br/>    return <em class="od">mono </em><strong class="nr iu">{<br/>        </strong>request.<em class="od">schema</em>.<em class="od">name</em>.<em class="od">let </em><strong class="nr iu">{ </strong>name <strong class="nr iu">-&gt;<br/>            </strong><em class="od">CoroutineScope</em>(<em class="od">IO</em>).<em class="od">launch </em><strong class="nr iu">{<br/>                </strong>when (name) {<br/>                    "ArtistVotingDto" -&gt; {<br/>                        val vote = VoteCategoryArtist(<br/>                            userId = request.get(0).toString(),<br/>                            idC = request.get(1).toString(),<br/>                            idA = request.get(2).toString()<br/>                        )<br/>                        votingCategoryArtistRepository.save(vote)<br/>                        val category = categoryArtistRepository.findByCategoryIdAndArtistId(vote.idC, vote.idA)<br/>                        categoryArtistRepository.save(<br/>                            category.copy(<br/>                                votes = category.votes + 1,<br/>                                updates = category.updates + 1<br/>                            )<br/>                        )<br/>                    }<br/>                    else -&gt; {<br/>                        val vote = VoteCategorySong(<br/>                            userId = request.get(0).toString(),<br/>                            idC = request.get(1).toString(),<br/>                            idS = request.get(2).toString()<br/>                        )<br/>                        votingCategorySongRepository.save(vote)<br/>                        val category = categorySongRepository.findByCategoryIdAndSongId(vote.idC, vote.idS)<br/>                        categorySongRepository.save(<br/>                            category.copy(<br/>                                votes = category.votes + 1,<br/>                                updates = category.updates + 1<br/>                            )<br/>                        )<br/><br/>                    }<br/>                }<br/>            <strong class="nr iu">}<br/>        }<br/>    }</strong>.doOnError <strong class="nr iu">{ </strong>logger.error("Exception while trying to create a new user", <strong class="nr iu">it</strong>) <strong class="nr iu">}<br/></strong>}</span></pre><p id="9ebc" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这个例子中，我们原则上不需要在IO线程上下文中启动协程。我把它作为一个例子添加进来，说明如何从我们选择的特定上下文中启动协程。在这种情况下，我们已经在<strong class="kk iu">发布者</strong>的<strong class="kk iu">反应上下文</strong>中运行我们的代码。在我们的例子中，这个发布者是<strong class="kk iu"> <em class="od">单声道&lt;作业&gt; </em>。作业</strong>，是在<strong class="kk iu"> <em class="od">启动期间创建的对象。下面是一个例子，说明我们如何在接收到事件时重新构造元数据和数据:</em></strong></p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="2408" class="nv lr it nr b gy nw nx l ny nz">val vote = VoteCategoryArtist(<br/>    userId = request.get(0).toString(),<br/>    idC = request.get(1).toString(),<br/>    idA = request.get(2).toString()<br/>)<br/>votingCategoryArtistRepository.save(vote)</span></pre><p id="b192" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在收到事件后，我们还尝试给予额外的投票:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="cae4" class="nv lr it nr b gy nw nx l ny nz">val category = categoryArtistRepository.findByCategoryIdAndArtistId(vote.idC, vote.idA)<br/>categoryArtistRepository.save(<br/>    category.copy(<br/>        votes = category.votes + 1,<br/>        updates = category.updates + 1<br/>    )<br/>)</span></pre><p id="cd5d" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这是一个尝试的原因，因为表实体是通过以下方式实现的:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="ec8d" class="nv lr it nr b gy nw nx l ny nz">@Table<br/>data class CategoryArtist(<br/>    @field: Id<br/>    val idCA: String = UUID.randomUUID().toString(),<br/>    val idC: String? = null,<br/>    val idA: String? = null,<br/>    val updates: Int = -1,<br/>    val votes: Long = 0,<br/>    val voteCount: Long = 0,<br/>    @field: Version<br/>    val version: Long? = null,<br/>) : Persistable&lt;String&gt; {<br/>    override fun getId(): String = idCA<br/>    override fun isNew(): Boolean = updates &lt; 0<br/>}</span></pre><p id="cef7" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这样做时，我们要确保在读取数据和将数据写入数据库的特定行之间不会发生更新。这仅通过使用<strong class="kk iu"><em class="od">@ field:Version</em></strong>注释来保证。这样做可以保证我上面提到的优化锁定机制处于活动状态。</p><p id="a913" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">以这种方式实现的监听器是被动的，在我们的例子中，我们还使用了协程和R2DBC。换句话说，这意味着大量的解耦，这意味着我们系统的所有运动部分都是相互独立的，根本不会相互阻碍。</p><h1 id="138a" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">4.4.数据库集群部分</h1><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/b4d7881db4cd2218e70de9506cbb160e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HxXkzfsex8bAgR2-Hv1Svw.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">应用部分直接数据库集群交互</figcaption></figure><p id="d9e5" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">没有这最后一部分，这个项目就不会有意思。这是我们与数据库交互的地方。在投票之前、期间和之后，查阅数据库中的数据极其重要。系统必须有足够的弹性来支持投票检查，并允许用户跟踪投票的进展。在真实的情况下，我们看不到正在进行的投票。通常会定期更新，我们实际上是从网站上读取投票总数。为了我们的练习，让我们假设我们真的想时不时地检查一下过载的数据库。我们不仅想让我们自己使用，也想让全世界同时使用这个应用程序的所有用户使用。为此，我们需要几个方法。我们将只检查一个用于<strong class="kk iu"> <em class="od">通量</em> </strong>和一个用于<strong class="kk iu"> <em class="od">暂停</em> </strong>，并看看它在<strong class="kk iu"> MVC </strong> <strong class="kk iu">设计</strong> <strong class="kk iu">模式</strong>的不同层中是如何工作的。</p><p id="f303" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们在代码中有一个<strong class="kk iu"> <em class="od"> GET </em> </strong>方法，它为我们提供了填充VMA投票页面所需的完整数据，位于<strong class="kk iu"><em class="od">registry controller</em></strong>:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="e648" class="nv lr it nr b gy nw nx l ny nz">@GetMapping("/current")<br/>fun getCurrentVma(@CookieValue("votingId") votingKey: String?): Flow&lt;CategoryDto&gt; =<br/>    categoryService.findAll(votingKey)</span></pre><p id="70be" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这个方法返回一个<strong class="kk iu"> <em class="od">类别到</em> </strong>的列表。这方面的代码是:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="0a54" class="nv lr it nr b gy nw nx l ny nz">data class CategoryDto(<br/>    val id: String? = null,<br/>    val category: String,<br/>    val type: CategoryType?,<br/>    val capacity: Int,<br/>    val artists: List&lt;ArtistDto&gt; = <em class="od">emptyList</em>(),<br/>    val songs: List&lt;SongDto&gt; = <em class="od">emptyList</em>(),<br/>    val voted: Boolean<br/>)</span></pre><p id="e6ac" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这个数据传输对象中，就像在许多其他对象中一样，我们可以找到许多转换扩展函数:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="5ad9" class="nv lr it nr b gy nw nx l ny nz">fun CategoryDto.toData(): Category = Category(<br/>    name = this.category,<br/>    capacity = this.capacity,<br/>    type = this.type<br/>)<br/><br/>val CategoryDto.<em class="od">toNewData</em>: Category<br/>    get() = Category(<br/>        name = this.category,<br/>        capacity = this.capacity,<br/>        updates = 0,<br/>        type = this.type<br/>    )<br/><br/>fun Category.toDto(): CategoryDto = CategoryDto(<br/>    id = this.<em class="od">id</em>,<br/>    category = this.name,<br/>    capacity = this.capacity,<br/>    type = this.type,<br/>    voted = false<br/>)<br/><br/>fun Category.toDtoWithArtistsAndVote(artists: List&lt;ArtistDto&gt;, voted: Boolean): CategoryDto = CategoryDto(<br/>    id = this.<em class="od">id</em>,<br/>    category = this.name,<br/>    capacity = this.capacity,<br/>    type = this.type,<br/>    artists = artists,<br/>    voted = voted<br/>)<br/><br/>fun Category.toDtoWithSongsAndVote(songs: List&lt;SongDto&gt;, voted: Boolean): CategoryDto = CategoryDto(<br/>    id = this.<em class="od">id</em>,<br/>    category = this.name,<br/>    capacity = this.capacity,<br/>    type = this.type,<br/>    songs = songs,<br/>    voted = voted<br/>)<br/><br/><br/>fun Category.toDtoWithArtists(artists: List&lt;ArtistDto&gt;): CategoryDto = CategoryDto(<br/>    id = this.<em class="od">id</em>,<br/>    category = this.name,<br/>    capacity = this.capacity,<br/>    type = this.type,<br/>    artists = artists,<br/>    voted = false<br/>)<br/><br/>fun Category.toDtoWithSongs(songs: List&lt;SongDto&gt;): CategoryDto = CategoryDto(<br/>    id = this.<em class="od">id</em>,<br/>    category = this.name,<br/>    capacity = this.capacity,<br/>    type = this.type,<br/>    songs = songs,<br/>    voted = false<br/>)</span></pre><p id="6832" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在我们的例子中，不一定需要转换，但重要的是要记住，在<strong class="kk iu">生产</strong> <strong class="kk iu">环境</strong>中，显示的数据不一定总是与数据库中的<strong class="kk iu">域</strong>模型匹配。我们也可能会发现<strong class="kk iu">混淆</strong> <strong class="kk iu"> Id的</strong>的系统。一般来说，最好不要将<strong class="kk iu">数据模型</strong>与<strong class="kk iu">表示层混合在一起。</strong></p><p id="c118" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">顺着控制器方法的线索，我们在位于<strong class="kk iu"> <em class="od"> Services.kt </em> </strong>脚本中的<strong class="kk iu"><em class="od">category service</em></strong>实现中找到了它的实现:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="c4c7" class="nv lr it nr b gy nw nx l ny nz">fun findAll(votingKey: String?): Flow&lt;CategoryDto&gt; {<br/>    return categoryRepository.findAll().<em class="od">map </em><strong class="nr iu">{ </strong>category <strong class="nr iu">-&gt;<br/>        </strong>when (category.type) {<br/>            <em class="od">ARTIST </em>-&gt; category.<em class="od">toDtoWithArtistsAndVote</em>(<br/>                artistService.findAll(<br/>                    categoryArtistRepository.findByCategoryId(category.<em class="od">id</em>).<em class="od">map </em><strong class="nr iu">{ </strong>e <strong class="nr iu">-&gt; </strong>e.idA <strong class="nr iu">}</strong>.<em class="od">filterNotNull</em>()<br/>                        .toList()<br/>                ).toList(), votingKey?.<em class="od">let </em><strong class="nr iu">{ </strong>cache[votingKey]?.votedOff?.contains(category.<em class="od">id</em>) <strong class="nr iu">} </strong>?: false<br/>            )<br/>            else -&gt; category.<em class="od">toDtoWithSongsAndVote</em>(<br/>                songService.findAll(<br/>                    categorySongRepository.findByCategoryId(category.<em class="od">id</em>).<em class="od">map </em><strong class="nr iu">{ </strong>e <strong class="nr iu">-&gt; </strong>e.idS <strong class="nr iu">}</strong>.<em class="od">filterNotNull</em>().toList()<br/>                ).toList(), votingKey?.<em class="od">let </em><strong class="nr iu">{ </strong>cache[votingKey]?.votedOff?.contains(category.<em class="od">id</em>) <strong class="nr iu">} </strong>?: false<br/>            )<br/>        }<br/>    <strong class="nr iu">}<br/></strong>}</span></pre><p id="edc9" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">实现本身有点复杂，因为它包含了前面提到的与<strong class="kk iu"> <em class="od"> Hazelcast </em> </strong>管理的状态相关联的业务逻辑。这里需要注意的是，我们使用了两个<strong class="kk iu">库</strong>和几个<strong class="kk iu">扩展函数</strong>。我们将重点介绍<strong class="kk iu"> <em class="od">类别和</em> </strong>:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="228e" class="nv lr it nr b gy nw nx l ny nz">@Repository<br/>interface CategoryArtistRepository : CoroutineCrudRepository&lt;CategoryArtist, String&gt; {<br/>    @Query("Select * from category_artist ca where ca.id_c=:idc")<br/>    fun findByCategoryId(@Param("idc") categoryId: String): Flow&lt;CategoryArtist&gt;<br/><br/>    @Query("Select * from category_artist ca where ca.id_c=:idc and ca.id_a=:ida")<br/>    suspend fun findByCategoryIdAndArtistId(<br/>        @Param("idc") categoryId: String,<br/>        @Param("ida") artistId: String<br/>    ): CategoryArtist<br/>}</span></pre><p id="f004" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们可以看到两个声明的抽象，它们将给出两个本地查询的结果。对于本文，查询本身并不重要。它们的结果是。我们谈了一点关于<strong class="kk iu">发射器</strong>和它们对<strong class="kk iu"> <em class="od">通量</em> </strong>物体的意义。<strong class="kk iu"> <em class="od"> findByCategoryId </em> </strong>返回一个<strong class="kk iu"><em class="od">category artist</em></strong>列表。因为这是一个包含许多结果的结果集，所以挂起这个函数没有意义，因为对每个元素的访问都是以挂起的方式完成的。这意味着访问是在协程内完成的。函数<strong class="kk iu"><em class="od">findByCategoryIdAndArtistId</em></strong>只返回(我们希望)一个结果。返回一个结果意味着我们应该使用关键字<strong class="kk iu"><em class="od"/></strong>。如前所述，这个关键字立即使我们的函数在协程中运行，从而符合反应式编程的要求。</p><p id="d03a" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">最后，我们还应该快速查看一个负责获取特定类别和艺术家的投票计数的方法。它位于<strong class="kk iu"><em class="od">voting controller</em></strong>:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="2205" class="nv lr it nr b gy nw nx l ny nz">@GetMapping("/artist/{idc}/{ida}")<br/>suspend fun getArtistVotingResults(<br/>    @PathVariable idc:String,<br/>    @PathVariable ida:String<br/>) = votingService.getArtistVotingResults(idc, ida)</span></pre><p id="68b1" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这将导致它在<strong class="kk iu"><em class="od">voting service</em></strong>类的<strong class="kk iu"> <em class="od"> Services.kt </em> </strong>脚本中的实现:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="8f7f" class="nv lr it nr b gy nw nx l ny nz">suspend fun getArtistVotingResults(idc: String, ida: String): Long =<br/>    categoryArtistRepository.findByCategoryIdAndArtistId(idc, ida).votes</span></pre><p id="86d2" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这是我们之前评估的方法。这结束了我们的闪电贯穿我们的项目。以下是投票开始时整个项目的完整概述:</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/fa8cc34b30b1c744a341459072a48960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zMdJitOJRcyYOfjRohzyWg.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">完整的投票图</figcaption></figure><h1 id="6195" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">5.运行演示</h1><p id="f263" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi translated">为了运行演示，请确保您已经安装了Docker和JDK 17。然后，您可以从根目录运行此命令:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="b610" class="nv lr it nr b gy nw nx l ny nz">make docker-clean-build-start</span></pre><p id="e6e0" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">等待几分钟，也许10分钟，只是为了确定。然后你可以运行蝗虫测试:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="6a77" class="nv lr it nr b gy nw nx l ny nz">make locust</span></pre><p id="27ff" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">同时你可以跳转到<a class="ae lp" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>上的投票页面。在那里你可以选择投票。结果可以在以下网站看到:<a class="ae lp" href="http://localhost:8080/result" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/result</a></p><p id="668e" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">继续检查蝗虫进程。一旦完成，投票仍然没有完成。你必须让这个过程运行一段时间。或者，您可以运行:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="b7ed" class="nv lr it nr b gy nw nx l ny nz">make count-votes</span></pre><p id="dafd" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果您得到一个异常，很可能是因为乐观锁定算法。这样做是为了让你看到它的作用。当投票完全停止时，您应该能够运行它而不会出错。</p><p id="fc82" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们应该看到的重要日志是来自应用程序的日志和来自侦听器的日志。在这里，我们应该可以找到乐观锁定实现和Hazelcast启动的例外情况:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="fb82" class="nv lr it nr b gy nw nx l ny nz">docker logs jofisaes_vma_listener_1<br/>docker logs jofisaes_vma_backend_img_1</span></pre><p id="5258" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在后端应该会看到类似这样的异常:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="09e1" class="nv lr it nr b gy nw nx l ny nz">2021-11-17 16:55:22.810 ERROR 8 --- [io-8081-exec-10] o.a.c.c.C.[.[.[.[dispatcherServlet]      : Servlet.service() for servlet [dispatcherServlet] threw exception</span><span id="c805" class="nv lr it nr b gy ob nx l ny nz">org.springframework.dao.OptimisticLockingFailureException: Failed to update table [category_artist]. Version does not match for row with Id [9cf34b5a-37f9-444c-8518-b778d2fa4a3b].<br/> at org.springframework.data.r2dbc.core.R2dbcEntityTemplate.lambda$doUpdate$14(R2dbcEntityTemplate.java:704) ~[spring-data-r2dbc-1.3.6.jar!/:1.3.6]<br/> at reactor.core.publisher.FluxHandle$HandleSubscriber.onNext(FluxHandle.java:103) ~[reactor-core-3.4.11.jar!/:3.4.11]<br/> at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:79) ~[reactor-core-3.4.11.jar!/:3.4.11]<br/> at reactor.core.publisher.MonoUsingWhen$MonoUsingWhenSubscriber.deferredComplete(MonoUsingWhen.java:278) ~[reactor-core-3.4.11.jar!/:3.4.11]</span></pre><p id="4a48" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在听者看来是这样的:</p><pre class="ni nj nk nl gt nq nr ns nt aw nu bi"><span id="68c0" class="nv lr it nr b gy nw nx l ny nz">Exception in thread "DefaultDispatcher-worker-3" org.springframework.dao.OptimisticLockingFailureException: Failed to update table [category_song]. Version does not match for row with Id [8eb3cdde-0771-49b3-a031-9b011cb48ef0].<br/> at org.springframework.data.r2dbc.core.R2dbcEntityTemplate.lambda$doUpdate$14(R2dbcEntityTemplate.java:704)<br/> at reactor.core.publisher.FluxHandle$HandleSubscriber.onNext(FluxHandle.java:103)<br/> at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:79)<br/> at reactor.core.publisher.MonoUsingWhen$MonoUsingWhenSubscriber.deferredComplete(MonoUsingWhen.java:278)</span></pre><p id="6dc3" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">本文对完整的堆栈跟踪不感兴趣，但是您会发现它非常广泛。</p><p id="4dc9" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我制作了一个视频来引导您完成开始演示的步骤。请看看它，看看它到底是如何工作的。既然录了，应该没有已知的“演示效果”:</p><figure class="ni nj nk nl gt ju"><div class="bz fp l di"><div class="oj ok l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">科特林演示中的协同程序、分布式缓存、弹性和复制——VMA的应用</figcaption></figure><h1 id="0177" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">6.结论</h1><p id="7b22" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi lg translated">我希望通过这篇篇幅很长、内容广泛的文章和项目，我能够分享一些你感兴趣的和/或你作为一名<strong class="kk iu">软件工程师能够在日常生活中使用的知识</strong>。我对协程的探索向我展示了非常重要的东西。总的来说，如果我们认为协程正在回到我们的日常工作中，那么它们是一个相对较新的主题。这是有充分理由的。可观察到的模式实现起来非常困难和麻烦。Spring WebFlux确实支持反应式编程实现，但这也让实现变得更加困难。协程确实涵盖了这一点。我们可以认为这是用<strong class="kk iu"> <em class="od">暂停</em> </strong>而不是用<strong class="kk iu"> <em class="od">单声道&lt; T &gt; </em> </strong>。至少我知道。而我们也可以这样认为，用<strong class="kk iu"> <em class="od">流量&lt;&gt;</em></strong>代替<strong class="kk iu"> <em class="od">流量&lt;&gt;</em></strong>。流动和流动似乎没有太大的区别。从编程的角度来看，它们似乎非常相似。不使用<strong class="kk iu"> <em class="od"> Mono &lt; T &gt; </em>，</strong>让我想起了过去的实现，在这些实现中，我别无选择，只能使用<strong class="kk iu"> WebFlux </strong>的<strong class="kk iu"> Zip </strong>函数，以确保我会创建一个非阻塞的进程来加入不同查询的结果。</p><p id="2495" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">但是所有这些中最重要的部分实际上是协程如何工作的。通过允许多个线程在我们喜欢的线程上独立运行，我们也允许多个不同的计算在同一个<strong class="kk iu"> <em class="od">线程</em> </strong>中同时发生！。这个概念使得反应式编程更容易，因此也更有趣。</p><p id="70b2" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这篇文章根本没有说反应式<strong class="kk iu">协程</strong>比<strong class="kk iu"> <em class="od"> WebFlux </em> </strong>好。发表那份声明并不是它的目的。然而，在编程层面上有一个明显的结论，那就是用这种方式构建项目更容易。这也是我加入<strong class="kk iu"> <em class="od">反应器——卡夫卡</em> </strong>的部分原因。我们可以提出的另一个问题是，他们中的哪一个更具反应性？它们都与R2DBC实现耦合得很好，而且从协程及其语法来看，它们可以单独测试。但是这可能是另一篇文章要探讨的内容。</p><p id="d123" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我已经把这个应用程序的所有源代码放在了GitHub上</p><p id="bc00" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我希望你能像我喜欢写这篇文章一样喜欢它。我尽量让它简洁明了，并省略了许多小细节。</p><p id="a122" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我很想听听你的想法，所以请在下面留下你的评论。</p><p id="6581" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">提前感谢阅读！</p><h1 id="1c96" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">6.参考</h1><figure class="ni nj nk nl gt ju"><div class="bz fp l di"><div class="ol ok l"/></div></figure><figure class="ni nj nk nl gt ju"><div class="bz fp l di"><div class="ol ok l"/></div></figure><figure class="ni nj nk nl gt ju"><div class="bz fp l di"><div class="ol ok l"/></div></figure><figure class="ni nj nk nl gt ju"><div class="bz fp l di"><div class="ol ok l"/></div></figure><div class="om on gp gr oo op"><a href="https://en.wikipedia.org/wiki/Coroutine" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">协同程序-维基百科</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">协程是计算机程序组件，它通过允许…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">en.wikipedia.org</p></div></div></div></a></div><div class="om on gp gr oo op"><a href="https://en.wikipedia.org/wiki/Cooperative_multitasking" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">合作多任务-维基百科</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">协作式多任务处理，也称为非抢占式多任务处理，是计算机多任务处理的一种形式</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">en.wikipedia.org</p></div></div></div></a></div><div class="om on gp gr oo op"><a href="https://en.wikipedia.org/wiki/Preemption_%28computing%29" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">抢占(计算)-维基百科</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">在计算中，抢占是暂时中断一个正在执行的任务的行为，目的是在某一时刻恢复它</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">en.wikipedia.org</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd jz op"/></div></div></a></div><div class="om on gp gr oo op"><a href="https://en.wikipedia.org/wiki/Real-time_computing#Hard" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">实时计算-维基百科</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">实时计算(RTC)是计算机科学术语，指受“实时”控制的硬件和软件系统</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">en.wikipedia.org</p></div></div><div class="oy l"><div class="pe l pa pb pc oy pd jz op"/></div></div></a></div></div></div>    
</body>
</html>