<html>
<head>
<title>The zenith of React’s functional paradigms — Part 2: The worst parts of React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React函数范式的顶峰——第2部分:React最糟糕的部分</h1>
<blockquote>原文：<a href="https://itnext.io/the-zenith-of-reacts-functional-paradigms-part-2-the-worst-parts-of-react-6011b85ba6a1?source=collection_archive---------6-----------------------#2019-06-16">https://itnext.io/the-zenith-of-reacts-functional-paradigms-part-2-the-worst-parts-of-react-6011b85ba6a1?source=collection_archive---------6-----------------------#2019-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3a04624fe5369480c38bd774ecdb30ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qWovDWCK3_pik8bF"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">本杰明·罗宾·叶斯柏森在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="574e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">功能性React代码库的两个主要构建块——无状态功能组件和高阶组件——都有严重的缺陷。</p><h1 id="fee1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">无状态功能组件的限制</h1><p id="c4c8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我之前已经<a class="ae kc" href="https://medium.com/@adamterlson/functional-react-series-part-1-get-your-app-outta-my-component-92656ae13e25" rel="noopener">发表过我对SFCs </a>的热爱。然而，有几个原因使我不能像我希望的那样充分利用它们。</p><p id="3413" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在React Native中，性能优化的需求不是“是否”的问题，而是“何时”的问题——消除不必要的重新渲染是“React优化101”。</p><p id="3168" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基准测试不会说谎:<a class="ae kc" href="https://moduscreate.com/blog/react_component_rendering_performance/" rel="noopener ugc nofollow" target="_blank">sfc是</a> <a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/react-component-class-vs-stateless-component-e3797c7d23ab">而不是</a> <a class="ae kc" href="https://medium.com/groww-engineering/stateless-component-vs-pure-component-d2af88a1200b" rel="noopener">最快的选项</a>。特别是React本地应用的用户可能会遭受<em class="me">真正可察觉的</em>性能差异，仅仅因为工程师选择利用函数而不是类。</p><p id="483d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个世界不应该是这样的！</p><p id="1ca3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">工程师们别无选择:使用PureComponent(或者用一个HOC包装每个组件，它本身又会使用PureComponent)。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="8255" class="lb lc iq bd ld le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly bi translated">特设组件组成烂透了</h1><p id="4d9c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">hoc是为React组件添加功能的可靠选择。需要访问状态、转换道具、访问上下文、调度一个动作，或者任何你能想象到的事情，hoc可以是这些行为的描述方式(参见<a class="ae kc" href="https://github.com/acdlite/recompose" rel="noopener ugc nofollow" target="_blank"> recompose </a>之类的库的流行程度)。</p><p id="cd7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，走得太远了，你最后会留下一点混乱:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="3ccc" class="na lc iq mw b gy nb nc l nd ne">const FinalComponent = compose(<br/>    connect(...)<br/>    mapProps(...),<br/>    dispatchOnMount(...),<br/>    defaultProps(...),<br/>    ...20 HOCs later...,<br/>    pure,<br/>)(IncompleteComponent)</span></pre><p id="5a3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了简单地作为一个跟踪/调试的PITA之外，通过组件组合来实现行为定义有一些严重的缺陷，这些缺陷并不那么明显。</p><h2 id="3874" class="na lc iq bd ld nf ng dn lh nh ni dp ll ko nj nk lp ks nl nm lt kw nn no lx np bi translated">问题1:属性和渲染封送处理</h2><p id="f0d3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">因为道具必须从一个组件流到下一个组件，所以每个HOC都有责任确保它们不被修改和中断地通过。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="7779" class="na lc iq mw b gy nb nc l nd ne">compose(<br/>  withState,<br/>  myCustomHOC, // Must pass all state changes through, uninterrupted<br/>)(MyComponent)</span></pre><p id="8cf6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了简单地成为一类没人希望出现的新错误之外，这还意味着实际上不可能在特设中应用shouldComponentUpdate毕竟，阻止特设重新呈现将阻止下游组件从上游接收适当的更改。</p><h2 id="e0b6" class="na lc iq bd ld nf ng dn lh nh ni dp ll ko nj nk lp ks nl nm lt kw nn no lx np bi translated">问题2:道具上的全有或全无型安全</h2><p id="5e30" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在一个完美的世界中，当用JSX编写一个呈现方法时，类型系统将确保你正在使用的组件的所有适当的需求将被满足(并且希望有工作的智能感知)。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="92ed" class="na lc iq mw b gy nb nc l nd ne">const MyComponent = compose(<br/>    someHOCA, // Requires prop "propA"<br/>    someHOCB, // Requires prop "propB"<br/>)((props: { propC: string }) =&gt; (...))</span><span id="6cf7" class="na lc iq mw b gy nq nc l nd ne"><br/>&lt;MyComponent propA={10} propB={false} /&gt; // Error - PropC is missing</span></pre><p id="dade" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，为了用HOC组件组合实现这一点，类型系统必须能够完全理解每个HOC以及它对props有什么影响(如果有的话)。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="8642" class="na lc iq mw b gy nb nc l nd ne">const MyComponent = compose(<br/>    someHOCA, // Requires prop "propA"<br/>    someHOCB, // Requires prop "propB"<br/>    propMap(props =&gt; ({ ...props, propC: "Yes!" }), // Add propC<br/>)((props: { propC: string }) =&gt; (...))</span><span id="d238" class="na lc iq mw b gy nq nc l nd ne"><br/>&lt;MyComponent propA={10} propB={false} /&gt; // No error (hopefully)!</span></pre><p id="d573" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当试图创建一个具有良好类型覆盖和良好风格的React项目时，这种复杂性(参见:开销)会产生很多问题。</p><p id="de7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">说到类型，要么全有，要么全无。生或死。杀人或被杀——你明白了。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><p id="e04c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您错过了，请前往<a class="ae kc" href="https://medium.com/@adamterlson/react-hooks-memo-the-zenith-of-reacts-functional-paradigms-8067dc258afb" rel="noopener">查看第1部分</a>了解更多关于React函数范式的历史。</p><h1 id="a79a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">第三部分:很快</h1><p id="7226" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我将讨论这些问题是如何解决的，以及我所看到的函数式react代码库的惯用前进方式。</p></div></div>    
</body>
</html>