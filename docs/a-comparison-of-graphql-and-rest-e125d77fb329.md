# GraphQL 和 REST 的比较

> 原文：<https://itnext.io/a-comparison-of-graphql-and-rest-e125d77fb329?source=collection_archive---------4----------------------->

对于我们大多数人来说，在设计 API 和 web 应用程序时，REST 架构已经深入我们的脑海。仅仅想到范式转换到其他东西上，就可以被看作是一种无意义的头痛诱导练习，不会带来任何净收益，而且会带来大量工作。

通过亲自调查这一转变，我想我会分享一些我在这一过程中学到的东西。我将尝试解释如何使用 GraphQL，并强调这两种方法之间的区别。

> GraphQL 是什么？

GraphQL 在很多方面被描述为，“*访问数据的统一接口。”，“一种在单个端点上公开数据模式的查询语言。*、*服务器端运行时，使用数据定义的类型系统执行查询。*”。

老实说，所有这些不同的描述可能会增加最初对使用它的内容、位置和原因的困惑。从表面上看，所有这些描述都指向同一件事，而不是给你另一个关于 GraphQL 基本存在的乏味描述。我觉得用图片的形式更容易理解。

下面是一个 GraphQL 查询的例子。

![](img/931bcb4f43488e2bd5016982cfc065a2.png)

来源于[https://www . howtographql . com/basics/1-graph QL-is-the-better-rest/](https://www.howtographql.com/basics/1-graphql-is-the-better-rest/)

这里我们用用户的“id”查询用户数据。关于查询和响应要注意的第一件事是它们是相同的，这是因为 GraphQL 是类型化的，这意味着您要求的就是您得到的。我们只是说“给我这个 id 的用户，并返回给我他们的名字，帖子和追随者”。

现在，为了帮助您理解 GraphQL 查询，让我们将它与使用下面的 REST 端点得到的相同结果进行比较。

![](img/33495f301d1fccc58d1b38caf43c1d23.png)

来源于[https://www . howtographql . com/basics/1-graph QL-is-the-better-rest/](https://www.howtographql.com/basics/1-graphql-is-the-better-rest/)

这里，我们必须定义 3 个独立的端点，以便能够访问相同的数据。现在，你们中的一些人会说，通过在第一个请求中返回整个用户对象，可以将此减少到一个端点，这将被视为过度获取数据。如果我们设想我们有一个只需要显示用户名列表的 UI，使用这个单一的 REST 请求来获取所有用户将意味着我们必须对响应数据执行一些客户端处理，以便获取我们最初想要的内容。

这里要注意的一个主要区别是，使用 GraphQL，您知道每个查询可以使用哪些对象和数据，因此您可以指定希望从服务器返回的数据的形式。使用 REST，您无法真正定义返回给您的内容，因为这是服务器决定的。

因此，我们可以将 GraphQL 视为一个端点，在这个端点上，我们有一组可执行的查询，这些查询映射到我们希望服务器公开的数据模式。

好了，对 GraphQL 描述的拙劣尝试可能仍然没有任何意义，所以让我们运行一些代码示例，并构建我们自己的小 API 来比较这两者。我已经创建了一个小节点应用程序，你可以从 GitHub 派生。在这个应用程序中，我们将重现上图所示的例子。这一切都紧扣[](https://www.howtographql.com)**团队精彩的介绍指导。**

 **[## Cameron newby/graphqlvrest

### 此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…

github.com](https://github.com/CameronNewby/graphqlvsrest)** 

**我们要做的第一件事是创建并启动一个本地 mongoDB 服务器。之后，使用 mongoose 为我们的用户数据定义一个模型。**

**我还创建了一个简单的数据库管理器类，它可以启动和停止本地 MongoDB 服务器，并插入一些虚拟数据供我们运行查询。**

**接下来，我们将使用 express 创建一个非常简单的 REST API，它将具有与上图所示大致相同的端点。每个人都会调用数据库来获得一堆模拟数据。**

**最后，让我们创建我们的 GraphQL 端点和模式。为此，我们将使用****express-graph QL***来完成，它将通过 HTTP 提供我们的 GraphQL API，并使用 ***graphql 工具来构建和定义我们的模式。*** 有许多其他的方法来表示你的 GraphQL 模式，但是对于这个例子，我想尽可能地接近 GraphQL SDL 模型。我打算将类型定义从解析器函数中分离出来，希望这样更容易理解。其他方式请看 [**这里**](https://blog.apollographql.com/three-ways-to-represent-your-graphql-schema-a41f4175100d) 。***

***首先，我们创建我们的类型定义，它布局了我们的数据结构。我们将把它映射到我们之前定义的 mongoose 模型。这里的前两个类型定义是特价类型。每个 GraphQL 服务都必须有一个查询类型(默认情况下不需要突变)。这些类型与常规对象类型相同，但它们是唯一的，因为它们定义了每个 GraphQL 查询的入口点。***

***因此，对于“查询”类型，我们将定义一个用户函数，它将接受一个字符串并返回一个用户对象“！”表示我们返回的不能是空对象，它必须是我们稍后定义的“用户”类型的对象。***

```
*user(name: String!): User!*
```

***其他类型是普通对象类型(它们不是 GraphQL 特有的)，其中使用一系列受支持的标量类型，这些类型表示数据的实际类型(String、Int、Date)。因此，这里我们希望创建基于存储在 mongo 中的数据结构的类型，并将返回给客户端。“User”、“Post”和“Comments”类型定义将类似于我们的 mongoose 模式定义。***

```
*type User: {
  name: String!
  age: Int!
  posts: [Post!]!
  followers: [User!]
}*
```

***看看我们是如何为“User”对象创建上面的 GraphQL 类型定义，使其类似于下面的“User”mongose 模式的。***

```
*let userSchema = new mongoose.Schema({
  name: { type: String },        
  age: { type: Number },        
  posts: [postSchema],        
  followers: [{type: mongoose.Schema.Types.ObjectId, ref: 'User'}]    });*
```

***GraphQL 有以下类型:***

*   ***`Int`:一个带符号的 32 位整数。***
*   ***`Float`:有符号双精度浮点值。***
*   ***`String`:UTF‐8 字符序列。***
*   ***`Boolean` : `true`或`false`。***
*   ***`ID`:ID 标量类型表示一个惟一的标识符，通常用于重新提取一个对象或作为缓存的键。ID 类型以与字符串相同的方式序列化；然而，将它定义为`ID`意味着它不适合人类阅读。***

***GraphQL 还允许您构建和创建自己的标量类型，因此虽然它们只支持开箱即用的基本标量类型，但您可以相当容易地构建自己的类型，有关 GraphQL 类型的更多信息，请参见 [**此处**](https://graphql.org/learn/schema/#type-system) 。***

***因此，在编写了查询和变异方法的正式类型定义之后，下一步是使用这些定义来构建相应的函数/解析器，调用这些函数/解析器来获取或更新数据。***

***每个解析器可以接受四个参数:***

*   ***`parent` : 前一个对象，这对于根查询类型上的一个字段是经常不使用的。***
*   ***`args` : 是您在类型定义中注册的输入，以及提供给 GraphQL 查询中的字段的参数。***
*   ***`context`:提供给每个解析器的值，保存重要的上下文信息，如当前登录的用户或对数据库的访问。***
*   ***`info` : 保存与当前查询相关的特定于字段的信息以及模式详细信息的值***

***在这种情况下，我们将在上下文中传递数据库连接。我们解构的参数与我们之前在这些方法的类型定义中定义的参数相同。我们还通过使用'**'定义了哪些参数是强制的，哪些是可选的！**符号，带符号的是解析器的强制参数。***

***因此，让我们从“查询”类型回到“用户”类型定义。***

```
*user(name: String!): User!*
```

***我们已经定义了这个“用户”查询接受一个名为 *name* 的参数，该参数必须是非空字符串。现在我们知道解析器的“args”参数将是以下形状的对象。***

```
*args: {
  name: 'John'
}*
```

***然后，我们对每个解析器所做的就是接受给定的参数，并使用它们对我们的 mongoose 模型执行查询，以获取或更新数据记录。***

***就是这样！我想我还没有详细介绍 GraphQL 模式的所有组件，但这是因为有太多其他很好的描述和教程，我想鼓励人们自己去运行代码，并将其作为学习和改进的基础。这里要注意的一个要点是，不仅为嵌套模式创建类型定义是如此简单，而且创建一个比 REST 方法更具通用性的查询方法只需要很少的代码。***

***有关如何安装和运行该应用程序的详细信息，请参见 GitHub 项目的自述文件。***

***最后，让我们回顾一下使用 GraphQL 优于 REST 的优点和缺点。***

# ***优势***

## ***1.不再有过多和过少的获取***

***REST 最常见的一个问题是提取过量和不足。我们这样说的意思是，客户端正在调用返回由服务器定义的数据结构的固定端点，因此客户端可能会接收到它不想要的数据，或者可能必须发出几个请求才能获得它实际需要的所有数据。很难设计一个没有这个固有问题的 REST API。***

***另一方面，GraphQL 没有这个问题。在 GraphQL 中，服务器声明哪些资源是可用的，客户机询问它当时需要什么。***

## ***2.模式定义和文档***

***GraphQL 使用强类型系统，该系统概述了服务器可以返回的数据的结构。使用 SDL 定义模式意味着客户端可以很容易地确定他们可以接收的数据的形状以及他们可以进行什么样的改变或查询，这样做允许客户端开发者独立工作，因为他们可以很容易地看到他们有什么可用的数据。***

***以这种方式定义模式允许您非常容易地编写 API 文档，而以前您必须在开发 REST 端点之后编写 API 文档，现在您的模式充当了文档的一种形式。***

## ***3.减少所需的端点数量***

***这可能是我最喜欢的一点。不得不设计和构建多个 REST API，所有这些都有大量的端点，对于开发人员来说，减少到一个似乎是一个辉煌的胜利。***

## ***4.捐款***

***GraphQL 订阅是一种将数据从服务器推送到客户端的方式，客户端选择收听来自服务器的实时消息。订阅类似于查询，因为它们指定了一组要传递给客户端的字段，但不是立即返回单个答案，而是在服务器上每次发生特定事件时都发送一个结果。***

***这允许您通过 web 套接字通知客户端已经执行或完成的特定事件。***

# ***不足之处***

## ***1.采用和支持***

***GraphQL 是新的，正因为如此，它不仅仅具有 REST 所具有的时间天赋，因此这使得它被如此普遍地采用，以及围绕其框架构建的大量支持和工具。但是 GraphQL 的变化很快，随着越来越多的公司采用这项技术，我们只会看到支持和工具的增长。***

## ***2.你的嵌入程度如何？***

***这并不是 GraphQL 的直接缺点，而是切换到它的过程。对于一些应用程序和 API 来说，向这种新的工作方式转变可能为时已晚。如果您已经有了一个非常复杂的路由结构，或者有大量的客户端使用您的 API，那么进行这种转换可能从来都不划算，甚至不实际。但是请记住，脸书有这个确切的问题，并且 GraphQL 是如何首先出现的，所以在这方面，总是有可能进行转换，这只是它是否值得的问题。***

***这些只是我在考虑将一个 API 从 REST 迁移到 GraphQL 时发现的一些事情。如果你对两者之间的比较有更多的想法？请在评论中发表！***

## ***参考资料和有用的链接***

***[](https://blog.apollographql.com/graphql-vs-rest-5d425123e34b) [## GraphQL 与 REST

### 通过 HTTP 发送数据的两种方式:有什么区别？

blog.apollographql.com](https://blog.apollographql.com/graphql-vs-rest-5d425123e34b) [](https://www.freecodecamp.org/news/so-whats-this-graphql-thing-i-keep-hearing-about-baf4d36c20cf/?source=post_page---------------------------) [## 我一直听说的 GraphQL 是什么？

### 我一直听说的 GraphQL 是什么？如果你像我一样，你可能会经历三个…

www.freecodecamp.org](https://www.freecodecamp.org/news/so-whats-this-graphql-thing-i-keep-hearing-about-baf4d36c20cf/?source=post_page---------------------------) [](https://blog.apollographql.com/the-next-step-for-realtime-data-in-graphql-b564b72eb07b) [## GraphQL 中实时数据的下一步

### 规范中现在有一个开放的 RFC 用于订阅！

blog.apollographql.com](https://blog.apollographql.com/the-next-step-for-realtime-data-in-graphql-b564b72eb07b)***