<html>
<head>
<title>How to mock Auth0 spa hooks to test your React components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何模拟Auth0 spa挂钩来测试React组件</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-mock-auth0-spa-hooks-to-test-your-react-components-e45b6a38fddb?source=collection_archive---------3-----------------------#2019-09-06">https://itnext.io/how-to-mock-auth0-spa-hooks-to-test-your-react-components-e45b6a38fddb?source=collection_archive---------3-----------------------#2019-09-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/80b3dbc389e9a9069d20dfd7423abe0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*3f2tXYghuHbRB_1CvPGyRg.png"/></div></figure><p id="5d42" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最近，我们开始开发一个新的React Web应用程序，并决定使用<a class="ae kv" href="https://auth0.com/" rel="noopener ugc nofollow" target="_blank"> Auth0 </a>来处理认证。</p><p id="3f91" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">Auth0有一个名为<a class="ae kv" href="https://github.com/auth0/auth0-spa-js#readme" rel="noopener ugc nofollow" target="_blank"> auth0/auth0-spa-js </a>的新库，它处理连接你的应用和auth0所需的大量繁重工作。它提供了关键的登录功能，还包括一系列有用的React挂钩，可以在整个应用程序中使用，以访问用户配置文件和登录状态</p><p id="2b5d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你可以在npm包的readme文件中找到他们的快速入门链接，这里还有一个很好的教程<a class="ae kv" href="https://auth0.com/docs/quickstart/spa/react/01-login" rel="noopener ugc nofollow" target="_blank"/>，解释了如何将这个库与你的react应用程序集成。</p><p id="ecc2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">指南非常好，我们很快就开始了，但是有一个方面在库的文档中没有详细说明:在对组件执行单元测试时如何模拟钩子。我将展示一小段代码，我们发现它在我们的项目中创建单元测试时非常有用。</p><h1 id="f037" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">假设</h1><p id="2cb1" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">在本教程中，我假设如下:</p><ul class=""><li id="beef" class="lz ma it jz b ka kb ke kf ki mb km mc kq md ku me mf mg mh bi translated">你对什么是单元测试，为什么它们有用有一些基本的了解，并且你在过去做过一些</li><li id="5e3d" class="lz ma it jz b ka mi ke mj ki mk km ml kq mm ku me mf mg mh bi translated">您的项目已经连接了运行jest测试的正确依赖项</li><li id="7d37" class="lz ma it jz b ka mi ke mj ki mk km ml kq mm ku me mf mg mh bi translated">我的<code class="fe mn mo mp mq b">spec</code>文件将保存在与主组件相同的文件夹中。您可以将您的文件保存在其他地方，它仍然可以工作，显然要确保导入路径是正确的</li><li id="7856" class="lz ma it jz b ka mi ke mj ki mk km ml kq mm ku me mf mg mh bi translated">我也在我的代码中使用了<code class="fe mn mo mp mq b">enzyme</code>，但是我相信如果你使用其他库，比如<code class="fe mn mo mp mq b">react-test-renderer</code>，这个教程也会以同样的方式工作</li></ul><h1 id="5473" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">以Navbar为例</h1><p id="bd5f" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">让我们看看教程示例中引用的NavBar.js文件:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="c6c4" class="mz kx it mq b gy na nb l nc nd">// src/components/NavBar.js<br/><br/>import React from "react";<br/>import { useAuth0 } from "../react-auth0-wrapper";<br/><br/>const NavBar = () =&gt; {<br/>  const { isAuthenticated, loginWithRedirect, logout } = useAuth0();<br/><br/>  return (<br/>    &lt;div&gt;<br/>      {!isAuthenticated &amp;&amp; (<br/>        &lt;button<br/>          onClick={() =&gt;<br/>            loginWithRedirect({})<br/>          }<br/>        &gt;<br/>          Log in<br/>        &lt;/button&gt;<br/>      )}<br/><br/>      {isAuthenticated &amp;&amp; &lt;button onClick={() =&gt; logout()}&gt;Log out&lt;/button&gt;}<br/>    &lt;/div&gt;<br/>  );<br/>};<br/><br/>export default NavBar;</span></pre><p id="f813" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如您所见，该组件引用了<code class="fe mn mo mp mq b">useAuth0</code>钩子，该钩子允许navbar访问用户配置文件和登录状态(在<code class="fe mn mo mp mq b">isAuthenticated</code>中)</p><p id="2327" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您通常为该组件编写单元测试的方式是这样的:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="b32c" class="mz kx it mq b gy na nb l nc nd">// src/components/Navbar.spec.js</span><span id="a13b" class="mz kx it mq b gy ne nb l nc nd">import React from 'react';<br/>import { mount } from 'enzyme';<br/>// component to test<br/>import Navbar from './Navbar';</span><span id="a786" class="mz kx it mq b gy ne nb l nc nd">describe('components/navbar', () =&gt; {</span><span id="1b93" class="mz kx it mq b gy ne nb l nc nd">  it('Renders with required props', async () =&gt; {<br/>    const wrapper = mount(&lt;Navbar /&gt;);<br/>    expect(wrapper).toBeTruthy();<br/>  });</span><span id="c928" class="mz kx it mq b gy ne nb l nc nd">});</span></pre><p id="b8bc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，问题是你会得到一个错误，因为<code class="fe mn mo mp mq b">useAuth0</code>是未定义的。</p><p id="d5a9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe mn mo mp mq b">TypeError: Cannot read property 'isAuthenticated' of undefined</code></p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nf"><img src="../Images/4f556dc3cc004764dfa0f2db77b6395f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O_I4NBMabJTtAvogbsbiDQ.png"/></div></div></figure><p id="3a10" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是因为在单元测试的上下文中，<code class="fe mn mo mp mq b">react-auth0-wrapper</code>还没有被React上下文初始化，所以函数是未定义的。</p><p id="f951" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">除此之外，我们希望能够测试具有不同用户状态的组件:用户登录，用户注销，用户是否验证了他们的电子邮件，等等。</p><h1 id="8619" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">嘲笑useAuth0钩子</h1><p id="215f" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">我们所做的是在上面的代码上写一个简单的附加，允许我们模仿useAuth0函数，并让它返回一个特定的对象。</p><p id="426d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是最后的代码:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="8a0e" class="mz kx it mq b gy na nb l nc nd">// src/components/Navbar.spec.js</span><span id="17bb" class="mz kx it mq b gy ne nb l nc nd">import React from 'react';<br/>import { mount } from 'enzyme';</span><span id="4cc0" class="mz kx it mq b gy ne nb l nc nd">// component to test<br/>import Navbar from './Navbar';</span><span id="0b84" class="mz kx it mq b gy ne nb l nc nd">// import the auth0 hook<br/>import { useAuth0 } from '<!-- -->../react-auth0-wrapper<!-- -->';</span><span id="3c56" class="mz kx it mq b gy ne nb l nc nd">// create a dummy user profile<br/>const user = {<br/>  email: 'johndoe@me.com',<br/>  email_verified: true,<br/>  sub: 'google-oauth2|2147627834623744883746',<br/>};</span><span id="eece" class="mz kx it mq b gy ne nb l nc nd">// intercept the useAuth0 function and mock it<br/>jest.mock('<!-- -->../react-auth0-wrapper<!-- -->');</span><span id="9fe0" class="mz kx it mq b gy ne nb l nc nd">describe('components/NavBar - logged in', () =&gt; {</span><span id="a7f8" class="mz kx it mq b gy ne nb l nc nd">  beforeEach(() =&gt; {</span><span id="e676" class="mz kx it mq b gy ne nb l nc nd">    // Mock the Auth0 hook and make it return a logged in state<br/>    useAuth0.mockReturnValue({<br/>      isAuthenticated: true,<br/>      user,<br/>      logout: jest.fn(),<br/>      loginWithRedirect: jest.fn(),<br/>    });</span><span id="bfa7" class="mz kx it mq b gy ne nb l nc nd">  });</span><span id="5a4f" class="mz kx it mq b gy ne nb l nc nd">  it('Renders with required props', async () =&gt; {</span><span id="29ff" class="mz kx it mq b gy ne nb l nc nd">    const wrapper = mount(&lt;Navbar /&gt;);<br/>    expect(wrapper).toBeTruthy();</span><span id="0388" class="mz kx it mq b gy ne nb l nc nd">  });</span><span id="5f02" class="mz kx it mq b gy ne nb l nc nd">  it('Renders with correct link in the menu', async () =&gt; {</span><span id="1cdc" class="mz kx it mq b gy ne nb l nc nd">    const wrapper = mount(&lt;Navbar /&gt;);<br/>    expect(wrapper).toBeTruthy();</span><span id="8238" class="mz kx it mq b gy ne nb l nc nd">    // should contain a button to be defined<br/>    expect(wrapper.find('button')).toHaveLength(1);</span><span id="02f1" class="mz kx it mq b gy ne nb l nc nd">    // the button should be the "Log out" one since the use is logged in<br/>    expect(wrapper.find('button').text()).toEqual('Log out');</span><span id="2b08" class="mz kx it mq b gy ne nb l nc nd">  });</span><span id="fa1f" class="mz kx it mq b gy ne nb l nc nd">});</span></pre><p id="2503" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是怎么回事:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="aab9" class="mz kx it mq b gy na nb l nc nd">// import the auth0 hook<br/>import { useAuth0 } from '<!-- -->../react-auth0-wrapper<!-- -->';</span><span id="c36f" class="mz kx it mq b gy ne nb l nc nd">and </span><span id="3886" class="mz kx it mq b gy ne nb l nc nd">// intercept the useAuth0 function and mock it<br/>jest.mock('<!-- -->../react-auth0-wrapper<!-- -->');</span></pre><p id="d5b7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一起导入函数，然后告诉Jest使用一个模拟版本</p><p id="845b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后这一节:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="e1a8" class="mz kx it mq b gy na nb l nc nd">beforeEach(() =&gt; {</span><span id="7531" class="mz kx it mq b gy ne nb l nc nd">// Mock the Auth0 hook and make it return a logged in state<br/>    useAuth0.mockReturnValue({<br/>      isAuthenticated: true,<br/>      user,<br/>      logout: jest.fn(),<br/>      loginWithRedirect: jest.fn(),<br/>    });</span><span id="ed48" class="mz kx it mq b gy ne nb l nc nd">});</span></pre><p id="473a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">允许我们定义一组测试，对于每个测试，Jest将用我们定义的函数替换<code class="fe mn mo mp mq b">useAuth0</code>函数。在这种情况下，我们将返回<code class="fe mn mo mp mq b">isAuthenticated: true</code>和我们在文件中定义的虚拟用户配置文件。</p><p id="f619" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后我们测试组件安装是否正确，以及<code class="fe mn mo mp mq b">NavBar.js</code>中选择显示登录或注销的条件是否有效:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="0ab4" class="mz kx it mq b gy na nb l nc nd">{isAuthenticated &amp;&amp; &lt;button onClick={() =&gt; logout()}&gt;<strong class="mq iu">Log out</strong>&lt;/button&gt;}</span></pre><p id="a299" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，我们测试了导航栏中的按钮是否以文本形式“注销”。</p><h1 id="a6ef" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">接下来呢？</h1><p id="8966" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">从那里，添加另一组测试将非常容易，这次我们为useAuth0调用返回一组不同的数据。简单地复制<code class="fe mn mo mp mq b">describe</code>块，在<code class="fe mn mo mp mq b">beforeEach</code>部分，修改<code class="fe mn mo mp mq b">useAuth0</code>返回的对象。可能很简单:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="4a36" class="mz kx it mq b gy na nb l nc nd">{ isAuthenticated: false, user: null, logout: jest.fn(), loginWithRedirect: jest.fn()}</span></pre><p id="3bc4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后测试这次组件在按钮中显示“Log in”文本。</p><p id="f564" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个小片段对于测试应用程序中使用<code class="fe mn mo mp mq b">useAuth0</code>钩子的各种组件应该非常有用。</p><p id="7f30" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您还可以模拟点击按钮，并测试函数<code class="fe mn mo mp mq b">loginWithRedirect</code>和<code class="fe mn mo mp mq b">logout</code>是否被成功调用。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="1bea" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当然，我们可以说整个<code class="fe mn mo mp mq b">react-auth0-wrapper</code>可以而且应该用Jest来测试。对于一个简单的项目，你可以认为这个库是Auth0的责任，测试这个组件超出了范围(也就是说，它是Auth0的工作)。或者你可以争辩说代码实际上是项目的一部分，因此应该被测试。在我看来，因为我们有一个完整的组件，而不只是做一个<code class="fe mn mo mp mq b">import '@auth0/auth0-spa-js'</code>我们很可能很快就会认为它应该被正确测试。一旦完成，它也将为我们提供另一种测试使用钩子的组件的方法，用一个虚拟的Auth0Provider组件包装被测试的组件。</p><p id="67d6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">同样，也可以认为需要编写端到端的测试，合并这个库。<br/>例如，您可能想要测试您的登录页面，并测试一个序列:<em class="nr">登录页面正确挂载</em> &gt;输入<em class="nr">用户名=" &lt;测试值&gt; " +密码=" &lt;测试密码&gt; " +单击“登录”</em> &gt; <em class="nr">页面刷新，用户对象出现</em> <code class="fe mn mo mp mq b"><em class="nr">isAuthenticated=true</em></code> <em class="nr">。我也同意这一点，我认为测试应该是整个测试策略的一部分。同样，我们已经在其他项目中使用了旧的auth0.js库，新的auth0-spa是一个新的库，我们还没有在端到端测试中完全集成，所以可能会在下一篇文章中讨论。</em></p><h1 id="bb85" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="a89f" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">我希望这篇短文是有帮助的，一如既往，让我知道你的想法和观点，如果有人有一些更复杂的例子要分享，请让我知道！如果有人比我们走得更远，并且已经嘲笑了Auth0Provider，我很想听听你的经历。</p></div></div>    
</body>
</html>