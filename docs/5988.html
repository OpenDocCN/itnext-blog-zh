<html>
<head>
<title>Clean and simple hot-reloading on uninterrupted go applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在不间断的go应用程序上进行干净简单的热重装</h1>
<blockquote>原文：<a href="https://itnext.io/clean-and-simple-hot-reloading-on-uninterrupted-go-applications-5974230ab4c5?source=collection_archive---------2-----------------------#2021-07-19">https://itnext.io/clean-and-simple-hot-reloading-on-uninterrupted-go-applications-5974230ab4c5?source=collection_archive---------2-----------------------#2021-07-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/49c195488724b6356dab2216f6227351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UQLTbGRjkOQhHft2UfpINQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://www.pexels.com/photo/gray-scale-photo-of-gears-159298/" rel="noopener ugc nofollow" target="_blank">档位</a></figcaption></figure><p id="b56a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将学习如何使用<a class="ae kc" href="https://github.com/slok/reload" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> slok/reload </strong> </a>库，在不停止正在运行的Go应用程序的情况下，以一种简单、结构良好且干净的方式热重装任何应用程序组件。但是让我们从头开始…</p><h1 id="eb05" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">介绍</h1><p id="0fea" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">通常，人们会将应用程序的热重新加载(查看一些文件，终止进程并重新运行)与热重新加载应用程序组件相混淆，其中<strong class="kf ir">主进程根本没有被终止，我们在运行中重新创建/重新配置应用程序的一些组件，同时应用程序继续运行，没有中断</strong>。</p><p id="60ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对于一些应用程序来说很重要，因为我们需要在不需要的时候减少中断时间，而这可以通过使用热/实时重载来避免。</p><p id="855d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一些最常用的应用程序需要这样，例如:</p><ul class=""><li id="ace8" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated"><a class="ae kc" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank">普罗米修斯</a></li><li id="c3a6" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><a class="ae kc" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> Nginx </a></li><li id="71e5" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><a class="ae kc" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a></li><li id="0562" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><a class="ae kc" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank">特使</a></li></ul><p id="0dae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，这个重新加载过程可以通过使用HTTP端点(例如:在"<em class="ms"> /-/reload" </em>路径上的POST请求)或使用<a class="ae kc" href="https://en.wikipedia.org/wiki/SIGHUP" rel="noopener ugc nofollow" target="_blank"> SIGHUP </a> OS信号来触发。</p><h1 id="7e7f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">oklog/run</h1><p id="ada9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">几年前，我偶然发现了<a class="ae kc" href="https://github.com/oklog/run" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> oklog/run </strong> </a>，这是一个非常小的go库，但是功能非常强大并且易于使用。</p><p id="ff61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ms"> oklog/run </em>让您控制不同的主应用程序执行入口点生命周期。例如，当您启动一个应用程序时，您将:</p><ul class=""><li id="38c1" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">在一个goroutine中为REST API启动一个HTTP服务器。</li><li id="3f78" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">为另一个goroutine中的度量启动HTTP服务器。</li><li id="6779" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">启动一个长期运行的goroutine，定期通过一些检查。</li><li id="d5a7" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">侦听操作系统信号的通道，当收到信号时，它会停止应用程序。</li><li id="fb4a" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi">…</li></ul><p id="11fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用oklog/ <em class="ms"> run </em>用运行和停止函数来定义这些执行入口点。Oklog/r <em class="ms"> un，</em>将在其中一个组件有或无错误结束时管理启动和正常关闭(在所有组件上)。例如:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">oklog/run示例</figcaption></figure><p id="d27c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，您就获得了一个干净可靠的应用程序的启动/停止，因为您的所有入口点都有一个干净的方式来声明在开始时做什么(例如运行一个服务器)和在停止时做什么(例如关闭服务器和排出连接)。此外，该应用程序迫使您在一个地方以单一方式管理每个运行的入口点。这么简单干净…牛逼。</p><h1 id="4c3f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">慢装/重装</h1><p id="bb53" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们深入了解热重装过程…这就是我们在这里的原因，对吗？</p><p id="bb5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有时，当我们创建一个应用程序时，一些组件(服务、功能……)需要在任何给定的时间点热重装，这种重装逻辑通常在组件本身内部，然而，事情并不那么简单:多个组件需要同时重装，或者我们需要一个重装顺序，同样，存在重装错误，重装是从相同的源触发的，或者可能是从不同的源触发的…</p><p id="6b69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简而言之，这不是一件容易的事情，而且很容易变得凌乱。我们需要一种清晰的、结构良好的方式来声明这些热重载操作。</p><p id="e7ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">受<a class="ae kc" href="https://github.com/oklog/run" rel="noopener ugc nofollow" target="_blank"> oklog/run </a>及其简单性的启发，我开始思考如何以类似的方式管理干净的重新加载过程…</p><p id="34e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">向</strong><a class="ae kc" href="https://github.com/slok/reload" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">slok/reload</strong></a><strong class="kf ir">问好！</strong></p><p id="169c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了<em class="ms"> oklog/run </em>已经提出并解决的要求之外，我还有一些其他要求:</p><ul class=""><li id="29d9" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">管理所有热重装进程的单一入口点(例如:<em class="ms"> func main() </em>)。</li><li id="91da" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">易于使用和配置一个小的API和库。</li><li id="d2d0" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">以单一方式管理应用组件的重新加载。</li><li id="ec8a" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">由多个触发器触发的多个重新加载组件。</li><li id="b08b" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">能够按顺序重新加载不同的组件。</li><li id="41b7" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">多个重载触发器同时发生时的可靠重载。</li><li id="08ff" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">足够灵活，可用于任何类型的重新加载过程。</li></ul><h2 id="2f00" class="mz lc iq bd ld na nb dn lh nc nd dp ll ko ne nf lp ks ng nh lt kw ni nj lx nk bi translated">应用程序接口</h2><p id="bf3c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">先来展示一下库的小API。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/c5ba3a64cd710ad4952fa1b6f9fcd59a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LQaudDbhS2dAUyecnvBXmg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://github.com/slok/reload" rel="noopener ugc nofollow" target="_blank">锁定/重新加载</a> API</figcaption></figure><p id="cb8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该API基于3个主要组件:</p><ul class=""><li id="f74f" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated"><a class="ae kc" href="https://pkg.go.dev/github.com/slok/reload#Notifier" rel="noopener ugc nofollow" target="_blank">通知器</a>:当结束执行时，触发重新加载进程(例如:HTTP处理程序、OS信号……)。</li><li id="dc13" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><a class="ae kc" href="https://pkg.go.dev/github.com/slok/reload#Reloader" rel="noopener ugc nofollow" target="_blank">重新加载器</a>:执行组件重新加载过程(例如:配置加载器，客户端工厂…)。</li><li id="869f" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><a class="ae kc" href="https://pkg.go.dev/github.com/slok/reload#Manager" rel="noopener ugc nofollow" target="_blank">管理器</a>:使用通知器和重装器管理重装生命周期。它将永远运行，直到通知程序或重新加载程序返回一个错误或上下文结束。</li></ul><p id="1f40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">API附带了一些方便的助手，所以用户不需要声明新的类型来创建通知器和重载器(例如:从函数或通道创建通知器)。</p><h2 id="096a" class="mz lc iq bd ld na nb dn lh nc nd dp ll ko ne nf lp ks ng nh lt kw ni nj lx nk bi translated">它是如何工作的</h2><p id="073d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在下图中，我们看到了在<a class="ae kc" href="https://pkg.go.dev/github.com/slok/reload#Manager" rel="noopener ugc nofollow" target="_blank">管理器</a>中运行的内容。</p><p id="532b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有5个已经执行的通知程序，等待在某个时间结束以触发重新加载过程。</p><p id="63de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当通知程序触发重新加载过程时，我们有5个重新加载程序(分为3组)等待执行。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/a81e622748881eb2ca1f245800c26697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*QToyCvooXM5xnUjWcmyHTw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://github.com/slok/reload" rel="noopener ugc nofollow" target="_blank"> slok/reload </a>高层架构</figcaption></figure><ul class=""><li id="e56b" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">1:其中一个通知程序将结束其执行，并将触发重新加载过程。</li><li id="896e" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">2:优先级为10的第一个重装程序组将执行它拥有的单个重装程序。</li><li id="1dbe" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">3:优先级为99的第二个重装程序将同时执行这两个重装程序。</li><li id="745a" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">4:优先级为500的第三个重新加载组将同时执行两个重新加载程序，所有操作都将结束。</li></ul><p id="9805" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">管理器将确保在执行重新加载器组时，没有其他通知程序可以触发该重新加载组的重新加载过程。</p><p id="b3f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当通知程序的一个执行结束时(为了触发重新加载进程)，它将立即再次启动，以便通知程序为新的重新加载触发器做好准备。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="d637" class="lb lc iq bd ld le nu lg lh li nv lk ll lm nw lo lp lq nx ls lt lu ny lw lx ly bi translated">实际例子</h1><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/10d4761862327b5f5ffe2aab40f74937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6-eUYK_FZT-_7IybFZYExA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://www.pexels.com/photo/lighthouse-snail-staircase-53554/" rel="noopener ugc nofollow" target="_blank">灯塔蜗牛楼梯</a></figcaption></figure><p id="e7f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将创建一个简单的应用程序来展示我们如何通过使用以下代码来设置一个可靠、简单、干净的具有热/实时重载特性的应用程序启动和卸载:</p><ul class=""><li id="bf60" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated"><strong class="kf ir"> oklog/run </strong>:管理正在运行的入口点生命周期。</li><li id="737b" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><strong class="kf ir">锁定/重装</strong>:管理热重装生命周期。</li></ul><p id="94bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">TL；</strong> <a class="ae kc" href="https://github.com/slok/reload/tree/main/_examples/simpleapp" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">博士:完整示例此处</strong> </a></p><h2 id="99c7" class="mz lc iq bd ld na nb dn lh nc nd dp ll ko ne nf lp ks ng nh lt kw ni nj lx nk bi translated">要求</h2><p id="3ba1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们有一个加载JSON配置文件的应用程序。此配置将用于创建两个域服务:</p><ul class=""><li id="63fb" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">Printer:用配置中的内容打印一条消息。</li><li id="8894" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">Curler:使用配置中的内容向URL发出请求。</li></ul><p id="f1d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该应用程序应该能够热重新加载配置，然后这两个服务。</p><p id="0f61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">热重装应以多种方式触发:</p><ul class=""><li id="9285" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">SIGHUP(按需)。</li><li id="d6ff" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">HTTP API处理程序(按需)。</li><li id="1c5c" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">文件系统文件更改(在文件更改事件时)。</li></ul><p id="eb71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当应用程序启动时，它应该运行4个入口点:</p><ul class=""><li id="74ca" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">一个操作系统信号处理程序:处理停止信号和热重装触发器。</li><li id="5cdc" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">HTTP服务器:处理域服务执行和热重装触发器。</li><li id="5cf6" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">文件监视器:在文件改变时触发热重装。</li><li id="6819" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">热重装管理器:处理所有热重装过程的执行。</li></ul><h2 id="1e7a" class="mz lc iq bd ld na nb dn lh nc nd dp ll ko ne nf lp ks ng nh lt kw ni nj lx nk bi translated">配置加载程序</h2><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">示例配置负载</figcaption></figure><p id="76ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们看到了配置加载器。这是一个知道如何从文件中加载配置的服务，代码的任何组件都可以使用它通过公共方法来获取配置。</p><ul class=""><li id="96a5" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">使用RW互斥锁锁定加载程序内部的读/写配置值。</li><li id="8b42" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">有一个<em class="ms"> Reload </em>方法重新读取配置文件并加载它。</li><li id="98f4" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">有一个<em class="ms"> Get </em>方法，该方法返回当时加载的配置。</li></ul><h2 id="7a7e" class="mz lc iq bd ld na nb dn lh nc nd dp ll ko ne nf lp ks ng nh lt kw ni nj lx nk bi translated">域服务</h2><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">示例打印机服务</figcaption></figure><p id="debb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们可以看到<em class="ms">打印机</em>服务，最重要的部分是这些:</p><ul class=""><li id="6fa6" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">使用RW互斥锁来锁定读/写值访问，我们将使用它来重新加载和打印。</li><li id="8de5" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">有一个<em class="ms"> Reload </em>公共方法，可以在服务内部重新加载配置(使用配置加载器),并设置所需的服务配置消息，以便服务可以打印它。</li></ul><p id="8541" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于卷发器服务，我们也有类似的事情。</p><h2 id="8107" class="mz lc iq bd ld na nb dn lh nc nd dp ll ko ne nf lp ks ng nh lt kw ni nj lx nk bi translated">重装机</h2><p id="dcfa" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们来讨论一下加载器:<em class="ms">配置加载器，卷曲器，打印机</em>。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">重装机</figcaption></figure><p id="2a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们刚刚开始分析应用程序主代码，在上面代码的第一部分，创建了域服务。然后我们创建重载管理器。</p><p id="9a7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有趣的部分发生在我们开始使用<em class="ms"> slok/reload </em>的时候。我们以一种非常简单明了的方式按照特定的顺序声明了3个重载操作:</p><ul class=""><li id="1a42" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">首先，0优先级重新加载器，配置服务(我们警告配置加载失败，但没有错误)。</li><li id="c9dc" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">第二，100优先级重新加载器，重新加载卷曲器和打印机服务(当这个重新加载时，配置加载器已经被重新加载了，所以，它们将选择新的配置)。</li></ul><h2 id="7ead" class="mz lc iq bd ld na nb dn lh nc nd dp ll ko ne nf lp ks ng nh lt kw ni nj lx nk bi translated">信号重新加载通知程序</h2><p id="6626" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">最后是最后一部分，通知程序。让我们从OS信号通知程序开始。</p><p id="e9cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们想监听操作系统信号。当出现SIGHUP时，我们希望通过<em class="ms"> slok/reload来触发重载过程。经理</em></p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">操作系统信号重载通知程序</figcaption></figure><p id="d2e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们看到我们创建了多个通道:</p><ul class=""><li id="ae2f" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">sigC:接收操作系统信号。</li><li id="890d" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">exitC:明确停止监听OS信号。</li><li id="b5a1" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">reloadC:触发重新加载过程(该通道用作使用<a class="ae kc" href="https://pkg.go.dev/github.com/slok/reload?utm_source=godoc#NotifierChan" rel="noopener ugc nofollow" target="_blank"> <em class="ms"> reload的通知器。</em> </a> <em class="ms"> </em>助手通知人)。</li></ul><p id="e4b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，逻辑主要是，永远等待OS信号<em class="ms">的<em class="ms"> sigC </em>，当我们接收到SIGHUP类型的信号时，使用<em class="ms"> reloadC </em>来触发重新加载过程。其他的，请退出。</em></p><h2 id="334b" class="mz lc iq bd ld na nb dn lh nc nd dp ll ko ne nf lp ks ng nh lt kw ni nj lx nk bi translated">HTTP重新加载通知程序</h2><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">HTTP重新加载通知程序</figcaption></figure><p id="922f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们为HTTP服务声明了通知程序，就像SIGHUP通知程序一样，我们使用将<em class="ms"> chan字符串</em>转换为通知程序的<a class="ae kc" href="https://pkg.go.dev/github.com/slok/reload?utm_source=godoc#NotifierChan" rel="noopener ugc nofollow" target="_blank"><em class="ms">Notifier chan</em></a>helper来完成。</p><p id="bf9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">逻辑很小，我们注册我们的热重新加载HTTP处理程序，当HTTP服务器在"<em class="ms"> /-/reload </em>"路径上收到请求时，我们将使用这个<em class="ms"> chan字符串</em>通道触发重新加载过程。</p><h2 id="0443" class="mz lc iq bd ld na nb dn lh nc nd dp ll ko ne nf lp ks ng nh lt kw ni nj lx nk bi translated">配置文件观察器通知程序</h2><p id="b0ee" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">最后，我们有一个通知程序，它监视配置文件的变化并触发重新加载</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">配置文件观察器通知程序</figcaption></figure><p id="4e9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了观察这个文件，我们使用了<a class="ae kc" href="https://github.com/fsnotify/fsnotify" rel="noopener ugc nofollow" target="_blank"> fsnotify </a>库。我们创建一个自动开始监视所有指定文件的监视器，然后我们添加要监视的配置文件的路径。</p><p id="62c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">观察器有一个称为<em class="ms">事件的事件通道。</em>我们将使用它来获取文件上的事件更改并触发重新加载。</p><p id="f542" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与其他两个通知程序不同，这个通知程序不使用<em class="ms"> NotifierChan </em>助手，而是使用<a class="ae kc" href="https://pkg.go.dev/github.com/slok/reload?utm_source=godoc#NotifierFunc" rel="noopener ugc nofollow" target="_blank"> <em class="ms"> NotifierFunc </em> </a>助手。这个助手将一个函数转换成一个通知程序。这个函数将由重载管理器执行，当它结束执行时，将触发重载过程。</p><p id="da38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，该函数将通过监听文件监视器通道上的事件(事件和错误)来等待，并且根据它接收到的内容，它将触发重新加载，或者告诉重新加载管理器存在错误。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="985b" class="lb lc iq bd ld le nu lg lh li nv lk ll lm nw lo lp lq nx ls lt lu ny lw lx ly bi translated">结论</h1><p id="40df" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">控制和协调一个可靠的应用程序启动并不是一件容易的事情。如果我们增加热重装需求，事情会变得非常混乱和复杂。然而，我们已经看到了如何为任何类型的Go应用程序设计和实现一个简单的、结构良好的、干净的、运行/热重装过程。</p><p id="6873" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，<a class="ae kc" href="https://github.com/slok/reload" rel="noopener ugc nofollow" target="_blank">slok/reload</a>library<em class="ms">迫使</em>你以某种方式设置所有重新加载的组件，并且大部分都在同一个地方(应用程序的主要入口点)，让代码对你和未来的人来说都很清楚。</p><p id="4bf8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为奖励，我们已经看到了<a class="ae kc" href="https://github.com/oklog/run" rel="noopener ugc nofollow" target="_blank"> oklog/run </a>，这是一个定义应用程序启动的令人惊叹的简单软件(它与<a class="ae kc" href="https://github.com/slok/reload" rel="noopener ugc nofollow" target="_blank"> slok/reload </a>配合得非常好)。</p><p id="e25a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您的阅读，如果您有评论、建议、问题或意见，请在此留下评论或提出问题<a class="ae kc" href="https://github.com/slok/reload/issues" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/624a3b7a9602551b422be1b1687166af.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/1*8DYd6Hlf4wXOPcNEtPf2Rw.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">再见！</figcaption></figure></div></div>    
</body>
</html>