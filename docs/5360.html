<html>
<head>
<title>Factory Method Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">工厂方法设计模式</h1>
<blockquote>原文：<a href="https://itnext.io/factory-method-design-pattern-5a2bbaea08dc?source=collection_archive---------3-----------------------#2021-02-16">https://itnext.io/factory-method-design-pattern-5a2bbaea08dc?source=collection_archive---------3-----------------------#2021-02-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/354ce0fae2e36332a31c14be9dc67c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*y-Vm5CxhYS9GKZmP_600jQ.png"/></div></figure><p id="6523" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">工厂方法是一种创造性的设计模式，它提供了在超类中创建对象的接口，但允许子类改变将要创建的对象的类型。</p><p id="b438" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在软件工程中，创造性的设计模式是处理对象创建机制的设计模式，试图以适合情况的方式创建对象。对象创建的基本形式可能会导致设计问题或增加设计的复杂性。创造性设计模式通过某种方式控制对象的创建来解决这个问题。</p><ul class=""><li id="0575" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated"><a class="ae lb" href="https://sourcemaking.com/design_patterns/abstract_factory" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir"/></a><br/>抽象工厂创建几个家族类的实例</li><li id="37d1" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated"><a class="ae lb" href="https://sourcemaking.com/design_patterns/builder" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">构建器</strong> </a> <br/>将对象构造与其表示分离</li><li id="a619" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated"><a class="ae lb" href="https://sourcemaking.com/design_patterns/factory_method" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">工厂方法</strong> </a> <br/>创建几个派生类的实例</li><li id="3b94" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated"><a class="ae lb" href="https://sourcemaking.com/design_patterns/object_pool" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">对象池</strong> </a> <br/>通过回收不再使用的对象来避免昂贵的资源获取和释放</li><li id="2d02" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated"><a class="ae lb" href="https://sourcemaking.com/design_patterns/prototype" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">原型</strong> </a> <br/>被复制或克隆的完全初始化的实例</li><li id="cf36" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated"><a class="ae lb" href="https://sourcemaking.com/design_patterns/singleton" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir">Singleton</strong></a><br/>只有一个实例存在的类</li></ul><p id="27d1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">工厂设计模式要求定义一个接口(java接口或抽象类),让子类决定实例化哪个对象。接口中的工厂方法让一个类将实例化推迟到一个或多个具体的子类。因为这些设计模式谈论的是对象的实例化，所以它属于创造性设计模式的范畴。如果我们注意到工厂方法这个名字，这意味着有一个方法是工厂，一般来说，工厂涉及到创造性的东西，在这里，一个对象被创建。这是创建对象的最佳方式之一，其中对象创建逻辑对客户端是隐藏的。现在让我们看看实现。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><p id="6f54" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi lo translated"><span class="l lp lq lr bm ls lt lu lv lw di">一</span>实施:</p><ul class=""><li id="26c0" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">在接口中定义工厂方法。</li><li id="fa24" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated">让子类实现上面的工厂方法，决定创建哪个对象。在Java中，构造函数不是多态的，但是通过允许一个子类创建一个对象，我们给实例化增加了多态行为。</li></ul><p id="db7b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们举个例子。</p><p id="e46d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们有一个程序类<strong class="jw ir"/>这是一个客户端类。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="0ed3" class="mg mh iq mc b gy mi mj l mk ml">public class Program {<br/>    public static void main(String[] args) {<br/>        JavaDeveloper javaDeveloper = new JavaDeveloper();<br/>        javaDeveloper.writeJavaCode();<br/>    }<br/>}</span></pre><p id="fd10" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">并用一个方法创建一个JavaDeveloper类:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="4510" class="mg mh iq mc b gy mi mj l mk ml">public class JavaDeveloper {<br/>    public void writeJavaCode() {<br/>        System.<em class="mm">out</em>.printf("Java Developer write java code ..... ");<br/>    }<br/>}</span></pre><p id="fff3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">运行程序后，我们将在控制台中看到执行过程:</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mn"><img src="../Images/a5f5aa264fcc1a352dd8fe897efde069.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kTxdk0RAUu1f41hpeP2cAQ.png"/></div></div></figure><p id="890b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">例如，接下来，我们需要创建一个CppDeveloper</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="744a" class="mg mh iq mc b gy mi mj l mk ml">public class Program {<br/>    public static void main(String[] args) {<br/>        CppDeveloper cppDeveloper = new CppDeveloper();<br/>        cppDeveloper.writeCppCode();<br/>    }<br/>}</span></pre><p id="a70d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">和</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="06a7" class="mg mh iq mc b gy mi mj l mk ml">public class CppDeveloper {<br/>    void writeCppCode() {<br/>        System.<em class="mm">out</em>.printf("C++ developer write C++ code .... ");<br/>    }<br/>}</span></pre><p id="9cdd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">运行程序后，我们将在控制台中看到执行过程:</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi ms"><img src="../Images/ace848fbeb3cf8638b7372751f6c2b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lvo2WiroETnnuBVUT9CYBg.png"/></div></div></figure><p id="11be" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">正如我们所看到的，我们的程序正在工作。但如果我们需要改变编程语言或添加一些方法，我们将不得不编写许多相同类型的代码。我们还必须对客户端类<strong class="jw ir">程序</strong>执行许多动作。这种做法不方便，也是错误的。</p><p id="b630" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下面我们将采取不同的方法。创建开发人员界面。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="2f77" class="mg mh iq mc b gy mi mj l mk ml">public interface Developer {<br/>    void writeCode();<br/>}</span></pre><p id="bf76" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">另外，创建两个实现类JavaDeveloper和CppDeveloper类。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="6d47" class="mg mh iq mc b gy mi mj l mk ml">public class JavaDeveloper implements Developer {<br/>    @Override<br/>    public void writeCode() {<br/>        System.<em class="mm">out</em>.printf("Java Developer writes Java code ....");<br/>    }<br/>}</span></pre></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><pre class="mb mc md me aw mf bi"><span id="cfd3" class="mg mh iq mc b gy mt mu mv mw mx mj l mk ml">public class CppDeveloper implements Developer {<br/>    @Override<br/>    public void writeCode() {<br/>        System.<em class="mm">out</em>.printf("Cpp Developer writes Cpp code ....");<br/>    }<br/>}</span></pre><p id="5d84" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以图表的形式，我们的类看起来像这样:</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi my"><img src="../Images/a052179edc1de454460aafd232b21a3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LS56j0brxRqgOLzr6yr85g.png"/></div></div></figure><p id="54ac" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以如下使用这个实现:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="4986" class="mg mh iq mc b gy mi mj l mk ml">public class Program {<br/>    public static void main(String[] args) {<br/>        Developer developer = new JavaDeveloper();<br/>        developer.writeCode();<br/>    }<br/>}</span></pre><p id="c8ba" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">和</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="938f" class="mg mh iq mc b gy mi mj l mk ml">public class Program {<br/>    public static void main(String[] args) {<br/>        Developer developer = new CppDeveloper();<br/>        developer.writeCode();<br/>    }<br/>}</span></pre><p id="f62b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个实现比前一个实现方便得多。但是，我们仍然需要编写大量重复的代码，并创建一个JavaDeveloper或CppDeveloper的实例。这种方法不够灵活。为了改进这个实现，我们将创建开发者工厂接口。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="64fb" class="mg mh iq mc b gy mi mj l mk ml">public interface DeveloperFactory {<br/>    Developer createDeveloper();<br/>}</span></pre><p id="f430" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们创建开发人员工厂接口的两个实现:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="2ede" class="mg mh iq mc b gy mi mj l mk ml">public class JavaDeveloperFactory implements DeveloperFactory {<br/>    @Override<br/>    public Developer createDeveloper() {<br/>        return new JavaDeveloper();<br/>    }<br/>}</span></pre></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><pre class="mb mc md me aw mf bi"><span id="5420" class="mg mh iq mc b gy mt mu mv mw mx mj l mk ml">public class CppDeveloperFactory implements DeveloperFactory {<br/>    @Override<br/>    public Developer createDeveloper() {<br/>        return new CppDeveloper();<br/>    }<br/>}</span></pre><p id="b2e1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以图表的形式，我们的类看起来像这样:</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mz"><img src="../Images/cb371dfcd64bb5cace91afc28a9d2a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YdM9kK-h5IsWKARGqZ2Z1g.png"/></div></div></figure><p id="b7f5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，在客户端类中，我们需要注册以下实现。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="9b58" class="mg mh iq mc b gy mi mj l mk ml">public class Program {<br/>    public static void main(String[] args) {<br/>        DeveloperFactory developerFactory = new JavaDeveloperFactory();<br/>        Developer developer = developerFactory.createDeveloper();<br/>        developer.writeCode();<br/>    }<br/>}</span><span id="0d29" class="mg mh iq mc b gy na mj l mk ml">Java Developer writes Java code ....</span></pre><p id="092a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">和</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="15a6" class="mg mh iq mc b gy mi mj l mk ml">public class Program {<br/>    public static void main(String[] args) {<br/>        DeveloperFactory developerFactory = new CppDeveloperFactory();<br/>        Developer developer = developerFactory.createDeveloper();<br/>        developer.writeCode();<br/>    }<br/>}</span><span id="eb02" class="mg mh iq mc b gy na mj l mk ml">Cpp Developer writes Cpp code ....</span></pre><p id="4944" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是我们仍然需要创建一个开发人员实例。为了避免这种情况，您需要创建一个更加灵活的实现。</p><p id="84a8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们创建一个方法的实现，它的任务是根据编程语言返回特定的开发人员工厂。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="31ec" class="mg mh iq mc b gy mi mj l mk ml">static DeveloperFactory createDeveloperBySpecialty(final String specialty) {<br/>    if ("java".equalsIgnoreCase(specialty)) {<br/>        return new JavaDeveloperFactory();<br/>    } else if ("c++".equalsIgnoreCase(specialty)) {<br/>        return new CppDeveloperFactory();<br/>    } else {<br/>        throw new RuntimeException(specialty + "is unknow specialty");<br/>    }<br/>}</span></pre><p id="0522" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最终的实现是这样的。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="ced3" class="mg mh iq mc b gy mi mj l mk ml">public class Program {<br/>    public static void main(String[] args) {<br/>        DeveloperFactory developerFactory = <em class="mm">createDeveloperBySpecialty</em>("java");<br/>        Developer developer = developerFactory.createDeveloper();<br/>        developer.writeCode();<br/>    }<br/><br/>    static DeveloperFactory createDeveloperBySpecialty(final String specialty) {<br/>        if ("java".equalsIgnoreCase(specialty)) {<br/>            return new JavaDeveloperFactory();<br/>        } else if ("c++".equalsIgnoreCase(specialty)) {<br/>            return new CppDeveloperFactory();<br/>        } else {<br/>            throw new RuntimeException(specialty + "is unknow specialty");<br/>        }<br/>    }<br/>}</span><span id="675d" class="mg mh iq mc b gy na mj l mk ml">Java Developer writes Java code ....</span></pre><p id="b62c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">和</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="dac4" class="mg mh iq mc b gy mi mj l mk ml">public class Program {<br/>    public static void main(String[] args) {<br/>        DeveloperFactory developerFactory = <em class="mm">createDeveloperBySpecialty</em>("c++");<br/>        Developer developer = developerFactory.createDeveloper();<br/>        developer.writeCode();<br/>    }<br/><br/>    static DeveloperFactory createDeveloperBySpecialty(final String specialty) {<br/>        if ("java".equalsIgnoreCase(specialty)) {<br/>            return new JavaDeveloperFactory();<br/>        } else if ("c++".equalsIgnoreCase(specialty)) {<br/>            return new CppDeveloperFactory();<br/>        } else {<br/>            throw new RuntimeException(specialty + "is unknow specialty");<br/>        }<br/>    }<br/>}</span><span id="5eba" class="mg mh iq mc b gy na mj l mk ml">Cpp Developer writes Cpp code ....</span></pre><p id="43bd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">例如，我们需要为PHP开发人员创建一个实现。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="e59c" class="mg mh iq mc b gy mi mj l mk ml">public class PhpDeveloper implements Developer {<br/>    @Override<br/>    public void writeCode() {<br/>        System.<em class="mm">out</em>.printf("Php Developer writes Php code....");<br/>    }<br/>}</span><span id="b6fd" class="mg mh iq mc b gy na mj l mk ml">public class PhpDeveloperFactory implements DeveloperFactory {<br/>    @Override<br/>    public Developer createDeveloper() {<br/>        return new PhpDeveloper();<br/>    }<br/>}</span><span id="3e5e" class="mg mh iq mc b gy na mj l mk ml">public class Program {<br/>    public static void main(String[] args) {<br/>        DeveloperFactory developerFactory = <em class="mm">createDeveloperBySpecialty</em>("php");<br/>        Developer developer = developerFactory.createDeveloper();<br/>        developer.writeCode();<br/>    }<br/>    <br/>    static DeveloperFactory createDeveloperBySpecialty(final String specialty) {<br/>        if ("java".equalsIgnoreCase(specialty)) {<br/>            return new JavaDeveloperFactory();<br/>        } else if ("c++".equalsIgnoreCase(specialty)) {<br/>            return new CppDeveloperFactory();<br/>        } else if ("php".equalsIgnoreCase(specialty)) {<br/>            return new PhpDeveloperFactory();<br/>        } else {<br/>            throw new RuntimeException(specialty + "is unknown specialty");<br/>        }<br/>    }<br/>}</span><span id="fc14" class="mg mh iq mc b gy na mj l mk ml">Php Developer writes Php code....</span></pre><p id="4be0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如您所见，实现变得非常简单和灵活。</p><p id="98e6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是为了更灵活和高质量的实现，我们可以用Map替换if-else条件。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="4a68" class="mg mh iq mc b gy mi mj l mk ml">public class NameOfDeveloper {<br/><br/>    private static final ConcurrentHashMap&lt;String, DeveloperFactory&gt; <em class="mm">CODE_COUNTRY </em>= new ConcurrentHashMap&lt;&gt;();<br/><br/>    static {<br/>        <em class="mm">CODE_COUNTRY</em>.put("java", new JavaDeveloperFactory());<br/>        <em class="mm">CODE_COUNTRY</em>.put("cpp", new CppDeveloperFactory());<br/>        <em class="mm">CODE_COUNTRY</em>.put("php", new PhpDeveloperFactory());<br/>    }<br/><br/>    public static DeveloperFactory returnNameOfDeveloper(final String specialty) {<br/>        return <em class="mm">CODE_COUNTRY</em>.get(specialty);<br/>    }<br/>}</span></pre><p id="bb5c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">更改后，我们的代码将如下所示:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="1df2" class="mg mh iq mc b gy mi mj l mk ml">public class Program {<br/>    public static void main(String[] args) {<br/>        DeveloperFactory developerFactory = NameOfDeveloper.<em class="mm">returnNameOfDeveloper</em>("java");<br/>        Developer developer = developerFactory.createDeveloper();<br/>        developer.writeCode();<br/>    }<br/>}</span><span id="4eb5" class="mg mh iq mc b gy na mj l mk ml">Java Developer writes Java code ....</span></pre><h1 id="e897" class="nb mh iq bd nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx bi translated">结论</h1><p id="b758" class="pw-post-body-paragraph ju jv iq jw b jx ny jz ka kb nz kd ke kf oa kh ki kj ob kl km kn oc kp kq kr ij bi translated">工厂方法是一种广泛使用的、创造性的设计模式，可以用在许多存在多个具体接口实现的情况下。</p><p id="9bfb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该模式删除了难以维护的复杂逻辑代码，并用可重用和可扩展的设计取而代之。该模式避免修改现有代码来支持新的需求。</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/231a99b48e540fa32e0c24d269f4d4da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*rascrB_jyT057jep4YyOrw.png"/></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated"><a class="ae lb" href="https://test-engineer.site/" rel="noopener ugc nofollow" target="_blank">https://test-engineer.site/</a></figcaption></figure><h2 id="085a" class="mg mh iq bd nc oi oj dn ng ok ol dp nk kf om on no kj oo op ns kn oq or nw os bi translated">作者<a class="ae lb" href="https://www.linkedin.com/in/vaskocuturilo/" rel="noopener ugc nofollow" target="_blank">安东·斯米尔诺夫</a></h2></div></div>    
</body>
</html>