<html>
<head>
<title>Test your Java code with the help of Testcontainers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">借助Testcontainers测试您的Java代码</h1>
<blockquote>原文：<a href="https://itnext.io/test-your-java-code-with-the-help-of-testcontainers-898d31b64883?source=collection_archive---------3-----------------------#2020-01-13">https://itnext.io/test-your-java-code-with-the-help-of-testcontainers-898d31b64883?source=collection_archive---------3-----------------------#2020-01-13</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><p id="3997" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">当一个人在写软件时，测试是其中很大的一部分。算法的单元测试很容易实现和运行，并且可能(但愿如此！)如今一个公认的标准。</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div class="gi gj km"><img src="../Images/0540b932379dcdc422b4677c6abe6cd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*hHkLLVgBkH86cdSUiSmRvg.jpeg"/></div><figcaption class="ku kv gk gi gj kw kx bd b be z dk translated">等待测试的单元</figcaption></figure><p id="b873" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">当外部依赖开始起作用时，事情变得更有趣了。这通常被称为集成测试。但是实际上，我们想要测试的并不是与目标环境的集成，而是关于如何与其他系统交互的基本假设得到了满足。模拟对象经常发挥作用，例如抽象数据库访问以提供结果对象。不幸的是，这留下了两个问题:a)谁来测试模拟，b)模拟对象在多大程度上代表了现实？但是我跑题了。</p><p id="317b" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">进行这些测试的另一种方法是部署依赖项，然后针对这些依赖项运行您的代码。当以传统方式做这件事时，这意味着很多痛苦。可能是一个中央数据库服务器或消息总线或类似的东西。每个开发人员都有他们自己的模式或目的地(-前缀)或类似的东西，所以互相冒犯的可能性是最小的。或者开发人员建立他们自己的依赖关系的本地实例，这可能与不同项目的设置冲突和/或经常使用稀缺的系统资源。</p><h2 id="af0c" class="ky kz ir bd la lb lc dn ld le lf dp lg jz lh li lj kd lk ll lm kh ln lo lp lq bi translated">拯救测试容器</h2><p id="3a48" class="pw-post-body-paragraph jo jp ir jq b jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh lv kj kk kl ik bi translated">幸运的是，Linux容器已经成为IT环境的一部分好几年了。容器可以快速启动，并且可以限制在其中运行的软件。停止(和删除)容器还会清除更改，以便可以为下一次运行建立定义的开始/基础(假设它们不会将更改保存在主机文件系统中)。</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div class="gi gj lw"><img src="../Images/247e792091f53a74192ce5d6490554c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*T3wDxrtGcIUOoWR4oHgcXA.jpeg"/></div></figure><p id="48c4" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">Testcontainers 现在是一种从Java代码中轻松启动容器映像的方法，这些映像具有这样的依赖关系，然后使它们对您的测试可用。Testcontainers与JUnit之类的测试框架集成得很好。</p><p id="f5d9" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><strong class="jq is">使用PostgreSQL </strong></p><p id="c8ab" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">让我们看一些例子，从Postgres数据库开始:</p><pre class="kn ko kp kq gu ly lz ma mb aw mc bi"><span id="8c5f" class="ky kz ir lz b gz md me l mf mg">@QuarkusTest              // <strong class="lz is">(1)</strong><br/>class RestApiTest {<br/><br/>  @ClassRule<br/>  private static PostgreSQLContainer <em class="mh">postgreSQLContainer </em>=<br/>      new PostgreSQLContainer("postgres");   // <strong class="lz is">(2)</strong></span></pre><p id="3839" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在这里，我们说这是一个测试类，它应该通过启动Quarkus来运行测试，因为这是我选择的应用服务器(1 ),然后设置一个Postgres容器。参数“postgres”实际上是图像名称，可以省略。现在我们有了这个，我们需要从图像中启动一个容器，并告诉我们的代码在哪里可以找到它:</p><pre class="kn ko kp kq gu ly lz ma mb aw mc bi"><span id="80e6" class="ky kz ir lz b gz md me l mf mg">@BeforeAll<br/>private static void setupPostgres() throws Exception {<br/>  <em class="mh">postgreSQLContainer</em>.start();  // <strong class="lz is">(3)</strong><br/>  // Now that postgres is started, we need to get its URL and tell <br/>  //      Quarkus<br/>  System.<em class="mh">setProperty</em>("quarkus.datasource.url",<br/>           <em class="mh">postgreSQLContainer</em>.getJdbcUrl());  <br/>  System.<em class="mh">setProperty</em>("quarkus.datasource.username","test");// <strong class="lz is">(4)</strong><br/>  System.<em class="mh">setProperty</em>("quarkus.datasource.password","test");</span></pre><p id="4d82" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">(3)启动容器和里面的Postgres实例。一旦它开始运行，我们就可以从它那里获得JDBC URL，并通过系统属性(4)将其传递给Quarkus。我们还需要设置访问数据库的凭证。在示例中，这是硬编码的“test ”,因为这是我在PostgreSQLContainer的源代码中找到的，但理想情况下，应该将其参数化，如下所示。</p><p id="fb1c" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">接下来，我们需要建立一个模式(除非您的代码像Hibernates auto-DDL模式那样做)。我在这里使用的是<a class="ae lx" href="http://www.liquibase.org/" rel="noopener ugc nofollow" target="_blank"> Liquibase </a>，但是<a class="ae lx" href="https://www.testcontainers.org/modules/databases/#using-an-init-script-from-a-file" rel="noopener ugc nofollow" target="_blank">也可以通过参数</a>传递DDL脚本。</p><pre class="kn ko kp kq gu ly lz ma mb aw mc bi"><span id="bf66" class="ky kz ir lz b gz md me l mf mg">PGSimpleDataSource ds = new PGSimpleDataSource(); // <strong class="lz is">(5)</strong><br/><br/>// Datasource initialization<br/>ds.setUrl(<em class="mh">postgreSQLContainer</em>.getJdbcUrl());<br/>ds.setUser(<em class="mh">postgreSQLContainer</em>.getUsername());<br/>ds.setPassword(<em class="mh">postgreSQLContainer</em>.getPassword());<br/><br/>DatabaseConnection dbconn = new JdbcConnection(ds.getConnection());<br/>ResourceAccessor ra = new FileSystemResourceAccessor("src/test/sql");<br/>Liquibase liquibase = new Liquibase("dbinit.sql", ra, dbconn);//<strong class="lz is">(6)</strong><br/>liquibase.dropAll();<br/>liquibase.update(new Contexts());    // <strong class="lz is">(7)</strong></span></pre><p id="636c" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在(5)中，我建立了一个简单的数据源，然后对其进行参数化，并从中获得一个数据库连接。然后，我们(6)告诉Liquibase使用这个连接和我们的DDL脚本来用DDL更新数据库(7)，基本上是设置模式和测试数据。</p><p id="a927" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><strong class="jq is">使用模拟HTTP服务器</strong></p><p id="2746" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我的代码还向另一个服务发出http请求，这在我的服务测试期间不一定可用。但是没问题，有一个<a class="ae lx" href="https://www.testcontainers.org/modules/mockserver/" rel="noopener ugc nofollow" target="_blank"> Mockserver </a>可以实现这个目的。同样，我们首先定义服务器:</p><pre class="kn ko kp kq gu ly lz ma mb aw mc bi"><span id="0a34" class="ky kz ir lz b gz md me l mf mg">@ClassRule<br/>public static MockServerContainer <em class="mh">mockServer </em>= new MockServerContainer();</span></pre><p id="6087" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">然后再启动它:</p><pre class="kn ko kp kq gu ly lz ma mb aw mc bi"><span id="bcc3" class="ky kz ir lz b gz md me l mf mg"><em class="mh">mockServer</em>.start();<br/>System.<em class="mh">err</em>.println("Mock engine at http://" + <br/>      <em class="mh">mockServer</em>.getContainerIpAddress() + ":" + // <strong class="lz is">(8)</strong><br/>      <em class="mh">mockServer</em>.getServerPort());</span></pre><p id="4dcb" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">容器在“随机”位置暴露它们的端口以避免冲突(除非有不同的说明)。我们需要在(8)中获取端口，并告诉我们的代码服务器在哪里。</p><p id="fbab" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">现在的问题是服务器如何知道提供什么？有几种方法可以做这件事。我喜欢的一个是请求匹配和提供响应的流畅API。为此，我们需要类路径上的org . mock-server:mock server-client-Java。棘手的是客户端版本需要与Testcontainer的Mockserver中的服务器版本相匹配。解决这个问题后，我们可以在设置代码中使用它:</p><pre class="kn ko kp kq gu ly lz ma mb aw mc bi"><span id="5851" class="ky kz ir lz b gz md me l mf mg">new MockServerClient(<em class="mh">mockServer</em>.getContainerIpAddress(), <br/>                     <em class="mh">mockServer</em>.getServerPort())<br/>    .when(<em class="mh">request</em>()<br/>        .withPath("/api/v1/verifyPolicy")<br/>    )<br/>    .respond(<em class="mh">response</em>()<br/>        .withStatusCode(201)<br/>        .withHeader("Content-Type","application/json")<br/>        .withBody("{ \"msg\" : \"ok\" }")<br/>    );<br/></span><span id="d8c6" class="ky kz ir lz b gz mi me l mf mg">System.<em class="mh">setProperty</em>("engine/mp-rest/url",<br/>                   "http://" + <br/>                   <em class="mh">mockServer</em>.getContainerIpAddress() + <br/>                   ":" + <br/>                   <em class="mh">mockServer</em>.getServerPort());</span></pre><p id="b671" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><strong class="jq is">使用卡夫卡</strong></p><p id="8ded" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">最后但同样重要的是，我们看一下如何在Testcontainer中设置Kafka，并将其告知MicroProfile反应式消息客户端:</p><pre class="kn ko kp kq gu ly lz ma mb aw mc bi"><span id="0809" class="ky kz ir lz b gz md me l mf mg">@ClassRule<br/>private static KafkaContainer <em class="mh">kafka </em>= new KafkaContainer();</span></pre><p id="93ae" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我想你可以在这里看到一个模式:-)</p><pre class="kn ko kp kq gu ly lz ma mb aw mc bi"><span id="72f7" class="ky kz ir lz b gz md me l mf mg">// Start Kafka<br/><em class="mh">kafka</em>.start();<br/>// It is running, so pass the bootstrap server location to Quarkus<br/>String kafkaBootstrap =  <em class="mh">kafka</em>.getBootstrapServers();<br/>System.<em class="mh">setProperty</em>("kafka.bootstrap.servers", kafkaBootstrap);</span></pre><p id="2396" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">这种基本设置非常简单，没有必要处理所有遗留的麻烦。</p><h2 id="fd78" class="ky kz ir bd la lb lc dn ld le lf dp lg jz lh li lj kd lk ll lm kh ln lo lp lq bi translated">结论</h2><p id="58d3" class="pw-post-body-paragraph jo jp ir jq b jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh lv kj kk kl ik bi translated">Testcontainers可以为您提供一种非常容易地建立一个相对复杂的环境来测试您的代码的方法。这种设置可以用于CI系统，如Travis或其他支持Docker容器(Testcontainers依赖于Docker，所以目前不支持其他容器运行时)的地方，这些地方包括开发人员的机器。</p><p id="acbc" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">上面<a class="ae lx" href="https://github.com/RedHatInsights/custom-policies-ui-backend/blob/928a8648b3093d076272dcbb1731d5eef5de0605/src/test/java/com/redhat/cloud/custompolicies/app/RestApiTest.java#L66" rel="noopener ugc nofollow" target="_blank">的(大部分)例子的代码可以在网上找到</a>。</p></div></div>    
</body>
</html>