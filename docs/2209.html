<html>
<head>
<title>QuickCheck Testing in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang的快速检查测试</h1>
<blockquote>原文：<a href="https://itnext.io/quickcheck-testing-in-golang-772e820f0bd5?source=collection_archive---------7-----------------------#2019-04-16">https://itnext.io/quickcheck-testing-in-golang-772e820f0bd5?source=collection_archive---------7-----------------------#2019-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="cf42" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上一部:<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/types-and-specifications-c4d34ade6d5c">https://itnext.io/types-and-specifications-c4d34ade6d5c</a></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/444c64a5294db5223352c0c9549f992a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1xGCb5yXQySBsn_Y"/></div></div></figure><p id="86d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lb">“我们只看到我们知道的东西。”</em><strong class="js iu"><em class="lb"/>——</strong><a class="ae ko" href="https://en.wikipedia.org/wiki/Johann_Wolfgang_von_Goethe" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">歌德</strong> </a></p><p id="7d37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我上一篇关于测试的文章中，我介绍了QuickCheck的概念，使用了一种表面上是非类型化的语言clojure。虽然我认为基于规范的检查优于依赖类型系统来建立正确性，但是您可能会发现自己处于一种必须使用类型化语言的情况。我最喜欢的类型语言之一是混合函数/过程语言golang。Golang有对QuickCheck的原生支持，但是你使用它的方式与spec/check有很大的不同，它也不是erlang或Haskell中QuickCheck的全功能实现。尽管如此，这个包允许开发人员为他们的工作创建各种各样的模糊测试，只要有足够的时间和创造力，就可以产生强大的生成性测试。</p><h1 id="1b96" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">测试框架:goConvey</h1><p id="c076" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">在我开始写代码之前，我想向您介绍我最喜欢的golang测试框架之一:goConvey。虽然golang原生测试很棒，但它是相当程序化的，会导致大量围绕t.Fail()或t.Fatal()行的条件逻辑。虽然默认测试对于小项目来说已经足够了，但是goConvey可以进行更密集的测试，并且随着项目的增长，这些密集的测试可以更好地记录您的代码。此外，goConvey对函数的操作并不严格依赖于允许组合和数据驱动测试的条件。</p><p id="4e14" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然这在我的“玩错误的游戏”中有所涉及，但post goConvey还通过启动本地web服务器作为持续构建集成来促进TDD和代码覆盖。虽然我敦促您不要玩覆盖率游戏，但是简单地在浏览器上有一个快速的反馈，表明构建/测试在后台自动通过，这就创建了一个伟大的连续工作流。你可以在这里找到:<a class="ae ko" href="http://goconvey.co/" rel="noopener ugc nofollow" target="_blank">http://goconvey.co/</a></p><h1 id="541c" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">收集工具</h1><p id="3c9c" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">在基本层面上，testing/quick提供了两个工具:Check和CheckEqual。这些函数接受一个或两个函数和一个配置。Check就是CheckEqual，但第二个函数相当于“持续为真”。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/3302715680a7ca0c686c53d86200dc42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*2qezPmGmV5CZQ2PB"/></div></figure><p id="c2e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然QuickCheck在工作时总是很好，但使用它的原因是为了找到错误，为了找到错误，我们需要对产生错误的输入进行反馈。这些信息是在CheckError和CheckEqualError接口中捕获的。通过转换输出错误，我们可以看到调用计数、输入(表示为接口的一部分)以及在CheckEqualError的情况下不匹配的输出(也是接口的一部分)。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/5890b30c76c843bedb343a7b6deedd90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/0*HU2q0vgYOV4_NOG-"/></div></figure><h1 id="bc04" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">安排一些免费的午餐</h1><p id="9f25" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">虽然上面的内容非常简单，但为了便于讨论，让我们做一些真实的、简单明了的事情。一个纯函数可以很容易地与带有CheckEqual的简化函数相比较。回溯解析，不是因为它特别有趣，而是因为似乎有无数种方法可以做到这一点。我们将比较基于正则表达式的解析器和时间包中内置的解析器，以展示QuickCheck如何神奇地为我们完成所有工作，并在正则表达式中找到一个bug:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mh"><img src="../Images/611d91e341437a40b10b1eb18cafc035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aqOo4T0mCxx_4Ybi"/></div></div></figure><p id="5f00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">检查goConvey我发现这并不像希望的那么简单:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mi"><img src="../Images/78eb0c24edff4880a096ecff276c250b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e78RWmkJk_tblrJO"/></div></div></figure><p id="8ae1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">说明错误的静态测试通过了，但是QuickCheck无法找到可以在没有帮助的情况下找到错误的非常具体的字符串。增加迭代次数可能最终会找到无效的字符串，但是考虑到在任意长度的字符串中可能出现的难以想象的变化，增加迭代次数是没有用的。</p><h1 id="52b2" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">有限随机性</h1><p id="b21f" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">我们需要做的是帮助QuickCheck创建这些输入，就像我们在clojure规范中做的那样。对此有几种选择。如果您的输入不是简单类型，您可以实现Generate接口，或者您可以直接实现quick的“Values”函数。对于这个例子，我将选择后者。</p><p id="f2d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想在RFC3339规范有一些变化的地方创建测试。每个字符串的基本头应该相当一致，但有几个时区格式以及可能的毫秒/等。我用随机有效日期格式对此建模，但是用“垃圾”格式，我让随机生成来掩盖我在阅读RFC时的懒惰。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/9ac1c8c559612787ec80205420568583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/0*JPnHMZNm9sHCZeOw"/></div></figure><p id="0c4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">定义了TimeValues函数后，我们可以在quick的“值”部分使用它。配置以及更大的最大迭代次数，以便更有信心找到罪魁祸首:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mk"><img src="../Images/f15e25be3ad2273ac952f57ceef711f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Xk1oVRFyuZULRU1Q"/></div></div></figure><p id="bdf3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如希望的那样，QuickCheck为我们找到了一个无效的格式:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ml"><img src="../Images/4ecc31bb9818ed3664728f4e97986240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pfXTE4R4w9hyuTmu"/></div></div></figure><p id="aae4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，日期部分是不相关的，但祖鲁语/GMT时间丢失的“Z”很快被找到，我可以用它来修复这个错误。现在，很容易进一步探索这条道路，可能会加入更大的unicode字符或改变格式，但总的来说，这显示了如何检查单个函数。</p><h1 id="04be" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">顺序输入</h1><p id="35d0" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">纯函数的生成测试是有帮助的，它肯定能找到单元测试可能遗漏的极限情况。不过，用QuickCheck测试有状态系统会更好，这样可以发现更复杂的错误。这些更像是“组件”甚至“集成”级别的测试，golang中的QuickCheck确实给了我们这样做的方法。</p><p id="d54b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们有一个需要测试的API。有许多可能的端点/过程可用，我们希望找到在任意命令序列之后发生的任何问题。我们要保证的是，任何命令序列都不会导致数据库进入崩溃状态。下面的“API”说明了这一点</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/ed5462f737f0e9e23992f727fdcecd00.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/0*-YhQN1xEp-WzUmyE"/></div></figure><p id="c5d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它有一个处理程序和一些状态，如果我们按顺序运行事件1到6并生成一个“错误”，它将进行跟踪。您可以想象这些整数查找可能是命令映射的关键，但是为了便于讨论，这是一个非常简单的API，它只是直接获取整数值。我们还需要一些辅助函数来将事物连接在一起:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/bfa3465990873b924e2bcd3b4b1bdfb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/0*QMvvAPRtFe3IDsDC"/></div></figure><p id="30e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一种方法是快速获得一个能够正确处理负值的余数函数，这样我们就可以使用默认情况下int64的QuickCheck提供给我们的任意切片。第二个是一个函数，它接受一个API，按顺序运行给定的事件，并在API“is broken”的任何时候返回false。有了这些工具，我们可以使用quickCheck找到破坏API的事件序列:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/df3ee81b2fc9d815ba5034b97bad716f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/0*DhsByh96G1pu9krC"/></div></figure><p id="d69b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它传递给我们一个破坏API的序列:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mp"><img src="../Images/eebd7095d1445e618774b62833e5f050.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-dUy1YwExiCmXblT"/></div></div></figure><p id="2599" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这不是理想的解决方案(真正的QuickCheck会将输入减少到最小可能的解决方案，golang不会免费提供给我们)，但它是“破坏”测试中的API的解决方案之一。</p><p id="a815" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然QuickCheck的这种实现并没有完全达到最小故障集，但是它允许对纯函数进行定制的模糊测试，并且如上所述，在处理诸如API、外部数据库等系统时，还可以运行更多的有状态系统测试。代码示例可在此处找到:</p><p id="d01d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://github.com/weberr13/Kata/blob/master/gogen/gen_test.go" rel="noopener ugc nofollow" target="_blank">https://github . com/weberr 13/Kata/blob/master/gogen/gen _ test . go</a></p><p id="3dde" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为回购协议中的所有内容都是在麻省理工学院的许可下呈现的。</p><p id="1fa6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">系列下一篇:<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/gopter-property-based-testing-in-golang-b36728c7c6d7">https://it next . io/go pter-property-based-testing-in-golang-b 36728 c 7 c 6d 7</a></p></div></div>    
</body>
</html>