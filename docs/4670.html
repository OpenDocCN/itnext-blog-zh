<html>
<head>
<title>Defaults are hard: Kubernetes Deployment edition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">默认是困难的:Kubernetes部署版</h1>
<blockquote>原文：<a href="https://itnext.io/defaults-are-hard-kubernetes-deployment-edition-3b11095792f2?source=collection_archive---------3-----------------------#2020-08-19">https://itnext.io/defaults-are-hard-kubernetes-deployment-edition-3b11095792f2?source=collection_archive---------3-----------------------#2020-08-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1a68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我在谷歌GKE团队的一个同事刚刚遇到了一个非常奇怪的问题。她正在用正在开发的新映像更新现有的部署，所以她在映像上使用了<code class="fe ko kp kq kr b">:latest</code>标记，而没有设置<code class="fe ko kp kq kr b">imagePullPolicy</code>。毕竟,<a class="ae ks" href="https://kubernetes.io/docs/concepts/containers/images/#updating-images" rel="noopener ugc nofollow" target="_blank"> Kubernetes文档指出,</a>:</p><blockquote class="kt ku kv"><p id="8238" class="jq jr kw js b jt ju jv jw jx jy jz ka kx kc kd ke ky kg kh ki kz kk kl km kn im bi translated">如果你想总是强制拉，你可以…省略<code class="fe ko kp kq kr b">imagePullPolicy</code>，使用<code class="fe ko kp kq kr b">:latest</code>作为图像的标签。</p></blockquote><p id="9eef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">没问题吧？然而，她节点上的图像顽固地拒绝更新。这是为什么？</p><p id="64d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="kw">更新(2021年3月):</em> </strong> <em class="kw">文档</em> <a class="ae ks" href="https://github.com/kubernetes/website/pull/26661" rel="noopener ugc nofollow" target="_blank"> <em class="kw">现在提供了答案</em> </a> <em class="kw">，但当时没有。</em></p><p id="d514" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">经过几个小时的困惑，她<a class="ae ks" href="https://github.com/kubernetes-sigs/multi-tenancy/issues/1025#issuecomment-675738933" rel="noopener ugc nofollow" target="_blank">找到了自己的答案</a>。记得我说过她是在<em class="kw">更新</em>她的部署，而不是<em class="kw">创建</em>它吗？事实证明，她的部署的最初版本没有<em class="kw">而不是</em>使用<code class="fe ko kp kq kr b">:latest</code>标签——它使用了一个真实的、真实的、不应该被删除的图片。因此，当她创建没有<code class="fe ko kp kq kr b">imagePullPolicy</code>的部署时，Kubernetes很有帮助地将策略设置为<code class="fe ko kp kq kr b">IfNotPresent</code>——然后保持这个新的默认值。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi la"><img src="../Images/33d1c293bcf0015b9d46bcaa996361c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5S0JslyxyrXjvTuZCfAvxw.jpeg"/></div></div></figure><p id="f2a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这一点上，我应该提一下，我成为GKE团队的一员已经将近两年了，她在团队中的时间大约是一半。虽然我们不是专业的GKE <em class="kw">操作员</em>，但我们在开发<a class="ae ks" href="https://kubernetes.io/blog/2020/08/14/introducing-hierarchical-namespaces/" rel="noopener ugc nofollow" target="_blank">相当复杂的功能</a>的同时，已经持续开发和部署了大约一年的工作负载。我们绝不是新手。而我们<em class="kw">还是</em>被绊倒了。</p><p id="60e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个问题的根源是<em class="kw">持久的、依赖的默认值</em>的概念。也就是说，当一个字段(<code class="fe ko kp kq kr b">imagePullPolicy</code>)未置位时，其值根据另一个字段(<code class="fe ko kp kq kr b">image</code>字段上的标签)的<em class="kw">来确定。但是当第二个字段改变时，第一个字段没有改变。哎呀。</em></p><p id="4b70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个问题的一个可能的直接解决方案是简单地将<code class="fe ko kp kq kr b">imagePullPolicy</code>改为<code class="fe ko kp kq kr b">Always</code>。正如<a class="ae ks" href="https://kubernetes.io/docs/concepts/configuration/overview/#container-images" rel="noopener ugc nofollow" target="_blank">完全不同的doc </a>有益地指出的:</p><blockquote class="kt ku kv"><p id="9761" class="jq jr kw js b jt ju jv jw jx jy jz ka kx kc kd ke ky kg kh ki kz kk kl km kn im bi translated"><strong class="js iu">注意:</strong>底层图像提供者的缓存语义使得<code class="fe ko kp kq kr b">imagePullPolicy: Always</code>也很高效。例如，使用Docker，如果图像已经存在，则拉取尝试会很快，因为所有图像层都被缓存，并且不需要下载图像。</p></blockquote><p id="39d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然这是真的，但它确保了当您启动一个pod时，您的容器注册表<em class="kw">保证</em>在关键路径上。在开发过程中，这几乎肯定没问题，但是如果您的pod频繁重启，就要小心了。</p><p id="b217" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">添加一个警告(<a class="ae ks" href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-api-machinery/1693-warnings" rel="noopener ugc nofollow" target="_blank">在1.19 </a>中新增)来捕捉这种情况也不错，但是这说起来容易做起来难。正如一位<a class="ae ks" href="https://twitter.com/liggitt" rel="noopener ugc nofollow" target="_blank">资深撰稿人</a>向我解释的那样(在我抱怨了一下我们的不幸之后):</p><blockquote class="kt ku kv"><p id="2661" class="jq jr kw js b jt ju jv jw jx jy jz ka kx kc kd ke ky kg kh ki kz kk kl km kn im bi translated">这实际上是客户端应用程序和来自其他字段的默认值之间的一种不幸的交互。这两者结合在一起，很难也不可能检测到您所描述的级别的问题。</p><p id="218c" class="jq jr kw js b jt ju jv jw jx jy jz ka kx kc kd ke ky kg kh ki kz kk kl km kn im bi translated"><code class="fe ko kp kq kr b">kubectl apply</code>(更新现有对象时)提交<strong class="js iu">补丁，</strong>不完整对象，基于您正在应用的清单和您上次应用的内容(存储为对象上的注释)之间的差异。如果您添加了<code class="fe ko kp kq kr b">--v=8</code>,那么您只能看到在补丁请求正文中发送的图像字段。</p><p id="f346" class="jq jr kw js b jt ju jv jw jx jy jz ka kx kc kd ke ky kg kh ki kz kk kl km kn im bi translated">在REST处理程序或准入看到新对象之前，补丁被应用于现有对象以计算通用补丁处理层中的“新对象”,因此当REST处理程序或验证或准入看到旧/新对象时，不可能辨别出<code class="fe ko kp kq kr b">imagePullPolicy</code>是用户设置的还是默认的，以及新对象中的<code class="fe ko kp kq kr b">imagePullPolicy</code>是由传入补丁设置的还是从现有对象继承的。</p><p id="5cc8" class="jq jr kw js b jt ju jv jw jx jy jz ka kx kc kd ke ky kg kh ki kz kk kl km kn im bi translated">顺便说一句，正是因为这个原因，像这样的派生默认值是非常有问题的。如果用户在更新时更改输入字段，他们可以保留基于旧值的默认值。这就是为什么在apps/v1部署中，选择器和标签不再默认为pod模板标签。</p></blockquote><p id="7115" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，如果你是一个API设计者，请非常仔细地考虑这些相关的默认设置。与此同时，我要去写一篇<a class="ae ks" href="https://github.com/kubernetes/website/pull/26661" rel="noopener ugc nofollow" target="_blank">文档公关</a>。</p><p id="a720" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="kw">感谢</em> <a class="ae ks" href="https://www.linkedin.com/in/yiqigao" rel="noopener ugc nofollow" target="_blank"> <em class="kw">高</em> </a> <em class="kw">调试问题，感谢</em><a class="ae ks" href="https://twitter.com/liggitt" rel="noopener ugc nofollow" target="_blank"><em class="kw">Jordan Liggitt</em></a><em class="kw">提供大量有趣的背景资料。照片由米格尔·Á拍摄。佩克斯的帕德里安。</em></p></div></div>    
</body>
</html>