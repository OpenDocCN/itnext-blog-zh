<html>
<head>
<title>Kubernetes without Nodes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">没有节点的Kubernetes</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-without-nodes-caedd172f940?source=collection_archive---------3-----------------------#2020-04-06">https://itnext.io/kubernetes-without-nodes-caedd172f940?source=collection_archive---------3-----------------------#2020-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="df77" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用虚拟Kubelet探索无服务器节点</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0febfc194af57b887e0a9b828d060a07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fTS1mpMgHtgo0Q_muPsUEA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/photos/dVRD8E3XUGs" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/dVRD8E3XUGs</a></figcaption></figure><p id="76a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虚拟Kubelet模拟Kubernetes API的一个节点。它允许在例如无服务器容器服务上调度pod。</p><p id="4e80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无服务器容器服务在<a class="ae ky" href="https://azure.microsoft.com/en-us/services/container-instances/" rel="noopener ugc nofollow" target="_blank"> Azure </a>、<a class="ae ky" href="https://cloud.google.com/run" rel="noopener ugc nofollow" target="_blank"> GCE </a>、<a class="ae ky" href="https://aws.amazon.com/fargate/" rel="noopener ugc nofollow" target="_blank"> AWS </a>上可用，并允许创建、运行和缩放容器。它们提供了很多很棒的东西，比如无限的伸缩性、快速的启动时间和每秒计费。我们能否利用这些优势，同时仍然像过去一样与Kubernetes互动？</p><h2 id="bdbb" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">有关系的</h2><ul class=""><li id="5f3a" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated"><a class="ae ky" href="https://medium.com/@wuestkamp/kubernetes-serverless-simply-visually-explained-ccf7be05a689?sk=142c4725e110bcd9ad67f93bd2b37ede" rel="noopener"> Kubernetes无服务器简单直观解释</a></li></ul><h1 id="e220" class="mz lw it bd lx na nb nc ma nd ne nf md jz ng ka mg kc nh kd mj kf ni kg mm nj bi translated">库伯莱到底是什么？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/c55e1a581131a5c4ce8225bcbd8b9d86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Awdkj27aBWdTt90DBaePCQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">这张图应该能说明一切。</figcaption></figure><p id="36af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn no b">kubelet</code>是节点的入口点。Kubernetes中的一个节点通常是一个虚拟机，但也可能是一个物理服务器。一个节点唯一需要的就是所谓的<code class="fe nl nm nn no b">kubelet</code>(以及<code class="fe nl nm nn no b">kubelet</code>需要的任何工具)。这个CLI程序在虚拟机上运行，可以做一件主要的事情:<strong class="lb iu">管理pod</strong>。</p><h2 id="6236" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">库伯莱</h2><p id="4fb1" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><code class="fe nl nm nn no b">kubelet</code>是一个HTTPS服务器和客户端。它连接到Kubernetes API并被其连接。这样它就能接收到指令来安排或杀死哪一个吊舱。</p><p id="2c8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn no b">kubelet</code>可以管理pod，这意味着它可以根据收到的PodSpec创建、维护和删除pod。它通过与容器运行时引擎(通常是Docker)通信来实现这一点。</p><p id="d64e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦<code class="fe nl nm nn no b">kubelet</code>在一个虚拟机上运行并连接到Kubernetes API服务器，该虚拟机就被注册为一个节点，并可用于调度pods。</p><h2 id="6a02" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">调度程序</h2><p id="7631" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">Kubernetes中的调度程序负责决定在哪个节点上调度一个pod。做出决策时要考虑各种因素，如节点状态、空闲资源或自定义节点选择器。</p><h2 id="990f" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结节</h2><p id="17f8" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">简单地说，Kubernetes节点就是一个可以调度pod的东西。Kubernetes API知道它的存在、状态、各种度量和信息。API从运行在每个节点上的<code class="fe nl nm nn no b">kubelet</code>获取这些数据。</p><p id="255b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，为什么不欺骗Kubernetes API，让它相信自己在与一个节点对话，而不是与它对话呢？没错。</p><h1 id="e359" class="mz lw it bd lx na nb nc ma nd ne nf md jz ng ka mg kc nh kd mj kf ni kg mm nj bi translated">虚拟库伯勒</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/cc350f37582a44425f63e98de2603cdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hqQX45UHlbyk8eqYtxvlcA.png"/></div></div></figure><p id="9e3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虚拟的Kubelet欺骗Kubernetes API，让它相信自己在与一个实际的节点对话。嗯，这并不是欺骗，因为API想要的只是一些它可以调度pods并从中接收度量和信息的东西。考虑到这一点，措辞“欺骗”可能有点太苛刻，我们仍然给API它想要的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/460e856d4d75bedd75221810304a8c46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fT-sApYiRSerdz8BjBsTWg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://virtual-kubelet.io/" rel="noopener ugc nofollow" target="_blank">https://virtual-kube let . io</a></figcaption></figure><h2 id="1762" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">混合节点设置</h2><p id="05ae" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">如上图所示，一个集群可以同时包含真实节点和虚拟Kubelet节点。调度可以像往常一样用节点标签、标签选择器、污点、容忍度等来控制。</p><h2 id="de42" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">无限的资源</h2><p id="1d90" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">虚拟的Kubelet可以告诉K8s API，它有无限的或者至少是非常大量的可用免费资源。通过这种方式，至少在考虑空闲资源时，总是会考虑调度。</p><h2 id="7f6e" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">用例</h2><p id="5fa2" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">当使用云提供商的无服务器容器产品作为虚拟Kubelet的提供商/后端时，我们可以获得:</p><ul class=""><li id="bfe8" class="mo mp it lb b lc ld lf lg li nu lm nv lq nw lu mv mw mx my bi translated">无限制缩放</li><li id="21cd" class="mo mp it lb b lc nx lf ny li nz lm oa lq ob lu mv mw mx my bi translated">无需集群自动扩展(无需等待添加新节点)</li><li id="6444" class="mo mp it lb b lc nx lf ny li nz lm oa lq ob lu mv mw mx my bi translated">快速启动时间</li><li id="8231" class="mo mp it lb b lc nx lf ny li nz lm oa lq ob lu mv mw mx my bi translated">每秒计费</li><li id="bdd6" class="mo mp it lb b lc nx lf ny li nz lm oa lq ob lu mv mw mx my bi translated">更细粒度的云资源使用</li></ul><h2 id="2ed8" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">提供商/后端</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/b570952a5586893421dd78e3f0711ef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-c5bFiN2XmSv_BH-LfGAwA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">https://virtual-kubelet.io/docs/providers/<a class="ae ky" href="https://virtual-kubelet.io/docs/providers/" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><h2 id="352e" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">在集群内部或外部运行</h2><p id="5046" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">虚拟Kubelet可以在任何地方运行，只要它可以与Kubernetes API通信。因此，这也可以作为同一个集群内的pod中的容器。还有掌舵图:【https://virtual-kubelet.io/docs/usage】T4</p><p id="dd0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虚拟Kubelet有点像K8s API和可以运行容器的东西之间的代理。</p><h1 id="8bf5" class="mz lw it bd lx na nb nc ma nd ne nf md jz ng ka mg kc nh kd mj kf ni kg mm nj bi translated">没有节点的Kubernetes？</h1><p id="c606" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">所以我们正在运行一个没有节点的Kubernetes集群？不完全是，仍然有节点，但这些节点不再受虚拟机或物理机支持。所以也许就像“有演技没演技”(Seinfeld @ Curb)；)</p><h1 id="f5c4" class="mz lw it bd lx na nb nc ma nd ne nf md jz ng ka mg kc nh kd mj kf ni kg mm nj bi translated">它看起来怎么样</h1><p id="dff3" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">开始使用Azure很容易，因为他们已经将虚拟Kubelet作为一个选项集成到他们的托管Kubernetes解决方案中。在这里阅读如何设置它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/b8b044d3d8c31f59290666ea21361873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gW0VP6JRBjK-_djk-mVucQ.png"/></div></div></figure><p id="df46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面我们看到两个普通节点(由虚拟机支持)和一个虚拟节点(由Azure ACI支持)。默认情况下，虚拟节点有一个污点，以防止不必要的调度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/ba60cf408f4c2420fd936958e0452ed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5-5l7BfA4FYB-vjL-qGipw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我们通过向PodSpec添加一个容差，计划在虚拟节点上部署5个pod</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/6ef6e190690368f2c9c75aa9be0d4b3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K6Mo4lMikbYP1DGtN2FV0w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">这5个实例由Azure容器实例运行</figcaption></figure><h1 id="961c" class="mz lw it bd lx na nb nc ma nd ne nf md jz ng ka mg kc nh kd mj kf ni kg mm nj bi translated">虚拟Kubelet + Knative / OpenFaaS</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/54a95a17c192601ebbf6d2b35ec953a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*m_pSaKy2v3e2LkqRdFfMWQ.png"/></div></figure><p id="46ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Virtual Kubelet和Knative或OpenFaaS联合起来可能是一个强大的组合。基于事件创建pods无服务器，并通过Virtual Kubelet在无服务器的云后端执行这些操作。我将在接下来的另一篇文章中更深入地探讨这种组合。</p><h1 id="a4b4" class="mz lw it bd lx na nb nc ma nd ne nf md jz ng ka mg kc nh kd mj kf ni kg mm nj bi translated">概述</h1><p id="d84b" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">虚拟Kubelet允许更精确的资源使用。使用计算实例(虚拟机)时，您可能总是会分配比所需更多的资源(CPU/内存)。</p><p id="bd93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您向群集添加一个新的2 GB节点，以便可以计划另一个100MB Pod，那么这不是最佳选择。有了像on <a class="ae ky" href="https://azure.microsoft.com/en-us/services/container-instances/" rel="noopener ugc nofollow" target="_blank"> Azure </a>、<a class="ae ky" href="https://cloud.google.com/run" rel="noopener ugc nofollow" target="_blank"> GCE </a>、<a class="ae ky" href="https://aws.amazon.com/fargate/" rel="noopener ugc nofollow" target="_blank"> AWS </a>这样的无服务器容器服务，我们可以像一个大集体一样共享资源，从而实现更优化的使用。</p><p id="0694" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看来无服务器不会这么快取代Kubernetes？激动人心的时刻。</p><h1 id="e159" class="mz lw it bd lx na nb nc ma nd ne nf md jz ng ka mg kc nh kd mj kf ni kg mm nj bi translated">来源</h1><p id="0ae5" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/virtual-kubelet/virtual-kubelet" rel="noopener ugc nofollow" target="_blank">https://github.com/virtual-kubelet/virtual-kubelet</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><h1 id="dedc" class="mz lw it bd lx na nb nc ma nd ne nf md jz ng ka mg kc nh kd mj kf ni kg mm nj bi translated">成为Kubernetes认证</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://killer.sh"><div class="gh gi oj"><img src="../Images/cf3901a56841fcb55f9e4e17b9f07672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Kbj17_6VncUuoBqNsAzzg.png"/></div></a><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://killer.sh" rel="noopener ugc nofollow" target="_blank"> https://killer.sh </a></figcaption></figure></div></div>    
</body>
</html>