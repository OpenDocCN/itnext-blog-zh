<html>
<head>
<title>Preemptive tactics to improve your Lighthouse score</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">先发制人的策略，以提高您的灯塔得分</h1>
<blockquote>原文：<a href="https://itnext.io/preemptive-tactics-to-improve-your-lighthouse-score-348ca88f392?source=collection_archive---------7-----------------------#2019-09-03">https://itnext.io/preemptive-tactics-to-improve-your-lighthouse-score-348ca88f392?source=collection_archive---------7-----------------------#2019-09-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/10ef54e197284321863dfd14d12c8ae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H_aUbCCbta1GPFAG9ANESA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片鸣谢:<a class="ae kc" href="https://fly.io/articles/lighthouse-how-to-reduce-render-blocking-scripts/" rel="noopener ugc nofollow" target="_blank"> fly.io </a></figcaption></figure><p id="e6b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有什么比在几个月的辛勤工作后部署您的应用程序，却发现它有一个可怕的Lighthouse性能分数更糟糕的了。如果你的应用程序因其低性能指标而被搜索引擎惩罚，或者更糟糕的是，如果你的用户在浏览器加载和解析3Mb转基因JavaScript所需的5秒钟后逃离你的登录页面，那么你在TDD、DRY、SEO和其他流行词汇上投入的所有时间都是徒劳的。</p><p id="7130" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">网络捆扎机的出现极大地提高了我们的生产力；包管理器的发展使得共享和重用代码变得更加容易；但在这个过程中，我们已经失去了对应用程序大小的控制，我们已经看不到我们的依赖性，我们已经放弃了管理何时加载和执行特定脚本的能力——这只是一个难以理解的聚合填充的大垃圾堆。唉，另一个带有一些神奇配置和大量正则表达式的webpack插件不会修复困扰你的应用程序的架构缺陷。</p><p id="5da0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也就是说，你必须在发展的所有阶段考虑你的Lighthouse分数:试图回顾性地提高性能是很难的，如果不是不可能的话。以下是我在处理服务器端渲染的单页应用程序时学到的一些经验。</p><ol class=""><li id="1882" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kf ir">找回你的AMD思维</strong></li></ol><p id="feee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">异步模块定义是几年前的热门话题，我仍然对我用AMD原则编写的代码感到满意。逻辑很简单:当页面的特定部分需要一些JS爱时，定义一个模块及其依赖项，等待依赖项加载，然后执行代码。执行流程是透明和可靠的，最重要的是它是高效的——您只在需要的时候加载需要的内容。</p><p id="3203" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们想要显示一个谷歌地图。它对我们的SEO没有影响，我们不需要它预先呈现，我们甚至不需要它显示，直到用户向下滚动到我们页面的特定部分。即使你的应用程序没有预渲染，也没有理由让谷歌地图屏蔽你的页面。如果你在使用谷歌地图的页面上运行灯塔检查，你会看到，它对性能有多么可怕的影响。</p><p id="b826" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个不同的方法(我以前给<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/vue-ssr-and-external-dependencies-bce84fbcbe6d">写过一篇关于它的文章</a>)。我使用的是Vue.js组件，但这适用于任何前端框架。其思想是只有当组件被挂载时才加载依赖项，并在依赖项被加载时呈现它。</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="9f83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 2。保持</strong> <code class="fe lq lr ls lt b"><strong class="kf ir">&lt;head&gt;</strong></code> <strong class="kf ir">灯</strong></p><p id="bf8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们被截止日期赶得很急时，很容易把事情放在<code class="fe lq lr ls lt b">&lt;head&gt;</code>中继续前进，但即使是一个<code class="fe lq lr ls lt b">&lt;script&gt;</code>或<code class="fe lq lr ls lt b">&lt;link&gt;</code>标签也会对性能产生相当大的影响。第三方脚本、字体、样式表——都需要加载和解析，这让用户一直在等待。</p><p id="a06e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 2.1。</strong> <code class="fe lq lr ls lt b"><strong class="kf ir">&lt;script&gt;</strong></code></p><p id="8c36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我上面概述的方法允许您在尝试对其进行操作之前，确保第三方脚本已加载。如果您正在加载一个可以独立执行的脚本，请确保异步并延迟它，使其不阻塞<code class="fe lq lr ls lt b">&lt;script async defer src=""/&gt;</code>。也就是说，如果有令人信服的理由将脚本放在文档的头部，那么它很有可能会出现在文档的末尾，在结束的<code class="fe lq lr ls lt b">&lt;/body&gt;</code>标记之前。渴望我们的数据的服务，如谷歌分析，会希望你在头部加载他们的脚本，但你会因此受到Lighthouse的惩罚。我是一个注重隐私的开发人员，所以我不听:我的首选方法是请求用户允许被跟踪，然后通过附加一个脚本标签异步加载脚本(如我的第一个示例所示)。</p><p id="f4b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 2.2。</strong> <code class="fe lq lr ls lt b"><strong class="kf ir">&lt;link rel="stylesheet" /&gt;</strong></code></p><p id="6715" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我发现，添加一个可以忽略的延迟，并在稍后阶段向文档添加一个链接标签，对Lighthouse得分有积极的影响。像外部字体和样式表这样的东西会降低你的页面速度，所以如果你可以忍受没有漂亮字体和图标的小延迟，考虑做以下事情:</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="f61f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 3。惰性加载可视资产</strong></p><p id="8cc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图像和视频嵌入可以大大减少第一次有意义的绘画的时间，它将帮助您的灯塔得分，以消除渲染块，这是在折叠下，也就是说，直到你的访问者向下滚动才可见。在某些情况下，图片可以帮助你的搜索引擎优化，所以你需要在内容和性能之间取得平衡。</p><p id="96ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">说到图像，看看鲜为人知的<code class="fe lq lr ls lt b">srcset</code>和<code class="fe lq lr ls lt b">decoding</code>属性。<a class="ae kc" href="https://survivejs.com/webpack/loading/images/" rel="noopener ugc nofollow" target="_blank">使用webpack </a>，通过提供所有evergreen浏览器都支持的<code class="fe lq lr ls lt b">srcset</code>属性，您可以提供一组基于屏幕分辨率的优化图像。这是您在项目开始时需要考虑的事情，并确保您的组件是兼容的。属性可以用来延迟图像的解码，帮助T7减少页面的绘制时间。</p><p id="6178" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当涉及到视频和其他嵌入时，请记住，它们中的大多数都带有JavaScript和cookie包。作为一名注重隐私的开发人员，我更喜欢隐藏视频，直到用户与它交互，即显示一个带有播放按钮的海报图像，并在用户明确决定点击它观看视频时用iframe替换它。</p><p id="d063" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也许在处理图像和视频时，最有用的工具是<code class="fe lq lr ls lt b">IntersectionObserver</code>。我发现，如果你只是在它们被滚动到视图中时才显示它们，这真的有助于你的灯塔得分。</p><p id="b104" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是我在Noah UI 中使用的一些代码，用于延迟图像加载，直到组件被滚动到视图中。当您需要实现无限滚动或发出昂贵的服务器请求时，这也很有帮助。</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="lo lp l"/></div></figure></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><p id="e8b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这只是冰山一角。达到100%的Lighthouse分数并不容易，尤其是当您的应用程序增长时，因此尽早做出与性能相关的架构决策非常重要。仔细检查数百个组件并对其进行追溯性调整并不是一件容易的事情。</p><p id="f0f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为我们还应该意识到，捆绑器并不真正适合未来的网络，一旦我们忘记了过去噩梦般的浏览器和服务器，转而使用ES模块和HTTP 2，它们将发挥更小的作用。代码分割和树抖动只能帮助我们这么多——重要的是我们要了解我们的应用程序如何以及何时与第三方交互，以及它们如何消耗浏览器资源——把所有的信心都放在捆绑器上不会让我们的应用程序更高效。</p></div></div>    
</body>
</html>