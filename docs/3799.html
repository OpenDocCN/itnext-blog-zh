<html>
<head>
<title>Curveball — A typescript microframework with first class AWS Lambda and HTTP/2 Push support</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">curve ball——一个具有一流AWS Lambda和HTTP/2推送支持的类型脚本微框架</h1>
<blockquote>原文：<a href="https://itnext.io/curveball-a-typescript-microframework-with-first-class-aws-lambda-and-http-2-push-support-6efeba66ca45?source=collection_archive---------1-----------------------#2020-02-27">https://itnext.io/curveball-a-typescript-microframework-with-first-class-aws-lambda-and-http-2-push-support-6efeba66ca45?source=collection_archive---------1-----------------------#2020-02-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="870e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自2018年年中以来，我们一直在开发一个新的微框架，用typescript编写。该框架与<a class="ae kl" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>竞争，并从<a class="ae kl" href="https://koajs.com/" rel="noopener ugc nofollow" target="_blank"> Koa </a>获得大量灵感。叫做<a class="ae kl" href="https://github.com/curveball" rel="noopener ugc nofollow" target="_blank">曲球</a>。</p><p id="272f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你只与Express合作过，我觉得对大多数人来说，这个项目会感觉像是一个巨大的进步。Express实际上是在Node.js的早期编写的，那时Promises和async/await还不常见，所以最大的变化是始终使用async/await中间件。</p><p id="69f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你是从Koa来的，那应该已经很熟悉了。与Koa相比，主要区别如下:</p><ul class=""><li id="4a91" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">曲球是用打字稿写的</li><li id="4e5d" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">它具有强大的内置支持HTTP/2 push。</li><li id="3756" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">原生支持在AWS Lambda上运行服务器，无需使用<a class="ae kl" href="https://github.com/awslabs/aws-serverless-express/blob/master/src/index.js" rel="noopener ugc nofollow" target="_blank">奇怪的黑客</a>。</li><li id="9c6f" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">Curveball的请求/响应对象与Node.js <code class="fe la lb lc ld b">http</code>库解耦。</li></ul><p id="938f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae kl" href="https://badgateway.net/" rel="noopener ugc nofollow" target="_blank"> Bad Gateway </a>过去几年里，我们已经在各种各样的(主要是API)项目中使用了这种方法，它对我们来说非常有效。我们还发现，它往往是一种相当“粘性”的产品。接触到它的人也倾向于在他们的下一个项目中使用它。</p><p id="30aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好奇？以下是一些常见任务的示例:</p><h1 id="611e" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">例子</h1><h2 id="c6bc" class="mc lf iq bd lg md me dn lk mf mg dp lo jy mh mi ls kc mj mk lw kg ml mm ma mn bi translated">你好世界</h2><pre class="mo mp mq mr gt ms ld mt mu aw mv bi"><span id="a2a9" class="mc lf iq ld b gy mw mx l my mz">import { Application } from '@curveball/core';<br/><br/>const app = new Application();<br/>app.use( async ctx =&gt; {<br/>  ctx.response.type = 'text/plain';<br/>  ctx.response.body = 'hello world';<br/>});<br/><br/>app.listen(80);</span></pre><p id="e9c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一切都是中间件，中间件可能是也可能不是<code class="fe la lb lc ld b">async</code>。</p><h2 id="f49d" class="mc lf iq bd lg md me dn lk mf mg dp lo jy mh mi ls kc mj mk lw kg ml mm ma mn bi translated">AWS Lambda上的Hello world</h2><pre class="mo mp mq mr gt ms ld mt mu aw mv bi"><span id="c5ed" class="mc lf iq ld b gy mw mx l my mz">import { Application } from '@curveball/core';<br/>import { handler } from '@curveball/aws-lambda';<br/><br/>const app = new Application();<br/>app.use( ctx =&gt; {<br/>  ctx.response.type = 'text/plain';<br/>  ctx.response.body = 'hello world';<br/>});<br/><br/>exports.handler = handler(app);</span></pre><h2 id="5b66" class="mc lf iq bd lg md me dn lk mf mg dp lo jy mh mi ls kc mj mk lw kg ml mm ma mn bi translated">HTTP/2推送</h2><pre class="mo mp mq mr gt ms ld mt mu aw mv bi"><span id="7d90" class="mc lf iq ld b gy mw mx l my mz">const app = new Application();<br/>app.use( ctx =&gt; {<br/>  ctx.response.type = 'text/plain';<br/>  ctx.body = 'hello world';<br/><br/>  ctx.push( pushCtx =&gt; {<br/><br/>    pushCtx.path = '/sub-item';<br/>    pushCtx.response.type = 'text/html';<br/>    pushCtx.response.body = '&lt;h1&gt;Automatically pushed!&lt;/h1&gt;';<br/><br/>  });<br/><br/>});</span></pre><p id="d7a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对<code class="fe la lb lc ld b">ctx.push</code>的回调只有在客户端支持推送的情况下才会被调用，因为它创建了一个新的“上下文”，任何中间件都可以被附加到它上面，甚至通过执行一个“子请求”来调用所有的中间件。</p><h2 id="5dd2" class="mc lf iq bd lg md me dn lk mf mg dp lo jy mh mi ls kc mj mk lw kg ml mm ma mn bi translated">基于资源的控制器</h2><p id="9dba" class="pw-post-body-paragraph jn jo iq jp b jq nb js jt ju nc jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk ij bi translated">控制器是可选的和固执己见的。单个控制器应该只管理一种类型的资源或一条路由。</p><pre class="mo mp mq mr gt ms ld mt mu aw mv bi"><span id="9be2" class="mc lf iq ld b gy mw mx l my mz">import { Application, Context } from '@curveball/core';<br/>import { Controller } from '@curveball/controller';</span><span id="1ad4" class="mc lf iq ld b gy ng mx l my mz">const app = new Application();</span><span id="2003" class="mc lf iq ld b gy ng mx l my mz">class MyController extends Controller {</span><span id="ad68" class="mc lf iq ld b gy ng mx l my mz">  get(ctx: Context) {</span><span id="68ba" class="mc lf iq ld b gy ng mx l my mz">    // This is automatically triggered for GET requests</span><span id="c386" class="mc lf iq ld b gy ng mx l my mz">  }</span><span id="46c7" class="mc lf iq ld b gy ng mx l my mz">  put(ctx: Context) {</span><span id="577e" class="mc lf iq ld b gy ng mx l my mz">    // This is automatically triggered for PUT requests</span><span id="3085" class="mc lf iq ld b gy ng mx l my mz">  }</span><span id="bbc9" class="mc lf iq ld b gy ng mx l my mz">}</span><span id="03af" class="mc lf iq ld b gy ng mx l my mz">app.use(new MyController());</span></pre><p id="d2f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">控制器是可选的和固执己见的。单个控制器应该只管理一种类型的资源或一条路由。</p><h2 id="74c4" class="mc lf iq bd lg md me dn lk mf mg dp lo jy mh mi ls kc mj mk lw kg ml mm ma mn bi translated">按指定路线发送</h2><p id="ad33" class="pw-post-body-paragraph jn jo iq jp b jq nb js jt ju nc jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk ij bi translated">推荐的模式是每条路由只使用一个控制器。</p><pre class="mo mp mq mr gt ms ld mt mu aw mv bi"><span id="bdde" class="mc lf iq ld b gy mw mx l my mz">import { Application } from '@curveball/core';<br/>import router from '@curveball/router';<br/><br/>const app = new Application();<br/><br/>app.use(router('/articles', new MyCollectionController());<br/>app.use(router('/articles/:id', new MyItemController());</span></pre><h2 id="7c4f" class="mc lf iq bd lg md me dn lk mf mg dp lo jy mh mi ls kc mj mk lw kg ml mm ma mn bi translated">控制器中的内容协商</h2><pre class="mo mp mq mr gt ms ld mt mu aw mv bi"><span id="5d65" class="mc lf iq ld b gy mw mx l my mz">import { Context } from '@curveball/core';<br/>import { Controller, method, accept } from '@curveball/controller';<br/><br/>class MyController extends Controller {<br/><br/>  @accept('html')<br/>  @method('GET')<br/>  async getHTML(ctx: Context) {<br/><br/>    // This is automatically triggered for GET requests with<br/>    // Accept: text/html<br/><br/>  }<br/><br/>  @accept('json')<br/>  @method('GET')<br/>  async getJSON(ctx: Context) {<br/><br/>    // This is automatically triggered for GET requests with<br/>    // Accept: application/json<br/><br/>  }<br/><br/>}</span></pre><h2 id="af47" class="mc lf iq bd lg md me dn lk mf mg dp lo jy mh mi ls kc mj mk lw kg ml mm ma mn bi translated">发射误差</h2><pre class="mo mp mq mr gt ms ld mt mu aw mv bi"><span id="c0b9" class="mc lf iq ld b gy mw mx l my mz">function myMiddleware(ctx: Context, next: Middleware) {<br/><br/>  if (ctx.method !== 'GET') {<br/>    throw new MethodNotAllowed('Only GET is allowed here');<br/>  }<br/>  await next();<br/><br/>}</span></pre><p id="147a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要发出一个HTTP错误，可以设置<code class="fe la lb lc ld b">ctx.status</code>，但是更容易的是抛出一个相关的异常。</p><p id="0de2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该项目还附带了一个<a class="ae kl" href="https://github.com/curveball/problem/" rel="noopener ugc nofollow" target="_blank">中间件</a>来自动生成<a class="ae kl" href="https://tools.ietf.org/html/rfc7807" rel="noopener ugc nofollow" target="_blank"> RFC7807 </a> <code class="fe la lb lc ld b">application/problem+json</code>响应。</p><h2 id="216c" class="mc lf iq bd lg md me dn lk mf mg dp lo jy mh mi ls kc mj mk lw kg ml mm ma mn bi translated">在中间件中转换HTTP响应</h2><p id="d2f6" class="pw-post-body-paragraph jn jo iq jp b jq nb js jt ju nc jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk ij bi translated">使用express middlewares，很容易在处理请求之前做一些事情，但是如果你想在中间件中转换响应，这只能通过复杂的黑客来实现。</p><p id="d260" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是因为响应会立即写入TCP套接字，一旦写入套接字，响应就会消失。</p><p id="9a52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，要做诸如gzipping响应之类的事情，Express中间件作者需要模拟响应流并截取发送给它的任何字节。这一点在express-compression源码中可以看得很清楚:<a class="ae kl" href="https://github.com/expressjs/compression/blob/master/index.js" rel="noopener ugc nofollow" target="_blank">https://github . com/express js/compression/blob/master/index . js</a>。</p><p id="a4b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">曲球不会这样做。响应体被缓冲并可由中间件使用。</p><p id="1032" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，下面的中间件寻找一个HTTP Accept头<code class="fe la lb lc ld b">text/html</code>，并自动将JSON转换成一个简单的HTML输出:</p><pre class="mo mp mq mr gt ms ld mt mu aw mv bi"><span id="bb13" class="mc lf iq ld b gy mw mx l my mz">app.use( async (ctx, next) =&gt; {<br/><br/>  // Let the entire middleware stack run<br/>  await next();<br/> <br/>  // HTML encode JSON responses if the client was a browser.<br/>  if (ctx.accepts('text/html')<br/>   &amp;&amp; ctx.response.type ==== 'application/json') {<br/>     ctx.response.type = 'text/html';<br/>     ctx.response.body = '&lt;h1&gt;JSON source&lt;/h1&gt;&lt;pre&gt;' +    <br/>       JSON.stringify(ctx.response.body) + '&lt;/pre&gt;';<br/>  }<br/><br/>});</span></pre><p id="9ee2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在express中实现同样的事情会非常复杂。</p><p id="ff5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能想知道这是否对大文件的性能不利。你是完全正确的，这个问题还没有解决。</p><p id="d937" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，不是直接写入输出流，这样做的目的是允许用户在<code class="fe la lb lc ld b">body</code>属性上设置一个回调，所以写主体不会被缓冲，只是被延迟。实现这些中间件的复杂性不会改变。</p><h2 id="a7aa" class="mc lf iq bd lg md me dn lk mf mg dp lo jy mh mi ls kc mj mk lw kg ml mm ma mn bi translated">HTML API浏览器</h2><p id="d2ed" class="pw-post-body-paragraph jn jo iq jp b jq nb js jt ju nc jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk ij bi translated">Curveball还附带了一个<a class="ae kl" href="https://github.com/curveball/hal-browser" rel="noopener ugc nofollow" target="_blank"> API浏览器</a>，可以自动将JSON转换成可遍历的HTML，并自动解析HAL链接和HTTP链接头。</p><p id="e162" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个导航元素都是完全基于响应中的链接生成的。</p><p id="ba5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要使用它:</p><pre class="mo mp mq mr gt ms ld mt mu aw mv bi"><span id="20ca" class="mc lf iq ld b gy mw mx l my mz">import { halBrowser } from 'hal-browser';<br/>import { Application } from '@curveball/core';<br/><br/>const app = new Application();<br/>app.use(halBrowser());</span></pre><p id="8e6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">设置完成后，当浏览器访问时，您的API将开始呈现HTML。</p><figure class="mo mp mq mr gt ni gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nh"><img src="../Images/1459d64b1ac7aa07f964b73097187e33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1YZ7nO8QWWRlzv7E.png"/></div></div></figure><h2 id="c062" class="mc lf iq bd lg md me dn lk mf mg dp lo jy mh mi ls kc mj mk lw kg ml mm ma mn bi translated">发送信息响应</h2><pre class="mo mp mq mr gt ms ld mt mu aw mv bi"><span id="dd78" class="mc lf iq ld b gy mw mx l my mz">ctx.response.sendInformational(103, {<br/>  link: '&lt;/foo&gt;; rel="preload"'<br/>})</span></pre><p id="861a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装:</p><pre class="mo mp mq mr gt ms ld mt mu aw mv bi"><span id="88c8" class="mc lf iq ld b gy mw mx l my mz">npm i @curveball/core</span></pre><p id="80c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">文档可以在<a class="ae kl" href="https://github.com/curveball/core" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。在<a class="ae kl" href="https://github.com/curveball" rel="noopener ugc nofollow" target="_blank">组织页面</a>可以看到中间件列表。</p><h1 id="28d3" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">稳定发布</h1><p id="380e" class="pw-post-body-paragraph jn jo iq jp b jq nb js jt ju nc jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk ij bi translated">我们目前正在进行第11个测试版，很快就要发布稳定版了。在这一点上，变化将是微小的。</p><p id="845c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你对这个项目有想法或反馈，听听会很有帮助。不要犹豫留下评论、问题或建议作为Github问题。</p><p id="6b0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有一件大事要做，那就是完成<a class="ae kl" href="https://curveballjs.org/" rel="noopener ugc nofollow" target="_blank">网站</a>。我们有一个伟大的设计，它只需要被推到终点线。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="69aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">【https://evertpot.com】原载于2020年2月27日<a class="ae kl" href="https://evertpot.com/curveball-typescript-framework-update/" rel="noopener ugc nofollow" target="_blank"><em class="na"/></a><em class="na">。</em></p></div></div>    
</body>
</html>