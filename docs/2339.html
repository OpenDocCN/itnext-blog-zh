<html>
<head>
<title>Creating a TensorFlow DNN in C++ Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在C++中创建张量流DNN第1部分</h1>
<blockquote>原文：<a href="https://itnext.io/creating-a-tensorflow-dnn-in-c-part-1-54ce69bbd586?source=collection_archive---------0-----------------------#2019-05-08">https://itnext.io/creating-a-tensorflow-dnn-in-c-part-1-54ce69bbd586?source=collection_archive---------0-----------------------#2019-05-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5028" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇文章中，我将从数据准备、一个小图表和使用TensorBoard开始。</p><h1 id="f132" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">背景</h1><p id="506f" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在我的<a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-your-c-muscle-using-tensorflow-2-0-and-xcode-without-using-bazel-builds-9dc82d5e7f80">上一篇文章</a>中，我展示了如何在MacOS上准备一个可以使用TensorFlow并在XCode中编译的项目。</p><p id="af3d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇文章中，我们将开始编码，创建一个小图，运行它，并将其可视化。</p><p id="87a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当你从事机器学习项目时，数据准备可能是工作的一半，所以我们将看到如何在C++中使用TensorFlow APIs进行编码。</p><p id="9817" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您搜索DNN的C++实现时，您通常会找到加载预训练模型(用Python创建、训练并保存到磁盘)的方法，因此您可以将其加载到C++代码中进行运行时优化。</p><p id="5b88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我在第一篇文章中所说的，我的目标是从头开始，用C++做所有的事情。</p><p id="73e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以最终我的项目会有，全部用C++写的:</p><p id="d86a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">1.数据准备</p><p id="eeb6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.DNN模型创建</p><p id="7dd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.培养</p><p id="0605" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.确认</p><p id="ef7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我开始学习DNNs时，我发现了这个4篇文章的系列:<a class="ae ls" href="https://medium.com/towards-data-science/applied-deep-learning-part-1-artificial-neural-networks-d7834f67a4f6" rel="noopener">在Medium上应用深度学习</a>作者<a class="ae ls" href="https://towardsdatascience.com/@ardendertat" rel="noopener" target="_blank"> Arden Dertat </a>。在我看来，这是深度学习的最佳教程之一。</p><p id="9619" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将尝试做的是本系列第4部分中开发的模型的C++版本。</p><p id="eac1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是AlexNet的缩小版(如果我没有错的话，这是第一个CNN ),但功能强大到足以区分狗和猫。</p><p id="b02c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Arden文章中的模型是用Python和Keras开发的，我将尝试用C++来做。</p><p id="4ef2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是在我们进入模型之前，让我们回顾一些基本的东西。</p><h1 id="452d" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">Google示例</h1><p id="d88c" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">我在TensorFlow代码中找到了几个C++示例，您可以从GitHub中克隆:</p><p id="4609" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">1.<a class="ae ls" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/examples/label_image/main.cc" rel="noopener ugc nofollow" target="_blank">标签图像示例</a> —该示例显示了如何加载图像、加载预训练的图形并通过图形运行图像以进行分类。</p><p id="81ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.<a class="ae ls" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/cc/tutorials/example_trainer.cc" rel="noopener ugc nofollow" target="_blank">示例训练器</a> —以多线程和多步方式训练的简单图形，用于更好地利用计算能力。</p><p id="2373" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您遵循了我在上一篇文章中的说明，您应该已经有了代码。</p><p id="cb75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">无论如何，我将使用第一个示例代码作为本文的基础。</p><h1 id="2b87" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">基本概念</h1><p id="e6d7" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">如果您已经熟悉TensorFlow C++ API，可以继续下一节。</p><h2 id="b9dd" class="lt kq it bd kr lu lv dn kv lw lx dp kz kb ly lz ld kf ma mb lh kj mc md ll me bi translated">图表</h2><p id="d408" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">图形是由运算(节点)和张量(边)组成的。您可以通过添加节点来构建图表。边是节点的输入和输出。通常，在开始和结束的时候，你会有一个图形的输入和一个输出。</p><p id="c1e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">需要理解的重要一点是，构建一个图就是构建一个模型。这意味着操作不会立即运行，而是一步一步地构建图表，并且只有当您执行run命令时，它才会实际运行。</p><p id="21de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">把它想象成用C++编码。您首先编写代码，然后编译并运行。运行时，可以改变输入，得到不同的结果。然而，在我们的例子中，模型本身也会像你训练的情况一样发生变化，权重也会发生变化。</p><p id="8451" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">子图是主图的一部分，您可以评估它而不是整个图。</p><p id="9704" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行图只是给引擎提供您想要评估的节点(在大多数情况下是您添加的最后一个节点)。因为图实际上定义了节点之间的依赖关系，所以引擎将遍历图并评估依赖节点，直到它评估了您请求的节点并给出结果。如果它不需要运行整个图来给出结果，它将只运行相关的子图。</p><p id="1e80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该引擎还支持并行和分布式执行。</p><h2 id="991d" class="lt kq it bd kr lu lv dn kv lw lx dp kz kb ly lz ld kf ma mb lh kj mc md ll me bi translated">范围</h2><p id="1c5a" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">范围是提供上下文的对象。它包含图形和物理资源，如CPU。</p><p id="1ee4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用作用域时，首先创建根作用域，然后从它创建子作用域。</p><p id="3aa2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作用域的名称是由您给它们的名称和作用域内的操作构成的。</p><p id="4cc4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为范围也包含状态，所以这些名称有助于您理解构建图的每个步骤中发生了什么。</p><p id="0989" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不要混淆TensorFlow作用域和C++代码作用域，尽管概念是相似的。</p><h2 id="1adc" class="lt kq it bd kr lu lv dn kv lw lx dp kz kb ly lz ld kf ma mb lh kj mc md ll me bi translated">会议</h2><p id="98e0" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">会话是您与TensorFlow引擎的连接。您创建一个客户机会话来运行一个图形并获得结果。</p><p id="3b19" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如上所述，在运行时，您向会话提供图形的输入、要评估的节点以及可选的一些选项。你也给它一个结果容器。</p><h2 id="306a" class="lt kq it bd kr lu lv dn kv lw lx dp kz kb ly lz ld kf ma mb lh kj mc md ll me bi translated">运算和张量</h2><p id="c62a" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">运算是图中的节点，张量是图中的边。</p><p id="e665" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">节点也可以是类似操作的节点(常量和变量),边可以是类似张量的对象(标量、字符串等)。)</p><p id="72ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看一个来自<a class="ae ls" href="https://www.tensorflow.org/guide/extend/cc" rel="noopener ugc nofollow" target="_blank"> C++指南</a>的例子(有一些修改):</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="b67b" class="lt kq it mk b gy mo mp l mq mr">Scope root = Scope::NewRootScope();</span><span id="099e" class="lt kq it mk b gy ms mp l mq mr">// 2x2 matrix</span><span id="36b6" class="lt kq it mk b gy ms mp l mq mr">auto a = Const(root, { {1, 2}, {2, 4} });</span><span id="118a" class="lt kq it mk b gy ms mp l mq mr">// 2x2 matrix</span><span id="8ae6" class="lt kq it mk b gy ms mp l mq mr">auto b = Const(root, { {2, 2}, {1, 1} });</span><span id="79ca" class="lt kq it mk b gy ms mp l mq mr">// a x b</span><span id="af6a" class="lt kq it mk b gy ms mp l mq mr">auto m = MatMul(root, a, b);</span><span id="ee0e" class="lt kq it mk b gy ms mp l mq mr">ClientSession session(root);</span><span id="68e1" class="lt kq it mk b gy ms mp l mq mr">std::vector&lt;Tensor&gt; outputs;</span><span id="66bc" class="lt kq it mk b gy ms mp l mq mr">session.Run({m}, &amp;outputs);</span><span id="553b" class="lt kq it mk b gy ms mp l mq mr">// outputs[0] == [ [4, 4], [8, 8] ]</span><span id="207d" class="lt kq it mk b gy ms mp l mq mr">cout &lt;&lt; outputs[0].DebugString(4);</span></pre><p id="d57a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们创建2个2x2矩阵，然后将它们相乘(数学上)；从输出向量中提取结果，并发送到输出流。</p><h1 id="31d2" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">让我们开始工作吧！</h1><p id="f37f" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">这篇文章的代码在<a class="ae ls" href="https://github.com/bennyfri/TFMacCpp" rel="noopener ugc nofollow" target="_blank">这个资源库</a>中提供</p><p id="41e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您遵循了前一篇文章中的说明，您应该已经有了一个可以在XCode中编译并与TensorFlow库链接的项目。</p><p id="55dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只需使用main.cpp文件来创建下面的示例。</p><p id="9ab6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我所写的，我希望我的代码基于上面提到的图像标签示例。</p><p id="2342" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想采用的主要函数是读取图像，对其进行一些操作，并返回一个张量，您可以将它输入到另一个图形中。</p><p id="fe7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这项工作由TensorFlow引擎中运行的图形来完成。</p><p id="8479" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我采用示例中的函数头——函数的输入参数是:文件名、图像大小、归一化值和输出引用。我为TensorBoard添加了另一个bool标志，我们稍后会看到原因。</p><p id="a49b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们创建一个新的范围</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="51c5" class="lt kq it mk b gy mo mp l mq mr">auto root = Scope::NewRootScope();</span></pre><p id="0b06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们创建一个变量，当我们运行图表时，这个变量将被输入值</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="ea83" class="lt kq it mk b gy mo mp l mq mr">auto file_name_var = Placeholder(root.WithOpName(“input”), DT_STRING);</span></pre><p id="5425" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意以下几点:</p><p id="feec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">1.我们使用auto，因为TensorFlow类型非常混乱，很难猜测(Output也可以用作Input……)。你会习惯的。</p><p id="3de5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.我们从root创建一个子作用域，给它一个名字“input ”,它只是用这个名字标记这个节点。</p><p id="7cb2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.变量的类型不是字符串，这是一个包含字符串元素的张量(字符串被视为基本类型)。</p><p id="df4a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们想创建一个读取图像文件的操作。该框架提供了许多您可以使用的操作。API文档列出了(大部分)它们。寻找它接受的具体参数和类型很重要。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="efb5" class="lt kq it mk b gy mo mp l mq mr">auto file_reader = ReadFile(root.WithOpName(“file_readr”), file_name_var);</span></pre><p id="c467" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里注意:</p><p id="ca31" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">1.使用新名称创建一个新的子范围。</p><p id="9bce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.我们把从上一个操作中得到的节点放到这个操作中。那是在两个节点之间流动的(边)张量。这也定义了第二和第一节点之间的依赖性。</p><p id="56ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.返回的输出是我们将在下一个操作中使用的另一个节点。</p><p id="279b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们使用另一个操作来解码文件:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="ccc3" class="lt kq it mk b gy mo mp l mq mr">const int wanted_channels = 3;</span><span id="2111" class="lt kq it mk b gy ms mp l mq mr">auto image_reader = DecodeJpeg(root.WithOpName(“jpeg_reader”), file_reader, DecodeJpeg::Channels(wanted_channels));</span></pre><p id="44e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">1.有几个解码器，原来的例子显示了如何使用其他图像类型。</p><p id="b5c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.如果你想知道操作接受什么作为输入，去<a class="ae ls" href="https://www.tensorflow.org/versions/r2.0/api_docs/cc/class/tensorflow/ops/decode-jpeg" rel="noopener ugc nofollow" target="_blank">文档</a>或者查看<a class="ae ls" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/ops/image_ops.cc" rel="noopener ugc nofollow" target="_blank">实现文件</a>。</p><p id="d2be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.该操作还接受属性作为第三个输入参数(struct)。在这种情况下，我们传递图像中通道(颜色)的数量。同样，<a class="ae ls" href="https://www.tensorflow.org/versions/r2.0/api_docs/cc/struct/tensorflow/ops/decode-jpeg/attrs" rel="noopener ugc nofollow" target="_blank">文档</a>可能会有所帮助。</p><p id="8d94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">前面操作的输出是uint8的张量。我们希望将元素转换成浮点数，这样我们就可以对它们进行一些数学运算。这是TensorFlow的典型特征。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="a166" class="lt kq it mk b gy mo mp l mq mr">auto float_caster = Cast(root.WithOpName(“float_caster”), image_reader, DT_FLOAT);</span></pre><p id="bd58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们要在现有的三个维度(高度、宽度、通道)上添加第四个维度。第四个是批的。在图像处理的情况下，这对于TensorFlow也是典型的，具有批次、高度、宽度、通道的四维张量(称为NHWC)。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="9405" class="lt kq it mk b gy mo mp l mq mr">auto dims_expander = ExpandDims(root.WithOpName(“dim”), float_caster, 0);</span></pre><p id="7273" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，这里的0表示dim插入在开头。</p><p id="8f08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们将图像调整到函数输入中指定的大小。这样做是因为当图像被馈送到深层网络时，它们被期望具有相同的大小。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="ffa8" class="lt kq it mk b gy mo mp l mq mr">auto resized = ResizeBilinear(root.WithOpName(“size”), dims_expander, Const(root, {input_height, input_width}));</span></pre><p id="1348" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ResizeBilinear接受具有两个元素的一维张量作为大小:高度和宽度。在我们的例子中，我们简单地给它一个常量运算的输出，它为我们创建了张量。</p><p id="fa8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来是浮动元素的规范化。当元素中的值介于0和1之间时，网络的性能通常会更好。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="2db5" class="lt kq it mk b gy mo mp l mq mr">auto d = Div(root.WithOpName(“normalized”), Sub(root, resized, {input_mean}), {input_std});</span></pre><p id="24d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这一行中，我们再次将两个操作嵌套在一个操作中—首先做减法，然后做除法。在这两种情况下，操作都是基于元素的，第二个参数可以是一个标量(一个元素的一维张量),因此是带括号的。</p><h1 id="27d1" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">准备好跑了吗？</h1><p id="878c" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">图表准备好了。现在我们想运行它。</p><p id="68f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，我们需要:</p><p id="cd1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">1.会话对象</p><p id="2e29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.向变量提供输入</p><p id="4ab6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.决定我们要评估哪个节点</p><p id="66c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.为输出准备一个容器</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="449b" class="lt kq it mk b gy mo mp l mq mr">ClientSession session(root);</span><span id="2202" class="lt kq it mk b gy ms mp l mq mr">TF_CHECK_OK(session.Run({{file_name_var, file_name}}, {d}, out_tensors));</span></pre><p id="3d92" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Run方法可以有多种形式，最基本的形式是要计算的节点向量和指向输出张量向量的指针。</p><p id="f4f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用另一个参数作为输入值。</p><p id="1110" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们回顾一下上面列出的所有要求:</p><p id="8808" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">1.我们根据作用域创建一个新的ClientSession对象。作用域隐式地给出了对会话对象创建的图的引用。注意，可能有多个图，但是在我们的例子中，我们只使用默认的一个。</p><p id="3529" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.输入作为map对象提供，其中索引是节点，元素是值。在我们的例子中，我们只有一个输入(文件名)，所以我们提供了一对从占位符返回的变量节点和一个字符串值。这是在另一对括号内，因为它是一个列表(一个地图)。</p><p id="0764" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.run函数的第二个参数是我们想要评估的节点向量。在我们的例子中，这只是一个——我们添加到图表中的最后一个。</p><p id="1bc3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.out_tensors是指向从main提供给函数的vector <tensor>对象的指针。返回向量中的每个元素对应于求值列表中的一个节点。我们期望只得到一个元素。</tensor></p><p id="c6ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用TF_CHECK_OK宏来检查调用的结果，以便在失败时运行和记录错误。</p><p id="1606" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们所料，out_tensors[0]中的结果是形状[1，299，299，3]的四维张量(该函数的输入大小为299乘299)。</p><p id="ede1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">仅仅加载一个图像就要做大量的工作！而且我们创建的图也不是无足轻重的(对于初学者来说)。我听说有一种可视化图表的方法。</p><h1 id="5b77" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">张量板</h1><blockquote class="mt"><p id="437c" class="mu mv it bd mw mx my mz na nb nc kn dk translated">-你想用冲浪板吗？</p><p id="9406" class="mu mv it bd mw mx my mz na nb nc kn dk translated">-是的</p><p id="98a6" class="mu mv it bd mw mx my mz na nb nc kn dk translated">-没问题，只需运行一次模型，然后调用tf.summary.FileWriter…</p><p id="d5b9" class="mu mv it bd mw mx my mz na nb nc kn dk translated">-那是python，对吧？</p><p id="dff1" class="mu mv it bd mw mx my mz na nb nc kn dk translated">-是的…</p><p id="fac3" class="mu mv it bd mw mx my mz na nb nc kn dk translated">-我想用C++。</p><p id="5c15" class="mu mv it bd mw mx my mz na nb nc kn dk translated">-嗯，在这种情况下你必须做一些工作，你需要创建一个事件对象，然后序列化图形…</p><p id="ab99" class="mu mv it bd mw mx my mz na nb nc kn dk translated">-没有。</p></blockquote><p id="fb51" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">还好有个隐藏(？)文件，该文件执行与python方法相同的操作。您需要将summary_file_writer.cc文件添加到项目中(来自/tensorflow/core/summary/)，并将summary_file_writer.h包含在main.ccp文件中。</p><p id="9409" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">TensorBoard是许多事物的可视化工具，其中包括图形结构。</p><h2 id="8a59" class="lt kq it bd kr lu lv dn kv lw lx dp kz kb ly lz ld kf ma mb lh kj mc md ll me bi translated">TensorBoard如何工作</h2><p id="ee52" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">首先，您需要创建一个文件夹。我在我的项目文件夹下创建了一个文件夹“graphs”。这是您想要转储TensorBoard知道要读取的图表摘要数据的位置。</p><p id="8200" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">TensorBoard是一种后台服务，您在终端中触发，然后在终端中指定的端口中打开浏览器。</p><p id="31e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从代码部分开始:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="a87a" class="lt kq it mk b gy mo mp l mq mr">GraphDef graph;</span><span id="785d" class="lt kq it mk b gy ms mp l mq mr">TF_RETURN_IF_ERROR(root.ToGraphDef(&amp;graph));</span><span id="23dc" class="lt kq it mk b gy ms mp l mq mr">SummaryWriterInterface* w;</span><span id="8edc" class="lt kq it mk b gy ms mp l mq mr">TF_CHECK_OK(CreateSummaryFileWriter(1, 0, "/Users/bennyfriedman/Code/TF2example/TF2example/graphs", ".img-graph", Env::Default(), &amp;w));</span><span id="5ec1" class="lt kq it mk b gy ms mp l mq mr">TF_CHECK_OK(w-&gt;WriteGraph(0, make_unique&lt;GraphDef&gt;(graph)));</span></pre><p id="6c62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你还记得的话，我们说过范围对象持有图形。我们需要使用这个工具方法从scope中提取graph对象。</p><p id="c5a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们创建一个SummaryFileWriter，将文件写入的文件夹传递给它。前两个参数控制它写的频率，在我们的例子中，我们希望它立即写，所以最大队列是1，等待0毫秒。第四个参数是一个扩展，这是在你想写多个图的情况下，所以你知道哪个是哪个。</p><p id="37ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来使用writer编写文件，给它一个graph对象。</p><p id="495f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行一次之后，您应该在文件夹中获得一个文件名类似events . out . TF events . 1556982975 . m b-Friedman . local . img-graph的文件。</p><p id="3092" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你不想每次运行你的图形时都使用它，所以这就是为什么我在函数中传递了一个标志来控制它。</p><p id="8954" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们启动TensorBoard:</p><p id="1921" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你从来没有安装它，首先打开终端并运行</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="070c" class="lt kq it mk b gy mo mp l mq mr">pip install TensorBoard</span></pre><p id="2c47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后运行以下命令:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="057c" class="lt kq it mk b gy mo mp l mq mr">tensorboard — logdir ~/Code/TF2example/TF2example/graphs/</span></pre><p id="5ac7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中，在logdir之后提供的文件夹是您在上面的代码中创建和使用的文件夹。</p><p id="9454" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">TensorBoard会做出如下回应:</p><p id="1dbb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">tensor board 1 . 14 . 0 a 2019 03 01 at<a class="ae ls" href="http://mb-friedman.local:6006" rel="noopener ugc nofollow" target="_blank">http://m b-Friedman . local:6006</a>(按CTRL+C退出)</p><p id="f130" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您可以打开浏览器，将URL复制到地址栏。</p><p id="8bde" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您将看到类似这样的内容:</p><figure class="mf mg mh mi gt nj gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/df536709c9debe38ccc81916b6b14653.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*fp4k4wdGS9vNdfBYyQV6dQ.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">张量图形可视化</figcaption></figure><p id="883a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不错！这有助于我们调试更复杂的图形，看看什么会真正运行，谁在喂谁？以及在哪里输入了什么常量。</p><h1 id="797f" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">回到代码:我们如何处理输出？</h1><p id="ba88" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">最终，我们将有许多图像提取出来，我们将创建一个DNN来训练他们，但现在让我们确保我们没有损坏图像。</p><p id="c5d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了验证这一点，让我们创建另一个图形，它采用张量并将其放回图像中。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="a698" class="lt kq it mk b gy mo mp l mq mr">auto root = Scope::NewRootScope();</span><span id="4274" class="lt kq it mk b gy ms mp l mq mr">auto un_normalized = Multiply(root.WithOpName("un_normalized"), Add(root, in_tensors[0], {input_mean}), {input_std});</span><span id="24d1" class="lt kq it mk b gy ms mp l mq mr">auto shaped = Reshape(root.WithOpName("reshape"), un_normalized, Const(root, {input_height, input_width, 3}));</span><span id="3ecc" class="lt kq it mk b gy ms mp l mq mr">auto casted = Cast(root.WithOpName("cast"), shaped, DT_UINT8);</span><span id="6407" class="lt kq it mk b gy ms mp l mq mr">auto image = EncodeJpeg(root.WithOpName("EncodeJpeg"), casted);</span><span id="5fac" class="lt kq it mk b gy ms mp l mq mr">vector&lt;Tensor&gt; out_tensors;</span><span id="27c0" class="lt kq it mk b gy ms mp l mq mr">ClientSession session(root);</span><span id="5323" class="lt kq it mk b gy ms mp l mq mr">TF_CHECK_OK(session.Run({image}, &amp;out_tensors));</span><span id="69bc" class="lt kq it mk b gy ms mp l mq mr">ofstream fs(file_name, ios::binary);</span><span id="4ac1" class="lt kq it mk b gy ms mp l mq mr">fs &lt;&lt; out_tensors[0].scalar&lt;string&gt;()();</span></pre><p id="0c6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">检查保存到磁盘的图像。它应该是原始图像的大小调整。</p><h1 id="ffc7" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">把所有的放在一起</h1><p id="6fa9" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">这是main中的代码:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="01e8" class="lt kq it mk b gy mo mp l mq mr">string image = "/Users/bennyfriedman/Code/TF2example/TF2example/data/grace_hopper.jpg";</span><span id="9f5c" class="lt kq it mk b gy ms mp l mq mr">int32 input_width = 299;</span><span id="330c" class="lt kq it mk b gy ms mp l mq mr">int32 input_height = 299;</span><span id="dc8b" class="lt kq it mk b gy ms mp l mq mr">float input_mean = 0;</span><span id="e74a" class="lt kq it mk b gy ms mp l mq mr">float input_std = 255;</span><span id="6907" class="lt kq it mk b gy ms mp l mq mr">vector&lt;Tensor&gt; resized_tensors;</span><span id="da52" class="lt kq it mk b gy ms mp l mq mr">Status read_tensor_status = ReadTensorFromImageFile(image, input_height, input_width, input_mean, input_std, &amp;resized_tensors, true);</span><span id="9ef3" class="lt kq it mk b gy ms mp l mq mr">cout &lt;&lt; resized_tensors[0].shape().DebugString();</span><span id="102f" class="lt kq it mk b gy ms mp l mq mr">if (!read_tensor_status.ok())</span><span id="06dc" class="lt kq it mk b gy ms mp l mq mr">{</span><span id="298a" class="lt kq it mk b gy ms mp l mq mr">    LOG(ERROR) &lt;&lt; read_tensor_status;</span><span id="a0bc" class="lt kq it mk b gy ms mp l mq mr">    return -1;</span><span id="994c" class="lt kq it mk b gy ms mp l mq mr">}</span><span id="0b66" class="lt kq it mk b gy ms mp l mq mr">Status write_tensor_staus = WriteTensorToImageFile("/Users/bennyfriedman/Code/TF2example/TF2example/data/output.jpg", input_height, input_width, input_mean, input_std, resized_tensors);</span></pre><h1 id="7c6e" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">解决纷争</h1><h2 id="8d52" class="lt kq it bd kr lu lv dn kv lw lx dp kz kb ly lz ld kf ma mb lh kj mc md ll me bi translated">使用状态</h2><p id="b1db" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">您已经看到，您需要检查从一些方法返回的状态对象，或者使用TF_CHECK_OK宏，或者像这样简单地使用这个状态返回对象:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="6bae" class="lt kq it mk b gy mo mp l mq mr">Status st = …</span><span id="a841" class="lt kq it mk b gy ms mp l mq mr">if(!st.ok())</span><span id="92b3" class="lt kq it mk b gy ms mp l mq mr">    LOG(ERROR) &lt;&lt; st;</span></pre><p id="c91c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它将向输出中写入一条有意义的消息。</p><h2 id="6455" class="lt kq it bd kr lu lv dn kv lw lx dp kz kb ly lz ld kf ma mb lh kj mc md ll me bi translated">范围状态</h2><p id="feba" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">有时，当您运行图表时，您会得到一个奇怪的错误，比如分段错误或访问冲突，而您不知道哪里出错了。</p><p id="134e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可能是由于您创建的图表有问题。典型的问题是为操作提供错误的数据类型或错误的形状。</p><p id="ee10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建图形元素时，您需要像这样检查范围对象:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="77d7" class="lt kq it mk b gy mo mp l mq mr">if(!root.ok())</span><span id="af9c" class="lt kq it mk b gy ms mp l mq mr">    LOG(FATAL) &lt;&lt; root.status().ToString();</span></pre><p id="4bce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，在这种情况下，输出会给你一个有意义的消息，告诉你什么是错的。</p><h2 id="1814" class="lt kq it bd kr lu lv dn kv lw lx dp kz kb ly lz ld kf ma mb lh kj mc md ll me bi translated">调试字符串</h2><p id="dc21" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">一些TensorFlow对象支持DebugString()方法将对象的内容转换为人类可读的内容。根据需要在张量和TensorShape中使用它。</p><h1 id="7fb6" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">摘要</h1><p id="10cc" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在这一部分中，我们看到了如何在TensorBoard中创建、运行和可视化图形。</p><p id="a02a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下一部分，我将开始创建一个DNN模型并训练它。</p></div></div>    
</body>
</html>