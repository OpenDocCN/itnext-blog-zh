<html>
<head>
<title>Dependency Injection with Swinject</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Swinject进行依赖注入</h1>
<blockquote>原文：<a href="https://itnext.io/dependency-injection-with-swinject-73f3144b20f0?source=collection_archive---------1-----------------------#2018-09-20">https://itnext.io/dependency-injection-with-swinject-73f3144b20f0?source=collection_archive---------1-----------------------#2018-09-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b352" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">简单、快速且稳定。</h2></div><p id="78ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将介绍依赖注入的基础知识，以及如何使用名为Swinject的开源框架将其应用于iOS项目。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/f6b7fb25b63894fd7877cc7fdc93d31d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0VZpdqGWqm2fHgTxy6tWxw.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">不会痛的——多亏了Swinject。</figcaption></figure><h2 id="1ff2" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">什么是依赖注入？</h2><p id="13c3" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">依赖注入(DI)是一种技术，在这种技术中，您从实体自身的范围之外设置实体的依赖关系，将您的系统变成松散耦合的模块。想象一下，一个类保存着对应用程序其他组件的引用，例如，它可以避免UIViewControllers之间的通信模式。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/4f708ded50f5cdb53c6d31af2a96c4d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/0*diyiGXn_8szNEO-1.gif"/></div></figure><p id="cfc1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">DI是一种公正的软件设计模式，它实现了控制反转(IoC)来解决依赖性。IMO最大的成就之一就是根据选择的方案使用适当的实现。这使得对象完全可测试，模仿数据变得容易多了。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mq"><img src="../Images/b69f2b66b00c0d3d7538ad5f722189f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*30n0vWyS4iDqqSR2oHansg.png"/></div></div></figure><h2 id="ef5c" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">如何使用Swinject？</h2><p id="402d" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">对于Swift项目的DI来说，Swinject是一个很好的框架，同样，它是开源的。它使用泛型以一种非常容易和简单的方式解耦你的代码，要使用它，第一步是通过CocoaPods把它添加到你的项目中</p><ul class=""><li id="5859" class="mz na iq kh b ki kj kl km ko nb ks nc kw nd la ne nf ng nh bi translated">pod 'Swinject '</li></ul><blockquote class="ni nj nk"><p id="2988" class="kf kg nl kh b ki kj jr kk kl km ju kn nm kp kq kr nn kt ku kv no kx ky kz la ij bi translated">如果你的代码库是Objective-C，你可能愿意检查一下Typhoon DI框架。</p></blockquote><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1684" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注册会消耗相当多的代码行，所以你可以把它分成一个扩展或者创建一个loader类。这听起来可能有点奇怪，但是，注册的顺序在这里并不重要，因为我们在应用程序执行的开始就注册了所有的东西，所以在任何东西被实例化之前。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="353e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在“Screen”类中，您将具有依赖关系:</p><blockquote class="ni nj nk"><p id="0ced" class="kf kg nl kh b ki kj jr kk kl km ju kn nm kp kq kr nn kt ku kv no kx ky kz la ij bi translated"><strong class="kh ir"><em class="iq">var</em></strong><em class="iq">data presenter:</em><strong class="kh ir"><em class="iq">data presenter protocol</em></strong><em class="iq">！</em></p></blockquote><p id="6320" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它不必知道这将是这个协议的哪个实现，只要这个实现符合这个相同的协议，只有注册会告诉谁来，谁不来。</p><p id="2c39" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当使用DI时，如果您忘记注册某个依赖项，那么它的值可能为零。此外，当在屏幕间导航时，你不应该实例化屏幕，而是使用容器<strong class="kh ir">来解析它。</strong>这就是为什么为你的应用程序创建一个<strong class="kh ir"> Navigator </strong>类是一个好主意，这样你就不必通过屏幕传递来自AppDelegate的容器，而是导航器。</p><blockquote class="ni nj nk"><p id="7ed6" class="kf kg nl kh b ki kj jr kk kl km ju kn nm kp kq kr nn kt ku kv no kx ky kz la ij bi translated">但是我将在每个屏幕上有不同的“导航器”实例？</p></blockquote><p id="8c68" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不，您可以在使用<strong class="kh ir"> <em class="nl">时为注册定义一个单例。inObjectScope(。容器)</em> </strong>这样，每次你解析它的时候，你都会有相同的实例。有一些很好的导航模式可以和DI一起工作，但是这是另一篇文章的主题。</p><h2 id="716f" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">结论</h2><p id="fad5" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">当使用依赖注入时，你会得到更少的代码行和更有组织的项目。除此之外，您的对象的可测试性将会提高，并且您可以避免在视图控制器之间使用通信模式。</p><p id="f00c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">特别感谢我的导师<a class="nr ns ep" href="https://medium.com/u/6afeeee2834e?source=post_page-----73f3144b20f0--------------------------------" rel="noopener" target="_blank"> Csabi Vidó </a>帮我评论这篇文章。</p></div></div>    
</body>
</html>