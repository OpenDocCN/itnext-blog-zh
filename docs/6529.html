<html>
<head>
<title>Sliding Window Algorithm Technique</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">滑动窗口算法技术</h1>
<blockquote>原文：<a href="https://itnext.io/sliding-window-algorithm-technique-6001d5fbe8b3?source=collection_archive---------0-----------------------#2021-12-11">https://itnext.io/sliding-window-algorithm-technique-6001d5fbe8b3?source=collection_archive---------0-----------------------#2021-12-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="cf9f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="270f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">滑动窗口是一种数据结构和算法的问题解决技术，用于应用数组或列表的问题。在<strong class="kn ir"> O(n ) </strong>或<strong class="kn ir"> O(n ) </strong>中使用强力方法解决这些问题是没有痛苦的。然而，<strong class="kn ir">滑动窗口</strong>技术可以将时间复杂度降低到<strong class="kn ir"> O(n) </strong>。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/3118fc4523537a584f050a02731645bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/0*4AzkYhWEX-Ia-G0j.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">图1:寻找5个连续数字的最大和的滑动窗口技术。</figcaption></figure><p id="4177" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">滑动窗口技术背后的基本思想是将两个嵌套循环转换成一个循环。</p><p id="691c" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">以下是识别此类问题的一些基本线索:</p><ul class=""><li id="131c" class="ma mb iq kn b ko lv ks lw kw mc la md le me li mf mg mh mi bi translated">问题将基于数组、列表或字符串类型的数据结构。</li><li id="8600" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated">它将要求在数组或字符串中查找子范围，必须给出最长、最短或目标值。</li><li id="48d0" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated">它的概念主要基于这样的想法，比如完美地满足给定条件的事物的最长序列或最短序列。</li></ul><p id="d373" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">假设您有一个如下所示的数组:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/ab23dd8fe5911a1773c9266c2486ea0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*LqRML1zu6WY7fqMFoSFmlA.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">图2:值的数组</figcaption></figure><p id="b49a" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">一个尺寸为3 的<strong class="kn ir">滑动窗口将在它上面运行，如下所示:</strong></p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/8cc6e531d4f27ba49a6b92ff3c564e8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*04i4nzgAPjvcKwtFaD9odQ.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">图3:大小为3的滑动窗口(3个项目的子列表)</figcaption></figure><h1 id="0d05" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">解决滑动窗口问题的基本步骤</h1><p id="f281" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我认为与其说它是一种算法，不如说它是一种技术。这是一种可以在许多算法中使用的技术。下面是解决与滑动窗口技术相关的问题的基本步骤:</p><ul class=""><li id="b064" class="ma mb iq kn b ko lv ks lw kw mc la md le me li mf mg mh mi bi translated">使用hashmap或dictionary来计算特定的数组输入，并坚持使用外部循环向右增加窗口。</li><li id="cd75" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated">将一个放入循环中，通过向右滑动来减少窗口边。这个循环会很短。</li><li id="55af" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated">根据问题陈述存储当前最大或最小窗口大小或计数。</li></ul><p id="ab67" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">滑动寻找五个连续元素的最大和的例子。</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="2b09" class="mv jo iq mr b gy mw mx l my mz">[ 5, 7, 1, 4, 3, 6, 2, 9, 2 ]</span></pre><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi na"><img src="../Images/271a18806cd03b37db8f3461d199bde7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/0*GqFhMN7SGZPOpeuL.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">图4:寻找五个连续元素的最大和的滑动窗口技术</figcaption></figure><p id="f7cf" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">滑动窗口技术有许多问题陈述。</p><h1 id="b62a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">大小为k的最大和子阵列</h1><p id="c2c1" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个正整数数组和一个正数<em class="nb"> k </em>，求任意相邻的大小为<em class="nb"> k </em>的子数组的最大和。</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="1f4a" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input</strong>: [3, 5, 2, 1, 7], k=2</span><span id="d015" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output</strong>: 8</span></pre><p id="e8e6" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">说明:</strong>这里子数组[1，7]是最大和的和。</p><p id="de49" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">解决方案:</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="53b7" class="mv jo iq mr b gy mw mx l my mz">def getMaxSum(arr, k):<br/>    maxSum = 0<br/>    windowSum = 0<br/>    start = 0<br/>    <br/>    for i in range(len(arr)):<br/>        windowSum += arr[i]<br/>        <br/>        if ((i - start + 1) == k):<br/>            maxSum = max(maxSum, windowSum)<br/>            windowSum -= arr[start]<br/>            start += 1<br/>    <br/>    return maxSum</span></pre><h1 id="8a98" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">计算变位词的出现次数</h1><p id="e2c2" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个单词和一个文本，返回该单词的变位词在文本中出现的次数。</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="a1aa" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input</strong>: text = gotxxotgxdogt, word = got</span><span id="59f9" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output </strong>: 3</span></pre><p id="18ea" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解释:</strong>单词— got，otg，ogt是got的变位词。</p><p id="fa89" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="4867" class="mv jo iq mr b gy mw mx l my mz">def countAnagram(text, word):<br/>    w = len(word) <br/>    count = 0<br/>    ana = ''<br/>    d = {}</span><span id="02f2" class="mv jo iq mr b gy nc mx l my mz">    for i in range(w):<br/>        ana += text[i]</span><span id="23ea" class="mv jo iq mr b gy nc mx l my mz">    if isAnagram(ana, word):<br/>        count += 1<br/>    <br/>    for i in range(1, len(text)):<br/>        ana = ana[1:] + text[i]<br/>        <br/>        if ana not in d and isAnagram(ana, word):<br/>            count += 1<br/>            d[ana] = 0<br/>        d[ana] = 0<br/>    <br/>    return count</span></pre><p id="9ea7" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">是变位词Util:</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="c2b6" class="mv jo iq mr b gy mw mx l my mz">def isAnagram(s, word):<br/>    if len(s) != len(word):<br/>        return False<br/>    <br/>    d = [0] * 26<br/>    for c in s:<br/>        d[ord(c) - ord('a')] = 1<br/>    <br/>    for c in word:<br/>        if d[ord(c) - ord('a')] == 0:<br/>            return False<br/>    <br/>    return True</span></pre><p id="2b42" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">采用不同方法的解决方案:</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="1e7c" class="mv jo iq mr b gy mw mx l my mz">def getCountOccurances(text, word):<br/>    wHeap = [0] * 26<br/>    textHeap = [0] * 26<br/>    start = 0<br/>    count = 0<br/>    <br/>    for c in word:<br/>        wHeap[ord(c) - ord('a')] += 1<br/>    <br/>    for i in range(len(text)):<br/>        textHeap[ord(text[i]) - ord('a')] += 1<br/>        if (i - start + 1) == len(word):<br/>            if textHeap == wHeap:<br/>                count += 1<br/>            <br/>            textHeap[ord(text[start]) - ord('a')] -= 1<br/>            start += 1<br/>        <br/>    return count</span></pre><h1 id="15f4" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">所有k长连续子阵列的最大和最小平均值之差</h1><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="5d0a" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input</strong>: arr[ ] = {3, 8, 9, 15}, K = 2</span><span id="a680" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output</strong>: 6.5</span></pre><p id="6006" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">说明:</strong>所有长度为2的子阵列分别为{3，8}、{8，9}、{9，15}，它们的平均值分别为(3+8)/2 = 5.5、(8+9)/2 = 8.5、(9+15)/2 = 12.0。</p><p id="b94d" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">因此，最大值(=12.0)和最小值(=5.5)之差为12.0 -5.5 = 6.5。</p><p id="cd31" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="38e9" class="mv jo iq mr b gy mw mx l my mz">def getMinMaxDiff(arr, k):<br/>    currSum = 0<br/>    minSum = float("inf")<br/>    maxSum = 0<br/>    start = 0<br/>    <br/>    for i in range(len(arr)):<br/>        currSum += arr[i]<br/>        <br/>        if (i - start + 1 == k):<br/>            avg = currSum / k<br/>            maxSum = max(avg, maxSum)<br/>            minSum = min(maxSum, minSum)<br/>            currSum -= arr[start]<br/>            start += 1<br/>    <br/>    diff = maxSum - minSum<br/>    return diff</span></pre><h1 id="51f8" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">查找包含“k”个不同字符的字符串中最长的子字符串</h1><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="c805" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input</strong>: s = 'abcbdbdbbdcdabd'<br/>k = 2</span><span id="ecdb" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output</strong>: bdbdbbd</span></pre><p id="27ad" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="e3d8" class="mv jo iq mr b gy mw mx l my mz">def getLongest(s, k):<br/>    high = 0<br/>    windows = set()<br/>    freq = [0] * 128<br/>    low = 0<br/>    end = 0<br/>    start = 0<br/>    <br/>    while high &lt; len(s):<br/>        windows.add(s[high])<br/>        freq[ord(s[high])] += 1<br/>        <br/>        while len(windows) &gt; k:<br/>            freq[ord(s[low])] -= 1<br/>            if freq[ord(s[low])] == 0:<br/>                windows.remove(s[low])<br/>            <br/>            low += 1<br/>            <br/>        if end - start &lt; high - low:<br/>            end = high<br/>            start = low<br/>        <br/>        high += 1<br/>        <br/>    return s[start:end + 1]</span></pre><h1 id="b88d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">在数组中查找范围“k”内的重复项</h1><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="7477" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input</strong>: nums = [5, 6, 8, 2, 4, 6, 9]</span><span id="2e02" class="mv jo iq mr b gy nc mx l my mz">k = 2</span><span id="96ae" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Ouput</strong>: False</span></pre><p id="9a84" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="4f51" class="mv jo iq mr b gy mw mx l my mz">def getDuplicates(nums, k):<br/>    d = {}<br/>    count = 0<br/>    for i in range(len(nums)):<br/>        if nums[i] in d and i - d[nums[i]] &lt;= k:<br/>            return True<br/>        else:<br/>            d[nums[i]] = i<br/>    <br/>    return False</span></pre><h1 id="639b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">求大小为k的最小和子数组</h1><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="c259" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input</strong>: arr = [10, 4, 2, 5, 6, 3, 8, 1]</span><span id="f327" class="mv jo iq mr b gy nc mx l my mz">k = 3</span><span id="a3af" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output</strong>: 11</span></pre><p id="a89f" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="faa8" class="mv jo iq mr b gy mw mx l my mz">def getMinSum(arr, k):<br/>    currSum = 0<br/>    minSum = float("inf")<br/>    start = 0<br/>    <br/>    for i in range(len(arr)):<br/>        currSum += arr[i]<br/>        <br/>        if (i - start + 1 == k):<br/>            minSum = min(minSum, currSum)<br/>            currSum -= arr[start]<br/>            start += 1<br/>    <br/>    return minSum</span></pre><h1 id="fc1c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">不包含任何元音的最长子字符串的长度</h1><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="79b9" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input</strong>: s = "codeforintelligents"<br/><strong class="mr ir">Output</strong>: 3</span><span id="83c6" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Explanation</strong>: 'nts' is the longest substring that doesn't contain any vowels.</span></pre><p id="1646" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="dcfa" class="mv jo iq mr b gy mw mx l my mz">def getLongestSubstring(s):<br/>    vowels = ['a', 'e', 'i', 'o', 'u']<br/>    result = ""<br/>    maxResult = ""<br/>    for i in range(len(s)):<br/>        if s[i] not in vowels:<br/>            result += s[i]<br/>            print(result)<br/>            if len(result) &gt; len(maxResult):<br/>                maxResult = result<br/>        else:<br/>            result = ""<br/>    <br/>    return len(maxResult)</span></pre><h1 id="d48a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">计算每个k长度子数组中出现的负元素</h1><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="914d" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input</strong>: arr = [-1, 2, -2, 3, 5, -7, -5], K = 3</span><span id="99c5" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output</strong>: 2, 1, 1, 1, 2</span></pre><p id="035f" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="7700" class="mv jo iq mr b gy mw mx l my mz">def getCountNegatives(arr, k):<br/>    lst = []<br/>    start = 0<br/>    count = 0<br/>    <br/>    for i in range(len(arr)):<br/>        if arr[i] &lt; 0:<br/>            count += 1<br/>        <br/>        if (i - start + 1 == k):<br/>            lst.append(count)<br/>            if arr[start] &lt; 0:<br/>                count -= 1<br/>                <br/>            start += 1<br/>    <br/>    return lst</span></pre><h1 id="49f9" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">最小尺寸子阵列和</h1><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="bd7a" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input</strong>: target = 7, nums = [2,3,1,2,4,3]</span><span id="4c46" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output</strong>: 2</span><span id="c285" class="mv jo iq mr b gy nc mx l my mz">Explanation: The subarray [4,3] has the minimal length under the problem constraint</span></pre><p id="6867" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="ee09" class="mv jo iq mr b gy mw mx l my mz">def minSubArrayLen(target, nums):<br/>    currSum = 0<br/>    start = 0<br/>    count = 0<br/>    minCount = float("inf")<br/>    <br/>    for i in range(len(nums)):<br/>        currSum += nums[i]<br/>        <br/>        while currSum &gt;= target:<br/>            minCount = min(minCount, i - start + 1)<br/>            currSum -= nums[start]<br/>            start += 1<br/>        <br/>        if minCount == float("inf"):<br/>            return 0<br/>        <br/>    return minCount</span></pre><h1 id="13b8" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">最长重复字符替换</h1><p id="c9cb" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给你一个字符串s和一个整数k，你可以选择字符串中的任何一个字符，把它改成任何其他大写的英文字符。您最多可以执行此操作k次。</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="f30d" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input</strong>: s = "ABAB", k = 2</span><span id="2c2b" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output</strong>: 4</span><span id="d9d1" class="mv jo iq mr b gy nc mx l my mz">Explanation: Replace the two 'A's with two 'B's or vice versa.</span></pre><p id="e995" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="7285" class="mv jo iq mr b gy mw mx l my mz">def characterReplacement(self, s, k):<br/>        freq = {}<br/>        maxRepeatLetterCount = 0<br/>        windowStart = 0<br/>        maxLength = 0<br/>        <br/>        for i in range(len(s)):<br/>            if s[i] not in freq:<br/>                freq[s[i]]= 0<br/>            <br/>            freq[s[i]] += 1<br/>            maxRepeatLetterCount = max(maxRepeatLetterCount, freq[s[i]])<br/>            if (i - windowStart + 1 - maxRepeatLetterCount) &gt; k:<br/>                freq[s[windowStart]] -= 1<br/>                windowStart += 1<br/>            <br/>        maxLength = max(maxLength, i-windowStart + 1)<br/>        <br/>        return maxLength</span></pre><h1 id="6bab" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">对排序数组中不同的绝对值进行计数</h1><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="ce46" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input: </strong> { -1, -1, 0, 1, 1, 1 }</span><span id="2add" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output:</strong> The total number of distinct absolute values is 2 (0 and 1)</span></pre><p id="55f0" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="f2aa" class="mv jo iq mr b gy mw mx l my mz">def getCountDistinct(arr):<br/>    count = 0<br/>    d = {}<br/>    for item in arr:<br/>        if item &gt;= 0 and item not in d:<br/>            d[item] = 1<br/>            count += 1<br/>    <br/>    return count</span></pre><h1 id="5341" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">字符串置换</h1><p id="c65d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定两个字符串s1和s2，如果s2包含s1的排列，则返回true，否则返回false。</p><p id="f195" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">换句话说，如果s1的排列之一是s2的子串，则返回true。</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="4161" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input:</strong> s1 = "ab", s2 = "eidbaooo"<br/><strong class="mr ir">Output:</strong> true<br/><strong class="mr ir">Explanation:</strong> s2 contains one permutation of s1 ("ba").</span></pre><p id="2515" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="8fe3" class="mv jo iq mr b gy mw mx l my mz">def checkInclusion(self, s1, s2):<br/>    numbers = [0]*26<br/>    numbers2 = [0]*26<br/>    <br/>    for c in s1:<br/>        numbers[ord(c) - ord('a')] += 1<br/>        <br/>    for index in range(0, len(s2)):<br/>        numbers2[ord(s2[index]) - ord('a')] += 1<br/>        <br/>        if index &gt;= len(s1) - 1:<br/>            if numbers == numbers2:<br/>                return True<br/>                <br/>            numbers2[ord(s2[index - len(s1) + 1]) - ord('a')] -= 1<br/>                <br/>    return False</span></pre><h1 id="46df" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">查找字符串中的所有变位词</h1><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="9109" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input</strong>: s = "cbaebabacd", p = "abc"</span><span id="a35a" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output</strong>: [0,6]</span><span id="8804" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Explanation</strong>:</span><span id="37c0" class="mv jo iq mr b gy nc mx l my mz">The substring with start index = 0 is "cba", which is an anagram of "abc".</span><span id="5a59" class="mv jo iq mr b gy nc mx l my mz">The substring with start index = 6 is "bac", which is an anagram of "abc".</span></pre><p id="93ab" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="ac06" class="mv jo iq mr b gy mw mx l my mz">def findAnagrams(s, p):<br/>    target = [0] *  26<br/>    result = []<br/>    count = [0] * 26<br/>    start = 0<br/>    <br/>    for c in p:<br/>        target[ord(c) - ord('a')] += 1<br/>   <br/>    for i in range(len(s)):<br/>        count[ord(s[i]) - ord('a')] += 1<br/>        if i - start == len(p):<br/>            count[ord(s[start]) - ord('a')] -= 1<br/>            start += 1<br/>        <br/>        if count == target:<br/>            result.append(start)</span><span id="d03a" class="mv jo iq mr b gy nc mx l my mz">    return result</span></pre><h1 id="6f45" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">最大平均子阵列I</h1><p id="bed5" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个由n个元素组成的num的整数数组和一个整数k。</p><p id="56b8" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">找到长度等于k的具有最大平均值的连续子阵列，并返回该值<em class="nb"/>。任何计算误差小于10–5的答案都将被接受。</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="59e6" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input: </strong>nums = [1,12,-5,-6,50,3], k = 4</span><span id="2b27" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output: </strong>12.75000</span><span id="a298" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Explanation: </strong>Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75</span></pre><p id="f0e4" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="ac19" class="mv jo iq mr b gy mw mx l my mz">def findMaxAverage(self, nums, k):<br/>    st = 0<br/>    max_sum = float('-inf')<br/>    win_sum = 0.0<br/>    <br/>    for i in range(len(nums)):<br/>        win_sum += nums[i]<br/>        if i &gt;= k-1:<br/>            max_sum = max(win_sum, max_sum)<br/>            win_sum -= nums[st]<br/>            st += 1<br/>        <br/>    return max_sum/k</span></pre><h1 id="4a05" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">k半径子阵列平均值</h1><p id="d9b0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">构建并返回长度为n的数组avgs，其中avgs[i]是以索引I为中心的子数组的k半径平均值。</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="b4d6" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input:</strong> nums = [7,4,3,9,1,8,5,2,6], k = 3<br/><strong class="mr ir">Output:</strong> [-1,-1,-1,5,4,4,-1,-1,-1]</span></pre><p id="593f" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="cd62" class="mv jo iq mr b gy mw mx l my mz">def getAverages(self, nums, k):<br/>    if k == 0:<br/>        return nums<br/>        <br/>    n = len(nums)<br/>    ans = [-1] * n<br/>    prefSum = [0] * n<br/>        <br/>    for i in range(0, n):<br/>        if i == 0:<br/>            prefSum[0] = nums[i]<br/>        else:<br/>            prefSum[i] = prefSum[i-1] + nums[i]<br/>                <br/>    for i in range(k, n-k):<br/>        if i-k-1 &lt; 0:<br/>            ans[i] = (prefSum[i + k])//(2*k + 1)<br/>        else:<br/>            ans[i] = (prefSum[i + k] - prefSum[i - k - 1])//(2*k + 1)<br/>                <br/>    return ans</span></pre><h1 id="7797" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">具有不同字符的大小为三的子字符串</h1><p id="1d91" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果没有重复的字符，字符串是好的。</p><p id="d3c7" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">给定一个字符串s，返回 s中长度为3的好的子字符串的数量。</p><p id="dd50" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">请注意，如果同一个子字符串多次出现，则每次出现都要计数。</p><p id="3a8f" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">子串是字符串中连续的字符序列。</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="caa0" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input</strong>: s = "xyzzaz"</span><span id="2c4d" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output</strong>: 1</span><span id="255e" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Explanation</strong>: There are 4 substrings of size 3: "xyz", "yzz", "zza", and "zaz".</span><span id="0c6f" class="mv jo iq mr b gy nc mx l my mz">The only good substring of length 3 is "xyz".</span></pre><p id="65d1" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="e691" class="mv jo iq mr b gy mw mx l my mz">class Solution(object):<br/>    def countGoodSubstrings(self, s):<br/>        """<br/>        :type s: str<br/>        :rtype: int<br/>        """<br/>        k = 3<br/>        <br/>        if k &gt; len(s):<br/>            return 0<br/>        <br/>        freq = {}<br/>        count = 0<br/>        start = 0<br/>        <br/>        for i in range(len(s)):<br/>            if s[i] not in freq:<br/>                freq[s[i]] = 0<br/>            freq[s[i]] += 1<br/>            <br/>            if i &gt;= k - 1:<br/>                if len(freq) == k:<br/>                    count += 1<br/>                <br/>                freq[s[start]] -= 1<br/>                if freq[s[start]] == 0:<br/>                    del freq[s[start]]<br/>                <br/>                start += 1<br/>                <br/>        return count</span></pre><h1 id="d483" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">最频繁元素的频率</h1><p id="b24d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">元素的频率是它在数组中出现的次数。</p><p id="a794" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">给定一个整数数组nums和一个整数k。在一次操作中，可以选择nums的索引，并将该索引处的元素递增1。</p><p id="dc52" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">在执行最多 k <em class="nb">个操作</em>后，返回<em class="nb">一个元件的最大可能频率。</em></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="8a0c" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input: </strong>nums = [1,2,4], k = 5</span><span id="1d5b" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output: </strong>3</span><span id="f8fa" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Explanation: </strong>Increment the first element three times and the second element two times to make nums = [4,4,4].</span><span id="301f" class="mv jo iq mr b gy nc mx l my mz">4 has a frequency of 3.</span></pre><p id="ea7c" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="22dd" class="mv jo iq mr b gy mw mx l my mz">class Solution(object):<br/>    def maxFrequency(self, nums, k):<br/>        """<br/>        :type nums: List[int]<br/>        :type k: int<br/>        :rtype: int<br/>        """<br/>        len_nums = len(nums)<br/>        nums.sort()<br/>        max_freq = 1<br/>        freq = 1<br/>        left = 0<br/>        ops = k<br/>        <br/>        for right in range(1, len_nums):<br/>            ops -= (nums[right] - nums[right - 1]) * freq<br/>            freq += 1<br/>            if ops &gt;= 0:<br/>                max_freq = max(max_freq, freq)<br/>            else:<br/>                while ops &lt; 0:<br/>                    ops += nums[right] - nums[left]<br/>                    left += 1<br/>                    freq -= 1<br/>                    <br/>        return max_freq</span></pre><h1 id="781c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">最大擦除值</h1><p id="154f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给你一个正整数num的数组，你想删除一个包含唯一元素的子数组。擦除子数组得到的分数等于它的元素之和。</p><p id="b334" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">返回<em class="nb">擦除一个子数组所能得到的最高分数。</em></p><p id="a7e3" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">如果数组b形成了a的连续子序列，即如果它等于a[l]，a[l+1]，…，a[r] for some (l，r)，则称它是a的子数组。</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="398a" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input</strong>: nums = [4,2,4,5,6]</span><span id="60b6" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output</strong>: 17</span><span id="6317" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Explanation</strong>: The optimal subarray here is [2,4,5,6].</span></pre><p id="1f1e" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="d855" class="mv jo iq mr b gy mw mx l my mz">class Solution(object):<br/>    def maximumUniqueSubarray(self, nums):<br/>        """<br/>        :type nums: List[int]<br/>        :rtype: int<br/>        """<br/>        m = {}<br/>        final = 0<br/>        summ = 0<br/>        l = 0<br/>        <br/>        for i in range(len(nums)):<br/>            if nums[i] in m:<br/>                index = m[nums[i]]<br/>                while l &lt;= index:<br/>                    del m[nums[l]]<br/>                    summ -= nums[l]<br/>                    l += 1<br/>            <br/>            m[nums[i]] = i<br/>            summ += nums[i]<br/>            final = max(final, summ)<br/>        <br/>        return final</span></pre><h1 id="6b43" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">子字符串出现的最大次数</h1><p id="6c76" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个字符串s，根据以下规则返回任何子字符串的最大出现次数:</p><ul class=""><li id="e383" class="ma mb iq kn b ko lv ks lw kw mc la md le me li mf mg mh mi bi translated">子字符串中唯一字符的数量必须小于或等于maxLetters。</li><li id="35c4" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated">子字符串大小必须介于minSize和maxSize之间。</li></ul><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="0ad9" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input</strong>: s = "aababcaab", maxLetters = 2, minSize = 3, maxSize = 4</span><span id="8aae" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output</strong>: 2</span><span id="3159" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Explanation</strong>: Substring "aab" has 2 ocurrences in the original string.</span><span id="98fc" class="mv jo iq mr b gy nc mx l my mz">It satisfies the conditions, 2 unique letters and size 3 (between minSize and maxSize).</span></pre><p id="d4c1" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="fa1d" class="mv jo iq mr b gy mw mx l my mz">class Solution(object):<br/>    def maxFreq(self, s, maxLetters, minSize, maxSize):<br/>        """<br/>        :type s: str<br/>        :type maxLetters: int<br/>        :type minSize: int<br/>        :type maxSize: int<br/>        :rtype: int<br/>        """<br/>        cnt = {}<br/>        res= 0<br/>        <br/>        for i in range(0,len(s)-minSize+1):<br/>            sub = s[i:i + minSize]<br/>            <br/>            if len(set(sub)) &lt;= maxLetters:<br/>                if sub not in cnt:<br/>                    cnt[sub] = 0<br/>                <br/>                cnt[sub] += 1<br/>                res = max(res, cnt[sub])<br/>                <br/>        return res</span></pre><h1 id="aaf5" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">大小为K且平均值大于或等于阈值的子数组的数量</h1><p id="73ab" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个整数数组arr和两个整数k和threshold。</p><p id="4eac" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">返回<em class="nb">大小为k且平均值大于或等于阈值的子数组</em>的数量。</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="ba1e" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input: </strong>arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4</span><span id="b847" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output: </strong>3</span><span id="0c9f" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Explanation: </strong>Sub-arrays [2,5,5],[5,5,5] and [5,5,8] have averages 4, 5 and 6 respectively. All other sub-arrays of size 3 have averages less than 4 (the threshold)<strong class="mr ir">.</strong></span></pre><p id="6c68" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="ea91" class="mv jo iq mr b gy mw mx l my mz">class Solution(object):<br/>    def numOfSubarrays(self, arr, k, threshold):<br/>        """<br/>        :type arr: List[int]<br/>        :type k: int<br/>        :type threshold: int<br/>        :rtype: int<br/>        """<br/>        start = 0<br/>        windowSum = 0<br/>        count = 0<br/>        <br/>        for windowEnd in range(len(arr)):<br/>            windowSum += arr[windowEnd] <br/>            if windowEnd &gt;= k - 1:<br/>                if (windowSum/k) &gt;= threshold:<br/>                    count+=1<br/>                windowSum -=arr[start]<br/>                start += 1<br/>                <br/>        return count</span></pre><h1 id="30c8" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">包含所有三个字符的子字符串的数量</h1><p id="1075" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个仅由字符<em class="nb"> a </em>、<em class="nb"> b </em>和<em class="nb"> c </em>组成的字符串s。</p><p id="19c1" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">返回至少包含一次所有这些字符<em class="nb"> a </em>、<em class="nb"> b </em>和<em class="nb"> c </em>的子字符串的数量。</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="5d92" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input: </strong>s = "abcabc"</span><span id="b4da" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output: </strong>10</span><span id="2247" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Explanation: </strong>The substrings containing at least one occurrence of the characters <em class="nb">a</em>, <em class="nb">b</em> and <em class="nb">c are "</em>abc<em class="nb">", "</em>abca<em class="nb">", "</em>abcab<em class="nb">", "</em>abcabc<em class="nb">", "</em>bca<em class="nb">", "</em>bcab<em class="nb">", "</em>bcabc<em class="nb">", "</em>cab<em class="nb">", "</em>cabc<em class="nb">" </em>and<em class="nb"> "</em>abc<em class="nb">" </em>(again)</span></pre><p id="216a" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="19df" class="mv jo iq mr b gy mw mx l my mz">class Solution(object):<br/>    def numberOfSubstrings(self, s):<br/>        """<br/>        :type s: str<br/>        :rtype: int<br/>        """<br/>        count, left = 0, 0<br/>        map = {x:0 for x in "abc"}<br/>        <br/>        for right in range(0,len(s)):<br/>            map[s[right]] += 1<br/>            <br/>            while map["a"] and map["b"] and map["c"]:<br/>                map[s[left]] -= 1<br/>                left += 1<br/>            <br/>            count += left<br/>            <br/>        return count</span></pre><h1 id="a027" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">您可以从卡中获得的最高点数</h1><p id="2957" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有几张牌排成一排，每张牌都有相应的点数。点数在整数数组cardPoints中给出。</p><p id="5ff6" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">在一个步骤中，您可以从该行的开头或结尾抽取一张牌。你必须拿k张牌。</p><p id="27d4" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">你的分数是你所拿的牌的分数之和。</p><p id="9862" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">给定整数数组cardPoints和整数k，返回您可以获得的最大分数<em class="nb"/>。</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="4b6c" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input: </strong>cardPoints = [1,2,3,4,5,6,1], k = 3</span><span id="4f7a" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output: </strong>12</span><span id="6d63" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Explanation: </strong>After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12.</span></pre><p id="2828" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="8997" class="mv jo iq mr b gy mw mx l my mz">class Solution(object):<br/>    def maxScore(self, cardPoints, k):<br/>        """<br/>        :type cardPoints: List[int]<br/>        :type k: int<br/>        :rtype: int<br/>        """<br/>        best = score = sum(cardPoints[:k])<br/>        <br/>        for i in range(1, k+1):<br/>            score = score - cardPoints[k-i] + cardPoints[-i]<br/>            best = score if score &gt; best else best<br/>            <br/>        return best</span></pre><h1 id="565d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">绝对差值小于或等于的最长连续子阵列</h1><p id="4f88" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个整数数组nums和一个整数极限，返回最长的非空子数组的大小，使得这个子数组的任意两个元素之间的绝对差小于或等于极限<em class="nb">。</em></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="4c9c" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input</strong>: nums = [8,2,4,7], limit = 4</span><span id="5002" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output</strong>: 2</span><span id="a784" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Explanation</strong>: All subarrays are:</span><span id="4053" class="mv jo iq mr b gy nc mx l my mz">[8] with maximum absolute diff |8-8| = 0 &lt;= 4.</span><span id="cb02" class="mv jo iq mr b gy nc mx l my mz">[8,2] with maximum absolute diff |8-2| = 6 &gt; 4.</span><span id="eaa5" class="mv jo iq mr b gy nc mx l my mz">[8,2,4] with maximum absolute diff |8-2| = 6 &gt; 4.</span><span id="130f" class="mv jo iq mr b gy nc mx l my mz">[8,2,4,7] with maximum absolute diff |8-2| = 6 &gt; 4.</span><span id="b634" class="mv jo iq mr b gy nc mx l my mz">[2] with maximum absolute diff |2-2| = 0 &lt;= 4.</span><span id="c6c6" class="mv jo iq mr b gy nc mx l my mz">[2,4] with maximum absolute diff |2-4| = 2 &lt;= 4.</span><span id="6062" class="mv jo iq mr b gy nc mx l my mz">[2,4,7] with maximum absolute diff |2-7| = 5 &gt; 4.</span><span id="0073" class="mv jo iq mr b gy nc mx l my mz">[4] with maximum absolute diff |4-4| = 0 &lt;= 4.</span><span id="fd0e" class="mv jo iq mr b gy nc mx l my mz">[4,7] with maximum absolute diff |4-7| = 3 &lt;= 4.</span><span id="0505" class="mv jo iq mr b gy nc mx l my mz">[7] with maximum absolute diff |7-7| = 0 &lt;= 4.</span><span id="3af3" class="mv jo iq mr b gy nc mx l my mz">Therefore, the size of the longest subarray is 2.</span></pre><p id="e1ba" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="86c8" class="mv jo iq mr b gy mw mx l my mz">class Solution(object):<br/>    def longestSubarray(self, nums, limit):<br/>        """<br/>        :type nums: List[int]<br/>        :type limit: int<br/>        :rtype: int<br/>        """<br/>        if not nums:<br/>            return 0<br/>        if len(nums) == 1:<br/>            return 1</span><span id="48c3" class="mv jo iq mr b gy nc mx l my mz">l = 0<br/>        r = 1<br/>        cur_mx = nums[0]<br/>        cur_mn = nums[0]<br/>        max_l = 1<br/>        <br/>        while l &lt;= r and r &lt; len(nums):<br/>            cur_mx = max(cur_mx, nums[r])<br/>            cur_mn = min(cur_mn, nums[r])</span><span id="0b38" class="mv jo iq mr b gy nc mx l my mz">if cur_mx - cur_mn &lt;= limit:<br/>                max_l = max(max_l, r - l + 1)<br/>            else:<br/>                if nums[l] == cur_mx:<br/>                    cur_mx = max(nums[l + 1:r + 1])<br/>                if nums[l] == cur_mn:<br/>                    cur_mn = min(nums[l + 1:r + 1])<br/>                l += 1<br/>                <br/>            r += 1<br/>            <br/>        return max_l</span></pre><h1 id="df9c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">给定长度的子字符串中元音的最大数量</h1><p id="1a6e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定字符串s和整数k。</p><p id="c818" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">返回长度为k的s的任意子串中元音字母的最大数量。</p><p id="a166" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">英语中的元音字母是(a，e，I，o，u)。</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="962d" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input</strong>: s = "abciiidef", k = 3</span><span id="4d36" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output</strong>: 3</span><span id="5c8a" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Explanation</strong>: The substring "iii" contains 3 vowel letters.</span></pre><p id="90e2" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="a80a" class="mv jo iq mr b gy mw mx l my mz">class Solution(object):<br/>    def maxVowels(self, s, k):<br/>        """<br/>        :type s: str<br/>        :type k: int<br/>        :rtype: int<br/>        """<br/>        vowels = ['a','e','i','o','u']<br/>        ans = 0<br/>        win = ''<br/>        v = 0<br/>        <br/>        for char in range(k):<br/>            win += s[char]<br/>            <br/>            if s[char] in vowels:<br/>                v+=1<br/>                <br/>        ans = max(ans,v)<br/>        <br/>        for char in range(len(s)-k):<br/>            win += s[char+k]<br/>            if s[char] in vowels:<br/>                v-=1<br/>            if s[char+k] in vowels:<br/>                v+=1<br/>            ans=max(ans,v)<br/>        return ans</span></pre><p id="db41" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">另一种方法:</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="55df" class="mv jo iq mr b gy mw mx l my mz">def getMaxVowels(s, k):<br/>    vowels = ['a', 'e', 'i', 'o', 'u']<br/>    temp = ''<br/>    isVowel = True<br/>    start = 0<br/>    maxCount = 0<br/>    <br/>    for i in range(len(s)):<br/>        if s[i] in vowels:<br/>            temp += s[i]<br/>        else:<br/>            isVowel = False<br/>        <br/>        if (i - start + 1 == k or isVowel == False):<br/>            maxCount = max(maxCount, len(temp))<br/>            if isVowel == False:<br/>                temp = ''<br/>                isVowel = True<br/>            else:<br/>                temp = temp[1:]<br/>                start += 1<br/>            <br/>    return maxCount</span></pre><h1 id="2a91" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">找到两个不重叠的子数组，每个子数组都有目标和</h1><p id="51d8" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个整数数组arr和一个整数目标。</p><p id="ee3e" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">您必须找到arr的两个不重叠的子数组，每个子数组都有一个和相等的目标。可能有多个答案，所以你必须找到两个子数组长度之和最小的答案。</p><p id="77ad" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">返回两个所需子数组长度之和的最小值，如果找不到这两个子数组，则返回-1。</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="e0d8" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input</strong>: arr = [3,2,2,4,3], target = 3</span><span id="cdc3" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output</strong>: 2</span><span id="2adf" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Explanation</strong>: Only two sub-arrays have sum = 3 ([3] and [3]). The sum of their lengths is 2</span></pre><p id="c017" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="3ffc" class="mv jo iq mr b gy mw mx l my mz">class Solution(object):<br/>    def minSumOfLengths(self, arr, target):<br/>        """<br/>        :type arr: List[int]<br/>        :type target: int<br/>        :rtype: int<br/>        """<br/>        INF = len(arr) + 1<br/>        best_at_i = [INF]*len(arr) <br/>        best = INF <br/>        curr_sum = 0 <br/>        <br/>        left = 0<br/>        for right in range(len(arr)):<br/>            curr_sum += arr[right]<br/>            <br/>            while curr_sum &gt; target and left &lt;= right:<br/>                curr_sum -= arr[left]<br/>                left += 1<br/>                <br/>            if curr_sum == target:<br/>                best = min(best, best_at_i[left-1] + right - left + 1)<br/>                best_at_i[right] = min(best_at_i[right-1], right - left + 1)<br/>            else:<br/>                best_at_i[right] = best_at_i[right-1]<br/>        <br/>        if best == INF:<br/>            return -1<br/>        return best</span></pre><h1 id="6cc3" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">删除一个元素后1的最长子数组</h1><p id="cdd1" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定二进制数组nums，应该从中删除一个元素。</p><p id="e087" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">返回结果数组中只包含 1的<em class="nb">的最长非空子数组的大小<em class="nb">。如果没有这样的子数组，则返回0。</em></em></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="d1d6" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input</strong>: nums = [1,1,0,1]</span><span id="8fb2" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output</strong>: 3</span><span id="569b" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Explanation</strong>: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.</span></pre><p id="08ff" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="449f" class="mv jo iq mr b gy mw mx l my mz">class Solution(object):<br/>    def longestSubarray(self, nums):<br/>        """<br/>        :type nums: List[int]<br/>        :rtype: int<br/>        """<br/>        windowStart = 0<br/>        hashmap = {x: 0 for x in nums}<br/>        max_length = 0<br/>        <br/>        if 0 not in hashmap.keys():<br/>            return len(nums) - 1<br/>        <br/>        for windowEnd in range(len(nums)):<br/>            hashmap[nums[windowEnd]] += 1<br/>            <br/>            if hashmap[0] &gt; 1:<br/>                hashmap[nums[windowStart]] -= 1<br/>                windowStart += 1<br/>            <br/>            max_length = max(max_length, windowEnd - windowStart)<br/>        return (max_length)</span></pre><h1 id="eeff" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">将X减少到零的最少操作</h1><p id="b178" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个整数数组nums和一个整数x。在一次操作中，您可以从数组nums中移除最左边或最右边的元素，然后从x中减去它的值。请注意，这将修改数组以供将来操作使用。</p><p id="a550" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">如果可能，返回<em class="nb">将</em> x <em class="nb">减少到正好</em> 0 <em class="nb">的最小操作数，否则返回</em> -1。</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="8f72" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input</strong>: nums = [1,1,4,2,3], x = 5</span><span id="5526" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output</strong>: 2</span><span id="df25" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Explanation</strong>: The optimal solution is to remove the last two elements to reduce x to zero.</span></pre><p id="78b4" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="87c8" class="mv jo iq mr b gy mw mx l my mz">class Solution(object):<br/>    def minOperations(self, nums, x):<br/>        """<br/>        :type nums: List[int]<br/>        :type x: int<br/>        :rtype: int<br/>        """<br/>        S = sum(nums)<br/>        left = right = curr = 0<br/>        ans = -1<br/>        <br/>        while right&lt;len(nums):<br/>            curr += nums[right]<br/>            right+=1<br/>            while left&lt;len(nums) and curr&gt;S-x:<br/>                curr-=nums[left]<br/>                left+=1<br/>            if curr == S-x:<br/>                ans = max(ans,right-left)<br/>                <br/>        return len(nums) - ans if ans!=-1 else ans</span></pre><h1 id="3456" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">在预算内获得相等的子字符串</h1><p id="bff3" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">还会给你一个整数maxCost。</p><p id="f6ae" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">返回s的子字符串的最大长度，该长度可以更改为与twith的对应子字符串相同，并且开销小于或等于maxCost。</p><p id="4a5f" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">如果s中没有子串可以转换为t中相应的子串，则返回0。</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="3362" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input:</strong> s = "abcd", t = "bcdf", maxCost = 3<br/><strong class="mr ir">Output:</strong> 3<br/><strong class="mr ir">Explanation: </strong>"abc" of s can change to "bcd". That costs 3, so the maximum length is 3.</span></pre><p id="bdf9" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="681c" class="mv jo iq mr b gy mw mx l my mz">class Solution(object):<br/>    def equalSubstring(self, s, t, maxCost):<br/>        """<br/>        :type s: str<br/>        :type t: str<br/>        :type maxCost: int<br/>        :rtype: int<br/>        """<br/>        diff = [abs(ord(s[i]) - ord(t[i])) for i in range(len(s))]<br/>        summ = 0<br/>        low = length = 0<br/>        <br/>        for i in range(len(s)):<br/>            summ += diff[i]<br/>            <br/>            while low &lt; i and summ &gt; maxCost:<br/>                summ -= diff[low]<br/>                low += 1<br/>            if summ &lt;= maxCost:<br/>                length = max(length, i-low+1)<br/>                <br/>        return length</span></pre><h1 id="730b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">坏脾气的书店老板</h1><p id="6d86" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有一个书店老板，他的店开了n分钟。每分钟都有一些顾客进入商店。给定一个长度为n的客户整数数组，其中customers[i]是在第I分钟开始时进入商店的客户数量，所有这些客户在该分钟结束后都离开了商店。</p><p id="3f46" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">有几分钟，书店老板脾气暴躁。给你一个二进制数组grumpy，其中如果书店老板在第I分钟脾气不好，grumpy[i]为1，否则为0。</p><p id="4c3f" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">书店老板脾气暴躁的时候，那一分钟的顾客不满意，反之，则满意。</p><p id="a75b" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">书店老板知道一个秘密技巧，可以让自己连续几分钟都不暴躁，但只能用一次。</p><p id="63f2" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">返回全天可以满足的客户的最大数量。</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="c31c" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input:</strong> customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3<br/><strong class="mr ir">Output:</strong> 16<br/><strong class="mr ir">Explanation:</strong> The bookstore owner keeps themselves not grumpy for the last 3 minutes. <br/>The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.</span></pre><p id="875f" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="212c" class="mv jo iq mr b gy mw mx l my mz">class Solution(object):<br/>    def maxSatisfied(self, customers, grumpy, minutes):<br/>        """<br/>        :type customers: List[int]<br/>        :type grumpy: List[int]<br/>        :type minutes: int<br/>        :rtype: int<br/>        """<br/>        n = len(customers)<br/>        res = 0<br/>        <br/>        for i in range(n):<br/>            if grumpy[i] == 0:<br/>                res += customers[i]<br/>        sum1 = 0        <br/>        for i in range(minutes):<br/>            if grumpy[i] == 1:<br/>                sum1 += customers[i]<br/>                <br/>        result = sum1<br/>        for r in range(minutes, n):<br/>            if grumpy[r] == 1:<br/>                sum1 += customers[r]<br/>            if grumpy[r - minutes] == 1:<br/>                sum1 -= customers[r - minutes]<br/>            result = max(sum1, result)<br/>        <br/>        return res + result</span></pre><h1 id="9b43" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">最大连续一III</h1><p id="0f77" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定二进制数组nums和一个整数k，如果最多能翻转k个0，则返回数组中连续1的最大数量。</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="2245" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input</strong>: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2</span><span id="62ad" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output</strong>: 6</span><span id="8e64" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Explanation</strong>: [1,1,1,0,0,1,1,1,1,1,1]</span><span id="d3e5" class="mv jo iq mr b gy nc mx l my mz">Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.</span></pre><p id="0dcf" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="22eb" class="mv jo iq mr b gy mw mx l my mz">class Solution(object):<br/>    def longestOnes(self, nums, k):<br/>        """<br/>        :type nums: List[int]<br/>        :type k: int<br/>        :rtype: int<br/>        """<br/>        start, end, n, max_consecutive = 0, 0, len(nums), 0<br/>        <br/>        while end &lt; n:<br/>            if nums[end] == 0:<br/>                if k &gt; 0:<br/>                    k -= 1<br/>                else:                  <br/>                    max_consecutive = max(max_consecutive, end - start)<br/>                    if nums[start] == 0:<br/>                        k += 1<br/>                    start += 1<br/>                    continue<br/>            end += 1</span></pre><h1 id="668f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">带和的二元子阵列</h1><p id="1295" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定二进制数组nums和一个整数目标，返回非空子数组的数量和目标。</p><p id="a6e2" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">子数组是数组的连续部分。</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="1934" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input</strong>: nums = [1,0,1,0,1], goal = 2</span><span id="f44f" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output</strong>: 4</span><span id="0fd3" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Explanation</strong>: The 4 subarrays are bolded and underlined below:</span><span id="2820" class="mv jo iq mr b gy nc mx l my mz">[1,0,1,0,1]</span><span id="27da" class="mv jo iq mr b gy nc mx l my mz">[1,0,1,0,1]</span><span id="2710" class="mv jo iq mr b gy nc mx l my mz">[1,0,1,0,1]</span><span id="7512" class="mv jo iq mr b gy nc mx l my mz">[1,0,1,0,1]</span></pre><p id="0d39" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="97ca" class="mv jo iq mr b gy mw mx l my mz">class Solution(object):<br/>    def numSubarraysWithSum(self, nums, goal):<br/>        """<br/>        :type nums: List[int]<br/>        :type goal: int<br/>        :rtype: int<br/>        """<br/>        cumSum = 0<br/>        result = 0<br/>        <br/>        hashMap = {0:1}<br/>        <br/>        for x in nums:<br/>            cumSum += x<br/>            <br/>            val = cumSum - goal<br/>            if (val) in hashMap:<br/>                result += hashMap[val]<br/>            <br/>            hashMap[cumSum] = hashMap.get(cumSum, 0) + 1<br/>        <br/>        return result</span></pre><h1 id="6378" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">重复子阵列的最大长度</h1><p id="5a75" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定两个整数数组nums1和nums2，返回出现在这两个数组中的子数组的最大长度。</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="aacb" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input</strong>: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]</span><span id="0ab8" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Output</strong>: 3</span><span id="c6c7" class="mv jo iq mr b gy nc mx l my mz"><strong class="mr ir">Explanation</strong>: The repeated subarray with maximum length is [3,2,1].</span></pre><p id="7119" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="d4ee" class="mv jo iq mr b gy mw mx l my mz">class Solution(object):<br/>    def findLength(self, nums1, nums2):<br/>        """<br/>        :type nums1: List[int]<br/>        :type nums2: List[int]<br/>        :rtype: int<br/>        """<br/>        nums2_str = ''.join([chr(x) for x in nums2])<br/>        max_str = ''<br/>        res = 0<br/>        <br/>        for num in nums1:<br/>            max_str += chr(num)<br/>            if max_str in nums2_str:<br/>                res = max(res,len(max_str))<br/>            else:<br/>                max_str = max_str[1:]<br/>                <br/>        return res</span></pre><h1 id="2d42" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">最长湍流子阵</h1><p id="abbe" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个整数数组arr，返回arr的最大湍流子数组的长度。</p><p id="7cf5" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">如果比较符号在子阵列中的每对相邻元素之间翻转，则子阵列是湍流的。</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="5c49" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input:</strong> arr = [9,4,2,10,7,8,8,1,9]<br/><strong class="mr ir">Output:</strong> 5<br/><strong class="mr ir">Explanation:</strong> arr[1] &gt; arr[2] &lt; arr[3] &gt; arr[4] &lt; arr[5]</span></pre><p id="e98a" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="2feb" class="mv jo iq mr b gy mw mx l my mz">class Solution(object):<br/>    def maxTurbulenceSize(self, arr):<br/>        """<br/>        :type arr: List[int]<br/>        :rtype: int<br/>        """<br/>        n = len(arr)<br/>        ans = 1<br/>        anchor = 0<br/>        <br/>        for i in range(1, n):<br/>            c = cmp(arr[i-1], arr[i])<br/>            if c == 0:<br/>                anchor = i<br/>            elif i == n - 1 or c * cmp(arr[i], arr[i+1]) != -1:<br/>                ans = max(ans, i - anchor + 1)<br/>                anchor = i<br/>        <br/>        return ans</span></pre><h1 id="4c97" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">按顺序排列的所有元音中最长的子串</h1><p id="89b2" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个由英文元音组成的字符串单词，返回单词中最长的漂亮子串的长度。如果不存在这样的子字符串，则返回0。</p><p id="316b" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">子串是字符串中连续的字符序列。</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="485f" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input:</strong> word = "aeiaaioaaaaeiiiiouuuooaauuaeiu"<br/><strong class="mr ir">Output:</strong> 13<br/><strong class="mr ir">Explanation:</strong> The longest beautiful substring in word is "aaaaeiiiiouuu" of length 13.</span></pre><p id="8262" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="adc1" class="mv jo iq mr b gy mw mx l my mz">class Solution(object):<br/>    def longestBeautifulSubstring(self, word):<br/>        """<br/>        :type word: str<br/>        :rtype: int<br/>        """<br/>        res = 0<br/>        i = 0<br/>        seen = set()<br/>        <br/>        for j in range(0,len(word)):<br/>            if j &gt; 0 and word[j] &lt; word[j-1]:<br/>                seen = set()<br/>                i = j<br/>            <br/>            seen.add(word[j])<br/>            if len(seen) == 5:<br/>                res = max(res,j-i+1)<br/>                <br/>        return res</span></pre><h1 id="d0d4" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">水果放进篮子里</h1><p id="0c27" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">你正在参观一个农场，农场里从左到右排列着一排果树。这些树由一个整数数组<code class="fe nd ne nf mr b">fruits</code>表示，其中<code class="fe nd ne nf mr b">fruits[i]</code>是<code class="fe nd ne nf mr b">ith</code>树生产的<strong class="kn ir">类型</strong>的水果。</p><p id="5d9c" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">你想收集尽可能多的水果。然而，业主有一些你必须遵守的严格规则:</p><ul class=""><li id="3738" class="ma mb iq kn b ko lv ks lw kw mc la md le me li mf mg mh mi bi translated">你只有<strong class="kn ir">两个</strong>筐，每个筐只能装一个<strong class="kn ir">单式</strong>水果。每个篮子可以装多少水果没有限制。</li><li id="22ad" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated">从你选择的任何一棵树开始，你必须从每棵<strong class="kn ir">树(包括起始树)中挑选<strong class="kn ir">恰好一个水果</strong>，同时向右移动。摘下的水果必须放在你的篮子里。</strong></li><li id="e4a1" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated">一旦你到达一棵树，树上的水果装不下你的篮子，你必须停下来。</li></ul><p id="d083" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">给定整数数组，返回<em class="nb"/><strong class="kn ir"><em class="nb">最大</em> </strong> <em class="nb">可以采摘的水果数量</em>。</p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="aef9" class="mv jo iq mr b gy mw mx l my mz"><strong class="mr ir">Input:</strong> fruits = [1,2,1]<br/><strong class="mr ir">Output:</strong> 3<br/><strong class="mr ir">Explanation:</strong> We can pick from all 3 trees.</span></pre><p id="a729" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lk ll lm ln gt mq mr ms mt aw mu bi"><span id="2002" class="mv jo iq mr b gy mw mx l my mz">class Solution(object):<br/>    def totalFruit(self, fruits):<br/>        """<br/>        :type fruits: List[int]<br/>        :rtype: int<br/>        """<br/>        length = len(fruits)<br/>        left, right, current = 0, length - 1, {}<br/>        currentLength, longestLength = 0, 0<br/>        <br/>        for right in range(0, length):<br/>            current[fruits[right]] = current.get(fruits[right], 0) + 1<br/>            <br/>            while len(current) &gt; 2:<br/>                current[fruits[left]] -= 1<br/>                if current[fruits[left]] == 0:<br/>                    del current[fruits[left]]<br/>                left += 1   <br/>                <br/>            currentLength  = right - left + 1<br/>            longestLength = max(longestLength, currentLength)     <br/>            <br/>        return longestLength</span></pre><h1 id="fc02" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="a809" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">滑动窗口技术背后的主要思想是将两个嵌套循环转换成一个循环。通常，该技术帮助我们将时间复杂度从<strong class="kn ir"> O(n ) </strong>或<strong class="kn ir"> O(n ) </strong>降低到<strong class="kn ir"> O(n) </strong>。</p></div></div>    
</body>
</html>