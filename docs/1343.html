<html>
<head>
<title>Exposing StatefulSets in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes中公开状态集</h1>
<blockquote>原文：<a href="https://itnext.io/exposing-statefulsets-in-kubernetes-698730fb92a1?source=collection_archive---------0-----------------------#2018-09-19">https://itnext.io/exposing-statefulsets-in-kubernetes-698730fb92a1?source=collection_archive---------0-----------------------#2018-09-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/95188f150c28d570b4a80530540c1275.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQWdPUq87w7VZ6IniIKT1A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">杰弗里·西卡</figcaption></figure><p id="d13d" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">到目前为止，我们在Kubernetes每月的<a class="ae lc" href="https://github.com/kubernetes/community/blob/master/events/office-hours.md" rel="noopener ugc nofollow" target="_blank">办公时间</a>中收到的最常见的问题之一是:<em class="ld">“你如何恰当地对外公开一组声明？”</em>通常这个问题以这样的形式提出:<em class="ld">“我如何允许从集群外部连接到Mongo或Postgres的特定实例？”</em></p><p id="e5d8" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">不要害怕！这并不像看起来那么有挑战性。如果你喜欢TL；博士回答，直接跳到本帖底部就可以了。如果你想要更多的解释，请继续阅读。</p><p id="5d9c" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">当您想要直接查询一个特定的实例时，按照常规的做法，让一个服务点指向应用程序的所有实例是行不通的。这已经由您在StatefulSet旁边创建的<a class="ae lc" href="https://kubernetes.io/docs/concepts/services-networking/service/#headless-services" rel="noopener ugc nofollow" target="_blank"> Headless服务</a>在内部处理了。创建的服务将<strong class="kg ir">而不是</strong>被赋予一个<code class="fe le lf lg lh b">clusterIP</code>，而是简单地包含一个<code class="fe le lf lg lh b">Endpoints</code>列表。然后，这些<code class="fe le lf lg lh b">Endpoints</code>被用来以<code class="fe le lf lg lh b">&lt;StatefulSet&gt;-&lt;Ordinal&gt;.&lt;Service&gt;.&lt;Namespace&gt;.svc.cluster.local</code>的形式生成特定于实例的DNS记录，例如<code class="fe le lf lg lh b">app-0.myapp.default.svc.cluster.local</code>。</p><p id="a79c" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">现在，当您想将它作为<code class="fe le lf lg lh b">LoadBalancer</code>服务对外公开时，如何复制它呢？Kubernetes的开发者已经想到了这一点。；)StatefulSet中的每个Pod都有自己的标签，其中包括其<a class="ae lc" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#pod-identity" rel="noopener ugc nofollow" target="_blank">生成的Pod标识</a> : <code class="fe le lf lg lh b">statefulset.kubernetes.io/pod-name</code>。你知道这意味着什么吗？这意味着我们可以在服务选择器中使用它！</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="2625" class="lq lr iq lh b gy ls lt l lu lv">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: app-0<br/>spec:<br/>  type: LoadBalancer<br/>  <strong class="lh ir">selector:</strong><br/>    <strong class="lh ir">statefulset.kubernetes.io/pod-name: app-0</strong><br/>  ports:<br/>  - protocol: TCP<br/>    port: 80<br/>    targetPort: 80</span></pre><p id="c9c2" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">虽然headless服务可能无法满足我们的所有需求，但是我们可以创建额外的服务，指向StatefulSet的各个pod。一般来说，如果没有仔细的计划，StatefulSets是不会被放大或缩小的，所以值得花费少量的额外努力来创建一些额外的服务。</p><p id="3fa1" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这样，我们将能够单独公开我们的实例，但是我们实际上可以在这一点上有所改进。</p><p id="5298" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">当一个外部Kubernetes服务(<code class="fe le lf lg lh b">NodePort</code>和<code class="fe le lf lg lh b">LoadBalancer</code>)被创建时，它将在集群中的<strong class="kg ir">所有</strong>节点上打开一个端口，该端口可用于到达我们公开的服务。一般来说，当您将流量分散到同一个Pod的多个实例中时，这很好，但是当您希望将流量定向到单个实例时，这就不太好了。如果我们能够将流量直接导向运行StatefulSet的特定实例的节点，那就更好了。谢天谢地，开发人员也想到了这个场景！</p><p id="dc24" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">通过将服务属性<code class="fe le lf lg lh b"><a class="ae lc" href="https://kubernetes.io/docs/tutorials/services/source-ip/#source-ip-for-services-with-type-loadbalancer" rel="noopener ugc nofollow" target="_blank">externalTrafficPolicy</a></code> <a class="ae lc" href="https://kubernetes.io/docs/tutorials/services/source-ip/#source-ip-for-services-with-type-loadbalancer" rel="noopener ugc nofollow" target="_blank">设置为</a> <code class="fe le lf lg lh b"><a class="ae lc" href="https://kubernetes.io/docs/tutorials/services/source-ip/#source-ip-for-services-with-type-loadbalancer" rel="noopener ugc nofollow" target="_blank">Local</a></code>，可以将流量直接路由到该节点。这将强制服务仅代理本地端点的流量。也就是说，群集中任何运行Pod特定实例的<strong class="kg ir">而非</strong>节点将<strong class="kg ir">而非</strong>代理流量，因此将无法通过任何外部健康检查。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="dbe6" class="lq lr iq lh b gy ls lt l lu lv">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: app-0<br/>spec:<br/>  type: LoadBalancer<br/>  <strong class="lh ir">externalTrafficPolicy: Local</strong><br/>  selector:<br/>    statefulset.kubernetes.io/pod-name: app-0<br/>  ports:<br/>  - protocol: TCP<br/>    port: 80<br/>    targetPort: 80</span></pre><p id="e29f" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这可能看起来有点奇怪，但这是一个非常有用的通用方法，可以很好地与各种云提供商及其负载平衡器配合。通过不代理流量，节点将自动从该外部服务的负载平衡器池中移除，从而强制流量仅流向运行该特定实例的节点。</p><p id="0198" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这样，您应该能够在外部公开StatefulSets，并在将流量路由到单个实例时删除不必要的额外跃点。</p><h1 id="15ac" class="lw lr iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">奖金:</h1><p id="e442" class="pw-post-body-paragraph ke kf iq kg b kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx mx kz la lb ij bi translated">如果您不想为StatefulSet的每个Pod创建一个额外的服务，那么可以使用一个强大的集群自动化工具来实现自动化，这个工具叫做<a class="ae lc" href="https://metacontroller.app/" rel="noopener ugc nofollow" target="_blank">元控制器</a>。它允许您创建自己的简单控制器，您可以在其中触发附加的脚本或动作。他们的一个例子是使用他们的<code class="fe le lf lg lh b"><a class="ae lc" href="https://github.com/GoogleCloudPlatform/metacontroller/tree/master/examples/service-per-pod" rel="noopener ugc nofollow" target="_blank">DecoratorController</a></code>为StatefulSet实例自动创建服务。</p><h1 id="6fc0" class="lw lr iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">TL；博士:</h1><ul class=""><li id="0db2" class="my mz iq kg b kh mt kl mu kp na kt nb kx nc lb nd ne nf ng bi translated">StatefulSet Pods具有标签:<code class="fe le lf lg lh b">statefulset.kubernetes.io/pod-name</code>，其中包含它们生成的名称(<code class="fe le lf lg lh b">&lt;StatefulSet Name&gt;-&lt;Ordinal&gt;</code>)。您可以为每个使用该标签作为选择器的实例创建单独的服务，以公开StatefulSet的单独实例。</li><li id="9eb6" class="my mz iq kg b kh nh kl ni kp nj kt nk kx nl lb nd ne nf ng bi translated">要删除潜在的额外跳，创建属性为<code class="fe le lf lg lh b">externalTrafficPolicy</code>的服务，并将其设置为<code class="fe le lf lg lh b">Local</code>。</li><li id="466a" class="my mz iq kg b kh nh kl ni kp nj kt nk kx nl lb nd ne nf ng bi translated">你可以用一个漂亮的集群自动化工具<a class="ae lc" href="https://metacontroller.app/" rel="noopener ugc nofollow" target="_blank">元控制器</a>来自动化这个过程。</li></ul></div></div>    
</body>
</html>