<html>
<head>
<title>React Async components: Classes vs Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React异步组件:类与挂钩</h1>
<blockquote>原文：<a href="https://itnext.io/react-async-components-classes-vs-hooks-1a9068b61b3f?source=collection_archive---------2-----------------------#2019-06-19">https://itnext.io/react-async-components-classes-vs-hooks-1a9068b61b3f?source=collection_archive---------2-----------------------#2019-06-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/40b75d90584ecef7cbcc85a33ec3c891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YUWh9jR8_K2Wf4yMbznUCg.jpeg"/></div></div></figure><p id="b339" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就像你现在一样，从React 16.8开始，钩子是可用的。这个新特性允许我们编写没有类的组件，所以<em class="kz">组件</em>倾向于被弃用。</p><h1 id="9d0d" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">为什么是钩子？</h1><p id="de81" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">三个最重要的原因是:</p><ul class=""><li id="be01" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">移除类。在JavaScript中，组合比继承好得多。更简洁的代码、性能和复杂性。</li><li id="3e71" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">避免通过<code class="fe mr ms mt mu b">super</code>类的未使用的生命周期方法。</li><li id="2437" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">复杂的类组件很难阅读和测试。那应该用钩子解决</li></ul><p id="0758" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以，我们要用真实的例子来讲主要的区别。</p><p id="1c26" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我正在使用我为此创建的<a class="ae mv" href="https://github.com/boxgames1/react-hooks-async" rel="noopener ugc nofollow" target="_blank"> Github库</a>。里面有4个例子可以比较:</p><ul class=""><li id="169c" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">类别组件</li><li id="7ecd" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">使用状态挂钩组件</li><li id="098c" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">useReducer挂钩组件</li><li id="c314" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">userContext挂钩组件</li></ul><p id="dd30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它们都实现了相同的功能。必须从这个API 中获取一个列表，并呈现一个表格组件(传递一个数据数组，通过props加载和出错),这将关系到其余部分。</p><h1 id="c3f1" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">类别组件</h1><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mw"><img src="../Images/11063e142835e2ed52da2408ba88950d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tbAgUuE-5PFFundwuo_tng.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">类别组件</figcaption></figure><p id="7ea2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">具有一个<em class="kz">状态</em>的典型类组件，一个管理异步调用的<em class="kz">组件和一个<em class="kz">呈现</em>。很难找到一个更简单的组件，我们已经在<em class="kz">组件中增加了一些复杂性。</em></em></p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="1cc8" class="la lb it bd lc ld nm lf lg lh nn lj lk ll no ln lo lp np lr ls lt nq lv lw lx bi translated">使用状态挂钩组件</h1><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/472395badf11ebef484119c945516300.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M3kHRm7spOh34l_xOsRIeg.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">使用状态挂钩组件</figcaption></figure><p id="e80a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，我们开始有一个孤立的状态管理。我们也可以将它们合并成一个单独的对象。<em class="kz">使用效果</em>替代<em class="kz">组件安装</em>。设置为空数组，他的第二个参数禁止使用相同的道具重新渲染。</p><p id="320a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz"> fetchTeams </em>函数的复杂度与<em class="kz"> componentDidMount </em>相似，所以我们没有赢得太多。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="4554" class="la lb it bd lc ld nm lf lg lh nn lj lk ll no ln lo lp np lr ls lt nq lv lw lx bi translated">useReducer挂钩组件</h1><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/537a4ae1e9319f71e762c8d4435ccbf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fYTd_xdNwn4uDXOdAZiAGg.png"/></div></div></figure><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/3e7480e10e565d596c76e3c3996086e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ATwEkeQHx50SP3A_QUB2WA.png"/></div></div></figure><p id="f5c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里，减速器是通过3个动作创建的。每个动作都是不可变的，只需一句话就可以设置新的状态。</p><p id="5c5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz"> useReducer </em>接收一个Reducer和一个初始值，然后返回<em class="kz">状态</em>和<em class="kz">调度</em>功能。</p><p id="d5fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz"> fetchTeams </em>功能也比之前的更加清晰</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="d033" class="la lb it bd lc ld nm lf lg lh nn lj lk ll no ln lo lp np lr ls lt nq lv lw lx bi translated">使用上下文挂钩组件</h1><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/de650f156c2816fd77baa67ec7739c5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XrfPIvBQfJT9LdpbHgGbgA.png"/></div></div></figure><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/f63816660b302a9fd476151601e405e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*syxmXYNDVn_oWnFtvibvBg.png"/></div></div></figure><p id="5d21" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，创建一个工作环境。这里创建了<strong class="kd iu">上下文状态。</strong></p><p id="01c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">提供者有一个子属性，并且应该呈现所创建的上下文的自己的提供者，将<em class="kz">状态</em>和<em class="kz">设置状态</em>作为值属性传递。</p><p id="d56b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">teamsookscontext</em>本身只有包装消费者的提供者。第二个是使用<strong class="kd iu"> useContext钩子</strong>从上下文中获取<em class="kz">状态</em>和<em class="kz">设置状态</em>，并通过useEffect钩子管理异步调用。</p><p id="6402" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后但同样重要的是，<em class="kz"> fetchTeams </em>函数看起来也是清晰且不可变的。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="1878" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">性能</strong></p><p id="3d20" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我已经使用<a class="ae mv" href="https://www.npmjs.com/package/react-performance" rel="noopener ugc nofollow" target="_blank"> react-performance </a>来检查每个组件的加载时间，所以让我们看看…</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/9b13bad3998740fcaa5e052ea07907f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*YvN5Ulu4rLzYxK-4IMhcdg.png"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">表演</figcaption></figure><p id="f9b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我不会一丝不苟地对待这件事，也不会明确地喜欢某样东西，因为这是一个非常小的时代，中间有一个网络因素。但是，我每次都点击了几次，这是一个准确的平均值。</p><p id="55ac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这项研究是在一个非常小的组件中进行的，想象一下在一个更复杂的完整程序中的差异。</p><h1 id="4c43" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="0dac" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">毫无疑问，钩子是正确的选择。这不会是一个容易的转变，但是React允许我们循序渐进地完成它。我推荐<a class="ae mv" href="https://reactjs.org/docs/hooks-faq.html" rel="noopener ugc nofollow" target="_blank"> Hooks FAQ部分</a>尤其是采用<strong class="kd iu">策略部分</strong>。</p><p id="b726" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Reducer和context选项更清晰IMO也更快。</p><p id="937e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">关于使用哪种类型的钩子。通常这取决于具体情况。没有归纳，我会做这个作业:</p><ul class=""><li id="ed03" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">只有一个状态项的组件。进入<strong class="kd iu">使用状态</strong></li><li id="aaed" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">具有复杂状态但没有太多业务逻辑的组件。T21应该没问题</li><li id="aa1c" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">具有复杂状态和一些业务逻辑的组件。发展一个项目中的所有状态(如第四个例子中所示)并使用上下文。</li></ul><p id="1799" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你有一个非常复杂的情况，你也可以使用一些上下文，一些状态或一些减少。你也有更多可能对你有用的钩子。</p><p id="199e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">完整的程序和一个演示页面在Github库中。</p><p id="4722" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读。</p></div></div>    
</body>
</html>