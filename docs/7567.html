<html>
<head>
<title>Running resilient workloads in EKS using Spot instances</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Spot实例在EKS运行弹性工作负载</h1>
<blockquote>原文：<a href="https://itnext.io/running-production-workloads-in-eks-using-spot-instances-fc6808a7b462?source=collection_archive---------1-----------------------#2022-11-08">https://itnext.io/running-production-workloads-in-eks-using-spot-instances-fc6808a7b462?source=collection_archive---------1-----------------------#2022-11-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/76b630eed5e2c24c0204ca67f78af913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U9GlcVWJ2kZQoMEhWJxEWQ.png"/></div></div></figure><h1 id="0d42" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">定点实例概述</h1><p id="49f4" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">一个<strong class="lb iu"> Spot实例</strong>是一个使用备用EC2容量的实例，可用价格低于按需价格(便宜90%)，这使它成为一个非常经济的选择，但也有一些缺点。在所谓的<em class="lx"> Spot实例中断中，Spot实例可被AWS EC2 Spot服务<strong class="lb iu">中断</strong>。</em>以下是Amazon EC2中断您的Spot实例的可能原因:</p><ul class=""><li id="41e0" class="ly lz it lb b lc ma lg mb lk mc lo md ls me lw mf mg mh mi bi translated"><strong class="lb iu">价格:</strong>现货价格大于你的最高限价。</li><li id="0e94" class="ly lz it lb b lc mj lg mk lk ml lo mm ls mn lw mf mg mh mi bi translated"><strong class="lb iu">容量:</strong> Amazon EC2可以在需要时中断您的Spot实例。EC2回收实例主要是为了重新利用容量，但也可能是因为其他原因，如主机维护或硬件退役。</li><li id="c62a" class="ly lz it lb b lc mj lg mk lk ml lo mm ls mn lw mf mg mh mi bi translated"><strong class="lb iu">约束:</strong>如果您的Spot请求包含一个约束，如启动组或可用性区域组，当约束不再满足时，Spot实例将作为一个组终止。</li></ul><blockquote class="mo mp mq"><p id="ce68" class="kz la lx lb b lc ma le lf lg mb li lj mr ms lm ln mt mu lq lr mv mw lu lv lw im bi translated">您可以在<a class="ae mx" href="http://aws.amazon.com/ec2/spot/instance-advisor/" rel="noopener ugc nofollow" target="_blank"> Spot Instance Advisor </a>中查看您的实例类型的历史中断率。</p></blockquote><p id="7d9d" class="pw-post-body-paragraph kz la it lb b lc ma le lf lg mb li lj lk ms lm ln lo mu lq lr ls mw lu lv lw im bi translated">如果Spot实例被停止、休眠或终止，可以使用CloudTrail查看Amazon EC2是否中断了Spot实例。在AWS CloudTrail中，事件名称<code class="fe my mz na nb b">BidEvictedEvent</code>表示Amazon EC2中断了Spot实例。要在CloudTrail中查看BidEvictedEvent事件:</p><ol class=""><li id="7103" class="ly lz it lb b lc ma lg mb lk mc lo md ls me lw nc mg mh mi bi translated">打开CloudTrail控制台</li><li id="54db" class="ly lz it lb b lc mj lg mk lk ml lo mm ls mn lw nc mg mh mi bi translated">在导航窗格中，选择<strong class="lb iu">事件历史</strong>。</li><li id="ac60" class="ly lz it lb b lc mj lg mk lk ml lo mm ls mn lw nc mg mh mi bi translated">在过滤器下拉列表中，选择<strong class="lb iu">事件名称</strong>，然后在右边的过滤器字段中，输入<strong class="lb iu">bidevictevent</strong>。</li><li id="961f" class="ly lz it lb b lc mj lg mk lk ml lo mm ls mn lw nc mg mh mi bi translated">在结果列表中选择<strong class="lb iu"> BidEvictedEvent </strong>查看其详细信息。在<strong class="lb iu">事件记录</strong>下，可以找到实例ID。</li></ol><p id="0e6e" class="pw-post-body-paragraph kz la it lb b lc ma le lf lg mb li lj lk ms lm ln lo mu lq lr ls mw lu lv lw im bi translated">Spot实例通常适用于无状态、容错的应用程序，这些应用程序能够检查点并在中断后继续运行，也适用于批处理作业。</p><h1 id="b962" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">使用定点实例时的注意事项</h1><p id="0208" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在giffgaff，我们使用100%的Spot实例在EKS集群中运行所有应用程序。我们利用Spot和<a class="ae mx" href="https://docs.spot.io/ocean/overview-kubernetes" rel="noopener ugc nofollow" target="_blank">海洋集群</a>特征。</p><p id="3f29" class="pw-post-body-paragraph kz la it lb b lc ma le lf lg mb li lj lk ms lm ln lo mu lq lr ls mw lu lv lw im bi translated">Spot持续监控跨操作系统、实例类型、可用性区域和地区的不同容量池，以便在中断发生之前，实时决定选择哪些实例进行配置，以及哪些实例需要主动重新平衡和替换。</p><p id="ddb4" class="pw-post-body-paragraph kz la it lb b lc ma le lf lg mb li lj lk ms lm ln lo mu lq lr ls mw lu lv lw im bi translated">一天之内，我们会被打断40到60次。虽然Spot做得很好，但有时实例在重新平衡完全发生之前就被删除了，这可能会导致某些应用程序停机。</p><p id="5095" class="pw-post-body-paragraph kz la it lb b lc ma le lf lg mb li lj lk ms lm ln lo mu lq lr ls mw lu lv lw im bi translated">为了最大限度地减少中断的可能性并避免任何停机时间，这些是我们在过去几年中采取的一些措施，使我们能够在不影响可用性的情况下利用现场实例。</p><h2 id="121c" class="nd kc it bd kd ne nf dn kh ng nh dp kl lk ni nj kp lo nk nl kt ls nm nn kx no bi translated">副本的最小数量</h2><p id="9d98" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如上所述，spot实例可被AWS EC2 Spot服务中断。我们经常看到两个实例同时被删除，有时甚至是4个。</p><p id="7f51" class="pw-post-body-paragraph kz la it lb b lc ma le lf lg mb li lj lk ms lm ln lo mu lq lr ls mw lu lv lw im bi translated">有可能某个特定应用程序的所有pod都在被取走的一个实例中运行。有几种方法可以避免这种情况，比如配置<a class="ae mx" href="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity" rel="noopener ugc nofollow" target="_blank">反亲和</a>规则，或者更好的是<a class="ae mx" href="https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/" rel="noopener ugc nofollow" target="_blank"> pod拓扑分布约束</a>。我们稍后会讨论这些。</p><p id="9596" class="pw-post-body-paragraph kz la it lb b lc ma le lf lg mb li lj lk ms lm ln lo mu lq lr ls mw lu lv lw im bi translated">在我们的关键应用程序中，默认情况下我们将pod的最小数量设置为4，并且我们强制在不同的实例中调度这些pod。这样，我们可以承受同时丢失多达3个实例，为一个特定的应用程序运行3个pods，而不会导致任何停机。</p><h2 id="f63f" class="nd kc it bd kd ne nf dn kh ng nh dp kl lk ni nj kp lo nk nl kt ls nm nn kx no bi translated"><strong class="ak">实例类型和可用区域</strong></h2><p id="5086" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在不同的可用性区域中跨许多不同的实例类型部署您的应用程序将进一步增强可用性。当多个实例同时关闭时，它们通常属于同一系列和实例类型，在特定的可用性区域中，因为对该特定实例类型的需求很高。</p><p id="c557" class="pw-post-body-paragraph kz la it lb b lc ma le lf lg mb li lj lk ms lm ln lo mu lq lr ls mw lu lv lw im bi translated">我们配置我们的集群来运行各种各样的实例类型。同时，我们将特定应用的pod分布在多个可用性区域，最大限度地降低了服务中断的风险。</p><h2 id="7470" class="nd kc it bd kd ne nf dn kh ng nh dp kl lk ni nj kp lo nk nl kt ls nm nn kx no bi translated">Pod中断预算</h2><p id="a72f" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">一个<a class="ae mx" href="https://kubernetes.io/docs/concepts/workloads/pods/disruptions/#pod-disruption-budgets" rel="noopener ugc nofollow" target="_blank"> Pod中断预算</a> (PDB)允许您在其Pod遭受自愿中断时限制对应用程序的中断:</p><ul class=""><li id="a6ab" class="ly lz it lb b lc ma lg mb lk mc lo md ls me lw mf mg mh mi bi translated">删除管理pod的部署或其他控制器</li><li id="c055" class="ly lz it lb b lc mj lg mk lk ml lo mm ls mn lw mf mg mh mi bi translated">更新部署的pod模板导致重新启动</li><li id="c50c" class="ly lz it lb b lc mj lg mk lk ml lo mm ls mn lw mf mg mh mi bi translated">直接删除pod</li><li id="70bf" class="ly lz it lb b lc mj lg mk lk ml lo mm ls mn lw mf mg mh mi bi translated">排出节点以进行修复或升级。</li><li id="35b4" class="ly lz it lb b lc mj lg mk lk ml lo mm ls mn lw mf mg mh mi bi translated">从集群中排出节点以缩小集群</li><li id="42ec" class="ly lz it lb b lc mj lg mk lk ml lo mm ls mn lw mf mg mh mi bi translated">从一个节点上移除一个pod以允许在该节点上安装其他东西。</li></ul><p id="626e" class="pw-post-body-paragraph kz la it lb b lc ma le lf lg mb li lj lk ms lm ln lo mu lq lr ls mw lu lv lw im bi translated">PDB限制了因自愿中断而同时停机的复制应用程序单元的数量。这在集群升级过程中特别有用，因为节点将按照特定的顺序被清空和升级，因此pdb将被考虑。</p><pre class="np nq nr ns gt nt nb nu nv aw nw bi"><span id="bbd6" class="nd kc it nb b gy nx ny l nz oa"><strong class="nb iu">apiVersion</strong>: policy/v1<br/><strong class="nb iu">kind</strong>: PodDisruptionBudget<br/><strong class="nb iu">metadata</strong>:<br/>  <strong class="nb iu">name</strong>: test-svc<br/><strong class="nb iu">spec</strong>:<br/>  <strong class="nb iu">maxUnavailable</strong>: 1<br/>  <strong class="nb iu">selector</strong>:<br/>    <strong class="nb iu">matchLabels</strong>:<br/>      <strong class="nb iu">app</strong>: test-svc</span></pre><h2 id="7fbd" class="nd kc it bd kd ne nf dn kh ng nh dp kl lk ni nj kp lo nk nl kt ls nm nn kx no bi translated">Pod反亲和性</h2><p id="6a09" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">正如<a class="ae mx" href="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity" rel="noopener ugc nofollow" target="_blank">官方文档</a>中所述，pod反亲缘关系允许您根据已经在节点 上运行的pod上的标签，而不是根据节点上的标签，来约束哪些节点您的pod有资格被调度<strong class="lb iu"> <em class="lx">。规则的形式是<em class="lx">“如果X已经在运行一个或多个符合规则Y的pod，则该pod不应在X中运行”。</em> Y表示为LabelSelector。</em></strong></p><p id="f2c3" class="pw-post-body-paragraph kz la it lb b lc ma le lf lg mb li lj lk ms lm ln lo mu lq lr ls mw lu lv lw im bi translated">从概念上讲，X是一个拓扑域，如节点、云提供商区域、云提供商区域等。你用一个<code class="fe my mz na nb b">topologyKey</code>来表达。</p><p id="59ab" class="pw-post-body-paragraph kz la it lb b lc ma le lf lg mb li lj lk ms lm ln lo mu lq lr ls mw lu lv lw im bi translated">在下面的示例中，不能在已经运行标签为<code class="fe my mz na nb b">app: app-name</code>的pod的节点中安排pod。</p><pre class="np nq nr ns gt nt nb nu nv aw nw bi"><span id="4c25" class="nd kc it nb b gy nx ny l nz oa">spec:<br/>  affinity:<br/>    podAntiAffinity:<br/>      requiredDuringSchedulingIgnoredDuringExecution:<br/>      - labelSelector:<br/>          matchExpressions:<br/>          - key: app<br/>            operator: In<br/>            values:<br/>            - app-name<br/>        topologyKey: kubernetes.io/hostname</span></pre><p id="efc6" class="pw-post-body-paragraph kz la it lb b lc ma le lf lg mb li lj lk ms lm ln lo mu lq lr ls mw lu lv lw im bi translated">直到最近，我们一直使用pod反亲缘关系在spot实例之间传播pod，从而降低停机风险。然而，当您的应用程序有大量副本，或者根据cron计划伸缩时，pod反相似性就不太好用了(请看我关于<a class="ae mx" rel="noopener ugc nofollow" target="_blank" href="/event-driven-autoscaling-503b5cefaa49">事件驱动自动伸缩</a>的文章)。例如，一个扩展到30个pod的应用程序需要30个不同的节点来调度所有30个pod。这既没有效率，也没有性能，因为应用程序必须等待新节点添加到集群中，而这些节点很可能有一半是空的。</p><p id="87c0" class="pw-post-body-paragraph kz la it lb b lc ma le lf lg mb li lj lk ms lm ln lo mu lq lr ls mw lu lv lw im bi translated">Pod拓扑分布约束修复了此问题。</p><h2 id="18fd" class="nd kc it bd kd ne nf dn kh ng nh dp kl lk ni nj kp lo nk nl kt ls nm nn kx no bi translated">Pod拓扑分布约束</h2><p id="467d" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在Kubernetes v1.19中提升为稳定，<a class="ae mx" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/" rel="noopener ugc nofollow" target="_blank"> Pod拓扑分布约束</a>帮助您控制Pod如何在您的集群中的域(如区域、分区、节点和其他用户定义的拓扑域)之间分布。这有助于实现高可用性以及高效的资源利用。</p><p id="08b7" class="pw-post-body-paragraph kz la it lb b lc ma le lf lg mb li lj lk ms lm ln lo mu lq lr ls mw lu lv lw im bi translated">通过以下配置，我们能够跨不同的可用性区域和不同的节点均匀地调度pod:</p><pre class="np nq nr ns gt nt nb nu nv aw nw bi"><span id="b863" class="nd kc it nb b gy nx ny l nz oa">topologySpreadConstraints:<br/>  - labelSelector:<br/>      matchLabels:<br/>        app: test-svc<br/>    maxSkew: 1<br/>    topologyKey: topology.kubernetes.io/zone<br/>    whenUnsatisfiable: DoNotSchedule<br/>  - labelSelector:<br/>      matchLabels:<br/>        app: test-svc<br/>    maxSkew: 2<br/>    topologyKey: kubernetes.io/hostname<br/>    whenUnsatisfiable: ScheduleAnyway</span></pre><p id="cb46" class="pw-post-body-paragraph kz la it lb b lc ma le lf lg mb li lj lk ms lm ln lo mu lq lr ls mw lu lv lw im bi translated">与pod反关联性不同，通过Pod拓扑分布约束，我们可以让多个Pod用于在同一个节点上运行的同一个应用程序。但是，由于我们使用3个可用性区域，第一个拓扑约束将确保至少有3个pod在3个不同的实例中运行。第二个拓扑约束将尝试在不同的实例(<code class="fe my mz na nb b">topologyKey: kubernetes.io/hostname</code>)中调度第4个pod，但这是没有保证的(<code class="fe my mz na nb b">ScheduleAnyway</code>告诉调度器仍然调度它，同时优先考虑使偏斜最小化的节点)。</p><p id="e4c6" class="pw-post-body-paragraph kz la it lb b lc ma le lf lg mb li lj lk ms lm ln lo mu lq lr ls mw lu lv lw im bi translated"><strong class="lb iu"> maxSkew </strong>描述了豆荚分布不均匀的程度。您必须指定此字段，并且数字必须大于零。它的语义根据<code class="fe my mz na nb b">whenUnsatisfiable</code>的值而不同:</p><ul class=""><li id="a7a2" class="ly lz it lb b lc ma lg mb lk mc lo md ls me lw mf mg mh mi bi translated"><code class="fe my mz na nb b">whenUnsatisfiable: DoNotSchedule</code>:然后<code class="fe my mz na nb b">maxSkew</code>定义目标拓扑中匹配pod数量与<em class="lx">全局最小值</em>之间的最大允许差值。例如，如果您有3个区域，分别有2个、2个和1个匹配窗格，<code class="fe my mz na nb b">MaxSkew</code>设置为1，则全局最小值为1。</li><li id="b672" class="ly lz it lb b lc mj lg mk lk ml lo mm ls mn lw mf mg mh mi bi translated">如果您选择<code class="fe my mz na nb b">whenUnsatisfiable: ScheduleAnyway</code>，调度程序会优先考虑有助于减少偏差的拓扑。</li></ul><h2 id="b4f3" class="nd kc it bd kd ne nf dn kh ng nh dp kl lk ni nj kp lo nk nl kt ls nm nn kx no bi translated"><strong class="ak">其他有助于可靠性的设置</strong></h2><p id="ffdc" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在Kubernetes中还有其他一些设置有助于运行高可用性的应用程序，无论您是否在Spot实例中这样做</p><p id="616d" class="pw-post-body-paragraph kz la it lb b lc ma le lf lg mb li lj lk ms lm ln lo mu lq lr ls mw lu lv lw im bi translated"><strong class="lb iu">Horizontal Pod auto scaling(HPA):</strong>自动更新工作负载资源(如<a class="ae mx" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">部署</a>或<a class="ae mx" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" rel="noopener ugc nofollow" target="_blank"> StatefulSet </a>，目的是自动扩展工作负载以匹配需求(即CPU、内存或任何其他指标，如果您使用指标适配器，如<a class="ae mx" rel="noopener ugc nofollow" target="_blank" href="/event-driven-autoscaling-503b5cefaa49"> KEDA </a>)。</p><p id="7996" class="pw-post-body-paragraph kz la it lb b lc ma le lf lg mb li lj lk ms lm ln lo mu lq lr ls mw lu lv lw im bi translated"><strong class="lb iu">终止宽限期:</strong>SIGTERM信号发送到pod后，Kubernetes会等待一段指定的时间，称为终止宽限期。默认情况下，这是30秒。</p><p id="296c" class="pw-post-body-paragraph kz la it lb b lc ma le lf lg mb li lj lk ms lm ln lo mu lq lr ls mw lu lv lw im bi translated">如果你的应用在terminationGracePeriod结束前关闭并退出，Kubernetes会立即进入下一步。如果您的pod关闭时间通常超过30秒，请确保延长宽限期。</p><p id="cb66" class="pw-post-body-paragraph kz la it lb b lc ma le lf lg mb li lj lk ms lm ln lo mu lq lr ls mw lu lv lw im bi translated"><strong class="lb iu">滚动更新策略:</strong>为滚动更新策略中的<code class="fe my mz na nb b">maxSurge</code>、<code class="fe my mz na nb b">maxUnavailable</code>参数设置正确的值，以避免在部署期间出现应用程序的多个副本。</p><h1 id="12bd" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结论</h1><p id="f866" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如果应用程序按照本文中提到的一些(或全部)参数进行配置，那么使用Spot实例运行弹性生产工作负载并不像听起来那么可怕。我们从一开始就这样做，利用成本节约，同时实现高水平的可靠性，为我们的成员提供最佳体验。</p></div></div>    
</body>
</html>