<html>
<head>
<title>A story about abstractions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个关于抽象的故事</h1>
<blockquote>原文：<a href="https://itnext.io/a-story-about-abstraction-f99e53516ca4?source=collection_archive---------6-----------------------#2020-07-10">https://itnext.io/a-story-about-abstraction-f99e53516ca4?source=collection_archive---------6-----------------------#2020-07-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="f345" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">抽象</h1><p id="23f1" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">抽象的能力应该是一个开发人员应该拥有的最基本的技能，这一点我怎么强调都不为过。通过抽象，我们可以从铺天盖地的看似不相关的细节中解脱出来，找到一个可以一次性解决所有问题的解决方案。</p><p id="89c6" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">然而，由于每个抽象都忽略了一些细节，强调了一些其他特征，有时它会阻止我们理解问题(我猜我们的大脑更喜欢有形的东西)。这就是例子跳出来寻求帮助的时候。换句话说，在一个创造性的过程中，无论是编码还是设计，我们一方面需要从具体的例子中提取概念，另一方面，我们需要将我们提取的概念例证回实例。Bret Victor 做了一个<a class="ae lo" href="http://worrydream.com/LadderOfAbstraction/" rel="noopener ugc nofollow" target="_blank">伟大的比喻</a>把这个过程比作上下梯子——你需要上到一个更高的层次，以便有一个大概的了解，然后回到地面进行测试。只有将这两者结合起来，你才能更好地理解问题，并提出更好的解决方案。</p><p id="1633" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">关于抽象的另一个有趣的事实是它有层次。一旦我们摆脱了地面上所有杂乱的细节，有了更高层次的概念，这些抽象就变成了新的细节，我们可以在它们的基础上再次构建抽象概念。这就是为什么我们可以使用<code class="fe lp lq lr ls b">JavaScript</code>或<code class="fe lp lq lr ls b">Python</code>来解决业务问题，而不需要知道寄存器地址或机器指令的长度，或者内存是如何分配或释放的。</p><p id="599f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我知道这听起来已经很抽象了，但是请耐心听我说，看看一个具体的例子。</p><h1 id="caf1" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">一些背景</h1><p id="7a4a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在本文中，我将通过重构一个模拟项目的测试套件(使用cypress)来描述一些模式和重构技术。我将谈论一些常规的重构技巧，但没什么大不了的，我相信看到如何分析和重写一些从<code class="fe lp lq lr ls b">working code</code>到<code class="fe lp lq lr ls b">concise</code>和<code class="fe lp lq lr ls b">easy to understand/modify</code>的测试用例是值得的，并且希望也是有趣的。我希望你能喜欢它。</p><p id="ecbf" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">它模拟了我去年参与的一个项目。从业务的角度来看，所有业务规则和逻辑的难度一般，但是从技术上来说，有很多细节值得回顾。项目中的UI测试套件，在几轮重构之后，最终达到了我非常满意的程度，它已经应用了我们将在本文中讨论的模式。</p><p id="def0" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">然而，这里的模拟是一个名为<code class="fe lp lq lr ls b">Questionnaire</code>的服务，它在后端使用一些计算引擎，通过询问一些问题，如角色、技能水平、技术堆栈、项目偏好等，向用户返回一些最合适的提议。我将把<code class="fe lp lq lr ls b">recommendation system</code>留在后台，只关注本文中的数据收集。</p><p id="a9a7" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">请注意，有些问题是动态的。例如，如果用户对问题<code class="fe lp lq lr ls b">Q1</code>回答了<code class="fe lp lq lr ls b">A</code>，那么接下来的问题可能是<code class="fe lp lq lr ls b">Q303</code>。如果他们回答的是<code class="fe lp lq lr ls b">B</code>，那么下一个将会是<code class="fe lp lq lr ls b">Q1024</code>。这意味着在UI中有许多可选择的路径，并且每条路径都同样重要(并且每个测试都应该彻底地遍历这条路径，直到计算出结果)。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/daba5518f976fca37d30f857ce7cce35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9TAbc8vfFd118zf4KKFysg.png"/></div></div></figure><p id="7b89" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">正如你从上面的UI中看到的，<code class="fe lp lq lr ls b">Questionnaire</code>有3个步骤，而在现实世界中，它可能有10多个步骤，每个步骤都有一个或多个问题。有些问题可能取决于前面步骤中的答案。收集完所有必填字段后，用户可以点击<code class="fe lp lq lr ls b">next</code>按钮继续。</p><h1 id="e8f2" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">摘要101 —功能</h1><p id="e98c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">从功能测试的角度来看，将每一步视为独立的单元是合理的。每一步都有一些类似的事情要做:</p><ol class=""><li id="c140" class="mf mg iq kn b ko lj ks lk kw mh la mi le mj li mk ml mm mn bi translated">验证步骤<strong class="kn ir">标题</strong></li><li id="69e0" class="mf mg iq kn b ko mo ks mp kw mq la mr le ms li mk ml mm mn bi translated">填写所有<strong class="kn ir">必填字段</strong></li><li id="dc79" class="mf mg iq kn b ko mo ks mp kw mq la mr le ms li mk ml mm mn bi translated">点击<strong class="kn ir">下一个</strong>按钮</li></ol><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mt"><img src="../Images/a7f00c8ba9a3e4ca54901b78a44ba706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R2ZHfgT01_KAPx2J9cSydg.png"/></div></div></figure><p id="b582" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我们可以通过使用<code class="fe lp lq lr ls b">cypress</code>API来测试第一个<code class="fe lp lq lr ls b">Step</code>(让我们假设所有的<code class="fe lp lq lr ls b">data-</code>属性都已经在产品代码中了):</p><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="195b" class="my jo iq ls b gy mz na l nb nc">it('Verify the basic information section', () =&gt; {<br/>  cy.get('[data-test="step-title"]')<br/>    .contains('Basic information');<br/>  <br/>  cy.get('[data-test="email-address"] input')<br/>    .type('juntao.qiu@gmail.com');<br/>  cy.get('[data-test="assignment"] input[value="assigned"]')<br/>    .check();<br/>  <br/>  cy.get('button[data-test="next-button"]').click();<br/>});</span></pre><p id="6db4" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">所以第二个非常相似:使用<code class="fe lp lq lr ls b">selector</code>在页面上定位元素，如果找到元素，我们可以通过<code class="fe lp lq lr ls b">cypress</code> API模拟一些用户动作:</p><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="52eb" class="my jo iq ls b gy mz na l nb nc">it('Verify the details section', () =&gt; {<br/>  cy.get('[data-test="step-title"]').contains('More details');<br/>​<br/>  cy.get('[data-test="ps-role"]').click();<br/>  cy.get('[data-value="dev"]').click();<br/>​<br/>  cy.get('[data-test="developer"] input[value="frontend"]').check();<br/>  cy.get('[data-test="rating"] [for="rating-4"]').click();<br/>  <br/>  cy.get('button[data-test="next-button"]').click();<br/>});</span></pre><p id="65df" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果你从字面上比较代码<em class="nd">和</em>，几乎每一行都是独一无二的，但是你可以<em class="nd">感觉到</em>有某种重复。删除这些重复可以大大提高可读性。最简单的方法是<code class="fe lp lq lr ls b">extract function</code>，例如，提取<em class="nd">验证步骤标题</em>和<em class="nd">点击下一步按钮</em>到各自的功能:</p><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="edca" class="my jo iq ls b gy mz na l nb nc">const checkStepTitle = (title) =&gt; {<br/>  cy.get("[data-test="step-title"]").contains(title);<br/>}<br/>​<br/>const goToNextStep = () =&gt; {<br/>  cy.get("button[data-test="next-button"]").click();<br/>}</span></pre><p id="b1c2" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">然后，测试被简化成这样:</p><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="fcd6" class="my jo iq ls b gy mz na l nb nc">it('Verify the basic information section', () =&gt; {<br/>  checkStepTitle("Basic information");<br/>  <br/>  cy.get('[data-test="email-address"] input')<br/>    .type('juntao.qiu@gmail.com');<br/>  cy.get('[data-test="assignment"] input[value="assigned"]')<br/>    .check();<br/>  <br/>  goToNextStep();  <br/>});<br/>​<br/>it("Verify the details section", () =&gt; {<br/>  checkStepTitle("More details");<br/>  <br/>  cy.get('[data-test="ps-role"]').click();<br/>  cy.get('[data-value="dev"]').click();<br/>​<br/>  cy.get('[data-test="developer"] input[value="frontend"]').check();<br/>  cy.get('[data-test="rating"] [for="rating-4"]').click();<br/>  <br/>  goToNextStep();<br/>});</span></pre><p id="2465" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">你会<em class="nd">觉得</em>有一些其他重复的代码，如果你模糊细节，你可以看到相似之处:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ne"><img src="../Images/a5a61f699c10f96a1e335d92337aa966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XwqIQTYZYrB4bDkETU4P9w.png"/></div></div></figure><p id="010e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">当我们将所有的<code class="fe lp lq lr ls b">cypress</code>动作提取到一个函数中时:</p><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="61ea" class="my jo iq ls b gy mz na l nb nc">const fillOutBasic = () =&gt; {<br/>  cy.get('[data-test="email-address"] input')<br/>    .type('juntao.qiu@gmail.com');<br/>  cy.get('[data-test="assignment"] input[value="assigned"]')<br/>    .check();<br/>}</span></pre><p id="dd51" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">然后定义一个<em class="nd">模板函数</em>来执行以下动作:</p><ol class=""><li id="550f" class="mf mg iq kn b ko lj ks lk kw mh la mi le mj li mk ml mm mn bi translated">验证步骤标题</li><li id="95fe" class="mf mg iq kn b ko mo ks mp kw mq la mr le ms li mk ml mm mn bi translated">填写必填字段</li><li id="2b54" class="mf mg iq kn b ko mo ks mp kw mq la mr le ms li mk ml mm mn bi translated">单击下一步按钮</li></ol><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="0c13" class="my jo iq ls b gy mz na l nb nc">const verifyStep = (title, verifier) =&gt; {<br/>  checkStepTitle(title);<br/>  verifier();<br/>  goToNextStep();<br/>}</span></pre><p id="bd3c" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">通过这样做，我们的测试可以进一步简化为:</p><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="16c6" class="my jo iq ls b gy mz na l nb nc">it("Verify the basic information section", () =&gt; {<br/>  verifyStep("Basic information", fillOutBasic);<br/>});</span></pre><p id="79d9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">和第二个一样:</p><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="9b89" class="my jo iq ls b gy mz na l nb nc">it("Verify the details section", () =&gt; {<br/>  verifyStep("More details", fillOutDetails);<br/>});</span></pre><h1 id="3e2a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">抽象102 —再简化一点</h1><p id="c050" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">正如你在上面看到的，<code class="fe lp lq lr ls b">step 2</code>有几个分支:对于开发人员，有3个必问的问题，而对于QA/BA，只有1个必问的问题。我们需要更多的测试用例来覆盖每个分支:</p><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="1fdf" class="my jo iq ls b gy mz na l nb nc">const fillOutDetailsForDev = () =&gt; {<br/>  cy.get('[data-test="ps-role"]').click();<br/>  cy.get('[data-value="dev"]').click();<br/>​<br/>  cy.get('[data-test="developer"] input[value="frontend"]').check();<br/>  cy.get('[data-test="rating"] [for="rating-4"]').click();<br/>}<br/>​<br/>const fillOutDetailsForQA = () =&gt; {<br/>  cy.get('[data-test="ps-role"]').click();<br/>  cy.get('[data-value="qa"]').click();<br/>}<br/>​<br/>const fillOutDetailsForBA = () =&gt; {<br/>  cy.get('[data-test="ps-role"]').click();<br/>  cy.get('[data-value="ba"]').click();<br/>}</span></pre><p id="ae46" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">因为那些杂乱/详细的代码，加上所有像<code class="fe lp lq lr ls b">cy.get</code>这样的<code class="fe lp lq lr ls b">cypress</code> API，使得理解每行代码背后的目的变得困难和间接。如果我们能够以某种方式消除这些噪音，测试的清晰度可以提高到一个新的水平。</p><p id="2f5d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">例如，如果我们有一组像下面这样的<code class="fe lp lq lr ls b">API</code>来隔离所有的DOM细节:</p><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="5f8f" class="my jo iq ls b gy mz na l nb nc">const select = (selector, value) =&gt; {<br/>  cy.get(`[data-test="${selector}"]`).click();<br/>  cy.get(`[data-value="${value}"]`).click();<br/>}<br/>​<br/>const checkbox = (selector, value) =&gt; {<br/>  cy.get(`[data-test="${selector}"] input[value="${value}"]`).check();<br/>}</span></pre><p id="f568" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">那么函数<code class="fe lp lq lr ls b">fillOutDetailsForDev</code>可以重写为:</p><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="5813" class="my jo iq ls b gy mz na l nb nc">const fillOutDetailsForDev = () =&gt; {<br/>  select("ps-role", "dev");<br/>  checkbox("developer", "frontend");<br/>  rating("rating", "4");<br/>}</span></pre><p id="6cc8" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">而<code class="fe lp lq lr ls b">fillOutDetailsForQA</code>变成了:</p><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="e4dc" class="my jo iq ls b gy mz na l nb nc">const fillOutDetailsForQA = () =&gt; {<br/>  select("ps-role", "qa");<br/>}</span></pre><p id="9ca4" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">尽管它们的代码量非常相似，但我们在这里做的是分离业务/测试逻辑和底层的<code class="fe lp lq lr ls b">cypress</code>DOM API。如果将来我们必须升级或更改产品代码中的UI库，我们就不必碰上面<code class="fe lp lq lr ls b">test</code>逻辑中的任何东西。只有<code class="fe lp lq lr ls b">select/checkbox</code>的实现需要更新。</p><h1 id="6b1e" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">示例101 —内嵌</h1><p id="fa89" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">但是如果我们足够仔细地观察上面提取的像<code class="fe lp lq lr ls b">fillOutDetailsForDev</code>和<code class="fe lp lq lr ls b">fillOutDetailsForQA</code>这样的函数，我们会发现我们失去了一些灵活性。这些<code class="fe lp lq lr ls b">named functions</code>锁定了一些动作，对于不同的场景，我们可能需要越来越多的功能。可能匿名函数更适合这里。例如，如果我们将这些<code class="fe lp lq lr ls b">fillOutDetailsForDev</code>内联到匿名函数中:</p><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="8558" class="my jo iq ls b gy mz na l nb nc">it("Verify the details section for developer", () =&gt; {<br/>  verifyStep("More details", () =&gt; {<br/>    select("ps-role", "dev");<br/>    checkbox("developer", "frontend");<br/>    rating("rating", "4");    <br/>  });<br/>});<br/>​<br/>it("Verify the details section for QA", () =&gt; {<br/>  verifyStep("More details", () =&gt; {<br/>    select("ps-role", "qa");<br/>  });<br/>});</span></pre><p id="6e20" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我认为上面的测试用例比那些与<code class="fe lp lq lr ls b">cypress</code> API紧密相关的测试用例要好得多，现在每一行代码都有了更精确的目的，它们在说<em class="nd">需要做什么</em>，而不是<em class="nd">如何做</em>。</p><p id="d651" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我们可以仔细看看测试用例中的完整的<code class="fe lp lq lr ls b">User Journey</code>(记住为了简单起见，这里只有3个步骤，但是在真实项目中可能更多)。</p><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="a62a" class="my jo iq ls b gy mz na l nb nc">it("Verify the details section for developer", () =&gt; {<br/>  verifyStep("Basic information", () =&gt; {<br/>    input("email-address", "juntao.qiu@gmail.com");<br/>    checkbox("assignment", "assigned");<br/>  });<br/>  <br/>  verifyStep("More details", () =&gt; {<br/>    select("ps-role", "dev");<br/>    checkbox("developer", "frontend");<br/>    rating("rating", "4");    <br/>  });<br/>  <br/>  verifyStep("Project preferences", () =&gt; {<br/>    checkbox("expectancy", "frontend");<br/>  });<br/>});</span></pre><p id="daa0" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果你和我一样对这3行<code class="fe lp lq lr ls b">``identical"</code>重复代码有同感，让我们尝试另一种方法来消除这些重复。</p><h1 id="fcf8" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">摘要201 —代码和数据</h1><p id="2478" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在大多数现代的<code class="fe lp lq lr ls b">functional programming languages</code>中，<code class="fe lp lq lr ls b">data</code>和<code class="fe lp lq lr ls b">code</code>之间的界限是模糊的，通过使用像<code class="fe lp lq lr ls b">eval/apply</code>这样的内置函数，开发者可以很容易地转换这两者。即使你不能在你的代码中实现<code class="fe lp lq lr ls b">code is data</code>，至少你可以将那些易变的部分提取到数据或配置中(比如<code class="fe lp lq lr ls b">selector</code>，问题序列定义，重新安排问题的顺序等等)，并确保稳定的部分作为一个框架被区别对待。</p><p id="fa59" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">例如，在上面讨论的场景<code class="fe lp lq lr ls b">Verify the details section for developer</code>中，我们可以将<em class="nd">改写为:</em></p><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="a841" class="my jo iq ls b gy mz na l nb nc">steps.forEach(step =&gt; {<br/>  verifyStep(step.title, step.verifier)<br/>});</span></pre><p id="9805" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">其中<code class="fe lp lq lr ls b">steps</code>定义为:</p><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="a77d" class="my jo iq ls b gy mz na l nb nc">const steps = [<br/>  {<br/>    title: 'Basic information',<br/>    verifier: () =&gt; { /*input, select, checkbox*/ }<br/>  },<br/>  {<br/>    title: 'Basic information',<br/>    verifier: () =&gt; { /*input, select, checkbox*/ }<br/>  },<br/>];</span></pre><p id="9b14" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这样，我们可以将那些<code class="fe lp lq lr ls b">logic</code>分离成一个静态配置。当然，<code class="fe lp lq lr ls b">verifier</code>还是动态的(定义为函数)。如果我们可以引入一种机制来将类似于<code class="fe lp lq lr ls b">checkbox("expectancy", "frontend")</code>的东西转换成静态配置，我们可以宣称数据和代码是完全分离的，它的好处是如果一个<code class="fe lp lq lr ls b">User Journey</code>需要更新，我们不必接触任何<code class="fe lp lq lr ls b">code</code>。</p><h2 id="0c1b" class="my jo iq bd jp nf ng dn jt nh ni dp jx kw nj nk kb la nl nm kf le nn no kj np bi translated">用户之旅</h2><p id="409f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">假设我们需要测试一个定义为以下步骤的<code class="fe lp lq lr ls b">user journey</code>:</p><ol class=""><li id="ca06" class="mf mg iq kn b ko lj ks lk kw mh la mi le mj li mk ml mm mn bi translated">用户输入电子邮件地址</li><li id="1790" class="mf mg iq kn b ko mo ks mp kw mq la mr le ms li mk ml mm mn bi translated">用户选择<code class="fe lp lq lr ls b">beach</code>作为当前项目</li><li id="5237" class="mf mg iq kn b ko mo ks mp kw mq la mr le ms li mk ml mm mn bi translated">用户将他/她评为中级前端开发人员</li><li id="c12b" class="mf mg iq kn b ko mo ks mp kw mq la mr le ms li mk ml mm mn bi translated">他/她想在即将到来的约会中尝试<code class="fe lp lq lr ls b">SRE</code></li></ol><p id="932b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我们可以将这些输入序列描述为以下格式:</p><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="6f45" class="my jo iq ls b gy mz na l nb nc">const steps = [<br/>  {<br/>    "title": "Basic information",<br/>    "fields": [<br/>      "input:email-address:abruzzi.dev@gmail.com",<br/>      "checkbox:assignment:assigned",<br/>    ]<br/>  },<br/>  {<br/>    "title": "More details",<br/>    "fields": [<br/>      "select:ps-role:dev",<br/>      "checkbox:developer:frontend",<br/>      "rating:rating:4",<br/>    ]<br/>  },<br/>  {<br/>    "title": "Project preferences",<br/>    "fields": [<br/>      "checkbox:expectancy:frontend",<br/>    ]<br/>  }<br/>];</span></pre><p id="31a3" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果我们有一个映射函数将上面的<code class="fe lp lq lr ls b">fields</code>解释为我们之前提取的<code class="fe lp lq lr ls b">operation</code>函数，我们就可以<em class="nd">最终执行</em>那些<code class="fe lp lq lr ls b">config</code>:</p><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="4c09" class="my jo iq ls b gy mz na l nb nc">const executeCypressCommand = (field) =&gt; {<br/>  const [type, selector, value] = field.split(':');<br/>  switch (type) {<br/>    case 'input': return input(selector, value);<br/>    case 'checkbox': return checkbox(selector, value);<br/>    case 'select': return select(selector, value);<br/>    case 'rating': return rating(selector, value);<br/>    default: return null;<br/>  }<br/>}</span></pre><p id="c10a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这意味着字段定义:</p><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="c816" class="my jo iq ls b gy mz na l nb nc">"fields": [<br/>  "input:email-address:abruzzi.dev@gmail.com",<br/>  "checkbox:assignment:assigned",<br/>]</span></pre><p id="d8fb" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">被翻译成:</p><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="1767" class="my jo iq ls b gy mz na l nb nc">input('email-address', 'abruzzi.dev@gmail.com');<br/>checkbox('assignment', 'assigned');</span></pre><p id="cfdf" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">并且在运行时，<code class="fe lp lq lr ls b">input</code>和<code class="fe lp lq lr ls b">checkbox</code>将被解释成底层的<code class="fe lp lq lr ls b">cypress</code>指令:</p><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="8d81" class="my jo iq ls b gy mz na l nb nc">cy.get('[data-test="email-address"] input')<br/>  .type('abruzzi.dev@gmail.com');<br/>cy.get('[data-test="assignment"] input[value="assigned"]').check();</span></pre><p id="b6a0" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这样，当需要新的<code class="fe lp lq lr ls b">User Journey</code>时，唯一需要的改变是添加一个<code class="fe lp lq lr ls b">json</code>文件。<code class="fe lp lq lr ls b">json</code>将被加载和解释，最终能够像这样在<code class="fe lp lq lr ls b">browser</code>中运行:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nq"><img src="../Images/870dec0e01a3035d1e2006e36fe61c91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*DsOyYOHgBJPvgdJk5lXd8w.gif"/></div></div></figure><p id="6102" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在任何旅程中添加/修改/删除步骤都变得毫不费力，确保测试与产品代码的UI同步也变得超级容易。</p><p id="e7fb" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果说<strong class="kn ir">外部</strong>将所有测试用例放入<code class="fe lp lq lr ls b">json</code>文件的想法看起来有些激进，那么只有利用提取的<strong class="kn ir">实用函数</strong>才能提高可读性，减少对底层DOM APIs的依赖。</p><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="252d" class="my jo iq ls b gy mz na l nb nc">verifySection('Basic information', () =&gt; {<br/>  input('email-address', 'abruzzi.dev@gmail.com');<br/>  checkbox('assignment', 'assigned');<br/>});<br/>​<br/>verifySection('More details', () =&gt; {<br/>  select('ps-role', 'qa');<br/>});</span></pre><h1 id="c19f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">摘要202 —用户案例</h1><p id="114e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们已经做了很多，从提取可重用的功能到高度抽象的、特定领域的API，这些API在很大程度上与开发人员和编写测试的人员共享的语言一致。</p><p id="5f8a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果我们检查这些测试用例:</p><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="c2f2" class="my jo iq ls b gy mz na l nb nc">it('explore journey for developers', () =&gt; {<br/>  runJourney(developerJourney)<br/>});<br/>​<br/>it('explore journey for qas', () =&gt; {<br/>  runJourney(qaJourney);<br/>});</span></pre><p id="946b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">你会发现它们在某种程度上是重复的代码，你还记得我们上一次对<code class="fe lp lq lr ls b">steps</code>做的重构吗？一个类似的<code class="fe lp lq lr ls b">forEach</code>可以消除这些重复。</p><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="8d1a" class="my jo iq ls b gy mz na l nb nc">journeys.forEach((journey) =&gt; {<br/>  it(journey.title, () =&gt; {<br/>    runJourney(journey);<br/>  });<br/>});</span></pre><p id="c9a3" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">不管我们有多少只<code class="fe lp lq lr ls b">User Journeys</code>，我们都不用再换<code class="fe lp lq lr ls b">code</code>了。对于加载不同的旅程，使用<code class="fe lp lq lr ls b">ES6</code>中的<code class="fe lp lq lr ls b">import/export</code>非常简单:</p><pre class="lu lv lw lx gt mu ls mv mw aw mx bi"><span id="6bbc" class="my jo iq ls b gy mz na l nb nc">import {journey as qaJourney} from "./qa";<br/>import {journey as baJourney} from "./ba";<br/>import {journey as devJourney} from "./developer";<br/>import {journey as devBeachJourney} from "./developer-on-beach";<br/>​<br/>const journeys = [<br/>  qaJourney,<br/>  baJourney,<br/>  devJourney,<br/>  devBeachJourney,<br/>];<br/>​<br/>export default journeys;</span></pre><p id="96bf" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">因为每个<code class="fe lp lq lr ls b">journey</code>都是普通的静态<code class="fe lp lq lr ls b">JSON</code>，对于任何进一步的业务逻辑变化，我们只需要更新那些静态文件，而不用担心框架代码的回归。</p><h1 id="734e" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">摘要</h1><p id="70d3" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在本文中，我通过重构测试套件介绍了一些<code class="fe lp lq lr ls b">how to abstract</code>方法/模式，最后，我们将所有频繁变化的部分隔离到单独的<strong class="kn ir"> json </strong>中，并使潜在的变化更容易和更集中。</p><p id="b46a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我们已经完成了几种形式的抽象:从将重复代码抽象成函数的基本方式到将逻辑上相关的代码连接成小函数，然后引入高阶函数来进行更高级别的抽象。另外，当出现一些结构相似的语句时，我们可以使用<code class="fe lp lq lr ls b">data+each/map</code>来分离代码和数据。</p><p id="d396" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">正如Bret Victor所说的比喻，整个过程可能不是直线的，在大多数情况下可能会螺旋上升。我们很少能看到代码在最开始会是怎样的，在重构的中间，会有很多的来回。那些来回不仅不可避免，而且不可或缺。在大多数情况下，一个好的重构需要在不同的方向上进行大量的尝试，几个回合才能让代码达到理想的状态。但是你必须非常小心这个<code class="fe lp lq lr ls b">ideal state</code>，因为它通常是不稳定的，一旦下一个突破性的变化到来，我们必须再次将相同的原则应用于<em class="nd">抽象和例证不同层次的</em>以适应这些变化。</p></div></div>    
</body>
</html>