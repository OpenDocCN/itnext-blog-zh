<html>
<head>
<title>Building SwiftUI apps in Markdown</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Markdown中构建SwiftUI应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/building-swiftui-apps-in-markdown-1602fcadfd0b?source=collection_archive---------9-----------------------#2021-05-17">https://itnext.io/building-swiftui-apps-in-markdown-1602fcadfd0b?source=collection_archive---------9-----------------------#2021-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b678" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当你的iOS应用程序使用Markdown文档时，为什么我们不能将它们转换为natives view？如果我们不编写Swift UI代码，而是构建一个自定义查看器应用程序，甚至可以从Xcode Live Preview Canvas运行，会怎么样？</p><p id="7453" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看看你能用它做什么:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/d2f455c06742d0932e1e8e6e02c7a142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*aC12NB2cxLzk1dEKhU-Urw.gif"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">展示SwiftUI实况降价的演示，调侃这篇文章</figcaption></figure><p id="6202" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个故事中，我们将涉及以下主题:</p><ol class=""><li id="f949" class="le lf it js b jt ju jx jy kb lg kf lh kj li kn lj lk ll lm bi translated">将Markdown解析为AST</li><li id="6bd9" class="le lf it js b jt ln jx lo kb lp kf lq kj lr kn lj lk ll lm bi translated">解析器/策略模式</li><li id="3d1d" class="le lf it js b jt ln jx lo kb lp kf lq kj lr kn lj lk ll lm bi translated">从解析的节点构建UI</li><li id="4124" class="le lf it js b jt ln jx lo kb lp kf lq kj lr kn lj lk ll lm bi translated">结论</li></ol><p id="e312" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想看到完整的库，请查看GitHub库<a class="ae ls" href="https://github.com/techprimate/CoolDown" rel="noopener ugc nofollow" target="_blank">冷却</a>，我们自己的Markdown解析器@ techprimate.com，它也包括一个正在进行中的库<em class="lt"> CDSwiftUIMapper。</em></p><h1 id="9e20" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">将降价解析到AST节点树中</h1><p id="ec4c" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">强烈建议您阅读我以前的文章“<em class="lt">在Swift中从头创建您自己的Markdown解析器</em>”，因为我们将重用其中的概念。</p><div class="mx my gp gr mz na"><a href="https://link.medium.com/p4VuywNzagb" rel="noopener follow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">在Swift中从头开始创建您自己的Markdown解析器</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">许多平台每天都在使用Markdown。在本教程中，您将学习如何实现自己的自定义…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">link.medium.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no ky na"/></div></div></a></div><p id="caa0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">无论如何，以下是对已解释概念的简短回顾:</p><ol class=""><li id="d2ef" class="le lf it js b jt ju jx jy kb lg kf lh kj li kn lj lk ll lm bi translated">Markdown文档由块(由空行分隔)组成，块又由片段(由换行符分隔)组成，片段由行内元素(如文本或粗体字)组成。</li><li id="5c35" class="le lf it js b jt ln jx lo kb lp kf lq kj lr kn lj lk ll lm bi translated">解析后，文档可以表示为抽象语法树(AST)。树元素从现在开始被认为是<em class="lt">节点</em>。</li><li id="c1bc" class="le lf it js b jt ln jx lo kb lp kf lq kj lr kn lj lk ll lm bi translated">将文档从Markdown转换到SwiftUI时，会经历四个阶段:样式化Markdown(仅用于可视化帮助)→原始Markdown→AST/节点树→ SwiftUI视图</li></ol><p id="5bff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通常一个例子更容易理解，所以请看看下面这个:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="9925" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">造型由GitHub Gists完成。实际的原始文档如下所示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e4fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，当使用markdown解析器解析文档时(在我的例子中是冷却)，AST表示如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="dfdc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完美！我们四个步骤中的三个非常容易理解，现在让我们进入最后一步:将ast节点转换成SwiftUI视图。</p><h1 id="5070" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">解析器/策略模式</h1><p id="c8bf" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">当解析我们的树时，我们必须考虑一个映射函数:</p><blockquote class="nr ns nt"><p id="0c77" class="jq jr lt js b jt ju jv jw jx jy jz ka nu kc kd ke nv kg kh ki nw kk kl km kn im bi translated">每一种节点都有自己的视图表示。<br/> <code class="fe nx ny nz oa b">mapping: node → view</code></p></blockquote><p id="7337" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，前面代码片段中的列表节点可能映射到以下SwiftUI视图代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c1bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，每个节点都映射到一个视图结构:</p><ul class=""><li id="f42a" class="le lf it js b jt ju jx jy kb lg kf lh kj li kn ob lk ll lm bi translated"><code class="fe nx ny nz oa b">.list</code>变成了<code class="fe nx ny nz oa b">VStack</code>的观点</li><li id="1848" class="le lf it js b jt ln jx lo kb lp kf lq kj lr kn ob lk ll lm bi translated"><code class="fe nx ny nz oa b">.bullet</code>变成了<code class="fe nx ny nz oa b">HStack</code>视图，第一个元素是<code class="fe nx ny nz oa b">Text("-")</code></li><li id="d9c3" class="le lf it js b jt ln jx lo kb lp kf lq kj lr kn ob lk ll lm bi translated"><code class="fe nx ny nz oa b">.text</code>变成了<code class="fe nx ny nz oa b">Text</code>视图</li></ul><p id="8974" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有必要为每个节点类型添加一个映射函数，并以有效的方式管理它。最简单的方法是创建一个映射器类，它将一个节点的<em class="lt">数组作为输入</em>，管理一组映射函数和<em class="lt">输出一个SwiftUI视图</em>结构。</p><p id="fe9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于所有你(有抱负的)计算机科学家来说，应用软件模式也被称为<a class="ae ls" href="https://en.wikipedia.org/wiki/Strategy_pattern" rel="noopener ugc nofollow" target="_blank">策略模式</a>，因为函数总是有相同的签名，但在实现上有所不同。</p><div class="mx my gp gr mz na"><a href="https://en.wikipedia.org/wiki/Strategy_pattern#/media/File:Strategy_Pattern_in_UML.png" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">策略模式-维基百科</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">在计算机编程中，策略模式(也称为策略模式)是一种行为软件设计…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">en.wikipedia.org</p></div></div><div class="nj l"><div class="oc l nl nm nn nj no ky na"/></div></div></a></div><p id="2710" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我将称它们为<code class="fe nx ny nz oa b">Resolver</code>，它们的定义如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="56da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能想知道，这是怎么回事，所以这里有一个快速概述:</p><ul class=""><li id="94c3" class="le lf it js b jt ju jx jy kb lg kf lh kj li kn ob lk ll lm bi translated">映射函数将一个泛型<code class="fe nx ny nz oa b">Node</code>作为输入。因为我们需要节点继承<code class="fe nx ny nz oa b">ASTNode</code>的子类，可以作为通用约束添加。</li><li id="4709" class="le lf it js b jt ln jx lo kb lp kf lq kj lr kn ob lk ll lm bi translated">我们不知道它将返回什么样的视图，因此输出是一个通用类型<code class="fe nx ny nz oa b">Result</code>。</li><li id="2889" class="le lf it js b jt ln jx lo kb lp kf lq kj lr kn ob lk ll lm bi translated">使用<code class="fe nx ny nz oa b">typealias</code>我们可以知道在我们的库中使用关键字<code class="fe nx ny nz oa b">Resolver</code></li></ul><p id="2ae0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不同的解析器在一个映射器类中管理:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="07ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解析器字典是不同节点类型标识符到其对应映射函数的一对一映射。</p><p id="78e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于这个初始实现，我们决定简单地使用一个<code class="fe nx ny nz oa b">String(describing: nodeType)</code>作为标识符，它将Swift类型转换成一个字符串，例如<code class="fe nx ny nz oa b">String(describing: SwiftUI.Text.self)</code>变成了<code class="fe nx ny nz oa b">"Text"</code>。<br/>一个更干净的方法是给<code class="fe nx ny nz oa b">ASTNode</code>添加一个静态<code class="fe nx ny nz oa b">identifier</code>，它需要在每个子类中被覆盖。(“嘿Siri，提醒我静态标识符”)。</p><p id="b2a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在实现这个类的过程中，我们还遇到了第一个限制:</p><p id="5f09" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我应该为解析器返回值使用哪种<code class="fe nx ny nz oa b">Result</code>类型？一个解析器可能返回<code class="fe nx ny nz oa b">SwiftUI.Text</code>，而其他解析器甚至可能返回自定义视图。也不可能使用超类型<code class="fe nx ny nz oa b">View</code>，因为它是一个协议，编译器会开始抱怨:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi od"><img src="../Images/835f6ddc393f46bfc1c4a875303e1edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sElta448vLw04Pop4s6lxQ.png"/></div></div></figure><p id="5a2d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不幸的是，除了打字擦除，我找不到更好的解决方案。因此，它使用了<code class="fe nx ny nz oa b">AnyView</code>，它将任何SwiftUI视图包装到一个非类型化的视图结构中。</p><p id="c04b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nx ny nz oa b">addResolver</code>函数的一个很大的特性是库外的强泛型类型，比如这个例子映射器:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="4146" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">从解析的节点构建UI</h1><p id="368b" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">至此，我们已经成功地将我们的文档解析为一个节点结构，并准备好了一个映射实用程序来填充解析器。</p><p id="5fb4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的第一个解析器是用于包含节点列表的<code class="fe nx ny nz oa b">list</code>的解析器。获得期望的<code class="fe nx ny nz oa b">VStack</code>结构的简单解析器如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="8c30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是所谓的<code class="fe nx ny nz oa b">ContainerNode</code>的一个很好的例子，一个包含更多嵌套节点的节点。我们迭代每个嵌套节点<code class="fe nx ny nz oa b">mapper.resolve(node: node)</code>，它负责查找必要的解析器。在上面提到的<code class="fe nx ny nz oa b">CDSwiftUIMapper</code>类中，你可能已经注意到了<code class="fe nx ny nz oa b">fatalError("not implemented")</code>。这是实施它们的大好时机:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c834" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">函数<code class="fe nx ny nz oa b">resolve</code>在创建过程中获取映射器中设置的节点，并将每个节点解析成一个<code class="fe nx ny nz oa b">AnyView</code>，然后将它们组合成一个<code class="fe nx ny nz oa b">ForEach</code>。<br/>如果它错过了一个节点解析器，它会返回一个警告文本，因为应该避免崩溃，而且在Xcode预览中调试起来非常困难。</p><p id="b8f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为最后一步(为了在开始时得到原始的GIF ),我们添加了一个新的视图<code class="fe nx ny nz oa b">MarkdownViewer</code>,它将输入参数<code class="fe nx ny nz oa b">text</code>转换成节点，并在映射后将它们包装在一个<code class="fe nx ny nz oa b">ScrollView</code>中:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="8d5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">把所有的东西结合在一起，你就在SwiftUI中创建了一个markdown viewer！🚀</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oe"><img src="../Images/ee8944943bd8e9b795d6c5322fceeaaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wMp_YgdOkjExmTjVVqdU_Q.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">markdown实时编辑演示的预览</figcaption></figure><h1 id="73e4" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">结论</h1><p id="214d" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">这不是很酷吗？使用Markdown可以构建SwiftUI应用程序🤯这种方法有多实用，你可以自己决定。</p><p id="b363" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是对未来的一些想法:</p><ul class=""><li id="048d" class="le lf it js b jt ju jx jy kb lg kf lh kj li kn ob lk ll lm bi translated">框架冷却和它的SwiftUI映射库仍然很不完整，因此还有一些工作要做。</li><li id="473f" class="le lf it js b jt ln jx lo kb lp kf lq kj lr kn ob lk ll lm bi translated">擦除所有输入似乎仍然是一个坏主意，尤其是当SwiftUI使用区分机制来仅重新呈现UI的相关部分时。我们将进一步研究，以找到更好的解决方案。</li><li id="5e9f" class="le lf it js b jt ln jx lo kb lp kf lq kj lr kn ob lk ll lm bi translated">我的目标是为每个可用的节点类型添加一个默认的解析器，这样这个库最终就可以即插即用，在UI中预览Markdown。</li><li id="eca6" class="le lf it js b jt ln jx lo kb lp kf lq kj lr kn ob lk ll lm bi translated">当使用交互式元素时，例如网络链接(例如<code class="fe nx ny nz oa b">[follow @philprimes](https://twitter.com/philprimes)</code>)，我们将尝试将其映射到例如<code class="fe nx ny nz oa b">Button</code>中，然后点击它打开相关的Safari视图，加载URL。</li><li id="bd32" class="le lf it js b jt ln jx lo kb lp kf lq kj lr kn ob lk ll lm bi translated">目前，<code class="fe nx ny nz oa b">MarkdownViewer</code>在每次视图更新时解析文档，这对性能来说是非常糟糕的<strong class="js iu"/>。一种解决方案是在缓存中缓存解析后的节点(甚至可能在<code class="fe nx ny nz oa b">@Environment</code>中)。</li><li id="8e76" class="le lf it js b jt ln jx lo kb lp kf lq kj lr kn ob lk ll lm bi translated">我仍在尝试不同的解决方案。一个主要的方法是将多个<code class="fe nx ny nz oa b">TextNode</code>节点合并成一个节点，这样它们就像单行文本一样工作。留下一颗星和/或观看<a class="ae ls" href="https://github.com/techprimate/CoolDown" rel="noopener ugc nofollow" target="_blank"> GitHub知识库</a>以了解最新的⭐️</li></ul><p id="9d5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想了解更多，请查看我的其他文章，在<a class="ae ls" href="https://twitter.com/philprimes" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，并随时给我发短信。你有具体的话题想让我介绍吗？让我知道！😃</p></div></div>    
</body>
</html>