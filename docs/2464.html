<html>
<head>
<title>Tagging Struct fields in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">标记Go中的结构字段</h1>
<blockquote>原文：<a href="https://itnext.io/creating-your-own-struct-field-tags-in-go-c6c86727eff?source=collection_archive---------2-----------------------#2019-05-28">https://itnext.io/creating-your-own-struct-field-tags-in-go-c6c86727eff?source=collection_archive---------2-----------------------#2019-05-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6025751da7846ddb821403ae90a8e9fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VSFWHSNVQ-d3vTdDl_WSkQ.jpeg"/></div></div></figure><p id="b316" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，您已经开始在Go中探索了一点，并且您现在开始想知道您有什么样的元编程选项可供选择。在大多数编程语言中，你有一个选择，就是使用反射。Go中反射的一种用法是处理struct字段标签。</p><h1 id="3034" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是结构字段标记？</h1><p id="a91b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如果你曾经在Go中编写过RESTful JSON api，你可能已经知道了，或者至少你见过它们。这是大多数地鼠第一次遇到这些字段标签。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="daad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，你会注意到我声明了两个结构，它们都有一个类型为<em class="mf">字符串</em>的字段<em class="mf">栏</em>。我试图指出的主要区别是，第二个结构<em class="mf"> FooWithTag </em>也声明了一个字段标签。这个标签由<em class="mf"> json </em>包在编组和解组数据时使用。如果您密切注意输出，您会注意到<em class="mf">条</em>在第一个输出中是大写的，在第二个输出中是小写的。在这种情况下，field标签告诉<em class="mf"> json </em>包将键写为<em class="mf">栏</em>而不是<em class="mf">栏</em>。如果我将我的标签声明为:</p><pre class="lz ma mb mc gt mg mh mi mj aw mk bi"><span id="d545" class="ml kx iq mh b gy mm mn l mo mp"><strong class="mh ir"><em class="mf">type</em></strong> FooWithTag <strong class="mh ir"><em class="mf">struct</em></strong> {<br/>    Bar <strong class="mh ir">string</strong> `json:"tomato"`<br/>}</span></pre><p id="ea99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它会打印:</p><pre class="lz ma mb mc gt mg mh mi mj aw mk bi"><span id="1ea1" class="ml kx iq mh b gy mm mn l mo mp">{"tomato":"something"}</span></pre><p id="2b67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们已经看到了<em class="mf"> json </em>包是如何使用字段标签的，那么让我们探索一下如何创建我们自己的标签。</p><h1 id="eb89" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">定义我们自己的自定义标签</h1><p id="ef1d" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们先玩得快一点，放松一点。当一个人如此行事时，他们往往会忘记自己的礼仪。因此，让我们制作一个struct字段标记，使我们的代码更有礼貌一些。</p><pre class="lz ma mb mc gt mg mh mi mj aw mk bi"><span id="baea" class="ml kx iq mh b gy mm mn l mo mp"><strong class="mh ir">type</strong> Foo <strong class="mh ir">struct</strong> {<br/>    Bar <strong class="mh ir">string</strong> `manners`<br/>}</span></pre><p id="f98a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当我们看到带有标签<em class="mf">礼仪</em>的字段，我们就应该<em class="mf"> </em>用<em class="mf"> pretty please对字符串进行后置处理。下面的片段概述了我们正在努力实现的目标。</em></p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="386f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了实现这种行为，我们需要依靠我们的好朋友<em class="mf">反射</em>包。</p><h2 id="98f7" class="ml kx iq bd ky mq mr dn lc ms mt dp lg kj mu mv lk kn mw mx lo kr my mz ls na bi translated">反射</h2><p id="48cb" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">反射是我们可以在运行时计算出一个结构包含的所有标签的方法。让我们首先打印出我们在结构中看到的所有标签。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="8761" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要专注于我们真正想要使用的标签。为了获取特定的标签，<em class="mf">反射</em>包提供了一个<em class="mf">查找</em>方法。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="cd83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，没有输出。</p><blockquote class="nb"><p id="15e5" class="nc nd iq bd ne nf ng nh ni nj nk kv dk translated">🤔为什么不呢？</p></blockquote><p id="eabb" class="pw-post-body-paragraph jy jz iq ka b kb nl kd ke kf nm kh ki kj nn kl km kn no kp kq kr np kt ku kv ij bi translated">因为我们打得太快太松了😱。让我们来看看来自<em class="mf">反射</em>包的一些文档。</p><blockquote class="nq nr ns"><p id="c4e0" class="jy jz mf ka b kb kc kd ke kf kg kh ki nt kk kl km nu ko kp kq nv ks kt ku kv ij bi translated">按照惯例，标记字符串是可选空格分隔的键:“值”对的串联。每个键都是非空字符串，由除空格(U+0020 ' ')、引号(U+0022 ' " ')和冒号(U+003A ':')以外的非控制字符组成。每个值都使用U+0022 ' " '字符和Go字符串文字语法引用。</p></blockquote><p id="de18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们已经阅读了文档，我们知道我们需要改变我们的结构字段标签的定义方式。一旦我们知道该字段正确地标记了我们正在寻找的标签，我们就需要找出一种方法来访问该字段的值。我们也可以用<em class="mf">反射</em>包来完成这个任务。完成所有这些编辑后，代码应该看起来像这样…</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><h2 id="69c3" class="ml kx iq bd ky mq mr dn lc ms mt dp lg kj mu mv lk kn mw mx lo kr my mz ls na bi translated">更进一步</h2><p id="c377" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">太好了。我们定义了我们的自定义标签，让它做我们想做的事情，现在一切都好了，对吗？不完全是。你看，任何时候你使用<em class="mf">反射</em>软件包，你都在让自己陷入恐慌。为了安全起见，我们应该检查我们正在操作的<em class="mf">类</em>田地。对于这个标签，让我们保持简单，说它应该只对类型为<em class="mf"> string的字段起作用。</em>此外，既然我们现在知道我们可以将一个值与我们的struct field标记相关联，那么我们说这个标记可以有选择地提供一个数字来定义单词<em class="mf"> pretty </em>被打印的次数。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><blockquote class="nb"><p id="1473" class="nc nd iq bd ne nf nw nx ny nz oa kv dk translated">🎉恭喜🎉，我们现在已经创建了一个标签，使我们的代码更有礼貌！</p></blockquote><h1 id="7933" class="kw kx iq bd ky kz la lb lc ld le lf lg lh ob lj lk ll oc ln lo lp od lr ls lt bi translated">我做了什么</h1><p id="ce80" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">现在，您已经了解了到野外探险并开始创建自己的定制标签所需的一切。如果你想引用一个稍微复杂一点的例子，我鼓励你<a class="ae oe" href="https://github.com/codyoss/verify" rel="noopener ugc nofollow" target="_blank">看一看<strong class="ka ir"> <em class="mf">验证</em> </strong> </a>。这是一个我扔在一起的包，它模仿了你可能在<em class="mf">javax . validation . constraints</em>中找到的一些东西，如果你熟悉的话。Go社区中还有其他更完整的包，它们做的事情与我创建的包一样，但我想构建一些小而真实的东西来帮助自己理解Go中的标记。希望这些对你有帮助！</p><div class="of og gp gr oh oi"><a href="https://github.com/codyoss/verify" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">codyoss/验证</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">用字段标签验证你的结构！通过在GitHub上创建一个帐户来为codyoss/verify开发做贡献。</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">github.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow jw oi"/></div></div></a></div><p id="0dcf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你能走到这一步，谢谢你。🙌</p></div></div>    
</body>
</html>