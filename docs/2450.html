<html>
<head>
<title>Using ES6 To Destructure Deeply Nested Objects in JavaScript &amp; Avoid Undefined Errors that Break Your Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ES6来析构JavaScript中深度嵌套的对象&amp;避免破坏代码的未定义错误</h1>
<blockquote>原文：<a href="https://itnext.io/using-es6-to-destructure-nested-objects-in-javascript-avoid-undefined-errors-that-break-your-code-612ae67913e9?source=collection_archive---------0-----------------------#2019-05-27">https://itnext.io/using-es6-to-destructure-nested-objects-in-javascript-avoid-undefined-errors-that-break-your-code-612ae67913e9?source=collection_archive---------0-----------------------#2019-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="b1ca" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">因为Airbnb的ESLint在反应上毫不留情</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/3ccdc09717a6bd0e8b49b74a0b41d2d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*S7cMNiHJaGkDuJVIUlhWyQ.jpeg"/></div></figure><h1 id="c326" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="b237" class="pw-post-body-paragraph kt ku iq kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi lr translated"><span class="l ls lt lu bm lv lw lx ly lz di">在</span>的情况下，这是你第一次阅读我的帖子，感谢你抽出时间，我是一个全栈软件开发人员，喜欢JavaScript，尤其是React框架。</p><p id="c086" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">一年多来，在我下班后的空闲时间里，我一直在网上文档、文章、教程和建立(和打破)副业的帮助下自学React。</p><p id="0e1e" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">有了所有这些知识和灵感来源，我设法构建了一个令我非常自豪的<a class="ae mf" href="https://github.com/paigen11/mysql-registration-passport" rel="noopener ugc nofollow" target="_blank">用户注册应用程序</a>。它有一个React前端，一个Express/Node.js服务器后端，一个MySQL数据库，它使用<a class="ae mf" rel="noopener ugc nofollow" target="_blank" href="/implementing-json-web-tokens-passport-js-in-a-javascript-application-with-react-b86b1f313436"> Passport.js和JSON Web令牌</a>来处理身份验证，使用<a class="ae mf" href="https://medium.com/@paigen11/sequelize-the-orm-for-sql-databases-with-nodejs-daa7c6d5aca3" rel="noopener"> Sequelize </a> ORM在数据库上执行CRUD操作，通过Nodemailer使用<a class="ae mf" rel="noopener ugc nofollow" target="_blank" href="/password-reset-emails-in-your-react-app-made-easy-with-nodemailer-bb27968310d7">密码重置功能</a>，在其余端点上测试<a class="ae mf" rel="noopener ugc nofollow" target="_blank" href="/setting-up-swagger-in-a-node-js-application-d3c4d7aa56d4"> Swagger端点</a>，在虚拟化容器环境中同时启动应用程序的所有三个部分的<code class="fe mg mh mi mj b"><a class="ae mf" href="https://medium.com/@paigen11/using-docker-docker-compose-to-improve-your-full-stack-application-development-1e41280748f4" rel="noopener">docker-compose.yml</a></code> <a class="ae mf" href="https://medium.com/@paigen11/using-docker-docker-compose-to-improve-your-full-stack-application-development-1e41280748f4" rel="noopener">文件</a>等。你有足够的技术扔给你吗？😫</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">是的，我把那些流行语都扔了，不，我真的没什么大不了的。😉</figcaption></figure><p id="9b84" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">请理解，这个项目绝不是一天就能完成的，它开始是一个非常基本的想法，随着我不断取得进展，并变得更加雄心勃勃，想看看我能把它推进多远。但是当我到了那一步的时候，我为自己感到非常自豪。我做了一个很酷、很有用的小项目——完全用JavaScript构建。</p><p id="4c02" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">然后，我<a class="ae mf" rel="noopener ugc nofollow" target="_blank" href="/how-eslint-makes-me-a-better-react-developer-237fb14c00ae">将Airbnb的ESLint </a>配置引入其中，当<a class="ae mf" rel="noopener ugc nofollow" target="_blank" href="/keep-code-consistent-across-developers-the-easy-way-with-prettier-eslint-60bb7e91b76c"> VS代码浏览器</a>左右亮起不赞成的红色波浪线时，我感到谦卑。😞然而，我没有放弃，而是坚持学习现代JavaScript/ES6开发的最佳实践(根据ESLint和Airbnb)，修复了我的大部分错误，并成为了一名更好的开发人员。</p><p id="d89a" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">然而，有一个错误让我困惑。深度嵌套的、被析构的对象。请告诉我，你是如何析构一个在JavaScript中有几层深度的<code class="fe mg mh mi mj b">prop</code>对象来让ESLint满意的？</p><blockquote class="mr"><p id="07cd" class="ms mt iq bd mu mv mw mx my mz na lq dk translated">今天，我将向您展示如何使用ES6来析构嵌套对象，我的朋友们，更重要的是，如果一个对象完全丢失了那个属性，防止可怕的未定义错误。</p></blockquote><p id="c044" class="pw-post-body-paragraph kt ku iq kv b kw nb ky kz la nc lc ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">我们开始吧。</p><h1 id="3749" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">问题:ES6对象析构&amp;深度嵌套对象</h1><p id="0b4d" class="pw-post-body-paragraph kt ku iq kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了让您更深入地了解我所描述的内容，让我先回顾一下JavaScript中的对象析构是什么，以及为什么一旦您的对象变得复杂，它就会变得令人望而生畏。</p><h2 id="b37a" class="ng jo iq bd jp nh ni dn jt nj nk dp jx le nl nm kb li nn no kf lm np nq kj nr bi translated">简而言之，对象析构</h2><p id="06b3" class="pw-post-body-paragraph kt ku iq kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">和往常一样，MDN的文档很好地总结了JavaScript析构:</p><blockquote class="ns nt nu"><p id="c1dd" class="kt ku nv kv b kw ma ky kz la mb lc ld nw mc lg lh nx md lk ll ny me lo lp lq ij bi translated"><strong class="kv ir">析构赋值</strong>语法是一个JavaScript表达式，可以将数组中的值或对象中的属性解包到不同的变量中。— MDN文档，析构分配</p></blockquote><p id="e9d9" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">这是ES6中引入的一个特性，在实践中，它意味着您的代码可以如下所示:</p><p id="2746" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated"><strong class="kv ir">普通的旧JavaScript对象</strong></p><pre class="km kn ko kp gt nz mj oa ob aw oc bi"><span id="0b42" class="ng jo iq mj b gy od oe l of og">const myObject = { <br/>  a : "foo", <br/>  b : false, <br/>  c : 11 <br/>};</span></pre><p id="612d" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated"><strong class="kv ir">传统JS对象属性访问示例(点符号和括号符号)</strong></p><p id="01dc" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">对象的属性通过点符号或括号符号来访问，如下所示:</p><pre class="km kn ko kp gt nz mj oa ob aw oc bi"><span id="6d6d" class="ng jo iq mj b gy od oe l of og">console.log(myObject.a); // "foo"<br/>console.log(myObject[b]); // false<br/>console.log(myObject.c); // 11</span></pre><p id="07fa" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated"><strong class="kv ir"> ES6对象属性访问示例(析构)</strong></p><p id="56ef" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">像这样被访问:</p><pre class="km kn ko kp gt nz mj oa ob aw oc bi"><span id="f4a8" class="ng jo iq mj b gy od oe l of og">const { a, b, c } = myObject;<br/>console.log(a); // "foo"<br/>console.log(b); // false<br/>console.log(c); // 11</span></pre><p id="6350" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">很酷，对吧？它更短，读起来更简洁，逻辑上也很有意义。</p><p id="8323" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">数组、对象和析构还有很多更酷的事情可以做，我建议你阅读<a class="ae mf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">文档</a>获取更多示例。</p><p id="87dd" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">好了，现在ES6的析构已经定义好了，让我们来看看我的问题，这个问题看起来不那么简单(至少在第一遍，对我来说)。</p><h2 id="64de" class="ng jo iq bd jp nh ni dn jt nj nk dp jx le nl nm kb li nn no kf lm np nq kj nr bi translated">嵌套很深的对象</h2><p id="0fb3" class="pw-post-body-paragraph kt ku iq kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是我在React应用程序中使用的对象的截图。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><div class="gh gi oh"><img src="../Images/a7ef384d171ef76a6e3bda772533e192.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CJyY3UxC8Q0BqTHrfPneeg.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">这是我的嵌套对象，用传统的JavaScript点符号语法编写。</figcaption></figure><pre class="km kn ko kp gt nz mj oa ob aw oc bi"><span id="61f4" class="ng jo iq mj b gy od oe l of og">this.props.match.params.username; // what a mouthful! no one wants to write this anymore</span></pre><p id="1fec" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">为了提供更多的上下文信息，这个对象从URL字符串中提取，并被传递到从浏览器客户端到服务器端的HTTP调用中，以识别(并验证)数据库中的用户名。这个语法是由<code class="fe mg mh mi mj b">react-router-dom</code> <a class="ae mf" href="https://www.npmjs.com/package/react-router-dom" rel="noopener ugc nofollow" target="_blank"> NPM包</a>和React的<code class="fe mg mh mi mj b">props</code>提供的。</p><p id="5e06" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">不管对象的语法和结构来自哪里，它都是复杂的。从技术上讲，它在这个对象中嵌套了4层以上，以获取有用的信息，即<code class="fe mg mh mi mj b">username</code>。</p><p id="89d4" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">与<code class="fe mg mh mi mj b">const {a} = myObject;</code>不同，试图弄清楚如何深入到一个物体的几个层次有点令人困惑。</p><h2 id="5701" class="ng jo iq bd jp nh ni dn jt nj nk dp jx le nl nm kb li nn no kf lm np nq kj nr bi translated">ESLint的错误:一如既往的无情</h2><p id="9826" class="pw-post-body-paragraph kt ku iq kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是ESLint在乎吗？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi om"><img src="../Images/9f4351dc7063cd99c8718722d5c5588d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*TYifiOJXooG5bR6kXZmQEg.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">我从未想过我会有理由在博客文章中使用蜜獾迷因，然而，它就在这里。</figcaption></figure><p id="1b05" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">用蜜獾不朽的话来说，“不”。</p><p id="6d1f" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">只要ESLint在我的代码中看到这种语法，警报就会响起，ESLint错误就会出现:<code class="fe mg mh mi mj b">Must use destructuring props assignment eslint(react/destructuring-assignment)</code>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><div class="gh gi on"><img src="../Images/064ba8d4d61c65a4d08ed90ab694208a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bPVi-IwEDW0kjSR8TFv06Q.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">谢谢你的帮助，ESLint，这是一个非常有用的警告信息。🙄</figcaption></figure><p id="c35b" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">我访问了ESLint文档，做了一些半心半意的尝试，试图找出如何将这些错综复杂的对象分开，但最终还是放弃了，而是求助于我的文件顶部的旧的<code class="fe mg mh mi mj b"><em class="nv">* eslint-disable react/destructuring-assignment */</em></code> <em class="nv"> </em>导入，而不是正确地修复它。我继续我的生活。😬</p><p id="ffd2" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">然后，过了一会儿，另一个开发人员给我指了一篇文章给我指明了方向，当时我们正试图决定如果在本地开发期间没有指定环境变量，如何最好地保护我们的代码不抛出错误。</p><p id="cc95" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">看完之后，事情就说得通多了。以下是我学到的东西。</p><h2 id="a085" class="ng jo iq bd jp nh ni dn jt nj nk dp jx le nl nm kb li nn no kf lm np nq kj nr bi translated">如何修复ESLint“解构道具”错误</h2><p id="2d47" class="pw-post-body-paragraph kt ku iq kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">显然，我试图使对象析构的求解比它需要的更复杂。这是我的对象的分解(或构建),一路上都在解构。</p><p id="8152" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated"><strong class="kv ir">一个JavaScript对象</strong></p><p id="12bd" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">对于最简单的对象(就像我在上面定义析构时概述的)，它看起来像这样:</p><pre class="km kn ko kp gt nz mj oa ob aw oc bi"><span id="43f3" class="ng jo iq mj b gy od oe l of og">const myObject = {<br/>  props: 'Hello world'<br/>};</span></pre><p id="cc2c" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">析构的版本变成:</p><pre class="km kn ko kp gt nz mj oa ob aw oc bi"><span id="414b" class="ng jo iq mj b gy od oe l of og">const { <br/>  props <br/>} = myObject; </span><span id="0ba2" class="ng jo iq mj b gy oo oe l of og">console.log(props); // prints: 'Hello world'</span></pre><p id="4551" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">对，这看起来合乎逻辑，访问对象中的属性值，只需用花括号将属性括起来。</p><p id="0e0a" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">接下来，上…</p><p id="b11a" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated"><strong class="kv ir">一个JS对象在<em class="nv">另一个</em>对象</strong>内</p><p id="4b9f" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">对于另一个对象中的一个对象，例如:</p><pre class="km kn ko kp gt nz mj oa ob aw oc bi"><span id="aab7" class="ng jo iq mj b gy od oe l of og">const myObject = { <br/>  props: { <br/>    match : 'Some value' <br/>  }<br/>};</span></pre><p id="5594" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">析构的版本变成:</p><pre class="km kn ko kp gt nz mj oa ob aw oc bi"><span id="a20e" class="ng jo iq mj b gy od oe l of og">const { <br/>  props : { <br/>    match <br/>  },<br/>} = myObject; </span><span id="7151" class="ng jo iq mj b gy oo oe l of og">console.log(match); // prints: 'Some value'</span></pre><p id="da06" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">好的，所以要访问两层的属性值，首先用花括号将顶层对象(在本例中为<code class="fe mg mh mi mj b">props</code>)中的原始属性括起来，然后，在该对象中，用另一组花括号将内部对象<code class="fe mg mh mi mj b">match</code>括起来。</p><p id="691e" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">好的，到目前为止…</p><p id="c212" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated"><strong class="kv ir">一个JS对象在<em class="nv">内两个以上</em>对象</strong></p><p id="81e3" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">对于稍微复杂一点的对象，比如:</p><pre class="km kn ko kp gt nz mj oa ob aw oc bi"><span id="b2eb" class="ng jo iq mj b gy od oe l of og">const myObject = { <br/>  props: { <br/>    match: {<br/>      params: 'A new value'<br/>    } <br/>  } <br/>};</span></pre><p id="69e6" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">新的析构版本变成:</p><pre class="km kn ko kp gt nz mj oa ob aw oc bi"><span id="c5df" class="ng jo iq mj b gy od oe l of og">const<em class="nv"> </em>{ <br/>  props: { <br/>    match:<em class="nv"> </em>{ <br/>      params <br/>    }, <br/>  }, <br/>}<em class="nv"> </em>=<em class="nv"> </em>myObject; </span><span id="513b" class="ng jo iq mj b gy oo oe l of og">console.log(params); // prints: 'A new value'</span></pre><p id="6b44" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">再次遍历每一层:<code class="fe mg mh mi mj b">props</code>被第一组花括号包围，<code class="fe mg mh mi mj b">match</code>，包含在<code class="fe mg mh mi mj b">props</code>中的对象被第二组花括号包围，最后，第三个对象<code class="fe mg mh mi mj b">params</code>(包含我想要访问的值)被第三组花括号包围。</p><p id="0e60" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">当一个接一个地解构时，这种模式开始变得有意义了。</p><p id="73b0" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated"><strong class="kv ir">一个JS对象内<em class="nv">三个以上</em>对象</strong></p><p id="ae2e" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">所以，对于一个甚至更<em class="nv">更</em>复杂的物体来说，就像这样:</p><pre class="km kn ko kp gt nz mj oa ob aw oc bi"><span id="e862" class="ng jo iq mj b gy od oe l of og">const myObject = { <br/>  props: { <br/>    match: { <br/>      params: { <br/>        username: 'Paige' <br/>      } <br/>    } <br/>  }<br/>};</span></pre><p id="46c9" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">新的析构版本变成:</p><pre class="km kn ko kp gt nz mj oa ob aw oc bi"><span id="c3d1" class="ng jo iq mj b gy od oe l of og">const { <br/>  props: {<br/>    match: {<br/>      params: { <br/>        username <br/>      }, <br/>    }, <br/>  }, <br/>} = myObject; </span><span id="2e08" class="ng jo iq mj b gy oo oe l of og">console.log(username); // prints: 'Paige'</span></pre><p id="599d" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">上面同样的规则和模式仍然适用，只需用花括号继续前进一级，到达您想要读取的对象属性。</p><p id="d58a" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">为了修复我的React应用程序抛出的ESLint错误，<code class="fe mg mh mi mj b">Must use destructuring props assignment eslint(react/destructuring-assignment)</code>，这是我想到的解决方案。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><div class="gh gi op"><img src="../Images/17721a480de12128d9771bd69b8842ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R10ZW5lugKp86FL71gyIdQ.png"/></div></div></figure><p id="2aa7" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">因为ESLint只希望从<code class="fe mg mh mi mj b">props</code>对象级别开始析构对象，所以我可以让我的对象比一个真正的、完全析构的对象稍微小一点。访问<code class="fe mg mh mi mj b">this.props</code>中的<code class="fe mg mh mi mj b">match</code>对象，访问<code class="fe mg mh mi mj b">match</code>中的<code class="fe mg mh mi mj b">params</code>对象，最后，访问我正在寻找的信息的<code class="fe mg mh mi mj b">username</code>的值。</p><p id="c685" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">分解成这样的步骤，一切开始变得更有意义。</p><p id="fa55" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">不错！但后来我想到了一个边缘情况，如果出于某种原因，这些属性中的一个丢失了怎么办？啊，在析构对象中也有防止<code class="fe mg mh mi mj b">undefined</code>错误的方法。</p><h2 id="fb06" class="ng jo iq bd jp nh ni dn jt nj nk dp jx le nl nm kb li nn no kf lm np nq kj nr bi translated"><strong class="ak">如何防止缺失属性的未定义错误:默认值</strong></h2><p id="3ba4" class="pw-post-body-paragraph kt ku iq kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我无法告诉你我在本地开发中抛出错误的次数，因为我试图访问的对象上的属性是<code class="fe mg mh mi mj b">undefined</code>，这意味着该属性(及其值)在该对象上不存在。不是空字符串，也不是空数组，甚至不是0。它根本不存在。</p><p id="c9da" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated"><code class="fe mg mh mi mj b">TypeError: Cannot read property ‘params’ of undefined</code>。这太烦人了——尤其是当它导致React在浏览器中抛出一个巨大的错误时。😠</p><p id="b5a0" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">但是有一种方法可以解决这个问题，使用<a class="ae mf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values_2" rel="noopener ugc nofollow" target="_blank">对象默认值</a>。ES6的另一个很好的特性是，在从对象解包的值是<code class="fe mg mh mi mj b">undefined</code>的情况下，变量可以被赋予一个默认值。</p><p id="f634" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">这完全是另一篇博文，但是对于我来说，在析构对象缺少属性的情况下，这意味着我可以提供一个字符串或其他值形式的回退值，而不是抛出一个<code class="fe mg mh mi mj b">TypeError</code>，并且我会接收到那个值，我可以专门查找该值，然后继续前进。</p><p id="2de4" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">这是一个只有一个属性的对象的例子。</p><p id="fa09" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated"><strong class="kv ir">普通旧JavaScript对象</strong></p><pre class="km kn ko kp gt nz mj oa ob aw oc bi"><span id="c976" class="ng jo iq mj b gy od oe l of og">const myObject = { <br/>  props: 'I only have props, nothing else'<br/>};</span></pre><p id="f180" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">和解构的版本:</p><pre class="km kn ko kp gt nz mj oa ob aw oc bi"><span id="e5c0" class="ng jo iq mj b gy od oe l of og">const { props } = myObject; </span><span id="4aeb" class="ng jo iq mj b gy oo oe l of og">console.log(props); // prints: 'I only have props, nothing else'</span></pre><p id="8326" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">如果我试图访问一个析构对象中未定义的属性，通常情况下:</p><p id="1cae" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated"><strong class="kv ir">没有默认属性的ES6析构对象</strong></p><pre class="km kn ko kp gt nz mj oa ob aw oc bi"><span id="b35c" class="ng jo iq mj b gy od oe l of og">const { <br/>  props: {<br/>    match <br/>  } <br/>} = myObject </span><span id="66af" class="ng jo iq mj b gy oo oe l of og">console.log(match); // throws error: <!-- -->TypeError: Cannot read property ‘match’ of undefined</span></pre><p id="bac8" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">但是，如果我设置一个默认值，如果这个属性不存在，就在这个析构的对象中，像这样:</p><p id="a5ec" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated"><strong class="kv ir">带有默认属性的ES6析构对象</strong></p><pre class="km kn ko kp gt nz mj oa ob aw oc bi"><span id="f317" class="ng jo iq mj b gy od oe l of og">const { <br/>  props: { match } = { match: 'No match'}<br/>} = myObject</span><span id="d0cf" class="ng jo iq mj b gy oo oe l of og">console.log(match); // prints: 'No match'</span></pre><p id="0888" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">对于一个空对象、一个空数组、一个默认的字符串或整数，或者除了可怕的<code class="fe mg mh mi mj b">undefined</code>错误之外的许多其他东西，我可以在DOM中设置错误处理，以向用户显示某种消息，这样他们就知道发生了什么以及如何修复这种情况——这比带有神秘消息的明显的React错误屏幕要好得多。</p><p id="7053" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">因此，这里有一个重写版本的析构对象，我的应用程序需要一个来自URL字符串的用户名。如果用户名不在URL中，这个对象结构将默认为字符串<code class="fe mg mh mi mj b">'no match’</code>，然后我可以检查它，并显示一个更好的错误消息来帮助用户回到应用程序中的工作位置。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><div class="gh gi oq"><img src="../Images/060be0384847b7c9a9fe9deff361b457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CK4Bk_T9JsP67Do_mzFE2A.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">默认值是防止析构对象中出现“未定义”错误的一种巧妙方法。</figcaption></figure><h1 id="6776" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="25e1" class="pw-post-body-paragraph kt ku iq kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">ES6是对JavaScript语法的一个很大的改进，Airbnb的ESLint配置是一个很好的识别代码的工具，可以用来识别ES6中最新最好的但还没有被使用的代码。</p><p id="8c13" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">我最大的抱怨是，有时它在解释如何修复它发现的错误方面不够有帮助。幸运的是，我找到了一个资源来更好地解释如何析构嵌套更深的对象，甚至如何设置默认值来防止React应用程序中抛出<code class="fe mg mh mi mj b">undefined</code>错误。</p><p id="4829" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">可读性，干净，简洁的代码，错误预防和缺省值，人们还能要求什么呢？我是对象析构的粉丝，尤其是现在我知道如何用它处理各种不同的场景。</p><p id="149e" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">过几周再来看看，我会写关于JavaScript、ES6或其他与web开发相关的东西，所以请关注我，这样你就不会错过了。</p><p id="c003" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">感谢您的阅读，我希望这能帮助您更好地理解ES6对象析构的强大功能以及如何在您自己的JavaScript应用程序中使用它。如果你觉得有帮助，请与你的朋友分享！</p><p id="b968" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated">如果你喜欢读这篇文章，你可能也会喜欢我的其他一些博客:</p><ul class=""><li id="d24a" class="or os iq kv b kw ma la mb le ot li ou lm ov lq ow ox oy oz bi translated"><a class="ae mf" rel="noopener ugc nofollow" target="_blank" href="/how-eslint-makes-me-a-better-react-developer-237fb14c00ae">ESLint如何让我成为更好的React开发人员</a></li><li id="bb4f" class="or os iq kv b kw pa la pb le pc li pd lm pe lq ow ox oy oz bi translated"><a class="ae mf" rel="noopener ugc nofollow" target="_blank" href="/update-feature-toggles-in-a-react-app-without-redeploying-5b95674a5bb1">更新功能在React应用中切换，无需重新部署</a></li><li id="bdc1" class="or os iq kv b kw pa la pb le pc li pd lm pe lq ow ox oy oz bi translated"><a class="ae mf" rel="noopener ugc nofollow" target="_blank" href="/settings-sync-with-vs-code-c3d4f126989">通过设置同步</a>,将您的VS代码配置轻松带到任何地方</li></ul><p id="fe77" class="pw-post-body-paragraph kt ku iq kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ij bi translated"><strong class="kv ir">参考资料和更多资源:</strong></p><ul class=""><li id="e420" class="or os iq kv b kw ma la mb le ot li ou lm ov lq ow ox oy oz bi translated">用户注册Github回购:<a class="ae mf" href="https://github.com/paigen11/mysql-registration-passport" rel="noopener ugc nofollow" target="_blank">https://github.com/paigen11/mysql-registration-passport</a></li><li id="bdfe" class="or os iq kv b kw pa la pb le pc li pd lm pe lq ow ox oy oz bi translated">MDN文档，对象析构:<a class="ae mf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Operators/destructing _ assignment # Object _ destructing</a></li><li id="a197" class="or os iq kv b kw pa la pb le pc li pd lm pe lq ow ox oy oz bi translated">https://www.npmjs.com/package/react-router-dom，NPM:<a class="ae mf" href="https://www.npmjs.com/package/react-router-dom" rel="noopener ugc nofollow" target="_blank"/></li><li id="cc9f" class="or os iq kv b kw pa la pb le pc li pd lm pe lq ow ox oy oz bi translated">MDN文档，对象默认值:<a class="ae mf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values_2" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Operators/destructing _ assignment # Default _ Values _ 2</a></li></ul></div></div>    
</body>
</html>