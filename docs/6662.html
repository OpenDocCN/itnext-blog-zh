<html>
<head>
<title>Building Multi-CPU Architecture Docker Images for ARM and x86 (1): The Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为ARM和x86构建多CPU架构Docker映像(1):基础知识</h1>
<blockquote>原文：<a href="https://itnext.io/building-multi-cpu-architecture-docker-images-for-arm-and-x86-1-the-basics-2fa97869a99b?source=collection_archive---------0-----------------------#2022-01-21">https://itnext.io/building-multi-cpu-architecture-docker-images-for-arm-and-x86-1-the-basics-2fa97869a99b?source=collection_archive---------0-----------------------#2022-01-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/644177f864f9a87776e58f3e28319742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4ck0quP7IX7GfEqU"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@json_pix?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jason Ng </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="6f8d" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">为什么？</h1><p id="439a" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">随着苹果的M1机器越来越受欢迎，开发人员从用户那里收到越来越多的ARM CPU支持他们软件的请求。虽然M1版本的docker桌面允许用户在仿真下运行x86 docker映像，但将您的软件作为“通用”的多拱docker映像提供，可以为您的ARM (M1)和x86用户提供服务，这将是一个更有效的解决方案。</p><p id="a1c0" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们也看到越来越多的云提供商提供基于ARM CPU的服务。例如，Oracle Ampere A1 Compute声称其ARM实例比AMD Milan 的<a class="ae kc" href="https://blogs.oracle.com/cloud-infrastructure/post/arm-based-cloud-computing-is-the-next-big-thing-introducing-arm-on-oracle-cloud-infrastructure" rel="noopener ugc nofollow" target="_blank">高32%的性价比。AWS Graviton声称，其ARM CPU EC2 A1实例的性价比比当前基于x86的同类实例高出40%。除了节省成本，ARM-power数据中心还能带给我们更多的节能和绿色未来。分析显示</a><a class="ae kc" href="https://devops.com/energy-efficiency-and-the-data-center/" rel="noopener ugc nofollow" target="_blank">ARM驱动的数据中心减少了74%的二氧化碳排放量，相当于近50万桶石油</a>。因此，即使您现在没有大量的ARM用户，构建一个CI管道来发布具有ARM CPU支持的docker映像仍然是一个不错的长期投资。</p><h1 id="0ee6" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">“Buildx”Docker CLI插件和莫比“BuildKit”生成器工具包</h1><p id="87d9" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Docker Buildx是一个CLI插件，它扩展了Docker命令，完全支持<a class="ae kc" href="https://github.com/moby/buildkit" rel="noopener ugc nofollow" target="_blank">莫比构建工具包</a>构建工具包提供的功能。BuildKit设计用于为多个平台构建，而不仅仅是调用构建的用户碰巧运行的架构和操作系统。这允许我们在一台机器上一次性构建多CPU架构docker映像。</p><p id="172f" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在您的本地开发PC(x86或苹果M1 CPU)上，访问“Buildx”和“BuildKit”的最简单方法是安装<a class="ae kc" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank"> Docker Desktop </a>。只要docker配置文件中的“experimental”&amp;“build kit”配置选项设置为true，您应该能够从终端访问Buildx docker CLI插件&amp; buildkit，而无需任何特殊设置。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/fab0ef3c44f73e88338589319a5b602e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cOmC8i3RS1SNF01Pizc0wA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">码头引擎配置</figcaption></figure><p id="c825" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">对于CI管道，我们可以使用安装了buildx CLI插件的预构建docker映像。要在Docker容器中安装buildx CLI插件，您只需从Github下载与您当前的CPU架构相匹配的正确版本。例如:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="8dac" class="mo ke iq mk b gy mp mq l mr ms">export BUILDX_ARCH="linux-amd64"<br/>export BUILDX_VERSION="v0.6.3"</span><span id="9d90" class="mo ke iq mk b gy mt mq l mr ms">mkdir -p ~/.docker/cli-plugins &amp;&amp; \    <br/>    wget -nv -O ~/.docker/cli-plugins/docker-buildx https://github.com/docker/buildx/releases/download/${BUILDX_VERSION}/buildx-${BUILDX_VERSION}.${BUILDX_ARCH} &amp;&amp; \    <br/>    chmod a+x ~/.docker/cli-plugins/docker-buildx</span></pre><p id="539e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">为了节省时间，也可以使用我发布的预建docker图片:<code class="fe mu mv mw mk b"><a class="ae kc" href="https://hub.docker.com/r/data61/magda-builder-docker/tags" rel="noopener ugc nofollow" target="_blank">data61/magda-builder-docker:latest</a></code>。</p><p id="0fb5" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们将在另一篇文章中讨论为CI管道构建多CPU架构docker映像的更多细节。</p><h1 id="f561" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">在本地机器上构建多CPU架构Docker映像</h1><p id="f6bb" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">要为多CPU架构构建Docker映像，只需运行以下命令:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="481f" class="mo ke iq mk b gy mp mq l mr ms">docker buildx build -t docker.io/xx/myimage:v1 -f [path to Dockerfile] --push --platform=linux/arm64,linux/amd64 [path to build context]</span></pre><p id="dba1" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">该命令的语法类似于单arch版本构建命令<code class="fe mu mv mw mk b"><a class="ae kc" href="https://docs.docker.com/engine/reference/commandline/build/" rel="noopener ugc nofollow" target="_blank">docker build</a></code>,但有几个额外的参数:</p><ul class=""><li id="dd8a" class="mx my iq ld b le lz li ma lm mz lq na lu nb ly nc nd ne nf bi translated"><code class="fe mu mv mw mk b">--platform</code>:您可以以<code class="fe mu mv mw mk b">TargetOS</code>(如<code class="fe mu mv mw mk b">linux</code> ) / <code class="fe mu mv mw mk b">TargetArch</code>(如<code class="fe mu mv mw mk b">arm64</code>/<code class="fe mu mv mw mk b">TargetVariant</code>(可选)的格式列出所有的目标CPU arch(用逗号分隔)。为了支持两种x86 64位CPU&amp;ARM 64 CPU(例如苹果M1)，您需要指定<code class="fe mu mv mw mk b">--platform=linux/arm64,linux/amd64</code>。当该命令运行时，将同时构建所有指定目标平台的docker映像。一旦构建了所有目标的映像，所有映像将被推送到docker注册表，并且包含所有目标平台信息的单个清单将被保存到注册表中。这确保了正确的目标映像的映像将用于不同的平台。</li><li id="056f" class="mx my iq ld b le ng li nh lm ni lq nj lu nk ly nc nd ne nf bi translated"><code class="fe mu mv mw mk b">--push</code>:当您提供该参数时，构建的图像将被直接推送到远程注册表。请注意:如果您不提供该参数，docker将不会尝试生成清单并将其推送到docker注册表。另一方面，本地docker存储库不能提供一个清单背后的多拱图像。因此，构建的结果将被简单地丢弃。除非您只想测试您的映像构建脚本，否则您可能总是希望在您的命令中包含<code class="fe mu mv mw mk b">--push</code>。</li></ul><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="6d07" class="mo ke iq mk b gy mp mq l mr ms">As a "universal" multi-arch Docker image is hosted by a registry as a list of docker images for different target platforms that is served behind one single manifest. Instead of using buildx / buildkit, you can alternatively achieve the same result by:<br/>- Build docker image for linux/arm64 on an arm machine (e.g. Apple m1) using `Docker build` and push to registry<br/>- Build docker image for linux/amd64 on an intel CPU PC and push to registry<br/>- Create a combined manifest: `docker manifest create my-      image:latest --amend my-image:x64 --amend my-image:arm`<br/>- Push the new manifest to registry: `docker manifest push my-image:lates`</span><span id="5906" class="mo ke iq mk b gy mt mq l mr ms">We will not cover the details of this apporach as it's troublesome and hard to implement in CI.</span></pre><h1 id="8536" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">为构建多CPU架构Docker映像编写Docker文件</h1><p id="af5e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">因为“buildx/buildkit”将使用一个<a class="ae kc" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank">docker文件</a>同时为所有目标平台构建docker映像。您的Docker文件需要能够为所有目标平台生成正确的Docker映像。</p><p id="d6da" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">即:</p><ul class=""><li id="adc7" class="mx my iq ld b le lz li ma lm mz lq na lu nb ly nc nd ne nf bi translated">使用的基本Docker映像应该是一个多拱映像，并支持您选择的平台(除非您在Docker文件中采用多阶段构建方法)</li><li id="b955" class="mx my iq ld b le ng li nh lm ni lq nj lu nk ly nc nd ne nf bi translated">用于构建Docker映像的所有脚本都应该编译/安装与容器中的目标平台相匹配的软件。</li></ul><p id="0fc8" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">为了确保基本映像支持您计划构建的所有CPU架构，您可以检查<a class="ae kc" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>上的映像操作系统/ARCH信息面板，如果它发布在Docker Hub上的话。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/6d900517e4e60454f9ba9ff0f702ce7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y1x3rd9tNEIyqdLxegO-rw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Docker Hub OS/Arch信息面板</figcaption></figure><p id="bd2b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">或者，您可以使用<code class="fe mu mv mw mk b"><a class="ae kc" href="https://docs.docker.com/engine/reference/commandline/manifest_inspect/" rel="noopener ugc nofollow" target="_blank">docker manifest inspect</a></code>命令直接检查基本映像清单。例如:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="3fdd" class="mo ke iq mk b gy mp mq l mr ms">docker manifest inspect docker.io/alpine:3.15</span></pre><p id="f821" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在选择了合适的基础映像之后，我们还需要确保我们的构建脚本安装/编译软件适合当前构建的目标平台。如果您使用操作系统附带的软件包管理器，这通常不是问题。例如<code class="fe mu mv mw mk b"><a class="ae kc" href="https://docs.alpinelinux.org/user-handbook/0.1a/Working/apk.html" rel="noopener ugc nofollow" target="_blank">apk</a></code> <code class="fe mu mv mw mk b"><a class="ae kc" href="https://linux.die.net/man/8/yum" rel="noopener ugc nofollow" target="_blank">yum</a></code>或<code class="fe mu mv mw mk b"><a class="ae kc" href="https://ubuntu.com/server/docs/package-management" rel="noopener ugc nofollow" target="_blank">apt</a></code>。因为它们会自动为您当前的平台安装正确的版本。但如果需要手动安装软件，就需要找出当前的构建平台(即OS &amp; CPU arch)。</p><p id="95f3" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这可以通过<a class="ae kc" href="https://docs.docker.com/engine/reference/builder/#automatic-platform-args-in-the-global-scope" rel="noopener ugc nofollow" target="_blank">docker在使用“buildkit”后端构建时自动设置的平台参数列表</a>来实现。它们是:</p><ul class=""><li id="6722" class="mx my iq ld b le lz li ma lm mz lq na lu nb ly nc nd ne nf bi translated"><code class="fe mu mv mw mk b">TARGETOS</code>:目标平台操作系统。例如<code class="fe mu mv mw mk b">linux</code></li><li id="27a5" class="mx my iq ld b le ng li nh lm ni lq nj lu nk ly nc nd ne nf bi translated"><code class="fe mu mv mw mk b">TARGETARCH</code>:目标平台CPU架构。例如<code class="fe mu mv mw mk b">arm64</code></li><li id="f15f" class="mx my iq ld b le ng li nh lm ni lq nj lu nk ly nc nd ne nf bi translated"><code class="fe mu mv mw mk b">TARGETVARIANT</code>:目标平台CPU架构变体。例如<code class="fe mu mv mw mk b">v8</code></li></ul><p id="b958" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">请注意:这些参数是在全局范围内定义的，因此在构建阶段或运行命令中不会自动提供。要在构建阶段公开这些参数之一，请将其重新定义为不带值。例如:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="062a" class="mo ke iq mk b gy mp mq l mr ms">FROM alpine:3.15</span><span id="9ff4" class="mo ke iq mk b gy mt mq l mr ms">ARG TARGETOS<br/>ARG TARGETARCH</span><span id="3d24" class="mo ke iq mk b gy mt mq l mr ms">RUN echo "I'm building for $<!-- -->TARGETOS/$TARGETARCH<!-- -->"</span></pre><p id="0bd9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">使用<code class="fe mu mv mw mk b">TARGETOS</code> &amp; <code class="fe mu mv mw mk b">TARGETARCH</code> ARG通过‘buildx’插件生成多拱Docker图像的完整Docker文件示例如下:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="4ab8" class="mo ke iq mk b gy mp mq l mr ms">FROM alpine:3.15</span><span id="9229" class="mo ke iq mk b gy mt mq l mr ms">ARG TARGETOS<br/>ARG TARGETARCH</span><span id="0483" class="mo ke iq mk b gy mt mq l mr ms">#`BUILDX_ARCH` will be used in the buildx package download URL <br/># The required format is in `TARGETOS-TARGETARCH`<br/># Set it default to linux-amd64 to make the Dockerfile <br/># works with / without buildkit</span><span id="b92f" class="mo ke iq mk b gy mt mq l mr ms">ENV BUILDX_ARCH="${TARGETOS:-linux}-${TARGETARCH:-amd64}"<br/>ENV BUILDX_VERSION="v0.6.3"</span><span id="d8c9" class="mo ke iq mk b gy mt mq l mr ms">RUN apk add --no-cache openssl ca-certificates wget docker docker-compose</span><span id="96c4" class="mo ke iq mk b gy mt mq l mr ms">RUN mkdir -p ~/.docker/cli-plugins &amp;&amp; \    <br/>    wget -nv -O ~/.docker/cli-plugins/docker-buildx https://github.com/docker/buildx/releases/download/${BUILDX_VERSION}/buildx-${BUILDX_VERSION}.${BUILDX_ARCH} &amp;&amp; \    <br/>    chmod a+x ~/.docker/cli-plugins/docker-buildx</span></pre><h1 id="e73e" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">具有多阶段构建多拱码头文件</h1><p id="679f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">您可能并不总能找到支持您计划构建的所有目标平台的基础映像。使用<a class="ae kc" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">多阶段构建</a>，可以根据docker文件中的当前构建平台(通过检查<code class="fe mu mv mw mk b">TARGETOS</code> &amp; <code class="fe mu mv mw mk b">TARGETARCH</code> ARG)有条件地选择不同的基础图像。</p><p id="51f8" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">下面是一个完整的Dockefile示例:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="87ee" class="mo ke iq mk b gy mp mq l mr ms"># Declare stage using linux/amd64 base image<br/>FROM --platform=linux/amd64 docker.elastic.co/elasticsearch/elasticsearch:6.8.22 as stage-amd64</span><span id="a3f6" class="mo ke iq mk b gy mt mq l mr ms"># Commands run only for linux/amd64 target platform<br/>RUN yum -y install sudo zip<br/>RUN find modules -type d -name "x-pack-*" -exec rm -r {} +<br/>COPY --chown=elasticsearch:elasticsearch component/elasticsearch.yml /usr/share/elasticsearch/config/</span><span id="a2eb" class="mo ke iq mk b gy mt mq l mr ms"># Declare stage using linux/arm64 base image<br/>FROM --platform=linux/arm64 data61/elasticsearch:6.8.22 as stage-arm64</span><span id="a19e" class="mo ke iq mk b gy mt mq l mr ms"># Commands run only for linux/arm64 target platform<br/>RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends sudo zip &amp;&amp; rm -rf /var/lib/apt/lists/*<br/>COPY --chown=elasticsearch:elasticsearch component/elasticsearch-arm64.yml /usr/share/elasticsearch/config/elasticsearch.yml </span><span id="b9af" class="mo ke iq mk b gy mt mq l mr ms"># Declare TARGETARCH to make it available<br/>ARG TARGETARCH</span><span id="eff8" class="mo ke iq mk b gy mt mq l mr ms"># Select final stage based on TARGETARCH ARG<br/>FROM stage-${TARGETARCH} as final</span><span id="9b19" class="mo ke iq mk b gy mt mq l mr ms"># Commands run at final stage for all target platforms<br/>ADD component/setup.sh /setup.shCOPY --chown=elasticsearch:elasticsearch component/wn_s.pl /usr/share/elasticsearch/config/analysis/<br/>COPY --chown=elasticsearch:elasticsearch component/regionSynonyms.txt /usr/share/elasticsearch/config/analysis/</span><span id="baa5" class="mo ke iq mk b gy mt mq l mr ms">CMD ["/setup.sh"]</span></pre><p id="24e1" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">请注意:Docker足够聪明，可以跳过当前建筑目标从不需要的阶段。因此，声明更多的阶段不会减慢你的构建过程。</p><h1 id="70b8" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">下一步是什么？</h1><p id="3661" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">到目前为止，我们已经讨论了在您的本地计算机上构建多CPU架构，无论它是英特尔PC还是苹果M1笔记本电脑。对于CI管道中的生产docker映像发布，请检查:</p><p id="d1f6" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><a class="ae kc" href="https://medium.com/p/295966b7185d" rel="noopener">为ARM和x86构建多CPU架构Docker映像(2):在GitLab CI中构建</a></p><p id="299c" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><a class="ae kc" href="https://medium.com/p/a382feab5af9" rel="noopener">为ARM和x86构建多CPU架构Docker映像(3):在GitHub Action CI中构建</a></p></div></div>    
</body>
</html>