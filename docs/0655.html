<html>
<head>
<title>chroot, cgroups and namespaces — An overview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">chroot、cgroups和名称空间—概述</h1>
<blockquote>原文：<a href="https://itnext.io/chroot-cgroups-and-namespaces-an-overview-37124d995e3d?source=collection_archive---------1-----------------------#2018-05-01">https://itnext.io/chroot-cgroups-and-namespaces-an-overview-37124d995e3d?source=collection_archive---------1-----------------------#2018-05-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3c05b91b2da21d1353a59fa9cf65eced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p4qIz4aRRF4K5Vsakp5iEg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/photos/hXOGHaGCtdA?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Aron Van de Pol </a>在<a class="ae kc" href="https://unsplash.com/search/photos/linux?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="bd72" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h1><p id="4cba" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">随着所有与Docker、容器和虚拟化相关的讨论，程序员了解这些将在日常编程中帮助他们的技术变得越来越重要。我将尝试记录Docker类应用程序背后的技术。</p><h1 id="2cd8" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">根和色根</h1><p id="a11e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在类Unix操作系统中，根目录(/)是顶层目录。根文件系统位于根目录所在的同一磁盘分区上。所有其他文件系统都是在这个根文件系统之上挂载的。所有文件系统条目都从这个根目录分支出来。这是系统的实际根目录。</p><p id="8645" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">但是每个进程都有自己的根目录概念。默认情况下，它是实际的系统根，但是我们可以通过使用<code class="fe me mf mg mh b">chroot()</code>系统调用来改变它。我们可以有一个不同的根，这样我们就可以创建一个单独的运行环境，这样就可以更容易地运行和调试流程。或者也可以为该过程使用遗留的依赖项和库。</p><p id="fdff" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><code class="fe me mf mg mh b"><strong class="ld ir">chroot</strong></code> <strong class="ld ir">改变当前运行进程及其子进程的表观根目录。</strong></p><p id="7cba" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">似乎通过使用<code class="fe me mf mg mh b">chroot()</code>分离一个进程，我们通过限制进程不能访问其环境之外的内容来确保安全性。但事实上，这并不完全正确。<code class="fe me mf mg mh b">chroot()</code>简单地修改进程及其子进程的路径名查找，将新的根路径添加到以<code class="fe me mf mg mh b">/</code>开头的任何名称之前。当前目录未被修改，相对路径可以引用新根目录之外的任何位置。</p><p id="743a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">所以，</strong> <code class="fe me mf mg mh b"><strong class="ld ir">chroot()</strong></code> <strong class="ld ir">不提供安全的沙箱来测试一个软件。</strong></p><h1 id="5c27" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">cgroups-隔离和管理资源</h1><p id="7cd9" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">控制组(cgroups)是一个Linux内核特性，它限制、隔离和测量一组进程的资源使用情况。可以设置内存、CPU、网络和IO的资源配额。在Linux 2.6.24中，这些是Linux内核的一部分。</p><p id="5d71" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">尽管Linux在处理和共享进程间的可用资源方面表现出色，但有时我们希望更好地控制资源。我们希望为一组进程分配或保证一定数量的资源。我们用cgroups做这个。这隔离了应用程序/组的资源。</p><p id="8b22" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">假设我们有一个想要隔离使用的应用程序。让我们称它为A1。我们将创建一个控制组，并对其分配资源限制:比如3GB的内存限制和70%的CPU。然后，我们可以将必需的应用程序的进程id添加到组中，现在应用程序资源的使用得到了控制。虽然应用程序可能会超出正常情况下的限制，但在系统面临资源短缺的情况下，它会被限制回预设的限制。当我们处理在一台机器上运行的许多虚拟机时，这就更有意义了——为虚拟机建立一个cgroup，并在发生资源争用时将它们单独限制在一个设定的限制范围内。</p><ul class=""><li id="72b3" class="mi mj iq ld b le lz li ma lm mk lq ml lu mm ly mn mo mp mq bi translated">定义问题的解决方案</li><li id="8ceb" class="mi mj iq ld b le mr li ms lm mt lq mu lu mv ly mn mo mp mq bi translated">创建一个cgroup来处理分配</li><li id="16da" class="mi mj iq ld b le mr li ms lm mt lq mu lu mv ly mn mo mp mq bi translated">将应用程序添加到组中。</li><li id="eea1" class="mi mj iq ld b le mr li ms lm mt lq mu lu mv ly mn mo mp mq bi translated">继续监视组(作为cgroups的一部分发生，我们不需要显式处理)</li></ul><p id="954d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">要安装cgroups，</p><p id="c18f" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><code class="fe me mf mg mh b">sudo apt-get install cgroup-bin cgroup-lite cgroup-tools cgroupfs-mount libcgroup1</code></p><p id="d12b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们可以看到创建了一个<code class="fe me mf mg mh b">/cgroup</code>目录:它被用作cgroup虚拟文件系统的挂载点。<code class="fe me mf mg mh b">etc/cgconfig.conf</code>文件给出了所有坐骑的预期信息。所有控制器都挂载到/cgroup，后跟控制器名称。要安装必要的控制器，运行<code class="fe me mf mg mh b">sudo service cgconfig restart</code>。接下来我们看到/cgroup中的目录，每个目录都可以用来管理一个cgroup子系统。</p><h2 id="b754" class="mw ke iq bd kf mx my dn kj mz na dp kn lm nb nc kr lq nd ne kv lu nf ng kz nh bi translated">创建cgroups</h2><p id="5f62" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">现在我们看到控制器安装在/cgroup上，让cd进入其中的任何目录，比如/cgroup/memory，并在其中创建一个子目录。</p><p id="a994" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><code class="fe me mf mg mh b">mkdir mytest</code></p><p id="cbd1" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">当我们<code class="fe me mf mg mh b">cd</code>进入这个子目录时，除了一个文件<code class="fe me mf mg mh b">release_agent</code>之外，它几乎与父目录相似。现在我们在<code class="fe me mf mg mh b">cgroup</code>下有了一个内存子系统，它的子节点<code class="fe me mf mg mh b">mytest</code>是cgroup。让我们创建一个测试函数来测试我们的节流假设:</p><pre class="ni nj nk nl gt nm mh nn no aw np bi"><span id="1550" class="mw ke iq mh b gy nq nr l ns nt">#include&lt;iostream&gt;</span><span id="9391" class="mw ke iq mh b gy nu nr l ns nt">#include &lt;new&gt;</span><span id="4221" class="mw ke iq mh b gy nu nr l ns nt">#include &lt;cstdlib&gt;</span><span id="a495" class="mw ke iq mh b gy nu nr l ns nt">int main()</span><span id="db3c" class="mw ke iq mh b gy nu nr l ns nt">{</span><span id="b1c5" class="mw ke iq mh b gy nu nr l ns nt">int i=0;</span><span id="df4a" class="mw ke iq mh b gy nu nr l ns nt">char* ptr =NULL;</span><span id="1798" class="mw ke iq mh b gy nu nr l ns nt">while(i&lt;50){</span><span id="5f05" class="mw ke iq mh b gy nu nr l ns nt">if ((ptr =(char*)malloc(1048576)) == NULL) {///1MB allocated</span><span id="ab59" class="mw ke iq mh b gy nu nr l ns nt">std::cout &lt;&lt; "Allocation fails at " &lt;&lt; i &lt;&lt; "MB\n";</span><span id="f58a" class="mw ke iq mh b gy nu nr l ns nt">return 0;</span><span id="8ed5" class="mw ke iq mh b gy nu nr l ns nt">}</span><span id="592c" class="mw ke iq mh b gy nu nr l ns nt">std::cout &lt;&lt; "Allocated "&lt;&lt; i+1 &lt;&lt; "MB\n";</span><span id="d624" class="mw ke iq mh b gy nu nr l ns nt">i++;</span><span id="ccd5" class="mw ke iq mh b gy nu nr l ns nt">}</span><span id="a2f6" class="mw ke iq mh b gy nu nr l ns nt">std::cout &lt;&lt; "Finished allocation";</span><span id="e6c2" class="mw ke iq mh b gy nu nr l ns nt">return 0;</span><span id="560e" class="mw ke iq mh b gy nu nr l ns nt">}</span></pre><p id="fb01" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">编译并运行上面的C++代码，我们看到所有的50 MB都已分配，最后一行“完成分配”被打印出来。这没有分配任何内存配额。让我们把<code class="fe me mf mg mh b">cd</code>变成<code class="fe me mf mg mh b">cgroup/memory/mytest</code>。我们将使用两个文件分别将物理内存和交换内存的内存限制设置为2MB:<code class="fe me mf mg mh b">mytest/memory.limit_in_bytes</code>和<code class="fe me mf mg mh b">mytest/memory.memsw.limit_in_bytes</code>。设置交换限制是为了实施一个硬限制，这样一旦达到2MB内存限制，它就不会开始消耗交换空间。</p><pre class="ni nj nk nl gt nm mh nn no aw np bi"><span id="5df2" class="mw ke iq mh b gy nq nr l ns nt">echo 2097152 &gt; /cgroup/memory/mytest/memory.limit_in_bytes<br/>echo 2097152 &gt; /cgroup/memory/mytest/<!-- -->memory.memsw.limit_in_bytes</span></pre><p id="0782" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">现在，我们可以使用<a class="ae kc" href="https://linux.die.net/man/1/cgexec" rel="noopener ugc nofollow" target="_blank"> cgexec </a>命令运行我们的上述程序。</p><pre class="ni nj nk nl gt nm mh nn no aw np bi"><span id="a09d" class="mw ke iq mh b gy nq nr l ns nt">cgexec -g memory:mytesttest ./&lt;binary_name&gt;</span></pre><p id="5b14" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这将运行内存测试组中的代码，当达到2MB分配限制时，进程将被终止。</p><p id="b469" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">像内存一样，我们可以为CPU、磁盘IO或网络IO分组，并根据预定义的限制来调节应用程序。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="f669" class="kd ke iq bd kf kg oc ki kj kk od km kn ko oe kq kr ks of ku kv kw og ky kz la bi translated">Linux名称空间</h1><p id="769e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Linux进程形成了一个单一的层次结构，所有进程都以<code class="fe me mf mg mh b">init</code>为根。通常这个树中的特权进程可以跟踪或终止其他进程。Linux名称空间使我们能够拥有许多带有自己的“子树”的进程层次结构，这样一个子树中的进程就不能访问甚至不知道另一个子树中的进程。</p><p id="3384" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">名称空间包装全局资源，使得在该名称空间中的进程看起来具有它们自己的所述资源的隔离实例。让我们以PID名称空间为例。如果不涉及命名空间，所有进程都从PID 1(init)开始分层下降。如果我们创建一个PID名称空间，并在其中运行一个进程，那么第一个进程将成为该名称空间中的PID 1。在本例中，我们包装了一个全局系统资源(进程id)。创建命名空间的进程仍保留在父命名空间中，但使其子进程成为新进程树的根。</p><p id="0d1b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">但这仅意味着新命名空间内的进程看不到父进程，但父进程命名空间可以看到子命名空间。新名称空间中的进程现在有两个PID:一个用于新名称空间，一个用于全局名称空间。</p><p id="bbca" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">Linux内核现在使用upid结构而不是单一的pid值来跟踪进程的pid。upid结构告诉我们pid和该pid有效的名称空间。</p><pre class="ni nj nk nl gt nm mh nn no aw np bi"><span id="8cb1" class="mw ke iq mh b gy nq nr l ns nt">struct upid {<br/>	int nr;			/* moved from struct pid */<br/>	struct pid_namespace *ns;	/* the namespace this value<br/>						 * is visible in<br/>						 */<br/>	...<br/>    };<br/>    struct pid {<br/>	atomic_t count;<br/>	struct hlist_head tasks[PIDTYPE_MAX];<br/>	struct rcu_head rcu;<br/>	int level;		/* the number of upids */<br/>	struct upid numbers[0];<br/>    };</span></pre><h2 id="1e21" class="mw ke iq bd kf mx my dn kj mz na dp kn lm nb nc kr lq nd ne kv lu nf ng kz nh bi translated">命名空间的类型</h2><p id="3747" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Linux提供了以下名称空间:</p><ul class=""><li id="f769" class="mi mj iq ld b le lz li ma lm mk lq ml lu mm ly mn mo mp mq bi translated">cgroup:这将隔离Cgroup根目录(<strong class="ld ir"> CLONE_NEWCGROUP </strong>)</li><li id="120c" class="mi mj iq ld b le mr li ms lm mt lq mu lu mv ly mn mo mp mq bi translated">IPC:隔离System V IPC、POSIX消息队列(<strong class="ld ir"> CLONE_NEWIPC </strong>)</li><li id="ffc1" class="mi mj iq ld b le mr li ms lm mt lq mu lu mv ly mn mo mp mq bi translated">网络:隔离网络设备、端口等(<strong class="ld ir"> CLONE_NEWNET </strong>)</li><li id="7373" class="mi mj iq ld b le mr li ms lm mt lq mu lu mv ly mn mo mp mq bi translated">挂载:隔离挂载点(<strong class="ld ir"> CLONE_NEWNS </strong>)</li><li id="777f" class="mi mj iq ld b le mr li ms lm mt lq mu lu mv ly mn mo mp mq bi translated">PID:隔离的进程id(<strong class="ld ir">CLONE _ NEWPID</strong>)</li><li id="d1f6" class="mi mj iq ld b le mr li ms lm mt lq mu lu mv ly mn mo mp mq bi translated">用户:隔离用户和组id(<strong class="ld ir">CLONE _ new User</strong>)</li><li id="dfd0" class="mi mj iq ld b le mr li ms lm mt lq mu lu mv ly mn mo mp mq bi translated">UTS:隔离主机名和NIS域名(<strong class="ld ir"> CLONE_NEWUTS </strong>)</li></ul><p id="6cf8" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">作为名称空间管理的一部分，Linux提供了以下API:</p><ul class=""><li id="90a6" class="mi mj iq ld b le lz li ma lm mk lq ml lu mm ly mn mo mp mq bi translated"><strong class="ld ir"> <em class="oh">【克隆()】</em></strong>——普通旧克隆()创建新流程。如果我们将一个或多个CLONE_NEW* <strong class="ld ir"> </strong>标志传递给CLONE()，那么将为每个<br/>标志创建新的名称空间，并且子进程将成为这些<br/>名称空间的成员。</li><li id="e537" class="mi mj iq ld b le mr li ms lm mt lq mu lu mv ly mn mo mp mq bi translated"><strong class="ld ir"> <em class="oh"> setns() </em> </strong> -允许一个进程加入一个已有的名称空间。命名空间由引用一个<code class="fe me mf mg mh b">proc/[pid]/ns</code>文件的文件描述符指定。</li><li id="b7ae" class="mi mj iq ld b le mr li ms lm mt lq mu lu mv ly mn mo mp mq bi translated">unshare()-将调用进程移动到根据CLONE_NEW*参数创建的新名称空间。可以指定多个这样的标志。</li></ul><p id="7b29" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">注意:对于PID命名空间，必须调用clone()，因为只有在创建新进程时才能创建clone()。克隆()产生的进程的pid为1。对于PID命名空间，unshare()没有用。</p><h2 id="e323" class="mw ke iq bd kf mx my dn kj mz na dp kn lm nb nc kr lq nd ne kv lu nf ng kz nh bi translated">网络命名空间</h2><p id="5ad9" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">假设我们有了新的PID名称空间。位于这个新名称空间中的进程在端口80上监听传入的请求。这意味着整个系统中的所有其他进程<strong class="ld ir"/>。被阻止监听它。这不是很有帮助的隔离。这就是网络名称空间的由来。</p><p id="ec5f" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">网络名称空间帮助内部进程看到不同的网络接口集——包括<code class="fe me mf mg mh b">lo</code>接口！但这只是故事的一半。当我们有新的网络名称空间时，我们必须设置跨越许多名称空间的虚拟网络接口，以及在全局名称空间中运行的路由过程，以处理流量并将其路由到正确的名称空间。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="d066" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">与上面的名称空间一样，其他名称空间隔离特定的全局资源，并将内部进程的访问限制在自己的沙箱中。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="41b9" class="kd ke iq bd kf kg oc ki kj kk od km kn ko oe kq kr ks of ku kv kw og ky kz la bi translated">结论</h1><p id="d2fc" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们看到了chroot、cgroups和namespaces的简要概述，它们为Linux开发人员提供了将进程隔离到他们自己的“容器”中的方法。这些技术是现在无处不在的Docker或Linux容器的基础。我将试着在这篇文章之后介绍Docker更具体的内部情况。</p><p id="f4aa" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">参考资料:</p><div class="oi oj gp gr ok ol"><a href="https://wiki.archlinux.org/index.php/cgroups" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">cgroups-archi wiki</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">cgroups(又名control groups)是一个Linux内核特性，用于限制、监管和计算一组…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">wiki.archlinux.org</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz jw ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://sysadmincasts.com/episodes/14-introduction-to-linux-control-groups-cgroups" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">Linux控制组(Cgroups)简介</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">在这一集里，我们将回顾控制组(cgroups ),它提供了一种机制来方便地管理和…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">sysadmincasts.com</p></div></div><div class="ou l"><div class="pa l ow ox oy ou oz jw ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="http://man7.org/linux/man-pages/man7/namespaces.7.html" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">名称空间(7) - Linux手册页</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">名称空间将全局系统资源包装在一个抽象中，使其对名称空间内的进程可见…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">man7.org</p></div></div><div class="ou l"><div class="pb l ow ox oy ou oz jw ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://lwn.net/Articles/259217/" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">2.6.24内核中的PID名称空间[LWN.net]</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">即将到来的2.6.24内核中的新特性之一将是OpenVZ团队开发的PID名称空间支持…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">lwn.net</p></div></div><div class="ou l"><div class="pc l ow ox oy ou oz jw ol"/></div></div></a></div></div></div>    
</body>
</html>