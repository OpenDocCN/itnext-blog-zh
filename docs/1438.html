<html>
<head>
<title>Easy patterns: Composite</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单模式:复合</h1>
<blockquote>原文：<a href="https://itnext.io/easy-patterns-composite-8b28aa1f158?source=collection_archive---------6-----------------------#2018-10-13">https://itnext.io/easy-patterns-composite-8b28aa1f158?source=collection_archive---------6-----------------------#2018-10-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/dd1f7de7dd648c2276f44a2e68637aee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b--Yigilhy6MlpJ9crVR7Q.png"/></div></div></figure><p id="ed32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文是easy patterns系列描述的延续，介绍了一种复合模式，它解决了如何在一组不同的对象之间使用递归组合的问题，因此客户不必进行这种区分。</p><h2 id="a875" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">创作模式:</h2><blockquote class="lp lq lr"><p id="fa0f" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-simple-factory-b946a086fd7e"> <strong class="ka ir">简易工厂</strong> </a></p><p id="2004" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-factory-method-5f27385ac5c"> <strong class="ka ir">工厂法</strong> </a></p><p id="8fab" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-builder-d85655bcf8aa"> <strong class="ka ir">构建器</strong> </a></p><p id="0e6b" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-singleton-283356fb29bf"> <strong class="ka ir">单个</strong> </a></p><p id="73db" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-abstract-factory-2325cb398fc6"> <strong class="ka ir">抽象工厂</strong> </a></p><p id="9d90" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-prototype-e03ec6962f89"> <strong class="ka ir">原型</strong> </a></p></blockquote><h2 id="b2ad" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">结构模式:</h2><blockquote class="lp lq lr"><p id="4425" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-adapter-9b5806cb346f"> <strong class="ka ir">适配器</strong> </a></p><p id="5343" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-decorator-eaa96c0550ea"> <strong class="ka ir">装饰者</strong> </a></p><p id="a7f3" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-bridge-28d50dc25f9f"> <strong class="ka ir">桥</strong> </a></p><p id="2353" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-composite-8b28aa1f158"> <strong class="ka ir">复合</strong> </a> <strong class="ka ir"> </strong> <em class="iq">(本文)</em></p><p id="2cca" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-facade-8cb185f4f44f"> <strong class="ka ir">立面</strong> </a></p><p id="9d1e" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-flyweight-dab4c018f7f5"> <strong class="ka ir">飞锤</strong> </a></p><p id="b7f6" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-proxy-45fc3a648020"> <strong class="ka ir">代理</strong> </a></p></blockquote><h2 id="c975" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">行为模式:</h2><blockquote class="lp lq lr"><p id="052a" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-visitor-b8ef57eb957"> <strong class="ka ir">来访者</strong> </a></p><p id="8f4d" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-mediator-e0bf18fefdf9"> <strong class="ka ir">调解员</strong> </a></p><p id="ee43" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-observer-63c832d41ffd"> <strong class="ka ir">观察者</strong> </a></p><p id="2da6" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-memento-ce966cec7478"> <strong class="ka ir">纪念物</strong> </a></p><p id="e199" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-iterator-f5c0dd85957"> <strong class="ka ir">迭代器</strong> </a></p><p id="f257" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-chain-of-responsibility-9a84307ad837"> <strong class="ka ir">责任链</strong> </a></p><p id="e67d" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-strategy-ecb6f6fc0ef3"> <strong class="ka ir">策略</strong> </a></p><p id="05de" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-state-ec87a1a487b4">状态<strong class="ka ir">状态</strong>状态</a></p></blockquote><h1 id="370f" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">主要本质</h1><p id="0b25" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">复合模式有助于以统一的顺序操作单独的对象。这是可能的，因为特殊的类对象为合成集中的所有参与者声明了公共表示操作。</p><p id="4ee0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种模式包括三个主要角色:</p><ul class=""><li id="deab" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated"><strong class="ka ir">组件</strong> —声明组合中对象的接口并实现默认行为(基于组合)</li><li id="e2f2" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated"><strong class="ka ir">叶子</strong> —代表构图中的图元对象</li><li id="2e89" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated"><strong class="ka ir">复合</strong> —在组件接口中实现子相关操作，并存储叶(原语)对象。</li></ul><p id="b0f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">客户端使用组件接口与合成集中的对象进行交互。如果接收者是一个简单的对象(叶子)，那么请求直接由这个简单的对象处理。如果接收方是一个复合组件，它通常会将请求转发给子组件。For composite也通常执行一些挂钩前和挂钩后操作。</p><h1 id="c0bd" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">使用示例</h1><p id="3176" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">在这个例子中，我们处理获取一个具体组织的雇员的平均工资。一个组织将雇员存储在一个数组中，可以计算所有雇员的平均工资。</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ae26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个简单的用法表示，当组织只能存储典型的雇员时(使用<code class="fe nn no np nq b">name</code>和<code class="fe nn no np nq b">getSalary</code>方法)。</p><p id="2690" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要感受模式的强大功能，只需想象一下这样一种情况:父组织不仅可以存储雇员，还可以存储子组织。所有需要做的就是为这样的子组织实现<code class="fe nn no np nq b">getSalary</code>方法，它将返回其内部雇员的平均工资。这样，调用母公司的<code class="fe nn no np nq b">avgSalary</code>将不会中断，并且结果将是所有员工的平均工资，无论是直接在母公司工作还是通过子公司工作。</p><h1 id="a63d" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">利润</h1><p id="0c5d" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">这种模式使客户端变得简单。客户可以以类似的方式处理单个或组合结构。这使得客户端代码更简单，因为它避免了为简单和复杂对象的类编写case语句函数。</p><p id="e033" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种模式使得添加新类型的组件变得容易。新创建的项自动与现有的结构和客户端代码一起工作。</p><h1 id="9ca5" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">薄弱的地方</h1><p id="64ab" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">另一方面，这种模式可以让你的设计更加通用。这使得限制组合的组件变得更加困难(例如，您希望组合只包含某些组件)。这种方法迫使您使用运行时检查。</p><h1 id="1e85" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">结论</h1><p id="04ed" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">复合模式通常与其他模式一起使用，如:</p><ul class=""><li id="77f0" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated">装饰者(Decorator)——当与组合一起使用时，它们通常有一个共同的父元素，所以装饰者必须支持组件接口，如添加、删除等。</li><li id="38ce" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-flyweight-dab4c018f7f5"> Flyweight </a> —让你共享组件。</li><li id="16df" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">迭代器—允许您遍历复合对象。</li><li id="78d3" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-visitor-b8ef57eb957">访问者</a> —本地化操作和行为，否则这些操作和行为将分布在复合类中。</li></ul><p id="dc2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您觉得这篇文章有帮助，请点击👏按钮并在下面随意评论！</p></div></div>    
</body>
</html>