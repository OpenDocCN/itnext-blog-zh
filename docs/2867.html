<html>
<head>
<title>Dependency Injection in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的依赖注入</h1>
<blockquote>原文：<a href="https://itnext.io/dependency-injection-in-react-6fcdbd2005e6?source=collection_archive---------0-----------------------#2019-08-18">https://itnext.io/dependency-injection-in-react-6fcdbd2005e6?source=collection_archive---------0-----------------------#2019-08-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/736bf19d3c55c487258f5b4af4a1809b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xqA2wa7A-y_PN9sG5-HyqA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">使用依赖注入，你知道如何打开一扇门，但是你不知道谁在门后。</figcaption></figure><p id="6034" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi ld translated">软件开发中最具挑战性的部分之一是保持代码的整洁、可维护和可扩展。<a class="ae lm" href="https://en.wikipedia.org/wiki/Robert_C._Martin" rel="noopener ugc nofollow" target="_blank"> Robert C. Martin </a>介绍了五个软件设计原则，揭示了被称为<a class="ae lm" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank"> SOLID </a>的面向对象设计的依赖管理方面。其中之一是依赖倒置原则，即“<em class="ln">依赖抽象，而不是具体”。实现这一原则的模式被称为依赖注入(DI)。这种模式使得分解程序组件、编写单元测试甚至在运行时提供模块变得更加容易。</em></p><p id="8f08" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在<a class="ae lm" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>中，javascript库DI是通过<a class="ae lm" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文</a>完成的。让我们看一下异步Web存储项目，在这个项目中，我将应用React上下文来使用不同的机制存储数据。</p><h1 id="0d02" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">异步Web存储</h1><p id="2920" class="pw-post-body-paragraph kf kg it kh b ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky mq la lb lc im bi translated">这种网络存储将支持三种操作:查找、向上插入和删除。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mr"><img src="../Images/ef7d4dd3413afa97de1fb997d56d81f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aAFHa6Rs7WBgKBXXgdkMgg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图一。抽象AsyncWebStorage。</figcaption></figure><p id="4606" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一个简单的具体实现是内存存储。但是这个想法可以扩展到localStorage/sessionStorage、AWS S3等等。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mw"><img src="../Images/f24355367797876537ad4cd6eb8c1e14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HIDYRj8XGNreiMfftfd-MQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图二。简单的内存异步网络存储。</figcaption></figure><p id="7743" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">默认情况下，我将使用React上下文来提供内存中的实现。内存和s3存储都将暴露在外。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/ead974b6b58894624d2d37ea1fc89627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rUSdy68qhYs4SLeQuvlFVQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图3。默认情况下，使用内存存储对上下文初始化做出反应。</figcaption></figure><p id="7a27" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们创建一个简单的React组件Foo，它将从存储中读取数据。它将只依赖于通过<strong class="kh iu"> AsyncWebStorageContext </strong>注入的抽象(图4)。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/c82a05508135138605fe303072db1afe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JddZawsj8ljt-ym-r-_peQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图4。抽象Web存储是通过React上下文注入的。</figcaption></figure><p id="1fb1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">使用<strong class="kh iu"> AsyncWebStorageContext进行存储之间的切换。提供商</strong>(图5)。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/d329371eff20fbd560d019f9ad81e3c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w6FyXzku5JuwFdY7rRD9WQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图5。第一个Foo组件从内存中读取，第二个组件从s3中读取。</figcaption></figure><p id="fd8c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因此，我们有可视化组件Foo和不同的异步Web存储实现，它们是独立的，可以并行开发，并且可以扩展。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="ab16" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">今天，这种模式被广泛使用，甚至在一些现代语言(如Scala)中构建，但通常它是由库或框架实现的。React库通过上下文内置了对DI的支持。通过公开抽象，使用DI代码变得更容易跟踪和维护，并且整个应用程序更加灵活和易于扩展。</p></div></div>    
</body>
</html>