<html>
<head>
<title>Cache components with Angular RouteReuseStrategy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用角度路由策略缓存组件</h1>
<blockquote>原文：<a href="https://itnext.io/cache-components-with-angular-routereusestrategy-3e4c8b174d5f?source=collection_archive---------0-----------------------#2018-11-09">https://itnext.io/cache-components-with-angular-routereusestrategy-3e4c8b174d5f?source=collection_archive---------0-----------------------#2018-11-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4377c4a4ba58dd2ab82f0328f00eec2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4rOO6B_Y1iErF31qEezC2w.jpeg"/></div></div></figure><p id="8f79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://angular.io/api/router/RouteReuseStrategy" rel="noopener ugc nofollow" target="_blank">routereustrategy</a>供应商允许控制角度路线和组件生命周期的行为。</p><p id="e364" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每次我们在组件之间导航时，Angular都会破坏之前的组件并创建新的组件。在许多情况下，我们可能不希望这样，因为每次我们加载一个组件，我们可能会再次运行昂贵的操作，如http请求。</p><p id="eb16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于这个服务的文档并不多，所以我决定写下一些文档，并附上一个例子。</p><h1 id="20b0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">它是如何工作的？</h1><p id="e738" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><strong class="ka ir">routerusestrategy</strong>接口定义了5种方法:</p><ul class=""><li id="5f4a" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><em class="mj"> shouldReuseRoute </em>每当我们在路线之间导航<strong class="ka ir">时，这个方法就会被调用。<em class="mj">未来</em>是我们要离开的路线(不确定为什么叫未来)<em class="mj">当前</em>是我们要着陆的路线。如果返回TRUE，则路由不会发生(这意味着路由没有改变)。如果它返回FALSE，那么路由发生，其余的方法被调用。</strong></li></ul><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="d0f4" class="mt ky iq mp b gy mu mv l mw mx">shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean {<br/>  // default action <br/>  return future.routeConfig === curr.routeConfig;<br/>}</span></pre><ul class=""><li id="4383" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><em class="mj"> shouldAttach </em>:当我们在这条路线的组件上着陆时，刚刚打开的<em class="mj">路线</em> <strong class="ka ir">调用这个方法。一旦组件被加载，这个方法被调用。如果该方法返回TRUE，那么将调用<em class="mj">检索</em>方法，否则将从头开始创建组件:</strong></li></ul><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="3256" class="mt ky iq mp b gy mu mv l mw mx">shouldAttach(route: ActivatedRouteSnapshot): boolean;</span></pre><ul class=""><li id="21d9" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><em class="mj"> retrieve </em>:如果<em class="mj"> shouldAttach </em>返回TRUE，则调用该方法，提供当前<em class="mj">路线</em>(我们刚刚着陆)作为参数，并返回一个存储的<em class="mj"> RouteHandle </em>。如果返回null，则没有任何效果。我们可以使用这种方法手动获取任何存储的<em class="mj"> RouteHandle </em>。这不是由框架自动管理的。我们有责任实施它:</li></ul><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="c2cf" class="mt ky iq mp b gy mu mv l mw mx">retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null;</span></pre><ul class=""><li id="02f8" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><em class="mj"> shouldDetach </em>:当我们<strong class="ka ir">离开当前</strong> <em class="mj">路径</em>时调用。如果返回TRUE，那么将调用<em class="mj">存储</em>方法:</li></ul><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="9b23" class="mt ky iq mp b gy mu mv l mw mx">shouldDetach(route: ActivatedRouteSnapshot): boolean;</span></pre><ul class=""><li id="4d3e" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><em class="mj"> store </em>:只有当<em class="mj"> shouldDetach </em>返回true时，才会调用该方法。我们可以在这里管理如何存储<em class="mj">例程句柄。</em>我们在这里存储的内容将在<em class="mj">检索</em>方法中使用。它提供了我们要离开的路线和<em class="mj">路线手柄</em>:</li></ul><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="86ff" class="mt ky iq mp b gy mu mv l mw mx">store(route: ActivatedRouteSnapshot, detachedTree: DetachedRouteHandle): void;</span></pre><h1 id="a492" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用示例</h1><p id="4dc7" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">让我们看一个典型的例子:</p><ol class=""><li id="4926" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv my mg mh mi bi translated"><strong class="ka ir">搜索表单组件</strong>加载<em class="mj">/搜索表单</em>路径。我们进行搜索</li><li id="ff39" class="ma mb iq ka b kb mz kf na kj nb kn nc kr nd kv my mg mh mi bi translated">导航到<em class="mj">/搜索结果</em>路径，该路径加载<em class="mj"> </em> <strong class="ka ir">搜索结果组件</strong></li><li id="ad43" class="ma mb iq ka b kb mz kf na kj nb kn nc kr nd kv my mg mh mi bi translated">点击一个结果并导航到<em class="mj"> /detail/1 </em>，加载<em class="mj"> </em> <strong class="ka ir">细节组件</strong></li><li id="dc78" class="ma mb iq ka b kb mz kf na kj nb kn nc kr nd kv my mg mh mi bi translated">点击浏览器后退按钮返回导航到<em class="mj">/搜索结果</em>路径，再次加载<em class="mj"> </em> <strong class="ka ir">搜索结果组件</strong></li></ol><p id="f8a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">步骤<strong class="ka ir"> 4 </strong>将导致<strong class="ka ir">搜索结果组件</strong>再次运行相同的搜索，向API发出无用的GET请求。</p><p id="b0f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们希望缓存并避免在步骤<strong class="ka ir"> 4 </strong>完全重新加载搜索结果组件(并保留滚动),并且仅在从步骤<strong class="ka ir"> 1 </strong>导航到步骤<strong class="ka ir"> 2时重新加载。</strong></p><p id="3c29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">cache-route-reuse . strategy . ts:</strong></p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="6b37" class="mt ky iq mp b gy mu mv l mw mx">import { RouteReuseStrategy } from '@angular/router/';<br/>import { ActivatedRouteSnapshot, DetachedRouteHandle } from '@angular/router';<br/>export class CacheRouteReuseStrategy implements RouteReuseStrategy {<br/>storedRouteHandles = new Map&lt;string, DetachedRouteHandle&gt;();</span><span id="868e" class="mt ky iq mp b gy ne mv l mw mx">allowRetriveCache = {<br/>  'search-results': true<br/>};</span><span id="f7ba" class="mt ky iq mp b gy ne mv l mw mx">shouldReuseRoute(before: ActivatedRouteSnapshot, curr:  ActivatedRouteSnapshot): boolean {</span><span id="552a" class="mt ky iq mp b gy ne mv l mw mx">if (this.getPath(before) === 'detail' &amp;&amp; this.getPath(curr) === 'search-result') {    <br/>    this.allowRetriveCache['search-results'] = true;<br/>  } else {<br/>    this.allowRetriveCache['search-results'] = false;<br/>  }</span><span id="ae3e" class="mt ky iq mp b gy ne mv l mw mx">  return before.routeConfig === curr.routeConfig;<br/>}</span><span id="f73d" class="mt ky iq mp b gy ne mv l mw mx">retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null {<br/>  return this.storedRouteHandles.get(this.getPath(route)) as DetachedRouteHandle;<br/>}</span><span id="8b67" class="mt ky iq mp b gy ne mv l mw mx">shouldAttach(route: ActivatedRouteSnapshot): boolean {<br/>  const path = this.getPath(route);<br/>  if (this.allowRetriveCache[path]) {<br/>    return this.storedRouteHandles.has(this.getPath(route));<br/>  }<br/>  <br/>  return false;<br/>}</span><span id="2ef4" class="mt ky iq mp b gy ne mv l mw mx">shouldDetach(route: ActivatedRouteSnapshot): boolean {<br/>  const path = this.getPath(route);<br/>  if (this.allowRetriveCache.hasOwnProperty(path)) {<br/>    return true;<br/>  }</span><span id="e609" class="mt ky iq mp b gy ne mv l mw mx">  return false;<br/>}</span><span id="09a6" class="mt ky iq mp b gy ne mv l mw mx">store(route: ActivatedRouteSnapshot, detachedTree: DetachedRouteHandle): void {<br/>  this.storedRouteHandles.set(this.getPath(route), detachedTree);<br/>}</span><span id="bfad" class="mt ky iq mp b gy ne mv l mw mx">private getPath(route: ActivatedRouteSnapshot): string {<br/>  if (route.routeConfig !== null &amp;&amp; route.routeConfig.path !== null) {<br/>    return route.routeConfig.path;<br/>  }</span><span id="6e50" class="mt ky iq mp b gy ne mv l mw mx">  return '';<br/>}<br/>}</span></pre><p id="c8e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> app.module.ts </strong>在<em class="mj"> providers </em>配置中插入复用策略的提供者:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="6f04" class="mt ky iq mp b gy mu mv l mw mx">...<br/>providers: [{<br/>  provide: RouteReuseStrategy,<br/>  useClass: CacheRouteReuseStrategy<br/>}],<br/>...</span></pre><p id="fb39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用<em class="mj"> shouldReuseRoute </em>方法只是为了理解导航流程:用户是从细节组件导航回搜索结果组件吗？如果是，则加载搜索结果的最后一个缓存组件(<em class="mj">should attach</em>=&gt;true，<em class="mj"> retrieve </em>被调用)，如果否，则重新创建组件并执行新的搜索。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="f1eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于Angular网站上的文档缺乏这方面的内容，所以我尝试对RouteReuseStrategy进行了详细的描述。<em class="mj"> shouldReuseRoute </em>我认为有一个错误的参数名称，因为<em class="mj">未来</em>参数似乎是我们刚刚离开的路线，所以过去。</p><p id="a8c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望对其他开发者有帮助。</p><p id="7cea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://github.com/angular/angular/issues/16713" rel="noopener ugc nofollow" target="_blank">https://github.com/angular/angular/issues/16713</a></p></div></div>    
</body>
</html>