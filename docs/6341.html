<html>
<head>
<title>A Practical Guide for Linkerd Authorization Policies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Linkerd授权策略实用指南</h1>
<blockquote>原文：<a href="https://itnext.io/a-practical-guide-for-linkerd-authorization-policies-6cfdb50392e9?source=collection_archive---------2-----------------------#2021-10-20">https://itnext.io/a-practical-guide-for-linkerd-authorization-policies-6cfdb50392e9?source=collection_archive---------2-----------------------#2021-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0ed005fc7bd4b03e2ac7cdcafab9a153.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5elwVf7bw77Q1PLP91NbLA.jpeg"/></div></div></figure><p id="8d1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之前我写了文章比较了一些服务网格解决方案，以及我们为什么选择Linkerd。当时，只有一种方法来限制服务之间的访问:标准K8s网络策略。在Linkerd 2.11.0中，有一个称为授权策略的新特性。在发布之后，我们开始使用它。这篇文章主要介绍我们在新政策方面的经验。我们观察它，尝试使用它，并找出符合我们需求的模式。</p><blockquote class="kx ky kz"><p id="4b97" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">我尽量不重复<a class="ae kw" href="https://linkerd.io/2.11/reference/authorization-policy/" rel="noopener ugc nofollow" target="_blank">的官方文档</a>，而是尽量把重点放在实践方面和一些缺陷上。此外，在本文中，<strong class="ka ir">多集群设置不在</strong>中，因为在ANNA Money中，我们不使用它。</p></blockquote><h1 id="6656" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">基线</h1><p id="88e1" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">向后兼容性很好。默认行为就像你对新的授权策略一无所知一样。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/0f6622ec52ceea7eeadcd21dc3b8703d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lNL7QTApkqpZGagjyAojsg.jpeg"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">默认行为</figcaption></figure><p id="f619" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如图所示，任何连接都被service(或POD)接受。Linkerd的显著优点是，默认情况下它不需要mTLS，但如果可以的话，它会支持mTLS。如果两个服务都是网状的，那么它们之间的连接使用mTLS。在另一种情况下，他们仍然可以通信，但没有加密。这个策略叫做<strong class="ka ir"> <em class="la">完全未认证。</em>T9】</strong></p><blockquote class="kx ky kz"><p id="01e8" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">当所有人都允许所有人时，这种模式虽然方便，但本质上并不安全。</p></blockquote><p id="374f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们希望通过新政策实现两个主要目标:</p><ul class=""><li id="eeeb" class="mq mr iq ka b kb kc kf kg kj ms kn mt kr mu kv mv mw mx my bi translated"><strong class="ka ir">内部沟通零信任政策</strong>。想象一下，一个黑客攻击前端，试图调用不受保护的内部API。所以我们想防止这种情况。</li><li id="1d30" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated"><strong class="ka ir">限制对内部API </strong>的非受控访问。例如，一些团队需要私有API，这些API可以被其名称空间(例如，业务域)内的服务调用，但不能从任何其他名称空间调用。所以我们想增加建立反腐败网关的可能性。</li></ul><p id="6ab4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，让我们一步一步地实施政策。</p><h1 id="0537" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">准备</h1><p id="3fa1" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">在我们开始之前，有些事情我们应该记住。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/ca4c32729add219fb42393beb1b1fd43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MgOyy1xAij2pQg3Xx7b9sQ.jpeg"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">想象的建筑</figcaption></figure><p id="d514" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，一些系统组件可能无法啮合。例如，我们以前没有啮合普罗米修斯。此外，您可能有一些Kubernetes作业应该调用其他服务，但不注入Linkerd代理(如何做参见<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/three-ways-to-use-linkerd-with-kubernetes-jobs-c12ccc6d4c7c">我的文章</a>)。所以他们应该在扣动扳机前就已经啮合了。</p><p id="7c81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其次，您的一些pod不能使用某些服务帐户，而是使用默认帐户。这可能会导致将来的授权问题。因此，我们应该为每个pod添加一个特定的服务帐户。</p><p id="f607" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第三，最好在pod中使用命名端口，因为它简化了策略配置。所以如果你不做，那就好好想想。</p><h1 id="c83e" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">步骤1:选择默认策略。</strong></h1><p id="7133" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">我们之前说过，启动<strong class="ka ir">后正确使用<em class="la"/>和</strong>策略。如果您使用多集群网格，这是合理的，但如果不使用，最好选择一个未经<strong class="ka ir"> <em class="la">集群认证的</em> </strong>策略，只允许来自有限范围的IP(例如，来自同一个集群)的请求。</p><p id="4d5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以通过在Linkerd配置中设置适当的属性来做到这一点:</p><pre class="mi mj mk ml gt nf ng nh ni aw nj bi"><span id="a964" class="nk lf iq ng b gy nl nm l nn no"><strong class="ng ir">policyController:<br/>  defaultAllowPolicy: cluster-unauthenticated</strong></span></pre><p id="e1df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者通过在名称空间甚至pod上设置注释<strong class="ka ir">config.linkerd.io/default-inbound-policy</strong>(我认为这样的粒度不合适)。</p><p id="4cf0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认情况下，<strong class="ka ir"> <em class="la">未经群集验证的</em> </strong>策略的IP范围过宽:</p><pre class="mi mj mk ml gt nf ng nh ni aw nj bi"><span id="debd" class="nk lf iq ng b gy nl nm l nn no">clusterNetworks: 10.0.0.0/8,100.64.0.0/10,172.16.0.0/12,192.168.0.0/16</span></pre><p id="8557" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最好通过集群中使用的实际范围来限制它。</p><h2 id="544d" class="nk lf iq bd lg np nq dn lk nr ns dp lo kj nt nu ls kn nv nw lw kr nx ny ma nz bi translated">*-经过验证的策略</h2><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/47e2fcf2543e0b1b1367c9e3d810429d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iHW96i_T9wElLEJ3JxWxmA.jpeg"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">*-身份验证模式限制非网状请求</figcaption></figure><p id="ff0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">两个策略隐式地只允许mTLS连接:<strong class="ka ir"> <em class="la">全认证</em> </strong>和<strong class="ka ir"> <em class="la">集群认证。</em></strong><strong class="ka ir"><em class="la">所有-* </em> </strong>和<strong class="ka ir"> <em class="la">集群-* </em> </strong>的区别以上我们整理了一下。对它的第一印象是哇。下一步是保护您的集群。打开它，继续前进。<strong class="ka ir">不！</strong></p><p id="60e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请不要在生产环境中启用此选项，直到您在测试环境中尝试并首先做好额外准备。这里的主要问题是这个模式拒绝<strong class="ka ir"> <em class="la">所有未网状连接，</em> </strong>包括来自kubelet的健康检查。你的豆荚进入崩溃循环，因为健康检查没有通过。哒哒！(GitHub 上有一个关于这种行为的问题，所以Linkerd可能会以某种方式解决它)。</p><p id="4254" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么如何才能修复呢？首先出现的天真想法是选择所有具有健康检查的端口，并添加附加配置以通过健康检查。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="5e51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们做了什么？我们为它们添加了两个<strong class="ka ir">服务器</strong>配置和一个授权策略。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/3b67d9390eacb029798cdd267a35e3b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8xt3Qci6RFd0u8lAAAE3kQ.jpeg"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">允许运行状况检查策略架构</figcaption></figure><p id="8a1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用一对多关系。每个<strong class="ka ir">服务器</strong>配置通过标签选择器覆盖一个名称空间中的所有网状pod:</p><pre class="mi mj mk ml gt nf ng nh ni aw nj bi"><span id="668e" class="nk lf iq ng b gy nl nm l nn no">podSelector:<br/><strong class="ng ir">  matchLabels:<br/>    linkerd.io/control-plane-ns: linkerd</strong></span></pre><p id="e899" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您知道某个端口的协议，最好通过<strong class="ka ir"> proxyProtocol </strong>属性显式添加此信息。</p><pre class="mi mj mk ml gt nf ng nh ni aw nj bi"><span id="dc19" class="nk lf iq ng b gy nl nm l nn no"><strong class="ng ir">proxyProtocol: "HTTP/2"</strong></span></pre><p id="f2f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，我们添加了一个适用于两种<strong class="ka ir">服务器</strong>配置的策略:</p><pre class="mi mj mk ml gt nf ng nh ni aw nj bi"><span id="bd90" class="nk lf iq ng b gy nl nm l nn no">server:<br/>  selector:<br/><strong class="ng ir">    matchLabels:<br/>      anna.money/server-type: common</strong></span></pre><p id="5757" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们定义了任何未经授权的特定IP的客户端都可以连接到我们。</p><pre class="mi mj mk ml gt nf ng nh ni aw nj bi"><span id="fbd2" class="nk lf iq ng b gy nl nm l nn no">client:<strong class="ng ir"><br/>  unauthenticated: true</strong><br/>  <strong class="ng ir">networks:</strong><br/>{% for n in range(x, y) %}<br/>{% for m in range(0, 256) %}<br/>    <strong class="ng ir">- cidr: 10.{{ n }}.{{ m }}.1/32</strong><br/>{% endfor %}<br/>{% endfor %}</span></pre><p id="c058" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，GKE没有很好的解决方案，因为kubelet从POD CIDR范围内的网关IP地址发出请求。如果您使用另一个Kubernetes解决方案，那么请阅读它的文档。</p><p id="23b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这能解决我们的问题吗？是的，但是带来新的。健康检查通过了，但是通常的请求(例如，来自Nginx入口的请求)没有通过。我们在沙盒环境中遇到了一个错误:</p><pre class="mi mj mk ml gt nf ng nh ni aw nj bi"><span id="68ee" class="nk lf iq ng b gy nl nm l nn no">{"message":"Request failed","error":"unauthorized connection on server serving-port"}<br/>...<br/>{"client.addr":"&lt;other_pod_address&gt;","name":"rescue"}</span></pre><p id="6ab9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是为什么呢？</p><p id="cc3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">否认政策</strong></p><p id="3f21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们需要满足最后一种政策:<strong class="ka ir"> <em class="la">否定</em> </strong>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/712bd4481591b15a4d91572157d3064b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R5DF2gNfl_FLJrMPpddzlg.jpeg"/></div></div></figure><p id="2a20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">拒绝策略要求明确允许任何连接。您可以将它用作默认策略，但是在为所有现有的pod和端口创建所有必要策略的最后一步。</p><p id="4e20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，回头看看我们的配置问题。</p><p id="63c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当任何<strong class="ka ir">服务器</strong>配置与端口匹配时，它使用<strong class="ka ir"> <em class="la">拒绝</em> </strong>策略，而不是默认策略。我们允许从kubelet进行健康检查，但不允许网状连接。</p><blockquote class="kx ky kz"><p id="48d0" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">如果您有一个单独的端口用于运行状况检查，就不会遇到这个问题。</p></blockquote><p id="b7b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们开始吧！</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">允许所有策略</figcaption></figure><p id="08ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据新策略，我们允许所有具有身份的网状连接(事实上，任何网状服务都应该具有身份):</p><pre class="mi mj mk ml gt nf ng nh ni aw nj bi"><span id="3112" class="nk lf iq ng b gy nl nm l nn no">client:<br/><strong class="ng ir">  meshTLS:<br/>    identities:<br/>      - "*"</strong></span></pre><h2 id="2d08" class="nk lf iq bd lg np nq dn lk nr ns dp lo kj nt nu ls kn nv nw lw kr nx ny ma nz bi translated">概述</h2><p id="923f" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">所以我们现在所做的是:</p><ul class=""><li id="5d77" class="mq mr iq ka b kb kc kf kg kj ms kn mt kr mu kv mv mw mx my bi translated">注入像Prometheus和CronJobs这样的Linkerd代理系统组件</li><li id="9e11" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">将所有端口命名为</li><li id="9529" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">为每个POD建立单独的服务帐户</li><li id="3dbb" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">为名称空间中的每个POD的<code class="fe od oe of ng b">serving-port</code>创建<strong class="ka ir">服务器</strong>配置</li><li id="8b94" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">为Linkerd代理管理端口创建<strong class="ka ir">服务器</strong>配置</li><li id="2a04" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">创建允许来自kubelet的请求的<strong class="ka ir"> ServerAuthorization </strong></li><li id="c220" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">创建允许任何网状连接的<strong class="ka ir">服务器授权</strong></li><li id="0712" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">使Linkerd配置中的<code class="fe od oe of ng b">clusterNetworks</code>更紧密</li><li id="78df" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">打开<strong class="ka ir">集群认证</strong>作为名称空间的默认策略</li></ul><h1 id="749a" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">第二步:使其可定制。</h1><p id="de26" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">还记得目标吗？目前，如果一个假想的黑客可以访问前端POD，他也可以调用任何其他POD。这是因为我们允许任何网状通信。所以让我们试着修复它。</p><p id="0ccc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们不能为服务端口服务器配置添加新的特定策略，因为此配置适用于大量的pod(确切地说，在名称空间中的任何网格上)。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/3dec0d7a9f142db6f7a7c2a7743cafaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*izZG2JtP1RpuP9ZkZf1V4A.jpeg"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">特定策略需要一个精确的服务器。</figcaption></figure><p id="05b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，也许我们可以为服务X再添加一个<strong class="ka ir">服务器</strong>配置？</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/d7374114504bf65fe3f30fc68285ca2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bghjD3Dq5_RoukA6MC3ClQ.jpeg"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">端口有多个服务器</figcaption></figure><p id="30ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很危险，会导致奇怪的行为。问题是Linkerd <strong class="ka ir">检查每台服务器对端口</strong>的访问。如果我们只应用特定的策略，那么运行状况检查就会开始失败。所以我们也需要使用所有的公共政策。</p><p id="b33f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，这也不是推荐的方式，准入挂钩试图拒绝这样的配置。</p><p id="5f43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的解决方案是在端口和服务器配置之间使用一对一的关系。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/826c160b8428548eccc84614dbd6d02c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tBADwlnRTuugxw1I-uaMTA.jpeg"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">独立的服务器配置</figcaption></figure><p id="af84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们保留了linkerd管理端口<strong class="ka ir">服务器</strong>配置，因为我们对名称空间中的所有Linkerd代理容器都有确切的要求。出于安全原因，有必要为管理端口添加一个策略，允许来自Prometheus(它获取度量)和其他工具(如果有)的连接，但拒绝其他连接。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="dacf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们用一个严格的名字来选择<strong class="ka ir">服务器</strong>而不是选择器:</p><pre class="mi mj mk ml gt nf ng nh ni aw nj bi"><span id="7bd9" class="nk lf iq ng b gy nl nm l nn no"><strong class="ng ir">server:<br/>  name: linkerd-admin-port</strong></span></pre><p id="5989" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，让<strong class="ka ir"> linkerd </strong>系统名称空间中的所有pod都获得授权也是合理的:</p><pre class="mi mj mk ml gt nf ng nh ni aw nj bi"><span id="0080" class="nk lf iq ng b gy nl nm l nn no">server:<br/>  name: linkerd-admin-port<br/>client:<br/>  meshTLS:<br/>    identities:<br/>      - "<strong class="ng ir">*.linkerd</strong>.serviceaccount.identity..."<br/>      - "<strong class="ng ir">*.linkerd-viz</strong>.serviceaccount.identity..."</span></pre><p id="674c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了支持应用程序端口的特定和通用策略，我们应该在所有其他应用程序中使用唯一标签来标记POD:</p><pre class="mi mj mk ml gt nf ng nh ni aw nj bi"><span id="c65c" class="nk lf iq ng b gy nl nm l nn no"><strong class="ng ir">labels:<br/>  anna.money/authorization-policy: "{{ app_name }}"</strong></span></pre><blockquote class="kx ky kz"><p id="0b17" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">在这里和下面，我们将使用Jinja语法进行模板化。所以<strong class="ka ir"> app_name </strong>只是一个带有应用名称的变量。</p></blockquote><p id="4a09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们应该为<strong class="ka ir">服务端口</strong>(或应用程序用来处理请求的每个端口)和<strong class="ka ir">服务器授权</strong>添加一个特定的<strong class="ka ir">服务器</strong>，允许所有授权的身份发出请求:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="581b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，我们用两个标签来标记<strong class="ka ir">服务器</strong>——一个用于公共授权策略，另一个用于特定于应用程序的策略。它让我们可以灵活地添加更多的通用授权策略，而无需重新配置服务器。此外，我们使用一个唯一的标签来为<strong class="ka ir">服务器</strong>选择合适的端口。</p><p id="ae2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们没有机会涵盖所有情况，但是您应该记住，在您进入生产环境之前的迁移过程中，可能会在测试环境中发现特定于平台的东西。对于每种情况，可能需要另一个<strong class="ka ir">服务器授权</strong>策略。</p><blockquote class="kx ky kz"><p id="abb3" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><strong class="ka ir"> GKE特有的</strong>。如果您使用内部负载平衡器(ILB)，您应该为平衡器代理的任何端口添加宽CIDR。原因是来自ILB的请求可以来自通常使用整个VPC网络的任何GKE节点。比如可以是<strong class="ka ir"> 10.xxx.0.0/20。</strong></p></blockquote><p id="0ba3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，请记住，我们应该对应用程序的每个名称空间进行适当的配置。</p><h2 id="edb4" class="nk lf iq bd lg np nq dn lk nr ns dp lo kj nt nu ls kn nv nw lw kr nx ny ma nz bi translated">概述</h2><p id="add5" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">所以我们在这一部分所做的:</p><ul class=""><li id="2d69" class="mq mr iq ka b kb kc kf kg kj ms kn mt kr mu kv mv mw mx my bi translated">将<strong class="ka ir">服务器</strong>定义从一对多修改为一对一关系</li><li id="39e7" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">为所有<strong class="ka ir"> linkerd-admin </strong>端口保留<strong class="ka ir">服务器</strong>，因为我们希望为名称空间中的任何<strong class="ka ir"> linkerd-proxy </strong>容器实现相同的行为</li><li id="8f6e" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">保护<strong class="ka ir"> linkerd-admin </strong>端口，但为Prometheus等系统组件打开它</li><li id="4a32" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">用一个唯一的标签标记pod，并在特定的<strong class="ka ir">服务器</strong>定义中将其用作选择器</li><li id="dc86" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">在<strong class="ka ir">服务器</strong>定义上使用通用标签，以简化新的通用授权策略添加</li><li id="2f10" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">请记住特定于平台的情况</li><li id="eb96" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">请记住，我们应该为任何覆盖的名称空间复制配置</li></ul><h1 id="851b" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">第三步:确保安全。</h1><p id="36e7" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">我们做了很好的准备，但是我们仍然没有达到我们的目标。要做到这一点，我们应该修改所有允许的政策，使之更加具体。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/5c06552fee2422084ce03e8d4774ea7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_iWhCfeev_7QWPhNmuWung.jpeg"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">想象的建筑#2</figcaption></figure><p id="2322" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看图表。我们有两个名称空间，三个服务，Nginx ingress将数据暴露给外部世界，Prometheus获取度量(实际上，我们应该从它添加更多的箭头，但这导致了一个不可读的图片)。</p><p id="35a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有些服务可以调用其他服务，有些不能。来自<strong class="ka ir">大象</strong>名称空间的服务只接受来自同一个名称空间的请求<strong class="ka ir">。Nginx不应该向服务#1发出请求，但是可以为服务# 2和服务# 3发出请求。</strong></p><p id="e325" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看起来很复杂？现实更多。让我们收拾残局。</p><p id="b26d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一步很简单。我们应该添加<strong class="ka ir"> ServerAuthorization </strong>，它允许所有应用程序从Prometheus发出请求。我们之前用<strong class="ka ir"> linkerd-admin </strong>端口做过，所以这应该很容易:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="542b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用Nginx的情况更棘手。我们希望拥有尽可能少的授权定义，但是我们不能对通用服务器类型应用新的授权策略。</p><p id="cff0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的解决方案是在<strong class="ka ir">服务器</strong>上为Nginx应该通过Nginx公开的端口添加一个新标签:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="9a0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，只有当<strong class="ka ir">服务器</strong>具有<code class="fe od oe of ng b">anna-money/nginx: enabled</code>标签时，授权策略才适用。我们可以在部署期间通过舵图或其他模板来实现。</p><p id="7cc7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们希望将<strong class="ka ir">大象</strong>名称空间与其他名称空间隔离开来，因此我们可以使用类似的技巧，在每个应用程序<strong class="ka ir">服务器</strong>上再添加一个标签:</p><pre class="mi mj mk ml gt nf ng nh ni aw nj bi"><span id="b009" class="nk lf iq ng b gy nl nm l nn no">labels:<br/>  anna.money/server-type: common<br/>  anna.money/authorization-policy: {{ app_name }}<br/>  anna.money/nginx: enabled<br/><strong class="ng ir">  anna.money/server-ns: {{ app_ns }}</strong></span></pre><p id="f47e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后允许来自该命名空间的所有身份:</p><pre class="mi mj mk ml gt nf ng nh ni aw nj bi"><span id="f345" class="nk lf iq ng b gy nl nm l nn no">server:<br/>  selector:<br/>    matchLabels:<br/>      <strong class="ng ir">anna.money/server-ns: {{ app_ns }}</strong><br/>client:<br/>  meshTLS:<br/>    identities:<br/>      - "<strong class="ng ir">*.elephants</strong>.serviceaccount.identity..."</span></pre><blockquote class="kx ky kz"><p id="3289" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">此时，我们应该逐步删除应用程序端口的allow-all<strong class="ka ir">server authorization</strong>定义。</p></blockquote><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/f332a74fd7d9d1a4d0b6613a86eb9b90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D7_ibpzC8o4pkn6dvPhEmQ.jpeg"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">想象的建筑#3</figcaption></figure><p id="1b6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们添加一个新组件——用于<strong class="ka ir">大象</strong>名称空间的API网关。它类似于其他名称空间的服务可以请求的公共API。这里我们应该为网关再添加一个<strong class="ka ir"> ServerAuthorization </strong>。它应该接受来自其他授权名称空间的任何请求。</p><p id="b897" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用通配符身份来实现这一点(就像我们之前做的一样):</p><pre class="mi mj mk ml gt nf ng nh ni aw nj bi"><span id="898c" class="nk lf iq ng b gy nl nm l nn no">server:<br/>  selector:<br/>    matchLabels:<br/>      <strong class="ng ir">anna.money/authorization-policy: gateway</strong><br/>client:<br/>  meshTLS:<br/>    identities:<br/>      - "<strong class="ng ir">*.hippo</strong>.serviceaccount.identity..."<br/>      - "<strong class="ng ir">*.xxx</strong>.serviceaccount.identity..."</span></pre><p id="d200" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，我们希望限制从<strong class="ka ir">服务#2 </strong>到<strong class="ka ir">服务#3 </strong>的呼叫。在这种情况下，我们应该删除允许名称空间内任何请求的策略，并添加一个更具体的策略。</p><p id="f6ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们有几个服务，我们可以为每个服务手动添加一个授权策略，其中包含服务帐户(或其他服务)的详细列表:</p><pre class="mi mj mk ml gt nf ng nh ni aw nj bi"><span id="ea0f" class="nk lf iq ng b gy nl nm l nn no">server:<br/>  selector:<br/>    matchLabels:<br/>      <strong class="ng ir">anna.money/authorization-policy: service1</strong><br/>client:<br/>  meshTLS:<br/>    <strong class="ng ir">serviceAccounts:<br/>      - namespace: elephants<br/>        name: gateway</strong></span></pre><blockquote class="kx ky kz"><p id="86e5" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">如你所见，在这里，我们使用另一种方式来定义身份。它比“身份”变体更明确。</p></blockquote><p id="941d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们有几十个生产应用程序，我们应该考虑流程的自动化，以允许一个服务大规模地提供给另一个服务。</p><p id="c01b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有两种方法来组织这个过程:显式和本机。要感受不同之处，让我们看一下图表。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/78a5880abe89fb5e9b15ffb95b0fd283.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qMTduXUFpN-2YWKJrPWJjw.jpeg"/></div></div></figure><p id="0e1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们应该如何定义这个方案？在<strong class="ka ir">显式变体</strong>中，我们在Helm chart(或另一个模板)中添加了一个新属性，以支持允许的应用程序或服务帐户列表:</p><pre class="mi mj mk ml gt nf ng nh ni aw nj bi"><span id="0a5e" class="nk lf iq ng b gy nl nm l nn no">#no one allowed<strong class="ng ir"><br/>allowedServiceAccounts: []</strong></span><span id="f48a" class="nk lf iq ng b gy ol nm l nn no">#only service #3 is allowed<strong class="ng ir"><br/>allowedServiceAccounts:<br/></strong>  <strong class="ng ir">- namespace: elephants<br/>    name: service3</strong></span></pre><p id="8d81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们很容易模板化策略，因为定义与<strong class="ka ir"> ServerAuthorization </strong>规范中的相同。</p><p id="35ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">变体的好处</strong>是容易理解和模板化。主要缺点是需要定义应用程序的所有客户端。这很棘手，需要时间。</p><p id="022c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相比之下，<strong class="ka ir">原生变体</strong>意味着定义每个服务的依赖关系，构建图表，并找出依赖于特定服务的所有应用程序。</p><pre class="mi mj mk ml gt nf ng nh ni aw nj bi"><span id="e758" class="nk lf iq ng b gy nl nm l nn no">#no dependencies<strong class="ng ir"><br/>dependencies: []</strong></span><span id="7f31" class="nk lf iq ng b gy ol nm l nn no">#service #3 depends on #1 and #2<strong class="ng ir"><br/>dependencies:<br/></strong>  <strong class="ng ir">- namespace: elephants<br/>    name: service1<br/>  - namespace: elephants<br/>    name: service2</strong></span></pre><p id="9362" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">该变体的主要好处</strong>是以一种更本地的方式定义应用程序之间的关系。<strong class="ka ir">主要缺点</strong>是模板化和更新授权策略的过程更加复杂，因为我们必须解决逆问题。</p><p id="15bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，如果服务没有明确的定义，我们可以将这两种方法结合起来，使用本地变体。</p><p id="4150" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在迁移过程的最后，我们应该删除应用程序的所有allow-all策略，并打开所有覆盖的名称空间的默认策略<strong class="ka ir"><em class="la"/></strong>。</p><h2 id="c64d" class="nk lf iq bd lg np nq dn lk nr ns dp lo kj nt nu ls kn nv nw lw kr nx ny ma nz bi translated">概述</h2><p id="4343" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">所以我们在这一部分所做的:</p><ul class=""><li id="a3df" class="mq mr iq ka b kb kc kf kg kj ms kn mt kr mu kv mv mw mx my bi translated">使用<strong class="ka ir">服务器</strong>的标签来定义典型行为；例如，我们添加标签以允许Prometheus和Nginx访问</li><li id="4319" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">与前一个类似，我们使用一个<strong class="ka ir">服务器</strong>的标签来确定一个应用程序是否在特定的名称空间中</li><li id="8905" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">我们已经理清了开发人员如何为名称空间(或业务领域)实现API网关</li><li id="6a25" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">我们看两种大规模组织服务到服务策略规则的方法</li><li id="33a1" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">我们一步一步地删除允许所有授权策略</li></ul></div><div class="ab cl om on hu oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ij ik il im in"><h1 id="4d8c" class="le lf iq bd lg lh ot lj lk ll ou ln lo lp ov lr ls lt ow lv lw lx ox lz ma mb bi translated"><strong class="ak">结论</strong></h1><p id="cba8" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">还记得目标吗？</p><p id="7434" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们通过Linkerd授权策略实现了两个主要目标:</p><ul class=""><li id="7dbc" class="mq mr iq ka b kb kc kf kg kj ms kn mt kr mu kv mv mw mx my bi translated"><strong class="ka ir">内部沟通零信任政策</strong></li><li id="9a04" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated"><strong class="ka ir">限制对内部API的非受控访问</strong></li></ul><p id="bb55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们一步一步地添加从allow-all到allow-only的授权规则，在文章的最后，每个服务定义它应该接受什么请求。<strong class="ka ir"> <em class="la">爽！</em> </strong></p><p id="06ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们回忆一下我们面临的主要陷阱:</p><ul class=""><li id="edb0" class="mq mr iq ka b kb kc kf kg kj ms kn mt kr mu kv mv mw mx my bi translated"><strong class="ka ir">*-经过认证的</strong>默认策略会破坏您的环境</li><li id="ba4e" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">每个端口应该只由一个<strong class="ka ir">服务器</strong>定义覆盖</li><li id="bdd0" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">还记得特定于平台的东西吗，比如GKE的内部负载平衡器或者CIDR的健康检查</li></ul><p id="29a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结束了。我希望这篇文章能帮助你通过这种方式，或者，至少，给你一些思考、见解和乐趣。</p></div></div>    
</body>
</html>