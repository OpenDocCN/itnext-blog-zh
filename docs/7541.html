<html>
<head>
<title>The Zig and Go Programming Showdown!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Zig和Go编程摊牌！</h1>
<blockquote>原文：<a href="https://itnext.io/the-zig-and-go-programming-showdown-2244b261c051?source=collection_archive---------0-----------------------#2022-10-28">https://itnext.io/the-zig-and-go-programming-showdown-2244b261c051?source=collection_archive---------0-----------------------#2022-10-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9f6a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Zig and Go中构建一个玩具组装器教会了我关于每种语言的什么</h2></div><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/ffc4cd3661cd4e88ec3ca5eab61b6259.png" data-original-src="https://miro.medium.com/v2/format:webp/1*MrertUkFGWIVDsHXBIsKuA.jpeg"/></div></figure><p id="3cb7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这个故事的标题应该是“为什么我放弃了Zig”，但Zig最终给我留下的印象比我预期的要多，而Go让我失望。那段经历很好地说明了我在过去两年中与Zig的关系:我真的很难决定我对Zig的看法。有时，这让我感到沮丧，我准备放弃。其他时候我会想，“这东西真的很棒，很聪明！”</p><p id="d741" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在我们深入研究之前，你可能会问:我为什么要比较Zig和Go？这两种语言是不是差别太大，无法比较？他们在同一个领域竞争吗？的确，它们是不同的，它们并不完全重叠。但就我的兴趣而言，我看到了明显的重叠。请允许我澄清。我更喜欢的语言是Julia，但是它是为JIT编译而设计的，因此不适合为小型命令行实用程序创建二进制文件。例如，我希望我的简单的<a class="ae lm" href="https://github.com/ordovician/Calcutron33.jl" rel="noopener ugc nofollow" target="_blank"> Calcutron-33玩具组装器</a>易于任何人下载和安装。任何需要安装虚拟环境、运行时系统或JIT编译器的东西都是不可行的。</p><p id="8c56" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我的另一个兴趣是编程游戏引擎和微控制器。我用<a class="ae lm" href="https://www.fischertechnik.de/en/" rel="noopener ugc nofollow" target="_blank">慧鱼</a>建造了一个很酷的大理石跑道，由<a class="ae lm" href="https://www.arduino.cc" rel="noopener ugc nofollow" target="_blank"> Arduino微控制器</a>控制，我用标准<a class="ae lm" href="https://www.arduino.cc/en/software" rel="noopener ugc nofollow" target="_blank"> Arduino IDE </a>用C/C++编程。每次我使用C/C++时，我都发现这种语言妨碍了我。我想要更好的东西。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/c21bbae91104511b553a773bd2d2492e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*hK-Ih8kovs3j9MbY4iuYvg.jpeg"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">Arduino控制的慧鱼大理石轨道</figcaption></figure><p id="4a23" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用Julia不是一种选择，因为它不是真正为小型系统设计的。Go似乎也不是一个好的选择，因为它使用了垃圾收集。然而，Go是一种与C#和Java等其他GC语言非常不同的语言。因为它允许您控制内存布局和使用真正的指针，所以您可以限制垃圾收集的使用。这些特性的结合使得TinyGo<a class="ae lm" href="https://tinygo.org" rel="noopener ugc nofollow" target="_blank">成为可能:</a></p><blockquote class="lr ls lt"><p id="6f09" class="kq kr lu ks b kt ku ju kv kw kx jx ky lv la lb lc lw le lf lg lx li lj lk ll im bi translated">TinyGo通过创建基于LLVM的新编译器，将Go编程语言引入嵌入式系统和现代网络。</p><p id="1d9a" class="kq kr lu ks b kt ku ju kv kw kx jx ky lv la lb lc lw le lf lg lx li lj lk ll im bi translated">您可以在超过85种不同的微控制器板上编译和运行TinyGo程序，例如BBC micro:bit和Arduino Uno</p></blockquote><p id="8f8a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因此，自从两年前我开始玩Zig以来，我几乎已经决定放弃Zig，专注于围棋。为什么不呢，当Go可以覆盖我感兴趣的大部分系统编程的时候？然而，我一直看到你们，我的读者，似乎对阅读我的Zig故事比我的Go故事更感兴趣。因此，这个月，我决定带Zig再转一圈。</p><p id="7337" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">感受一门语言的最好方法是通过实现一些重要的程序。我的选择是用大约1500行Zig代码完成我的玩具组装器<a class="ae lm" href="https://github.com/ordovician/Zacktron-33" rel="noopener ugc nofollow" target="_blank"> Zacktron-33 </a>。对应的围棋版本<a class="ae lm" href="https://github.com/ordovician/calcutron" rel="noopener ugc nofollow" target="_blank"> Calcutron-33 </a>大概是1000行围棋代码。请记住，Go版本还没有完成(10月27日)。</p><h1 id="cf81" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">最初的惊喜</h1><p id="037d" class="pw-post-body-paragraph kq kr it ks b kt mq ju kv kw mr jx ky kz ms lb lc ld mt lf lg lh mu lj lk ll im bi translated">乍一看，Zig似乎是一种比Go低级得多的编程语言。以下是Zig缺少但Go中存在的一些东西:</p><ul class=""><li id="153c" class="mv mw it ks b kt ku kw kx kz mx ld my lh mz ll na nb nc nd bi translated">垃圾收集工</li><li id="50fc" class="mv mw it ks b kt ne kw nf kz ng ld nh lh ni ll na nb nc nd bi translated">字符串类型</li><li id="11f0" class="mv mw it ks b kt ne kw nf kz ng ld nh lh ni ll na nb nc nd bi translated">抽象接口</li><li id="ff65" class="mv mw it ks b kt ne kw nf kz ng ld nh lh ni ll na nb nc nd bi translated">对并发的内置支持(例如，Goroutines)</li><li id="9e1e" class="mv mw it ks b kt ne kw nf kz ng ld nh lh ni ll na nb nc nd bi translated">关闭</li><li id="98fe" class="mv mw it ks b kt ne kw nf kz ng ld nh lh ni ll na nb nc nd bi translated">异常(<code class="fe nj nk nl nm b">panic</code>在Go中)</li><li id="25b3" class="mv mw it ks b kt ne kw nf kz ng ld nh lh ni ll na nb nc nd bi translated">运行时反射</li></ul><p id="e2ed" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Zig不使用字符串类型，而是使用基本的字节数组，就像c一样。然而，当在函数级工作时，角色是互换的:Go感觉像低级语言，Zig感觉像高级语言。我认为原因是Zig在其他重要领域比Go更复杂:</p><ul class=""><li id="5fc5" class="mv mw it ks b kt ku kw kx kz mx ld my lh mz ll na nb nc nd bi translated">代码的编译时评估，即所谓的<code class="fe nj nk nl nm b">comptime</code></li><li id="5217" class="mv mw it ks b kt ne kw nf kz ng ld nh lh ni ll na nb nc nd bi translated">枚举和联合类型</li><li id="f837" class="mv mw it ks b kt ne kw nf kz ng ld nh lh ni ll na nb nc nd bi translated">标记联合(总和类型)</li><li id="856d" class="mv mw it ks b kt ne kw nf kz ng ld nh lh ni ll na nb nc nd bi translated">可选类型(必须明确允许变量或参数采用<code class="fe nj nk nl nm b">null</code>值)</li></ul><p id="9ca0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最终的结果是，Go擅长于我称之为“大”的编程，而Zig擅长于“小”的编程。我这么说是什么意思？你在白板上勾画的所有东西，比如类、模块以及它们之间的关系，都是Go的优势所在。一旦深入到单个功能的层面，Zig就开始大放异彩。</p><p id="88f7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在我的Zig解决方案之后，我在Go中实现了我的汇编器。在编写Go代码时，我经常惊讶地发现，与Zig相比，Go在处理错误和空值方面是多么笨拙。在进行常规编程时，这种东西会不断地被处理。让我通过一个解析汇编源代码文件中的符号的例子来阐明这一点。</p><h1 id="1812" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">创建符号表</h1><p id="a7e4" class="pw-post-body-paragraph kq kr it ks b kt mq ju kv kw mr jx ky kz ms lb lc ld mt lf lg lh mu lj lk ll im bi translated">大多数编程语言都必须处理符号。我发明的Calcutron-33汇编语言也不例外。让我展示一个Calcutron-33汇编程序的例子。你会注意到标签<code class="fe nj nk nl nm b">loop</code>和<code class="fe nj nk nl nm b">multiply</code>，它们代表程序存储器中的特定位置。</p><pre class="ki kj kk kl gt nn nm no np aw nq bi"><span id="011e" class="nr lz it nm b gy ns nt l nu nv">loop:<br/>    INP x1        // read input into register x1<br/>    INP x2        // store next input value in register x2<br/>    CLR x3        // clear register x3<br/>    <br/>multiply:<br/>    ADD x3, x1    // add register x1 to register x3<br/>    DEC x2        // decrement register x2<br/>    BGT x2, multiply<br/>    OUT x3        // write register x3 to output<br/>    <br/>    BRA loop      // non-conditional jump to label loop</span></pre><p id="d0c4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当解析这个汇编代码时，我必须跟踪这些标签对应的内存地址，这样任何引用这些符号的指令都会替换一个内存地址。</p><p id="64ea" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们先来探讨一下Go版本。我使用Go <code class="fe nj nk nl nm b">Scanner</code>类型一次扫描文件中的一行。对于每一行，我使用<code class="fe nj nk nl nm b">IndexRune</code>来确定该行是否有冒号。每个标签的结尾都用冒号标记。<code class="fe nj nk nl nm b">IndexRune</code>返回您要搜索的字符的索引，如果找不到，则返回<code class="fe nj nk nl nm b">-1</code>。因此，下面的代码包含一个if语句，在字典中记录符号的地址之前检查<code class="fe nj nk nl nm b">i &gt;= 0</code>(Go中的<code class="fe nj nk nl nm b">map</code>)。</p><pre class="ki kj kk kl gt nn nm no np aw nq bi"><span id="0a66" class="nr lz it nm b gy ns nt l nu nv">func readSymTable(reader io.Reader) map[string]uint8 {<br/>	scanner := bufio.NewScanner(reader)<br/>	labels := make(map[string]uint8)<br/>	address := 0<br/>	for scanner.Scan() {<br/>		line := strings.Trim(scanner.Text(), " \t")<br/>		n := len(line)<br/><br/>		if n == 0 {<br/>			continue<br/>		}<br/><br/>		if i := strings.IndexRune(line, ':'); i &gt;= 0 {<br/>			labels[line[0:i]] = uint8(address)<br/><br/>			// is there anything beyond the label?<br/>			if n == i+1 {<br/>				continue<br/>			}<br/>		}<br/>		address++<br/>	}<br/>	return labels<br/>}</span></pre><p id="8f32" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这种实施方式面临几个突出的挑战:</p><ul class=""><li id="6d22" class="mv mw it ks b kt ku kw kx kz mx ld my lh mz ll na nb nc nd bi translated">可能会失败，但我不会在代码中处理这个问题。Go没有以任何方式强迫我或提醒我那样做。</li><li id="2306" class="mv mw it ks b kt ne kw nf kz ng ld nh lh ni ll na nb nc nd bi translated">很容易忘记检查索引<code class="fe nj nk nl nm b">i &gt; 0</code>。没有什么会强迫你去做那个检查。你只需要记得去做。</li></ul><p id="b56a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Zig解决方案避免了上述问题。它使用<code class="fe nj nk nl nm b">readUntilDelimiterOrEof</code>函数代替Go的<code class="fe nj nk nl nm b">Scan</code>函数来获取单独的行。一个关键的区别是，前者强迫你处理错误，而后者不。如果在读取过程中发生错误，类型为<code class="fe nj nk nl nm b">error</code>的类似枚举的值将从<code class="fe nj nk nl nm b">readSymTable</code>函数返回。我稍后将更详细地解释这个机制是如何工作的。</p><p id="4051" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">其次，在Zig中，我们使用<code class="fe nj nk nl nm b">mem.indexOf</code>函数而不是<code class="fe nj nk nl nm b">strings.IndexRune</code>来定位冒号<code class="fe nj nk nl nm b">:</code>字符的索引。在以下Zig代码中，无需检查<code class="fe nj nk nl nm b">i &gt; 0</code>。相反，如果没有冒号，则返回一个<code class="fe nj nk nl nm b">null</code>。这算什么进步？</p><pre class="ki kj kk kl gt nn nm no np aw nq bi"><span id="36f9" class="nr lz it nm b gy ns nt l nu nv">fn readSymTable(allocator: Allocator, <br/>                   reader: anytype) !StringHashMap(u8) {<br/><br/>    var labels = StringHashMap(u8).init(allocator);<br/>    errdefer labels.deinit();<br/>    var address: u8 = 0;<br/><br/>    var buffer: [500]u8 = undefined;<br/>    while (try reader.readUntilDelimiterOrEof(buffer[0..], '\n')) |tmp_line| {<br/>        const line = mem.trim(u8, tmp_line, " \t");<br/>        const n = line.len;<br/><br/>        if (n == 0) continue;<br/><br/>        if (mem.indexOf(u8, line, ":")) |i| {<br/>            const label = try allocator.dupe(u8, line[0..i]);<br/>            try labels.put(label, address);<br/><br/>            // is there anything beyond the label?<br/>            if (n == i + 1) continue;<br/>        }<br/>        address += 1;<br/>    }<br/><br/>    return labels;<br/>}</span></pre><p id="3ff6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Zig不允许你对<em class="lu">可能</em>包含<code class="fe nj nk nl nm b">null</code>的值做任何事情，直到你显式地打开那个值。</p><h2 id="be8c" class="nr lz it bd ma nw nx dn me ny nz dp mi kz oa ob mk ld oc od mm lh oe of mo og bi translated">理解索引</h2><p id="f455" class="pw-post-body-paragraph kq kr it ks b kt mq ju kv kw mr jx ky kz ms lb lc ld mt lf lg lh mu lj lk ll im bi translated">查看下面的<code class="fe nj nk nl nm b">indexOf</code>的函数签名，我们可以看到它返回一个类型为<code class="fe nj nk nl nm b">?usize</code>的值。添加的问号表示该值可能包含一个<code class="fe nj nk nl nm b">null</code>，因此必须以特殊方式处理。这就是我们所说的可选值或可空值。</p><pre class="ki kj kk kl gt nn nm no np aw nq bi"><span id="b471" class="nr lz it nm b gy ns nt l nu nv">fn indexOf(comptime T: type, haystack: []const T, needle: []const T) ?usize</span></pre><p id="53a4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe nj nk nl nm b">usize</code>本质上是一个无符号整数，大到足以表示数组中的任何索引。通过添加一个问号<code class="fe nj nk nl nm b">?</code>,我们使类型可选。如果我们没有这样做，那么返回<code class="fe nj nk nl nm b">null</code>将会产生一个编译错误。通过使返回类型可选(也称为可空)，我们被允许返回<code class="fe nj nk nl nm b">null</code>。</p><p id="2663" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因为可选值在类型系统中被显式标记，所以编译器可以捕捉任何试图直接使用该返回值的代码，而无需先将其解包。</p><p id="16ca" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在展开之前，不能在任何计算或运算中直接使用可选整数。在Zig中，您可以使用带横条的if语句展开可选值<code class="fe nj nk nl nm b">maybe</code>。</p><pre class="ki kj kk kl gt nn nm no np aw nq bi"><span id="0e13" class="nr lz it nm b gy ns nt l nu nv">if (maybe) |v| {<br/>    // do stuff with unwrapped v value<br/>}</span></pre><p id="ef43" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在Zig中，从解包选项中捕获的值、错误和许多其他东西都是用竖线中包含的变量捕获的，例如<code class="fe nj nk nl nm b">|i|</code>。在Zig中，不可能编写下面的代码，因为<code class="fe nj nk nl nm b">i</code>的类型是<code class="fe nj nk nl nm b">?usize</code>，它不能用作索引来指定<code class="fe nj nk nl nm b">line</code>字符串的一部分。</p><pre class="ki kj kk kl gt nn nm no np aw nq bi"><span id="e9ac" class="nr lz it nm b gy ns nt l nu nv">// This Zig code will not compile<br/>const i = mem.indexOf(u8, line, ":")<br/>const label = try allocator.dupe(u8, line[0..i]);</span></pre><p id="4fd7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Zig方法的好处是“忘记”检查<code class="fe nj nk nl nm b">i</code>是否是<code class="fe nj nk nl nm b">null</code>是不可能的。</p><h2 id="d24a" class="nr lz it bd ma nw nx dn me ny nz dp mi kz oa ob mk ld oc od mm lh oe of mo og bi translated">了解readUntilDelimiterOrEof</h2><p id="f49c" class="pw-post-body-paragraph kq kr it ks b kt mq ju kv kw mr jx ky kz ms lb lc ld mt lf lg lh mu lj lk ll im bi translated">为了解释Zig如何读取文本行，我们需要了解Zig如何处理错误。实际上，您可以定义一个要与函数一起使用的错误代码的枚举。</p><pre class="ki kj kk kl gt nn nm no np aw nq bi"><span id="7ba2" class="nr lz it nm b gy ns nt l nu nv">const FileOpenError = error {<br/>    AccessDenied,<br/>    OutOfMemory,<br/>    FileNotFound,<br/>};<br/><br/>fn open(filename: []const u8) FileOpenError!File {<br/>   // implementation of a file open function<br/>}</span></pre><p id="a9bc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">感叹号<code class="fe nj nk nl nm b">!</code>的使用创建了一个联合类型。从<code class="fe nj nk nl nm b">open</code>返回的值可以是一个<code class="fe nj nk nl nm b">FileOpenError</code>枚举值或一个<code class="fe nj nk nl nm b">File</code>对象。当调用这个函数时，您应该编写如下代码:</p><pre class="ki kj kk kl gt nn nm no np aw nq bi"><span id="5d1f" class="nr lz it nm b gy ns nt l nu nv">var file = open("foobar.text") catch |err| {<br/>    // do some stuff<br/>	return err <br/>}</span></pre><p id="9d98" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果没有错误，<code class="fe nj nk nl nm b">file</code>变量被设置为一个有效的文件对象，我们继续执行接下来的几行代码。但是，如果有错误，就会调用<code class="fe nj nk nl nm b">catch</code>子句，并在<code class="fe nj nk nl nm b">err</code>变量中捕获错误对象。您可能想尝试在这里处理错误，但通常最好是简单地从带有错误值的函数中提前返回。因为这种选择非常普遍，所以Zig有一种通过使用<code class="fe nj nk nl nm b">try</code>关键字来编写<code class="fe nj nk nl nm b">catch</code>和<code class="fe nj nk nl nm b">return</code>代码的简写方式:</p><pre class="ki kj kk kl gt nn nm no np aw nq bi"><span id="95d1" class="nr lz it nm b gy ns nt l nu nv">// will cause a return from enclosing function if open fails<br/>var file = try open("foobar.text")</span></pre><p id="723a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Zig编译器会强迫你处理错误情况。您必须要么捕捉错误，要么通过使用<code class="fe nj nk nl nm b">try</code>从封闭函数返回错误来转发错误。现在您可以更好地理解我们的<code class="fe nj nk nl nm b">readSymTable</code>函数了。</p><pre class="ki kj kk kl gt nn nm no np aw nq bi"><span id="396e" class="nr lz it nm b gy ns nt l nu nv">fn readSymTable(allocator: Allocator, <br/>                   reader: anytype) !StringHashMap(u8) {</span></pre><p id="fa2a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">它返回一个类型为<code class="fe nj nk nl nm b">!StringHashMap(u8)</code>的值。我们没有指定使用的<code class="fe nj nk nl nm b">error</code>枚举，这意味着函数接受任何返回的错误值。如果没有错误发生，我们的<code class="fe nj nk nl nm b">readSymTable</code>返回一个字典(hash map ),以字符串键和8位无符号整数作为值。如果我们不允许函数返回一个错误对象，那么将<code class="fe nj nk nl nm b">try</code>放在函数调用之前将会失败。可能返回错误值的函数调用。将<code class="fe nj nk nl nm b">try</code>放在从不返回错误值的函数调用之前是一个语法错误。</p><p id="704d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">观察我们的<code class="fe nj nk nl nm b">readSymTable</code>中的while循环。注意对<code class="fe nj nk nl nm b">readUntilDelimiterOrEof</code>的调用是如何以<code class="fe nj nk nl nm b">try</code>为前缀的，以便在读取文件时发生错误的情况下允许从<code class="fe nj nk nl nm b">readSymTable</code>返回。然而，即使没有错误，也可能没有更多的行要读取，这就是为什么我们需要<code class="fe nj nk nl nm b">|tmp_line|</code>来打开返回的可选值。</p><pre class="ki kj kk kl gt nn nm no np aw nq bi"><span id="1e42" class="nr lz it nm b gy ns nt l nu nv">while (try reader.readUntilDelimiterOrEof(buffer[0..], <br/>                                          '\n')) |tmp_line| {<br/>    // process each line<br/>}</span></pre><p id="e6ab" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我向您详细介绍了<code class="fe nj nk nl nm b">readSymTable</code>代码示例，以展示Zig如何处理许多在编写Go代码时容易被忽略的错误情况。在我在Zig ( <a class="ae lm" href="https://github.com/ordovician/Zacktron-33" rel="noopener ugc nofollow" target="_blank"> Zacktron-33 </a>)中实际实现<a class="ae lm" href="https://erik-engheim.medium.com/decimal-risc-cpu-a13968922812" rel="noopener"> Calcutron-33 </a>的过程中，除了最琐碎的功能之外，我对几乎任何功能都反复体验了这种好处。</p><p id="b717" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这种更高级的类型系统的缺点是复杂。你可以看到，为了解释这个相对简单的函数，我不得不涉及很多内容。意味着<code class="fe nj nk nl nm b">readUntilDelimiterOrEof</code>函数得到了复杂的返回类型<code class="fe nj nk nl nm b">!?[]u8</code>。我们用<code class="fe nj nk nl nm b">[]</code>来表示它是一个切片。<code class="fe nj nk nl nm b">?</code>表示类型是可选的，而<code class="fe nj nk nl nm b">!</code>表示可能返回一个错误。</p><pre class="ki kj kk kl gt nn nm no np aw nq bi"><span id="3dd7" class="nr lz it nm b gy ns nt l nu nv">fn readUntilDelimiterOrEof(self: Self, <br/>                            buf: []u8, <br/>                      delimiter: u8) !?[]u8</span></pre><h1 id="f584" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">正确性与简单性</h1><p id="f4e2" class="pw-post-body-paragraph kq kr it ks b kt mq ju kv kw mr jx ky kz ms lb lc ld mt lf lg lh mu lj lk ll im bi translated">现在，你可能知道为什么我很难决定我喜欢什么方法了。在Go中，编写代码检查返回的错误对象是否为<code class="fe nj nk nl nm b">nil</code>变得很繁琐。这也是一个你可能不总是记得要做的检查。例如，在下面的代码中，忘记在<code class="fe nj nk nl nm b">err</code>中存储错误对象不会产生编译错误。</p><pre class="ki kj kk kl gt nn nm no np aw nq bi"><span id="4b26" class="nr lz it nm b gy ns nt l nu nv">err := instruction.ParseOperands(labels, operands)<br/>if err != nil {<br/>    return 0, err<br/>}</span></pre><p id="6dec" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">根据我在Zacktron-33和其他各种玩具项目中的工作经验，在Zig中处理错误要顺利得多。但是这种平滑和更强的正确性保护是有代价的。正如你在我的<code class="fe nj nk nl nm b">readSymTable</code>演示中看到的，有更多的概念需要你保持头脑清醒。与使用<code class="fe nj nk nl nm b">readUntilDelimiterOrEof</code>的情况一样，同时处理错误对象和选项让我最初有些晕头转向。</p><p id="fc2b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">此外，在实践中，围棋并不像看起来那么糟糕。在典型的Go情况下，错误对象是两个值中的一个，例如:</p><pre class="ki kj kk kl gt nn nm no np aw nq bi"><span id="ecbf" class="nr lz it nm b gy ns nt l nu nv">machincode, err := instruction.MachineInstruction()<br/>if err != nil {<br/>    return 0, err<br/>}</span></pre><p id="ad5e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这些情况下，你不能取出你想要的值，除非你也取出错误对象。在Go中，如果你没有对返回的<code class="fe nj nk nl nm b">err</code>对象做任何导致编译错误的事情。因此，就像Zig迫使您在使用值之前打开它们一样，Go实际上也迫使您在大多数情况下处理错误对象。当返回的唯一对象是一个错误对象时，Go中就会出现问题。在这些情况下，很容易忘记获取和检查错误对象。</p><p id="35ff" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Zig错误处理也不是完美的。您只能返回枚举值，而Go允许您返回更复杂的错误对象，其中可能包含各种有用的信息。使用Zig，您需要提供第二个通道来提供关于发生的错误的注意细节。</p><h1 id="89d9" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">手动内存分配与垃圾收集</h1><p id="7e54" class="pw-post-body-paragraph kq kr it ks b kt mq ju kv kw mr jx ky kz ms lb lc ld mt lf lg lh mu lj lk ll im bi translated">垃圾收集当然很好，但是对于系统编程来说也有点麻烦。在实现操作系统内核或为微控制器编写程序时，您不希望使用垃圾收集器。游戏引擎开发人员也可能更喜欢手动管理内存分配，以避免由于垃圾收集周期开始而导致的任何突然的帧速率下降。这几乎适用于任何实时系统。</p><p id="61b8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然而，Go在实时系统方面做得比你所期望的带有垃圾收集器的语言好得多。Go被特别设计成不会产生大量垃圾，语言设计者总是优先考虑低延迟。</p><p id="0cf9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">补充一点相关的轶事:我和NASA的人聊过，他们热情地告诉我，他们在内部的许多实时系统中使用Go(而不是在他们的飞船、漫游者或类似的东西上)。</p><p id="a398" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">对于内存处理，我认为很难称之为赢家，因为Zig使得手动内存管理比我习惯的要好得多。下面是一个例子，说明我们如何分配字典来存储符号和它们相应的地址。注意到<code class="fe nj nk nl nm b">errdefer</code>语句了吗？</p><pre class="ki kj kk kl gt nn nm no np aw nq bi"><span id="a057" class="nr lz it nm b gy ns nt l nu nv">var labels = StringHashMap(u8).init(allocator);<br/>errdefer labels.deinit();</span></pre><p id="f50c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">正常情况下，我们会想要返回<code class="fe nj nk nl nm b">labels</code>字典，而不返回它。但是，如果出现错误，我们将无法正确初始化字典。在这些情况下，我们希望确保字典被释放，以避免内存泄漏。<code class="fe nj nk nl nm b">errdefer</code>语句只在返回一个<code class="fe nj nk nl nm b">error</code>对象的情况下执行。因此，在正常返回发生的情况下，不会执行<code class="fe nj nk nl nm b">labels.deinit()</code>语句。</p><p id="61ee" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在C程序中纠正这种行为要复杂得多。Zig的设计者安德鲁·凯利真的花了很多心思让手动内存管理尽可能顺利地工作。所有内存分配都必须通过您提供的分配器来完成。这适用于整个Zig标准库。因此，在开发Zig程序时，你使用一个特殊的分配器来检测内存泄漏、双释放和许多其他内存问题。这是我的Zig汇编程序的一个例子。</p><pre class="ki kj kk kl gt nn nm no np aw nq bi"><span id="c9c7" class="nr lz it nm b gy ns nt l nu nv">pub fn main() !void {<br/>    var gpa = std.heap.GeneralPurposeAllocator(.{}){};<br/>    defer _ = gpa.deinit();<br/>    const allocator = gpa.allocator();<br/><br/>	// get command line arguments<br/>    const args = try process.argsAlloc(allocator);<br/>    defer process.argsFree(allocator, args);<br/><br/>    var filename: []const u8 = undefined;<br/><br/>    if (args.len == 2) {<br/>        filename = args[1];<br/>    } else {<br/>        try stderr.print("Usage: assembler filename\n", .{});<br/>        try stderr.print("\nAssembly of {s}:\n", .{filename});<br/>        return<br/>    }<br/><br/>    try assembleFile(allocator, filename, stdout);<br/>}</span></pre><p id="c00f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您将会注意到，任何需要内存的东西都会首先请求一个分配器。一旦退出函数范围，我们使用<code class="fe nj nk nl nm b">defer</code>来释放已分配的内存。</p><p id="a81f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">作为一个老的C开发人员，我很喜欢这种对内存使用的完全控制。它让你在使用需要分配内存的解决方案时三思。它直接影响了我在编写Zig代码时的设计决策，从而降低了内存的使用。</p><p id="da08" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一个缺点是，像闭包和使用<code class="fe nj nk nl nm b">map</code>、<code class="fe nj nk nl nm b">filter</code>和<code class="fe nj nk nl nm b">reduce</code>的函数式编程变得相当困难。另一方面，在系统编程语言中，这不是你主要关心的。</p><p id="0bbc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因此，手动内存管理、错误处理和选项都是非常积极的体验，让我喜欢上了Zig。因此，问题是到底是什么让我接近放弃？</p><h1 id="7ba7" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">是什么让我差点放弃齐格</h1><p id="c8ae" class="pw-post-body-paragraph kq kr it ks b kt mq ju kv kw mr jx ky kz ms lb lc ld mt lf lg lh mu lj lk ll im bi translated">Zig真的像打了类固醇的C。这类似于采用一种与C语言功能相似的语言，并加上严格得多的类型系统，使C语言成为一种更安全的语言。这肯定有它的魅力，但是对于我这个终端用户来说，在处理对象时，它确实引起了很多挫折。Zig标准库是面向对象的。事物被组织成具有功能的结构。它们看起来有点像方法，但更像名称空间和语法糖。</p><p id="f977" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我在Go中的<code class="fe nj nk nl nm b">Assemble</code>函数允许我提供各种I/O对象，汇编器可以从中读取源代码进行汇编，I/O对象将结果写入其中。</p><pre class="ki kj kk kl gt nn nm no np aw nq bi"><span id="f2bc" class="nr lz it nm b gy ns nt l nu nv">func Assemble(reader io.Reader, writer io.Writer) error {<br/>	// implementation<br/>}</span></pre><p id="d74e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Go中的<code class="fe nj nk nl nm b">Reader</code>和<code class="fe nj nk nl nm b">Writer</code>界面使用起来确实很灵活实用。下面是使用它们的一个例子:</p><pre class="ki kj kk kl gt nn nm no np aw nq bi"><span id="6231" class="nr lz it nm b gy ns nt l nu nv">func AssembleFile(filepath string, writer io.Writer) error {<br/>	file, err := os.Open(filepath)<br/>	if err != nil {<br/>		return err<br/>	}<br/>	defer file.Close()<br/><br/>	return Assemble(file, writer)<br/>}</span></pre><p id="14cd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我可以传递一个文件对象，因为它符合<code class="fe nj nk nl nm b">io.Reader</code>接口。然而，插座、管道或<code class="fe nj nk nl nm b">os.Stdin</code>也可以连接到<code class="fe nj nk nl nm b">io.Reader</code>接口。<code class="fe nj nk nl nm b">io.Writer</code>接口同样有用。您的代码不需要知道编写器是<code class="fe nj nk nl nm b">os.Stdout</code>、文件还是套接字。我写出这样的汇编机器码:</p><pre class="ki kj kk kl gt nn nm no np aw nq bi"><span id="e938" class="nr lz it nm b gy ns nt l nu nv">fmt.Fprintf(writer, "%04d", machinecode)</span></pre><p id="787b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe nj nk nl nm b">Fprintf</code>函数并不真正知道它将输出写到什么，只知道它是实现<code class="fe nj nk nl nm b">io.Writer</code>接口的某个对象。简而言之，这是一个伟大的抽象。</p><p id="93c3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Zig也处理读者和作者抽象，但问题是:它们不是真正的接口。就你所说的接口而言，它只是在编译时隐含存在的东西，而不是在运行时。在Zig标准库中，还有一个<code class="fe nj nk nl nm b">io.Writer</code>和<code class="fe nj nk nl nm b">io.Reader</code>。,</p><pre class="ki kj kk kl gt nn nm no np aw nq bi"><span id="5d70" class="nr lz it nm b gy ns nt l nu nv">// Doens't work<br/>const Writer = std.io.Writer;<br/>const Reader = std.io.Reader;<br/><br/>fn assemble(allocator: Allocator, <br/>            reader: Reader, // naive assumption about interfaces<br/>            writer: Writer) !void <br/>{<br/>   // implementation<br/>}</span></pre><p id="f1ed" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">问题是它们根本不是接口，而是用于在编译时创建读取器和写入器结构的函数。在编译时必须知道读取器和写入器的具体类型。出于这个原因，您必须在Zig中指定一个读取器和写入器作为<code class="fe nj nk nl nm b">anytype</code>。在Zig中，<code class="fe nj nk nl nm b">anytype</code>指的是在编译时根据您传递的参数确定的类型。</p><pre class="ki kj kk kl gt nn nm no np aw nq bi"><span id="93f4" class="nr lz it nm b gy ns nt l nu nv">// This works!<br/>fn assemble(allocator: Allocator, <br/>            reader: anytype, <br/>            writer: anytype) !void <br/>{<br/>   // implementation<br/>}</span></pre><p id="1183" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我认为这个解决方案的问题是与用户的沟通不清楚。您无法在代码中清楚地表达您想要什么类型的参数作为输入。当编译器对你大喊大叫时，你只会知道你得到了错误的输入。因此，从安全角度来看，这不是问题。然而，从可用性的角度来看，这是一个问题。在Zig中，文件对象不是一个阅读器，相反，你可以通过<code class="fe nj nk nl nm b">Reader</code>接口向它请求一个对象:</p><pre class="ki kj kk kl gt nn nm no np aw nq bi"><span id="3d46" class="nr lz it nm b gy ns nt l nu nv">const file: File = try dir.openFile(<br/>    filename,<br/>    .{ .read = true },<br/>);<br/>const reader = file.reader();</span></pre><p id="7937" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这就引出了一个问题:返回的<code class="fe nj nk nl nm b">reader</code>对象是什么类型的？我们可以看看<code class="fe nj nk nl nm b">File</code>的实现来了解一下:</p><pre class="ki kj kk kl gt nn nm no np aw nq bi"><span id="1420" class="nr lz it nm b gy ns nt l nu nv">pub const Reader = io.Reader(File, ReadError, read);<br/><br/>pub fn reader(file: File) Reader {<br/>    return .{ .context = file };<br/>}<br/><br/>pub fn read(self: File, buffer: []u8) ReadError!usize {<br/>    // implementation of function reading bytes from file<br/>}</span></pre><p id="aa1b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe nj nk nl nm b">io.Reader(File, ReadError, read)</code>调用在编译时构造一个新的类型<code class="fe nj nk nl nm b">Reader</code>。然而，每个Zig I/O对象都会在编译时进行相似类型的调用，创建不同的<code class="fe nj nk nl nm b">Reader</code>类型。<code class="fe nj nk nl nm b">io.Reader</code>给我们的是一个模板，可以为每个定义的新I/O类型快速生成新的<code class="fe nj nk nl nm b">Reader</code>类型。因此，我们正在从事一种模板编程的形式。没有接口的子类化或实现。虽然，人们可能会说编译时阅读器接口是令人满意的。</p><p id="2fd7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您可以了解如何使用<code class="fe nj nk nl nm b">Reader</code>函数为新的I/O类型生成读取器类型。这里是一个经过大量编辑和配对的<code class="fe nj nk nl nm b">Reader</code>函数版本。可以看到它返回了一个<code class="fe nj nk nl nm b">struct</code>。它接受一个<code class="fe nj nk nl nm b">readFn</code>参数，这是一个函数指针，由在返回的<code class="fe nj nk nl nm b">struct</code>上定义的<code class="fe nj nk nl nm b">read</code>成员函数使用。</p><pre class="ki kj kk kl gt nn nm no np aw nq bi"><span id="f6ae" class="nr lz it nm b gy ns nt l nu nv">pub fn Reader(<br/>    comptime Context: type,<br/>    comptime ReadError: type,<br/>    comptime readFn: fn (context: Context, buffer: []u8) ReadError!usize,<br/>) type {<br/><br/>    return struct {<br/>        pub const Error = ReadError;<br/>        context: Context,<br/>        const Self = @This();<br/><br/>        pub fn read(self: Self, buffer: []u8) Error!usize {<br/>            return readFn(self.context, buffer);<br/>        }<br/><br/>        pub fn readUntilDelimiterOrEof(self: Self, <br/>                                        buf: []u8, <br/>                                  delimiter: u8) !?[]u8 {<br/>        	// implementation edited out<br/>        }<br/><br/>        // more read functions<br/>    }<br/>}</span></pre><p id="1311" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">定义了许多不同的读取函数。我选择显示<code class="fe nj nk nl nm b">readUntilDelimiterOrEof</code>包含在这个读取函数列表中，因为我们已经在代码示例中介绍过了。</p><p id="4d03" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我展示这个的原因是为了证明在Zig中有很多机制可以实现类似于接口的东西，而且它们使用起来比Go中的接口更笨拙。从更大的范围来看，这就是项目的意义所在。它们是关于不同模块之间的接口。在这方面，我认为围棋重新获得了优势。</p><p id="e182" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">挖掘所有这些标准库代码来理解Zig接口让我想放弃整件事。我做了大约15年的C++开发人员，发誓再也不在复杂的编程语言上浪费时间了。尽管我在C++上下了很大功夫，但我从未觉得有所回报。我有点担心会再犯同样的错误。</p><h1 id="7497" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">我会和Zig在一起吗？你会吗？</h1><p id="6681" class="pw-post-body-paragraph kq kr it ks b kt mq ju kv kw mr jx ky kz ms lb lc ld mt lf lg lh mu lj lk ll im bi translated">齐格仍然让我着迷。Zig背后的一些关键人物，如安德鲁·凯利和洛里斯·克罗，让我对这个社区和这门语言的发展方向有了很好的感觉。我认为两人都在他们的视频和作品中表达了许多明智的想法。我必须为没有在Zig社区中说出其他重要的名字而道歉，但是当我试图学习这门语言时，安德鲁和洛里斯已经非常明显了。</p><p id="d49f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我认为他们正在类C语言领域做出一些最令人兴奋的创新，这是我们很久以来所看到的。我已经等了很多年了。可悲的是，这么长时间过去了，我对C编程的兴趣已经消退。我认为Zig真正的吸引力在于C程序员。如果你已经做了很多C编程，我敢打赌Zig将会带来巨大的好处，特别是如果你在内核、游戏引擎、微控制器或任何有很高性能要求或资源限制的系统上工作。</p><p id="4846" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">目前我更倾向于围棋，但我认为Zig未来的发展可能会改变我的想法。Zig在几个方面比Go做得更好，但这部分是以语言工具不太友好为代价的。对于IDE来说，Go更容易解析。在编写我的汇编程序时，我注意到VS代码中的Go支持更好，这让我受益匪浅。</p><p id="86a5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这可能是一个不公平的比较，因为Zig要年轻得多，但是这种语言的本质应该使解析Zig代码更加困难。例如，无法确定什么函数将对类型为<code class="fe nj nk nl nm b">anytype</code>的参数起作用。</p><p id="2990" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当然，如果你们继续大量阅读我的Zig故事，我将被迫继续学习Zig😉</p></div></div>    
</body>
</html>