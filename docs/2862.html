<html>
<head>
<title>React Hooks: Inverting Container/Presenter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应挂钩:反转容器/演示器</h1>
<blockquote>原文：<a href="https://itnext.io/react-hooks-inverting-container-presenter-5758a1dfdaa?source=collection_archive---------0-----------------------#2019-08-16">https://itnext.io/react-hooks-inverting-container-presenter-5758a1dfdaa?source=collection_archive---------0-----------------------#2019-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/5b04da3712ce6822b174dabaca70e01e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ltW1DpRzmTClp3pa"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@she_sees?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">夏洛特·康尼比尔</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><div class=""/><div class=""><h2 id="1037" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">或者:我是如何学会停止担忧并热爱结束的</h2></div><p id="bfef" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">反应钩子已经完全从基于职业的原始软泥中爆发出来。</p><p id="93be" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">比我酷的人已经用了几十年了。谁还会使用类呢？你还在用类？？恶心！</p><p id="a461" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在他们到达后不久，我开始听到人们说“钩子取代了容器/展示者模式。”丹·阿布拉莫夫本人更新了他那篇著名的<a class="ae jd" href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" rel="noopener"> Medium文章，文章以一个警告开始:</a></p><blockquote class="lr"><p id="513e" class="ls lt jg bd lu lv lw lx ly lz ma lq dk translated"><em class="mb">我不建议再这样拆分你的组件了。</em> <strong class="ak"> <em class="mb">如果你觉得在你的代码库中很自然，这种模式就可以得心应手。但我已经多次看到它在没有任何必要的情况下，以近乎教条的热情被强制执行。</em> </strong></p></blockquote><p id="480c" class="pw-post-body-paragraph kv kw jg kx b ky mc kh la lb md kk ld le me lg lh li mf lk ll lm mg lo lp lq ij bi translated">我理解他关于“教条式热情”的观点，但不幸的是，他怀疑React中分离关注点的强大心理模型。</p><p id="7803" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我的第一个问题是“钩子将如何取代容器/展示者？”好吧，事实上，我看到了。您不再需要容器<em class="mh">组件</em>，因为有状态逻辑可以包含在自定义<em class="mh">钩子</em>中。可移植的状态，这实际上很好。</p><p id="8b87" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">HOCs？渲染道具？随着钩子应用的增加，这些可能会被淘汰。钩子给了你渲染道具的灵活性，而不需要在一个额外的组件中包装你的组件。</p><p id="6de0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当然，第一次接触React的开发人员将不得不考虑<code class="fe mi mj mk ml b">useEffect</code>和依赖数组的微妙之处，但是他们不需要记住一长串的生命周期方法。还记得你初来乍到时的反应吗？似乎每次你想出一个生命周期方法，就会有另外两个像九头蛇一样出现在它的位置上。更不用说他们的道具——“嗯，是<code class="fe mi mj mk ml b">prevProps/prevState</code>还是<code class="fe mi mj mk ml b">nextProps/nextState</code>？我想我会再次打开旧的开发工具。"</p><p id="a1b2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不管怎样，我说到哪了…容器/呈现器真正的好处是它鼓励你将关注点分开。您的容器处理状态/数据，而您的呈现者——漂亮而纯粹——持有UI，两者之间有一条清晰的分界线。他们的关系很清楚:容器…包含…呈现者。它在React架构模型中创建了一个自然的层次结构。</p><h1 id="b114" class="mm mn jg bd mo mp mq mr ms mt mu mv mw km mx kn my kp mz kq na ks nb kt nc nd bi translated">颠倒过来</h1><p id="d87a" class="pw-post-body-paragraph kv kw jg kx b ky ne kh la lb nf kk ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">给我留下深刻印象的是，这种关系现在颠倒了。之前只负责UI的组件现在… <em class="mh">包含了容器</em>。</p><p id="5f25" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">似乎没有一个明确的方法可以将这两者分开。这让我开始思考。</p><p id="d92e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以拥有一个从有状态功能组件呈现的无状态表示组件:</p><pre class="nj nk nl nm gt nn ml no np aw nq bi"><span id="c3f0" class="nr mn jg ml b gy ns nt l nu nv">// Hook<br/>const useName = () =&gt; {<br/>  const [name, setName] = useState('DeeDee');<br/>  const onJoey = () =&gt; setName('Joey');<br/>  return { name, onJoey };<br/>}</span><span id="7126" class="nr mn jg ml b gy nw nt l nu nv">// Presenter<br/>const GabbaGreeting = ({ name, onJoey }) =&gt; (<br/>  &lt;div&gt;<br/>    Gabba gabba hey, {name}<br/>    &lt;button onClick={onJoey}&gt;Click to Joey-ify&lt;/button&gt;<br/>  &lt;/div&gt;<br/>);</span><span id="9ec6" class="nr mn jg ml b gy nw nt l nu nv">// Ugh.<br/>export default const NameContainer = (props) =&gt; {<br/>  const { name, onJoey } = useName();</span><span id="7d87" class="nr mn jg ml b gy nw nt l nu nv">  return &lt;GabbaGreeting name={name} onJoey={onJoey} /&gt;<br/>}</span></pre><p id="5437" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这工作，但是<code class="fe mi mj mk ml b">NameContainer</code>感觉像一个不必要的层。</p><h1 id="2161" class="mm mn jg bd mo mp mq mr ms mt mu mv mw km mx kn my kp mz kq na ks nb kt nc nd bi translated">然后就是测试。</h1><p id="c852" class="pw-post-body-paragraph kv kw jg kx b ky ne kh la lb nf kk ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">表示组件测试起来非常简单明了——纯功能、道具输入、UI输出。它们非常适合TDD，尤其是对于那些刚刚开始测试优先开发的开发人员。以这种方式编写组件确实能让你明白如何(以及为什么)将你的架构分成不同的层。既然表示性组件/元素现在从组件内部获得了属性/属性，那么如何测试现在有状态的功能组件的纯粹表示性部分呢？</p><p id="886e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我想到的一个方法是DI，在你的组件中注入一个定制的钩子，但是在尝试了一点之后，感觉很奇怪。另一个可能的解决方案是允许在你的定制钩子中设置初始值，但是这会变得复杂…</p><pre class="nj nk nl nm gt nn ml no np aw nq bi"><span id="204a" class="nr mn jg ml b gy ns nt l nu nv">const useForm = ({<br/>  initialValues,<br/>  initialErrors,<br/>  initialIsDirty,<br/>  initialIsLoading,<br/>  etc...<br/>}) =&gt; {<br/>  const [values, setValues] = useState(initialValues);<br/>  const [errors, setErrors] = useState(initialErrors);<br/>  const [isDirty, setIsDirty] = useState(initialIsDirty);<br/>  const [isLoading, setIsLoading] = useState(initialIsLoading);<br/>  etc...<br/>}</span></pre><h1 id="80a1" class="mm mn jg bd mo mp mq mr ms mt mu mv mw km mx kn my kp mz kq na ks nb kt nc nd bi translated">一个新的挑战者出现了</h1><p id="2da2" class="pw-post-body-paragraph kv kw jg kx b ky ne kh la lb nf kk ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">经过一番思考后，我想到了一个解决方案，感觉它有解耦、测试和简洁的潜力。我写了一个小库，<a class="ae jd" href="https://www.npmjs.com/package/react-hooks-compose" rel="noopener ugc nofollow" target="_blank"> react-hooks-compose </a>，它可以让你将钩子连接到表示组件。</p><pre class="nj nk nl nm gt nn ml no np aw nq bi"><span id="161d" class="nr mn jg ml b gy ns nt l nu nv">composeHooks({ useMyHook })(Presenter);</span></pre><p id="19c8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它有一个类似于<code class="fe mi mj mk ml b">react-redux</code>中的<code class="fe mi mj mk ml b">connect</code>的API，将钩子的返回值映射到道具。这是我们第一个例子的样子:</p><pre class="nj nk nl nm gt nn ml no np aw nq bi"><span id="3a70" class="nr mn jg ml b gy ns nt l nu nv">// You still have your Hook<br/>const useName = () =&gt; {<br/>  const [name, setName] = useState('DeeDee');<br/>  const onJoey = () =&gt; setName('Joey');<br/>  return { name, onJoey };<br/>}</span><span id="d4d3" class="nr mn jg ml b gy nw nt l nu nv">// You still have your Presenter<br/>const GabbaGreeting = ({ name, onJoey }) =&gt; (<br/>  &lt;div&gt;<br/>    Gabba gabba hey, {name}<br/>    &lt;button onClick={onJoey}&gt;Click to Joey-ify&lt;/button&gt;<br/>  &lt;/div&gt;<br/>);</span><span id="7002" class="nr mn jg ml b gy nw nt l nu nv">// What have we here? Say, that's pretty easy on the eyes!<br/>export default composeHooks({ useName })(GabbaGreeting);</span></pre><p id="65a2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它涵盖了所有3个痛点:它保持了事物的解耦性，使测试变得简单明了，并消除了讨厌的额外容器组件。</p><h1 id="b680" class="mm mn jg bd mo mp mq mr ms mt mu mv mw km mx kn my kp mz kq na ks nb kt nc nd bi translated">选择你自己的冒险</h1><p id="95fc" class="pw-post-body-paragraph kv kw jg kx b ky ne kh la lb nf kk ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">我用钩子越多，我就越…上瘾(唉)。挂钩的好处远远大于缺点，我们正处于一个有趣的时期，在这个时期我们可以进行实验，找到新的做事方法。最佳做法正在出现；我们应该让它们出现，而不是强加它们。如果我们继续尝试，继续玩，新的模式就会出现。</p><p id="093e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">老实说:我无视了不要完成我的项目并将它们转化为钩子的建议，并在这个过程中学到了很多。我喜欢“一切都只是函数”的一致性闭包在，<code class="fe mi mj mk ml b">this</code>在外。相对于钩子和渲染道具，我更喜欢钩子的人体工程学。</p><p id="3de9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">也许我想多了，也许这不是问题。也许有人会想出一个更好的主意。或者其他人也感受到了同样的痛苦，而<a class="ae jd" href="https://www.npmjs.com/package/react-hooks-compose" rel="noopener ugc nofollow" target="_blank">反应-挂钩-撰写</a>正是他们一直在寻找的解决方案！我所知道的是，现在我只是感到一点分离(担忧)的焦虑。</p></div></div>    
</body>
</html>