<html>
<head>
<title>All you’ll ever need to know about Chrome Extensions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你需要知道的关于Chrome扩展的一切</h1>
<blockquote>原文：<a href="https://itnext.io/all-youll-ever-need-to-know-about-chrome-extensions-ceede9c28836?source=collection_archive---------0-----------------------#2019-06-20">https://itnext.io/all-youll-ever-need-to-know-about-chrome-extensions-ceede9c28836?source=collection_archive---------0-----------------------#2019-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/dd9b62af55cc9c205934a2d9962f855a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h1-GqrRp_lPg3cDIUhiXTw.png"/></div></figure><p id="21c0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">听起来很有希望？希望如此！在这篇文章中，我将试图揭开开发Chrome扩展时你需要知道的一切。我确信在阅读完这篇文章后，您将能够很容易地开发自己的扩展，而不会有太多的麻烦。有许多事情要谈，所以让我们直接开始吧。</p><h1 id="7cd2" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">基本概念</h1><p id="40a5" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">当我们想到一个扩展(也称为插件)时，我们有时会想到谷歌浏览器工具栏右上角的图标。大多数人可能记得，当你点击这个图标时，通常会出现一个漂亮的弹出窗口。实际上，这只是扩展的一部分。扩展是由三(3)个独立部分组成的生态系统:</p><ol class=""><li id="7202" class="lv lw iq jw b jx jy kb kc kf lx kj ly kn lz kr ma mb mc md bi translated">当你点击工具栏中的图标时，你看到的<strong class="jw ir">弹出</strong>。</li><li id="22a1" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">在现有网站上运行的<strong class="jw ir">内容脚本</strong>。</li><li id="1f24" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">在谷歌浏览器后台运行的<strong class="jw ir">后台脚本</strong>。</li></ol><p id="8871" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">名字不是随便起的，就是这么叫的。这三(3)个部分彼此完全独立，服务于完全不同的目的。我知道这还不能说明什么，但是坚持住。我可以向您保证，在本文结束时，您将会有一个完整的了解。让我们一个一个地检查一下:</p><h2 id="ae1c" class="mj kt iq bd ku mk ml dn ky mm mn dp lc kf mo mp lg kj mq mr lk kn ms mt lo mu bi translated">弹出窗口</h2><p id="4fe8" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">正如我之前提到的,<strong class="jw ir">弹出窗口,</strong>,仅仅是你点击图标与插件交互时看到的UI。</p><blockquote class="mv"><p id="3880" class="mw mx iq bd my mz na nb nc nd ne kr dk translated">实际上，它只是一个典型的网站</p></blockquote><p id="d29d" class="pw-post-body-paragraph ju jv iq jw b jx nf jz ka kb ng kd ke kf nh kh ki kj ni kl km kn nj kp kq kr ij bi translated">是的，没错，它只是一个普通的网站<strong class="jw ir"> </strong>，唯一的区别是它从Chrome获得有限的资源。你可以在网站上做任何你想做的事情；写CSS，使用React，执行AJAX请求等。网站和Chrome扩展弹出窗口的唯一区别是，它需要注册为扩展弹出窗口。为此，你只需要添加一个名为<em class="nk"> manifest.json. </em>的额外文件，通过添加和配置它，你的网站就可以作为插件运行了。</p><figure class="nm nn no np gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi nl"><img src="../Images/0d8b5f629547b178cdba3bc3acad0eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1aphAfuJqKrdTCaz70ETHQ.jpeg"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">弹出的是你的网站代码+ manifest.json</figcaption></figure><p id="5d50" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="nk"> manifest.json </em>是Google为了配置您的扩展(以及其他)而读取的内容。为了演示，选择任意目录并创建一个简单的HTML文件，文件名为<em class="nk">index.html</em>:</p><pre class="nm nn no np gt ny nz oa ob aw oc bi"><span id="852f" class="mj kt iq nz b gy od oe l of og">&lt;html&gt;<br/>  &lt;body&gt;<br/>    &lt;h1&gt;Hello world&lt;/h1&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="e924" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，在同一个目录下，创建一个<em class="nk"> manifest.json </em>文件，并填充以下基本内容:</p><pre class="nm nn no np gt ny nz oa ob aw oc bi"><span id="cd41" class="mj kt iq nz b gy od oe l of og">{<br/>  "name": "My plugin",<br/>  "version": "0.0.1",<br/>  "description": "This is the full description of the plugin",<br/>  "manifest_version": 2<br/>}</span></pre><p id="1463" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们还没有做任何与扩展相关的事情。我们所做的只是创建了一个HTML和一个清单，其中只陈述了我们项目的一些信息。现在是时候将我们的项目标记为Chrome扩展了。编辑manifest.json并添加以下几行:</p><pre class="nm nn no np gt ny nz oa ob aw oc bi"><span id="d802" class="mj kt iq nz b gy od oe l of og">{<br/>  "name": "My plugin",<br/>  "version": "0.0.1",<br/>  "description": "This is the full description of the plugin",<br/>  "manifest_version": 2,<br/>  <strong class="nz ir">"browser_action": {<br/>    "default_popup": "./index.html",<br/>    "default_title": "Open the popup",<br/>    "default_icon":"./image.png"<br/>  }</strong><br/>}</span></pre><p id="d5ca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> <em class="nk"> browser_action </em> </strong>键实质上翻译成“给我我需要的信息，以便创建一个扩展扩展弹出窗口”。我们告诉Google“当用户点击扩展图标(<strong class="jw ir"><em class="nk">【default _ icon】)</em></strong>，向他们显示一个弹出窗口，其内容可以在<strong class="jw ir"><em class="nk">default _ popup</em></strong><em class="nk">中找到。</em>此外，当他们悬停在扩展的图标上时，向他们显示在<strong class="jw ir"><em class="nk">default _ title</em></strong>下找到的文本。现在我们剩下要做的就是将插件加载到浏览器中。我们有两种方法:</p><h2 id="30f1" class="mj kt iq bd ku mk ml dn ky mm mn dp lc kf mo mp lg kj mq mr lk kn ms mt lo mu bi translated"><strong class="ak"> 1。自动通过Chrome商店</strong></h2><p id="6ed3" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">导航到商店中的插件页面，然后点击“安装插件”(类似于Google Play)</p><blockquote class="oh oi oj"><p id="1b9a" class="ju jv nk jw b jx jy jz ka kb kc kd ke ok kg kh ki ol kk kl km om ko kp kq kr ij bi translated">对生产部署有用</p></blockquote></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><h2 id="a4e7" class="mj kt iq bd ku mk ml dn ky mm mn dp lc kf mo mp lg kj mq mr lk kn ms mt lo mu bi translated"><strong class="ak"> 2。手动浏览chrome://extensions页面</strong></h2><p id="deb4" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">通过选择“Load unpacked ”,加载包含我们工作的文件夹</p><blockquote class="oh oi oj"><p id="cd4d" class="ju jv nk jw b jx jy jz ka kb kc kd ke ok kg kh ki ol kk kl km om ko kp kq kr ij bi translated">对当地发展有用</p></blockquote><p id="c463" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">或者，打包(压缩)文件，然后通过选择单个压缩文件来选择“加载打包”</p><blockquote class="oh oi oj"><p id="6279" class="ju jv nk jw b jx jy jz ka kb kc kd ke ok kg kh ki ol kk kl km om ko kp kq kr ij bi translated">有助于与他人分享工作</p></blockquote></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><p id="ff62" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们商店里还没有，所以我们要用手动的方式。我们将遵循第一种方法，我们将加载我们工作的“解包”版本，通过向google指示我们的文件所在的文件夹。</p><p id="df30" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在谷歌浏览器上导航至<code class="fe ou ov ow nz b">chrome://extension</code>。</p><figure class="nm nn no np gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi ox"><img src="../Images/101ffd1849a7595259da620f504f5f7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kk9Pw8tyI_SEpAoqED68UA.jpeg"/></div></div></figure><p id="3c30" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">从那里，打开开发者模式(右上角的开关)。</p><figure class="nm nn no np gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi oy"><img src="../Images/3659499bbd4a87a85e4c83a695ad56df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m3uZ4tfooz7fssAWtA-dpA.jpeg"/></div></div></figure><p id="3d3d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">点击右上角的“Load unpacked”按钮。</p><figure class="nm nn no np gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi oz"><img src="../Images/48966c5365ed7dc3929184050d8ce5d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*91ZRdxzhsb0gvWBAobiRfg.jpeg"/></div></div></figure><p id="ba9e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">选择包含2个文件的文件夹(外加一个图标图像)。</p><figure class="nm nn no np gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi pa"><img src="../Images/9e2ae0c4ec33a7e7c5ec73cb7dd64f43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gx5ayx4DuDvZ5TOVf8OcYA.jpeg"/></div></div></figure><p id="2f46" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果一切顺利，你应该会在主页和工具栏上看到你的插件。</p><figure class="nm nn no np gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi pb"><img src="../Images/2337a146d7639f0472b5f2e51c15b637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MM4fOVQJ26tVn8LWh8SlEQ.jpeg"/></div></div></figure><p id="c3ba" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，如果您单击工具栏图标，您应该会看到我们添加的HTML:</p><figure class="nm nn no np gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi pc"><img src="../Images/d0a46475bb7380c7c7c5a7d06e81979e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YjUIipR5XGZKlHS6vTUQpg.jpeg"/></div></div></figure><p id="180c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">恭喜你。您已经成功创建了一个小插件！现在你可能会认为这只是一个“你好世界”，但不要被骗了。这是一个功能齐全的网站。你可以在一个典型的网站上做任何你通常会做的事情。你可以让<em class="nk">index.html</em>加载javascript文件、css文件、字体等。如果愿意，您可以在其中创建一个React应用程序。字面意思，任何东西！有一点要知道，每次你关闭它，就好像你关闭了一个网站的标签。存储在内存中的所有内容都会丢失，就像网站刷新后会发生的情况一样。毕竟是网站啊！</p><p id="b71a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那么，为什么我们首先要有一个弹出窗口呢？它主要是为你的用户提供一个用户界面。它为插件提供了一个很好的与用户互动的方式，这样用户就可以对某些事情进行输入/反馈。有趣的是，插件的核心功能通常不存储在那里，因为那是由<strong class="jw ir">内容脚本</strong>或<strong class="jw ir">后台脚本</strong>来处理的。</p><h2 id="a42d" class="mj kt iq bd ku mk ml dn ky mm mn dp lc kf mo mp lg kj mq mr lk kn ms mt lo mu bi translated">内容脚本</h2><p id="7dd8" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">这些是添加到网站顶部的CSS和JS文件。这意味着你可以在网站上添加额外的文件，就好像它们是由最初的开发者自己添加的一样。你见过一些扩展是如何操纵你在页面中看到的东西的吗？他们就是这么做的！他们只是添加了额外的<strong class="jw ir"> </strong> Javascript和/或CSS。您可以添加任意数量的额外文件，只要您在清单中指定它们。</p><p id="b0fc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了展示他们的能力，我们将修改我们之前的例子，并给它一些额外的功能。把所有谷歌网站的背景颜色都改成红色，这看起来并不好玩，所以我们就这么做吧。创建一个<em class="nk"> content.css </em>文件，并向其中添加以下代码:</p><pre class="nm nn no np gt ny nz oa ob aw oc bi"><span id="51f2" class="mj kt iq nz b gy od oe l of og">body {<br/>  background-color: red !important;<br/>}</span></pre><p id="b3ac" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">另外，为什么不写一些javascript呢？让我们创建一个<em class="nk"> content.js </em>文件，并确保每次用户单击页面中的任何位置时，都会显示一个警告:</p><pre class="nm nn no np gt ny nz oa ob aw oc bi"><span id="11a7" class="mj kt iq nz b gy od oe l of og">document.addEventListener('click', () =&gt; alert('Click occurred!'));</span></pre><p id="df20" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，让我们将这两个文件注册为<strong class="jw ir">内容脚本</strong>。为此，我们需要指定将这些脚本“添加到”哪些网站。这是通过“<em class="nk">matches”</em>键完成的，这是一个正则表达式模式，可以让你针对任何网站，从每一个网站到特定的网站。在我们的例子中，我们希望向所有以<strong class="jw ir">google.com</strong>结尾的网站注册我们的内容脚本。为此，让我们更改我们的<em class="nk"> manifest.json </em>并添加以下代码:</p><pre class="nm nn no np gt ny nz oa ob aw oc bi"><span id="3041" class="mj kt iq nz b gy od oe l of og">{<br/>  "name": "My plugin",<br/>  "version": "0.0.1",<br/>  "description": "This is the full description of the plugin",<br/>  "manifest_version": 2,<br/>  "browser_action": {<br/>    "default_popup": "./index.html",<br/>    "default_title": "Open the popup",<br/>    "default_icon":"./image.png"<br/>  },<br/>  <strong class="nz ir">"content_scripts": [<br/>    {<br/>      "js": ["content.js"],<br/>      "css": ["content.css"],<br/>      "matches": ["https://*.google.com/*"]<br/>    }<br/>  ]</strong><br/>}</span></pre><p id="c364" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">点击插件卡中的刷新图标，重新加载插件，可在<code class="fe ou ov ow nz b">chrome://extensions</code>下找到:</p><figure class="nm nn no np gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi pd"><img src="../Images/b556042c2315d1bbec0625c3a2136446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*omlOwxkdUI7ikSx1avhIow.jpeg"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">清单更新后刷新插件数据</figcaption></figure><p id="2b29" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，试着打开google.com。您应该会看到类似这样的内容:</p><figure class="nm nn no np gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi pe"><img src="../Images/959f5eddf8f39f9219b36bdb7a7c881b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*joEKkpak1THZ2-3PZZYWEA.jpeg"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">CSS内容脚本的修改</figcaption></figure><p id="da9f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你试图点击任何地方，你应该看到一个可怕的警告弹出:</p><figure class="nm nn no np gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi oz"><img src="../Images/3cdb0c5ecded9d10b246fe44c6566aae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IQ_CAXboOJyYswUa1BbbQA.jpeg"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">JS内容脚本的修改</figcaption></figure><p id="0ad9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我知道这很愚蠢，但请从全局来看。你可以添加任何你想要的东西到任何你想要的网站。您可以在网站的DOM元素上安装React应用程序，并在现有网站旁边运行您自己的React应用程序！这些脚本会在网站打开后立即加载，并保持活动状态，直到相应的标签关闭。把它们想象成网站会自己加载的普通脚本。</p><h2 id="27cb" class="mj kt iq bd ku mk ml dn ky mm mn dp lc kf mo mp lg kj mq mr lk kn ms mt lo mu bi translated">后台脚本</h2><p id="1efc" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">让我们暂时忘记我们正在处理的虚拟扩展，假设我们想要同步用户已经下载到远程repo的所有文件。我们需要一个脚本来持续监控Chrome的下载，但是我们应该把它放在哪里呢？我们不会把它放在内容脚本中，因为它只会在特定页面加载时加载。我们也不会把它放在弹出窗口中，因为它的脚本只在你打开弹出窗口时运行，一旦你关闭弹出窗口就停止运行。嗯，这是后台脚本的工作。</p><p id="d5b0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这些JS脚本运行在页面的上下文之外，但是在浏览器的上下文之内。当你安装插件时，它们被激活<strong class="jw ir">一次</strong>，并且——只要插件保持安装——只要它们至少注册了一(1)个监听器，它们就保持活动状态。后台脚本停止运行的唯一方式是如果它真的没有任何事情可做。如果你让它监视或监听什么，它会一直在后台运行，耐心等待...呃，有点吓人。</p><p id="f179" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">后台脚本是Chrome Extension生态系统中最稳定的部分，因为它们不容易被“突然杀死”。内容脚本和弹出窗口中的脚本的生命周期取决于相应的网站和弹出窗口。相反，后台脚本依赖于您的扩展，因此只要它保持安装状态，脚本就会以守护程序的方式在后台运行。</p><p id="5038" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了试探一下，我们先创建一个文件<em class="nk"> background.js </em>，并向其中添加一个简单的警告:</p><pre class="nm nn no np gt ny nz oa ob aw oc bi"><span id="006c" class="mj kt iq nz b gy od oe l of og">alert('Hello from background script!');</span></pre><p id="c610" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在让我们通过调整<em class="nk"> manifest.json </em>来确保在我们的扩展中将它注册为后台脚本，如下所示:</p><pre class="nm nn no np gt ny nz oa ob aw oc bi"><span id="b950" class="mj kt iq nz b gy od oe l of og">{<br/>  "name": "My plugin",<br/>  "version": "0.0.1",<br/>  "description": "This is the full description of the plugin",<br/>  "manifest_version": 2,<br/>  "browser_action": {<br/>    "default_popup": "./index.html",<br/>    "default_title": "Open the popup",<br/>    "default_icon":"./image.png"<br/>  },<br/>  "content_scripts": [<br/>    {<br/>      "js": ["content.js"],<br/>      "css": ["content.css"],<br/>      "matches": ["https://*.google.com/*"]<br/>    }<br/>  ],<br/>  <strong class="nz ir">"background": {<br/>    "scripts": ["background.js"]<br/>  }</strong><br/>}</span></pre><p id="e0ec" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，如果我们刷新插件(就像上一个例子)，你应该会立即看到一个警告。</p><figure class="nm nn no np gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi oy"><img src="../Images/38ce72f6f2fa2b49056a7c756e5e9113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LVxncmO3X8s4AGyYmr0uIA.jpeg"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">后台脚本的激活</figcaption></figure><p id="073b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">正如我们之前提到的，一旦安装了扩展，后台脚本就会被激活<strong class="jw ir">一次。如果您停用&amp;重新激活插件(通过上面截图中可见的开关)，您将再次看到此警报。</strong></p><h1 id="891e" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">把所有的放在一起</h1><p id="bd47" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">如前所述，我们的生态系统有三个部分:弹出窗口、内容脚本和后台脚本。让我们确保我们做对了:</p><ul class=""><li id="9c67" class="lv lw iq jw b jx jy kb kc kf lx kj ly kn lz kr pf mb mc md bi translated"><strong class="jw ir">弹出:</strong>插件的自定义UI。你可以定义HTML，CSS，JS，弹出相关的图片。它的行为完全像一个典型的网站。每当你切换弹出窗口，就好像你在刷新一个网站！(即数据被重置)</li><li id="b0bf" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr pf mb mc md bi translated"><strong class="jw ir">后台脚本:</strong>每个扩展安装<strong class="jw ir">时在后台运行一次的JS脚本集合。</strong>用于配置&amp;设置，我们只声明一次&amp;不想关闭或重置(全局监听器等)。).</li><li id="d8ea" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr pf mb mc md bi translated"><strong class="jw ir">内容脚本:</strong>添加到网站代码中的脚本集合，就好像它们是网站自带的一样。可以访问DOM中的所有内容。对于以任何方式与页面的DOM交互都很有用。</li></ul><p id="ea64" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一个插件必须注册<strong class="jw ir">至少</strong>其中之一，否则它一开始就没有理由成为一个插件。尽管所有这些部分都是可选的(例如，您可能不需要弹出窗口，因为您不想公开任何接口)，但仍然必须声明其中的至少一个(1)。</p><figure class="nm nn no np gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi pg"><img src="../Images/906bff7bb1fdcd24af02a24c9f6579d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*akq504VG4j4QoI3ZqmjZpQ.jpeg"/></div></div></figure><p id="b002" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所有这三个独立的部分都生活在他们自己的小世界里。它们是完全沙箱化的，彼此不了解，因此不能直接<strong class="jw ir">访问彼此。相反，它们依靠Chrome定义的一组API来交换信息。如果您曾经使用过web workers，您可能已经看到过，其中主&amp;工作线程通过消息<strong class="jw ir">相互通信。</strong>这里有大量的API(确切地说是63个),我们不可能涵盖所有的，但是我会确保我浏览了核心的API，因为我很少发现自己使用任何其他的API，除非我正在构建一些非常具体的东西。</strong></p><h1 id="7ca1" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">Chrome APIs</h1><p id="9c6f" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">正如上面提到的，它们为你的扩展提供了一种让Chrome为你做事情的方式。你可以询问用户的标签，访问他们的下载，他们的浏览历史，等等。除了一些例外，每个API都有一个特定的权限。权限注册在<em class="nk"> manifest.json </em>中，是一种告诉用户“嘿，我的插件将要访问这个、这个和那个”的方式。这类似于原生应用程序的工作方式，其中许多应用程序在下载时需要访问特定的API，如相机。如果你没有指定某个API的权限，Google现在会允许你使用。</p><h2 id="e10b" class="mj kt iq bd ku mk ml dn ky mm mn dp lc kf mo mp lg kj mq mr lk kn ms mt lo mu bi translated">消息传递(运行时)API</h2><p id="cd0e" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">这是一个广泛的范围，包含了扩展生态系统中用于消息交换的所有方法，并且不需要任何权限。目前有两种不同的方式将消息从分机的一部分发送到另一部分:</p><ol class=""><li id="bb0b" class="lv lw iq jw b jx jy kb kc kf lx kj ly kn lz kr ma mb mc md bi translated"><strong class="jw ir">一次性</strong>消息请求(把它们想象成一个HTTP请求)</li><li id="c1e7" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated"><strong class="jw ir">长期存在的</strong>连接(把它们想象成一个websocket)</li></ol><p id="bb92" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第一个向您想要的任何目标发送一次性消息，类似于在DOM中触发的事件。对于每个请求消息，都可以有一个可选的响应消息，这就是为什么我将它与典型的HTTP请求相关联。</p><pre class="nm nn no np gt ny nz oa ob aw oc bi"><span id="f525" class="mj kt iq nz b gy od oe l of og">// send a message<br/>chrome.runtime.sendMessage({ greeting: 'hello '}, response =&gt; <br/>  console.log(response.farewell)<br/>});</span><span id="1cd8" class="mj kt iq nz b gy ph oe l of og">// respond to a message<br/>chrome.runtime.onMessage.addListener(request,sender, sendResponse =&gt; <br/>  if (request.greeting === 'hello') {<br/>    sendResponse({ farewell: 'goodbye' })<br/>  }<br/>});</span></pre><p id="0e6a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">不幸的是，如果你是垃圾邮件，那么走这条路不是很有效。相反，您可以选择第二个选项，创建一个可以随意向其发送垃圾邮件的端口。它可以处理大量流量，但不幸的是，它没有提供响应消息的机制。因此，如果你依赖于一个回应，那么第一个选择就是要走的路。</p><pre class="nm nn no np gt ny nz oa ob aw oc bi"><span id="fde8" class="mj kt iq nz b gy od oe l of og">// connect to a custom channel/port<br/>const port = chrome.runtime.connect({ port: 'foo' });</span><span id="41b8" class="mj kt iq nz b gy ph oe l of og">// push a message to the channel<br/>port.sendMessage({ greeting: 'hello' });</span><span id="75ea" class="mj kt iq nz b gy ph oe l of og">// react to the message (can't respond back!)<br/>port.onMessage.addListener(request =&gt; {<br/>  if (request.greeting === 'hello') {<br/>    console.log('received a hello message');<br/>  }<br/>});</span></pre><p id="7a01" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当目标是背景脚本或弹出窗口时，<code class="fe ou ov ow nz b">chrome.runtime</code>就可以了。你可以在它的<a class="ae pi" href="https://developers.chrome.com/extensions/runtime" rel="noopener ugc nofollow" target="_blank">文档页面</a>找到你可能需要的所有信息。不幸的是，如果您的目标是内容脚本，那么您需要指定您希望哪个选项卡接收此消息。为了找到您想要的选项卡(例如，在我们之前的示例中包含“google.com”的选项卡)，您必须利用tabs API。</p><h2 id="2e8f" class="mj kt iq bd ku mk ml dn ky mm mn dp lc kf mo mp lg kj mq mr lk kn ms mt lo mu bi translated">标签API</h2><p id="70ee" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">tabs API允许你与chrome窗口打开的所有标签进行交互。您可以查询当前活动的标签，强制标签后退/前进，打开，关闭，缩放等。这是一个非常强大的API，这就是为什么它的大多数方法都需要在<em class="nk"> manifest.json </em>中设置<code class="fe ou ov ow nz b">"tabs"</code>权限。你可以在它的<a class="ae pi" href="https://developers.chrome.com/extensions/tabs" rel="noopener ugc nofollow" target="_blank">对应的API文档页面</a>中找到你需要的所有信息。</p></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><p id="03d7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们重新看看我们最初的例子，我们把谷歌页面的背景颜色设置为红色。想象一下，我们想要调整它，以便允许用户选择背景颜色。我们想让他们选择通过弹出UI来指定它，然后从内容脚本中读取他们的选择。为此，我们需要同时使用消息传递和标签API。简而言之，我们将允许用户通过输入字段输入颜色，当他们单击“应用”按钮时，我们将向所有加载了“google.com”的选项卡的内容脚本发送包含所选颜色的一次性消息。听起来很有趣？同样，最有可能不是…</p><p id="0da2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们需要做的第一件事是请求读取用户标签的权限:</p><pre class="nm nn no np gt ny nz oa ob aw oc bi"><span id="4e8e" class="mj kt iq nz b gy od oe l of og">{<br/>  "name": "My plugin",<br/>  "version": "0.0.1",<br/>  "description": "This is the full description of the plugin",<br/>  "manifest_version": 2,<br/>  "browser_action": {<br/>    "default_popup": "./index.html",<br/>    "default_title": "Open the popup",<br/>    "default_icon":"./image.png"<br/>  },<br/>  "content_scripts": [<br/>    {<br/>      "js": ["content.js"],<br/>      "css": ["content.css"],<br/>      "matches": ["https://*.google.com/*"]<br/>    }<br/>  ],<br/>  "background": {<br/>    "scripts": ["background.js"]<br/>  },<br/>  <strong class="nz ir">"permissions": [<br/>    "tabs"<br/>  ]</strong><br/>}</span></pre><p id="00ca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，让我们修改我们弹出窗口的<em class="nk">index.html</em>来容纳前面提到的输入&amp;按钮:</p><pre class="nm nn no np gt ny nz oa ob aw oc bi"><span id="7917" class="mj kt iq nz b gy od oe l of og">&lt;html&gt;<br/>  &lt;body&gt;<br/>    &lt;input id="colour-input" type="text" /&gt;<br/>    &lt;button id="colour-submit-btn"&gt;Apply&lt;/button&gt;</span><span id="bbc2" class="mj kt iq nz b gy ph oe l of og">    &lt;script src="./popup.js" /&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="ded4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们也创建一个<em class="nk"> popup.js </em>来处理按钮的点击:</p><pre class="nm nn no np gt ny nz oa ob aw oc bi"><span id="0a5f" class="mj kt iq nz b gy od oe l of og">document<br/>.querySelector('#colour-submit-btn')<br/>.addEventListener('click', () =&gt; {</span><span id="0ced" class="mj kt iq nz b gy ph oe l of og">  // read the colour that the user has selected<br/>  const colour = document.querySelector('#colour-input').value;</span><span id="8932" class="mj kt iq nz b gy ph oe l of og">  // get all the google tabs and send a message to their tabs <br/>  chrome.tabs.query({ url: 'https://*.google.com/*' }, tabs =&gt; {<br/>    tabs.forEach(tab =&gt; <br/>      chrome.tabs.sendMessage(tab.id, { colour } )<br/>    );<br/>  });</span><span id="6e35" class="mj kt iq nz b gy ph oe l of og">});</span></pre><p id="b579" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，让我们在内容脚本中处理消息。然后，让我们修改<em class="nk"> content.js </em>来处理我们的自定义一次性消息:</p><pre class="nm nn no np gt ny nz oa ob aw oc bi"><span id="208f" class="mj kt iq nz b gy od oe l of og">chrome.runtime.onMessage.addListener(request =&gt; {<br/>  if (request.colour) {<br/>    document.body.style.backgroundColor = request.colour;<br/>  }<br/>});</span></pre><p id="eedc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们都准备好了！在我们刷新插件之前，让我们清除<em class="nk"> content.css </em>和<em class="nk"> background.js、</em>中的所有内容<strong class="jw ir">和</strong>，因为我们不再需要它们了。现在刷新和繁荣:</p><figure class="nm nn no np gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi pe"><img src="../Images/9222f040018a7e62390e2107d47f9800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f1Q0GYYR-DzK8lZIAtaOvg.jpeg"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">用户通过弹出窗口的输入选择了“黑色”作为背景色</figcaption></figure><p id="36e0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它真他妈的管用！请注意，如果我们刷新页面，我们的更改不是持久的。这是因为我们的内容脚本只对消息做出反应，但是在启动时，我们不会从弹出窗口向它发送任何消息。理想情况下，我们希望将选择存储在某个地方，以便内容脚本可以读取它，并在加载时应用它。为此，我们将利用存储API。</p><h2 id="e480" class="mj kt iq bd ku mk ml dn ky mm mn dp lc kf mo mp lg kj mq mr lk kn ms mt lo mu bi translated">存储API</h2><p id="ffe1" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">存储API是Chrome的“localstorage”版本，但以异步方式实现。无论何时你想跨会话存储一些东西，以便整个插件生态系统能够阅读<strong class="jw ir">，</strong>那么这应该是你的首选。如果你想知道，这两个内容脚本&amp;都有自己的本地存储，但是由于它们是沙箱化的，它们不能访问彼此的实例。目前有两(2)个版本的存储API: <strong class="jw ir">本地</strong>和<strong class="jw ir">同步:</strong></p><ol class=""><li id="69e0" class="lv lw iq jw b jx jy kb kc kf lx kj ly kn lz kr ma mb mc md bi translated"><strong class="jw ir"> local </strong>将数据存储到本地实例Chrome(你的PC)中，不依赖于任何用户。</li><li id="1e83" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated"><strong class="jw ir"> sync </strong>将数据存储在“云中”,并将它们绑定到当前的Gmail帐户。这些数据可以在你登录的任何电脑上使用。</li></ol><p id="1f74" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">两者都有完全相同的API，选择什么取决于你的需求。这个API非常简单，给你:<code class="fe ou ov ow nz b">get</code>、<code class="fe ou ov ow nz b">set</code>、<code class="fe ou ov ow nz b">remove</code>、<code class="fe ou ov ow nz b">clear</code>和一个<code class="fe ou ov ow nz b">onChanged</code>监听器。你可以在文档中阅读所有相关内容<a class="ae pi" href="https://developer.chrome.com/apps/storage" rel="noopener ugc nofollow" target="_blank">。要使用存储API，您需要将<em class="nk">“storage”</em>权限添加到您的<em class="nk"> manifest.json. </em></a></p></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><p id="0506" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">记住这一点，让我们继续使用它来存储用户的偏好。每次用户选择一种颜色，我们都会将它保存在Chrome的存储器中(本地版本)。然后，一旦内容脚本启动，我们将尝试从之前的会话中恢复背景颜色。</p><p id="5f25" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们对我们的<em class="nk"> manifest.json做如下修改:</em></p><pre class="nm nn no np gt ny nz oa ob aw oc bi"><span id="d29a" class="mj kt iq nz b gy od oe l of og">{<br/>  "name": "My plugin",<br/>  "version": "0.0.1",<br/>  "description": "This is the full description of the plugin",<br/>  "manifest_version": 2,<br/>  "browser_action": {<br/>    "default_popup": "./index.html",<br/>    "default_title": "Open the popup",<br/>    "default_icon":"./image.png"<br/>  },<br/>  "content_scripts": [<br/>    {<br/>      "js": ["content.js"],<br/>      "css": ["content.css"],<br/>      "matches": ["https://*.google.com/*"]<br/>    }<br/>  ],<br/>  "background": {<br/>    "scripts": ["background.js"]<br/>  },<br/>  "permissions": [<br/>    "tabs",<br/><strong class="nz ir">    "storage"<br/></strong>  ]<br/>}</span></pre><p id="e723" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后保存用户的选择，只要用户选择一种新颜色，就添加下面的代码:</p><pre class="nm nn no np gt ny nz oa ob aw oc bi"><span id="fc4f" class="mj kt iq nz b gy od oe l of og">document<br/>.querySelector('#colour-submit-btn')<br/>.addEventListener('click', () =&gt; {</span><span id="1499" class="mj kt iq nz b gy ph oe l of og">// read the colour that the user has selected<br/>  const colour = document.querySelector('#colour-input').value;</span><span id="fa25" class="mj kt iq nz b gy ph oe l of og"><strong class="nz ir">// Store the user's data<br/>chrome.storage.local.set({ colour });</strong></span><span id="3645" class="mj kt iq nz b gy ph oe l of og">// get all the google tabs and send a message to their tabs <br/>  chrome.tabs.query({ url: 'https://*.google.com/*' }, tabs =&gt; {<br/>    tabs.forEach(tab =&gt; <br/>      chrome.tabs.sendMessage(tab.id, { colour } )<br/>    );<br/>  });</span><span id="fbee" class="mj kt iq nz b gy ph oe l of og">});</span></pre><p id="050e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，修改<em class="nk"> content.js </em>以从存储值启动:</p><pre class="nm nn no np gt ny nz oa ob aw oc bi"><span id="d6bf" class="mj kt iq nz b gy od oe l of og"><strong class="nz ir">chrome.storage.local.get('colour', (response) =&gt; {<br/>  if (response.colour) {<br/>    document.body.style.backgroundColor = response.colour;<br/>  }<br/>});</strong><br/><br/><br/>chrome.runtime.onMessage.addListener(request =&gt; {<br/>  if (request.colour) {<br/>    document.body.style.backgroundColor = request.colour;<br/>  }<br/>});</span></pre><p id="5306" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">就是这样！您现在可以持久化数据。</p><h1 id="c8d7" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">结束语</h1><p id="6c28" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">这篇文章的目的是让你对Chrome插件的底层基础设施感到舒适。我希望你记住的是，在一天结束的时候，一个扩展就像一个不同的&amp;孤立的脚本的集合，你可以彼此协调。实现这一点的核心API是标签、消息和存储，但Chrome <a class="ae pi" href="https://developers.chrome.com/extensions/api_index" rel="noopener ugc nofollow" target="_blank">有许多不同的API</a>。我鼓励你用1分钟的时间快速阅读他们的描述，因为你可以用它们来构建非常有趣的东西。希望你现在在创建自己的插件时更加自信，我会非常乐意回答你的任何问题。</p><p id="07d7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">感谢坚持到最后！</p><p id="bbe7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="nk">附:(1)确保通过</em> <code class="fe ou ov ow nz b"><em class="nk">chrome://extensions</em></code> <em class="nk">页面禁用或删除插件，因为背景颜色的变化会立即让你生气。</em></p><p id="937a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你想知道的话，devtools扩展只是一个弹出菜单，但是有不同的用户界面。适用于popup的规则也适用于devtools，只是您在manifest.json中的不同键下注册了它的HTML</p><p id="3002" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"><em class="nk">P . S③。</em>T12】👋<strong class="jw ir"> <em class="nk">嗨，我是</em> </strong> <a class="ae pi" href="https://aggelosarvanitakis.me" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> <em class="nk">阿盖洛斯</em> </strong> </a> <strong class="jw ir"> <em class="nk">！如果你喜欢这个，可以考虑在twitter上关注我，并与你的开发者朋友分享这个故事😀</em></strong></strong></p></div></div>    
</body>
</html>