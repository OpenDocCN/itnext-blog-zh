<html>
<head>
<title>Migrating from AngularJS to Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从角度迁移到角度</h1>
<blockquote>原文：<a href="https://itnext.io/migrating-from-angularjs-to-angular6-1458ae6c1bae?source=collection_archive---------2-----------------------#2019-04-25">https://itnext.io/migrating-from-angularjs-to-angular6-1458ae6c1bae?source=collection_archive---------2-----------------------#2019-04-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a690" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">运行AngularJS和Angular的混合系统架构</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dd4e805f17ed396c2eb82291486eadd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sSEMYKTDwQ_t9JTM5bvWhg.png"/></div></div></figure><h2 id="b3bd" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">介绍</h2><p id="2ae3" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">处理遗留代码/技术从来都不好玩，迁移之路也不总是像你希望的那样直截了当。如果你是一家小型创业公司，试图平衡业务需求、稀缺资源和紧迫的截止日期，事情会变得更加复杂。</p><p id="b7cd" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">这是我提供建议的一家初创公司面临的情况。</p><h2 id="2ff7" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">一点背景知识</h2><p id="94fe" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">这家初创公司在过去的两年里一直在开发SaaS，并且(当时)在全球拥有大约15个客户。在这两年中，他们的代码库增长得相当快，并导致了相当多的快速/不计后果的编写代码。这无可厚非，在创业世界中，当业务需求的发展速度超过你的预期，你开始为了数量而牺牲代码质量的时候，这是很常见的。</p><p id="0e41" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">系统架构非常简单。<br/>用AngularJS编写的前端应用程序(根据客户端的配置，在构建时被分成多个选定的模块)<br/>用Python 2.7和Django 1.9编写的后端应用程序，使用Mysql数据库<br/>用于运行异步任务的Celery</p><p id="c595" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">每个客户将在AWS上部署他们自己的隔离环境:<br/>·Django应用程序前面的Apache(部署在ELB后面的多个EC2实例上)<br/>·AngularJS构建部署在前面有CloudFront的单个S3存储桶上</p><h2 id="ec1b" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">迁移之路</h2><p id="8837" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">在开始迁移的几个月前，开发变得非常缓慢，功能没有快速推出，错过了最后期限，客户报告了我们推出的每个更新的更多问题。正是在这个时候，我们开始更认真地思考某种重构或重大改进。</p><p id="bb2c" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">我们不知道我们到底要“重构/改进”什么，所以我们从回答三个问题开始(我建议任何正在考虑迁移/重构的人认真思考如何回答这些问题):</p><h2 id="39de" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">第一个问题:为什么现在需要重构？</h2><p id="1426" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">这是一个需要回答的非常重要的问题，因为它有助于您理解迁移的价值，也有助于让团队专注于期望的结果。例如<em class="ml">因为我不喜欢代码的编写方式</em>不是足够好的理由。原因是必须有一个明确的价值主张，以某种方式直接或间接有利于客户。</p><p id="d934" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">对我们来说，主要是三件事。功能开发变得极其缓慢；<br/> 2。代码不可预测。我们会在应用程序的一个部分工作，而在没有意识到的情况下破坏其他3个部分；<br/> 3。单点故障:只有一名工程师完全了解FE代码库，只有他可以在代码库上开发新功能(这是一个只有5名工程师的团队)</p><p id="3ad1" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">所以我们的目标很简单:</p><blockquote class="mm mn mo"><p id="fb01" class="ln lo ml lp b lq mg jr ls lt mh ju lv mp mi lx ly mq mj ma mb mr mk md me mf ij bi translated">通过授权其他工程师开发有限元功能，提高有限元开发速度并消除简单故障点</p></blockquote><h2 id="bbdf" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">第二个问题:谁来完成迁移？</h2><p id="2dc7" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">你可以现在回答这个问题，也可以在第三个问题之后回答。根据公司的规模和可用的资源，可以是一个人、几个人、整个团队等等…</p><p id="293f" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">我们当时处境困难。唯一能做这件事的开发人员不能，因为他正忙于为我们的客户构建关键特性。幸运的是，我们有一个高级后端工程师想接触一些FE，所以他自愿承担这项任务。我们还决定<em class="ml">在2周内完成概念验证。</em>我们这样做是因为我们不知道找到解决方案需要多长时间，也不知道工程师是否真的能完成这项任务，因为他以前没有做过有限元分析。</p><p id="fe3e" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">第三个问题:我们实际上要做什么？<br/> </strong>这里的答案通常包括一些发现时间、一些技术提案和对整个团队选项的概述，同时权衡每个选项的利弊。</p><p id="d028" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">对我们来说，有一件事从一开始就很清楚:我们不想在AngularJS上投入任何资源来学习/招聘工程师。AngularJS已经进入长期支持阶段，我们不想让我们的工程师在一些可能不会给他们带来长期利益的事情上投入时间。这意味着重构现有的AngularJS代码是不可行的。所以我们开始寻找角度6 …</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="2175" class="mz ks iq bd kt na nb nc kw nd ne nf kz jw ng jx ld jz nh ka lh kc ni kd ll nj bi translated">迁移</h1><p id="bfd4" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">有多种方法可以让一个混合应用运行不同的框架。在回顾了一些选项后，我们决定——对我们来说——最好的前进方式是简单地部署两个独立的FE应用程序:传统AngularJS应用程序和新Angular js应用程序。这意味着一个应用程序上的任何状态都不能转移到另一个应用程序上，这对我们来说不是一件大事，因为只有<strong class="lp ir">新的</strong>模块将使用Angular开发，我们的模块不会彼此共享状态。</p><p id="036d" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">从客户端的角度来看，一切看起来就像一个应用程序，除了当它们在应用程序之间移动时需要重新加载页面。</p><p id="ff26" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">这种方法的优点</strong></p><ul class=""><li id="2e93" class="nk nl iq lp b lq mg lt mh la nm le nn li no mf np nq nr ns bi translated"><strong class="lp ir"> <em class="ml">速度</em> </strong>:在不清理遗留代码的情况下启动并运行某些东西</li><li id="e6e9" class="nk nl iq lp b lq nt lt nu la nv le nw li nx mf np nq nr ns bi translated"><strong class="lp ir"/></li><li id="7e32" class="nk nl iq lp b lq nt lt nu la nv le nw li nx mf np nq nr ns bi translated"><strong class="lp ir">停止遗留开发:</strong>我们停止向已经无法管理的代码库添加更多代码</li></ul><p id="b60d" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">这种方法的缺点:</strong></p><ul class=""><li id="465e" class="nk nl iq lp b lq mg lt mh la nm le nn li no mf np nq nr ns bi translated"><strong class="lp ir"> <em class="ml">维护遗留代码</em> </strong>:没有解决现有模块上的特性改进；旧模块仍将处于不确定的时间段内</li><li id="a048" class="nk nl iq lp b lq nt lt nu la nv le nw li nx mf np nq nr ns bi translated"><strong class="lp ir"> <em class="ml">复制部分代码:</em> </strong>由于新应用程序的外观和感觉必须与旧应用程序的任何主题相似，因此必须在两个地方都编写自定义组件。此外，布局的一些部分将不得不在新的应用程序复制(如标题，菜单等)..)对这些组件的任何更改都必须在两个应用程序中完成</li></ul><p id="49c1" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">我们已经知道了一个我们想要构建的新模块，所以我们从头开始了一个新的Angular 6项目，我们用这个新模块进行了为期两周的概念验证。</p><p id="0362" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">步骤1—相同域</strong></p><p id="5cd1" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">让两个应用程序在同一个域上运行，以便它们可以访问相同的cookies和本地数据。这非常重要，因为只有AngularJS应用程序会继续处理认证和授权。</p><p id="2b03" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">第2步——观感</strong></p><p id="81e6" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">这两款应用的目标都是让新应用看起来和原来的应用一样。所以我们:<br/>复制了所有的样式表<br/>实现了应用程序的基本布局(标题&amp;菜单抽屉)</p><p id="b667" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">步骤3 —认证&amp;授权</strong></p><p id="3b86" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">我们必须在Angular6应用程序中复制授权逻辑，并确保正确的会话令牌可用于访问模块</p><p id="217a" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">步骤4——应用程序之间的路由</strong></p><p id="2709" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">因为我们的主导航链接会把你带到任何一个应用，我们决定把所有的逻辑都转移到一个叫做<code class="fe ny nz oa ob b">menu-service</code>的后端服务。这将消除在两个应用程序中编写任何导航更改的需要，也将允许对我们显示的导航按钮进行更大的运行时控制。</p><p id="c3e1" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">示例:</p><pre class="kg kh ki kj gt oc ob od oe aw of bi"><span id="04f0" class="kr ks iq ob b gy og oh l oi oj">HEADER: Authorization: Bearer xxxxx<br/>GET menu-service/v1/menu/?type=0|1 (0: legacy, 1: new)<br/>[{<br/>  "slug": "refresh",<br/>  "name" : "Refresh",<br/>  "icon" : "fa-refresh",<br/>  "type" : 1  <br/> }, {<br/>  "slug": "module1",<br/>  "name" : "Module1",<br/>  "icon" : "fa-module1",<br/>  "type" : 1<br/>}, {<br/>  "slug": "module2",<br/>  "name" : "Module2",<br/>  "icon" : "fa-module2",<br/>  "type" : 0<br/>}, {<br/>  "slug": "logout",<br/>  "name" : "Logout",<br/>  "icon" : "fa-logout",<br/>  "type" : 0<br/>}]</span></pre><p id="2c46" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">在上面的例子中，基于<code class="fe ny nz oa ob b">type</code>值，我们识别出<code class="fe ny nz oa ob b">module1</code>和<code class="fe ny nz oa ob b">refresh</code>是指向新应用的链接，而<code class="fe ny nz oa ob b">module2</code>和<code class="fe ny nz oa ob b">logout</code>是旧应用中的链接。这个信息允许每个应用程序决定是使用内部路由机制还是进行重定向</p><p id="4aea" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">Angular应用程序中的路由示例(AngularJS做了类似的事情):</p><pre class="kg kh ki kj gt oc ob od oe aw of bi"><span id="2aa5" class="kr ks iq ob b gy og oh l oi oj">export class MenuService {<br/>  constructor(private router: Router) {  }</span><span id="3617" class="kr ks iq ob b gy ok oh l oi oj">  onMenuItemClicked(menuItem): void {<br/>    if (menuItem.type === 1) {<br/>      this.router.navigate([menuItem.slug])    <br/>    } else {   <br/>      const url = `${legacy_endpoint}/${menuItem.slug}`;<br/>      window.location.href = url      <br/>    } <br/>  }<br/>}</span></pre><p id="4090" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">步骤5——在真实环境中构建/部署</strong></p><p id="8a2c" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">正如我在开始时提到的，AngularJS应用程序被部署到AWS S3桶中，并通过Cloudfront公开，以利用AWS提供的大规模和全球分布式基础设施。</p><p id="c8d8" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">我们想要的结果如下:<em class="ml">任何具有url </em> <code class="fe ny nz oa ob b"><a class="ae ol" href="https://hostname/v2" rel="noopener ugc nofollow" target="_blank">https://hostname/v2</a>/</code> <em class="ml">的内容都被路由到Angular应用程序，其他内容都被路由到遗留的AngularJS应用程序。</em></p><p id="07b3" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">我们使用了<a class="ae ol" href="https://angular.io/guide/router#base-href" rel="noopener ugc nofollow" target="_blank"> base-href </a>，以确保我们的Angular6应用程序能够相应地构建</p><pre class="kg kh ki kj gt oc ob od oe aw of bi"><span id="32d5" class="kr ks iq ob b gy og oh l oi oj">ng build --base-href /v2/ --deploy-url /v2/</span></pre><blockquote class="mm mn mo"><p id="7891" class="ln lo ml lp b lq mg jr ls lt mh ju lv mp mi lx ly mq mj ma mb mr mk md me mf ij bi translated">不幸的是，我们无法使用AWS Cloudfront实现理想的路由行为。这是一个很大的失望，因为我们不得不转向一个次优的解决方案。(如果有人对如何在Cloudfront中做到这一点有任何建议，我很乐意倾听)</p></blockquote><p id="6212" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">我们以下面的结构结束:<br/>每个应用部署在一个NGINX Docker容器中</p><pre class="kg kh ki kj gt oc ob od oe aw of bi"><span id="9773" class="kr ks iq ob b gy og oh l oi oj"># AngularJS — Dockerfile:<br/>FROM nginx:alpine<br/>COPY dist /usr/share/nginx/html</span><span id="9aac" class="kr ks iq ob b gy ok oh l oi oj">--------------------------------------------------------------------</span><span id="0a6e" class="kr ks iq ob b gy ok oh l oi oj"># Angular6 — Dockerfile:<br/>FROM nginx:alpine<br/>COPY dist /usr/share/nginx/html/v2</span></pre><p id="c63d" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">带路径路由的AWS ALB</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/2e527fe701e6c72d22a5deafad828396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u7RaMp3B9RJDUJul3A-3Ug.png"/></div></div></figure><p id="8988" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">第六步:本地发展</strong></p><p id="e7b0" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">AngularJS应用程序的本地开发不需要改变。然而，为了在Angular6应用程序上进行开发，您还必须运行AngularJS应用程序，以便能够进行身份验证并获得适当的会话令牌。</p><p id="07de" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">我们已经使用Docker将我们的应用程序部署为容器。所以我们添加了一个<code class="fe ny nz oa ob b">Makefile</code>目标来运行Docker存储库中的最新内容</p><pre class="kg kh ki kj gt oc ob od oe aw of bi"><span id="8003" class="kr ks iq ob b gy og oh l oi oj"># Angular6 — Makefile:</span><span id="da67" class="kr ks iq ob b gy ok oh l oi oj">AWS_REPOSITORY = xxx.dkr.ecr.eu-central-1.amazonaws.com<br/>JS_APP_NAME = angular-js</span><span id="9138" class="kr ks iq ob b gy ok oh l oi oj">...</span><span id="f501" class="kr ks iq ob b gy ok oh l oi oj">run-local: <br/>  docker run -p 8080:80 $(AWS_REPOSITORY)/$(JS_APP_NAME):latest</span></pre></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="0e92" class="mz ks iq bd kt na nb nc kw nd ne nf kz jw ng jx ld jz nh ka lh kc ni kd ll nj bi translated">结论</h1><p id="8496" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">这可能不是最干净或最佳的解决方案，但这是实现我们目标的最快方法。这对我们来说是最重要的事情。</p><p id="743b" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">这篇文章的目的不是教你如何进行AngularJS到Angular6的迁移，而是展示我们处理这种任务的方法。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><p id="d1aa" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><a class="ae ol" href="https://ctt.ac/T7eSf" rel="noopener ugc nofollow" target="_blank">【点击推文(发送前可编辑)</a><a class="ae ol" href="https://ctt.ac/T7eSf" rel="noopener ugc nofollow" target="_blank"/><a class="ae ol" href="https://ctt.ac/T7eSf" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>