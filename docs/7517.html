<html>
<head>
<title>Exceptions in Java lambdas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java lambdas中的异常</h1>
<blockquote>原文：<a href="https://itnext.io/exceptions-lambdas-efba6c591483?source=collection_archive---------0-----------------------#2022-10-19">https://itnext.io/exceptions-lambdas-efba6c591483?source=collection_archive---------0-----------------------#2022-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3944276448e362f6a4c634e579203400.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9GoUyOi670_4j2lieZYjYw.jpeg"/></div></div></figure><p id="328b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Java引入了<em class="kw">检查异常</em>的概念。与早期的方法相比，强迫开发人员管理异常的想法是革命性的。</p><p id="3956" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如今，Java仍然是唯一广泛使用的提供检查异常的语言。例如，Kotlin中的每个异常都是未检查的。</p><p id="e564" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">即使在Java中，新特性也与检查异常不一致:Java内置函数接口的签名不使用异常。当在lambdas中集成遗留代码时，会导致代码变得繁琐。这在溪流中显而易见。</p><p id="d867" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我想更深入地探讨如何管理这样的问题。</p><h1 id="0909" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">代码中的问题</h1><p id="4f4a" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">这里有一个示例代码来说明这个问题:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="0f8e" class="mk kz iq mg b gy ml mm l mn mo">Stream.of("java.lang.String", "ch.frankel.blog.Dummy", "java.util.ArrayList")<br/>      .map(it -&gt; new ForNamer().apply(it))                      // 1<br/>      .forEach(System.out::println);</span></pre><ol class=""><li id="f973" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated">不编译:需要捕捉选中的<code class="fe my mz na mg b">ClassNotFoundException</code></li></ol><p id="9618" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们必须添加一个try/catch块来解决编译问题。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="4e92" class="mk kz iq mg b gy ml mm l mn mo">Stream.of("java.lang.String", "ch.frankel.blog.Dummy", "java.util.ArrayList")<br/>      .map(it -&gt; {<br/>          try {<br/>              return Class.forName(it);<br/>          } catch (ClassNotFoundException e) {<br/>              throw new RuntimeException(e);<br/>          }<br/>      })<br/>      .forEach(System.out::println);</span></pre><p id="2e55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加块违背了易于阅读的管道的目的。</p><h1 id="5008" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">将try/catch块封装到一个类中</h1><p id="f11d" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">为了恢复可读性，我们需要重构代码来引入一个新的类。IntelliJ IDEA甚至提出了一个记录:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b77c" class="mk kz iq mg b gy ml mm l mn mo">var forNamer = new ForNamer();                                  // 1<br/>Stream.of("java.lang.String", "ch.frankel.blog.Dummy", "java.util.ArrayList")<br/>      .map(forNamer::apply)                                     // 2<br/>      .forEach(System.out::println);</span><span id="0090" class="mk kz iq mg b gy nb mm l mn mo">record ForNamer() implements Function&lt;String, Class&lt;?&gt;&gt; {</span><span id="d80d" class="mk kz iq mg b gy nb mm l mn mo">    @Override<br/>    public Class&lt;?&gt; apply(String string) {<br/>        try {<br/>            return Class.forName(string);<br/>        } catch (ClassNotFoundException e) {<br/>            return null;<br/>        }<br/>    }<br/>}</span></pre><ol class=""><li id="dad1" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated">创建单个记录对象</li><li id="70fe" class="mp mq iq ka b kb nc kf nd kj ne kn nf kr ng kv mu mv mw mx bi translated">重复使用它</li></ol><h1 id="ef0a" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">尝试使用龙目岛</h1><p id="57f4" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">Project Lombok是一个编译时注释处理器，它生成额外的<em class="kw">字节码</em>。人们使用适当的注释并获得结果，而不必编写样板代码。</p><blockquote class="nh ni nj"><p id="a9ca" class="jy jz kw ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated">Project Lombok是一个java库，可以自动插入到你的编辑器和构建工具中，增加你的java的味道。再也不用编写另一个getter或equals方法了，有了一个注释，你的类就有了一个全功能的构建器，自动记录变量，等等。</p><p id="62d0" class="jy jz kw ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated"><em class="iq"> — </em> <a class="ae kx" href="https://projectlombok.org/" rel="noopener ugc nofollow" target="_blank"> <em class="iq">项目龙目岛</em> </a></p></blockquote><p id="9e46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Lombok提供了<code class="fe my mz na mg b">@SneakyThrow</code>注释:它允许抛出检查过的异常，而不用在方法签名中声明它们。然而，目前它并不适用于现有的API。</p><p id="22a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你是一个Lombok用户，请注意有一个<a class="ae kx" href="https://github.com/projectlombok/lombok/issues/3096" rel="noopener ugc nofollow" target="_blank">打开的GitHub问题</a>，状态为“已暂停”。</p><h1 id="dd45" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">平民郎来拯救</h1><p id="1b18" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated"><a class="ae kx" href="https://commons.apache.org/proper/commons-lang/" rel="noopener ugc nofollow" target="_blank"> Apache Commons Lang </a>是一个古老的项目。它在当时很普遍，因为它提供了本来可以成为Java API一部分的实用程序，但没有。这是一个比在每个项目中重新发明<code class="fe my mz na mg b">DateUtils</code>和<code class="fe my mz na mg b">StringUtils</code>更好的选择。在研究这篇文章的时候，我发现它仍然被很好的API定期维护。其中之一就是<code class="fe my mz na mg b">Failable</code> API。</p><p id="8695" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">API由两部分组成:</p><ol class=""><li id="f162" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated">一张包装纸包裹着一个<code class="fe my mz na mg b">Stream</code></li><li id="c756" class="mp mq iq ka b kb nc kf nd kj ne kn nf kr ng kv mu mv mw mx bi translated">签名接受异常的管道方法</li></ol><p id="4123" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一小段摘录:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/1c787ad2378d93b6ad84c762fe77febd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UQRAuhRFEQmmLvgjgpZ4mQ.png"/></div></div></figure><p id="f6a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代码最终变成了我们一开始期望的样子:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="20fd" class="mk kz iq mg b gy ml mm l mn mo">Stream&lt;String&gt; stream = Stream.of("java.lang.String", "ch.frankel.blog.Dummy", "java.util.ArrayList");<br/>Failable.stream(stream)<br/>        .map(Class::forName)                                    // 1<br/>        .forEach(System.out::println);</span></pre><h1 id="27f5" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">修复编译时错误是不够的</h1><p id="aca9" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">前面的代码在<em class="kw">运行时</em>抛出一个包装在<code class="fe my mz na mg b">UndeclaredThrowableException</code>中的<code class="fe my mz na mg b">ClassNotFoundException</code>。我们满足了编译器，但是我们没有办法指定预期的行为:</p><ul class=""><li id="733c" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv no mv mw mx bi translated">在第一个异常时抛出</li><li id="c5ac" class="mp mq iq ka b kb nc kf nd kj ne kn nf kr ng kv no mv mw mx bi translated">丢弃异常</li><li id="fe39" class="mp mq iq ka b kb nc kf nd kj ne kn nf kr ng kv no mv mw mx bi translated">聚合类和异常，这样我们可以在管道的最后阶段对它们进行操作</li><li id="39dd" class="mp mq iq ka b kb nc kf nd kj ne kn nf kr ng kv no mv mw mx bi translated">别的东西</li></ul><p id="c016" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了实现这一点，我们可以利用Vavr的力量。Vavr是一个为Java语言带来函数式编程能力的库:</p><blockquote class="nh ni nj"><p id="2339" class="jy jz kw ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated"><em class="iq"> Vavr core是Java的函数库。这有助于减少代码量并增加健壮性。迈向函数式编程的第一步是开始考虑不可变的值。Vavr提供了不可变的集合以及必要的函数和控制结构来操作这些值。结果是美丽的，只是工作。</em></p><p id="ed4f" class="jy jz kw ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated"><em class="iq">—</em><a class="ae kx" href="https://www.vavr.io/" rel="noopener ugc nofollow" target="_blank"><em class="iq">Vavr</em></a></p></blockquote><p id="6970" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们想要一个收集异常和类的管道。下面是API的摘录，描述了几个构建块。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/d9b7b30f6027078304caa9b4c1971bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e7ilrZt71vUoM10Jm3AZ3Q.png"/></div></div></figure><p id="726b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它转化为以下代码:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="0f0e" class="mk kz iq mg b gy ml mm l mn mo">Stream.of("java.lang.String", "ch.frankel.blog.Dummy", "java.util.ArrayList")<br/>      .map(CheckedFunction1.liftTry(Class::forName))            // 1<br/>      .map(Try::toEither)                                       // 2<br/>      .forEach(e -&gt; {<br/>          if (e.isLeft()) {                                     // 3<br/>              System.out.println("not found:" + e.getLeft().getMessage());<br/>          } else {<br/>              System.out.println("class:" + e.get().getName());<br/>          }<br/>      });</span></pre><ol class=""><li id="813c" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated">将呼叫打包到Vavr中<code class="fe my mz na mg b">Try</code></li><li id="d72f" class="mp mq iq ka b kb nc kf nd kj ne kn nf kr ng kv mu mv mw mx bi translated">将<code class="fe my mz na mg b">Try</code>转换成<code class="fe my mz na mg b">Either</code>来保存异常。如果我们不感兴趣，我们可以用一个<code class="fe my mz na mg b">Optional</code>来代替</li><li id="c47f" class="mp mq iq ka b kb nc kf nd kj ne kn nf kr ng kv mu mv mw mx bi translated">根据<code class="fe my mz na mg b">Either</code>是否包含异常<em class="kw">左</em>或预期结果<em class="kw">右</em>来行动</li></ol><p id="d717" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，我们一直停留在Java流的世界中。直到看起来不“好看”的<code class="fe my mz na mg b">forEach</code>才按预期工作。</p><p id="e6a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Vavr确实提供了自己的<code class="fe my mz na mg b">Stream</code>类，它模仿了Java <code class="fe my mz na mg b">Stream</code> API并增加了额外的特性。让我们用它来重写管道:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="fa80" class="mk kz iq mg b gy ml mm l mn mo">var result = Stream.of("java.lang.String", "ch.frankel.blog.Dummy", "java.util.ArrayList")<br/>        .map(CheckedFunction1.liftTry(Class::forName))<br/>        .map(Try::toEither)<br/>        .partition(Either::isLeft)                              // 1<br/>        .map1(left -&gt; left.map(Either::getLeft))                // 2<br/>        .map2(right -&gt; right.map(Either::get));                 // 3</span><span id="2b26" class="mk kz iq mg b gy nb mm l mn mo">result._1().forEach(<br/>  it -&gt; System.out.println("not found: " + it.getMessage()));   // 4<br/>result._2().forEach(<br/>  it -&gt; System.out.println("class: " + it.getName()));          // 4</span></pre><ol class=""><li id="c717" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated">将<code class="fe my mz na mg b">Either</code>的<code class="fe my mz na mg b">Stream</code>分成两个<code class="fe my mz na mg b">Stream</code>的元组</li><li id="6121" class="mp mq iq ka b kb nc kf nd kj ne kn nf kr ng kv mu mv mw mx bi translated">将左流从<code class="fe my mz na mg b">Either</code>的<code class="fe my mz na mg b">Stream</code>展平到<code class="fe my mz na mg b">Throwable</code>的<code class="fe my mz na mg b">Stream</code></li><li id="44a6" class="mp mq iq ka b kb nc kf nd kj ne kn nf kr ng kv mu mv mw mx bi translated">将右流从<code class="fe my mz na mg b">Either</code>的<code class="fe my mz na mg b">Stream</code>展平到<code class="fe my mz na mg b">Class</code>的<code class="fe my mz na mg b">Stream</code></li><li id="ef96" class="mp mq iq ka b kb nc kf nd kj ne kn nf kr ng kv mu mv mw mx bi translated">做我们想做的任何事</li></ol><h1 id="5af7" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="69d4" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">Java的最初设计大量使用了检查异常。编程语言的发展证明这不是一个好主意。</p><p id="e887" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Java流不能很好地处理检查异常。将后者集成到前者所必需的代码看起来并不怎么样。为了恢复我们期望的流的可读性，我们可以依赖Apache Commons Lang。</p><p id="4a35" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">汇编只代表了问题的一小部分。我们通常希望对异常采取行动，而不是停止管道或忽略异常。在这种情况下，我们可以利用Vavr库，它提供了一种更加实用的方法。</p><p id="e2c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在<a class="ae kx" href="https://github.com/ajavageek/lambdas-exceptions" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到这篇文章的源代码。</p><p id="b2fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更进一步:</strong></p><ul class=""><li id="5097" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv no mv mw mx bi translated"><a class="ae kx" href="https://www.baeldung.com/java-lambda-exceptions" rel="noopener ugc nofollow" target="_blank">Java 8 Lambda表达式中的异常</a></li><li id="919f" class="mp mq iq ka b kb nc kf nd kj ne kn nf kr ng kv no mv mw mx bi translated"><a class="ae kx" href="https://dzone.com/articles/how-to-handle-checked-exception-in-lambda-expressi" rel="noopener ugc nofollow" target="_blank">如何用Lambda表达式处理检查过的异常</a></li><li id="fb51" class="mp mq iq ka b kb nc kf nd kj ne kn nf kr ng kv no mv mw mx bi translated"><a class="ae kx" href="https://stackoverflow.com/questions/18198176/java-8-lambda-function-that-throws-exception" rel="noopener ugc nofollow" target="_blank">“stack overflow:抛出异常的Java 8 Lambda函数？”</a></li><li id="6210" class="mp mq iq ka b kb nc kf nd kj ne kn nf kr ng kv no mv mw mx bi translated"><a class="ae kx" href="https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/function/Failable.html" rel="noopener ugc nofollow" target="_blank">失败的JavaDoc </a></li><li id="b9aa" class="mp mq iq ka b kb nc kf nd kj ne kn nf kr ng kv no mv mw mx bi translated"><a class="ae kx" href="https://docs.vavr.io/" rel="noopener ugc nofollow" target="_blank"> Vavr </a></li><li id="681b" class="mp mq iq ka b kb nc kf nd kj ne kn nf kr ng kv no mv mw mx bi translated"><a class="ae kx" href="https://www.baeldung.com/exceptions-using-vavr" rel="noopener ugc nofollow" target="_blank">使用Vavr的Lambda表达式中的异常</a></li><li id="70bc" class="mp mq iq ka b kb nc kf nd kj ne kn nf kr ng kv no mv mw mx bi translated"><a class="ae kx" href="https://www.baeldung.com/vavr-java-streams" rel="noopener ugc nofollow" target="_blank"> Java流vs Vavr流</a></li></ul><p id="ecb5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">原载于</em> <a class="ae kx" href="https://blog.frankel.ch/exceptions-lambdas/" rel="noopener ugc nofollow" target="_blank"> <em class="kw">一个Java极客</em></a><em class="kw">2022年10月16日</em></p></div></div>    
</body>
</html>