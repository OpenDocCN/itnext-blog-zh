# 传送器:设计你自己的网络

> 原文：<https://itnext.io/teleporter-design-your-own-network-af20d12454be?source=collection_archive---------4----------------------->

你是否曾希望在工作时可以接入家庭网络？事情变得简单了…

![](img/c2cf1dd68de66627639e7447a54c6fac.png)

最近我一直在思考我们一年前做的一个项目，我们定制了 NGrok 代码来创建一个隧道解决方案，将基于 AWS 的浏览器连接到客户的本地 web 服务器，用于功能测试产品(Microfocus SRF)。我一直认为协议隧道是一个令人兴奋的概念，是一种在雷达下爬行的聪明方法，可以向相反方向发送请求，钻透令人窒息的保护漏洞，并建立不可能的连接。

我想到了创建类似的东西，这将有助于保护家庭自动化设置，并在不使用端口映射、设置 VPN 或严重影响网络性能的情况下将工作和家庭环境融合在一起。传送是我想出来的，从头开始写在 muxado 上，**并且设置起来很容易。**

## 使用

因此，在进一步解释之前，这里是如何使用它:

**本地机器上的演示:**

1.  下载最新建造的[传送点](https://github.com/amitbet/teleporter/releases/tag/1.0)
2.  在任一示例中使用“run.bat”在本地主机上运行几个节点
3.  将您的浏览器配置为使用现在在 localhost:10101 上运行的 socks5 代理来查看它的运行情况。

**建立真实网络:**

1.  安装一些免费的云服务器(GCP 会给你 300 美元一年，没有义务，只要输入信用卡信息，AWS 免费云服务器也是一个选择)
2.  在机器上放置一个节点，并向公众开放中继端口
3.  在你喜欢的机器上部署传送节点&配置(见下文)构建你自己的互联网！

## 配置文件结构:

该配置的设计基本上是自解释的，它保存了创建侦听器、建立连接和限制网络访问的所有信息。默认规则是拒绝访问，当前请求将被路由到允许所请求地址的第一个节点。

传送配置文件分为 3 个部分:

*   **服务器**:创建两种不同类型的监听器:socks5 代理&中继
*   **Tethers** :定义与其他节点上中继端口的连接
*   **netConf** :包含节点的 ID 和映射规则，允许访问可从该节点到达的资源，这部分配置在连接到其他节点时发送给它们，这实现了智能路由。映射规则是按顺序执行的，它们规定了下一步将为路由选择哪个节点，选择“本地”意味着请求已经到达目的地，应该在当前机器上运行。

```
{
    "servers": [
        {
            "port": 10101,
            "type": "socks5",
            "acceptLocalOnly": true,
            "useAuthentication": true,
            "authClients": {
                "socks5User": "<SECRET STRING>"
            }
        }
    ],
    "tethers": [
        {
            "port": 10201,
            "host": "127.0.0.1",
            "connectionType": "tls",
            "connectionName": "Connection to node2",
            "proxy": {
                "address": "<proxy address>"
                "user":"<optional proxy user>"
                "pass":"<optional proxy password>"
            },
            "password": "<SECRET STRING>"
        }
    ],
    "netConf": {
        "clientId": "node1",
        "networkMapping": {
            **// send all *google* domain requests through node2**
            "*google*": "node2",
           ** //if not captured with prev rules - execute locally**
            "*": "local"
        }
    },
    "proxy": null,
    "numConnsPerTether": 10
}
```

## 潜在用途:

*   保持与家用设备的安全连接，无需端口映射
*   无缝 RDP/VNC 到多个网络，以实现远程支持
*   创建从客户站点到云服务的安全代理连接
*   无需您的 IT 部门的帮助，弥合网络差距
*   无需使用 VPN 即可保持工作连接
*   用作自定义 VPN 来欺骗您的来源，保护您的隐私并获得基于位置的服务
*   通过 socks5 代理和一些中继向潜在客户或云测试场公开本地 web 服务器

## 安全功能:

*   节点间连接(网络)是 TLS 加密的
*   Socks5 连接可以受密码保护(尽管没有加密)
*   Socks5 连接可以被限制为只接受来自本地主机的连接
*   中继服务器验证(客户端在服务器配置中有一个密码)

## 瞬移不就是另一个 VPN 吗？

我思考这个问题已经有一段时间了:VPN、隧道和 Socks5 已经存在很多年了，这个想法以前有过吗？事实证明，有很多类似的东西:OpenVPN、BadVPN & Brook，仅举几个例子，但每一个在一些基本方面都是不同的。但是 VPN 本质上是点对点隧道，通过加密通道将你带入网络，就像传送一样:

*   **Teleporter 在每个隧道的多个 TCP 通道上使用多路复用**，大多数 VPN 在较低的网络层上运行，其他 VPN(如 OpenVPN)依赖 UDP 作为其主要传输方式，以避免[线路头问题](https://en.wikipedia.org/wiki/Head-of-line_blocking)，有一些实现支持 TCP 隧道，但使用单一 TCP 连接，并认为这是在特定情况下使用的糟糕解决方案。TCP 支持允许通过大多数公司环境限制的隧道，这些限制基于只允许 TCP 在端口 80/443 上或使用 HTTP 代理，使用多个连接这样做可以避免在未知或丢失的 TCP 数据包后面阻塞浏览器连接。
*   **Teleporter 只中继指定地址的请求，**它创建了一个极度分裂的隧道，让用户完全控制路由，这意味着大多数请求可以在本地处理，没有延迟或网络成本。这些特定的地址是你的偏远地方(如家里)，或被你的工作网络屏蔽的地址(如:box.com，thepiratebay 等)。)对于在本地执行的流量，几乎没有性能损失，而对于从未到达过的站点，只需支付少量的性能费用，这样就可以进行家庭访问，而不必进行杂乱的端口映射，以免将您的家庭机器暴露给公共互联网上的攻击者。Socks5 不使用多路复用，也是未加密的，这意味着本地流量没有握手延迟或加密开销。
*   **Teleporter 轻松创建多跳网络**，这不是典型的 VPN 设置
*   **Teleporter 非常容易设置:**只需更改 JSON 文件中的几行，在几台机器上运行单个二进制文件就可以为自己创建一个分布式网络，设置浏览器或 OS 代理通过本地 socks5 代理运行，就大功告成了。
*   **传送机内置于 Go** 中，所以它很容易编译到所有主流操作系统中。
*   在 Teleporter(未来功能)中，重写规则可以用来拥有一个“CNAME ”,比如:home.com 代表你的家庭机器地址。

## 它是如何工作的？

每个传送节点都能够创建中继服务器、socks5 服务器，并将连接束(也称为系绳)连接到其他中继节点，一个系绳拥有多个 TCP 连接，每个连接都能够进行 TCP 多路复用。每个这样的系绳都是双向的，允许任何一方发起请求。

## 完整的故事

我们最初的解决方案基于 NGrok 1.0，在浏览器机器上添加了 http 代理服务器，这意味着对于每个浏览器连接，我们都创建了从代理到隧道服务器、从隧道客户端到隧道服务器以及从隧道客户端到 web 服务器的连接。在我们构建它并开始致力于连接缓存和重用之后，我认为“这可以通过多路复用来更好地解决”，但是当深入研究这个主题时，我发现由于 TCP 要求每个数据包都有一个 ACK，所以它往往会被卡住(T4 的线路头问题)，UDP 应该用于这样的解决方案，但是 UDP 不会通过大多数公司的设置， 永远不要把 WAF 传递到 AWS 农场……我决定放弃这个话题，但我脑海中的某个角落一直在唠叨，应该有更好的方法 ..所以我创建了**传送点**作为辅助项目来更好地探索可能性。