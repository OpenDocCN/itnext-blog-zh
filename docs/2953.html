<html>
<head>
<title>A deep dive guide into JavaScript Symbols (ES-6 and beyond)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript符号的深度指南(ES-6及更高版本)</h1>
<blockquote>原文：<a href="https://itnext.io/a-deep-dive-guide-into-javascript-symbols-es-6-and-beyond-8e23e1432215?source=collection_archive---------5-----------------------#2019-09-05">https://itnext.io/a-deep-dive-guide-into-javascript-symbols-es-6-and-beyond-8e23e1432215?source=collection_archive---------5-----------------------#2019-09-05</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div class="gi gj jr"><img src="../Images/391a9e7e1c753c5d53e0172abf7c147e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*agH9yprjUyvYvq8jqXCQww.png"/></div></figure><p id="8bdf" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">ES2015增加了大量有用的新功能，其中包括符号类型。符号让我们避免了属性名冲突，我们几乎可以在JavaScript对象中实现私有属性。</p><p id="8ded" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">在我看来，符号类型的主要吸引力在于:</p><pre class="kw kx ky kz gu la lb lc ld aw le bi"><span id="3fc0" class="lf lg iu lb b gz lh li l lj lk">const _note_key = Symbol('key');<br/>const _note_title = Symbol('title');<br/>const _note_body = Symbol('body');  </span><span id="6f8d" class="lf lg iu lb b gz ll li l lj lk">module.exports = class Note {<br/>     constructor(key, title, body) {<br/>         this[_note_key] = key;<br/>         this[_note_title] = title;<br/>         this[_note_body] = body;<br/>     }</span><span id="2809" class="lf lg iu lb b gz ll li l lj lk">     get key() { return this[_note_key]; }<br/>     get title() { return this[_note_title]; }<br/>     set title(newTitle) { this[_note_title] = newTitle; }<br/>     get body() { return this[_note_body]; }<br/>     set body(newBody) { this[_note_body] = newBody; }<br/>};</span></pre><p id="bfcb" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">我们已经定义了一个类，<em class="lm"/>，其属性的键是使用符号实例定义的。然后我们添加了<em class="lm"> get </em>和<em class="lm"> set </em>函数来访问属性。目标是，符号的不透明性将使这些属性足够私有，这样其他代码就不能访问它们。</p><p id="61ba" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">换句话说，我们有了像私有财产一样行走和说话的东西，即使这些领域不是真正的私有。</p><p id="63d1" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">正如我在别处提到的，JavaScript不允许我们实现完全私有的属性。但它足以提供少量的保护。参见:<a class="ae ln" href="https://techsparx.com/nodejs/esnext/class-data-hiding.html" rel="noopener ugc nofollow" target="_blank">JavaScript ES-2015类中的隐藏数据、创建封装</a></p><p id="3af3" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">同时，更好地理解JavaScript符号对象是有用的。</p><h1 id="b5ed" class="lo lg iu bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">JavaScript符号对象概述</h1><p id="27c3" class="pw-post-body-paragraph jy jz iu ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv in bi translated">在ES6中，Symbol成为了JavaScript中一种新的原始类型。符号是这样创建的:</p><pre class="kw kx ky kz gu la lb lc ld aw le bi"><span id="5540" class="lf lg iu lb b gz lh li l lj lk">&gt; const sym2 = Symbol();<br/>&gt; console.log(sym2);<br/>Symbol()<br/>&gt; const sym = Symbol('description');<br/>&gt; console.log(sym);<br/>Symbol(description)</span></pre><p id="a583" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">符号由工厂函数<code class="fe mq mr ms lb b">Symbol()</code>创建。您可以像第一个实例一样创建一个空符号，或者给它一个描述字符串。</p><p id="c53f" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">符号实例的关键属性是每个都是唯一的。</p><pre class="kw kx ky kz gu la lb lc ld aw le bi"><span id="c0ef" class="lf lg iu lb b gz lh li l lj lk">&gt; Symbol('description') === Symbol('description')<br/>false</span></pre><h1 id="742c" class="lo lg iu bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">使用符号实例作为对象键</h1><p id="b8bf" class="pw-post-body-paragraph jy jz iu ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv in bi translated">我们已经在前面定义的Note类中看到了这一点。但是我们先用一个简单的例子来尝试一下。</p><pre class="kw kx ky kz gu la lb lc ld aw le bi"><span id="b800" class="lf lg iu lb b gz lh li l lj lk">&gt; const obj = {}; <br/>&gt; obj <br/>{} <br/>&gt; const name = Symbol('name'); <br/>&gt; const addr = Symbol('addr'); <br/>&gt; obj[name] = "John Smith"; <br/>'John Smith' <br/>&gt; obj[addr] = "123 Main St"; <br/>'123 Main St' <br/>&gt; obj <br/>{ [Symbol(name)]: 'John Smith', [Symbol(addr)]: '123 Main St' } <br/>&gt;</span></pre><p id="5d32" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">该对象开始是空的，但现在有两个字段，每个字段的关键字是符号实例。访问这些字段的唯一方法是拥有那个确切的符号实例。</p><pre class="kw kx ky kz gu la lb lc ld aw le bi"><span id="bd99" class="lf lg iu lb b gz lh li l lj lk">&gt; obj.name <br/>undefined <br/>&gt; obj[name] <br/>'John Smith' <br/>&gt; obj[Symbol('name')] <br/>undefined</span></pre><p id="5c5c" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">请记住，每个符号实例都是唯一的。访问该字段的唯一方法是使用正确的符号实例。创建符号实例时传递的<em class="lm">描述</em>字符串完全是为了您的利益。</p><h1 id="481c" class="lo lg iu bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">符号实例不是对象</h1><p id="9a41" class="pw-post-body-paragraph jy jz iu ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv in bi translated">说<em class="lm">符号对象</em>很有诱惑力，但那是不正确的。</p><pre class="kw kx ky kz gu la lb lc ld aw le bi"><span id="4534" class="lf lg iu lb b gz lh li l lj lk">&gt; const name = Symbol(‘name’); <br/>&gt; typeof name <br/>‘symbol’ <br/>&gt; name instanceof Object <br/>false</span></pre><p id="6a04" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">换句话说，符号实例不是对象，因为它们不是对象类型的实例。相反，它们是符号类型的实例。</p><h1 id="a576" class="lo lg iu bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">使用符号来识别概念</h1><p id="b773" class="pw-post-body-paragraph jy jz iu ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv in bi translated">符号实例的一个可能用途是标识概念值。在许多语言中，我们能够定义全局常量——例如在C或C++中，预处理器让我们<code class="fe mq mr ms lb b">#define</code>一个可以在整个应用程序中使用的常量。</p><p id="1480" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">假设你想用一种象征性的方式来描述一些颜色:</p><pre class="kw kx ky kz gu la lb lc ld aw le bi"><span id="db56" class="lf lg iu lb b gz lh li l lj lk">exports.COLOR_RED = Symbol('Red');<br/>exports.COLOR_ORANGE = Symbol('Orange');<br/>exports.COLOR_YELLOW = Symbol('Yellow'); <br/>exports.COLOR_GREEN = Symbol('Green');<br/>exports.COLOR_BLUE = Symbol('Blue');<br/>exports.COLOR_VIOLET = Symbol('Violet');</span></pre><p id="b583" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">任何使用这个模块的代码都可以引用使用这个导出的<code class="fe mq mr ms lb b">COLOR_RED</code>概念。应用程序中的任何代码都可以引用<code class="fe mq mr ms lb b">COLOR_RED</code>，并知道它引用的是该符号的同一个实例。</p><p id="97f9" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">只是不要试图在另一个应用程序中使用这些符号值。请记住，每个符号实例都是唯一的。即使有可能将一个符号实例保存到数据库中，那也是没有用的，因为在另一个应用程序中<code class="fe mq mr ms lb b">Symbol('description')</code>有不同的值。</p><h1 id="dc70" class="lo lg iu bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">使用符号定义对象中的半私有属性</h1><p id="6da2" class="pw-post-body-paragraph jy jz iu ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv in bi translated">我们现在可以回到顶部的例子。</p><p id="3f3c" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">在典型的JavaScript实践中，一个对象实例可能通过这个或那个模块将混合的<em class="lm">片段</em>附加到对象上。按照惯例，一个对象的公共字段用一个<em class="lm">字符串</em>键来标识，使得访问该字段变得容易。但是存在这样的风险，两个附加私有属性的模块可能使用相同的密钥字符串，导致名称冲突。如果这些模块使用符号实例，就不会有名称冲突。</p><p id="10de" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">使用这种做法，我们可以避免名称冲突。</p><pre class="kw kx ky kz gu la lb lc ld aw le bi"><span id="d1f3" class="lf lg iu lb b gz lh li l lj lk">&gt; const obj = {}; <br/>undefined <br/>&gt; obj[Symbol(‘foo’)] = ‘bar’; <br/>‘bar’ <br/>&gt; obj[Symbol(‘foo’)] = ‘bar’; <br/>‘bar’ <br/>&gt; obj <br/>{ [Symbol(foo)]: ‘bar’, [Symbol(foo)]: ‘bar’ }</span></pre><p id="1198" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">即使在每次赋值时传递了相同的描述字符串，对象最终还是有两个字段，因为每个符号实例都是唯一的。这可能是将字段附加到同一个对象的两个模块，每个模块都使用<code class="fe mq mr ms lb b">Symbol('foo')</code>作为键，但是因为它们使用了一个符号，所以保证不会影响到彼此。</p><p id="825b" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">我们得不到完全的隐私。你可以清楚地看到这个对象有两个属性。如果有正确的符号实例，这两个字段的值都可以访问，并且可以更改。</p><p id="c579" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">一些检索对象键列表的机制没有告诉我们哪些键是符号实例。</p><pre class="kw kx ky kz gu la lb lc ld aw le bi"><span id="71c2" class="lf lg iu lb b gz lh li l lj lk">&gt; Object.keys(obj)<br/>[]<br/>&gt; Object.getOwnPropertyNames(obj)<br/>[]<br/>&gt; for (let key in obj) { console.log(key); }<br/>undefined<br/>&gt;<br/>&gt; obj['public'] = 'public value';<br/>'public value'<br/>&gt; <br/>&gt; obj<br/>{ public: 'public value', [Symbol(foo)]: 'bar', [Symbol(foo)]: 'bar' }<br/>&gt; <br/>&gt; Object.keys(obj);<br/>[ 'public' ]</span></pre><p id="73a2" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">使用前面定义的同一个对象，我们看到<code class="fe mq mr ms lb b">keys</code>和<code class="fe mq mr ms lb b">getOwnPropertyNames</code>函数没有告诉我们关于符号实例的按键。循环也没有告诉我们这些键。但是一旦我们添加了一个键是普通字符串的字段，<code class="fe mq mr ms lb b">Object.keys</code>就会告诉我们这个公共字段</p><p id="be77" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">但是我们可以使用新的反射类来访问每个键:</p><pre class="kw kx ky kz gu la lb lc ld aw le bi"><span id="c7c2" class="lf lg iu lb b gz lh li l lj lk">&gt; Reflect.ownKeys(obj);<br/>[ 'public', Symbol(foo), Symbol(foo) ]</span></pre><p id="1934" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">现在让我们进入对象的私有字段:</p><pre class="kw kx ky kz gu la lb lc ld aw le bi"><span id="109f" class="lf lg iu lb b gz lh li l lj lk">&gt; const foo1 = Reflect.ownKeys(obj)[1]; <br/>&gt; const foo2 = Reflect.ownKeys(obj)[2]; <br/>&gt; foo1 <br/>Symbol(foo) <br/>&gt; foo2 <br/>Symbol(foo) <br/>&gt; obj[foo1] = 'foobar'; <br/>'foobar' <br/>&gt; obj <br/>{   public: 'public value',   [Symbol(foo)]: 'foobar',   [Symbol(foo)]: 'bar' }</span></pre><p id="8de3" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">该字段先前的值为“bar ”,但现在的值为“foobar”。我们这样做是通过侧门进入场地。底线是，JavaScript没有给我们私有字段，只是一种避免将字段附加到对象时发生冲突的方法。</p><h1 id="4c55" class="lo lg iu bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">摘要</h1><p id="05e3" class="pw-post-body-paragraph jy jz iu ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv in bi translated">符号是JavaScript中一个强大的新特性。</p><p id="f03e" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">似乎私有字段以前的最佳实践是使用一个模糊的字段名。例如，Angular使用以<code class="fe mq mr ms lb b">$</code>开头的字段名来表示私有字段，并在某些情况下去掉这些字段。但是如果一个Angular程序需要与另一个使用以<code class="fe mq mr ms lb b">$</code>开头的字段名用于不同目的的系统接口，该怎么办呢？</p><p id="8b3f" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated"><em class="lm">最初发表于</em><a class="ae ln" href="https://techsparx.com/nodejs/esnext/symbol.html?utm_source=dlvr.it&amp;utm_medium=facebook&amp;fbclid=IwAR2zBgCt-oOGA2glKilqaD-vRKzGEOo31gdbJITBY15e4gGQtwf35bRozbw" rel="noopener ugc nofollow" target="_blank">T5【https://techsparx.com】</a><em class="lm">。</em></p></div></div>    
</body>
</html>