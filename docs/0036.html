<html>
<head>
<title>TypeScript: Static or Dynamic? The war is over.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript:静态还是动态？战争结束了。</h1>
<blockquote>原文：<a href="https://itnext.io/typescript-static-or-dynamic-64bceb50b93e?source=collection_archive---------0-----------------------#2016-06-16">https://itnext.io/typescript-static-or-dynamic-64bceb50b93e?source=collection_archive---------0-----------------------#2016-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2cb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TypeScript越来越受欢迎，这让一场古老的静态和动态语言之战死灰复燃。当你参与其中时，你希望自己做好准备。使用TypeScript并不像许多人认为的那么简单，所以我们将简短地探讨一下编程语言理论的基础。让我们从看起来显而易见的事情开始。</p><blockquote class="kl km kn"><p id="8f0a" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated"><strong class="jp ir">动态类型化</strong> —类型与运行时检查的<strong class="jp ir">值、</strong>和<strong class="jp ir">相关联。</strong></p></blockquote><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="02fc" class="lb lc iq kx b gy ld le l lf lg">function g( a ) {<br/>    return a / 10;<br/>}</span></pre><blockquote class="kl km kn"><p id="b00e" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated"><strong class="jp ir">静态类型化</strong> —类型与<strong class="jp ir">变量</strong>或<strong class="jp ir"> <em class="iq">文本表达式、</em> </strong> <em class="iq">和</em> <strong class="jp ir"> <em class="iq">关联，在编译时检查</em> </strong>。</p></blockquote><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="396d" class="lb lc iq kx b gy ld le l lf lg">function g( a : number ) : number{<br/>    return a / 10;<br/>}</span></pre><p id="6199" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这太简单了，有人会奇怪我们为什么要讨论它。每个孩子都知道这个，真的。但是等等。在我们开始血腥的静态与动态之争之前，我们将更深入地探讨这个话题。因为在表象背后同时存在着有趣和困惑。</p><h2 id="e194" class="lb lc iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">静态类型、类型注释和类型推断</h2><p id="8381" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">所以，静态类型的问题是这些类型注释。你把它们添加到你的程序中…正因为如此，它变成了静态类型。像这样:</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="9c6f" class="lb lc iq kx b gy ld le l lf lg">function g( a : number ) : number{<br/>    return a / 10;<br/>}</span></pre><p id="e8f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对吗？</p><p id="a368" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不，当然不是:)。比那诡异多了。:)</p><p id="37a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你仔细观察上面的程序，你会注意到在这种情况下类型<a class="ae md" href="https://en.wikipedia.org/wiki/Type_inference" rel="noopener ugc nofollow" target="_blank">可以从上下文</a>中确定。<em class="ko"> g() </em>只能返回<em class="ko">号</em>，为了正确操作，必须将<em class="ko">号</em>作为参数。</p><blockquote class="me"><p id="cda0" class="mf mg iq bd mh mi mj mk ml mm mn kk dk translated">"<a class="ae md" href="https://en.wikipedia.org/wiki/Type_inference" rel="noopener ugc nofollow" target="_blank">类型推断</a> " —可以从上下文中确定类型，使类型注释可选。</p></blockquote><p id="d14f" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">因此，具有<em class="ko">类型推断</em>能力的智能<em class="ko">静态类型系统</em>将允许您省略本例中的类型注释，并且仍然执行完整的静态类型检查。您的代码将如下所示，并且仍然是静态类型的<em class="ko">代码:</em></p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="f01b" class="lb lc iq kx b gy ld le l lf lg">function g( a ) {<br/>    return a / 10;<br/>}</span></pre><blockquote class="kl km kn"><p id="0e96" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">什么？但是…它看起来和动态的一模一样！</p></blockquote><p id="7910" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是啊，没错。:)为了给你一些现实世界中具有这种语义的静态类型语言的例子，我可以提到<a class="ae md" href="https://en.wikipedia.org/wiki/Category:ML_programming_language_family" rel="noopener ugc nofollow" target="_blank"> ML族编程语言</a>和<a class="ae md" href="https://en.wikipedia.org/wiki/Haskell_%28programming_language%29" rel="noopener ugc nofollow" target="_blank"> Haskell </a>。它们基于<a class="ae md" href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system" rel="noopener ugc nofollow" target="_blank"> Hindley-Milner类型系统</a>，该系统<em class="ko">保证</em>将从上下文中提取类型并进行静态检查。这意味着…</p><blockquote class="me"><p id="77b7" class="mf mg iq bd mh mi mj mk ml mm mn kk dk translated">没有单一类型注释，你可以编写整个程序，它将是静态类型的程序。</p></blockquote><p id="40eb" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">那么，到底是什么让语言成为静态的或动态的呢？键入注释？不。差远了。</p><h2 id="3f22" class="lb lc iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">软类型系统和渐进类型</h2><p id="058c" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">你还不够困惑吗？因为我忘了补充一点，动态语言也有类型注释功能。仅仅注意到它们中很少能够进行静态类型检查——对于Erlang/Elixir来说是<a class="ae md" href="http://learnyousomeerlang.com/dialyzer" rel="noopener ugc nofollow" target="_blank">透析器工具</a>,对于JavaScript来说是<a class="ae md" href="https://en.wikipedia.org/wiki/Google_Closure_Tools" rel="noopener ugc nofollow" target="_blank"> Google Closure编译器</a>。</p><p id="51df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了弄清楚关于打字稿的事情并获得一些安心，让我们打开<a class="ae md" href="https://www.typescriptlang.org/play/index.html" rel="noopener ugc nofollow" target="_blank">打字稿语言游乐场</a>，并在那里尝试我们的示例:</p><figure class="ks kt ku kv gt mv gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/3669755bfc2eab1b38d764aee00763e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*lJNwpVsKaghfDmcg4nJ1uw.png"/></div></figure><p id="bd8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您开始键入<em class="ko"> g() </em>函数调用时，您将看到由TypeScript编译器从上下文中推断出的函数签名(<em class="ko">类型推断！</em>)。有趣的细节是<em class="ko">“a”的类型不是一个数字。</em>推断为<strong class="jp ir"> <em class="ko">任何</em> </strong> <em class="ko">。发生这种情况的原因非常重要。</em></p><p id="5bcf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不，不是因为TypeScript的类型推断没有能力。事情是这样的，尽管既有<em class="ko">类型注释</em>又有<em class="ko">类型推理</em>，它仍然是<em class="ko">动态语言</em>。它还是假设你可以用<strong class="jp ir">任意</strong>参数类型调用g()，以及它返回<em class="ko"> NaN </em>时的有效情况。酷吧。</p><p id="facf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，到底是什么让<em class="ko">动态</em>？这不仅仅是做可选类型注释的机会；许多静态类型语言提供了同样的东西。这是<strong class="jp ir">任何</strong>类型的存在和<em class="ko">类型推理</em>工作方式的主要区别。与“数字”相比，它更喜欢“任意”类型，因此默认情况下它是动态的，就像普通的JavaScript一样。当你希望它更严格时，你必须添加类型注释。反之亦然。</p><blockquote class="me"><p id="5803" class="mf mg iq bd mh mi mj mk ml mm mn kk dk translated"><strong class="ak">这种类型注释与“</strong> any”类型<strong class="ak">的混合称为</strong> <a class="ae md" href="https://en.wikipedia.org/wiki/Gradual_typing" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">渐进键入</strong> </a> <strong class="ak">。</strong>默认选择“任意”时，称为“<a class="ae md" href="http://courses.cs.ut.ee/2006/types/uploads/Main/cartwright91soft.pdf" rel="noopener ugc nofollow" target="_blank">软类型系统</a>”。与动态类型和静态类型并不完全相反，而是取二者之长。</p></blockquote><p id="5d19" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">关于JavaScript的动态特性，你能说的每一件好事(如果有的话，这取决于你来自哪个阵营)也适用于类型脚本。这不是“静态对动态”战争的主题。没有任何“对立面”，也不是强迫你做你讨厌或不喜欢做的事情。这是关于新的机会。</p><p id="188b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，假设您有动态语言背景，让我们简要概述一下类型注释和静态类型检查给您带来的机会，以及一些常见的误解。例如，你可能听说…</p><h2 id="9167" class="lb lc iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">静态类型检查减少了代码中的缺陷数量？</h2><p id="4c38" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">如果你从字面上理解(正如许多人所做的)，这是错误的说法。稍微想一想。你的代码中的大量缺陷在最后完全取决于你的质量保证程序。无论你使用哪种编程语言，它都会找到所有重要的错误。你可以用汇编语言写。尽管如此，你的缺陷不会通过QA。</p><p id="57c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实是，开发人员<em class="ko">注入了或多或少相同数量的缺陷，</em>和静态类型检查允许他<em class="ko">更早地注意并修复这些缺陷的一部分</em>，因此花费的精力更少。</p><p id="4b5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然很好，但这件事本身完全不是重点。至少不是很重要。大多数语言中的静态类型检查(TypeScript也不例外)都太弱，无法与其他QA程序竞争。没什么好谈的。</p><p id="27c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，还有什么意义呢？为什么人们说TypeScript是大型系统开发人员期待已久的工具？因为…</p><h2 id="71e9" class="lb lc iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">有类型检查辅助的类型注释有助于您进行系统分解</h2><p id="f598" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">当你处理复杂的事情时，你会怎么做？您可能会尝试将它拆分成一组具有清晰接口的独立部分。因此，你可以把注意力集中在单个部分，而不用费心去记住其他部分的实现细节，<em class="ko">，只要你知道它们的接口</em>。</p><blockquote class="me"><p id="1c91" class="mf mg iq bd mh mi mj mk ml mm mn kk dk translated">类型注释为您提供了描述各部分之间接口的正式语言</p></blockquote><p id="6a62" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">当然，你可以用简单的英语描述这些界面。这个想法本身并不坏，但有一个问题。当你对系统进行修改时(这是我们工作的本质)，你应该保持你的文档同步。</p><p id="9dfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你猜怎么着？人们通常不会这样做。结果，你就是<em class="ko">不能相信简单的英语规范</em>，不管它们乍一看有多好。</p><blockquote class="kl km kn"><p id="fe64" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">我总是制作漂亮的文档，并且总是让它们保持同步！</p></blockquote><p id="3d69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">即使假设你真的属于那1%(毫无疑问你是)。尽管如此，我还是不信任你。不是针对你，只是因为你是个人。而且人类是如此的不可靠……(你怎么能<em class="ko">真的保证</em>你的文档确实符合代码？你总是有心情吗？你<em class="ko">总是</em>有时间<em class="ko">没有借口</em>吗？你没有犯任何错误吗？你是一个人在努力，还是有一整队超级英雄在负责？)</p><figure class="ks kt ku kv gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi my"><img src="../Images/08aad5ebe5da27f1df78b361eef8e77e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ex_I6iUnaYQgU4hF.jpg"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">软件开发团队准备每日文档更新。</figcaption></figure><blockquote class="me"><p id="8a3e" class="mf mg iq bd mh mi nh ni nj nk nl kk dk translated">类型注释是由编译器对照自身和代码检查的文档；保证<em class="mt">是正确的和最新的。</em></p></blockquote><p id="c550" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">类型注释是一种可以信任的技术文档。告诉你不符合规格的文件。不需要超级英雄。句号。</p><p id="f527" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为一种正式语言，类型注释实际上允许你以非常有效的方式表达和交流设计。当你处理大而乱的时，这是一个无价的工具，尤其是在团队中。</p><p id="76b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">毕竟，正如肯尼斯·艾弗森在他的图灵讲座中指出的，符号不仅仅是符号。</p><blockquote class="me"><p id="b088" class="mf mg iq bd mh mi mj mk ml mm mn kk dk translated">符号是思维的工具。</p></blockquote><p id="4143" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">如果有一种语言给你词语来表达设计，它给你机会有效地思考关于设计的问题。事实上，这是最重要的一点。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="be28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">综上所述，TypeScript不仅是前端开发人员工具链中有价值的补充，也是服务器端NodeJS开发的重要工具。这是<em class="ko">渐进打字</em>允许你在对你正在创建的东西的设计没有丝毫想法的时候，立刻从一个原型开始，并且在你想出它们的时候添加类型。</p><p id="144c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你问我，我讨厌被迫用静态语言做前期设计，我更讨厌当你的程序变得很大，你不知道你刚刚写了什么，你害怕接触它时，用动态语言的那种虚弱感。TypeScript不强迫我选择，它反而适应我的自然开发风格，在每一步都提供协助。</p><p id="d538" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">静态语言和动态语言之间的冷战似乎终于结束了，我们开发人员可能只会欢迎它。</p></div></div>    
</body>
</html>