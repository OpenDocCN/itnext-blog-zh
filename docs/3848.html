<html>
<head>
<title>Updating Vue Apollo Store From Different Sources</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从不同来源更新Vue Apollo商店</h1>
<blockquote>原文：<a href="https://itnext.io/updating-vue-apollo-store-from-different-sources-6802f812e0d8?source=collection_archive---------2-----------------------#2020-03-10">https://itnext.io/updating-vue-apollo-store-from-different-sources-6802f812e0d8?source=collection_archive---------2-----------------------#2020-03-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0dc6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">自从Vue-Apollo第一次发布以来，我就一直在为每个API开发项目使用GraphQL，就像任何其他新的工作环境一样，Vue-Apollo也有自己的注意事项。其中之一是你不能简单地更新它自己的存储而不调用一个突变(<em class="ko">在实践中，实际上一个查询也会更新存储，但这个主题</em>却不是这样)。</p><p id="8e90" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">显然，从开发者的角度来看，这是完全符合逻辑的。如果你想保持你的<a class="ae kp" href="https://en.wikipedia.org/wiki/Single_source_of_truth" rel="noopener ugc nofollow" target="_blank"> SSOT </a>概念完好无损，这就是方法。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/0992a069c48b387ab08a67e1c2366f43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*wqBlMZv1oO1JMidTrs2TZQ.gif"/></div></figure><p id="68fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，而且总是有但是，可能在某些情况下，您可能想要更新客户端屏幕上获取的GraphQL数据(<strong class="js iu"> <em class="ko">存储</em> </strong>)。我的情况是这样的:</p><ol class=""><li id="63fa" class="ky kz it js b jt ju jx jy kb la kf lb kj lc kn ld le lf lg bi translated">在客户端，有一个简单的输入，用户将一些Id号输入数据库，</li><li id="550e" class="ky kz it js b jt lh jx li kb lj kf lk kj ll kn ld le lf lg bi translated">在同一个页面上，有一个“最新的身份证号码”列表，所以用户可以在提交数据后看到一些结果，</li><li id="6481" class="ky kz it js b jt lh jx li kb lj kf lk kj ll kn ld le lf lg bi translated">当第一次加载页面时，使用GraphQL查询获取Id号的最后10位，</li><li id="b67e" class="ky kz it js b jt lh jx li kb lj kf lk kj ll kn ld le lf lg bi translated">当用户提交一个新的Id号时，一个变异开始工作，并用新数据更新查询，</li><li id="d6e5" class="ky kz it js b jt lh jx li kb lj kf lk kj ll kn ld le lf lg bi translated">在服务器端，Laravel命令每分钟检查一个被标记为“无效”的Id号，</li><li id="1fe0" class="ky kz it js b jt lh jx li kb lj kf lk kj ll kn ld le lf lg bi translated">这个Id号有一个第三方验证服务器，这个命令触发一个任务来发送Id号数据进行验证，</li><li id="76d9" class="ky kz it js b jt lh jx li kb lj kf lk kj ll kn ld le lf lg bi translated">同时，为了向用户显示这个验证过程的情况，而不需要每秒刷新页面或轮询GraphQL服务器，我使用Pusher服务，该作业触发一个事件来更新“最新Id号”列表，有趣的事情开始了。</li><li id="ebcd" class="ky kz it js b jt lh jx li kb lj kf lk kj ll kn ld le lf lg bi translated">虽然用户仍然可以向数据库中插入新的Id号，但他仍然可以看到他的列表输入了他输入的数据，并用数据推送器对其进行更新。</li></ol><p id="0349" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个概念的问题是，你可以更新Vue数据(来自GraphQL查询),你的页面仍然会很好。在上面的数字8中，Pusher通过其通道发送更新，并通知更新的数据:</p><pre class="kr ks kt ku gt lm ln lo lp aw lq bi"><span id="46d2" class="lr ls it ln b gy lt lu l lv lw">mounted () {<br/>   this.channel = this.$pusher.subscribe(`private-User.Entries.${this.user.id}`)</span><span id="c0aa" class="lr ls it ln b gy lx lu l lv lw">   this.channel.bind('pusher:subscription_succeeded', (e) =&gt; {</span><span id="d1af" class="lr ls it ln b gy lx lu l lv lw">      console.warn('Subscribed to Entries channel.')</span><span id="5b7d" class="lr ls it ln b gy lx lu l lv lw">   })</span><span id="f839" class="lr ls it ln b gy lx lu l lv lw">   this.channel.bind('App\\Events\\EntryStatus', (data) =&gt; {</span><span id="3916" class="lr ls it ln b gy lx lu l lv lw">      this.onUpdateEntry(data)</span><span id="f153" class="lr ls it ln b gy lx lu l lv lw">   })<br/>}</span></pre><p id="f4df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这段代码中，您可以看到，无论何时在Laravel端触发EntryStatus事件，它都会更新Pusher，Pusher会更新我的Vue应用程序，然后使用其更新的数据触发onUpdateEntry方法。</p><pre class="kr ks kt ku gt lm ln lo lp aw lq bi"><span id="02bf" class="lr ls it ln b gy lt lu l lv lw">data () {<br/>    return {<br/>        pendingUpdates: []<br/>    }<br/>},</span><span id="724d" class="lr ls it ln b gy lx lu l lv lw">methods: {<br/>   onUpdateEntry (entryUpdated) {<br/>      // First part</span><span id="3c82" class="lr ls it ln b gy lx lu l lv lw">      const entryRendered = this.$apolloData.data.entriesPaginate.find(entry =&gt; entry.id === entryUpdated.id)</span><span id="322f" class="lr ls it ln b gy lx lu l lv lw"><em class="ko">     if</em> (entryRendered !== undefined) {<br/>         entryRendered.status = entryUpdated.status<br/>     }</span><span id="3622" class="lr ls it ln b gy lx lu l lv lw">     // Second part</span><span id="4be5" class="lr ls it ln b gy lx lu l lv lw">     const index = this.pendingUpdates.findIndex(entry =&gt; entry.id === entryUpdated.id)</span><span id="fa99" class="lr ls it ln b gy lx lu l lv lw"><em class="ko">     if</em> (index !== -1) {<br/>         this.$set(this.pendingUpdates, index, entryUpdated)<br/>     } <em class="ko">else</em> {<br/>         this.pendingUpdates.push(entryUpdated)<br/>     }</span><span id="3236" class="lr ls it ln b gy lx lu l lv lw">}</span></pre><p id="d103" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这段代码更新呈现的GraphQL数据，同时轮询更新的条目数据。请注意entryRendered对象。您可能会想，当可以更新apolloData时，为什么有人需要轮询entryUpdated数据，对吗？问题是，阿波罗数据公司并不是真正的阿波罗商店。它是数据集，您可以在查询的结果方法中更改它。</p><pre class="kr ks kt ku gt lm ln lo lp aw lq bi"><span id="aa64" class="lr ls it ln b gy lt lu l lv lw">data () {<br/>    return {<br/>        pendingUpdates: [],<br/>        loading: false,<br/>        total: 0,<br/>        pagination: {<br/>            age: 1,<br/>            rowsPerPage: 10,<br/>            sortBy: 'id',<br/>            descending: true<br/>        },<br/>        entriesPaginate: []<br/>    }<br/>},</span><span id="6c14" class="lr ls it ln b gy lx lu l lv lw">apollo: {<br/>    entriesPaginate: () =&gt; ({<br/>        query: ENTRY_PAGINATE,<br/>        context: { uri: 'http://localhost/graphql' },<br/>        variables () {<br/>            <em class="ko">return</em> this.pagination<br/>        },<br/>        result ({ data: { entriesPaginate: { data, total } }, loading }) {<br/>            <em class="ko">if</em> (!loading) {<br/>                this.total = total<br/>                this.entriesPaginate = data.slice().map((key, i) =&gt; ({<br/>                   ...key,<br/>                   __index: i<br/>                }))<br/>            }<br/>        },<br/>        watchLoading (isLoading) {<br/>            this.loading = isLoading<br/>        }<br/>    })<br/>}</span></pre><p id="350b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用Vue-Apollo，您可以忽略查询中的result方法(以及数据中的entriesPaginate数组),让Apollo处理查询结果到Vue数据的分配。但在我的情况下，我需要单独的总数据，数据集上可能有一些其他的变化。因此我在这里使用结果方法。但是无论使用与否，entriesPaginate数组都将是Apollo store原始查询结果的一部分。</p><p id="0379" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我更新<em class="ko">这个也没关系。在<em class="ko"> onUpdateEntry </em>方法中的$ Apollo data . data . entriespaginate</em>或<em class="ko"> this.entriesPaginate </em>。当用户提交新的Id并触发变异时，Apollo将触发查询结果方法本身(已定义或未定义)，并且这个. entriesPaginate数组将使用Apollo存储的原始数据进行更新。这意味着来自<em class="ko"> onUpdateEntry </em>方法的所有更新将在用户的屏幕上回滚。他/她将看到新的Id条目和旧的查询数据。</p><p id="46f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了解决这个问题，我们会使用一个<em class="ko"> this。$apollo.store </em>方法，但是没有这样一个。所以我想出了轮询更新数据的变通办法。在<em class="ko"> onUpdateEntry </em>方法中，您可能会注意到有两部分代码带有注释，第一部分和第二部分。第二部分将<em class="ko"> updatedEntry </em>数据插入<em class="ko"> pendingUpdates </em>数组。当用户通过变异向数据库提交一个新的Id时，我首先保存这些记录来更新存储。这是:</p><pre class="kr ks kt ku gt lm ln lo lp aw lq bi"><span id="7b89" class="lr ls it ln b gy lt lu l lv lw">data () {<br/>    return {<br/>        graphQLErrors: [],<br/>        form: {<br/>            idNumber: null<br/>        },<br/>        pendingUpdates: [], // Empty here for definition, actual data filled with multiple entryUpdated data.<br/>    }<br/>},</span><span id="a31e" class="lr ls it ln b gy lx lu l lv lw">methods: {<br/>    submit () {<br/>        this.loading = true</span><span id="dfa0" class="lr ls it ln b gy lx lu l lv lw">        this.$apollo.mutate({<br/>             mutation: ENTRY_CREATE,<br/>             variables: {<br/>                 entry: {<br/>                     id_number: this.form.idNumber<br/>                 }<br/>             },<br/>             context: { uri: 'http://localhost/graphql' },<br/>             update: (store, { data: { entryCreated } }) =&gt; {<br/>                 const query = {<br/>                     query: ENTRY_PAGINATE,<br/>                     variables: this.pagination<br/>                 }, data = store.readQuery(query)<br/>             <br/>                 if (data !== undefined) {<br/>                      // First part<br/>                      if (this.pendingUpdates.length) {<br/>                         this.pendingUpdates.forEach(entryUpdated =&gt; {<br/>                             const index = data.entriesPaginate.data.findIndex(entry =&gt; entry.id === entryUpdated.id)<br/>                             if (index !== -1) {<br/>                                 this.$set(data.entriesPaginate.data, index, entryUpdated)<br/>                             }<br/>                         })</span><span id="c3d2" class="lr ls it ln b gy lx lu l lv lw">                         this.pendingUpdates = [] // Reset<br/>                     }<br/>                     <br/>                     // Second part<br/>                     if (data.entriesPaginate.data.findIndex(entry =&gt; entry.id === entryCreated.id) === -1) {<br/>                         data.entriesPaginate.data.unshift(entryCreated)<br/> <br/>                         store.writeQuery({<br/>                             ...query,<br/>                             data: data<br/>                         })<br/>                     }<br/>                 }<br/>             }<br/>        }).catch((e) =&gt; {<br/>            this.graphQLErrors = e<br/>        }).then(() =&gt; {<br/>            this.loading = false<br/>        })<br/>    }<br/>}</span></pre><p id="b9b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能会注意到这里的<em class="ko">更新</em>方法的变异又分为两部分。第一部分，在用新创建的数据更新存储之前，迭代<em class="ko"> pendingUpdates </em>数组并更新Apollo存储，然后第二部分在列表顶部插入<em class="ko"> entryCreated </em>对象，最后<em class="ko"> store.writeQuery </em>完成更新。</p><p id="7a5a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以上最重要的部分是，你必须向Pusher发布相同的GraphQL数据。我没有研究我的Laravel GraphQL包是否能够做到这一点，所以我只是模仿GraphQL服务数据的方式。更清楚地说，这是针对<em class="ko"> entriesPaginate </em>的GraphQL查询结果示例:</p><pre class="kr ks kt ku gt lm ln lo lp aw lq bi"><span id="9729" class="lr ls it ln b gy lt lu l lv lw">{<br/>  data: {<br/>    entriesPaginate: [<br/>      {id: 1, id_number: 12345678, created_at: SomeDate, validated_at: SomeDate, status: "queued", __typename: "Entry"},<br/>      {id: 2, id_number: 34567890, created_at: SomeDate, validated_at: SomeDate, status: "validated", __typename: "Entry"},<br/>      {id: 3, id_number: 45678901, created_at: SomeDate, validated_at: SomeDate, status: "validating", __typename: "Entry"},<br/>      ...<br/>    ],<br/>    total: 41,<br/>    __typename: "entriesPagination"<br/>  }<br/>}</span></pre><p id="7033" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">而这个my broadcating Event的<em class="ko">broadcast用</em>方法向Pusher发送数据:</p><pre class="kr ks kt ku gt lm ln lo lp aw lq bi"><span id="a367" class="lr ls it ln b gy lt lu l lv lw">public function broadcastWith()<br/>{<br/>    return [<br/>        '__typename' =&gt; 'Entry',<br/>        'id' =&gt; $this-&gt;entry-&gt;id,<br/>        'id_number' =&gt; $this-&gt;entry-&gt;id_number,<br/>        'status' =&gt; $this-&gt;entry-&gt;status,<br/>        'created_at' =&gt; $this-&gt;entry-&gt;created_at,<br/>        'validated_at' =&gt; $this-&gt;entry-&gt;validated_at<br/>    ];<br/>}</span></pre><p id="02f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以相同的格式保存数据可以防止Apollo存储更新错误。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="c3e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Vue代码示例中，我使用了数据对象中最相关的数据项。所以请不要试图简单地复制粘贴上面的代码，因为它们可能缺少数据定义/方法。</p></div></div>    
</body>
</html>