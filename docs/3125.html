<html>
<head>
<title>Dart basics. Isolates. 🤖 🤖 🤖</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">飞镖基础。隔离。🤖 🤖 🤖</h1>
<blockquote>原文：<a href="https://itnext.io/by-design-dart-is-a-single-threaded-programming-language-924c41e5c135?source=collection_archive---------1-----------------------#2019-10-08">https://itnext.io/by-design-dart-is-a-single-threaded-programming-language-924c41e5c135?source=collection_archive---------1-----------------------#2019-10-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/efbdac236e37c21c9ec7985fe5a0a25f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*neRpjd92Lsx9X-X-U4eEVA.jpeg"/></div></div></figure><p id="d2b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据设计，Dart是一种单线程编程语言。这意味着我们有跨应用程序的异步代码。当一个程序启动时，它会创建一个叫做隔离的东西。创建隔离时，微任务管理器异步执行所有事件。在这次灾难援助反应队委派之后，所有的管理都转向事件循环。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="aebb" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">孤立者</h2><p id="79bb" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">隔离是所有Dart程序运行的地方。它有一块内存，运行一个单独的线程。在像Java这样的编程语言中，开发人员可以创建多个线程并共享同一个内存。Dart允许我们创建多个隔离，这类似于多线程，但它不是。隔离用来做繁重的计算，以避免主程序变慢。</p><p id="3c90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">隔离有一个限制—两个隔离之间不能共享内存。尽管如此，被隔离的人可以互相发送信息。这种功能弥补了多线程的不足。<br/>下面是一个完整的例子，展示了如何在主线程和隔离线程之间产生(创建)隔离并建立通信。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="23f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<strong class="ka ir"> createNewIsolate </strong>方法中，新的隔离使用隔离类的静态方法创建— <strong class="ka ir"> Isolate.spawn </strong>。静态方法Isolate.spawn接受两个参数:</p><ul class=""><li id="de61" class="mh mi iq ka b kb kc kf kg kj mj kn mk kr ml kv mm mn mo mp bi translated">Isolates实例化时执行的回调— <strong class="ka ir"> isolateMain。</strong></li><li id="554e" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated">发送端口类的实例。</li></ul><p id="3338" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ReceivePort类的实例有一个SendPort类的实例— <strong class="ka ir"> receivePort.sendPort </strong>。</p><p id="750f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ReceivePort和SendPort是从一端向另一端发送和接收消息的主要类。<strong class="ka ir"> isolateMain </strong>函数接收发送端口实例。然后使用定时器和<strong class="ka ir">发送端口</strong>参数向主隔离发送多条消息。</p><ul class=""><li id="845c" class="mh mi iq ka b kb kc kf kg kj mj kn mk kr ml kv mm mn mo mp bi translated"><strong class="ka ir">接收端口.发送端口==发送端口</strong></li><li id="6b4e" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated">接收端口—侦听新的传入消息</li><li id="ccbf" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated">发送端口—将新消息从一个隔离发送到另一个隔离。</li></ul><p id="d788" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">隔离体之间的交流就是这样进行的。使用这个强大的功能来做一些繁重的计算，以保持应用程序的快速响应。</p></div></div>    
</body>
</html>