<html>
<head>
<title>React virtual rendering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应虚拟渲染</h1>
<blockquote>原文：<a href="https://itnext.io/react-virtual-rendering-448f0f1b81ad?source=collection_archive---------5-----------------------#2018-05-31">https://itnext.io/react-virtual-rendering-448f0f1b81ad?source=collection_archive---------5-----------------------#2018-05-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ea7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想知道如何在react组件中呈现大量记录，而不影响浏览器吗？例如，呈现包含数千项的列表或包含高密度列和行的数据网格。</p><p id="ffb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顺便说一句，如果你是一名云工程师，你可能会有兴趣加入topcloudops.com网络。伟大的客户，伟大的项目，伟大的薪酬。</p><p id="e71b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种技术的一个很好的例子可以在https://github.com/guiqui/react-timeline-gantt<a class="ae kl" href="https://github.com/guiqui/react-timeline-gantt" rel="noopener ugc nofollow" target="_blank">找到</a>更多的例子可以在<a class="ae kl" href="https://uxxu.io" rel="noopener ugc nofollow" target="_blank"> https://www.uxxu.io </a>找到。</p><p id="25c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解决这个问题的一种方法是使用一种叫做“虚拟渲染”的技术。“VR”的基本思想是只渲染用户看到的东西，保持渲染对象的数量最少。</p><p id="de47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“VR”和React的一个典型应用是实现一个包含数千个元素的列表组件。在这篇文章中，我将展示实现一个使用“虚拟渲染”技术的React组件是多么容易。<a class="ae kl" href="https://jsfiddle.net/gquiman/7hnr8pu0/" rel="noopener ugc nofollow" target="_blank">这里的</a>是jsfiddle中完整的例子。</p><p id="e947" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要一个<strong class="jp ir">视窗</strong>区域。这个区域将负责包含列表的可见项目，并有一个滚动条，使用户能够浏览所有项目。</p><p id="fe34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个例子的代码可以在<a class="ae kl" href="https://github.com/guiqui/react-virtual-list" rel="noopener ugc nofollow" target="_blank"> Github </a>中找到。</p><p id="a7e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也用同样的技术制作了一个react timeline组件，repo链接在这里是<a class="ae kl" href="https://github.com/guiqui/react-timeline" rel="noopener ugc nofollow" target="_blank">或者可以使用<strong class="jp ir">NPM install react-gantt-timeline来安装。</strong></a></p><p id="3c4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了在HTML中实现这一点，我们将创建一个名为“viewport”的div，并在其中添加另一个高度为<em class="km">h =行高*行数的div。</em>现在，视口div将能够以正确的滚动长度滚动，最后要做的事情是向我们的视口css添加属性<em class="km"> overflow-y: scroll。</em></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kn"><img src="../Images/59a56c0b81a8294803b3e209f692608a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*VONktO3_b_FCAjcOoBR9sw.png"/></div></figure><p id="18ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，让我们将这些放在一个react组件中，并为呈现行添加一个简单的类，我们称之为“Item”。代码和css将如下所示:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="kv kw l"/></div></figure><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="2ca4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们创建一些数据并初始化组件状态。我们将创建一些重要的变量:<br/> 1。我们将作为属性<br/> 2传递的行的高度(<strong class="jp ir"> itemheight </strong>)。使用<strong class="jp ir"> itemheight </strong>我们可以计算出<strong class="jp ir"> itemcontainer </strong> div的总高度(h= <strong class="jp ir"> itemheight </strong> * numRows ),我们将创建一个变量调用(<strong class="jp ir"> containerStyle </strong>)以用作内联样式。<br/> 3。viewPort中可见项目的数量(<strong class="jp ir">numvisible items</strong>)= viewPort . height/<strong class="jp ir">item height</strong><br/>4。我们将初始化包含要呈现的行的索引的状态。</p><p id="8049" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们已经设置好了，我们也可以创建一个renderRows方法，使用<strong class="jp ir"> start </strong>和<strong class="jp ir"> end </strong>来呈现可见的行。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="abd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">renderRow方法是所有魔法发生的地方，这里我们只渲染可见的元素，我们将每个项目放置在他的右边<strong class="jp ir">顶部</strong>与<strong class="jp ir">视窗</strong> div的滚动条的位置相匹配。</p><p id="c3a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这很酷，现在我们有了一个列表，可以用滚动条显示前n个可见项。最后要做的是给滚动条添加一个监听器，这样当滚动条移动时，我们可以改变状态属性<strong class="jp ir"> start </strong>和<strong class="jp ir"> end </strong> index <strong class="jp ir">。</strong>更改状态将触发更新，我们将看到右侧行呈现新的滚动位置。将创建新项目，不可见的项目将被销毁。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="763e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图显示了我们滚动时发生的情况:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi kx"><img src="../Images/521b55378df69f472baad9a310e712cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3n73odcK1A_QJ02hFXOo0w.png"/></div></div></figure><p id="b89a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以看看最终的结果。滚动时，代码运行速度非常快，对CPU几乎没有影响。</p></div></div>    
</body>
</html>