<html>
<head>
<title>How To Master Advanced React Design Patterns — Context API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何掌握高级React设计模式—上下文API</h1>
<blockquote>原文：<a href="https://itnext.io/using-advanced-design-patterns-to-create-flexible-and-reusable-react-components-part-2-react-3c5662b997ab?source=collection_archive---------0-----------------------#2018-04-09">https://itnext.io/using-advanced-design-patterns-to-create-flexible-and-reusable-react-components-part-2-react-3c5662b997ab?source=collection_archive---------0-----------------------#2018-04-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fed49b85f41dd1b4ffcce1d9db654c76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qy6OfQ44pgHxXpI2Ir52xQ.png"/></div></div></figure><p id="42de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/using-advanced-design-patterns-to-create-flexible-and-reusable-react-components-part-1-dd495fa1823">单击此处查看本系列的第1部分:复合组件</a></p><p id="9bd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/using-advanced-design-patterns-to-create-flexible-and-reusable-react-components-part-3-render-d7517dfe72bc">点击这里查看本系列第三部分:渲染道具</a></p><p id="082a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本系列的最后一部分中，我们讨论了如何使用复合组件和静态类方法来生成可重用和灵活的组件。使用我们创建的API，我们能够以一种非常声明性的方式动态地重新创建组件的不同变体。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="3fc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以轻松地添加任意多的步骤，并且我们可以决定进度面板是放在左边还是右边。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ld lc l"/></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">步进器组件的简单实现</figcaption></figure><p id="c07b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们之所以能够做到这一点，是因为我们使用了一些React API辅助函数来将所需的道具传递给树中的每个孩子；需要它们的组件可以访问“stage”和“handleClick”道具。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi li"><img src="../Images/f2c8823cb17e64b46cda5c0f64b9a3a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*14Xc1evO1VUe7ZbtaswMWA.png"/></div></div></figure><p id="e3c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是这种技术有一个主要的缺陷。道具只能传给他们的直系子孙。这使得API变得非常僵化，成为“步进器”。“Steps”组件必须是“Stepper”组件的直接子组件，否则它会中断。这在灵活性方面有着巨大的影响。</p><p id="ec58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们想疯狂一点，用一点flexbox的魔力来添加一个标题呢？</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ld lc l"/></div></figure><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lj"><img src="../Images/d9f5a7cdaf036ba6d331ed2c483b4f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qd-eBIPrVF9yUx2SlHMb6g.png"/></div></div></figure><p id="0cf2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过添加一个简单的div，我们完全打破了组件。踏步机。“Steps”组件不再是“Stepper”组件的直接子组件，因此无法接收其道具。当我们需要时，灵活地添加小的调整不是很好吗？</p><p id="fe7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">救援的背景！！</p><h1 id="9c64" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">反应上下文API</h1><p id="ca6f" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">React Context已经存在一段时间了，但React的工程师们明确表示，它是实验性的，可能会在不久的将来崩溃。好消息是，从React 16.3开始，这已经很稳定了，可以在React应用程序中使用。</p><p id="fa42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么我们一直听到的这个背景是什么呢？</p><p id="74b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我找不到比React官方文档中更清晰的定义了:</p><blockquote class="mn"><p id="9575" class="mo mp iq bd mq mr ms mt mu mv mw kv dk translated">上下文提供了一种通过组件树传递数据的方式，而不必在每一层手动向下传递属性。</p></blockquote><p id="7167" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated">这正是我们需要解决的问题！使用上下文，我们不再需要通过循环和克隆每个孩子来传递所需的道具。设计上下文是为了让我们可以共享“全局”状态，这种状态可以在React树中的任何地方共享。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/020ba73fed5971261f054ebe5644dc10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ceym3XmxMn8phkR5yk5HCg.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">通过使用上下文，我们的所有组件都可以访问“舞台”和“handleClick”道具。</figcaption></figure><p id="dfdb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，让我来引导您了解上下文API，以及启动和运行它需要采取的步骤。</p><h1 id="1300" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">1:创建新的上下文</h1><p id="e010" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">React现在附带了一个名为“createContext”的方法。我们需要做的就是简单地调用这个方法，并把它赋给一个变量。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ld lc l"/></div></figure><p id="0cad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们创建的新上下文为我们提供了对提供者和消费者对的访问。信不信由你，提供者为我们提供了在整个React树中共享状态变化的能力。消费者允许我们在树的任何地方订阅这些状态变化。</p><h1 id="3388" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">2.创建上下文提供程序</h1><p id="4994" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">我们刚刚创建的上下文有一个名为“Provider”的静态类方法，它创建一个React组件。该组件接受值属性。这是非常重要的，因为正是这个属性将代表我们的全局状态，我们需要将它传递给树中更下面的组件。在我们的例子中，我们想要在全球范围内共享的只是“stage”道具和“handleClick”方法。</p><p id="8dc6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过使用我们在本系列第一部分中使用的props.children技术，我们可以动态地向提供者公开任何子组件，不管它在树中有多深。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ld lc l"/></div></figure><h1 id="c349" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">3.围绕我们的步进组件包装我们的提供商</h1><p id="fe4d" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">通过简单地将“StepperProvider”组件包装在我们最初的“Stepper”组件周围，树中任何进一步向下的子组件现在都暴露在我们的上下文中。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ld lc l"/></div></figure><p id="9404" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">按照现在的情况，我们的步进器代码看起来几乎是相同的，但是通过简单地将它包装在StepperProvider组件中，我们所有的子组件都可以访问“stage”和“handleClick ”,而无需手动深入到每个组件。</p><h1 id="c345" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">4.重构我们的组件</h1><p id="4148" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">最初，我们的状态是由Stepper组件管理的，我们克隆了每个子元素来接收所需的道具。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ld lc l"/></div></figure><p id="25f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">几乎所有这些代码都不再需要了。我们不再需要创造状态，也不再需要传承任何道具。我们可以完全去掉这些代码，但是这是一个声明我们的静态方法来创建一个干净的、可读的API的好地方。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ld lc l"/></div></figure><h1 id="6b10" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">5.使用使用者订阅状态更改</h1><p id="4345" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">我会用踏步机。步骤组件来演示如何连接消费者组件。前情提要踏步机。步骤组件要求其父组件直接向下传递舞台道具，以使其正常工作:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ld lc l"/></div></figure><p id="6098" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着我们的应用程序与上下文联系起来，我们不再需要它作为一个道具。我们可以使用消费者来订阅它:</p><pre class="kx ky kz la gt nd ne nf ng aw nh bi"><span id="6b61" class="ni ll iq ne b gy nj nk l nl nm">&lt;Consumer&gt;<br/>  {value =&gt; /* render something based on the context value */}<br/>&lt;/Consumer&gt;</span></pre><p id="56ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">消费者需要一个函数作为孩子，并为这个函数提供我们的全局上下文值。当函数完成时，它返回一个react节点。</p><p id="9eb8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这到底是什么意思？</p><p id="f25e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一开始这有点让人摸不着头脑，但是让我们来看看“消费”步骤组件。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ld lc l"/></div></figure><p id="23a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们没有将“Step”标记作为子标记直接添加给消费者，而是添加了一个函数。这个函数提供了我们之前从提供者那里创建的值，然后我们可以使用ES6析构来完成舞台道具。“步骤”组件现在可以像以前一样访问舞台道具，但这次它是从上下文中提取的。从这里我们可以随心所欲地处理它；在这种情况下，我们使用它来确定返回什么样的React节点。</p><p id="903c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里使用的技术可能看起来有点奇怪。它叫做<em class="nn">渲染道具</em>，<a class="ae kw" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank">官方react文档在这里解释</a>。这是一项非常强大的技术，我将在本系列的第3部分中讨论。</p><h1 id="5da8" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">6.对所有需要道具或传递道具的组件重复第4和第5步</h1><p id="e962" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">我不会在这里一步一步地详细介绍，而是重复第4和第5步。台阶踏步机。进度和步进器。阶段组件您应该最终拥有与之前完全相同的组件外观和功能。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="9571" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的组件现在都不依赖于成为其他组件的直接后代。嘣！我们现在有了更加灵活的代码，应该可以添加我们之前无法添加的标题了！</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ld lc l"/></div></figure><p id="b6d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">踏步机。台阶和踏步机。Step不再直接从他们的父母那里拉“舞台”道具。他们从上下文中订阅它，所以额外的div不会阻止道具沿树向下传递。应用程序仍然有效！</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/020ba73fed5971261f054ebe5644dc10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ceym3XmxMn8phkR5yk5HCg.png"/></div></div></figure><p id="dfb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这给了我们极大的灵活性。我们可以重用我们的组件来动态地创建步进组件的复杂变体，而不用担心我们的应用程序会崩溃</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="4dba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管我们可以在应用程序的任何地方使用这个组件，但它仍然不是真正可重用的。为了让它工作，我们仍然需要上下文的样板。</p><p id="9563" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本系列的下一部分中，我将讨论如何使用render props来实现相同的目标，而不必依赖于连接上下文来共享应用程序中组件之间的状态。</p></div></div>    
</body>
</html>