<html>
<head>
<title>Build gRPC server with Golang/Go step by step</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Golang/Go逐步构建gRPC服务器</h1>
<blockquote>原文：<a href="https://itnext.io/build-grpc-server-with-golang-go-step-by-step-b3f5abcf9e0e?source=collection_archive---------0-----------------------#2022-09-20">https://itnext.io/build-grpc-server-with-golang-go-step-by-step-b3f5abcf9e0e?source=collection_archive---------0-----------------------#2022-09-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="acc8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Golang编写一个完整的gRPC应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/178e1d5f62772393ae366f14228d881a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fIlHXjSG5ZaRAMZeyDDrrg.png"/></div></div></figure><h1 id="1b26" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">gRPC是什么？</h1><p id="f112" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">是由<strong class="lo iu"> Google </strong>开发的处理远程过程调用(RPC)的框架。</p><p id="d9a2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">今天，gRPC被谷歌、思科、Dropbox、网飞、IBM等技术领导者所使用。</p><p id="d974" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">有关官方文件，请查看<a class="ae mn" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> grpc.io </a>。</p><h2 id="3591" class="mo kv it bd kw mp mq dn la mr ms dp le lv mt mu lg lz mv mw li md mx my lk mz bi translated">利益</h2><p id="9bec" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">gRPC使用HTTP/2作为其传输协议。虽然与HTTP 1.1兼容，但HTTP/2具有许多高级功能:</p><ul class=""><li id="b207" class="na nb it lo b lp mi ls mj lv nc lz nd md ne mh nf ng nh ni bi translated"><strong class="lo iu">轻量级消息。</strong>用gRPC编码的消息比JSON消息小60-80%。</li><li id="8f25" class="na nb it lo b lp nj ls nk lv nl lz nm md nn mh nf ng nh ni bi translated"><strong class="lo iu">代码生成。gRPC已经自动化了代码生成<a class="ae mn" href="https://grpc.io/docs/languages/" rel="noopener ugc nofollow" target="_blank"/>，涵盖了C#、C++、Java、Go、Kotlin、Node、PHP、Python、Ruby等语言。</strong></li><li id="dc6d" class="na nb it lo b lp nj ls nk lv nl lz nm md nn mh nf ng nh ni bi translated"><strong class="lo iu">支持流媒体</strong>。gRPC还提供数据流:服务器端流、客户端流和双向流。</li><li id="548d" class="na nb it lo b lp nj ls nk lv nl lz nm md nn mh nf ng nh ni bi translated"><strong class="lo iu">超速。</strong> gRPC比REST+JSON通信快7倍甚至8倍。</li></ul><h1 id="2bab" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated"><a class="ae mn" href="https://developers.google.com/protocol-buffers/docs/overview" rel="noopener ugc nofollow" target="_blank">什么是协议缓冲器？</a></h1><p id="8107" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">协议缓冲区是Google的语言中立、平台中立、可扩展的机制，用于序列化结构化数据——想想XML，但是更小、更快、更简单。</p><p id="7e66" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">您只需定义一次数据的结构化方式，然后就可以使用专门生成的源代码，使用各种语言轻松地将结构化数据写入各种数据流或从中读取。</strong></p><p id="d1ee" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">您可以在一个<code class="fe no np nq nr b">.proto</code>文件中定义一个protobuf消息，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="5a92" class="ku kv it bd kw kx ob kz la lb oc ld le jz od ka lg kc oe kd li kf of kg lk ll bi translated">先决条件</h1><h2 id="9d2f" class="mo kv it bd kw mp mq dn la mr ms dp le lv mt mu lg lz mv mw li md mx my lk mz bi translated">戈朗</h2><p id="cc56" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">你必须拥有任何一款最新发布的<a class="ae mn" href="https://go.dev/doc/devel/release" rel="noopener ugc nofollow" target="_blank"> <strong class="lo iu">三大版本的围棋。</strong> </a></p><h2 id="a424" class="mo kv it bd kw mp mq dn la mr ms dp le lv mt mu lg lz mv mw li md mx my lk mz bi translated">协议缓冲编译程序</h2><p id="c4ce" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">为了编译协议定义<code class="fe no np nq nr b">(.proto file)</code>,我们必须安装协议缓冲编译器和协议编译器的golang插件。</p><p id="6ef6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">protobuf编译器是一个可执行文件，你可以从这里的<a class="ae mn" href="https://github.com/protocolbuffers/protobuf/tags" rel="noopener ugc nofollow" target="_blank"> <strong class="lo iu">下载(官方页面)。</strong> </a></p><p id="ae6a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">例如在linux上，您将下载</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="89d8" class="mo kv it nr b gy ok ol l om on"><a class="ae mn" href="https://github.com/protocolbuffers/protobuf/releases/download/v21.6/protoc-21.6-linux-x86_64.zip" rel="noopener ugc nofollow" target="_blank">protoc-21.6-linux-x86_64.zip</a></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/56cafb6be451ed32e0b50bfa59ce0744.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/format:webp/1*FlOY0fQhXI6VZEe73X7Gug.png"/></div><figcaption class="op oq gj gh gi or os bd b be z dk translated"><a class="ae mn" href="https://github.com/protocolbuffers/protobuf/releases/download/v21.6/protoc-21.6-win64.zip" rel="noopener ugc nofollow" target="_blank">protocol-21.6-win 64 . zip</a>内容</figcaption></figure><p id="0a28" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><em class="ot">然后按照readme(从windows到linux到osx都不一样)。</em></p><p id="61b6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">基本上，你必须把bin文件夹的内容(协议二进制文件)放在你的<strong class="lo iu">路径</strong>中。</p><h2 id="6782" class="mo kv it bd kw mp mq dn la mr ms dp le lv mt mu lg lz mv mw li md mx my lk mz bi translated"><strong class="ak"> Go插件</strong></h2><p id="be5c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">然后你必须为协议编译器安装<strong class="lo iu"> Go插件</strong>:</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="188f" class="mo kv it nr b gy ok ol l om on">$ <!-- -->go install google.golang.org/protobuf/cmd/protoc-gen-go<br/>$ <!-- -->go install google.golang.org/grpc/cmd/protoc-gen-go-grpc</span></pre><p id="d74b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi ou translated">最后(如果你以前没有做过)，你必须更新你的<code class="fe no np nq nr b">PATH</code>来包含go/bin，这样<code class="fe no np nq nr b">protoc</code>就可以找到你刚刚安装的插件。</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="05e1" class="mo kv it nr b gy ok ol l om on">$ export PATH="$PATH:<strong class="nr iu">$(</strong>go env GOPATH<strong class="nr iu">)</strong>/bin"</span></pre><p id="d972" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在，您已经拥有了构建gRPC服务器所需的所有工具😃</p><h1 id="7880" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">第一步</h1><p id="19a7" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">首先，你必须初始化一个golang项目<em class="ot">(随你怎么命名，我把我的命名为grpctutorial ) </em></p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="0740" class="mo kv it nr b gy ok ol l om on">$ <!-- -->go mod init grpctutorial</span></pre><p id="632b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后，您必须安装grpc-go软件包</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="14a8" class="mo kv it nr b gy ok ol l om on">$ <!-- -->go get -u google.golang.org/grpc</span></pre><p id="57fd" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在我们编写主函数(和main.go文件)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="84cf" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后，您必须创建您的第一个协议文件，并将其放在名为<strong class="lo iu">教程</strong>的目录中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="dc86" class="mo kv it bd kw mp mq dn la mr ms dp le lv mt mu lg lz mv mw li md mx my lk mz bi translated">编译原型文件</h2><p id="a78c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在我们已经定义了原型，我们必须把它编译成Golang代码。</p><p id="252e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">将终端移动到包含您的的文件夹。proto文件并运行这个命令</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="90e8" class="mo kv it nr b gy ok ol l om on">$ protoc --go_out=. --go_opt=paths=source_relative \<br/>  --go-grpc_out=. --go-grpc_opt=paths=source_relative \<br/>  *.proto</span></pre><p id="3f97" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">基本上，这个命令将获得你当前所在文件夹中的所有<code class="fe no np nq nr b">*.proto</code>文件，并用我们之前用grpc插件安装的协议二进制文件进行编译。</p><p id="a9ec" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我的项目编译后看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/c811cddec1b7164e0d450ab3d88de91a.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*x5hRFEXpKhFgvOBnc-cCTw.png"/></div></div></figure><p id="221d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">注意:我已经将tutorial.proto文件放在tutorial文件夹/包中。</p><p id="1e71" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">文件<code class="fe no np nq nr b">tutorial_grpc.pb.go</code>是用protocol(带grpc插件)编译的<code class="fe no np nq nr b">tutorial.proto</code>文件的结果。</p><p id="99dc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在<code class="fe no np nq nr b">tutorial_grpc.pb.go </code>文件中，有我们在proto文件中定义的所有类型，还有服务器和客户端代码。</p><h1 id="53f3" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">gRPC服务器的实施</h1><p id="ddf5" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在运行gRPC服务器之前，我们<strong class="lo iu">必须实现我们在<code class="fe no np nq nr b">.proto</code>文件中定义的方法</strong>。</p><p id="e630" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在我们的例子中，我们必须实现</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="da6f" class="mo kv it nr b gy ok ol l om on">rpc SayHello (HelloRequest) returns (HelloReply) {}</span></pre><p id="3c78" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">为了启动gRPC服务器，我们必须实现这个接口(您可以在<code class="fe no np nq nr b">tutorial_grpc.pb.go</code>文件中找到它)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="8cb9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">首先，我们在<code class="fe no np nq nr b">.proto</code>文件旁边创建一个<code class="fe no np nq nr b">server.go</code>文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/601d5cef851f6a34890443ef4fbd15bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*GIlPvWFzkej2FWXltLEOYQ.png"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="f258" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在我们必须启动服务器，并在main.go文件的TCP端口上为它提供服务</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="23f1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在，您已经准备好在端口9000上启动服务器😃 😃</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="c22f" class="mo kv it nr b gy ok ol l om on">$ go run .</span></pre></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h2 id="c728" class="mo kv it bd kw mp mq dn la mr ms dp le lv mt mu lg lz mv mw li md mx my lk mz bi translated">让我们用BloomRPC(用于RPC服务的GUI客户机)测试我们的gRPC服务器</h2><p id="c97c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">你可以从github页面下载Bloom。</p><p id="7aad" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">安装之后，您必须添加您在项目中定义的proto(在我的例子中是tutorial.proto ),然后您可以测试您的API。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/3a430b2d16409ddb1133fcadd89d9957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c5EjeKTqUfDurpnnFTGSwA.png"/></div></div></figure><p id="9f93" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们的服务器正在工作😃</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h2 id="44eb" class="mo kv it bd kw mp mq dn la mr ms dp le lv mt mu lg lz mv mw li md mx my lk mz bi translated">最后的想法</h2><p id="f538" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在，您终于创建了您的第一台gRPC服务器。</p><p id="34ce" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果你做到了这一步，我希望你喜欢它！</p><p id="c92e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果你有任何问题，请留下评论。</p><p id="aeaf" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">感谢您的阅读。</p><h1 id="d407" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">这里有一些我写的其他文章，我想你会觉得有用</h1><div class="oy oz gp gr pa pb"><a href="https://www.klitonbare.com/blog/animate-svg-with-framer" rel="noopener  ugc nofollow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">用React和帧运动制作SVG动画</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">你好👋在这篇文章中，我将向你展示我是如何为我的博客标识创建一个绘制效果的。在这里你将得到什么(你可以…</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">www.klitonbare.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp ks pb"/></div></div></a></div><div class="oy oz gp gr pa pb"><a rel="noopener  ugc nofollow" target="_blank" href="/best-books-that-every-software-developer-must-know-8b96faff180d"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">每个软件开发人员都必须知道的最佳书籍！</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">你的书架上有这些书吗？</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">itnext.io</p></div></div><div class="pk l"><div class="pq l pm pn po pk pp ks pb"/></div></div></a></div><div class="oy oz gp gr pa pb"><a rel="noopener  ugc nofollow" target="_blank" href="/best-vscode-extensions-by-a-full-stack-developer-in-2022-f730037b6e0b"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">2022年全栈开发者评选的最佳VsCode扩展</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">作为一名完整的堆栈开发人员，以下是我挑选的最好的VS代码扩展！</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">itnext.io</p></div></div><div class="pk l"><div class="pr l pm pn po pk pp ks pb"/></div></div></a></div></div></div>    
</body>
</html>