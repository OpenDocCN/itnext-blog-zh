<html>
<head>
<title>End-to-end microservices testing with Catcher</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Catcher进行端到端微服务测试</h1>
<blockquote>原文：<a href="https://itnext.io/end-to-end-microservices-testing-with-catcher-d29e5a2f1394?source=collection_archive---------4-----------------------#2019-05-16">https://itnext.io/end-to-end-microservices-testing-with-catcher-d29e5a2f1394?source=collection_archive---------4-----------------------#2019-05-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4b580f167da874f0eab154bef20d77c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_Ghv9oTJ_8U7lSbJ.png"/></div></div></figure><p id="237e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想介绍一个新的端到端测试工具— <a class="ae kw" href="https://github.com/comtihon/catcher" rel="noopener ugc nofollow" target="_blank"> Catcher </a>。</p><h1 id="51a4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是e2e测试？</h1><p id="59c5" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">端到端测试通常回答这样的问题:“这个用户真的被创建了吗，或者服务只是返回200而没有任何动作？”。</p><p id="3cb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与项目级测试(单元/功能/集成)相比，e2e是针对整个系统运行的。它们可以调用后端的http端点，检查写入数据库、消息队列的值，询问其他服务的变化，甚至模拟外部服务的行为。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/055c976f763c6c6883def734b5d90512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LWnq2IjgN249iIwu.png"/></div></div></figure><p id="59db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">E2E测试是最高水平的测试。它们通常旨在验证系统是否满足需求，以及所有组件是否可以相互交互。</p><h1 id="18f1" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">为什么我们需要e2e测试？</h1><p id="ec1f" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">为什么我们需要编写这些测试？甚至M .福勒<a class="ae kw" href="https://martinfowler.com/articles/microservice-testing/#testing-end-to-end-tips" rel="noopener ugc nofollow" target="_blank">也建议</a>避免这些测试，转而进行更简单的测试。</p><p id="21ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，在更高的抽象层上编写测试——将会进行更少的重写。在重构的情况下，单元测试通常会被完全重写。在代码更改期间，您还应该将大部分时间花在功能测试上。但是端到端测试应该检查您的业务逻辑，这不太可能经常改变。</p><p id="de1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除此之外，即使所有微服务的全覆盖也不能保证它们之间的正确交互。开发人员可能会错误地实现协议(命名或数据类型错误)。或者依靠文档中的数据模式开发新功能。无论如何，在prod环境中你会得到一个惊喜，因为模式不匹配:数据混乱或者有人忘记更新模式。</p><p id="b0b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个服务的测试都是绿色的。</p><h1 id="964e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">为什么我们需要自动化测试？</h1><p id="907c" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">确实如此。在我之前的公司，决定不花精力在建立自动化测试上，因为这需要时间。我们的系统当时还不大(10–15个微服务加常见的Kafka)。CTO说“测试不重要，重要的是——系统应该工作”。所以我们在多种环境下进行手动测试。</p><p id="f4f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它看起来像什么:</p><ol class=""><li id="d6d3" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">与其他微服务的所有者讨论应该部署什么来测试新功能。</li><li id="4903" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">部署所有服务。</li><li id="c9e8" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">连接到远程kafka(通过网关的双ssh)。</li><li id="8623" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">连接到k8s日志。</li><li id="c70a" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">手动创建并发送kafka消息(感谢上帝是普通的json)。</li><li id="8534" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">检查日志，试图了解它是否工作。</li></ol><p id="9730" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们添加一个美中不足的地方:大多数测试需要创建新用户，因为重用现有用户很困难。</p><p id="ad2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用户注册的样子:</p><ol class=""><li id="0c64" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">插入各种数据(姓名、电子邮件等)。</li><li id="b557" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">插入个人数据(地址、电话、各种税务数据)。</li><li id="f16f" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">插入银行数据。</li><li id="7aa4" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">回答20-40个问题。</li><li id="6038" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">Pass <a class="ae kw" href="https://www.idnow.io/" rel="noopener ugc nofollow" target="_blank"> IdNow </a>(有dev的模型，但是stage花了5分多钟，因为他们的沙箱有时会过载)。</li><li id="3bd5" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">这一步需要开设银行账户，你不能通过前端。你必须通过ssh访问kafka，并充当一个模拟服务(发送一条消息，该帐户已被打开)。</li><li id="ad33" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">转到另一个前端上的版主帐户，批准您刚刚创建的用户。</li></ol><p id="d25d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">超级，用户刚刚创建！现在让我们添加另一个fly:一些测试需要不止一个用户。当测试失败时，你必须重新开始注册用户。</p><p id="dcb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">新功能如何通过业务团队的检查？下一个环境需要做同样的动作。</p><p id="0aa3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一段时间后，你开始觉得自己像一只猴子，点击这些众多的按钮，注册用户和执行手动步骤。此外，一些开发人员在kafka连接方面有问题，或者不知道tmux，并且面临默认终端和80字符限制的问题。</p><p id="2d3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">优点</strong>:</p><ul class=""><li id="4944" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mt ml mm mn bi translated">不需要做设置。只是在现有环境下测试。</li><li id="4661" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mt ml mm mn bi translated">不需要很高的资质。可以由廉价的专家来完成</li></ul><p id="ad3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">缺点</strong>:</p><ul class=""><li id="50eb" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mt ml mm mn bi translated">要花很多时间(越远—越多)。</li><li id="29f7" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mt ml mm mn bi translated">通常只测试新的特性(不保证之前测试的所有特性都没问题)。</li><li id="18cc" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mt ml mm mn bi translated">通常手动测试是由合格的开发人员执行的(昂贵的开发人员从事廉价的工作)。</li></ul><h1 id="08c4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">怎么自动化？</h1><p id="3900" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如果你读到这里，仍然确信手工测试是可以的，并且在这个公司里所有的事情都做对了，那么我文章的其他部分你就不会感兴趣了。</p><p id="a7b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">开发人员可以有两种方法来自动化重复操作。它们取决于程序员的类型，他们有足够的时间:</p><ul class=""><li id="3068" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mt ml mm mn bi translated">独立的后端服务，存在于您的环境中。测试是内部硬编码的，通过端点触发。可以通过CI实现部分自动化。</li><li id="9381" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mt ml mm mn bi translated">带有硬编码测试的脚本。只是运行方式不同。您需要连接到某个地方(可能通过ssh)并调用这个脚本。可以放入Docker图像中。也可以通过CI实现自动化。</li></ul><p id="8657" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">听起来不错。有问题吗？</p><p id="0296" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是的。这种测试通常是使用作者知道的技术创建的。通常它是一种脚本语言，如python或ruby，它允许您快速、轻松地编写测试。</p><p id="78ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，有时您可能会偶然发现一些bash脚本、C语言或其他更奇特的东西。有一次，我花了一周时间将bike on bash脚本重写为python，因为这些脚本不再可扩展，没有人真正知道它们是如何工作的，或者它们测试什么。自制端到端测试的例子这里是<a class="ae kw" href="https://github.com/comtihon/metrics" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><p id="7b56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">优点</strong>:</p><ul class=""><li id="c890" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mt ml mm mn bi translated">它们是自动化的！</li></ul><p id="ab8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">缺点</strong>:</p><ul class=""><li id="8d42" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mt ml mm mn bi translated">对开发人员的资格有额外的要求(例如，主要语言是Java，但测试是用Python编写的)</li><li id="3b22" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mt ml mm mn bi translated">你写一个代码来测试一个代码(谁来测试这些测试？)</li></ul><h1 id="b9b1" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">有没有开箱即用的东西？</h1><p id="b065" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">当然了。看看<a class="ae kw" href="https://en.wikipedia.org/wiki/Behavior-driven_development" rel="noopener ugc nofollow" target="_blank"> BDD </a>就知道了。有<a class="ae kw" href="https://cucumber.io/" rel="noopener ugc nofollow" target="_blank">黄瓜</a>或<a class="ae kw" href="https://www.gauge.org/" rel="noopener ugc nofollow" target="_blank">规</a>。</p><p id="e892" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简而言之，开发人员用一种特殊的语言描述业务场景，然后编写实现。这种语言通常是人类可读的。假设它不仅会被开发人员读/写，也会被项目经理读/写。</p><p id="c063" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与实现场景一起存储在独立项目中，由第三方服务(Cucumber、Gauge……)运行。</p><p id="43d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">场景:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="da05" class="mz ky iq mv b gy na nb l nc nd">Customer sign-up <br/>================ <br/>* Go to sign up page<br/> <br/>Customer sign-up <br/>---------------- <br/>tags: sign-up, customer</span><span id="cbcf" class="mz ky iq mv b gy ne nb l nc nd">* Sign up a new customer with name "John" email "jdoe@test.de" and "password" <br/>* Check if the sign up was successful</span></pre><p id="a185" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实施:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="01fa" class="mz ky iq mv b gy na nb l nc nd">@Step("Sign up as &lt;customer&gt; with email &lt;test@example.com&gt; and &lt;password&gt;") <br/>public void signUp(String customer, String email, String password) { <br/>  WebDriver webDriver = Driver.webDriver; <br/>  WebElement form = webDriver.findElement(By.id("new_user"));<br/>  form.findElement(By.name("user[username]")).sendKeys(customer); <br/>  form.findElement(By.name("user[email]")).sendKeys(email); <br/>  form.findElement(By.name("user[password]")).sendKeys(password); <br/>  form.findElement(By.name("user[password_confirmation]")).sendKeys(password); <br/>  form.findElement(By.name("commit")).click(); <br/>} </span><span id="2b45" class="mz ky iq mv b gy ne nb l nc nd">@Step("Check if the sign up was successful") <br/>public void checkSignUpSuccessful() { <br/>  WebDriver webDriver = Driver.webDriver; <br/>  WebElement message = webDriver.findElements(By.className("message"));<br/>  assertThat(message.getText(), is("You have been signed up successfully!")); <br/>}</span></pre><p id="aeaa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完整的项目可以在<a class="ae kw" href="https://github.com/getgauge-examples/java-maven-selenium" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="7ae0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">优点</strong>:</p><ul class=""><li id="06aa" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mt ml mm mn bi translated">业务逻辑是用人类可读的语言描述的，并且存储在一个地方(可以用作文档)。</li><li id="f743" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mt ml mm mn bi translated">使用现有的解决方案。开发者只需要知道如何使用它们。</li></ul><p id="a572" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">缺点</strong>:</p><ul class=""><li id="7200" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mt ml mm mn bi translated">经理不会读/写这些规范。</li><li id="4135" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mt ml mm mn bi translated">您必须维护规范和实现。</li></ul><h1 id="e219" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">为什么我们需要捕手？</h1><p id="8621" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">当然，为了简化流程。</p><p id="d1e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">开发者只需用json或yaml编写一个测试场景，catcher执行它们。该场景只是一组连续的步骤，例如:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="ae66" class="mz ky iq mv b gy na nb l nc nd">steps: <br/>  - http: <br/>      post: <br/>        url: '127.0.0.1/save_data' <br/>        body: {key: '1', data: 'foo'} <br/>  - postgres: <br/>      request: <br/>        conf: 'dbname=test user=test host=localhost password=test' <br/>        query: 'select * from test where id=1'</span></pre><p id="9788" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Catcher支持<a class="ae kw" href="http://jinja.pocoo.org" rel="noopener ugc nofollow" target="_blank"> Jinja2 </a>模板，所以可以用变量代替硬编码的值。您还可以将全局变量存储在清单文件中(如ansible中)，从环境中获取它们或注册新的变量。</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="7e30" class="mz ky iq mv b gy na nb l nc nd">variables: <br/>  bonus: 5000 <br/>  initial_value: 1000 <br/>steps: <br/>  - http: <br/>      post: <br/>        url: '{{ user_service }}/sign_up' <br/>        body: {username: 'test_user_{{ RANDOM_INT }}', data: 'stub'}     <br/>      register: {user_id: '{{ OUTPUT.uuid }}' <br/>  - kafka: <br/>      consume: <br/>        server: '{{ kafka }}' <br/>        topic: '{{ new_users_topic }}' <br/>        where: <br/>          equals: {the: '{{ MESSAGE.uuid }}', is: '{{ user_id }}'}   <br/>      register: {balance: '{{ OUTPUT.initial_balance }}'}</span></pre><p id="0a94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，您可以运行验证步骤:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="809d" class="mz ky iq mv b gy na nb l nc nd">- check: # check user's initial balance <br/>     equals: {the: '{{ balance }}', is: '{{ initial_value + bonus }}'}</span></pre><p id="59ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您也可以从一个测试运行另一个测试，这允许您重用代码并保持它在逻辑上的分离。</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="8e8e" class="mz ky iq mv b gy na nb l nc nd">include: <br/>  file: register_user.yaml <br/>  as: sign_up <br/>steps: <br/>  # .... some steps <br/>  - run: <br/>      include: sign_up <br/>  # .... some steps</span></pre><p id="ac15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Catcher还有一个标记系统——您可以只运行包含测试中的一些特殊步骤。</p><p id="262a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了内置的<a class="ae kw" href="https://catcher-test-tool.readthedocs.io/en/latest/source/catcher.steps.html" rel="noopener ugc nofollow" target="_blank">步骤</a>和额外的<a class="ae kw" href="https://github.com/comtihon/catcher_modules" rel="noopener ugc nofollow" target="_blank">存储库</a>之外，还可以用python(简单地通过继承<a class="ae kw" href="https://catcher-test-tool.readthedocs.io/en/latest/source/modules.html#python-module" rel="noopener ugc nofollow" target="_blank"> ExternalStep </a>)或任何其他语言编写自己的模块:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="9d04" class="mz ky iq mv b gy na nb l nc nd">#!/bin/bash <br/>one=$(echo ${1} | jq -r '.add.the') <br/>two=$(echo ${1} | jq -r '.add.to') <br/>echo $((${one} + ${two}))</span></pre><p id="50c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并执行它:</p><pre class="mb mc md me gt mu mv mw mx aw my bi"><span id="abe4" class="mz ky iq mv b gy na nb l nc nd">--- <br/>variables: <br/>  one: 1 <br/>  two: 2 <br/>steps: <br/>  - math: <br/>      add: {the: '{{ one }}', to: '{{ two }}'} <br/>    register: {sum: '{{ OUTPUT }}'}</span></pre><p id="35ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">建议将测试放在docker中，并通过CI运行它们。</p><p id="6992" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Docker image还可以在Marathon / K8s中用于测试现有环境。目前我正在做一个后端(AnsibleTower的模拟)来使测试过程更加容易和方便。</p><p id="f0f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一组微服务的e2e测试的例子就是这里的<a class="ae kw" href="https://catcher-test-tool.readthedocs.io/en/latest/source/microservices.html" rel="noopener ugc nofollow" target="_blank"/>。<br/>Travis集成的e2e测试的工作示例是<a class="ae kw" href="https://github.com/comtihon/surveyor" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><p id="90f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">优点</strong>:</p><ul class=""><li id="7d1e" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mt ml mm mn bi translated">无需编写任何代码(仅在定制模块的情况下)。</li><li id="d7e9" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mt ml mm mn bi translated">通过库存文件切换环境(如ansible)。</li><li id="3cf1" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mt ml mm mn bi translated">易于扩展定制模块(任何语言)。</li><li id="087d" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mt ml mm mn bi translated">准备使用模块。</li></ul><p id="71eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">缺点</strong>:</p><ul class=""><li id="f7cd" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mt ml mm mn bi translated">开发人员必须知道不太容易被人理解的DSL(与其他BDD工具相比)。</li></ul><h1 id="2aab" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">而不是结论</h1><p id="1442" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">你可以使用标准技术或者自己写一些东西。但是我这里说的是微服务。他们的特点是各种各样的技术和大量的团队。如果对于<code class="fe nf ng nh mv b">JVM</code>团队<a class="ae kw" href="https://junit.org/junit5/" rel="noopener ugc nofollow" target="_blank">来说，JUnit</a>+<a class="ae kw" href="https://www.testcontainers.org/" rel="noopener ugc nofollow" target="_blank">test containers</a>将是一个很好的选择，<code class="fe nf ng nh mv b">Erlang</code>团队将选择common <a class="ae kw" href="http://erlang.org/doc/man/common_test.html" rel="noopener ugc nofollow" target="_blank"> test </a>。在你的部门发展壮大后，所有的e2e测试都将交给一个专门的团队——基础设施或qa。想象一下他们会因为这个动物园而有多开心？</p><p id="5a4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在写这个工具的时候，只是想减少平时花在测试上的时间。在每家新公司，我通常都要编写(或重写)这样的测试系统。然而，这个工具比我想象的更加灵活。F.e. Catcher还可以用于组织集中迁移和更新微服务系统，或数据管道集成测试。</p></div></div>    
</body>
</html>