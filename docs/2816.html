<html>
<head>
<title>Performant Custom Map Markers for React-Native-Maps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React-Native-Maps的高性能自定义地图标记</h1>
<blockquote>原文：<a href="https://itnext.io/performant-custom-map-markers-for-react-native-maps-ddc8d5a1eeb0?source=collection_archive---------0-----------------------#2019-08-08">https://itnext.io/performant-custom-map-markers-for-react-native-maps-ddc8d5a1eeb0?source=collection_archive---------0-----------------------#2019-08-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e656" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">TL；dr-使用标记属性</em> <code class="fe km kn ko kp b"><em class="kl">tracksViewChanges</em></code> <em class="kl">控制标记在自定义标记加载后何时重新渲染，方法是将其设置为</em> <code class="fe km kn ko kp b"><em class="kl">false</em></code> <em class="kl">。</em></p><h1 id="3226" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">添加自定义标记</h1><pre class="lo lp lq lr gt ls kp lt lu aw lv bi"><span id="a337" class="lw kr iq kp b gy lx ly l lz ma">&lt;Marker<br/>    coordinate={marker.coordinate}<br/>&gt;<br/>    &lt;CustomMarkerComponent /&gt;<br/>&lt;/Marker&gt;</span></pre><p id="6019" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">典型的方法是简单地将您的自定义标记组件或<code class="fe km kn ko kp b">&lt;Image/&gt;</code>包装在<code class="fe km kn ko kp b">&lt;Marker&gt;</code>标签中。在你有多个标记之前，这都没问题。即使像这样向地图添加10个自定义标记，也会导致地图渲染出现严重的性能问题。</p><h1 id="fb7b" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">问题是</h1><p id="81d3" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">与几乎所有React原生性能问题一样，问题的根源在于大量不必要的重新渲染。每次地图更新时，所有自定义标记都会被渲染，这是非常低效的，因为标记大头针通常不会改变(图像和坐标)。</p><h1 id="31b5" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">提高性能</h1><p id="38e5" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">为了解决这个问题，我们将告诉地图准确的时间来跟踪标记针的视图变化。我们用<code class="fe km kn ko kp b">marker</code>上的<code class="fe km kn ko kp b">tracksViewChanges</code>道具来做这个。</p><pre class="lo lp lq lr gt ls kp lt lu aw lv bi"><span id="f08b" class="lw kr iq kp b gy lx ly l lz ma">import React, { PureComponent } from 'react';<br/>import { Image } from 'react-native';<br/>import { Marker } from 'react-native-maps';</span><span id="8018" class="lw kr iq kp b gy mg ly l lz ma">export default class CustomMarker <em class="kl">extends</em> PureComponent {</span><span id="b74f" class="lw kr iq kp b gy mg ly l lz ma">  constructor() {<br/>    super();<br/>    this.state = {<br/>      tracksViewChanges: true,<br/>    };<br/>  }</span><span id="82d0" class="lw kr iq kp b gy mg ly l lz ma">  stopTrackingViewChanges = () =&gt; {<br/>    this.setState(() =&gt; ({<br/>      tracksViewChanges: false,<br/>    }));<br/>  }</span><span id="1e4b" class="lw kr iq kp b gy mg ly l lz ma">  render() {<br/>    const { tracksViewChanges } = this.state;<br/>    const { marker } = this.props;</span><span id="5057" class="lw kr iq kp b gy mg ly l lz ma">  return (<br/>      &lt;Marker<br/>        coordinate={marker.coordinate}<br/>        tracksViewChanges={tracksViewChanges}<br/>      &gt;<br/>        &lt;Image<br/>          onLoad={this.stopTrackingViewChanges}<br/>          fadeDuration={0}<br/>        /&gt;<br/>      &lt;/Marker&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="ba0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来分析一下这里发生了什么:</p><p id="8303" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.我们用<code class="fe km kn ko kp b">tracksViewChanges = true</code>初始化，所以当自定义标记图像加载时，它将呈现。<br/> 2。我们设置了图像的<code class="fe km kn ko kp b">onLoad</code>，这样我们就不会不必要地重新渲染自定义标记。<br/> 3。我们应该设置<code class="fe km kn ko kp b">fadeDuration = 0</code>，否则当标记停止跟踪视图变化时，图像可能会卡在部分淡入状态。</p><p id="b2a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用这个组件，你可以添加大量的引脚，而不会降低你的应用程序。</p><p id="8581" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是请记住，标记不会在初始图像加载后跟踪变化。这意味着<strong class="jp ir">对标记的更新不会触发重新渲染</strong>。</p><figure class="lo lp lq lr gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mh"><img src="../Images/4f5e87d3a8643c81da4c88e81c82f7b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7DEWkm_3CYi9_RHhSRqQxg.png"/></div></div></figure><p id="dd98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除非我们处理适当的变化，否则不可能创建像这样的效果，其中单个标记图像基于传送带的位置被更新。</p><h1 id="95f2" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">处理道具变化</h1><p id="f12a" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">您所要做的就是添加这个<code class="fe km kn ko kp b">componentWillRecieveProps</code>逻辑并用您自己的实现来实现<code class="fe km kn ko kp b">shouldUpdate</code>方法:</p><pre class="lo lp lq lr gt ls kp lt lu aw lv bi"><span id="df78" class="lw kr iq kp b gy lx ly l lz ma">  componentWillReceiveProps(nextProps) {<br/>    if (this.shouldUpdate(nextProps)) {<br/>      this.setState(() =&gt; ({<br/>        tracksViewChanges: true,<br/>      }));<br/>    }<br/>  }</span><span id="b9b5" class="lw kr iq kp b gy mg ly l lz ma">  shouldUpdate = (nextProps) =&gt; { //TODO implement }</span></pre><p id="849e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">地图图钉现在可以动态更新，而不会影响性能。</p></div></div>    
</body>
</html>