<html>
<head>
<title>Why Standard C++ Math Functions Are Slow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么标准C++数学函数很慢</h1>
<blockquote>原文：<a href="https://itnext.io/why-standard-c-math-functions-are-slow-d10d02554e33?source=collection_archive---------0-----------------------#2020-12-27">https://itnext.io/why-standard-c-math-functions-are-slow-d10d02554e33?source=collection_archive---------0-----------------------#2020-12-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/75b5d9c704df425862e1c51abddf9c4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9URxUNoctIyySKJV6dt4CA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">计算平方根的C++函数的汇编</figcaption></figure><p id="6861" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">性能一直是C++的重中之重，然而在语言和标准库中都有许多例子，编译器生成的代码比机器能够生成的代码要慢得多。在这篇博文中，我将从标准数学库中探究一个这样的例子。</p><p id="f511" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">假设我们的任务是计算浮点数数组的平方根。我们可以编写一个这样的函数来执行操作:</p><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="10f0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我们使用gcc，我们可以用</p><pre class="la lb lc ld gt lg lh li lj aw lk bi"><span id="8baa" class="ll lm iq lh b gy ln lo l lp lq">g++ -c -O3 -march=native sqrt1.cpp</span></pre><p id="c9df" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有了<code class="fe lr ls lt lh b">-O3</code>，gcc将极大地优化代码，但仍然会产生符合标准的代码。<code class="fe lr ls lt lh b">-march=native</code>选项告诉gcc生成针对本地架构指令集的代码。即使在不同的x86-64 CPU之间，生成的二进制文件也可能不可移植。</p><p id="dbf3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，让我们对该函数进行基准测试。我们将使用<a class="ae lu" href="https://github.com/google/benchmark" rel="noopener ugc nofollow" target="_blank">谷歌基准</a>来测量计算<code class="fe lr ls lt lh b">1,000,000</code>数字的平方根需要多长时间:</p><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="2509" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">编译我们的基准并运行我们得到</p><pre class="la lb lc ld gt lg lh li lj aw lk bi"><span id="e849" class="ll lm iq lh b gy ln lo l lp lq">g++ -O3 -march=native -o benchmark benchmark.cpp sqrt1.o<br/>./benchmark<br/>Running ./benchmark<br/>Run on (6 X 2600 MHz CPU s)<br/>CPU Caches:<br/> L1 Data 32 KiB (x6)<br/> L1 Instruction 32 KiB (x6)<br/> L2 Unified 256 KiB (x6)<br/> L3 Unified 9216 KiB (x6)<br/>Load Average: 0.17, 0.07, 0.05<br/> — — — — — — — — — — — — — — — — — — — — — — — — — — — — — -<br/>Benchmark Time CPU Iterations<br/> — — — — — — — — — — — — — — — — — — — — — — — — — — — — — -<br/>BM_Sqrt1/1000000 4984457 ns 4946631 ns 115</span></pre><p id="9387" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们能做得更好吗？让我们试试这个版本:</p><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="65a2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">并使用编译</p><pre class="la lb lc ld gt lg lh li lj aw lk bi"><span id="e6ca" class="ll lm iq lh b gy ln lo l lp lq">g++ -c -O3 -march=native -fno-math-errno sqrt2.cpp</span></pre><p id="58a3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lr ls lt lh b">compute_sqrt1</code>和<code class="fe lr ls lt lh b">compute_sqrt2</code>唯一的区别是我们在编译时增加了额外的选项<code class="fe lr ls lt lh b">-fno-math-errno</code>。稍后我会解释<code class="fe lr ls lt lh b">-fno-math-errno</code>是做什么的；但是现在，我只会指出产生的代码不再符合标准。</p><p id="3f45" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们来对标一下<code class="fe lr ls lt lh b">compute_sqrt2</code>。</p><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="8e6a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">运转</p><pre class="la lb lc ld gt lg lh li lj aw lk bi"><span id="3ae5" class="ll lm iq lh b gy ln lo l lp lq">g++ -O3 -march=native -o benchmark benchmark.cpp sqrt2.o<br/>./benchmark</span></pre><p id="e99a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们得到了</p><pre class="la lb lc ld gt lg lh li lj aw lk bi"><span id="3520" class="ll lm iq lh b gy ln lo l lp lq">Running ./benchmark<br/>Run on (6 X 2600 MHz CPU s)<br/>CPU Caches:<br/> L1 Data 32 KiB (x6)<br/> L1 Instruction 32 KiB (x6)<br/> L2 Unified 256 KiB (x6)<br/> L3 Unified 9216 KiB (x6)<br/>Load Average: 0.17, 0.07, 0.05<br/> — — — — — — — — — — — — — — — — — — — — — — — — — — — — — -<br/>Benchmark Time CPU Iterations<br/> — — — — — — — — — — — — — — — — — — — — — — — — — — — — — -<br/>BM_Sqrt2/1000000 1195070 ns 1192078 ns 553</span></pre><p id="6cf1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">呀！<code class="fe lr ls lt lh b">compute_sqrt2</code>是<em class="lv">比<code class="fe lr ls lt lh b">compute_sqrt1</code>快4倍多</em>。</p><p id="ea9a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有什么不同？让我们深入到组件中找出答案。我们可以通过运行以下命令来生成代码的程序集</p><pre class="la lb lc ld gt lg lh li lj aw lk bi"><span id="a62d" class="ll lm iq lh b gy ln lo l lp lq">g++ -S -c -O3 -march=native sqrt1.cpp<br/>g++ -S -c -O3 -march=native -fno-math-errno sqrt2.cpp</span></pre><p id="4f98" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">结果将取决于您使用的架构，但是在我的架构上查看<a class="ae lu" href="https://github.com/rnburn/cmath-benchmark/blob/main/asm/sqrt1.s" rel="noopener ugc nofollow" target="_blank"> sqrt1.s </a>，我们看到了这一部分</p><pre class="la lb lc ld gt lg lh li lj aw lk bi"><span id="90e2" class="ll lm iq lh b gy ln lo l lp lq">.L3:<br/> vmovsd (%rdi), %xmm0<br/> vucomisd %xmm0, %xmm2<br/> vsqrtsd %xmm0, %xmm1, %xmm1<br/> ja .L12<br/> addq $8, %rdi<br/> vmovsd %xmm1, (%rdx)<br/> addq $8, %rdx<br/> cmpq %r12, %rdi<br/> jne .L3</span></pre><p id="23c5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们分解前几条指令:</p><pre class="la lb lc ld gt lg lh li lj aw lk bi"><span id="d9a7" class="ll lm iq lh b gy ln lo l lp lq">1: vmovsd (%rdi), %xmm0 <br/> # Load a value from memory into the register %xmm0<br/>2: vucomisd %xmm0, %xmm2<br/> # Compare the value of %xmm0 with %xmm2 and set the register<br/> # EFLAGS with the result<br/>3: vsqrtsd %xmm0, %xmm1, %xmm1 <br/> # Compute the square root of %xmm0 and store in %xmm1<br/>4: ja .L12 <br/> # Inspects EFLAGS and jumps if %xmm2 is above %xmm0</span></pre><p id="85d6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">指令3和4是干什么用的？回想一下，对于实数，sqrt没有定义负值。当传递给<code class="fe lr ls lt lh b">std::sqrt</code>一个负数时，C++标准要求它返回特殊的浮点值<code class="fe lr ls lt lh b">NaN</code>，并将全局变量<code class="fe lr ls lt lh b">errno</code>设置为<code class="fe lr ls lt lh b">EDOM</code>。但是错误处理最终会非常昂贵。</p><p id="2ebd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我们看一下<a class="ae lu" href="https://github.com/rnburn/cmath-benchmark/blob/main/asm/sqrt2.s" rel="noopener ugc nofollow" target="_blank"> sqrt2.s </a>，我们会看到主循环的这些指令:</p><pre class="la lb lc ld gt lg lh li lj aw lk bi"><span id="9b75" class="ll lm iq lh b gy ln lo l lp lq">.L6:<br/> addl $1, %r8d<br/> vsqrtpd (%r10,%rax), %ymm0<br/> vextractf128 $0x1, %ymm0, 16(%rcx,%rax)<br/> vmovups %xmm0, (%rcx,%rax)<br/> addq $32, %rax<br/> cmpl %r8d, %r11d<br/> ja .L6</span></pre><p id="364d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">没有错误处理的负担，gcc可以产生更快的代码。<code class="fe lr ls lt lh b">vsqrtpd</code>是所谓的单指令多数据(SIMD)指令。它一次计算四个双精度浮点数的平方根。对于像sqrt这样计算量很大的函数，矢量化非常有用。</p><p id="190f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">不幸的是，标准要求这样的错误处理。进行错误检查要慢得多，以至于许多编译器，如英特尔的icc和苹果默认的基于clang的编译器，默认情况下都选择不进行错误处理。即使我们想让<code class="fe lr ls lt lh b">std::sqrt</code>做错误处理，我们也不能依赖主流编译器来做。</p><p id="2ce1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="lv">完整的基准可以在</em><a class="ae lu" href="https://github.com/rnburn/cmath-benchmark" rel="noopener ugc nofollow" target="_blank"><em class="lv">rn burn/cmath-bech mark</em></a><em class="lv">找到。这个故事最初发表于</em><a class="ae lu" href="https://ryanburn.com/2020/12/26/why-c-standard-math-functions-are-slow/" rel="noopener ugc nofollow" target="_blank">https://ryanburn . com/2020/12/26/why-c-standard-math-functions-are-slow/</a></p></div></div>    
</body>
</html>