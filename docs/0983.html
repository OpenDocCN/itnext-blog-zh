<html>
<head>
<title>Serverless GraphQL with FREE CDN &amp; in-memory caching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有免费CDN和内存缓存的无服务器GraphQL</h1>
<blockquote>原文：<a href="https://itnext.io/serverless-graphql-with-free-cdn-in-memory-caching-766c1e29376a?source=collection_archive---------5-----------------------#2018-06-27">https://itnext.io/serverless-graphql-with-free-cdn-in-memory-caching-766c1e29376a?source=collection_archive---------5-----------------------#2018-06-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f52f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">声明:这是我的第一篇关于媒体的文章，我只是想和大家分享我的经验:)所以请不要介意我的写作技巧。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/2ec08de59683f851324ba050e966a215.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JpzHX1DIDvQ8n81ZLkJFPg.jpeg"/></div></div></figure><p id="72b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自从我发现了GraphQL，我就爱上了它，尤其是因为它有像apollo-client这样的客户端库。然而，正如每种技术一样，也有权衡(见本文<a class="ae kx" href="https://dev-blog.apollodata.com/graphql-vs-rest-5d425123e34b" rel="noopener ugc nofollow" target="_blank">https://dev-blog . Apollo data . com/graph QL-vs-rest-5d 425123 e 34 b</a>)。我认为最大的缺点之一是缺少CDN &amp; HTTP缓存。幸运的是，apollo-client团队提出了一些解决方案:<a class="ae kx" href="https://www.apollographql.com/docs/engine/" rel="noopener ugc nofollow" target="_blank"> Apollo引擎</a>和<a class="ae kx" href="https://www.apollographql.com/docs/engine/auto-persisted-queries.html" rel="noopener ugc nofollow" target="_blank">自动持久化查询</a>。结合Firebase云功能，它可以解决所有的缓存问题。</p><h1 id="2259" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">阿波罗发动机的缺点</h1><p id="a6e1" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">当我写这篇文章时(27/06/2018)，如果你想在AWS Lambda或Google/Firebase Cloud Functions这样的无服务器框架上使用Apollo引擎，它并不真正适合。主要的缺点是您需要托管一个代理服务器，在基础设施中引入了一个额外的节点，从而产生了一个单点故障。</p><p id="4ba7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题在于apollo-server如何处理请求(至少是apollo-server-express)。目前，只要请求来自客户端，single express中间件就会处理查询解析、解析查询，并最终将请求发送回客户端。这就只剩下预处理和后处理请求的一个选项。是的，使用代理服务器…</p><p id="d214" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，我们可以将apollo-server-express包分成几个express中间件，这样我们就可以对请求进行预处理/后处理。</p><h1 id="089c" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">让我们写一些代码</h1><p id="c692" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">是时候编码了:</p><p id="d7c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要修改apollo-server-express包，以便能够使用我们的定制express中间件:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="eb32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主要区别是这几行:</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="24e7" class="mi kz iq me b gy mj mk l ml mm">gqlResponse =&gt; {<br/>        res['gqlResponse'] = gqlResponse;<br/>        next();<br/>},</span></pre><p id="750d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将gqlResponse存储在res['gqlResponse']变量中，并转到链中的下一个中间件，而不是直接发送给客户机。</p><p id="d392" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们创建负责向用户发送响应的最终中间件:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="d4a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并替换默认设置(假设您之前已经有了一些bodyparser中间件)</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="0b6c" class="mi kz iq me b gy mj mk l ml mm">app.use('/graphql', graphqlExpress({ schema: myGraphQLSchema }));</span></pre><p id="5ff1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="6658" class="mi kz iq me b gy mj mk l ml mm">app.use(<br/> '/graphql',<br/> // resolve the request<br/> graphqlExpress({<br/>  schema,<br/> }),<br/> // send the response<br/> graphqlResponseHandler<br/>);</span></pre><p id="367e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成了。</p><h1 id="4887" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">让我们释放野兽</h1><p id="a978" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">这个设计最好的部分是，我们可以在graphql处理请求之前和服务器发送响应之前添加中间件。实现缓存、跟踪、追踪等的完美技术。</p><p id="e7ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终，端点将拥有这些中间件:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="3481" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">storeCache是一个LTU缓存库，但也可以是一个redis数据库。</p><p id="6afe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里定义了所有的中间件:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><h2 id="7978" class="mi kz iq bd la mn mo dn le mp mq dp li jy mr ms lm kc mt mu lq kg mv mw lu mx bi translated">关于缓存“POST”请求的快速解释</h2><p id="2a50" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">首先，如果你使用post请求，CDN缓存将不起作用。剩下的就是服务器上的响应缓存。</p><p id="21c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">诀窍是从post主体生成一个惟一的散列队列。这是通过调用hashPostBody函数来完成的。</p><p id="405f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当post请求到达服务器时，getFromCacheIfAny中间件检查查询是否被缓存(第101行)。如果是，它将从缓存中发送响应。否则，它继续到下一个中间件graphqlHandler。graphql服务器解析查询并将结果设置在res["gqlResponse"]变量中，如上所述。</p><p id="9937" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后storeInCache中间件开始工作，在这里我们再次缓存post主体，检查整个查询的maxDuration(在这里解释:<a class="ae kx" href="https://github.com/apollographql/apollo-cache-control" rel="noopener ugc nofollow" target="_blank">https://github.com/apollographql/apollo-cache-control</a>)并将结果存储在带有maxDuration的缓存中。</p><p id="fca7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们用extensionsFilter清理完扩展之后(您也可以在这里做一些日志记录)。最后，我们将请求发送回去。</p><h1 id="f280" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">让我们创造一个火箭</h1><p id="faa2" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">现在是时候设置CDN缓存了。要使用CDN缓存，我们需要发送GET请求。总之，apollo-client散列查询(就像我们对POST请求所做的那样)并发送一个散列。服务器检查散列是否在高速缓存中，如果是，它发送高速缓存数据，否则它解析查询并将结果与散列关键字(也由apollo-client发送)一起存储在高速缓存中。有深度的文章和设置说明可以在这里找到:<a class="ae kx" href="https://www.apollographql.com/docs/engine/auto-persisted-queries.html" rel="noopener ugc nofollow" target="_blank">https://www . apollographql . com/docs/engine/auto-persisted-queries . html</a>，直接跳过引擎部分。</p><h2 id="1e0a" class="mi kz iq bd la mn mo dn le mp mq dp li jy mr ms lm kc mt mu lq kg mv mw lu mx bi translated">由Firebase支持的免费CDN缓存</h2><p id="e898" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">Firebase是托管无服务器后端的绝佳平台。最棒的是:如果你使用Firebase云功能，你可以获得免费的CDN缓存。详情见此:<a class="ae kx" href="https://firebase.google.com/docs/hosting/functions#manage_cache_behavior" rel="noopener ugc nofollow" target="_blank">https://firebase . Google . com/docs/hosting/functions # manage _ cache _ behavior</a></p><p id="d847" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要在Firebase云功能上启用CDN缓存，只需一行代码:</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="3d08" class="mi kz iq me b gy mj mk l ml mm">// set CDN caching<br/>// line 120<br/>res.setHeader('Cache-Control', `public, max-age=${durationLeft}, s-maxage=${durationLeft}`);</span></pre><p id="0f17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">火基云功能的缺点:</strong> <br/>火基云功能:冷启动…</p><p id="7433" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，您不会被firebase或任何其他无服务器服务所束缚。</p><h1 id="b696" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="c19f" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们已经创建了一个全功能的graphql服务器，它运行在Firebase Cloud函数上，并具有内置的内存和CDN缓存。最棒的是:它是免费的(<em class="my">直到你每月达到200万次请求，CDN响应不算</em>)。</p><p id="b3c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完整的代码库可以在这里找到:<a class="ae kx" href="https://github.com/Rusfighter/firegraph" rel="noopener ugc nofollow" target="_blank">https://github.com/Rusfighter/firegraph</a></p><p id="48e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要在本地运行:</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="e81b" class="mi kz iq me b gy mj mk l ml mm">cd functions &amp;&amp; npm install &amp;&amp; npm run watch</span></pre><p id="9beb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要部署到firebase，请查看firebase云功能文档。</p><h2 id="ae5a" class="mi kz iq bd la mn mo dn le mp mq dp li jy mr ms lm kc mt mu lq kg mv mw lu mx bi translated">最后的话</h2><p id="55b5" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">就像我在免责声明中说的，这是我第一篇关于medium的文章。而且我的英语写作能力也没有我希望的那么好，所以如果你有一些备注或者需要更多的解释，请继续并留下评论:)。</p><h1 id="2eb1" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">奖金</h1><p id="662e" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">由于我们应该提高冷启动性能，所以我们需要延迟加载我们只对特定云功能感兴趣的模块。为此，我们创建一个助手函数:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="74e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，如果函数被触发，我们就延迟加载我们只需要的模块。这将导致更好的冷启动性能，尤其是当您需要大量模块时。更多改进建议请见:<a class="ae kx" href="https://firebase.google.com/docs/functions/tips#performance" rel="noopener ugc nofollow" target="_blank">https://firebase.google.com/docs/functions/tips#performance</a></p></div></div>    
</body>
</html>