<html>
<head>
<title>Using Python Trained Machine Learning Models from Phoenix (Elixir) Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用来自Phoenix (Elixir)应用程序的Python训练的机器学习模型</h1>
<blockquote>原文：<a href="https://itnext.io/using-machine-learning-models-python-from-phoenix-elixir-applications-cd028e4e5f01?source=collection_archive---------2-----------------------#2019-05-10">https://itnext.io/using-machine-learning-models-python-from-phoenix-elixir-applications-cd028e4e5f01?source=collection_archive---------2-----------------------#2019-05-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="2780" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Python是机器学习和数据科学事实上的语言。Python中有许多用于此目的的库和框架。另一方面，Elixir相对较新，在Elixir中进行机器学习仍然不容易。在本文中，我将介绍我们如何使用一个机器学习模型，该模型是使用Phoenix (Elixir) web应用程序中的Python训练的。由于流程保持不变，因此不一定必须是web应用程序。任何Elixir应用程序都可以使用类似的方法，并使用预先训练好的Python ML模型。</p><h1 id="d6a0" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">埃尔波特:秘制调味酱</h1><p id="f45b" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我将使用<a class="ae lr" href="http://erlport.org" rel="noopener ugc nofollow" target="_blank">erport</a>来建立Python和Elixir之间的通信通道。</p><p id="87eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ErlPort是一个用于Erlang的库，它帮助Erlang连接到许多其他编程语言。目前支持的外部语言有Python和Ruby。该库使用 <a class="ae lr" href="http://erlang.org/doc/reference_manual/ports.html" rel="noopener ugc nofollow" target="_blank"> <em class="ls"> Erlang端口协议</em> </a> <em class="ls">来简化语言之间的连接，并使用Erlang外部术语格式来设置通用数据类型映射</em></p><p id="91f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要详细了解ErlPort以及它如何为Python工作，我建议阅读官方文档<a class="ae lr" href="http://erlport.org/docs/" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae lr" href="http://erlport.org/docs/python.html" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="432b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总而言之，</p><p id="00f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">— ErlPort使用库函数<strong class="js iu"> start/0 </strong>或<strong class="js iu"> start/1 </strong>创建Python语言的实例</p><p id="e8da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">—一旦创建了语言实例，就可以使用函数<strong class="js iu"> call/4(同步)</strong>或<strong class="js iu"> cast/2(异步)</strong>来调用Python函数并将结果传回给调用者。</p><p id="af29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">—会话结束时，调用<strong class="js iu"> stop/1 </strong>函数终止语言实例</p><p id="21e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Erlang和Python之间的数据类型映射在这里以表格形式呈现—<a class="ae lr" href="http://erlport.org/docs/python.html" rel="noopener ugc nofollow" target="_blank">http://erlport.org/docs/python.html</a>。也可以使用提供定制编码器/解码器的定制数据类型。</p><p id="4b8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我将从这里使用ErlPort十六进制模块—<a class="ae lr" href="https://hex.pm/packages/erlport" rel="noopener ugc nofollow" target="_blank">https://hex.pm/packages/erlport</a></p><h1 id="1fe1" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">训练ML模型</h1><p id="c16f" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">早些时候我写过一篇文章——“使用Scikit训练自己的ML模型，并在iOS应用中使用CoreML(可能还有增强现实) ”。由于本文的重点是我们如何使用来自Elixir app的预训练模型，我将在这里使用在那篇文章中训练的相同模型。鼓励有兴趣了解机器学习部分的读者阅读这篇文章。因为我们在这里不会使用CoreML模型，所以培训的最后一部分已经做了一些小的修改，使用'<strong class="js iu"> joblib </strong>'而不是CoreML将模型保存为pickle格式。</p><p id="c8be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完整的Jupyter笔记本(<strong class="js iu"> iris-analysis.ipynb </strong>)可在此处获得—<a class="ae lr" href="https://github.com/imeraj/Phoenix_Playground/blob/master/1.4/phoenix_ml/lib/phoenix_ml/model/iris-analysis.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/imeraj/Phoenix _ Playground/blob/master/1.4/Phoenix _ ml/lib/Phoenix _ ml/model/iris-analysis . ipynb</a></p><p id="62e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">包含训练数据的CSV文件(<strong class="js iu"> iris-data.csv </strong>)可在此处获得—<a class="ae lr" href="https://github.com/imeraj/Phoenix_Playground/blob/master/1.4/phoenix_ml/lib/phoenix_ml/model/iris-data.csv" rel="noopener ugc nofollow" target="_blank">https://github . com/imeraj/Phoenix _ Playground/blob/master/1.4/Phoenix _ ml/lib/Phoenix _ ml/model/iris-data . CSV</a></p><p id="1529" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">生成的ML模型保存在文件(<strong class="js iu"> classifier.pkl </strong>)中，可在此处获得—<a class="ae lr" href="https://github.com/imeraj/Phoenix_Playground/blob/master/1.4/phoenix_ml/lib/phoenix_ml/model/classifier.pkl" rel="noopener ugc nofollow" target="_blank">https://github . com/imeraj/Phoenix _ Playground/blob/master/1.4/Phoenix _ ML/lib/Phoenix _ ML/model/classifier . pkl</a></p><p id="60ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">凤凰app ( <strong class="js iu"> phoenix_ml </strong>)的完整源代码在这里——<a class="ae lr" href="https://github.com/imeraj/Phoenix_Playground/tree/master/1.4/phoenix_ml" rel="noopener ugc nofollow" target="_blank">https://github . com/imeraj/Phoenix _ Playground/tree/master/1.4/Phoenix _ ml</a></p><h2 id="5344" class="lt kp it bd kq lu lv dn ku lw lx dp ky kb ly lz lc kf ma mb lg kj mc md lk me bi translated">注意:请注意，我已经将Jupyter笔记本、CSV文件和生成的模型放在了同一源代码库中，这只是为了本文的目的。实际上，您的应用程序代码和ML代码可以存储在不同的位置。我们所需要的只是从我们的web应用程序访问训练好的模型文件“<strong class="ak"> classifier.pkl </strong>”。</h2><h1 id="86f4" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">从Phoenix(Elixir) Web应用程序访问ML模型</h1><p id="fe3f" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">在这一节中，我将把重点放在应用程序方面，并遍历必要的代码。</p><p id="c1ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我生成了一个没有ecto的简单的Phoenix 1.4应用程序，并在<strong class="js iu"> mix.exs </strong>中添加了ErlPort作为依赖项</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="c3e3" class="lt kp it mk b gy mo mp l mq mr">defp deps do<br/>    [<br/>      {:phoenix, "~&gt; 1.4.0"},<br/>      {:phoenix_pubsub, "~&gt; 1.1"},<br/>      {:phoenix_html, "~&gt; 2.11"},<br/>      {:phoenix_live_reload, "~&gt; 1.2", only: :dev},<br/>      {:gettext, "~&gt; 0.11"},<br/>      {:jason, "~&gt; 1.0"},<br/>      {:plug_cowboy, "~&gt; 2.0"},<br/>      <strong class="mk iu">{:erlport, "~&gt; 0.10.0"}</strong><br/>    ]<br/>  end</span></pre><p id="1c77" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu"> router.ex </strong>中增加了一条新路线——</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="e875" class="lt kp it mk b gy mo mp l mq mr">scope "/", PhoenixMlWeb do<br/>    pipe_through :browser<br/><br/>    get "/", PageController, :index<br/>    post "/predict", PageController, :show<br/>  end</span></pre><p id="8b2f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">修改了UI代码(<strong class="js iu">templates/page/{ form . html . eex，index.html.eex} </strong>)，最终的UI如下所示</p><figure class="mf mg mh mi gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ms"><img src="../Images/dbafa7a5e8f09e34ce595f88739aa3f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Ure1gNIf4G5T_wyj0WvBQ.png"/></div></div></figure><p id="7df0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">“<strong class="js iu">秀”</strong>的控制器代码非常简单，如下所示</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="23bd" class="lt kp it mk b gy mo mp l mq mr">def show(conn, %{<br/>        "sepal_length" =&gt; sepal_length,<br/>        "sepal_width" =&gt; sepal_width,<br/>        "petal_length" =&gt; petal_length,<br/>        "petal_width" =&gt; petal_width<br/>      }) do<br/>    with {sepal_length, _} &lt;- Float.parse(sepal_length),<br/>         {sepal_width, _} &lt;- Float.parse(sepal_width),<br/>         {petal_length, _} &lt;- Float.parse(petal_length),<br/>         {petal_width, _} &lt;- Float.parse(petal_width) do<br/>      <strong class="mk iu">class = ML.predict([[sepal_length, sepal_width, petal_length, petal_width]])<br/></strong><br/>      conn<br/>      |&gt; put_flash(:info, "Predicted class: " &lt;&gt; class)<br/>      |&gt; render("index.html")<br/>    else<br/>      _error -&gt;<br/>        conn<br/>        |&gt; put_flash(:error, "Invalid parameters!")<br/>        |&gt; render("index.html")<br/>    end<br/>  end</span></pre><p id="a726" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，控制器接受输入参数并将其解析为浮点型。解析成功后，调用<strong class="js iu"> ML.predict </strong>来生成预测的类。我们的大部分逻辑驻留在<strong class="js iu"> ML.predict </strong>中。</p><h2 id="1fef" class="lt kp it bd kq lu lv dn ku lw lx dp ky kb ly lz lc kf ma mb lg kj mc md lk me bi translated">做预测</h2><p id="a97d" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">读取模型和进行预测的主要部分是在Python代码(<strong class="js iu">lib/phoenix _ ml/model/classifier . py</strong>)中完成的</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="8bb9" class="lt kp it mk b gy mo mp l mq mr">import os<br/>from sklearn.externals import joblib <br/><br/>def load_model():<br/>    path = os.path.abspath('lib/phoenix_ml/model/classifier.pkl')<br/>    return joblib.load(path)  <br/><br/>def predict_model(args):<br/>    iris_classifier = load_model()<br/>    return iris_classifier.predict([args])[0]</span></pre><p id="9d38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> predict_model </strong>函数从'<strong class="js iu"> classifier.pkl </strong>中加载模型，调用<strong class="js iu"> predict </strong>函数传递必要的参数并返回结果。(<strong class="js iu"> <em class="ls">关于【args】部分我后面会再讲</em> </strong>)</p><p id="6239" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu"> lib/phoenix_ml/helpers </strong>里面有两个文件——<strong class="js iu">model _ predictor . ex</strong>和<strong class="js iu"> python_helper.ex </strong>。</p><p id="52cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我解释一下这部分代码。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="7ed1" class="lt kp it mk b gy mo mp l mq mr">defmodule PhoenixMl.ModelPredictor do<br/>  @moduledoc false<br/><br/>  alias PhoenixMl.PythonHelper, as: Helper<br/><br/>  @path 'lib/phoenix_ml/model/'<br/><br/>  def predict(args) do<br/>    <strong class="mk iu">call_python(:classifier, :predict_model, args)</strong><br/>  end<br/><br/>  defp call_python(module, func, args) do<br/>    <strong class="mk iu">pid = Helper.py_instance(Path.absname(@path))</strong><br/>    <strong class="mk iu">result = Helper.py_call(pid, module, func, args)</strong><br/><br/>    <strong class="mk iu">pid<br/>    |&gt; Helper.py_stop()</strong><br/><br/>    result<br/>  end<br/>end</span></pre><p id="0e52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><p id="0e6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">— <strong class="js iu">预测</strong>函数调用<strong class="js iu"> call_python </strong>带模块(:<strong class="js iu">分类器</strong>)、函数(:<strong class="js iu">预测_模型</strong>)和参数(<strong class="js iu"> args </strong>)</p><p id="f9be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">— <strong class="js iu"> call_python </strong>函数使用驻留在<strong class="js iu"> python_helper.ex </strong>中的助手函数与python模块通信</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="f258" class="lt kp it mk b gy mo mp l mq mr">defmodule PhoenixMl.PythonHelper do<br/>  @moduledoc false<br/><br/>  def py_instance(path) when is_binary(path) do<br/>    {:ok, pid} = :python.start([{:python_path, to_charlist(path)}])<br/>    pid<br/>  end<br/><br/>  def py_call(pid, module, func, args \\ []) do<br/>    pid<br/>    |&gt; :python.call(module, func, args)<br/>  end<br/><br/>  def py_stop(pid) do<br/>    :python.stop(pid)<br/>  end<br/>end</span></pre><p id="912e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><p id="3dbb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">— <strong class="js iu"> py_instance </strong>:使用Python模块(:<strong class="js iu">分类器</strong>)创建Python实例</p><p id="d9a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">— <strong class="js iu"> py_call </strong>:使用<strong class="js iu"> args </strong>作为参数，同步调用Python模块的<strong class="js iu"> predict_model </strong>函数</p><p id="1d93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">— <strong class="js iu"> py_stop </strong>:终止Python实例</p><p id="5ce4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个阶段，我们准备做预测。下面的屏幕截图显示了输入参数和相应的预测类—</p><figure class="mf mg mh mi gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi na"><img src="../Images/abe7ec79899e9f38bf7a16b5660c39b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jNLEISDskgHoQO0_5NTjAw.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">做出预测</figcaption></figure><h2 id="ef05" class="lt kp it bd kq lu lv dn ku lw lx dp ky kb ly lz lc kf ma mb lg kj mc md lk me bi translated">最后一件事</h2><p id="fc03" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我想多说一点关于已通过的论点。</p><p id="112d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从<strong class="js iu">控制器</strong>，我传递参数— [[5.5，2.4，3.7，1.0]]</p><p id="908a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这转到<strong class="js iu"> ML。预测</strong>函数为— [[5.5，2.4，3.7，1.0]]</p><p id="10f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> py_call </strong>接收该参数并调用— <strong class="js iu"> predict_model </strong>函数，将参数作为[5.5，2.4，3.7，1.0]传递，因为ErlPort将分隔每个参数(它接受一个参数列表)</p><p id="af54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是SKLean希望用一个二维数组来进行预测。因此，当我调用<strong class="js iu">iris _ classifier . predict([args])时，</strong>我必须再次创建一个二维数组，这样最终参数就变成了— [[5.5，2.4，3.7，1.0]]</p><h1 id="b4f4" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">参考</h1><ol class=""><li id="0837" class="nf ng it js b jt lm jx ln kb nh kf ni kj nj kn nk nl nm nn bi translated"><a class="ae lr" href="https://hex.pm/packages/erlport" rel="noopener ugc nofollow" target="_blank">https://hex.pm/packages/erlport</a></li><li id="9a62" class="nf ng it js b jt no jx np kb nq kf nr kj ns kn nk nl nm nn bi translated">http://erlport.org<a class="ae lr" href="http://erlport.org" rel="noopener ugc nofollow" target="_blank"/></li><li id="4c50" class="nf ng it js b jt no jx np kb nq kf nr kj ns kn nk nl nm nn bi translated">【http://erlport.org/docs/ T4】</li><li id="cf3a" class="nf ng it js b jt no jx np kb nq kf nr kj ns kn nk nl nm nn bi translated"><a class="ae lr" href="http://erlport.org/docs/python.html" rel="noopener ugc nofollow" target="_blank">http://erlport.org/docs/python.html</a></li><li id="605b" class="nf ng it js b jt no jx np kb nq kf nr kj ns kn nk nl nm nn bi translated"><a class="ae lr" href="https://hackernoon.com/mixing-python-with-elixir-7a2b7ac6696" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/mixing-python-with-elixir-7a 2 b 7 AC 6696</a></li></ol><p id="58ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望这篇文章能帮助一些读者理解如何使用来自Phoenix(Elixir)应用程序的用Python训练的机器学习模型。然而，ErlPort并不是与来自Elixir的Python代码进行通信的唯一方式。还有其他项目，如用于跨语言服务开发的<a class="ae lr" href="https://thrift.apache.org" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">Apache Thrift</strong></a><strong class="js iu"/>。感兴趣的读者被敦促寻找替代解决方案。</p><p id="7fae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ls">更多详细和深入的未来技术帖子，请关注我这里或</em><a class="ae lr" href="https://twitter.com/meraj_enigma" rel="noopener ugc nofollow" target="_blank"><em class="ls">Twitter</em></a><em class="ls">。</em></p></div></div>    
</body>
</html>