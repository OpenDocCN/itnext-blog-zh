<html>
<head>
<title>Building an operator for Kubernetes with kubebuilder</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用kubebuilder为Kubernetes构建一个操作符</h1>
<blockquote>原文：<a href="https://itnext.io/building-an-operator-for-kubernetes-with-kubebuilder-17cbd3f07761?source=collection_archive---------2-----------------------#2018-07-22">https://itnext.io/building-an-operator-for-kubernetes-with-kubebuilder-17cbd3f07761?source=collection_archive---------2-----------------------#2018-07-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2f0c9ac75e5c30f5b357a447c17de201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zw37ylQjDXzGtK75WgHfag.jpeg"/></div></div></figure><ul class=""><li id="c559" class="jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><a class="ae kq" href="https://medium.com/p/b4204be9ad56" rel="noopener">本系列的第一篇文章</a>探索了样本控制器。</li><li id="1fd2" class="jy jz iq ka b kb kr kd ks kf kt kh ku kj kv kl km kn ko kp bi translated">在本系列的第二篇文章中，我们将探索kubebuilder。</li><li id="c7a3" class="jy jz iq ka b kb kr kd ks kf kt kh ku kj kv kl km kn ko kp bi translated"><a class="ae kq" href="https://medium.com/p/40a029ea056" rel="noopener">在本系列的第三篇文章</a>中，我们将探索operator-sdk。</li></ul><p id="4d1e" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">你可以在我的新书中了解更多关于使用Kubernetes API和操作符的信息:<a class="ae kq" href="https://bit.ly/3vsuwI9" rel="noopener ugc nofollow" target="_blank">https://bit.ly/3vsuwI9</a></p><p id="0024" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">你也可以看看我在2018年伦敦Velocity Conf上关于这个主题的演讲:【https://youtu.be/Fp0QUf0Bwm0 T21】</p><h1 id="4aeb" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">库伯builder</h1><p id="d49a" class="pw-post-body-paragraph kw kx iq ka b kb mj ky kz kd mk la lb kf ml ld le kh mm lg lh kj mn lj lk kl ij bi translated">现在让我们探索kubebuilder套件并创建相同的CRD和操作符。记住，我们想要编写一个操作符，它将在集群的节点上部署一个守护进程。它将使用<code class="fe mo mp mq mr b">DaemonSet</code>对象来部署这个守护进程，我们希望能够指定一个标签，以便只在标记有该标签的节点上部署守护进程。我们还希望能够指定要部署的Docker映像。</p><h2 id="c3e4" class="ms lm iq bd ln mt mu dn lr mv mw dp lv kf mx my lz kh mz na md kj nb nc mh nd bi translated">开始一个项目</h2><p id="465c" class="pw-post-body-paragraph kw kx iq ka b kb mj ky kz kd mk la lb kf ml ld le kh mm lg lh kj mn lj lk kl ij bi translated">我们首先需要安装一些工具准备好:<code class="fe mo mp mq mr b">kubebuilder</code>本身、<code class="fe mo mp mq mr b">dep</code>和<code class="fe mo mp mq mr b">kustomize</code>。安装这些工具的所有信息可以在<a class="ae kq" href="http://book.kubebuilder.io/quick-start.html" rel="noopener ugc nofollow" target="_blank">http://book.kubebuilder.io/quick-start.html</a>找到</p><p id="56a7" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">让我们创建操作符。我们需要在GOPATH下创建我们的项目:</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="c89d" class="ms lm iq mr b gy nm nn l no np">mkdir -p $GOPATH/src/mydomain.com/mygroup &amp;&amp; cd $_</span></pre><p id="658c" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">然后启动项目:</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="04a5" class="ms lm iq mr b gy nm nn l no np">kubebuilder init --domain mydomain.com</span></pre><p id="c989" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">并在提示运行<code class="fe mo mp mq mr b">dep ensure</code>时回复<code class="fe mo mp mq mr b">y</code>。</p><p id="df7d" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">最后创造了CRD:</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="5672" class="ms lm iq mr b gy nm nn l no np">kubebuilder create api --group mygroup --version v1beta1 --kind GenericDaemon</span></pre><p id="4ddf" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">并在提示创建资源和控制器时回复<code class="fe mo mp mq mr b">y</code>。</p><p id="39fc" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated"><code class="fe mo mp mq mr b">kubebuilder</code>为我们创建了API的源代码，以在<code class="fe mo mp mq mr b">pkg/apis/mygroup/v1beta1</code>下访问我们的CRD。您可以看到创建的文件与我们之前在sample-controller中编辑的文件相似。</p><h2 id="52e4" class="ms lm iq bd ln mt mu dn lr mv mw dp lv kf mx my lz kh mz na md kj nb nc mh nd bi translated">写一些代码</h2><p id="abbb" class="pw-post-body-paragraph kw kx iq ka b kb mj ky kz kd mk la lb kf ml ld le kh mm lg lh kj mn lj lk kl ij bi translated">我们需要修改我们的<code class="fe mo mp mq mr b">GenericDaemon</code>的结构，为我们的对象添加必要的字段。不要忘记记录字段，这样文档生成器可以创建一个好的文档:</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="6def" class="ms lm iq mr b gy nm nn l no np">// pkg/apis/mygroup/v1beta1/genericdaemon_types.go<br/>[...]<br/>// GenericDaemonSpec defines the desired state of GenericDaemon<br/>type GenericDaemonSpec struct {<br/>  // Label is the value of the 'daemon=' label to set on a node that should run the daemon<br/>  <strong class="mr ir">Label string `json:"label"`<br/>  </strong>// Image is the Docker image to run for the daemon<br/><strong class="mr ir">  Image string `json:"image"`</strong><br/>}</span><span id="753c" class="ms lm iq mr b gy nq nn l no np">// GenericDaemonStatus defines the observed state of GenericDaemon<br/>type GenericDaemonStatus struct {<br/>  // Count is the number of nodes the daemon is deployed to<br/>  <strong class="mr ir">Count int32 `json:"count"`</strong><br/>}<br/>[...]</span></pre><p id="ab31" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">然后让我们遵循<code class="fe mo mp mq mr b">genericdaemon_controller.go</code>文件中的TODO指令。首先在<code class="fe mo mp mq mr b">add</code>函数中，让我们听听<code class="fe mo mp mq mr b">DaemonSet</code>而不是<code class="fe mo mp mq mr b">Deployment</code>:</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="0085" class="ms lm iq mr b gy nm nn l no np">// pkg/controller/genericdaemon/genericdaemon_controller.go<br/>func add(mgr manager.Manager, r reconcile.Reconciler) error {<br/>  [...]<br/>  // watch a Daemonset created by GenericDaemon<br/>  err = c.Watch(&amp;source.Kind{Type: &amp;appsv1.DaemonSet{}}, &amp;handler.EnqueueRequestForOwner{<br/>    IsController: true,<br/>    OwnerType:    &amp;mygroupv1beta1.GenericDaemon{},<br/>  })<br/>  [...]<br/>}</span></pre><p id="3218" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">其次，我们来写<code class="fe mo mp mq mr b">Reconcile</code>函数的代码。我们的CRD的具体部分以粗体显示:</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="a4e7" class="ms lm iq mr b gy nm nn l no np">// pkg/controller/genericdaemon/genericdaemon_controller.go<br/>// Automatically generate RBAC rules to allow the Controller to read and write Deployments<br/>// +kubebuilder:rbac:groups=apps,resources=<strong class="mr ir">daemonsets</strong>,verbs=get;list;watch;create;update;patch;delete<br/>// +kubebuilder:rbac:groups=mygroup.mydomain.com,resources=genericdaemons,verbs=get;list;watch;create;update;patch;delete<br/>func (r *ReconcileGenericDaemon) Reconcile(request reconcile.Request) (reconcile.Result, error) {<br/>  // Fetch the GenericDaemon instance<br/>  instance := &amp;mygroupv1beta1.GenericDaemon{}<br/>  err := r.Get(context.TODO(), request.NamespacedName, instance)<br/>  if err != nil {<br/>    if errors.IsNotFound(err) {<br/>      // Object not found, return.<br/>      // Created objects are automatically garbage collected.<br/>      // For additional cleanup logic use finalizers.<br/>      return reconcile.Result{}, nil<br/>    }<br/>    // Error reading the object - requeue the request.<br/>    return reconcile.Result{}, err<br/>  }</span><span id="2e2a" class="ms lm iq mr b gy nq nn l no np">// Define the desired Daemonset object<br/>  daemonset := &amp;appsv1.DaemonSet{<br/>    ObjectMeta: metav1.ObjectMeta{<br/>      Name:      instance.Name + "-daemonset",<br/>      Namespace: instance.Namespace,<br/>    },<br/>    Spec: appsv1.DaemonSetSpec{<br/>      Selector: &amp;metav1.LabelSelector{<br/>        MatchLabels: map[string]string{"daemonset": instance.Name + "-daemonset"},<br/>      },<br/>      Template: corev1.PodTemplateSpec{<br/>        ObjectMeta: metav1.ObjectMeta{<br/>          Labels: map[string]string{"daemonset": instance.Name + "-daemonset"},<br/>        },<br/>        Spec: corev1.PodSpec{<br/>          <strong class="mr ir">NodeSelector: map[string]string{"daemon": instance.Spec.Label},<br/></strong>          Containers: []corev1.Container{<br/>            {<br/>              Name:  "genericdaemon",<br/><strong class="mr ir">              Image: instance.Spec.Image,<br/></strong>            },<br/>          },<br/>        },<br/>      },<br/>    },<br/>  }<br/>  if err := controllerutil.SetControllerReference(instance, daemonset, r.scheme); err != nil {<br/>    return reconcile.Result{}, err<br/>  }</span><span id="1bc4" class="ms lm iq mr b gy nq nn l no np">// Check if the Daemonset already exists<br/>  found := &amp;appsv1.DaemonSet{}<br/>  err = r.Get(context.TODO(), types.NamespacedName{Name: daemonset.Name, Namespace: daemonset.Namespace}, found)<br/>  if err != nil &amp;&amp; errors.IsNotFound(err) {<br/>    log.Printf("Creating Daemonset %s/%s\n", daemonset.Namespace, daemonset.Name)<br/>    err = r.Create(context.TODO(), daemonset)<br/>    if err != nil {<br/>      return reconcile.Result{}, err<br/>    }<br/>  } else if err != nil {<br/>    return reconcile.Result{}, err<br/>  }<br/><strong class="mr ir">  // Get the number of Ready daemonsets and set the Count status <br/></strong>  <strong class="mr ir">if found.Status.NumberReady != instance.Status.Count {<br/>    log.Printf("Updating Status %s/%s\n", isntance.Namespace, instance.Name)<br/>    instance.Status.Count = found.Status.NumberReady<br/>    err = r.Update(context.TODO(), instance)<br/>    if err != nil {<br/>      return reconcile.Result{}, err<br/>    }<br/>  }</strong><br/>  // Update the found object and write the result back if there are any changes<br/>  if !reflect.DeepEqual(daemonset.Spec, found.Spec) {<br/>    found.Spec = daemonset.Spec<br/>    log.Printf("Updating Daemonset %s/%s\n", daemonset.Namespace, daemonset.Name)<br/>    err = r.Update(context.TODO(), found)<br/>    if err != nil {<br/>      return reconcile.Result{}, err<br/>    }<br/>  }<br/>  return reconcile.Result{}, nil<br/>}</span></pre><p id="17c2" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">我们还必须修改泛型守护进程的测试。重要的部分是正确地创建一个<code class="fe mo mp mq mr b">GenericDaemon</code>实例:</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="56ea" class="ms lm iq mr b gy nm nn l no np">// pkg/controller/genericdaemon/genericdaemon_controller_test.go<br/>func TestReconcile(t *testing.T) {<br/>  g := gomega.NewGomegaWithT(t)<br/><strong class="mr ir">  instance := &amp;mygroupv1beta1.GenericDaemon{<br/>    ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "default"},<br/>    Spec: mygroupv1beta1.GenericDaemonSpec{<br/>      Label: "http",<br/>      Image: "mydockerid/myimage",<br/>    },<br/>  }<br/></strong>  [...]</span></pre><h2 id="b208" class="ms lm iq bd ln mt mu dn lr mv mw dp lv kf mx my lz kh mz na md kj nb nc mh nd bi translated">部署和播放</h2><p id="d603" class="pw-post-body-paragraph kw kx iq ka b kb mj ky kz kd mk la lb kf ml ld le kh mm lg lh kj mn lj lk kl ij bi translated">仅此而已！我们现在可以重新构建API和控制器，构建和推送Docker映像，并部署我们的项目:</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="681b" class="ms lm iq mr b gy nm nn l no np">make<br/>make docker-build IMG=mydockerid/genericdaemon<br/>make docker-push IMG=mydockerid/genericdaemon<br/>make deploy</span></pre><p id="0232" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">如果您检查<code class="fe mo mp mq mr b">make deploy</code>命令的输出，您可以看到该命令为操作员部署了CRD、RBAC角色和角色绑定，以访问必要的对象，为操作员创建了名称空间，为操作员创建了服务和状态集。</p><p id="5c4d" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">此时，操作员应该正在运行:</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="8f6a" class="ms lm iq mr b gy nm nn l no np">$ kubectl get pods --namespace=mygroup-system <br/>NAME                           READY     STATUS    RESTARTS   AGE<br/>mygroup-controller-manager-0   1/1       Running   0          7s<br/>$ kubectl logs mygroup-controller-manager-0 --namespace=mygroup-system<br/>2018/07/22 09:06:32 Registering Components.<br/>2018/07/22 09:06:32 Starting the Cmd.</span></pre><p id="53b8" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">我们现在可以个性化生成的<code class="fe mo mp mq mr b">GenericDaemon</code>样本:</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="3739" class="ms lm iq mr b gy nm nn l no np">// config/samples/mygroup_v1beta1_genericdaemon.yaml<br/>apiVersion: mygroup.mydomain.com/v1beta1<br/>kind: GenericDaemon<br/>metadata:<br/>  labels:<br/>    controller-tools.k8s.io: "1.0"<br/>  name: genericdaemon-sample<br/>spec:<br/>  <strong class="mr ir">image: httpd<br/>  label: http</strong></span></pre><p id="65e6" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">并创建它:</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="1060" class="ms lm iq mr b gy nm nn l no np">$ kubectl apply -f config/samples/mygroup_v1beta1_genericdaemon.yaml</span><span id="fcd7" class="ms lm iq mr b gy nq nn l no np">$ kubectl get genericdaemon<br/>NAME                   AGE<br/><strong class="mr ir">genericdaemon-sample</strong>   5s</span><span id="9bc4" class="ms lm iq mr b gy nq nn l no np">$ kubectl get daemonset<br/>NAME                             <strong class="mr ir">READY</strong> [...]  NODE SELECTOR<br/>genericdaemon-sample-daemonset   <strong class="mr ir">0</strong>     [...]  <strong class="mr ir">daemon=http</strong></span><span id="0988" class="ms lm iq mr b gy nq nn l no np">$ kubectl describe genericdaemons genericdaemon-sample<br/>[...]<br/>Spec:<br/>  Image:  httpd<br/>  Label:  http<br/><strong class="mr ir">Status:<br/>  Count:  0</strong></span><span id="6aaa" class="ms lm iq mr b gy nq nn l no np">$ kubectl label nodes mynode1 daemon=http</span><span id="fae5" class="ms lm iq mr b gy nq nn l no np">$ kubectl get daemonset<br/>NAME                             <strong class="mr ir">READY</strong> [...]  NODE SELECTOR<br/>genericdaemon-sample-daemonset   <strong class="mr ir">1</strong>     [...]  <strong class="mr ir">daemon=http</strong></span><span id="af12" class="ms lm iq mr b gy nq nn l no np">$ kubectl describe genericdaemons genericdaemon-sample<br/>[...]<br/>Spec:<br/>  Image:  httpd<br/>  Label:  http<br/><strong class="mr ir">Status:<br/>  Count:  1</strong></span></pre><h2 id="f0e5" class="ms lm iq bd ln mt mu dn lr mv mw dp lv kf mx my lz kh mz na md kj nb nc mh nd bi translated">结论</h2><p id="bef6" class="pw-post-body-paragraph kw kx iq ka b kb mj ky kz kd mk la lb kf ml ld le kh mm lg lh kj mn lj lk kl ij bi translated">与前一篇文章中探讨的样本控制器相比，kubebuilder为我们提供了以下优势:</p><ul class=""><li id="80eb" class="jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">kubebuilder仍然使用基本的Kubernetes API:如果您已经使用过sample-controller或者您自己的控制器或操作符的实现，您将会认识到相同的模式，</li><li id="f3e7" class="jy jz iq ka b kb kr kd ks kf kt kh ku kj kv kl km kn ko kp bi translated">可以在几个版本中创建几个API，</li><li id="e70e" class="jy jz iq ka b kb kr kd ks kf kt kh ku kj kv kl km kn ko kp bi translated">有些测试是为我们编写的，</li><li id="5334" class="jy jz iq ka b kb kr kd ks kf kt kh ku kj kv kl km kn ko kp bi translated">角色和角色绑定是为我们编写的(您必须用一些+kubebuilder:rbac标记来修饰源代码)，</li><li id="1fb0" class="jy jz iq ka b kb kr kd ks kf kt kh ku kj kv kl km kn ko kp bi translated">docker映像的构建和部署由我们来处理。</li></ul><p id="2e56" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">接下来，<a class="ae kq" href="https://medium.com/p/40a029ea056" rel="noopener">探索运营商——SDK</a>。</p></div></div>    
</body>
</html>