<html>
<head>
<title>Angular patterns 2: how to write seriously reusable components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度模式2:如何编写真正可重用的组件</h1>
<blockquote>原文：<a href="https://itnext.io/angular-patterns-2-how-to-write-seriously-reusable-components-96be16568abc?source=collection_archive---------1-----------------------#2018-06-09">https://itnext.io/angular-patterns-2-how-to-write-seriously-reusable-components-96be16568abc?source=collection_archive---------1-----------------------#2018-06-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8459" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在现实生活项目中使用Angular的经历之后，我开发了自己的一套模式，用于在大型复杂的应用程序上组织可伸缩的Angular代码。我认为分享它们会很有用。</p><p id="65e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我试着把它们分成小文章，尽可能简洁明了。</p><p id="bb52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该系列的其他文章:</p><ul class=""><li id="519f" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/angular-patterns-1-modules-organisation-d3b2224ec4cf"> 1:模块组织</a></li><li id="8cac" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><a class="ae ku" href="https://medium.com/@adrdilauro/angular-patterns-3-flexible-and-scalable-design-of-complex-pages-c35f327ac50" rel="noopener"> 3:复杂页面的灵活可扩展设计</a></li></ul><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi la"><img src="../Images/cde381e283f13a4d1934f12fc6e58113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qZuSl1tncCpePR_VJOH5rQ.png"/></div></div></figure><p id="211f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我写了一个组件，我希望它是可重用的。</p><p id="98ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最常见的问题是，我所认为的“可重用”可能与客户或设计者的想法不一致:我可能认为组件是可重用的，但客户提出了一个意想不到的更改请求，这迫使我在从头重写一切或开始编写hacks之间做出选择。</p><p id="25f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然，如果客户要求一些非常不合逻辑的东西，没有什么可以让开发人员不去重新思考代码，但是我仍然希望一个可重用的组件在合理的范围内是可重用的。</p><blockquote class="lm ln lo"><p id="0a0a" class="jn jo lp jp b jq jr js jt ju jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj kk ij bi translated">我如何通过确保我的组件可以在最广泛的情况下被重用来减少我未来的麻烦？</p></blockquote><p id="30f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的观点是，这个问题与另一个非常重要的问题紧密相关，乍一看，这个问题似乎与变更检测更相关，而不是可重用性:</p><blockquote class="lm ln lo"><p id="9393" class="jn jo lp jp b jq jr js jt ju jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj kk ij bi translated">在什么情况下我的可重用组件的HTML会改变？</p></blockquote></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="5b1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从一个例子开始:你为相册中的图片列表开发了一个组件；每个图像都有一个“X”按钮来删除它。</p><p id="c005" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是实现组件最直观的方式:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="4283" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该组件通过删除相应的图像来响应用户的单击。它通过发出一个事件来通知它的父组件这个变化，这是一个很好的实践，因为它允许我们从根组件控制API，而不需要到处传播API调用。</p><p id="4ed7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原则上，这个实现没有什么特别的，它已经非常“可重用”，因为它非常简单。但是我想展示如何改变它以使它更加可重用，并且我将从问自己关于改变检测的问题开始:在什么情况下这个组件会改变？</p><ul class=""><li id="0cfb" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">当父节点更新图像列表时，它会改变</li><li id="c32e" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">当用户点击其中一个图像上的“X”时，它会改变</li></ul><p id="8bce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更一般地说，组件的状态取决于父组件和外部因素(用户)。因此，从变更检测的角度来看，不可能通过将这个组件从变更检测树中分离出来来优化它。</p><p id="885e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一般来说，在一个应用程序中，会有许多“哑”组件，它们在决定自己的内部状态时没有任何权力，再加上许多“交互式”组件，它们对用户的动作做出反应并改变它们的内部状态。第一个组件是可以通过使用<a class="ae ku" href="https://angular-2-training-book.rangle.io/handout/change-detection/change_detection_strategy_onpush.html" rel="noopener ugc nofollow" target="_blank">changeedetectionstrategy从变更检测中分离出来的组件。OnPush </a>。</p><p id="af61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的做法是尝试并最大化“哑”组件的数量，以便最大限度地优化变化检测，使我们的应用程序非常快。但是这与可重用性有什么关系呢？</p><p id="d831" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我看来，重用一个“愚蠢”的组件更容易，因为它只关注一件事情，而不“决定”任何事情。</p><blockquote class="lm ln lo"><p id="f75b" class="jn jo lp jp b jq jr js jt ju jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj kk ij bi translated">一个哑组件只不过是你的应用程序中的一块砖，你可以从外面拿走它，控制它的外观，然后毫不费力地把它放在你喜欢的任何地方。</p></blockquote><p id="1440" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们试着把上面的组件变成一个“哑”组件。这就像注释掉一行代码一样简单</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="4def" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我删除了不必要的东西，比如导入和模板，把重点放在我注释的那一行:第12行。</p><p id="2086" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">组件仍然会通知它的父组件用户的点击，但是它实际上不会删除任何东西。父组件有责任删除元素。</p><p id="b54b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们的组件只依赖于父组件的状态，而不依赖于用户。它可以通过使用OnPush策略的变化检测来分离(假设<a class="ae ku" href="https://angular-2-training-book.rangle.io/handout/change-detection/enforcing_immutability.html" rel="noopener ugc nofollow" target="_blank">我们将输入数组标记为“不可变”</a>)。<strong class="jp ir">而且更容易重复使用。</strong></p><p id="d19b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们在组件的父组件中实现了图像删除，如下所示</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="6f48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设设计者希望在其他页面中实现相同的列表，但在这种情况下，他希望您在确认删除之前弹出一个警告:由于组件“images-list”并不决定其内部状态，并且它完全由父组件控制，您可以立即重用它，而无需更改其中的任何一行。</p><p id="62dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在不同的上下文中调用相同的组件看起来是这样的:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="1340" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们想象一下，设计者变得疯狂，决定在第三种情况下，他希望应用程序删除两张图像，而不是一张，以惩罚用户想要删除的东西。</p><p id="a9bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好消息是，我们不必跟着他一起发疯，因为我们仍然可以重用原始组件，而不改变其中的任何内容:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="f3dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们实现了我们的目标:开发尽可能多的哑组件，除了在变更检测优化方面的明显好处之外，我们实际上可以在我们最初设计它们时无法想象的极端环境中重用它们。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="aef5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">组件仅依赖父级=组件可从外部控制=组件可重用</strong></p><p id="5088" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想强调上述类比的另一个方面。</p><p id="0ae9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们看到，如果一个组件只依赖于它的父组件，那么就可以通过实现OnPush策略将其从变更检测中分离出来。但相反的含义并不适用，因为有些组件并不完全依赖于它们的父组件，但您仍然可以实现OnPush。</p><p id="a783" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原因是，如果输入不变，OnPush策略不会完全阻止更改检测:在某些特殊情况下，例如，当用户单击组件内部的元素时，即使OnPush已打开并且外部绑定中没有更改，也会触发更改检测。</p><p id="8e1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们从可重用性的角度来看这个相同的概念，我们可以说，仍然可以从组件本身控制某些特定的内部更新，而不影响父级对组件的控制(即其可重用性)。</p><p id="1fc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，让我们设想扩展前面示例中的“images-list”组件，并添加一个拖放功能:当用户将鼠标放在一个图像上，并在列表中上下拖动它时，从外部控制拖动的图像的位置将是疯狂的。该组件需要控制类似这样的细节。</p><p id="8a95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以委托给父代的是当用户释放并丢弃图像时会发生什么:在这个阶段，组件可以发送一个事件，并让父代决定它的命运。就像前面的例子一样，我可以想象，当用户将一个图像放在与其初始位置不同的位置时，会有几种不同的反应:如果位置有效，图像就可以停留在原来的位置；如果该位置无效，则可以回到其原始位置；或者它可以改变颜色、发送警报等。</p><p id="325b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们来看看“在列表中拖动并移动图像”与“将图像放在某个位置”这两种事件之间的区别</p><p id="2dc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">拖动图像</strong></p><ul class=""><li id="e877" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">即使变更检测通过OnPush分离，我们仍然会看到div移动，因为Angular会强制变更检测为内部事件激发，如下所示</li><li id="67de" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">从外部控制div的移动是没有意义的，因为它是内部的东西，很难控制；它更类似于CSS盘旋状态</li></ul><p id="1dcb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">放下形象</strong></p><ul class=""><li id="0044" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">当用户删除图像时，除非父组件更改了外部绑定，否则相应的div只是停止；从现在开始，组件将不会改变，除非父组件更新绑定</li><li id="372e" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">当用户丢弃项目时，从外部决定做什么是有意义的，这有几个用例</li></ul><p id="3659" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是什么意思？</p><p id="1bc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当一个组件实现较小的内部事件时，一方面Angular足够聪明，可以灵活地触发变化检测(尽管有OnPush策略)，另一方面该组件仍然可以很好地重用(尽管它确实可以控制一些事件)。</p><blockquote class="lm ln lo"><p id="ab2c" class="jn jo lp jp b jq jr js jt ju jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj kk ij bi translated">一般来说，为了提高性能和可重用性，您应该尝试将组件的呈现从其行为中分离出来，并将后者委托给父组件。您可以委托给父组件的东西的数量取决于每个特定的情况，但是您可以分离的越多，组件的可重用性就越高。</p></blockquote></div></div>    
</body>
</html>