<html>
<head>
<title>How to Write Bug-Free Goroutines in Go (Golang)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Go (Golang)中编写无Bug的Goroutines</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-write-bug-free-goroutines-in-go-golang-59042b1b63fb?source=collection_archive---------1-----------------------#2020-11-09">https://itnext.io/how-to-write-bug-free-goroutines-in-go-golang-59042b1b63fb?source=collection_archive---------1-----------------------#2020-11-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d6e5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以下是可预测、可靠且无错误的Go代码的并发性最佳实践。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0e51026b7aab381d1992e124746567c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oL0hjMQxldCYMKRb0a3yhg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">一只不遵守规则的地鼠</figcaption></figure><h1 id="702c" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">Go中的并发性</h1><p id="e0a4" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">围棋因其并发性而广为人知并受到<strong class="ls iu">的喜爱。go运行时管理称为goroutines的轻量级线程。Goroutines编写起来既快又简单。</strong></p><p id="1268" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">您只需在另一个线程中，在您想要异步执行的函数前键入<code class="fe mr ms mt mu b">go</code>。</p><p id="5070" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><strong class="ls iu">听起来够简单吧？</strong></p><p id="8efc" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">Goroutines是Go编写异步代码的方式。</p><p id="cfcb" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">理解goroutine以及更一般的并发性是如何工作的很重要。Go提供了管理goroutines的方法，使它们在复杂的程序中更易于管理和预测。</p><blockquote class="mv"><p id="037c" class="mw mx it bd my mz na nb nc nd ne ml dk translated">因为goroutines太好用了，所以也太容易误用了。</p></blockquote><h1 id="a2b8" class="ky kz it bd la lb lc ld le lf lg lh li jz nf ka lk kc ng kd lm kf nh kg lo lp bi translated">1)不要对异步例程中的执行顺序做出假设</h1><p id="cc22" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在Go中调度并发任务时，记住异步任务的不可预测性很重要。</p><p id="e19e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">混合异步和同步计算是可以做到的，但前提是同步任务不对异步任务做任何假设。</p><p id="d6db" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">初学者经常犯的错误是创建一个goroutine，然后根据goroutine的结果继续执行同步任务。例如，如果goroutine要写入其作用域之外的变量，然后在同步任务中使用该变量。</p><h2 id="aac8" class="ni kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">假设执行顺序</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">假设goroutines的执行顺序</figcaption></figure><p id="4a52" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><strong class="ls iu">这种模式会导致不可预测的行为</strong>。它引入了依赖于我们无法控制的因素的代码；与go运行时相关的因素，更具体地说，是它如何管理goroutines。</p><blockquote class="nw nx ny"><p id="90c5" class="lq lr nz ls b lt mm ju lv lw mn jx ly oa mo mb mc ob mp mf mg oc mq mj mk ml im bi translated">像这样编写代码意味着您假设goroutine将在需要结果之前完成它的任务。</p></blockquote><p id="c3dc" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><strong class="ls iu">首先</strong>，如果没有某种管理技术(我们将会讨论)，交错异步和同步代码的成功将取决于CPU的可用性。</p><p id="db4c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这意味着，如果有CPU密集型进程与goroutines同时运行，那么执行时间会有所不同。</p><p id="c24b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><strong class="ls iu">其次</strong>，不同的编译器会对goroutines进行不同的调度。因此，最好不要假设goroutine会在同步任务中完成。</p><p id="8f20" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><strong class="ls iu">你能做些什么来确保goroutine已经完成？</strong></p><blockquote class="nw nx ny"><p id="8362" class="lq lr nz ls b lt mm ju lv lw mn jx ly oa mo mb mc ob mp mf mg oc mq mj mk ml im bi translated">使用频道。</p></blockquote><h2 id="9b58" class="ni kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">使用通道通知异步任务完成</h2><p id="90d8" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">通道应该用于接收来自异步任务(如goroutines)的值。</p><p id="05a5" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">如果你想防止阻塞进一步的执行，直到最终从通道中读取一个值来释放它，通道可以被<strong class="ls iu">缓冲</strong>。</p><p id="653f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">如果您想要<em class="nz"> 1进1出</em>行为，通道可以是<strong class="ls iu">非缓冲</strong>。</p><p id="7e46" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在这个例子中，使用通道，我们可以确保主任务一直等到异步任务完成。当goroutine完成其工作时，它将通过通道<code class="fe mr ms mt mu b">done</code>发送一个值，该值将在对<code class="fe mr ms mt mu b">numbers</code>数组进行操作之前被读取。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">等待goroutine结束频道</figcaption></figure><p id="9b7e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">虽然这是一个虚构的例子，但是您可以看到它的用处:当主线程与goroutine并行处理复杂的工作时。这两项任务可以同时完成，没有出现<code class="fe mr ms mt mu b">panic</code>的可能。</p><h1 id="a9c7" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">2)避免跨并发线程访问可变数据</h1><p id="6f24" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">跨多个goroutines访问可变数据是在程序中引入数据竞争的好方法。</p><p id="e6ae" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">数据竞争是指两个或多个线程(或上下文中的go routine)<strong class="ls iu">同时访问相同的内存位置</strong>。</p><p id="b7df" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这意味着跨线程访问同一个变量会导致不可预测的值。如果两个进程同时访问同一个变量，有两种可能:</p><ul class=""><li id="502b" class="od oe it ls b lt mm lw mn lz of md og mh oh ml oi oj ok ol bi translated">两个线程的值相同(<strong class="ls iu">不正确</strong>)。</li><li id="52ad" class="od oe it ls b lt om lw on lz oo md op mh oq ml oi oj ok ol bi translated">对于较慢/较晚的线程，该值是不同的。(<strong class="ls iu">纠正</strong>)</li></ul><p id="b82e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">如果较慢/较晚的线程读取已被较快/较早的线程修改的更新值，那么它将对该更新值进行操作。<strong class="ls iu">这是预期的行为。</strong></p><p id="8b96" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">否则，<strong class="ls iu">如在数据竞争</strong>中所见，两个线程将产生相同的值，因为它们都将对未改变的值进行操作。</p><h2 id="e8f0" class="ni kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">1000种可能的数据竞争</h2><p id="aea7" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在这个例子中，我们使用<code class="fe mr ms mt mu b">sync.WaitGroup</code>来保持我们的程序运行，直到所有的goroutine都完成，但是我们不控制对每个go routine中变量的访问。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="4b53" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><strong class="ls iu">根据发生的数据竞争数量，该代码可以打印0-1000</strong>之间的任何数字。</p><p id="d518" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">其工作方式是，两个线程将分别对同一个变量执行2次操作，总共将有2次读取+ 2次写入。</p><blockquote class="nw nx ny"><p id="a6c9" class="lq lr nz ls b lt mm ju lv lw mn jx ly oa mo mb mc ob mp mf mg oc mq mj mk ml im bi translated">在两个线程产生相同值的情况下，两(2)次读取都必须发生在对变量的任何写入之前。</p></blockquote><h2 id="77f0" class="ni kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">使用互斥体在不同的例程间共享内存</h2><p id="08cb" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">为了防止goroutines中的数据竞争，我们需要同步对共享内存的访问。我们可以使用互斥来实现这一点。互斥体将确保我们不会同时读取或写入相同的值。</p><p id="311a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">它本质上是<strong class="ls iu">暂时锁定对变量的访问</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用同步。互斥锁暂时保护对变量的访问</figcaption></figure><p id="7c86" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">就这么简单。</p><p id="bd28" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><strong class="ls iu">该代码将始终产生1000 </strong>,因为对同一变量的每个后续操作都将基于更新后的值。</p><h1 id="7097" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">3)不要编写应该同步的异步任务</h1><p id="96f6" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Goroutines通常被认为是后台任务。它们被看作是可以与主程序同时运行的小任务，通过一个goroutine将它委托给另一个线程。</p><p id="1c31" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">当学习Go时，你倾向于考虑使用goroutines来最小化阻塞操作或使我们的程序更高效。</p><p id="a335" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">但是由于对goroutines的看法过于简单，<strong class="ls iu">很容易养成把所有东西都做成goroutine </strong>“以防万一”的习惯。</p><p id="6d52" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">如果某些任务本质上是同步的，这可能会导致问题，但是你已经异步地使用它们了。</p><h2 id="8be8" class="ni kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">不是所有的事情都应该是完美的</h2><p id="a60d" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">有些任务需要<strong class="ls iu">命令</strong>。在许多过程中，下一项任务取决于前一项任务的结果。这些连续的任务会使你的程序出错，并且不可避免地需要使这些区域更加同步。</p><p id="a0f5" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">因此，在有些情况下，您还不如忘记goroutine，首先让它保持同步。</p><h2 id="c4e5" class="ni kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">无限循环浪费CPU</h2><p id="84d5" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在这个虚构的例子中，我们有一个程序，它将所有事情委托给goroutines，并使用for循环来保持程序运行。</p><p id="acd5" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这是一个<strong class="ls iu">如何不</strong>控制围棋程序流程的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="bcb7" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">最好让事情简单化。你可以通过用主<strong class="ls iu">线程、<strong class="ls iu">线程和额外的</strong>线程来思考你的程序，来防止这种不良行为。您可以让事情以同步的方式在主线程上运行，但是如果需要的话，可以通过goroutines将任务委托给另一个线程。</strong></p><p id="fe52" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">还有更好的方法可以控制程序的流程，比如通过<a class="ae or" href="https://gobyexample.com/waitgroups" rel="noopener ugc nofollow" target="_blank"><strong class="ls iu">wait groups</strong></a><strong class="ls iu">或者</strong> <a class="ae or" href="https://gobyexample.com/channels" rel="noopener ugc nofollow" target="_blank"> <strong class="ls iu">通道</strong> </a> <strong class="ls iu">。</strong></p><h2 id="4f37" class="ni kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">控制WaitGroup的流</h2><p id="e2ee" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">为了避免浪费宝贵的CPU资源，您可以使用WaitGroup向运行时表明，您正在等待<code class="fe mr ms mt mu b">n</code>任务的完成，然后程序才能退出。这不会让CPU无限循环。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用WaitGroup控制流</figcaption></figure><p id="be6b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">首先，您需要提供等待完成的任务数量作为<code class="fe mr ms mt mu b">wg.Add()</code>函数的参数。</p><p id="d86f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">放置<code class="fe mr ms mt mu b">wg.Wait()</code>很重要。<strong class="ls iu">这是程序中执行将暂停</strong>的地方，等待所有任务完成。</p><p id="51bf" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">一旦任务<strong class="ls iu">完成</strong>，你用<code class="fe mr ms mt mu b">wg.Done()</code>让程序知道。</p><h1 id="7edd" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">4)不要让goroutines挂着</h1><p id="7c88" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">确保处理掉不再使用的食物。持续运行的Goroutines将会阻塞并浪费宝贵的CPU资源。</p><p id="ca97" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">如果一个goroutine试图发送一个值给一个没有任何阅读器等待接收该值的通道，就会发生这种情况<strong class="ls iu">。这实质上意味着通道将永远被阻塞。</strong></p><h2 id="bce6" class="ni kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">9悬挂式Goroutines</h2><p id="9e85" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在本例中，通道仅读取<strong class="ls iu">一次</strong>。这意味着9个goroutines正在等待通过通道发送值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">通过阻塞通道悬挂goroutines</figcaption></figure><p id="2034" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">为了避免这种情况，请确保通过处置不再需要的goroutines来释放CPU。</p><h2 id="fc2b" class="ni kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">使频道缓冲</h2><p id="958c" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">使通道缓冲意味着您为通道提供了存储额外值的空间。</p><p id="8e10" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">对于当前的例子，这意味着所有的goroutines都将成功执行，并且不会阻塞。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用缓冲通道防止程序挂起</figcaption></figure><h2 id="e2e2" class="ni kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">不要在不知道什么时候停止的情况下开始一场战争</h2><p id="782a" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在不知道何时停止的情况下启动goroutine将导致这种行为，即goroutine被阻塞或浪费CPU资源。</p><p id="c722" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">你应该知道什么时候goroutine会停止，什么时候不再需要它。</p><p id="b2b3" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><strong class="ls iu">你可以通过</strong> <code class="fe mr ms mt mu b"><strong class="ls iu">select</strong></code> <strong class="ls iu">语句和</strong>通道来实现</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用通道选择作为退出信号</figcaption></figure><p id="ed0e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这本质上是一个带有退出条件的异步for循环。</p><p id="b786" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">重要的逻辑将在<code class="fe mr ms mt mu b">default</code>条件下写入。</p><blockquote class="nw nx ny"><p id="e30e" class="lq lr nz ls b lt mm ju lv lw mn jx ly oa mo mb mc ob mp mf mg oc mq mj mk ml im bi translated">当一个值被发送到<code class="fe mr ms mt mu b">done</code>通道时，循环将停止，如<code class="fe mr ms mt mu b">done &lt;- true</code>所示。这将意味着通道读取<code class="fe mr ms mt mu b">&lt;-done</code>成功并返回。</p></blockquote><h1 id="6903" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">Go中的并发性非常强大</h1><p id="0b1b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">但它也可能是失眠、冒名顶替综合症和脱发的原因。</p><p id="c98b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">了解何时以及如何使用Goroutines将有助于防止这种情况。</p><h2 id="001f" class="ni kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">感谢阅读！有任何问题，请在评论中告诉我。</h2></div></div>    
</body>
</html>