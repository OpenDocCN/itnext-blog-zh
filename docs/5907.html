<html>
<head>
<title>Why must a ValueTask only be awaited once?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么ValueTask只能等待一次？</h1>
<blockquote>原文：<a href="https://itnext.io/why-can-a-valuetask-only-be-awaited-once-31169b324fa4?source=collection_archive---------0-----------------------#2021-06-27">https://itnext.io/why-can-a-valuetask-only-be-awaited-once-31169b324fa4?source=collection_archive---------0-----------------------#2021-06-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/f2afb8045e3166d14f9c7a32c8e8a479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kJ3QWHaBrXtV1e6y0IDJiQ.jpeg"/></div></div></figure><div class=""/><p id="8cc0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你一直在关注。你可能也听说过包含了<strong class="kd jf"> ValueTask &lt; T &gt; </strong>。简而言之:一个<em class="kz"> ValueTask </em>本质上是一个可区分的联合，它既能表示同步结果，也能在必要时表示<em class="kz"> Task </em>。这对于以下情况很有用:在初始化缓存值时，您的异步方法可能只是异步一次，但对于所有其他调用，它会同步完成，因为它们只读取缓存。</p><p id="40af" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想了解更多，https://dev blogs . Microsoft . com/dotnet/understanding-the-whys-whys-and-whes-of-value task/是对创建者本身的一个很好的总结。</p><p id="a06a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，使用<em class="kz"> ValueTask </em>会导致一些意想不到的行为。首先，一个<em class="kz">值任务</em>不能被等待两次。遗憾的是，现有的文档只是以一种非常肤浅的方式进行推理，所以我继续深入研究，因为我不满足于被告知“不要这样做”，而是想了解“为什么”。</p><p id="6da1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我将继续尝试概述整个流程，因此很明显这是一个需求。我还假设您了解状态机构造，否则，请随意阅读这里的内容:<a class="ae la" href="https://stefansch.medium.com/what-the-async-keyword-actually-does-bb10d54ce31c" rel="noopener">https://Stefan sch . medium . com/what-the-async-keyword-actually-does-bb10 d 54 ce 31 c</a></p><h1 id="229a" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">值任务流</strong></h1><p id="aa50" class="pw-post-body-paragraph kb kc je kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">好吧，我们开始吧。首先，请注意<em class="kz"> ValueTasks </em>的池行为是根据以下条件启用的:</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi me"><img src="../Images/632087dea6151e00bd8e8f71bebe6af1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V7-jYA71faIWe-mNqfvedA.png"/></div></div></figure><p id="c7f9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是我们想要使用的代码:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="64e2" class="mo lc je mk b gy mp mq l mr ms">public async Task Main()<br/>{<br/>    var task = GetValue();<br/>    Console.WriteLine(await task);<br/>    Console.WriteLine(await task);<br/>}</span><span id="7b1a" class="mo lc je mk b gy mt mq l mr ms">int? cachedValue = null;</span><span id="0078" class="mo lc je mk b gy mt mq l mr ms">private async ValueTask&lt;int&gt; GetValue()<br/>{<br/>     if (cachedValue is null)<br/>     {<br/>         await Task.Delay(500);<br/>         cachedValue = 5;<br/>     }<br/>      return cachedValue.Value;<br/>}</span></pre><p id="f76b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个很常见的使用<em class="kz"> ValueTask </em>的例子，我们还添加了等待它两次的反模式。运行这段代码将在第二个<em class="kz">等待</em>时抛出<strong class="kd jf">InvalidOperationException</strong>，如果启用了池。简单解释一下:<em class="kz"> ValueTask </em>使用了一个可重复使用的<em class="kz">ivaluetaksource</em>，它基本上一次只对一次消费有效，之后可能会被另一个<em class="kz"> ValueTask </em>重复使用。如果你想知道为什么在常规的<em class="kz">任务</em>之上添加了<em class="kz">值任务</em>，唯一的原因是通过尽可能减少分配来提高性能和减少内存消耗。</p><p id="d477" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么，到底是什么让我们不再等待第二次呢？让我们开始吧:</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mu"><img src="../Images/c165e1b13cd596ae17054d4c5def9cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6kcVzuIuzQwZ95Joda4_hw.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">编译器生成了值任务状态机</figcaption></figure><p id="66da" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们看一看我们想要研究的<em class="kz"> GetValue() </em>方法的编译器生成的代码，我们实际上可以看到编译器创建了一个<em class="kz">AsyncValueTaskMethodBuilder</em>，并调用了<em class="kz">。Start() </em>，传递为<em class="kz"> GetValue </em>方法生成的异步状态机。</p><p id="94e1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">。Start() </em>方法在内部做一些不太有趣的事情，但重要的是，它通过调用<em class="kz">来启动状态机。MoveNext() </em>。</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mz"><img src="../Images/e0e1126cad6505519de8e1a20dca3fd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KHF6GMExncQsFPZlg0yYuw.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">编译器生成的状态机的MoveNext()方法</figcaption></figure><p id="1a91" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们用<em class="kz"> state == -1 </em>启动状态机。由于<em class="kz"> cachedValue </em>前面没有数据，并且由于延迟，awaiter没有完成，所以我们进入标记块。重要的部分是对<em class="kz"> AwaitUnsafeOnCompleted </em>的调用。</p><p id="db9f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过。Net源码，这是值得注意的调用:</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi na"><img src="../Images/3361d6912845e73a25f59b8c5ae9caa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zrt_10Mi1lSS9elvThl91A.png"/></div></div></figure><p id="da62" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果启用了池，我们获取我们状态机的<em class="kz"> m_task </em>字段，并将其转换为一个<em class="kz"> StateMachineBox </em>。一个<em class="kz"> StateMachineBox </em>是一个a类型，它包装并转发对底层<em class="kz"> IValueTaskSource的调用。它本质上是任何其他<em class="kz">ivaluetaksource</em>的包装器，确保默认行为，而不管底层的源是什么。</em></p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="c991" class="mo lc je mk b gy mp mq l mr ms">internal abstract class StateMachineBox : IValueTaskSource&lt;TResult&gt;, IValueTaskSource</span></pre><p id="ec68" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">简而言之，在<em class="kz"> AwaitUnsafeOnCompleted </em>方法中，通过所有<em class="kz"> ref </em>参数，我们在这里结束:</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nb"><img src="../Images/ffd0b0412991da323c34cf0fe774fa27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hIn--LsJwVpzrFECglhjIg.png"/></div></div></figure><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nc"><img src="../Images/1107429cad89554863240ae70fc45293.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YJy-upWe8EdPFK_JKTU85Q.png"/></div></div></figure><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/810ae81459fd66aef67f798f0bfb7a67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*nUmGbfCMgSlG5N6TrsmyiA.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">StateMachineBox以及基础IValueTaskSource缓存</figcaption></figure><p id="d43b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个非常重要的部分，因为这是我们实际分配<em class="kz">ivaluetaksource</em>的地方，稍后由<em class="kz"> ValueTask </em>使用！理解这里发生的一切并不重要，但重要的是要认识到我们获取的资源是<strong class="kd jf">缓存和可重用的</strong>。</p><p id="fd1d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那是很难接受的。让我们在状态机的<em class="kz"> MoveNext() </em>方法中再加几层。我们现在搬出了<em class="kz"> AwaitUnsafeOnCompleted </em>方法，而<em class="kz">将</em>从<em class="kz">中返回。【Start()【方法..</em></p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mu"><img src="../Images/c165e1b13cd596ae17054d4c5def9cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6kcVzuIuzQwZ95Joda4_hw.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">编译器生成了值任务状态机</figcaption></figure><p id="84e6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，唯一剩下要做的事情，就是抓住<em class="kz">。状态机的任务</em>属性。由于我们没有同步完成，下面的代码将会执行:</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/3bec3801456e80e4305dec0633631f58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*IuJY85N6ZtIkotdD8T9VMA.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">价值任务的生成</figcaption></figure><p id="0d08" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们又可以看到<em class="kz"> m_task </em>对象了！由于我们之前经历了初始化它的所有麻烦，它现在不是空的，现在将被转发到实际的<em class="kz"> ValueTask </em>。特别注意第二个<em class="kz">盒。版本</em>参数！</p><p id="e02f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">。Version </em>属性是<em class="kz">ivaluetaksource</em>类型的一部分，在以后会很重要。它本质上是一个小令牌，证明你是<em class="kz">ivaluetaksource</em>的当前“所有者”。</p><p id="11f9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们已经完成了对<em class="kz"> GetValue() </em>方法的分析。现在让我们来看看我们的<em class="kz"> Main() </em>方法生成的状态机，它执行无效的消费模式。</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nf"><img src="../Images/866f4264a7acb3a11176531e3d7e9cbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sk72HCQVGGmwa1QnVZKFyg.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">主方法的状态机</figcaption></figure><p id="bdfb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这一开始很令人困惑！让我们一步一步地解决它。</p><ol class=""><li id="6901" class="ng nh je kd b ke kf ki kj km ni kq nj ku nk ky nl nm nn no bi translated">我们再次从一个状态<em class="kz"> -1 </em>开始。<em class="kz"> GetValue() </em>被调用，我们获取在该方法中生成的<em class="kz"> ValueTask </em>。</li><li id="4a8e" class="ng nh je kd b ke np ki nq km nr kq ns ku nt ky nl nm nn no bi translated">我们抓取我们的<em class="kz"> ValueTask </em>的<em class="kz"> ValueTaskAwaiter </em>，由于我们还没有完成，执行被推迟。<em class="kz"> ValueTaskAwaiter </em>通过<em class="kz"> ValueTask </em>上的常规<em class="kz"> GetAwaiter() </em>方法公开。</li><li id="b28a" class="ng nh je kd b ke np ki nq km nr kq ns ku nt ky nl nm nn no bi translated">在重入时，状态机到达对<em class="kz">的调用。GetResult() </em>在现在完成的waiter上。</li></ol><p id="d912" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是我们要再次休息的地方，再往下一层看看发生了什么。<em class="kz"> ValueTaskAwaiter </em>和常规的<em class="kz">任务</em>waiter一样，在完成时也会调用其<em class="kz"> OnCompleted </em>方法。(注意:它还实现了<em class="kz">ICriticalNotifyCompletion</em>接口)</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nu"><img src="../Images/4e60f96394a5e85e4014ab5424dfe9b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FeWg7DiGG8jBULPQ6USJ0A.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">ValueTaskAwaiter的on完成方法</figcaption></figure><p id="56c5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到，在这个方法内部，我们也调用<em class="kz">。OnCompleted() </em>上的<em class="kz"> obj </em>字段，这正是我们传递给ValueTask生成的<em class="kz">ivaluetaksource</em>。后面的具体实现是<a class="ae la" href="https://source.dot.net/Microsoft.Bcl.AsyncInterfaces/R/2ea1d69c971646b9.html" rel="noopener ugc nofollow" target="_blank"><em class="kz">ManualResetValueTaskSourceCore</em></a><em class="kz">的一个实例。</em>对的呼唤。<em class="kz"> OnCompleted() </em>隐式执行以下检查:</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/d8db9772bac30db8397cb9eefca7feda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*_gZVJxUUxLQqtH7gGOUmnA.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">ManualResetValueTaskSourceCore的ValidateToken方法</figcaption></figure><p id="49ab" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">太好了！我们刚刚解决了另一个谜团！这就是第二个参数，我们传递给我们的<em class="kz"> ValueTask </em>的令牌的用途。它基本上是一个<em class="kz">短</em>令牌，确认您是池化<em class="kz">ivaluetaksource</em>的当前所有者。如果令牌和源使用的版本不匹配，将引发InvalidOperationException。就像发生在我们身上的一样，记得吗？</p><p id="cc8f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们越来越接近搞清楚一切了！现在我们知道了源头在哪里，以及最终是什么导致了这个问题。我们还知道源的所有权令牌。</p><p id="5591" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们只需要拼图的另一部分——谁负责更改源代码的版本，导致我们的第二次调用失败？</p><p id="2f08" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回到步骤3)在我们的<em class="kz"> Main() </em>状态机内。<em class="kz"> GetResult() </em>调用将通过多层，再次在<em class="kz">ivaluetaksource-Box</em>中结束，其中存储了我们的<em class="kz"> ValueTask </em>结果。这个调用显然将返回整数<em class="kz">的值</em>，但是它也调用了<em class="kz"> ReturnOrDropBox()。</em>现在我们就快成功了。让我们来看看这个方法是做什么的！</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nw"><img src="../Images/d9bf17374d5a6329933ab8bd01396199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZegWULuj3EJ2dfXCA3UJjg.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">我们的StateMachineBox的ReturnOrDropBox方法</figcaption></figure><p id="db9c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这听起来很可疑。让我们看看这个调用在这个盒子装饰的<em class="kz">ManualResetValueTaskSourceCore</em>中做了什么:</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/0af5ff8eea7d3117b98187f2e8641ae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*IF4A0L0hGfgx8mLT45FmzA.png"/></div></figure><p id="16db" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">完美！这就是我们一直在寻找的缺失部分！版本增加了，源代码被清理了供下次使用。还记得我说过源代码是以池的方式工作的吗？这是它能够做到这一点的原因。</p><p id="9148" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，故事的其余部分就很容易理解了。在第4点中，我们已经再次检查了状态机，在同一个<em class="kz"> ValueTask </em>上获得了另一个awaiter，现在我们遇到了异常。</p><p id="0919" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，这非常有意义。由于我们正在重用<em class="kz"> ValueTask </em>，我们仍然拥有旧的令牌集。然而，由于第一次获取结果时，我们增加了源代码的版本，现在我们有了一个不匹配。</p><p id="8f95" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是为什么你不想等待<em class="kz">一个<em class="kz">价值任务</em>两次的原因！</em></p><h1 id="3ca6" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="ec97" class="pw-post-body-paragraph kb kc je kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">这是大量的信息——您可以自己随意探索source.dot.net知识库，有了我刚才提供的信息，事情就会变得清楚了！</p><p id="15ad" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不等待两次的整个概念都是<em class="kz"> ValueTask </em>目标的结果，即尽可能节省分配。因为池行为也是这样做的，所以它与多个等待直接冲突，因为底层缓存的<em class="kz"> ValueTaskSource </em>可能已经被重用了，正如我们已经看到的。</p></div></div>    
</body>
</html>