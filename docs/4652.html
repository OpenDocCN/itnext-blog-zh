<html>
<head>
<title>Creating a streaming data pipeline with Kafka Streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kafka流创建流数据管道</h1>
<blockquote>原文：<a href="https://itnext.io/creating-a-streaming-data-pipeline-with-kafka-streams-898fb352a7b7?source=collection_archive---------2-----------------------#2020-08-14">https://itnext.io/creating-a-streaming-data-pipeline-with-kafka-streams-898fb352a7b7?source=collection_archive---------2-----------------------#2020-08-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7c9d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建基于规则的流数据拓扑</h2></div><h1 id="6dec" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">什么是流式拓扑？</h1><p id="e01a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">拓扑是由流(边)连接的流处理器(节点)的<a class="ae lw" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" rel="noopener ugc nofollow" target="_blank">有向无环图(DAG) </a>。DAG的几个关键特征是它是有限的，并且不包含任何环。创建流拓扑允许数据处理器成为小型、集中的微服务，可以轻松分布和扩展，并可以并行执行工作。</p><h1 id="ce4a" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">为什么要用卡夫卡流？</h1><p id="d5b3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><a class="ae lw" href="https://kafka.apache.org/documentation/streams/" rel="noopener ugc nofollow" target="_blank"> Kafka Streams </a>是由<a class="ae lw" href="https://www.confluent.io/" rel="noopener ugc nofollow" target="_blank"> Confluent </a>开发的API，用于构建使用Kafka主题的流媒体应用程序，分析、转换或丰富输入数据，然后将结果发送到另一个Kafka主题。它允许您以分布式和容错的方式用简洁的代码来实现这一点。Kafka Streams将处理器拓扑定义为流处理代码的逻辑抽象。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi lx"><img src="../Images/c5c2fdac9c9b2954055c823751955b7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*snsbFuY8OzrEeaQ7p8Ekgg.jpeg"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">一个简单的卡夫卡流拓扑</figcaption></figure><h2 id="96ff" class="mn kj it bd kk mo mp dn ko mq mr dp ks lj ms mt ku ln mu mv kw lr mw mx ky my bi translated">卡夫卡流的关键概念</h2><ul class=""><li id="2063" class="mz na it lc b ld le lg lh lj nb ln nc lr nd lv ne nf ng nh bi translated">一个<strong class="lc iu">流</strong>是一个无界的、持续更新的数据集，由一个有序的、可重复的、容错的键值对序列组成。</li><li id="9888" class="mz na it lc b ld ni lg nj lj nk ln nl lr nm lv ne nf ng nh bi translated"><strong class="lc iu">流处理器</strong>是拓扑中的一个节点，它从拓扑中的上游处理器一次接收一个输入记录，对其应用操作，并且可以选择性地向其下游处理器产生一个或多个输出记录。</li><li id="09b7" class="mz na it lc b ld ni lg nj lj nk ln nl lr nm lv ne nf ng nh bi translated"><strong class="lc iu">源处理器</strong>是没有任何上游处理器的处理器。</li><li id="387d" class="mz na it lc b ld ni lg nj lj nk ln nl lr nm lv ne nf ng nh bi translated"><strong class="lc iu">接收处理器</strong>是没有任何下游处理器的处理器。</li></ul></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="da8e" class="ki kj it bd kk kl nu kn ko kp nv kr ks jz nw ka ku kc nx kd kw kf ny kg ky kz bi translated">入门指南</h1><p id="bc48" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于本教程，我将使用Kafka和Kafka流的Java APIs。我将假设对使用<a class="ae lw" href="https://maven.apache.org/guides/getting-started/maven-in-five-minutes.html" rel="noopener ugc nofollow" target="_blank"> Maven </a>构建Java项目有一个基本的了解，对Kafka有一个初步的熟悉，并且已经设置了一个Kafka实例。<a class="ae lw" href="https://lenses.io/" rel="noopener ugc nofollow" target="_blank">lens . io</a>提供了一个快速简单的容器化解决方案来设置Kafka实例<a class="ae lw" href="https://github.com/lensesio/fast-data-dev" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="1ed3" class="pw-post-body-paragraph la lb it lc b ld nz ju lf lg oa jx li lj ob ll lm ln oc lp lq lr od lt lu lv im bi translated">首先，我们需要添加<a class="ae lw" href="https://mvnrepository.com/artifact/org.apache.kafka/kafka-clients" rel="noopener ugc nofollow" target="_blank"> kafka-clients </a>和<a class="ae lw" href="https://mvnrepository.com/artifact/org.apache.kafka/kafka-streams" rel="noopener ugc nofollow" target="_blank"> kafka-streams </a>作为项目pom.xml的依赖项:</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="caea" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">构建流式拓扑</h1><p id="f3ce" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">流式拓扑需要一个或多个输入、中间和输出主题。创造新的卡夫卡主题的信息可以在<a class="ae lw" href="https://kafka.apache.org/quickstart#quickstart_createtopic" rel="noopener ugc nofollow" target="_blank">这里</a>找到。一旦我们创建了必要的主题，我们就可以创建一个流拓扑。下面是一个为输入主题创建拓扑的例子，其中值被序列化为JSON(由<a class="ae lw" href="https://github.com/google/gson" rel="noopener ugc nofollow" target="_blank"> GSON </a>序列化/反序列化)。</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">流式拓扑的简单示例</figcaption></figure><p id="7ae6" class="pw-post-body-paragraph la lb it lc b ld nz ju lf lg oa jx li lj ob ll lm ln oc lp lq lr od lt lu lv im bi translated">上面的例子是一个非常简单的流拓扑，但是在这一点上它并没有真正做什么。<strong class="lc iu">需要注意的是，拓扑由执行前面代码片段的应用程序执行和保存，拓扑不在Kafka代理内部运行。所有拓扑处理开销都由创建应用程序支付。</strong></p><p id="0e4c" class="pw-post-body-paragraph la lb it lc b ld nz ju lf lg oa jx li lj ob ll lm ln oc lp lq lr od lt lu lv im bi translated">可以通过执行以下命令来停止正在运行的拓扑:</p><pre class="ly lz ma mb gt og oh oi oj aw ok bi"><span id="9458" class="mn kj it oh b gy ol om l on oo">streams.close();</span></pre><p id="111f" class="pw-post-body-paragraph la lb it lc b ld nz ju lf lg oa jx li lj ob ll lm ln oc lp lq lr od lt lu lv im bi translated">为了使这种拓扑更有用，我们需要定义基于规则的分支(或边)。在下一个示例中，我们根据JSON消息有效负载中特定字段的值，创建了一个具有3个分支的基本拓扑。</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">具有多个分支的流拓扑</figcaption></figure><p id="d809" class="pw-post-body-paragraph la lb it lc b ld nz ju lf lg oa jx li lj ob ll lm ln oc lp lq lr od lt lu lv im bi translated">我们刚刚创建的拓扑如下图所示:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi op"><img src="../Images/99181eeaca5dae49a828c0cca18fc0cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*eleWxYq_lu0N2B6XtBR62Q.png"/></div></figure><p id="e4a8" class="pw-post-body-paragraph la lb it lc b ld nz ju lf lg oa jx li lj ob ll lm ln oc lp lq lr od lt lu lv im bi translated">前一个例子中的分支的下游消费者可以像使用任何其他Kafka主题一样使用分支主题。下游处理器可以产生它们自己的输出主题。因此，将来自下游处理器的结果与原始输入主题相结合可能是有用的。我们还可以使用Kafka Streams API来定义将结果输出主题加入到单个流中的规则。</p><h1 id="2ca0" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">穿越溪流</h1><p id="dde1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Kafka Streams根据SQL连接对其流连接功能进行建模。有三种联接:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oq"><img src="../Images/d0be9ecb0f982b41ccaab63b30796758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iMVjZEIWyAO87rbOPNzExQ.jpeg"/></div></div></figure><ul class=""><li id="f7d4" class="mz na it lc b ld nz lg oa lj or ln os lr ot lv ne nf ng nh bi translated"><strong class="lc iu">内部连接:</strong>当两个输入主题都有相同键的记录时，发出一个输出。</li><li id="8b1d" class="mz na it lc b ld ni lg nj lj nk ln nl lr nm lv ne nf ng nh bi translated"><strong class="lc iu"> left join: </strong>为左侧或主输入主题中的每个记录发出一个输出。如果另一个主题没有给定键的值，则它被设置为null。</li><li id="f778" class="mz na it lc b ld ni lg nj lj nk ln nl lr nm lv ne nf ng nh bi translated"><strong class="lc iu">外部连接:</strong>在任一输入主题中为每个记录发出一个输出。如果只有一个源包含键，则另一个源为空。</li></ul><p id="727d" class="pw-post-body-paragraph la lb it lc b ld nz ju lf lg oa jx li lj ob ll lm ln oc lp lq lr od lt lu lv im bi translated">对于我们的例子，我们将输入记录流和来自下游处理器的结果连接在一起。在这种情况下，执行一个左连接最有意义，因为输入主题被认为是主主题。这将确保连接的流总是输出原始输入记录，即使没有可用的处理器结果。</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="cc54" class="pw-post-body-paragraph la lb it lc b ld nz ju lf lg oa jx li lj ob ll lm ln oc lp lq lr od lt lu lv im bi translated">最终的整体拓扑如下图所示:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ou"><img src="../Images/bafa97965db2261685b1be95d55cd2db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KhCtu3Nfj8-pzYqvEL1wdA.png"/></div></div></figure><p id="78b5" class="pw-post-body-paragraph la lb it lc b ld nz ju lf lg oa jx li lj ob ll lm ln oc lp lq lr od lt lu lv im bi translated">通过编程可以让同一个服务创建并执行两个流拓扑，但是我在示例中避免了这样做，以保持图形不循环。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="e8f5" class="ki kj it bd kk kl nu kn ko kp nv kr ks jz nw ka ku kc nx kd kw kf ny kg ky kz bi translated">参考</h1><ul class=""><li id="2278" class="mz na it lc b ld le lg lh lj nb ln nc lr nd lv ne nf ng nh bi translated"><a class="ae lw" href="https://docs.confluent.io/current/streams/index.html" rel="noopener ugc nofollow" target="_blank">汇合文件</a></li><li id="f47d" class="mz na it lc b ld ni lg nj lj nk ln nl lr nm lv ne nf ng nh bi translated"><a class="ae lw" href="https://medium.com/better-programming/learn-stream-processing-with-kafka-streams-stateless-operations-2111080e6c53" rel="noopener">用Kafka Streams学习流处理</a></li><li id="025d" class="mz na it lc b ld ni lg nj lj nk ln nl lr nm lv ne nf ng nh bi translated"><a class="ae lw" href="https://www.baeldung.com/java-kafka-streams" rel="noopener ugc nofollow" target="_blank">Java kafk stream简介</a></li></ul></div></div>    
</body>
</html>