<html>
<head>
<title>Interacting with Service Workers using Puppeteer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用木偶师与服务人员互动</h1>
<blockquote>原文：<a href="https://itnext.io/interacting-with-service-workers-using-puppeteer-583e5fc4a40b?source=collection_archive---------4-----------------------#2018-08-03">https://itnext.io/interacting-with-service-workers-using-puppeteer-583e5fc4a40b?source=collection_archive---------4-----------------------#2018-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/78970542e9f0072ebe071fa7ce1393d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*o4RS6KEa9nYfOm2yf9yoGQ.png"/></div></figure><blockquote class="ju"><p id="ad66" class="jv jw iq bd jx jy jz ka kb kc kd ke dk translated"><strong class="ak">免责声明:</strong>这篇文章假设你已经有了你最喜欢的测试者(我建议Jest)的木偶师设置，并且你了解服务人员。</p></blockquote><p id="24c8" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ke ij bi translated">在为使用SWs的<a class="ae lc" href="https://github.com/humphd/next" rel="noopener ugc nofollow" target="_blank"> web应用</a>编写集成测试时，我在Jest和Puppeteer的设置上遇到了问题。显然，目前木偶戏还没有与SWs交互的API。参见<a class="ae lc" href="https://github.com/GoogleChrome/puppeteer/issues/2634" rel="noopener ugc nofollow" target="_blank">特征请求</a>和本<a class="ae lc" href="https://github.com/GoogleChrome/puppeteer/issues/1193" rel="noopener ugc nofollow" target="_blank">问题</a>。</p><p id="8b65" class="pw-post-body-paragraph kf kg iq kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb ke ij bi translated">应用:</p><ul class=""><li id="b35a" class="li lj iq kh b ki ld km le kq lk ku ll ky lm ke ln lo lp lq bi translated">您想要验证从SW绕过UI返回的内容。</li><li id="9f59" class="li lj iq kh b ki lr km ls kq lt ku lu ky lv ke ln lo lp lq bi translated">您希望向SW发送非GET请求。目前，实现这一点的唯一方法是修改请求头，但是它关闭了软件请求拦截。</li></ul><h1 id="c11c" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">解决办法</h1><p id="ce35" class="pw-post-body-paragraph kf kg iq kh b ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky my la lb ke ij bi translated">解决方案以一点点“黑”的形式出现。有许多puppeteer函数允许我们在页面的上下文中运行js代码。看到他们<a class="ae lc" href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageemulateoptions" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="da42" class="pw-post-body-paragraph kf kg iq kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb ke ij bi translated">我们对<code class="fe mz na nb nc b">evaluate</code>方法特别感兴趣。它以一个<code class="fe mz na nb nc b">Promise</code>的形式返回在页面上执行的操作的结果，该结果用来自页面的数据进行解析。</p><p id="50f2" class="pw-post-body-paragraph kf kg iq kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb ke ij bi translated">让我们看一个例子，看看如何使用<code class="fe mz na nb nc b">fetch</code>接口直接从页面发出不同类型的请求。</p><blockquote class="nd ne nf"><p id="d55e" class="kf kg ng kh b ki ld kk kl km le ko kp nh lf ks kt ni lg kw kx nj lh la lb ke ij bi translated"><strong class="kh ir">注意:</strong>节点中没有对<code class="fe mz na nb nc b">fetch</code>的原生支持。然而，也有类似的努力复制<code class="fe mz na nb nc b">fetch</code>的行为。</p></blockquote><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="23d8" class="pw-post-body-paragraph kf kg iq kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb ke ij bi translated">那么上面发生了什么呢？</p><ol class=""><li id="f030" class="li lj iq kh b ki ld km le kq lk ku ll ky lm ke nq lo lp lq bi translated">声明接收要传递给<code class="fe mz na nb nc b">fetch</code>的<code class="fe mz na nb nc b">url</code>和<code class="fe mz na nb nc b">config</code> ( <a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch" rel="noopener ugc nofollow" target="_blank">获取API </a>)的方法。</li><li id="76be" class="li lj iq kh b ki lr km ls kq lt ku lu ky lv ke nq lo lp lq bi translated">从将解析为<code class="fe mz na nb nc b">fetch</code>结果的<code class="fe mz na nb nc b">evaluate</code>返回<code class="fe mz na nb nc b">Promise</code>。</li><li id="5c19" class="li lj iq kh b ki lr km ls kq lt ku lu ky lv ke nq lo lp lq bi translated">传递所有应该在<code class="fe mz na nb nc b">evaluate</code>的上下文中可用的参数。</li><li id="d59d" class="li lj iq kh b ki lr km ls kq lt ku lu ky lv ke nq lo lp lq bi translated">用步骤<code class="fe mz na nb nc b">3</code>中提供的参数列表声明要由<code class="fe mz na nb nc b">evaluate</code>执行的方法。</li><li id="7db4" class="li lj iq kh b ki lr km ls kq lt ku lu ky lv ke nq lo lp lq bi translated">运行<code class="fe mz na nb nc b">fetch</code>并返回<code class="fe mz na nb nc b">Promise</code>结果。</li></ol></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="cd10" class="pw-post-body-paragraph kf kg iq kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb ke ij bi translated">现在我们有了基础，让我们进入SWs。任何与他们打过交道的人都会告诉你，关于工人，你需要知道的最重要的事情之一就是他们的生命周期。我不打算详细说明它是如何工作的，我只想说，在SW不活动之前，所有对它的请求都将返回404。因此，在运行任何测试之前，我们需要确保页面已经准备好。</p><p id="47c8" class="pw-post-body-paragraph kf kg iq kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb ke ij bi translated">我们通过在页面上下文中注册侦听器来实现这一点，当所有SW都处于活动状态时，该上下文将进行解析。下面是一个片段:</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><ol class=""><li id="17cc" class="li lj iq kh b ki ld km le kq lk ku ll ky lm ke nq lo lp lq bi translated">我使用<a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/getRegistrations" rel="noopener ugc nofollow" target="_blank"> getRegistrations </a>方法来获取与域相关的所有注册。</li><li id="3960" class="li lj iq kh b ki lr km ls kq lt ku lu ky lv ke nq lo lp lq bi translated">遍历所有注册，将所有内容合并到一个<code class="fe mz na nb nc b">Promise</code>中，一旦所有SW都是活动的，这个【】就会被解析。</li><li id="4f84" class="li lj iq kh b ki lr km ls kq lt ku lu ky lv ke nq lo lp lq bi translated">检查当前软件注册是否已激活，如果是—解决，如果否—监听<a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/onupdatefound" rel="noopener ugc nofollow" target="_blank"> onupdatefound </a>事件，并让浏览器安装软件。</li></ol><h1 id="be8c" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">就是这样！🎉</h1><p id="997e" class="pw-post-body-paragraph kf kg iq kh b ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky my la lb ke ij bi translated">我们现在需要做的就是在<code class="fe mz na nb nc b">beforeAll</code>中调用<code class="fe mz na nb nc b">waitForServiceWorkers</code>或者在你的框架中调用它的等价物！</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="db8c" class="pw-post-body-paragraph kf kg iq kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb ke ij bi translated"><em class="ng">发现错误？请在评论中让我知道！</em></p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="5b6a" class="pw-post-body-paragraph kf kg iq kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb ke ij bi translated"><em class="ng">原载于</em><a class="ae lc" href="https://gist.github.com/cbc98054e837f365fad7e3f7f0538aa2" rel="noopener ugc nofollow" target="_blank"><em class="ng">gist.github.com</em></a><em class="ng">。</em></p></div></div>    
</body>
</html>