<html>
<head>
<title>Practical Data Structures for Frontend Applications: When to use Linked Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">前端应用的实用数据结构:何时使用链表</h1>
<blockquote>原文：<a href="https://itnext.io/practical-data-structures-for-frontend-applications-when-to-use-linked-lists-8ef9826a745?source=collection_archive---------2-----------------------#2018-04-18">https://itnext.io/practical-data-structures-for-frontend-applications-when-to-use-linked-lists-8ef9826a745?source=collection_archive---------2-----------------------#2018-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/3d88f457bb1ac4f155d1e2ec792bc6fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*IbiU2ECEJwf4MZcL66Xs4g.jpeg"/></div></figure><p id="c472" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在网上搜索什么时候使用链表，你可能会找到这样的答案:</p><ul class=""><li id="c46c" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">使用链接来解决哈希冲突的哈希表。</li><li id="7e82" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">简单的内存分配器。</li><li id="5d79" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">FAT文件系统中大型文件的元数据。</li></ul><p id="4d0e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你是一名开发应用程序的前端开发人员，你实现内存分配器或哈希表的可能性有多大？可能性极小。</p><p id="8201" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这篇文章中，我们将看看前端应用程序中链表<em class="lg"> </em>的<em class="lg">实际用途</em>。本文不会讨论如何实现一个链表。网上已经有很多关于这个的文章了。</p><h2 id="4c12" class="lh li iq bd lj lk ll dn lm ln lo dp lp kf lq lr ls kj lt lu lv kn lw lx ly lz bi translated">剧透警报</h2><p id="09a2" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">现代前端应用程序中的链表存在一些问题:</p><ul class=""><li id="2ee2" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">主流框架中的大部分模板都不容易使用链表。React和Vue就是两个例子。在React中，您只能使用数组进行集合。其他任何事情都会产生错误:</li></ul><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mf"><img src="../Images/6ceeeed94d79828bbae5810ef69b56e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tu_kr98RkWsReaX8QlEfrg.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">这里没有链表爱…</figcaption></figure><p id="a2ad" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Vue模板中的go-to集合数据结构也是一个数组。尽管Vue官方支持对象上的迭代，但这种迭代是在自己的属性上(使用数组):</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="172c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">链表是通过引用连接的对象。要迭代一个链表，你需要能够一步一步地跟踪它的引用。</p><p id="c222" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">虽然从技术上讲，你可以在Vue和React中使用链表，但这需要做大量的工作。它是非标准的。不干净。而且，它很可能性能不佳。</p><ul class=""><li id="edce" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">即使你没有使用框架，你也不会经常使用链表。当修改一个有很多变化的大集合时，链表在性能增益方面显示了它们的价值。集合通常不够大，或者在前端的更新量不够大，无法从链表提供的性能改进中受益。</li><li id="0d43" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">最后，即使性能优化证明了使用链表的合理性，使用链表的场景也是有限的。</li></ul><p id="3a2b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，如果您仍然有兴趣了解前端应用程序中的链表，请继续阅读！</p><h2 id="98e0" class="lh li iq bd lj lk ll dn lm ln lo dp lp kf lq lr ls kj lt lu lv kn lw lx ly lz bi translated">将数组与链表进行对比</h2><p id="d12b" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">注意:<em class="lg">各种JavaScript引擎都会实现JavaScript规范。不一样。因此，不同环境的性能结果可能会有所不同。此外，下面描述的内部原理可能适用于也可能不适用于特定的JavaScript实现。最后，下面所有关于数组和链表的讨论都适用于JavaScript。</em></p><p id="8f5a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当您修改数组实现时，许多数组实现会进行大量的重新洗牌——这取决于您调用的方法。JavaScript中的经典例子是<code class="fe mu mv mw mx b">shift</code>和<code class="fe mu mv mw mx b">unshift</code>。<code class="fe mu mv mw mx b">unshift</code>在一个JavaScript数组上非常慢。相比之下，在链表上，它是常数时间O(1)。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi my"><img src="../Images/4d339172628c481d1e0442cdb36cc833.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lf6BgtcpogwP9jzW7Z5OVw.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">做10000次<strong class="bd lj"> <em class="mz"> unshift </em> </strong>操作时数组和链表的性能差异。使用Chrome 65.x计算</figcaption></figure><p id="74d5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在上面提到的<a class="ae na" href="https://measurethat.net/Benchmarks/Show/2716/2/array-vs-linked-list" rel="noopener ugc nofollow" target="_blank">测试中</a>，链表每秒能够执行993次<code class="fe mu mv mw mx b">unshift</code>操作，相比之下，数组每秒只能执行60次操作。这是一个巨大的，1555%的性能差异。</p><p id="7b09" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，数组上的其他方法，比如<code class="fe mu mv mw mx b">push</code>，运行起来要比链表快得多。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nb"><img src="../Images/84a13db36ec3be477d9797788b6c077f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9n4vrrDuUDqzi_-Sy89aIA.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">做10000次<strong class="bd lj"> push </strong>操作时数组和链表的性能差异。使用Chrome 65.x计算</figcaption></figure><p id="1b40" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里，链表能够执行958次操作，而数组只能执行16，447次。另一个巨大的性能差异:1616%。</p><h2 id="a46c" class="lh li iq bd lj lk ll dn lm ln lo dp lp kf lq lr ls kj lt lu lv kn lw lx ly lz bi translated">何时使用链表(在前端应用程序中)</h2><ul class=""><li id="0b1b" class="ks kt iq jw b jx ma kb mb kf nc kj nd kn ne kr kx ky kz la bi translated">您需要对列表进行大量修改——尤其是在列表末尾之外的地方添加或删除项目时。实时更新并在列表顶部添加新项目的股票行情自动收录器就是一个很好的例子。</li><li id="6137" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">您不需要经常访问列表中的单个项目，例如只读日志。</li><li id="2e93" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">当您需要轻松地在列表中双向导航时，双向链表会很有价值。双向链表可以反向导航，不需要递归。</li></ul><h2 id="cd15" class="lh li iq bd lj lk ll dn lm ln lo dp lp kf lq lr ls kj lt lu lv kn lw lx ly lz bi translated">用链表替换and数组</h2><p id="d87f" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">用链表替换数组的复杂度取决于链表的实现。我们将用于链表的代码有一个与JavaScript的数组非常相似的API(<a class="ae na" href="https://github.com/joe-crick/practical-data-structures/blob/master/linked-list.js" rel="noopener ugc nofollow" target="_blank">见这里的代码</a>)。要用这个链表替换一个数组，需要做两处修改:</p><ul class=""><li id="3fce" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">用链表初始化替换数组初始化:</li></ul><pre class="mg mh mi mj gt nf mx ng nh aw ni bi"><span id="4dbe" class="lh li iq mx b gy nj nk l nl nm">const requestList = [];</span><span id="f240" class="lh li iq mx b gy nn nk l nl nm">// becomes...</span><span id="44f5" class="lh li iq mx b gy nn nk l nl nm">const requestList = new LinkedList();</span></pre><ul class=""><li id="4ee4" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">用对<code class="fe mu mv mw mx b">get</code>的调用替换对数组边界的调用:</li></ul><pre class="mg mh mi mj gt nf mx ng nh aw ni bi"><span id="1013" class="lh li iq mx b gy nj nk l nl nm">const selectedItem = requestList[itemIndex];</span><span id="f5c7" class="lh li iq mx b gy nn nk l nl nm">// becomes...</span><span id="426c" class="lh li iq mx b gy nn nk l nl nm">const selectedItem = requestList.get(itemIndex);</span></pre><h2 id="3049" class="lh li iq bd lj lk ll dn lm ln lo dp lp kf lq lr ls kj lt lu lv kn lw lx ly lz bi translated">天真的例子</h2><p id="98cc" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">现在，让我们看一个在一个非常简单的前端应用程序场景中使用链表的例子:向一个<code class="fe mu mv mw mx b">ui</code>添加<code class="fe mu mv mw mx b">li</code>元素。</p><p id="7a43" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如上所述，对于链表和数组来说，API在很大程度上是相同的。我们要做的是对比链表和数组在结合DOM更新的<code class="fe mu mv mw mx b">unshift</code>操作上的性能。</p><p id="4d2a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">给定这个DOM:</p><pre class="mg mh mi mj gt nf mx ng nh aw ni bi"><span id="89d7" class="lh li iq mx b gy nj nk l nl nm">&lt;ul id="request-list"&gt;&lt;/ul&gt;</span></pre><p id="f1af" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">更新DOM的代码:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="6985" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这种更新方法:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="73e0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">哪个更快？</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi no"><img src="../Images/deabaa13254e0b79738df852053e05f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dEpqrbm9_MBbFMPKYmIatQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">获胜的链接列表。</figcaption></figure><p id="1a25" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如你所见，即使我们涉及到DOM更新，链表仍然比使用数组快50%。</p><h1 id="b08b" class="np li iq bd lj nq nr ns lm nt nu nv lp nw nx ny ls nz oa ob lv oc od oe ly of bi translated">摘要</h1><p id="e594" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">在某些情况下，链表比数组快得多。然而，考虑到面向用户的应用程序的本质，它们在前端应用程序中并没有太多的实际用途。对于大型数据集，链表带来的大多数性能提升都是显而易见的。我们通常不会在前端处理这种规模的数据集。此外，现代框架中的大多数模板都不支持链表。因此，如果你使用React或Vue，它们不是一个好的选择。请改用数组。</p></div></div>    
</body>
</html>