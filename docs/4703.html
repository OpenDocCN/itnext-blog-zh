<html>
<head>
<title>Simple Sliding Side Bar for your Angular Web Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单的滑动侧栏，方便您的网页应用</h1>
<blockquote>原文：<a href="https://itnext.io/simple-sliding-side-bar-for-your-angular-web-apps-d54fef7c1654?source=collection_archive---------0-----------------------#2020-08-27">https://itnext.io/simple-sliding-side-bar-for-your-angular-web-apps-d54fef7c1654?source=collection_archive---------0-----------------------#2020-08-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4615" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在Angular中创建一系列Web组件，避免为其导入整个库。在这篇文章中，我将为你的Angular Web应用程序和pwa(渐进式Web应用程序)创建一个简单的滑动侧栏，你可以用它来隐藏你的菜单选项，并从应用程序的任何地方触发。<br/> <em class="kl">任其滑，任其滑，任其滑！</em>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/0c2099ed3dfd497637494c97994052ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*LqmT5Z0bbO2eMp4Sbxlbwg.gif"/></div></figure><blockquote class="ku kv kw"><p id="5841" class="jn jo kl jp b jq jr js jt ju jv jw jx kx jz ka kb ky kd ke kf kz kh ki kj kk ij bi translated">依赖关系:<a class="ae la" href="https://cli.angular.io/" rel="noopener ugc nofollow" target="_blank">角度CLI </a></p></blockquote><p id="b094" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在Angular中构建一个简单而灵活的可配置滑动条(通常用于导航目的),同时学习一些重要的概念:</p><ul class=""><li id="3358" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">使用角度输入创建可配置组件，以增加其灵活性和可重用性</li><li id="ea95" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">组件嵌入的简单模板技术</li><li id="987d" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">使用服务实现组件间高度解耦的通信</li><li id="1aec" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">将CSS与角度指令结合使用，为角度组件创建代码最少的动画过渡</li></ul><h1 id="ed7c" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">目标</strong></h1><p id="9128" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">我们希望创建一个简单的滑动条，它具有以下功能:</p><ul class=""><li id="c160" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">允许用户提供从左侧或右侧滑动的选项</li><li id="8860" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">允许用户配置滑动条动画的速度</li><li id="c460" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">允许用户配置滑动条的宽度</li><li id="a07d" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">允许用户配置滑动条的内容</li></ul><p id="d5b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开始吧！</p><h1 id="1dc0" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">创建项目</h1><p id="b522" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">继续，通过Angular CLI使用命令创建项目</p><pre class="kn ko kp kq gt ms mt mu mv aw mw bi"><span id="7ae4" class="mx lq iq mt b gy my mz l na nb">ng new simple-side-nav</span></pre><p id="64be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在添加角度路由时选择<strong class="jp ir">是</strong>，并在项目创建过程中出现提示时选择<strong class="jp ir"> SCSS </strong>作为样式表格式。</p><p id="4f55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将为这个项目使用<a class="ae la" href="https://fonts.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌字体</a>,这样它看起来就不会那么无聊，而且我还将使用一些<a class="ae la" href="https://material.io/resources/icons/?style=baseline" rel="noopener ugc nofollow" target="_blank">网络材质图标</a>(我将使用其中的一些图标),从CDN中引用它们。将下面的链接放在项目的<strong class="jp ir">index.html</strong>的<strong class="jp ir"> <em class="kl"> &lt;头&gt; </em> </strong>标签内。稍后我们将展示如何使用它们。</p><pre class="kn ko kp kq gt ms mt mu mv aw mw bi"><span id="0c80" class="mx lq iq mt b gy my mz l na nb">&lt;link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"&gt;</span><span id="81e4" class="mx lq iq mt b gy nc mz l na nb">&lt;link href="https://fonts.googleapis.com/css2?family=Alata&amp;display=swap" rel="stylesheet"&gt;</span></pre><p id="e8b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你的应用程序的主index.html应该是这样的:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5796" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在项目的根目录下，在<strong class="jp ir"> src/app </strong>文件夹中，我将为更好的项目结构创建几个目录。我将创建名为<strong class="jp ir">组件、模型、页面</strong>和<strong class="jp ir">服务</strong>的目录。你的结构应该看起来如下(从<strong class="jp ir"> <em class="kl"> src </em> </strong>根):</p><pre class="kn ko kp kq gt ms mt mu mv aw mw bi"><span id="f126" class="mx lq iq mt b gy my mz l na nb">- src<br/>  - app<br/>    - components<br/>    - pages<br/>    - services</span></pre><h1 id="2cf4" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">建立基金会</h1><p id="f058" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">我们已经决定，我们将在这个应用程序中有几个页面和几个组件，以及路由，所以我们需要清理现有的应用程序组件页面(在项目创建期间生成)以适应这种变化。转到<strong class="jp ir">app.component.html</strong>文件，清除锅炉板内容并替换为:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2ca2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用<strong class="jp ir"> &lt;路由器出口&gt; </strong>接入Angular的路由框架来显示页面。我们有两个占位符(一个用于侧边导航栏，一个用于标题——我们稍后会谈到它们)。现在，导航到<strong class="jp ir"> app.component.scss </strong>并用以下内容替换它:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="92a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在项目的根目录下，在src文件夹中，项目生成一个<strong class="jp ir"> styles.scss </strong>文件。此文件用于我们希望在全局级别应用并影响所有页面的样式，请始终小心您在此处放置的样式。在我们的例子中，我们希望让body标签伸展到边缘，如下所示:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><blockquote class="ku kv kw"><p id="0ab4" class="jn jo kl jp b jq jr js jt ju jv jw jx kx jz ka kb ky kd ke kf kz kh ki kj kk ij bi translated"><em class="iq">我使用的策略是将最外层的容器(在我们的例子中是</em> <strong class="jp ir"> <em class="iq">，body标签</em> </strong> <em class="iq">)绝对定位并拉伸到页面的边缘(通过设置</em> <strong class="jp ir"> <em class="iq">顶部</em> </strong> <em class="iq">，</em> <strong class="jp ir"> <em class="iq">右侧</em> </strong> <em class="iq">，</em> <strong class="jp ir"> <em class="iq">底部</em> </strong> <em class="iq">和</em></p></blockquote><h1 id="e8f9" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">创建服务</strong></h1><p id="482d" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">我们需要一种方法让应用程序跟踪侧边导航栏的状态(当它打开或关闭时)，并提供一个API来允许感兴趣的组件利用功能，如订阅侧边导航栏的状态变化，以及改变导航栏状态的方法(以编程方式触发它打开/关闭)，所以让我们创建一个<strong class="jp ir">服务</strong>来处理这个问题。</p><p id="6d6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">导航到src/app/services，并执行Angular CLI命令来创建服务:</p><pre class="kn ko kp kq gt ms mt mu mv aw mw bi"><span id="55f8" class="mx lq iq mt b gy my mz l na nb">&gt; ng generate service navigation<br/><strong class="mt ir"><em class="kl">...or the short version:</em></strong><br/>&gt; ng g s navigation</span></pre><p id="0f13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将创建一个名为NavigationService的服务，该服务在默认情况下是可注入的，并且可以通过依赖注入来使用。让我们用下面的代码替换它的内容:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6675" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来剖析一下服务。注意在顶部我们已经创建了一个名为<strong class="jp ir"> showNav$ </strong>的<strong class="jp ir">行为主体</strong> <strong class="jp ir"> <em class="kl">私有</em> </strong>属性。这只是一个简单的<a class="ae la" href="https://www.learnrxjs.io/learn-rxjs/subjects/behaviorsubject" rel="noopener ugc nofollow" target="_blank"> BehaviorSubject </a>属性，它将允许用户通过该服务中提供的API订阅它，这样他们就可以访问它、订阅它并在该属性更改时接收通知。这是布尔型的<strong class="jp ir">所以它只是一个简单的开关标志，开关状态。我们正在创建一个非常封装的服务，因此围绕它提供了以下入口点:</strong></p><ul class=""><li id="3e55" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated"><strong class="jp ir"> <em class="kl"> getShowNav </em> </strong>:该方法将behavior subject<strong class="jp ir">showNav $</strong>公开为一个可观察对象，因此客户端可以订阅它，并在它发生变化时通过<strong class="jp ir">得到通知。asObservable() </strong>行为主体的方法。</li><li id="7051" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir"> <em class="kl"> setShowNav </em> </strong>:将<strong class="jp ir"> showNav$ </strong>设置为通过<strong class="jp ir"> showHide </strong>参数提供的值。</li><li id="2e9a" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir"><em class="kl">toggleNavState</em></strong>:简单切换数值(从真到假，反之亦然)。</li><li id="d949" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir"> isNavOpen </strong>:查询属性的当前状态(无论<strong class="jp ir"> showNav$ </strong>是真还是假)。</li></ul><blockquote class="ku kv kw"><p id="8a6b" class="jn jo kl jp b jq jr js jt ju jv jw jx kx jz ka kb ky kd ke kf kz kh ki kj kk ij bi translated">我总是喜欢创建围绕<strong class="jp ir"> Observables </strong>和<strong class="jp ir"> BehaviorSubject </strong>属性的方法——我建议这样做是出于可测试性的目的(远远超出了这个主题),当然也是为了提供进入这些属性的单一入口点，因此我将它创建为private，这样访问它们的唯一方式就是通过所提供的方法。</p></blockquote><h1 id="2606" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">创建组件</h1><p id="72a3" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">让我们通过发出Angular CLI命令，从主要组件—侧面导航栏开始:</p><pre class="kn ko kp kq gt ms mt mu mv aw mw bi"><span id="a232" class="mx lq iq mt b gy my mz l na nb">&gt; ng generate component side-nav</span></pre><p id="2731" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这为这个组件创建了我们需要的三个部分(<em class="kl"> HTML </em>、<em class="kl"> SCSS </em>和<em class="kl"> TS </em>文件)。我们稍后将回到这些，但首先我们要创建一个附加文件。在<strong class="jp ir"> components/side-nav </strong>文件夹中，我将创建一个名为<strong class="jp ir"> side-nav-direction.ts </strong>的附加文件，该文件将保存枚举<strong class="jp ir">sidenav direction</strong>——该枚举将表示侧面导航栏滑动动画的两个选项:<strong class="jp ir"> <em class="kl">左侧</em> </strong>和<strong class="jp ir"> <em class="kl">右侧</em> </strong>。添加以下内容:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6325" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们回到侧面导航栏组件。让我们从它的类型脚本逻辑开始。在生成的文件<strong class="jp ir"> side-nav.component.ts </strong>中，我们删除以下内容:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="24a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们来剖析一下这个组件。这个组件显然需要与我们在它的伙伴服务<strong class="jp ir"> NavigationService </strong>中维护的状态保持同步，这也是我们注入它的原因。我们调用NavigationService的<strong class="jp ir"> <em class="kl"> getShowNav() </em> </strong>，这样我们就可以订阅返回的<strong class="jp ir"> showNav$ </strong>的<strong class="jp ir"> Observable </strong>。</p><p id="ff05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使该组件可配置且灵活，我们提供了四个输入属性:</p><ul class=""><li id="3bce" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated"><strong class="jp ir"><em class="kl">sidenavTemplateRef</em></strong>:这将为组件提供一个占位符，以便人们将其他子组件嵌入其中，使用Angular中的一个可用指令<a class="ae la" href="https://angular.io/api/common/NgTemplateOutlet" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">ngtemplateeoutlet</strong></a>。我们稍后再来讨论。</li><li id="ff9c" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir"> <em class="kl">持续时间</em> </strong>:设置侧面导航栏滑动动画的持续时间(秒)。默认值为0.25秒。</li><li id="4610" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir"> <em class="kl"> navWidth </em> </strong>:设置侧面导航条的宽度(以像素为单位)。默认是窗口的宽度<strong class="jp ir"> <em class="kl"> innerWidth </em> </strong>。</li><li id="b698" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir"> <em class="kl">方向</em> </strong>:这里我们将使用前面创建的枚举，它将允许侧边导航栏滑出的方向。<strong class="jp ir">默认为<em class="kl">左</em>右</strong>。</li></ul><p id="f4b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了输入之外，我们还提供了一个名为<strong class="jp ir"><em class="kl">onSideBarClose()</em></strong>的便捷方法，通过服务的<strong class="jp ir"> setShowNav() </strong>并传递<strong class="jp ir"> false </strong>值来关闭侧边导航栏。</p><p id="d53f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">方法<strong class="jp ir"><em class="kl">getSideNavBarStyle()</em></strong>从可观察对象<strong class="jp ir"> showSideNav </strong>中获取展开的值，并构建一个对象，该对象馈入Angular的<strong class="jp ir"> <em class="kl"> ngStyle </em> </strong>的指令。我们设置一个具有三个属性的对象:</p><ul class=""><li id="6275" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated"><strong class="jp ir"> <em class="kl">过渡</em> </strong>:根据提供的<strong class="jp ir">方向</strong>和<strong class="jp ir">持续时间</strong>决定侧面导航条的过渡。</li><li id="f54d" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir"> width </strong>:侧边导航条的宽度(提供或者默认为屏幕宽度)。</li><li id="12db" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir">方向</strong>:注意我们是如何根据提供的方向动态创建navBarStyle对象的属性的。</li></ul><pre class="kn ko kp kq gt ms mt mu mv aw mw bi"><span id="2626" class="mx lq iq mt b gy my mz l na nb"><strong class="mt ir">navBarStyle[this.direction] = <br/>   (showNav ? 0 : (this.navWidth * -1)) + 'px';</strong></span><span id="4718" class="mx lq iq mt b gy nc mz l na nb">...which eventually turns into:</span><span id="e4c0" class="mx lq iq mt b gy nc mz l na nb"><strong class="mt ir">navBarStyle.left <br/></strong>...or<strong class="mt ir"><br/>navBarStyle.right</strong></span></pre><p id="b904" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看代码如何映射到<br/><strong class="jp ir">side-nav.component.html</strong>中的标记:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2aea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顶部容器(<strong class="jp ir"> <em class="kl">侧导航条</em> </strong>)包装了覆盖层(<strong class="jp ir"> <em class="kl">侧导航条覆盖层</em> </strong>)和主侧栏(<strong class="jp ir"> <em class="kl">侧导航条菜单容器</em> </strong>)。</p><p id="978e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">侧导航条</strong>在<strong class="jp ir">显示侧导航条</strong>为<strong class="jp ir">真</strong>时应用一个类(<strong class="jp ir">侧导航条折叠</strong>)。</p><p id="52ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">覆盖图(<strong class="jp ir"> side-nav-bar-overlay </strong>)在其背景颜色和可见性上有一个CSS过渡动画，该动画通过<strong class="jp ir"> ngStyle </strong>指令基于持续时间开始，并且在<strong class="jp ir"> showSideNav </strong>为真时添加一个类(<strong class="jp ir">side-nav-bar-overlay-collapsed</strong>)。我们想让覆盖图可点击，这样当用户点击覆盖图时，它也会关闭侧边导航条，因此也将<strong class="jp ir"> onSidebarClose() </strong> click事件连接到它。</p><p id="7936" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意<strong class="jp ir">侧导航条菜单容器</strong>以及我们如何通过<strong class="jp ir"><em class="kl">getSideNavBarStyle</em></strong>方法<strong class="jp ir"> <em class="kl"> </em> </strong>应用我们正在构建的CSS样式对象，并向该方法提供<strong class="jp ir"> showSideNav </strong>属性的展开值。返回的对象(如前所示)也被送入<strong class="jp ir"> ngStyle </strong>指令。</p><blockquote class="ku kv kw"><p id="f640" class="jn jo kl jp b jq jr js jt ju jv jw jx kx jz ka kb ky kd ke kf kz kh ki kj kk ij bi translated"><strong class="jp ir">注意:</strong>每次<strong class="jp ir"> getSideNavBarStyle </strong>中的一个属性发生变化时，Angular会重新调用它，重新生成CSS ngStyle对象，CSS转换会再次启动。剩下的就交给你了。</p></blockquote><p id="30d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们添加了一个关闭按钮(<strong class="jp ir"> side-nav-bar-close </strong>)来关闭边栏，边栏上有一个由Google的Material Icons(之前添加的CDN)提供的图标。</p><p id="c2c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了包装这个组件的标记，我们有一个容器(<strong class="jp ir">side-nav-bar-content-container</strong>)来包装(双关语)将显示在侧边导航栏中的内容。内容是一个使用<strong class="jp ir"> ngTemplateOutlet </strong>选项的<strong class="jp ir"> ng容器</strong>。一个<strong class="jp ir"> NgTemplateOutlet </strong>只不过是一个占位符，让你动态地、编程地将内容嵌入其中。</p><p id="9674" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，侧面导航栏的CSS，在文件<strong class="jp ir">side-nav-bar . component . scss</strong>中:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="0f8f" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">应用的CSS技巧(和解释)</h1><ul class=""><li id="2f13" class="lb lc iq jp b jq mn ju mo jy nf kc ng kg nh kk lg lh li lj bi translated">覆盖图的诀窍是<em class="kl">总是呈现</em> —通过使用CSS样式<strong class="jp ir">可见性:折叠</strong>我们允许它仍然留在原处<em class="kl">，同时不占用布局中的任何空间并完全隐藏元素</em> —点击事件仍然被覆盖图下面的元素捕获。当覆盖图可见时，它接收到隐藏侧栏的click事件，通过CSS转换，我们不仅淡化了它的背景色，还动画化了可见性，允许在折叠后继续点击。</li><li id="ce47" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">让<strong class="jp ir">侧边导航条</strong>保持在顶部而不管页面滚动的诀窍是使用position: fixed CSS属性并给它一个高的z-index，使它保持在顶部。</li><li id="37b7" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">使用CSS过渡使<strong class="jp ir">侧边导航栏菜单容器</strong>具有动画效果的技巧是使其成为<strong class="jp ir">位置:绝对</strong>，因此它沿着将要发生过渡的坐标移动——在我们的例子中，是左<em class="kl">和右<em class="kl">坐标。</em></em></li></ul><p id="309c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是组件的示意性外观:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ni"><img src="../Images/e04a65202add6a3687a13cf2dee9b938.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zdqteIcplISvSUZFndzu0g.png"/></div></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">你可以看到侧边导航条是如何放在边上的，而覆盖层就在那里；我们用CSS过渡将导航条滑入和滑出，并且我们淡化覆盖图的背景和它的可见性。侧边栏位于应用程序的顶部，而所有其他页面位于下方。</figcaption></figure><p id="a645" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在组件已经创建好了，让我们学习如何在应用程序中应用它。</p><h1 id="9b72" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">我如何使用这个组件？</h1><p id="d5b0" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">很简单！让我们回到app.component.html，用以下内容更新这个组件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="42dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意我们是如何通过自定义选择器<strong class="jp ir"> app-side-nav </strong>在<strong class="jp ir">app.component.html</strong>的最顶端添加之前创建的侧面导航栏组件的，以及输入是如何提供给它的:</p><ul class=""><li id="e45a" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">方向:右</li><li id="c394" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">导航宽度:280</li><li id="3d0a" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">持续时间:0.5</li></ul><p id="e198" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，看看我们是如何为侧边导航栏提供一个显示在其内部占位符<strong class="jp ir"> sidenavTemplateRef </strong>中的模板的引用的:通过在标记(<strong class="jp ir"> ng-template #navContent </strong>)中提供一个现有模板的id，所发生的是Angular将通过id <strong class="jp ir"> navContent </strong>(实际上是这里的任何内容)获取<strong class="jp ir"> ng-template </strong>的内容， 将其作为输入传递给<strong class="jp ir"> sideNavTemplateRef </strong>，并将其嵌入到侧面导航栏中定义的<strong class="jp ir">ngtemplateeoutlet</strong>中，其中<strong class="jp ir">ngtemplateeoutlet</strong>引用具有相同的名称(<strong class="jp ir"> sideNavTemplateRef </strong>)。 这是一种灵活的嵌入内容的方式。侧栏不知道模板出口中嵌入了什么内容——它所知道的是它得到了一些需要嵌入的内容。</p><h1 id="a14d" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">现在我添加了它，我如何看到它的作用呢？</h1><h2 id="643f" class="mx lq iq bd lr nr ns dn lv nt nu dp lz jy nv nw md kc nx ny mh kg nz oa ml ob bi translated">需要有人来触发它。</h2><p id="a20e" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">是啊，你说得对。为此，我们将创建一个简单的组件来表示该应用程序的标题。这样，我们将演示一个完全独立的组件如何触发侧栏的打开。</p><p id="8823" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们发出Angular CLI命令，为标题创建一个新的简单组件:</p><pre class="kn ko kp kq gt ms mt mu mv aw mw bi"><span id="0d02" class="mx lq iq mt b gy my mz l na nb">ng generate component header</span></pre><p id="1860" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和往常一样，它生成了我们需要的三个部分(HTML、SCSS和TS文件)。让我们从名为<strong class="jp ir"> header.component.ts </strong>的类型脚本开始:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f96c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意它是多么简单。它只是通过<em class="kl"> Angular的依赖注入</em>系统将<strong class="jp ir"> NavigationService </strong>注入其构造函数中，而在一个名为<strong class="jp ir"> toggleSideNav() </strong>的方法内部只是调用<strong class="jp ir"> setShowNav </strong>来<strong class="jp ir"> true </strong>。这将触发一系列事件，将<strong class="jp ir">behavior subject</strong><strong class="jp ir">show nav $</strong>设置为<strong class="jp ir"> true </strong>，任何订阅/收听此更改的人都将相应地采取行动。这就是异步、事件驱动编程的美妙之处！</p><p id="71dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">header.component.html</strong>长这样:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7e5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这只是一个非常简单的布局结构，但值得一提的是，我们使用了一个span标签作为按钮，因为我们向它附加了一个click事件来触发<strong class="jp ir"> toggleSideNav() </strong>事件，并添加了一个材质图标，使它看起来像一个汉堡包菜单(通常用于菜单)。</p><p id="e47a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> header.component.scss </strong>的SCSS甚至更简单:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7ebb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些样式通过增加字体大小、添加一些填充和改变光标来改变材料图标的默认样式——使这种将图标导入应用程序的策略非常灵活和强大！</p><p id="653e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更新应用程序组件</p><p id="5482" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们已经创建了标题组件，现在我们有了一个可以触发侧边导航条打开的人！让我们更新app.component.html文件，并把标题放在正确的位置:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="03ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意<strong class="jp ir"> app-header </strong>选择器被放置在<strong class="jp ir">主容器</strong>容器的正内部，但也在包围<strong class="jp ir">路由器出口</strong>的部分的正上方。我们希望它总是显示在每个页面的顶部，这样无论我在哪个页面，它对整个应用程序都是全局的。</p><p id="85d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦所有东西都连接好了，它就会变成这样:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/40fd37a0d8a05f6fa2045f0a3824046e.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/1*mlqAWCQrC2THIoVdQhp8wQ.gif"/></div></figure><h1 id="8124" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">额外收获:添加主页</h1><p id="d452" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">我创建了一个简单的组件，只是为了说明我的观点，即页面位于页眉之上，并通过应用程序组件的路由器出口显示。在src/pages文件夹中，我创建了名为<strong class="jp ir"> home.component </strong>的页面组件，添加了<strong class="jp ir"> app-routing.module.ts </strong>中所需的配置，因此它指向刚刚创建的HomeComponent。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="21ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重新构建后，应用程序最终将如下所示:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/669e842e165304455dde5fa7c665eb2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/1*kbhxInzk2Kl52mbwIvQuqA.gif"/></div></figure><h1 id="b1c3" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">额外奖励</strong>:菜单内容的独立组件。</h1><p id="863e" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">谈谈组件的解耦——现在我制作了一个单独的组件来容纳导航项目。我调用了组件<strong class="jp ir"> side-nav-content </strong>，它包含了使用Angular路由器机制的整个应用程序的页面链接。点击链接后，它会导航到相应的页面，同时也隐藏了侧导航栏。更改后，应用程序将如下所示:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/585530d4decf1d5a07a67f19280f8289.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/1*0Q6QIRfWBxp8B_yDkpiHNA.gif"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">单击导航链接也会关闭侧面导航栏，但不会显式调用导航服务的setShowNav()为false</figcaption></figure><p id="edf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我如何在导航改变时关闭侧边导航条，而不显式调用NavigationService的<strong class="jp ir"> setShowNav() </strong>为false？在<strong class="jp ir"> NavigationService的</strong>构造函数中，我注入Angular的<strong class="jp ir"> Router </strong>，我监听<strong class="jp ir"><em class="kl">router.events</em></strong>——任何导航动作(在我的例子中，导航改变到另一个页面)都将在附加到Router . events的订阅I中触发。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9cd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的<a class="ae la" href="https://github.com/romanejaquez/simple-side-nav" rel="noopener ugc nofollow" target="_blank"> Github Repo </a>上看到这个教程的完整实现。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/72bfc609a106b08b8a9ce0787f5628e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/1*BqUth9L5TfVS9e0LrmccQQ.gif"/></div></figure><p id="00f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就这样，我结束了这篇文章，希望这是一个对你有帮助的教程，告诉你如何利用Angular的力量，并带你踏上探索以下内容的旅程:</p><ul class=""><li id="06c6" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated"><strong class="jp ir"> <em class="kl">使用角度输入创建可配置组件以增加其灵活性和可重用性</em></strong>——我们创建了一个简单的侧边导航栏、标题和导航链接组件，以高度解耦的方式无缝通信</li><li id="9ede" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir"> <em class="kl">用于组件嵌入的简单模板技术</em></strong>——使用NgTemplateOutlet，我们以简单而灵活的方式将组件和内容嵌入到其他组件中。</li><li id="e8a3" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir"> <em class="kl">使用服务实现组件间高度解耦的通信</em></strong>——使用异步、事件驱动的编程方法，使用服务与组件通信，触发事件。</li><li id="b973" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir"> <em class="kl">使用CSS结合角度指令为您的角度组件</em> </strong>创建最少代码的动画过渡——我们使用CSS过渡结合角度指令(<strong class="jp ir"> <em class="kl"> ngStyle，ngIf，ngClass </em> </strong>)创建流畅简单的动画效果，使用最少的代码使您的应用程序更加完美。</li></ul><p id="9b15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，你可以在我的<a class="ae la" href="https://github.com/romanejaquez/simple-side-nav" rel="noopener ugc nofollow" target="_blank"> Github Repo </a>上看到这个教程的完整实现。</p><p id="f3e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请在Twitter <a class="ae la" href="https://twitter.com/drcoderz" rel="noopener ugc nofollow" target="_blank"> @drcoderz </a>上关注我，看看我这些天都在做什么，别忘了在下面鼓掌以示感谢——看到掌声多少会激励我写作，所以请这样做吧！</p><p id="cd76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">滑的开心！</p></div></div>    
</body>
</html>