# 我们如何避免 if/else 并使用策略模式编写可扩展的代码

> 原文：<https://itnext.io/how-we-avoided-if-else-and-wrote-extendable-code-with-strategy-pattern-256e34b90caf?source=collection_archive---------0----------------------->

我们为一家电信客户工作，在那里我们为客户推出了`offers`。他们有大量的业务逻辑，基于这些逻辑，用户将获得一个`offer`。除此之外，他们还将在 2010 年前创建更多类别的`offer`久而久之。我们看到了类似这样的代码

策略模式:不使用策略模式

每当一个新的`offer`类型被引入，或者现有的规则需要修改，我们需要改变`User`类。

调用这个类看起来像这样

我们对代码有以下问题:

*   违反了[中的“O”固体原理](https://en.wikipedia.org/wiki/SOLID):根据固体原理

> "软件实体…应该对扩展开放，但对修改关闭."

然而，每当我们必须生成新的报价类别时，我们就必须更改一个`User`类。

*   多重`if/else`使得代码难以测试和维护
*   `offer`和`User`紧密耦合

# 拯救的策略模式

策略模式允许我们独立于使用它的客户端来改变算法。在我们的例子中，我们希望独立于`User`来修改`offer`的算法。

让我们创建一个名为`UserOffer`的新类

策略模式:报价的新类别

需要注意的重要事项:

*   在`line 3`，它是一个函数引用，而不是一个实际的调用。
*   从`line 11`开始，我们可以创建新的优惠

我们的`User`类现在变得简单多了

策略模式:具有策略模式的用户类

在上面的代码中，我们已经引入了与`setType`类似的`setOffer`。`getOffer`现在只需调用`offer.getOffer`，它将返回相关报价。

*   这种方法使我们能够灵活地修改/创建新的报价，而无需更改`User`类别。
*   我们已经避免了`if/else`的编码风格
*   我们的代码更容易扩展和测试。