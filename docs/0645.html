<html>
<head>
<title>Declarative dialogs in React and JSX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React和JSX中的声明性对话框</h1>
<blockquote>原文：<a href="https://itnext.io/declarative-dialogs-in-react-and-jsx-570aa40d258c?source=collection_archive---------0-----------------------#2018-04-27">https://itnext.io/declarative-dialogs-in-react-and-jsx-570aa40d258c?source=collection_archive---------0-----------------------#2018-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0394472e0928d61639b2ad8d7f3193b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*L24gp9qqbw1CZ-tM8Lew6w.png"/></div></div></figure><h1 id="a592" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="9266" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在实际应用中，我们经常会在各种情况下看到确认对话框，例如在SNS上发帖、推广付费计划、购买确认等。有时它们很烦人，但对用户来说仍然很重要。</p><p id="4ed3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在HTML5.2 <code class="fe lz ma mb mc b">&lt;dialog/&gt;</code>或者jQuery中，有一个方法可以打开这样的对话框，但是在React中情况就有点不一样了。让我们来看看它们有什么不同。</p><p id="9d60" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">*更新* 2018/7/19新增巴别塔示例。</p><h1 id="4842" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">如何在React中打开对话框？</h1><p id="0bba" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">虽然HTML 5.2 的<code class="fe lz ma mb mc b"><a class="ae md" href="https://www.w3.org/TR/html52/interactive-elements.html#the-dialog-element" rel="noopener ugc nofollow" target="_blank">&lt;dialog/&gt;</a></code> <a class="ae md" href="https://www.w3.org/TR/html52/interactive-elements.html#the-dialog-element" rel="noopener ugc nofollow" target="_blank">元素已经发布，但是jQuery UI的dialog目前仍然是一个流行的库。使用jQuery UI，可以像这样打开一个对话框，</a></p><pre class="me mf mg mh gt mi mc mj mk aw ml bi"><span id="300e" class="mm jz iq mc b gy mn mo l mp mq">&lt;div id="dialog" title="Basic dialog"&gt;<br/>  &lt;p&gt;Hello World!&lt;/p&gt;<br/>&lt;/div&gt;<!-- --> </span><span id="3f28" class="mm jz iq mc b gy mr mo l mp mq">// in script tag<br/>$(function() {<br/>  $("#dialog").dialog();<br/>});</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/21715e6947c121f174ff933c1e913535.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*lmlUK4WTz41SqxHy7BqeFg.png"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">jQuery UI对话框的示例</figcaption></figure><p id="35f4" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">相反，在React/JSX中使用<a class="ae md" href="https://github.com/reactjs/react-modal" rel="noopener ugc nofollow" target="_blank"> react-modal </a>打开一个对话框看起来像这样。</p><pre class="me mf mg mh gt mi mc mj mk aw ml bi"><span id="7dd1" class="mm jz iq mc b gy mn mo l mp mq">&lt;ReactModal isOpen={this.state.isOpen}&gt;<br/>  &lt;p&gt;Hello World!&lt;/p&gt;<br/>  &lt;button&gt;OK&lt;/button&gt;<br/>&lt;/ReactModal&gt;</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/23ba8cb35d3c8c7b40182928d504dabf.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*07yLr16kLm56iPS5K5sn5g.png"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">反应对话框的一个例子</figcaption></figure><p id="4a77" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">可以用<code class="fe lz ma mb mc b">isOpen = true</code>改变状态打开，但是jQueryUI中没有<code class="fe lz ma mb mc b">.dialog()</code>这样的方法。我们要做的是管理好<code class="fe lz ma mb mc b">isOpen</code>州。</p><h1 id="da8d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">管理对话状态</h1><p id="cb10" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">可以用任何方式管理<code class="fe lz ma mb mc b">isOpen</code>状态:类状态、HoC、Redux等。然而，这种状态<a class="ae md" href="https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367" rel="noopener">不应该由Redux </a>管理，因为它在大多数情况下是局部的，并且与全局状态隔离。有一个来自<code class="fe lz ma mb mc b"><a class="ae md" href="https://www.npmjs.com/package/reenhance-components" rel="noopener ugc nofollow" target="_blank">reenhance-components</a></code>的组件<code class="fe lz ma mb mc b">StateProvider</code>，它提供状态和更新器。可以这样用。</p><pre class="me mf mg mh gt mi mc mj mk aw ml bi"><span id="7090" class="mm jz iq mc b gy mn mo l mp mq">const ModalState = StateProvider(false);</span><span id="3856" class="mm jz iq mc b gy mr mo l mp mq">const HelloModal = () =&gt; (<br/>  &lt;ModalState&gt;<br/>    {({ state: isOpen, setState: setIsOpen }) =&gt; (<br/>      ...<br/>    )}<br/>  &lt;/ModalState&gt;<br/>);</span></pre><p id="66e6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">若要通过单击按钮打开对话框，按钮和模式必须用状态括起来。下面是例子。</p><pre class="me mf mg mh gt mi mc mj mk aw ml bi"><span id="27dc" class="mm jz iq mc b gy mn mo l mp mq">const ModalState = StateProvider(false);</span><span id="05d3" class="mm jz iq mc b gy mr mo l mp mq">const HelloModal = () =&gt; (<br/>  &lt;ModalState&gt;<br/>    {({ state: isOpen, setState: setIsOpen }) =&gt; (<br/>      &lt;div&gt;<br/>        &lt;button onClick={() =&gt; setIsOpen(true)}&gt;Push me&lt;/button&gt;<br/>        &lt;ReactModal<br/>          isOpen={isOpen}<br/>          shouldCloseOnEsc={true}<br/>          onRequestClose={() =&gt; setIsOpen(false)}<br/>          className='modal'<br/>        &gt;<br/>          &lt;p&gt;Hello modal dialog!&lt;/p&gt;<br/>          &lt;button onClick={() =&gt; setIsOpen(false)}&gt;OK&lt;/button&gt;<br/>        &lt;/ReactModal&gt;<br/>      &lt;/div&gt;<br/>    )}<br/>  &lt;/ModalState&gt;<br/>);</span></pre><p id="2808" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">仅此而已。让我们在下面的CodePen上试试吧。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b073" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">你可能会觉得把一个模态放在按钮的同一层很奇怪。这是有意义的，因为这样的实现使得重用组件有点困难。</p><h1 id="414d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">在JSX让对话框以声明方式打开</h1><p id="9b09" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">因为JSX是一种声明式DSL，所以我们可以像这样声明一个带有确认对话框的按钮。</p><pre class="me mf mg mh gt mi mc mj mk aw ml bi"><span id="260e" class="mm jz iq mc b gy mn mo l mp mq">&lt;WithConfirm&gt;<br/>  &lt;button onClick={...)}&gt;Increment&lt;/button&gt;<br/>&lt;/WithConfirm&gt;</span></pre><p id="191b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">封装组件<code class="fe lz ma mb mc b">WithConfirm</code>可以通过这些步骤实现。</p><ul class=""><li id="c80f" class="na nb iq ky b kz lu ld lv lh nc ll nd lp ne lt nf ng nh ni bi translated">从儿童道具中获取<code class="fe lz ma mb mc b">onClick</code>的句柄。</li><li id="5d1e" class="na nb iq ky b kz nj ld nk lh nl ll nm lp nn lt nf ng nh ni bi translated">将处理程序附加到模式对话框的“确定”按钮。</li><li id="d067" class="na nb iq ky b kz nj ld nk lh nl ll nm lp nn lt nf ng nh ni bi translated">用打开模态对话框的处理程序替换儿童道具的<code class="fe lz ma mb mc b">onClick</code>道具。</li></ul><p id="6d21" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">父组件可以通过<code class="fe lz ma mb mc b">children.props</code>访问子组件的道具。将<code class="fe lz ma mb mc b">onClick</code>从孩子身上移除，<code class="fe lz ma mb mc b">React.cloneElement</code>可以用新道具克隆他们。所以，渲染方法应该是这样的。</p><pre class="me mf mg mh gt mi mc mj mk aw ml bi"><span id="d768" class="mm jz iq mc b gy mn mo l mp mq">const newChildren = React.Children.map(children,<br/>  (child) =&gt; React.cloneElement(child, {<br/>    onClick: () =&gt; setIsOpen(true),<br/>  }));</span><span id="0aaf" class="mm jz iq mc b gy mr mo l mp mq">return (<br/>  &lt;&gt;<br/>    {newChildren}<br/>    &lt;ConfirmModal<br/>      isOpen={isOpen}<br/>      setIsOpen={setIsOpen}<br/>      onOkClick={children.props.onClick}<br/>    /&gt;<br/>  &lt;/&gt;<br/>);</span></pre><p id="de8e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这是CodePen上的一个工作示例。试着点击按钮，看看会发生什么。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="b301" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="949c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">乍一看，在React中显示对话框似乎很困难，但是由于React的JSX和声明性，标记可以非常清晰。</p></div></div>    
</body>
</html>