<html>
<head>
<title>Container Image Building with BuildKit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用BuildKit构建容器图像</h1>
<blockquote>原文：<a href="https://itnext.io/container-image-building-with-buildkit-13b283602be0?source=collection_archive---------8-----------------------#2020-06-19">https://itnext.io/container-image-building-with-buildkit-13b283602be0?source=collection_archive---------8-----------------------#2020-06-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><a href="https://www.giantswarm.io/"><div class="gh gi jn"><img src="../Images/e9dc0a20268e4c46e6c1608e05e321d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c4HNBb4AAV1Ua4IkQM1FLA.jpeg"/></div></a></figure><p id="fcc2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这个系列的最后一篇文章中，我们将回到Docker的莫比项目，这是它开始的地方，以及一个名为<a class="ae ks" href="https://github.com/moby/buildkit" rel="noopener ugc nofollow" target="_blank"> BuildKit </a>的子项目。</p><p id="33a1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">BuildKit是Docker的<a class="ae ks" href="https://mobyproject.org/projects/" rel="noopener ugc nofollow" target="_blank">莫比项目</a>提供的第二代映像构建器，从Docker CE 18.09开始提供使用。正如我们在之前的文章中看到的Img builder，BuildKit并不仅限于与Docker一起使用。这是一种通用的映像构建功能，可以作为独立的二进制文件(在守护程序或无守护程序模式下)和库来使用。事实上，BuildKit可以用来构建任何工件(<a class="ae ks" href="https://twitter.com/tonistiigi/status/1047921976763867136" rel="noopener ugc nofollow" target="_blank">而不仅仅是容器图像</a>)，只要构建步骤可以被翻译成它的低级构建器(LLB)表示。我们在这里主要关心容器映像构建，所以让我们看看BuildKit为聚会带来了什么。</p><h1 id="fd51" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">构建步骤优化</h1><p id="faf5" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">Docker提供的原始构建后端最常遇到的挫折之一是Dockerfile指令的构建步骤执行的顺序性。在引入了<a class="ae ks" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">多阶段构建</a>之后，可以将构建步骤分组到同一个docker文件中的独立的逻辑构建任务中。</p><p id="8f22" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有时，这些构建阶段彼此完全独立，这意味着它们可以并行执行，或者根本不需要执行。不幸的是，传统的Docker映像构建体验并不能满足这种灵活性，有时会在不需要的时候执行构建步骤。这意味着构建时间通常比绝对必要的时间要长。</p><p id="8797" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">相反，BuildKit创建了一个构建步骤之间的依赖关系图，并使用它来确定可以忽略哪些构建元素；其可以并行执行；并且需要顺序执行。这提供了更有效的构建执行，这反过来对开发人员来说是有价值的，因为他们为他们的应用程序迭代映像构建。</p><h1 id="42d2" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">高效灵活的缓存</h1><p id="8f80" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">虽然传统Docker映像构建中构建步骤的缓存非常有用，但它并没有达到应有的效率。作为构建后端的重写，BuildKit对此进行了改进，并提供了更快、更准确的缓存机制。它使用为映像构建生成的依赖关系图，并基于指令定义和构建步骤内容。</p><p id="3893" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">BuildKit提供的另一个巨大好处是构建缓存的导入和导出。正如<a class="ae ks" href="https://blog.giantswarm.io/container-image-building-with-kaniko/" rel="noopener ugc nofollow" target="_blank"> Kaniko </a>和<a class="ae ks" href="https://blog.giantswarm.io/container-image-building-with-makisu/" rel="noopener ugc nofollow" target="_blank"> Makisu </a>允许将构建缓存推送到远程注册表，BuildKit也是如此。然而，BuildKit让您可以灵活地将缓存嵌入到映像中(内联),并将它们推到一起(尽管不是每个注册表都支持),或者将它们单独推到一起。还可以将缓存导出到本地目录，供后续使用。</p><p id="4bab" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当构建环境是从零开始构建的，没有以前的构建历史可以利用时，导入构建缓存的能力就有了用武之地。导入会“预热”缓存，对于短暂的CI/CD环境尤其有用。</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><a href="https://www.giantswarm.io/on-demand-webinar-kubernetes-hard-lessons-and-how-to-avoid-them"><div class="gh gi lw"><img src="../Images/586ae4a78029a9b94d460ce073713bdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YhKu8gw5UKqYYuGZ.jpg"/></div></a></figure><h1 id="212e" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">构建工件</h1><p id="b2c4" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">当使用传统的Docker映像构建器构建映像时，生成的映像会被添加到由Docker守护程序管理的本地映像缓存中。需要单独的<code class="fe mb mc md me b">docker push</code>将图像上传到远程容器图像注册中心。再一次，新一代的映像构建工具允许您在构建调用时指定映像推送，从而增强了体验。BuildKit也不例外，它还允许几种不同格式的图像输出；本地目录中的文件、本地tarball、本地OCI映像tarball、Docker映像tarball、存储在本地高速缓存中的Docker映像以及被推送到注册表的Docker映像。那可是好多格式啊！</p><h1 id="ad8b" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">扩展语法</h1><p id="b0cc" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">在<code class="fe mb mc md me b">docker build</code>体验中<a class="ae ks" href="https://github.com/moby/moby/pull/30637" rel="noopener ugc nofollow" target="_blank">经常重复</a>的许多功能要求之一是安全处理镜像构建期间所需的机密。莫比项目抵制这一呼吁多年。但是，利用BuildKit灵活的“前端”定义，为Buildkit提供了一个<a class="ae ks" href="https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/experimental.md" rel="noopener ugc nofollow" target="_blank">实验前端</a>，它扩展了Dockerfile语法。扩展的语法为<code class="fe mb mc md me b">RUN</code> Dockerfile指令提供了有用的补充，其中包括安全特性。</p><p id="c844" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.docker.com/develop/develop-images/build_enhancements/#overriding-default-frontends" rel="noopener ugc nofollow" target="_blank">引用</a>的docker文件实验前端可以为<code class="fe mb mc md me b">RUN</code>指令临时挂载秘密。使用<code class="fe mb mc md me b">docker build</code>的<code class="fe mb mc md me b">--secret</code>标志将秘密提供给构建。类似地，使用ssh挂载类型可以实现SSH代理连接的转发，从而实现安全的SSH身份验证。</p><p id="3395" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以这种方式扩展事实上的Dockerfile语法的能力是BuildKit独有的。</p><h1 id="19d3" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">消费构建工具包</h1><p id="62d6" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">BuildKit还有许多其他特性，这些特性极大地改进了构建容器图像的技巧。如果它是一个适用于许多不同环境的通用工具，如何使用它呢？</p><p id="fc05" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个问题的答案是多种多样的，取决于你工作的环境。让我们看一看。</p><h1 id="2cbf" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">码头工人</h1><p id="07a6" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">鉴于BuildKit是一个莫比项目，它可以作为Docker (v18.09+)的首选构建后端也就不足为奇了。它还不是默认的后端，因为它在Windows平台上不受支持，但在Linux上构建映像时，它很容易打开。</p><p id="b80d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">简单地设置一个环境变量(<code class="fe mb mc md me b">DOCKER_BUILDKIT=1</code>)就可以了，或者将下面的键/值对添加到守护程序的配置文件中以便永久使用；<code class="fe mb mc md me b">"features":{"buildkit": true}</code>。</p><p id="eba2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这种配置中，由于Docker守护进程当前的一些限制，Docker并没有完全展示BuildKit的全部功能。出于这个原因，Docker客户端CLI被扩展为提供插件框架，允许使用插件来扩展可用的CLI功能。一个名为<a class="ae ks" href="https://github.com/docker/buildx" rel="noopener ugc nofollow" target="_blank"> Buildx </a>的实验性插件绕过守护进程中的遗留构建函数，使用BuildKit后端进行所有构建。它提供了所有熟悉的映像构建命令和特性，但是增加了一些特定于BuildKit的附加特性。</p><p id="2c53" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">BuildKit，通过扩展Buildx，支持多个构建器实例。这是生态系统中其他映像构建工具所没有的重要特性。这实际上意味着一群构建器实例可以被共享用于构建目的；也许一个项目被分配了一组构建器实例，而另一个项目得到了一组不同的实例。</p><p id="3d03" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">默认情况下，Buildx插件以<code class="fe mb mc md me b">docker</code>驱动程序为目标，该驱动程序使用Docker守护进程提供的BuildKit库，但有其固有的限制。另一个驱动程序是<code class="fe mb mc md me b">docker-container</code>，它透明地在容器中启动BuildKit来执行构建。它可以提供BuildKit中可用的全部功能。第三个驱动程序是Kubernetes，它使在pods中运行的BuildKit的构建器实例成为映像构建的目标。这一点特别有趣，因为它支持为Kubernetes中运行的BuildKit启动构建——全部从Docker CLI启动。这是否是一个理想的工作流程，完全取决于个人或公司的选择。</p><h1 id="9db5" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">库伯内特斯</h1><p id="b2b4" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">越来越多的组织在短暂的基础设施上实施他们的应用程序工作流。这包括Kubernetes，并且经常看到容器映像构建作为CI/CD工作流的一部分出现在pods中。当谈到在Kubernetes中运行BuildKit实例时，有许多不同的配置可用。每种部署策略都有其优点和缺点，并且适合不同的目的。</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi jn"><img src="../Images/6b2d99f70b80842f77362c019a9437a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*n08JO36soCMYg-zW.png"/></div></div></figure><p id="b9b6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">除了使用Docker CLI为BuildKit启动面向开发人员的构建之外，构建还可以由各种CI/CD工具触发。使用BuildKit构建容器映像可以作为<a class="ae ks" href="https://github.com/tektoncd/pipeline" rel="noopener ugc nofollow" target="_blank"> Tekton管道</a>任务执行，例如<a class="ae ks" href="https://github.com/tektoncd/catalog/tree/master/buildkit" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="57c6" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="a7bc" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">本文没有足够的篇幅来介绍BuildKit提供的其他特性，比如<a class="ae ks" href="https://github.com/docker/buildx#building-multi-platform-images" rel="noopener ugc nofollow" target="_blank">多平台映像</a>和<a class="ae ks" href="https://github.com/moby/buildkit/blob/master/docs/rootless.md" rel="noopener ugc nofollow" target="_blank">无根</a>映像构建。然而，它提供了BuildKit为容器映像构建带来的许多重大改进。</p><p id="674d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="mj">许多新一代的构建工具都试图缓解与传统构建过程相关的问题，而BuildKit则试图更进一步，进行创新。</em></p><p id="1d9e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当然，BuildKit还处于早期，一些特性需要随着社区的采用而成熟和发展。长期以来，一直局限于一个适当但不完美的容器映像构建体验，当面对今天可用的选择时，可能会有点困惑。有些人必然会基于隶属关系做出选择；红帽的Buildah ，谷歌的<a class="ae ks" href="https://blog.giantswarm.io/container-image-building-with-kaniko/" rel="noopener ugc nofollow" target="_blank"> Kaniko </a>，Docker的BuildKit。但是，可以肯定地说，由于现在有了不同的选择，构建容器映像的工作变得更加容易了。快乐形象塑造！</p><p id="33dc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由<a class="ae ks" href="https://twitter.com/puja108" rel="noopener ugc nofollow" target="_blank">Puja Abbas si</a>——开发者倡议@ <a class="ae ks" href="https://giantswarm.io/" rel="noopener ugc nofollow" target="_blank">巨型群体</a>撰写</p></div></div>    
</body>
</html>