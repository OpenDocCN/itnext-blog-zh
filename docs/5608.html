<html>
<head>
<title>Using the Spotify Algorithm to Find High Energy Physics Particles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Spotify算法寻找高能物理粒子</h1>
<blockquote>原文：<a href="https://itnext.io/using-the-spotify-algorithm-to-find-high-energy-physics-particles-1c28f5f37650?source=collection_archive---------2-----------------------#2021-04-15">https://itnext.io/using-the-spotify-algorithm-to-find-high-energy-physics-particles-1c28f5f37650?source=collection_archive---------2-----------------------#2021-04-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9f61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几个步骤，python指南粒子跟踪与近似最近邻库烦扰。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/f0b967b68ebda8d7a0405d71e382859a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xCl8cDqyrb8kP171b_sjjQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">在“桶”中收集相邻粒子碰撞</figcaption></figure><p id="cadf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于用Python处理和可视化粒子的复习，请查看我之前的文章。在高能物理学中追踪粒子就是将同一粒子产生的碰撞连接在一起。在一个典型的<a class="ae lb" href="https://home.cern/science/accelerators/high-luminosity-lhc" rel="noopener ugc nofollow" target="_blank">高光度</a>碰撞事件中，10K粒子产生了10万次碰撞，导致平均粒子大小为10次碰撞。</p><p id="8cc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来的挑战是从一堆看起来相似的10万个点击中把正确的10个连接起来，并且在一秒钟之内完成！这就是我们转向“开箱即用”解决方案的原因，这些解决方案通常用于处理大规模数据集。几百万<strong class="jp ir">歌曲</strong>数据集呢？</p><p id="2091" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在推荐你下一首可能喜欢的歌曲方面，Spotify是无可争议的赢家。这里的计算技巧是在一个非常大的数据库中搜索歌曲之间的相似性，而Spotify的烦人库做得非常优雅。它是开源的，使用简单，有多种语言版本。让我们看看如何用它来寻找光速粒子。</p><p id="e2dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用pip可以快速安装骚扰</p><pre class="km kn ko kp gt lc ld le lf aw lg bi"><span id="c98a" class="lh li iq ld b gy lj lk l ll lm">#Version used in this guide :  1.17.0<br/>pip install annoy</span></pre><p id="8128" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">近似最近邻技术背后的一般思想是返回<em class="ln">近似</em>和<em class="ln">快速</em>最接近查询点的点集。第一步是建立数据集的索引，同时指定用于评估点之间相似性的度量。然后，当进行查询时(图中的x <em class="ln"> 4 </em>，使用近似技术而不是穷举搜索来检索相似点的集合。Annoy使用随机投影来快速绑定数据，这使得搜索速度非常快。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lo"><img src="../Images/e1303687076b040b29941b91392fa3d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lFTrZu1ZhE0Edd14eL-0qg.png"/></div></div></figure><p id="4906" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你还没猜到，我们在粒子追踪中的<em class="ln">邻居</em>将是同一个粒子产生的命中。对数据集的不同查询会产生不同的邻居集合，我们的目标是在每个集合中找到至少一个粒子。我们将使用的碰撞事件同样来自<a class="ae lb" href="https://www.kaggle.com/c/trackml-particle-identification" rel="noopener ugc nofollow" target="_blank">公共TrackML数据集</a>。</p><p id="ec4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要使用Annoy构建索引，我们只需指定每次点击的特征数量和相似性度量。作为第一步，我们将只有一个角距离击中的三维坐标。角距离确保相邻的击中相对于原点对齐。正如后面将要展示的，这是一个非常好的开始标准。接下来，让我们编写一个构建索引并用数据填充它的函数。</p><pre class="km kn ko kp gt lc ld le lf aw lg bi"><span id="3531" class="lh li iq ld b gy lj lk l ll lm">from annoy import AnnoyIndex</span><span id="fd78" class="lh li iq ld b gy lp lk l ll lm">def buildAnnoyIndex(data,metric="angular",ntrees=5):<br/>    f = data.shape[1]<br/>    idx = AnnoyIndex(f,metric)  <br/>    for i,d in enumerate(data):<br/>        idx.add_item(i, d)<br/>    idx.build(ntrees) <br/>    return idx</span></pre><p id="48eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了确保更高的精度，通过参数“ntrees”构建多个随机投影。为了确保更快的搜索，我们只使用了5棵树。</p><p id="d2a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在碰撞事件上建立人工神经网络指数是通过以下几行完成的:</p><pre class="km kn ko kp gt lc ld le lf aw lg bi"><span id="5691" class="lh li iq ld b gy lj lk l ll lm">import pandas as pd</span><span id="4d5f" class="lh li iq ld b gy lp lk l ll lm">data=pd.read_csv("lhc_event.csv")</span><span id="a3e3" class="lh li iq ld b gy lp lk l ll lm">annoy_idx=buildAnnoyIndex(data[["x","y","z"]].values)</span></pre><p id="38b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然数据集存储在“annoy _ idx”变量中，我们就能够执行查询了。允许返回查询命中的近似最近邻的函数如下:</p><pre class="km kn ko kp gt lc ld le lf aw lg bi"><span id="f9ab" class="lh li iq ld b gy lj lk l ll lm">annoy_idx.get_nns_by_item(hit_id,Nb_neighbors)</span></pre><p id="bb75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查询命中通过其在数据集中的索引来指定，并且Nb_neighbors指示要返回的最接近命中的数量。这个函数然后返回近似邻居的索引。也可以通过打开选项参数<code class="fe lq lr ls ld b">include_distances=True</code>返回距离值</p><p id="c0e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当将Nb_neighbors设置为20并随机选择命中索引时，我们得到以下结果:</p><pre class="km kn ko kp gt lc ld le lf aw lg bi"><span id="f797" class="lh li iq ld b gy lj lk l ll lm">hit_id=467<br/>Nb_neighbors=20<br/>annoy_idx.get_nns_by_item(hit_id,Nb_neighbors)<br/>Out : [467, 468, 469, 470, 471, 474, 466, 472, 473, 476, 475, 477, 478, 480, 465, 479, 18519, 18521, 495, 18520]</span></pre><p id="3f6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到与这些“桶”索引相关联的命中如下:</p><pre class="km kn ko kp gt lc ld le lf aw lg bi"><span id="5dc4" class="lh li iq ld b gy lj lk l ll lm">bucket_idx=annoy_idx.get_nns_by_item(hit_id,Nb_neighbors)<br/>data.iloc[bucket_idx]</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lt"><img src="../Images/ba57525d7df206be9ae66edb9c71b108.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d7PnWZYdFtTNGjARCLWTzA.png"/></div></div></figure><p id="97fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原来我们的随机查询命中是一个幸运的电子！注意，数据帧的索引列正是我们的ANN存储桶。我们还可以看到，查询后的点击似乎共享同一个particle_id=774646073942605824。这意味着我们的人工神经网络查询检索到了由同一个粒子产生的命中结果:一个电子。</p><p id="159f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们检查一下桶中这些电子击中的准确数量:(计数器功能在<a class="ae lb" href="https://greysab.medium.com/10-ways-of-analyzing-high-energy-particles-with-python-329b736817dd" rel="noopener">上一篇文章</a>中介绍过)</p><pre class="km kn ko kp gt lc ld le lf aw lg bi"><span id="5ba1" class="lh li iq ld b gy lj lk l ll lm">from collections import Counter</span><span id="6892" class="lh li iq ld b gy lp lk l ll lm">Counter(data.iloc[bucket_idx].particle_id)<br/>Counter({<strong class="ld ir">774646073942605824</strong>: <strong class="ld ir">16</strong>, 945764717840826368: 3, 409834231879958528: 1})</span></pre><p id="62e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">答对了。我们在一个20次击中的桶中找回了16次击中的电子！但这是这个粒子产生的总命中数吗？</p><pre class="km kn ko kp gt lc ld le lf aw lg bi"><span id="4564" class="lh li iq ld b gy lj lk l ll lm">len(data[data.particle_id==<strong class="ld ir">774646073942605824])<br/></strong>Out : 16</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lu"><img src="../Images/fb8eecc8ec8a801593951b6f3bc7bba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rrJRpZhTC8tTIohSoUeCHQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">20个命中(红点)的ANN桶和由线表示的最大粒子。TrackML探测器的横向视图。</figcaption></figure><p id="33d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，确实所有的电子痕迹都在这个桶里。这是一个幸运的场景吗？当询问20个邻居时，我们实际得到的<em class="ln">平均</em>粒子大小是多少？让我们看看所有可能的人工神经网络查询中最大颗粒尺寸的分布。</p><p id="dc5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过简单地在每个查询中存储最大计数<em class="ln">来做到这一点，类似于我们对电子桶所做的可视化操作。在计数器上使用most_common()函数可以只返回最大颗粒的id和尺寸。这个函数大约需要40秒，因为命中次数非常多，Counter()不是最快的选项(但它是最好的)。</em></p><pre class="km kn ko kp gt lc ld le lf aw lg bi"><span id="a98d" class="lh li iq ld b gy lj lk l ll lm">largest_particle_size=[]</span><span id="2c76" class="lh li iq ld b gy lp lk l ll lm">for i in data.index.values:<br/>   bucket_idx=annoy_idx.get_nns_by_item(i,Nb_neighbors)</span><span id="6d21" class="lh li iq ld b gy lp lk l ll lm">   c=Counter(data.iloc[bucket_idx].particle_id).most_common(1)[0][1]         </span><span id="eded" class="lh li iq ld b gy lp lk l ll lm">   largest_particle_size.append(c)</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lu"><img src="../Images/a25f21bb7a8b07f3d1943a71d70ea60e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FugPG7Kv7thFo0OxDWbohw.png"/></div></div></figure><p id="8a5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实证明，在20命中的安桶中获得16命中的粒子是有点幸运的。不到1K个查询包含如此高数量的相同粒子命中。大多数人工神经网络桶包含3、2和4次击中的粒子轨迹。但是，如果我们尝试将查询的邻居数量从20增加到… 50，分布就会发生变化！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lu"><img src="../Images/20279b668611b2034711b666c7bbe079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XC3d5tJtcczSj7eN-IZvRQ.png"/></div></div></figure><p id="6935" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，大多数桶包含由同一粒子产生的4次和5次点击。总体分布很好地向右移动，允许包含更大的迹线。</p><p id="dc91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Annoy librabry进行50次10K(大约是一个事件中的粒子数)查询需要<strong class="jp ir">400毫秒</strong>。我们是否可以进一步优化人工神经网络查询，使其仅包含大量的粒子痕迹？</p><p id="dfe6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，我们只研究了按角度距离构建的ANN桶。有更好的选择吗？敬请关注下期帖子！</p><p id="51a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完整的代码可以在github.com/greysab/pyhep的<a class="ae lb" href="https://github.com/greysab/pyhep/blob/main/ann_hep.ipynb" rel="noopener ugc nofollow" target="_blank">找到</a></p></div></div>    
</body>
</html>