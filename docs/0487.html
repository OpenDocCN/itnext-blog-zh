<html>
<head>
<title>How not to suffer with APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何不受API的困扰</h1>
<blockquote>原文：<a href="https://itnext.io/how-not-to-suffer-with-apis-8aa75f890fe6?source=collection_archive---------2-----------------------#2018-03-17">https://itnext.io/how-not-to-suffer-with-apis-8aa75f890fe6?source=collection_archive---------2-----------------------#2018-03-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8d1d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">重新思考Apicase和为什么我仍然没有使用axios</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/04493507765ac99f60ea83e54dd5e1f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hkGSiwxTKK1YWl0s47zU5w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">典型OAuth</figcaption></figure><blockquote class="kv kw kx"><p id="b36d" class="ky kz la lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><a class="ae lv" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fhow-not-to-suffer-with-apis-8aa75f890fe6" rel="noopener ugc nofollow" target="_blank">点击这里在LinkedIn上分享这篇文章</a></p></blockquote><p id="78b8" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">每天我都会看到这样的问题<em class="la">“如何使用API？”</em>、<em class="la">“能不能给点最佳做法”</em>、<em class="la">“如何烹饪axios”</em>前台聊天。他们得到了很多答案，但都可以归纳为三种类型</p><h2 id="2386" class="lz ma iq bd mb mc md dn me mf mg dp mh lw mi mj mk lx ml mm mn ly mo mp mq mr bi translated">–获取足够了</h2><p id="4af9" class="pw-post-body-paragraph ky kz iq lb b lc ms jr le lf mt ju lh lw mu lk ll lx mv lo lp ly mw ls lt lu ij bi translated">致命的错误。大量的样板代码保证，我没有更多要说的</p><h2 id="083e" class="lz ma iq bd mb mc md dn me mf mg dp mh lw mi mj mk lx ml mm mn ly mo mp mq mr bi translated">–Axios很好，受到社区的推荐</h2><p id="b663" class="pw-post-body-paragraph ky kz iq lb b lc ms jr le lf mt ju lh lw mu lk ll lx mv lo lp ly mw ls lt lu ij bi translated">有的人就是用axios，不在乎。在我看来，它只在“Hello world”示例上看起来不错。当我们想更深入时，我们需要编写自己的包装器、处理程序等。而上面的问题就来了。</p><h2 id="f9d8" class="lz ma iq bd mb mc md dn me mf mg dp mh lw mi mj mk lx ml mm mn ly mo mp mq mr bi translated">–我写了我的包装，它不是最好的，但对我的案例来说足够了</h2><p id="1322" class="pw-post-body-paragraph ky kz iq lb b lc ms jr le lf mt ju lh lw mu lk ll lx mv lo lp ly mw ls lt lu ij bi translated"><em class="la">针对您的案例。</em>有些人分享他们的包装函数甚至类但是看起来还是很丑。通常只是axios调用被封装到一个函数中，用于检查auth、处理响应等。它非常具体，仅涵盖他们的使用案例，不能用于其他应用程序。</p><p id="c3cf" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">看起来，这么长时间过去了，我们有了非常酷的框架来使用view，我们有了非常酷的库来进行状态管理，但是…</p><blockquote class="mx"><p id="e3b3" class="my mz iq bd na nb nc nd ne nf ng lu dk translated">我们仍然没有统一的工具来轻松地使用API</p></blockquote><h1 id="b467" class="nh ma iq bd mb ni nj nk me nl nm nn mh jw no jx mk jz np ka mn kc nq kd mq nr bi translated">介绍Apicase</h1><p id="9350" class="pw-post-body-paragraph ky kz iq lb b lc ms jr le lf mt ju lh lw mu lk ll lx mv lo lp ly mw ls lt lu ij bi translated">Apicase是一个强大的库，它将API的大部分工作转移到一个独立的层。它基于4个原则</p><ul class=""><li id="5e5f" class="ns nt iq lb b lc ld lf lg lw nu lx nv ly nw lu nx ny nz oa bi translated"><strong class="lb ir">基于事件的</strong>请求处理</li><li id="b6be" class="ns nt iq lb b lc ob lf oc lw od lx oe ly of lu nx ny nz oa bi translated"><strong class="lb ir">中间件</strong>更新/动态更改/撤销/重做API调用</li><li id="880a" class="ns nt iq lb b lc ob lf oc lw od lx oe ly of lu nx ny nz oa bi translated"><strong class="lb ir">无限继承的服务</strong></li><li id="97d8" class="ns nt iq lb b lc ob lf oc lw od lx oe ly of lu nx ny nz oa bi translated"><strong class="lb ir">适配器</strong>代替具体工具(fetch/xhr)</li></ul><p id="1d3f" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">所以，我不想深究理论和歌词，还是深潜一下，试着写点请求吧。</p><h1 id="a3a8" class="nh ma iq bd mb ni nj nk me nl nm nn mh jw og jx mk jz oh ka mn kc oi kd mq nr bi translated">入门指南</h1><h2 id="ecb1" class="lz ma iq bd mb mc md dn me mf mg dp mh lw mi mj mk lx ml mm mn ly mo mp mq mr bi translated">装置</h2><p id="aa6e" class="pw-post-body-paragraph ky kz iq lb b lc ms jr le lf mt ju lh lw mu lk ll lx mv lo lp ly mw ls lt lu ij bi translated">用你最喜欢的包管理器(npm，yarn，pnpm，或者一匹穿外套的马)安装它</p><pre class="kg kh ki kj gt oj ok ol om aw on bi"><span id="2dc8" class="lz ma iq ok b gy oo op l oq or">npm install @apicase/core @apicase/adapter-fetch</span></pre><p id="3f7d" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">我一般用fetch，但是如果你想要xhr，可以安装<code class="fe os ot ou ok b">@apicase/adapter-xhr</code>代替。别担心，两者都有相同的API。</p><p id="60bd" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">然后，我们需要将适配器包装到<code class="fe os ot ou ok b">apicase</code>中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">我认为很简单</figcaption></figure><p id="5357" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">已经可以用了。让我们现在就使用它</p><h2 id="2ec1" class="lz ma iq bd mb mc md dn me mf mg dp mh lw mi mj mk lx ml mm mn ly mo mp mq mr bi translated">基于事件的API的简单请求</h2><p id="59b1" class="pw-post-body-paragraph ky kz iq lb b lc ms jr le lf mt ju lh lw mu lk ll lx mv lo lp ly mw ls lt lu ij bi translated">因此，最简单的请求如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="ak">获取</strong> /api/posts，处理该请求的事件</figcaption></figure><p id="d660" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">为什么不只是<code class="fe os ot ou ok b">.then()</code>和<code class="fe os ot ou ok b">.catch()</code>？</p><p id="cea9" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">Apicase遵循<em class="la">“业务逻辑失败不例外”</em>原则。这意味着您的请求至少需要3个状态。承诺只有两个——成功或失败。事件允许您处理尽可能多的事情。喜欢</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">针对任何用例的独立事件—不再需要<code class="fe os ot ou ok b"><strong class="ak">if (err instanceof Error)</strong></code></figcaption></figure><p id="6696" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">你仍然可以使用<code class="fe os ot ou ok b">async/await</code>，当然，我给你留了这个，我的小语法糖爱好者:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="8552" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated"><strong class="lb ir">注意:</strong>承诺只有在<code class="fe os ot ou ok b">error</code>发生时才会被拒绝。否则会正面解决。</p><p id="5940" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">带有<code class="fe os ot ou ok b">apicase</code>的简单请求看起来类似于axios请求:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">获取/XHR适配器使用<a class="ae lv" href="https://github.com/pillarjs/path-to-regexp" rel="noopener ugc nofollow" target="_blank"><strong class="ak">path-to-regexp</strong></a>来处理参数。还有查询字符串的查询选项</figcaption></figure><p id="69d7" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">就这些吗？当然不是。</p><h1 id="b31f" class="nh ma iq bd mb ni nj nk me nl nm nn mh jw og jx mk jz oh ka mn kc oi kd mq nr bi translated">“创建帖子”示例</h1><h2 id="4223" class="lz ma iq bd mb mc md dn me mf mg dp mh lw mi mj mk lx ml mm mn ly mo mp mq mr bi translated">Apicase服务</h2><p id="4ca8" class="pw-post-body-paragraph ky kz iq lb b lc ms jr le lf mt ju lh lw mu lk ll lx mv lo lp ly mw ls lt lu ij bi translated">所以，就像我之前说的，当我们深入下去的时候，axios是不够的。这只是让我们写了很多样板代码或包装成函数。</p><p id="1b31" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">所以，我们不想写重复的请求数据部分(在前面的例子中:<code class="fe os ot ou ok b">url</code>、<code class="fe os ot ou ok b">method</code>、<code class="fe os ot ou ok b">headers</code>)。让我们创建一个服务！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">现在，您可以减少商店活动计数(尤其是在Vuex中)。因为它是API层逻辑，而不是存储</figcaption></figure><p id="986e" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">此外，服务可以根据您的需要进行扩展，因此您可以这样做:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="87b9" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">我打赌它已经有了比你组织API更有趣的工作方式。但这还不是全部。</p><p id="1203" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">因此，我们减少了一些样板代码。但是这里我们静态地传递了我们的<code class="fe os ot ou ok b">token</code>。永远不会变。所以，钩子就是来解决你的问题的。</p><h2 id="2404" class="lz ma iq bd mb mc md dn me mf mg dp mh lw mi mj mk lx ml mm mn ly mo mp mq mr bi translated">蜂箱挂钩</h2><p id="1f19" class="pw-post-body-paragraph ky kz iq lb b lc ms jr le lf mt ju lh lw mu lk ll lx mv lo lp ly mw ls lt lu ij bi translated">钩子在某个时刻拦截请求，并可能修改请求<em class="la">有效载荷</em>、<em class="la">响应</em>，取消请求或重试请求，进行另一个请求等。像axios拦截器，但更好。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="ak">前</strong>钩子修改请求前请求有效载荷</figcaption></figure><p id="1c30" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">看起来很简单——我们只需添加将<code class="fe os ot ou ok b">token</code>添加到标题的<code class="fe os ot ou ok b">before</code>钩子，然后进入下一步。</p><p id="5fc3" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">我们能做得更好吗？当然啦！我们可以将它移动到我们的根服务，然后继承它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="2fef" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">如果我们不需要到处传递auth token呢？Apicase有传递给钩子的<code class="fe os ot ou ok b">meta</code>选项。喜欢<code class="fe os ot ou ok b">vue-router</code>有，如果你知道:)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="a02d" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">所以，这里<code class="fe os ot ou ok b">GetProfile</code>服务不会有令牌传递。</p><p id="2d8e" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">还有别的吗？当然，因为我能做到！</p><h1 id="de8e" class="nh ma iq bd mb ni nj nk me nl nm nn mh jw og jx mk jz oh ka mn kc oi kd mq nr bi translated">成为硬核</h1><h2 id="5c73" class="lz ma iq bd mb mc md dn me mf mg dp mh lw mi mj mk lx ml mm mn ly mo mp mq mr bi translated">“刷新令牌”不再痛苦</h2><p id="0de0" class="pw-post-body-paragraph ky kz iq lb b lc ms jr le lf mt ju lh lw mu lk ll lx mv lo lp ly mw ls lt lu ij bi translated">因此，让我们假设我们有需要auth token的API。如果我们收到401错误，我们可以尝试在特定路由内刷新令牌。典型的oAuth。</p><p id="991a" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">我们可以不用任何样板代码，只用钩子就可以做到。</p><p id="b02e" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">因为钩子是异步的，我们可以在那里做另一个请求。我们还可以将请求状态从失败更改为成功，反之亦然。看这个:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">你的解决方案和这个一样可靠吗？</figcaption></figure><p id="801c" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">因此，如果请求以401状态失败，我们将尝试刷新令牌。如果没问题，请求再次开始，应用程序中没有额外的操作和处理。</p><h2 id="7845" class="lz ma iq bd mb mc md dn me mf mg dp mh lw mi mj mk lx ml mm mn ly mo mp mq mr bi translated">更难！两个请求同时失败</h2><p id="1faa" class="pw-post-body-paragraph ky kz iq lb b lc ms jr le lf mt ju lh lw mu lk ll lx mv lo lp ly mw ls lt lu ij bi translated">哦耶！您有两个并发的API请求，但都失败了。他们都将尝试刷新令牌，但我们只需要一个。</p><p id="bd09" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">重写以前的代码？创造一个自行车？Lol，我只用一个字就能搞定。不信？请看:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="ak">第26行。</strong>剂量请求</figcaption></figure><p id="729c" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">服务的请求队列中包含当前正在运行的请求。他们也有一些有用的方法:</p><ul class=""><li id="e839" class="ns nt iq lb b lc ld lf lg lw nu lx nv ly nw lu nx ny nz oa bi translated"><code class="fe os ot ou ok b">doRequest</code> —只需启动请求并将其添加到队列中</li><li id="dda9" class="ns nt iq lb b lc ob lf oc lw od lx oe ly of lu nx ny nz oa bi translated"><code class="fe os ot ou ok b">pushRequest</code> —仅在队列清空后创建新请求</li><li id="01db" class="ns nt iq lb b lc ob lf oc lw od lx oe ly of lu nx ny nz oa bi translated"><code class="fe os ot ou ok b">doSingleRequest</code> —仅当<strong class="lb ir">没有</strong>个当前正在运行的请求时，才创建一个新请求。否则，<em class="la">返回当前运行的请求</em>。</li><li id="cfdc" class="ns nt iq lb b lc ob lf oc lw od lx oe ly of lu nx ny nz oa bi translated"><code class="fe os ot ou ok b">doUniqueRequest</code> —仅当<strong class="lb ir">没有</strong>当前正在运行的请求<strong class="lb ir">具有相同的</strong> <code class="fe os ot ou ok b">payload</code>时，才创建新的请求。否则，<em class="la">返回这个当前运行的请求</em>。</li></ul><p id="ccb4" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">您只需创建请求或监听当前正在运行的请求。那不是很美吗？</p><p id="b753" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">完成？不要！</p><h1 id="1f3b" class="nh ma iq bd mb ni nj nk me nl nm nn mh jw og jx mk jz oh ka mn kc oi kd mq nr bi translated">请求取消</h1><p id="38c6" class="pw-post-body-paragraph ky kz iq lb b lc ms jr le lf mt ju lh lw mu lk ll lx mv lo lp ly mw ls lt lu ij bi translated">没有更多的低劣取消令牌，只是<code class="fe os ot ou ok b">.cancel()</code>它</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="fe07" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated"><strong class="lb ir"> XHR </strong>适配器使用<code class="fe os ot ou ok b">xhr.abort()</code>取消请求<br/> <strong class="lb ir">获取</strong>适配器使用新的<code class="fe os ot ou ok b"><a class="ae lv" href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController" rel="noopener ugc nofollow" target="_blank">AbortController</a></code>(如果可用)</p><h1 id="2067" class="nh ma iq bd mb ni nj nk me nl nm nn mh jw og jx mk jz oh ka mn kc oi kd mq nr bi translated">请求队列</h1><p id="b7a9" class="pw-post-body-paragraph ky kz iq lb b lc ms jr le lf mt ju lh lw mu lk ll lx mv lo lp ly mw ls lt lu ij bi translated">想创建一个同步的请求队列吗？动手吧，兄弟:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">不到30行代码的Apicase队列解释</figcaption></figure><h2 id="8ec9" class="lz ma iq bd mb mc md dn me mf mg dp mh lw mi mj mk lx ml mm mn ly mo mp mq mr bi translated">延迟/限时/去抖请求</h2><p id="2efb" class="pw-post-body-paragraph ky kz iq lb b lc ms jr le lf mt ju lh lw mu lk ll lx mv lo lp ly mw ls lt lu ij bi translated">Requests具有options属性和一些coll things:</p><ul class=""><li id="2cd7" class="ns nt iq lb b lc ld lf lg lw nu lx nv ly nw lu nx ny nz oa bi translated"><strong class="lb ir">立即:</strong>设置为<code class="fe os ot ou ok b">false</code>，请求不会自动开始。你必须使用<code class="fe os ot ou ok b">.start()</code>手动启动它</li><li id="f336" class="ns nt iq lb b lc ob lf oc lw od lx oe ly of lu nx ny nz oa bi translated"><strong class="lb ir">延迟:</strong>延迟就好。请求将在N毫秒后开始(也适用于自动)</li><li id="6cab" class="ns nt iq lb b lc ob lf oc lw od lx oe ly of lu nx ny nz oa bi translated"><strong class="lb ir">去抖:</strong>经典去抖。对于从服务器自动完成很有用——创建请求，然后<code class="fe os ot ou ok b">.start()</code>延迟N毫秒。如果它在时间到之前被调用—重新启动计时器</li><li id="efe5" class="ns nt iq lb b lc ob lf oc lw od lx oe ly of lu nx ny nz oa bi translated"><strong class="lb ir">超时:</strong>如果您想为请求添加时间限制，您可以使用此选项。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">去抖请求示例</figcaption></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">超时示例</figcaption></figure><h1 id="c96c" class="nh ma iq bd mb ni nj nk me nl nm nn mh jw og jx mk jz oh ka mn kc oi kd mq nr bi translated">服务树插件</h1><p id="6e9e" class="pw-post-body-paragraph ky kz iq lb b lc ms jr le lf mt ju lh lw mu lk ll lx mv lo lp ly mw ls lt lu ij bi translated">服务创造可能看起来巨大而怪异。我做了一个小工具，允许使用一个JSON对象来声明服务:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="761a" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">你也可以传递钩子，元，选项。此外，还有<code class="fe os ot ou ok b">on</code>属性来传递事件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="b921" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">而且，如果你想要相当干净的结构，你可以使用<code class="fe os ot ou ok b">rest</code>和<code class="fe os ot ou ok b">restWrapped</code>助手:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div></figure><h1 id="7d03" class="nh ma iq bd mb ni nj nk me nl nm nn mh jw og jx mk jz oh ka mn kc oi kd mq nr bi translated">路标</h1><p id="942f" class="pw-post-body-paragraph ky kz iq lb b lc ms jr le lf mt ju lh lw mu lk ll lx mv lo lp ly mw ls lt lu ij bi translated">做如此庞大的工作，路途是如此遥远。我尝试从头开始做了至少4次。现在看起来很强大(至少，对我来说)。我对Apicase的未来计划:</p><ul class=""><li id="29b7" class="ns nt iq lb b lc ld lf lg lw nu lx nv ly nw lu nx ny nz oa bi translated"><strong class="lb ir">规范和标准化API: </strong>我觉得有些东西不够严格。我也可以跳过一些错误。在1.0发布之前，我会继续努力。</li><li id="f259" class="ns nt iq lb b lc ob lf oc lw od lx oe ly of lu nx ny nz oa bi translated">创建devtools: 最重要的特性——带有请求日志、服务可视化等的Chrome插件</li><li id="a08d" class="ns nt iq lb b lc ob lf oc lw od lx oe ly of lu nx ny nz oa bi translated"><strong class="lb ir">TS/Flow的类型:</strong>有一个悲伤的时刻——由于钩子的缘故，Apicase可能没有响应的类型。但是请求的类型可能创建得很好。</li><li id="f35c" class="ns nt iq lb b lc ob lf oc lw od lx oe ly of lu nx ny nz oa bi translated"><strong class="lb ir">更多简化工作的工具:</strong>我还想创建更多的助手工具(比如<em class="la">服务</em>)，让使用API工作更加舒适。</li></ul><h1 id="7cfe" class="nh ma iq bd mb ni nj nk me nl nm nn mh jw og jx mk jz oh ka mn kc oi kd mq nr bi translated">链接</h1><p id="c86d" class="pw-post-body-paragraph ky kz iq lb b lc ms jr le lf mt ju lh lw mu lk ll lx mv lo lp ly mw ls lt lu ij bi translated">Apicase文档:<a class="ae lv" href="https://kelin2025.gitbooks.io/apicase/content/" rel="noopener ugc nofollow" target="_blank">点击这里</a>(还在进行中)<br/> Github repos: <a class="ae lv" href="https://github.com/apicase/core" rel="noopener ugc nofollow" target="_blank"> core </a>，<a class="ae lv" href="https://github.com/apicase/adapter-fetch" rel="noopener ugc nofollow" target="_blank"> adapter-fetch </a>，<a class="ae lv" href="https://github.com/apicase/adapter-xhr" rel="noopener ugc nofollow" target="_blank"> adapter-xhr </a>，<a class="ae lv" href="https://github.com/apicase/services" rel="noopener ugc nofollow" target="_blank"> services </a> <br/>我的无聊推特:<a class="ae lv" href="http://twitter.com/kelin2025" rel="noopener ugc nofollow" target="_blank">关注我</a></p></div></div>    
</body>
</html>