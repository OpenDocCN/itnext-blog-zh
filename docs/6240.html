<html>
<head>
<title>Simple &amp; intelligible numbered pagination in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单易懂的角度编号分页</h1>
<blockquote>原文：<a href="https://itnext.io/simple-intelligible-numbered-pagination-in-angular-66dbed73e2d7?source=collection_archive---------1-----------------------#2021-09-28">https://itnext.io/simple-intelligible-numbered-pagination-in-angular-66dbed73e2d7?source=collection_archive---------1-----------------------#2021-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/09c5ce46d1d436a376d61e959b997f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*51Gj9imNGZS8j_ffWXSMKQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@studiomediainc?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">工作室媒体</a>在<a class="ae kc" href="https://unsplash.com/s/photos/book?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="5c4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你在你的应用程序中使用<a class="ae kc" href="https://material.angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular Material </a>组件，你可能已经注意到它们的<a class="ae kc" href="https://material.angular.io/components/paginator/overview" rel="noopener ugc nofollow" target="_blank">分页器</a>有一个非常小但可扩展的API。然而，有时候避免导入一个完整的角度材质模块和<em class="lb">修改</em>API来满足你的需求是有意义的。</p><p id="e415" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将使用Angular和<a class="ae kc" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数式编程</a>，用最少的代码构建一个非常简单的编号分页。我们将从定义我们的需求开始，然后打破这个过程的每一步来创建简单的内联分页，您可以用它来进行前端和后端分页。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="02ae" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">要求</h1><p id="e385" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">当你构建一个模块或组件时，你需要知道需求是什么。在设计方面，它可以改变一切。对于这种编号分页，我们需要:</p><ol class=""><li id="f578" class="mm mn iq kf b kg kh kk kl ko mo ks mp kw mq la mr ms mt mu bi translated">创建最少的信息<em class="lb">关闭</em>分页:开始索引，每页的总项数和结果数。</li><li id="d4b1" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">分页组件上显示的最少信息:页面上显示的数字数(标尺)。</li><li id="876f" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">显示第一个、最后一个、上一个和下一个按钮。当然，还有基于标尺的编号分页。</li><li id="9b59" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">光标(活动页面)在标尺上移动时的自然行为。</li><li id="4db0" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">仅当页面实际发生变化时发出页面变化事件<strong class="kf ir">。</strong></li><li id="50f3" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">符合<a class="ae kc" href="https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design" rel="noopener ugc nofollow" target="_blank">坚实</a>的原则。</li><li id="20a3" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">尽可能小，但要容易理解。</li></ol></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="c481" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">第一步</h1><p id="185a" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">首先，我们需要创建一个<a class="ae kc" href="https://angular.io/guide/ngmodules" rel="noopener ugc nofollow" target="_blank">角度模块</a>来保存编号分页的所有逻辑。我们会尽可能地缩小规模:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="c080" class="nj lk iq nf b gy nk nl l nm nn"><em class="lb">import</em> { NgModule } <em class="lb">from</em> '@angular/core';<br/><em class="lb">import</em> { CommonModule } <em class="lb">from</em> '@angular/common';</span><span id="1fbb" class="nj lk iq nf b gy no nl l nm nn">@NgModule({<br/>  imports: [CommonModule],<br/>  declarations: [],<br/>  exports: [],<br/>})</span><span id="c3a6" class="nj lk iq nf b gy no nl l nm nn"><em class="lb">export</em> class NumberedPaginationModule {}</span></pre><p id="18e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据你的栈，这个模块要么放在你的<code class="fe np nq nr nf b">shared/</code>文件夹中，要么作为你的UI库的一部分。</p><p id="fe30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们有了这个模块，我们就可以创建我们的组件。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="0d02" class="nj lk iq nf b gy nk nl l nm nn"><em class="lb">import</em> { Component, ChangeDetectionStrategy, Input, Output } <em class="lb">from</em> '@angular/core';</span><span id="5dcc" class="nj lk iq nf b gy no nl l nm nn">@Component({<br/>  selector: 'numbered-pagination',<br/>  templateUrl: './numbered-pagination.component.html',<br/>  styleUrls: ['./numbered-pagination.component.scss'],<br/>  changeDetection: ChangeDetectionStrategy.OnPush,<br/>})</span><span id="586a" class="nj lk iq nf b gy no nl l nm nn"><em class="lb">export</em> class NumberedPaginationComponent {</span><span id="02e4" class="nj lk iq nf b gy no nl l nm nn">  maxPages: number;</span><span id="9ff4" class="nj lk iq nf b gy no nl l nm nn">  @Input() index: number;<br/>  @Input() totalCount: number;<br/>  @Input() pageSize: number;<br/>  @Input() rulerLength: number;</span><span id="a730" class="nj lk iq nf b gy no nl l nm nn">}</span></pre><p id="f076" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本上，我们拥有创建分页组件所需的所有变量，其中:</p><blockquote class="ns nt nu"><p id="0297" class="kd ke lb kf b kg kh ki kj kk kl km kn nv kp kq kr nw kt ku kv nx kx ky kz la ij bi translated"><code class="fe np nq nr nf b"><em class="iq">maxPages</em></code> <em class="iq">代表我们分页的最后一页<br/> </em> <code class="fe np nq nr nf b"><em class="iq">index</em></code> <em class="iq">是活动页面<br/> </em> <code class="fe np nq nr nf b"><em class="iq">totalCount</em></code> <em class="iq">是项目总数<br/> </em> <code class="fe np nq nr nf b"><em class="iq">pageSize</em></code> <em class="iq">是每页的结果数<br/> </em> <code class="fe np nq nr nf b"><em class="iq">rulerLength</em></code> <em class="iq">是标尺上显示的页数</em></p></blockquote><p id="e093" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，<code class="fe np nq nr nf b">maxPages</code>不是<code class="fe np nq nr nf b">@Input()</code>，因为定义最大页数是<code class="fe np nq nr nf b">NumberedPaginationComponent</code>的职责。</p><p id="3412" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们的分页不仅仅是内联的T30，而是由路由定义的，那么将<code class="fe np nq nr nf b">index</code>作为<code class="fe np nq nr nf b">@Input()</code>将启用动态分页。</p><p id="3de5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在将在模块中注册我们的组件。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="ba67" class="nj lk iq nf b gy nk nl l nm nn"><em class="lb">import</em> { NgModule } <em class="lb">from</em> '@angular/core';<br/><em class="lb">import</em> { CommonModule } <em class="lb">from</em> '@angular/common';<br/><em class="lb">import</em> { NumberedPaginationComponent } <em class="lb">from</em> './components';</span><span id="e1af" class="nj lk iq nf b gy no nl l nm nn">@NgModule({<br/>  imports: [CommonModule],<br/>  declarations: [NumberedPaginationComponent]<br/>  exports: [NumberedPaginationComponent],<br/>})</span><span id="95bc" class="nj lk iq nf b gy no nl l nm nn"><em class="lb">export</em> class NumberedPaginationModule {}</span></pre><p id="896c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模块现在完全准备好了🎉</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="4a5d" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">第二步</h1><p id="be5d" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">现在我们的<code class="fe np nq nr nf b">NumberedPaginationModule</code>已经可以导入了。我们需要在我们的部分上下功夫。我们已经看到我们的组件有几个<code class="fe np nq nr nf b">@Input()</code>，但我们现在将设置一些默认值，以便符合TypeScript严格模式，因为我们希望为我们的分页提供一些预设。</p><p id="e3c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还希望在页面更改时发出一个事件，所以我们将添加一个简单的<code class="fe np nq nr nf b">@Output()</code>来通知父组件要加载的页面。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="32af" class="nj lk iq nf b gy nk nl l nm nn"><em class="lb">import</em> { Component, ChangeDetectionStrategy, EventEmitter, Input, Output } <em class="lb">from</em> '@angular/core';</span><span id="df96" class="nj lk iq nf b gy no nl l nm nn">@Component({<br/>  selector: 'numbered-pagination',<br/>  templateUrl: './numbered-pagination.component.html',<br/>  styleUrls: ['./numbered-pagination.component.scss'],<br/>  changeDetection: ChangeDetectionStrategy.OnPush,<br/>})</span><span id="c410" class="nj lk iq nf b gy no nl l nm nn"><em class="lb">export</em> class NumberedPaginationComponent {</span><span id="32e8" class="nj lk iq nf b gy no nl l nm nn">  maxPages: number = 0;</span><span id="1b35" class="nj lk iq nf b gy no nl l nm nn">  @Input() index: number = 1;<br/>  @Input() totalCount: number = 100;<br/>  @Input() pageSize: number = 5;<br/>  @Input() rulerLength: number = 5;</span><span id="cb47" class="nj lk iq nf b gy no nl l nm nn">  @Output() page: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;();</span><span id="ce79" class="nj lk iq nf b gy no nl l nm nn">  constructor() {<br/><em class="lb">    </em>this.maxPages = Math.ceil(this.totalCount / this.pageSize);<br/>  }</span><span id="a36b" class="nj lk iq nf b gy no nl l nm nn">}</span></pre><p id="7f3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于这个例子，我将在构造函数中设置<code class="fe np nq nr nf b">maxPages</code>。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="3e54" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">第三步</h1><p id="7b2a" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">到目前为止，我们已经满足了构建编号分页的前两个需求。让我们继续第三个，模板。</p><p id="8ece" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不打算详细说明，因为阅读和理解正在发生的事情是非常容易理解和简单的。我将只分享HTML和界面结果。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="0856" class="nj lk iq nf b gy nk nl l nm nn">&lt;ol <em class="lb">class</em>="pagination-container"&gt;<br/>&lt;li <em class="lb">(click)</em>="navigateToPage(1)"&gt;First page&lt;/li&gt;<br/>&lt;li <em class="lb">(click)</em>="navigateToPage(index - 1)"&gt;Previous page&lt;/li&gt;<br/>&lt;li<br/>  <em class="lb">*ngFor</em>="let page of pagination.pages; trackBy: trackByFn"<br/>  <em class="lb">class</em>="pagination-number"<br/>  <em class="lb">[class.active]</em>="page === pagination.index"<br/>  <em class="lb">(click)</em>="navigateToPage(page)"&gt;<br/>    {{ page }}<br/>&lt;/li&gt;<br/>&lt;li <em class="lb">(click)</em>="navigateToPage(index + 1)"&gt;Next page&lt;/li&gt;<br/>&lt;li <em class="lb">(click)</em>="navigateToPage(maxPages)"&gt;Last page&lt;/li&gt;<br/>&lt;/ol&gt;</span></pre><blockquote class="ns nt nu"><p id="c08a" class="kd ke lb kf b kg kh ki kj kk kl km kn nv kp kq kr nw kt ku kv nx kx ky kz la ij bi translated"><code class="fe np nq nr nf b"><em class="iq">navigateToPage(n)</em></code> <em class="iq">会处理导航并发出事件<br/> </em> <code class="fe np nq nr nf b"><em class="iq">trackByFn</em></code> <em class="iq">会帮助渲染引擎画得更快</em>~超俗化init？</p></blockquote><p id="0ca7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过一些小的设计，我们会得到这样的东西:</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/c1dde5179aae5600faf8fd995afad715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-muEdNCl_PeHVRIc3uLbYQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">标尺是标签之间的部分</figcaption></figure></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="a557" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">第四步</h1><p id="a23b" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">是时候回到我们的组件了。基于我们在本文开头定义的需求，我们已经讨论了数字1到3。这一步将完成剩余的需求。</p><p id="902f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的模板中，有一个<code class="fe np nq nr nf b">*ngFor</code>循环遍历一个<code class="fe np nq nr nf b">pages</code>数组。这个数组属于一个叫做<code class="fe np nq nr nf b">pagination</code>的物体。首先，我们想为这个对象创建一个接口。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="f5f5" class="nj lk iq nf b gy nk nl l nm nn"><em class="lb">export</em> interface NumberedPagination {<br/>  index: number;<br/>  maxPages: number;<br/>  pages: number[];<br/>}</span></pre><p id="1f71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个非常简单的接口，但它将包含我们分页工作所需的一切。</p><p id="3455" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们使用一个<code class="fe np nq nr nf b">getter</code>在我们的组件中创建<code class="fe np nq nr nf b">pagination</code>对象，因为我们希望这个对象对变化做出反应。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="074a" class="nj lk iq nf b gy nk nl l nm nn"><em class="lb">import</em> { Component, ChangeDetectionStrategy, Input, Output } <em class="lb">from</em> '@angular/core';<br/><em class="lb">import</em> { NumberedPagination } <em class="lb">from</em> './../../interfaces';</span><span id="c75d" class="nj lk iq nf b gy no nl l nm nn">@Component({<br/>  selector: 'numbered-pagination',<br/>  templateUrl: './numbered-pagination.component.html',<br/>  styleUrls: ['./numbered-pagination.component.scss'],<br/>  changeDetection: ChangeDetectionStrategy.OnPush,<br/>})</span><span id="4019" class="nj lk iq nf b gy no nl l nm nn"><em class="lb">export</em> class NumberedPaginationComponent {</span><span id="f178" class="nj lk iq nf b gy no nl l nm nn">  maxPages: number = 0;</span><span id="fbdb" class="nj lk iq nf b gy no nl l nm nn">  @Input() index: number = 1;<br/>  @Input() totalCount: number = 100;<br/>  @Input() pageSize: number = 5;<br/>  @Input() rulerLength: number = 5;</span><span id="c9c8" class="nj lk iq nf b gy no nl l nm nn">  @Output() page: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;();</span><span id="6388" class="nj lk iq nf b gy no nl l nm nn">  constructor() {<br/><em class="lb">    </em>this.maxPages = Math.ceil(this.totalCount / this.pageSize);<br/>  }</span><span id="eac6" class="nj lk iq nf b gy no nl l nm nn">  get pagination(): NumberedPagination {<br/>    const { index, maxPages, rulerLength } = <em class="lb">this</em>;<br/>    const pages = ruler(index, maxPages, rulerLength);</span><span id="fd06" class="nj lk iq nf b gy no nl l nm nn">    <em class="lb">return</em> { index, maxPages, pages } <em class="lb">as</em> NumberedPagination;<br/>  }</span><span id="48e3" class="nj lk iq nf b gy no nl l nm nn">}</span></pre><p id="87bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的分页对象由活动页面<code class="fe np nq nr nf b">index</code>、分页的最大页数<code class="fe np nq nr nf b">maxPages</code>和我们希望在<code class="fe np nq nr nf b">ruler</code>上显示的页数<code class="fe np nq nr nf b">pages</code>组成。</p><p id="4d0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe np nq nr nf b">pages</code>变量由<code class="fe np nq nr nf b">ruler()</code>方法的输出组成。让我们来看看这个函数:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="7319" class="nj lk iq nf b gy nk nl l nm nn">const ruler = (currentIndex: number, maxPages: number, rulerLength: number): number[] =&gt; {<br/>  const array = new Array(rulerLength).fill(null);<br/>  const min = Math.floor(rulerLength / 2);</span><span id="7f5f" class="nj lk iq nf b gy no nl l nm nn"><em class="lb">  return</em> array.map((_, index) =&gt; rulerFactory(currentIndex, index, min, maxPages, rulerLength));<br/>};</span></pre><p id="46f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个方法中，我们创建一个空数组，其大小与由预置或<code class="fe np nq nr nf b">@Input()</code>定义的<code class="fe np nq nr nf b">rulerLength</code>一样大。在我们的例子中，<code class="fe np nq nr nf b">rulerLength</code>就是<code class="fe np nq nr nf b">5</code>。我们将使用来自<code class="fe np nq nr nf b">min</code>的值为标尺创建一个逻辑行为，因为有3种不同的方式来移动标尺，但我们将在下面看到。在我们的例子中<code class="fe np nq nr nf b">min</code>将会是<code class="fe np nq nr nf b">2</code>。</p><blockquote class="ns nt nu"><p id="a3fb" class="kd ke lb kf b kg kh ki kj kk kl km kn nv kp kq kr nw kt ku kv nx kx ky kz la ij bi translated">注意:如果我们想要一把对称的尺子，我们可以将尺子的长度设为偶数。我们可以很容易地改变它的值:<br/> <code class="fe np nq nr nf b">rulerLength = rulerLength % 2 === 0 ? rulerLength + 1 : rulerLength</code></p></blockquote><p id="9d03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个<code class="fe np nq nr nf b">ruler</code>方法实际上是返回一个数字数组。例如，当用我们的预置创建组件时，它将返回<code class="fe np nq nr nf b">[1, 2, 3, 4]</code>。</p><p id="b938" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在方法的回归中，我们可以看到一个叫做<code class="fe np nq nr nf b">rulerFactory</code>的新方法。<code class="fe np nq nr nf b">rulerFactory</code>旨在避免<code class="fe np nq nr nf b">if-else</code>语句。相反，我们将使用<a class="ae kc" href="https://en.wikipedia.org/wiki/Factory_method_pattern" rel="noopener ugc nofollow" target="_blank">工厂设计模式</a>从<code class="fe np nq nr nf b">ruler</code>函数中抽象出一堆if。</p><p id="2a24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们剖析<code class="fe np nq nr nf b">rulerFactory</code>方法之前，我们需要引入一个枚举。由于标尺有3种不同的行为，我们创建一个枚举来保存它们:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="998c" class="nj lk iq nf b gy nk nl l nm nn"><em class="lb">export</em> enum RulerFactoryOption {<br/>  Start = 'START',<br/>  End = 'END',<br/>  Default = 'DEFAULT',<br/>}</span></pre><blockquote class="ns nt nu"><p id="78f8" class="kd ke lb kf b kg kh ki kj kk kl km kn nv kp kq kr nw kt ku kv nx kx ky kz la ij bi translated"><code class="fe np nq nr nf b"><em class="iq">Start</em></code> <em class="iq">将在活动页面到达标尺中间之前使用。<br/> </em> <code class="fe np nq nr nf b"><em class="iq">End</em></code> <em class="iq">是最后一个行为。当我们接近最后一页的时候。<br/> </em> <code class="fe np nq nr nf b"><em class="iq">Default</em></code> <em class="iq">是默认行为。</em></p></blockquote><p id="88d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们来看看<code class="fe np nq nr nf b">rulerFactory</code>:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="6320" class="nj lk iq nf b gy nk nl l nm nn">const rulerFactory = (currentIndex: number, index: number, min: number, maxPages: number, rL: number): number =&gt; {<br/>  const factory = {<br/>    [RulerFactoryOption.Start]: () =&gt; index + 1<br/>    [RulerFactoryOption.End]: () =&gt; maxPages - rL + index + 1,<br/>    [RulerFactoryOption.Default]: () =&gt; currentIndex + index - min,<br/>  };</span><span id="a49c" class="nj lk iq nf b gy no nl l nm nn"><em class="lb">  return</em> factory[rulerOption(currentIndex, min, maxPages)]();</span><span id="985d" class="nj lk iq nf b gy no nl l nm nn">};</span></pre><p id="dfac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:为了更好的可读性，我不得不把 <code class="fe np nq nr nf b"><em class="lb">rulerLength</em></code> <em class="lb">重新命名为rL。</em></p><p id="6932" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可能看起来有点晦涩难懂，但工厂所做的实际上非常简单。目标是在标尺上移动时有一个自然的流程。ruler工厂使用<code class="fe np nq nr nf b">rulerOption</code>定义了ruler必须返回的行为。换句话说，除了开头和结尾，活动页面将始终位于屏幕中央。由于最后两种情况，标尺没有改变，只有突出显示的页面:</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/54955fdeb78e1161b1e0ff131d0734e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Lb8lJZ6Fv2TahokfUs1PYQ.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">开始、默认和结束行为</figcaption></figure><p id="a4d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了定义我们是在标尺的起点、中间还是终点，我们使用了<code class="fe np nq nr nf b">rulerOption</code>函数:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="e9cd" class="nj lk iq nf b gy nk nl l nm nn">const rulerOption = (currentIndex: number, min: number, maxPages: number): RulerFactoryOption =&gt; {<br/>  <em class="lb">return</em> currentIndex &lt;= min<br/>    ? RulerFactoryOption.Start<br/>    : currentIndex &gt;= maxPages - min<br/>    ? RulerFactoryOption.End<br/>    : RulerFactoryOption.Default;<br/>};</span></pre><p id="0c42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文结束之前，我们需要用上面模板中介绍的两种方法更新我们的组件:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="f098" class="nj lk iq nf b gy nk nl l nm nn">navigateToPage(pageNumber: number): void {<br/>  <em class="lb">if</em> (allowNavigation(pageNumber, <em class="lb">this</em>.index, <em class="lb">this</em>.maxPages)) {<br/>    <em class="lb">this</em>.index = pageNumber;<br/><em class="lb">    this</em>.page.emit(<em class="lb">this</em>.index);<br/>  }<br/>}</span><span id="3da0" class="nj lk iq nf b gy no nl l nm nn">trackByFn(index: number): number {<br/><em class="lb">  return</em> index;<br/>}</span></pre><p id="f5e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的<code class="fe np nq nr nf b">navigateToPage</code>方法将触发索引更新，并且只有在页面不同于当前页面并且页面存在的情况下才会发出<code class="fe np nq nr nf b">page</code>事件。</p><p id="308e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe np nq nr nf b">trackByFn</code>帮助Angular跟踪<code class="fe np nq nr nf b">*ngFor</code>循环上的变化，并使绘画更快。严格来说是性能方面。</p><p id="4e65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据<code class="fe np nq nr nf b">allowNavigation</code>，如果没有改变，我们不想触发页面事件或更新索引，因此我们进行如下测试:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="44e8" class="nj lk iq nf b gy nk nl l nm nn">const allowNavigation = (pageNumber: number, index: number, maxPages: number): boolean =&gt; {<br/>  <em class="lb">return</em> pageNumber !== index &amp;&amp; pageNumber &gt; 0 &amp;&amp; pageNumber &lt;= maxPages;<br/>};</span></pre></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="69bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">演示:<a class="ae kc" href="https://stackblitz.com/edit/simple-numbered-pagination-angular" rel="noopener ugc nofollow" target="_blank">https://stack blitz . com/edit/simple-numbered-pagination-angular</a></p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="e617" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">结论</h1><p id="5320" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">该组件只有70行代码，所以它是一个非常小的零依赖模块，可以很好地完成工作。</p><p id="0605" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您更喜欢使用<code class="fe np nq nr nf b">if-else</code>语句而不是工厂语句，您也可以删除<code class="fe np nq nr nf b">rulerFactory</code>方法，直接在<code class="fe np nq nr nf b">.map()</code>中运行条件语句。代码更少，你也不需要枚举。但是依我看，遵循严格的原则总是更好。</p><p id="7e39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你喜欢这篇文章，并祝大家玩得开心。都是爱。</p></div></div>    
</body>
</html>