<html>
<head>
<title>Creating a Docker Swarm using Multipass and Ubuntu 20.04 on your laptop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在你的笔记本电脑上使用Multipass和Ubuntu 20.04创建Docker Swarm</h1>
<blockquote>原文：<a href="https://itnext.io/creating-a-docker-swarm-using-multipass-and-ubuntu-20-04-on-your-laptop-fbf7ea85547c?source=collection_archive---------4-----------------------#2020-05-24">https://itnext.io/creating-a-docker-swarm-using-multipass-and-ubuntu-20-04-on-your-laptop-fbf7ea85547c?source=collection_archive---------4-----------------------#2020-05-24</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><p id="8d41" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">Docker是一个很酷的系统，可以将应用程序部署为可重用的容器，而Docker Swarm是一个Docker Orchestrator，让我们可以在多台机器上扩展容器的数量。Multipass是一个运行在Windows、Linux和macOS上的轻量级虚拟机管理器应用程序，它让我们可以轻松地在笔记本电脑上设置多个Ubuntu实例，而不会影响性能。因此，Multipass可以作为一种手段，轻松地在您的笔记本电脑上试验Docker Swarm，了解它如何工作，设置网络等。</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj kp"><img src="../Images/ff425b23e3a54f73056b9ed646ba0bb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qg2sohrJ7FLg-WhT.png"/></div></div></figure><p id="b0e1" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">理论上这并不难，因为在Multipass上启动Ubuntu实例就像在Ubuntu上安装Docker和Docker Swarm一样简单。但是有足够多的活动部分，所以回顾一下如何在Multipass上安装Docker，然后初始化Docker Swarm是很有用的。此外，设置脚本来轻松初始化Docker群组实例也很有用，因为群组在跨多个系统时当然更有用。</p><p id="96c1" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">Docker Swarm是众多Docker编排平台之一。它处理跨一组节点分发Docker容器，通过根据需要重新部署容器来确保群集的可靠性等等。Multipass为我们提供了一种不用离开笔记本电脑就能试验Docker Swarm的简单方法。</p><p id="5ce9" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">要安装Multipass，请进入<a class="ae lb" href="https://multipass.run" rel="noopener ugc nofollow" target="_blank"> https://multipass.run </a>，找到您系统的安装程序。或者，您会发现在一些包管理系统中可以使用Multipass。</p><p id="8edd" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在Ubuntu 20.04上设置Docker Swarm的步骤如下:</p><ul class=""><li id="bb5a" class="lc ld iu jt b ju jv jy jz kc le kg lf kk lg ko lh li lj lk bi translated">在Multipass上初始化Ubuntu 20.04实例</li><li id="06d2" class="lc ld iu jt b ju ll jy lm kc ln kg lo kk lp ko lh li lj lk bi translated">在实例内部，执行步骤来初始化Ubuntu 20.04上的Docker</li><li id="03ee" class="lc ld iu jt b ju ll jy lm kc ln kg lo kk lp ko lh li lj lk bi translated">在第一个这样的实例中运行<code class="fe lq lr ls lt b">docker swarm init</code></li><li id="0d26" class="lc ld iu jt b ju ll jy lm kc ln kg lo kk lp ko lh li lj lk bi translated">在后续实例中，运行命令使实例加入群</li></ul><p id="c29b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在Ubuntu上安装Docker的官方说明位于:</p><ul class=""><li id="1e27" class="lc ld iu jt b ju jv jy jz kc le kg lf kk lg ko lh li lj lk bi translated"><a class="ae lb" href="https://docs.docker.com/engine/install/ubuntu/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/engine/install/ubuntu/</a>—在Ubuntu上安装Docker-CE</li><li id="e038" class="lc ld iu jt b ju ll jy lm kc ln kg lo kk lp ko lh li lj lk bi translated"><a class="ae lb" href="https://docs.docker.com/engine/install/linux-postinstall/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/engine/install/linux-postinstall/</a>—运行Linux的安装后步骤</li></ul><p id="e2a8" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">而在Windows上我们安装Docker for Windows，在macOS上我们安装Docker for macOS，在Linux上我们只是安装Docker。那是因为Docker原生运行在Linux上。</p><p id="8979" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们的目标是将官方指令转换成shell脚本。因此，我们可以随时轻松地创建新实例，并快速构建任何规模的群集群。</p><h1 id="6484" class="lu lv iu bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">用于初始化Ubuntu/Docker/Docker群实例的Shell脚本</h1><p id="5195" class="pw-post-body-paragraph jr js iu jt b ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk mw km kn ko in bi translated">我将官方指令翻译成可重复脚本的实验让我创建了两个脚本。</p><p id="7654" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">首先，创建<code class="fe lq lr ls lt b">init-instance.sh</code>包含:</p><pre class="kq kr ks kt gu mx lt my mz aw na bi"><span id="9a9f" class="nb lv iu lt b gz nc nd l ne nf">NM=$1 </span><span id="06c8" class="nb lv iu lt b gz ng nd l ne nf">multipass launch --name ${NM} focal<br/>multipass transfer setup-instance.sh ${NM}:/home/ubuntu/setup-instance.sh<br/>multipass exec ${NM} -- sh -x /home/ubuntu/setup-instance.sh</span></pre><p id="2d26" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">实例的名称将在命令行上传递。在<code class="fe lq lr ls lt b">multipass launch</code>中，我们指定了一个图像名<code class="fe lq lr ls lt b">focal</code>，它指的是Ubuntu 20.04。在撰写本文时，2020年5月，20.04映像是最新的，但是它还不像LTS版本那样支持多通道。</p><p id="52de" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这个脚本的其余部分将脚本<code class="fe lq lr ls lt b">setup-instance.sh</code>转移到新创建的实例，然后执行该脚本。虽然<code class="fe lq lr ls lt b">setup-instance.sh</code>中的大部分命令都可以使用<code class="fe lq lr ls lt b">multipass exec</code>来执行，但有些命令并不能很好地执行，因此有必要转而使用shell脚本。</p><p id="09ba" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">创建<code class="fe lq lr ls lt b">setup-instance.sh</code>包含:</p><pre class="kq kr ks kt gu mx lt my mz aw na bi"><span id="03d2" class="nb lv iu lt b gz nc nd l ne nf">sudo apt-get update <br/>sudo apt-get upgrade -y <br/>sudo apt-get -y install \<br/>     apt-transport-https ca-certificates \<br/>     curl gnupg-agent software-properties-common</span><span id="f92d" class="nb lv iu lt b gz ng nd l ne nf">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><span id="284e" class="nb lv iu lt b gz ng nd l ne nf">sudo apt-key fingerprint 0EBFCD88 sudo add-apt-repository \<br/>   "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" </span><span id="9622" class="nb lv iu lt b gz ng nd l ne nf">sudo apt-get update <br/>sudo apt-get upgrade -y <br/>sudo apt-get install -y docker-ce docker-ce-cli containerd.io <br/>sudo groupadd docker<br/>sudo usermod -aG docker ubuntu<br/>sudo systemctl enable docker</span></pre><p id="0c00" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这是官方说明中列出的命令，有几个小小的音译。第一部分更新已安装的包，然后给<code class="fe lq lr ls lt b">apt-get</code>添加从HTTPS服务器加载包的能力。然后我们为Docker设置Ubuntu包存储库，然后从该存储库安装Docker。最后，我们确保<code class="fe lq lr ls lt b">docker</code>组存在，并将<code class="fe lq lr ls lt b">ubuntu</code>用户ID添加到该组，以便我们可以运行<code class="fe lq lr ls lt b">docker</code>命令，并通过确保<code class="fe lq lr ls lt b">docker</code>守护进程在系统启动时运行来完成。</p><p id="b00a" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这不做任何Docker群命令。但是它确实让Docker运行起来，您可以这样验证:</p><pre class="kq kr ks kt gu mx lt my mz aw na bi"><span id="f7d5" class="nb lv iu lt b gz nc nd l ne nf">$ multipass exec NAME -- docker run hello-world</span></pre><p id="753f" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这是验证Docker初始化的标准方式，以运行<code class="fe lq lr ls lt b">hello-world</code>容器。如果配置正确，它将下载<code class="fe lq lr ls lt b">hello-world</code>图像，然后实例化一个容器，这将打印出一条有用的消息。替换您指定的实例名<code class="fe lq lr ls lt b">NAME</code>。</p><h1 id="ab81" class="lu lv iu bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">在多遍Ubuntu实例上建立Docker群</h1><p id="e057" class="pw-post-body-paragraph jr js iu jt b ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk mw km kn ko in bi translated">有了这些脚本，我们可以启动一个Ubuntu/Docker实例，并初始化Swarm。</p><pre class="kq kr ks kt gu mx lt my mz aw na bi"><span id="e542" class="nb lv iu lt b gz nc nd l ne nf">$ sh -x init-instance.sh swarm1 <br/>+ NM=swarm1 <br/>+ multipass launch --name swarm1 focal Launched: swarm1 <br/>+ multipass transfer setup-instance.sh swarm1:/home/ubuntu/setup-instance.sh <br/>+ multipass exec swarm1 -- sh -x /home/ubuntu/setup-instance.sh <br/>+ sudo apt-get update <br/>... much output <br/>+ sudo systemctl enable docker <br/>Synchronizing state of docker.service with SysV service script with /lib/systemd/systemd-sysv-install. <br/>Executing: /lib/systemd/systemd-sysv-install enable docker<br/>$</span></pre><p id="c8f9" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在一分钟左右的时间内，这将启动一个Multipass实例并设置Docker。</p><pre class="kq kr ks kt gu mx lt my mz aw na bi"><span id="9957" class="nb lv iu lt b gz nc nd l ne nf">$ multipass list <br/>Name State IPv4 Image <br/>swarm1 Running 192.168.64.14 Ubuntu 20.04 LTS </span><span id="f3ad" class="nb lv iu lt b gz ng nd l ne nf">$ multipass exec swarm1 -- docker run hello-world <br/>Unable to find image 'hello-world:latest' locally <br/>latest: Pulling from library/hello-world 0e03bdcc26d7: Pull complete <br/>Digest: sha256:6a65f928fb91fcfbc963f7aa6d57c8eeb426ad9a20c7ee045538ef34847f44f1 <br/>Status: Downloaded newer image for hello-world:latest <br/>Hello from Docker! <br/>...</span></pre><p id="9ff4" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><code class="fe lq lr ls lt b">swarm1</code>实例正在运行，我们可以执行Docker。让我们初始化Docker Swarm。</p><pre class="kq kr ks kt gu mx lt my mz aw na bi"><span id="a063" class="nb lv iu lt b gz nc nd l ne nf">$ multipass exec swarm1 -- docker swarm init Swarm initialized: current node (xki1yma9q91401zv0i0yksrht) is now a manager.</span><span id="73f8" class="nb lv iu lt b gz ng nd l ne nf">To add a worker to this swarm, run the following command:      </span><span id="50a2" class="nb lv iu lt b gz ng nd l ne nf">    docker swarm join --token SWMTKN-1-10r3749fp92qk7bpszvv2ejvdrbc4vkoaeks7kkpqdlytwbcq8-33a4kq3xpb315zrwhghs68atx 192.168.64.14:2377  </span><span id="eb5b" class="nb lv iu lt b gz ng nd l ne nf">To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.  </span><span id="2c4e" class="nb lv iu lt b gz ng nd l ne nf">$ multipass exec swarm1 -- docker node ls <br/>ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION <br/>xki1yma9q91401zv0i0yksrht *   swarm1              Ready               Active              Leader              19.03.9</span></pre><p id="4b6f" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这个群体中有一个节点，这个节点是这个群体的领导者。当你是唯一投票的人时，很容易被选为领袖，嗯？</p><p id="88da" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">输出包括一个命令，用于您希望添加到集群的任何新Docker系统。您不需要记录命令字符串，而是需要学习这两个命令:</p><pre class="kq kr ks kt gu mx lt my mz aw na bi"><span id="b190" class="nb lv iu lt b gz nc nd l ne nf">$ multipass exec swarm1 -- docker swarm join-token manager <br/>$ multipass exec swarm1 -- docker swarm join-token worker</span></pre><p id="0b41" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><code class="fe lq lr ls lt b">docker swarm join-token {manager,worker}</code>命令为您提供了一个节点作为管理节点或工作节点加入集群的命令字符串。</p><p id="170c" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">群集群中有两种节点。</p><ul class=""><li id="9b1c" class="lc ld iu jt b ju jv jy jz kc le kg lf kk lg ko lh li lj lk bi translated"><em class="nh">管理器</em>节点维护群集群。它们相互通信，并自动维护群集中所有节点的共享状态。管理器间通信通道被称为<em class="nh">控制平面</em>。</li><li id="8ca9" class="lc ld iu jt b ju ll jy lm kc ln kg lo kk lp ko lh li lj lk bi translated"><em class="nh"> Worker </em>节点不参与集群的管理，只是在集群内执行任务。管理器节点也可以像工人一样执行任务，这使得Docker Swarm比大多数工作场所更加平等。</li></ul><h1 id="1c2b" class="lu lv iu bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">向群中添加第二个管理器</h1><pre class="kq kr ks kt gu mx lt my mz aw na bi"><span id="78ac" class="nb lv iu lt b gz nc nd l ne nf">$ sh -x init-instance.sh swarm2 <br/>... much output <br/>$ multipass exec swarm1 -- docker swarm join-token manager <br/>To add a manager to this swarm, run the following command:      </span><span id="1a10" class="nb lv iu lt b gz ng nd l ne nf">     docker swarm join --token SWMTKN-1-10r3749fp92qk7bpszvv2ejvdrbc4vkoaeks7kkpqdlytwbcq8-4bfaew5hps8mntqubxt9kkc4n 192.168.64.14:2377 </span><span id="c77e" class="nb lv iu lt b gz ng nd l ne nf">$ multipass exec swarm2 -- docker swarm join --token SWMTKN-1-10r3749fp92qk7bpszvv2ejvdrbc4vkoaeks7kkpqdlytwbcq8-4bfaew5hps8mntqubxt9kkc4n 192.168.64.14:2377 <br/>This node joined a swarm as a manager.  </span><span id="315e" class="nb lv iu lt b gz ng nd l ne nf">$ multipass exec swarm1 -- docker node ls <br/>ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION xki1yma9q91401zv0i0yksrht *   swarm1              Ready               Active              Leader              19.03.9 wgcj54zs2u3k9x1th3s20s1lm     swarm2              Ready               Active              Reachable           19.03.9</span></pre><p id="e0da" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">现在有两个节点。</p><h1 id="a2e7" class="lu lv iu bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">向群中添加一个工作节点</h1><pre class="kq kr ks kt gu mx lt my mz aw na bi"><span id="eca2" class="nb lv iu lt b gz nc nd l ne nf">$ sh -x init-instance.sh swarm3 <br/>... </span><span id="09c3" class="nb lv iu lt b gz ng nd l ne nf">$ multipass exec swarm1 -- docker swarm join-token worker <br/>To add a worker to this swarm, run the following command: </span><span id="d4c7" class="nb lv iu lt b gz ng nd l ne nf">     docker swarm join --token SWMTKN-1-10r3749fp92qk7bpszvv2ejvdrbc4vkoaeks7kkpqdlytwbcq8-33a4kq3xpb315zrwhghs68atx 192.168.64.14:2377 </span><span id="ef2c" class="nb lv iu lt b gz ng nd l ne nf">$ multipass exec swarm3 -- docker swarm join --token SWMTKN-1-10r3749fp92qk7bpszvv2ejvdrbc4vkoaeks7kkpqdlytwbcq8-33a4kq3xpb315zrwhghs68atx 192.168.64.14:2377 <br/>This node joined a swarm as a worker.  </span><span id="f1c0" class="nb lv iu lt b gz ng nd l ne nf">$ multipass list <br/>Name                    State             IPv4             Image swarm1                  Running           192.168.64.14    Ubuntu 20.04 LTS <br/>swarm2                  Running           192.168.64.15    Ubuntu 20.04 LTS <br/>swarm3                  Running           192.168.64.16    Ubuntu 20.04 LTS  $</span><span id="5706" class="nb lv iu lt b gz ng nd l ne nf"> multipass exec swarm1 -- docker node ls <br/>ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION xki1yma9q91401zv0i0yksrht *   swarm1              Ready               Active              Leader              19.03.9 wgcj54zs2u3k9x1th3s20s1lm     swarm2              Ready               Active              Reachable           19.03.9 vk3c3etx53zq4hhzk7q6kgo3y     swarm3              Ready               Active                                  19.03.9</span></pre><p id="5535" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们现在有三个节点，两个经理和一个工人。</p><h1 id="d9d8" class="lu lv iu bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">向集群添加工作负载</h1><p id="ba06" class="pw-post-body-paragraph jr js iu jt b ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk mw km kn ko in bi translated">在Docker Swarm中，我们创建了一个<em class="nh">服务</em>，它又包含<em class="nh">任务</em>，每个任务包含一个<em class="nh">容器</em>。容器是我们使用<code class="fe lq lr ls lt b">docker run</code>命令创建的同一个容器，其余部分是为了让Swarm可以跨一组Swarm节点管理一组容器。</p><pre class="kq kr ks kt gu mx lt my mz aw na bi"><span id="fff0" class="nb lv iu lt b gz nc nd l ne nf">$ multipass exec swarm2 -- docker service create --name nginx --replicas 3 -p 80:80 nginx <br/>l0z5s0e1rpoy35gksnioikf5w <br/>overall progress: 3 out of 3 tasks <br/>1/3: running <br/>2/3: running <br/>3/3: running <br/>verify: Service converged</span></pre><p id="6abc" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这里，我们请求在一个管理节点(<code class="fe lq lr ls lt b">swarm2</code>)上创建一个名为<code class="fe lq lr ls lt b">nginx</code>的服务。我们请求该服务的三个实例，它将使用来自Docker Hub的<code class="fe lq lr ls lt b">nginx</code>图像。它也将从容器中暴露端口80。</p><pre class="kq kr ks kt gu mx lt my mz aw na bi"><span id="c932" class="nb lv iu lt b gz nc nd l ne nf">$ multipass exec swarm1 -- docker service ls <br/>ID NAME MODE REPLICAS IMAGE PORTS <br/>l0z5s0e1rpoy nginx replicated 3/3 nginx:latest *:80-&gt;80/tcp</span></pre><p id="c93e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">为了证明群节点可以相互通信，让我们列出当前在集群上运行的服务，但是这些服务是从<code class="fe lq lr ls lt b">swarm1</code>节点请求的。</p><pre class="kq kr ks kt gu mx lt my mz aw na bi"><span id="ca67" class="nb lv iu lt b gz nc nd l ne nf">$ multipass exec swarm1 -- docker service ps nginx <br/>ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS wcoiz9p6cmck nginx.1 nginx:latest swarm1 Running Running 5 minutes ago <br/>yud37ipf4lwb nginx.2 nginx:latest swarm2 Running Running 5 minutes ago <br/>wrze6s2csz62 nginx.3 nginx:latest swarm3 Running Running 4 minutes ago</span></pre><p id="ff15" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们可以获得<code class="fe lq lr ls lt b">nginx</code>服务的状态，显示三个任务在哪里运行。也就是说，集群在节点之间分配任务，每个节点一个任务。</p><p id="bfd1" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><code class="fe lq lr ls lt b">nginx</code>图像显示了一个默认的HTML页面，因此我们可以在浏览器中访问位于<code class="fe lq lr ls lt b">http://192.168.64.14/</code>、<code class="fe lq lr ls lt b">http://192.168.64.15/</code>和<code class="fe lq lr ls lt b">http://192.168.64.16/</code>的三个Multipass实例，以验证它们是否都工作正常。</p><p id="fafc" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">不那么明显的是，Swarm负责交叉连接服务，这样每个发布的服务在每个节点上都是可见的，即使该服务没有在该节点上运行。</p><h1 id="397b" class="lu lv iu bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">探索跨群节点的服务的交叉连接</h1><p id="06f6" class="pw-post-body-paragraph jr js iu jt b ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk mw km kn ko in bi translated">为了探索服务是如何跨群节点交叉连接的，让我们创建一个服务，看看它是如何工作的。</p><pre class="kq kr ks kt gu mx lt my mz aw na bi"><span id="810e" class="nb lv iu lt b gz nc nd l ne nf">$ multipass exec swarm1 -- docker service create --name httpd --replicas 1 -p 90:80 httpd <br/>qnodrnbmpd5hy360fn99hgdg5 <br/>overall progress: 1 out of 1 tasks <br/>1/1: running <br/>verify: Service converged </span><span id="7040" class="nb lv iu lt b gz ng nd l ne nf">$ multipass exec swarm1 -- docker service ls <br/>ID NAME MODE REPLICAS IMAGE PORTS <br/>qnodrnbmpd5h httpd replicated 1/1 httpd:latest *:90-&gt;80/tcp <br/>l0z5s0e1rpoy nginx replicated 3/3 nginx:latest *:80-&gt;80/tcp </span><span id="467f" class="nb lv iu lt b gz ng nd l ne nf">$ multipass exec swarm1 -- docker service ps httpd <br/>ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS <br/>yb6dv4ur8eq2 httpd.1 httpd:latest swarm1 Running Running 49 seconds ago</span></pre><p id="07a6" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">为了给Nginx的竞争以同等的时间，我们启动了Apache HTTPD的一个实例。蜂群把它分配给了<code class="fe lq lr ls lt b">swarm1</code>节点。我们将其设置为在端口90可见。通过仅使用一个副本，我们确保了HTTPD服务仅位于一个节点上。</p><p id="6082" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">并且，访问<code class="fe lq lr ls lt b">http://192.168.64.14:90/</code>、<code class="fe lq lr ls lt b">http://192.168.64.15:90/</code>和<code class="fe lq lr ls lt b">http://192.168.64.16:90/</code>确实显示Apache服务通过每个节点可见。因此，Docker Swarm的安排使得服务在每个节点上都是可见的，即使它只部署在其中一个节点上。</p><h1 id="7bc7" class="lu lv iu bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">修改已部署服务的状态</h1><p id="af07" class="pw-post-body-paragraph jr js iu jt b ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk mw km kn ko in bi translated">我们可以修改已经部署的服务的状态，然后群将发布修改。</p><pre class="kq kr ks kt gu mx lt my mz aw na bi"><span id="4608" class="nb lv iu lt b gz nc nd l ne nf">$ multipass exec swarm1 -- docker service update --replicas 2 httpd httpd <br/>overall progress: 2 out of 2 tasks <br/>1/2: running <br/>2/2: running <br/>verify: Service converged </span><span id="50de" class="nb lv iu lt b gz ng nd l ne nf">$ multipass exec swarm1 -- docker service ps httpd <br/>ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS <br/>yb6dv4ur8eq2 httpd.1 httpd:latest swarm1 Running Running 4 minutes ago <br/>9uxc9p9wbvdu httpd.2 httpd:latest swarm2 Running Running 10 seconds ago</span></pre><p id="4ce5" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这增加了实例的数量，现在有两个<code class="fe lq lr ls lt b">httpd</code>实例被分配给<code class="fe lq lr ls lt b">swarm1</code>和<code class="fe lq lr ls lt b">swarm2</code>。</p><h1 id="da28" class="lu lv iu bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">探索部署到每个节点的容器</h1><p id="a5af" class="pw-post-body-paragraph jr js iu jt b ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk mw km kn ko in bi translated">另一个命令是<code class="fe lq lr ls lt b">docker container</code>，它有许多管理单个容器的命令。有了它，我们可以探索部署在每个节点上的容器。</p><pre class="kq kr ks kt gu mx lt my mz aw na bi"><span id="185c" class="nb lv iu lt b gz nc nd l ne nf">$ multipass exec swarm1 -- docker container ls<br/>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES<br/>b6fc2b1000e3        httpd:latest        "httpd-foreground"       7 minutes ago       Up 7 minutes        80/tcp              httpd.1.yb6dv4ur8eq2epuae97i34ij1<br/>f950a9c2db96        nginx:latest        "nginx -g 'daemon of…"   19 minutes ago      Up 19 minutes       80/tcp              nginx.1.wcoiz9p6cmckvb8il9n7uwyvk<br/><br/>$ multipass exec swarm2 -- docker container ls<br/>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES<br/>649d821a4e78        httpd:latest        "httpd-foreground"       3 minutes ago       Up 3 minutes        80/tcp              httpd.2.9uxc9p9wbvdu8l9h1lnesqjhc<br/>44f12c4b4c5f        nginx:latest        "nginx -g 'daemon of…"   20 minutes ago      Up 20 minutes       80/tcp              nginx.2.yud37ipf4lwb43idtgu2bfhs7<br/><br/>$ multipass exec swarm3 -- docker container ls<br/>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES<br/>be8bcd336ad1        nginx:latest        "nginx -g 'daemon of…"   20 minutes ago      Up 20 minutes       80/tcp              nginx.3.wrze6s2csz62cdoc2ozwb0g03</span></pre><p id="a79d" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">请注意，在名称列中，我们看到类似于<code class="fe lq lr ls lt b">nginx.2.yud37ipf4lwb43idtgu2bfhs7</code>的名称。为了使容器名称在集群中是唯一的，Docker Swarm将那个<em class="nh"> nonce </em>添加到容器名称中。</p><p id="5151" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">另一件要注意的事情是，在容器处，HTTPD容器暴露端口80。从端口90到端口80的映射发生在更高的级别。</p><h1 id="9785" class="lu lv iu bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">删除服务</h1><p id="7b6a" class="pw-post-body-paragraph jr js iu jt b ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk mw km kn ko in bi translated">要清理和删除服务，请执行以下操作:</p><pre class="kq kr ks kt gu mx lt my mz aw na bi"><span id="ba7a" class="nb lv iu lt b gz nc nd l ne nf">$ multipass exec swarm2 -- docker service rm nginx<br/>nginx<br/><br/> multipass exec swarm2 -- docker service ls<br/>ID                  NAME                MODE                REPLICAS            IMAGE               PORTS<br/>qnodrnbmpd5h        httpd               replicated          2/2                 httpd:latest        *:90-&gt;80/tcp<br/><br/>$ multipass exec swarm1 -- docker service rm httpd<br/>httpd<br/>$ multipass exec swarm2 -- docker service ls<br/>ID                  NAME                MODE                REPLICAS            IMAGE               PORTS</span></pre><p id="7256" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><code class="fe lq lr ls lt b">service rm</code>命令启动关闭指定服务的过程。它通过向集群分发命令来关闭容器。</p><h1 id="1db9" class="lu lv iu bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">管理多路实例</h1><p id="c40c" class="pw-post-body-paragraph jr js iu jt b ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk mw km kn ko in bi translated">您可以停止单个实例，如下所示:</p><pre class="kq kr ks kt gu mx lt my mz aw na bi"><span id="c1f6" class="nb lv iu lt b gz nc nd l ne nf">$ multipass stop swarm3<br/>$ multipass stop swarm2<br/>$ multipass stop swarm1</span></pre><p id="ff12" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">或者删除它们:</p><pre class="kq kr ks kt gu mx lt my mz aw na bi"><span id="3add" class="nb lv iu lt b gz nc nd l ne nf">$ multipass delete swarm3<br/>$ multipass delete swarm2<br/>$ multipass delete swarm1<br/>$ multipass purge</span></pre><p id="a22c" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">不同之处在于，停止的实例可以重新启动，但删除的实例处于炼狱状态。<code class="fe lq lr ls lt b">purge</code>命令删除与任何已删除实例相关的数据。</p><pre class="kq kr ks kt gu mx lt my mz aw na bi"><span id="3f30" class="nb lv iu lt b gz nc nd l ne nf">$ multipass start swarm3<br/>$ multipass start swarm2<br/>$ multipass start swarm1</span></pre><p id="1e3e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">如果您想重启一个节点，只需使用<code class="fe lq lr ls lt b">start</code>命令。</p><p id="692b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">要试验的是有运行实例的群，当你在其中一个实例上运行<code class="fe lq lr ls lt b">stop</code>时会发生什么。例如，swarm会根据需要重新部署容器。如果您已经停止了Leader实例，将会选出一个新的Leader。</p><h1 id="31a6" class="lu lv iu bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">表演</h1><p id="35a0" class="pw-post-body-paragraph jr js iu jt b ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk mw km kn ko in bi translated">这个实验是在一台2012款MacBook Pro上进行的，它有16 GB的主内存和一个SSD引导驱动器。也就是说，这是一台已经使用了八年的电脑，已经扩展到了极限。目前运行的是Chrome(有多个顶层窗口和几百个打开的标签页)，Firefox和Safari浏览器，加上几个Visual Studio代码窗口，以及几个其他应用程序。换句话说，这不是一台负载很轻的计算机。</p><p id="f0f8" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">但是同时运行三个多通道实例并不会导致系统明显变慢。</p><p id="cb1b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">Multipass团队声称这是一个极其轻量级(意味着低系统影响)的虚拟机管理器，支持成熟的Ubuntu实例。该实验表明“低系统影响”部分是正确的。虽然我启动的Nginx和HTTPD容器并没有对系统造成太大影响，但我确实有三台虚拟机，其中三个Nginx实例和两个HTTPD实例同时运行。在一台有八年历史的MacBook Pro上使用VirtualBox试试吧，它同时运行着许多其他进程。</p><p id="13ac" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我对VirtualBox的记忆是，它能迅速把台式电脑变成糖蜜。</p><h1 id="4d91" class="lu lv iu bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">摘要</h1><p id="dbc0" class="pw-post-body-paragraph jr js iu jt b ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk mw km kn ko in bi translated">Multipass看起来是在开发人员的笔记本电脑上启动Ubuntu实例的一个非常有用的工具。它非常强大，一分钟左右你就能得到一个成熟的Ubuntu实例。据说Multipass支持其他操作系统是可能的，但似乎Ubuntu是目前唯一可用的版本。</p><p id="2d5f" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">Docker Swarm是一款非常强大的Docker orchestrator。学习Swarm是值得的，只要你对Docker编排有更好的理解，从而对其他Docker编排有更清晰的了解。Multipass看起来是一个很好的平台，可以在这个平台上不用离开你的笔记本电脑就可以体验Docker Swarm。</p><h1 id="603b" class="lu lv iu bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">关于作者</h1><p id="9151" class="pw-post-body-paragraph jr js iu jt b ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk mw km kn ko in bi translated"><a class="ae lb" href="https://techsparx.com/about.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jt iv">大卫·赫伦</strong> </a> <strong class="jt iv"> </strong>:大卫·赫伦是一名作家和软件工程师，专注于技术的明智使用。他对太阳能、风能和电动汽车等清洁能源技术特别感兴趣。David在硅谷从事了近30年的软件工作，从电子邮件系统到视频流，再到Java编程语言，他已经出版了几本关于Node.js编程和电动汽车的书籍。</p></div><div class="ab cl ni nj hy nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="in io ip iq ir"><p id="2102" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><em class="nh">原载于</em><a class="ae lb" href="https://techsparx.com/software-development/docker/swarm/multipass.html" rel="noopener ugc nofollow" target="_blank"><em class="nh">https://techsparx.com</em></a><em class="nh">。</em></p></div></div>    
</body>
</html>