<html>
<head>
<title>Guidance for Building a Control Plane for Envoy Part 4: Build for Extensibility</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为Envoy构建控制平面指南第4部分:可扩展性构建</h1>
<blockquote>原文：<a href="https://itnext.io/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility-80313ce93ade?source=collection_archive---------8-----------------------#2019-04-02">https://itnext.io/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility-80313ce93ade?source=collection_archive---------8-----------------------#2019-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2ec5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是<a class="ae kl" href="https://medium.com/solo-io/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh-badb6c36a2af" rel="noopener">系列</a>的第4部分，探索为特使代理构建控制平面。跟随<a class="ae kl" href="https://twitter.com/christianposta" rel="noopener ugc nofollow" target="_blank"> @christianposta </a>和<a class="ae kl" href="https://twitter.com/soloio_inc" rel="noopener ugc nofollow" target="_blank">@ solio _ Inc</a>一周之后的下一部。</p><p id="e518" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个博客系列中，我们将看看以下几个方面:</p><ul class=""><li id="4ceb" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated"><a class="ae kl" href="https://medium.com/solo-io/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh-badb6c36a2af" rel="noopener">采用动态更新特使路由、服务发现和其他配置的机制</a></li><li id="375f" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated"><a class="ae kl" href="https://medium.com/solo-io/guidance-for-building-a-control-plane-for-envoy-proxy-part-2-identify-components-2d0731b0d8a4" rel="noopener">确定控制平面由哪些组件组成，包括后备存储器、服务发现API、安全组件等。艾尔。</a></li><li id="ed17" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated"><a class="ae kl" href="https://medium.com/solo-io/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration-c97e8124b9d1" rel="noopener">建立最适合您的用例及组织的任何特定于领域的配置对象和API</a></li><li id="c724" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">思考如何最好地让您的控制面板可插入到您需要的地方(<em class="la">此条目</em>)</li><li id="acc7" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">部署各种控制面板组件的选项</li><li id="be31" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">仔细考虑你的控制平面的测试装具</li></ul><p id="97b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在前面的<a class="ae kl" href="https://medium.com/solo-io/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration-c97e8124b9d1" rel="noopener">条目</a>中，我们探索了为您的控制平面构建一个特定于领域的API，它最适合您的组织和工作流偏好/约束。</p><p id="5efd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Envoy是一款非常强大的软件，每天都有新的用例以及新的贡献被提交给社区。虽然Envoy的核心非常稳定，但它建立在一个<a class="ae kl" href="https://github.com/envoyproxy/envoy-filter-example" rel="noopener ugc nofollow" target="_blank">可插拔过滤器架构</a>上，因此人们可以为不同的L7协议编写新的编解码器或添加新的功能。目前，Envoy过滤器是用C++编写的，并且有一个选项可以用<a class="ae kl" href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http_filters/lua_filter" rel="noopener ugc nofollow" target="_blank"> Lua </a>扩展Envoy，但是也有<a class="ae kl" href="https://github.com/envoyproxy/envoy/issues/4272" rel="noopener ugc nofollow" target="_blank">讨论支持Web组装</a>的可扩展性。同样值得注意的是，Cilium<a class="ae kl" href="https://cilium.io/" rel="noopener ugc nofollow" target="_blank">的优秀人员正在为特使</a>围绕<a class="ae kl" href="https://cilium.io/blog/2018/10/23/cilium-13-envoy-go/" rel="noopener ugc nofollow" target="_blank">基于Go的扩展机制所做的工作。除了快速发展的Envoy社区和配置这些新功能的需求之外，还需要包含新的特定于领域的对象模型，以支持希望利用Envoy的新平台。在本节中，我们将探索沿着这两个维度扩展特使控制平面。</a></p><p id="4efa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过编写C++过滤器来扩展Envoy相当简单。我们在<a class="ae kl" href="https://github.com/solo-io/envoy-gloo" rel="noopener ugc nofollow" target="_blank"> Gloo项目</a>中创建的特使过滤器包括:</p><ul class=""><li id="8e67" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated"><a class="ae kl" href="https://github.com/solo-io/squash" rel="noopener ugc nofollow" target="_blank"> Squash </a>调试器(<a class="ae kl" href="https://github.com/envoyproxy/envoy/tree/master/api/envoy/config/filter/http/squash" rel="noopener ugc nofollow" target="_blank">https://github . com/envoy proxy/envoy/tree/master/API/envoy/config/filter/http/Squash</a>)</li><li id="0d0f" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">缓存(目前关闭源码；应该会在不久的将来开放源代码)</li><li id="c028" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">请求/响应转换(<a class="ae kl" href="https://github.com/solo-io/envoy-gloo/tree/master/source/extensions/filters/http/transformation" rel="noopener ugc nofollow" target="_blank">https://github . com/solo-io/envoy-gloo/tree/master/source/extensions/filters/http/Transformation</a>)</li><li id="f466" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">AWS lambda(<a class="ae kl" href="https://github.com/solo-io/envoy-gloo/tree/master/source/extensions/filters/http/aws_lambda" rel="noopener ugc nofollow" target="_blank">https://github . com/solo-io/envoy-gloo/tree/master/source/extensions/filters/http/AWS _ lambda</a></li><li id="c094" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">NATS流媒体(<a class="ae kl" href="https://github.com/solo-io/envoy-nats-streaming" rel="noopener ugc nofollow" target="_blank">https://github.com/solo-io/envoy-nats-streaming</a>，<a class="ae kl" href="https://github.com/solo-io/envoy-gloo/tree/master/source/extensions/filters/http/nats/streaming" rel="noopener ugc nofollow" target="_blank">https://github . com/solo-io/envoy-gloo/tree/master/source/extensions/filters/http/NATs/streaming</a>)</li><li id="0cbd" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">谷歌云功能(【https://github.com/solo-io/envoy-google-function】T4)</li><li id="411a" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">天蓝色函数(<a class="ae kl" href="https://github.com/solo-io/envoy-azure-functions" rel="noopener ugc nofollow" target="_blank">https://github.com/solo-io/envoy-azure-functions</a>)</li></ul><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="ab gu cl lg"><img src="../Images/27d954472139203cc0e51619b7821ee7.png" data-original-src="https://miro.medium.com/v2/0*RaU4vOteNufOnrRc.gif"/></div></figure><p id="d5c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上图中，我们可以看到一个请求如何流经Envoy，并通过许多过滤器，这些过滤器具有适用于请求和响应的专门任务。你可以在由Solo.io首席执行官/创始人和Solo.io首席架构师撰写的博客文章中了解更多关于特使的力量和我们在建造Gloo的控制平面时所做的权衡。</p><p id="0765" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于Envoy功能多样，而且新功能一直在增加，因此值得花些时间考虑是否要构建可扩展的控制平面，以便能够使用这些新功能。在Gloo项目中，我们选择在以下几个层面进行:</p><ul class=""><li id="5eb1" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">在一个<em class="la">核心</em> Gloo配置对象之上构建更多自以为是的特定领域配置对象</li><li id="865c" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">控制平面<em class="la">插件</em>增加控制平面的现有行为</li><li id="7c66" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">创建工具来加速前面两点</li></ul><p id="fa7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看每一个级别，以及它们如何构成一个可扩展且灵活的控制平面。</p><p id="08a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上一节中，我们重点讨论了用于配置控制平面的特定于域的配置对象。在Gloo中，我们有称为<a class="ae kl" href="https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/proxy.proto.sk/" rel="noopener ugc nofollow" target="_blank">代理</a>和<a class="ae kl" href="https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/upstream.proto.sk/" rel="noopener ugc nofollow" target="_blank">上游</a>的<a class="ae kl" href="https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/proxy.proto.sk/" rel="noopener ugc nofollow" target="_blank">最低级别配置对象</a>。<code class="fe lj lk ll lm b">Proxy</code>定义了我们可以在底层代理(在本例中是特使)上进行的最低级别配置。通过<code class="fe lj lk ll lm b">Proxy</code>对象，我们定义了请求如何被路由到<code class="fe lj lk ll lm b">Upstreams</code>。</p><p id="2e92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是代理对象的一个例子(在这个例子中是Kubernetes中的一个CRD):</p><pre class="lb lc ld le gt ln lm lo lp aw lq bi"><span id="a0ed" class="lr ls iq lm b gy lt lu l lv lw">apiVersion: <a class="ae kl" href="http://gloo.solo.io/v1" rel="noopener ugc nofollow" target="_blank">gloo.solo.io/v1</a><br/>kind: Proxy<br/>metadata:<br/> clusterName: ""<br/> creationTimestamp: "2019-02-15T13:27:39Z"<br/> generation: 1<br/> labels:<br/> created_by: gateway<br/> name: gateway-proxy<br/> namespace: gloo-system<br/> resourceVersion: "5209108"<br/> selfLink: /apis/gloo.solo.io/v1/namespaces/gloo-system/proxies/gateway-proxy<br/> uid: 771377f2-3125-11e9-8523-42010aa800e0<br/>spec:<br/> listeners:<br/> - bindAddress: '::'<br/> bindPort: 8080<br/> httpListener:<br/> virtualHosts:<br/> - domains:<br/> - '*'<br/> name: gloo-system.default<br/> routes:<br/> - matcher:<br/> exact: /petstore/findPet<br/> routeAction:<br/> single:<br/> destinationSpec:<br/> rest:<br/> functionName: findPetById<br/> parameters: {}<br/> upstream:<br/> name: default-petstore-8080<br/> namespace: gloo-system<br/> - matcher:<br/> exact: /sample-route-1<br/> routeAction:<br/> single:<br/> upstream:<br/> name: default-petstore-8080<br/> namespace: gloo-system<br/> routePlugins:<br/> prefixRewrite:<br/> prefixRewrite: /api/pets<br/> name: gateway<br/>status:<br/> reported_by: gloo<br/> state: 1</span></pre><p id="9284" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以看到<code class="fe lj lk ll lm b">Proxy</code>对象指定了监听器、它们的类型以及路由信息。如果你仔细观察，你会发现它在一定程度上遵循了Envoy的配置<em class="la">但又支持额外的功能。在路由中，您可以看到请求被发送到“上游”。Gloo知道如何路由到<a class="ae kl" href="https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/upstream.proto.sk/" rel="noopener ugc nofollow" target="_blank">上游</a>，你可以在上面的<code class="fe lj lk ll lm b">Proxy</code>对象中看到这些定义。<code class="fe lj lk ll lm b">Proxy</code>对象是由Gloo的控制平面转换为Envoy xDS API的对象。如果我们看一下组成Gloo的组件，我们会看到以下内容:</em></p><pre class="lb lc ld le gt ln lm lo lp aw lq bi"><span id="80a9" class="lr ls iq lm b gy lt lu l lv lw">NAME READY STATUS RESTARTS AGE<br/>discovery-676bcc49f8-n55jt 1/1 Running 0 8m<br/>gateway-d8598c78c-425hz 1/1 Running 0 8m<br/>gateway-proxy-6b4b86b4fb-cm2cr 1/1 Running 0 8m<br/>gloo-565659747c-x7lvf 1/1 Running 0 8m</span></pre><p id="9f29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lj lk ll lm b">gateway-proxy</code>组件是特使代理。控制平面由以下组件组成:</p><p id="e68e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">负责此<code class="fe lj lk ll lm b">Proxy</code> - &gt; Envoy xDS转换的组件是<code class="fe lj lk ll lm b">gloo</code>，它是一个事件驱动的组件，通过将<code class="fe lj lk ll lm b">Proxy</code>对象转换为Envoy的LDS/RDS/CDS/EDS API来负责核心xDS服务和自定义Envoy过滤器的配置</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="ab gu cl lg"><img src="../Images/99f707dcc6672ee0a897af8207c4a430.png" data-original-src="https://miro.medium.com/v2/format:webp/0*LC2bqpUKb07rrguE.png"/></div></figure><p id="1ee7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Gloo知道如何路由到存在于<code class="fe lj lk ll lm b">Upstreams</code>上的<code class="fe lj lk ll lm b">Upstream</code>和功能。<a class="ae kl" href="https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/upstream.proto.sk/" rel="noopener ugc nofollow" target="_blank">上游</a>也是Gloo的一个核心配置对象。我们需要这个上游对象的原因是为了封装更多关于上游集群能力的保真度，而不是Envoy所知道的现成内容。Envoy知道“集群”，但是Gloo(在Envoy之上)知道函数。这些知识使得<a class="ae kl" href="https://medium.com/solo-io/announcing-gloo-the-function-gateway-3f0860ef6600" rel="noopener">功能级路由</a>成为可能，这是一个更强大的路由构造，用于组合新的应用程序和API。Envoy从“host:port”端点的角度了解集群，但是使用Gloo，我们可以为这些集群附加额外的上下文，以便它们理解“函数”,这些函数可以是REST方法/路径、gRPC操作或Lambda之类的云函数。例如，这里有一个Gloo上游名为<code class="fe lj lk ll lm b">default-petstore-8080</code>:</p><pre class="lb lc ld le gt ln lm lo lp aw lq bi"><span id="6b71" class="lr ls iq lm b gy lt lu l lv lw">---<br/>discoveryMetadata: {}<br/>metadata:<br/> labels:<br/> discovered_by: kubernetesplugin<br/> service: petstore<br/> sevice: petstore<br/> name: default-petstore-8080<br/> namespace: gloo-system<br/>status:<br/> reportedBy: gloo<br/> state: Accepted<br/>upstreamSpec:<br/> kube:<br/> selector:<br/> app: petstore<br/> serviceName: petstore<br/> serviceNamespace: default<br/> servicePort: 8080<br/> serviceSpec:<br/> rest:<br/> swaggerInfo:<br/> url: <a class="ae kl" href="http://petstore.default.svc.cluster.local:8080/swagger.json" rel="noopener ugc nofollow" target="_blank">http://petstore.default.svc.cluster.local:8080/swagger.json</a><br/> transformations:<br/> addPet:<br/> body:<br/> text: '{"id": {{ default(id, "") }},"name": "{{ default(name, "")}}","tag":<br/> "{{ default(tag, "")}}"}'<br/> headers:<br/> :method:<br/> text: POST<br/> :path:<br/> text: /api/pets<br/> content-type:<br/> text: application/json<br/> deletePet:<br/> headers:<br/> :method:<br/> text: DELETE<br/> :path:<br/> text: /api/pets/{{ default(id, "") }}<br/> content-type:<br/> text: application/json<br/> findPetById:<br/> body: {}<br/> headers:<br/> :method:<br/> text: GET<br/> :path:<br/> text: /api/pets/{{ default(id, "") }}<br/> content-length:<br/> text: "0"<br/> content-type: {}<br/> transfer-encoding: {}<br/> findPets:<br/> body: {}<br/> headers:<br/> :method:<br/> text: GET<br/> :path:<br/> text: /api/pets?tags={{default(tags, "")}}&amp;limit={{default(limit,<br/> "")}}<br/> content-length:<br/> text: "0"<br/> content-type: {}<br/> transfer-encoding: {}</span></pre><p id="29b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我们在这个上游暴露什么功能方面有更多的保真度。在这种情况下，上游恰好是一个REST服务，公开了一个<a class="ae kl" href="https://github.com/OAI/OpenAPI-Specification" rel="noopener ugc nofollow" target="_blank"> Open API Spec/Swagger </a>文档。Gloo自动发现了这些信息，并用这些信息丰富了上游对象，然后可以在代理对象中使用这些信息。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="ab gu cl lg"><img src="../Images/f674015c7d694de9527373b8906ed083.png" data-original-src="https://miro.medium.com/v2/format:webp/0*J9SLX5o4ES6FBo2q.png"/></div></figure><p id="5a53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你回头参考Gloo控制平面中的组件，你会看到一个<code class="fe lj lk ll lm b">discovery</code>组件，它通过添加“上游发现服务”(UDS)和“功能发现服务”(FDS)来增强Envoy的发现API。UDS使用一组插件(见下一节)从各自的运行时目录中自动发现<code class="fe lj lk ll lm b">Upstream</code>。最简单的例子是在Kubernetes中运行时，我们可以自动发现<a class="ae kl" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank"> Kubernetes服务</a>。Gloo还可以从Consul、AWS <a class="ae kl" href="https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/plugins.proto.sk/#a-name-upstreamspec-upstreamspec-a" rel="noopener ugc nofollow" target="_blank">等</a>中发现<code class="fe lj lk ll lm b">Upstreams</code>。函数发现服务(FDS)评估每个已经被发现的<code class="fe lj lk ll lm b">Upstreams</code>，并试图发现它们的类型(REST、gRPC、GraphQL、AWS Lambda等)。如果FDS可以发现这些关于上游的附加属性，它就可以用这些“功能”来丰富上游元数据。</p><p id="0d59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Gloo控制平面中的<code class="fe lj lk ll lm b">discovery</code>组件仅使用其UDS和FDS服务来发现<code class="fe lj lk ll lm b">Upstream</code>对象并将其写入Kuberentes CRDs。从那里，用户可以创建从特使代理上的特定API路径到<code class="fe lj lk ll lm b">Upstream</code>上的特定函数的路由规则。特使代理不直接与这个控制平面组件交互(回想一下，特使只使用由<code class="fe lj lk ll lm b">gloo</code>组件公开的xDS API)。相反，<code class="fe lj lk ll lm b">discovery</code>组件<em class="la">有助于</em>创建<code class="fe lj lk ll lm b">Upstream</code>然后被<code class="fe lj lk ll lm b">Proxy</code>对象使用。这是一个使用支持微服务(本例中的<code class="fe lj lk ll lm b">discovery</code>服务)为控制平面的整体功能做出贡献的好例子。</p><p id="53cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lj lk ll lm b">Proxy</code>和<code class="fe lj lk ll lm b">Upstream</code>是上一节提到的较低级别的特定于域的配置对象。更有趣的是，我们如何在此基础上分层一组配置对象，以满足具有更自以为是的工作流的用户特定的用例。</p><p id="4d6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Gloo的控制平面中，还有另一个组件叫做<code class="fe lj lk ll lm b">gateway</code>组件。该组件实现了更高级别的特定于域的配置，用户将最终与之交互(直接通过YAML文件或间接通过<code class="fe lj lk ll lm b">glooctl</code> CLI工具)。<code class="fe lj lk ll lm b">gateway</code>组件知道两个领域特定的对象:</p><ul class=""><li id="6edd" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated"><a class="ae kl" href="https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gateway/api/v1/gateway.proto.sk/" rel="noopener ugc nofollow" target="_blank">网关</a> —指定特定监听器端口上可用的路由和API端点，以及每个API附带的安全性</li><li id="1086" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated"><a class="ae kl" href="https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gateway/api/v1/virtual_service.proto.sk/" rel="noopener ugc nofollow" target="_blank"> VirtualService </a> —将API路由分组为一组“虚拟API”，这些API可以路由到后台函数(gRPC、http/1、http/2、lambda等)；让开发人员控制一条路线如何进行不同的转换，试图将前端API从后端中分离出来(以及后端可能引入的任何重大变化)</li></ul><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="ab gu cl lg"><img src="../Images/fc4250a9aeb816c25ad3e0a0c548bd8a.png" data-original-src="https://miro.medium.com/v2/format:webp/0*l5Rm5YI6COLm5Dh-.png"/></div></figure><p id="7952" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些对象允许从<code class="fe lj lk ll lm b">Proxy</code>对象解耦。当用户使用更符合人体工程学的或自以为是的API创建新的<code class="fe lj lk ll lm b">Gateway</code>或<code class="fe lj lk ll lm b">VirtualService</code>对象时，Gloo的<code class="fe lj lk ll lm b">gateway</code>组件获取这些对象(Kubernetes中的CRD，Consul中的配置条目)并更新底层的<code class="fe lj lk ll lm b">Proxy</code>对象。这是扩展Gloo的一种常见模式:偏好控制平面组件的可组合性。这允许我们为更具观点的特定于域的对象构建更专用的控制器，以支持不同的用途。例如，<a class="ae kl" href="https://solo.io/" rel="noopener ugc nofollow" target="_blank"> Solo.io </a>团队还为Gloo构建了一个名为<a class="ae kl" href="https://sqoop.solo.io/" rel="noopener ugc nofollow" target="_blank"> Sqoop </a>的开源控制器，它遵循相同的模式，并扩展了Gloo API，用于声明基于具有GraphQL模式的<a class="ae kl" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL引擎</a>的路由规则。在Sqoop中，我们引入了<a class="ae kl" href="https://sqoop.solo.io/introduction/concepts/api_objects/" rel="noopener ugc nofollow" target="_blank">模式和ResolverMaps </a>对象，它们最终构成了代理对象，然后被转换为Envoy xDS。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="ab gu cl lg"><img src="../Images/b10d74490ccbc48036e254caa81946cd.png" data-original-src="https://miro.medium.com/v2/format:webp/0*kwdQ5FKYuBkbca0E.png"/></div></figure><p id="3f56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">构建在基本Gloo对象上的特定领域配置分层的另一个例子是我们最近在<a class="ae kl" href="https://medium.com/solo-io/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative-324753586f3a" rel="noopener"> Knative中使用Gloo代理作为Istio </a>的替代。Knative有一个用于声明集群入口资源的特定对象，称为<a class="ae kl" href="https://github.com/knative/serving/blob/master/pkg/client/clientset/versioned/typed/networking/v1alpha1/clusteringress.go" rel="noopener ugc nofollow" target="_blank"> ClusterIngress </a>对象，如下所示:</p><pre class="lb lc ld le gt ln lm lo lp aw lq bi"><span id="1e54" class="lr ls iq lm b gy lt lu l lv lw">apiVersion: <a class="ae kl" href="http://networking.internal.knative.dev/v1alpha1" rel="noopener ugc nofollow" target="_blank">networking.internal.knative.dev/v1alpha1</a><br/>kind: ClusterIngress<br/>metadata:<br/> labels:<br/> <a class="ae kl" href="http://serving.knative.dev/route" rel="noopener ugc nofollow" target="_blank">serving.knative.dev/route</a>: helloworld-go<br/> <a class="ae kl" href="http://serving.knative.dev/routeNamespace" rel="noopener ugc nofollow" target="_blank">serving.knative.dev/routeNamespace</a>: default<br/> name: helloworld-go-txrqt<br/>spec:<br/> generation: 2<br/> rules:<br/> - hosts:<br/> - <a class="ae kl" href="http://helloworld-go.default.example.com/" rel="noopener ugc nofollow" target="_blank">helloworld-go.default.example.com</a><br/> - helloworld-go.default.svc.cluster.local<br/> - helloworld-go.default.svc<br/> - helloworld-go.default<br/> http:<br/> paths:<br/> - appendHeaders:<br/> knative-serving-namespace: default<br/> knative-serving-revision: helloworld-go-00001<br/> retries:<br/> attempts: 3<br/> perTryTimeout: 10m0s<br/> splits:<br/> - percent: 100<br/> serviceName: activator-service<br/> serviceNamespace: knative-serving<br/> servicePort: 80<br/> timeout: 10m0s<br/> visibility: ExternalIP</span></pre><p id="4a28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了在Gloo中支持这个用例，我们所做的就是<a class="ae kl" href="https://github.com/solo-io/gloo/blob/ac3bddf202423b297fb909eb6eff498745a8c015/projects/clusteringress/pkg/translator/translate.go#L19" rel="noopener ugc nofollow" target="_blank">构建一个新的控制器，它监视</a>并将<a class="ae kl" href="https://github.com/knative/serving/blob/master/pkg/client/clientset/versioned/typed/networking/v1alpha1/clusteringress.go" rel="noopener ugc nofollow" target="_blank"> ClusterIngress </a>对象转换成Gloo的<a class="ae kl" href="https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/proxy.proto.sk/" rel="noopener ugc nofollow" target="_blank">代理</a>。有关在Knative 中使用Gloo来简化<a class="ae kl" href="https://github.com/knative/serving" rel="noopener ugc nofollow" target="_blank"> Knative Serving </a>安装以使用Gloo作为集群入口的更多信息，请参见<a class="ae kl" href="https://blog.christianposta.com/guidance-for-building-a-control-plane-for-envoy-build-for-pluggability/MISSING" rel="noopener ugc nofollow" target="_blank">这篇博客。</a></p><p id="fb63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上一节中，我们看到了通过在核心对象之上分层特定于域的配置对象来扩展控制平面的功能。另一个扩展点直接位于控制面板核心对象本身。在Istio中是<code class="fe lj lk ll lm b">VirtualService</code>和<code class="fe lj lk ll lm b">DestinationRule</code>，在Contour中是<code class="fe lj lk ll lm b">IngressRoute</code>，在Gloo中是<code class="fe lj lk ll lm b">Proxy</code>和<code class="fe lj lk ll lm b">Upstream</code>对象。例如，Gloo的<a class="ae kl" href="https://github.com/solo-io/gloo/blob/7a5c3a9a7a060841a7047efce79e5b7b3ed981be/projects/gloo/api/v1/proxy.proto#L30" rel="noopener ugc nofollow" target="_blank">代理对象</a>包含了<a class="ae kl" href="https://github.com/solo-io/gloo/blob/7a5c3a9a7a060841a7047efce79e5b7b3ed981be/projects/gloo/api/v1/proxy.proto#L90" rel="noopener ugc nofollow" target="_blank">监听器</a>、<a class="ae kl" href="https://github.com/solo-io/gloo/blob/7a5c3a9a7a060841a7047efce79e5b7b3ed981be/projects/gloo/api/v1/proxy.proto#L124" rel="noopener ugc nofollow" target="_blank">虚拟主机</a>和<a class="ae kl" href="https://github.com/solo-io/gloo/blob/7a5c3a9a7a060841a7047efce79e5b7b3ed981be/projects/gloo/api/v1/proxy.proto#L154" rel="noopener ugc nofollow" target="_blank">路由</a>的扩展点。这意味着在代理配置中有明确定义的点，我们可以在配置中引入新的功能(例如，如果我们希望公开新的Envoy功能，或者如果我们为我们希望公开配置的Envoy编写新的过滤器，等等)。尽量不大惊小怪。例如，我们编写了一些<a class="ae kl" href="https://github.com/solo-io/gloo/blob/a27e1018640c46f7a25e4c1a0dc1f4cadf1773f5/projects/gloo/api/v1/plugins.proto#L44" rel="noopener ugc nofollow" target="_blank">插件，丰富了Envoy的路由和转换功能</a>。例如，要转换进入Envoy并被指定给名为<code class="fe lj lk ll lm b">foo-service</code>的服务的请求，我们可以使用<a class="ae kl" href="https://github.com/pantor/inja" rel="noopener ugc nofollow" target="_blank"> Inja模板</a>来管理消息头或消息体。更多信息参见Gloo文档中的<a class="ae kl" href="https://gloo.solo.io/user_guides/function_routing/" rel="noopener ugc nofollow" target="_blank">功能路由指南。</a></p><pre class="lb lc ld le gt ln lm lo lp aw lq bi"><span id="0e5f" class="lr ls iq lm b gy lt lu l lv lw">routes:<br/>- matcher:<br/> prefix: /<br/> routeAction:<br/> single:<br/> upstream:<br/> name: foo-service<br/> namespace: default<br/> routePlugins:<br/> transformations:<br/> requestTransformation:<br/> transformationTemplate:<br/> headers:<br/> x-canary-foo<br/> text: foo-bar-v2<br/> :path:<br/> text: /v2/canary/feature<br/> passthrough: {}</span></pre><p id="92f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要查看Gloo <a class="ae kl" href="https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/proxy.proto.sk/" rel="noopener ugc nofollow" target="_blank">代理</a>和<a class="ae kl" href="https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/upstream.proto.sk/" rel="noopener ugc nofollow" target="_blank">上游</a>对象上可用插件的完整列表，请参见<a class="ae kl" href="https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/plugins.proto.sk/" rel="noopener ugc nofollow" target="_blank">这里的文档</a></p><p id="cf82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦您向控制平面添加了新插件，您就可以扩展面向用户的特定于域的配置对象，以利用这些新功能。您可以扩充现有的控制器来实现这一点，或者添加新的控制器(遵循微服务相互松散协调的原则)。我们已经编写了<a class="ae kl" href="https://gloo.solo.io/dev/example-proxy-controller/" rel="noopener ugc nofollow" target="_blank">大量的例子来帮助你编写控制器</a>来增强你的控制平面功能，或者在<a class="ae kl" href="https://slack.solo.io/" rel="noopener ugc nofollow" target="_blank"> Slack </a>上寻找更多关于这方面的指导。</p><p id="73e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在前面的章节中，我们看到了如何考虑控制平面的可扩展性和灵活性。我们看到了使用多层特定于域的配置对象如何通过添加新的对象和控制器来实现可扩展性。在<a class="ae kl" href="https://solo.io/" rel="noopener ugc nofollow" target="_blank"> Solo.io </a>中，我们创建了一个名为<a class="ae kl" href="https://github.com/solo-io/solo-kit" rel="noopener ugc nofollow" target="_blank"> solo-kit </a>的开源项目，通过从<a class="ae kl" href="https://developers.google.com/protocol-buffers/" rel="noopener ugc nofollow" target="_blank"> protobuf </a>对象开始，并代码生成正确的类型安全客户端，以便在您的平台上与这些对象进行交互，从而加速为您的控制平面构建新的、声明性的、自以为是的API对象。例如，在Kubernetes上，<a class="ae kl" href="https://github.com/solo-io/solo-kit" rel="noopener ugc nofollow" target="_blank"> solo-kit </a>将这些原型转化为<a class="ae kl" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank">customresourcediefinitions</a>并生成Golang Kubernetes客户端来观看这些资源并与之交互。如果你不在Kubernetes上，你也可以使用Consul、Vault和许多其他东西作为后端存储。</p><p id="e858" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦创建了资源并生成了类型安全的客户端，您将希望检测用户何时创建新资源或对现有资源进行更改。使用<a class="ae kl" href="https://github.com/solo-io/solo-kit" rel="noopener ugc nofollow" target="_blank"> solo-kit </a>你只需指定你希望观看的资源，或者称为“快照”的资源组合，客户端运行一个事件循环来处理任何通知。在您的事件循环中，您可以更新协作对象或核心对象。事实上，这就是Gloo的分层领域特定配置对象的工作方式。更多信息参见<a class="ae kl" href="https://gloo.solo.io/operator_guide/gloo_declarative_model/" rel="noopener ugc nofollow" target="_blank"> Gloo声明性模型文档</a>。</p><p id="70a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">控制平面可以根据您的需要简单或复杂。Gloo团队建议将重点放在控制平面的简单核心上，然后通过插件和微服务控制器通过可组合性来扩展它。Gloo的架构就是这样构建的，并使<a class="ae kl" href="https://github.com/solo-io/gloo/graphs/contributors" rel="noopener ugc nofollow" target="_blank">Gloo团队</a>能够快速添加任何新功能，以支持任何平台、配置、过滤器等。这就是为什么，虽然Gloo是非常Kubernetes-native的，但它是为在任何云上的任何平台上运行而构建的。核心控制平面设计允许这一点。</p><p id="763f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本系列的下一部分中，我们将看看部署控制平面组件在可伸缩性、容错性、独立性和安全性等方面的利弊。<a class="ae kl" href="https://twitter.com/soloio_inc" rel="noopener ugc nofollow" target="_blank">敬请期待</a>！</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><p id="374c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="la">原载于2019年4月2日</em><a class="ae kl" href="https://medium.com/solo-io/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility-40f8ac8e48e" rel="noopener"><em class="la">medium.com</em></a><em class="la">。</em></p></div></div>    
</body>
</html>