<html>
<head>
<title>Typing React (1) — Basic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">键入React (1) —基本</h1>
<blockquote>原文：<a href="https://itnext.io/typing-react-1-basic-488f661149f6?source=collection_archive---------4-----------------------#2019-05-26">https://itnext.io/typing-react-1-basic-488f661149f6?source=collection_archive---------4-----------------------#2019-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/dc23fa3be495db7d192bdca3fd5e4627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NIQhzeOwp7vi7DiycOqVjw.png"/></div></figure><p id="5b5e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">TypeScript越来越受欢迎。键入系统有助于在编译时消除大多数编码错误。一般来说，TypeScript花费你大量的时间在编码和打字上，但是稍后我会为你节省更多的调试时间。</p><p id="e9c4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">本系列文章试图简化打字的痛苦工作，尤其是当您不太熟悉TypeScript时。因此，我们将把重点放在类型上，而不是其他——任何与TypeScript无关的东西，比如redux的使用，都将被忽略。</p><p id="89fd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个系列的演示项目可以在我的GitHub下载:<a class="ae kv" href="https://github.com/charlee/todolist" rel="noopener ugc nofollow" target="_blank">https://github.com/charlee/todolist</a>。</p><h1 id="51b3" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">创建项目</h1><p id="5978" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">流行的<code class="fe lz ma mb mc b">create-react-app</code>工具现在支持直接用TypeScript创建应用程序。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="6daf" class="ml kx it mc b gy mm mn l mo mp">$ create-react-app todolist --typescript<br/>$ cd todolist</span></pre><p id="2aa9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">打开项目文件夹，你会看到<code class="fe lz ma mb mc b">index.tsx</code>和<code class="fe lz ma mb mc b">App.tsx</code>文件。命名约定是，最初使用JSX的文件以<code class="fe lz ma mb mc b">.tsx</code>结尾，纯类型脚本文件以<code class="fe lz ma mb mc b">.ts</code>结尾。</p><p id="8b93" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您可能注意到TypeScript抱怨React的导出有一个隐式的<code class="fe lz ma mb mc b">any</code>类型。这是因为最初的React不包含任何类型定义。通过安装<code class="fe lz ma mb mc b">@types/react</code>来解决这个问题:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="0c58" class="ml kx it mc b gy mm mn l mo mp">$ npm install --save @types/react</span></pre><p id="def1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我还会推荐在项目根目录中添加一个<code class="fe lz ma mb mc b">.prettierrc.yaml</code>，内容如下。如果您使用的是Visual Studio代码，可以按Cmd+Shift+F (Mac)或Ctrl+Shift+I (Windows/Linux)来自动格式化文件:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="5ec8" class="ml kx it mc b gy mm mn l mo mp">printWidth: 90<br/>tabWidth: 2<br/>singleQuote: true<br/>trailingComma: all</span></pre><h1 id="2729" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">成分</h1><p id="7c2c" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">在一个地方定义所有的数据模型也是有用的，即<code class="fe lz ma mb mc b">src/models/types.d.ts</code>:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="062d" class="ml kx it mc b gy mm mn l mo mp">declare module 'Models' {<br/>  export interface Todo {<br/>    id: number;<br/>    text: string;<br/>    done: boolean;<br/>  };<br/><br/>  export type TodoList = Todo[];<br/>}</span></pre><p id="0821" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">创建组件时，需要为道具创建一个接口类型:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="1c29" class="ml kx it mc b gy mm mn l mo mp">import React, { useState } from 'react';<br/>import { Todo } from 'Models';<br/><br/>export interface IProps {<br/>  todo: Todo;<br/>}<br/><br/>const Todo: React.FC&lt;Todo&gt; = props =&gt; {<br/>  const { todo } = props;<br/>  const [expanded, setExpanded] = useState&lt;boolean&gt;(false);<br/>  return &lt;div&gt;{todo.text}&lt;/div&gt;;<br/>};<br/><br/>export default Todo;</span></pre><p id="355b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">或者，如果您需要用类定义旧样式组件，您可以这样做:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="23b1" class="ml kx it mc b gy mm mn l mo mp">import React from 'react';<br/>import { Todo } from 'Models';<br/><br/>export interface IProps {<br/>  todo: Todo;<br/>}<br/><br/>export interface IState {<br/>  expanded: boolean;<br/>}<br/><br/>class Todo extends React.Component&lt;IProps, IState&gt; {<br/>  state: IState = {<br/>    expanded: false,<br/>  };<br/><br/>  render() {<br/>    const { todo } = this.props;<br/>    return &lt;div&gt;{todo.text}&lt;/div&gt;;<br/>  }<br/>}<br/><br/>export default Todo;</span></pre><p id="b202" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注意，在类定义中，我们需要显式定义<code class="fe lz ma mb mc b">state</code>属性的类型。这是因为TypeScript无法从类(即<code class="fe lz ma mb mc b">React.Component&lt;IProps, IState&gt;</code>)中推断其类型。省略类似<code class="fe lz ma mb mc b">state = { expanded: false }</code>的类型适用于这种简单的情况，但是如果状态包含任何类型化的列表，TypeScript将抱怨空列表不符合列表的类型:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="5c36" class="ml kx it mc b gy mm mn l mo mp">// State type definition<br/>export interface IState {<br/>  todos: Todo[];<br/>}<br/><br/>class TodoList extends React.Component&lt;IProps, IState&gt; {<br/>  state = { todos: [] };  // WRONG: [] does not match Todo[]<br/>}</span></pre><h1 id="b54e" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">通用组件</h1><p id="5b75" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">TypeScript的一个优点是通用性。它允许我们从代码中提取算法。类似地，我们也可以创建通用组件来处理一些常见的UI行为。</p><p id="5953" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">下面的例子展示了一个名为<code class="fe lz ma mb mc b">FilteredList</code>的通用组件。它接受任意类型的对象列表和一个过滤函数，并用过滤函数过滤对象列表，然后将过滤后的列表传递给其子对象。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="9216" class="ml kx it mc b gy mm mn l mo mp">import React from 'react';<br/><br/>export interface IProps&lt;T&gt; {<br/>  objects: T[];<br/>  filter: (o: T) =&gt; boolean;<br/>  children: (objects: T[]) =&gt; JSX.Element;<br/>}<br/><br/>const FilteredList = &lt;T extends {}&gt;(props: IProps&lt;T&gt;) =&gt; {<br/>  const { children, objects, filter } = props;<br/>  const filtered = objects.filter(o =&gt; filter(o));<br/>  return &lt;React.Fragment&gt;{children(filtered)}&lt;/React.Fragment&gt;;<br/>};<br/><br/>export default FilteredList;</span></pre><p id="d965" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在上面的代码中，我们使用了一个技巧<code class="fe lz ma mb mc b">&lt;T extends {}&gt;</code>而不是<code class="fe lz ma mb mc b">&lt;T&gt;</code>。尽管<code class="fe lz ma mb mc b">&lt;T&gt;</code>在TypeScript中是合法的，但在JSX中它会被识别为一个标签，并产生一个编译错误。</p><p id="b944" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">请注意，尽管<code class="fe lz ma mb mc b">FilteredList</code>是泛型，但在某些情况下它可以直接使用，因为TypeScript可以从其属性中推断出其类型参数:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="df62" class="ml kx it mc b gy mm mn l mo mp">export interface Todo {<br/>  id: number;<br/>  name: string;<br/>}<br/><br/>export interface IProps {<br/>  todos: Todo[];<br/>}<br/><br/>const TodoList: React.FC&lt;IProps&gt; = props =&gt; {<br/>  const { todos } = props;<br/>  return (<br/>    &lt;FilteredList objects={todos} filter={o =&gt; o.name.startsWith('[URGENT]')}&gt;<br/>      {todos =&gt; (<br/>        &lt;React.Fragment&gt;<br/>          {todos.map(todo =&gt; (<br/>            &lt;TodoItem todo={todo} /&gt;<br/>          ))}<br/>        &lt;/React.Fragment&gt;<br/>      )}<br/>    &lt;/FilteredList&gt;<br/>  );<br/>};</span></pre><p id="d9ec" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里我们没有指定使用<code class="fe lz ma mb mc b">&lt;FilteredList&gt;</code>时<code class="fe lz ma mb mc b">T</code>是什么。完全是从它的<code class="fe lz ma mb mc b">objects</code>属性推断出来的。</p><p id="7bbe" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个帖子到此为止。我知道我没有涵盖关于打字的所有内容，所以欢迎您在这里评论任何您认为值得一提的内容。感谢阅读！</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><p id="6f4b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="mx">原载于2019年5月26日</em><a class="ae kv" href="https://charlee.li/typeing-react-1-basic/" rel="noopener ugc nofollow" target="_blank"><em class="mx">charlee . Li</em></a><em class="mx">。</em></p></div></div>    
</body>
</html>