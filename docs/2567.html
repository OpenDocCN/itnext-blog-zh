<html>
<head>
<title>Declarative Idempotency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">陈述幂等性</h1>
<blockquote>原文：<a href="https://itnext.io/declarative-idempotency-aaa07c6dd9a0?source=collection_archive---------2-----------------------#2019-06-16">https://itnext.io/declarative-idempotency-aaa07c6dd9a0?source=collection_archive---------2-----------------------#2019-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="03c2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">迫使工程师编写经验证的、一致记录的和幂等的代码，而他们甚至没有意识到</h2></div><p id="f93d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le"/>第七部分<a class="ae lf" href="https://medium.com/@cjkuech/declarative-devops-microframeworks-9908c8d05332" rel="noopener"> <em class="le">声明式DevOps微框架</em> </a></p><p id="3d27" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当一个脚本可以多次运行而没有不同的结果或错误时，它就是<strong class="kk iu">幂等的</strong>。在DevOps中，我们经常描述复杂的系统，然后将它们设置为期望的状态。系统的组件可能处于不同的状态，所以我们的脚本是幂等的并且不假设系统的初始配置是很重要的。</p><p id="723f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了获得幂等性，开发人员通常会应用几种模式中的一种</p><ul class=""><li id="2025" class="lg lh it kk b kl km ko kp kr li kv lj kz lk ld ll lm ln lo bi translated">拆卸和重建，常见于只处理单个启动配置的命令式脚本。</li><li id="5913" class="lg lh it kk b kl lp ko lq kr lr kv ls kz lt ld ll lm ln lo bi translated">重复的<code class="fe lu lv lw lx b">if</code> / <code class="fe lu lv lw lx b">else</code>块，在设置资源之前检查资源是否处于所需状态。</li><li id="4760" class="lg lh it kk b kl lp ko lq kr lr kv ls kz lt ld ll lm ln lo bi translated"><code class="fe lu lv lw lx b">-Force</code>参数用于在资源已经处于所需状态时消除错误。</li><li id="eaf0" class="lg lh it kk b kl lp ko lq kr lr kv ls kz lt ld ll lm ln lo bi translated">声明性框架，在这里您定义了期望的状态，然后让框架来处理初始和中间状态。</li></ul><p id="ac54" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">声明式框架是目前最好的选择；然而，在我们的PowerShell脚本中，没有足够通用的方法来解决任意代码的幂等性。我们将实现我们自己的<a class="ae lf" href="https://medium.com/@cjkuech/declarative-devops-microframeworks-9908c8d05332" rel="noopener">声明性DevOps微框架</a>来为PowerShell添加声明性幂等支持，并自动强制所有代码都是幂等的、经过验证的和一致记录的。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/f4ecbdb5273f0f2649b7346ecdfb58c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*trL6xWvZvHkxucsM"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">电梯按钮是幂等的。在电梯中按下“3”按钮将总是将电梯设置到3楼，而不管该按钮被按下多少次。</figcaption></figure><h1 id="a00d" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">改善期望的状态配置</h1><p id="a025" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">PowerShell已经提供了一个声明性的幂等框架:期望的状态配置。那么我们为什么要自己写呢？</p><h2 id="75ae" class="nl mp it bd mq nm nn dn mu no np dp my kr nq nr na kv ns nt nc kz nu nv ne nw bi translated">好人</h2><p id="4221" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">期望状态配置是用于配置复杂系统的PowerShell语言构造。它们为DevOps提供了各种有价值的好处—</p><ul class=""><li id="4ae2" class="lg lh it kk b kl km ko kp kr li kv lj kz lk ld ll lm ln lo bi translated"><strong class="kk iu">声明性的</strong>，因此您定义了您希望您的配置是什么样子，而不是如何实现您的配置</li><li id="b309" class="lg lh it kk b kl lp ko lq kr lr kv ls kz lt ld ll lm ln lo bi translated"><strong class="kk iu">等幂</strong>，因此您可以根据需要多次应用有效配置，而不会出错</li><li id="5db5" class="lg lh it kk b kl lp ko lq kr lr kv ls kz lt ld ll lm ln lo bi translated"><strong class="kk iu">在编译过程中静态验证</strong>，以便在应用配置之前尽可能多地捕捉错误</li><li id="f64d" class="lg lh it kk b kl lp ko lq kr lr kv ls kz lt ld ll lm ln lo bi translated"><strong class="kk iu">与日志记录</strong>集成，因此我们知道我们的配置是否失败、在哪里失败以及为什么失败</li><li id="5f6e" class="lg lh it kk b kl lp ko lq kr lr kv ls kz lt ld ll lm ln lo bi translated"><strong class="kk iu">自我修复，</strong>定期运行以重新应用漂移的配置</li></ul><h2 id="8fcf" class="nl mp it bd mq nm nn dn mu no np dp my kr nq nr na kv ns nt nc kz nu nv ne nw bi translated">坏事</h2><p id="16a4" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">DSC实际上只是设计用来帮助一群Windows服务器节点异步维护所需的状态。不幸的是，DSC的异步执行模型和对Windows操作系统的依赖排除了它在许多完美的DevOps场景中的应用，例如</p><ul class=""><li id="0810" class="lg lh it kk b kl km ko kp kr li kv lj kz lk ld ll lm ln lo bi translated">命令行界面</li><li id="a5e9" class="lg lh it kk b kl lp ko lq kr lr kv ls kz lt ld ll lm ln lo bi translated">CI/CD脚本</li><li id="fd9c" class="lg lh it kk b kl lp ko lq kr lr kv ls kz lt ld ll lm ln lo bi translated">码头文件</li><li id="f948" class="lg lh it kk b kl lp ko lq kr lr kv ls kz lt ld ll lm ln lo bi translated">Linux操作系统</li></ul><h2 id="f3de" class="nl mp it bd mq nm nn dn mu no np dp my kr nq nr na kv ns nt nc kz nu nv ne nw bi translated">向DSC学习</h2><p id="b863" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">DSC提供了一个不错的资源库，但是复杂的逻辑总是以<code class="fe lu lv lw lx b">Script</code>资源告终，这些资源定义了一个“测试”<code class="fe lu lv lw lx b">scriptblock</code>和一个“集合”<code class="fe lu lv lw lx b">scriptblock</code>。一个理想的框架会盗用这种模式(甚至可能盗用资源库)来声明性地定义资源，然后幂等地将资源设置为它们期望的状态；与DSC不同，这种理想的框架将同步运行，以便将错误传播到主机，并清晰地记录输出。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/b661493ba97e9f480f3737bb54b64247.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*x5bJqGrUAHtZLHGn.jpg"/></div></figure><h1 id="5d23" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">设计一个声明性幂等框架</h1><p id="ff3a" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">为了设计我们的声明性幂等框架，我们将根据一组“需求”来定义系统，必须满足这些“需求”才能使系统处于期望的状态。然后，我们将编写一个引擎，用于将需求幂等地设置为期望的状态，并输出事件以观察引擎的执行——然后，我们可以使用本机<code class="fe lu lv lw lx b">Format-*</code>甚至<code class="fe lu lv lw lx b">Export-Csv</code>cmdlet来格式化事件。</p><h2 id="97f4" class="nl mp it bd mq nm nn dn mu no np dp my kr nq nr na kv ns nt nc kz nu nv ne nw bi translated">申报要求</h2><p id="a216" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">“需求”是系统的一个原子组成部分。它由一个系统必须满足的单个条件或另一个需求的先决条件组成。常见要求包括设置文件内容、设置环境变量、放置二进制文件或安装证书。</p><p id="be25" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个需求，最简单的形式，可以被定义为—</p><ul class=""><li id="97bf" class="lg lh it kk b kl km ko kp kr li kv lj kz lk ld ll lm ln lo bi translated">一个<strong class="kk iu">名</strong>，用于识别测井中的组件。</li><li id="4df3" class="lg lh it kk b kl lp ko lq kr lr kv ls kz lt ld ll lm ln lo bi translated"><strong class="kk iu">测试</strong>条件，测试系统是否处于配置所需的状态。</li><li id="94ef" class="lg lh it kk b kl lp ko lq kr lr kv ls kz lt ld ll lm ln lo bi translated">一个<strong class="kk iu">设置</strong>条件，用于将系统修改为配置所需的状态。</li><li id="257a" class="lg lh it kk b kl lp ko lq kr lr kv ls kz lt ld ll lm ln lo bi translated">一组<strong class="kk iu">依赖关系</strong>，在该需求应用之前必须处于期望状态的其他需求。我们不会实现这一点(DSC的方法)，我们将假设需求是按照依赖图的拓扑顺序来声明的。</li></ul><p id="9b39" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将定义一个<code class="fe lu lv lw lx b">Requirement</code>作为包含这些属性的<a class="ae lf" href="https://medium.com/@cjkuech/functional-powershell-with-classes-820c8e9acd8f" rel="noopener"> PowerShell类</a>。</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="d0a3" class="nl mp it bd mq nm nn dn mu no np dp my kr nq nr na kv ns nt nc kz nu nv ne nw bi translated">需求引擎</h2><p id="bbfa" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">在上面的代码片段中，我们有一个<code class="fe lu lv lw lx b">Requirements</code>数组，我们现在需要将它设置为期望的状态。我们将编写一个cmdlet <code class="fe lu lv lw lx b">Invoke-Requirement</code>来为我们完成这项工作。我们将使用<code class="fe lu lv lw lx b">Test</code>条件来决定是否运行<code class="fe lu lv lw lx b">Set</code>条件。与DSC不同，我们将再次运行<code class="fe lu lv lw lx b">Test</code>条件来<a class="ae lf" href="https://medium.com/@cjkuech/defensive-powershell-with-validation-attributes-8e7303e179fd" rel="noopener">验证和快速失败</a>。</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="4986" class="nl mp it bd mq nm nn dn mu no np dp my kr nq nr na kv ns nt nc kz nu nv ne nw bi translated">伐木编织</h2><p id="7a6b" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">上面的解决方案已经很有价值了；然而，我们可以通过一些日志来改进它。我们希望我们的日志记录是可扩展的和惯用的，所以我们将通过返回<code class="fe lu lv lw lx b">RequirementEvent</code>对象来实现它<a class="ae lf" href="https://medium.com/@cjkuech/functional-programming-in-powershell-876edde1aadb" rel="noopener">功能</a>，然后我们可以用现有的cmdlet(<code class="fe lu lv lw lx b">Format-Table</code>、<code class="fe lu lv lw lx b">Format-List</code>)或我们自己实现的更多特定于域的格式化程序来格式化这些对象。</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b98b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们可以将引擎日志通过管道传输给格式化程序—</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="004a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它会干净地输出—</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="4074" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在有了框架级别的详细日志记录——我们不再需要依赖工程师来维护一致的日志记录。这突出了<a class="ae lf" href="https://github.com/microsoft/Requirements" rel="noopener ugc nofollow" target="_blank">需求</a>及其底层<a class="ae lf" href="https://medium.com/@cjkuech/declarative-devops-30788ddd43cd" rel="noopener">声明性</a>方法的真正价值:我们的声明性解决方案迫使工程师编写一致记录和验证的代码，而不是依赖约定、代码审查和手工实施的风格指南。</p><blockquote class="oa ob oc"><p id="97a0" class="ki kj le kk b kl km ju kn ko kp jx kq od ks kt ku oe kw kx ky of la lb lc ld im bi translated">声明式解决方案迫使工程师编写一致的记录和验证代码</p></blockquote><h1 id="441a" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">完整的解决方案</h1><p id="5e1d" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated"><code class="fe lu lv lw lx b"><a class="ae lf" href="https://github.com/microsoft/Requirements" rel="noopener ugc nofollow" target="_blank">Requirements</a></code> PowerShell Gallery模块提供了这种声明性幂等微框架的完整且更健壮的实现。文档可在其GitHub网站上获得—</p><blockquote class="og"><p id="8f16" class="oh oi it bd oj ok ol om on oo op ld dk translated">【https://github.com/microsoft/requirements】</p></blockquote><p id="79d5" class="pw-post-body-paragraph ki kj it kk b kl oq ju kn ko or jx kq kr os kt ku kv ot kx ky kz ou lb lc ld im bi translated"><code class="fe lu lv lw lx b">Requirements</code>为定义和运行<code class="fe lu lv lw lx b">Requirement</code>提供多个接口，支持依赖图执行，支持DSC资源，并包含专门的日志格式化cmdlets。</p><h2 id="45be" class="nl mp it bd mq nm nn dn mu no np dp my kr nq nr na kv ns nt nc kz nu nv ne nw bi translated">日志格式</h2><p id="280c" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated"><code class="fe lu lv lw lx b">Requirements</code>引入了两个cmdlets，用于格式化从引擎流出的<code class="fe lu lv lw lx b">RequirementEvent</code></p><ul class=""><li id="a1a1" class="lg lh it kk b kl km ko kp kr li kv lj kz lk ld ll lm ln lo bi translated"><code class="fe lu lv lw lx b">Format-Checklist</code> —模拟需求完成后的检查，是CLI和其他人工启动的脚本的理想选择。</li></ul><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/1fa9f48253a0d10574483fd864412f36.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*IelsVq1KpPm6iYLljtcyXQ.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">通过管道向<code class="fe lu lv lw lx b">Format-Checklist</code>实时反馈</figcaption></figure><ul class=""><li id="4e26" class="lg lh it kk b kl km ko kp kr li kv lj kz lk ld ll lm ln lo bi translated"><code class="fe lu lv lw lx b">Format-Callstack</code> —将每个事件记录到输出流中，非常适合在CI/CD脚本和Docker容器构建等无头环境中运行。</li></ul><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/960b2f999d2d9a86d83bacc45f11c533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*J0n7NxFWwlOM3jwRXVoUEw.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">通过管道将详细日志记录到格式调用堆栈</figcaption></figure><h2 id="325c" class="nl mp it bd mq nm nn dn mu no np dp my kr nq nr na kv ns nt nc kz nu nv ne nw bi translated">DSC支持</h2><p id="b8b5" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated"><code class="fe lu lv lw lx b">New-Requirement</code>支持引用DSC资源，因此您可以在我们的同步需求引擎中使用DSC资源。这允许您利用庞大的声明性DSC资源库，而无需提交完整的DSC堆栈。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/9a3d21937d41b9c798dedafaf3ddb62d.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*fb7SwwDxeEv4tPEUOOG6CQ.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">使用有要求的DSC资源</figcaption></figure><p id="5ce2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不幸的是，DSC不是非常跨平台友好的，所以这种场景只在PowerShell 5中受支持。</p><h1 id="1c81" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">后续步骤</h1><h2 id="6d76" class="nl mp it bd mq nm nn dn mu no np dp my kr nq nr na kv ns nt nc kz nu nv ne nw bi translated">了解有关扩展PowerShell的更多信息</h2><p id="ef6a" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">本文是关于大规模管理PowerShell代码库的<a class="ae lf" href="https://medium.com/@cjkuech/declarative-devops-microframeworks-9908c8d05332" rel="noopener">声明性DevOps微框架</a>系列文章的一部分。阅读本系列的<a class="ae lf" href="https://medium.com/@cjkuech/declarative-devops-microframeworks-9908c8d05332" rel="noopener">部分，了解更多关于为大型DevOps代码库设计和编写更少代码的信息。</a></p></div></div>    
</body>
</html>