<html>
<head>
<title>Journey Of A Microservice Application In The Kubernetes World</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes世界的微服务应用之旅</h1>
<blockquote>原文：<a href="https://itnext.io/journey-of-a-microservice-application-in-the-kubernetes-world-f760cba7600f?source=collection_archive---------1-----------------------#2022-10-19">https://itnext.io/journey-of-a-microservice-application-in-the-kubernetes-world-f760cba7600f?source=collection_archive---------1-----------------------#2022-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4d8a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">安全考虑:策略实施</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e178d65d1bb16af0eb8fdd1a87151391.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pTDU3wSVivxcGzVm8QFwug.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">丹尼·米勒在<a class="ae ky" href="https://unsplash.com/s/photos/enforcement?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h2 id="c0a7" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="773f" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-6abd625c60fe">的上一篇文章</a>中，我们从几个安全工具的审计结果中增强了webhooks应用的部署规范。在本文中，我们将讨论策略执行工具，其目的是确保集群中不会创建错误配置的规范。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="b364" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">本系列文章</h2><ul class=""><li id="732e" class="mv mw it lx b ly lz mb mc li mx lm my lq mz mn na nb nc nd bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-bdfe795532ef">web hooks . app的展示</a></li><li id="2c01" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-3c2a9e701e9f">使用Helm在本地单节点Kubernetes上运行应用</a></li><li id="572c" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-e800579f0be3#0174-87b0e3c1fcd3">在Civo Kubernetes集群上运行应用</a></li><li id="3686" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-d9493b19edff">使用GitOps和Argo CD进行连续部署</a></li><li id="5038" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-876f72ce1681">使用Loki堆栈的可观察性</a></li><li id="eccf" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-e2f6475ddde1">使用Acorn定义应用</a></li><li id="29d5" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-6abd625c60fe">安全注意事项:安全相关工具</a></li><li id="b0ef" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-eb0fb52e1bf0">安全考虑:修复错误配置</a></li><li id="f614" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">安全性考虑:策略实施(本文)</li><li id="17fb" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">安全考虑:漏洞扫描(即将推出)</li></ul></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="17ee" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">策略实施工具</h2><p id="ed8a" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-6abd625c60fe">之前的文章</a>中，我们增强了webhooks应用的微服务的部署规范，以使整个应用更加安全(我们将在未来的帖子中继续增强这些规范)。下面是api的原始部署和具有附加安全相关属性的相同部署。</p><div class="kj kk kl km gt ab cb"><figure class="nj kn nk nl nm nn no paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/5aa5d8b6a9869ee106223f7ba15b1153.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*teXu425xAmFiXjFdrW5ZtQ.png"/></div></figure><figure class="nj kn np nl nm nn no paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/58197c5ad315a278b3f6a0b9e58fbf39.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*I5VOG-jz_Ptqqt5pyLkOAw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk nq di nr ns translated">api微服务的规格:左边是原创的，右边是更安全的</figcaption></figure></div><p id="e5d9" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">即使我们知道我们必须如何指定一个部署以便它更安全，也没有什么能阻止我们发送原始版本(上面左边的那个)并在集群中创建它。由于各种原因，这可能是有害的，例如:</p><ul class=""><li id="a4b3" class="mv mw it lx b ly nt mb nu li ny lm nz lq oa mn na nb nc nd bi translated">没有<em class="ob">资源.请求</em>也没有<em class="ob">资源.限制</em>，因此api Pod可能耗尽其他Pod(嘈杂的邻居)所需的资源</li><li id="b0c6" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">没有<em class="ob">安全上下文</em>来防止损坏的映像以root用户身份运行并可能危及主机</li><li id="113f" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">没有<em class="ob"> seccomp </em>配置文件限制容器可以使用的系统调用</li><li id="3252" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">有一组默认的Linux功能，容器可以使用这些功能以提升的权限执行一些操作</li><li id="c161" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi">…</li></ul><p id="75e2" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">为了确保遵守最佳的安全实践，因此只有增强的yaml规范(上面右边的那个)可以在集群中创建，我们需要定义和执行一些安全策略。这样做，API服务器就不会让一个有潜在危险的规范通过。</p><p id="ae95" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">有几种工具可以强制实施策略，从而防止潜在的高风险应用程序在集群中运行。这些工具包括:</p><ul class=""><li id="1a35" class="mv mw it lx b ly nt mb nu li ny lm nz lq oa mn na nb nc nd bi translated"><a class="ae ky" href="https://kubernetes.io/docs/concepts/security/pod-security-admission/" rel="noopener ugc nofollow" target="_blank"> Pod策略准入</a>是Pod安全策略(又名PSP)的继承者，很长一段时间以来一直被弃用，并在Kubernetes 1.25中被删除</li><li id="c1a3" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><a class="ae ky" href="https://www.datree.io/" rel="noopener ugc nofollow" target="_blank"> Datree </a>是一个防止错误配置的工具(我们已经在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-6abd625c60fe">上一篇文章</a>中讨论过Datree)。它也可以用在准入控制器中，以拒绝错误配置的规范</li><li id="7f0f" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><a class="ae ky" href="https://www.openpolicyagent.org/" rel="noopener ugc nofollow" target="_blank">开放策略代理</a> / <a class="ae ky" href="https://github.com/open-policy-agent/gatekeeper" rel="noopener ugc nofollow" target="_blank">看门人</a> : OPA是一个通用的策略引擎，它不是Kubernetes专用的。网守是Kubernetes的OPA用例，它允许在Kubernetes准入控制器中定义策略</li><li id="299a" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">Kyverno 是一个Kubernetes本地策略管理，其中策略被定义为Kubernetes资源</li></ul><p id="19dd" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">基本上，这些工具中的每一个都运行一个准入控制器，负责检查规范，如果它们不遵守一组预定义的规则，就拒绝它们。</p><p id="16d4" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">现在让我们来看看策略实施工具的使用如何有助于使应用程序更加安全。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/91a6d6ca3e5b5c6a4b66de331eacf5b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*n80UHSo56Xc3wkejx5AAew.png"/></div></figure><p id="0c3f" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated"><a class="ae ky" href="https://kubernetes.io/docs/concepts/security/pod-security-admission/" rel="noopener ugc nofollow" target="_blank">吊舱安全准入</a>定义了3个<a class="ae ky" href="https://kubernetes.io/docs/concepts/security/pod-security-standards/" rel="noopener ugc nofollow" target="_blank">吊舱安全标准</a>:</p><ul class=""><li id="0beb" class="mv mw it lx b ly nt mb nu li ny lm nz lq oa mn na nb nc nd bi translated"><strong class="lx iu">特权:</strong>无限制策略，提供尽可能广泛的权限级别。该策略允许已知的权限提升</li><li id="bb2b" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><strong class="lx iu">基线:</strong>防止已知权限升级的最低限制策略。允许默认(最低指定)Pod配置</li><li id="81b9" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><strong class="lx iu">受限:</strong>严格受限的策略，遵循当前的Pod强化最佳实践。</li></ul><p id="3569" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">每个配置文件的详细信息可以在<a class="ae ky" href="https://kubernetes.io/docs/concepts/security/pod-security-standards/#profile-details" rel="noopener ugc nofollow" target="_blank">文档</a>中找到:对于每个标准，我们可以看到受影响的属性、允许的值…</p><p id="a9db" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">可以使用几种模式来处理这些标准中的违反策略的情况:</p><ul class=""><li id="8bbc" class="mv mw it lx b ly nt mb nu li ny lm nz lq oa mn na nb nc nd bi translated"><strong class="lx iu">强制执行:</strong>违反政策将导致pod被拒绝</li><li id="da23" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><strong class="lx iu">审计:</strong>违反策略将触发向审计日志中记录的事件添加审计注释，但在其他情况下是允许的</li><li id="702d" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><strong class="lx iu">警告:</strong>违反策略将触发面向用户的警告，但在其他情况下是允许的</li></ul><p id="e320" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">从1.22版本开始，Kubernetes提供了一个内置的<a class="ae ky" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#podsecurity" rel="noopener ugc nofollow" target="_blank">准入控制器</a>来执行<a class="ae ky" href="https://kubernetes.io/docs/concepts/security/pod-security-standards" rel="noopener ugc nofollow" target="_blank"> Pod安全标准</a>。这个准入控制器可以通过AdmissionConfiguration资源进行配置，或者在我们想要限制的名称空间上添加标签。</p><p id="4da1" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">例如，下面的命令<strong class="lx iu">在webhooks名称空间上强制执行</strong>受限的标准，这个名称空间就是我们的webhooks示例应用程序运行所在的名称空间:</p><p id="7f13" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">注意:我们使用- dry-run选项来模拟这种标记</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="b96c" class="kz la it oe b gy oi oj l ok ol"><strong class="oe iu">$ kubectl label --dry-run=server --overwrite ns webhooks pod-security.kubernetes.io/enforce=restricted</strong><br/>namespace/webhooks labeled</span></pre><p id="250d" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">没有错误！从该输出中，我们可以看到我们在部署规范中所做的更改(在之前的文章中有更多关于这方面的内容)非常好，因为更严格的策略得到了遵守。似乎我们尊重这里的一些最佳实践。</p><p id="db29" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">让我们移除<em class="ob">——试运行</em>旗帜，真正执行限制性政策:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="7119" class="kz la it oe b gy oi oj l ok ol"><strong class="oe iu">$ kubectl label --overwrite ns webhooks pod-security.kubernetes.io/enforce=restricted</strong></span></pre><p id="fef5" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">有了这个约束，如果我们尝试创建一个不包含securityContext属性的部署，我们将得到一个包含以下错误的事件。它表示Pod无法通过，因为它违反了安全策略。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/d7d2d9d6c2e5a8bdc4e68f64df84dd30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YoAe0TwqvV2lCZCvH1iDqA.png"/></div></div></figure><p id="7c57" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">请注意，Pod安全许可使用一组预定义的规则，不允许我们指定自己的规则…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/845f1384388aa7f9d5c61dc57b222de3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*T2X7r8pFg4JQJZvzFk0AJw.png"/></div></figure><p id="979b" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">Pod安全许可仍然很年轻，可能会在不久的将来添加一些功能和方法来扩展它的使用。</p><p id="e11a" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">如果您想了解pod安全准入提供的所有功能，请访问<a class="ae ky" href="https://kubernetes.io/docs/concepts/security/pod-security-admission/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/Security/Pod-Security-Admission/</a>。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/8996bbb16d16700b4ef1f8ecf62dbda2.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*-hQrReuukRVz4y5t.png"/></div></figure><p id="f1fa" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated"><a class="ae ky" href="https://datree.io" rel="noopener ugc nofollow" target="_blank"> Datree </a>使得检测yaml规范中的错误配置变得容易，正如我们在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-6abd625c60fe">上一篇文章</a>中看到的。它还提供了集群集成，允许您使用准入webhook根据配置的策略验证资源。如果发现配置错误，webhook将拒绝该操作，并显示详细的输出，说明如何解决每个配置错误。</p><p id="afb0" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">以下模式说明了Datree的体系结构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/84232aae9cdf3679e60d6e0bb5bc76de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DBbBjhkHWqiUPAX4"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">引擎盖下的Datree</figcaption></figure><p id="3b1c" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">Datree admission webhook可以使用以下Helmfile轻松安装:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="4de3" class="kz la it oe b gy oi oj l ok ol">repositories:<br/>- name: datree-webhook<br/>  url: <a class="ae ky" href="https://datreeio.github.io/admission-webhook-datree/" rel="noopener ugc nofollow" target="_blank">https://datreeio.github.io/admission-webhook-datree/</a><br/>releases:<br/>- name: datree<br/>  namespace: datree<br/>  labels:<br/>    app: datree<br/>  chart: datree-webhook/datree-admission-webhook<br/>  set:<br/>  - name: datree.token<br/>    value: {{ env "DATREE_TOKEN" }}</span></pre><p id="9580" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">注意:我们首先需要从<a class="ae ky" href="https://app.datree.io" rel="noopener ugc nofollow" target="_blank"> https://app.datree.io </a>中的设置菜单获取认证令牌。在本例中，我在DATREE_TOKEN环境变量中设置了令牌，以便Helmfile使用它。</p><p id="5090" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">一旦它运行良好，让我们看看如果我们尝试使用api的增强版本创建部署会发生什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/4181a8139f5135b53815e8922e4d8bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LFZGBl4-z8FS1ExEBTFIOQ.png"/></div></div></figure><p id="ac3d" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">准入webhook不让规范通过。因此，我们需要进一步细化部署规范(添加探测器和增加副本的数量)。</p><p id="e9e9" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">前往<a class="ae ky" href="https://app.datree.io" rel="noopener ugc nofollow" target="_blank"> https://app.datree.io </a>上的Datree控制面板，我们可以看到已检查的策略列表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/73f56ee61ab3f38f70c624f794351e7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gp0j_9WxaH_gv73T5agQ7w.png"/></div></div></figure><p id="1d0a" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">在此示例中，使用了默认策略的规则(60个可用规则中的18个)，但是可以更改准入webhook的设置，以便它使用仪表板中列出的其他策略(更具限制性)。Datree允许创建我们自己的策略，选择它应该包含的规则。为了更进一步，Datree还允许定义一些自定义规则。</p><p id="9a9e" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">如果你想了解datree提供的所有功能，请访问<a class="ae ky" href="https://datree.io" rel="noopener ugc nofollow" target="_blank"> https://datree.io </a>。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/7cc9c1227615d2acd3c69a72d2b77404.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*v294a9zGYnyqwRMtu59dKw.png"/></div></figure><p id="1137" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated"><a class="ae ky" href="https://www.openpolicyagent.org/" rel="noopener ugc nofollow" target="_blank">开放策略代理</a>是通用策略引擎，也是<a class="ae ky" href="https://www.cncf.io/projects/open-policy-agent-opa/" rel="noopener ugc nofollow" target="_blank"> CNCF毕业项目</a>。</p><p id="9c38" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">看门人是Kubernetes的OPA用例，它允许我们在Kubernetes准入控制器中定义策略。Gatekeeper提供了一个可扩展的参数化策略库，它允许我们使用Kubernetes CRDs来扩展策略库(通过<strong class="lx iu"> ConstraintTemplate </strong>的定义)和实例化策略库(通过<strong class="lx iu">约束的定义)。</strong></p><p id="f57f" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">可以使用以下Helmfile轻松安装它:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="20eb" class="kz la it oe b gy oi oj l ok ol">repositories:<br/>- name: gatekeeper<br/>  url: <a class="ae ky" href="https://open-policy-agent.github.io/gatekeeper/charts" rel="noopener ugc nofollow" target="_blank">https://datreeio.github.io/admission-webhook-datree/</a><br/>releases:<br/>- name: gatekeeper<br/>  namespace: gatekeeper-system<br/>  labels:<br/>    app: gatekeeper<br/>  chart: gatekeeper/gatekeeper</span></pre><p id="ff2a" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">OPA /网守使用减压阀语言来定义策略。下面是一个rego片段，如果一个Pod的容器不使用来自gitlab注册表(其url是<em class="ob">registry.gitlab.com</em>)的图像，它会引发一个错误</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="5cff" class="kz la it oe b gy oi oj l ok ol">package trustedregistry</span><span id="f9c8" class="kz la it oe b gy os oj l ok ol">violation[{"msg": msg, "details": {}}] {<br/>  container := input_containers[_]<br/>  image := container.image<br/>  not startswith(image, "registry.gitlab.com/")<br/>  msg := sprintf("image '%s' untrusted",[image])<br/>}</span><span id="ea67" class="kz la it oe b gy os oj l ok ol">input_containers[c] {<br/>  c := input.review.object.spec.containers[_]<br/>}</span></pre><p id="cf38" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">为了用这个样本策略配置网守，我们首先需要定义一个<strong class="lx iu"> ConstraintTemplate </strong>，它描述了实施约束的<a class="ae ky" href="https://www.openpolicyagent.org/docs/latest/#rego" rel="noopener ugc nofollow" target="_blank">减压阀</a>和约束的模式。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="e1be" class="kz la it oe b gy oi oj l ok ol">apiVersion: templates.gatekeeper.sh/v1beta1<br/>kind: ConstraintTemplate<br/>metadata:<br/>  name: trustedregistry<br/>spec:<br/>  crd:<br/>    spec:<br/>      names:<br/>        kind: TrustedRegistry<br/>  targets:<br/>  - target: admission.k8s.gatekeeper.sh<br/>    rego: |<br/>      package trustedregistry</span><span id="db6e" class="kz la it oe b gy os oj l ok ol">      violation[{"msg": msg, "details": {}}] {<br/>        container := input_containers[_]<br/>        image := container.image<br/>        not startswith(image, "registry.gitlab.com/")<br/>        msg := sprintf("image '%s' untrusted",[image])<br/>      }</span><span id="7498" class="kz la it oe b gy os oj l ok ol">      input_containers[c] {<br/>        c := input.review.object.spec.containers[_]<br/>      }</span></pre><p id="4a8b" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">接下来，我们创建一个<strong class="lx iu">约束</strong>，以便网守执行策略</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="038a" class="kz la it oe b gy oi oj l ok ol">apiVersion: constraints.gatekeeper.sh/v1beta1<br/>kind: TrustedRegistry<br/>metadata:   <br/>  name: image-trusted-registry<br/>spec:   <br/>  match:     <br/>    kinds:       <br/>    - apiGroups: [""]         <br/>      kinds: ["Pod"]</span></pre><p id="565d" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">现在我们有了一个约束，让我们创建以下部署:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="45f2" class="kz la it oe b gy oi oj l ok ol"><strong class="oe iu"># www.yaml</strong></span><span id="051d" class="kz la it oe b gy os oj l ok ol">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: www<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: www<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: www<br/>    spec:<br/>      containers:<br/>        - image: nginx:1.20<br/>          name: www</span></pre><p id="4e06" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">没有什么可以阻止创建部署资源:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="4137" class="kz la it oe b gy oi oj l ok ol"><strong class="oe iu">$ kubectl apply -f </strong><a class="ae ky" href="http://www.yaml" rel="noopener ugc nofollow" target="_blank"><strong class="oe iu">www.yaml</strong></a><strong class="oe iu"><br/></strong>deployment.apps/www created</span></pre><p id="bfde" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">但是豆荚从未被创造出来:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="9c7f" class="kz la it oe b gy oi oj l ok ol"><strong class="oe iu">$ kubectl get deploy www<br/></strong>NAME   READY   UP-TO-DATE   AVAILABLE   AGE<br/>www    0/1     0            0           31s</span><span id="47a2" class="kz la it oe b gy os oj l ok ol"><strong class="oe iu">$ kubectl get po -l app=www<br/></strong>No resources found in default namespace.</span></pre><p id="1f91" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">如果我们看一下群集的事件，我们可以看到网关守护设备的验证webhook阻止了Pod的创建:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/b5b2391c546a637139388e97c4cddcb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E12xzvVVnJ1IMjhAFrfzZg.png"/></div></div></figure><p id="be38" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">现在让我们使用来自GitLab容器注册表的图像创建一个规范:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="2390" class="kz la it oe b gy oi oj l ok ol"><strong class="oe iu"># api.yaml</strong></span><span id="e8f3" class="kz la it oe b gy os oj l ok ol">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: api<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: api<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: api<br/>    spec:<br/>      containers:<br/>        - image: registry.gitlab.com/web-hook/api:v1.0.33<br/>          name: api</span></pre><p id="338f" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">没有什么可以阻止创建部署资源:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="f601" class="kz la it oe b gy oi oj l ok ol"><strong class="oe iu">$ k apply -f api.yaml<br/></strong>deployment.apps/www created</span></pre><p id="e0a4" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">但是这一次，Pod是按照定义的约束创建的。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="8551" class="kz la it oe b gy oi oj l ok ol"><strong class="oe iu">$ kubectl get po -l app=api<br/></strong>NAME                   READY   STATUS    RESTARTS   AGE<br/>api-65f8799b4b-ms5lq   1/1     Running   0          31s</span></pre><p id="eb7e" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">这只是一个简单的例子，说明了我们如何创建ConstraintTemplate和Constraint来实施策略。</p><p id="8929" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">如果您想了解OPA /网守提供的所有功能，请访问<a class="ae ky" href="https://github.com/open-policy-agent/gatekeeper" rel="noopener ugc nofollow" target="_blank">https://github.com/open-policy-agent/gatekeeper</a>。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/fad6c6e8bdc77f366b0cb6bb146825cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*QSR90rTBIHf5gANOEGR4MA.png"/></div></figure><p id="13bc" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated"><a class="ae ky" href="https://kyverno.io" rel="noopener ugc nofollow" target="_blank"> Kyverno </a>是Kubernetes本地策略管理，其中策略被定义为Kubernetes资源。这也是<a class="ae ky" href="https://www.cncf.io/projects/" rel="noopener ugc nofollow" target="_blank">一个CNCF孵化项目</a>。</p><p id="84b6" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">它可以通过以下Helmfile轻松安装:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="828a" class="kz la it oe b gy oi oj l ok ol">repositories:<br/>  - name: kyverno<br/>    url: <a class="ae ky" href="https://kyverno.github.io/kyverno/" rel="noopener ugc nofollow" target="_blank">https://kyverno.github.io/kyverno/</a></span><span id="26f6" class="kz la it oe b gy os oj l ok ol">releases:<br/>  - name: kyverno<br/>    namespace: kyverno<br/>    labels:<br/>      app: kyverno<br/>    chart: kyverno/kyverno</span></pre><p id="6022" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">Kyverno定义了以下CRD，其中一些可用于定义我们自己的一套政策。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="abb4" class="kz la it oe b gy oi oj l ok ol">admissionreports.kyverno.io               <br/>backgroundscanreports.kyverno.io          <br/>clusteradmissionreports.kyverno.io        <br/>clusterbackgroundscanreports.kyverno.io   <br/>clusterpolicies.kyverno.io                <br/>clusterpolicyreports.wgpolicyk8s.io       <br/>generaterequests.kyverno.io               <br/>policies.kyverno.io                       <br/>policyreports.wgpolicyk8s.io              <br/>updaterequests.kyverno.io</span></pre><p id="6218" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">开箱即用，它还提供了许多已经定义好的策略。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/30c4e16a83532bf3640fbb49713951f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QkIIwJeTgr1XKhouraS0xw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">许多政策已经可供我们使用</figcaption></figure><p id="2111" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">为了坚持我们用于OPA/Gatekeeper的相同示例，我们将定义一个策略，以确保如果映像不是来自GitLab注册表(<em class="ob">registry.gitlab.com</em>)，则不能创建任何Pod。</p><p id="05d9" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">注意:以下内容基于现有的<a class="ae ky" href="https://kyverno.io/policies/best-practices/restrict_image_registries/restrict_image_registries/" rel="noopener ugc nofollow" target="_blank">限制图像注册表</a>策略</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="8de5" class="kz la it oe b gy oi oj l ok ol">apiVersion: kyverno.io/v1 <br/>kind: ClusterPolicy <br/>metadata:   <br/>  name: restrict-to-gitlab-registry<br/>  annotations:     <br/>    policies.kyverno.io/title: Restrict Image Registries<br/>    policies.kyverno.io/category: Best Practices<br/>    policies.kyverno.io/severity: medium<br/>    policies.kyverno.io/subject: Pod     <br/>spec:   <br/>  validationFailureAction: enforce   <br/>  background: true<br/>  rules:   <br/>  - name: check-registry     <br/>    match:       <br/>      resources:         <br/>        kinds:         <br/>        - Pod     <br/>    validate:       <br/>      message: "registry is not trusted"       <br/>      pattern:        <br/>        spec:           <br/>          containers:          <br/>          - image: "registry.gitlab.com/*"</span></pre><p id="d02a" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">使用与上例相同的<em class="ob"> www.yaml </em>和<em class="ob"> api.yaml </em>，我们可以看到www部署没有通过:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="1906" class="kz la it oe b gy oi oj l ok ol"><strong class="oe iu">$ kubectl apply -f www.yaml<br/></strong>Error from server: error when creating "<a class="ae ky" href="http://www.yaml" rel="noopener ugc nofollow" target="_blank">www.yaml</a>": admission webhook "validate.kyverno.svc-fail" denied the request:</span><span id="a2f9" class="kz la it oe b gy os oj l ok ol">policy Deployment/webhooks/www for resource violation:</span><span id="4a7d" class="kz la it oe b gy os oj l ok ol">restrict-to-gitlab-registry:<br/>  autogen-check-registry: 'validation error: registry is not trusted. rule autogen-check-registry<br/>    failed at path /spec/template/spec/containers/0/image/'</span></pre><p id="df0f" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">api部署是从可信的registry.gitlab.com注册中心创建的。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="3541" class="kz la it oe b gy oi oj l ok ol"><strong class="oe iu">$ k apply -f api.yaml<br/></strong>deployment.apps/api created</span></pre><p id="6c59" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">如果想了解kyverno提供的所有功能，请访问https://kyverno.io。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="f258" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">包扎</h2><p id="75c1" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在本文中，我们介绍了一些目前用于替代PodSecurityPolicy (PSP)的工具，这些工具从Kubernetes 1.21开始就被弃用，并在1.25中被删除。每种工具都有自己的功能集和方法来创建我们想要实施的策略。</p><p id="642b" class="pw-post-body-paragraph lv lw it lx b ly nt ju ma mb nu jx md li nv mf mg lm nw mi mj lq nx ml mm mn im bi translated">对于每个工具，我们只给出了几个例子，我建议您尝试一下，这样您就可以选择一个可以在您的环境中使用的工具。</p></div></div>    
</body>
</html>