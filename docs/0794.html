<html>
<head>
<title>Building RESTful Web APIs with Dart, Aqueduct, and PostgreSQL–Part 4: Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Dart、Aqueduct和PostgreSQL构建RESTful Web APIs第4部分:测试</h1>
<blockquote>原文：<a href="https://itnext.io/building-restful-web-apis-with-dart-aqueduct-and-postgresql-part-4-testing-de3618515639?source=collection_archive---------7-----------------------#2018-05-30">https://itnext.io/building-restful-web-apis-with-dart-aqueduct-and-postgresql-part-4-testing-de3618515639?source=collection_archive---------7-----------------------#2018-05-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/06e8bbde0c96f1f6bf784142ca15afc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WZOMxFZ3wwPS9yd0OYUPHg.jpeg"/></div></div></figure><div class=""/></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="9a94" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh jc"> <em class="ld">请注意:从Dart 2开始，导水管的API发生了变化，导致了突破性的变化。本文基于Dart v1的Aqueduct 2.5.0。</em> </strong></p><p id="088e" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh jc"> <em class="ld">我把这个更新为新的视频系列:</em></strong><a class="ae le" href="http://bit.ly/aqueduct-tutorial" rel="noopener ugc nofollow" target="_blank"><strong class="kh jc"><em class="ld">http://bit.ly/aqueduct-tutorial</em></strong></a></p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="f169" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在第3部分中，我们将API与PostgreSQL数据库集成，利用Aqueduct的ORM作为管理数据事务的手段。了解了托管对象和托管上下文之后，我们得到了一个解决方案，它提供了数据持久性，而不需要编写复杂的SQL查询。</p><p id="a8b5" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">本文是系列文章的一部分，涵盖:</p><ul class=""><li id="7fd4" class="lf lg jb kh b ki kj km kn kq lh ku li ky lj lc lk ll lm ln bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/building-restful-web-apis-with-dart-aqueduct-and-postgresql-3cc9b931f777"> <strong class="kh jc">第1部分:设置并运行示例</strong> </a></li><li id="0e57" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc lk ll lm ln bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/building-restful-web-apis-with-dart-aqueduct-and-postgresql-part-2-routing-with-crud-operations-629fe58114fa"> <strong class="kh jc">第二部分:用CRUD操作实现路由</strong> </a></li><li id="1742" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc lk ll lm ln bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/building-restful-web-apis-with-dart-aqueduct-and-postgresql-part-3-postgres-90ff70742675"> <strong class="kh jc">第3部分:将Web APIs连接到PostgreSQL数据库</strong> </a></li><li id="c038" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc lk ll lm ln bi translated"><strong class="kh jc">第4部分:编写自动化测试</strong> ( <em class="ld">我们到了)</em></li><li id="a653" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc lk ll lm ln bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/building-restful-web-apis-with-dart-aqueduct-and-postgresql-bonus-content-2fc086b7259a"><strong class="kh jc">*奖金内容* </strong> <em class="ld"> </em> DB迁移和模型关系</a></li></ul><p id="66ad" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在这一部分中，我们将编写测试，同时重构我们的逻辑以适应这些测试。我们将使用建立在Dart团队<a class="ae le" href="https://pub.dartlang.org/packages/test" rel="noopener ugc nofollow" target="_blank"> <strong class="kh jc">测试</strong> </a>包之上的Aqueduct内置测试库，这样我们就不用自己设置了。</p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><h1 id="394f" class="lt lu jb bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">测试装具</h1><p id="ea6d" class="pw-post-body-paragraph kf kg jb kh b ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky mv la lb lc ij bi translated">使用第1部分中的搭建工具在项目根目录下创建了一个<code class="fe mw mx my mz b">test/</code>文件夹，文件结构如下:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="3ef7" class="ni lu jb mz b gy nj nk l nl nm">test/<br/>|--harness<br/>   |--<strong class="mz jc">app.dart</strong><br/>   <strong class="mz jc">example_test.dart</strong></span></pre><p id="ea4c" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">测试工具<code class="fe mw mx my mz b">harness/app.dart</code>负责启动和停止我们的应用程序。当我们看着<code class="fe mw mx my mz b">test/example_test.dart</code>中的这个片段时，我们看到了这一点:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="7a51" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">应用程序在运行所有测试之前启动，之后立即停止。我们的测试工具复制了<code class="fe mw mx my mz b">bin/main.dart</code>，但有以下例外:</p><ol class=""><li id="1034" class="lf lg jb kh b ki kj km kn kq lh ku li ky lj lc np ll lm ln bi translated">指定了一个端口<code class="fe mw mx my mz b">0</code>,这样我们的测试可以在任何可用的端口上运行</li><li id="9536" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc np ll lm ln bi translated">给出了一个单独的配置文件(config.src.yaml ),其中包含特定于测试的数据</li><li id="5436" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc np ll lm ln bi translated">当调用<code class="fe mw mx my mz b">application.start</code>时，在主线程上运行我们的测试，选项<code class="fe mw mx my mz b">runOnMainIsolate</code>被设置为真。这将禁用多线程，以便我们可以访问应用程序的状态和服务来执行我们的断言。</li><li id="3127" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc np ll lm ln bi translated">一个<code class="fe mw mx my mz b">TestClient</code>被实例化以提供一个HTTP客户端来执行对我们的API的请求。使用它将为我们的断言提供测试响应。</li><li id="7444" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc np ll lm ln bi translated">提供了一种停止应用程序的方法，以便在所有测试运行后调用</li></ol><p id="d090" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">为了运行我们的测试，让我们在第3部分中重构我们的解决方案，从我们的数据库配置开始。这是为了支持测试和生产环境的灵活性。</p><h1 id="81c7" class="lt lu jb bd lv lw nq ly lz ma nr mc md me ns mg mh mi nt mk ml mm nu mo mp mq bi translated">1.配置数据库</h1><p id="d463" class="pw-post-body-paragraph kf kg jb kh b ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky mv la lb lc ij bi translated">再看一下<code class="fe mw mx my mz b">lib/fave_reads_sink.dart</code>中的<code class="fe mw mx my mz b">FaveReadsSink</code>，同样的Postgres细节将被用在我们的测试和生产环境中。*)</p><p id="8c72" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">通过分离测试和生产信息，配置文件的使用有助于缓解这一问题。在我们的项目中，我们将在根级别使用<code class="fe mw mx my mz b">config.src.yaml</code>和<code class="fe mw mx my mz b">config.yaml</code>文件。</p><p id="8ce1" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">让我们首先用我们的数据库连接信息修改这些文件:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="b99e" class="ni lu jb mz b gy nj nk l nl nm"># config.src.yaml - for test environment<br/>database:<br/>  username: dartuser<br/>  password: dbpass123<br/>  host: localhost<br/>  port: 5432<br/>  databaseName: fave_reads_test<br/>  isTemporary: true</span></pre><p id="5111" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在我们的config.yaml文件中:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="f7f0" class="ni lu jb mz b gy nj nk l nl nm"># for production environment<br/>database:<br/>  username: dartuser<br/>  password: dbpass123<br/>  host: localhost<br/>  port: 5432<br/>  databaseName: fave_reads<br/>  isTemporary: false</span></pre><p id="bc2d" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这允许我们对<code class="fe mw mx my mz b">FaveReadsSink</code>进行以下修改:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="9cf4" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我们的配置文件路径由<code class="fe mw mx my mz b">bin/main.dart</code>和<code class="fe mw mx my mz b">test/harness/app.dart</code>中的<code class="fe mw mx my mz b">Application</code>构造函数的<code class="fe mw mx my mz b">configurationFilePath</code>属性指定。我们的<code class="fe mw mx my mz b">FaveReadsSink</code>类在一个应用程序对象中被实例化，通过它接收请求接收器构造函数的<code class="fe mw mx my mz b">appConfig</code>参数中的配置路径。</p><p id="cc12" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">然后我们通过扩展<code class="fe mw mx my mz b">ConfigurationItem</code>助手类的子类<code class="fe mw mx my mz b">FaveReadsConfiguration</code>来提取我们的配置信息。这会将配置文件解析为一个映射。</p><p id="3968" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在请求接收器之后，让我们定义我们的配置项:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="07cf" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">属性映射到我们配置文件中的同一个键。这就是暴露我们的数据库信息被这样访问的原因:<code class="fe mw mx my mz b">config.database.username</code></p><h1 id="f33e" class="lt lu jb bd lv lw nq ly lz ma nr mc md me ns mg mh mi nt mk ml mm nu mo mp mq bi translated">2.将SchemaBuilder提取到实用程序文件中</h1><p id="68f9" class="pw-post-body-paragraph kf kg jb kh b ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky mv la lb lc ij bi translated">让我们将<code class="fe mw mx my mz b">createDatabaseSchema</code>方法移动到一个单独的文件中，也供我们的测试工具使用:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d530" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我们现在有第二个参数<code class="fe mw mx my mz b">isTemporary</code>要由我们的配置文件来设置。这个选项决定了我们的数据是否被持久化。对于我们的测试，我们将其设置为<code class="fe mw mx my mz b">true</code>。</p><p id="28af" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">现在让我们将这个实用程序重新导入到<code class="fe mw mx my mz b">lib/fave_reads_sink.dart</code>中:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="de1a" class="lt lu jb bd lv lw nq ly lz ma nr mc md me ns mg mh mi nt mk ml mm nu mo mp mq bi translated">3.建立测试数据库</h1><p id="2006" class="pw-post-body-paragraph kf kg jb kh b ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky mv la lb lc ij bi translated">打开<code class="fe mw mx my mz b">psql</code>工具，运行下面的SQL查询:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="ee59" class="ni lu jb mz b gy nj nk l nl nm">CREATE DATABASE <strong class="mz jc">fave_reads_test</strong>;<br/>CREATE USER <strong class="mz jc">dartuser</strong>;<br/>ALTER USER dartuser WITH password '<strong class="mz jc">dbpass123</strong>';<br/>GRANT ALL ON database fave_reads_test TO dartuser;</span></pre><p id="3f05" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">如果您已经在第3部分中这样做了，那么您可以跳过第2行和第3行。</p><h1 id="96b1" class="lt lu jb bd lv lw nq ly lz ma nr mc md me ns mg mh mi nt mk ml mm nu mo mp mq bi translated">4.写一些测试</h1><p id="966b" class="pw-post-body-paragraph kf kg jb kh b ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky mv la lb lc ij bi translated">将<code class="fe mw mx my mz b">example_test.dart</code>重命名为<code class="fe mw mx my mz b">books_controller_test.dart</code>，并将其内容替换为以下内容:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="0c05" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在第39行，我们调用了<code class="fe mw mx my mz b">discardPersistentData</code>方法来断开和重新连接数据库，为我们运行的每个测试使用相同的设置数据。因为我们的测试数据是临时的，它只在连接期间有效。</p><p id="56d6" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我们仍然需要在我们的测试工具中创建这个方法:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="06ee" class="ni lu jb mz b gy nj nk l nl nm">// test/harness/app.dart</span><span id="b8b3" class="ni lu jb mz b gy nv nk l nl nm">class TestApplication {<br/>  ...<br/>  Future <strong class="mz jc">discardPersistentData</strong>() async {<br/>    <strong class="mz jc">await</strong> ManagedContext.defaultContext<br/>      .persistentStore.close();<br/>    <strong class="mz jc">await </strong>createDatabaseSchema(<br/>      ManagedContext.defaultContext, true);<br/>  }<br/>  ...<br/>}</span></pre><p id="a7ac" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">按照Dart的要求，我们的测试包含在一个<code class="fe mw mx my mz b">main()</code>顶级函数中，以便运行我们的测试。<code class="fe mw mx my mz b">setUp</code>函数创建一个<code class="fe mw mx my mz b">Book</code>类型的列表，并使用<code class="fe mw mx my mz b">Query&lt;T&gt;</code>对象为每个测试填充数据库。调用查询对象会在测试过程中重新打开数据库。</p><p id="4325" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">让我们通过用下面的代码片段替换<code class="fe mw mx my mz b">//...tests to go here</code>注释来创建一个测试:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="2f00" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><code class="fe mw mx my mz b">group</code>函数用于对相关测试进行分类，类似于使用Jasmine BDD框架的<code class="fe mw mx my mz b">describe</code>块，而<code class="fe mw mx my mz b">test</code>类似于<code class="fe mw mx my mz b">it</code>块。</p><p id="cfc5" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">需要注意的其他事项:</p><ol class=""><li id="34f6" class="lf lg jb kh b ki kj km kn kq lh ku li ky lj lc np ll lm ln bi translated">我们的第一个测试从我们的<code class="fe mw mx my mz b">TestClient</code>对象创建一个请求，执行GET操作，并使用<code class="fe mw mx my mz b">expectResponse</code> <em class="ld">匹配器方法</em>在响应上运行我们的断言。它接受响应、状态代码和<code class="fe mw mx my mz b">body</code>命名参数下的断言。</li><li id="f3ad" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc np ll lm ln bi translated"><code class="fe mw mx my mz b">everyElement</code>是另一个匹配器方法，它允许我们对响应体中的每一项进行检查，假设它是一个列表。</li><li id="982a" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc np ll lm ln bi translated"><code class="fe mw mx my mz b">partial</code>针对特定的键做出断言，前提是列表项是一个映射。我们用这个来避免检查每一个键。</li><li id="0fe1" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc np ll lm ln bi translated"><code class="fe mw mx my mz b">isString</code>和<code class="fe mw mx my mz b">isInteger</code>是其他内置的获取器，用于确保类型是我们期望的类型</li></ol><p id="a350" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">下面是下一个POST请求:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="4d90" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">post请求对象通过<code class="fe mw mx my mz b">json</code>属性接受一个主体。这假设有效负载是一个JSON字符串。</p><p id="3b66" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">以下是我们的全自动测试:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d337" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我们可以通过以下方式运行我们的测试:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="4691" class="ni lu jb mz b gy nj nk l nl nm">dart <strong class="mz jc">test/books_controller_test.dart</strong></span></pre><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/6ac9a8f3b4d152d14577539c0d7d990d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*4EQLo_dXI0c06BNpfSjOyw.png"/></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated">所有测试通过！🎉</figcaption></figure><h1 id="dca3" class="lt lu jb bd lv lw nq ly lz ma nr mc md me ns mg mh mi nt mk ml mm nu mo mp mq bi translated">结论</h1><p id="fdb7" class="pw-post-body-paragraph kf kg jb kh b ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky mv la lb lc ij bi translated">我们的API现在被测试覆盖了。我希望你能学到一些有用的东西，并发现它值得你在下一个项目中考虑。</p><p id="ac45" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">查看下面的阅读材料，进一步了解导水管测试的细节。一如既往，<strong class="kh jc">欢迎反馈</strong>。让我知道你喜欢什么，不喜欢什么，以及你接下来想看什么。我真的很感激。</p><p id="1197" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">本系列的第4部分到此结束。源代码在github 上有<a class="ae le" href="https://github.com/graphicbeacon/favereads" rel="noopener ugc nofollow" target="_blank">。<strong class="kh jc">如果您喜欢这篇文章，请喜欢并关注我</strong>了解更多关于Dart的内容。查看</a><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/building-restful-web-apis-with-dart-aqueduct-and-postgresql-bonus-content-2fc086b7259a"> <strong class="kh jc">奖励内容</strong> </a>现已推出。</p><h1 id="e207" class="lt lu jb bd lv lw nq ly lz ma nr mc md me ns mg mh mi nt mk ml mm nu mo mp mq bi translated">进一步阅读</h1><ol class=""><li id="1524" class="lf lg jb kh b ki mr km ms kq ob ku oc ky od lc np ll lm ln bi translated"><a class="ae le" href="https://aqueduct.io/docs/testing/tests/" rel="noopener ugc nofollow" target="_blank">在渡槽中编写测试</a></li><li id="4c4a" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc np ll lm ln bi translated"><a class="ae le" href="https://www.dartdocs.org/documentation/aqueduct/latest/aqueduct.test/aqueduct.test-library.html" rel="noopener ugc nofollow" target="_blank">渡槽测试库文件</a></li><li id="578b" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc np ll lm ln bi translated"><a class="ae le" href="https://pub.dartlang.org/packages/test" rel="noopener ugc nofollow" target="_blank">飞镖“测试”包</a></li></ol></div></div>    
</body>
</html>