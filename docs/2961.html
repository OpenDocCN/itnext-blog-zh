<html>
<head>
<title>React — state management without libraries (with hooks)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React —不带库的状态管理(带挂钩)</h1>
<blockquote>原文：<a href="https://itnext.io/react-state-management-without-libraries-with-hooks-5601959759a0?source=collection_archive---------7-----------------------#2019-09-06">https://itnext.io/react-state-management-without-libraries-with-hooks-5601959759a0?source=collection_archive---------7-----------------------#2019-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6b77" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在React中不使用任何外部库的情况下管理状态？</h2></div><blockquote class="kf kg kh"><p id="4793" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><em class="iq">阅读这篇博文时，打开CodeSandbox编辑器可能会有所帮助。</em></p></blockquote><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="lk ll l"/></div></figure><h1 id="26ff" class="lm ln iq bd lo lp lq lr ls lt lu lv lw jw lx jx ly jz lz ka ma kc mb kd mc md bi translated">你为什么不想使用状态管理器呢？</h1><p id="8536" class="pw-post-body-paragraph ki kj iq kl b km me jr ko kp mf ju kr mg mh ku kv mi mj ky kz mk ml lc ld le ij bi translated">状态管理器(如<a class="ae mm" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>或<a class="ae mm" href="https://mobx.js.org/" rel="noopener ugc nofollow" target="_blank"> MobX </a>)真的很棒，但是在我看来，它们对于小应用来说太复杂了。</p><h2 id="4bef" class="mn ln iq bd lo mo mp dn ls mq mr dp lw mg ms mt ly mi mu mv ma mk mw mx mc my bi translated">什么是「小app」？</h2><p id="ce10" class="pw-post-body-paragraph ki kj iq kl b km me jr ko kp mf ju kr mg mh ku kv mi mj ky kz mk ml lc ld le ij bi translated">我们可以假设它只有不到10个视图，你可以在一个屏幕上打印整个状态定义。让我给你举个例子:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi mz"><img src="../Images/2b601b38d63c521ef017af25901fba50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IdtPd9XsLqRdlzyFEJQTPA.png"/></div></div></figure><blockquote class="kf kg kh"><p id="a220" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><em class="iq">免责声明！请不要用这个例子来创建你的界面。这样显示只是为了一次显示整个状态。它应该被分割成可以重用的小块。参考沙盒示例中的</em> <code class="fe ng nh ni nj b"><em class="iq">types.ts</em></code> <em class="iq">。</em></p></blockquote><p id="372b" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mg kt ku kv mi kx ky kz mk lb lc ld le ij bi translated">这种状态可以用在负责过滤和存储房地产机构销售报价的应用程序中。</p><h1 id="fbd5" class="lm ln iq bd lo lp lq lr ls lt lu lv lw jw lx jx ly jz lz ka ma kc mb kd mc md bi translated">如何在我们的应用程序中处理这样的状态？</h1><p id="75ed" class="pw-post-body-paragraph ki kj iq kl b km me jr ko kp mf ju kr mg mh ku kv mi mj ky kz mk ml lc ld le ij bi translated">为此，我们必须首先引入两种类型的挂钩:</p><ul class=""><li id="c9e2" class="nk nl iq kl b km kn kp kq mg nm mi nn mk no le np nq nr ns bi translated"><a class="ae mm" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">使用上下文</a></li><li id="e807" class="nk nl iq kl b km nt kp nu mg nv mi nw mk nx le np nq nr ns bi translated"><a class="ae mm" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank"> useReducer </a></li></ul><p id="79cf" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mg kt ku kv mi kx ky kz mk lb lc ld le ij bi translated">如果你不熟悉它们，我真的建议你停下来，查看一下ReactJS网站上的文档。</p><p id="3dad" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mg kt ku kv mi kx ky kz mk lb lc ld le ij bi translated"><strong class="kl ir"> useContext </strong>钩子负责创建一个<strong class="kl ir">上下文</strong>对象。上下文被设计成通过组件树共享数据(没有props传播)。</p><p id="2c21" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mg kt ku kv mi kx ky kz mk lb lc ld le ij bi translated">useReducer  hook类似于<strong class="kl ir"> useState </strong>，但是它允许你指定一个函数来解析输入的数据。</p><p id="c91c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mg kt ku kv mi kx ky kz mk lb lc ld le ij bi translated">我们要做的是把这些钩子结合起来，创造出类似Redux的东西。默认情况下，<strong class="kl ir"> Context </strong>没有为我们提供任何一种分派方法。我们可以绕过这个问题，因为它不限制存储在上下文中的值的类型。这就是<strong class="kl ir"> useReducer </strong>发挥作用的地方。</p><p id="1bb2" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mg kt ku kv mi kx ky kz mk lb lc ld le ij bi translated">如你所知<strong class="kl ir"> useReducer </strong>接受减速器状态和初始值。当它被调用时，我们得到的是状态和调度函数，它们可以作为上下文的输入。</p><pre class="lf lg lh li gt ny nj nz oa aw ob bi"><span id="dd59" class="mn ln iq nj b gy oc od l oe of">// AppState.tsx<br/>const AppStateContext = React.createContext&lt;AppStateContextType&gt;([<br/>  defaultAppState,<br/>  () =&gt; {},<br/>]);<br/><br/>const AppStateProvider = ({ children }) =&gt; {<br/>  const [state, dispatch] = useReducer(reducer, defaultAppState);<br/><br/>  return (<br/>    &lt;AppStateContext.Provider value={[state, dispatch]}&gt;<br/>      {children}<br/>    &lt;/AppStateContext.Provider&gt;<br/>  );<br/>};</span></pre><p id="296a" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mg kt ku kv mi kx ky kz mk lb lc ld le ij bi translated">首先，我们创建一个上下文，它接受一个包含两个元素的数组。之后，我们必须创建我们的<code class="fe ng nh ni nj b">AppStateProvider</code>，它是<code class="fe ng nh ni nj b">AppStateContext.Provider</code>的包装器，它唯一的目的是调用<code class="fe ng nh ni nj b">useReducer(reducer, defaultAppState</code>来获取<code class="fe ng nh ni nj b">state</code>和<code class="fe ng nh ni nj b">dispatch</code>。</p><blockquote class="kf kg kh"><p id="8d15" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><em class="iq">你可能会问为什么</em> <code class="fe ng nh ni nj b"><em class="iq">defaultAppState</em></code> <em class="iq">就设置在这里？这是因为我们必须根据</em> <code class="fe ng nh ni nj b"><em class="iq">AppStateContextType</em></code> <em class="iq">提供有效的论证。</em></p></blockquote><h1 id="96b5" class="lm ln iq bd lo lp lq lr ls lt lu lv lw jw lx jx ly jz lz ka ma kc mb kd mc md bi translated">使用中的AppState</h1><p id="6bb3" class="pw-post-body-paragraph ki kj iq kl b km me jr ko kp mf ju kr mg mh ku kv mi mj ky kz mk ml lc ld le ij bi translated">导出我们的状态提供者和上下文后:</p><pre class="lf lg lh li gt ny nj nz oa aw ob bi"><span id="f205" class="mn ln iq nj b gy oc od l oe of">// AppState.tsx<br/>export { AppStateContext, AppStateProvider };</span></pre><p id="71b0" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mg kt ku kv mi kx ky kz mk lb lc ld le ij bi translated">我们可以回到我们的主应用程序，把<code class="fe ng nh ni nj b">AppStateProvider</code>放在树的某个地方。</p><pre class="lf lg lh li gt ny nj nz oa aw ob bi"><span id="a8dd" class="mn ln iq nj b gy oc od l oe of">// index.tsx<br/>function App() {<br/>  return (<br/>    &lt;AppStateProvider&gt;<br/>      &lt;AddProperty /&gt;<br/>      &lt;ListComponent /&gt;<br/>    &lt;/AppStateProvider&gt;<br/>  );<br/>}</span></pre><p id="c31b" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mg kt ku kv mi kx ky kz mk lb lc ld le ij bi translated">此时,<code class="fe ng nh ni nj b">AppStateContext</code>的值可用于树中的任何子节点(也是嵌套的)。让我们进入<code class="fe ng nh ni nj b">AddProperty</code>组件，看看我们如何访问状态信息。</p><pre class="lf lg lh li gt ny nj nz oa aw ob bi"><span id="c7d5" class="mn ln iq nj b gy oc od l oe of">// AddProperty.tsx<br/>import { ACTIONS, AppStateContext } from './AppState';<br/><br/>const [{ settings }, dispatch] = useContext(AppStateContext);</span></pre><p id="f2a9" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mg kt ku kv mi kx ky kz mk lb lc ld le ij bi translated">正如你所记得的，数组的第一个元素总是一个<code class="fe ng nh ni nj b">state</code>对象，第二个是我们的<code class="fe ng nh ni nj b">dispatch</code>函数。该组件对当前状态没有用处，但它需要一个方法来将新属性添加到状态中。</p><pre class="lf lg lh li gt ny nj nz oa aw ob bi"><span id="376f" class="mn ln iq nj b gy oc od l oe of">// AddProperty.tsx<br/>const submitProperty = (event: React.FormEvent&lt;{}&gt;) =&gt; {<br/>  event.preventDefault();<br/>  dispatch({<br/>    type: ACTIONS.ADD_ITEM,<br/>    payload: {<br/>      name: form.name,<br/>    },<br/>  });<br/>  setForm({<br/>    ...defaultFormState,<br/>  });<br/>};</span></pre><p id="415b" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mg kt ku kv mi kx ky kz mk lb lc ld le ij bi translated"><code class="fe ng nh ni nj b">submitProperty</code>是我们表单的一个<code class="fe ng nh ni nj b">onSubmit</code>回调。点击<strong class="kl ir">提交</strong>按钮后，它调用<code class="fe ng nh ni nj b">dispatch</code>进行适当的操作，该操作在定义的减速器中处理。</p><pre class="lf lg lh li gt ny nj nz oa aw ob bi"><span id="9bf6" class="mn ln iq nj b gy oc od l oe of">// AppState.tsx<br/>    case ACTIONS.ADD_ITEM:<br/>      return {<br/>        ...state,<br/>        list: [<br/>          {<br/>            ...payload,<br/>            seen: false,<br/>            isInFavourites: false,<br/>            hashId: uuid()<br/>          },<br/>          ...state.list<br/>        ]<br/>      };</span></pre><p id="ca7e" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mg kt ku kv mi kx ky kz mk lb lc ld le ij bi translated">每次我们分派这种类型的动作时，它都会在我们的<code class="fe ng nh ni nj b">list</code>中添加一个新项目，并且在<strong class="kl ir">上下文</strong>中更新状态。</p><p id="024b" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mg kt ku kv mi kx ky kz mk lb lc ld le ij bi translated">现在我们可以在另一个组件中访问该列表</p><pre class="lf lg lh li gt ny nj nz oa aw ob bi"><span id="63de" class="mn ln iq nj b gy oc od l oe of">// ListComponent.tsx<br/>export default function ListComponent() {<br/>  const [{ list }, dispatch] = useContext(AppStateContext);<br/><br/>  const addToFavourites = (event: React.BaseSyntheticEvent&lt;{}&gt;) =&gt; {<br/>    const {<br/>      target: {<br/>        dataset: { hashid }<br/>      }<br/>    } = event;<br/>    dispatch({<br/>      type: ACTIONS.ADD_TO_FAVOURITES,<br/>      payload: hashid<br/>    });<br/>  };<br/><br/>  return (<br/>    &lt;React.Fragment&gt;<br/>      &lt;br /&gt;<br/>      &lt;h2&gt;List of properties&lt;/h2&gt;<br/>      {list.map(element =&gt; (<br/>        &lt;div key={element.hashId}&gt;<br/>          &lt;span&gt;{element.name}&lt;/span&gt;<br/>          &lt;button onClick={addToFavourites} data-hashid={element.hashId}&gt;<br/>            Add to Fav<br/>          &lt;/button&gt;<br/>        &lt;/div&gt;<br/>      ))}<br/>      &lt;Favourites /&gt;<br/>    &lt;/React.Fragment&gt;<br/>  );<br/>}</span></pre><p id="3d06" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mg kt ku kv mi kx ky kz mk lb lc ld le ij bi translated">该组件显示当前列表，并允许用户将一些元素添加到<strong class="kl ir">收藏夹</strong>中。</p><h1 id="bec8" class="lm ln iq bd lo lp lq lr ls lt lu lv lw jw lx jx ly jz lz ka ma kc mb kd mc md bi translated">结论</h1><p id="fd34" class="pw-post-body-paragraph ki kj iq kl b km me jr ko kp mf ju kr mg mh ku kv mi mj ky kz mk ml lc ld le ij bi translated">您不必总是为了管理一个简单的状态而将外部库导入到项目中。通过使用React的内置方法可以达到同样的效果，并且它不会比Redux的可读性差(你甚至可以从中复制reducers)。您可以决定您的应用程序是否可以从更紧凑的方法中受益。</p><p id="ea68" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mg kt ku kv mi kx ky kz mk lb lc ld le ij bi translated">有一个改进可以让创建reducers更容易，但那是另一篇博文的内容了:)</p></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><p id="ed0e" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mg kt ku kv mi kx ky kz mk lb lc ld le ij bi translated"><em class="kk">原发布于</em><a class="ae mm" href="https://erdem.pl/2019/09/react-state-management-without-libraries-with-hooks" rel="noopener ugc nofollow" target="_blank"><em class="kk">https://erdem . pl</em></a><em class="kk">。</em></p></div></div>    
</body>
</html>