<html>
<head>
<title>High level Micro-ui Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级微ui架构</h1>
<blockquote>原文：<a href="https://itnext.io/high-level-micro-ui-architecture-a033bc8e87a8?source=collection_archive---------1-----------------------#2019-12-05">https://itnext.io/high-level-micro-ui-architecture-a033bc8e87a8?source=collection_archive---------1-----------------------#2019-12-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><blockquote class="jq jr js"><p id="35e6" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated">“好的前端开发很难。扩展前端开发，让许多团队可以同时开发一个大型复杂的产品就更难了。”— <strong class="jw iu">卡姆·杰克逊</strong></p></blockquote></div><div class="ab cl ks kt hx ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="im in io ip iq"><h1 id="2202" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">这只是另一种时尚吗？</h1><p id="e0f9" class="pw-post-body-paragraph jt ju it jw b jx lx jz ka kb ly kd ke lz ma kh ki mb mc kl km md me kp kq kr im bi translated">当前技术社区的趋势是构建功能丰富和强大的SPA，它们通常由微服务架构驱动。我们已经看到，随着时间的推移，前端层变得庞大、臃肿和重复。不同的团队通常会维护不同的特性。</p><p id="bd76" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lz kg kh ki mb kk kl km md ko kp kq kr im bi translated">一个代码库，几个团队一起工作需要大量的协调工作，并且会因为阻碍、官僚主义和围绕技术团队范围标准的几十次会议而削弱一个团队。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mf"><img src="../Images/9dc97685fd292a96df217a0de6982d0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WXTsaqXwg9rMqNYPgCwtAQ.jpeg"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">总体应用程序结构化的高级方法</figcaption></figure><p id="da33" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lz kg kh ki mb kk kl km md ko kp kq kr im bi translated">在不同的行业中，自主团队有很多好处，在我们的特定行业中，我们已经看到，自主可以带来创新思维、复杂问题的简单解决方案和更好的工作满意度——如果成功的话。</p><p id="a11a" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lz kg kh ki mb kk kl km md ko kp kq kr im bi translated">微ui或微前端方法努力将自主权交还给团队，让他们完全控制自己的功能或产品，而不必在具体细节上保持一致，这些细节可以由每个团队或小组决定。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mv"><img src="../Images/d57e4de4cc8ebd7424740ad3b01951f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9tzceopxrIpG4LtGsBcUTA.jpeg"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">高级微ui结构</figcaption></figure><h1 id="054a" class="kz la it bd lb lc mw le lf lg mx li lj lk my lm ln lo mz lq lr ls na lu lv lw bi translated">微型用户界面背后的核心思想</h1><p id="8a1d" class="pw-post-body-paragraph jt ju it jw b jx lx jz ka kb ly kd ke lz ma kh ki mb mc kl km md me kp kq kr im bi translated"><strong class="jw iu">成为技术不可知者</strong></p><p id="e17f" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lz kg kh ki mb kk kl km md ko kp kq kr im bi translated">每个团队应该能够选择和升级他们的堆栈，而不必与其他团队协调。这使得技术团队可以通过技术无关的方法更快地扩展。<a class="ae nb" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank"> Web组件</a>是向他人提供中立界面的好方法</p><p id="03d2" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lz kg kh ki mb kk kl km md ko kp kq kr im bi translated"><em class="jv">例如</em></p><pre class="mg mh mi mj gt nc nd ne nf aw ng bi"><span id="4abb" class="nh la it nd b gy ni nj l nk nl">&lt;notification-bell&gt;{notificationCount}&lt;/notification-bell&gt;</span></pre><p id="1cd6" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lz kg kh ki mb kk kl km md ko kp kq kr im bi translated"><em class="jv"> vs </em></p><pre class="mg mh mi mj gt nc nd ne nf aw ng bi"><span id="7b9c" class="nh la it nd b gy ni nj l nk nl">&lt;div class=”notification-bell”&gt;{notificationCount}&lt;/div&gt;</span></pre><p id="171d" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lz kg kh ki mb kk kl km md ko kp kq kr im bi translated"><strong class="jw iu">隔离团队代码</strong></p><p id="a49b" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lz kg kh ki mb kk kl km md ko kp kq kr im bi translated">如果所有的团队共享相同的技术栈，标准等就不能共享相同的运行时。构建独立的、自包含的应用程序，不依赖于特定的共享状态或全局变量，但是也有例外，我稍后会提到。</p><p id="2be5" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lz kg kh ki mb kk kl km md ko kp kq kr im bi translated"><strong class="jw iu">建立弹性网站</strong></p><p id="cc39" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lz kg kh ki mb kk kl km md ko kp kq kr im bi translated">并非所有的浏览器都是一样的，它们使用JavaScript的方式不同，并且许多特性并不被所有的浏览器所支持。尽最大努力使用所有浏览器中都有的API，否则使用polyfill在不支持它们的浏览器上实现这些API。</p><p id="a1a9" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lz kg kh ki mb kk kl km md ko kp kq kr im bi translated">使用<a class="ae nb" href="https://github.com/brillout/awesome-universal-rendering" rel="noopener ugc nofollow" target="_blank">通用渲染技术</a>(SSR/SSG/预渲染)和<a class="ae nb" href="https://www.webfx.com/blog/web-design/progressive-enhancement/" rel="noopener ugc nofollow" target="_blank">渐进式增强</a>(首先强调核心网页内容)来提高感知性能。我将在本文后面讨论几种性能改进策略。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nm"><img src="../Images/542626645cf93f25dbe07e47b2b9f3de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UEfgg_iJLIGSPEdupIjQ7Q.jpeg"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">自主团队</figcaption></figure><h1 id="28e1" class="kz la it bd lb lc mw le lf lg mx li lj lk my lm ln lo mz lq lr ls na lu lv lw bi translated">这看起来像什么？</h1><p id="3463" class="pw-post-body-paragraph jt ju it jw b jx lx jz ka kb ly kd ke lz ma kh ki mb mc kl km md me kp kq kr im bi translated">从开发的角度来看，我们看到独立运行和构建的独立应用程序，它们可能有不同的技术堆栈，但最终结果是一个web应用程序或网站可以在您的浏览器上运行，并按照定义的方式运行。</p><p id="f6ab" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lz kg kh ki mb kk kl km md ko kp kq kr im bi translated">从用户的角度来看，他们看到一个链接或导航不同微ui的web应用程序——然而他们没有看到或注意到这一点(或者说，不应该看到或注意到)。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nn"><img src="../Images/7f357457daae1d692daf410f3042238f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*77BjGLt8wpP5nqLAo0z9EA.jpeg"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">微用户界面的端到端交付</figcaption></figure><p id="263e" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lz kg kh ki mb kk kl km md ko kp kq kr im bi translated">每个微ui都有自己的源代码，包含在某个地方的repo中(理想情况下)。这些项目中的每一个都是在他们自己的管道中构建和测试的，一旦完成，它们就被部署到网络上的某个地方。最后，我们开始将所有这些产品或功能整合到一个应用程序中。我们可以通过使用不同的路由方法来实现这一点，如route 53、nginx、ingress等。</p><h1 id="9a79" class="kz la it bd lb lc mw le lf lg mx li lj lk my lm ln lo mz lq lr ls na lu lv lw bi translated">公共源和逻辑</h1><p id="f3a2" class="pw-post-body-paragraph jt ju it jw b jx lx jz ka kb ly kd ke lz ma kh ki mb mc kl km md me kp kq kr im bi translated">我们希望在这些不同的应用程序之间共享的最常见的东西是样式，可能还有几个在您的应用程序中常用的助手函数(例如解析不记名令牌)。</p><p id="a94e" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lz kg kh ki mb kk kl km md ko kp kq kr im bi translated">通常使用的技术是创建单独的NPM库，并把它们放入每个微型用户界面中。这些应该被设计，以便他们的客户端(微用户界面)可以在这些共享组件上扩展，这样，如果不同的主题，填充等。需要很容易做到这一点。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi no"><img src="../Images/c78c1fcf16ae3c248a0f1405ef8a49a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TwK0j-Q_NKidZK9FriRl1Q.jpeg"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">公共共享库</figcaption></figure><p id="c1f9" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lz kg kh ki mb kk kl km md ko kp kq kr im bi translated">在许多情况下，micro-ui需要验证状态，简单的方法是将您的验证令牌存储在跨域工作的LocalStorage中。如果您要使用预渲染渐进式增强方法，将使用这种方法。我们都有cookie方法，如果你使用服务器端渲染(SSR)方法，你需要使用这个方法。</p><p id="997a" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lz kg kh ki mb kk kl km md ko kp kq kr im bi translated">共享身份验证状态只是一个例子，您可以共享几个状态位，但请小心使用，因为这可能会暴露敏感信息。</p><h1 id="1112" class="kz la it bd lb lc mw le lf lg mx li lj lk my lm ln lo mz lq lr ls na lu lv lw bi translated">表演技巧</h1><p id="3017" class="pw-post-body-paragraph jt ju it jw b jx lx jz ka kb ly kd ke lz ma kh ki mb mc kl km md me kp kq kr im bi translated">您可能遇到的最大问题是加载大量编译后的代码。加载多个包时，有几种方法可以提高性能，我将介绍其中的一些。</p><p id="c17f" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lz kg kh ki mb kk kl km md ko kp kq kr im bi translated"><strong class="jw iu">为静态资产使用内容交付网络</strong></p><p id="2caf" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lz kg kh ki mb kk kl km md ko kp kq kr im bi translated">使用CDN将允许您的所有资产更快地加载，因为大多数CDN将知道用户从哪里请求内容。除了性能，这还将降低您的带宽和基础设施成本。</p><p id="3b5a" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lz kg kh ki mb kk kl km md ko kp kq kr im bi translated"><strong class="jw iu">“预浏览”</strong></p><p id="40bd" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lz kg kh ki mb kk kl km md ko kp kq kr im bi translated">如果你的浏览器预测到了用户需要的请求会怎样？你完全可以指示它这样做。简而言之，预浏览会告诉浏览器在用户浏览时获取并缓存用户浏览器中的资源。有几个<a class="ae nb" href="https://css-tricks.com/prefetching-preloading-prebrowsing/" rel="noopener ugc nofollow" target="_blank">预浏览</a> API，我将讨论两个与我们的问题最相关的。</p><ul class=""><li id="f620" class="np nq it jw b jx jy kb kc lz nr mb ns md nt kr nu nv nw nx bi translated"><strong class="jw iu"> Preconnect </strong> <br/>我们希望在HTTP请求实际发送到服务器之前，尽可能早地加载特定的内容。Preconnect解析DNS并进行TCP握手，如果需要TLS，它还会进行协商。预连接可以将请求延迟减少几百毫秒，有时甚至几千毫秒。<br/> <code class="fe ny nz oa nd b">&lt;link rel="preconnect" href="(url)"&gt;</code></li><li id="7f65" class="np nq it jw b jx ob kb oc lz od mb oe md of kr nu nv nw nx bi translated"><strong class="jw iu">预取<br/> </strong>我们知道将来会加载某些微ui，因此我们可以同时请求浏览器获取该资源，并将其存储在缓存中以备后用。例如，您可以通过预取加载图像，也可以加载浏览器可缓存的任何资源。<br/> <code class="fe ny nz oa nd b">&lt;link rel="preconnect" href="(url)"&gt;</code></li></ul><h1 id="16c9" class="kz la it bd lb lc mw le lf lg mx li lj lk my lm ln lo mz lq lr ls na lu lv lw bi translated">迁移方法</h1><p id="bb56" class="pw-post-body-paragraph jt ju it jw b jx lx jz ka kb ly kd ke lz ma kh ki mb mc kl km md me kp kq kr im bi translated">如果你想开始将你的前端monolith移植到更易于维护和分离的微ui应用程序中，你可以立即开始。首先，我鼓励你定义你的应用程序的哪些部分应该被分离，例如你的认证或登录模块。这样，当模块仍在monolith上使用时，您可以开始孤立地迁移模块。</p><p id="cb80" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lz kg kh ki mb kk kl km md ko kp kq kr im bi translated">对于你需要在应用程序中加入的每一个新特性，我建议立即创建微型用户界面，比如一个新的博客。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi og"><img src="../Images/a372da967a9889b9465bfcfef9bc4658.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g41GNM5FRyiiWXRgFiF3-Q.jpeg"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">将您的monolith迁移到micro-ui中</figcaption></figure><p id="6048" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lz kg kh ki mb kk kl km md ko kp kq kr im bi translated">一旦使用这种方法迁移了所有的模块，您基本上就拥有了一个路由应用程序。</p><h1 id="97da" class="kz la it bd lb lc mw le lf lg mx li lj lk my lm ln lo mz lq lr ls na lu lv lw bi translated">TLDR；</h1><p id="21fd" class="pw-post-body-paragraph jt ju it jw b jx lx jz ka kb ly kd ke lz ma kh ki mb mc kl km md me kp kq kr im bi translated">总之，通过使用微ui驱动的架构方法，您将获得几个好处。这包括真正的团队自治，更少的故障点——如果引入一个关键错误，您的整个应用程序可能不会崩溃，这为我们提供了一个类似于我们在微服务架构中看到的隔离环境。这只是冰山一角当涉及到微ui或者微前端架构的时候，一定要在评论区提问或者留下想法！</p></div></div>    
</body>
</html>