<html>
<head>
<title>The transition from Scala to Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Scala到Go的过渡</h1>
<blockquote>原文：<a href="https://itnext.io/the-transition-from-scala-to-go-27603e373986?source=collection_archive---------2-----------------------#2021-10-04">https://itnext.io/the-transition-from-scala-to-go-27603e373986?source=collection_archive---------2-----------------------#2021-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/fad7768bc4149c00189d5ce6f35e91cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFaeNO48gYlRMQii977cQg.jpeg"/></div></div></figure><div class=""/><p id="42f4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一年前，我作为一名软件工程师加入了谷歌。我的团队使用Go编写了一些代码来保持谷歌云的运行。一年后，我已经变得对这门语言非常有生产力，我已经获得了Go的可读性，而且无论如何，我都不怀念用Scala编写软件。</p><p id="7535" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">至少对我来说，Scala的一些特性使它成为一门有吸引力的语言。其中一个特征是可以使用高阶函数。</p><p id="439a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">高阶函数是简单的函数，可以接收函数作为参数，并可以返回另一个函数作为结果。让我们看一些例子。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="4712" class="lf lg jb lb b gy lh li l lj lk">def addS(n: Int) = n.toString() + "S"<br/>val xs = List(1,2,3,4,5)<br/>val someNumsWithS = xs.map(addS)</span></pre><p id="6951" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意<code class="fe ll lm ln lb b">map</code>接收一个函数作为参数，在我们的例子中，接收的函数是<code class="fe ll lm ln lb b">addS</code>。</p><p id="a3f5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个例子是函数返回另一个函数，而不是一个具体的值。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="766a" class="lf lg jb lb b gy lh li l lj lk">def aFunc = addS <br/>val fn = aFunc<br/>fn(5)<br/> --&gt; 5S</span></pre><p id="15f5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，<code class="fe ll lm ln lb b">aFunc</code>是一个返回另一个函数<code class="fe ll lm ln lb b">addS</code>的函数。</p><p id="47b3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Scala中的这两个函数构造非常重要，但是Go以相似的方式呈现了它们，让我们看看如何呈现。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="efc7" class="lf lg jb lb b gy lh li l lj lk">func AddS(n int) string {<br/>  return string(n) + "S"<br/>}</span><span id="719a" class="lf lg jb lb b gy lo li l lj lk">func map(xs []int, fn func(int)string) []string {<br/>  result := []string{}<br/>  for _, n := range xs {<br/>    result = append(result, fn(n))<br/>  }<br/>  <br/>  return result<br/>}</span><span id="bfca" class="lf lg jb lb b gy lo li l lj lk">xs := []int{1,2,3,4,5}<br/>someNumsWithS := map(xs, AddS)</span></pre><p id="357b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我们实现了与Scala中相同的功能。我们有一个函数<code class="fe ll lm ln lb b">map</code>，它接收另一个函数<code class="fe ll lm ln lb b">fn</code>作为参数。我们可以将任何函数传递给<code class="fe ll lm ln lb b">map</code>，只要它具有相同的签名。</p><p id="5d2c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和Scala一样，我们可以创建返回其他函数的函数。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="2284" class="lf lg jb lb b gy lh li l lj lk">func addOne(n int) func(int)int {<br/>  return func() { return n + 1 }<br/>}</span><span id="7dc5" class="lf lg jb lb b gy lo li l lj lk">fn := AddOne(5)<br/>x := fn()<br/> --&gt; 6</span><span id="ca1c" class="lf lg jb lb b gy lo li l lj lk">func sum() func(int, int)int {<br/>  return func(a, b int) int { return a + b}<br/>}</span><span id="e290" class="lf lg jb lb b gy lo li l lj lk">var s func(int, int)int = sum() // same as s := sum()<br/>s(3, 4)<br/> --&gt; 7</span></pre><p id="c4b4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意<code class="fe ll lm ln lb b">s</code>是如何被类型注释来显示类型的，但是这完全没有必要，因为它可以写成<code class="fe ll lm ln lb b">s := sum()</code>。</p><p id="d7c2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上一个例子让我想到了另一个让从Scala过渡变得非常容易的地方，那就是类型推断。</p><p id="d84e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Go有很好的类型推断。它与Scala最大的不同在于，在Go中，我们需要指定函数的返回类型，就像我们在预览示例中看到的那样。<code class="fe ll lm ln lb b">AddS</code>返回<code class="fe ll lm ln lb b">string</code>，<code class="fe ll lm ln lb b">sum()</code>返回<code class="fe ll lm ln lb b">func(int, int)int</code>以此类推。在Scala中，大多数时候，我们可以跳过函数的返回类型，它仍然可以从上下文中正确地推断出来，编译器总是会检查类型的正确性。然而，即使类型推理系统允许我们省略一些字符，我还是会用Scala来写，因为这有助于更好地理解函数的作用。</p><p id="ea67" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Go是一种简单的语言，与Scala相比更容易学习。例如，在Scala中有很多很多方法可以迭代集合:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="a86c" class="lf lg jb lb b gy lh li l lj lk">val values = ...</span><span id="8928" class="lf lg jb lb b gy lo li l lj lk">values.forEach<br/>values.map<br/>values.filter<br/>values.first<br/>values.foldLeft<br/>values.collect<br/>values.takeWhile<br/>...</span></pre><p id="1661" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在围棋中，有一种更简单、更明确的方法:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="bcde" class="lf lg jb lb b gy lh li l lj lk">values := ...</span><span id="f6b4" class="lf lg jb lb b gy lo li l lj lk">for idx, value := range values {<br/>  // do what you need to do<br/>}</span></pre><p id="d9ad" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">集合中的所有东西都是用最基本的工具解决的，一个<code class="fe ll lm ln lb b">for</code>循环。在Scala中，有许多奇特的实用程序，它们都以非常高效的方式解决特定的问题。然而，这意味着我们必须知道所有这些不同的实现，它们的类型签名，它们的用例，等等…</p><p id="9e80" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Go中，我们有<code class="fe ll lm ln lb b">for</code>，一个简单、优雅的解决方案，永远有效。</p><p id="9601" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从Scala过渡到Go还有一点，那就是并发程序是如何编写的。这本身就需要一个帖子，不过幸运的是，我们已经把这个内容写好了，参见<a class="ae lp" href="https://levelup.gitconnected.com/basic-parallel-computing-in-go-fda50894241c?source=friends_link&amp;sk=55bd268422c3321581ac6382d0fa41ae" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc">基本并行计算中的Go </strong> </a> <strong class="ka jc"> </strong>和<strong class="ka jc"> </strong> <a class="ae lp" href="https://levelup.gitconnected.com/as-a-follow-up-of-basic-parallel-computing-in-go-i-wanted-to-build-a-more-complex-example-where-13978bf84608?source=friends_link&amp;sk=33ee3b3489b7762f8cfcfa255128b22c" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc">更多关于Go通道、并行性和并发性</strong> </a></p><p id="5f72" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总的来说，我认为Scala是一种非常强大的编程语言，拥有丰富的工具，在函数式编程世界中占有很好的地位。然而，它带来了额外的复杂性，固执己见，并有一个非常分裂的用户群。它的库通常实现得很好，但是很难使用，特别是对于那些缺乏函数式编程经验的人。</p><p id="1f99" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，Go是一种简单、快速、干净的小型语言，非常容易学习。通过Go，我们构建了世界上最大的(可能是最大的)基础设施系统之一，为Google Cloud提供动力。Go允许成千上万的工程师一起工作，似乎证明了简单性大有裨益。</p></div></div>    
</body>
</html>