<html>
<head>
<title>The pragmatic guide to React network programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应式网络编程实用指南</h1>
<blockquote>原文：<a href="https://itnext.io/the-pragmatic-guide-to-react-network-programming-c6f9de9962ed?source=collection_archive---------2-----------------------#2022-12-15">https://itnext.io/the-pragmatic-guide-to-react-network-programming-c6f9de9962ed?source=collection_archive---------2-----------------------#2022-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/578a4987b4249086ebaf6ed7f50c272c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KMVLzVlkfpWDxqAj"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/es/@robynnexy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Robynne Hu </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4731" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我想分享一些实用的技巧来编写更好的涉及网络请求的React应用程序，比如每个React应用程序。我将从我们作为开发人员在处理网络请求时所面临的挑战开始，并尝试将这些挑战从React构建视图中分离出来，将这个怪物封装到一个笼子(一个钩子)中，最后使用<code class="fe lb lc ld le b">react-query</code>进行简化。</p><p id="cd4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，您应该能够构建一个相当健壮和有组织的组件，并支持更容易测试和维护的功能。</p><p id="d2fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将要构建的应用程序是一个简单的用户列表。正如您所想象的，实现它很简单:用一个<code class="fe lb lc ld le b">useEffect</code>钩子从remote获取数据，并在获取后呈现列表。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lf"><img src="../Images/9cf15428055379249e5f0b5f99ae26f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yZ3_YsnJHyJfViHdzBCdZw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">用于演示的用户列表应用程序</figcaption></figure><h1 id="627f" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">使用简易获取API</h1><p id="2936" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">让我们将这个简单的应用程序分解成几个步骤，这样我就可以很容易地揭示React中网络编程的所有“阴暗面”。</p><h1 id="b6ba" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">快乐之路</h1><p id="71a4" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">在React中从服务器端获取远程数据并不是非常困难。使用带有资源的正确URL的<code class="fe lb lc ld le b">fetch</code>,将数据转换成JSON，就可以开始了。</p><pre class="lg lh li lj gt mn le mo bn mp mq bi"><span id="64a0" class="mr ll iq le b be ms mt l mu mv">const [users, setUsers] = useState&lt;User[]&gt;([])<br/><br/>useEffect(() =&gt; {<br/>  const fetchUsers = () =&gt; {<br/>    fetch('https://jsonplaceholder.typicode.com/users')<br/>      .then((response) =&gt; response.json())<br/>      .then((data) =&gt; setUsers(data));<br/>  }<br/>  fetchUsers();<br/>}, []);</span></pre><p id="9afa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但这只是整个故事的一小部分。通常，您将需要较慢请求的加载状态，以改善用户体验。</p><h1 id="70c7" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">装载指示器</h1><p id="bc26" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">稍微改变一下，还是可以的。在网络请求开始时，您可以将加载指示器设置为<code class="fe lb lc ld le b">true</code>，并在返回数据后将其重置。您可以使用该标志来呈现一个微调器，让用户知道正在发生的事情。</p><pre class="lg lh li lj gt mn le mo bn mp mq bi"><span id="1ec7" class="mr ll iq le b be ms mt l mu mv">const [users, setUsers] = useState&lt;User[]&gt;([])<br/>const [loading, setLoading] = useState&lt;boolean&gt;(false);<br/><br/>useEffect(() =&gt; {<br/>  const fetchUsers = () =&gt; {<br/>    setLoading(true);<br/>    fetch('https://jsonplaceholder.typicode.com/users')<br/>      .then((response) =&gt; response.json())<br/>      .then((data) =&gt; {<br/>        setLoading(false);<br/>        setUsers(data)<br/>      });<br/>  }<br/>  fetchUsers();<br/>}, []);<br/>if(loading) {<br/>  return &lt;Spinner /&gt;<br/>}</span></pre><p id="b2dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你有数据的时候，你可以做常规的渲染。</p><h1 id="fec2" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">事情并不总是像预期的那样进行。</h1><p id="a7e5" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">在现实世界中，事情会出错(或者至少不是你期望的那样)。网络问题、认证失败、会话过期、有效载荷中的数据不正确、地震、洪水以及谁知道呢。</p><p id="8da5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您最不希望看到的就是一个错误毁掉整个应用程序。这就是为什么你需要错误处理，当它发生时，你需要让用户知道(或者重试几次)</p><pre class="lg lh li lj gt mn le mo bn mp mq bi"><span id="39e8" class="mr ll iq le b be ms mt l mu mv">const [loading, setLoading] = useState&lt;boolean&gt;(false);<br/>const [error, setError] = useState&lt;string&gt;('');<br/><br/>useEffect(() =&gt; {<br/>  const fetchUsers = () =&gt; {<br/>    setLoading(true);<br/>    fetch('https://jsonplaceholder.typicode.com/users2')<br/>      .then((response) =&gt; {<br/>        if (response.status &gt;= 200 &amp;&amp; response.status &lt;= 299) {<br/>          return response.json();<br/>        } else {<br/>          setLoading(false);<br/>          throw Error(response.statusText);<br/>        }<br/>      })<br/>      .then((data) =&gt; {<br/>        setLoading(false);<br/>        setUsers(data)<br/>      })<br/>      .catch((e) =&gt; {<br/>        setLoading(false);<br/>        setError(e);<br/>      });<br/>  }<br/>  fetchUsers();<br/>}, []);<br/><br/>if(error) {<br/>  return &lt;ErrorMessage /&gt;<br/>}</span></pre><p id="fedf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还是那句话，一点点改变，就能达到预期。这里唯一的问题是，默认情况下，<code class="fe lb lc ld le b">fetch</code>不会将<code class="fe lb lc ld le b">4xx</code>或<code class="fe lb lc ld le b">5xx</code>视为错误，所以我们需要检查状态并有条件地抛出。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lf"><img src="../Images/4ec54ed803eec7cf7641d77515536816.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cx8Nvx1tx-ouKbR39x-N1Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">出错时抛出一个错误</figcaption></figure><p id="764a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你当然可以使用其他像<code class="fe lb lc ld le b">axios</code>这样的库来减轻一点痛苦。</p><pre class="lg lh li lj gt mn le mo bn mp mq bi"><span id="882a" class="mr ll iq le b be ms mt l mu mv">useEffect(() =&gt; {<br/>  const fetchUsers = () =&gt; {<br/>    setLoading(true);<br/>    <br/>    axios.get('https://jsonplaceholder.typicode.com/users')<br/>      .then((response: AxiosResponse&lt;User[]&gt;) =&gt; {<br/>        setLoading(false);<br/>        setUsers(response.data)<br/>      }).catch((e) =&gt; {<br/>        setLoading(false);<br/>        setError(e);<br/>    })<br/>  }<br/>  fetchUsers();<br/>}, []);</span></pre><p id="8312" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当前代码运行良好。但是当我读这些代码的时候，我觉得它们很分散我的注意力。这里正在进行许多事情，我们在其他网络请求中也需要这些类似的代码。在现实世界的应用程序中，这仍然是一个非常简化的生产代码版本。</p><p id="ba7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们遗漏了一些非常标准的东西:</p><ul class=""><li id="c047" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated">当临时错误发生时重试(比如不稳定的网络，我们至少应该重试几次)</li><li id="d72b" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">定期轮询某些检查请求(如运行状况检查或状态检查请求)。</li><li id="0050" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">取消不需要的请求，或者再次启动相同的请求。</li></ul><h1 id="6742" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">让我们再试一次。</h1><p id="4e2c" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">实现重试很容易出错，因为还有很多状态需要处理。例如，我们可以添加一个实例状态<code class="fe lb lc ld le b">retryCount</code>，并在重新发送网络请求之前每秒增加一次。我们通常会逐渐增加重试时间跨度，以确保远程恢复。</p><pre class="lg lh li lj gt mn le mo bn mp mq bi"><span id="fdf1" class="mr ll iq le b be ms mt l mu mv">const retryCount = useRef&lt;number&gt;(0);<br/><br/>useEffect(() =&gt; {<br/>    //... fetchUsers<br/>  const intervalId = setInterval(() =&gt; {<br/>    if(error === null) {<br/>      fetchUsers();<br/>      clearInterval(intervalId);<br/>    } else if (retryCount.current &lt; 3) {<br/>      retryCount.current = retryCount.current + 1;<br/>      fetchUsers();<br/>    } else {<br/>      clearInterval(intervalId);<br/>    }<br/>  }, 1000);<br/><br/>  return () =&gt; {<br/>    clearInterval(intervalId);<br/>  }<br/>}, [error]);</span></pre><p id="927a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了调整间隔时间跨度，我们将不得不引入更多的状态，这可能会使代码更加难以阅读。一般的事实是，文件越长，错误就越容易潜入。(<strong class="kf ir"> <em class="nk">注:上面的代码其实是有bug的，所以不要在你的制作中使用</em> </strong>)</p><p id="2548" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我假设您已经意识到了当前实现的“丑陋”。那么，我们如何解决这个难以维护的问题呢？一种方法是将整个<code class="fe lb lc ld le b">useEffect</code>块提取到一个单独的钩子中，并在那里做所有疯狂的事情。</p><h1 id="08da" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">一些清理和重构</h1><h1 id="9ef8" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">将效果代码提取到一个钩子中</h1><p id="8b11" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">通过简单地将状态和<code class="fe lb lc ld le b">useEffect</code>部分的代码复制到一个单独的函数<code class="fe lb lc ld le b">useFetchUsers</code>中，我们就有了管理所有网络相关逻辑的新钩子:</p><pre class="lg lh li lj gt mn le mo bn mp mq bi"><span id="1be4" class="mr ll iq le b be ms mt l mu mv">const useFetchUsers = () =&gt; {<br/>  const [users, setUsers] = useState&lt;User[] | undefined&gt;([])<br/>  const [loading, setLoading] = useState&lt;boolean&gt;(false);<br/>  const [error, setError] = useState&lt;string | null&gt;(null);<br/><br/>  const retryCount = useRef&lt;number&gt;(0);<br/><br/>  useEffect(() =&gt; {<br/>    const fetchUsers = () =&gt; {<br/>        //...<br/>    }<br/>    const intervalId = setInterval(() =&gt; {<br/>        //...<br/>    }, 1000);<br/><br/>    return () =&gt; {<br/>      clearInterval(intervalId);<br/>    }<br/>  }, [error]);<br/><br/>  return {<br/>    users,<br/>    loading,<br/>    error<br/>  }<br/>}</span></pre><p id="34bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们甚至可以在<code class="fe lb lc ld le b">fetchUsers</code>中拆分这里的逻辑。它目前做两件事:发送网络请求和设置本地状态。我们可以定义一个只关注网络的函数，包括设置HTTP头、网络超时和认证等。</p><pre class="lg lh li lj gt mn le mo bn mp mq bi"><span id="6c24" class="mr ll iq le b be ms mt l mu mv">const fetchUsers = async (): Promise&lt;User[] | undefined&gt; =&gt; {<br/>  try {<br/>    const response = await axios.get('https://jsonplaceholder.typicode.com/users');<br/>    return (response.data as User[]);<br/>  } catch (e) {<br/>    new Error('fetch users data error')<br/>  }<br/>}</span></pre><p id="93b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们原始组件中的代码可以简化为:</p><pre class="lg lh li lj gt mn le mo bn mp mq bi"><span id="c609" class="mr ll iq le b be ms mt l mu mv">export const UserList = () =&gt; {<br/>  const {loading, error, users} = useFetchUsers();<br/>  <br/>  if(loading) {<br/>    return &lt;Spinner /&gt;<br/>  }<br/><br/>  if(error) {<br/>    return &lt;ErrorMessage /&gt;<br/>  }<br/><br/>  return (&lt;div&gt;<br/>    {//...}<br/>  &lt;/div&gt;)<br/>}</span></pre><p id="e2bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在看起来好多了。钩子提供数据和不同的状态，而视图负责呈现数据(具有不同的用户界面状态)。</p><p id="3d81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本质上，我们有三个部分负责应用程序的三个不同方面:</p><ol class=""><li id="bafe" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nl nc nd ne bi translated">呈现数据的列表视图(快乐路径)，以及<code class="fe lb lc ld le b">loading</code>和<code class="fe lb lc ld le b">error</code>状态</li><li id="1cd3" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nl nc nd ne bi translated">一个钩子，它安排应用程序的所有状态，并在必要时重试逻辑</li><li id="6f1b" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nl nc nd ne bi translated">一个处理网络相关工作的fetch函数:设置HTTP头，定义超时等。</li></ol><p id="0e81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这种关注点的分离，仍然有改进的空间。尤其是网络状态管理。</p><h1 id="9f53" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">更进一步</h1><p id="cac3" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">我想在这个阶段，您已经意识到与网络相关的代码有多复杂(再说一遍，这只是故事的一部分)。幸运的是，我们有来自<code class="fe lb lc ld le b">tanstack</code>的<code class="fe lb lc ld le b">react-query</code>，可以更容易地简化整个过程。</p><pre class="lg lh li lj gt mn le mo bn mp mq bi"><span id="be1f" class="mr ll iq le b be ms mt l mu mv">yarn add @tanstack/react-query --save</span></pre><p id="9451" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用<code class="fe lb lc ld le b">react-query</code>，您需要将您的应用程序包装到一个<code class="fe lb lc ld le b">Provider</code>中，这样所有的子节点都可以访问查询客户端。<code class="fe lb lc ld le b">react-query</code>提供了许多有用的钩子，可以大大简化逻辑。</p><p id="ffc4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的<code class="fe lb lc ld le b">useFetchUsers</code>钩子中，带有<code class="fe lb lc ld le b">react-query</code>的代码如下:</p><pre class="lg lh li lj gt mn le mo bn mp mq bi"><span id="df1c" class="mr ll iq le b be ms mt l mu mv">import { useQuery } from "@tanstack/react-query";<br/><br/>const useFetchUsers = () =&gt; {<br/>  const {<br/>    isLoading: loading,<br/>    error,<br/>    data: users,<br/>  } = useQuery(["fetchUsers"], fetchUsers, { retry: 3 });<br/><br/>  return {<br/>    users,<br/>    loading,<br/>    error,<br/>  };<br/>};</span></pre><p id="132e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样。所有的状态现在都由<code class="fe lb lc ld le b">react-query</code>自己管理，还有重试逻辑、缓存、数据过时时自动重新获取等等。</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">这两个代码片段的直观比较</figcaption></figure><p id="516a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，您使用三个参数调用<code class="fe lb lc ld le b">useQuery</code> hook:查询键的作用类似于查询的id，因此您可以在其他地方引用它(例如，取消它，或者如果它是一个变异，则评估缓存)。第二个参数是返回承诺或错误的函数。和一个可选的options对象，您可以定义出错时想要重试的次数、每次重试之间的延迟以及许多其他事情。</p><p id="bb25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意这里用<code class="fe lb lc ld le b">react-query</code>，你可以替换<code class="fe lb lc ld le b">fetchUsers</code>函数，它用一个不起眼的<code class="fe lb lc ld le b">fetch</code>调用发出底层网络请求。</p><p id="1a84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe lb lc ld le b">react-query</code>还有很多其他好处，我从主页上摘录几个。</p><div class="no np gp gr nq nr"><a href="https://tanstack.com/query/v4/docs/overview" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">概览|转移查询文档</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">React Query经常被描述为React缺少的数据获取库，但是用更专业的术语来说，它使得……</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">tanstack.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of jw nr"/></div></div></a></div><p id="c5cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">react-query</code>的特性我就不多讨论了。相反，我更想强调关注点的分离。正如您所看到的，我们如何将内容提取到不同的位置，这使得切换非常简单。如果您在编写React代码或进行重构时总是考虑到这一点，将会有所帮助。</p><h1 id="1ae2" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">摘要</h1><p id="7763" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">与网络打交道并不容易。必须考虑许多事情:协议、报头、缓存、超时、出错时重试以及管理不同的状态。<code class="fe lb lc ld le b">react-query</code>可以让开发人员的生活轻松一点。最重要的是，您仍然需要将这些挑战与视图和底层网络客户端(或者是<code class="fe lb lc ld le b">fetch</code>或者是<code class="fe lb lc ld le b">axios</code>客户端)隔离开来。</p></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><p id="b11f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">如果你喜欢阅读，请</strong> <a class="ae kc" href="https://icodeit.com.au/#subscribe" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">报名参加我的邮件列表</strong> </a> <strong class="kf ir">。我每周通过</strong> <a class="ae kc" href="https://juntao-qiu.medium.com/" rel="noopener"> <strong class="kf ir">博客</strong></a><strong class="kf ir"/><a class="ae kc" href="https://leanpub.com/u/juntao" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">书籍</strong> </a> <strong class="kf ir">和</strong> <a class="ae kc" href="https://www.youtube.com/@icodeit.juntao" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">视频</strong> </a> <strong class="kf ir">分享干净代码和重构技术。</strong></p></div></div>    
</body>
</html>