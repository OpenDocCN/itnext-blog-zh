<html>
<head>
<title>[V8 Deep Dives] Understanding Map Internals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[V8深入探讨]了解地图内部</h1>
<blockquote>原文：<a href="https://itnext.io/v8-deep-dives-understanding-map-internals-45eb94a183df?source=collection_archive---------2-----------------------#2020-08-27">https://itnext.io/v8-deep-dives-understanding-map-internals-45eb94a183df?source=collection_archive---------2-----------------------#2020-08-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9380e3581b6aa1ee2de0c95108fb34f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t535eVa3f0fBwYfz"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">朱利安·保罗在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2c99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这篇博客，我开始了V8 Deep Dives系列，致力于我在V8中的实验和发现，毫无疑问，V8是一个设计良好的复杂软件。希望你会发现这篇博文很有价值，并分享你对下一个主题的想法。</p><h2 id="65e9" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">介绍</h2><p id="90b8" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><a class="ae kc" href="http://www.ecma-international.org/ecma-262/6.0/" rel="noopener ugc nofollow" target="_blank"> ECMAScript 2015 </a>，也被称为ES6，引入了许多内置集合，如Map、Set、WeakMap和WeakSet。它们似乎是标准JS库的优秀补充，并在库、应用程序和Node.js核心中被广泛采用。今天，我们将重点关注地图收集，并尝试了解V8的实施细节，以及做出一些实际的结论。</p><p id="488b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该规范没有规定用于实现Map支持的精确算法，而是给出了一些可能的实现和预期性能特征的提示:</p><blockquote class="lz ma mb"><p id="a743" class="kd ke mc kf b kg kh ki kj kk kl km kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated">Map对象必须使用哈希表或其他机制来实现，平均来说，这些机制提供的访问时间与集合中的元素数量呈次线性关系。本地图对象规范中使用的数据结构仅用于描述地图对象所需的可观察语义。它不是一个可行的实现模型。</p></blockquote><p id="3179" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们在这里看到的，该规范为每个实现者(即JS引擎)留出了很大的空间，但并没有对具体的算法、其性能或实现的内存占用给出很多确定性。如果您的应用程序在其热路径上处理地图，或者您在地图中存储了大量数据，这些细节肯定会有很大帮助。</p><p id="4341" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一名具有Java背景的开发人员，我已经习惯了Java集合，可以在Map接口的多种实现之间进行选择，如果所选的类支持的话，甚至可以对它进行微调。此外，在Java中，总是可以从标准库中开放任何类的源代码，并熟悉实现(当然，这可能会因版本而异，但只是朝着更有效的方向)。所以，这就是为什么我不能忍受不学习V8中地图的工作原理。</p><p id="8640" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们开始潜水。</p><p id="ae25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">免责声明。</strong>下面写的是特定于V8 8.4的实现细节，捆绑了Node.js的最新开发版本(更准确地说是<a class="ae kc" href="https://github.com/nodejs/node/commit/238104c531219db05e3421521c305404ce0c0cce" rel="noopener ugc nofollow" target="_blank"> commit 238104c </a>)。你不应该期望任何超出规范的行为。</p><h2 id="23ec" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">底层算法</h2><p id="a874" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">首先，V8中的映射建立在哈希表之上。后续文本假设您了解散列表是如何工作的。如果你不熟悉这个概念，你应该先学习一下(例如，通过阅读这个<a class="ae kc" href="https://en.wikipedia.org/wiki/Hash_table" rel="noopener ugc nofollow" target="_blank"> wiki页面</a>)，然后再回到这里。</p><p id="9334" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你对地图有丰富的经验，你可能已经注意到了这里的矛盾。哈希表不为迭代提供任何顺序保证，而ES6规范要求实现在映射上迭代时保持插入顺序。所以,“经典”算法不适用于地图。但是似乎仍然有可能稍微改变一下就使用它。</p><p id="a2b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">V8使用Tyler Close提出的所谓的<a class="ae kc" href="https://wiki.mozilla.org/User:Jorend/Deterministic_hash_tables" rel="noopener ugc nofollow" target="_blank">确定性哈希表算法</a>。以下基于TypeScript的伪代码显示了此算法使用的主要数据结构:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="1704" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里<code class="fe mm mn mo mp b">CloseTable</code>接口代表哈希表。它包含<code class="fe mm mn mo mp b">hashTable</code>数组，大小等于桶的数量。数组的第n个元素代表第n个桶，并保存了<code class="fe mm mn mo mp b">dataTable</code>数组中桶头元素的索引。依次，<code class="fe mm mn mo mp b">dataTable</code>数组包含了按插入顺序排列的条目。最后，每个<code class="fe mm mn mo mp b">Entry</code>都有<code class="fe mm mn mo mp b">chain</code>属性，它指向桶的链中的下一个条目(或者更精确地说，是单链表)。</p><p id="7cbc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每次当一个新条目被插入到表中时，它被存储在索引<code class="fe mm mn mo mp b">nextSlot</code>下的<code class="fe mm mn mo mp b">dataTable</code>数组中。这个过程还需要更新相应桶的链，因此插入的条目成为新的尾部。</p><p id="de26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当从散列表中删除一个条目时，它从<code class="fe mm mn mo mp b">dataTable</code>中被移除(例如，通过将键和值都设置为<code class="fe mm mn mo mp b">undefined</code>)。您可能会注意到，这意味着所有被删除的条目仍然占据着<code class="fe mm mn mo mp b">dataTable</code>中的空间。</p><p id="5a3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为拼图的最后一块，当一个表充满了条目(包括存在的和删除的)时，需要用更大(或更小)的大小重新散列(重建)。</p><p id="b960" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这种方法，在地图上的迭代只是一个遍历<code class="fe mm mn mo mp b">dataTable</code>的问题。这保证了迭代的插入顺序要求。考虑到这一点，我希望大多数JS引擎(如果不是全部的话)使用确定性哈希表作为映射背后的构建块。</p><h2 id="601d" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">算法实践</h2><p id="6737" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">让我们通过更多的例子来看看算法是如何工作的。比方说，我们有一个具有2个存储桶(<code class="fe mm mn mo mp b">hashTable.length</code>)和总容量为4 ( <code class="fe mm mn mo mp b">dataTable.length</code>)的<code class="fe mm mn mo mp b">CloseTable</code>，散列表由以下内容填充:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="a5b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在此示例中，内部表格表示可以表示如下:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="63ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们通过调用<code class="fe mm mn mo mp b">table.delete(0)</code>删除一个条目，这个表就变成这样:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="58a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们再插入两个条目，散列表将需要重新散列。稍后我们将更详细地讨论这个过程。</p><p id="ca1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相同的算法可以应用于集合。唯一的区别是集合条目不需要<code class="fe mm mn mo mp b">value</code>属性。</p><p id="9c1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们对V8中地图背后的算法有了一个了解，我们就准备进行更深入的探究。</p><h2 id="71da" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">实施细节</h2><p id="a6f6" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">V8中的Map实现是用C++写的，然后暴露给JS代码。它的主要部分在<code class="fe mm mn mo mp b">OrderedHashTable</code>和<code class="fe mm mn mo mp b">OrderedHashMap</code>类中定义。我们已经了解了这些类是如何工作的，但是如果你想自己阅读代码，你可以在这里找到<a class="ae kc" href="https://github.com/nodejs/node/blob/238104c531219db05e3421521c305404ce0c0cce/deps/v8/src/objects/ordered-hash-table.h" rel="noopener ugc nofollow" target="_blank">这里</a>，这里<a class="ae kc" href="https://github.com/nodejs/node/blob/238104c531219db05e3421521c305404ce0c0cce/deps/v8/src/objects/ordered-hash-table.cc" rel="noopener ugc nofollow" target="_blank">这里</a>，最后，这里<a class="ae kc" href="https://github.com/nodejs/node/blob/238104c531219db05e3421521c305404ce0c0cce/deps/v8/src/builtins/builtins-collections-gen.cc" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="6566" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们关注V8的Map实现的实际细节时，我们需要理解表容量是如何选择的。</p><h2 id="0b28" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">容量</h2><p id="cdee" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在V8中，哈希表(Map)容量总是等于2的幂。至于load factor，它是一个常数，等于2，这意味着一个表的最大容量是<code class="fe mm mn mo mp b">2 * number_of_buckets</code>。当您创建一个空映射时，它的内部哈希表有两个桶。因此，这种映射的容量是4个条目。</p><p id="984d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最大容量也有限制。在64位系统上，这个数字是2个⁷，这意味着你不能在一个地图上存储超过1670万个条目。这个限制来自于用于map的堆上表示，但是我们将在稍后讨论这个方面。</p><p id="074f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，用于再散列的增长/收缩因子等于2。因此，一旦一个映射获得4个条目，下一次插入将导致一个重散列过程，其中将构建一个两倍大(或更小)的新哈希表。</p><p id="f020" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了确认在源代码中可以看到什么，我修改了Node.js中捆绑的V8，将桶的数量作为地图上可用的自定义属性<code class="fe mm mn mo mp b">buckets</code>。你可以在这里找到结果<a class="ae kc" href="https://github.com/puzpuzpuz/node/tree/experiment/expose-map-capacity" rel="noopener ugc nofollow" target="_blank"/>。使用这个自定义Node.js构建，我们可以运行以下脚本:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="fbb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的脚本简单地将100个条目插入到一个空地图中。它产生以下输出:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="3fdf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们在这里看到的，当达到地图容量时，地图以2的幂增长。所以，我们的理论现在被证实了。现在，让我们尝试通过删除地图中的所有项目来缩小地图:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="1e78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该脚本产生以下输出:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="0120" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们再次看到，一旦剩余条目比<code class="fe mm mn mo mp b">number_of_buckets / 2</code>少，地图就会以2的幂缩小。</p><h2 id="3fae" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">散列函数</h2><p id="a35e" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">到目前为止，我们还没有讨论V8如何为存储在映射中的键计算散列码，虽然这是一个好话题。</p><p id="979d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于类似数字的值(SMI和堆号、BigInts和其他类似的内部内容)，它使用一个或另一个众所周知的低冲突概率的<a class="ae kc" href="https://github.com/nodejs/node/blob/238104c531219db05e3421521c305404ce0c0cce/deps/v8/src/utils/utils.h#L213" rel="noopener ugc nofollow" target="_blank">散列函数</a>。</p><p id="b044" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于类似字符串的值(字符串和符号)，它<a class="ae kc" href="https://github.com/nodejs/node/blob/238104c531219db05e3421521c305404ce0c0cce/deps/v8/src/objects/string.cc#L1338" rel="noopener ugc nofollow" target="_blank">根据字符串内容计算</a>散列码，然后将其缓存在内部头中。</p><p id="d2dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，对于对象，V8 <a class="ae kc" href="https://github.com/nodejs/node/blob/238104c531219db05e3421521c305404ce0c0cce/deps/v8/src/execution/isolate.cc#L3785" rel="noopener ugc nofollow" target="_blank">根据一个随机数计算</a>哈希码，然后缓存在内部头中。</p><h1 id="b627" class="mq lc iq bd ld mr ms mt lg mu mv mw lj mx my mz lm na nb nc lp nd ne nf ls ng bi translated">时间复杂度</h1><p id="255b" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">大多数地图操作，如<code class="fe mm mn mo mp b">set</code>或<code class="fe mm mn mo mp b">delete</code>，都需要查找。就像“经典”哈希表一样，查找具有O(1)时间复杂度。</p><p id="255d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们考虑最坏的情况，当表有N/N个条目时(它已满)，所有条目都属于一个桶，所需条目位于尾部。在这种情况下，查找需要遍历链元素N次。</p><p id="7f93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，在最好的情况下，当表已满，但每个存储桶有2个条目时，查找将需要多达2次移动。</p><p id="4c40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">众所周知，虽然散列表中的单个操作很“便宜”，但重新散列却不便宜。重散列的时间复杂度为O(N ),并且需要在堆上分配新的哈希表。此外，必要时，再散列是作为插入或删除操作的一部分来执行的。因此，举例来说，一个电话可能比你预期的要贵。幸运的是，重新散列是一个相对不常见的操作。</p><h2 id="be01" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">内存占用</h2><p id="e850" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">当然，底层哈希表必须以某种方式存储在堆中，即所谓的“后备存储”中。还有一个有趣的事实。整个表(以及Map)存储为一个固定长度的数组。阵列布局可以用下图来说明。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/25035521988988336364b0c5b86858b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lrmWw6cULyCZ6sRmXnsZyQ.png"/></div></div></figure><p id="2393" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">后备存储数组的特定片段对应于头(包含必要的信息，如存储桶计数或已删除条目计数)、存储桶和条目。bucket链的每个条目占用数组的三个元素:一个用于键，一个用于值，一个用于指向链中下一个条目的“指针”。</p><p id="e76a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">至于数组大小，我们可以大致估算为<code class="fe mm mn mo mp b">N * 3.5</code>，其中<code class="fe mm mn mo mp b">N</code>是表容量。为了理解它在内存占用方面的含义，让我们假设我们有一个64位系统，并且V8的<a class="ae kc" href="https://v8.dev/blog/pointer-compression" rel="noopener ugc nofollow" target="_blank">指针压缩</a>特性被禁用。在这个设置中，每个数组元素需要8个字节，一个容量为2 ⁰ (~1M)的映射需要大约29 MB的堆内存。</p><h2 id="62e0" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">摘要</h2><p id="c4ee" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">天哪，那是一次长途旅行。总结一下，下面是我们在V8中了解到的地图的列表:</p><ul class=""><li id="90cb" class="ni nj iq kf b kg kh kk kl ko nk ks nl kw nm la nn no np nq bi translated">V8使用确定性哈希表算法实现映射，其他JS引擎也很有可能这样做。</li><li id="f7da" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated">地图用C++实现，并通过JS API公开。</li><li id="636b" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated">就像“经典的”散列映射一样，映射操作所需的查找是O(1 ),重散列是O(N)。</li><li id="7185" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated">在64位系统上，当禁用指针压缩时，具有1M条目的映射在堆上占用大约29 MB。</li><li id="f877" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated">这篇博文中描述的大部分内容也可以应用于set。</li></ul><p id="5c4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这次到此为止。请分享你对下一个V8深潜的想法。</p></div></div>    
</body>
</html>