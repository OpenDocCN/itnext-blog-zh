<html>
<head>
<title>How to Write More Reusable Code?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何写出更多可重用的代码？</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-write-more-reusable-code-73f936283eff?source=collection_archive---------0-----------------------#2022-11-12">https://itnext.io/how-to-write-more-reusable-code-73f936283eff?source=collection_archive---------0-----------------------#2022-11-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b78b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在以写代码为生多年后，我发现了一些有趣的事情:程序员所做的无非是在抽象和具体之间跳来跳去。他们要么提取一些东西使它们更通用(这样它可以被广泛使用)，要么使用一个抽象的实例来解决一个特定的问题。换句话说，他们将代码抽象为具体的用法(尽管有时他们做得太过了)。</p><blockquote class="ko kp kq"><p id="fc1e" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">需要注意的是，没有一个受过职业道德训练的软件工程师会同意编写一个 <code class="fe kv kw kx ky b"><em class="it">DestroyBaghdad</em></code> <em class="it">程序。相反，基本的职业道德要求他编写一个</em> <code class="fe kv kw kx ky b"><em class="it">DestroyCity</em></code> <em class="it">程序，巴格达可以作为一个参数。</em></p><p id="24a7" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">——纳撒尼尔·博伦斯坦</p></blockquote><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/729c7e87682040f1693e0fc3d90cee53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P5e7nyeYM7jVKa2t"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated"><a class="ae lp" href="https://unsplash.com/@rainierridao?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">雷尼尔·里道</a>在<a class="ae lp" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="bcc2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一般来说，你越抽象，就越容易被重用。如果你发现一些硬代码，提取它作为一个参数。有时候一个参数是不够的，然后你提取一个保存这些参数的对象，甚至是一个可以为你产生这些参数的“函数”(我们将在下面的例子中看到这一点)。</p><h1 id="ebbd" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">好代码，坏代码？</h1><p id="ccf2" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">就像俗话说的“浪费只是用错了地方的资源”一样，糟糕的代码本质上只是一些写错了地方的代码。如果你能找到一种方法使现有的代码易于修改和适应新的用途，那么你就有了一个优雅得体的设计——这个过程被称为<em class="kr">重构</em>。</p><p id="de3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，理论到此为止。让我们来看一些例子，看看我在这里抽象和具体化是什么意思。</p><h1 id="dfe6" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">字符串格式化函数</h1><p id="e90c" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">让我们想象一下页面上的一个小特性:我们需要以一种特殊的方式格式化一个给定的标题——大写。例如，当标题是<code class="fe kv kw kx ky b">this is a string</code>时，那么我们需要将其转换为:</p><pre class="la lb lc ld gt mt ky mu bn mv mw bi"><span id="cc1f" class="mx lr it ky b be my mz l na nb">('Title ｜ ' + 'this is a string').toUpperCase()</span></pre><p id="cbd4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们很快意识到上面的代码只能处理这个特殊的字符串，所以我们需要让它处理任何给定的字符串。那么我们需要一个功能。</p><pre class="la lb lc ld gt mt ky mu bn mv mw bi"><span id="e296" class="mx lr it ky b be my mz l na nb">const formatTitle = (str: string) =&gt; `Title ｜ ${str.toUpperCase()}`</span></pre><p id="edd6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将适用于所有字符串。随着时间的推移，在其他一些情况下，我们需要将标题格式化为小写。再引入一个参数可以解决这个问题:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nc"><img src="../Images/24610660b3e9c31e9eb71b29f8b5cf47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EBGSBmyd8A6CU6OPubmWRw.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">formatTitle函数</figcaption></figure><p id="996c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以代码现在灵活多了。你可以把它弄得更高或更低。然而，当你想以其他方式转换一个字符串时(比如只大写一个字符串的第一个字母)，我们必须再一次扩展这个参数:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nc"><img src="../Images/dfd10adc5091f5d73b46eb4bc3038c2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MRVhe7BiVi5gTk7IcxO6jA.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">formatTitle函数</figcaption></figure><p id="0d37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着转换逻辑的发展，我们还必须在<code class="fe kv kw kx ky b">formatTitle</code>中放置许多if-else分支，直到我们意识到这里需要更多的<strong class="js iu"> <em class="kr">抽象</em> </strong>。更确切地说，我们需要一个<strong class="js iu">的东西</strong>可以<strong class="js iu">在这里做</strong>转换。换句话说，<code class="fe kv kw kx ky b">upper</code>、<code class="fe kv kw kx ky b">lower</code>和<code class="fe kv kw kx ky b">capitalise</code>都是某个东西的实例——我们在这里给那个东西起个名字:<strong class="js iu"> transformer </strong>。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nc"><img src="../Images/34de37ee5017cf1c9fde535f390ea6cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pEvKJmtnW83bw9M4ULrMyg.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">具有高阶函数的格式标题函数</figcaption></figure><p id="83e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这个抽象，我们就把<code class="fe kv kw kx ky b">format</code>和<code class="fe kv kw kx ky b">transform</code>分开了，我们可以传入一个transformer的任何实例来得到不同的结果。</p><p id="20bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，传入<code class="fe kv kw kx ky b">x.toUpperCase</code>将字符串转换成大写:</p><pre class="la lb lc ld gt mt ky mu bn mv mw bi"><span id="7def" class="mx lr it ky b be my mz l na nb">const title = formatTitle('this is a title', (x) =&gt; x.toUpperCase())</span></pre><p id="aaf1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并传入<code class="fe kv kw kx ky b">x.toLowerCase</code>将字符串转换成小写:</p><pre class="la lb lc ld gt mt ky mu bn mv mw bi"><span id="1a06" class="mx lr it ky b be my mz l na nb">const title = formatTitle('this is a title', (x) =&gt; x.toLowerCase())</span></pre><p id="6e43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意这里我们传入了一个名词，一个可以做动作的东西。即使当我们需要更复杂的逻辑时，我们也不需要改变<code class="fe kv kw kx ky b">formatTitle</code>的任何东西，而是实现一个新类型的实例。</p><p id="02f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，如果我们想把一个sting做成标题格式(<code class="fe kv kw kx ky b">This Is A Title Format</code>)</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nc"><img src="../Images/7290ab2e2c3849762b7e9c9825f9239c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yvl0hiDgq8kALqGyqRiVKQ.png"/></div></div></figure><p id="5108" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它不仅使代码非常灵活，而且使它非常容易测试。例如，在测试中，您只需要创建一个新类型的(抽象的)实例，它易于设置和验证:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nc"><img src="../Images/59f59bc5a53ef5bb4a11930bb8551583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B7F3ug2umEDVgDitDvuq4g.png"/></div></div></figure><p id="a3e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，我们是如何逐渐从<code class="fe kv kw kx ky b">formatTitle</code>中提取出<code class="fe kv kw kx ky b">transform</code>，并使替换另一个实现变得容易。所以本质上，这就是你如何做软件设计。</p><p id="f600" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">附注练习:尝试修改<code class="fe kv kw kx ky b">formatTitle</code>以使前缀易于替换，同样，用户可以提供<em class="kr">任何东西</em>作为前缀。</p><h1 id="0724" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">React的另一个例子</h1><p id="5163" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">假设React中有一个类似的案例:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nc"><img src="../Images/68e1a0c7eb014d5131467852198f13d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g4bi35EODDPb8axrqgU1AQ.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">React中的标题组件</figcaption></figure><p id="c56a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一行<code class="fe kv kw kx ky b">Title</code>组件基本上是硬编码的，并不真正可重用(除非您想要一个确切的标题，“这是一个标题”)，第二个组件接受一个参数，这要好得多。为了进行奇特的转换，我们有第二个参数:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nc"><img src="../Images/ac46f8e7011e425e844ae00d3ab93353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wGnmfy7HzKhHGc0c3fh20w.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">在属性列表中带有变压器功能</figcaption></figure><p id="1249" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际上，我们可以用React做更多的事情。例如，如果我们不希望<code class="fe kv kw kx ky b">Title</code>是一个<code class="fe kv kw kx ky b">h1</code>，而是一个<code class="fe kv kw kx ky b">h3</code>，我们可以在这里提取一个新的<strong class="js iu">概念</strong>，一个接受字符串并返回一个ReactNode的函数:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nc"><img src="../Images/f3ad0c0d31813a8ccbeff8c37f5e8262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IOI1uA90v1NP4v7LI6n33g.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">使用渲染属性</figcaption></figure><p id="2bd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就像普通组件一样使用它。请注意如何返回JSX节点，这为<code class="fe kv kw kx ky b">render</code>在这里可以做的事情打开了一个全新的世界。你甚至可以在这里返回<code class="fe kv kw kx ky b">header&gt;h3.className</code>。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nc"><img src="../Images/ff74f7a2e6ef6e6595f8695c0396954f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NYP-v9vUjum8Q4piUYbfmQ.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">使用渲染属性</figcaption></figure><p id="f0ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际上，在React中，你甚至可以将<code class="fe kv kw kx ky b">render</code>简化为<code class="fe kv kw kx ky b">children</code>，而不必在道具中传递一个函数:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nc"><img src="../Images/f2651c4028500e9bdca22ae3831a6a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o0RgNJjn-P6ljLiPiUDm3A.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">儿童作为渲染道具</figcaption></figure><p id="50e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后你的代码会被简化一点，你可以像个孩子一样通过任何你喜欢的东西:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nc"><img src="../Images/ec477ad8c60a05c45b573b6e9047e615.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*znc_rG1I2rt0KhwyVJJE4Q.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">像孩子一样使用函数</figcaption></figure><p id="9633" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，如果我们把它们放在一起，你可以看到这个抽象过程是多么强大。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nc"><img src="../Images/27a080eedb8af8883f6c4e23f2e3f3c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4pCDoKZY9NskFaHJdzfMBQ.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">把它们放在一起</figcaption></figure><p id="bdd7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意这里的模式:尝试从几个实例中提取一个概念:h2或h3都是<code class="fe kv kw kx ky b">heading</code>的不同实例，一旦我们提取了<code class="fe kv kw kx ky b">heading</code>，我们注意到我们不受<code class="fe kv kw kx ky b">heading</code>的限制，而是一个更广泛的概念:<code class="fe kv kw kx ky b">component</code> (ReactNode)，然后<code class="fe kv kw kx ky b">render</code>道具或<code class="fe kv kw kx ky b">children</code>更有意义。</p><p id="9581" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦我们有了一个通用组件(这里有<code class="fe kv kw kx ky b">render</code>),我们就可以具体地传入该抽象的一个实例。但美妙的是，我们只写一次通用代码，其他地方都只是它的<strong class="js iu"> <em class="kr">用法</em></strong>——即使是在单元测试中。</p><h1 id="018e" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">摘要</h1><p id="4ad4" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">对我来说，<em class="kr">写代码是一个尽量让代码做得少的过程</em>。换句话说，我们需要确定当前模块的核心职责。对于其余的部分，我们应该总是寻求将它们外包出去或者作为一个单独的模块提取出来(然后在需要的时候使用它们)。</p><p id="cb04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，可重用性的关键是尝试根据需要进行抽象，然后将调用位置替换为该抽象的具体实例。一旦你发现抽象还不够，再做一层抽象，重复这个过程。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><p id="b4f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae lp" href="https://icodeit.com.au/#subscribe" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">报名我的邮件列表</strong> </a> <strong class="js iu">。我大概是每周通过博客、</strong> <a class="ae lp" href="https://leanpub.com/u/juntao" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">书籍</strong> </a> <strong class="js iu">和</strong> <a class="ae lp" href="https://www.youtube.com/@icodeit.juntao" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">视频</strong> </a> <strong class="js iu">分享干净代码和重构技巧。</strong></p></div></div>    
</body>
</html>