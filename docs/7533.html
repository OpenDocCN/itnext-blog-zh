<html>
<head>
<title>When React Meets OOP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当React遇到OOP时</h1>
<blockquote>原文：<a href="https://itnext.io/when-react-meets-oop-7b2d89258b94?source=collection_archive---------0-----------------------#2022-10-26">https://itnext.io/when-react-meets-oop-7b2d89258b94?source=collection_archive---------0-----------------------#2022-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9f3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将讨论一个混合面向对象编程和React(函数式编程)的案例研究，并演示它如何提高可读性和可扩展性。</p><p id="572c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没有一种通用的方式来编写和形成你的React应用程序，但是我确实看到一些人鼓励人们在React中编写更多函数式编程风格的代码，而另一些人将所有东西都放在<code class="fe kl km kn ko b">view</code>中，我相信我们应该应用在其他软件领域中已经被证明的东西(特别是在这种情况下的设计模式和OOP ),我认为这些实践也可以有益于React代码。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ku kv l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">如果你喜欢看而不是读，我也有一个视频版本</figcaption></figure></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="c92b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="lh">【更新11。现在整个系列都完成了，我在leanpub上为它创作了一本书</em></strong><a class="ae li" href="https://leanpub.com/react-clean-code" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="lh"/></strong></a><strong class="jp ir"><em class="lh">。用</em> </strong> <a class="ae li" href="https://leanpub.com/react-clean-code/c/mYXp686cMFw1" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="lh">这个链接可以获得一份7折</em> </strong> </a> <strong class="jp ir"> <em class="lh">。</em>T24】</strong></p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="2d26" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">背景</h1><p id="3ac7" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">几个月前，我发表了两篇博文，总结了我在这个项目的重构之旅中的发现。我从origin项目中提取了一些有趣的事实，并去除了所有的噪音，从本质上讲，该功能完全是关于不同市场中的舍入逻辑，以及围绕该需求，作为开发人员，我们如何将代码重构为易于采用任何新市场或新舍入算法的状态。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mm"><img src="../Images/509d54fbaaa725b9b1d95cadd60555f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L01uZDYUxWmgoppwQbnu9w.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">web应用程序中的支付屏幕</figcaption></figure><p id="640b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，在澳大利亚市场，当订单是19.9美元时，通常会问用户是否愿意捐赠0.1美元。但同样的逻辑在日本市场并不适用，因为0.1日元实际上什么都不是。我们需要四舍五入到最接近的百，对于丹麦，我们需要四舍五入到最接近的十。</p><p id="4c37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理论到此为止。最近，当我把这些放在一起作为视频教程时，我发现了一些有趣的事情。我最初的计划是将这些博客帖子复制到一个视频中，这对于喜欢通过观看视频来学习的人来说更容易，但是由于我已经在很多情况下完成了这个特定的案例，在录制之后，我被另一个想法击中<a class="ae li" href="https://www.youtube.com/watch?v=j-VHE62zfjQ" rel="noopener ugc nofollow" target="_blank">(我相信如果我第一次这样做就不会发生这种情况)——这个场景类似于我的后端项目功能之一，我想知道如果我也可以在我的React代码中应用相同的设计模式会怎么样？</a></p><p id="4781" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更具体地说，在我的React代码中，我需要在props中公开一个<code class="fe kl km kn ko b">countryCode</code>:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mt"><img src="../Images/aa371fa75dec9f71d2b28b719ebfb1f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X3ojG_YGqhOyasSA_ZtVaw.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">道具中的国家代码</figcaption></figure><p id="b826" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您所猜测的，我需要在<code class="fe kl km kn ko b">Payment</code>中使用一些逻辑来格式化标签并计算取整金额:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mu"><img src="../Images/5ebaa3bf02917c571383e75e9f373a15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3hNu08YsX0XJIPHJBo7DYQ.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">使用货币映射获得正确的符号</figcaption></figure><p id="7f20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还需要在我的自定义钩子中为不同的国家切换到不同的算法:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mv"><img src="../Images/4cd57fbe08f4ffee917898395dac2be3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TBAGssHW13Vn8ldbijB4ag.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">useRoundUp挂钩中的类似逻辑</figcaption></figure><p id="0a3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(我知道你想说什么，但是别担心，上面的代码是简化的，我根本不用<code class="fe kl km kn ko b">let</code>。</p><h1 id="6f74" class="lj lk iq bd ll lm mw lo lp lq mx ls lt lu my lw lx ly mz ma mb mc na me mf mg bi translated">问题是</h1><p id="641e" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">这里的问题是，每当一个新的国家代码被添加到系统中时，我需要更改一些地方。格式化逻辑(针对货币符号)、取整逻辑(到整数、十或百)和一些帮助函数。</p><p id="78de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这差不多就是人们所说的猎枪手术。基本上，你必须修改很多地方来实现一个小的需求变化。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi nb"><img src="../Images/3b6ee7e6bc7019c9a8e8b0e530c6d980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GyIKvw6RH0JPv5yYdNURMA.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">猎枪手术的味道</figcaption></figure><h1 id="3233" class="lj lk iq bd ll lm mw lo lp lq mx ls lt lu my lw lx ly mz ma mb mc na me mf mg bi translated">战略模式</h1><p id="90fc" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">现在是时候介绍我想在本文中讨论的主要内容了:策略模式。这是我第二喜欢的模式(第一个当然是观察者模式)。本质上，策略模式是有一些策略实现一个公共接口，并且该接口有方法可以替换之前在代码中传播的这些<code class="fe kl km kn ko b">if-else</code>检查(或映射查找)。</p><p id="73fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常在OO语言中，我们使用多态性在运行时使用不同的接口实例。</p><p id="6426" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，在上面的图像中，不同颜色的条代表类似于<code class="fe kl km kn ko b">if(countryCode === 'JP')</code>的支票，所以与其这样做，不如想象我们有一个专门针对日本的类，在该类中，它有一个类似于<code class="fe kl km kn ko b">getCurrencySign</code>的方法，该方法返回<code class="fe kl km kn ko b">¥</code>。同时，我们有一个兄弟类，如果在这个类上调用了<code class="fe kl km kn ko b">getCurrencySign</code>，它将返回<code class="fe kl km kn ko b">$</code>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi nb"><img src="../Images/4a2b49b6f6352fabe55608588879b618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RGA_0xcKFjFGFTgTtXTrMQ.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">使用策略模式</figcaption></figure><p id="7a1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着我们只有一个地方可以为澳大利亚、日本或新市场拓展的任何地方改变任何东西！</p><h1 id="b1c9" class="lj lk iq bd ll lm mw lo lp lq mx ls lt lu my lw lx ly mz ma mb mc na me mf mg bi translated">反应上下文是锦上添花</h1><p id="9ee7" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">回到我们的React应用程序，一旦我提取了三个类<code class="fe kl km kn ko b">RoundUpStrategyAustraliaRoundUpStrategyDenmark</code>和<code class="fe kl km kn ko b">RoundUpStrategyJapan</code>。我唯一需要传进去的是:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi nc"><img src="../Images/8a6bbe962ddacc828cf83639a828a8d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NMyuGKtOag5Qv2OdrGQsGg.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">将策略作为一个整体对象传入</figcaption></figure><p id="d5de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我向妻子展示(实际上是炫耀)我所做的工作时，我很快意识到我可以用React Context做得更干净。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi nd"><img src="../Images/f76015ca5fa5e9ed21e590ee0aa2f50d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zI1AOEJFyuGrq-FOu6HYFg.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">在上下文中定义策略</figcaption></figure><p id="1daa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我可以把付款包在<code class="fe kl km kn ko b">RoundUpStrategyContext</code>周围，就像:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ne"><img src="../Images/d996b88fdcf0daf59802dd8d700cc691.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xEbUBxR_FwM6FqimOvZw6g.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">用上下文包装支付——然后你可以动态切换</figcaption></figure><p id="be4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于<code class="fe kl km kn ko b">Payment</code>本身来说，它差不多就是我的初始版本。唯一的依赖是超级抽象的<code class="fe kl km kn ko b">RoundUpStrategy</code>接口。</p><h1 id="b83c" class="lj lk iq bd ll lm mw lo lp lq mx ls lt lu my lw lx ly mz ma mb mc na me mf mg bi translated">类图</h1><p id="d150" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">最后，我制作了一个UML图来展示React代码旁边的内容。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi nf"><img src="../Images/983aae573224931c9225cd798e177b72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KJattDplzpt-zkGKcn3d_g.jpeg"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">支付应用程序的类图</figcaption></figure><h1 id="c685" class="lj lk iq bd ll lm mw lo lp lq mx ls lt lu my lw lx ly mz ma mb mc na me mf mg bi translated">利益</h1><p id="303c" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">我认为这种OOP + React方法有很多好处，但我在这里只列举几个:</p><ul class=""><li id="ca8a" class="ng nh iq jp b jq jr ju jv jy ni kc nj kg nk kk nl nm nn no bi translated">视图和业务逻辑之间更清晰的界限</li><li id="c4e7" class="ng nh iq jp b jq np ju nq jy nr kc ns kg nt kk nl nm nn no bi translated">视图和类(或算法)的可测试性</li><li id="26f7" class="ng nh iq jp b jq np ju nq jy nr kc ns kg nt kk nl nm nn no bi translated">我们可以将提取的类完全推到后端，而无需修改一行代码</li></ul></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="971b" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">摘要</h1><p id="f2cc" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">尽管在React中很少提到面向对象编程，但这并不意味着我们应该忽略软件开发的其他领域中已被证实的模式和概念，尤其是当它们修复我们的问题时。</p><p id="84ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在React中使用接口、类和上下文，我们可以从我们的<code class="fe kl km kn ko b">view</code>和<code class="fe kl km kn ko b">hooks</code>中显著简化大量复杂的逻辑，同时保持高水平的可读性和可测试性。</p><p id="a11d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想了解更多关于这个话题的内容，我在leanpub也有一本关于它的书。</p></div></div>    
</body>
</html>