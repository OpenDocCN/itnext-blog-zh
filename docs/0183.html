<html>
<head>
<title>The Pipeline Operator is Now!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">管道操作员现在！</h1>
<blockquote>原文：<a href="https://itnext.io/an-emoji-lovers-guide-to-functional-programming-part-4-735c17ca4113?source=collection_archive---------0-----------------------#2017-11-03">https://itnext.io/an-emoji-lovers-guide-to-functional-programming-part-4-735c17ca4113?source=collection_archive---------0-----------------------#2017-11-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/340a0bbf86d5ec4926929328322c8f60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gvPr1Dhzh8XB2BckHqZkrQ.png"/></div></div></figure><h2 id="344a" class="iz ja jb bd b dl jc jd je jf jg jh dk ji translated" aria-label="kicker paragraph">表情符号爱好者的函数式编程指南</h2><div class=""/><div class=""><h2 id="3ecd" class="pw-subtitle-paragraph kh jk jb bd b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dk translated">使用正式的ECMAScript管道操作符。</h2></div><p id="f2c9" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><em class="lv">用表情符号和JavaScript学习函数式编程。代码示例应该足够简单，不需要任何先验知识就可以理解，但是我可以想象它看起来有点奇怪。还有，JavaScript实际上不允许表情符号作为JavaScript变量名。出于这个原因，这些代码示例不会在没有修改的情况下运行。</em></p><ul class=""><li id="5d08" class="lw lx jb lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-1-241d8d4c9223" rel="noopener"> <em class="lv">用食物表情符号制作便便。</em>T11】</a></li><li id="4cf2" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-2-800b438c7ce3" rel="noopener"> <em class="lv">把暴风云变成晴朗的云。</em>T15】</a></li><li id="34ed" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-3-ef78e3156e" rel="noopener"> <em class="lv">用减速器造独角兽！</em>T19】</a></li><li id="f0f3" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-4-735c17ca4113" rel="noopener"> <em class="lv">现在的管道操作员是！</em> </a></li><li id="cb51" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-5-a6bc3324a839" rel="noopener"> <em class="lv">为食肉动物过滤肉类。</em> </a></li><li id="3f85" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-6-5c1d441d36af" rel="noopener"> <em class="lv">使用递归与归约。</em> </a></li></ul></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="f8a3" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们一直在使用的<code class="fe ms mt mu mv b">pipe</code>函数实际上是pipeline的简称。当你读到这篇文章的时候，它可能已经发布了，我们目前正处于JavaScript 中<a class="ae mf" href="https://github.com/tc39/proposal-pipeline-operator" rel="noopener ugc nofollow" target="_blank">管道操作符的第一阶段</a>。</p><p id="47a6" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">让我们回到unicorn的例子，如果不遍历一个数组，链接我们的<code class="fe ms mt mu mv b">add</code>函数会有一个大问题。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="a67f" class="ne nf jb mv b gy ng nh l ni nj">add = additive =&gt; item =&gt; item + additive</span><span id="aefb" class="ne nf jb mv b gy nk nh l ni nj">🦄 = (<br/>    add(🎶)(<br/>        add(✨)(<br/>            add(🌈)(<br/>                add(🤘)(🐴)<br/>            )<br/>        )<br/>    )<br/>)</span></pre><p id="8f84" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">有时候我们不想遍历数组。也许我们想要一个<code class="fe ms mt mu mv b">subtract</code>和一个<code class="fe ms mt mu mv b">add</code>混合在一起，当循环一个函数时会变得稍微复杂一点。当然，我们可以添加一个三元组，并拆分我们在<code class="fe ms mt mu mv b">map</code>上调用的函数，但这不会非常干净地解决所有情况。</p><p id="24d8" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这是我们之前用自己的<code class="fe ms mt mu mv b">pipe</code>函数得到的解决方案:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="5ad4" class="ne nf jb mv b gy ng nh l ni nj">🦄 = pipe(<br/>    🐴,<br/>    add(🤘),<br/>    add(🌈),<br/>    add(✨),<br/>    add(🎶)<br/>)</span></pre><p id="1e9a" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">使用本地管道操作符，我们可以进一步改进:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="5f5b" class="ne nf jb mv b gy ng nh l ni nj">🦄 = 🐴 |&gt; add(🤘) |&gt; add(🌈) |&gt; add(✨) |&gt; add(🎶)</span><span id="d86c" class="ne nf jb mv b gy nk nh l ni nj">🦄 = (<br/>    🐴<br/>    |&gt; add(🤘)<br/>    |&gt; add(🌈)<br/>    |&gt; add(✨)<br/>    |&gt; add(🎶)<br/>)</span></pre><p id="26ce" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">管道操作符获取一个值，然后将其传递给链中的每个函数。看看这段代码，很容易推理并以正确的顺序完成我们需要的任务。</p><p id="a1f1" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">回到我们最初的管道，它返回一个函数；管道运营商没有。这是否意味着管道运营商势在必行？不。但这确实意味着如果我们想要像以前一样的功能管道，我们需要包装它:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="c869" class="ne nf jb mv b gy ng nh l ni nj">rockBand = item =&gt; (<br/>    item<br/>    |&gt; add(🤘)<br/>    |&gt; add(🎶)<br/>)</span><span id="ddb2" class="ne nf jb mv b gy nk nh l ni nj">luckyCharms = item =&gt; (<br/>    item<br/>    |&gt; add(🌈)<br/>    |&gt; add(✨)<br/>)</span><span id="6d71" class="ne nf jb mv b gy nk nh l ni nj">kidsTheseDays = item =&gt; rockBand(luckyCharms(item))</span><span id="cce0" class="ne nf jb mv b gy nk nh l ni nj">🦄 = kidsTheseDays(🐴)</span></pre><p id="9262" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们可以用不同的方式写<code class="fe ms mt mu mv b">kidsTheseDays</code>,实现同样的事情:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="db2d" class="ne nf jb mv b gy ng nh l ni nj">kidsTheseDays = item =&gt; (<br/>    item <br/>    |&gt; rockBand<br/>    |&gt; luckyCharms<br/>)</span><span id="e595" class="ne nf jb mv b gy nk nh l ni nj">🦄 = kidsTheseDays(🐴)</span></pre><p id="eb43" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">注意我们如何使用功能管道来连接其他功能管道。这将导致一些奇妙的代码重用！一个额外的好处是，只有在我们传递了<code class="fe ms mt mu mv b">item</code>之后，处理才会发生。</p><p id="d6c6" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">因为所有管道操作符(<code class="fe ms mt mu mv b">|&gt;</code>)都可以是我们常规的旧<code class="fe ms mt mu mv b">pipe</code>函数的独立参数，所以让我们用JavaScript的原生<code class="fe ms mt mu mv b">pipe</code>实用程序<code class="fe ms mt mu mv b">Promise</code>制作一个独角兽:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="370b" class="ne nf jb mv b gy ng nh l ni nj">rockBand = item =&gt; (<br/>    Promise.resolve(item)<br/>    .then(add(🤘))<br/>    .then(add(🎶))<br/>)</span><span id="425d" class="ne nf jb mv b gy nk nh l ni nj">luckyCharms = item =&gt; (<br/>    Promise.resolve(item)<br/>    .then(add(🌈))<br/>    .then(add(✨))<br/>)</span><span id="77af" class="ne nf jb mv b gy nk nh l ni nj">kidsTheseDays = item =&gt; (<br/>    Promise.resolve(item)<br/>    .then(rockBand)<br/>    .then(luckyCharms)<br/>)</span><span id="96d6" class="ne nf jb mv b gy nk nh l ni nj">promiseICanHasUnicorn = kidsTheseDays(🐴)</span><span id="4d8f" class="ne nf jb mv b gy nk nh l ni nj">promiseICanHasUnicorn<br/>.then(console.log)<br/>// 🦄</span></pre><p id="4367" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">使用<code class="fe ms mt mu mv b">Promise.resolve</code>，我们能够做与管道操作符完全相同的事情，并且我们获得了内置的错误处理的额外好处。</p><p id="dcca" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如果你还没有使用过承诺，你可能会意识到它们是异步发生的；因此，您实际上对它们的执行没有多少控制权。在我们的例子中，我们没有对unicorn做任何事情，但是在普通的代码库中，您通常会一直进行处理，直到您触发了副作用，比如写入数据库或呈现到DOM。</p><p id="3136" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">虽然JavaScript的本机<code class="fe ms mt mu mv b">Promise</code>允许我们像使用管道操作符一样使用管道，但它固有的异步性可能不符合您的特定限制。在这种情况下，你可以像这样使用<code class="fe ms mt mu mv b">await</code>:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="c386" class="ne nf jb mv b gy ng nh l ni nj">🦄 =<!-- --> await <!-- -->kidsTheseDays(🐴)</span></pre><p id="8d57" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">当直接处理承诺时，您不需要指定<code class="fe ms mt mu mv b">async</code>关键字，因为它只是将您的返回值包装在承诺中的语法糖。这样，我们就有了一个不一定是异步的原生JavaScript <code class="fe ms mt mu mv b">pipe</code>。</p><p id="ea61" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">与<code class="fe ms mt mu mv b">async-await</code>有取舍写法。<code class="fe ms mt mu mv b">Promise</code>是处理副作用的功能性方法。使用<code class="fe ms mt mu mv b">async-await</code>将你的功能性的基于承诺的代码转变为一步一步的命令式方法。这里需要一个<code class="fe ms mt mu mv b">await</code>的例子看起来很棒，但是当你围绕其他函数创建函数时，<code class="fe ms mt mu mv b">async-await</code>就变成了一种疾病。</p><p id="0be7" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">每个包含<code class="fe ms mt mu mv b">await</code>的函数都需要定义为<code class="fe ms mt mu mv b">async</code>。任何调用链上的<code class="fe ms mt mu mv b">async</code>函数的函数在被调用之前也需要有<code class="fe ms mt mu mv b">await</code>，然后也需要被包装在<code class="fe ms mt mu mv b">async</code>中。这意味着深入代码库的一个<code class="fe ms mt mu mv b">async-await</code>会导致链上所有更高的功能需要相同的处理。因此，当需要异步操作时，最好使用基于<code class="fe ms mt mu mv b">Promise</code>的管道，而不是<code class="fe ms mt mu mv b">async-await</code>。</p><p id="5ba6" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="lb jl">感受未来！</strong></p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h2 id="85a2" class="ne nf jb bd nl nm nn dn no np nq dp nr li ns nt nu lm nv nw nx lq ny nz oa jh bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-5-a6bc3324a839" rel="noopener">点击此处进入第5部分！</a></h2><h1 id="af41" class="ob nf jb bd nl oc od oe no of og oh nr kq oi kr nu kt oj ku nx kw ok kx oa ol bi translated">更多阅读</h1><p id="b4c8" class="pw-post-body-paragraph kz la jb lb b lc om kl le lf on ko lh li oo lk ll lm op lo lp lq oq ls lt lu ij bi translated">如果您对与函数式编程相关的更多主题感兴趣，您应该看看我的其他文章:</p><ul class=""><li id="f12a" class="lw lx jb lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae mf" rel="noopener ugc nofollow" target="_blank" href="/how-to-safely-refactor-old-code-part-1-a1a853263fec">安全重构旧代码:第1部分</a></li><li id="21e8" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/the-secret-to-using-redux-createnamespacereducer-d3fed2ccca4a" rel="noopener">使用Redux的秘密:createNamespaceReducer </a></li><li id="c67f" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/using-redux-reducers-in-react-components-4e92985dd9cb" rel="noopener">在React组件中使用Redux还原剂</a></li><li id="7284" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/redux-observable-can-solve-your-state-problems-15b23a9649d7" rel="noopener"> Redux-Observable可以解决你的状态问题</a></li><li id="e914" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/flicblog/flic-buttons-and-the-observable-customization-using-rxjs-2214bc53d407" rel="noopener"> RxJS和可观察的Flic按钮</a></li></ul></div></div>    
</body>
</html>