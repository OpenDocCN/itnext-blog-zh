<html>
<head>
<title>Building Vue Enterprise Application: Part 3. The Store</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建Vue企业应用程序:第3部分。商店</h1>
<blockquote>原文：<a href="https://itnext.io/building-vue-enterprise-application-part-3-the-store-dbda0e4bb117?source=collection_archive---------0-----------------------#2020-04-02">https://itnext.io/building-vue-enterprise-application-part-3-the-store-dbda0e4bb117?source=collection_archive---------0-----------------------#2020-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0e6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将清洁架构的原则应用于企业前端应用</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/7c4487e7defb9d5d8494e1afdbe5a19c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QKgJUsm94-7qAmMMqGXiIQ.png"/></div></div></figure><h1 id="ef6b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">目录</h1><ul class=""><li id="7a2a" class="lv lw iq jp b jq lx ju ly jy lz kc ma kg mb kk mc md me mf bi translated">介绍</li><li id="78ad" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">需求分析</li><li id="73cf" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">设置</li><li id="3fb5" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">吸气剂</li><li id="def1" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">突变</li><li id="8e29" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">行动</li><li id="7800" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">引入存储</li><li id="821a" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">连接点</li><li id="4fcf" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">结论</li></ul><h1 id="ada8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">到…里面</h1><p id="086d" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">是时候发布这个系列的第三篇帖子了。在第一篇文章《T1》中，我们谈到了实体和博客的基本商业规则。我们奉献了<a class="ae mo" href="https://medium.com/@gregsolo/building-vue-enterprise-application-part-2-services-f7ec400190e7" rel="noopener">第二教程</a>来揭示这些规则是如何被执行和启动的。在这篇文章中，我将重点介绍应用程序的全球商店:Vuex。</p><p id="01df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有成千上万的帖子/视频/关于Vuex及其工作原理的讨论。我不会花时间介绍基础知识，而只是简单地提醒一下概念概念。Vuex遵循通量模式，由3种主要药剂组成:</p><ul class=""><li id="ee69" class="lv lw iq jp b jq jr ju jv jy mp kc mq kg mr kk mc md me mf bi translated">行动</li><li id="cf86" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">突变</li><li id="1f55" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">商店</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ms"><img src="../Images/e10388dd5cb7b3a98c6d5919845de61d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-x6T1BBu1KlLL-TvN9hSHA.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">Vuex</figcaption></figure><p id="86f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一个是在应用程序中存储数据，为每个UI组件提供对数据的访问。突变仅仅是功能，其责任是使商店发生突变。最后，动作是执行侧面影响的操作并基于此提交突变的功能。还有一个“getters”的概念:可选的助手函数，提供对商店中最常用部分的访问。</p><p id="b82e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常将业务逻辑放在动作/突变中。毕竟，他们有责任改变国家。但是正如我们<a class="ae mo" href="https://medium.com/javascript-in-plain-english/react-vue-and-business-logic-19df105698a2" rel="noopener">讨论的</a>，业务逻辑不能与用户界面相结合。而<strong class="jp ir"> Vuex是UI </strong>、<strong class="jp ir">的一部分，不管它假装不是</strong>有多难。Vuex的唯一职责是:</p><blockquote class="mx my mz"><p id="5f9b" class="jn jo na jp b jq jr js jt ju jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj kk ij bi translated">应用程序中所有[UI]组件的集中存储，规则确保[UI]状态只能以可预测的方式发生变化</p><p id="ed68" class="jn jo na jp b jq jr js jt ju jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj kk ij bi translated"><a class="ae mo" href="https://vuex.vuejs.org" rel="noopener ugc nofollow" target="_blank">https://vuex.vuejs.org</a></p></blockquote><p id="1cd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">之所以会发生</strong>状态变化的原因以及这些变化的<strong class="jp ir">规则背后的深层商业推理与Vuex无关。</strong></p><p id="84c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以前，我们定义了拥有业务规则知识并操作它们的实体和服务。但是，我们如何在Vuex商店和服务/实体之间搭建桥梁呢？</p><p id="a997" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从Vuex的角度来看，服务是“副作用”。它们存在于Vue-Vuex生态系统之外，并有权影响国家。在Vuex中有一个专门的角色，负责处理副作用:行动</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/8b3338fee86d3ba5def44387d87a0f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IHX7KeJb0fZwutIlAZN6zw.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">Vuex +服务</figcaption></figure><p id="702d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">副作用的一个典型例子是HTTP请求。就Vuex而言，服务与发出HTTP请求、与套接字通信或处理任何其他类型的副作用没有什么不同。</p><p id="9f3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，建筑上的差异是显著的。如果我们允许动作直接发出HTTP请求，它们就必须知道如何从API操作数据。更糟糕的是，在将数据发送到后端之前，他们必须知道如何验证和准备数据。这是UI (Store)与业务逻辑的耦合。我们应该尽可能地避免它。为了防止这种耦合，动作将只调用服务，而不提供关于服务如何操作的任何信息。</p><h1 id="767f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">需求分析</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/8b98b08ae875d04f452d04e31adc166c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Wo3HunQl-2zUDpHm"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">由<a class="ae mo" href="https://unsplash.com/@helloquence?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在<a class="ae mo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的</a></figcaption></figure><p id="2636" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自从我们上次讨论业务需求以来，它们并没有改变。让我们提醒自己它们是什么:</p><ul class=""><li id="87c9" class="lv lw iq jp b jq jr ju jv jy mp kc mq kg mr kk mc md me mf bi translated">作为用户，我应该能够在主页上看到所有的文章</li><li id="f346" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">作为一个用户，我应该能够从那里导航到一个页面，代表一个特定的文章，并看到完整的文章</li><li id="9ff7" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">作为一个用户，我应该能够在这个页面上留下评论</li></ul><p id="558c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们完成了为我们准备服务的技术任务。是时候为商店定义任务了:</p><ul class=""><li id="2dd8" class="lv lw iq jp b jq jr ju jv jy mp kc mq kg mr kk mc md me mf bi translated">UI组件应该有机会轻松访问全球商店中的所有文章。</li><li id="8fb0" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">每次用户创建新评论时，商店都应该更新。</li></ul><h1 id="b335" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">设置</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ng"><img src="../Images/ca44e1364288dd72bdd5b3446a3f66e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YNLz1a03Y3e30Bdh"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">照片由<a class="ae mo" href="https://unsplash.com/@alexacea?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alexandru Acea </a>在<a class="ae mo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="9061" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回购可在<a class="ae mo" href="https://github.com/soloschenko-grigoriy/vue-vuex-ts/" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得</p><p id="d1ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">演示可在<a class="ae mo" href="https://vue-vuex-ts-services.herokuapp.com" rel="noopener ugc nofollow" target="_blank">此处</a>获得</p><p id="d494" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="na">如果您完成了之前的教程，您可以继续在当前分支工作。但是可以随意切换到“服务”分支，它包含了以前完成的教程。</em></p><p id="2794" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在最简单的场景中，所有的动作、突变和getters都位于一个文件中。但是我将为它们定义单独的文件夹。理由是它将允许我更容易地扩展和测试。每个文件夹都有一个熟悉的结构:类型、规范、模拟、桶文件，以及实际的动作/变异/getter和存储本身:</p><p id="9e6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">商店:</p><pre class="km kn ko kp gt nh ni nj nk aw nl bi"><span id="5c93" class="nm ky iq ni b gy nn no l np nq">/src/store/store.mock.ts<br/>/src/store/store.ts<br/>/src/store/store.types.ts</span></pre><p id="5e28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">动作:</p><pre class="km kn ko kp gt nh ni nj nk aw nl bi"><span id="f6f5" class="nm ky iq ni b gy nn no l np nq">/src/store/actions/actions.mock.ts<br/>/src/store/actions/actions.spec.ts<br/>/src/store/actions/actions.types.ts<br/>/src/store/actions/actions.ts<br/>/src/store/actions/index.ts</span></pre><p id="706c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">吸气剂:</p><pre class="km kn ko kp gt nh ni nj nk aw nl bi"><span id="ce40" class="nm ky iq ni b gy nn no l np nq">/src/store/getters/getters.mock.ts<br/>/src/store/getters/getters.spec.ts<br/>/src/store/getters/getters.types.ts<br/>/src/store/getters/getters.ts<br/>/src/store/getters/index.ts</span></pre><p id="79be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">突变:</p><pre class="km kn ko kp gt nh ni nj nk aw nl bi"><span id="9945" class="nm ky iq ni b gy nn no l np nq">/src/store/mutations/mutations.mock.ts<br/>/src/store/mutations/mutations.spec.ts<br/>/src/store/mutations/mutations.types.ts<br/>/src/store/mutations/mutations.ts<br/>/src/store/mutations/index.ts</span></pre><p id="3a28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们首先更新所有的桶文件，并暂时忘记它们:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">桶形锉</figcaption></figure><p id="b1ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="na">注意:在实际应用中，将Vuex存储分离到名称空间并为每个域的每个动作/变异/getter创建文件夹和文件也是明智的。但是由于我们的App只有一个域(文章)，感觉没必要复杂。</em></p><p id="0230" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="na">还要注意:我没有为商店创建一个规范，因为它所做的只是将动作、变异和获取器组合在一起。我测试这个案例没有发现太大的价值，但是你的应用可能不一样。</em></p><p id="21b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将从商店的类型开始。我们必须提供的最关键的类型是用于<strong class="jp ir">状态的接口。</strong> Vuex操作两个术语:根状态和实际状态。此外，我们可以为商店本身创建一个方便的别名(这只是从State派生的一个通用别名):</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">商店类型</figcaption></figure><p id="3778" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，该存储将包含一个IArticlesData数组，为UI组件提供对数据的访问。我们不打算在存储中存储类实例(通常不推荐)，而是存储原始数据，并在需要数据时实例化文章。</p><h1 id="23dc" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">吸气剂</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nt"><img src="../Images/2445f8328de10acf0d2e86a58da526d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uPMrN1y6QNuBhbrD"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">照片由<a class="ae mo" href="https://unsplash.com/@franckinjapan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Franck V. </a>在<a class="ae mo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="cad4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">先从最简单的说起:getters。它是一个普通的对象，具有从存储中获取数据、基于该数据实例化一个类并返回它的函数:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">Getters类型</figcaption></figure><p id="431a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="na">注意“这个”的明确定义Vuex将在商店的上下文中调用这些函数，并且知道这将允许我们在未来利用一些优势。</em></p><p id="e2c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试非常简单:“getAllArticles”必须返回所有文章，而getOneArticlesById必须按Id返回一篇文章，如果没有数据，则返回undefined:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">吸气剂规格</figcaption></figure><p id="0d11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="na">注意，为了正确测试，我们必须在存储的上下文中调用getters。Vuex就是这么称呼他们的。</em></p><p id="7c83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个测试(和许多其他测试一样)需要“mockState”和“mockStore”。在我们继续之前，让我们定义这些模拟:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">商店类型</figcaption></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">商店模拟</figcaption></figure><p id="47ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="na">您可能想知道"</em> dispatch "、" commit "、" subscribe" <em class="na">等附加功能来自于"</em> mockStore。"它们是Vuex商店界面的一部分。因为IStoreMock扩展了IStore，所以我们必须实现和模拟Store的所有公共方法。另外，我发现在测试中嘲笑和窥探他们是很有用的。</p><p id="cfc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们现在可以实现Getters本身了:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">吸气剂</figcaption></figure><p id="ae39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和他们的嘲笑:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">吸气者嘲笑</figcaption></figure><h1 id="152e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">突变</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ng"><img src="../Images/6e3b452ffa08f8a17bf0de402d277552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B2Yzzfa3mtt_bbM0"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">克里斯·劳顿在<a class="ae mo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="7ef8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是突变，Vuex商店的核心。我们只有两种类型的变化:第一种允许我们存储商店中的所有文章，第二种为现有文章添加新的评论。</p><p id="07b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个变体期望文章数组作为有效载荷，而第二个变体需要引用文章和评论数据。</p><p id="a4d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来定义接口:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">突变类型</figcaption></figure><p id="345c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Spec应测试“fetchArticles”是否将数据放入存储中，如果不存在，则“createComment”会创建文章并为文章添加注释:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">突变规格</figcaption></figure><p id="a50a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果有一个有效负载的模拟就好了，所以让我们来定义它:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">变异嘲笑</figcaption></figure><p id="a3fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并实现突变:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">肉体的变异</figcaption></figure><h1 id="2052" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">行动</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nu"><img src="../Images/1a120b299497c6c4c3eab8c1f8d59f3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9ncSrFo1yCwymUaO"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">马修·布罗德在<a class="ae mo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="aa6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，行动有点棘手。他们与外界交流；他们处理副作用。对于我们的应用程序，我们将实现两个动作:一个负责获取文章，另一个处理评论创建过程。</p><p id="477e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">他们到底是怎么做到的？首先，动作调用服务并获取所有需要的数据。然后，他们使用这些数据来提交突变，并将其保存到存储中。</p><p id="4ab9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">服务的“getAll”方法不需要任何参数。抓取动作也不需要任何东西。另一方面，服务的“createComment”方法需要文章的id和评论的数据。所以，我们必须为这个动作提供类似的有效载荷。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">动作类型</figcaption></figure><p id="ee4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="na">注意:Context只是Vuex应用于我们州的ActionContext的别名。</em></p><p id="834e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，让我们定义一下模拟:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">行动模拟</figcaption></figure><p id="1e7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="na">注意:不要忘记Vuex调用带有特殊ActionContext参数的动作。我们也必须嘲笑它。</em></p><p id="4407" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试必须非常简单。“fetchArticles”操作应调用服务，然后提交变异。</p><p id="3384" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是怎么做呢？</p><p id="911b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一点上，我们没有联系，没有服务和商店之间的“桥梁”。如果您还记得，我们创建了一个专用的提供者来提供对服务实例的访问。现在我们要<em class="na">把</em>注入店里。</p><p id="bce1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Vuex是Vue基础设施的一部分，按照它的规则运行。具体来说，这意味着我们可以使用一个叫做<em class="na">插件</em>的简洁特性来按照我们想要的方式调整商店上下文。</p><p id="011b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">导航到/src/ui/plugins。您可以看到这里有一个Vuetify插件，我们将创建另一个插件。称之为“services.ts ”,并添加以下内容:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">服务插件</figcaption></figure><p id="4b7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要忘记更新桶文件:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">插件桶文件</figcaption></figure><p id="6e33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个插件中，我们定义了一个注入服务实例的函数(由<em class="na">提供者提供，</em>原谅我的<em class="na"> </em>赘述)并将它注入到商店和每个Vue组件中。</p><p id="a902" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，这些代码并不是现成的。你看，Vue和Vuex都不知道在<em class="na">编译时</em>是否存在服务。从技术上讲，它们的类型不包含“$service”属性。这就是为什么我们会收到类似“<em class="na">属性“$services”在类型“Vue”上不存在的错误</em></p><p id="faa6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们必须调整Vue和Vuex类型，以尊重我们刚刚注入到它们中的这个属性。我们将采用与Vuetify相同的方式解决这个问题:通过提供一个定制的shim文件。</p><p id="ad80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在/src/ui文件夹中，您可能会看到一些shim文件。让我们定义另一个“shims-provider.d.ts”，其内容如下:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">提供商shim</figcaption></figure><p id="ca55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在Vue和Vuex类型在编译时都知道服务。</p><p id="fcb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="na">为什么财产名称前有美元符号？这是Vue生态系统中的常见约定。你可以找到$vuetify，$props，$store properties等。</em></p><p id="b807" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，让我们将插件投入使用。在/src/main.ts中实例化Store并调用“prepareServices”:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">在启动时应用提供者插件</figcaption></figure><p id="cabe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们必须更新Store mock，因为它现在保存了对服务的引用:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">更新存储模拟和类型</figcaption></figure><p id="4a6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回到动作，我们可以验证<strong class="jp ir"> </strong>服务现在在执行上下文中是可访问的:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">操作现在可以访问服务</figcaption></figure><p id="0bfe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是实施变异。由于Vuex执行动作时将上下文作为第一个参数，我们可以很容易地调用突变:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">行动</figcaption></figure><p id="1106" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管从技术上讲这可能行得通，但这不是一种可扩展的安全方法。首先要注意的是，我使用了一个<strong class="jp ir">字符串</strong>作为变异名称。</p><p id="bb72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从长远来看，这可能是一个问题:有人可以更改突变的名称，突然，这些代码不再工作了。更糟糕的是，它可能会在没有任何显式错误的情况下停止工作:突变根本不会被提交。</p><p id="4207" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了避免这个问题，通常的做法是使用常量作为变异/动作/getter的名称:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">伪代码</figcaption></figure><p id="37e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这种方法是完全合法的，但它没有解决这个难题的一个关键部分:<strong class="jp ir">有效载荷的签名</strong>。动作/变异/获取器的常量名称没有给出关于它们期望的有效载荷类型的提示或约束。</p><p id="df95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仔细看看这些动作。“commit”方法接受任何内容作为第二个参数。作为突变消费者，我们对我们必须提供的数据一无所知。唯一知道的方法是通过查找突变的源代码。我写了一整篇文章，讨论为什么应用程序的不同部分应该是未知的、黑盒的。最后，提供不正确的数据可能会导致运行时错误，为了捕捉这些错误，我们必须经历一个非常长的反馈循环。</p><p id="bf1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以用TypeScript做得更好。 </p><h1 id="e543" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">储物简介</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nv"><img src="../Images/22dc6d9a3230c5a06eb1e39d8470824f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*opZizh9ABHar8FVE"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">弗兰克·麦肯纳在<a class="ae mo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="554b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想法很简单:我们创建一个具有清晰接口的对象，该对象将在幕后调用Vuex方法。这个“代理”是依赖循环中存储的一部分。商店的消费者(首先是UI组件)将有一个健壮的API可以使用:他们肯定知道支持什么动作/变化/获取器，以及他们期望什么有效负载。我将把这个模块称为存储。</p><p id="18df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="na">为什么，“储存？”没有特别的原因。这听起来很主观，因为它与“商店”这个词产生了共鸣但是如果你不喜欢，你可以用任何其他的名字。</em></p><p id="27a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我首先在商店中创建一个“存储”文件夹，并按照熟悉的结构用空文件填充它:</p><pre class="km kn ko kp gt nh ni nj nk aw nl bi"><span id="5e30" class="nm ky iq ni b gy nn no l np nq">/src/store/storage/storage.ts<br/>/src/store/storage/storage.types.ts<br/>/src/store/storage/storage.mock.ts<br/>/src/store/storage/storage.spec.ts<br/>/src/store/storage/index.ts</span></pre><p id="75eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并重新导出桶文件中的所有内容:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">桶形锉</figcaption></figure><p id="4072" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">存储本身只是一个对象，它为每个getter/variation/action保存方法，并具有适当的有效负载:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">存储类型</figcaption></figure><p id="3934" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个方法的职责是调用相应的存储API。我们可以通过确保调用API方法来快速测试这一点:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">存储规格</figcaption></figure><p id="b8ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实际代码相对简单。同样，存储在运行时所做的只是代理存储:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">储存；储备</figcaption></figure><p id="f78e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我使用一个工厂函数将对存储的引用注入存储对象并返回它。</p><p id="7cdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们不要忘记嘲弄:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">存储模拟</figcaption></figure><p id="bbd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在许多UI组件中使用存储，甚至是存储本身，这意味着我们应该像对待服务一样注入它。</p><p id="dac4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们为它定义一个Vue插件:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">存储Vue插件</figcaption></figure><p id="8d78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后在引导时初始化存储:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">在启动时应用存储插件</figcaption></figure><p id="98dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，让我们扩展Vue和Vuex的类型:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">存储垫片</figcaption></figure><p id="eaf7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并更新商店模拟:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">更新存储模拟以使用存储模拟</figcaption></figure><p id="f4fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="na">注意:有一些库为Vuex提供了强大的类型解决方案。是否使用它们而不是这种存储由您决定。我个人不赞成在代码中添加另一个依赖项，尤其是因为我们只需要几行代码就可以完成我们的目标。</em></p><h1 id="367f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">将这些点连接起来</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nw"><img src="../Images/ebd5127abdf2fc02aa9236f5057e0de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_22q50jxCQ0NYgzw"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">照片由<a class="ae mo" href="https://unsplash.com/@othentikisra?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> israel palacio </a>在<a class="ae mo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1bf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没有什么能阻止我们从便利的存储API中获益。让我们在行动中尝试一下。我将使用存储，而不是直接提交“fetchArticles”突变:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">获取文章操作</figcaption></figure><p id="9b60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单而强大。消费者现在不必猜测什么动作或突变或getters是可用的，以及它们的签名是什么。我们将在下一篇文章中充分利用存储。现在，让我们结束商店。</p><p id="9e33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还必须提供一个动作，“createComment”，它调用服务，然后提交突变:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">创建评论操作</figcaption></figure><p id="8ed3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们测试一下动作。此时，只需确保使用正确的数据调用服务和存储即可:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">动作规格</figcaption></figure><p id="4fd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后(终于！)，我们可以构造商店本身:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">商店</figcaption></figure><p id="f845" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，代码应该没有任何错误地编译，并且测试应该以100%的覆盖率通过:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nx"><img src="../Images/f7a4b26ebc0971652f81827846ee7e2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8DXKB0aIWRixN0d7_2vzQQ.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">所有代码都符合，并且测试通过</figcaption></figure><h1 id="feff" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="fd22" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">这的确是一次漫长的旅行。让我们花一点时间来奖励我们自己已经完成的伟大工作。</p><p id="d060" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们从开发Getters开始:商店的访问点。然后我们实现了负责Vuex基本部分的突变:改变状态。然后，我们走了一个快速的弯路来构建Storage:Store的灵活而强大的API。然后，我们在动作中使用存储，并通过将Getters、Mutations和action组合在一个屋檐下来分解存储本身。</p><p id="417c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的下一步是UI组件。我们将看到存储如何简化对商店的访问，以及所有这些如何最终整合成我们可以在屏幕上看到的东西。</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="3e17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是“构建Vue企业应用”系列文章的第三章。其他剧集请点击此处:</p><ul class=""><li id="10e3" class="lv lw iq jp b jq jr ju jv jy mp kc mq kg mr kk mc md me mf bi translated">第0部分。序曲</li><li id="3c47" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><a class="ae mo" href="https://medium.com/@gregsolo/building-vue-enterprise-application-part-1-entities-808077f3d2e7" rel="noopener">第一部分。实体</a></li><li id="f766" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><a class="ae mo" href="https://medium.com/@gregsolo/building-vue-enterprise-application-part-2-services-f7ec400190e7" rel="noopener">第二部分。服务</a></li><li id="495f" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">第三部分。Vuex </li><li id="e778" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><a class="ae mo" href="https://medium.com/@gregsolo/building-vue-enterprise-application-part-4-ui-components-21a45b3067a4" rel="noopener">第四部分。UI:页面和组件</a></li></ul></div></div>    
</body>
</html>