<html>
<head>
<title>How to prevent Cross-Site Request Forgery of Legitime Cross-Site Request</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何防止跨站请求伪造合法的跨站请求</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-prevent-cross-site-request-forgery-of-legitime-cross-site-request-5b59a6a56808?source=collection_archive---------1-----------------------#2020-11-24">https://itnext.io/how-to-prevent-cross-site-request-forgery-of-legitime-cross-site-request-5b59a6a56808?source=collection_archive---------1-----------------------#2020-11-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="957b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你在你的角度应用中打开CSRF保护了吗？你注意到这对于合法的跨站点请求不起作用吗？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/ce381c6506e29e400a9e82520db629c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KJ8ySDEIuLDbk5Um"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">东圭佑在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="d822" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想象一下，有一天你醒来，发现有人窃取了你的互联网域名。这正是几年前设计师大卫·艾雷的情况。一名攻击者利用了<a class="ae lb" href="https://www.davidairey.com/google-gmail-security-hijack" rel="noopener ugc nofollow" target="_blank"> Gmail的CSRF漏洞</a>，控制了大卫·艾雷的邮箱，并以他的名义联系了域名注册商。</p><p id="be57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在过去的几年里，CSRF已经意识到了这一点，所以现在的现代框架都有内置的保护机制。</p><p id="3b61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个常见的情况是，网站从同一个域(即源)提供服务，就像站点发出请求的目标域一样。但是，情况并非总是如此，这种情况对CSRF来说尤其脆弱。</p><p id="c52d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我探讨了有哪些选项可以减轻同站点和单页面应用程序的合法跨站点请求的CSRF漏洞。这篇博客中的代码示例是针对在服务器端使用Spring用Angular编写的单页面应用程序的，但是这些原则也适用于其他框架。</p><h2 id="65c2" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">什么是CSRF？</h2><p id="cc3d" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">互联网上有大量解释CSRF袭击的精彩文章。让我在这里引用一下，根据<a class="ae lb" href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#double-submit-cookie" rel="noopener ugc nofollow" target="_blank"> OWASP </a>的定义是什么:</p><blockquote class="ma mb mc"><p id="2dcd" class="jn jo md jp b jq jr js jt ju jv jw jx me jz ka kb mf kd ke kf mg kh ki kj kk ij bi translated">跨站点请求伪造是一种攻击，当恶意网站、电子邮件、博客、即时消息或程序在用户通过身份验证后导致用户的web浏览器在受信任的站点上执行不需要的操作时，就会发生这种攻击。CSRF攻击之所以有效，是因为浏览器请求自动包含所有cookie，包括会话cookie。因此，如果用户通过了站点的身份验证，站点就无法区分合法请求和伪造请求。"</p></blockquote></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="3009" class="mo ld iq bd le mp mq mr lh ms mt mu lk mv mw mx ln my mz na lq nb nc nd lt ne bi translated">相同站点场景和双重提交Cookie</h1><p id="d74f" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">根据带有双重提交cookie保护模式的OWASP备忘单:“我们在cookie和请求参数中发送一个随机值，服务器验证Cookie值和请求值是否匹配。”</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/e36b69c4929b874d389d1812bc73d173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3q_Ifoasg27ik6C5"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">双重提交Cookie方案</figcaption></figure><h2 id="dbcc" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">Angular的内置保护</h2><p id="cd28" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在自定义请求头中发送CSRF cookie值是Angular内置保护的一部分，默认情况下<strong class="jp ir">关闭<strong class="jp ir"/>。我们需要导入<code class="fe ng nh ni nj b">HttpClientXsrfModule </code>来打开保护。</strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="d9a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这指示站点查找名为<code class="fe ng nh ni nj b">XSRF-TOKEN</code>的cookie，提取cookie值，并将其设置为每个状态修改<code class="fe ng nh ni nj b">XHR </code>请求的自定义<code class="fe ng nh ni nj b">X-XSRF-TOKEN</code>请求头。</p><p id="22c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，<code class="fe ng nh ni nj b">XSRF-TOKEN</code> cookie必须被设置为<code class="fe ng nh ni nj b">HttpOnly:false</code>，这样javascript代码才能读取它的值。也可以定制一个cookie名称和请求头，如Angular文档<a class="ae lb" href="https://angular.io/guide/http#security-xsrf-protection" rel="noopener ugc nofollow" target="_blank">中所述。</a></p><h2 id="ecfc" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">服务器生成的CSRF令牌</h2><p id="a7bf" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在客户端可以在每个状态改变请求中附加cookie之前，需要设置cookie。这对于Spring Security来说很简单。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="475c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe ng nh ni nj b">csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()</code>,我们可以确保对于每个到达服务器的请求，服务器都会评估<code class="fe ng nh ni nj b">X-XSRF-TOKEN</code>请求头是否存在，并将其与自定义请求头中存在的<code class="fe ng nh ni nj b">XSRF-TOKEN</code> cookie的值进行比较。如果没有cookie，或者cookie不匹配，服务器用HTTP状态代码403响应，并在响应<code class="fe ng nh ni nj b">Set-Cookie </code>响应头中添加新生成的<code class="fe ng nh ni nj b">XSRF-TOKEN</code>。</p><h2 id="c17f" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">为什么这为CSRF提供了保护</h2><ol class=""><li id="8da1" class="nm nn iq jp b jq lv ju lw jy no kc np kg nq kk nr ns nt nu bi translated">从javascript不可能读取或修改cookiess，这些cookie是为作为站点来源的不同域设置的。因此，如果攻击者诱骗用户访问evil.com，evil.com上的javascript无法读取也无法覆盖为example.com域设置的<code class="fe ng nh ni nj b">XSRF-TOKEN</code> cookie的值</li><li id="51bb" class="nm nn iq jp b jq nv ju nw jy nx kc ny kg nz kk nr ns nt nu bi translated">根据javascript，不可能根据浏览器的同源策略设置自定义请求头(例如<code class="fe ng nh ni nj b">X-XSRF-TOKEN</code>)，除非服务器允许来自该域的跨源请求，并允许这种特定的自定义头。</li><li id="18d3" class="nm nn iq jp b jq nv ju nw jy nx kc ny kg nz kk nr ns nt nu bi translated">如果cookie是在服务器端用<code class="fe ng nh ni nj b">SameSite</code>属性设置的，它将提供额外的保护级别，因为该属性告诉浏览器不要在跨站点请求中附加cookie。这是Spring Security的类<code class="fe ng nh ni nj b">CookieCsrfTokenRepository</code>的一个限制，到今天为止，它还不能将CSRF cookie设置为<code class="fe ng nh ni nj b">SameSite:Strict</code>或<code class="fe ng nh ni nj b">Lax</code>。</li></ol><p id="5756" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个致命弱点是攻击者控制了子域，因为evil.example.com有可能为example.com设置了一个cookie。OWASP备忘单建议通过设置HMAC签名的CSRF cookie在服务器端引入另一层保护，这样即使在子域上运行的恶意代码覆盖了cookie，服务器也会注意到cookie被篡改了。</p><p id="b4c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个弱点是，即使带有安全标志的cookies也可能被http站点覆盖。这两个弱点在这里都有详细的<a class="ae lb" href="https://owasp.org/www-chapter-london/assets/slides/David_Johansson-Double_Defeat_of_Double-Submit_Cookie.pdf" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="df9c" class="mo ld iq bd le mp mq mr lh ms mt mu lk mv mw mx ln my mz na lq nb nc nd lt ne bi translated">跨站点场景和双重提交Cookie</h1><p id="465b" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">以前的方法不适用于跨源请求，在跨源请求中，站点合法地从另一个域而不是站点源请求资源。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/56c064315f8b4846d2cda9f79e6ed651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-bN-Q__ukaKIlXPY"/></div></div></figure><p id="486d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是因为javascript无法读取为不同域设置的cookie的值。因此，不可能使用Angular的内置功能。</p><h2 id="17cc" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">生成并分发CSRF令牌</h2><p id="8c26" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">解决这个问题的一种方法是公开一个专用的令牌API方法，该方法生成一个令牌，将它包含在自定义响应头或响应体中，同时通过<code class="fe ng nh ni nj b">Set-Cookie</code>响应头将其设置为cookie。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="20cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个新的/token方法的实现中:</p><ul class=""><li id="cc28" class="nm nn iq jp b jq jr ju jv jy oa kc ob kg oc kk od ns nt nu bi translated">我们不再需要javascript可读的cookie，因此我们将cookie设置为<code class="fe ng nh ni nj b">HttpOnly</code></li><li id="cd69" class="nm nn iq jp b jq nv ju nw jy nx kc ny kg nz kk od ns nt nu bi translated"><code class="fe ng nh ni nj b">SameSite </code>被设置为<code class="fe ng nh ni nj b">None </code> —这与<a class="ae lb" href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#samesite-cookie-attribute" rel="noopener ugc nofollow" target="_blank"> OWASP CSRF预防备忘单建议</a>使用<code class="fe ng nh ni nj b">SameSite</code>T5或<code class="fe ng nh ni nj b">Strict</code>相矛盾。然而，如果在这种情况下，我们真的需要针对不同的领域，所以我们必须设置<code class="fe ng nh ni nj b">None</code>。如果我们不显式设置，Chrome默认为<code class="fe ng nh ni nj b">Lax</code>(正如我之前的<a class="ae lb" href="https://medium.com/swlh/7-keys-to-the-mystery-of-a-missing-cookie-fdf22b012f09" rel="noopener">博文</a>中所讨论的)。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/7651a5c4011561aef99703e620d3cadf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z0CGbFXYG2E7_3gU"/></div></div></figure><h2 id="0dd5" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">获取CSRF令牌并将其附加到状态更改请求</h2><ol class=""><li id="b502" class="nm nn iq jp b jq lv ju lw jy no kc np kg nq kk nr ns nt nu bi translated">在下面的示例中，主组件/令牌方法在<code class="fe ng nh ni nj b">ngOnInit</code>中被调用，来自响应主体的令牌被设置为变量csrfToken。注意，由于请求是跨源请求，它必须是<code class="fe ng nh ni nj b">withCredentials:true</code>，否则服务器响应<code class="fe ng nh ni nj b">Set-Cookie</code>将被浏览器忽略。</li></ol><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="27cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.实现一个拦截器，它在定制请求头<code class="fe ng nh ni nj b">X-XSRF-TOKEN-B</code>中向每个(状态改变)请求附加令牌值</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="8207" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">过滤请求</h2><p id="95f5" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">此外，还需要在服务器上实现一个定制的过滤机制，将从请求头中提取的值与cookie中的值进行比较。CSRF滤波器的参考实现可以在<a class="ae lb" href="https://github.com/righettod/poc-csrf/blob/master/src/main/java/eu/righettod/poccsrf/filter/CSRFValidationFilter.java" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="1350" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">为什么这为CSRF提供了保护</h2><ol class=""><li id="2632" class="nm nn iq jp b jq lv ju lw jy no kc np kg nq kk nr ns nt nu bi translated">除非服务器在<code class="fe ng nh ni nj b">Access-Control-Allow-Origin </code>响应头中回复带有站点来源的预检请求，否则站点不可能向加载站点之外的来源发出XHR请求。</li><li id="1b31" class="nm nn iq jp b jq nv ju nw jy nx kc ny kg nz kk nr ns nt nu bi translated">网站不可能在XHR请求中附加任意自定义标题，除非服务器在允许的标题列表中用自定义标题回复预检请求</li></ol><blockquote class="ma mb mc"><p id="9ffd" class="jn jo md jp b jq jr js jt ju jv jw jx me jz ka kb mf kd ke kf mg kh ki kj kk ij bi translated">在这个场景中，服务器端的令牌分发和过滤本身<strong class="jp ir">并不能保护</strong>免受CSRF攻击，因为当访问恶意站点时，GET request to /token方法可能是伪造的。如果CSRF令牌被期望作为隐藏的表单值POST发送到服务器，这将不会提供任何保护。CSRF令牌作为自定义请求标头发送是非常重要的。</p></blockquote><h2 id="36cc" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">模拟攻击</h2><p id="580a" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">下面是一个恶意HTML的例子，在加载时，XHR获取获取令牌的请求，然后将这个令牌附加在隐藏的表单参数中。如果我们运行这个目标后端服务，它表明，由于CORS政策，自定义标头中带有CSRF令牌值的POST请求将被浏览器阻止，除非该自定义标头和该域被特别允许。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="32a3" class="mo ld iq bd le mp oe mr lh ms of mu lk mv og mx ln my oh na lq nb oi nd lt ne bi translated">摘要</h1><p id="c89f" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">为合法的跨站点请求实现足够的跨站点伪造保护是具有挑战性的。</p><p id="87fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至少可以做的是:</p><ul class=""><li id="f687" class="nm nn iq jp b jq jr ju jv jy oa kc ob kg oc kk od ns nt nu bi translated">使用<strong class="jp ir">定制请求头</strong>实现双重提交cookie模式</li><li id="dbb2" class="nm nn iq jp b jq nv ju nw jy nx kc ny kg nz kk od ns nt nu bi translated">依靠浏览器的同源策略，该策略不允许XHR请求指向任意来源。在服务器端设置特定(<strong class="jp ir">而非通配符</strong>)允许的来源和自定义头</li><li id="03ca" class="nm nn iq jp b jq nv ju nw jy nx kc ny kg nz kk od ns nt nu bi translated">防范跨站点脚本(XSS)。XSS的攻击可以打破任何CSRF的保护</li></ul></div></div>    
</body>
</html>