<html>
<head>
<title>Security Measures inside Kubernetes cluster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes集群内部的安全措施</h1>
<blockquote>原文：<a href="https://itnext.io/security-measures-inside-kubernetes-cluster-e43b3a328473?source=collection_archive---------0-----------------------#2020-03-30">https://itnext.io/security-measures-inside-kubernetes-cluster-e43b3a328473?source=collection_archive---------0-----------------------#2020-03-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e3f56344935d8c877aa13ba70d853c17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cHesgVkrJ6oWoaxHaC46fg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">杰森·登特在<a class="ae kc" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="2e61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于Kubernetes已经迅速成为在云中部署代码的最受欢迎的选择之一，我决定写一篇文章来给你一些关于安全措施的见解。此外，在Kubernetes的生产集群中，您应该考虑那些隐藏的东西。</p><p id="e937" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我假设这篇文章的读者熟悉Kubernetes结构的基本知识。本文主要是为Kubernetes开发人员或DevOps工程师编写的，他们希望在产品上部署他们的服务，并且正在寻找一些安全技巧来确保他们的服务在部署后仍然安全。</p><p id="474f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">应该考虑一些关于集群本身的安全措施，尤其是作为一名集群管理员，当您想从头开始创建一个集群时。甚至在托管的Kubernetes服务上，如GKE、EKS、AKS等。你需要小心谨慎。虽然在大多数情况下，托管Kubernetes服务可以帮助您保护您的堆栈，如集群网络和对集群API服务器的访问。</p><blockquote class="lb lc ld"><p id="ca9e" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">如果你认为技术可以解决你的安全问题，那么你不了解问题，也不了解技术。</p><p id="45cc" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">布鲁斯·施奈尔，应用密码学</p></blockquote><p id="3456" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">集装箱安全</strong></p><p id="bad8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">经常犯的一个大错误是认为容器是完全隔离的。</p><p id="afd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对Roo说不:用root运行的一些例外情况可能是:</p><ul class=""><li id="07a2" class="li lj iq kf b kg kh kk kl ko lk ks ll kw lm la ln lo lp lq bi translated">您的容器需要编辑主机系统，例如修改内核的配置。</li><li id="17a8" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">容器需要绑定到节点上的特权端口，例如端口80上的nginx服务，尽管这可以通过Kubernetes中服务抽象中的端口映射来避免。</li><li id="a43c" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">在运行时将软件安装到容器中。在某些情况下，传统的包管理系统可能要求root在某个位置运行或存储文件，尽管这种方法是不好的做法，因为在运行时安装的任何代码都没有进行漏洞或其他策略要求的扫描。</li></ul><p id="990e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">扫描docker映像:</strong>为了扫描Docker映像中的漏洞，您需要利用容器映像扫描器来检查映像中包含的包。图像扫描仪让您知道是否有任何已知的漏洞，包括在这些软件包或没有。<br/>像docker Trusted Registry、Google Container Registry甚至Red Hat Container Catalog这样的知名Docker注册表已经有了图像扫描结果。因此，如果你想使用这些资源中的任何docker图像，你可以在那里检查扫描结果。</p><p id="169c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">容器实用程序:</strong>确保你的docker文件中有尽可能少的实用程序，这将使运行中的容器对试图破坏它的攻击者来说用处不大。例如，假设我们在一个容器的文件中有一些可读的凭证，如果容器不包括像<strong class="kf ir"><em class="le"/></strong>或<strong class="kf ir"> <em class="le"> more </em> </strong>或甚至<strong class="kf ir"> <em class="le"> shell </em> </strong>(像<strong class="kf ir"> <em class="le"> sh </em> </strong>或<strong class="kf ir"> <em class="le"> bash </em> </strong>)这样，读取凭证就会困难得多。有时删除这些实用程序会使故障诊断更加困难，但这可能是一种权衡，看您是否需要这些程序。</p><p id="4f2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">图像版本:</strong>通过使用语义版本标签来引用pod中的图像，或者即使可以通过其唯一的摘要而不是标签来引用它，这总是有助于您知道容器图像的哪个特定版本正在部署。如果我们忽略图像标记或摘要，图像版本将被标记为<strong class="kf ir">最新</strong>，强烈建议在生产中避免使用<strong class="kf ir">最新</strong>版本。因为当您想要回滚到前一个版本时，很难准确地跟踪正在运行的代码以及要使用的版本。</p><p id="96ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">吊舱安全</strong></p><p id="3669" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Kubernetes提供了两种pod级安全策略机制，第一种是允许我们限制一个pod内的进程可以做什么(安全上下文)，第二种是pod如何相互通信(网络策略)。</p><p id="e0d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">安全上下文:</strong>我们可以在安全上下文中定义pod或容器级别的权限和访问控制设置。例如，假设您希望通过<strong class="kf ir"> <em class="le"> runAsUser </em> </strong>设置让pod中的所有容器在<strong class="kf ir"> <em class="le"> 1001 </em> </strong> user下运行，或者通过将<strong class="kf ir"><em class="le">allowprivilagessescalation</em></strong>设置为false来阻止<strong class="kf ir"> <em class="le"> setuid </em> </strong>二进制文件更改用户id。下面的示例说明了如何在pod中定义安全上下文:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="0506" class="mf mg iq mb b gy mh mi l mj mk">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: security-context-demo<br/>spec:<br/>  securityContext:<br/>    runAsUser: 1001<br/>  volumes:<br/>  - name: sec-ctx-vol<br/>    emptyDir: {}<br/>  containers:<br/>  - name: sec-ctx-demo<br/>    image: busybox<br/>    command: [ "sh", "-c", "sleep 1h" ]<br/>    volumeMounts:<br/>    - name: sec-ctx-vol<br/>      mountPath: /data/demo<br/>    securityContext:<br/>      allowPrivilegeEscalation: <strong class="mb ir">false<br/></strong>      runAsUser: 1001</span></pre><p id="e5de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">网络策略:</strong>默认情况下，允许所有类型的传入和传出流量，但您可以通过网络策略控制允许pod如何相互通信。</p><p id="ed18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">网络策略为您的集群增加了一个安全层，假设外部攻击者能够通过任何安全漏洞到达集群网络，网络策略可以阻止该攻击者向pod内部运行的应用程序代码发送流量。</p><p id="44de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，如果某个容器不知何故遭到破坏，攻击者通常会尝试探索网络以转移到其他容器，这通过限制地址、端口和容器可能要困难得多。看一下这个示例，了解如何在pod之间定义网络策略:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="988e" class="mf mg iq mb b gy mh mi l mj mk">apiVersion: networking.k8s.io/v1<br/>kind: NetworkPolicy<br/>metadata:<br/>  name: test-network-policy<br/>  namespace: default<br/>spec:<br/>  podSelector:<br/>    matchLabels:<br/>      role: db<br/>  policyTypes:<br/>  - Ingress<br/>  - Egress<br/>  ingress:<br/>  - from:<br/>    - ipBlock:<br/>        cidr: 172.17.0.0/16<br/>        except:<br/>        - 172.17.1.0/24<br/>    - namespaceSelector:<br/>        matchLabels:<br/>          project: myproject<br/>    - podSelector:<br/>        matchLabels:<br/>          role: frontend<br/>    ports:<br/>    - protocol: TCP<br/>      port: 6379<br/>  egress:<br/>  - to:<br/>    - ipBlock:<br/>        cidr: 10.0.0.0/24<br/>    ports:<br/>    - protocol: TCP<br/>      port: 5978</span></pre><p id="0878" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">机密管理</strong></p><p id="0168" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">建议十二因素应用程序将配置信息作为环境变量传递。这允许我们将配置从代码中分离出来，这在我们需要在不同的环境中运行代码时非常有用，比如dev、test、acc和prod。</p><p id="9728" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Kubernetes为此提供了秘密资源，但有不同的使用方式。默认情况下，机密值与其他配置信息一起存储在etcd数据库中，尽管base64编码使内容不可读，但当您可以使用base64解码对其进行解码时，它不会对其进行加密。不知何故，我可以说base64对攻击者来说是纯文本。<br/>看这个例子，用户名和密码是加密的，你可以很容易地解密<em class="le"> : </em></p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="c1f5" class="mf mg iq mb b gy mh mi l mj mk">apiVersion: v1<br/>data:<br/>  username: YWRtaW4=<br/>  password: MWYyZDFlMmU2N2Rm<br/>kind: Secret<br/>metadata:<br/>  annotations:<br/>    kubectl.kubernetes.io/last-applied-configuration: { ... }<br/>  name: mysecret<br/>type: Opaque</span></pre><p id="f818" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您可能猜到的那样，在etcd中存储加密值不够安全。一些第三方系统专门用于存储机密和敏感值，如HashiCorp Vault。<br/>这些第三方通常提供与多个后端机密存储的集成，并且还可以控制对特定机密的访问，即只有特定的容器可以访问特定的机密。</p><blockquote class="lb lc ld"><p id="a1f5" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">如果你想保守秘密，你应该对自己隐瞒</p><p id="9a44" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">乔治·奥威尔，1984</p></blockquote><p id="6cda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">存储秘密变量的另一种常见方式是将它们存储在文件中，Kubernetes支持通过卷挂载将秘密传递到pods中。容器化的代码需要从这些文件中读取值。如果装入的卷是一个临时文件系统，这意味着文件没有写入磁盘，而是保存在内存中，并且文件中的值不能通过docker inspect或kubectl describe访问。通过这个例子，您可以了解如何将秘密存储到文件中:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="1aa6" class="mf mg iq mb b gy mh mi l mj mk">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: mypod<br/>spec:<br/>  containers:<br/>  - name: mypod<br/>    image: redis<br/>    volumeMounts:<br/>    - name: foo<br/>      mountPath: "/etc/foo"<br/>      readOnly: <strong class="mb ir">true</strong><br/>  volumes:<br/>  - name: foo<br/>    secret:<br/>      secretName: mysecret<br/>      items:<br/>      - key: username<br/>        path: my-group/my-username</span></pre><p id="9931" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">总结</strong></p><p id="9c32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Kubernetes的安全性很复杂。不可能在一篇文章中涵盖所有主题。在这篇文章中，我打算介绍开发人员常用的安全措施，请记住在集群上部署时要遵循和阅读良好的实践。从我的建议开始吧。</p><p id="2da7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我强烈推荐阅读Liz Rice和Michael Hausenblas撰写的Kubernetes Security，其中涵盖了所有这些主题，并且提供了更详细的信息。</p></div></div>    
</body>
</html>