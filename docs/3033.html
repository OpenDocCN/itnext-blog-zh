<html>
<head>
<title>Introduction to Web Components — Part II Shadow Dom</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web组件介绍—第二部分阴影Dom</h1>
<blockquote>原文：<a href="https://itnext.io/introduction-to-web-components-part-ii-shadow-dom-8d1d8e126332?source=collection_archive---------3-----------------------#2019-09-18">https://itnext.io/introduction-to-web-components-part-ii-shadow-dom-8d1d8e126332?source=collection_archive---------3-----------------------#2019-09-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="296c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/introduction-to-web-components-part-i-custom-elements-4de6713cef9d">Web组件概述的第一部分</a>是关于自定义元素标准的。</p><h1 id="6958" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">阴影DOM</h1><p id="87a6" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">规范给Web样式的定义带来了范围的概念。这些范围通过嵌入到单个文档中的多个<code class="fe ls lt lu lv b">DOM</code>树来实现。在某种程度上，<code class="fe ls lt lu lv b">Shadow DOM</code>的方法可以与文档中的<code class="fe ls lt lu lv b">iframe</code>元素相比较，因为它有一个自然隔离的<code class="fe ls lt lu lv b">DOM</code>结构。在文档方面，<code class="fe ls lt lu lv b">Shadow DOM</code>的定义分布在几个不同的标准之间，如<code class="fe ls lt lu lv b">DOM specification</code>、<code class="fe ls lt lu lv b">HTML specification</code>、<code class="fe ls lt lu lv b">CSS Scoping Module</code>、<code class="fe ls lt lu lv b">UI Events</code>等。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/fd2b00561dc97c81fc674f5bc48d41ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*geSNRrK8K9qcpuiDISH80g.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">Web组件</figcaption></figure><p id="a084" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ls lt lu lv b">DOM specification</code>定义了节点树的模型以及节点如何通过事件相互通信。<code class="fe ls lt lu lv b">DOM</code>节点树是节点的层次结构，其中一些节点可以分支，而其他节点只是叶子。该规范通过与根的连接来区分<code class="fe ls lt lu lv b">Document Tree</code>和<code class="fe ls lt lu lv b">Shadow Tree</code>。<code class="fe ls lt lu lv b">document</code>对象是<code class="fe ls lt lu lv b">Document Tree</code>的根，而对于<code class="fe ls lt lu lv b">Shadow Tree</code>，提出了一种特殊类型的根，称为<code class="fe ls lt lu lv b">Shadow Root</code>。<code class="fe ls lt lu lv b">Shadow Root</code>必须连接到<code class="fe ls lt lu lv b">host</code>元素下的任何其他树。可以认为<code class="fe ls lt lu lv b">Shadow Root</code>是一个<code class="fe ls lt lu lv b">Document Fragment</code>——规范定义了两个接口之间的归属关系。</p><pre class="lx ly lz ma gt mi lv mj mk aw ml bi"><span id="ac88" class="mm kq it lv b gy mn mo l mp mq">&lt;script&gt;<br/> class CustomElement extends HTMLElement {<br/>   constructor() {<br/>     super()<br/>     this.attachShadow({ mode: 'open' })<br/>   }<br/>   connectedCallback() {<br/>     this.shadowRoot.innerHTML = '&lt;a href="#"&gt;My link&lt;/a&gt;'<br/>   }<br/> }<br/> customElements.define('hello-shadow-dom', CustomElement)<br/>&lt;/script&gt;<br/>&lt;hello-shadow-dom&gt;&lt;/hello-shadow-dom&gt;</span></pre><p id="ce4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建<code class="fe ls lt lu lv b">Shadow DOM</code>的唯一方法是调用<code class="fe ls lt lu lv b">Element</code>类的<code class="fe ls lt lu lv b">attachShadow()</code>方法。它为元素创建一个影子根。只能为该元素附加一个影像根。在<code class="fe ls lt lu lv b">attachShadow() </code>调用中指定的<code class="fe ls lt lu lv b">mode</code>属性定义了是否可以从<code class="fe ls lt lu lv b">JavaScript</code>访问一棵树。“打开”值的替代值是“关闭”值。附加的<code class="fe ls lt lu lv b">shadowRoot</code>属性是指定节点树的父节点。在下面的例子中，<code class="fe ls lt lu lv b">shadowRoot.host</code>被设置为<code class="fe ls lt lu lv b">hello-shadow-dom</code>元素。</p><pre class="lx ly lz ma gt mi lv mj mk aw ml bi"><span id="54e4" class="mm kq it lv b gy mn mo l mp mq">&lt;hello-shadow-dom&gt;&lt;/hello-shadow-dom&gt;<br/> #shadow-root (open)<br/>   &lt;a href="#"&gt;My link&lt;/a&gt;</span></pre><p id="354b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ls lt lu lv b">Slot</code>功能在<code class="fe ls lt lu lv b">UI Libraries</code>中广泛使用。在<code class="fe ls lt lu lv b">Angular,</code>中，它被称为投影或转换，并通过<code class="fe ls lt lu lv b">ng-content</code>指令来支持。<code class="fe ls lt lu lv b">Vue</code>似乎更符合标准——它调用与<code class="fe ls lt lu lv b">slot</code>相同的功能。最后，在<code class="fe ls lt lu lv b">React</code>中，这种能力与库更加密切相关，可以通过在元素容器中使用<code class="fe ls lt lu lv b">{props.children}</code>来实现。<code class="fe ls lt lu lv b">Slot</code>特征用作占位符。一方面，<code class="fe ls lt lu lv b">Shadow Tree</code>可能包含用<code class="fe ls lt lu lv b">slot</code>标签定义的<code class="fe ls lt lu lv b">slots</code>元素。另一方面，当开发人员想要使用元素时，他或她可以为声明的<code class="fe ls lt lu lv b">slots</code>指定一个标记，这样内容将在<code class="fe ls lt lu lv b">Shadow Tree</code>包装器中呈现。</p><pre class="lx ly lz ma gt mi lv mj mk aw ml bi"><span id="583f" class="mm kq it lv b gy mn mo l mp mq">&lt;script&gt;<br/> class OhMySlotElement extends HTMLElement {<br/>   constructor() {<br/>     super()<br/>     this.attachShadow({ mode: 'open' })<br/>   }<br/>   connectedCallback() {<br/>     this.shadowRoot.innerHTML = `&lt;p&gt;<br/>       &lt;slot name="my-text"&gt;default&lt;/slot&gt;<br/>     &lt;/p&gt;`<br/>   }<br/> }<br/> customElements.define('oh-my-slot', OhMySlotElement);<br/>&lt;/script&gt;<br/>&lt;oh-my-slot&gt;<br/> &lt;pre slot="my-text"&gt;<br/>   anything<br/> &lt;/pre&gt;<br/>&lt;/oh-my-slot&gt;</span></pre><p id="e5d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后的<code class="fe ls lt lu lv b">DOM</code>树包含一个带有<code class="fe ls lt lu lv b">p</code>子元素的<code class="fe ls lt lu lv b">Shadow Root</code>和开发者的<code class="fe ls lt lu lv b">pre</code>元素。后者链接到<code class="fe ls lt lu lv b">slot</code>节点并替换它的“默认”内容。标签上的name属性定义了使用哪个占位符。如果没有可用的替代项，也可以使用未命名的插槽。</p><p id="f582" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">规范允许开发者声明独立的样式，并提供一个API来使用主文档上下文。外部文档<code class="fe ls lt lu lv b">CSS</code>选择器无法访问<code class="fe ls lt lu lv b">Shadow Tree</code>内部的元素。</p><p id="bfc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下面的例子中，有两个样式的部分——一个在主文档中，另一个在元素的附件<code class="fe ls lt lu lv b">Shadow DOM</code>中。</p><pre class="lx ly lz ma gt mi lv mj mk aw ml bi"><span id="25fe" class="mm kq it lv b gy mn mo l mp mq">&lt;style&gt;h3 { color: blue; }&lt;/style&gt;<br/>&lt;script&gt;<br/> class CustomElement extends HTMLElement {<br/>   constructor() {<br/>     super()<br/>     this.attachShadow({ mode: 'open' })<br/>   }<br/>   connectedCallback() {<br/>     this.shadowRoot.innerHTML = `<br/>       &lt;style&gt;h3 { color: red; }&lt;/style&gt;<br/>       &lt;h3&gt;Shadow DOM&lt;/h3&gt;<br/>     `<br/>   }<br/> }<br/> customElements.define('my-element', CustomElement);<br/>&lt;/script&gt;</span><span id="11d0" class="mm kq it lv b gy mr mo l mp mq">&lt;h3&gt;Normal DOM&lt;/h3&gt;<br/>&lt;my-element&gt;&lt;/my-element&gt;</span></pre><p id="6f1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">应用于主文档的<code class="fe ls lt lu lv b">h3</code>元素的样式为蓝色，而<code class="fe ls lt lu lv b">my-element</code>内的<code class="fe ls lt lu lv b">h3</code>被涂成红色。值得注意的是，主文档可以为<code class="fe ls lt lu lv b">host</code>元素本身定义样式。当<code class="fe ls lt lu lv b">my-element</code>样式被设置为绿色时，它将被应用到它的子元素上，就像普通的样式继承一样。继承的颜色仍然比任何其他定义的样式优先级低。</p><p id="969f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ls lt lu lv b">:host</code>伪类选择器正在查看<code class="fe ls lt lu lv b">Shadow Root</code>的<code class="fe ls lt lu lv b">host</code>元素。</p><pre class="lx ly lz ma gt mi lv mj mk aw ml bi"><span id="d372" class="mm kq it lv b gy mn mo l mp mq">:host { color: green; }</span></pre><p id="d601" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与元素内部的<code class="fe ls lt lu lv b">:host</code>样式相比，主文档中的样式具有更高的优先级。条件选择器可以使用<code class="fe ls lt lu lv b">:host()</code>功能</p><pre class="lx ly lz ma gt mi lv mj mk aw ml bi"><span id="76b7" class="mm kq it lv b gy mn mo l mp mq">:host(.error) { color: red; }</span></pre><p id="77cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当<code class="fe ls lt lu lv b">host</code>附加了<code class="fe ls lt lu lv b">error</code>类时，红色将应用于它。</p><p id="7965" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个功能选择器是<code class="fe ls lt lu lv b">:host-context()</code>，它可以检测在<code class="fe ls lt lu lv b">Shadow Tree</code>之外是否有祖先匹配指定的选择器。</p><p id="c300" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类似地，<code class="fe ls lt lu lv b">::slotted()</code>函数可以应用于<code class="fe ls lt lu lv b">slots</code>内部的“外部”元素。</p><p id="ac41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">仍然可以在主文档中自定义样式。这就是应用于<code class="fe ls lt lu lv b">Shadow DOM</code>的<code class="fe ls lt lu lv b">CSS custom properties</code>或变量特性。它基于几个原则:</p><ul class=""><li id="6817" class="ms mt it js b jt ju jx jy kb mu kf mv kj mw kn mx my mz na bi translated">属性在<code class="fe ls lt lu lv b">Shadow DOM</code>中定义和使用。所以组件的作者负责提供一个API(或者一个可以从外部覆盖的属性列表)。</li><li id="134d" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated">变量应用于主文档中的<code class="fe ls lt lu lv b">host</code>元素。正如规范所说，自定义属性确实继承了。这意味着如果一个元素没有在子元素的级别中定义，它将采用父元素的值。</li></ul><p id="f98d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当自定义元素使用<code class="fe ls lt lu lv b">Shadow DOM</code>时，其样式定义为:</p><pre class="lx ly lz ma gt mi lv mj mk aw ml bi"><span id="91d3" class="mm kq it lv b gy mn mo l mp mq">h3 { color: var(--my-color); }</span></pre><p id="1a14" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它将尝试访问<code class="fe ls lt lu lv b">--my-color</code>变量。因此，使用该元素的开发人员可以在他或她的样式定义中附加一个变量。</p><pre class="lx ly lz ma gt mi lv mj mk aw ml bi"><span id="8724" class="mm kq it lv b gy mn mo l mp mq">custom-element { --my-color: red; }</span></pre><p id="05f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，<code class="fe ls lt lu lv b">--my-color</code>变量没有在任何样式定义的<code class="fe ls lt lu lv b">h3</code>选择器中定义，它是从<code class="fe ls lt lu lv b">Shadow Root</code>的<code class="fe ls lt lu lv b">host</code>中继承的，并被应用于内部元素的<code class="fe ls lt lu lv b">DOM</code>。<code class="fe ls lt lu lv b">h3</code>颜色的值是红色。</p><p id="5efb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对那些公共定义的变量使用回退或默认值是合理的。如果客户没有指定变量，它仍然有一个合理的值。</p><p id="dc6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总而言之，<code class="fe ls lt lu lv b">Shadow DOM</code>提供的功能有:</p><ul class=""><li id="fe82" class="ms mt it js b jt ju jx jy kb mu kf mv kj mw kn mx my mz na bi translated">孤立的<code class="fe ls lt lu lv b">DOM</code>，从文档中分离出来。</li><li id="9bba" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated">对树进行私有或公共访问的元素的组合。</li><li id="9c3d" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><code class="fe ls lt lu lv b">slots</code>以重复使用为目的。</li><li id="5883" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><code class="fe ls lt lu lv b">CSS</code>是有作用域的，所以页面的样式不会与<code class="fe ls lt lu lv b">Shadow Tree</code>中声明的样式混合在一起。这种方法简化了样式的定义，减少了对层次选择器的需求。</li></ul><h1 id="3d37" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">HTML模板</h1><p id="726e" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated"><code class="fe ls lt lu lv b">HTML Template</code>规格通常与<code class="fe ls lt lu lv b">Shadow DOM</code>和<code class="fe ls lt lu lv b">Custom Elements</code>组合使用。它解释了一种在不影响文档本身的情况下指定布局的方法。<code class="fe ls lt lu lv b">template</code>标签中的任何内容都不会在页面加载时呈现，稍后可以被<code class="fe ls lt lu lv b">JavaScript</code>代码用来实例化元素。</p><pre class="lx ly lz ma gt mi lv mj mk aw ml bi"><span id="f515" class="mm kq it lv b gy mn mo l mp mq">&lt;template id="mytemplate"&gt;<br/> &lt;script&gt;<br/>   alert()<br/> &lt;/script&gt;<br/>&lt;/template&gt;</span></pre><p id="760a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在给定的例子中，浏览器现在将显示弹出窗口；但是，它是在<code class="fe ls lt lu lv b">script</code>标签中声明的。</p><pre class="lx ly lz ma gt mi lv mj mk aw ml bi"><span id="3c34" class="mm kq it lv b gy mn mo l mp mq">const template = document.querySelector('#mytemplate')<br/>const clone = document.importNode(template.content, true)</span><span id="a9f1" class="mm kq it lv b gy mr mo l mp mq">document.body.appendChild(clone)</span></pre><p id="6f84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">仅当模板被实例化并添加到文档中时，弹出窗口才会出现。<code class="fe ls lt lu lv b">content</code>是另一个<code class="fe ls lt lu lv b">Document Fragment</code>，它包含指定的<code class="fe ls lt lu lv b">HTML</code>结构。文档的方法生成给定节点的副本。它采用的最后一个参数是“deep”标志。默认情况下，它是<code class="fe ls lt lu lv b">false</code>，唯一的高级元素将被复制，因此应使用<code class="fe ls lt lu lv b">true</code>来复制整个布局。</p><p id="a18f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建包含<code class="fe ls lt lu lv b">style</code>定义的<code class="fe ls lt lu lv b">template</code>元素是有意义的。</p><pre class="lx ly lz ma gt mi lv mj mk aw ml bi"><span id="5783" class="mm kq it lv b gy mn mo l mp mq">&lt;template id="mytemplate"&gt;<br/> &lt;style&gt;<br/>   :host { color: red }<br/> &lt;/style&gt;<br/>&lt;/template&gt;</span></pre><p id="a02d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该定义符合自然的<code class="fe ls lt lu lv b">HTML</code>语法，不会在页面加载时呈现，可以在以后开发人员需要追加模板实例时使用。</p><pre class="lx ly lz ma gt mi lv mj mk aw ml bi"><span id="8b7d" class="mm kq it lv b gy mn mo l mp mq">const template = document.querySelector('#mytemplate')<br/>const div = document.createElement('div')<br/>const root = div.attachShadow({ mode: 'open' })<br/>const clone = document.importNode(template.content, true)<br/>root.appendChild(clone)</span><span id="2304" class="mm kq it lv b gy mr mo l mp mq">document.body.appendChild(div)</span></pre><h1 id="d9ee" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">摘要</h1><p id="6a3c" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated"><code class="fe ls lt lu lv b">Custom Elements</code>、<code class="fe ls lt lu lv b">Shadow DOM</code>和<code class="fe ls lt lu lv b">HTML Template</code>规范允许开发人员创建具有封装的<code class="fe ls lt lu lv b">DOM</code>、风格和行为的可重用组件。大多数已声明的API已经可以在主流浏览器中使用，并且有多种填充来模仿其余的API。</p><p id="21fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有一个不错的编码，并希望看到你的评论！</p></div></div>    
</body>
</html>