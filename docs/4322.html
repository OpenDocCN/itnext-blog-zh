<html>
<head>
<title>Creating the 2nd Prometheus Operator in OpenShift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在OpenShift中创建第二个普罗米修斯运算符</h1>
<blockquote>原文：<a href="https://itnext.io/creating-the-2nd-prometheus-operator-in-openshift-80767f996b26?source=collection_archive---------2-----------------------#2020-06-08">https://itnext.io/creating-the-2nd-prometheus-operator-in-openshift-80767f996b26?source=collection_archive---------2-----------------------#2020-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7beac2d88293256213e718e1c5d3629e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G9ga0bRQkOotKRBEPIN-0g.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">维克多·哈纳切克摄影</figcaption></figure><p id="a274" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">OpenShift 4.x提供开箱即用的Prometheus操作员监控。但是，这个操作符只限于某些特定的名称空间，专门用于集群监控。对于应用程序监控，需要单独的Prometheus操作员。必须考虑仔细的规划，以避免两个管理者(操作者)管理完全相同的资源的情况(CRD)。虽然我使用OpenShift作为集群，但是一般步骤适用于其他Kubernetes实现。</p><h2 id="cf72" class="ld le it bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">安装第二个操作器</h2><p id="0a44" class="pw-post-body-paragraph kf kg it kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc im bi translated">OpenShift监控操作员使用与Prometheus操作员完全相同的CRDs，</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="0190" class="ld le it mg b gy mk ml l mm mn">oc get crd -o name| grep monitoring.coreos<br/>customresourcedefinition.apiextensions.k8s.io/alertmanagers.monitoring.coreos.com<br/>customresourcedefinition.apiextensions.k8s.io/podmonitors.monitoring.coreos.com<br/>customresourcedefinition.apiextensions.k8s.io/prometheuses.monitoring.coreos.com<br/>customresourcedefinition.apiextensions.k8s.io/prometheusrules.monitoring.coreos.com<br/>customresourcedefinition.apiextensions.k8s.io/servicemonitors.monitoring.coreos.com</span></pre><p id="9978" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因此，对于第二个运算符，我们不能使用默认的OpenShift方式来安装带有OLM的运算符。我们必须跳过CRD安装，以避免任何覆盖。基于取自prometheus-operator repo的原始源代码，<a class="ae mo" href="https://github.com/coreos/prometheus-operator/blob/master/bundle.yaml" rel="noopener ugc nofollow" target="_blank"> bundle.yaml </a>，我们相应地修改了operator安装。</p><p id="1274" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">忽略集群角色。假设我们将在不同于openshift-monitoring的名称空间中安装操作符。创建服务帐户，并重命名集群角色绑定的名称，如下所示(<em class="mp">使用golang模板格式</em>)</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="15b0" class="ld le it mg b gy mk ml l mm mn">apiVersion: rbac.authorization.k8s.io/v1<br/>kind: ClusterRoleBinding<br/>metadata:<br/>  labels:<br/>    app.kubernetes.io/component: controller<br/>    app.kubernetes.io/name: prometheus-operator<br/>    app.kubernetes.io/version: v0.39.0<br/>  name: {{ .ns }}-prometheus-operator<br/>  namespace: {{ .ns }}<br/>roleRef:<br/>  apiGroup: rbac.authorization.k8s.io<br/>  kind: ClusterRole<br/>  name: prometheus-operator<br/>subjects:<br/>- kind: ServiceAccount<br/>  name: prometheus-operator<br/>  namespace: {{ .ns }}</span></pre><p id="2f8b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">部署也如下所示进行了修改，</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="5ecc" class="ld le it mg b gy mk ml l mm mn">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app.kubernetes.io/component: controller<br/>    app.kubernetes.io/name: prometheus-operator<br/>    app.kubernetes.io/version: v0.39.0<br/>  name: prometheus-operator<br/>  namespace: {{ .ns }}<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app.kubernetes.io/component: controller<br/>      app.kubernetes.io/name: prometheus-operator<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app.kubernetes.io/component: controller<br/>        app.kubernetes.io/name: prometheus-operator<br/>        app.kubernetes.io/version: v0.39.0<br/>    spec:<br/>      containers:<br/>      - args:<br/>        - --kubelet-service=kube-system/kubelet<br/>        - --logtostderr=true<br/>        - --config-reloader-image=jimmidyson/configmap-reload:v0.3.0<br/>        - --prometheus-config-reloader=quay.io/coreos/prometheus-config-reloader:v0.39.0<br/>        # manage the following listed namespaces only , separated<br/>        <strong class="mg iu">- --namespaces={{ .listOfNamespaces }}<br/></strong>        image: quay.io/coreos/prometheus-operator:v0.39.0<br/>        name: prometheus-operator<br/>        ports:<br/>        - containerPort: 8080<br/>          name: http<br/>        resources:<br/>          limits:<br/>            cpu: 200m<br/>            memory: 200Mi<br/>          requests:<br/>            cpu: 100m<br/>            memory: 100Mi<br/>        securityContext:<br/>          allowPrivilegeEscalation: false<br/>      nodeSelector:<br/>        beta.kubernetes.io/os: linux<br/>      securityContext:<br/>        runAsNonRoot: true<br/>        runAsUser: 65534<br/>      serviceAccountName: prometheus-operator</span></pre><p id="3ad6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于容器的命令参数，我们添加了一个名称空间选项，这是一个逗号分隔的名称空间字符串。然后，操作符将只关注在列出的名称空间中定义的CRD。这一点至关重要，否则所有CRD，包括由OpenShift监控操作符创建的CRD，都将由该操作符监视和管理，与默认的OpenShift操作符竞争。</p><h2 id="5968" class="ld le it bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated"><strong class="ak">创建AlertManager资源</strong></h2><p id="8a45" class="pw-post-body-paragraph kf kg it kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc im bi translated">一旦部署了操作符，我们就可以创建prometheus CRD实例。但是由于我们的设置需要AlertManager的依赖性，我们首先创建AlertManager实例。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="0fe2" class="ld le it mg b gy mk ml l mm mn">apiVersion: monitoring.coreos.com/v1<br/>kind: Alertmanager<br/>metadata:<br/>  name: {{ .ns }}-alert-manager<br/>  namespace: {{ .ns }}<br/>spec:<br/>  replicas: 1</span></pre><p id="33d8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">警报管理器需要一个名为<code class="fe mq mr ms mg b">alertmanager-{{ .nameOfAlertManager }}</code>的K8s秘密配置。定义以下内容另存为<code class="fe mq mr ms mg b">alertmanager.yaml</code></p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="5b93" class="ld le it mg b gy mk ml l mm mn">global:<br/>  resolve_timeout: 5m<br/>route:<br/>  group_by: ['job']<br/>  group_wait: 30s<br/>  group_interval: 5m<br/>  repeat_interval: 12h<br/>  receiver: 'webhook'<br/>receivers:<br/>- name: 'webhook'<br/>  webhook_configs:<br/>  - url: '<a class="ae mo" href="http://amwebhook.{{" rel="noopener ugc nofollow" target="_blank">http://amwebhook.{{</a> .ns }}.svc:8080/'</span></pre><p id="0612" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">用固定的名称和文件名创建秘密。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="aaa9" class="ld le it mg b gy mk ml l mm mn">kubectl -n {{ .ns }} create secret generic alertmanager-{{ .ns }}-alert-manager --from-file=<!-- -->alertmanager.yaml</span></pre><p id="075a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，将创建Alertmanager statefulSet。使用<code class="fe mq mr ms mg b">alertmanager: name of the alert manager</code>选择器创建以下服务</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="4ce1" class="ld le it mg b gy mk ml l mm mn">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: svc-alert-manager<br/>  namespace: {{ .ns }}<br/>spec:<br/>  type: ClusterIP<br/>  ports:<br/>  - name: web<br/>    port: 9093<br/>    protocol: TCP<br/>    targetPort: web<br/>  selector:<br/>    alertmanager: {{ .ns }}-alert-manager</span></pre><h2 id="6373" class="ld le it bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">创建普罗米修斯资源</h2><p id="abb9" class="pw-post-body-paragraph kf kg it kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc im bi translated">为普罗米修斯创建以下CRD对象，</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="6218" class="ld le it mg b gy mk ml l mm mn">apiVersion: monitoring.coreos.com/v1<br/>kind: Prometheus<br/>metadata:<br/>  name: prometheus<br/>  namespace: {{ .ns }}<br/>  labels:<br/>    prometheus: prometheus<br/>spec:<br/>  replicas: 1<br/>  serviceAccountName: prometheus<br/> <strong class="mg iu"> serviceMonitorSelector:</strong><br/>    matchLabels:<br/>      managedBy: my-prometheus<br/><strong class="mg iu">  serviceMonitorNamespaceSelector:<br/></strong>     matchLabels:<br/>       monitored-by: my-prometheus<br/>  <strong class="mg iu">ruleSelector:</strong><br/>    matchLabels:<br/>      managedBy: my-prometheus<br/>  alerting:<br/>    alertmanagers:<br/>    - namespace: {{ .ns }}<br/>      name: svc-alert-manager<br/>      port: web</span></pre><p id="9012" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这将创建一个普罗米修斯状态集。请注意Prometheus将抓取的服务监视器资源，警报规则是用标签选择器定义的。现在，当且仅当满足以下所有条件时，这些类型的资源将由这个Prometheus实例管理。</p><ol class=""><li id="9bf8" class="mt mu it kh b ki kj km kn kq mv ku mw ky mx lc my mz na nb bi translated">名称空间在被监视的操作员名称空间列表中。</li><li id="d027" class="mt mu it kh b ki nc km nd kq ne ku nf ky ng lc my mz na nb bi translated">资源具有与定义为<code class="fe mq mr ms mg b">serviceMonitorSelector</code>和<code class="fe mq mr ms mg b">ruleSelector</code>相匹配的标签。</li><li id="b52f" class="mt mu it kh b ki nc km nd kq ne ku nf ky ng lc my mz na nb bi translated">如果未定义serviceMonitorNamespaceSelector和ruleNamespaceSelector，则操作符将只在自己的名称空间中查找serviceMonitors和规则。如果要监视其他命名空间，必须在serviceMonitorNamespaceSelector或ruleNamespaceSelector中定义它</li></ol><p id="9062" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">应用yaml，观察普罗米修斯舱启动并运行。一旦准备就绪，我们就可以创建ServiceMonitor资源来收集指标。下面列出了一个示例服务监视器资源，</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="7603" class="ld le it mg b gy mk ml l mm mn">apiVersion: monitoring.coreos.com/v1<br/>kind: ServiceMonitor<br/>metadata:<br/>  name: qmon-svc-mon<br/>  namespace: {{ .ns }}<br/><strong class="mg iu">  labels:<br/>    managedBy: my-prometheus</strong><br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: mq<br/>  endpoints:<br/>  - port: metrics</span></pre><p id="7f91" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">和一个警报规则示例，</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="e955" class="ld le it mg b gy mk ml l mm mn">apiVersion: monitoring.coreos.com/v1<br/>kind: PrometheusRule<br/>metadata:<br/>  name: monitoring-rules<br/>  namespace: {{ .ns }}<br/><strong class="mg iu">  labels:<br/>    managedBy: my-prometheus</strong><br/>spec:<br/>  groups:<br/>  - name: queueDepthHigh<br/>    rules:<br/>    - alert: QueueDepthTooHigh<br/>      annotations:<br/>        summary: Queue Depth is more than 100<br/>      expr:<br/>        mq_mon_queue_depth &gt; 100<br/>      for: 5m<br/>      labels:<br/>        severity: warning</span></pre><p id="c1db" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">第二艘普罗米修斯号已经准备好投入使用。这些步骤可以应用于多个Prometheus操作符和多租户集群。</p></div></div>    
</body>
</html>