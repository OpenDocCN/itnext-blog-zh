<html>
<head>
<title>Creating your first Docker application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建您的第一个Docker应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/creating-your-first-docker-application-b0ce40ac67d1?source=collection_archive---------1-----------------------#2020-12-12">https://itnext.io/creating-your-first-docker-application-b0ce40ac67d1?source=collection_archive---------1-----------------------#2020-12-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="208c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Docker:图像和容器</h2><div class=""/><div class=""><h2 id="6229" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">在这一课中，我们将了解创建Docker图像和Docker容器的过程。因为Dockerfile对于创建Docker图像是必不可少的，所以我们也将理解Dockerfile的语义。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/a6426865fc826181a5e8eb5da072c022.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zvEOGTe4-erMj1_7432llw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(来源:【unsplash.com】<strong class="bd li"/>)</figcaption></figure><p id="fe51" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在<a class="ae lh" href="https://medium.com/sysf/getting-started-with-docker-1-b4dc83e64389" rel="noopener"> <strong class="ll jd">上一课</strong> </a>中，我们学习了Docker集装箱的结构以及集装箱化的简单工作原理。然而，我们并没有真正使用Docker创建任何应用程序，也没有从头开始理解映像构建过程。在本课中，我们将这样做。</p><p id="6957" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在我们继续之前，让我们先了解一些术语。Docker <strong class="ll jd">容器</strong>是一个短暂的(<em class="mf">短命</em>)进程。这个过程类似于具有私有文件系统、网络端口、内存空间等的客户操作系统。您可以执行各种操作，如启动HTTP服务器、启动数据库服务器或执行IO操作的任何进程。</p><p id="0127" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">Docker <strong class="ll jd">图像</strong>是容器的<strong class="ll jd">蓝图</strong>。将Docker图像看作一个类，而Docker容器则是该类的一个实例。在一个标准程序中，你可以使用<code class="fe mg mh mi mj b">new Image()</code>来创建一个<code class="fe mg mh mi mj b">container</code>。类似地，我们使用<code class="fe mg mh mi mj b">$ docker run &lt;image&gt;</code>命令从图像创建一个容器，其中<code class="fe mg mh mi mj b">image</code>是Docker图像的惟一id。</p><p id="b3bb" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">然而，要创建一个图像，我们需要一个<strong class="ll jd"> Dockerfile </strong>。这是一个纯文本文件，包含组装图像的指令。这些指令被称为<strong class="ll jd">构建指令</strong>或简称为<strong class="ll jd">指令</strong>。一旦图像被创建，我们就可以用它来制作容器。</p><p id="0087" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">Docker引擎协调图像的创建和容器的生命周期。Docker守护进程是Docker引擎中的一个长期运行的进程，负责处理这些任务。Docker引擎通过命令行接口(CLI)和REST API接口公开Docker守护进程。<strong class="ll jd">要安装</strong>Docker引擎(<em class="mf">和其他资源</em>)，请遵循此 文档。它还附带了一个GUI来管理容器。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="5e13" class="mr ms it bd li mt mu mv mw mx my mz na ki nb kj nc kl nd km ne ko nf kp ng nh bi translated">文档文件</h1><p id="cb60" class="pw-post-body-paragraph lj lk it ll b lm ni kd lo lp nj kg lr ls nk lu lv lw nl ly lz ma nm mc md me im bi translated">在本课中，我们将使用<a class="ae lh" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd"> ExpressJS </strong> </a>创建一个Docker容器来启动一个简单的HTTP服务器。这个HTTP服务器返回一个带有用户列表的JSON响应。仅此而已。</p><blockquote class="nn no np"><p id="606f" class="lj lk mf ll b lm ln kd lo lp lq kg lr nq lt lu lv nr lx ly lz ns mb mc md me im bi translated"><em class="it">💡</em>您需要在系统上安装Node.js来<strong class="ll jd">测试</strong>我们正在构建的Docker应用程序。可以从<a class="ae lh" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">这个</strong> </a>官网下载或者使用<a class="ae lh" href="https://github.com/nvm-sh/nvm" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd"> NVM </strong> </a> ( <em class="it">节点版本管理器</em> ) CLI实用程序。但是，这一步不是必需的，因为我们希望在Docker容器中运行这个应用程序，该容器将安装Node.js。</p></blockquote><p id="c9d6" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">众所周知，要创建一个容器，我们需要一个Docker映像，而要创建一个Docker映像，我们需要一个Docker文件。嗯，不总是这样。有人可能已经创建了这样一个图像，做完全相同的事情。你可以在<a class="ae lh" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd"> Docker Hub </strong> </a>注册表上找到公开图片。所以您可以使用<code class="fe mg mh mi mj b">$ docker pull &lt;image_name&gt;</code>命令从这个注册表下载它。</p><p id="5996" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">但是由于我们试图理解创建Docker映像的过程，我们将使用Docker文件自己构建一个映像。你可以在<a class="ae lh" href="https://github.com/course-one/docker-express-example" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">这个</strong> </a> GitHub仓库里找到这个项目的源代码。因此，让我们创建项目目录并安装依赖项。</p><pre class="ks kt ku kv gt nt mj nu nv aw nw bi"><span id="7422" class="nx ms it mj b gy ny nz l oa ob">$ mkdir docker-express-example &amp;&amp; cd docker-express-example<br/>$ npm init -y<br/>$ npm install --save express</span></pre><p id="3c43" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">以上命令将在我们的项目中生成<code class="fe mg mh mi mj b">package.json</code>和<code class="fe mg mh mi mj b">package-lock.json</code>文件以及<code class="fe mg mh mi mj b">node_modules</code>目录。到目前为止，我们的项目结构如下所示。</p><pre class="ks kt ku kv gt nt mj nu nv aw nw bi"><span id="714c" class="nx ms it mj b gy ny nz l oa ob"><strong class="mj jd">docker-express-example/</strong><br/>├── .dockerignore<br/>├── .gitignore<br/>├── Dockerfile<br/>├── db.json<br/>├── images<br/>|  ├── female.png<br/>|  └── male.png<br/>├── node_modules/...<br/>├── package-lock.json<br/>├── package.json<br/>└── server.js</span></pre><p id="f461" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们将讨论项目中的其他文件，但是现在，让我们把重点放在服务器实现上。<code class="fe mg mh mi mj b">db.json</code>文件包含一个用户列表。<code class="fe mg mh mi mj b">server.js</code>文件服务于来自<code class="fe mg mh mi mj b">/</code>端点的<code class="fe mg mh mi mj b">db.json</code>和来自<code class="fe mg mh mi mj b">/images</code>端点的<code class="fe mg mh mi mj b">images/</code>目录中的图像。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(来源:<a class="ae lh" href="https://gist.github.com/thatisuday/64f4ca7166c77410b11364e68802798b" rel="noopener ugc nofollow" target="_blank"><strong class="ak">gist.github.com</strong></a>)</figcaption></figure><p id="daa1" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">该服务器将监听的端口是从<code class="fe mg mh mi mj b">SERVER_PORT</code>环境变量接收的。因此，当我们启动服务器时，需要为这个环境变量提供一个值。我已经通过<code class="fe mg mh mi mj b">package.json</code>中的<code class="fe mg mh mi mj b">start</code>命令完成了。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(来源:<a class="ae lh" href="https://gist.github.com/thatisuday/ced5c79dc70135d789ad569c5947144d" rel="noopener ugc nofollow" target="_blank"><strong class="ak">gist.github.com</strong></a>)</figcaption></figure><p id="879b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在，当我们从项目目录中运行<code class="fe mg mh mi mj b">$ npm run start</code>命令时，我们应该在终端中收到<code class="fe mg mh mi mj b">Server started at port 3000.</code>消息，并且应该能够在<code class="fe mg mh mi mj b">http://localhost:3000</code>端点的浏览器中看到JSON响应。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/39108f3d4e2f6127071e8375bbee6fd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*ZpOjh6DaRXFcafnUx8a5sA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(<a class="ae lh" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>)</figcaption></figure><p id="788a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">既然我们的HTTP服务器如预期的那样工作，让我们讨论一下为什么我们想要<strong class="ll jd">容器化</strong>它。Docker的USP在一个隔离的环境中运行应用程序，而不必安装依赖项来运行它们。此外，由于容器很便宜，我们可以很快产生应用程序的许多副本。</p><p id="0194" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">例如，如果您想与您的同事或用户共享这个应用程序，那么您必须共享源代码，并要求他们安装Node.js才能运行这个应用程序。现在，这也可能导致各种问题，比如运行时相关问题(<em class="mf">由于Node.js版本差异</em>)，平台相关问题(<em class="mf"> Mac vs Windows </em>)，或者其他成千上万的事情。</p><p id="4440" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">要解决这个问题，我们能做的就是创建一个Docker镜像，把这个项目的所有内容都放在里面。这个映像还将拥有运行这个应用程序所需的所有依赖项，比如标准的Node.js安装等等。然后，我们可以公开或私下发布图像，以便其他人可以下载它。一旦他们下载了图像，他们可以用它创建一个容器，并在几秒钟(<em class="mf">或几分之一秒(</em>)内启动应用程序(<em class="mf"> HTTP服务器</em>)。</p><p id="48f7" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">好吧。因此，我们已经大致了解了Docker的用处。因此，让我们开始为这个应用程序构建Docker映像。正如我们所讨论的，要构建一个映像，我们需要一个Dockerfile文件。这个文件通常放在项目的根目录下，但是我们可以把它放在项目的任何地方。稍后会详细介绍。</p><p id="5c2e" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在我们开始处理Dockerfile文件之前，让我们了解成功运行这个应用程序的要求。首先，我们需要一个安装了Node.js的操作系统(<em class="mf">带NPM </em>)。然后我们需要<code class="fe mg mh mi mj b">package.json</code>和<code class="fe mg mh mi mj b">package-lock.json</code>文件来安装依赖项。然后我们需要项目的所有源代码。然后我们需要<code class="fe mg mh mi mj b">SERVER_PORT</code>环境变量来启动服务器。为此，docker文件如下所示。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(来源:<a class="ae lh" href="https://gist.github.com/thatisuday/9ea53836b823da98ee4eddf5b00654de" rel="noopener ugc nofollow" target="_blank"><strong class="ak">gist.github.com</strong></a>)</figcaption></figure><p id="5bb1" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">Dockerfile是一个简单的文本文件，它包含Docker守护进程组装映像的指令。任何以<code class="fe mg mh mi mj b">#</code>开头的文本都是注释，但也可以是<a class="ae lh" href="https://docs.docker.com/engine/reference/builder/#parser-directives" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">解析器指令</strong> </a>。让我们仔细阅读docker文件中的每条指令，了解它们对映像构建过程的贡献。</p><h2 id="59b5" class="nx ms it bd li of og dn mw oh oi dp na ls oj ok nc lw ol om ne ma on oo ng iz bi translated">来自指令</h2><p id="e14b" class="pw-post-body-paragraph lj lk it ll b lm ni kd lo lp nj kg lr ls nk lu lv lw nl ly lz ma nm mc md me im bi translated"><code class="fe mg mh mi mj b"><a class="ae lh" href="https://docs.docker.com/engine/reference/builder/#from" rel="noopener ugc nofollow" target="_blank">FROM</a></code>指令为我们将要使用这个docker文件创建的新图像设置一个<strong class="ll jd">父图像</strong>。父映像包括我们需要的所有必要的东西，例如操作系统环境(<a class="ae lh" href="https://hub.docker.com/_/alpine" rel="noopener ugc nofollow" target="_blank"> <em class="mf"> alpine </em> </a>)和Node.js安装(<em class="mf"> v12.20.0 </em>)。可以在<a class="ae lh" href="https://hub.docker.com/search?q=&amp;type=image&amp;image_filter=store%2Cofficial" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd"> Docker Hub </strong> </a>上寻找官方图片。这里，我们使用<code class="fe mg mh mi mj b"><a class="ae lh" href="https://hub.docker.com/_/node" rel="noopener ugc nofollow" target="_blank">node:12.20.0-alpine3.10</a></code>图像作为我们的父图像。</p><blockquote class="nn no np"><p id="24c1" class="lj lk mf ll b lm ln kd lo lp lq kg lr nq lt lu lv nr lx ly lz ns mb mc md me im bi translated"><em class="it">💡在</em> <code class="fe mg mh mi mj b">node:12.20.0-alpine3.10</code>图像名称格式中，<code class="fe mg mh mi mj b">node</code>部分是图像名称， <code class="fe mg mh mi mj b"><em class="it">:</em></code> <em class="it">之后的<code class="fe mg mh mi mj b"><em class="it">12.20.0-alpine3.10</em></code> <em class="it">称为</em> <strong class="ll jd"> <em class="it">标记</em> </strong> <em class="it">。如果没有提供</em> <code class="fe mg mh mi mj b"><em class="it">:tag</em></code> <em class="it">部分，将默认使用</em> <code class="fe mg mh mi mj b"><em class="it">:latest</em></code> <em class="it">标签。我们将在</em> <a class="ae lh" href="https://medium.com/sysf/understanding-docker-image-tags-and-publishing-images-to-docker-hub-b7a4f900f201" rel="noopener"> <strong class="ll jd"> <em class="it">的另一课</em> </strong> </a> <em class="it">中谈到这种格式。</em></em></p></blockquote><p id="9403" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">您可能会听到术语“<strong class="ll jd">基础映像”</strong>与<strong class="ll jd">父映像</strong>互换使用，但有一点细微的区别。基础图像是父子层次结构中的最后一个图像。例如，我们的新图像源自<code class="fe mg mh mi mj b">node</code>图像，<code class="fe mg mh mi mj b"><a class="ae lh" href="https://hub.docker.com/_/node" rel="noopener ugc nofollow" target="_blank">node</a></code>图像源自<code class="fe mg mh mi mj b"><a class="ae lh" href="https://hub.docker.com/_/alpine" rel="noopener ugc nofollow" target="_blank">alpine</a></code>图像(<a class="ae lh" href="https://github.com/nodejs/docker-node/blob/ecab21f67543ce370cca404b925b21fdc35ea0b2/12/alpine3.10/Dockerfile" rel="noopener ugc nofollow" target="_blank"> <em class="mf">见此处</em> </a>)，而<code class="fe mg mh mi mj b"><a class="ae lh" href="https://hub.docker.com/_/alpine" rel="noopener ugc nofollow" target="_blank">alpine</a></code>图像源自<code class="fe mg mh mi mj b"><a class="ae lh" href="https://hub.docker.com/_/scratch" rel="noopener ugc nofollow" target="_blank">scratch</a></code>图像(<a class="ae lh" href="https://github.com/alpinelinux/docker-alpine/blob/7d751912c8925b5dbcef03522f5edad6acfd175b/x86_64/Dockerfile" rel="noopener ugc nofollow" target="_blank"> <em class="mf">见此处</em> </a>)。</p><p id="47f2" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在,<code class="fe mg mh mi mj b"><a class="ae lh" href="https://hub.docker.com/_/scratch" rel="noopener ugc nofollow" target="_blank">scratch</a></code>图像包含了与Docker引擎一起工作的绝对最少的东西，它是父子层次结构中的最后一个图像，这意味着它不基于任何其他图像。您可以使用此映像来安装操作系统、软件、工具等。，并制作父映像。因此，任何使用<code class="fe mg mh mi mj b">FROM scratch</code>指令继承<code class="fe mg mh mi mj b">scratch</code>的映像都是基础映像。要创建您自己的基础映像，请遵循此 文档。</p><blockquote class="nn no np"><p id="43ec" class="lj lk mf ll b lm ln kd lo lp lq kg lr nq lt lu lv nr lx ly lz ns mb mc md me im bi translated"><em class="it">💡</em>docker文件中的指令<strong class="ll jd">不区分大小写</strong>，这意味着您也可以使用<code class="fe mg mh mi mj b">from &lt;image&gt;</code>代替<code class="fe mg mh mi mj b">FROM &lt;image&gt;</code>。但是建议使用大写字母作为指令名，以增加可读性。</p></blockquote><p id="df35" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">理想情况下，<code class="fe mg mh mi mj b">FROM</code>指令应该是Dockerfile文件中的第一条指令。在<strong class="ll jd">多阶段构建</strong>的情况下，我们可以在Dockerfile中有不止一个<code class="fe mg mh mi mj b">FROM</code>指令，我们将在<a class="ae lh" href="https://medium.com/sysf/docker-container-as-an-executable-to-process-images-using-go-golang-5233f9bd3bf7" rel="noopener"> <strong class="ll jd">的另一课</strong> </a>中介绍。</p><h2 id="4bde" class="nx ms it bd li of og dn mw oh oi dp na ls oj ok nc lw ol om ne ma on oo ng iz bi translated">工作目录指令</h2><p id="d51f" class="pw-post-body-paragraph lj lk it ll b lm ni kd lo lp nj kg lr ls nk lu lv lw nl ly lz ma nm mc md me im bi translated">Dockerfile文件中的第二个重要指令是<code class="fe mg mh mi mj b"><a class="ae lh" href="https://docs.docker.com/engine/reference/builder/#workdir" rel="noopener ugc nofollow" target="_blank">WORKDIR</a></code>。该指令为Dockerfile中的指令(<em class="mf">如</em> <code class="fe mg mh mi mj b"><em class="mf">RUN</em></code> <em class="mf">，</em> <code class="fe mg mh mi mj b"><em class="mf">CMD</em></code> <em class="mf">，</em> <code class="fe mg mh mi mj b"><em class="mf">ENTRYPOINT</em></code> <em class="mf">，</em> <code class="fe mg mh mi mj b"><em class="mf">COPY</em></code> <em class="mf">，</em> <code class="fe mg mh mi mj b"><em class="mf">ADD</em></code> <em class="mf">等)设置了一个<strong class="ll jd">工作目录。</strong></em>)使用相对路径访问或修改镜像的文件系统。如果文件系统中不存在该目录，将在创建映像时创建它。</p><blockquote class="nn no np"><p id="c54c" class="lj lk mf ll b lm ln kd lo lp lq kg lr nq lt lu lv nr lx ly lz ns mb mc md me im bi translated"><em class="it">💡Dockerfile文件中可以有多个<code class="fe mg mh mi mj b">WORKDIR</code>指令。每条指令将为下一条指令设置一个新的工作目录。我们可以提供下一条<code class="fe mg mh mi mj b">WORKDIR</code>指令的相对路径，该路径将与前一条<code class="fe mg mh mi mj b">WORKDIR</code>路径相关。</em></p></blockquote><p id="59f9" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在我们的例子中，我们已经将<code class="fe mg mh mi mj b">/app</code>目录(<em class="mf">相对于映像</em>的文件系统的根)设置为工作目录。因为这个目录不存在于<code class="fe mg mh mi mj b">node</code>映像的文件系统中，所以它将被创建。</p><p id="1049" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">您可以将工作目录视为映像中的目录，终端shell将在该目录中打开，并且命令中用于访问或修改文件的所有相对路径都将相对于该目录。</p><p id="663d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">类似地，<strong class="ll jd">构建上下文</strong>是主机(<em class="mf">，我们在其上创建Docker映像</em>)上的一个目录，在构建包含<code class="fe mg mh mi mj b">Dockerfile</code>、<code class="fe mg mh mi mj b">.dockerignore</code>和<code class="fe mg mh mi mj b">package.json</code>、<code class="fe mg mh mi mj b">images/</code>.等应用相关文件的映像时，该目录被发送到Docker守护程序。该目录通过用于创建映像的<code class="fe mg mh mi mj b">$ docker build &lt;path&gt;</code>命令提供，其中<code class="fe mg mh mi mj b">path</code>是构建上下文目录的路径。在我们的例子中，它将是到<code class="fe mg mh mi mj b">docker-express-example</code>目录的路径。</p><h2 id="570b" class="nx ms it bd li of og dn mw oh oi dp na ls oj ok nc lw ol om ne ma on oo ng iz bi translated">添加说明</h2><p id="b7eb" class="pw-post-body-paragraph lj lk it ll b lm ni kd lo lp nj kg lr ls nk lu lv lw nl ly lz ma nm mc md me im bi translated"><code class="fe mg mh mi mj b"><a class="ae lh" href="https://docs.docker.com/engine/reference/builder/#add" rel="noopener ugc nofollow" target="_blank">ADD</a></code>指令将文件从构建上下文复制到工作目录(<em class="mf">表示相对目标路径</em>)或镜像的任何其他目录(<em class="mf">表示绝对路径</em>)。我们可以将一个或多个源文件从构建上下文复制到映像中的目的地。使用该指令有两种方式，如下所示。后者对于包含空白的文件很有用。</p><pre class="ks kt ku kv gt nt mj nu nv aw nw bi"><span id="84a5" class="nx ms it mj b gy ny nz l oa ob">ADD &lt;src&gt;... &lt;dest&gt;<br/>ADD ["&lt;src&gt;",... "&lt;dest&gt;"]</span></pre><blockquote class="nn no np"><p id="7f01" class="lj lk mf ll b lm ln kd lo lp lq kg lr nq lt lu lv nr lx ly lz ns mb mc md me im bi translated"><em class="it">💡</em><code class="fe mg mh mi mj b">ADD</code>指令也可以从远程URL(如Git存储库)复制文件。如果<code class="fe mg mh mi mj b">src</code>是一个本地tar存档文件，那么它将在复制操作期间在<code class="fe mg mh mi mj b">dest</code>被提取。从<a class="ae lh" href="https://docs.docker.com/engine/reference/builder/#add" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">本</strong> </a>文档中了解有关此行为的更多信息。该功能在<code class="fe mg mh mi mj b">COPY</code>指令中不受支持。</p></blockquote><p id="a92d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在我们的例子中，我们首先将<code class="fe mg mh mi mj b">package.json</code>和<code class="fe mg mh mi mj b">package-lock.json</code>文件复制到工作目录( <code class="fe mg mh mi mj b"><em class="mf">./</em></code> <em class="mf">路径</em>指定的<em class="mf">，这样我们就可以安装NPM依赖项了。但是构建上下文不是已经包含了包含所有依赖项的<code class="fe mg mh mi mj b">node_module</code>目录吗？难道我们不能把它从构建上下文中复制到工作区目录中吗？</em></p><p id="452e" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">首先，我们应该真正避免向Docker守护进程发送大的、不必要的和敏感的文件，这些文件可能会使用<code class="fe mg mh mi mj b">ADD</code>或<code class="fe mg mh mi mj b">COPY</code>指令复制到映像中。<code class="fe mg mh mi mj b">.<a class="ae lh" href="https://docs.docker.com/engine/reference/builder/#dockerignore-file" rel="noopener ugc nofollow" target="_blank">dockerignore</a></code>文件的工作方式类似于<code class="fe mg mh mi mj b">.gitignore</code>文件，但是在将文件发送到Docker守护进程时，会将其从构建上下文中排除。我们通过在<code class="fe mg mh mi mj b">.<a class="ae lh" href="https://github.com/course-one/docker-express-example/blob/master/.dockerignore" rel="noopener ugc nofollow" target="_blank">dockerignore</a></code>文件中添加<code class="fe mg mh mi mj b">node_modules</code>行来排除<code class="fe mg mh mi mj b">node_module</code>目录。</p><blockquote class="nn no np"><p id="9f69" class="lj lk mf ll b lm ln kd lo lp lq kg lr nq lt lu lv nr lx ly lz ns mb mc md me im bi translated"><em class="it">💡</em>如果<code class="fe mg mh mi mj b"><em class="it">src</em></code>路径不属于<code class="fe mg mh mi mj b"><em class="it">../file.txt</em></code>等构建上下文，那么<code class="fe mg mh mi mj b"><em class="it">ADD</em></code>或<code class="fe mg mh mi mj b"><em class="it">COPY</em></code>操作将失败。</p></blockquote><h2 id="f515" class="nx ms it bd li of og dn mw oh oi dp na ls oj ok nc lw ol om ne ma on oo ng iz bi translated">运行指令</h2><p id="20fd" class="pw-post-body-paragraph lj lk it ll b lm ni kd lo lp nj kg lr ls nk lu lv lw nl ly lz ma nm mc md me im bi translated"><code class="fe mg mh mi mj b"><a class="ae lh" href="https://docs.docker.com/engine/reference/builder/#run" rel="noopener ugc nofollow" target="_blank">RUN</a></code>指令在构建时运行命令。这可能是bash命令，如<code class="fe mg mh mi mj b">rm -rf ./file.txt</code>或任何复杂的命令，如下载文件、访问或修改文件系统等。<code class="fe mg mh mi mj b">RUN</code>命令的结果被提交到映像，如文件修改。如下图所示，有两种类型的<code class="fe mg mh mi mj b">RUN</code>命令。</p><pre class="ks kt ku kv gt nt mj nu nv aw nw bi"><span id="54ac" class="nx ms it mj b gy ny nz l oa ob">RUN &lt;command&gt;<br/>RUN ["executable", "param1", "param2"]</span></pre><p id="682a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">指令的前一种格式被称为<strong class="ll jd">外壳格式</strong>，因为默认情况下它是用<code class="fe mg mh mi mj b">/bin/sh -c</code>执行的，而后一种格式被称为<strong class="ll jd">执行格式</strong>，因为你可以传递一个定制的可执行文件。</p><p id="3e39" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在我们的例子中，我们使用映像的默认shell运行<code class="fe mg mh mi mj b">npm install</code>命令，该shell将NPM依赖项安装在工作区目录中。</p><h2 id="0ffe" class="nx ms it bd li of og dn mw oh oi dp na ls oj ok nc lw ol om ne ma on oo ng iz bi translated">环境指令</h2><p id="efb0" class="pw-post-body-paragraph lj lk it ll b lm ni kd lo lp nj kg lr ls nk lu lv lw nl ly lz ma nm mc md me im bi translated"><code class="fe mg mh mi mj b"><a class="ae lh" href="https://docs.docker.com/engine/reference/builder/#env" rel="noopener ugc nofollow" target="_blank">ENV</a></code>指令在图像中设置一个环境变量。该指令的值是一系列的<code class="fe mg mh mi mj b">key=value</code>对，但是，在docker文件中可以有多个<code class="fe mg mh mi mj b">ENV</code>指令。</p><pre class="ks kt ku kv gt nt mj nu nv aw nw bi"><span id="1478" class="nx ms it mj b gy ny nz l oa ob">ENV &lt;key&gt;=&lt;value&gt; ...</span></pre><p id="3383" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们可以在其他指令中使用环境变量的值。例如，我们在<code class="fe mg mh mi mj b">EXPOSE</code>指令中使用了<code class="fe mg mh mi mj b">SERVER_PORT</code>环境变量的值。您可以对<code class="fe mg mh mi mj b">RUN</code>或<code class="fe mg mh mi mj b">CMD</code>指令进行同样的操作，但在使用<code class="fe mg mh mi mj b">exec</code>表单时有一些注意事项，请阅读<a class="ae lh" href="https://docs.docker.com/engine/reference/builder/#run" rel="noopener ugc nofollow" target="_blank">了解更多信息</a>。</p><p id="aa76" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这些环境变量也将保存在容器中。这意味着当我们从这个图像创建一个容器时，您可以访问这个环境变量的值(例如在节点上运行JavaScript程序的情况下使用 <code class="fe mg mh mi mj b"><em class="mf">process.env.SERVER_PORT</em></code> <em class="mf">)。您可以使用从图像创建容器的<code class="fe mg mh mi mj b">$ docker run</code>命令的<code class="fe mg mh mi mj b">--env</code>或<code class="fe mg mh mi mj b">-e</code>标志覆盖由<code class="fe mg mh mi mj b">ENV</code>设置的环境变量的值。</em></p><p id="3554" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果您不希望环境变量在容器中可访问，而是只在构建期间存在，那么考虑使用<code class="fe mg mh mi mj b"><a class="ae lh" href="https://docs.docker.com/engine/reference/builder/#arg" rel="noopener ugc nofollow" target="_blank">ARG</a></code>指令。您也可以像使用<code class="fe mg mh mi mj b">--env</code>标志一样使用<code class="fe mg mh mi mj b">--build-arg</code>标志来覆盖<code class="fe mg mh mi mj b">ARG</code>指令的默认值。</p><h2 id="136f" class="nx ms it bd li of og dn mw oh oi dp na ls oj ok nc lw ol om ne ma on oo ng iz bi translated">暴露指令</h2><p id="1057" class="pw-post-body-paragraph lj lk it ll b lm ni kd lo lp nj kg lr ls nk lu lv lw nl ly lz ma nm mc md me im bi translated">容器是一个独立的环境，拥有自己的文件系统和网络，就像拥有一个虚拟客户操作系统一样。因此，容器不使用主机的端口。容器中的所有端口都被防火墙封闭，主机(<em class="mf">运行容器的那个</em>)无法访问它。</p><pre class="ks kt ku kv gt nt mj nu nv aw nw bi"><span id="d3bb" class="nx ms it mj b gy ny nz l oa ob">EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span></pre><p id="ab5d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe mg mh mi mj b"><a class="ae lh" href="https://docs.docker.com/engine/reference/builder/#expose" rel="noopener ugc nofollow" target="_blank">EXPOSE</a></code>指令指示容器打开某个端口，并对主机公开。Dockerfile文件中可以有任意多的<code class="fe mg mh mi mj b">EXPOSE</code>指令。在从映像创建容器时，您可以选择将主机上的一个端口绑定到这些开放端口之一，以便使用<code class="fe mg mh mi mj b">$ docker run</code>命令的<code class="fe mg mh mi mj b">--publish</code>或<code class="fe mg mh mi mj b">-p</code>标志将流量从<code class="fe mg mh mi mj b">host_port</code>发送到<code class="fe mg mh mi mj b">container_port</code>。</p><p id="1c3b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在我们的例子中，由于环境变量<code class="fe mg mh mi mj b">SERVER_PORT</code>的默认值是<code class="fe mg mh mi mj b">8000</code>，当容器运行时，只有端口<code class="fe mg mh mi mj b">8000</code>会暴露给主机。但是这个值可以通过使用<code class="fe mg mh mi mj b">--env</code>标志改变<code class="fe mg mh mi mj b">SERVER_PORT</code>环境变量的值来改变，这意味着我们可以控制在运行时暴露哪个端口。</p><blockquote class="nn no np"><p id="bbaa" class="lj lk mf ll b lm ln kd lo lp lq kg lr nq lt lu lv nr lx ly lz ns mb mc md me im bi translated"><em class="it">💡</em>您可以使用<code class="fe mg mh mi mj b"><em class="it">--expose</em></code>标志和<code class="fe mg mh mi mj b"><em class="it">$ docker run</em></code>命令在运行时从容器中公开一个端口。</p></blockquote><h2 id="e130" class="nx ms it bd li of og dn mw oh oi dp na ls oj ok nc lw ol om ne ma on oo ng iz bi translated">复制指令</h2><p id="ac9f" class="pw-post-body-paragraph lj lk it ll b lm ni kd lo lp nj kg lr ls nk lu lv lw nl ly lz ma nm mc md me im bi translated"><code class="fe mg mh mi mj b"><a class="ae lh" href="https://docs.docker.com/engine/reference/builder/#copy" rel="noopener ugc nofollow" target="_blank">COPY</a></code>指令的工作方式与<code class="fe mg mh mi mj b"><a class="ae lh" href="https://docs.docker.com/engine/reference/builder/#add" rel="noopener ugc nofollow" target="_blank">ADD</a></code>指令相同。它将文件从构建上下文复制到工作区目录或映像的任何其他目录。</p><pre class="ks kt ku kv gt nt mj nu nv aw nw bi"><span id="2ab8" class="nx ms it mj b gy ny nz l oa ob">COPY &lt;src&gt;... &lt;dest&gt;<br/>COPY ["&lt;src&gt;",... "&lt;dest&gt;"]</span></pre><p id="f609" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">然而，<code class="fe mg mh mi mj b">COPY</code>指令不支持URL，也不提取tar存档的源代码。所以建议用<code class="fe mg mh mi mj b">COPY</code>代替<code class="fe mg mh mi mj b">ADD</code>，以免误下载文件或解压档案。</p><p id="d711" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">然而，<code class="fe mg mh mi mj b">COPY</code>的亮点是能够使用带有<code class="fe mg mh mi mj b">COPY</code>指令的<code class="fe mg mh mi mj b">--from=&lt;name&gt;</code>标志从另一个映像复制文件。这里，<code class="fe mg mh mi mj b">name</code>是在多阶段构建过程中生成的映像的名称。我们将在<a class="ae lh" href="https://medium.com/sysf/docker-container-as-an-executable-to-process-images-using-go-golang-5233f9bd3bf7" rel="noopener"> <strong class="ll jd">的单独课程</strong> </a>中了解更多关于这一点和多阶段构建的内容。</p><p id="b54a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在我们的例子中，我们将文件从<code class="fe mg mh mi mj b">.</code>复制到<code class="fe mg mh mi mj b">.</code>，这意味着通过考虑<code class="fe mg mh mi mj b">.<a class="ae lh" href="https://github.com/course-one/docker-express-example/blob/master/.dockerignore" rel="noopener ugc nofollow" target="_blank">dockerignore</a></code>文件中提到的被排除的文件，将构建上下文的内容递归地复制到工作区目录中。</p><h2 id="bf1f" class="nx ms it bd li of og dn mw oh oi dp na ls oj ok nc lw ol om ne ma on oo ng iz bi translated">CMD指令</h2><p id="ea36" class="pw-post-body-paragraph lj lk it ll b lm ni kd lo lp nj kg lr ls nk lu lv lw nl ly lz ma nm mc md me im bi translated"><code class="fe mg mh mi mj b"><a class="ae lh" href="https://docs.docker.com/engine/reference/builder/#cmd" rel="noopener ugc nofollow" target="_blank">CMD</a></code>指令的工作方式与<code class="fe mg mh mi mj b"><a class="ae lh" href="https://docs.docker.com/engine/reference/builder/#run" rel="noopener ugc nofollow" target="_blank">RUN</a></code>指令相似，但它们有很大的不同。如前所述，<code class="fe mg mh mi mj b">RUN</code>指令在构建期间执行一个命令，并将命令的结果提交给映像。</p><pre class="ks kt ku kv gt nt mj nu nv aw nw bi"><span id="337f" class="nx ms it mj b gy ny nz l oa ob">CMD &lt;command&gt;<br/>CMD ["executable", "param1", "param2"]</span></pre><p id="092f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">然而，<code class="fe mg mh mi mj b">CMD</code>命令在构建过程中不会被执行。默认情况下，当我们创建容器时，它会被执行。这意味着<code class="fe mg mh mi mj b">CMD</code>将在运行时生效。因此，如果您想在创建容器后立即启动服务器或任何进程，<code class="fe mg mh mi mj b">CMD</code>是正确的选择。</p><p id="7b06" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">与其他指令不同，<code class="fe mg mh mi mj b">CMD</code>在Dockerfile中只能出现一次。如果docker文件中有<code class="fe mg mh mi mj b"><a class="ae lh" href="https://docs.docker.com/engine/reference/builder/#entrypoint" rel="noopener ugc nofollow" target="_blank">ENTRYPOINT</a></code>指令，那么就不需要有<code class="fe mg mh mi mj b">CMD</code>指令，然而，<code class="fe mg mh mi mj b">CMD</code>可以为<code class="fe mg mh mi mj b">ENTRYPOINT</code>设置默认参数，并且它们可以被提供给<code class="fe mg mh mi mj b">$ docker run</code>命令的参数覆盖。我们将在另一课 的<a class="ae lh" href="https://medium.com/sysf/docker-container-as-an-executable-to-process-images-using-go-golang-5233f9bd3bf7" rel="noopener"> <strong class="ll jd">中详细讨论<code class="fe mg mh mi mj b">ENTRYPOINT</code>指令及其与<code class="fe mg mh mi mj b">CMD</code>的关系。</strong></a></p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="43f0" class="mr ms it bd li mt mu mv mw mx my mz na ki nb kj nc kl nd km ne ko nf kp ng nh bi translated">图像构建过程</h1><p id="b451" class="pw-post-body-paragraph lj lk it ll b lm ni kd lo lp nj kg lr ls nk lu lv lw nl ly lz ma nm mc md me im bi translated">我希望你还和我在一起，因为我们现在要讨论酷的部分，从docker文件构建一个图像。Docker附带了一个CLI来访问Docker引擎的内部。它使我们能够构建图像、管理容器，以及做Docker引擎能做的几乎任何事情。</p><p id="fd3a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">您可以通过运行<code class="fe mg mh mi mj b">docker --version</code>命令来检查Docker安装。为了构建一个图像，我们使用<code class="fe mg mh mi mj b">docker <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/build/" rel="noopener ugc nofollow" target="_blank">build</a></code>命令。</p><pre class="ks kt ku kv gt nt mj nu nv aw nw bi"><span id="d9ce" class="nx ms it mj b gy ny nz l oa ob">$ docker build [options] PATH</span></pre><p id="7703" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这里，<code class="fe mg mh mi mj b">PATH</code>是我们想要发送给Docker守护进程的构建上下文的目录。<code class="fe mg mh mi mj b">options</code>标志控制如何创建图像。</p><blockquote class="nn no np"><p id="b68a" class="lj lk mf ll b lm ln kd lo lp lq kg lr nq lt lu lv nr lx ly lz ns mb mc md me im bi translated"><em class="it">💡</em> <code class="fe mg mh mi mj b">PATH</code>也可以是Git资源库之类的URL。它也可以是一个tar存档文件。如果不想传递构建上下文，使用<code class="fe mg mh mi mj b">-</code>作为<code class="fe mg mh mi mj b">PATH</code>值。</p></blockquote><p id="7f0c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">理想情况下，Dockerfile应该在构建上下文的根目录中，但这不是一个硬性的规则。您可以将Dockerfile存储在文件系统中的任何地方，并使用<code class="fe mg mh mi mj b">--file</code>或<code class="fe mg mh mi mj b">-f</code>标志提供到它的路径。也可以通过STDIN ( <a class="ae lh" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#pipe-dockerfile-through-stdin" rel="noopener ugc nofollow" target="_blank"> <em class="mf">阅读更多</em> </a>)提供Dockerfile。</p><p id="f490" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">首先，因为我们的图像将基于<code class="fe mg mh mi mj b">node:12.20.0-alpine3.10</code>图像，所以我们需要事先准备好。为了从Docker Hub下载Docker映像，我们使用了<code class="fe mg mh mi mj b">docker pull</code>命令。</p><pre class="ks kt ku kv gt nt mj nu nv aw nw bi"><span id="e4d8" class="nx ms it mj b gy ny nz l oa ob">$ docker pull node:12.20.0-alpine3.10</span></pre><p id="dda1" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jd">然而</strong>,<code class="fe mg mh mi mj b">docker build</code>命令足够智能，如果本地存储库中没有图像，它会自动下载。所以上面的步骤是不必要的。让我们在项目目录的根目录下打开终端并运行<code class="fe mg mh mi mj b">docker build</code>命令。</p><pre class="ks kt ku kv gt nt mj nu nv aw nw bi"><span id="b8bf" class="nx ms it mj b gy ny nz l oa ob">$ cd docker-express-example<br/>$ docker build .</span></pre><p id="29b9" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这里，<code class="fe mg mh mi mj b">.</code>是到<code class="fe mg mh mi mj b">docker-express-example</code>目录的路径，该目录是发送到Docker守护进程的构建上下文，它包含Docker文件。让我们看看这个命令执行的结果。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/f54bd36dd9e6761ed519b83a009c6bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q5cmWYnNTtNFa3zJsWSCLA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker构建。</figcaption></figure><p id="9e5b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe mg mh mi mj b">docker build</code>命令(<em class="mf"> Docker守护进程</em>)在将构建上下文发送到Docker守护进程之前分析Docker文件。然后它一次遍历docker文件中的一条指令。由于第一条指令是<code class="fe mg mh mi mj b">FROM</code>，它将试图找到<code class="fe mg mh mi mj b">node:12.20.0-alpine3.10</code>映像的本地副本，如果不存在，它将等待，直到从Dockerhub下载。</p><p id="783a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">正如我们在<a class="ae lh" href="https://medium.com/sysf/getting-started-with-docker-1-b4dc83e64389" rel="noopener"> <strong class="ll jd">上一课</strong> </a>中所讨论的，Docker映像由多个只读层堆叠而成。当Docker守护进程从Docker hub下载图像时，您可以在上面的日志输出中看到这些层的<code class="fe mg mh mi mj b">node</code>图像。我们的图像也将以类似的方式组装。</p><p id="0a52" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">一旦执行完<code class="fe mg mh mi mj b">FROM</code>指令，构建上下文将被转移到Docker守护进程，其大小为58.53kb。这乍一看似乎不太寻常，但是请记住，我们已经忽略了<code class="fe mg mh mi mj b">.dockerignore</code>文件中的<code class="fe mg mh mi mj b">node_modules</code>目录，因此不会包括它。</p><p id="d764" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">下一个指令是设置<code class="fe mg mh mi mj b">WORKDIR</code>，这被认为是一个步骤，因此它是图像构建过程的步骤2。从这里开始，任何使用相对路径来访问或修改镜像文件系统的指令都是相对于<code class="fe mg mh mi mj b">/app</code>目录的。</p><p id="5f5d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">下一条<code class="fe mg mh mi mj b">ADD</code>指令将<code class="fe mg mh mi mj b">package.json</code>和<code class="fe mg mh mi mj b">package-lock.json</code>从构建上下文(<em class="mf">与</em> <code class="fe mg mh mi mj b"><em class="mf">./package.json</em></code>相同)复制到工作区目录(<em class="mf">，因为</em> <code class="fe mg mh mi mj b"><em class="mf">.</em></code> <em class="mf">路径被用作目的地</em>)。之后，<code class="fe mg mh mi mj b">RUN</code>指令执行<code class="fe mg mh mi mj b">npm install</code>命令(<em class="mf"> shell form </em>)并生成<code class="fe mg mh mi mj b">node_modules</code>目录。</p><p id="1cee" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">一旦<code class="fe mg mh mi mj b">RUN</code>指令成功运行，<code class="fe mg mh mi mj b">ENV</code>指令设置环境变量，<code class="fe mg mh mi mj b">EXPOSE</code>指令公开由<code class="fe mg mh mi mj b">SERVER_PORT</code>值指示的端口。这些指令不被认为是构建步骤，但是它们由Docker守护进程执行。</p><p id="1f2f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe mg mh mi mj b">COPY . .</code>指令将构建上下文的内容复制到工作区目录。这一步是必要的，因为我们需要<code class="fe mg mh mi mj b">server.js</code>、<code class="fe mg mh mi mj b">db.json</code>和其他文件来运行应用程序。然而，该指令也复制了我们在开始时已经使用<code class="fe mg mh mi mj b">ADD</code>指令复制的<code class="fe mg mh mi mj b">package.json</code>和<code class="fe mg mh mi mj b">package-lock.json</code>。那么为什么我们不能在那个地方使用这个<code class="fe mg mh mi mj b">COPY</code>指令呢？</p><h2 id="eb06" class="nx ms it bd li of og dn mw oh oi dp na ls oj ok nc lw ol om ne ma on oo ng iz bi translated">构建缓存</h2><p id="cf70" class="pw-post-body-paragraph lj lk it ll b lm ni kd lo lp nj kg lr ls nk lu lv lw nl ly lz ma nm mc md me im bi translated">在<a class="ae lh" href="https://medium.com/sysf/getting-started-with-docker-1-b4dc83e64389" rel="noopener"> <strong class="ll jd">上一课</strong> </a>中，我们讨论了Docker映像的剖析以及容器如何使用Docker映像。docker图像由只读层组成。每一层都包含从前一层修改的文件。因此，每个<code class="fe mg mh mi mj b">RUN</code>、<code class="fe mg mh mi mj b">COPY</code>和<code class="fe mg mh mi mj b">ADD</code>指令创建一个单独的层。这些层会根据修改或添加的文件数量增加图像的大小。</p><p id="03b0" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在构建映像时，Docker守护程序还会为Docker文件中的每个指令临时创建中间映像(在 <code class="fe mg mh mi mj b"><em class="mf">FROM</em></code> <em class="mf">指令</em>之后的<em class="mf">),一旦构建了最终映像，这些中间映像将被删除，但是，它们将成为<strong class="ll jd">构建缓存</strong>的一部分。</em></p><p id="5b92" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">每当我们尝试使用Docker文件构建映像时，Docker守护程序都会检查构建缓存，查找从它正在分析的Docker文件中提到的相同父映像创建的映像。然后，它将处理当前docker文件中的下一条指令，并检查在构建缓存中是否存在具有相同指令的中间映像。</p><p id="5d8b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果指令不同，或者指令中提到的文件内容(如<code class="fe mg mh mi mj b">ADD package.json</code>)与构建缓存中的中间映像不同，那么Docker守护程序将停止寻找缓存，并通过处理发生<strong class="ll jd">缓存未命中</strong>的后续指令来创建映像。你可以从<a class="ae lh" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#leverage-build-cache" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">这里</strong> </a>阅读更多关于构建缓存的内容。</p><blockquote class="nn no np"><p id="19a7" class="lj lk mf ll b lm ln kd lo lp lq kg lr nq lt lu lv nr lx ly lz ns mb mc md me im bi translated"><em class="it">💡</em>如果您不想在构建映像时使用构建缓存，请在<code class="fe mg mh mi mj b">docker build</code>命令中使用<code class="fe mg mh mi mj b">--no-cache=true</code>标志。如果您想要持久化构建期间生成的中间映像，请使用<code class="fe mg mh mi mj b">--rm=false</code>标志。</p></blockquote><p id="f828" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">由于项目源代码的内容更有可能改变，我们在docker文件的末尾添加了<code class="fe mg mh mi mj b">COPY . .</code>指令。由于<code class="fe mg mh mi mj b">package.json</code>和<code class="fe mg mh mi mj b">package-lock.json</code>文件不太可能更改，因此在创建新的构建时，Docker可以使用来自早期构建的构建缓存的中间映像来执行<code class="fe mg mh mi mj b">ADD</code>指令。缓存未命中可能发生在<code class="fe mg mh mi mj b">COPY</code>指令处，但是到那时，我们已经使用了大部分缓存。这大大减少了构建时间。</p><blockquote class="nn no np"><p id="ea81" class="lj lk mf ll b lm ln kd lo lp lq kg lr nq lt lu lv nr lx ly lz ns mb mc md me im bi translated"><em class="it">💡</em>如果你想删除所有构建缓存，使用<code class="fe mg mh mi mj b">$ docker builder prune -a</code>命令。你也可以使用<code class="fe mg mh mi mj b">$ docker system prune -a</code>命令来删除所有没有运行的容器、映像和网络。</p></blockquote><p id="ce07" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">Docker文件中的最后一条指令是<code class="fe mg mh mi mj b">CMD</code>，但它不会被Docker守护进程执行。当从这个Docker映像创建一个容器时，它将被注册和执行。一旦这一步完成，我们的docker图像将被创建。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/80c65533d3cb406522e249980fe5c38f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CYDNnJUjvbkmIHfc-MdOuw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker图像</figcaption></figure><p id="ac8e" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">要查看本地显示的Docker图像，我们使用<code class="fe mg mh mi mj b">$ docker images</code>或<code class="fe mg mh mi mj b">$ docker image ls</code>命令。它列出了我们从docker Hub获取或在本地创建的所有Docker图像。此刻，我们可以看到我们几秒钟前创建的Docker图像。</p><p id="ed86" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe mg mh mi mj b">REPOSITORY</code>列包含我们刚刚创建的图像的名称，而<code class="fe mg mh mi mj b">TAG</code>列包含用于识别同一图像的不同版本的标签。我们可以使用带有<code class="fe mg mh mi mj b">$ docker build</code>命令的<code class="fe mg mh mi mj b">--tag</code>或<code class="fe mg mh mi mj b">-t</code>标志来提供这些值。因为我们没有使用这个标志，所以这些值是空的(<code class="fe mg mh mi mj b"><em class="mf">&lt;none&gt;</em></code>)。我们将在<a class="ae lh" href="https://medium.com/sysf/understanding-docker-image-tags-and-publishing-images-to-docker-hub-b7a4f900f201" rel="noopener"> <strong class="ll jd">的另一课</strong> </a>中谈到这些领域。</p><p id="102b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">每个Docker图像都有一个独特的SHA-256摘要，由<code class="fe mg mh mi mj b">IMAGE ID</code>列表示。当我们使用<code class="fe mg mh mi mj b">$ docker images</code>命令列出图像时，它只显示前12个字符。但是，使用<code class="fe mg mh mi mj b">--no-trunc</code>标志，您可以看到完整的摘要值。</p><blockquote class="nn no np"><p id="f321" class="lj lk mf ll b lm ln kd lo lp lq kg lr nq lt lu lv nr lx ly lz ns mb mc md me im bi translated"><em class="it">💡</em> Docker通过查看图像的内容为图像生成这个SHA-256哈希值。如果两个Docker映像包含完全相同的文件，它们的ID将是相同的。但是，你不要把所有的信任都放在这个逻辑上。</p></blockquote><p id="bd47" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们使用相同的docker文件创建另一个构建，但是这一次，我们将使用<code class="fe mg mh mi mj b">-t</code>标志来命名图像。<code class="fe mg mh mi mj b">--tag</code>或<code class="fe mg mh mi mj b">-t</code>的值的一般格式是<code class="fe mg mh mi mj b">name:tag</code>，但是我们可以删除<code class="fe mg mh mi mj b">:tag</code>部分，Docker将默认使用<code class="fe mg mh mi mj b">:latest</code>值。让我们更改<code class="fe mg mh mi mj b">.gitignore</code>的内容，以便<code class="fe mg mh mi mj b">COPY . .</code>指令导致缓存未命中。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/2f89ce16f0601896ac890f99c9782be6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nl4bJxLT2IBbWXnB296vXw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker build -t expserver。</figcaption></figure><p id="2333" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这个构建用了3.7秒完成，比上一个构建快了10秒。这样做的主要原因是我们已经有了先前构建的<code class="fe mg mh mi mj b">node:12.20.0-alpine3.10</code>映像的本地副本。因此Docker守护进程不会从Docker Hub再次下载它。</p><p id="c6ca" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果您检查上面的输出日志，除了<code class="fe mg mh mi mj b">COPY</code>之外的所有步骤都在使用构建缓存(它们用 <code class="fe mg mh mi mj b"><em class="mf">CACHED</em></code> <em class="mf">标签</em>提到<em class="mf">)。如果我们没有更改<code class="fe mg mh mi mj b">.gitignore</code>文件，那么<code class="fe mg mh mi mj b">COPY</code>步骤(<em class="mf"> step5/5 </em>)也会从构建缓存中被提取出来。因此，我们应该总是将可能导致缓存未命中的指令放在docker文件的末尾。</em></p><p id="8daa" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在，如果我们使用<code class="fe mg mh mi mj b">$ docker images</code>命令再次看到这些图像，我们将看到一个带有<code class="fe mg mh mi mj b">express:latest</code>标签和唯一SHA256摘要值的新图像。我们可以使用这个标签值和<code class="fe mg mh mi mj b">IMAGE ID</code>来识别一个图像，以执行一些操作，比如从它创建一个容器或者删除它。</p><p id="45a7" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们删除id为<code class="fe mg mh mi mj b">64cbafb8165a</code>的未标记图像。要删除图像，我们使用<code class="fe mg mh mi mj b">$ docker <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/rmi/" rel="noopener ugc nofollow" target="_blank">rmi</a></code>命令(<em class="mf"> rmi代表删除图像</em>)。如果从这个映像创建的容器仍然在运行，那么您需要在这个命令中使用<code class="fe mg mh mi mj b">--force</code>或<code class="fe mg mh mi mj b">-f</code>标志。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/5e844084dacd5572de414eaf2f6e1c29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zJeIjMzfDB0ZrgC7J2Tcww.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">64cbafb8165a</figcaption></figure><p id="a877" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果我们要删除第二个图像，我们可以使用<code class="fe mg mh mi mj b">$ docker rmi 78de5f4b5437</code>命令和<code class="fe mg mh mi mj b">$ docker rmi express:latest</code>命令。如果我们使用<code class="fe mg mh mi mj b">$ docker rmi express</code>命令，默认情况下它会扩展为<code class="fe mg mh mi mj b">$ docker rmi express:latest</code>命令，所以它也能工作。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/598bb718c306df465714e1c2a672dc71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SM3mNF32MuSO3vpQ_qKrpA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$码头工人检查</figcaption></figure><p id="a995" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">您可以使用<code class="fe mg mh mi mj b">$ docker <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/inspect/" rel="noopener ugc nofollow" target="_blank">inspect</a> &lt;image_id|image_name&gt;</code>命令查看JSON格式的图像信息。在上面的截图中，我们只提取了由<code class="fe mg mh mi mj b">docker inspect</code>返回的JSON的<code class="fe mg mh mi mj b">Config</code>属性，而<code class="fe mg mh mi mj b">python -m json.tool</code>用于美化JSON。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="58c5" class="mr ms it bd li mt mu mv mw mx my mz na ki nb kj nc kl nd km ne ko nf kp ng nh bi translated">运行和管理容器</h1><p id="3e0b" class="pw-post-body-paragraph lj lk it ll b lm ni kd lo lp nj kg lr ls nk lu lv lw nl ly lz ma nm mc md me im bi translated">我希望你还和我在一起。到目前为止，我们已经成功创建了一个Docker映像，它将作为创建容器的蓝图。容器是一个正在运行的应用程序。我们的<code class="fe mg mh mi mj b">express</code>图像包含一个HTTP服务器应用程序，当我们从它创建一个容器时，它将运行docker文件中的<code class="fe mg mh mi mj b">CMD</code>指令指定的<code class="fe mg mh mi mj b">$ node server</code>命令。</p><p id="8d1c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">为了从图像创建一个容器，我们使用了<code class="fe mg mh mi mj b">$ docker <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/run/" rel="noopener ugc nofollow" target="_blank">run</a> [options] &lt;image&gt;</code>命令，其中<code class="fe mg mh mi mj b">image</code>参数是图像的惟一SHA256 ID，或者图像名称(<em class="mf"> repo:tag </em>)和<code class="fe mg mh mi mj b">options</code>是可选标志，用于控制正在运行的容器的行为。</p><p id="5f8f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">首先，当我们使用<code class="fe mg mh mi mj b">docker run</code>创建一个容器时，Docker将调用与<code class="fe mg mh mi mj b">CMD</code>指令相关的命令来启动应用程序，在我们的例子中是<code class="fe mg mh mi mj b">node server</code>。如果该命令退出(<em class="mf">完成</em>，集装箱将被停止。在我们的例子中，<code class="fe mg mh mi mj b">node server</code>命令停止进程，所以容器将永远不会停止运行，除非我们发送一个<strong class="ll jd">停止信号</strong> ( <em class="mf">例如通过按CTRL-C </em>)。</p><blockquote class="nn no np"><p id="06af" class="lj lk mf ll b lm ln kd lo lp lq kg lr nq lt lu lv nr lx ly lz ns mb mc md me im bi translated"><em class="it">💡</em>您应该使用<code class="fe mg mh mi mj b">--interactive</code>或<code class="fe mg mh mi mj b">-i</code>和<code class="fe mg mh mi mj b">-t</code>或<code class="fe mg mh mi mj b">--tty</code>标志将信号从主机上打开的终端传递到容器。您可以使用<code class="fe mg mh mi mj b">-it</code>标志作为组合标志，以交互模式启动容器。</p></blockquote><p id="54d3" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们需要使用<code class="fe mg mh mi mj b">--publish</code>或<code class="fe mg mh mi mj b">-p</code>标志将流量从主机发送到容器，因为正在运行的容器不使用主机的端口。该标志的值为<code class="fe mg mh mi mj b">host_port:container_port</code>。在我们的例子中，我们已经公开了HTTP服务器的<code class="fe mg mh mi mj b">8000</code>端口( <code class="fe mg mh mi mj b"><em class="mf">SERVER_PORT</em></code> <em class="mf"> env变量</em>的<em class="mf">默认值)，我们将使用<code class="fe mg mh mi mj b">-p "9000:8000"</code>值将流量从主机上的<code class="fe mg mh mi mj b">9000</code>端口发送到容器的<code class="fe mg mh mi mj b">8000</code>端口。</em></p><blockquote class="nn no np"><p id="ff0e" class="lj lk mf ll b lm ln kd lo lp lq kg lr nq lt lu lv nr lx ly lz ns mb mc md me im bi translated"><em class="it">💡</em>如果一个容器公开了多个端口，我们可以在<code class="fe mg mh mi mj b">docker run</code>命令中有多个<code class="fe mg mh mi mj b">-p</code>标志。如果您想自动将主机的随机端口分配给容器的暴露端口，则使用<code class="fe mg mh mi mj b">-P</code>或<code class="fe mg mh mi mj b">--publish-all</code>标志。</p></blockquote><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/0e9beb426fd6d5108ce23b78e176c14f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y-_8QW5JCo4cq8PXN1bPBA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker运行</figcaption></figure><p id="4cee" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">使用<code class="fe mg mh mi mj b">$ docker run -p "9000:8000" express:latest</code>命令，我们从<code class="fe mg mh mi mj b">express:latest</code> ( <em class="mf"> ID: 78de5f4b5437 </em>)映像创建一个容器，并将流量从主机的<code class="fe mg mh mi mj b">9000</code>端口发送到容器的<code class="fe mg mh mi mj b">8000</code>端口。所以我们打开浏览器，访问<code class="fe mg mh mi mj b">http://localhost:9000</code>网址。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/75c28a339603155062ebc0fa148a5b88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*HE6U58GO6zeOSDZ4_1skcQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(<a class="ae lh" href="http://localhost:9000" rel="noopener ugc nofollow" target="_blank"> http://localhost:9000 </a>)</figcaption></figure><p id="9254" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在容器内部运行的HTTP服务器按照应用程序中设计的JSON格式返回用户列表。只要上面的终端打开，该服务器就会运行。要停止容器，我们只需要通过终止HTTP服务器来退出进程。通常，我们通过按<code class="fe mg mh mi mj b">CTRL+C</code>来实现，但这次不行。在运行Node.js进程时，我们需要使用<code class="fe mg mh mi mj b">--init</code>标志。更多阅读从<a class="ae lh" href="https://github.com/nodejs/docker-node/blob/master/docs/BestPractices.md#handling-kernel-signals" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">这里</strong> </a>。</p><p id="d0bf" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">因为我们不能离开当前的终端，所以让我们打开一个新的终端窗口并查看正在运行的容器。要查看正在运行的容器，我们使用<code class="fe mg mh mi mj b">docker <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/ps/" rel="noopener ugc nofollow" target="_blank">ps</a></code>或<code class="fe mg mh mi mj b">docker container ls</code>命令。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oq"><img src="../Images/4c7764bf7101a7cb8ff3224f34df7e95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JWSs-ZZ8-XcxS8V9mPt0vw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker ps</figcaption></figure><p id="5d0c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">从上面的结果中，我们可以看到ID为<code class="fe mg mh mi mj b">9b18ffbe6ed2</code>的容器启动并运行了15分钟。它是根据<code class="fe mg mh mi mj b">express:latest</code>图像创建的，其名称为<code class="fe mg mh mi mj b">hopeful_euler</code>。这个唯一的名称是由Docker自动分配的，但是我们可以使用<code class="fe mg mh mi mj b">--name</code>标志提供一个自定义名称，它将用于识别一个容器。上述结果还显示了打开的端口及其与主机的连接方式。</p><p id="a06c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们停止容器，我们使用<code class="fe mg mh mi mj b">$ docker stop &lt;container&gt;</code>命令，其中<code class="fe mg mh mi mj b">container</code>是<code class="fe mg mh mi mj b">CONTAINER ID</code>或唯一名称。一旦容器停止，第一个终端将退出，您将无法在浏览器中访问<code class="fe mg mh mi mj b">http://localhost:9000</code> URL。</p><p id="d3ea" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">一旦容器不再运行，它就不会出现在<code class="fe mg mh mi mj b">$ docker ps</code>结果中。为了查看运行和非运行容器的完整列表，我们在这个命令中使用了<code class="fe mg mh mi mj b">-a</code>或<code class="fe mg mh mi mj b">--all</code>标志。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oq"><img src="../Images/52a247132785a7e0198c8318451efb6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dAjHD-LDbeGx3b8nV80JiQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker ps -a</figcaption></figure><p id="f9d0" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">您可以使用<code class="fe mg mh mi mj b">$ docker <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/restart/" rel="noopener ugc nofollow" target="_blank">restart</a> &lt;container&gt;</code>命令重启停止的容器。如果你想暂停正在运行的容器，你可以使用<code class="fe mg mh mi mj b">$ docker <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/pause/" rel="noopener ugc nofollow" target="_blank">pause</a> &lt;container&gt;</code>命令。为了解除暂停的容器，我们使用<code class="fe mg mh mi mj b">$ docker <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/unpause/" rel="noopener ugc nofollow" target="_blank">unpause</a> &lt;container&gt;</code>命令。</p><p id="cd13" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们从<code class="fe mg mh mi mj b">express:latest</code>映像创建一个新容器，而不是重启停止的容器。这一次，我们将使用<code class="fe mg mh mi mj b">--init</code>标志，并为我们的新容器命名。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/bafec23b886065a13eeea5ff4ff0d663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OfV50ltgEz3Mog14LVskMg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker运行</figcaption></figure><p id="870a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在我们可以使用<code class="fe mg mh mi mj b">CTRL-C</code>来停止正在运行的节点流程，这将停止容器并从终端退出。要移除容器，我们使用<code class="fe mg mh mi mj b">$ docker <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/rm/" rel="noopener ugc nofollow" target="_blank">rm</a> &lt;container&gt;</code>命令。您可能需要使用<code class="fe mg mh mi mj b">-f</code>或<code class="fe mg mh mi mj b">--force</code>标志来移除正在运行的容器。</p><blockquote class="nn no np"><p id="4359" class="lj lk mf ll b lm ln kd lo lp lq kg lr nq lt lu lv nr lx ly lz ns mb mc md me im bi translated"><em class="it">💡</em>如果你想自动移除存在的容器，使用<code class="fe mg mh mi mj b">--rm</code>标志和<code class="fe mg mh mi mj b">$ docker run</code>命令。</p></blockquote><p id="7149" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在，你会想，如果我必须在生产中使用这个容器，我是否需要保持终端打开。这听起来不太理想。嗯，你是对的。我们不想让容器进程(<em class="mf">服务器</em>)与终端耦合，而是希望它作为后台进程运行。为了在后台运行容器，或者更准确地说，在<strong class="ll jd">分离模式</strong>下，我们需要使用<code class="fe mg mh mi mj b">-d</code>或<code class="fe mg mh mi mj b">--detach</code>标志。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/95978ca0e58e59b569f7c17710394c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cycx8I3Fsi9vdGZKa1DWdA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker运行</figcaption></figure><p id="caa2" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">当我们在分离模式下运行容器时，<code class="fe mg mh mi mj b">$ docker run</code>命令返回容器的SHA256 ID并退出终端会话。从<code class="fe mg mh mi mj b">$ docker ps</code>命令的结果可以看出，容器正在后台运行。您可以使用<code class="fe mg mh mi mj b">$ docker stop</code>命令来停止容器，这将停止容器中的HTTP服务器进程。</p><p id="bd02" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">您可以通过在<code class="fe mg mh mi mj b">$ docker run</code>命令中提供额外的参数来覆盖默认的<code class="fe mg mh mi mj b">CMD</code>命令。为此，我们需要使用<code class="fe mg mh mi mj b">-it</code>标志以交互模式启动容器，这样我们就可以从主机上打开的终端控制容器的外壳。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi os"><img src="../Images/d4f6ce170f8f321f69da9d8efb9e07dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*mSmXTWpWXMcbcwOpK_6AOQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker运行</figcaption></figure><p id="7784" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这里，我们用<code class="fe mg mh mi mj b">sh</code>命令覆盖默认的<code class="fe mg mh mi mj b">CMD</code>命令(<em class="mf"> node server.js </em>)来启动一个shell会话。shell进程将在容器的<code class="fe mg mh mi mj b">WORKDIR</code>目录中启动。在那里，我们可以手动启动和存在HTTP服务器。一旦我们退出这个shell进程(<em class="mf">使用</em> <code class="fe mg mh mi mj b"><em class="mf">exit</em></code>)，容器将会停止，因为它唯一保持其活动的进程已经死亡。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="0baf" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我已经<a class="ae lh" href="https://medium.com/sysf/understanding-docker-image-tags-and-publishing-images-to-docker-hub-b7a4f900f201" rel="noopener"> <strong class="ll jd">在Docker Hub上以<code class="fe mg mh mi mj b"><a class="ae lh" href="https://hub.docker.com/r/thatisuday/express-example" rel="noopener ugc nofollow" target="_blank">thatisuday/express-example</a></code>的名字发布了</strong> </a>这张Docker图片。因此，您可以使用<code class="fe mg mh mi mj b">$ docker pull thatisuday/express-example</code>命令从Docker Hub下载它，或者使用<code class="fe mg mh mi mj b">$ docker run -it --init thatisuday/express-example</code>命令直接运行它。如果您不想在创建容器时启动服务器，请使用<code class="fe mg mh mi mj b">$ docker run -it --init thatisuday/express-example sh</code>来代替。</p><p id="ed34" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">您可以从下面的GitHub资源库中找到本课中使用的示例的docker文件和源代码。如果您想改进这个图像或它的文档，请随时提出拉取请求。</p><div class="ot ou gp gr ov ow"><a href="https://github.com/course-one/docker-express-example" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd jd gy z fp pb fr fs pc fu fw jc bi translated">课程-一/码头-快速-示例</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">一个用于创建sample express . js HTTP server GitHub的Docker项目是超过5000万开发人员的家园…</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">github.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk lb ow"/></div></div></a></div><h2 id="d5ee" class="nx ms it bd li of og dn mw oh oi dp na ls oj ok nc lw ol om ne ma on oo ng iz bi translated">资源:</h2><ol class=""><li id="0f5a" class="pl pm it ll b lm ni lp nj ls pn lw po ma pp me pq pr ps pt bi translated">Dockerfile最佳实践:<a class="ae lh" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/develop/develop-images/docker file _ best-practices/</a></li><li id="4a3c" class="pl pm it ll b lm pu lp pv ls pw lw px ma py me pq pr ps pt bi translated">https://docs.docker.com/engine/reference/commandline/cli/<a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/cli/" rel="noopener ugc nofollow" target="_blank"/></li><li id="ddc3" class="pl pm it ll b lm pu lp pv ls pw lw px ma py me pq pr ps pt bi translated">Docker引擎API:【https://docs.docker.com/engine/api/ T4】</li></ol></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pz"><img src="../Images/e3da3bf1cee07cd997d46904bbbf70b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t4VSpLEAu4Gmg-GweZ3RvA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(<a class="ae lh" href="http://thatisuday.com" rel="noopener ugc nofollow" target="_blank"><strong class="bd li"/></a>/<a class="ae lh" href="https://github.com/thatisuday" rel="noopener ugc nofollow" target="_blank"><strong class="bd li">GitHub</strong></a>/<a class="ae lh" href="https://twitter.com/thatisuday" rel="noopener ugc nofollow" target="_blank">/<strong class="bd li">Twitter</strong></a>/<a class="ae lh" href="https://stackoverflow.com/users/2790983/uday-hiwarale" rel="noopener ugc nofollow" target="_blank"><strong class="bd li">stack overflow</strong></a><strong class="bd li"/>/<a class="ae lh" href="https://www.instagram.com/thatisuday/" rel="noopener ugc nofollow" target="_blank"><strong class="bd li">insta gram</strong></a>)</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qa"><img src="../Images/fdebb498630e863a0129025be5b74fb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/1*Cj3GjJSU7reYw49BYdQfpw.gif"/></div></figure></div></div>    
</body>
</html>