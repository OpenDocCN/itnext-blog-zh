<html>
<head>
<title>How to build your own secure image processing service with Imaginary and Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Imaginary和Kubernetes构建自己的安全图像处理服务</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-build-your-own-secure-image-processing-service-with-imaginary-and-kubernetes-cf124649047c?source=collection_archive---------2-----------------------#2019-01-13">https://itnext.io/how-to-build-your-own-secure-image-processing-service-with-imaginary-and-kubernetes-cf124649047c?source=collection_archive---------2-----------------------#2019-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4ca3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前一段时间，有人让我看一下关于用亚马逊CloudFront &amp; Lambda@Edge 调整图片大小的文章，看看是否有用。</p><p id="9ee0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我对它有一些想法，因为它涉及lambda函数，该函数将在每个图像请求上执行&amp;向s3存储桶读写文件</p><p id="df00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Lambda在每次开始执行请求以响应事件通知或invoke调用(包括来自控制台的测试调用)时都对请求进行计数。您需要为所有职能部门的请求总数付费</p><p id="476c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">持续时间是从您的代码开始执行的时间开始计算，直到它返回或终止，四舍五入到最接近的100毫秒。<br/>价格取决于你分配给函数的内存量</p><p id="f0ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">λ@ Edge函数以50毫秒的粒度进行计量</p><p id="b647" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还将在S3驱动器中填充越来越多的图像，以满足每个分辨率的要求，因为它们将在图像处理后由Lambda函数写回存储器，并为其提供服务</p><blockquote class="km kn ko"><p id="cec9" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">有了一些闲置的CPU站着烧钱，用它来处理我们自己的图像岂不是很酷？</p></blockquote><p id="5b9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我发现<a class="ae kl" href="https://github.com/h2non/imaginary" rel="noopener ugc nofollow" target="_blank">是虚构的</a>，它已经有了所有docker的东西，所以把它放在Kubernetes是一件轻而易举的事情，所以这个PoC诞生了</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/3af2a18ae371e0b538781d05dd19511e.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*0hE-1RDdWYrSPuMpHnlZug.png"/></div></figure><h1 id="0d94" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">虚构的</h1><p id="8706" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/h2non/imaginary#benchmarks" rel="noopener ugc nofollow" target="_blank"> Fast </a> HTTP <a class="ae kl" href="http://microservices.io/patterns/microservices.html" rel="noopener ugc nofollow" target="_blank">微服务</a>用Go编写，用于高层图像处理，由<a class="ae kl" href="https://github.com/h2non/bimg" rel="noopener ugc nofollow" target="_blank"> bimg </a>和<a class="ae kl" href="https://github.com/jcupitt/libvips" rel="noopener ugc nofollow" target="_blank"> libvips </a>支持。<code class="fe me mf mg mh b">imaginary</code>可作为私有或公共的HTTP服务用于海量图像处理，对<a class="ae kl" href="https://github.com/h2non/imaginary#docker" rel="noopener ugc nofollow" target="_blank">Docker</a>&amp;<a class="ae kl" href="https://github.com/h2non/imaginary#heroku" rel="noopener ugc nofollow" target="_blank">Heroku</a>提供一流支持。它几乎是无依赖性的，并且只使用<code class="fe me mf mg mh b"><a class="ae kl" href="http://golang.org/pkg/net/http/" rel="noopener ugc nofollow" target="_blank">net/http</a></code>本地包，没有额外的抽象，以获得更好的<a class="ae kl" href="https://github.com/h2non/imaginary#performance" rel="noopener ugc nofollow" target="_blank">性能</a></p><p id="924e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">支持作为简单的<a class="ae kl" href="https://github.com/h2non/imaginary#http-api" rel="noopener ugc nofollow" target="_blank"> HTTP API </a>公开的多个<a class="ae kl" href="https://github.com/h2non/imaginary#supported-image-operations" rel="noopener ugc nofollow" target="_blank">图像操作</a>，具有额外的可选特性，如API令牌授权、URL签名保护、HTTP流量节流策略和对web客户端的CORS支持</p><p id="d523" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe me mf mg mh b">imaginary</code>可以从HTTP POST有效负载、服务器本地路径或远程HTTP服务器读取图像，支持JPEG、PNG、WEBP，如果<code class="fe me mf mg mh b">libvips@8.3+</code>使用正确的库绑定进行编译，还可以选择TIFF、PDF、GIF和SVG格式</p><p id="fc70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe me mf mg mh b">imaginary</code>能够输出JPEG、PNG和WEBP格式的图像，包括它们之间的透明转换</p><p id="fac3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe me mf mg mh b">imaginary</code>还可选地支持图像占位符回退机制，以防图像处理错误或任何性质的服务器错误，因此即使在错误的情况下，图像也将始终由服务器根据HTTP响应正文和内容MIME类型返回，透明地匹配预期的图像大小和格式</p><p id="9177" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它在内部使用了<code class="fe me mf mg mh b">libvips</code>，这是一个用C编写的强大而高效的图像处理库，需要<a class="ae kl" href="http://www.vips.ecs.soton.ac.uk/index.php?title=Speed_and_Memory_Use" rel="noopener ugc nofollow" target="_blank">低内存占用</a>，通常比使用最快的ImageMagick和GraphicsMagick设置或Go native <code class="fe me mf mg mh b">image</code>包快4倍，在某些情况下，它甚至比处理JPEG图像快8倍</p><p id="091d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，看一下<a class="ae kl" href="https://github.com/h2non/imaginary#installation" rel="noopener ugc nofollow" target="_blank">安装</a>步骤、<a class="ae kl" href="https://github.com/h2non/imaginary#command-line-usage" rel="noopener ugc nofollow" target="_blank">使用</a>案例和<a class="ae kl" href="https://github.com/h2non/imaginary#http-api" rel="noopener ugc nofollow" target="_blank"> API </a>文档</p><h1 id="35b9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将它部署到Kubernetes</h1><p id="0ed3" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我的假想部署看起来像这样</p><p id="9b1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你咨询想象中的医生，会有更多的选择</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="83ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要一个服务来连接入口</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="0ca6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后是一个入口(不要忘记更新域)</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="c833" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">签名图像url</h1><p id="55b1" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">Imaginary的文档中有一个很好的例子，在Go how to sign your URL中(不要忘记请求字段的顺序)</p><p id="cd60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我的版本，做了一点改动，给了我一个更好的复制/粘贴网址</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="49e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用到集群后，您应该能够通过加载来测试影像服务</p><p id="0b34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="http://localhost:9000/resize?nocrop=true&amp;type=jpeg&amp;url=https%3A%2F%2Fwww.google.com%2Flogos%2Fdoodles%2F2015%2Fgoogles-new-logo-5078286822539264.3-hp2x.gif&amp;width=200&amp;sign=9Rawdy5gEmqGTRgxUOO7fFMYegivSQd1jNSuJljY2PM" rel="noopener ugc nofollow" target="_blank"> http:// &lt;你的服务url &gt; /resize？no crop = true&amp;type = JPEG&amp;URL = https % 3A % 2F % 2f www . Google . com % 2f GOOS % 2f oodles % 2f 2015% 2f Googles-new-logo-5078286822539264.3-hp2x . gif&amp;width = 200&amp;sign = 9 rawdy 5 gemqgtrgxuo 7 ffmyegivisvsd 1 jnsujjljy2pm</a></p><p id="f007" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，上面的示例URL假设您在我的示例中使用signKey。如果您使用了不同的密钥，则需要生成新的URL签名</p><h1 id="3ef8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">全部缓存！</h1><p id="3e80" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">如果你使用的是AWS，你可以在整个设置的前面放一个CloudFront发行版，并在边缘利用图像缓存来减轻后端的负载。只有当图像由于LRU而从缓存中掉出时，才会发生图像操作，因此图像越受欢迎，从后端请求的图像就越少</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/b5c6cbcdd1ed5badccc89125c9181288.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*ZBZBFdoVDf3Pbhs1-wSr1w.png"/></div></figure><p id="52cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想象谷歌有一些类似于<a class="ae kl" href="https://aws.amazon.com/cloudfront/" rel="noopener ugc nofollow" target="_blank"> CloudFront </a>和<a class="ae kl" href="https://www.cloudflare.com" rel="noopener ugc nofollow" target="_blank"> CloudFlare </a>的服务，可能也能提供这项服务</p><h1 id="64b5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结束语</h1><p id="2f56" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我在这篇文章中随意引用了入口清单。实际上，根据您的环境，让Kubernetes中的ingress工作起来可能是一个非常复杂的设置，我建议您花时间适当地研究一下哪种解决方案最适合您的使用情况</p><p id="229b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我个人推荐扎兰多的<a class="ae kl" href="https://github.com/zalando/skipper" rel="noopener ugc nofollow" target="_blank"> Skipper。在我们工作的生产环境中，这对我很有帮助。顺便说一句，你可以在这里读到关于</a><a class="ae kl" href="https://medium.com/@roffe/kubernetes-in-production-shopgun-2c280f0c0923" rel="noopener">的文章</a></p></div></div>    
</body>
</html>