# 角度模式 1:模块组织

> 原文：<https://itnext.io/angular-patterns-1-modules-organisation-d3b2224ec4cf?source=collection_archive---------3----------------------->

在现实生活的项目中与 Angular 一起工作，我开发了自己的一套模式，用于在大型复杂的应用程序上组织可伸缩的 Angular 代码。我认为分享它们会很有用。

我试着把它们分成小文章，尽可能简洁明了。

该系列的其他文章:

*   [2:如何认真编写可复用组件](/angular-patterns-2-how-to-write-seriously-reusable-components-96be16568abc)
*   [3:复杂页面的灵活可扩展设计](https://medium.com/@adrdilauro/angular-patterns-3-flexible-and-scalable-design-of-complex-pages-c35f327ac50)

![](img/cde381e283f13a4d1934f12fc6e58113.png)

**懒加载模块**

在我看来，我总是把我正在做的项目分成一组页面，这些页面分组在不同的惰性加载模块中。

我认为这种心理结构来自于我的 Ruby on Rails 背景，在不同的控制器中有类似的动作划分。这两个概念非常不同，但相似之处依然存在，因为将你必须做的事情归类到一个高层次的项目列表中总是有益的，每个项目包含一个子列表。

为了决定你的惰性加载模块的结构，你要做的第一件事就是看需求，并且清楚地写下在用户旅程中被访问的所有不同的 URL。Url = page =这种情况下，如果用户刷新浏览器，他会返回到他正在查看的那个 HTML。

当你有了完整的页面列表，你需要将它们分组到不同的惰性加载模块中，**试图优化它们之间的共享依赖关系**。共享依赖=放在样板文件中的可重用组件。

> 如果两个页面依赖于一组非常相似的可重用组件，那么将它们放在同一个惰性加载模块中。

以这种方式对页面进行分组对性能非常有利，因为您可以最大限度地减少依赖于同一个可重用组件的延迟加载模块的数量。

假设页面 P1 依赖于可重用组件 A、B、C，页面 P2 依赖于 A、B、d。如果你把 P1 和 P2 放在两个不同的延迟加载模块中，他们每个人都有 A 和 B 的副本，因此，对于每个人来说，最终的包可能比它可能的要大。

当然，不要对此疑神疑鬼，有些情况下，您无法避免一个组件在两个不同的模块中重复。您还必须考虑到，像 WebPack 这样的工具在优化包方面变得越来越复杂，所以您总是可以依赖用于生产的比用于开发的更轻的包。所以，这只是一个很好的经验法则，如果你从一开始就开始优化，当应用程序增长时，维护起来会更容易。

**页面组件和可重用组件**

我总是倾向于重用任何组件，并且只使用根组件来获取正确的可重用组件并将它们放在 HTML 中。这样做了一段时间后，我发现我所有的项目都假设了一个精确的结构:

让我们看看相应的文件夹结构

文件夹“p_edit”中的文件“component.ts”是我声明页面/posts/:id/edit 的根组件的地方。这种组件的 HTML 只不过是我在另一个文件夹中定义的必要的可重用组件的捆绑包。

然后，在惰性加载模块的路由中，我将子路径“/:id/edit”指向正确的根组件:

最后，这是惰性加载模块的样子(包括上面路由的导入)

该模块确切地声明了两个根页面组件，并且不导出任何内容(因为编写它的目的只是为了延迟加载)。

SharedModule 是您应该随处导入的模块，它包含您想要全局使用的公共组件和指令。在官方文档中有大量关于共享模块模式的文档。

**命名法**

您已经注意到 I 命名空间文件夹和组件/模块名称。这非常有助于保持事物的条理和清晰，也避免了重复同一个名字的风险

*   ll_…代表“懒装”
*   p_…代表“页面”
*   f_…代表“特性”

在组件/模块名称中，相同的命名空间一个接一个地嵌套，如下所示:

您可以清楚地看到，这是“编辑”页面的根组件，包含在延迟加载的模块“帖子”中。

另外，我喜欢的另一件事是避免为每个文件名重复命名空间。我只是将每个文件简单地称为“component.ts”或“component.html”，然后您可以通过查看其内容的名称或其在文件夹结构中的位置来推断它是什么组件。这有助于保持文件夹结构的可读性。

**可重复使用的组件**

在官方教程中，包含可在整个应用程序中重用的组件包的模块被称为“功能模块”:这就是为什么我习惯于将所有可重用的组件放在一个名为“功能”的文件夹中，并以字母“f_…”开头命名它们。

然而，我个人喜欢使用可重用组件的方式比文档中建议的方式更“极端”。

围绕文档中所谓的“功能模块”的常见模式是将一堆组件、指令和管道放在一起，这些组件、指令和管道可以作为工具在其他地方使用。一种可重用的工具库。这种“特性模块”的例子有 RouterModule、CommonModule、RxJs 以及大部分可以在 Angular 环境中使用的东西。

这些模块的工作方式与 Ruby on Rails 中的帮助器非常相似(当然不同之处在于它们是分开的，并且您可以准确地包含您需要的帮助器)。我从现在开始将这种类型的模块称为“**助手模块**；我通常把这些模块放在它们自己的名为“helpers”的文件夹中，并以字母“h_…”作为前缀。

> 助手模块=包含大量可重用工具(指令、组件、管道)的模块

现在，虽然这种捆绑助手模块的方式很有用，但当我想要实现真正的、广泛的可重用性时，我仍然发现这是不够的。

每当我为特定页面开发新组件时，我都希望能够(1)定义组件所依赖的输入和输出的通用列表，(2)将它打包成允许我在任何需要的地方无缝重用它的东西。

为了做到这一点，我需要定义一个只导出一个组件的模块，这就是我个人现在更喜欢称之为“**特性模块**”:一个包含一个特性的模块。当我需要使用我的组件时，我在相应的惰性加载模块中导入该模块，并从页面的根组件(或其子组件)中调用该组件。

> 特征模块=仅包含一个可重用组件(特征)的模块

这种方法与包含几个工具的助手模块之间存在一些概念上的差异:

**辅助模块:**

*   一个模块包含几个组件和指令
*   潜在地，这样的组件和指令可以在我的特定应用程序的上下文之外使用
*   通常，大多数组件/指令都是导出的
*   导出的组件通常以某种方式相互关联，但可以独立使用，所以每个组件都有自己的 CSS 范围

**功能模块:**

*   一个模块对应一个可重用组件
*   该组件不太可能在我的应用程序环境之外重用
*   该模块只导出一个组件:内部可能需要几个子组件来构建最终的可重用组件，但是这些组件只是被声明，而不是被导出
*   模块代表一个特定的、独立的 HTML 块，它只有一个 CSS 文件:内部子组件没有自己的 CSS

好，让我们来看一个例子:在我们的应用程序中，对于一个特定的页面，我们必须开发一个属于一个相册的片段图像的垂直列表；在设计中，列表底部有一个“加号”按钮，用于添加新图像。

片段图像列表看起来像是我想在将来重用的东西，所以我将以下文件夹添加到我的“功能”中:

在这种情况下，我们只需要一个子组件(single_image)，但根据具体情况，可以有多个子组件。

在模块中，我声明了两个组件，但是我只导出了“公共”组件:

注意，只有一个 CSS 文件，位于根文件夹中。

一个有用的技巧是每个文件夹都有一个“index.ts”文件，这样，当您需要导入这个组件时，您就不必每次都疯狂地记住文件是如何在内部命名的。

当然，一旦你开始拥有大量可重用的组件，你可能会寻找一种方法来组织它们:将几个功能组件模块捆绑在一起成为一个更大的模块可能会很好:你将拥有功能模块的模块，等等，这完全取决于你，取决于你需要实现什么。

> 我的想法是，不管你打算如何有效地使用或组织你的组件，最好是找到最小的独立部件，并分别包装。

**总结:我在大型项目中常用的文件夹结构**