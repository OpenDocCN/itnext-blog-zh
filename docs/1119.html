<html>
<head>
<title>How I reverse engineered Notion API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何对API概念进行逆向工程</h1>
<blockquote>原文：<a href="https://itnext.io/how-i-reverse-engineered-notion-api-19480490bbeb?source=collection_archive---------3-----------------------#2018-07-24">https://itnext.io/how-i-reverse-engineered-notion-api-19480490bbeb?source=collection_archive---------3-----------------------#2018-07-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/3c3d3506a3f9c0bdc56ee6f1c48f2078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c0cM8oCZ8PKJFXsgHlN2eg.jpeg"/></div></div></figure><div class=""/><p id="a1bc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://blog.kowalczyk.info/article/88aee8f43620471aa9dbcad28368174c/" rel="noopener ugc nofollow" target="_blank">观念</a>是一个很好的写作工具，但内容却被困在网络应用程序中。</p><p id="0a00" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该公司正在开发一个官方API，但我没有耐心。</p><p id="8a5f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章描述了我如何逆向工程他们的API并创建了一个Go库<a class="ae kw" href="https://github.com/kjk/notionapi" rel="noopener ugc nofollow" target="_blank"> notionapi </a>。</p><h1 id="8b90" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">这一切都始于一次失败。</h1><p id="da0e" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我提取概念内容的第一次尝试是传统的网络抓取。</p><p id="c558" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我发现了一个Python <a class="ae kw" href="https://github.com/shariq/notion-on-firebase" rel="noopener ugc nofollow" target="_blank">脚本</a>，它使用Selenium递归地抓取一个概念页面，并将其发布到Firebase主机。</p><p id="9029" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我把它移植到Node上使用<a class="ae kw" href="https://blog.kowalczyk.info/article/ea07db1b9bff415ab180b0525f3898f6/" rel="noopener ugc nofollow" target="_blank">木偶师</a>(比Selenium更好的技术)。</p><p id="7fce" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这种方法有效，但它仅限于获得由概念应用程序呈现的页面的一字不差的HTML。</p><p id="9906" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望能够改变页面的外观，添加像页脚和页眉和导航栏等元素。</p><p id="38c2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我曾短暂地考虑过尝试从呈现的HTML中重建页面结构，但这充其量只是一大堆丑陋的猜测。</p><h1 id="cbc6" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">灯泡时刻</h1><p id="9ccb" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">像concept这样的现代SPA应用程序通常的工作方式是，它们使用从服务器请求的数据，用JavaScript在客户机上呈现大部分HTML。</p><p id="983e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">快速浏览Chrome开发工具证实了这一理论。</p><p id="328d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当加载一个概念页面时，我看到了像<code class="fe ma mb mc md b">/api/v3/getRecordValues</code>和<code class="fe ma mb mc md b">/api/v3/loadPageChunk</code>这样的XHR请求。</p><figure class="mf mg mh mi gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi me"><img src="../Images/1461cfe6c7af9d080e3f069ba34e0c5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qs7vBkA3SkF6FDLT.png"/></div></div></figure><p id="85ea" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是我的API没有混淆。它以JSON数据的形式返回响应，不难理解字段的含义。</p><p id="50ec" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我可以直接向服务器请求结构，而不是从HTML中推导出结构。</p><h1 id="c575" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">建筑工具</h1><p id="6a5a" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我可以在Chrome dev tools中查看客户端和服务器之间的API请求，但这不是最好的工作流程。</p><p id="522c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的第一步是编写node.js脚本，记录客户端在呈现给定页面时调用的所有XHR请求。</p><p id="cd67" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这比使用开发工具有几个优点:</p><ul class=""><li id="c60e" class="mj mk jb ka b kb kc kf kg kj ml kn mm kr mn kv mo mp mq mr bi translated">我可以过滤掉对第三方服务的请求，比如amplitude、fullstory和intercom</li><li id="0f1e" class="mj mk jb ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated">我可以过滤掉不感兴趣的请求，比如<code class="fe ma mb mc md b">/api/v3/ping</code></li><li id="90be" class="mj mk jb ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated">我可以漂亮地打印JSON</li><li id="f7cd" class="mj mk jb ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated">我可以将捕获的流量写入一个文件，以供进一步分析</li></ul><p id="0460" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">剧本是这样的:</p><figure class="mf mg mh mi gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="93b8" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">大局分析</h1><p id="1459" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">查看捕获的数据后，概念内容的结构并不复杂。</p><p id="6d9c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">包括顶级页面在内的所有内容都是一个块。</p><p id="2148" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">块由一个唯一的id标识，看起来像一个标准的UUID格式。</p><p id="1ef6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">块被排列成一棵树，即一些块具有子块。</p><p id="3518" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">块有元数据，如创建时间、最后编辑时间、版本等。</p><p id="bb29" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有不同种类的块:页面、文本、待办事项、列表项等。</p><p id="4bb4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有些图块具有该图块类型特有的性质。例如，页面块具有<code class="fe ma mb mc md b">title</code>属性。</p><p id="e41a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了获取页面的内容，我们从它的UUID开始，我们可以找到它，因为它是页面url的最后一部分。</p><p id="581d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以发出<code class="fe ma mb mc md b">/api/v3/getRecordValues</code> API来获取页面中的块列表，然后发出<code class="fe ma mb mc md b">/api/v3/loadPageChunk</code>来获取这些块的内容。</p><p id="2e36" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">剩下的工作是弄清楚有哪些类型的块，它们是如何表示的，并编写一些代码来帮助检索数据，并以一种更容易消费的格式呈现数据，以便生成输出，例如定制的HTML。</p><h1 id="f38b" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">测试不同种类的块</h1><p id="8d83" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">概念页面由不同种类的块组成，我们需要知道每个块在JSON响应中是如何表示的。</p><p id="cbd3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了系统地研究它，我为每种类型的块创建了一个测试页面，并使用请求日志脚本查看服务器为该块返回的JSON。</p><h1 id="7898" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">编写Go库</h1><p id="2055" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">下一步是编写一个Go库。</p><p id="b96f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从<code class="fe ma mb mc md b">getRecordValues</code>和<code class="fe ma mb mc md b">loadPageChunk</code>获取样本JSON响应后，我使用<a class="ae kw" href="https://app.quicktype.io/" rel="noopener ugc nofollow" target="_blank"> Quicktype </a>生成Go结构。</p><p id="2bd4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不得不稍微调整它们以适应响应的变化。</p><p id="86b6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">剩下的工作是编写一个helper函数，它抽象出HTTP请求的细节，并返回一个易于使用的描述概念页面的结构。</p><p id="d2fa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该工作的结果是<a class="ae kw" href="https://github.com/kjk/notionapi" rel="noopener ugc nofollow" target="_blank"> notionapi </a> Go包。</p><h1 id="bd22" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">在实践中使用图书馆</h1><p id="e4be" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这不仅仅是一次学术练习。</p><p id="5edc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个博客是由我存储在GitHub库中的markdown文件驱动的。</p><p id="ee89" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的目标是将内容转移到概念，这样我就可以更容易地编辑它，将其转换为HTML并作为我的网站/博客发布。</p><p id="4d7b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这里看到代码<a class="ae kw" href="https://github.com/kjk/blog" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="5dcb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代码的高层结构:</p><ul class=""><li id="b111" class="mj mk jb ka b kb kc kf kg kj ml kn mm kr mn kv mo mp mq mr bi translated">我使用我的Go <a class="ae kw" href="https://github.com/kjk/notionapi" rel="noopener ugc nofollow" target="_blank"> notionapi </a>库从概念下载内容</li><li id="3793" class="mj mk jb ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated">我缓存下载的数据，并将它们存储在git存储库中。这是为了确保即使idea消失了，我也有一份数据的副本，以便更快地调整发布代码(不需要重新下载)，并且对idea服务器更友好(除非绝对必要，否则不需要重新下载)</li><li id="e8e2" class="mj mk jb ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated">我将概念数据转换成HTML，将其包装在我的页面的模板中，并将HTML文件写入磁盘</li><li id="bb9b" class="mj mk jb ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated">我部署到<a class="ae kw" href="https://www.netlify.com/" rel="noopener ugc nofollow" target="_blank">网络生活</a></li></ul></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="2734" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ng">原载于</em><a class="ae kw" href="https://blog.kowalczyk.info/article/88aee8f43620471aa9dbcad28368174c/how-i-reverse-engineered-notion-api.html" rel="noopener ugc nofollow" target="_blank"><em class="ng">blog . kowalczyk . info</em></a><em class="ng">。</em></p></div></div>    
</body>
</html>