<html>
<head>
<title>PubSub to BigTable — Piping your Data Stream in via GCP Cloud Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从PubSub到BigTable——通过GCP云函数将数据流管道化</h1>
<blockquote>原文：<a href="https://itnext.io/pubsub-to-bigtable-piping-your-data-stream-in-via-gcp-cloud-functions-a2ef785935b5?source=collection_archive---------3-----------------------#2019-09-11">https://itnext.io/pubsub-to-bigtable-piping-your-data-stream-in-via-gcp-cloud-functions-a2ef785935b5?source=collection_archive---------3-----------------------#2019-09-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1792" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天，阅读、编写、发布实现无服务器ETL所需的代码。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/8d3309502a620903fcdf87283a6375ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*AWDsSoV8pmJr5VBr9lSlJg.png"/></div></figure><p id="30e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你的老板刚刚宣布，你将在所有东西上安装物联网传感器……我指的是所有东西。现在，您已经收集了所有数据并将其写入数据库。与此同时，前端团队告诉您他们需要亚秒级的响应时间。高管们不断抛出“无服务器”和“NoSQL”这样的时髦词汇……如果你不抓紧时间，他们会开始要求“机器学习”和“区块链”</p><p id="bbf7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个简单的、可扩展的、无服务器的数据移动解决方案。它不像Dataflow那样做所有的技巧和翻转，但它实现起来更快，易于团队合作，并且不需要您学习Apache Beam。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/254247e033fcd252c38641f2e5d6b2a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*bTBd3-CyryRyDkxCjJ2JTQ.png"/></div></figure><p id="79ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TL；GitHub repo博士在<a class="ae kl" href="https://krapes.github.io/pubsub_bigtable/" rel="noopener ugc nofollow" target="_blank">这里</a>可用。</p><h1 id="79e4" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">设置</h1><h2 id="2324" class="lt kw iq bd kx lu lv dn lb lw lx dp lf jy ly lz lj kc ma mb ln kg mc md lr me bi translated">物联网— PubSub — CloudFunction — BigTable</h2><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mf"><img src="../Images/1070eca24cc3d8aba98f984421c0dd2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oVmQwWBG8koIYyhr1LspfQ.png"/></div></div></figure><h2 id="320a" class="lt kw iq bd kx lu lv dn lb lw lx dp lf jy ly lz lj kc ma mb ln kg mc md lr me bi translated">定义</h2><p id="75b5" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated"><strong class="jp ir"> <em class="mp"> —服务</em> </strong></p><ol class=""><li id="d1ce" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated"><strong class="jp ir"> PubSub </strong></li></ol><p id="0b75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PubSub是由GCP提供的发布者-订阅者消息服务。把它想象成AWS世界的SNS或者开源社区的Kafka。完全托管的服务可以在拉或推设置中使用。在拉取场景中，系统充当各种队列，应用程序在其中拉取消息并确认它们被成功处理。在push情况下，PubSub自动将消息推送到订阅端点(在我们的例子中是云函数)，并在函数终止时收到确认(不管它是以“ok”还是“crash”终止)。</p><p id="f931" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<strong class="jp ir">云函数</strong></p><p id="a827" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">云函数是无服务器的计算包，允许开发人员在事件触发时运行一些无状态代码(想想AWS Lambda)。</p><p id="fdbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.<strong class="jp ir"> BigTable </strong></p><p id="5e62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">BigTable是一个托管NoSQL数据库。它使用单个密钥存储库，允许请求延迟低于10ms。</p><p id="6e0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.<strong class="jp ir">无服务器框架</strong></p><p id="149b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无服务器框架是一个用于无服务器应用程序的开源部署框架。对于这个项目，我们将使用它来创建和部署GCP资源。在实践中，这个框架允许可靠的测试，因为相同的资源和配置可以应用于所有的开发、测试和生产环境。</p><p id="8a34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mp"> —连接</em> </strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mz"><img src="../Images/42b9c5bf09025cb6cdbfb034a0921986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s05V5ermarwN47RhdFbwdw.png"/></div></div></figure><ol class=""><li id="489c" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated"><strong class="jp ir">物联网(模拟器)——PubSub</strong></li></ol><p id="20d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个演示中的物联网是基于谷歌公开的<em class="mp"> NYC Taxi </em>数据集的模拟设备。<em class="mp"> mock_sensorData.py </em>脚本将通读CSV文件，并以事件最初发生时的速度发布事件(如时间戳所示),也可以将事件更改为该速度的一个因素。例如，如果我们希望看到一系列事件更快地展开，我们可以将<em class="mp"> —速度因子</em>参数更改为60，表示1分钟内将处理1小时的数据。事件作为PubSub消息发布在<em class="mp"> sensorData_STAGE </em>主题上，稍后将由云函数获取。</p><p id="7b5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<strong class="jp ir"> PubSub — CloudFunction </strong></p><p id="483e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这个项目，我们将使用一个订阅PubSub主题的云函数和一个在消息发布时启动该函数的自动触发器。</p><p id="c785" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.<strong class="jp ir"> CloudFunction — BigTable </strong></p><p id="ed3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了执行ETL和存储数据，云函数将事件消息的内容写入文件。该事件将与一个主键一起存储，该主键是专门为最常见的访问模式提供最佳响应时间而构建的。有关构造分区键的更多信息，请查看Google的<a class="ae kl" href="https://cloud.google.com/bigtable/docs/schema-design" rel="noopener ugc nofollow" target="_blank"> <em class="mp">模式设计</em> </a>页面。</p><h1 id="7d31" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">履行</h1><h2 id="bcb9" class="lt kw iq bd kx lu lv dn lb lw lx dp lf jy ly lz lj kc ma mb ln kg mc md lr me bi translated"><a class="ae kl" href="https://serverless.com/framework/docs/providers/google/guide/installation/" rel="noopener ugc nofollow" target="_blank">无服务器框架服务</a></h2><p id="d68d" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated"><strong class="jp ir"> <em class="mp"> —安装包</em> </strong></p><p id="598c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从零开始构建服务，首先安装带有npm的<a class="ae kl" href="https://serverless.com/framework/docs/providers/google/guide/installation/" rel="noopener ugc nofollow" target="_blank"> <em class="mp">无服务器框架</em> </a>。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="89c9" class="lt kw iq nb b gy nf ng l nh ni">$npm install -g serverless</span></pre><p id="0b71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mp"> —创建服务</em> </strong></p><p id="16dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，使用“create”命令创建一个基本的python服务。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="bd8f" class="lt kw iq nb b gy nf ng l nh ni">$sls create --template google-python --path my-service</span></pre><p id="587b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mp"> —基础解剖学</em> </strong></p><p id="3a50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将生成包含serverless.yml和main.py文件的样板文件包。</p><ul class=""><li id="8911" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk nj mw mx my bi translated"><em class="mp"> Serverless.yml </em></li></ul><p id="b5ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">YML文件是提供设置和部署服务所需的任何和所有信息的基础。在文件内部，定义了名称、区域、提供者以及函数、API端点、触发器和基础设施等内容。</p><ul class=""><li id="49f9" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk nj mw mx my bi translated"><em class="mp"> GCP插件</em></li></ul><p id="868a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无服务器框架通过调用Google的API端点进行基础设施建设来运行。为了正常工作，必须安装GCP插件。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="4e20" class="lt kw iq nb b gy nf ng l nh ni">$npm install --save serverless-google-cloudfunctions</span></pre><ul class=""><li id="a8e5" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk nj mw mx my bi translated"><em class="mp">访问键</em></li></ul><p id="74da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你需要向Google证明你是一个真正的开发者，而不是一个试图用一些疯狂的ETL函数统治世界的黑客。在IAM控制台中创建自己的凭证，将秘密令牌JSON文件保存在安全的位置，并将文件路径粘贴到severless.yml的凭证部分。yml被设置为在您的主目录中查找与您的项目同名的JSON)</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="6c0d" class="lt kw iq nb b gy nf ng l nh ni">**serverless.yml**<br/>credentials: ~/${self:provider.project}.json</span></pre><h2 id="651d" class="lt kw iq bd kx lu lv dn lb lw lx dp lf jy ly lz lj kc ma mb ln kg mc md lr me bi translated">云函数</h2><p id="f579" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated"><strong class="jp ir"> <em class="mp"> —编写处理程序</em> </strong></p><p id="cf33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mp">server less-Google-cloud functions</em>插件通过一个名为<em class="mp"> main.py </em>的python文件引导所有流量。虽然这对于小项目来说可能没什么问题，但我发现当我试图管理<em class="mp">开发、测试、生产</em>环境时，它的装备很差。到目前为止，我发现的最佳解决方案是通过<em class="mp"> main.py </em>文件将事件流定向到单独的<em class="mp"> *_handler.py </em>文件。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="59bc" class="lt kw iq nb b gy nf ng l nh ni">## main.py ##</span><span id="ada0" class="lt kw iq nb b gy nk ng l nh ni">import pubSubReciever_handler<br/>import mock_sensorData_handler</span><span id="077d" class="lt kw iq nb b gy nk ng l nh ni">def pubSubReciever_dev(event, context):<br/>  return pubSubReciever_handler.main(event, context)<br/>def pubSubReciever_test(event, context):<br/>   return pubSubReciever_handler.main(event, context)<br/>def pubSubReciever_prod(event, context):<br/>   return pubSubReciever_handler.main(event, context)</span><span id="cd63" class="lt kw iq nb b gy nk ng l nh ni">def mock_sensorData_dev(event):<br/>   return mock_sensorData_handler.main(event)<br/>def mock_sensorData_test(event):<br/>   return mock_sensorData_handler.main(event)<br/>def mock_sensorData_prod(event):<br/>   return mock_sensorData_handler.main(event)</span></pre><p id="f25e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mp"> —读取来电信息</em> </strong></p><p id="5433" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦您的函数设置好了，它需要做的第一件事就是读取Pubsub消息。从解码出<em class="mp"> base64开始。</em>。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="aeb8" class="lt kw iq nb b gy nf ng l nh ni">data = base64.b64decode(event['data']).decode('utf-8')<br/>print("DATA: {}".format(data))</span></pre><p id="5459" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mp"> —写入BigTable </em> </strong></p><p id="f4fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了数据之后，函数可能会做一些非常酷的转换，然后需要将结果写入BigTable。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="cf7c" class="lt kw iq nb b gy nf ng l nh ni">def writeToBigTable(table, data):</span><span id="8977" class="lt kw iq nb b gy nk ng l nh ni">    timestamp = data['event']['date']<br/>    rts = reverseTimestamp(timestamp)<br/>    row_key = '{}'.format(rts).encode()<br/>    row = table.row(row_key)<br/>    for colFamily in data.keys():<br/>        for key in data[colFamily].keys():<br/>            row.set_cell(colFamily,<br/>                         key,<br/>                         data[colFamily][key],<br/>                         timestamp=timestamp)<br/>    table.mutate_rows([row])<br/>    return data</span></pre><h2 id="e3e9" class="lt kw iq bd kx lu lv dn lb lw lx dp lf jy ly lz lj kc ma mb ln kg mc md lr me bi translated">公共订阅</h2><p id="e718" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated"><strong class="jp ir"> <em class="mp"> —将物联网事件写成题目</em> </strong></p><p id="35d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个项目的目标是通过管道将数据流导入BigTable。因此，要开始整个事情，你需要将你的物联网数据发布到Pubsub。就像云功能中的消息解码一样，所有的数据在发布之前都需要进行编码。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="d873" class="lt kw iq nb b gy nf ng l nh ni">def publish(publisher, topic, events):<br/>   numobs = len(events)<br/>   if numobs &gt; 0:<br/>       logging.info('Publishing {0} events from {1}'.format(numobs, get_timestamp(events[0])))<br/>       for event_data in events:<br/>         publisher.publish(topic,event_data)</span></pre><h1 id="c8a6" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">齐心协力</h1><p id="0ea2" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated"><strong class="jp ir"> <em class="mp"> —创建话题</em> </strong></p><p id="25b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">零零碎碎的东西做好之后，就该把整个东西组装起来了。首先在serverless.yml的资源部分创建一个主题</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="7a47" class="lt kw iq nb b gy nf ng l nh ni">- name: mock_SensorData_${self:provider.stage}<br/>  type: gcp-types/pubsub-v1:projects.topics<br/>  properties:<br/>    topic: sensorData_${self:provider.stage}</span></pre><p id="0aa2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mp"> —订阅功能</em> </strong></p><p id="237d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，在functions部分创建云函数，并为其订阅主题。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="9464" class="lt kw iq nb b gy nf ng l nh ni">pubSubReciever:<br/>    handler: pubSubReciever_${self:provider.stage}<br/>    events:<br/>      - event:<br/>          eventType: providers/cloud.pubsub/eventTypes/topic.publish<br/>          resource:       projects/${self:provider.project}/topics/sensorData_${self:provider.stage}</span></pre><p id="f669" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"><em class="mp">——</em></strong>创建表格</p><p id="4431" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，回到参考资料，声明BigTable集群并定义它的列。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="807f" class="lt kw iq nb b gy nf ng l nh ni">- type: gcp-types/bigtableadmin-v2:projects.instances<br/>      name: projects/${self:provider.project}/instances/iotincoming<br/>      properties:<br/>        parent: projects/${self:provider.project}<br/>        instanceId: iotincoming<br/>        clusters:<br/>          iotcluster:<br/>            defaultStorageType: HDD<br/>            location: projects/${self:provider.project}/locations/${self:provider.region}<br/>        instance:<br/>          displayName: IotIncoming<br/>          type: DEVELOPMENT<br/>    - type: gcp-types/bigtableadmin-v2:projects.instances.tables<br/>      name: incomingraw_${self:provider.stage}<br/>      properties:<br/>        parent: projects/${self:provider.project}/instances/iotincoming<br/>        tableId: incomingraw_${self:provider.stage}<br/>        table:<br/>          granularity: MILLIS<br/>          columnFamilies:<br/>            event:<br/>              gcRule:<br/>                maxNumVersions: 2</span></pre><p id="cffb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mp"> —部署和执行</em> </strong></p><p id="262a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在已经准备好实现你老板所有的ETL梦想了。要部署，运行一个快速的<em class="mp"> sls deploy </em>，然后通过发布到Pubsub主题开始流式传输您的数据。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="2aac" class="lt kw iq nb b gy nf ng l nh ni">$sls deploy --project PROJECTNAME</span><span id="2b53" class="lt kw iq nb b gy nk ng l nh ni">$curl --header "Content-Type: application/json" \<br/>  --request POST \<br/>  --data '{"limit": NUMER_OF_EVENTS, "speedFactor": VELOCITY_OF_SIMULATION, "project": PROJECT_NAME}' \<br/>  https://REGION-PROJECT_NAME.cloudfunctions.net/FUNCTION_NAME_STAGE_NAME</span></pre><h1 id="92b2" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">收集你的劳动成果</h1><p id="453b" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated"><strong class="jp ir"> <em class="mp"> —从表中读取</em> </strong></p><p id="ba7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当一切都结束并且尘埃落定之后，您将可以访问BigTable中的数据。Google的BigTable白皮书中列出了一些不同的选项，但我们发现最有用的方法是将数据流式传输到字典中。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="080d" class="lt kw iq nb b gy nf ng l nh ni">from google.cloud import bigtable<br/>from google.cloud.bigtable import column_family<br/>from google.cloud.bigtable import row_filters<br/><br/><br/>client = bigtable.Client(project=project_id, admin=True)<br/>instance = client.instance(instance_id)<br/>table = instance.table(table_id)<br/><br/>def streamToDict(partial):<br/>    def dc(byte):<br/>        return byte.decode("utf-8")<br/>    newDict = {}<br/>    for row in partial:<br/>        newDict[dc(row.row_key)] = {}<br/>        for col in row.cells.keys():<br/>            newDict[dc(row.row_key)][col] = {}<br/>            for key in row.cells[col].keys():<br/>                newDict[dc(row.row_key)][col][dc(key)] = dc(row.cells[col][key][0].value)<br/>    return newDict<br/>    <br/>    <br/>partial = table.read_rows(limit=3)<br/>response = streamToDict(partial)<br/>for key in response.keys():<br/>    print(response[key])<br/>    print()</span></pre><h1 id="bdff" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">结论</h1><p id="6a45" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">要查看完整的实现<em class="mp">，请参见<a class="ae kl" href="https://krapes.github.io/pubsub_bigtable/" rel="noopener ugc nofollow" target="_blank"> GitHub页面</a>。</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi nl"><img src="../Images/c3aad19375f533b6073e2cbf50781551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SeW5ltxFfiQMRvKYjBJQVQ.png"/></div></div></figure><p id="ae5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mp"> —性能</em> </strong></p><p id="2d60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这项服务能够以亚秒级的速度接收、处理和存储所有数据。我们注意到的唯一缺点是PubSub不保证消息按顺序传递。这意味着，有时，如果我们读的速度和写的速度一样快，我们会看到数据点A和C，然后在下一次读取时，我们会看到A、B和C。在我们的例子中，BigTable键被设计为创建日期时间顺序，我们不需要在数据点被写入PubSub后几毫秒读取数据点，所以这没什么大不了的。然而，这是需要记住的事情。</p><p id="9109" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mp"> —展望</em> </strong></p><p id="4895" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">展望未来，这个ETL为扇出架构提供了一个很好的基础。为特定任务构建更多函数并将PubSub主题链接在一起的能力使得顺序和并行处理成为可能。而云功能的隔离性质使得该服务非常适合与团队合作，并且在其中一个流程失败时也很健壮。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi nm"><img src="../Images/267b05972dd37e20ef075102578f9529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AZC3tN9PSqMRwjjs.png"/></div></div></figure></div></div>    
</body>
</html>