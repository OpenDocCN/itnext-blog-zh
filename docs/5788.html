<html>
<head>
<title>The Outbox Pattern in Event-Driven ASP.NET Core Microservice Architectures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">事件驱动的ASP.NET核心微服务架构中的发件箱模式</h1>
<blockquote>原文：<a href="https://itnext.io/the-outbox-pattern-in-event-driven-asp-net-core-microservice-architectures-10b8d9923885?source=collection_archive---------0-----------------------#2021-05-26">https://itnext.io/the-outbox-pattern-in-event-driven-asp-net-core-microservice-architectures-10b8d9923885?source=collection_archive---------0-----------------------#2021-05-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="636c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何用RabbitMQ、C#、实体框架和事务性发件箱模式构建弹性架构</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/20e223f20e7c3b0e59cd58985cf1cb88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2XzNHj4sM_IbYyo2hH-Tgw.png"/></div></div></figure><p id="7dae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一步，您将创建<strong class="kt ir">两个微服务</strong>。每个微服务<strong class="kt ir">都有自己的数据库</strong>。他们使用<strong class="kt ir">事件向RabbitMQ事件总线</strong>发布变更。(如果你已经在我的<a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/how-to-build-an-event-driven-asp-net-core-microservice-architecture-e0ef2976f33f?source=friends_link&amp;sk=5f9f08a726f5e261a032a7bd5caa636a">上一篇文章</a>中实现了，你可以跳过这一部分)。接下来，您将<strong class="kt ir">看到消息是如何丢失的</strong>，例如当消息总线关闭时。</p><p id="16b5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在第二部分中，您将应用<a class="ae ln" href="https://microservices.io/patterns/data/transactional-outbox.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">事务发件箱模式</strong> </a>并查看它<strong class="kt ir">如何防止丢失消息</strong>。</p><p id="114a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后一步，添加发布者和订阅者<strong class="kt ir">确认</strong>和<strong class="kt ir">重复/无序消息处理</strong>。</p><h2 id="7259" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">内容</h2><ol class=""><li id="c5cc" class="mh mi iq kt b ku mj kx mk la ml le mm li mn lm mo mp mq mr bi translated">创建。网络核心微服务和交换消息</li><li id="2fbe" class="mh mi iq kt b ku ms kx mt la mu le mv li mw lm mo mp mq mr bi translated">实现事务发件箱模式</li><li id="56cc" class="mh mi iq kt b ku ms kx mt la mu le mv li mw lm mo mp mq mr bi translated">(可选)测试实现</li><li id="fc8f" class="mh mi iq kt b ku ms kx mt la mu le mv li mw lm mo mp mq mr bi translated">添加发布者通知、确认和弹性消息处理</li><li id="faae" class="mh mi iq kt b ku ms kx mt la mu le mv li mw lm mo mp mq mr bi translated">最后的想法和展望</li></ol></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="aaa6" class="ne lp iq bd lq nf ng nh lt ni nj nk lw jw nl jx lz jz nm ka mc kc nn kd mf no bi translated">1.创建。网络核心微服务和交换消息</h1><p id="2f04" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la np lc ld le nq lg lh li nr lk ll lm ij bi translated">关于如何创建微服务和配置RabbitMQ ，请参见我之前的文章。</p><p id="ba8e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ns">这将为您提供以下组件和工作流程:</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/11040c13d289478c08ba552405110324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HdhCYNbYhiF4_Pt708ZCcg.png"/></div></div></figure><p id="0359" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在微服务和RabbitMQ容器“some-rabbit”都应该在运行。<strong class="kt ir">使用用户服务的REST API </strong>创建和修改用户<strong class="kt ir">确保一切正常</strong>。用户服务应该将事件发送到事件总线，由Post服务处理它们。并且用户数据库中的用户与帖子数据库中的用户同步。</p><h2 id="7069" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">邮件丢失</h2><p id="6ae9" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la np lc ld le nq lg lh li nr lk ll lm ij bi translated">停止RabbitMQ容器:</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="fbb5" class="lo lp iq nv b gy nz oa l ob oc">C:\dev&gt;docker stop some-rabbit</span></pre><p id="0b93" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用Swagger UI在用户服务中创建用户:</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="fb67" class="lo lp iq nv b gy nz oa l ob oc">{<br/> "name": "Chris2",<br/> "mail": "chris2@chris2.com",<br/> "otherData": "Some other data"<br/>}</span></pre><p id="26d2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">无法访问RabbitMQ服务器:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/989df7e29b1c4f1dac4d05bea9a9f455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WKlblqy35DDue5czDi43rg.png"/></div></div></figure><p id="9396" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用户在用户数据库中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/8eebe1d67333c4dc66a1324bb7b16cb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*I7-FOm_OoNMzl9d3mRo8qA.png"/></div></figure><p id="e9a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">事件丢失，因此用户不在post数据库中，微服务现在不一致。在本指南的下一步，你将看到如何解决这个问题。</strong></p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="c56d" class="ne lp iq bd lq nf ng nh lt ni nj nk lw jw nl jx lz jz nm ka mc kc nn kd mf no bi translated">2.实现事务发件箱模式</h1><p id="5af9" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la np lc ld le nq lg lh li nr lk ll lm ij bi translated">在指南的这一部分中，您将向UserService项目添加事务性发件箱模式，以防止丢失消息。</p><blockquote class="of og oh"><p id="53cf" class="kr ks ns kt b ku kv jr kw kx ky ju kz oi lb lc ld oj lf lg lh ok lj lk ll lm ij bi translated"><em class="iq">如果你想了解事务发件箱模式的细节和概念，你可以在:</em><a class="ae ln" href="https://microservices.io/patterns/data/transactional-outbox.html" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://microservices . io/patterns/data/transactional-outbox . html</em></a>获得更多信息</p></blockquote><p id="43ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">创建IntegrationEvent实体:</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="d015" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将其添加到用户服务上下文:</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="c753" class="lo lp iq nv b gy nz oa l ob oc">public DbSet&lt;UserService.Entities.IntegrationEvent&gt; IntegrationEventOutbox { get; set; }</span></pre><p id="cee4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">修改用户控制器</strong></p><p id="d65d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">PutUser和PostUser中的代码启动一个事务，并更新/插入用户实体。在同一事务中，它将IntegrationEvent插入到数据库中，而不是直接发布事件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="1569" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">将发布者创建为BackgroundService </strong></p><p id="7acc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">IntegrationEventSenderService轮询数据库并将所有未完成的事件发送到RabbitMQ:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure><blockquote class="of og oh"><p id="26d7" class="kr ks ns kt b ku kv jr kw kx ky ju kz oi lb lc ld oj lf lg lh ok lj lk ll lm ij bi translated">持续轮询数据库并不好。您将在下一步中改进轮询。</p></blockquote><p id="ccc4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将IntegrationEventSenderService作为HostedService添加到Startup.cs:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="fe9a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ns">延伸阅读:</em> <a class="ae ln" href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/background-tasks-with-ihostedservice" rel="noopener ugc nofollow" target="_blank"> <em class="ns">用IHostedService和BackgroundService类</em> </a>实现微服务中的后台任务</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="515a" class="ne lp iq bd lq nf ng nh lt ni nj nk lw jw nl jx lz jz nm ka mc kc nn kd mf no bi translated">3.(可选)测试实现</h1><p id="a924" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la np lc ld le nq lg lh li nr lk ll lm ij bi translated">现在是测试一切是否按预期运行的好时机:</p><p id="a923" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">删除user.db </strong>以便创建数据库模式，包括发件箱表</p><p id="e1ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">删除post.db ，这样两个数据库都是空的</p><p id="626a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">启动RabbitMQ容器:</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="992a" class="lo lp iq nv b gy nz oa l ob oc">C:\dev&gt;docker start some-rabbit</span></pre><p id="a14b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在Visual Studio中启动用户服务</p><p id="cf22" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">使用Swagger UI在用户服务中创建一个用户</strong>:</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="fee4" class="lo lp iq nv b gy nz oa l ob oc">{<br/> "name": "Chris",<br/> "mail": "chris@chris.com",<br/> "otherData": "Some other data"<br/>}</span></pre><p id="6f95" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">事件的发送被记录到控制台:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/b8aa04cc8483ebe7c7c1b39598309f1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eEhRvp20AWEzhGIWgptryA.png"/></div></div></figure><p id="e6f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">停止RabbitMQ容器</strong>:</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="7157" class="lo lp iq nv b gy nz oa l ob oc">C:\dev&gt;docker stop some-rabbit</span></pre><p id="731b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">使用Swagger UI在用户服务中创建另一个用户</strong>:</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="9243" class="lo lp iq nv b gy nz oa l ob oc">{<br/> "name": "Chris2",<br/> "mail": "chris2@chris2.com",<br/> "otherData": "Some other data"<br/>}</span></pre><p id="d02e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">IntegrationEventSender无法发送消息，每5秒记录一次RabbitMQ异常:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/488b30042aa77f8d6f27356e5beca7b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a0p5DBdIihZnACjGo04A1w.png"/></div></div></figure><p id="14a5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">启动后期服务</strong>(没有自动重启逻辑)</p><p id="7e79" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">启动RabbitMQ容器</strong>:</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="61c8" class="lo lp iq nv b gy nz oa l ob oc">C:\dev&gt;docker stop some-rabbit</span></pre><p id="7904" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">IntegrationEventSender发送消息:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/74644f413b84a482997a847cd3cb90f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a33Luv8n_d1Yk22hPQQxQw.png"/></div></div></figure><p id="87b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">祝贺您:您的发件箱实现工作正常！</strong></p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="618a" class="ne lp iq bd lq nf ng nh lt ni nj nk lw jw nl jx lz jz nm ka mc kc nn kd mf no bi translated">4.添加发布者通知、确认和弹性消息处理</h1><p id="c927" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la np lc ld le nq lg lh li nr lk ll lm ij bi translated">插入或更新用户实体<strong class="kt ir">通知发布者</strong>，因此只有当有新条目时<strong class="kt ir">才会从发件箱表中加载数据。用户实体的<strong class="kt ir">版本字段</strong>允许<strong class="kt ir">处理消费者中的重复或无序消息</strong>。<strong class="kt ir"> RabbitMQ发布者确认，持久消息和确认</strong>处理发布者、订阅者或事件总线不工作的情况。</strong></p><p id="5ab5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ns">发件箱模式、发布者通知、确认和版本控制的详细工作流程:</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/2484b069d98057790c4d4c3d15241441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OHnUE_VqIiI3bpdE05XgDQ.png"/></div></div></figure><p id="ecfc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">修改用户实体</strong>以包含版本字段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure><blockquote class="of og oh"><p id="dc69" class="kr ks ns kt b ku kv jr kw kx ky ju kz oi lb lc ld oj lf lg lh ok lj lk ll lm ij bi translated">您可以对生产SQL数据库使用RowVersion。但是SQLite不支持。</p></blockquote><p id="67d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">修改IntegrationEventSender </strong></p><p id="3d49" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它使用CancelationToken在发件箱中有新条目时唤醒。参见第47、49和65行的注释，了解持久消息和发布者确认是如何实现的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure><blockquote class="of og oh"><p id="3777" class="kr ks ns kt b ku kv jr kw kx ky ju kz oi lb lc ld oj lf lg lh ok lj lk ll lm ij bi translated">同步等待发布者确认是非常低效的。如何改进参见<a class="ae ln" href="https://www.rabbitmq.com/tutorials/tutorial-seven-dotnet.html" rel="noopener ugc nofollow" target="_blank">官方RabbitMQ指南</a>。</p></blockquote><p id="8967" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">确保您创建了持久队列:</strong></p><blockquote class="of og oh"><p id="798d" class="kr ks ns kt b ku kv jr kw kx ky ju kz oi lb lc ld oj lf lg lh ok lj lk ll lm ij bi translated">持久队列将在节点启动时恢复，包括其中发布为持久的消息。在恢复过程中，发布为瞬态的消息将被丢弃，即使它们存储在持久队列中。(<a class="ae ln" href="https://www.rabbitmq.com/queues.html" rel="noopener ugc nofollow" target="_blank">https://www.rabbitmq.com/queues.html</a>)</p></blockquote><p id="612d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">修改用户控制器</strong></p><p id="131c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">设置/增加PostUser/PutUser中的版本字段。</p><p id="fd91" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">获取构造函数中的IntegrationEventSender，并在提交事务后调用它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="982e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">修改后期服务项目</strong>中的program.cs</p><ul class=""><li id="5266" class="mh mi iq kt b ku kv kx ky la oq le or li os lm ot mp mq mr bi translated">第78行禁用自动确认</li><li id="a45b" class="mh mi iq kt b ku ms kx mt la mu le mv li mw lm ot mp mq mr bi translated">第75行发送确认</li><li id="0e3f" class="mh mi iq kt b ku ms kx mt la mu le mv li mw lm ot mp mq mr bi translated">第45和64行检查重复的消息</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure><blockquote class="of og oh"><p id="ec91" class="kr ks ns kt b ku kv jr kw kx ky ju kz oi lb lc ld oj lf lg lh ok lj lk ll lm ij bi translated">使用程序。主要不是最优的。您可以将代码移动到后台服务。</p></blockquote><p id="718b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">现在，您可以删除用户并发布数据库，然后测试您的实现，就像您在本指南的第三部分中所做的那样。</strong></p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="69d0" class="ne lp iq bd lq nf ng nh lt ni nj nk lw jw nl jx lz jz nm ka mc kc nn kd mf no bi translated">5.最后的想法和展望</h1><p id="c813" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la np lc ld le nq lg lh li nr lk ll lm ij bi translated">您将发件箱模式添加到了事件驱动架构中，并使其更具弹性。</p><p id="c50a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您必须<strong class="kt ir">调整代码以在生产环境中使用</strong> : <strong class="kt ir">清理代码</strong>并<strong class="kt ir">应用安全最佳实践。</strong>申请。NET核心设计模式、错误处理等。您还应该<strong class="kt ir">优化发布者确认</strong>并<strong class="kt ir">在发布服务</strong>中使用后台服务。</p><p id="019e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以<strong class="kt ir">将发件箱逻辑移动到一个中心位置</strong>比如DbContext或者<strong class="kt ir">使用一个框架比如</strong> <a class="ae ln" href="https://masstransit-project.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> MassTransit </strong> </a>。(这些框架、<strong class="kt ir">传奇、</strong>和<strong class="kt ir">缩放/分片</strong>可能是我下一篇文章的不错选择。)</p><p id="063b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">参见我的其他文章，关于如何<a class="ae ln" href="https://levelup.gitconnected.com/kubernetes-angular-asp-net-core-microservice-architecture-c46fc66ede44" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">将您的ASP.NET核心应用程序部署到Kubernetes，使用Angular作为UI </strong> </a>，以及<a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/databases-in-a-kubernetes-angular-net-core-microservice-arch-a0c0ae23dca9"> <strong class="kt ir">添加MySql和MongoDB数据库</strong> </a>。</p><p id="51e0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你有任何问题、想法或建议，请联系我。</p></div></div>    
</body>
</html>