<html>
<head>
<title>Binary Protocol for JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript的二进制协议</h1>
<blockquote>原文：<a href="https://itnext.io/binary-protocol-for-javascript-cc409e144a3c?source=collection_archive---------3-----------------------#2021-07-19">https://itnext.io/binary-protocol-for-javascript-cc409e144a3c?source=collection_archive---------3-----------------------#2021-07-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/3e72fbd2412028a2d557d799f06c6934.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vUQW73XzI_lOf0AK3Oia-g.png"/></div></div></figure><div class=""/><p id="f2e7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">拥有对JSON的本机支持是开发全栈JavaScript应用程序的乐趣之一。JSON是简单的、无模式的、人类可读的——当我们的数据模型仍然易于变化时，这些特性在开发的早期阶段特别有用。然而，这种灵活性是以运行时的大小和处理开销为代价的。</p><p id="d482" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JSON是一种基于文本的格式，将所有值编码为UTF-8，这导致在处理非文本数据时会产生大小开销。无模式意味着我们必须将数据模型的结构(例如对象键)和数据一起编码。我们在处理时也做了额外的工作，因为我们必须在编码之前将值转换为文本表示，在解析为JSON之前将二进制解码回文本。</p><p id="2ef9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">诚然，这种开销对于一般的web应用程序来说不是问题；通过使用压缩和JavaScript引擎擅长解析JSON，这个问题得到了缓解。然而，也有开销成问题的情况，例如压缩效率低，并且可能增加消息的大小，例如在收集遥测数据时交换小消息，在实时应用中交换数据，或者发送通知。为了解决JSON的这些限制，我们可以采用二进制格式。</p><h1 id="3c2c" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">二进制格式</h1><p id="e047" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在已建立的数据序列化格式<a class="ae ma" href="#568c" rel="noopener ugc nofollow"> </a>中有过多的二进制格式，它们具有各种各样的属性。为了解决JSON的局限性，我们必须关注两个属性:a)它们是否基于模式，b)支持零拷贝操作。</p><p id="704e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与JSON相比，无模式二进制格式(如MessagePack或FlexBuffers)的大小有所减小。这些格式的主要优点是，它们可以作为JSON的替代物，只需很少的工作。然而，a)我们仍然用数据对结构进行编码，因此有很大的开销，b)我们不能进行零拷贝操作。使用基于模式的格式，如协议缓冲区、FlatBuffers或Cap'n Proto，我们可以避免对消息中的结构信息进行编码，尽管以偏移指针的形式存在一些开销。</p><p id="8e26" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个上下文中，零拷贝操作意味着我们能够在不拷贝数据或解码整个消息的情况下查找部分消息。例如，在服务器上，我们可以先检查请求的重要部分，而不用解析整个请求体；在客户端，我们可以部分地解析和呈现大的响应，以最小化我们的FCP <a class="ae ma" href="#6073" rel="noopener ugc nofollow"> </a>时间。这意味着在某些情况下，处理时间可以减少几个数量级。在数据序列化格式中，Cap'n Proto和FlatBuffers支持零拷贝操作，而协议缓冲区、JSON和无模式格式不支持。然而，Cap'n Proto和FlatBuffers都将内存访问速度优先于消息大小，由于数据对齐使用了填充，导致了大小开销。</p><h1 id="37d5" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">带视图的原始缓冲区</h1><p id="0a2c" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">为了实现零拷贝访问的最小化，我们可以使用所谓的原始缓冲区。例如，要对一个JavaScript对象进行编码，我们可以计算它的每个字段所需的大小，按顺序排列它们以导出布局模式，并使用它对ArrayBuffer中的字段进行编码。得到的缓冲区有“原始”数据，没有任何关于其结构的信息。我们可以对它进行整体解码，或者使用布局模式来访问单个字段，因为它对所有同类型的对象都是通用的。我们将需要可选和可变长度字段的指针，但是开销仍然远远小于键编码或数据对齐。</p><p id="0916" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ma" href="https://github.com/zandaqo/structurae#binary-protocol" rel="noopener ugc nofollow" target="_blank">structuraie的View </a>接口正是这样做的:给定一个对象(或数组，或任何支持的类型)的JSON模式，View将计算布局模式，将其存储为原始缓冲区，并创建一个类来处理扩展DataView的缓冲区:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="e7fb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">视图使用JSON模式进行模式定义。除了为开发人员所熟悉之外，使用JSON模式还允许在其他工具中重用模式，比如作为单一事实来源的JSON验证器。架构和所有派生类都是强类型的，以利用ide中的类型提示和智能感知。与其他流行的基于模式的格式不同，View不需要预编译—布局在初始化时计算一次。总的来说，View旨在很好地适应以JSON为中心的架构和现代web应用程序的开发工作流。</p><p id="4892" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">值得注意的是，View的目标并不是在整个全栈JavaScript应用程序中取代JSON。而是最大限度地提高应用程序部分的性能，通过使用零拷贝操作，可以大大减少消息大小并避免额外的解析步骤。我们可以在JSON做不到的所有情况下使用它:受益于二进制编码的大量数据、实时应用程序中或工作进程之间的高速消息交换，或者用于验证的部分消息处理。</p><h1 id="23f8" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">完整堆栈示例</h1><p id="ee12" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">为了展示视图结构的作用，我们将使用一个熟悉的留言板例子；这不是使用二进制的最佳例子，但是更恰当的例子是特定领域的，很难理解。</p><p id="e2dd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想象一下，你正在维护戒酒联合会<a class="ae ma" href="#56a5" rel="noopener ugc nofollow"> </a>当地分会的留言板。让我们定义我们的消息结构:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="9f30" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，在客户端，我们可以使用<code class="fe mh mi mj mk b">MessageView</code>类对消息进行编码。由于它是一个数据视图，我们可以使用Fetch API直接将它作为请求体发送:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="fadb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，在使用Express.js的服务器节点上，我们可以将消息作为缓冲区接收并对其进行操作，而无需解析或复制请求体:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="b5a3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，现在我们可以进行访问控制，检查消息作者是否可以在线程中发布消息，并拒绝未经授权的请求，而无需解析整个请求体:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="939d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从缓冲区读取一个数字比解析JSON快几个数量级，更不用说从长远来看减少了GC的负载。</p><p id="839c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我们可以更进一步。该视图使用一个特殊的类<a class="ae ma" href="https://github.com/zandaqo/structurae#strings" rel="noopener ugc nofollow" target="_blank"> StringView </a>来处理UTF-8编码的字符串，该类使用几个与字符串相关的方法来扩展DataView，这些方法可以对编码的字符串进行操作，而无需将它们解码为JavaScript字符串。比方说，我们决定引入一点审查机制，屏蔽包含“zer b-vord”的消息:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="fd7c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe mh mi mj mk b">view.getView</code>，我们在缓冲区的一部分上实例化了一个DataView(在本例中是一个StringView ),而没有对该部分进行解码，然后使用一个方法在编码的数据内部进行搜索。同样，我们在解析无效请求方面节省了速度和GC压力。</p><p id="a237" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们可以将消息解码成JavaScript对象。在这种情况下，由于我们在创建视图类时提供了构造函数类，所以我们把它放入了一个<code class="fe mh mi mj mk b">BoardMessage</code>实例:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="e35e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">视图还利用了JavaScript引擎使用的隐藏类优化<a class="ae ma" href="#0238" rel="noopener ugc nofollow"> ⁴ </a>:视图不是创建一个空对象<code class="fe mh mi mj mk b">{}</code>并用解码的字段填充它，而是使用一个提供的构造函数(如上例所示)或者为这样的构造函数生成代码，这样每个新对象都用相同数量和顺序的字段进行实例化。这使得对对象的操作速度更快，同时降低了GC压力。</p><p id="fa7f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，通过缩减消息大小、零拷贝零解析检查和序列化优化，我们极大地提高了主板的消息处理能力。让那些不务正业的狼人现在给我们发垃圾邮件吧！</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><ol class=""><li id="568c" class="ms mt jb ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated"><a class="ae ma" href="https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats" rel="noopener ugc nofollow" target="_blank">数据序列化格式的比较</a></li><li id="6073" class="ms mt jb ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><a class="ae ma" href="https://developer.mozilla.org/en-US/docs/Glossary/First_contentful_paint" rel="noopener ugc nofollow" target="_blank">第一幅内容丰富的画</a></li><li id="56a5" class="ms mt jb ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><a class="ae ma" href="https://wiki.lspace.org/%C3%9Cberwald_League_of_Temperance" rel="noopener ugc nofollow" target="_blank">disc world戒酒联盟</a></li><li id="0238" class="ms mt jb ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><a class="ae ma" href="https://engineering.linecorp.com/en/blog/v8-hidden-class/" rel="noopener ugc nofollow" target="_blank"> V8隐藏类</a></li></ol></div></div>    
</body>
</html>