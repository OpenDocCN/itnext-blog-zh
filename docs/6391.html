<html>
<head>
<title>Microservices and how to analyse them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务及其分析方法</h1>
<blockquote>原文：<a href="https://itnext.io/a-microservices-and-how-to-analyse-them-aa6d33f4dcf6?source=collection_archive---------1-----------------------#2021-11-05">https://itnext.io/a-microservices-and-how-to-analyse-them-aa6d33f4dcf6?source=collection_archive---------1-----------------------#2021-11-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4c56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上一篇文章中，我们定义了一个简单的框架来推理我们需要知道什么来实现一个可预测的基于微服务的软件。</p><div class="kl km gp gr kn ko"><a rel="noopener  ugc nofollow" target="_blank" href="/microservices-clearing-up-the-definitions-f679ebb794cb"><div class="kp ab fo"><div class="kq ab kr cl cj ks"><h2 class="bd ir gy z fp kt fr fs ku fu fw ip bi translated">微服务，清理定义</h2><div class="kv l"><h3 class="bd b gy z fp kt fr fs ku fu fw dk translated">在前一篇文章中，我们研究了松散耦合如何导致更大的复杂性。</h3></div><div class="kw l"><p class="bd b dl z fp kt fr fs ku fu fw dk translated">itnext.io</p></div></div><div class="kx l"><div class="ky l kz la lb kx lc ld ko"/></div></div></a></div><p id="38d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将实现一个更正式但简单的框架来找出可能出错的地方，这样我们就可以扩展我们的需求，以可预测的方式处理这些情况。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><p id="280f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上一篇文章中，我们为基于微服务的应用给出了以下定义:</p><ul class=""><li id="69c0" class="ll lm iq jp b jq jr ju jv jy ln kc lo kg lp kk lq lr ls lt bi translated">维护多个状态存储，</li><li id="22d8" class="ll lm iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">在多个存储上运行多个并行操作，</li><li id="bb62" class="ll lm iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">必须能够减轻由此环境引起的特定故障案例</li></ul><p id="b726" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一点要求我们在实现中识别所有潜在的冲突状态，否则我们将无法将可能的失败案例转化回客户端(考虑在输入表单上用红色标出无效值，或者由于资金不足而取消操作)。为了识别这样的问题，我们首先需要知道我们在这个过程中做了什么决定，以及它们如何可能出错。我们的操作将信息读取和/或写入独立的数据存储，彼此独立，其中许多操作可以并行运行。</p><p id="ad8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">他们对潜在互动的任何了解，我们都必须自己设计。</p><p id="ea6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有人可能会说，客户通常不会用请求“轰炸”系统，所以我们需要探索每个潜在失败案例的前提是有缺陷的。一个很好的反驳观点是，如果不知道系统可能发生错误的每一种可能方式，我们实际上就无法知道它的影响。另一个是，软件必须表现正确，即使面对意想不到的甚至邪恶的使用模式，尤其是如果涉及到金钱。这些攻击不仅仅是理论上的，它们<a class="ae lz" href="https://blog.acolyer.org/2017/08/07/acidrain-concurrency-related-attacks-on-database-backed-web-applications/" rel="noopener ugc nofollow" target="_blank">至少从</a><a class="ae lz" href="https://www.researchgate.net/publication/316848790_ACIDRain_Concurrency-Related_Attacks_on_Database-Backed_Web_Applications" rel="noopener ugc nofollow" target="_blank">2017</a>开始就已经公开了。2014年，一家比特币交易所自愿将这个向量确定为其失败的<a class="ae lz" href="https://arstechnica.com/information-technology/2014/03/how-the-worlds-first-bitcoin-bank-was-robbed-blind/" rel="noopener ugc nofollow" target="_blank">原因，还有许多其他案件受到怀疑。</a></p><h2 id="9612" class="ma mb iq bd mc md me dn mf mg mh dp mi jy mj mk ml kc mm mn mo kg mp mq mr ms bi translated">模型</h2><p id="1582" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">如果我们以一个库存管理系统为例，直觉上来说，我们不能出售比我们现有的更多的库存。为了更全面地了解这一需求，我们需要建立一个从存储中删除项目的请求顺序。换句话说，单一种类的检索必须是连续的。否则，如果两个并行请求询问“<em class="my">我们是否有15个cookies，删除它们</em>”，而我们有20个，我们可能会因为允许这两个请求而出现赤字。为了模拟现实生活，每个商店都将正确地运行，并为每个请求正确地序列化这些请求。</p><p id="cd98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，如果我们有一个在多个步骤中更新多个存储的操作，会发生什么呢？继续这个例子，购物者要求购买商品，然后在相同的操作中付款，但是在不同的微服务上的不同步骤中。请记住，我们不是来解决这些问题的，只是来识别它们。让我们把这个正式化。</p><p id="72f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的应用程序有一个操作<strong class="jp ir"> A </strong>，它读写(访问)两个存储器:<strong class="jp ir"> X </strong>和<strong class="jp ir"> Y的数据。A </strong>按以下顺序从存储器中访问信息:<strong class="jp ir"> X </strong>、<strong class="jp ir"> Y </strong>、<strong class="jp ir"> X </strong>、<strong class="jp ir"> Y </strong>。</p><p id="ed75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由<strong class="jp ir"> A⁰ </strong>执行的数据访问可以这样列出:</p><p id="a261" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> X:TA⁰ </strong>，<strong class="jp ir"> Y:TA </strong>，<strong class="jp ir"> X:TA </strong>，<strong class="jp ir"> Y:TA </strong></p><p id="12e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中<strong class="jp ir"> TA </strong> … <strong class="jp ir"> TA⁴ </strong>表示执行这些操作的时间。请记住，这些事件只是操作步骤的连续事件，因为微服务是相互独立的。我们将介绍<strong class="jp ir"> A </strong>，操作<strong class="jp ir"> A </strong>的并行执行，它与<strong class="jp ir"> A </strong> ⁰.处理相同的数据我们的系统现在有以下步骤:</p><p id="28b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> A⁰:X:TA⁰ </strong>，<strong class="jp ir"> A⁰:Y:TA </strong>，<strong class="jp ir"> A⁰:X:TA </strong>，<strong class="jp ir"> A⁰:Y:TA </strong></p><p id="924d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> A :X:TB⁰ </strong>，<strong class="jp ir"> A :Y:TB </strong>，<strong class="jp ir"> A :X:TB </strong>，<strong class="jp ir"> A :Y:TB </strong></p><p id="69e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在这里真正寻找的是这些步骤的可能顺序。一个随机选择的例子是:</p><p id="5ed3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> A⁰:X:TA⁰ </strong>，<strong class="jp ir">一个:X:TB⁰ </strong>，<strong class="jp ir"> A⁰:Y:TA </strong>，<strong class="jp ir"> A⁰:X:TA </strong>，<strong class="jp ir">一个:X:TB </strong>，<strong class="jp ir"> A⁰:Y:TA一个:Y: </strong>，<strong class="jp ir">一个:Y:TB⁴ </strong></p><p id="f5a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为时间对于步骤是唯一的，所以我们可以简化我们的符号:</p><p id="27ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> TA⁰ </strong>，<strong class="jp ir"> TB⁰ </strong>，<strong class="jp ir"> TA </strong>，<strong class="jp ir"> TA </strong>，<strong class="jp ir"> TB </strong>，<strong class="jp ir"> TB </strong>，<strong class="jp ir"> TA，TB </strong></p><p id="356d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，我们如何在这个场景中找到<strong class="jp ir">所有</strong>(潜在的)冲突状态？通过查看这些步骤可能执行的每一个可能的顺序<strong class="jp ir">。</strong></p><figure class="na nb nc nd gt ne gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/3d9da5d36f4071e4893124c730669b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*GzG_wE1l5xRcvsdY_GFoEA.png"/></div></figure><p id="7e37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些步骤的两组时间是{ <strong class="jp ir"> T⁰ </strong>、<strong class="jp ir"> T </strong>、<strong class="jp ir"> T </strong>、<strong class="jp ir"> T </strong> }和{ <strong class="jp ir"> T⁴ </strong>、<strong class="jp ir"> T⁵ </strong>、<strong class="jp ir"> T⁶ </strong>、<strong class="jp ir"> T⁷ </strong> }。我们知道<strong class="jp ir">t⁰</strong>&lt;<strong class="jp ir">t</strong>&lt;<strong class="jp ir"/>&lt;<strong class="jp ir">t</strong>和<strong class="jp ir">t⁴</strong>&lt;<strong class="jp ir">t⁵</strong>&lt;<strong class="jp ir">t⁶</strong>&lt;<strong class="jp ir">t⁷</strong>因为单个操作按顺序执行其步骤(这是为了简化模型，不一定反映真实生活)。所以我们现在需要找到的是这两个集合之间的元素的排序。</p><p id="b5fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在这里取一个捷径，说我们有8个元素的组合<a class="ae lz" href="https://math.stackexchange.com/questions/382174/ways-of-merging-two-incomparable-sorted-lists-of-elements-keeping-their-relative" rel="noopener ugc nofollow" target="_blank">超过4个位置</a>。计算结果数量的公式说明<a class="ae lz" href="https://www.mathcelebrity.com/permutation.php?num=8&amp;den=4&amp;pl=Combinations" rel="noopener ugc nofollow" target="_blank">可在</a>中找到。所以<strong class="jp ir">组合</strong> (8，4)得出70。</p><p id="782c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着我们必须手动检查70个可能的执行命令，以确保我们在分析我们的(两个)并发操作是否总是都达到一些期望的结论时，已经查看了所有可能的情况。</p><p id="911d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">记住两件事。首先，这是一种单一类型的操作，在两个状态存储上工作。很难想象我们之前定义的基于微服务的应用的更小的例子。第二，我们有意将并行执行的数量限制为两个。除了(过度)简化之外，这种限制没有任何理由。事实上，我们可以使用我们早期的模型来计算3个并行操作的可能组合的数量，这将产生<strong class="jp ir">组合</strong> (12，8) = 495。基于我们之前的真实例子，我们可以想象一个攻击者(或故障软件)同时运行数百个这样的事务。很容易看出手动方法是不可维护的。</p><p id="3d6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一篇文章中，我们将探讨目前业界在整体式和分布式系统中使用的安全措施，以及这些安全措施如何帮助我们判断操作的正确性。</p><p id="b1b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lz" href="https://andrasgerlits.medium.com/microservices-reasoning-about-boundaries-8da26c0271cb" rel="noopener">https://andrasgerlits . medium . com/microservice-reasoning-about-boundaries-8da 26 c 0271 CB</a></p></div></div>    
</body>
</html>