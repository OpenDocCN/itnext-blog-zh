<html>
<head>
<title>Having fun deconstructing the localstorage in TypeScript 🤙</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">享受在TypeScript中解构本地存储的乐趣🤙</h1>
<blockquote>原文：<a href="https://itnext.io/having-fun-deconstructing-the-localstorage-in-typescript-e5e99d95aa13?source=collection_archive---------2-----------------------#2022-09-01">https://itnext.io/having-fun-deconstructing-the-localstorage-in-typescript-e5e99d95aa13?source=collection_archive---------2-----------------------#2022-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f4048c31e79b22164af097a165b87dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lvgsaU8SeMInv0Rb"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@katya?utm_source=Papyrs&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Katya Ross </a>在<a class="ae kf" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d43f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我最近用<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" rel="noopener ugc nofollow" target="_blank"> localstorage </a>实现了一些特性。虽然我总是使用接口的<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/Storage/getItem" rel="noopener ugc nofollow" target="_blank"> getItem() </a>方法读取值，但在我最近的工作中，我用存储对象的解构代替了这种方法。</p><p id="ba1b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有特别的原因。我只是喜欢解构事物，非常喜欢😄。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="8677" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">守旧派</h1><p id="50e6" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">回到过去——直到最近几周😉—我可能会实现一个函数来从存储中读取一个字符串化的<code class="fe mo mp mq mr b">object</code>,如下所示:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="1443" class="na lm it mr b gy nb nc l nd ne">type MyType = unknown;<br/><br/>const isValid = (value: string | null): value is string =&gt; [null, undefined, ""].includes(value)<br/><br/>const oldSchool = (): MyType | undefined =&gt; {<br/>  const value: string | null = localStorage.getItem("my_key");<br/><br/>  if (!isValid(value)) {<br/>    return undefined;<br/>  }<br/><br/>  return JSON.parse(value);<br/>};</span></pre><p id="40f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也就是说，在仔细检查其有效性并解析回一个对象之前，我将首先使用<code class="fe mo mp mq mr b">getItem()</code>获得<code class="fe mo mp mq mr b">string</code>值(我将保存在存储器中的对象的字符串化<code class="fe mo mp mq mr b">JSON.stringify()</code>表示)。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="3529" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">新学校</h1><p id="b5c2" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">虽然我现在继续遵循以前的逻辑(“读取、检查有效性和解析”)，但我现在正在解构存储以读取值。</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="586d" class="na lm it mr b gy nb nc l nd ne">const newSchool = (): MyType | undefined =&gt; {<br/>  const { my_key: value }: Storage = localStorage;<br/><br/>  if (!isValid(value)) {<br/>    return undefined;<br/>  }<br/><br/>  return JSON.parse(value);<br/>};</span></pre><p id="9870" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，没有特别的原因，但是，它不是更闪亮吗？👨‍🎨</p><p id="ee86" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种方法在TypeScript中是可行的，因为存储接口——表示<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API" rel="noopener ugc nofollow" target="_blank">存储API</a>——实际上被声明为<code class="fe mo mp mq mr b">any</code>类型的键映射。</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="a7b2" class="na lm it mr b gy nb nc l nd ne">interface Storage {<br/>    readonly length: number;<br/>    clear(): void;<br/>    getItem(key: string): string | null;<br/>    key(index: number): string | null;<br/>    removeItem(key: string): void;<br/>    setItem(key: string, value: string): void;<br/>    // HERE 😃 [name: string]: any;<br/>    [name: string]: any;<br/>}</span></pre></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="725d" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">SSR和预渲染</h1><p id="ba11" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated"><code class="fe mo mp mq mr b">localstorage</code>是<code class="fe mo mp mq mr b">window</code>界面的只读属性，即它只存在于浏览器中。为了防止我的SvelteKit的静态构建在使用时崩溃，我为NodeJS上下文设置了一个<code class="fe mo mp mq mr b">undefined</code>回退值。</p><p id="029d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，除了解构模式之外，我还喜欢将所有内容(😄).所以，我想出了下面的代码片段来解决我的灵感:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="144d" class="na lm it mr b gy nb nc l nd ne">import { browser } from "$app/env";<br/><br/>const newSchool = (): MyType | undefined =&gt; {<br/>  const { my_key: value }: Storage = browser<br/>    ? localStorage<br/>    : ({ my_key: undefined } as unknown as Storage);<br/><br/>  if (!isValid(value)) {<br/>    return undefined;<br/>  }<br/><br/>  return JSON.parse(value);<br/>};</span></pre></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="e7f7" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">一般的</h1><p id="0a4e" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在这一点上，你可能会说“是的，大卫，很好，这很酷，但是，可重用性呢？”。对此，我会回答“拿着我的啤酒，你可以动态解构对象”😉。</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="7150" class="na lm it mr b gy nb nc l nd ne">const newSchool = &lt;T&gt;(key: string): T | undefined =&gt; {<br/>  const { [key]: value }: Storage = browser<br/>    ? localStorage<br/>    : ({ [key]: undefined } as unknown as Storage);<br/><br/>  if (!isValid(value)) {<br/>    return undefined;<br/>  }<br/><br/>  return JSON.parse(value);<br/>};</span></pre></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="d49d" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">摘要</h1><p id="0bd0" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">返回<code class="fe mo mp mq mr b">undefined</code>对于演示来说很方便，但是在实际实现中——比如我今天早上在<a class="ae kf" href="https://papy.rs/" rel="noopener ugc nofollow" target="_blank"> Papyrs </a>(一个web3博客平台)中发布的——使用默认的回退值可能更有用。</p><p id="0716" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，这是我的泛型函数的最终形式，使用有趣的东西，如解构对象、断言和泛型，读取保存在TypeScript的<code class="fe mo mp mq mr b">localstorage</code>中的项目。</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="3b53" class="na lm it mr b gy nb nc l nd ne">import { browser } from "$app/env";<br/><br/>const isValid = (value: string | null): value is string =&gt;<br/>  [null, undefined, ""].includes(value);<br/><br/>const getStorageItem = &lt;T&gt;({<br/>  key,<br/>  defaultValue,<br/>}: {<br/>  key: string;<br/>  defaultValue: T;<br/>}): T =&gt; {<br/>  const { [key]: value }: Storage = browser<br/>    ? localStorage<br/>    : ({ [key]: undefined } as unknown as Storage);<br/><br/>  if (!isValid(value)) {<br/>    return defaultValue;<br/>  }<br/><br/>  return JSON.parse(value);<br/>};</span></pre><p id="76a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无限和超越<br/>大卫</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="35a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更多冒险，请在🖖推特上关注我</p></div></div>    
</body>
</html>