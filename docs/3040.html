<html>
<head>
<title>Angular Monorepo pains</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角单孔疼痛</h1>
<blockquote>原文：<a href="https://itnext.io/monorepo-pains-9064db3b9882?source=collection_archive---------0-----------------------#2019-09-20">https://itnext.io/monorepo-pains-9064db3b9882?source=collection_archive---------0-----------------------#2019-09-20</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><h1 id="20cc" class="jo jp ir bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">以及如何克服它们</h1><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div class="gi gj km"><img src="../Images/05c763f99d54e2ceb543a5a3d0d6e184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*jXZ26bo8TQE1Q0RBMan8kQ.jpeg"/></div><figcaption class="ku kv gk gi gj kw kx bd b be z dk translated">图片借用自<a class="ae ky" href="https://codefresh.io/continuous-integration/using-codefresh-with-mono-repos/" rel="noopener ugc nofollow" target="_blank">https://code fresh . io/continuous-integration/using-code fresh-with-mono-repos/</a>(我找到的最能形象解释monorepos的一个)</figcaption></figure><p id="dfe8" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">几个月前，我们的CTO休假回来，告诉我们他协助了<a class="ae ky" href="https://www.ng-conf.org/" rel="noopener ugc nofollow" target="_blank"> NG Conf 2019 </a>。一次伟大的经历使他得出这样的结论:</p><blockquote class="lx"><p id="6c51" class="ly lz ir bd ma mb mc md me mf mg lw dk translated"><em class="mh">“我们应该像谷歌一样发展，使用单一回购”</em></p></blockquote><p id="39b1" class="pw-post-body-paragraph kz la ir lb b lc mi le lf lg mj li lj lk mk lm ln lo ml lq lr ls mm lu lv lw ik bi translated">(奇怪的是这很像<a class="ae ky" href="https://nrwl.io/" rel="noopener ugc nofollow" target="_blank"> NWRL.io </a>的广告语)。</p><p id="3dae" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">一开始，作为一个资深开发者，这并没有太大的意义。我们公司运行几个项目，每个项目都有自己的git库，每个项目都有自己的文件夹结构、依赖项和部署工具链。当然，过了一段时间，在阅读了大量文章后，我仍然没有发现将我们所有的逻辑都改为<em class="mn"> monorepo </em>有太多的意义，但它最终确实有意义。</p></div><div class="ab cl mo mp hv mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ik il im in io"><h1 id="6761" class="jo jp ir bd jq jr mv jt ju jv mw jx jy jz mx kb kc kd my kf kg kh mz kj kk kl bi translated">顺便问一下，什么是monorepo？</h1><p id="e19c" class="pw-post-body-paragraph kz la ir lb b lc na le lf lg nb li lj lk nc lm ln lo nd lq lr ls ne lu lv lw ik bi translated">我借用<a class="ae ky" href="https://codefresh.io" rel="noopener ugc nofollow" target="_blank"> Codefresh </a>的图应该够清晰了。</p><p id="69a2" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">一个典型的旧式项目通常是单一的，一个巨大的项目，某种程度上解决了组织的需求。可悲的是，monolyth通常缺乏良好的开发实践，是高度耦合的，并且几乎不可能扩展。</p><p id="7473" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">过度简化现实，当组织承认其自身的缺陷时，它通常会试图转移到更好的方法；这是将它能从monolyth中分离出来的东西分离出来，并致力于几个较小的项目，以某种方式解决较小的需求。耦合更少，但是集成每个新层需要大量的工作。这是一个明显的进步，但是对于来自单一宇宙的组织来说，集成无疑是一个灾难。</p><p id="2a6c" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">如果组织中的每个项目或大多数项目在它们之间共享某些组件(前端组件或后端库)，并且在查看源代码后，您发现所有项目之间有太多重复的模块、组件或逻辑，并且许多项目与同一级别的其他项目交互，那么<em class="mn"> monorepo </em>是有意义的。</p><p id="8d60" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">monorepo是一个单一版本控制的存储库，它包含许多独立的项目，就像它们是一个单独的项目一样。这个想法是统一共享代码，避免重复逻辑，促进团队协作和其他相关的魔术。</p><p id="3a3c" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">看起来不错，对吧？整个组织的双赢局面。<br/> Ehmmmm…，好，好，大概<a class="ae ky" href="https://medium.com/@mattklein123/monorepos-please-dont-e9a279be011b" rel="noopener">没那么好</a>，但是好。正如该条所述:</p><blockquote class="nf ng nh"><p id="d28d" class="kz la mn lb b lc ld le lf lg lh li lj ni ll lm ln nj lp lq lr nk lt lu lv lw ik bi translated">坦率的现实是，在规模上，一个组织在代码共享、协作、紧密耦合等方面做得如何。是工程文化和领导力的直接结果，与使用monorepo还是polyrepo无关。</p></blockquote><p id="c34c" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">采用单一回购策略不会没有痛苦。</p></div><div class="ab cl mo mp hv mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ik il im in io"><h1 id="8c65" class="jo jp ir bd jq jr mv jt ju jv mw jx jy jz mx kb kc kd my kf kg kh mz kj kk kl bi translated">如何采用单一回购策略？</h1><p id="0ad3" class="pw-post-body-paragraph kz la ir lb b lc na le lf lg nb li lj lk nc lm ln lo nd lq lr ls ne lu lv lw ik bi translated">有一些工具可以简化这个过程。<a class="ae ky" href="https://hackernoon.com/4-ways-to-go-monorepo-in-2019-ea5d19fc1f08" rel="noopener ugc nofollow" target="_blank"> Hackernoon </a>列举几个:</p><ul class=""><li id="12b7" class="nl nm ir lb b lc ld lg lh lk nn lo no ls np lw nq nr ns nt bi translated"><a class="ae ky" href="https://bit.dev/" rel="noopener ugc nofollow" target="_blank">钻头</a></li><li id="cba0" class="nl nm ir lb b lc nu lg nv lk nw lo nx ls ny lw nq nr ns nt bi translated"><a class="ae ky" href="https://lerna.js.org/" rel="noopener ugc nofollow" target="_blank">蕾娜</a></li><li id="0010" class="nl nm ir lb b lc nu lg nv lk nw lo nx ls ny lw nq nr ns nt bi translated"><a class="ae ky" href="https://git-scm.com/book/en/v2/Git-Tools-Submodules" rel="noopener ugc nofollow" target="_blank"> Git子模块</a></li></ul><p id="fb35" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">正如大多数情况下，可能符合你自己用例的解决方案是高度自以为是的，所以我的建议是<em class="mn">“你自己选毒”</em>。monorepos没有灵丹妙药，所以我会告诉你我们的情况。</p><h1 id="b7ba" class="jo jp ir bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">我们是如何采用单一回购策略的？</h1><p id="f75e" class="pw-post-body-paragraph kz la ir lb b lc na le lf lg nb li lj lk nc lm ln lo nd lq lr ls ne lu lv lw ik bi translated">首先我必须说我们没有使用Hackernoon的任何建议。我们公司以NX.dev关于<a class="ae ky" href="https://nx.dev/angular/fundamentals/monorepos-automation" rel="noopener ugc nofollow" target="_blank"> Monorepos和自动化</a>的文章为起点。</p><p id="d519" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">我们的大多数项目都是带有NodeJS后端的Angular前端项目，其结构如下:</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div class="gi gj nz"><img src="../Images/fa2bdabe3d69ed4465a83a8b373c8fd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*cdockkyG6squhN8tSzhxeg.png"/></div></figure><p id="43bc" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">一个<strong class="lb is"> <em class="mn">前端</em> </strong>文件夹，有自己的<em class="mn"> package.json </em>，一个<strong class="lb is"> <em class="mn">后端</em> </strong>文件夹(前端的后端api)，也有自己的<em class="mn"> package.json </em>和一个<strong class="lb is"> <em class="mn"> toolchain </em> </strong>文件夹(不在镜像中)，有一些部署脚本，通常每个环境一个脚本。</p><p id="a385" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">所以我们的第一个目标是把这个结构转换成一个<em class="mn"> monorepo </em>结构，NX.dev建议的<em class="mn"> monorepo </em>结构。这将导致一个单独的<strong class="lb is"> <em class="mn"> package.json </em> </strong>和一个单独的<strong class="lb is"> <em class="mn"> node_module </em> </strong>文件夹。</p><p id="3842" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">所以痛苦开始了…</p></div><div class="ab cl mo mp hv mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ik il im in io"><h1 id="bcf4" class="jo jp ir bd jq jr mv jt ju jv mw jx jy jz mx kb kc kd my kf kg kh mz kj kk kl bi translated">单报告疼痛</h1><h2 id="05e9" class="oa jp ir bd jq ob oc dn ju od oe dp jy lk of og kc lo oh oi kg ls oj ok kk ol bi translated">痛苦0。拥抱你的monorepo工具</h2><p id="231c" class="pw-post-body-paragraph kz la ir lb b lc na le lf lg nb li lj lk nc lm ln lo nd lq lr ls ne lu lv lw ik bi translated">无论您选择什么工具来迁移项目，都会发生这种情况。您必须了解您选择的cli工具、所有选项(或者希望是大部分选项)、所有参数。正如我之前提到的我们选择了<a class="om on ep" href="https://medium.com/u/2817fb68583?source=post_page-----9064db3b9882--------------------------------" rel="noopener" target="_blank"> Nrwl.io </a>的nx工具作为我们的毒药。</p><p id="1620" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">学习每一个命令变体其实并不困难，你可以在创建自己的<em class="mn"> monorepo </em>项目结构时轻松地学习它们，在我们的例子中，通过遵循<a class="ae ky" href="https://nx.dev/angular/getting-started/getting-started" rel="noopener ugc nofollow" target="_blank">入门指南</a>和Nx教程。</p><p id="8234" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">一步一步的命令行:</p><pre class="kn ko kp kq gu oo op oq or aw os bi"><span id="4967" class="oa jp ir op b gz ot ou l ov ow"># Create your monorepo<br/>npm init nx-workspace monorepo-project</span><span id="d3fd" class="oa jp ir op b gz ox ou l ov ow"># Go to your new project folder<br/>cd monorepo-project</span><span id="416e" class="oa jp ir op b gz ox ou l ov ow"># Install the schematics for each sub-projects<br/>npm install --save @nrwl/angular<br/>npm install --save @nrwl/express<br/>npm install --save @nrwl/node</span><span id="3522" class="oa jp ir op b gz ox ou l ov ow"># Create the container folders for every sub-project to be included<br/># more on this later</span></pre><h2 id="df96" class="oa jp ir bd jq ob oc dn ju od oe dp jy lk of og kc lo oh oi kg ls oj ok kk ol bi translated">痛苦1。在您的单一回购中包含单一回购项目</h2><p id="e583" class="pw-post-body-paragraph kz la ir lb b lc na le lf lg nb li lj lk nc lm ln lo nd lq lr ls ne lu lv lw ik bi translated">您的组织可能来自单一回购宇宙和您的所有项目，无论它们是否共享任何代码、组件或配置，都存在于单一回购中。在我们的例子中，我们使用(仍然使用，因为有一个应用程序不适合<em class="mn"> monorepo </em>)私有位桶回购，克隆每个位桶类似于:</p><blockquote class="nf ng nh"><p id="ff3f" class="kz la mn lb b lc ld le lf lg lh li lj ni ll lm ln nj lp lq lr nk lt lu lv lw ik bi translated">git克隆<a class="ae ky" href="mailto:git@bitbucket.org" rel="noopener ugc nofollow" target="_blank">git@bitbucket.org</a>:your _ organization/your _ single _ repo _ project . git</p></blockquote><p id="eb5e" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">将上面的代码行修改为<em class="mn"> monorepo </em>也可以工作，它将克隆整个巨型项目，其中包含所有子项目。请记住，这将在未来发生，每次您需要在代码中提取最后的更改时，您将提取整个<em class="mn"> monorepo </em>。</p><p id="18a1" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">要做的第一件事是准备你的<em class="mn">单一回购</em>项目结构，以便它包括所有打算由<em class="mn">单一回购</em>吸收的单一回购:</p><pre class="kn ko kp kq gu oo op oq or aw os bi"><span id="1c10" class="oa jp ir op b gz ot ou l ov ow"># Create the container folders for every sub-project to be included<br/>ng g <a class="ae ky" href="http://twitter.com/nrwl/angular" rel="noopener ugc nofollow" target="_blank">@nrwl/angular</a>:application frontend/store<br/>ng g <a class="ae ky" href="http://twitter.com/nrwl/angular" rel="noopener ugc nofollow" target="_blank">@nrwl/angular</a>:application frontend/store-admin<br/>ng g <a class="ae ky" href="http://twitter.com/nrwl/express" rel="noopener ugc nofollow" target="_blank">@nrwl/express</a>:application store --frontendProject=frontend-store<br/>ng g <a class="ae ky" href="http://twitter.com/nrwl/express" rel="noopener ugc nofollow" target="_blank">@nrwl/express</a>:application store-admin --frontendProject=frontend-store-admin<br/>ng g <a class="ae ky" href="http://twitter.com/nrwl/angular" rel="noopener ugc nofollow" target="_blank">@nrwl/angular</a>:lib ui-components<br/>ng g <a class="ae ky" href="http://twitter.com/nrwl/node" rel="noopener ugc nofollow" target="_blank">@nrwl/node</a>:lib server-modules<br/>ng g <a class="ae ky" href="http://twitter.com/nrwl/node" rel="noopener ugc nofollow" target="_blank">@nrwl/node</a>:lib config</span></pre><p id="65e4" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">在上面的示例中，我们生成了以下结构:</p><ul class=""><li id="3bbe" class="nl nm ir lb b lc ld lg lh lk nn lo no ls np lw nq nr ns nt bi translated">前端:<br/> -商店<br/> -商店-管理</li><li id="df1b" class="nl nm ir lb b lc nu lg nv lk nw lo nx ls ny lw nq nr ns nt bi translated">后端:<br/> -商店<br/> -商店-管理</li><li id="b165" class="nl nm ir lb b lc nu lg nv lk nw lo nx ls ny lw nq nr ns nt bi translated">库:<br/>-ui-组件<br/> -服务器-模块<br/> -配置</li></ul><p id="5e4c" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">其中store和store-admin是不同的项目，存在于它们自己的单一回购协议下，并且它们中的每一个都有自己特定的后端。起初，你可能会发现这两个项目有很多共同点。也许是一些UI组件，也许是一些配置；因此，<em class="mn"> monorepo </em>背后的想法之一是最小化(或减少)重复代码。</p><p id="428e" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">到目前为止，我们只有项目占位符，但是项目的真正代码还没有包括在内。因此，我们需要在<em class="mn"> monorepo </em>中包含我们的单一回购代码。</p><p id="886e" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">我是这样做的:</p><pre class="kn ko kp kq gu oo op oq or aw os bi"><span id="a23b" class="oa jp ir op b gz ot ou l ov ow"># Pull latest changes in the develoment branch<br/>git pull</span><span id="af31" class="oa jp ir op b gz ox ou l ov ow"># Create a local feature for including the single repo on the monorepo<br/>git flow feature start singlerepo-store</span><span id="36ac" class="oa jp ir op b gz ox ou l ov ow"># Add the remote for the store frontend<br/>git remote add store-front git@bitbucket:user/store-frontend<br/># Fetch the code from the recently added remote<br/>git fetch store-front<br/># Create a new branch from this remote using the develop branch<br/>git branch store-front-src store-front/develop<br/># Now you are on the store-front-src branch, you can edit<br/># code, create new folders, move files, etc. Be sure to commit any<br/># changes but DO NOT PUSH THEM. We want to keep them local.<br/># Do as many changes required to match the folder structure of <br/># the monorepo. Remember to delete all non-used files.</span><span id="c706" class="oa jp ir op b gz ox ou l ov ow"># Return to the feature branch<br/>git checkout feature/singlerepo-store<br/># Merge the code with the adjusted code from the single repo branch<br/>git merge --strategy-option=theirs --allow-unrelated-histories store-front-src<br/># Make final adjustments to your code, check if everything works. <br/># If you have new dependencies from the single repo, include them <br/># on the package.json and do an npm install</span><span id="4a84" class="oa jp ir op b gz ox ou l ov ow"># Once everything works finish the feature<br/>git flow feature finish singlerepo-store</span></pre><p id="17f9" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">你必须为每个包含在<em class="mn"> monorepo </em>中的子项目重复这些步骤。<br/> <strong class="lb is">重要的</strong>:不要只是照抄&amp;粘贴剧本的台词，试着去理解自己在做什么，为什么要做。将repo URL、项目名称和分支名称更改为您自己的名称。理解，然后让它发挥作用。</p><h2 id="6fbf" class="oa jp ir bd jq ob oc dn ju od oe dp jy lk of og kc lo oh oi kg ls oj ok kk ol bi translated">痛苦2。保存代码历史</h2><p id="1c3e" class="pw-post-body-paragraph kz la ir lb b lc na le lf lg nb li lj lk nc lm ln lo nd lq lr ls ne lu lv lw ik bi translated">在大多数情况下，来自单一回购领域意味着在采用<em class="mn"> monorepo </em>之前已经有了很多发展，因此每次提交都有很多历史。在与git脚本斗争了一段时间后，我了解到<a class="ae ky" href="http://thisbythem.com/blog/preserving-history-when-renaming-files-in-git/" rel="noopener ugc nofollow" target="_blank"> git跟踪内容而不是文件</a>，但我也认为文件重命名或甚至git mv执行都不符合干净地保存代码历史的需要。</p><p id="98d3" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">所以我来到了一个<a class="ae ky" href="https://gist.github.com/emiller/6769886" rel="noopener ugc nofollow" target="_blank">旧脚本(2014) </a>，它使用git filter-branch移动文件，同时保留它们的历史。做什么广告，但是…它很慢。该脚本接受给定的每个参数，并重写整个历史，因此如果您有许多提交，并重命名许多文件，将需要几个小时才能完成。此外，对于许多文件，我的建议是将它们分成块，并在处理完每个文件后提交/推送新的更改。当一个巨大的进程因为一些奇怪的提交而失败时，我用头撞了很多次键盘。</p><p id="040f" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">一个有效的策略是首先使用<em class="mn"> git mv </em>重命名文件，例如，我们必须从<em class="mn">重命名我们所有的后端文件。js </em>至<em class="mn">。ts </em>之后，我们不得不调整代码，使其具有严格的类型，但是将js重命名为ts ( <em class="mn"> Javascript </em>到<em class="mn"> Typescript </em>)是一个起点。</p><p id="54b8" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">为此，我们使用了以下命令行:</p><pre class="kn ko kp kq gu oo op oq or aw os bi"><span id="6825" class="oa jp ir op b gz ot ou l ov ow">find project-folder -name '*.js' | awk -F '.js'  '{ print $1 }' | xargs -i echo "git mv '{}.js' '{}.ts' &amp;&amp; git add -A '{}.ts'"</span></pre><p id="b233" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">这将搜索所有。<em class="mn"> js </em>文件放在<em class="mn">上。/project-folder </em>，剥离<em class="mn">。js </em> out，并生成一个新的命令行，如下所示:</p><pre class="kn ko kp kq gu oo op oq or aw os bi"><span id="bb30" class="oa jp ir op b gz ot ou l ov ow">git mv 'project-folder/src/index.js' 'project-folder/src/index.ts' &amp;&amp; git add -A 'project-folder/src/index.ts'</span></pre><p id="db60" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">请注意引号，这样就不会有文件名包含空格或其他麻烦的特殊字符的问题。执行这个命令可能需要一段时间，但没有<em class="mn"> git-mv-with-history.sh </em>脚本那么长。</p><p id="8656" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">重命名文件后，您可以应用<a class="ae ky" href="https://gist.github.com/emiller/6769886" rel="noopener ugc nofollow" target="_blank">脚本</a>来重写文件夹历史。脚本的注释在用法上非常清楚:</p><pre class="kn ko kp kq gu oo op oq or aw os bi"><span id="2887" class="oa jp ir op b gz ot ou l ov ow"># Given this example repository structure:<br/>#<br/>#   src/makefile<br/>#   src/test.cpp<br/>#   src/test.h<br/>#   src/help.txt<br/>#   README.txt<br/>#<br/># The command:<br/>#<br/>#   git-rewrite-history README.txt=README.md  \     &lt;-- rename to markdpown<br/>#                       src/help.txt=docs/    \     &lt;-- move help.txt into docs<br/>#                       src/makefile=src/Makefile   &lt;-- capitalize makefile<br/>#<br/>#  Would restructure and retain history, resulting in the new structure:<br/>#<br/>#    docs/help.txt<br/>#    src/Makefile<br/>#    src/test.cpp<br/>#    src/test.h<br/>#    README.md</span></pre><p id="a2a8" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">我建议在进行最后的步骤，将单一回购项目包括在<em class="mn"> monorepo </em>中之前，使用关于这个问题的说明调整项目的结构。看看哪些适合您自己的用例。</p><h2 id="c8c0" class="oa jp ir bd jq ob oc dn ju od oe dp jy lk of og kc lo oh oi kg ls oj ok kk ol bi translated">痛苦3。迁移到Angular 8(正面)和Typescript(背面)</h2><p id="5632" class="pw-post-body-paragraph kz la ir lb b lc na le lf lg nb li lj lk nc lm ln lo nd lq lr ls ne lu lv lw ik bi translated">我们公司有几个项目运行在Angular 6上，其他项目运行在Angular 7上。每个后端项目都是使用普通的旧节点开发的。JS Javascript文件。NX.dev工具前端使用Angular 8，后端使用Typescript。</p><p id="f9af" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">迁移到Angular 8是一个相当容易的任务，Angular团队提供了一个迁移的原理图，以及一些<a class="ae ky" href="https://update.angular.io/#7.0:8.0" rel="noopener ugc nofollow" target="_blank">相当清晰的说明</a>，并且两者几乎都处理好了一切。只需运行:</p><pre class="kn ko kp kq gu oo op oq or aw os bi"><span id="b7b2" class="oa jp ir op b gz ot ou l ov ow">ng update @angular/core --from 7 --to 8 --migrate-only</span></pre><p id="afe7" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">你必须仔细检查:</p><ul class=""><li id="5097" class="nl nm ir lb b lc ld lg lh lk nn lo no ls np lw nq nr ns nt bi translated">路由定义，不再使用<em class="mn"> loadChildren:'。/page/page . module # page module '</em>通过字符串但使用动态导入</li><li id="6e6d" class="nl nm ir lb b lc nu lg nv lk nw lo nx ls ny lw nq nr ns nt bi translated">每个<em class="mn"> @ContentChild </em>和<em class="mn"> @ViewChild </em>上的额外参数<em class="mn"> { static: true|false } </em>。您的里程数可能会有所不同，但是静态的:false通常适用于大多数情况。</li><li id="cb76" class="nl nm ir lb b lc nu lg nv lk nw lo nx ls ny lw nq nr ns nt bi translated">任何中断的依赖关系。</li></ul><p id="b202" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">迁移到Typescript可能是一次全新的冒险。在我们的例子中，我们必须通过ES5-ES6代码迁移，然后应用一些类型脚本魔法。请注意，在迁移阶段，您的所有团队都必须参与进来，并且您将每分钟都收到关于<em class="mn">“某些东西不工作”</em>的报告。Typescript很棒，就像Javascript、严格类型化语言和OOP原则之间的完美结合，但是要注意，过去在普通的旧Javascript上工作的东西在从Typescript转换过来后可能就不工作了。</p><p id="6941" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">来自Github上Typescript 3.5  线程的<a class="ae ky" href="https://github.com/microsoft/TypeScript/issues/33272" rel="noopener ugc nofollow" target="_blank"> <em class="mn"> Google反馈:</em></a></p><blockquote class="nf ng nh"><p id="6973" class="kz la mn lb b lc ld le lf lg lh li lj ni ll lm ln nj lp lq lr nk lt lu lv lw ik bi translated">我们相信大多数这些改变都是有意的，旨在改进类型检查，但我们也相信TypeScript团队理解<strong class="lb is">类型检查总是在安全性和人机工程学之间进行权衡。</strong></p></blockquote><p id="4c18" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">痛苦4。分离可重用代码</p><p id="08ed" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">monorepo背后的主要决策之一是重用代码/避免重复代码。当在<em class="mn">单一回购</em>中包含单一回购项目时，一个巨大的任务是找到重复的代码。但不仅仅是可以在库上重构的重复代码，还有共享的UI组件，共享的配置，可以以某种方式重写或抽象的类似方法。</p><p id="fdc8" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">这将需要运行并检查每个子项目的所有代码，然后将一些代码重构为公共或共享模块，然后重复gain，直到您的团队感觉完成为止。除非你这么说，否则这没有终点，这个想法是以一种智能的方式重构代码，而不会破坏团队对每个项目的理解。</p><p id="8012" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">在我们的例子中，每个后端都有一些我们正在使用的ORM的模型定义，这是我和<a class="ae ky" href="https://sequelize.org/" rel="noopener ugc nofollow" target="_blank"> Sequelize </a>之间的爱恨关系。每个子项目共享相同的数据库配置，以及一些安全策略配置和一些外部库配置。所以大部分的工作是将所有的模型定义连接成一个单独的模型库，为所有的子项目所共用，合并所有的配置文件和重构每个子项目的库导入。</p><p id="b613" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">我们最终得到了如下的项目结构:</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div class="gi gj oy"><img src="../Images/9cd652272c1d25b67982608bfed98bbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/format:webp/1*p965_wsP-usel2DeVuCUGQ.png"/></div></figure><p id="2577" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">我们所有的前端项目都在<em class="mn">应用/前端</em>文件夹中，我们所有的后端项目都在<em class="mn">应用/后端。</em></p><h2 id="45a2" class="oa jp ir bd jq ob oc dn ju od oe dp jy lk of og kc lo oh oi kg ls oj ok kk ol bi translated">如何运行monorepo子项目？</h2><p id="816c" class="pw-post-body-paragraph kz la ir lb b lc na le lf lg nb li lj lk nc lm ln lo nd lq lr ls ne lu lv lw ik bi translated">使用<em class="mn"> NX.dev </em>工具创建<em class="mn"> monorepo </em>时，会要求您在<em class="mn"> angular-cli </em>或<em class="mn"> nx-cli </em>之间进行选择。由于我们的项目是带有NodeJS + Express.js后端的基于Angular的前端，我们使用的是<em class="mn"> angular-cli </em>。</p><p id="1b2f" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">另外，NX提供了几个<em class="mn"> npm run </em>脚本来运行每个项目和做其他事情。在幕后，每个脚本都使用带有一些额外参数的<em class="mn"> ng </em>命令，每个<em class="mn"> ng </em>命令都引用<em class="mn"> angular.json </em>文件中的某个部分。</p><p id="1ea5" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">例如，如果我的项目是<em class="mn"> frontend/store、frontend/store-admin、backend/store、backend/store-admin </em>和一些共享库:</p><ul class=""><li id="1758" class="nl nm ir lb b lc ld lg lh lk nn lo no ls np lw nq nr ns nt bi translated"><strong class="lb is"><em class="mn">【NPM启动前端-存储- -o </em> </strong>:运行存储前端项目。额外的双破折号o将-o参数传递给底层的ng命令，以便打开浏览器。您需要传递的任何额外参数都需要前面的双破折号。</li><li id="aa1c" class="nl nm ir lb b lc nu lg nv lk nw lo nx ls ny lw nq nr ns nt bi translated"><strong class="lb is"> <em class="mn"> npm启动后端-商店</em> </strong>:运行商店后端项目。请注意，由于我们的项目位于<em class="mn"> apps/frontend </em>和<em class="mn"> apps/backend </em>文件夹下，因此<em class="mn"> npm start </em>命令的项目名称需要在frontend或backend后面加一个破折号(取决于您想要运行的项目)。</li><li id="3e70" class="nl nm ir lb b lc nu lg nv lk nw lo nx ls ny lw nq nr ns nt bi translated"><strong class="lb is"><em class="mn">NPM run build back end-store-admin--configuration = local-dev:</em></strong>使用<em class="mn"> local-dev </em>环境配置构建商店管理后端项目。当指定不同的环境时，您可以配置构建，以便它根据环境替换一些文件。该项目构建在<em class="mn">dist/apps/back end/store-admin</em>文件夹中。</li></ul><p id="763a" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">假设您已经配置了一个名为<em class="mn"> local-dev </em>的额外环境，它指向一个本地数据库，而不是实际的开发数据库。要使用此环境运行商店后端，您必须执行以下命令:</p><p id="9950" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated"><em class="mn">export NODE _ ENV = local-dev&amp;&amp;NPM run build back end-store-admin--configuration = local-dev&amp;&amp;NODE dist/apps/back end/store-admin/main . js</em></p><p id="5271" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">这个命令将<em class="mn"> NODE_ENV </em>变量设置为<em class="mn"> local-dev </em>(有一点可能你不需要它，除非你有任何依赖于系统环境变量的配置)；使用本地开发设置构建存储管理后端；最后执行编译好的<em class="mn"> main.js </em>文件运行后端。</p><p id="fed2" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">如果记住所有命令参数对你来说很难，你可以在<em class="mn"> package.json </em>文件的<em class="mn">脚本</em>部分添加一个新的<em class="mn">脚本</em>。相信我，无论如何你最终都会知道这些参数的。</p><h2 id="6332" class="oa jp ir bd jq ob oc dn ju od oe dp jy lk of og kc lo oh oi kg ls oj ok kk ol bi translated">痛苦5。调整相关性</h2><p id="0b5e" class="pw-post-body-paragraph kz la ir lb b lc na le lf lg nb li lj lk nc lm ln lo nd lq lr ls ne lu lv lw ik bi translated">重构代码是一回事，许多导入将不得不改变，以便它们可以使用新的共享库和模块。必须添加一些代码行，删除一些代码行，到处都要修改。而当你觉得一切都准备好运行的时候，<strong class="lb is"> <em class="mn">一切都会惨败</em> </strong>(大部分时候)。</p><p id="ed5f" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">那个漂亮的组件库，那些额外的ngPipes，那个NodeJS库，所有那些奇迹:</p><ul class=""><li id="4007" class="nl nm ir lb b lc ld lg lh lk nn lo no ls np lw nq nr ns nt bi translated">没有为角度≥8°的兼容性做好准备；信不信由你，它仍然发生</li><li id="f25f" class="nl nm ir lb b lc nu lg nv lk nw lo nx ls ny lw nq nr ns nt bi translated">不能作为ES6模块导入</li><li id="47a5" class="nl nm ir lb b lc nu lg nv lk nw lo nx ls ny lw nq nr ns nt bi translated">由于缺少@types，无法在Typescript中使用</li></ul><p id="3bb7" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">因此，你必须去每个项目回购(希望他们有)，阅读报告的兼容性问题，更新版本(并打破你自己开发的功能)，应用变通办法。最坏的情况是不得不移除冲突的包，找到可用的替代包，重构更多的代码。</p><p id="9d6c" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">如果你幸运的话，开发团队没有使用一个没有声誉的用户开发的库，而是使用一个背后有巨大社区的用户开发的库，那么调整依赖关系就不会那么痛苦了。不管怎样，这仍然是一种痛苦。</p><h2 id="9a20" class="oa jp ir bd jq ob oc dn ju od oe dp jy lk of og kc lo oh oi kg ls oj ok kk ol bi translated">痛苦6。部署工具链</h2><p id="0db0" class="pw-post-body-paragraph kz la ir lb b lc na le lf lg nb li lj lk nc lm ln lo nd lq lr ls ne lu lv lw ik bi translated">在单个回购宇宙中，部署工具链是"<em class="mn">简单的</em>":</p><ul class=""><li id="cb53" class="nl nm ir lb b lc ld lg lh lk nn lo no ls np lw nq nr ns nt bi translated">听取项目主分支上的更改</li><li id="e6d9" class="nl nm ir lb b lc nu lg nv lk nw lo nx ls ny lw nq nr ns nt bi translated">简单的构建(没有额外的参数)</li><li id="3e58" class="nl nm ir lb b lc nu lg nv lk nw lo nx ls ny lw nq nr ns nt bi translated"><a class="ae ky" href="https://docs.cloudfoundry.org/devguide/deploy-apps/blue-green.html" rel="noopener ugc nofollow" target="_blank">蓝绿部署策略</a>(针对云代工厂或类似的持续交付云服务)。</li></ul><p id="5585" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">在monorepo上，事情不再那么简单了。</p><ul class=""><li id="294b" class="nl nm ir lb b lc ld lg lh lk nn lo no ls np lw nq nr ns nt bi translated">有一个巨大的项目，包括所有其他子项目。如果每个子项目都没有特定的分支，那么当主分支上有新的提交时，您必须禁用自动部署。这是对<strong class="lb is">疼痛<em class="mn">7</em>疼痛</strong>的解释。</li><li id="4409" class="nl nm ir lb b lc nu lg nv lk nw lo nx ls ny lw nq nr ns nt bi translated">编译需要特定的项目参数。好吧，这没那么糟糕，只是在构建指令中增加了几行。</li><li id="19af" class="nl nm ir lb b lc nu lg nv lk nw lo nx ls ny lw nq nr ns nt bi translated">蓝绿色部署保持不变。</li></ul><p id="e91f" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">到目前为止还好吗？没有。问题在于单一回购协议本身。因为所有项目都包含在子项目中，所以它们的依赖项也必须包含在子项目中。如果您有许多不同的项目，预计会有许多库，所以部署规模会在没有必要的情况下增加，只是因为<em class="mn"> npm install </em>命令不知道哪个项目需要哪些库。巨大的<em class="mn"> node_modules </em>文件夹可能会导致部署失败。</p><p id="5dfa" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated"><strong class="lb is"> <em class="mn">我们所做的</em> </strong>:在服务器部署阶段，我们定制了<em class="mn"> package.json </em>文件，这是一个节点脚本的结果，该脚本使用一个包黑名单来构建文件，因此它不包含任何不需要的包。我们特别小心地排除了大型软件包，如<em class="mn"> jest </em>、<em class="mn"> cypress </em>、<em class="mn"> webpack bundle analyzer、</em>和大多数<em class="mn"> angular </em>依赖项。我们的前端项目在编译阶段失败的几率比我们的后端项目在部署阶段失败的几率要小，顺便说一下，IBM部署可能会因为那天风刮得很大而失败…</p><p id="5883" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">我们还对我们的部署工具链做了一些小小的调整，主要是编写脚本来简化未来的部署:</p><ul class=""><li id="af61" class="nl nm ir lb b lc ld lg lh lk nn lo no ls np lw nq nr ns nt bi translated">构建脚本ow包含一个清理行，因此它会删除最终部署中不需要的所有内容。它还指定了必须构建什么项目。其余的几乎和原始的一样，但是构建阶段在克隆项目之后被包含进来。自动部署被禁用，现在每当我们需要一个新的部署，我们必须手动运行任务(也不是那么可怕)。</li><li id="0489" class="nl nm ir lb b lc nu lg nv lk nw lo nx ls ny lw nq nr ns nt bi translated">部署阶段在运行之前进行一些初始检查，这样它就不会在第一次运行时失败，因为第一次运行时没有项目要备份。该脚本将项目、子域名称和应用程序名称作为参数，因此很容易调整每个子项目的设置。只有在少数情况下需要额外的定制。</li></ul><p id="b376" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">不那么痛苦，但无论如何是一种痛苦。它需要检查每个项目的部署工具链，测试它，并设置它。这里还是没有魔法。</p><h2 id="6a08" class="oa jp ir bd jq ob oc dn ju od oe dp jy lk of og kc lo oh oi kg ls oj ok kk ol bi translated">痛苦7。部署单个monorepo子项目</h2><p id="49af" class="pw-post-body-paragraph kz la ir lb b lc na le lf lg nb li lj lk nc lm ln lo nd lq lr ls ne lu lv lw ik bi translated"><em class="mn">单一回购</em>在一个未详细说明的定义中，是指依赖于一个单一回购协议的许多回购协议，或作为一个单一项目的许多项目，它们共享一些共同的组件、配置、模块等。这些项目中的许多都有不同的开发节奏，并且可能比同一个<em class="mn"> monorepo </em>中的其他项目遭受更快的变化。</p><p id="853e" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">据我们所知，Nx tool没有提供一种方式来包含新的应用程序或库，这些应用程序或库存在于其他回购上(就像它们是单一回购应用程序一样)，作为<a class="ae ky" href="https://git-scm.com/book/en/v2/Git-Tools-Submodules" rel="noopener ugc nofollow" target="_blank"> git子模块</a>。所以每个新应用程序都存在于同一个巨大的<em class="mn"> monorepo </em>上。除非你的项目使用一个非标准的分支模型(<em class="mn">注意后面的</em>)，其中每个<em class="mn"> monorepo </em>都有它自己的<em class="mn">“主分支”，</em>每个来自主分支或发布分支的部署将会拖拽可能还没有发布的变更。</p><p id="ff33" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">举个例子，假设你的<em class="mn"> monorepo </em>有如下结构:</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div class="gi gj oz"><img src="../Images/ef0124e4e9dde2881a29cee6ba7b494b.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*H9EyElRuDhHn7sl1ef5GHg.png"/></div><figcaption class="ku kv gk gi gj kw kx bd b be z dk translated">为此做了一个样本项目</figcaption></figure><ul class=""><li id="5abf" class="nl nm ir lb b lc ld lg lh lk nn lo no ls np lw nq nr ns nt bi translated">前端:<br/> -商店<br/> -商店-管理</li><li id="d820" class="nl nm ir lb b lc nu lg nv lk nw lo nx ls ny lw nq nr ns nt bi translated">后端:<br/> -商店<br/> -商店-管理</li><li id="5374" class="nl nm ir lb b lc nu lg nv lk nw lo nx ls ny lw nq nr ns nt bi translated">库:<br/>-ui-组件<br/> -服务器-模块<br/> -配置</li></ul><p id="8ba1" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">假设您的部署链监听任何主分支提交，并在某个云提供商上运行部署管道。</p><p id="ab75" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">自从第一个版本以来，商店管理的前端几乎没有变化，但是商店总是在改进，所以代码变化很大，并且还有许多版本在进行中。如果您的monorepo依赖于单个repo，因为它是一个非常大的项目，每次store项目需要部署时，store-admin也会被部署，即使它没有任何更改。</p><p id="05f0" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">此外，如果在将项目合并到主<em class="mn">分支</em>之前，有任何项目的变更必须被审查和批准(然后触发每一个自动部署)，这些变更将被包括在内，除非团队对每一个必须被有效包括的提交进行精选。</p><p id="a23f" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">挑选是一项单调乏味的任务，所以在部署一些项目时，寻找一种方法来避免它是一个健康的决定，在这些项目中，不是所有的变更都必须包含在兄弟项目中(然而，这是在审查之前)。</p><p id="2d08" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">关于这一点的一些想法:</p><ul class=""><li id="9f1b" class="nl nm ir lb b lc ld lg lh lk nn lo no ls np lw nq nr ns nt bi translated"><strong class="lb is"> <em class="mn">特征基础提交</em> </strong>。每个新功能都作为一个功能分支，在reviewal上发布和合并。如果你的工作流使用特性(如<a class="ae ky" href="https://danielkummer.github.io/git-flow-cheatsheet/" rel="noopener ugc nofollow" target="_blank"> git flow </a>)，应该不会太难。</li><li id="c694" class="nl nm ir lb b lc nu lg nv lk nw lo nx ls ny lw nq nr ns nt bi translated"><strong class="lb is"> <em class="mn">主控分部分项工程</em> </strong>。这种方法更容易，因为<em class="mn">"它只需要"</em>为每个必须部署的项目创建一个新的主分支。如果它包含了还没有被评审的变更，这没有关系，因为这些代码不会被包含在最终的编译中。我所看到的问题是，除非您的团队能够看到所有已评审的提交，否则保留主分支(真正的主分支，而不是每个项目的新主分支)将需要一些额外的工作。</li></ul><p id="7919" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">但是等等，创建主分支或特性分支不是一样的吗，你是在repo中创建新分支吗？的确，这将完全取决于您自己的工作流程。</p><p id="bf49" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated"><strong class="lb is"> <em class="mn">关于非标准分支模型的注意事项</em> </strong>:每个组织都有自己的开发工作流程。</p><ul class=""><li id="d382" class="nl nm ir lb b lc ld lg lh lk nn lo no ls np lw nq nr ns nt bi translated">一个经典的方法是使用<a class="ae ky" href="https://danielkummer.github.io/git-flow-cheatsheet/" rel="noopener ugc nofollow" target="_blank"> git flow </a> : <em class="mn"> master，develop，release，feature，fix </em>建议的分支模型(顺便说一下，我喜欢这个)。</li><li id="7346" class="nl nm ir lb b lc nu lg nv lk nw lo nx ls ny lw nq nr ns nt bi translated">另一个是有几个开发分支，每个团队成员一个，没有特性、修复或发布分支，只有开发、主和阶段(有点像发布分支)。我不喜欢这个特别的，因为如果团队成长，你的项目将会有太多的分支。从长远来看，这是不可用的。</li></ul><p id="d791" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">尝试找到两个世界中最好的一个，并为每个子项目添加一个主分支。是的，分支模型增加了复杂性，但是你会以某种方式<em class="mn">解决</em>你的<em class="mn"> monorepo </em>部署困难。</p></div><div class="ab cl mo mp hv mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ik il im in io"><h1 id="eebc" class="jo jp ir bd jq jr mv jt ju jv mw jx jy jz mx kb kc kd my kf kg kh mz kj kk kl bi translated">monorepos是邪恶的吗？</h1><p id="ab19" class="pw-post-body-paragraph kz la ir lb b lc na le lf lg nb li lj lk nc lm ln lo nd lq lr ls ne lu lv lw ik bi translated">很高兴你问了:)<br/>不，他们并不邪恶，但至少在他们开始被收养的阶段，他们是皮塔饼。在我看来，将所有相关的项目作为一个单一的回购(一个<em class="mn"> monorepo </em>)并不是一个坏主意，但是组织必须为这种变化做好准备，评估如果没有一个<em class="mn"> monorepo </em>是否不能解决这个特殊的需求，或者甚至改变开发工作流程。</p><p id="e22b" class="pw-post-body-paragraph kz la ir lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">而且有可能我会发现更多的痛苦。</p></div></div>    
</body>
</html>