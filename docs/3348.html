<html>
<head>
<title>Why I like Go HTTP client as a Java developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为一名Java开发人员，我为什么喜欢Go HTTP client</h1>
<blockquote>原文：<a href="https://itnext.io/why-i-like-go-http-client-as-a-java-developer-676ea1e698b4?source=collection_archive---------6-----------------------#2019-11-26">https://itnext.io/why-i-like-go-http-client-as-a-java-developer-676ea1e698b4?source=collection_archive---------6-----------------------#2019-11-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a103" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们生活在一个微服务的时代。那些在他们的生态系统中有很多交流。你可能见过所谓的微服务死星:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/a4c60038c5c17919ec53633124bc5ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mZkidifrgL4zIcJKv5_uCQ.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图片由<a class="ae lb" href="http://www.csl.cornell.edu/~delimitrou/papers/2019.asplos.microservices.pdf" rel="noopener ugc nofollow" target="_blank">康乃尔大学</a>的研究人员拍摄</figcaption></figure><p id="3efb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现代互联网的每一次点击都会引发大量的网络呼叫，你可能知道，<a class="ae lb" href="https://blog.acolyer.org/2014/12/18/the-network-is-reliable/" rel="noopener ugc nofollow" target="_blank">网络是不可靠的</a>。这就是为什么在通过网络获取数据时<strong class="jp ir">应该设置请求超时</strong>的原因之一。最好也结合一些其他技术，但这是另一篇文章(甚至是整本书)的主题。</p><h2 id="c1ac" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">为什么要担心超时呢？</h2><p id="61d0" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">设置它们是非常重要的，因为网络可能会失败，你的实例可能会变慢或崩溃。您不希望用户因为1000台服务器中的一台突然关闭而无限期等待。人们讨厌等待，这会影响他们的幸福，因此也会影响你的收入。如果网络调用停滞，您应该放弃它，重试，除非您的集群有问题，否则它最有可能成功。</p><p id="699a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看如何用Java实现它。</p><h2 id="fabc" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">通用Java方法</h2><p id="f39f" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">java中最流行的http客户端是Apache HttpClient。下面是配置请求超时的样子:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">使用Apache HttpClient设置超时</figcaption></figure><p id="8c93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这三者都是不同且独立的。我们在这里面临的最大问题是如何将500毫秒表示为3种不同的超时——应该是100 + 100 + 300还是50 + 50 + 400？更重要的是，我们关心连接超时是否需要200毫秒吗？假设服务器将在50毫秒内完成请求，那么总响应时间将是250毫秒，在大多数情况下— <strong class="jp ir">您不要在意，这完全没问题！</strong></p><p id="e44a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，你不能将超时设置得太大，因为这会导致更长的请求。此外，套接字超时只是从套接字读取的任何连续包之间的超时，<strong class="jp ir">而不是发送回您的整个响应</strong>。</p><p id="5453" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管如此，这是我们使用Apache HttpClient所能做的一切。让我们来看看围棋。</p><h2 id="9b69" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">Go标准库</h2><p id="56d8" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">但是，Go支持整个客户端调用超时:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">使用标准Go http客户端设置呼叫超时</figcaption></figure><p id="93e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们将调用超时设置为2秒，并调用<a class="ae lb" href="http://httpbin.org" rel="noopener ugc nofollow" target="_blank"> httpbin </a>，它将模拟工作1秒钟，之后返回一个响应。启动此功能将导致成功的通话。</p><p id="3fd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们将调用超时设置为1秒，它将失败，并显示类似于given的消息，这正是我们所期待的！</p><pre class="km kn ko kp gt mc md me mf aw mg bi"><span id="c1fb" class="lc ld iq md b gy mh mi l mj mk">2019/11/25 19:06:09 Get <a class="ae lb" href="http://httpbin.org/delay/1" rel="noopener ugc nofollow" target="_blank">http://httpbin.org/delay/1</a>: net/http: request canceled (Client.Timeout exceeded while awaiting headers)</span></pre><p id="618a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，仅配置呼叫超时<strong class="jp ir">并不总是我们能够实现的最佳</strong>。想象一下，有一个又长又重的请求需要10秒钟才能完成。等待10秒钟的响应，并发现服务器一直在尝试建立连接，而实际上并没有做任何工作，这是非常糟糕的。</p><p id="2cb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对此的解决方案？—连接超时。是的，我们之前责备过的那个。结合呼叫超时，它为您的网络交互提供强大的保护:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">使用标准Go http客户端设置呼叫和连接超时</figcaption></figure><p id="2b55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">超过连接超时将会产生我们想要的行为:</p><pre class="km kn ko kp gt mc md me mf aw mg bi"><span id="c82c" class="lc ld iq md b gy mh mi l mj mk">2019/11/25 19:12:25 Get <a class="ae lb" href="http://httpbin.org/delay/5" rel="noopener ugc nofollow" target="_blank">http://httpbin.org/delay/5</a>: dial tcp 54.172.95.6:80: i/o timeout</span></pre><p id="9fe3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Go的标准HTTP客户端给了你很大的灵活性，库也得到供应商的支持——完美的组合，<strong class="jp ir">这就是我非常喜欢它的原因！</strong>现在让我们再一次回到Java世界。</p><h2 id="005f" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">那么，Java是不是注定要失败了？</h2><p id="4eb1" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated"><strong class="jp ir">没有</strong>还有不太流行的替代品，比如<a class="ae lb" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpClient.html" rel="noopener ugc nofollow" target="_blank"> JDK 11 </a> http客户端和<a class="ae lb" href="https://square.github.io/okhttp/" rel="noopener ugc nofollow" target="_blank"> OkHttp </a>，支持调用超时功能。可悲的是，在谷歌上搜索时，这些并不是最热门的结果，所以人们不太了解它们，或者不愿意开始使用它们。</p><h2 id="61e4" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">JDK 11</h2><p id="ac9b" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这是一个由标准库提供的现代http客户端，支持HTTP/1.1、HTTP/2、通过CompletableFuture的异步调用，并提供了方便的api。让我们将这两种超时结合起来:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">使用JDK 11 http客户端设置连接和调用超时</figcaption></figure><p id="ca8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个客户端将分别为连接和调用超时提供漂亮且易于理解的错误消息(特别是与Go相比):</p><pre class="km kn ko kp gt mc md me mf aw mg bi"><span id="055c" class="lc ld iq md b gy mh mi l mj mk">Exception in thread "main" java.net.http.HttpConnectTimeoutException: HTTP connect timed out</span><span id="02a2" class="lc ld iq md b gy ml mi l mj mk">Exception in thread "main" java.net.http.HttpTimeoutException: request timed out</span></pre><h2 id="4423" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">OkHttp</h2><p id="b53d" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">OkHttp也支持呼叫和连接超时。两者都可以在客户端抽象级别进行配置，这比JDK11实现稍微方便一些:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">使用OkHttp设置超时</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mm"><img src="../Images/7b392e66f12fe79dbe7631a8e0a72bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yXo-_LI9yrR_ze2az0XpMg.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://unsplash.com/@agebarros?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿格巴洛斯</a>在<a class="ae lb" href="https://unsplash.com/s/photos/timer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="a02c" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">不管怎样，如何选择超时值？</h2><p id="15dd" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">最后我想说的是如何得出这两个数字。呼叫超时更多地是关于你与其他服务的SLA/SLO，而连接超时是关于来自底层网络的期望。例如，如果您向同一个数据中心发送请求，那么100ms就可以了(尽管它应该比5ms更快地建立连接)，但是在移动网络(更容易出错)上运行将需要更长的连接超时。</p><h2 id="86f6" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">总结</h2><p id="32d4" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在本文中，我们讨论了为什么超时很重要，为什么“经典”超时不符合现代要求，以及使用什么工具来强制超时。希望你能从中找到有用的东西。</p></div></div>    
</body>
</html>