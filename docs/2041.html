<html>
<head>
<title>How to create M:N Relationship with Room and Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何与Room和Kotlin建立M:N关系</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-create-m-n-relationship-with-room-and-kotlin-ddbdebf0ee38?source=collection_archive---------0-----------------------#2019-03-21">https://itnext.io/how-to-create-m-n-relationship-with-room-and-kotlin-ddbdebf0ee38?source=collection_archive---------0-----------------------#2019-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/8bcb6510f4ceadd4964b5865ca99042a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*CVXy1WUgtAAbSIDMtrWbcQ.png"/></div><figcaption class="iv iw gj gh gi ix iy bd b be z dk translated">如何与Room和Kotlin建立M:N关系</figcaption></figure><div class=""/><p id="10cc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将解释如何使用<a class="ae kw" href="https://developer.android.com/topic/libraries/architecture/room" rel="noopener ugc nofollow" target="_blank"> Room </a>创建多对多关系。我会尽量多练习，不写很多理论，只写必要的。我将遵循以下几点:</p><ul class=""><li id="5981" class="kx ky jb ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">多对多关系的描述</li><li id="6a12" class="kx ky jb ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">为其创建房间实体</li><li id="50c2" class="kx ky jb ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">插入关系</li><li id="b4ac" class="kx ky jb ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">查询关系数据</li></ul><p id="2472" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我将使用以下实体:Recipe和Day，其中一个配方可以分配给多天，一天可以包含多个配方。这个例子是我为一个食谱应用程序做的，用户可以创建一周的饮食计划。</p><figure class="lm ln lo lp gt is gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ll"><img src="../Images/206d38181c181eec66afeface7d26b92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*djhxnMovayU-fRhVPepXCg.png"/></div></div></figure><p id="d5da" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">表示多对多关系的标准方法是使用连接表。您可以将此表想象为两个实体之间的表:</p><figure class="lm ln lo lp gt is gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lu"><img src="../Images/6f4e58a97a2de9dcfdeae85e40dd7d31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SytlS1PLg36UIhDuXtInOQ.png"/></div></div></figure><p id="2b7f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以看到星期二有多种食谱，因此这样我们就建立了多对多的关系。我使用字段名只是为了解释这个表的目的，实际上我们在这里存储的是日期和收件人</p><figure class="lm ln lo lp gt is gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lv"><img src="../Images/b021f6982d5c2737186ac106b3f6bde6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qm3JP0X-Sxl7Wf2DSkcqgQ.png"/></div></div></figure><p id="00e6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看房间实体如何寻找这些</p><pre class="lm ln lo lp gt lw lx ly lz aw ma bi"><span id="b4fe" class="mb mc jb lx b gy md me l mf mg">@Entity(primaryKeys = ["id"])<br/>data class Recipe(val id: Int, val name : String)</span><span id="221a" class="mb mc jb lx b gy mh me l mf mg">@Entity(primaryKeys = ["id"])<br/>data class Day (val id : Int , val name : String)</span></pre><p id="e6cf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在这里看到的第一件事是，我们不需要指定ForeignKey，但是我们需要创建一个实体来表示AssignedRecipe。为此，我将把它存储在一个名为DatabaseDataHolder的类中，因为在结束之前我们还需要一些其他的东西。</p><pre class="lm ln lo lp gt lw lx ly lz aw ma bi"><span id="1503" class="mb mc jb lx b gy md me l mf mg">class DatabaseDataHolder {<br/><br/>    @Entity(<br/>        primaryKeys = ["day", "recipe"], foreignKeys = [<br/>            ForeignKey(<br/>                entity = Day::class,<br/>                parentColumns = ["id"],<br/>                childColumns = ["day"],<br/>                onDelete = ForeignKey.<em class="mi">CASCADE<br/>            </em>),<br/>            ForeignKey(<br/>                entity = Recipe::class,<br/>                parentColumns = ["id"],<br/>                childColumns = ["recipe"],<br/>                onDelete = ForeignKey.<em class="mi">CASCADE<br/>            </em>)]<br/>    )<br/>    class AssignedRecipe {<br/>        var day: Int = 0<br/>        var recipe: Int = 0<br/>    }<br/>}</span></pre><p id="a048" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个表中，我们有两个Int字段，一个表示日期，另一个表示食谱。这些字段用作dayId和recipeId的外键。</p><p id="4eb3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> <em class="mi">记住，您需要将这个表添加到数据库类中的实体列表中。</em> </strong></p><p id="bf13" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们已经定义了一个新的实体并让数据库知道了它，我们需要定义一个函数来分配一个配方。那么让我们定义一个<a class="ae kw" href="https://developer.android.com/reference/android/arch/persistence/room/Dao" rel="noopener ugc nofollow" target="_blank"> <em class="mi">刀</em> </a> <em class="mi"> </em>叫做累西腓刀</p><pre class="lm ln lo lp gt lw lx ly lz aw ma bi"><span id="3270" class="mb mc jb lx b gy md me l mf mg">@Dao<br/>interface RecipeDao {<br/><br/>    @Insert(onConflict = OnConflictStrategy.<em class="mi">IGNORE</em>)<br/>    fun addAssignedRecipe( assignedRecipe: AssignedRecipe)<br/><br/>}</span></pre><p id="d63f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用OnConflictStrategy。忽略以避免插入已存在的具有相同配方和日期的已分配接收方。</p><p id="1228" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用这个函数很简单:</p><pre class="lm ln lo lp gt lw lx ly lz aw ma bi"><span id="cb1a" class="mb mc jb lx b gy md me l mf mg"><em class="mi">thread </em><strong class="lx jc">{<br/>    </strong>var assignedRecipe = DatabaseDataHolder.AssignedRecipe()<br/>    assignedRecipe.day = day<br/>    assignedRecipe.recipe = recipe<br/>    recipeDao.addAssignedRecipe(assignedRecipe)<br/><strong class="lx jc">}</strong></span></pre><p id="3712" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要取消分配配方，我们删除AssignedRecipe表中具有recipeId/dayId的所有行，因此我们总是在RecipeDao中添加这个函数</p><pre class="lm ln lo lp gt lw lx ly lz aw ma bi"><span id="489f" class="mb mc jb lx b gy md me l mf mg">@Query("DELETE FROM AssignedRecipe WHERE AssignedRecipe.day =:dayId")<br/>fun removeAllAssignedRecipeByDayId( dayId : Int)</span><span id="6929" class="mb mc jb lx b gy mh me l mf mg">@Query("DELETE FROM AssignedRecipe WHERE AssignedRecipe.recipe =:recipeId")<br/>fun removeAllAssignedRecipeByRecipeId( recipeId : Int)</span></pre><p id="e970" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，我们已经有了主表，但是我们真正想要的是从Recipe和Day获得所有数据，例如，我们想要知道某一天的所有食谱。表示这些信息的一个好方法可能是一对<em class="mi">，</em>像&lt; 1，4 &gt;或&lt;星期一，意大利面&gt;。我们需要连接3个表(日、指定接收、配方),以便获得我们需要的所有数据</p><figure class="lm ln lo lp gt is gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi mj"><img src="../Images/38274b978f773754775563a789359ccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SqOJBxE8QMupY56Cha04LA.png"/></div></div></figure><p id="db70" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看如何通过查询创建这个结果，首先定义一个表示对<day recipe="">的类</day></p><pre class="lm ln lo lp gt lw lx ly lz aw ma bi"><span id="62a0" class="mb mc jb lx b gy md me l mf mg">class DatabaseDataHolder {<br/><br/>    @Entity(<br/>        primaryKeys = ["day", "recipe"], foreignKeys = [<br/>            ForeignKey(<br/>                entity = Day::class,<br/>                parentColumns = ["id"],<br/>                childColumns = ["day"],<br/>                onDelete = ForeignKey.<em class="mi">CASCADE<br/>            </em>),<br/>            ForeignKey(<br/>                entity = Recipe::class,<br/>                parentColumns = ["id"],<br/>                childColumns = ["recipe"],<br/>                onDelete = ForeignKey.<em class="mi">CASCADE<br/>            </em>)]<br/>    )<br/>    class AssignedRecipe {<br/>        var day: Int = 0<br/>        var recipe: Int = 0<br/>    }<br/><br/><br/><br/>    <strong class="lx jc">class RecipeDayPair {<br/>        @Embedded(prefix = "recipe_")<br/>        lateinit var recipe : Recipe<br/><br/>        @Embedded<br/>        var day : Day? = null<br/>    }</strong></span><span id="1877" class="mb mc jb lx b gy mh me l mf mg">}</span></pre><p id="91f9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们知道菜谱不会为空，所以我使用<em class="mi"> lateinit </em>来避免菜谱为空。然后我使用<em class="mi">嵌入的</em>注释来避免与其他表的字段冲突。现在我们可以定义返回<em class="mi">LiveData&lt;List&lt;database data holder的查询。往复对&gt; &gt;。为了简单起见，我们把它分成不同的部分</em></p><p id="d4c7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从Recipe表中选择一些字段，从day表中选择所有内容，然后分配Recipe.day。我用“<em class="mi"> recipe_nameField </em>作为Recipe字段的前缀，否则我们会与Day的列名发生冲突。</p><pre class="lm ln lo lp gt lw lx ly lz aw ma bi"><span id="ee23" class="mb mc jb lx b gy md me l mf mg">SELECT Recipe.id as recipe_id, Recipe.name as recipe_name, AssignedRecipe.day , Day.*</span></pre><p id="f6e5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们开始连接表(我们试图复制我在上一张图中解释过的连接表) :</p><ul class=""><li id="b7be" class="kx ky jb ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">我们使用Recipe.id将Recipe表与AssignedRecipe连接起来</li></ul><pre class="lm ln lo lp gt lw lx ly lz aw ma bi"><span id="32f9" class="mb mc jb lx b gy md me l mf mg">FROM Recipe LEFT OUTER JOIN AssignedRecipe on AssignedRecipe.Recipe = Recipe.id</span></pre><ul class=""><li id="a25c" class="kx ky jb ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">我们使用Day.id连接日表</li></ul><pre class="lm ln lo lp gt lw lx ly lz aw ma bi"><span id="17b7" class="mb mc jb lx b gy md me l mf mg">LEFT OUTER JOIN Day on AssignedRecipe.day = Day.id</span></pre><p id="76c1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们把所有这些部分放在一起，我们有我们的查询</p><pre class="lm ln lo lp gt lw lx ly lz aw ma bi"><span id="2e27" class="mb mc jb lx b gy md me l mf mg">@Query("SELECT Recipe.id as recipe_id, Recipe.name as recipe_name, AssignedRecipe.day , Day.* FROM Recipe LEFT OUTER JOIN AssignedRecipe on AssignedRecipe.Recipe = Recipe.id LEFT OUTER JOIN Day on AssignedRecipe.day = Day.id")<br/>fun getAllWithAssignedDays() : LiveData&lt;List&lt;DatabaseDataHolder.RecipeDayPair&gt;&gt;</span></pre><p id="8652" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果配方未分配，我们预计该配方的日期将为空。</p><p id="625c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，通过这个查询，我们可以获得一个对列表<day recipe="">，例如:</day></p><pre class="lm ln lo lp gt lw lx ly lz aw ma bi"><span id="ea31" class="mb mc jb lx b gy md me l mf mg">{ Pair(Monday , Pasta) , Pair(Tuesday, Chicken Fajitas) ,<br/>Pair(Tuesday , Pasta) }</span></pre><p id="f74c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个结果还可以，但我认为我们可以做得更好，使用比配对列表更方便的东西。我希望有一天和那天的食谱列表，这样我们可以尝试将我们的Pair对象列表转换成这个新的表示。就像我们之前用<em class="mi"> RecipeDayPair所做的一样，</em>让我们在DatabaseDataHolder中创建一个表示日期和食谱列表的类。</p><pre class="lm ln lo lp gt lw lx ly lz aw ma bi"><span id="b61d" class="mb mc jb lx b gy md me l mf mg">data class DayAndItsRecipes (val day: Day, <br/>val recipes: List&lt;Recipe&gt;)</span></pre><p id="b387" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们使用我们之前声明的查询，我们得到的响应将是一个<em class="mi">recipe paypal</em>的列表</p><pre class="lm ln lo lp gt lw lx ly lz aw ma bi"><span id="f705" class="mb mc jb lx b gy md me l mf mg">viewModel.getAllWithAssignedDays().observe( this , <em class="mi">Observer </em><strong class="lx jc">{ </strong>response <strong class="lx jc">-&gt;<br/>    </strong>if(!response.<em class="mi">isNullOrEmpty</em>()) {<br/><br/>    }<br/><strong class="lx jc">}</strong>)</span></pre><figure class="lm ln lo lp gt is gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi mk"><img src="../Images/e09fd8137f5ff0d3ca9439577386e037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hn-wMpczMp_QYKffV9SGbw.png"/></div></div></figure><p id="8a57" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们想把这个列表转换成更容易操作的形式，比如一个DayAndItsRecipes的列表。为此，我将使用Kotlin<a class="ae kw" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/group-by.html" rel="noopener ugc nofollow" target="_blank"><em class="mi">group by</em></a><em class="mi">函数按天对每个项目进行分组。</em>该功能给出一张&lt;日地图，列出&lt;食谱&gt;和&gt;。</p><figure class="lm ln lo lp gt is gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ml"><img src="../Images/67beca63f727771fbcaec123e9e64f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hd8N9_E6TPpYRDlPIGX2dg.png"/></div></div></figure><p id="ed8f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用函数<a class="ae kw" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/for-each.html" rel="noopener ugc nofollow" target="_blank">forEachforEach</a>forEach<em class="mi">遍历这个映射，并填充我们的列表</em></p><pre class="lm ln lo lp gt lw lx ly lz aw ma bi"><span id="7edd" class="mb mc jb lx b gy md me l mf mg">combinedRecipes.<em class="mi">forEach </em><strong class="lx jc">{ </strong>items.add(DatabaseDataHolder.DayAndItsRecipes(<strong class="lx jc">it</strong>.key , <strong class="lx jc">it</strong>.value))<strong class="lx jc">}</strong></span></pre><p id="07e6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就这样，我们有了我们的食谱清单。一件重要的事情是使代码可读和可重用，所以最好将这最后一部分代码移到DatabaseDataHolder类中，使它在任何地方都可以重用。</p><figure class="lm ln lo lp gt is"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="1aa4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以在任何地方使用这个函数，它使代码更具可读性:)</p><figure class="lm ln lo lp gt is"><div class="bz fp l di"><div class="mm mn l"/></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="cfb0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这不是一个简单的话题，我知道，我也没有在谷歌上找到好的教程。尽管我的英语不好，但我希望这篇文章能帮助你，如果你有任何问题，请随时通过Linkedin联系我。</p></div></div>    
</body>
</html>