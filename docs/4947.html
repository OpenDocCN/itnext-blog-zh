<html>
<head>
<title>.net core — be secure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">。网络核心—确保安全</h1>
<blockquote>原文：<a href="https://itnext.io/net-core-be-secure-a48d6b27d3b8?source=collection_archive---------3-----------------------#2020-11-01">https://itnext.io/net-core-be-secure-a48d6b27d3b8?source=collection_archive---------3-----------------------#2020-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e81ad5e1ca8b77676e51b0fb72a22799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nDU44lEPIUCxd03BcX3nGw.png"/></div></div></figure><p id="922e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安全，它总是引起头痛，它不是简单的。尽管人们认为这很简单，但它并不简单，而且很可能永远不会简单。我确实记得我的第一个项目，实际上是用PHP，最有趣的部分，而不是通过https。这一切都是关于，与秘密快速握手，秘密在瞬间有效。在某种程度上，是的安全，但即使是几秒钟也是我们需要考虑的。我完全同意，把安全留给真正明白什么是由内而外的安全的人，比如<a class="ae kw" href="https://auth0.com/" rel="noopener ugc nofollow" target="_blank"> Auth0 </a>。我非常喜欢Auth0，原因之一可能是它对开发人员友好的文档，你实际上可以感觉到它们是为实际执行的人工作的。</p><p id="c4ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，安全是有代价的，那么，没有安全专家在上面的代价是什么，有时是你的业务。</p><p id="c725" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，如果——是的，如果，你只是需要一个小的，也许是中等规模的项目来担保呢？很复杂吗？不，它不是，微软团队使我们能够简单地做到这一点。记住，你需要明白你在唱什么，你在做什么纯粹是你的责任。</p><p id="c265" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">女士们先生们，我给你们带来了我简单的经验。开箱即用的网络核心安全性。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="c462" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好，所以你认为你知道你在做什么，有什么风险，很好。</p><p id="74e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从一个没有任何安全性的空web API项目开始。让我们使用dotnet客户端创建一个项目。至于这个项目的名字，我想不出更好的了，就叫它Matrix吧。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="37b4" class="ln lo iq lj b gy lp lq l lr ls">dotnet new webapi -n Matrix</span></pre><p id="564f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦项目创建完毕，打开你最喜欢的IDE，让我们开始黑吧。</p><p id="103d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我创建的任何项目中，我都会通过删除https相关的东西来修复一些东西、启动properties和startup.cs。无论如何，我的意图是在Azure服务上卸载https，或者在数字海洋的反向代理后面。让我们从launchsSettings.json开始</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="c738" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我只是删除了所有的IIS内容和https引用，所以它将作为一个简单的终端应用程序在端口5000上运行。之后，让我们进入Startup.cs文件并删除所有注释(我不喜欢注释)和https相关的行。此外，我，嗯，它是IDE，帮助我删除未使用的usings。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="6594" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，当我们运行这个项目时，它将启动默认的web浏览器并导航到天气端点。如果我们仔细观察launchSettings.json，它实际上就是我们想要的。它应该显示类似这样的内容。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="8a0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不错！我们的API正在工作，如何保护它？Nop，不是说“复杂”的安全流程。只需用户名/密码，获取令牌，并将令牌用于正在进行的请求。所以我可以想象，我们需要一个控制器来发送用户名和密码，它返回一个令牌。然后是某种验证受保护端点上的令牌的中间件。</p><p id="4874" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好的——让我们更进一步，添加API版本控制。API版本化是一个长期的愿景，我强烈建议你这么做。代替</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="7ef3" class="ln lo iq lj b gy lp lq l lr ls"><a class="ae kw" href="http://localhost:5000/weatherforecast" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/weatherforecast</a></span></pre><p id="4731" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们按时到达</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="2fd8" class="ln lo iq lj b gy lp lq l lr ls"><a class="ae kw" href="http://localhost:5000/weatherforecast" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/api/v1/weatherforecast</a></span></pre><p id="9c51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们创建BaseController.cs</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="e72a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里发生了什么，我们说这是一个API控制器，默认版本是1.0，路由应该是start/API/{ version _ number/{ controller name }。最重要的是，你必须是一个授权用户才能得到响应。</p><p id="3e49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将不会工作，因为我们缺少几个包，这将被强调为未解决的</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="3c76" class="ln lo iq lj b gy lp lq l lr ls">[ApiVersion( "1.0" )]</span></pre><p id="fca8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以通过添加Microsoft包来解决这个问题。注意:导航到项目目录</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="00ce" class="ln lo iq lj b gy lp lq l lr ls">cd Matrix</span><span id="8752" class="ln lo iq lj b gy lv lq l lr ls">dotnet add package Microsoft.AspNetCore.Mvc.Versioning</span></pre><p id="ea1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，这应该可以修复错误。现在让我们通过添加扩展我们的基本控制器来调整WeatherForecastController.cs控制器。注意:我们删除了控制器的所有属性，因为基本控制器包含了所有属性，所以不再需要它了。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="36d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好的—在运行之前，我们需要调整启动设置，因为我们调整了路线以包含版本。由于我们添加了一个新的NuGet，它负责版本，我们需要添加服务，它负责版本。</p><p id="85ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">启动设置，请注意launchUrl</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="8cd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Startup.cs，通知服务。addapiversioning</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="2ee9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我们运行这个项目，仍然会产生一个错误</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="d058" class="ln lo iq lj b gy lp lq l lr ls">InvalidOperationException: No authenticationScheme</span></pre><p id="3893" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是可以的，因为我们还没有定义任何方案，但是如果你得到这个错误，它应该是这样的。</p><p id="66ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是微软大放异彩的时候了，因为定义您的身份验证方案和处理传入请求非常简单。</p><p id="fe15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个方案都需要一个处理程序——让我们创建一个处理简单令牌方案的处理程序。</p><p id="ca5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建一个类defaultauthenticationhandler . cs，该类使用其通用AuthenticationSchemeOptions扩展AuthenticationHandler</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="5676" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了，我们有一个中间件来处理传入的请求。现在，我们只需要添加检查传入请求的逻辑。正如我们所知，将有传入令牌，我们需要检查传入令牌的有效性。</p><p id="f45b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在实现逻辑之前，让我们将这个处理程序添加到我们的应用程序中，这样我们就不会出现异常</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="6dd8" class="ln lo iq lj b gy lp lq l lr ls">InvalidOperationException: No authenticationScheme</span></pre><p id="46aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Startup.cs中，请注意服务。添加身份验证</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="5b8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们说我们将使用不记名令牌，这里是中间件“DefaultAuthenticationHandler ”,它将处理令牌是否有效。</p><p id="c80e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很好，现在当我们运行项目时，浏览器会显示</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lw"><img src="../Images/6ffa0d07d0b444a1875def1c082ac15e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JxcV3Gan9M6AAyq9ZcOaKQ.png"/></div></div></figure><p id="7b7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不完美，但我们至少没有得到一个错误。这只是说我们作为用户没有被授权查询端点。这很好，在这一点上应该是这样的。让我们对我们的处理程序进行调整，并赋予它一些智能。但在此之前，让我们再添加一个包，它将帮助我们进行依赖注入，并且我们不会使Startup.cs过于混乱</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="56b9" class="ln lo iq lj b gy lp lq l lr ls">dotnet add package ServiceLocator</span></pre><p id="83dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">调整Starup.cs，看第3行</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="2a4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">设置好之后，让我们创建一个用户模型。其中包含用户名、密码和令牌，为了清楚起见，让我们也添加用户ID。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="7fc4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有一个对象，可以用来#1通过用户名和密码或令牌来验证用户。</p><p id="9cf6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们创建一个用户服务，它将通过令牌为我们的处理程序完成这项工作。我们将从抽象即接口开始。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="fa2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，当抽象清晰时，让我们实现抽象。抽象地说，我们希望通过令牌来认证用户。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="d157" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里没有太多内容，但是首先，UserService有一个属性(第11行)，它指出这个类应该在依赖注入中注册，并且作用域是scope，所以我们可以在我们的安全处理程序中注入它。</p><p id="2666" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们有一个私有用户列表，只有一个用户。但是这可以用DB存储库来代替，否则，这就是内存中的用户数据库。</p><p id="8970" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一件事，抽象“认证”和令牌的实现，我们试图通过令牌找到用户。</p><p id="a547" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经准备好给我们的认证处理程序添加大脑了。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="c056" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看起来确实有很多事情在进行，但实际上，并没有很多。像第29行检查它是否是一个受保护的端点，如果不是，就忽略。在第38行，我们查看头部并获取传入的令牌。在第39行，我们使用我们的用户服务通过令牌寻找用户。之后，我们只需填充用户上下文user。</p><p id="cc84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，让我们使用postman或者在我的例子中使用<a class="ae kw" href="https://insomnia.rest/" rel="noopener ugc nofollow" target="_blank">失眠症</a>来获取天气数据，方法是在头中传递标记“芜菁”。</p><h1 id="bb51" class="lx lo iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">Ups！</h1><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/dc58fd1dea842291d95c7176ac85738e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eHMBp4brvkSZWfE_9pex6g.png"/></div></div></figure><p id="8e27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管如此，401，看起来我们有一个错误，不是第一次，让我们看看Startup.cs文件，是的，我们没有把一个配置</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="0053" class="ln lo iq lj b gy lp lq l lr ls">app.UseAuthentication();</span></pre><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="8ada" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">10号线。</p><p id="a2cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们跑吧</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/cc2862392c63cee80a6692370690c69f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oK_l2KzIMYulawK_-20odA.png"/></div></div></figure><p id="0b17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">瞧啊。我们通过令牌为有效用户“baldrick”获取天气信息！我们可以在控制器中访问用户上下文。</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/ee9e619dec7b389654b975577c5d4a44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B2P2NYSVE8dgd79Urhvvkw.png"/></div></div></figure><p id="7790" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">故事当然会到此结束，但如何得到一个令牌呢？当然，我们知道它基本上是静态的，但如何创建一种体验，即在用户输入用户名和密码后，用户实际上获得了令牌？</p><p id="65c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我们需要付出额外的努力，让我们开始吧。我们需要创建UsersController和无需身份验证即可访问的端点。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="f7ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先要指出的是，第19行，我们明确地说，这个端点</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="a0b7" class="ln lo iq lj b gy lp lq l lr ls"><a class="ae kw" href="http://127.0.0.1:5000/api/v1/users/authenticate" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:5000/api/v1/users/authenticate</a></span></pre><p id="92cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不受保护，因为我们需要<a class="ae kw" href="http://127.0.0.1:5000/api/v1/users/authenticate" rel="noopener ugc nofollow" target="_blank">认证</a>并获得令牌。</p><p id="3e1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，我们衍生了三个新的类</p><p id="a9b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">#1 AuthenticateModel，我们希望API消费者发送用户名和密码</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="647d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">#2认证响应，如果认证成功，我们将向API消费者返回一个令牌。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="f658" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">#3 UserOrPasswordException，如果用户名或密码不正确，则出现异常。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="c2a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，我们需要改进我们的用户服务，以便能够通过用户名和密码找到用户，如果出现问题，抛出我们创建的异常。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="e12e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们测试我们的新端点，并为用户“baldrick”获取一个令牌</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/e5751ad62a1b58d095700a45421fbbbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XBxoLEZYMWSwOA_uRyPwvQ.png"/></div></div></figure><h1 id="8ecb" class="lx lo iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">接下来的步骤是</h1><p id="efe8" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated">添加有状态存储库，向用户上下文添加范围和角色。所有这些都是可行且简单的。</p><h1 id="fe94" class="lx lo iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">一锤定音</h1><p id="ab0e" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated">正如你所看到的，微软已经做了大量的工作来帮助开发者创造出令人敬畏的解决方案。正如我在文章开头提到的，将安全性留给专业人员，因为这个例子只展示了简单的认证/授权流程。它可能会变得很复杂。这个指南只是为了<em class="nc">指出</em>，有时候你不需要为简单的流程建立沉重的框架。</p><p id="16ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://github.com/alzuma/matrix" rel="noopener ugc nofollow" target="_blank">饭桶</a></p></div></div>    
</body>
</html>