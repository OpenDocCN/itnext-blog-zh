<html>
<head>
<title>Controlled vs Uncontrolled Components in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中受控与非受控组件</h1>
<blockquote>原文：<a href="https://itnext.io/controlled-vs-uncontrolled-components-in-react-5cd13b2075f9?source=collection_archive---------0-----------------------#2020-01-26">https://itnext.io/controlled-vs-uncontrolled-components-in-react-5cd13b2075f9?source=collection_archive---------0-----------------------#2020-01-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="38c0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">WTF就是区别？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a372d4ce2a0d3d2cb120d3353f780c99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X2sU3SBT4BSUTAMy"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">尼克·舒利亚欣在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="a8ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React是一个用于构建用户界面的JavaScript库。如果你点击阅读了这篇文章，你可能已经知道React是关于组件的。组件是<strong class="lb iu"><em class="lv"/></strong>反应过来的根本特征。</p><p id="d9e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React支持两种类型的组件:受控组件和非受控组件。React文档声明:</p><blockquote class="lw lx ly"><p id="a14e" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">在大多数情况下，我们建议使用<a class="ae ky" href="https://reactjs.org/docs/forms.html#controlled-components" rel="noopener ugc nofollow" target="_blank">受控组件</a>来实现表单。在受控组件中，表单数据由React组件处理。另一种方法是不受控制的组件，表单数据由DOM本身处理。</p></blockquote><p id="a9f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看每一个。</p><h2 id="0b25" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">受控组件</h2><p id="3ea4" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在受控组件中，表单数据由组件中的状态<em class="lv">处理。组件内的状态充当由组件呈现的输入元素的<em class="lv">“真实的单一来源】</em>。</em></p><p id="4c78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个代码示例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2c4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有一个简单的组件，它在页面上呈现一个文本框，并回显用户在文本框中键入的任何内容。下面是它的使用情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/fcfd9f5cb7ce42519ab0906e88905e29.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/1*qya0oJOdM8nQ0IKJsv7XbQ.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">运行中的受控组件！</figcaption></figure><p id="5f9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们看看这个组件的代码，在第4行我们创建了状态对象。它拥有一个名为<em class="lv">消息</em>的属性。这是文本框中输入的值的存储位置。</p><p id="33b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了存储该值，我们需要一个当用户在文本框中键入时触发的事件。我们如何做到这一点？</p><p id="f722" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您查看代码的第19行和第20行，您可以看到:</p><ol class=""><li id="794a" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">textbox有一个值属性绑定到状态中的message属性。</li><li id="aabb" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">我们声明了一个onChange事件处理程序。</li></ol><p id="0afe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">这2点告诉你这是一个受控组件。</em>T19】</strong></p><p id="28ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">我们不需要页面上的表单元素来使组件成为受控组件。</em> </strong></p><p id="1b5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当对任何具有<em class="lv">事件处理程序</em>的输入元素进行更改时，该处理程序将被触发。</p><p id="8b41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理程序调用setState()，如上面第9行所示。这将更新组件内的状态。</p><p id="c95c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您不应该像这样直接设置状态:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="907c" class="mc md it ns b gy nw nx l ny nz">this.state.message = 'dont update state like this';</span></pre><p id="4dbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以这种方式更新状态不会导致组件的重新呈现，用户所做的更改也不会显示在UI中。</p><p id="58f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当通过setState()进行状态更新时，它会导致组件重新呈现，新输入的值会显示在元素中。</p><p id="d7fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据流从组件状态到输入元素是单向的。</p><p id="f9ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用受控组件可能有点麻烦。如果页面上有大量的输入元素，每个元素都需要设置一个<em class="lv">值</em>属性和一个<em class="lv">事件处理程序</em>。</p><h2 id="7152" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">不受控制的组件</h2><p id="6d12" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">不受控制的组件更像传统的HTML表单元素。每个输入元素的数据都存储在DOM中，而不是组件中。您不用为所有的状态更新编写事件处理程序，而是使用一个<strong class="lb iu"> <em class="lv"> ref </em> </strong>从DOM中检索值。</p><p id="83a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想知道什么是<strong class="lb iu"> <em class="lv"> ref </em> </strong>，问得好！<a class="ae ky" href="https://reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank">来自React文档</a>:</p><blockquote class="lw lx ly"><p id="6dd1" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">Refs提供了一种方法来访问在render方法中创建的DOM节点或React元素。</p></blockquote><p id="d371" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个代码示例。</p><p id="c6a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将上面的受控组件修改为非受控组件，我们会得到以下结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="5b07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到，我们在第4行添加了一个构造函数，在其中我们设置了事件处理程序并创建了一个<em class="lv">ref</em>to<em class="lv">this . input .</em></p><p id="7595" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在第19行再次引用<em class="lv"> this.input </em>，在这里我们将它设置为input元素上的<em class="lv"> ref </em>属性。有了这些部分，每次我们在文本框中输入时，值都会在控制台中回显。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/1e3ce9e139aec26b7318afde60182074.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/1*B2PFcYzP43pRhG0NDOF5UQ.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我们行动中不受控制的部分！</figcaption></figure><p id="4132" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于<em class="lv">参考文献的几个要点:</em></p><ol class=""><li id="03bf" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">引用是使用React.createRef()创建的。</li><li id="0d64" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">使用相关元素上的<em class="lv"> ref </em>属性将引用附加到输入元素。</li><li id="0e1e" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">参考通常用作元件的例证性质。ref是在构造函数中设置的(如上所示),该值在整个组件中都可用。</li><li id="f761" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">不能在 功能组件上使用<em class="lv"> ref </em>属性<strong class="lb iu"> <em class="lv">，因为没有创建实例。这里有一个例子:</em></strong></li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="37ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5.<strong class="lb iu"> <em class="lv">但是</em> </strong>，你可以用一个<em class="lv"> ref </em>属性<strong class="lb iu"> <em class="lv">在</em> </strong>一个功能组件里面，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="ec1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank">更多来自React文档:</a></p><blockquote class="lw lx ly"><p id="48fc" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">有几个很好的参考用例:</p><p id="46c3" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">管理焦点、文本选择或媒体播放。</p><p id="d240" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">触发命令式动画。</p><p id="8b49" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">与第三方DOM库集成。</p><p id="31f9" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">避免对任何可以声明完成的事情使用refs。</p></blockquote><h2 id="9e74" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">总结和要点</h2><ol class=""><li id="aeba" class="nd ne it lb b lc mv lf mw li ob lm oc lq od lu ni nj nk nl bi translated">尽可能使用受控部件。</li><li id="c7c8" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">受控组件不需要表单元素即可被视为受控组件。</li><li id="661e" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">如果一个组件有一个input元素，它的value属性绑定到state，并且有一个事件处理程序来更新所述状态，那么它就是一个受控组件。</li><li id="3117" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">对于具有大量输入元素的页面，使用受控组件可能会很麻烦。</li><li id="a4bd" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">在受控组件中，数据流是单向的，组件中的状态充当唯一的真实来源。</li><li id="5348" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">受控组件内的所有状态更改都应通过setState函数进行。</li><li id="7cd6" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">不受控制的组件像传统的HTML输入元素一样将数据存储在DOM中。</li><li id="0ee4" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">React.createRef()用于在不受控制的组件构造函数中创建实例变量。然后，这些变量通过<em class="lv"> ref </em>属性与输入元素相关联。</li><li id="0d6b" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">由于没有实例，引用不能用于 功能组件上的<strong class="lb iu"> <em class="lv">。</em></strong></li><li id="ba86" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">引用可以在 功能组件内使用<strong class="lb iu"> <em class="lv">。</em></strong></li></ol><p id="df11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一如既往的感谢阅读！如果你喜欢这篇文章，请分享它，并查看我在Medium 上的其他文章。</p><div class="oe of gp gr og oh"><a href="https://medium.com/@aritzcovan" rel="noopener follow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">亚历克斯·里茨科万-中等</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">阅读Alex Ritzcovan在媒体上的文章。前CTO和软件开发人员。我热爱学习和分享…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">medium.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ks oh"/></div></div></a></div></div></div>    
</body>
</html>