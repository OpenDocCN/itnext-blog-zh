<html>
<head>
<title>.NET Console Apps Preparation for Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">。Docker的. NET控制台应用程序准备</h1>
<blockquote>原文：<a href="https://itnext.io/net-console-apps-preparation-for-docker-b72c9dfc1ded?source=collection_archive---------4-----------------------#2020-05-14">https://itnext.io/net-console-apps-preparation-for-docker-b72c9dfc1ded?source=collection_archive---------4-----------------------#2020-05-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="dff5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我有一个服务要在我的Raspberry Pi上运行，我决定用Docker部署和托管它。事情进行得很顺利，直到我需要一些改变来让我的控制台应用程序为Docker做好准备。</p><p id="05dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">大多数时候，我们通过调用<code class="fe ko kp kq kr b">Console.ReadLine</code>来结束我们的应用程序Main方法。这似乎很合理，直到你尝试在Docker <a class="ae ks" href="https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)" rel="noopener ugc nofollow" target="_blank">分离模式</a>下运行你的应用。</p><pre class="kt ku kv kw gt kx kr ky kz aw la bi"><span id="1194" class="lb lc it kr b gy ld le l lf lg">docker run -d myapp:latest</span></pre><p id="4d66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它运行容器，应用程序将立即退出！因为在分离模式下你做不到。我将涵盖交互式和分离模式的所有场景和解决方法，所以请系好安全带！</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h2 id="15fe" class="lb lc it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">场景1:交互模式</h2><p id="39f1" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">互动模式是什么？交互模式意味着你需要用户在容器中的应用上进行交互，比如输入一些信息，选择一个选项等等。我不喜欢这样，因为在大多数情况下，用户更喜欢为容器提供带有参数或环境变量的数据。</p><p id="b65b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">想象一个简单的。NET控制台应用程序，需要用户确认才能覆盖文件。</p><pre class="kt ku kv kw gt kx kr ky kz aw la bi"><span id="731f" class="lb lc it kr b gy ld le l lf lg">static void Main(string[] args)<br/>{<br/> while (true)<br/> {<br/>  Console.WriteLine("Overwrite the files? (y/n)");<br/>  var confirmation = Console.ReadLine().Substring(0, 1);<br/>  if (confirmation.Equals("y", StringComparison.OrdinalIgnoreCase))<br/>  {<br/>   Console.WriteLine("File(s) overwrited.");<br/>   break;<br/>  }<br/> }<br/> Console.WriteLine("Application exited.");<br/>}</span></pre><blockquote class="mk ml mm"><p id="3864" class="jq jr mn js b jt ju jv jw jx jy jz ka mo kc kd ke mp kg kh ki mq kk kl km kn im bi translated">💡这不是为实现CLI的好方法。为了更好地实现CLI，请阅读<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/command-line-interface-cli-application-with-net-core-75bb5603ee70?source=friends_link&amp;sk=2819a8e43b2e02e72c816961eb0c3217">命令行界面(CLI)应用程序。网芯</a>篇。</p></blockquote><p id="95b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们创建并运行docker映像，您将得到这个错误。用户输入为null，应用程序引发NullReferenceException。</p><figure class="kt ku kv kw gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mr"><img src="../Images/d22df2c4655af03f8a3b454f5b3608af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AOqeGyf8W7PI_5cRTciFsg.png"/></div></div></figure><p id="1ed8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是因为当您运行docker-image时没有任何用户输入。现在，如果在交互<code class="fe ko kp kq kr b">-i</code>模式下运行应用程序:</p><figure class="kt ku kv kw gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mz"><img src="../Images/d559e5998788ddbacd5089f8d39183c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iB7O-3IU2qC8FG3mU7yxPg.png"/></div></div></figure><p id="d58e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种场景和实现中，您不能以分离或附加的方式运行应用程序。</p><h2 id="6dae" class="lb lc it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">场景2:分离模式下长时间运行的作业</h2><p id="39b9" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">假设您有一个永远运行的服务，它提取数据并以面向事件的方式处理它们。</p><p id="3211" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑到这些类型的应用程序是在分离模式下运行的，像<code class="fe ko kp kq kr b">Console.Read</code>或<code class="fe ko kp kq kr b">System.Thread.Thread.Sleep(...)</code>这样的解决方法并不好。在下面带有<a class="ae ks" href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.autoresetevent?view=netcore-3.1" rel="noopener ugc nofollow" target="_blank">autoreseteevent、</a>的代码中，我们设法保持应用程序打开，直到用户想要用<code class="fe ko kp kq kr b">CTRL + C</code>关闭应用程序。</p><pre class="kt ku kv kw gt kx kr ky kz aw la bi"><span id="1530" class="lb lc it kr b gy ld le l lf lg">internal static class Program<br/>{<br/> private static readonly AutoResetEvent _waitHandle = new AutoResetEvent(false);</span><span id="a25c" class="lb lc it kr b gy na le l lf lg">private static readonly Service _service = new Service();<br/> private static void Main()<br/> {</span><span id="c7a9" class="lb lc it kr b gy na le l lf lg">_service.OnMessageRecieved = OnMessage_Received;<br/>  _service.StartReceiving();</span><span id="7fca" class="lb lc it kr b gy na le l lf lg">// Handle Control+C or Control+Break<br/>  Console.CancelKeyPress += (o, e) =&gt;<br/>  {<br/>   Console.WriteLine("Exit");<br/>   // Allow the manin thread to continue and exit...<br/>   _waitHandle.Set();<br/>  };</span><span id="63e5" class="lb lc it kr b gy na le l lf lg">// wait until Set method calls<br/>  _waitHandle.WaitOne();<br/> }</span><span id="7f24" class="lb lc it kr b gy na le l lf lg">private static void OnMessage_Received(int messageId, string message)<br/> {<br/>  Console.WriteLine($"Message {messageId} recieved.");<br/> }<br/>}</span></pre><ul class=""><li id="14dc" class="nb nc it js b jt ju jx jy kb nd kf ne kj nf kn ng nh ni nj bi translated">记住，在所有的作业之后调用<code class="fe ko kp kq kr b">AutoResetEvent.WaitOne</code>方法。</li></ul><h2 id="6402" class="lb lc it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">场景3:分离模式下的服务</h2><p id="18dc" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">在这种情况下，您可以轻松创建一个托管服务，并在您的控制台应用程序中运行它。微软<a class="ae ks" href="https://www.nuget.org/packages/Microsoft.Extensions.Hosting/" rel="noopener ugc nofollow" target="_blank">提供托管服务。扩展.托管</a>包。</p><p id="f949" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只需创建一个类并实现<code class="fe ko kp kq kr b">IHostedService</code>接口。你可以在微软文档上阅读更多关于<a class="ae ks" href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/background-tasks-with-ihostedservice" rel="noopener ugc nofollow" target="_blank"> HostedServices的信息。</a></p><pre class="kt ku kv kw gt kx kr ky kz aw la bi"><span id="d6c8" class="lb lc it kr b gy ld le l lf lg">public class Service : IHostedService<br/>{<br/> public Service()<br/> {<br/> }</span><span id="0c14" class="lb lc it kr b gy na le l lf lg">public Task StartAsync(CancellationToken cancellationToken)<br/> {<br/>  Console.WriteLine("Task is started.");<br/>  return Task.CompletedTask;<br/> }</span><span id="7215" class="lb lc it kr b gy na le l lf lg">public Task StopAsync(CancellationToken cancellationToken)<br/> {<br/>  Console.WriteLine("Task stopped.");<br/>  return Task.CompletedTask;<br/> }<br/>}</span></pre><p id="8f62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在您的Main方法中，创建托管服务并配置服务，等等。</p><pre class="kt ku kv kw gt kx kr ky kz aw la bi"><span id="2f7a" class="lb lc it kr b gy ld le l lf lg">private static async Task Main()<br/>{<br/> var hostBuilder = new HostBuilder()<br/>  .ConfigureServices((hostContext, services) =&gt;<br/>   {<br/>    services.AddHostedService&lt;Service&gt;();<br/>   }<br/>  );</span><span id="9982" class="lb lc it kr b gy na le l lf lg">await hostBuilder.RunConsoleAsync().ConfigureAwait(false);<br/>}</span></pre><h2 id="6683" class="lb lc it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">结论</h2><p id="5e50" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">我更喜欢AutoResetEvent方法，因为我的服务非常小。然而，对于更复杂或现实世界的问题，最好采用托管服务方法。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h2 id="c414" class="lb lc it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">要阅读的相关文章</h2><ul class=""><li id="4ffc" class="nb nc it js b jt mf jx mg kb nk kf nl kj nm kn ng nh ni nj bi translated"><a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/smaller-docker-images-for-asp-net-core-apps-bee4a8fd1277?source=friends_link&amp;sk=32ffef97e661f1131703b2c84a0d5e14">ASP.NET核心应用的较小Docker图像</a></li><li id="b9d3" class="nb nc it js b jt nn jx no kb np kf nq kj nr kn ng nh ni nj bi translated"><a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/command-line-interface-cli-application-with-net-core-75bb5603ee70?source=friends_link&amp;sk=2819a8e43b2e02e72c816961eb0c3217">命令行界面(CLI)应用程序。网络核心</a></li></ul></div></div>    
</body>
</html>