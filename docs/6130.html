<html>
<head>
<title>How to Architect a Production-Level App in Flutter: Phone Number Authentication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Flutter中构建生产级应用程序:电话号码认证</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-architect-a-production-level-app-in-flutter-phone-number-sign-in-263628e1872c?source=collection_archive---------0-----------------------#2021-08-30">https://itnext.io/how-to-architect-a-production-level-app-in-flutter-phone-number-sign-in-263628e1872c?source=collection_archive---------0-----------------------#2021-08-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/64fb9387d1e33308985e310df3407396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*56dabNrDBnpH7l5k4vxKFQ.png"/></div></div></figure><p id="19f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当开发人员进入Flutter时，他们可以找到各种资源来帮助他们开始。教程、存储库和UI挑战等资源可以将初学者变成中级Flutter开发人员。很快，开发人员就爱上了这个框架。</p><p id="bd70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">构建令人惊叹的UI是Flutter最有趣的方面。然而，没有可维护的业务逻辑支持的漂亮的UI/UX不会让你走得太远。如果你的目标是成为一名高级Flutter开发人员，不幸的是，没有太多的资源可以帮助你。</p><p id="f5d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我相信没有一个Flutter开发者会在整个旅程中感到孤独，所以我决定分享我构建生产级应用程序的经验。因此，我开源了<a class="ae kw" href="https://sponty.app/#/" rel="noopener ugc nofollow" target="_blank"> Sponty </a>的电话号码登录功能及其生产级的干净架构。</p><p id="d230" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将展示如何使用Firebase构建一个具有电话号码登录功能的Flutter应用程序。本文的范围仅限于架构和如何处理状态管理。你可以在<a class="ae kw" href="https://github.com/erkansahin/phone_number_sign_in" rel="noopener ugc nofollow" target="_blank"> Github </a>中找到该项目的完整源代码。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/123827e5292532d1953e907863393485.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/1*T2lEUMEIoaBeNp-Lp6rpXg.gif"/></div></figure><p id="26f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要开始，您可以使用<a class="ae kw" href="https://github.com/erkansahin/bare-bones" rel="noopener ugc nofollow" target="_blank">裸机</a>项目模板。它预先配置了所需的依赖注入、路由和linter，因此您不必设置所有这些。基本的文件夹结构如下所示:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/f663adaf989d386b2bbed633f63e1d50.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*UuqktltVIF87fZnRMAGmXg.png"/></div></figure><h1 id="e128" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">畴层</h1><p id="e23c" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">首先，我们在域层下为身份验证特性创建一个文件夹。这一层保存auth用户模型类、自定义身份验证失败和用于与身份验证服务通信的接口。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/65d3cea64171c9de9b9eba6a00d31c09.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*AqMcspU8WQ_dxsd3ezszig.png"/></div></figure><p id="d4ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://pub.dev/packages/freezed" rel="noopener ugc nofollow" target="_blank">冻结的</a>包用于生成模型类。freezed的一个优点是支持值相等。在不冻结的情况下，如果两个实例的对象引用相同，<code class="fe mh mi mj mk b">==</code>返回true。Freezed覆盖了<code class="fe mh mi mj mk b">==</code>操作符和<code class="fe mh mi mj mk b">hashCode</code>，这样我们就不用编写样板代码了。你可以从官方文档<a class="ae kw" href="https://dart.dev/guides/language/effective-dart/design#equality" rel="noopener ugc nofollow" target="_blank">中读到更多关于Dart语言中的平等的内容。</a></p><p id="4270" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的用户模型类很简单。任何登录的用户都会有一个用户id和一个<code class="fe mh mi mj mk b">phoneNumber</code>。当用户未登录时，两个字段都将是空字符串:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="914c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当用户想要用电话号码登录时，存在一些需要处理的失败场景:</p><ul class=""><li id="933e" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv ms mt mu mv bi translated">用户可能输入了无效的电话号码。</li><li id="76d4" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">输入SMS代码的超时时间可能已过。</li><li id="ed39" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">用户输入的验证码可能不正确。</li><li id="5709" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">用户会话可能会过期。</li><li id="43bb" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">服务器可能关闭了。</li><li id="5978" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">用户滥用身份验证服务，请求过多。</li><li id="3f2b" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">用户设备不支持电话号码登录(模拟器)。</li></ul><p id="666b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要处理上述场景，并通知我们的用户哪里出错了。<a class="ae kw" href="https://github.com/spontyapp/phone_number_sign_in/blob/main/lib/domain/auth/auth_failure.dart" rel="noopener ugc nofollow" target="_blank"> AuthFailure </a>类包含用户在电话号码登录期间可能收到的错误。更具体地说，它是一个冻结的类，一个联合类型。Dart目前不支持联合；然而，freezed提供了语法类似于Kotlin的联合类:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="b2ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">认证服务负责处理四个主要功能:</p><ul class=""><li id="9a0f" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv ms mt mu mv bi translated">身份验证状态更改时通知。</li><li id="d800" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">从服务中注销。</li><li id="9fbc" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">发送电话号码到后端，发出错误信息，如果有的话。</li><li id="3683" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">发送短信代码到后端进行验证，发出错误消息，如果有的话。</li></ul><p id="d0b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们创建一个接口来与认证服务通信。因此，应用层将只知道接口，这将使认证服务独立于Firebase。以下方法与任何认证服务都没有严格的关系。认证服务的抽象允许后端的无缝改变(Firebase，AWS，Azure)。</p><p id="1181" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用的返回类型来自一个名为<a class="ae kw" href="https://pub.dev/packages/dartz" rel="noopener ugc nofollow" target="_blank"> dartz </a>的函数式编程包。当用户输入电话号码并按下发送按钮时，就会触发<code class="fe mh mi mj mk b">signInWithPhoneNumber</code>方法。它会发出一个<code class="fe mh mi mj mk b">AuthenticationFailure</code>或者一个<code class="fe mh mi mj mk b">verificationId</code>。收到验证id意味着用户将收到一条短信。当用户输入<code class="fe mh mi mj mk b">smsCode</code>时，我们会将其与验证id一起发送到服务器，以完成登录。它返回一个<code class="fe mh mi mj mk b">AuthFailure</code>或者通过返回<code class="fe mh mi mj mk b">Unit</code>返回成功。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h1 id="c760" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">基础设施层</h1><p id="bba9" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">既然认证服务的抽象已经完成，我们就准备好实现<code class="fe mh mi mj mk b">FirebaseAuthService</code>。与域层类似，为身份验证功能创建了一个子文件夹。该文件夹下有两个文件:</p><ul class=""><li id="821f" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv ms mt mu mv bi translated"><code class="fe mh mi mj mk b">FirebaseAuthService</code>实现了<code class="fe mh mi mj mk b">IAuthService</code>。</li><li id="2453" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">将firebase用户映射到我们的<code class="fe mh mi mj mk b">AuthUserModel</code>类的扩展方法。</li></ul><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/049a70e303494d3f1b6906d7a9c60a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/1*KHmZbvsQbMv--ijupAqUtg.png"/></div></figure><p id="7448" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">依赖注入用于实例化FirebaseAuthService。如果您不熟悉<a class="ae kw" href="https://stackoverflow.com/questions/130794/what-is-dependency-injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>或<a class="ae kw" href="https://pub.dev/packages/injectable" rel="noopener ugc nofollow" target="_blank">可注入</a>包，您可以查看<a class="ae kw" href="https://medium.com/r?url=https%3A%2F%2Fresocoder.com%2F2020%2F02%2F04%2Finjectable-flutter-dart-equivalent-to-dagger-angular-dependency-injection%2F" rel="noopener">链接资源</a>。<code class="fe mh mi mj mk b">InjectableModule</code>注册第三方依赖项需要类:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="6991" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们创建实现<code class="fe mh mi mj mk b">IAuthService</code>的<code class="fe mh mi mj mk b">FirebaseAuthService</code>类。可注入包将为我们创建一个<code class="fe mh mi mj mk b">FirebaseAuthService</code>的单例实例。如果您想将认证服务从Firebase切换到AWS，您唯一需要做的就是为<code class="fe mh mi mj mk b">AmazonAuthService</code>实现<code class="fe mh mi mj mk b">IAuthService</code>接口，并将其注册为<code class="fe mh mi mj mk b">IAuthService</code>。这提供了在不同服务提供商之间切换的灵活性，而无需修改业务逻辑。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="8466" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以从<a class="ae kw" href="https://firebase.flutter.dev/docs/auth/phone/" rel="noopener ugc nofollow" target="_blank">官方文档</a>中找到Firebase手机认证的设置说明。本文的范围不包括Firebase Auth的设置。</p><p id="eaae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">signInWithPhoneNumber</code>是我们将要编写的最棘手的方法，因为<code class="fe mh mi mj mk b">verifyPhoneNumber</code>是由Firebase实现的。Firebase要求我们处理四个回调:</p><blockquote class="nc nd ne"><p id="ef64" class="jy jz nf ka b kb kc kd ke kf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku kv ij bi translated"><a class="ae kw" href="https://firebase.flutter.dev/docs/auth/phone/#verificationCompleted" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">验证完成</strong> </a>:自动处理Android设备上的短信代码。</p><p id="23c2" class="jy jz nf ka b kb kc kd ke kf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku kv ij bi translated"><a class="ae kw" href="https://firebase.flutter.dev/docs/auth/phone/#verificationFailed" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">验证失败</strong> </a>:处理电话号码无效、是否超过短信限额等失败事件。</p><p id="1ae4" class="jy jz nf ka b kb kc kd ke kf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku kv ij bi translated"><a class="ae kw" href="https://firebase.flutter.dev/docs/auth/phone/#codeSent" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> codeSent </strong> </a>:当一个代码从Firebase发送到设备时的处理，用于提示用户输入代码。</p><p id="f04a" class="jy jz nf ka b kb kc kd ke kf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku kv ij bi translated"><a class="ae kw" href="https://firebase.flutter.dev/docs/auth/phone/#codeAutoRetrievalTimeout" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">codeAutoRetrievalTimeout</strong></a>:处理短信代码自动处理失败时的超时。</p></blockquote><p id="9b68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在同一个<code class="fe mh mi mj mk b">signInWithPhoneNumber</code>进程中可以触发多个回调。例如，当从Firebase接收到SMS代码时，就会触发<code class="fe mh mi mj mk b">codeSent</code>回调。如果用户有Android设备，还会触发<code class="fe mh mi mj mk b">verificationCompleted</code>回调，让用户自动登录，而无需输入短信代码。此外，在此过程中，用户可能会收到验证失败的消息。我们需要在UI中表示这些错误。</p><p id="9900" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大多数教程将UI与回调中的逻辑结合在一起。UI不应该包含任何与Firebase Auth实现相关的内容。<code class="fe mh mi mj mk b">signInWithPhoneNumber</code>返回一个流。如果触发了<code class="fe mh mi mj mk b">codeSent</code>回调，就会产生一个验证id。如果验证由于某种原因失败，该方法产生一个<code class="fe mh mi mj mk b">AuthFailure</code>。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="b062" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果<code class="fe mh mi mj mk b">signInWithPhoneNumber</code>方法成功运行，它将通过<code class="fe mh mi mj mk b">codeSent</code>回调返回一个验证id。用户的设备应该很快就会收到来自Firebase的SMS代码。此时，我们会要求用户填写短信代码。</p><p id="612b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">verifySmsCode</code>将输入的SMS代码发送给Firebase Auth以完成验证。如果出错，该方法将返回相应的失败。例如，用户可能输入不正确的SMS代码。在这种情况下，将返回无效的验证码失败。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="22b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要一个让用户退出的方法:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="bde7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论是<code class="fe mh mi mj mk b">signOut</code>还是<code class="fe mh mi mj mk b">verifySmsCode</code>都没有给我们任何关于用户认证状态是否改变的线索。幸运的是，Firebase为我们提供了一个观察身份验证状态变化的流。<code class="fe mh mi mj mk b">authStateChanges</code>流用于了解用户是否登录。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="ml mm l"/></div></figure></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="caaf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着<code class="fe mh mi mj mk b">FirebaseAuthService</code>的实现，域和基础设施层都完成了。恭喜你！在下一部分中，我们将处理应用层中的状态管理。最后，我们将把业务逻辑组件集成到表示层的UI中。下一部分再见:</p><p id="47a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://medium.com/@erkansahin/how-to-architect-a-production-level-app-in-flutter-phone-number-sign-in-part-2-63fff0bb79b1" rel="noopener">第二部分:如何在Flutter中构建一个产品级的应用:电话号码认证</a></p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="nq mm l"/></div></figure></div></div>    
</body>
</html>