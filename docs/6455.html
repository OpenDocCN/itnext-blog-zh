<html>
<head>
<title>Paged-Based Pagination with Azure CosmosDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Azure CosmosDB实现基于页面的分页</h1>
<blockquote>原文：<a href="https://itnext.io/paged-based-pagination-with-azure-cosmosdb-319a23f2a2c7?source=collection_archive---------4-----------------------#2021-11-21">https://itnext.io/paged-based-pagination-with-azure-cosmosdb-319a23f2a2c7?source=collection_archive---------4-----------------------#2021-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e6fea89813a1729314da4dd8b0f23255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4wCqZURyFKDL4MniolhDSg.png"/></div></div></figure><h1 id="1c4b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">设置</h1><p id="3b56" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在<a class="ae lu" href="https://www.cloudpwr.com/" rel="noopener ugc nofollow" target="_blank">我的工作</a>我为美国成千上万的用户制作无服务器的网络应用程序。过去几个月，我一直在为一个州政府实施一个相当大的项目。这个最新项目部署在微软的Azure平台上，我有机会深入研究各种Azure服务。今天，我想分享一些我使用<a class="ae lu" href="https://azure.microsoft.com/en-us/services/cosmos-db/" rel="noopener ugc nofollow" target="_blank"> Azure CosmosDB </a>作为静态前端后端的经验。</p><h1 id="203c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">问题是</h1><p id="3bcd" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">CosmosDB是Azure的NoSQL数据库解决方案。有几个不同的API前端(如Cassandra，Mongo等)，但他们也有一个核心的SQL API前端，这是我最终在项目中使用的。客户的需求之一是让批准的工作项目表总是显示在他们的管理仪表板中。</p><p id="1d5b" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我可以查询所有已批准的工作项，并将它们放入表中，但是由于已批准的项的数量只会随着时间的推移而增加，加载管理仪表板会越来越慢，因为必须下载越来越多的已批准项。我觉得我们可以做得更好。</p><p id="9993" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">通常这就是分页发挥作用的地方。不需要下载所有记录，一次下载一页记录即可。幸运的是，CosmosDB通过使用延续令牌支持分页。</p><p id="aa60" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">延续标记就像查询的书签。这个想法是，例如，你在数据库中有1000条记录。您的页面大小是25项，所以您告诉CosmosDB一次只返回这些记录中的25项。除了这25条记录，CosmosDB还会给您发送一个延续令牌。如果您在下一个请求中提供这个令牌，查询将从它停止的地方“继续”并*继续*查询，为您提供接下来的25条记录。</p><p id="12f9" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这对于许多用例非常有用，比如当你向下滚动页面时，博客上的文章会不断加载。但是延续标记只是一个时间点——在CosmosDB告诉我们已经到达终点之前，我们不知道还剩下多少条记录。我们也不能轻易后退。我们的continuation令牌将获得下一组记录，但是我们之前的所有结果都不见了，需要重新查询。</p><p id="c672" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">除此之外，我为这些批准的项目使用的前端表组件有一个基于页面的异步API。它想要一个总页数，它想要向前或向后得到任意一页的记录值。</p><p id="1df3" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我需要找到一种方法，在CosmosDB的基础上为表格提供一个漂亮的基于页面的界面。</p><h1 id="7155" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">解决方案(或至少一个可能的解决方案！)</h1><p id="2e88" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">对于那些只想<em class="ma">看看代码的人来说</em>这里是我想出的一个演练如下:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="a675" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这是作为一个Azure函数编写的，但是这个想法对于你正在使用的任何后端都是一样的。为了理解这是怎么回事，让我们看一下请求本身:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="fe0f" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">对于对后端的第一个请求，我们提供三条信息。</p><ol class=""><li id="1ae3" class="mh mi iq ky b kz lv ld lw lh mj ll mk lp ml lt mm mn mo mp bi translated">存放数据的容器。</li><li id="1fee" class="mh mi iq ky b kz mq ld mr lh ms ll mt lp mu lt mm mn mo mp bi translated">我们希望看到的页面(通常是第1页，但也可以是任何页面)</li><li id="6667" class="mh mi iq ky b kz mq ld mr lh ms ll mt lp mu lt mm mn mo mp bi translated">每页的结果数。</li></ol><p id="af56" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我们可以选择在这里提供一个过滤器(本质上是WHERE子句)。请注意，我们没有为令牌或“totalCount”提供值。该函数将在响应中包含这些值。</p><p id="e6c1" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">跳过一些样板文件，下面是下一个重要的部分。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="aa0e" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">相对而言，获取所有可能结果的总数是一项开销很大的操作。所以我们只需要查询一次，然后将值缓存到函数的响应中。在后续请求中，前端可以传递项目的总数，这样我们就不必再次查找这个值。</p><p id="e308" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">前端还可以通过从请求中省略缓存的计数值来选择在任何时候重新生成该总计数。这在以后变得很重要。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="b3bb" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">现在我们设置各种项目，比如对容器的查询。如果我们有一个过滤器，我们将它连接到基本查询(简单地询问容器中的所有内容。)接下来，我们第一次提到延续令牌。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="231b" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我们的令牌通过这个令牌容器传递给函数，这个容器是一个包含字符串数组的对象。但是请记住，我们并没有通过第一个请求。该功能本身处理该结构的维护和保养。</p><p id="f260" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我们首先通过过滤器值和页面大小的任意连接来生成令牌索引。这使得键看起来像这样:</p><pre class="mb mc md me gt mv mw mx my aw mz bi"><span id="d1a2" class="na jz iq mw b gy nb nc l nd ne">|25<br/>|10<br/>c.status="approved"|25<br/>c.name LIKE "%foo%"|30</span></pre><p id="430d" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">令牌容器存储过滤器和页面大小的每个组合的延续令牌。存储的值是一个最多包含N个项目的数组，其中N是总页数。这个数组中的每一项都是一个单独的延续标记。我们为不同的过滤器和页面大小存储不同的数组的原因是，项目的总数基于这些事情而变化。这让我们在前端表中拥有过滤和分页功能，并且仍然允许任意页面访问。因为我们存储了这些延续令牌，所以我们可以高效轻松地向前和向后<em class="ma"/>。</p><p id="15db" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">现在我们有了我们的令牌索引，我们看看我们的容器中是否有与之匹配的令牌数组。如果有，我们会储存起来以备后用。</p><p id="7522" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">最后，我们根据记录总数和页面大小计算总页数。然后，我们将这个值固定在总页数上。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="1a54" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">最后，我们得到了函数的核心。我们做的第一件事是从令牌容器中找到令牌数组中最后一个延续令牌的索引。</p><p id="93cc" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">请记住延续标记的工作方式，它们将用于获取下一组结果的<em class="ma">。这意味着我们想要的延续标记将出现在数组项上，就在当前标记之前。例如，如果我们试图得到第3页:</em></p><pre class="mb mc md me gt mv mw mx my aw mz bi"><span id="ff81" class="na jz iq mw b gy nb nc l nd ne">[token1, token2, token3, token 4]<br/>              ^---|We want the token stored here to <br/>                  |get the page 3 results.</span></pre><p id="e964" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">现在我们差不多完成了。如果我们的最后一个标记索引是-1，那么就没有最后一个标记。这意味着这是一个新的请求，所以我们获取我们的结果页面，并将延续标记放入空的标记数组中。</p><p id="e7d6" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">接下来，如果我们请求的页面小于最后一个令牌索引，这意味着我们已经为该页面获取了一个令牌。因此，我们使用页面的延续标记来查询结果页面。这就是允许任意页面访问的原因。</p><p id="c3dc" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">最后，用户请求了一个我们还没有令牌的页面。因此，我们遍历每个页面，从我们获取的最后一个页面，到用户请求的页面。我们沿途隐藏令牌，所以即使用户没有请求这些页面，我们也已经准备好了，如果他们将来这样做的话。</p><p id="7d89" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">如果用户要求结果的最后一页，这意味着我们将遍历结果集中的每一页。但是，我们只返回一页结果。因此，即使在这种最坏的情况下，我们仍然缓存所有的延续令牌以供将来使用，用户不会被数据淹没。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="ff61" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">现在我们结束了。如果没有传递给我们一个新的令牌容器，我们可能会创建一个新的令牌容器，并向其中添加新的令牌数组。然后，我们将我们的响应传递回前端，但现在我们正在填充令牌容器、totalPages和totalCount。前端存储这些值供以后使用。</p><p id="0b02" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">在随后的请求中，前端只需将总计数和令牌容器传递回函数，并在下一页继续。</p><h1 id="a35c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">最终位</h1><p id="61a1" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们最终还是到了这里。我确实想再提一件关于Order By子句的事情。你完全可以使用它们，但是如果你这样做了，一定要把它们添加到标记索引中，因为它们自然会影响延续标记。不幸的是，当您进行跨分区查询时，Order By子句不能与延续标记一起使用。您将不会从查询中得到延续标记。我希望这是一个将来会被取消的限制。但是，如果您正在进行单分区查询，那么就大胆地将order by子句包含到这个查询中。效果很好。</p><p id="bb5a" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">无论如何，今天就够了。希望这能帮助一些人。关于如何使用CosmosDB进行分页，有大约一百万个堆栈溢出问题。我希望这能给你们中的一些人提供一个可行的解决方案。</p></div></div>    
</body>
</html>