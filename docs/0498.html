<html>
<head>
<title>Partial Reactive Form With Angular Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有角分量的部分反应形式</h1>
<blockquote>原文：<a href="https://itnext.io/partial-reactive-form-with-angular-components-443ca06d8419?source=collection_archive---------2-----------------------#2018-03-20">https://itnext.io/partial-reactive-form-with-angular-components-443ca06d8419?source=collection_archive---------2-----------------------#2018-03-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a658e1d08edca62665756892358dc703.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G1Jync_YShfbur3nOWI9Sw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">组成一个整体的多个部分</figcaption></figure><p id="f1e0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是我即将发布的多篇帖子中的第一篇，我想分享我的一个个人项目的进展。</p><p id="6a64" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最近我不得不实现一个页面，里面有一个相对较大的表单。我想设计它，所以我会将所有相关的领域分为自己的组，每个组都有一个稍微不同的设计和逻辑。</p><p id="5887" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我选择做大多数Angular开发人员可能会做的事情:构建几个组件，让它们操作自己的表单，并使用反应式表单来更好地处理表单本身。</p><p id="6534" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了这篇文章，让我们假设我想实现一个简单的订单结帐，它将有一个<code class="fe lb lc ld le b">fullName</code>字段，以及两个部分<code class="fe lb lc ld le b">billing</code>和<code class="fe lb lc ld le b">shipping</code>。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="edcb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">TL；这是我们目标的一个演示。</strong></p><p id="f9cb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们想要做的事情的基本思想是让我们的父组件处理通用字段(<code class="fe lb lc ld le b">fullName</code>)，让组件构建自己的表单(从而将逻辑从父组件中分离出来)并将其与父组件同步。</p><p id="5d86" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">听起来相当简单直观，对吧？</p><p id="3de2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae lm" href="https://blog.angularindepth.com/@cartant?source=post_header_lockup" rel="noopener ugc nofollow" target="_blank"> Nicholas Jamieson </a>在他的一篇<a class="ae lm" href="https://blog.angularindepth.com/connecting-components-with-reactive-forms-55f56fce2aad" rel="noopener ugc nofollow" target="_blank">帖子</a>中提出使用反应式的<code class="fe lb lc ld le b">valueChanges</code>能力来解决这个问题，这种能力可以在每次变化时将值发送给父节点。</p><p id="346e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这很好。但是我想要一个解决方案，我可以做一个<strong class="ke ir">单个</strong>动作来‘绑定’我的嵌套表单和父表单。</p><p id="a6eb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此..不，那对我来说还不够好。</p><p id="d847" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后我读了大卫·赫格斯的<a class="ae lm" href="https://medium.com/@davidh_23?source=post_header_lockup" rel="noopener"/><a class="ae lm" href="https://medium.com/spektrakel-blog/angular2-building-nested-reactive-forms-7978ecd145e4" rel="noopener">解决方案</a>，找到了我想要的。他在我们的父组件中创建了一个<code class="fe lb lc ld le b">formGroup</code>，并将其注入到子组件中，然后对其进行处理。<em class="la">单次</em>简单动作。</p><p id="e429" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">…但是它不是把我们的孩子和它的父母结合在一起了吗？</p><p id="ef82" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">是的。是的，它是。如果我们决定删除其中一个字段，我们必须重构父字段和子字段。</p><p id="145b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对此，我的解决方案是采用<a class="ae lm" href="https://medium.com/@davidh_23?source=post_header_lockup" rel="noopener"> David Herges </a>的解决方案，但从另一方面实施。我们将在我们的子组件中创建表单，当它准备好时，我们将通知父组件一个新的表单组已经初始化，并在表单中设置它。</p><p id="6943" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们看看这里的一些代码。我们的子组件优先:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="59dc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当我们的表单准备好了，我们使用Angular的<code class="fe lb lc ld le b">@Output</code>来发出它。</p><p id="bdb2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们看看如何在我们的父母中处理这个问题:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="4eb4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">就是这样！我们将表单分成几个块，但是我们仍然得到一个与小表单同步的整体表单。</p><p id="9170" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以点击查看完整代码<a class="ae lm" href="https://stackblitz.com/edit/monolithic-reactive-form" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="d7a3" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">异步初始数据</h1><p id="2848" class="pw-post-body-paragraph kc kd iq ke b kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz ij bi translated">我的挑战还没有结束。</p><p id="53a5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">与大多数web应用程序一样，我们倾向于用从服务器接收的数据预填充表单。例如— <code class="fe lb lc ld le b">User</code>。</p><p id="1f34" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们所要做的就是将用户数据传递到子组件中，用<code class="fe lb lc ld le b"><a class="ae lm" href="https://angular.io/api/core/OnChanges" rel="noopener ugc nofollow" target="_blank">OnChanges</a></code> <a class="ae lm" href="https://angular.io/api/core/OnChanges" rel="noopener ugc nofollow" target="_blank"> </a>生命周期钩子发现变化(我们可以更进一步，用<code class="fe lb lc ld le b"><a class="ae lm" href="https://angular.io/api/core/SimpleChange#firstChange" rel="noopener ugc nofollow" target="_blank">SimpleChange.firstChange</a></code>只在第一次或每次变化时填充它)，并修补表单值。</p><p id="e09f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是我们的子组件，支持异步接收用户:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="3f2d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里是<a class="ae lm" href="https://stackblitz.com/edit/monolithic-reactive-form-async-fill" rel="noopener ugc nofollow" target="_blank">演示</a></p><h1 id="94d7" class="lt lu iq bd lv lw mw ly lz ma mx mc md me my mg mh mi mz mk ml mm na mo mp mq bi translated">结论</h1><p id="033d" class="pw-post-body-paragraph kc kd iq ke b kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz ij bi translated">我们设法找到了一种方法，将我们的形状分成几个组件，并将它们从周围环境中分离出来，但仍然能够同步它们，并仅使用<em class="la">的</em>反应形式和Angular的<code class="fe lb lc ld le b">@Input</code> <code class="fe lb lc ld le b">@Output</code>获得一个流体形状对象。</p><p id="f63b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">似乎我们用很少的收获了很多。</p></div></div>    
</body>
</html>