<html>
<head>
<title>HTML to PDF using a Chrome puppet in the cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在云中使用Chrome傀儡将HTML转换为PDF</h1>
<blockquote>原文：<a href="https://itnext.io/html-to-pdf-using-a-chrome-puppet-in-the-cloud-de6e6a0dc6d7?source=collection_archive---------0-----------------------#2019-05-01">https://itnext.io/html-to-pdf-using-a-chrome-puppet-in-the-cloud-de6e6a0dc6d7?source=collection_archive---------0-----------------------#2019-05-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7ccd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将带您了解设置一个无头chrome浏览器的过程，您可以在AWS上运行该浏览器，并使用API来做浏览器可以做的大多数事情。我们今天的目标是让chrome导航到一个URL，等待页面完全加载，然后创建一个PDF。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="6d59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">chromium团队已经发布了无头chrome节点API木偶师。</p><div class="ks kt gp gr ku kv"><a href="https://github.com/GoogleChrome/puppeteer" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab fo"><div class="kx ab ky cl cj kz"><h2 class="bd ir gy z fp la fr fs lb fu fw ip bi translated">谷歌色素/木偶师</h2><div class="lc l"><h3 class="bd b gy z fp la fr fs lb fu fw dk translated">无头Chrome节点API。在GitHub上创建一个帐户，为Google chrome/木偶师的发展做出贡献。</h3></div><div class="ld l"><p class="bd b dl z fp la fr fs lb fu fw dk translated">github.com</p></div></div><div class="le l"><div class="lf l lg lh li le lj lk kv"/></div></div></a></div><blockquote class="ll lm ln"><p id="39d7" class="jn jo lo jp b jq jr js jt ju jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj kk ij bi translated">Puppeteer是一个节点库，它提供了一个高级API来控制Chrome或通过<a class="ae ls" href="https://chromedevtools.github.io/devtools-protocol/" rel="noopener ugc nofollow" target="_blank"> DevTools协议</a>的Chrome。木偶师默认运行无头的<a class="ae ls" href="https://developers.google.com/web/updates/2017/04/headless-chrome" rel="noopener ugc nofollow" target="_blank">，但可以配置为运行全(无头)铬或铬。</a></p></blockquote><p id="ad99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有一个非常有用的网站，你可以去试试木偶戏:<a class="ae ls" href="https://try-puppeteer.appspot.com/" rel="noopener ugc nofollow" target="_blank">https://try-puppeteer.appspot.com/</a>。他们提供的创建pdf的示例代码如下所示:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="bcd1" class="mc md iq ly b gy me mf l mg mh">const browser = await puppeteer.launch();<br/>  const page = await browser.newPage();<br/>  await page.goto('<a class="ae ls" href="https://news.ycombinator.com'" rel="noopener ugc nofollow" target="_blank">https://news.ycombinator.com'</a>, {waitUntil: 'networkidle2'});<br/>  await page.pdf({<br/>    path: 'hn.pdf',<br/>    format: 'letter'<br/>  });</span><span id="005e" class="mc md iq ly b gy mi mf l mg mh">await browser.close();</span></pre><p id="b23d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面使用的API在这里有很好的记录<a class="ae ls" href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md" rel="noopener ugc nofollow" target="_blank"/>。看一下page.pdf，我们看到该函数接受一组选项，并返回一个用PDF缓冲区解析的承诺。这些选项给了你很好的控制。如果您不想消耗缓冲区、控制页眉、页脚和页面格式等，您可以设置保存pdf的路径。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><h1 id="34e8" class="mj md iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">构建和部署到AWS</h1><p id="c5cb" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk ij bi translated">在我们开始之前，您需要在您的机器上安装node8.10和npm，并且您需要一个AWS帐户来部署您的代码。AWS Lambda有一个相当慷慨的免费层—参见<a class="ae ls" href="https://aws.amazon.com/lambda/pricing/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda定价</a></p><h2 id="60ca" class="mc md iq bd mk nl nm dn mo nn no dp ms jy np nq mw kc nr ns na kg nt nu ne nv bi translated">无服务器</h2><p id="be7f" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk ij bi translated">我将使用无服务器框架，我发现这是部署到AWS的最简单的方法。如果您以前没有使用过无服务器，请从安装cli开始:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="f079" class="mc md iq ly b gy me mf l mg mh">npm install -g serverless</span></pre><p id="7a82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，您需要设置您的AWS凭证:</p><figure class="lt lu lv lw gt nw"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">如何创建AWS访问键</figcaption></figure><p id="f073" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成设置后，创建您的项目。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="3650" class="mc md iq ly b gy me mf l mg mh">serverless create --template aws-nodejs --path ./lambda-puppeteer</span></pre><p id="266b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将创建lambda-puppeter文件夹，其中包含一个基本的javascript lambda部署项目。</p><p id="3577" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的偏好是使用typescript而不是普通的javascript，所以我们将把项目转换成下面的typescript。上面可以使用无服务器模板<code class="fe od oe of ly b">aws-nodejs-typescript</code>,但是它创建了一个遗漏了许多有用注释的项目，并且它包含了我们不需要的webpack。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="437a" class="mc md iq ly b gy me mf l mg mh">cd lambda-puppeteer</span></pre><p id="8952" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">yml文件包含了部署项目所需的所有配置，模板创建了一个可以直接部署和测试的项目。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="eecd" class="mc md iq ly b gy me mf l mg mh">serverless deploy -v</span></pre><p id="3247" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在用以下命令测试您的函数并查看日志:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="3088" class="mc md iq ly b gy me mf l mg mh">serverless invoke -f hello -l</span><span id="5f8a" class="mc md iq ly b gy mi mf l mg mh">serverless logs -f hello -t</span></pre><h2 id="3e09" class="mc md iq bd mk nl nm dn mo nn no dp ms jy np nq mw kc nr ns na kg nt nu ne nv bi translated">铬和木偶核心</h2><p id="6eee" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk ij bi translated">Lambda有50Mb的部署限制(除非使用<a class="ae ls" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html" rel="noopener ugc nofollow" target="_blank">层</a>),但是社区提供了一种简单的方法来部署大约35Mb的包中所需的一切。我们将使用这个库获得我们需要的chromium依赖项:</p><div class="ks kt gp gr ku kv"><a href="https://github.com/alixaxel/chrome-aws-lambda" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab fo"><div class="kx ab ky cl cj kz"><h2 class="bd ir gy z fp la fr fs lb fu fw ip bi translated">alix axel/chrome-AWS-λ</h2><div class="lc l"><h3 class="bd b gy z fp la fr fs lb fu fw dk translated">AWS Lambda的铬二进制。通过在GitHub上创建一个帐户，为alixaxel/chrome-aws-lambda开发做出贡献。</h3></div><div class="ld l"><p class="bd b dl z fp la fr fs lb fu fw dk translated">github.com</p></div></div><div class="le l"><div class="og l lg lh li le lj lk kv"/></div></div></a></div><p id="dd84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">初始化节点程序包管理器:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="6913" class="mc md iq ly b gy me mf l mg mh">npm init</span></pre><p id="549d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接受项目设置的默认值即可。</p><p id="7596" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">添加铬:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="e4ae" class="mc md iq ly b gy me mf l mg mh">npm i chrome-aws-lambda --save</span></pre><p id="90f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以及puppeteer-core，这是一个默认情况下不下载Chromium的puppeteer版本:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="d1ad" class="mc md iq ly b gy me mf l mg mh">npm i puppeteer-core --save</span></pre><h2 id="a555" class="mc md iq bd mk nl nm dn mo nn no dp ms jy np nq mw kc nr ns na kg nt nu ne nv bi translated">使用typescript</h2><p id="3279" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk ij bi translated">有很多方法可以为typescript配置项目，比如使用<code class="fe od oe of ly b">serverless-plugin-typescript</code>。在这种情况下，我们将分五步手动转换项目:</p><p id="1b9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.安装typescript</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="c7cd" class="mc md iq ly b gy me mf l mg mh">npm i --save-dev typescript</span></pre><p id="e55c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.将<code class="fe od oe of ly b">handler.js</code>更名为<code class="fe od oe of ly b">handler.ts</code></p><p id="565b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.安装节点类型:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="bbe6" class="mc md iq ly b gy me mf l mg mh">npm i @types/node</span></pre><p id="7c62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.添加一个包含以下内容的<code class="fe od oe of ly b">tsconfig.json</code>文件:</p><figure class="lt lu lv lw gt nw"><div class="bz fp l di"><div class="oh ny l"/></div></figure><p id="7200" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.将这两个脚本添加到<code class="fe od oe of ly b">package.json</code>:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="2a55" class="mc md iq ly b gy me mf l mg mh">"scripts": {<br/>  "build": "tsc",<br/>  "deploy": "npm run build &amp;&amp; serverless deploy",<br/>  ...<br/>},</span></pre><p id="bb88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们添加了一个deploy命令，该命令将编译typescript并执行无服务器部署。您还可以通过定义一个测试脚本并将deploy更改为<code class="fe od oe of ly b">npm run build &amp;&amp; npm run test &amp;&amp; serverless deploy</code>，将测试作为部署的一部分来运行。</p><h1 id="4161" class="mj md iq bd mk ml oi mn mo mp oj mr ms mt ok mv mw mx ol mz na nb om nd ne nf bi translated">实现服务</h1><p id="b3fb" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk ij bi translated">我们的pdf服务将有以下界面:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="12e2" class="mc md iq ly b gy me mf l mg mh">export interface PdfService {<br/>  getPdf(url: string): Promise&lt;Buffer&gt;;<br/>}</span></pre><p id="9d68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们公开了一个函数，它接受一个URL参数并返回一个包含URL内容的PDF的缓冲区。</p><p id="03d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个名为<code class="fe od oe of ly b">pdf-service.ts</code>的文件，并将上面的接口代码添加到其中。</p><p id="72ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该接口的实现如下所示:</p><figure class="lt lu lv lw gt nw"><div class="bz fp l di"><div class="oh ny l"/></div></figure><p id="6d98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将上面的实现代码添加到<code class="fe od oe of ly b">pdf-service.ts</code>中，使其包含接口和实现。</p><p id="f6e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这段代码扩展了本文开头附近的简单示例。需要注意的一点是我已经包括的<code class="fe od oe of ly b">waitUntil</code>选项。该设置决定何时认为导航成功，默认为<code class="fe od oe of ly b">load</code>。当指定事件字符串数组时，在所有事件都被激发后，导航被认为是成功的。</p><ul class=""><li id="1884" class="on oo iq jp b jq jr ju jv jy op kc oq kg or kk os ot ou ov bi translated"><code class="fe od oe of ly b">load</code> -当<code class="fe od oe of ly b">load</code>事件触发时，认为导航完成。</li><li id="c485" class="on oo iq jp b jq ow ju ox jy oy kc oz kg pa kk os ot ou ov bi translated"><code class="fe od oe of ly b">domcontentloaded</code> -当<code class="fe od oe of ly b">DOMContentLoaded</code>事件被触发时，认为导航完成。</li><li id="e8b2" class="on oo iq jp b jq ow ju ox jy oy kc oz kg pa kk os ot ou ov bi translated"><code class="fe od oe of ly b">networkidle0</code> -当至少<code class="fe od oe of ly b">500</code>毫秒没有超过0个网络连接时，认为导航结束</li></ul><p id="7c13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，在这三项中的最后一项完成之前，捕获pdf不会继续进行。</p><h2 id="b5c4" class="mc md iq bd mk nl nm dn mo nn no dp ms jy np nq mw kc nr ns na kg nt nu ne nv bi translated">连接到https端点</h2><p id="0fd4" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk ij bi translated">为了使我们的服务可调用，我们将处理程序代码改为:</p><figure class="lt lu lv lw gt nw"><div class="bz fp l di"><div class="oh ny l"/></div></figure><p id="7a45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们将从我们的<code class="fe od oe of ly b">PdfService</code>返回的缓冲区转换成一个base64字符串。</p><p id="76c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们添加一个https端点<code class="fe od oe of ly b">/pdf</code>来调用我们的函数，将<code class="fe od oe of ly b">serverless.yml</code>的函数部分替换为:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="2b62" class="mc md iq ly b gy me mf l mg mh">functions:<br/>  pdfReport:<br/>    handler: lib/handler.pdfReport<br/>    events:<br/>     - http:<br/>        path: pdf<br/>        method: get<br/>        integration: lambda</span></pre><p id="5b35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意<code class="fe od oe of ly b">lib</code>的处理程序路径与上面<code class="fe od oe of ly b">tsconfig.json</code>中指定的<code class="fe od oe of ly b">outDir</code>相匹配。</p><p id="ab7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用我们在<code class="fe od oe of ly b">package.json</code>中定义的部署脚本来部署您的服务:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="f697" class="mc md iq ly b gy me mf l mg mh">npm run deploy</span></pre><p id="f3a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">部署完成后，我们可以通过访问无服务器部署分配的url来调用我们的pdf服务，例如:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="aa86" class="mc md iq ly b gy me mf l mg mh">https://&lt;your project id and region&gt;.amazonaws.com/dev/pdf?url=https://example.com</span></pre><p id="9207" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果一切正常，这应该会返回一个很长的base64文本响应。如果我们使用一个在线base64到pdf转换器(例如<a class="ae ls" href="https://base64.guru/converter/decode/pdf" rel="noopener ugc nofollow" target="_blank"> base64.guru </a>)将回复的文本转换成pdf，我们可以看到结果。</p><figure class="lt lu lv lw gt nw gh gi paragraph-image"><div role="button" tabindex="0" class="pc pd di pe bf pf"><div class="gh gi pb"><img src="../Images/8d63c0d016f18b59adb7a8d374486a1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bk3dx4bmUnj5xWlwDqcQxQ.png"/></div></div></figure><h2 id="549b" class="mc md iq bd mk nl nm dn mo nn no dp ms jy np nq mw kc nr ns na kg nt nu ne nv bi translated">返回应用程序/pdf</h2><p id="4bc9" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk ij bi translated">通过更改API gateway中的一些设置，您可以让您的端点返回正确的<code class="fe od oe of ly b">Content-Type</code>以显示为PDF。有一个无服务器插件可以自动完成这些设置:</p><div class="ks kt gp gr ku kv"><a href="https://www.npmjs.com/package/serverless-plugin-custom-binary" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab fo"><div class="kx ab ky cl cj kz"><h2 class="bd ir gy z fp la fr fs lb fu fw ip bi translated">无服务器插件定制二进制</h2><div class="lc l"><h3 class="bd b gy z fp la fr fs lb fu fw dk translated">为API网关启用二进制支持</h3></div><div class="ld l"><p class="bd b dl z fp la fr fs lb fu fw dk translated">www.npmjs.com</p></div></div><div class="le l"><div class="ph l lg lh li le lj lk kv"/></div></div></a></div><p id="fda2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不能让它工作，但它可能对你有用。然而，我能够按照这些说明手动进行更改，但是在您的无服务器部署之外进行配置并不理想。</p><p id="4493" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">更新:</strong>在发表这篇文章几周后，无服务器框架v1.42.0增加了对二进制媒体类型响应的支持。见这篇<a class="ae ls" href="https://serverless.com/blog/framework-release-v142/" rel="noopener ugc nofollow" target="_blank">无服务器博文</a>。</p><h2 id="8b7e" class="mc md iq bd mk nl nm dn mo nn no dp ms jy np nq mw kc nr ns na kg nt nu ne nv bi translated">添加页眉和页脚</h2><p id="f475" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk ij bi translated">您可以添加自己的HTML标记来创建自定义页眉和页脚。需要注意的一点是，页面中没有样式表可用，因此任何样式都需要内联完成。</p><p id="b2eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">页眉和页脚标记可以包含以下用于向其中注入打印值的类:</p><ul class=""><li id="9caa" class="on oo iq jp b jq jr ju jv jy op kc oq kg or kk os ot ou ov bi translated"><code class="fe od oe of ly b">date</code>格式化打印日期</li><li id="6a8f" class="on oo iq jp b jq ow ju ox jy oy kc oz kg pa kk os ot ou ov bi translated"><code class="fe od oe of ly b">title</code>文档标题</li><li id="05c7" class="on oo iq jp b jq ow ju ox jy oy kc oz kg pa kk os ot ou ov bi translated"><code class="fe od oe of ly b">url</code>文件位置</li><li id="7dec" class="on oo iq jp b jq ow ju ox jy oy kc oz kg pa kk os ot ou ov bi translated"><code class="fe od oe of ly b">pageNumber</code>当前页码</li><li id="acc7" class="on oo iq jp b jq ow ju ox jy oy kc oz kg pa kk os ot ou ov bi translated"><code class="fe od oe of ly b">totalPages</code>文档总页数</li></ul><p id="7a9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是添加包含页码的页脚的示例:</p><figure class="lt lu lv lw gt nw"><div class="bz fp l di"><div class="oh ny l"/></div></figure><p id="3c6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是它在页面上的外观:</p><figure class="lt lu lv lw gt nw gh gi paragraph-image"><div role="button" tabindex="0" class="pc pd di pe bf pf"><div class="gh gi pi"><img src="../Images/edb70817bacf06c9f21fcc20b844ec92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cN9RNravA4d6mhMlA8vDGg.png"/></div></div></figure></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="7fe1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，使用<code class="fe od oe of ly b">page.pdf</code>只是使用木偶师API在chrome上做的许多事情中的一个例子。</p><p id="8de4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天的帖子到此结束。当您使用完<code class="fe od oe of ly b">serverless remove</code>时，记得删除您的AWS资源。</p><p id="1e3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的下一篇文章<a class="ae ls" href="https://medium.com/@keith.coughtrey/running-arbitrary-executables-in-aws-lambda-encrypting-a-pdf-afea47e3c345?source=friends_link&amp;sk=22d11f9a7e4a759c51f09368a4974b30" rel="noopener">中，我们将使用命令行工具添加PDF密码保护，在本系列的第三篇文章中，我将介绍从AWS step函数调用PDF服务。</a></p><p id="129e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该系列的所有代码都可以在<a class="ae ls" href="https://github.com/keithcoughtrey/LambdaPuppeteer" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>