<html>
<head>
<title>CQRS &amp; Mediator Part 2: Domain scaffolding with Roslyn API and Dotnet CLI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CQRS和仲裁者第2部分:用Roslyn API和Dotnet CLI搭建域</h1>
<blockquote>原文：<a href="https://itnext.io/cqrs-mediator-part-2-domain-scaffolding-with-roslyn-api-and-dotnet-cli-7c99b5b011f?source=collection_archive---------3-----------------------#2020-02-10">https://itnext.io/cqrs-mediator-part-2-domain-scaffolding-with-roslyn-api-and-dotnet-cli-7c99b5b011f?source=collection_archive---------3-----------------------#2020-02-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2eeb049b160d4b2f061c34e6e586d02c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fYUK9H4TJ9gWiyA1x_hUOA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">新加坡樟宜宝石瀑布</figcaption></figure><blockquote class="kc kd ke"><p id="0dad" class="kf kg kh ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">在第2部分中，我们将构建一个dotnet CLI工具，它遵循CQRS和中介器模式，使用Roslyn API在域层自动生成命令、查询、响应和处理程序来生成代码。<a class="ae le" href="https://github.com/ArmandJ77/CQRSAndMediator-Scaffolding" rel="noopener ugc nofollow" target="_blank"> Git回购</a></p></blockquote></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="8f71" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">系列</h1><ul class=""><li id="1c7b" class="mk ml iq ki b kj mm kn mn mo mp mq mr ms mt ld mu mv mw mx bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/why-and-how-i-implemented-cqrs-and-mediator-patterns-in-a-microservice-b07034592b6d"> CQRS &amp;中介器第1部分:<br/>为什么以及如何在微服务中实现CQRS和中介器模式</a></li><li id="7b77" class="mk ml iq ki b kj my kn mz mo na mq nb ms nc ld mu mv mw mx bi translated"><a class="ae le" href="https://medium.com/@armandjordaan6/cqrs-mediator-part-2-domain-scaffolding-with-roslyn-api-and-dotnet-cli-7c99b5b011f" rel="noopener"> CQRS &amp;中介器第2部分:<br/>使用罗斯林API和Dotnet CLI的领域搭建</a></li></ul></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="ec83" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">问题</h1><p id="8412" class="pw-post-body-paragraph kf kg iq ki b kj mm kl km kn mn kp kq mo nd kt ku mq ne kx ky ms nf lb lc ld ij bi translated">CQRS模式最突出的挑战是克服开发人员需要创建的类的数量，当不断创建查询、命令、处理程序和响应对象时，这些类会变得很麻烦。</p><p id="4d69" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">为了解决这个问题，本文将带您完成创建命令行搭建工具的过程，该工具可以接受诸如模式类型、关注点和操作之类的参数。解析我们在其中执行CLI命令的目录的域的路径和名称。它不仅应该创建相应的CQRS类，还应该添加类继承，并使用正确的方法签名实现IRequestHandler接口的handle函数。</p><p id="5754" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">该工具将在创建对象时减少摩擦和上下文切换，并使用正确的命名约定正确执行方法连接，从而为开发人员提供跨领域的一致性，并使他们能够专注于实现而不是抽象。</p><p id="324a" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">总之。使开发人员能够自动化重复工作，并在未知领域进行创新。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="d7da" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">工具作业</h1><p id="96ec" class="pw-post-body-paragraph kf kg iq ki b kj mm kl km kn mn kp kq mo nd kt ku mq ne kx ky ms nf lb lc ld ij bi translated">如果您已经熟悉下面的概念和工具，请跳到代码分解的解决方案部分。</p><p id="ed98" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated"><strong class="ki ir">什么是Dotnet CLI？</strong></p><blockquote class="kc kd ke"><p id="478e" class="kf kg kh ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">的。NET Core命令行界面(CLI)是一个用于开发的跨平台工具链。NET应用程序。CLI是集成开发环境(ide)、编辑器和构建流程编排器等高级工具的基础。— <a class="ae le" href="https://docs.microsoft.com/en-us/dotnet/core/tools/?tabs=netcore2x" rel="noopener ugc nofollow" target="_blank"> MSDN </a></p></blockquote><p id="4d9d" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">观点:我更喜欢UI而不是命令行，但是Dotnet CLI是一个非常强大的工具，对Visual Studio用户(包括我自己)来说，IDE是强大的，具有丰富的功能集和高级工具支持，但是在编写windows上的VS时，它仍然不能很好地处理多项目解决方案，当谈到加载和构建速度时——每次用VS打开一个整体时，它的内部都会有点死:(</p><p id="37ef" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated"><strong class="ki ir">什么是NuGet？</strong></p><blockquote class="kc kd ke"><p id="a401" class="kf kg kh ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">任何现代开发平台的基本工具都是一种机制，开发人员可以通过这种机制创建、共享和使用有用的代码。通常，这些代码被捆绑到“包”中，包中包含编译后的代码(作为dll)以及使用这些包的项目中所需的其他内容。— <a class="ae le" href="https://docs.microsoft.com/en-us/nuget/what-is-nuget" rel="noopener ugc nofollow" target="_blank"> MSDN </a></p></blockquote><p id="d8ab" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated"><strong class="ki ir">罗斯林是什么？</strong></p><p id="4b55" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">它是。NET编译器平台AKA Roslyn，它为C#/ Visual basic开发人员提供了访问。Net编译器和丰富的代码分析API。像大多数网络世界一样，这是开源的，可以在GitHub上找到。</p><p id="84e4" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">我们将使用的API是<em class="kh">微软。CodeAnalysis </em>和<em class="kh">Microsoft . code analysis . cs harp .</em>像大多数API/库一样，有一个学习曲线，当您第一次开始时，这是非常令人生畏的，但是在查看了一些实现示例和经典RTFM之后，它像任何其他具有其概念和工作方式的API一样工作。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="512d" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">模式</h1><h2 id="fc3e" class="ng ln iq bd lo nh ni dn ls nj nk dp lw mo nl nm ma mq nn no me ms np nq mi nr bi translated">流畅的界面模式</h2><p id="a520" class="pw-post-body-paragraph kf kg iq ki b kj mm kl km kn mn kp kq mo nd kt ku mq ne kx ky ms nf lb lc ld ij bi translated">简而言之，它是一种构建器模式，允许通过使用方法链接指定对象上的函数列表来收集数据。</p><p id="7fd3" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">这可以通过以下方式实现:</p><p id="a305" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">用法:</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">实现fluent接口模式的类的示例</figcaption></figure><p id="60e4" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">实施:</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">如何实现流畅接口模式的示例</figcaption></figure><p id="11a0" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">这种模式的突出之处在于，您可以使用接口返回类型来定义特定的逻辑路径，因此我建议您首先定义接口以及逻辑将如何流动，并回顾每种可能性。</p><p id="1a04" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">关于这种模式更详细的分解，我推荐Dimitrie Tataru的文章<a class="ae le" href="https://assist-software.net/blog/design-and-implement-fluent-interface-pattern-c" rel="noopener ugc nofollow" target="_blank">如何在C#中设计和实现流畅的接口模式</a></p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="998e" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">使用</h1><p id="96f9" class="pw-post-body-paragraph kf kg iq ki b kj mm kl km kn mn kp kq mo nd kt ku mq ne kx ky ms nf lb lc ld ij bi translated"><strong class="ki ir">安装:</strong></p><pre class="ns nt nu nv gt ny nz oa ob aw oc bi"><span id="e9eb" class="ng ln iq nz b gy od oe l of og">dotnet tool install --global CQRSAndMediator.Scaffolding</span></pre><p id="82eb" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated"><strong class="ki ir">概念和命令的分解:</strong></p><p id="5dbe" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">显示帮助信息:</p><pre class="ns nt nu nv gt ny nz oa ob aw oc bi"><span id="e698" class="ng ln iq nz b gy od oe l of og">scaffold -h</span></pre><h2 id="b638" class="ng ln iq bd lo nh ni dn ls nj nk dp lw mo nl nm ma mq nn no me ms np nq mi nr bi translated">命令参数:</h2><p id="67f0" class="pw-post-body-paragraph kf kg iq ki b kj mm kl km kn mn kp kq mo nd kt ku mq ne kx ky ms nf lb lc ld ij bi translated">关注点:您正在工作的领域的名称，即订单、人员、发票等。</p><pre class="ns nt nu nv gt ny nz oa ob aw oc bi"><span id="a02e" class="ng ln iq nz b gy od oe l of og">-c|--concern &lt;NAME&gt;</span></pre><p id="40ca" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">操作:您在关注中采取的操作的名称，即查询的GetById、GetPagedResult或命令的Create、Patch、Update。</p><pre class="ns nt nu nv gt ny nz oa ob aw oc bi"><span id="8c4e" class="ng ln iq nz b gy od oe l of og">-c|--concern &lt;NAME&gt;</span></pre><p id="de0f" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">OperationType:您正在搭建的CQRS操作的类型，即命令或查询</p><pre class="ns nt nu nv gt ny nz oa ob aw oc bi"><span id="f827" class="ng ln iq nz b gy od oe l of og">-ot|--operationtype &lt;TYPE&gt;</span></pre><p id="eee8" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">GroupBy:指定如何对域操作进行分组。通过<em class="kh">关注点</em>或<em class="kh">操作</em>:通过【C】关注点或【O】操作对域对象进行分组，默认为关注点</p><pre class="ns nt nu nv gt ny nz oa ob aw oc bi"><span id="c88e" class="ng ln iq nz b gy od oe l of og">-g|--groupBy &lt;TYPE&gt;</span></pre><p id="c2ee" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">按关注点:即当参数为-c Orders -o GetById时按关注点分组</p><p id="1c7f" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">-ot查询</p><pre class="ns nt nu nv gt ny nz oa ob aw oc bi"><span id="2d38" class="ng ln iq nz b gy od oe l of og">| YourDomainLayer<br/>    | Orders<br/>        | Handlers<br/>            | OrdersGetByIdHandler.cs<br/>        | Responses<br/>            | OrdersGetByIdResponse.cs<br/>        | Queries<br/>            | OrderGetByIdQuery.cs</span></pre><p id="c379" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">按操作，即当参数为-c Orders -o GetById -ot query -g O时按操作分组</p><pre class="ns nt nu nv gt ny nz oa ob aw oc bi"><span id="4a88" class="ng ln iq nz b gy od oe l of og">| YourDomainLayer<br/>    | Handler<br/>        | OrdersGetByIdHandler.cs<br/>    | Responses<br/>        | OrdersGetByIdResponse.cs<br/>    | Queries<br/>        | OrderGetByIdQuery.cs</span></pre><p id="e36e" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated"><strong class="ki ir">注意:<br/> </strong>该工具要求项目已经建立，并且在你的领域层目录所在的顶层目录中执行动作。</p><p id="e45d" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated"><strong class="ki ir">命令示例:</strong> <br/>用例支架出一张发票的CRUD域:</p><p id="985e" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">按关注点分组时的创建命令</p><pre class="ns nt nu nv gt ny nz oa ob aw oc bi"><span id="61bb" class="ng ln iq nz b gy od oe l of og">scaffold -c Invoices -o Create -ot command</span></pre><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/ae653b2012cfb86f4e83c3adebc84d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ti1jhWMrXgnpjoQvk5btA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">脚手架发票创建命令</figcaption></figure><p id="820e" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">按关注分组时的get by id查询</p><pre class="ns nt nu nv gt ny nz oa ob aw oc bi"><span id="c32d" class="ng ln iq nz b gy od oe l of og">scaffold -c Invoices -o GetById -ot query</span></pre><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/e43ae7695368384abdebea44ba70b17e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k4OHohh2lmPx4ypHfzmFVg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">搭建OrdersGetByIdQuery</figcaption></figure><p id="fae5" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">按操作分组时的GetPaged查询</p><pre class="ns nt nu nv gt ny nz oa ob aw oc bi"><span id="e245" class="ng ln iq nz b gy od oe l of og">scaffold -c Orders -o GetPaged -ot query -g o</span></pre><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/77297157e7393394e0256a3f4f66c81d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e3_7vELTsQouORK4tlZU9w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">绞刑架</figcaption></figure><p id="01eb" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">按操作分组时的OrderCancelledCommand</p><pre class="ns nt nu nv gt ny nz oa ob aw oc bi"><span id="11aa" class="ng ln iq nz b gy od oe l of og">scaffold -c Orders -o Cancelled -ot command -g o</span></pre><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/0429dce0e90dd66b183da39d71b9f9c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cqdR7DdY8rYaH0KMoacNaw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">脚手架订单取消命令</figcaption></figure><p id="e7d9" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">使用CRUD操作只是一个例子，不需要解释特定领域语言的复杂性和规则。归根结底，CQRS模式不在乎它是一个CRUD操作还是一个复杂的领域规则，它都归结为一个命令或一个查询。</p><h1 id="e9d5" class="lm ln iq bd lo lp ol lr ls lt om lv lw lx on lz ma mb oo md me mf op mh mi mj bi translated">解决办法</h1><p id="c686" class="pw-post-body-paragraph kf kg iq ki b kj mm kl km kn mn kp kq mo nd kt ku mq ne kx ky ms nf lb lc ld ij bi translated">我们将看看NuGet包的项目以及它是如何实现的。该工具将在第1部分的解决方案结构中执行，因此将只关注输出，而不会深入目标解决方案的域层的域设置。参见<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/why-and-how-i-implemented-cqrs-and-mediator-patterns-in-a-microservice-b07034592b6d">第1部分</a>。</p><h2 id="95a6" class="ng ln iq bd lo nh ni dn ls nj nk dp lw mo nl nm ma mq nn no me ms np nq mi nr bi translated">结构:</h2><p id="4fb5" class="pw-post-body-paragraph kf kg iq ki b kj mm kl km kn mn kp kq mo nd kt ku mq ne kx ky ms nf lb lc ld ij bi translated">我没有选择将项目分成多层库，而是选择了更简单的子目录结构。</p><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/7d9d83dd52f544aa0717254f0e47273f.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*m78XiSsTX7vz-urEnGyHhw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Dotnet CLI项目结构</figcaption></figure><ul class=""><li id="32f0" class="mk ml iq ki b kj kk kn ko mo or mq os ms ot ld mu mv mw mx bi translated"><strong class="ki ir"> Program.cs: </strong>应用入口点。</li><li id="8cab" class="mk ml iq ki b kj my kn mz mo na mq nb ms nc ld mu mv mw mx bi translated"><strong class="ki ir"> Builders: </strong>包含ClassAssembler.cs的流畅接口模式的实现</li><li id="bd69" class="mk ml iq ki b kj my kn mz mo na mq nb ms nc ld mu mv mw mx bi translated"><strong class="ki ir">基础设施:</strong>包含了fluent接口模式的定义，该模式包装了我们的Roslyn API实现。</li><li id="63af" class="mk ml iq ki b kj my kn mz mo na mq nb ms nc ld mu mv mw mx bi translated"><strong class="ki ir">模型:</strong>包含应用程序中使用的通用对象结构</li><li id="9c56" class="mk ml iq ki b kj my kn mz mo na mq nb ms nc ld mu mv mw mx bi translated"><strong class="ki ir">枚举:</strong>包含应用程序中使用的通用类型</li><li id="a455" class="mk ml iq ki b kj my kn mz mo na mq nb ms nc ld mu mv mw mx bi translated"><strong class="ki ir"> nupkg: </strong>包含为每个版本生成的NuGet包信息，并上传到NuGet以将包更新到最新版本——以后可能会使用Github操作自动构建项目。</li></ul><h2 id="72f0" class="ng ln iq bd lo nh ni dn ls nj nk dp lw mo nl nm ma mq nn no me ms np nq mi nr bi translated"><strong class="ak">代码深潜:</strong></h2><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Startup.cs</figcaption></figure><p id="5e6d" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第14–39行:命令输入参数的初始化。</p><p id="e81b" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第43–77行:输入参数验证</p><p id="d6d1" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第79行:调用一个响应构建器类来构建目标域中的响应目录和支持类。</p><p id="89d0" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第81–95行:在操作类型上添加逻辑分割，然后调用查询构建器对象来构建查询目录和目标域中的支持对象。</p><p id="aa78" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第97行:调用Handler builder对象为我们的目标域组装和创建处理程序类。</p><p id="fa06" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated"><strong class="ki ir">注意</strong> : <em class="kh"> Log </em>是一个静态对象，包含<em class="kh"> Error(string) </em>和<em class="kh"> Info(string) </em>函数，在整个应用程序中用来标准化日志消息。</p><h2 id="ffc5" class="ng ln iq bd lo nh ni dn ls nj nk dp lw mo nl nm ma mq nn no me ms np nq mi nr bi translated"><strong class="ak">建设者:</strong></h2><p id="6646" class="pw-post-body-paragraph kf kg iq ki b kj mm kl km kn mn kp kq mo nd kt ku mq ne kx ky ms nf lb lc ld ij bi translated">这一层的想法是将Roslyn API实现从其使用中抽象出来。所有4个建筑者都有相同的模式。</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">BuildHandler.cs</figcaption></figure><p id="3b30" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">这是ClassAssembler.cs最复杂的用例，需要注意的是，第24–43行是我们使用fluent接口模式的地方。这被复制到其他3个构建器中，每个构建器根据用例将参数传递给ClassAssembler。</p><p id="f24d" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第12–16行:构建第39行使用的命令/查询对象的名称的逻辑分割。</p><p id="a80b" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第18–22行:建立命令/查询名称空间的逻辑分割，该名称空间需要添加到处理程序类的顶部。使用第46–51行的效用函数。</p><p id="5b3e" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第25行:提供基本的配置细节和类组装器的实例化。</p><p id="27df" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第26行:传递一个名称空间列表，添加到Handler.cs类的顶部，即按照Roslyn API使用指令导入。</p><p id="8c00" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第35行:创建名称空间声明。一个类似的例子相当于第6行，但是带有生成的名称空间名称。</p><p id="7a03" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第36行:创建一个类声明。</p><p id="50ff" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第37行:指定从哪个接口继承。</p><p id="815d" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第41行:指示ClassAssembler实现IRequestHandler的handle函数。</p><p id="5c67" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第42行:指示ClassAssembler将类元数据添加到名称空间，然后将名称空间元数据添加到Roslyn的SyntaxFactory。然后将syntaxFactory节点转换为一个字符串，根据操作类型创建指定的目录，并将C#对象写出到磁盘。</p><h2 id="346a" class="ng ln iq bd lo nh ni dn ls nj nk dp lw mo nl nm ma mq nn no me ms np nq mi nr bi translated"><strong class="ak"> ClassAssembler: </strong></h2><p id="f473" class="pw-post-body-paragraph kf kg iq ki b kj mm kl km kn mn kp kq mo nd kt ku mq ne kx ky ms nf lb lc ld ij bi translated"><strong class="ki ir">初始化:</strong></p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">ClassAssembler.cs的入口点和初始化</figcaption></figure><p id="5fc2" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第7行:从构建者处调用以启动流程。</p><p id="0192" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第1–5行:ClassAssembler的唯一构造函数。</p><p id="0042" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第3行:为private _settings属性创建/分配一个新的DomainSettingsModel实例。这个DomainSettingsModel构建了关于目标域的项目绝对路径、域名、域绝对路径等的所有目录和元数据。</p><p id="5c15" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated"><strong class="ki ir">名称空间添加和创建:</strong></p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">ClassAssembelr.cs中的命名空间添加和创建摘录</figcaption></figure><p id="1795" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第1–9行:负责添加/导入我们试图创建的类将使用的所有名称空间。即<em class="kh">使用系统</em>或使用您的域名.订单.处理程序</p><p id="ad1c" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第14–27行:将为当前正在生成的类创建名称空间。</p><p id="c3a7" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated"><strong class="ki ir">类创建:</strong></p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">ClassAssembler.cs中的类创建摘录</figcaption></figure><p id="5250" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第4–5行:创建一个新的公共类。</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">ClassAssembler.cs的继承提取</figcaption></figure><p id="d766" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第8–9行:添加从类声明继承的类型。</p><p id="03c5" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated"><em class="kh"> ImplementMediatorHandler </em>函数特定于处理程序构建器。</p><p id="5c8c" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第16行:在函数语法中声明并添加应该抛出一个未实现的异常。这当然是您添加处理程序的实现细节的地方。</p><p id="f791" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第17–21行:创建一个数组，包含方法签名的参数列表以及参数名和类型。</p><p id="6a4e" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第23–26行:用我们指定的参数列表(17–21)和方法体语法(第16行)声明一个名为“Handle”的公共方法。</p><p id="632f" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第28行:将方法声明添加到我们正在构建的类中。</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">ClassAssembler.cs的生成摘录</figcaption></figure><p id="cdf2" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第3行:将生成的类添加到名称空间。</p><p id="f376" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第5行:将名称空间添加到SyntaxFactory中。</p><p id="f371" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第7行:以字符串形式获取Syntaxfactory。</p><p id="9971" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第11–23行:根据操作类型和分组策略建立目录结构。</p><p id="cf88" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第25行:用第7行的字符串将C#文件写到目录中。</p><p id="1fd6" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">第28行:将_class、_namespace和_syntaxfactory重置为null。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="a7fd" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="e540" class="pw-post-body-paragraph kf kg iq ki b kj mm kl km kn mn kp kq mo nd kt ku mq ne kx ky ms nf lb lc ld ij bi translated">用Roslyn API构建代码生成工具是一个梦想，不再有T4模板的怪异和糟糕的代码编辑器支持。—如果你没有使用过T4模板，你应该感到幸运。如果您发现自己偶尔使用这些模式构建一个API，那么这个工具就有些多余了，但是当您需要输出大量的特性并构建各种将受益于这些模式的微服务时，代码生成工具可能会有很大帮助。</p><p id="40d2" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">这个工具的未来还不得而知。然而，潜力是存在的。比如将scaffolding命令指向一个DB实体，将整个CRUD操作搭建到控制器层的堆栈，将过滤器添加到处理程序的CLI命令，或者从消息队列中搭建发布/订阅所需的对象。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="efd5" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">资源</h1><p id="1f03" class="pw-post-body-paragraph kf kg iq ki b kj mm kl km kn mn kp kq mo nd kt ku mq ne kx ky ms nf lb lc ld ij bi translated"><a class="ae le" href="https://assist-software.net/blog/design-and-implement-fluent-interface-pattern-c" rel="noopener ugc nofollow" target="_blank">如何在C#中设计并实现流畅的界面模式——Dimitri e Tataru</a></p><p id="31cf" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated"><a class="ae le" href="https://github.com/natemcmaster/CommandLineUtils/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">命令行工具</a></p><p id="d2ee" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated">使用创建一个类。网芯和罗斯林</p><p id="1f46" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated"><a class="ae le" href="https://www.infoq.com/articles/dotnet-core-template-engine/" rel="noopener ugc nofollow" target="_blank">使用。NET核心模板引擎创建自定义模板和项目</a> — <a class="ae le" href="https://www.infoq.com/profile/Matt-Ellis/" rel="noopener ugc nofollow" target="_blank">马特·埃利斯</a></p><p id="58b7" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated"><a class="ae le" href="https://docs.microsoft.com/en-us/dotnet/core/tools/?tabs=netcore2x" rel="noopener ugc nofollow" target="_blank">。NET核心命令行界面(CLI)工具</a></p><p id="fdd8" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq mo ks kt ku mq kw kx ky ms la lb lc ld ij bi translated"><a class="ae le" href="https://docs.microsoft.com/en-us/nuget/what-is-nuget" rel="noopener ugc nofollow" target="_blank">nu get简介</a></p></div></div>    
</body>
</html>