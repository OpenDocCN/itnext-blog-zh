<html>
<head>
<title>Writing Scripts As Frontend With Es6 And Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Es6和Jest编写脚本作为前端</h1>
<blockquote>原文：<a href="https://itnext.io/writing-scripts-as-frontend-with-es6-and-jest-bb53d32da8b5?source=collection_archive---------1-----------------------#2019-07-03">https://itnext.io/writing-scripts-as-frontend-with-es6-and-jest-bb53d32da8b5?source=collection_archive---------1-----------------------#2019-07-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2d70b1fa43c9d01a1b0a134673d5f725.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wwVyYAekryv0Mk4kW3TBVw.png"/></div></div></figure><h1 id="437a" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">语境</h1><p id="a9ef" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">作为前端开发人员，当我想从一个网站提取信息，然后注入到一个文档(通常是markdown文档)中时，我会做一些<code class="fe lu lv lw lx b">web scraping</code>来了解如何使用<a class="ae ly" href="https://www.w3schools.com/cssref/css_selectors.asp" rel="noopener ugc nofollow" target="_blank"> CSS选择器</a>(例如<code class="fe lu lv lw lx b">classNames</code>)从网页中获取我需要的元素的数据，然后我在控制台中执行一个简单的脚本，如下所示:</p><pre class="lz ma mb mc gt md lx me mf aw mg bi"><span id="52c8" class="mh jz iq lx b gy mi mj l mk ml">copy(<br/>  Array.from(document.querySelectorAll('.row-title'))<br/>    .map(e =&gt; e.textContent)<br/>    .join(';;')<br/>);</span></pre><p id="dffb" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">然后在<a class="ae ly" href="https://www.sublimetext.com/" rel="noopener ugc nofollow" target="_blank"> Sublime </a>或<a class="ae ly" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> VS Code </a>中，我使用那些连接字符粘贴它们；;'和多光标功能的编辑器来编辑它们，因为我想给它我需要的降价格式。</p><p id="053d" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">这一次，我想提取网页的技术，并把它们的链接保存在一个文档中。但是wappalyzer提供了<a class="ae ly" href="https://www.wappalyzer.com/download" rel="noopener ugc nofollow" target="_blank">浏览器扩展</a>，我们不能从控制台访问浏览器扩展的弹出内容，所以不可能像我以前那样从控制台脚本中提取信息。</p><h1 id="192a" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">代表团</h1><p id="3304" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我发现了这个<a class="ae ly" href="https://www.npmjs.com/package/wappalyzer" rel="noopener ugc nofollow" target="_blank"> npm节点模块</a>，它开启了我的思维，让我知道如何以最终用户的身份使用它来获取网站上使用的技术并将其粘贴到剪贴板。</p><p id="3208" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">在我的职业生涯中，我创建了许多<code class="fe lu lv lw lx b">.sh</code>来自动化开发过程、部署、可重复的任务，有时甚至使用<a class="ae ly" href="https://en.wikipedia.org/wiki/AppleScript" rel="noopener ugc nofollow" target="_blank"> AppleScript </a>，但令我惊讶的是，我从未想过使用我的web开发工具集(这里是javascript和npm)来编写“桌面脚本”。所以<code class="fe lu lv lw lx b">npm scripts</code>和这个<code class="fe lu lv lw lx b">wappalyzer node module</code>是一个很好的开始来构建要用<a class="ae ly" href="https://www.npmjs.com/package/npx" rel="noopener ugc nofollow" target="_blank"> npx </a>执行的东西。</p><blockquote class="mr ms mt"><p id="d8a2" class="kw kx mu ky b kz mm lb lc ld mn lf lg mv mo lj lk mw mp ln lo mx mq lr ls lt ij bi translated"><strong class="ky ir"> <em class="iq">我想写一个脚本来提取任何带有npm的页面的技术，通过npx来执行，并从wappalyzer中获取输出到markdown中的剪贴板。</em> </strong></p></blockquote><p id="10d5" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">所以这个“练习”的目的不仅仅是解决它，而是在一些限制下学习一些东西。</p><ul class=""><li id="6d4a" class="my mz iq ky b kz mm ld mn lh na ll nb lp nc lt nd ne nf ng bi translated">我想要单元测试。</li><li id="1328" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated">我想使用模块和最新的es6语法，而不仅仅是(它是在node内部执行的，所以我知道这将是一个难点)。</li><li id="3d00" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated">将其注册到npm register，这样任何人都可以在将来使用它或由任何其他人使用。</li><li id="2cd2" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated">当然，在Github中发布它，也许将来有人可以使用它或对它进行修改。</li></ul><h1 id="2638" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">工具集和规划</h1><p id="e684" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我找到了这篇文章<a class="ae ly" href="https://blog.npmjs.org/post/118810260230/building-a-simple-command-line-tool-with-npm" rel="noopener ugc nofollow" target="_blank">“用npm构建一个简单的命令行工具”</a>，但是没有给我es6模块、babel、eslint和jest。我学会了如何通过<code class="fe lu lv lw lx b">package.json</code>中的<code class="fe lu lv lw lx b">bin</code>属性公开npm脚本。我们链接的那些脚本需要有一个作为节点脚本执行的<code class="fe lu lv lw lx b"><a class="ae ly" href="https://en.wikipedia.org/wiki/Shebang_(Unix)" rel="noopener ugc nofollow" target="_blank">Shebang</a></code>。</p><p id="6d38" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">然后我就知道用<code class="fe lu lv lw lx b">last es6 syntax</code>、<code class="fe lu lv lw lx b">node modules imports</code>、<code class="fe lu lv lw lx b">prettier</code>，...我需要一个工具来编译<code class="fe lu lv lw lx b">js</code>，我的第一选择是<code class="fe lu lv lw lx b"><a class="ae ly" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank">webpack</a></code>，就像我在我的web项目中经常做的那样。但是<code class="fe lu lv lw lx b">webpack</code>是为了构建web输出而创建的，我不得不将它修改为不要期望HTML、CSS，并且在<code class="fe lu lv lw lx b">.js</code>中接受带有<code class="fe lu lv lw lx b">Shebang</code>的脚本，所以我最终决定使用简单的<code class="fe lu lv lw lx b">babel-cli</code>。</p><p id="1ba4" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated"><code class="fe lu lv lw lx b">Jest</code>对于单元测试来说是一个非常明确的决定，没有任何额外的配置，因为它对测试功能非常有效，我们不需要任何特别的东西，比如<a class="ae ly" href="https://airbnb.io/enzyme/" rel="noopener ugc nofollow" target="_blank">酶</a>或<a class="ae ly" href="https://testing-library.com/react" rel="noopener ugc nofollow" target="_blank">反应测试库</a>。</p><p id="0c17" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">最后一个难题是如何复制机器剪贴板上的内容，因为我知道在浏览器控制台中有这个<code class="fe lu lv lw lx b"><a class="ae ly" href="https://css-tricks.com/can-copy-console/" rel="noopener ugc nofollow" target="_blank">copy</a></code>，但在<code class="fe lu lv lw lx b">node</code>中没有。但是又一个准备好使用的节点模块在那里做这项工作(<code class="fe lu lv lw lx b"><a class="ae ly" href="https://github.com/sindresorhus/clipboardy" rel="noopener ugc nofollow" target="_blank">clipboardy</a></code>)</p><h1 id="e0f2" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">履行</h1><p id="9950" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">所以一旦我清楚了如何构建这个项目，我只需要开始。</p><h1 id="2d8e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">项目初始化</h1><p id="679c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">只是创建了一个简单的空的新文件夹<code class="fe lu lv lw lx b">wappalyzer-to-md</code>，剩下的由npm <code class="fe lu lv lw lx b">npm init</code>完成。</p><pre class="lz ma mb mc gt md lx me mf aw mg bi"><span id="4a34" class="mh jz iq lx b gy mi mj l mk ml">mkdir wappalyzer-to-md; cd wappalyzer-to-md; npm init</span></pre><h1 id="d93c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">配置<code class="fe lu lv lw lx b">.babelrc</code>和<code class="fe lu lv lw lx b">eslint</code></h1><p id="b6f7" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在让我们添加<code class="fe lu lv lw lx b">.babelrc</code>和<code class="fe lu lv lw lx b">eslint</code>配置:</p><p id="f339" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">首先，我们安装配置所需的东西:</p><p id="ac2d" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated"><code class="fe lu lv lw lx b">npm install --save-dev @babel/core @babel/cli @babel/preset-env @babel/node</code></p><p id="8031" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">而<code class="fe lu lv lw lx b">.babelrc</code>文件看起来是这样的:</p><pre class="lz ma mb mc gt md lx me mf aw mg bi"><span id="0f47" class="mh jz iq lx b gy mi mj l mk ml">{<br/>  "presets": ["@babel/preset-env"]<br/>}</span></pre><p id="f07e" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">然后是eslint的，因为现在没有eslint+pretty我无法工作。同样，对于开发依赖关系:</p><pre class="lz ma mb mc gt md lx me mf aw mg bi"><span id="6a27" class="mh jz iq lx b gy mi mj l mk ml">npm install --save-dev babel-eslint eslint eslint-config-node eslint-config-prettier eslint-plugin-prettier babel-loader babel-polyfill</span></pre><p id="cc08" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">配置文件(<code class="fe lu lv lw lx b">.eslintrc</code>)也是这样，在对这个项目做了一些特定的修改之后:</p><pre class="lz ma mb mc gt md lx me mf aw mg bi"><span id="1696" class="mh jz iq lx b gy mi mj l mk ml">{<br/>  "extends": ["node", "prettier"],<br/>  "parser": "babel-eslint",<br/>  "parserOptions": {<br/>    "ecmaVersion": 8,<br/>    "ecmaFeatures": {<br/>      "experimentalObjectRestSpread": true,<br/>      "impliedStrict": true,<br/>      "classes": true<br/>    }<br/>  },<br/>  "env": {<br/>    "es6": true,<br/>    "browser": false,<br/>    "jasmine": true,<br/>    "node": true,<br/>    "commonjs": false,<br/>    "jest": true<br/>  },<br/>  "rules": {<br/>    "no-unused-vars": [<br/>      1,<br/>      {<br/>        "ignoreRestSiblings": true,<br/>        "argsIgnorePattern": "^ignore",<br/>        "varsIgnorePattern": "^ignore",<br/>        "caughtErrorsIgnorePattern": "^ignore"<br/>      }<br/>    ],<br/>    "arrow-body-style": [2, "as-needed"],<br/>    "no-param-reassign": [<br/>      2,<br/>      {<br/>        "props": false<br/>      }<br/>    ],<br/>    "no-console": 0,<br/>    "import": 0,<br/>    "func-names": 0,<br/>    "space-before-function-paren": 0,<br/>    "max-len": 0,<br/>    "no_underscore-dangle": 0,<br/>    "consistent-return": 0,<br/>    "comma-dangle": 0,<br/>    "import/prefer-default-export": 0,<br/>    "array-bracket-spacing": 0,<br/>    "space-in-parens": 0,<br/>    "prefer-arrow-callback": 0,<br/>    "no-plusplus": 0,<br/>    "no-use-before-define": 0,<br/>    "global-require": 1,<br/>    "import/no-commonjs": 0,<br/>    "import/no-extraneous-dependencies": [<br/>      "error",<br/>      {<br/>        "devDependencies": true<br/>      }<br/>    ],<br/>    "no-process-exit": 0<br/>  },<br/>  "plugins": ["prettier"]<br/>}</span></pre><h1 id="49d9" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">要使用的库和包设置<code class="fe lu lv lw lx b">npm build</code></h1><p id="403a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">然后我们需要能够使用<code class="fe lu lv lw lx b">babel</code>转换过程来构建。/src，并在<code class="fe lu lv lw lx b">bin</code>脚本中连接。</p><pre class="lz ma mb mc gt md lx me mf aw mg bi"><span id="71c3" class="mh jz iq lx b gy mi mj l mk ml">{<br/>  // ...<br/>  "scripts": {<br/>    "build": "babel src --out-dir dist",<br/>    "test": "jest --watchAll"<br/>  },<br/>  // ...<br/>  "bin": {<br/>    "wappalyzer-to-md": "./dist/cli.js"<br/>  },<br/>  // ...<br/>}</span></pre><p id="27eb" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">使用前面的配置，我们能够执行<code class="fe lu lv lw lx b">babel</code>编译的源代码。我们可以在每次构建项目时更新它们。</p><p id="307b" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">因此，让我们也创建我们的第一个文件，这将是我们的脚本<code class="fe lu lv lw lx b">/src/cli.js</code>的起点:</p><pre class="lz ma mb mc gt md lx me mf aw mg bi"><span id="ec42" class="mh jz iq lx b gy mi mj l mk ml">console.log('-- Starting Execution --');<br/>const [, , url] = process.argv;</span><span id="2f3e" class="mh jz iq lx b gy nm mj l mk ml">(async () =&gt; {<br/>  try {<br/>    // 1.- We need to validate params<br/>    // 2.- Make the call to the sever side to check<br/>    // 3.- Transform it to markdown<br/>    // 4.- Copy it to the clipboard</span><span id="e6b2" class="mh jz iq lx b gy nm mj l mk ml">    console.log(' -- 📋 Markdown Copied 📋 -- ');<br/>  } catch (e) {<br/>    console.error(' --💥 Something when wrong 💥-- ');<br/>    console.error(e);<br/>  } finally {<br/>    process.exit(0);<br/>  }<br/>})();</span></pre><p id="9203" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">我们不仅创建了文件，而且定义了“脚本工作流”,并对其进行了分割，以便能够以正确的方式处理测试💁‍.</p><h1 id="6f84" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">使用<code class="fe lu lv lw lx b">npm link</code>执行项目</h1><p id="6ae2" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><code class="fe lu lv lw lx b"><a class="ae ly" href="https://docs.npmjs.com/cli/link" rel="noopener ugc nofollow" target="_blank">npm link</a></code>在注册之前测试和使用<code class="fe lu lv lw lx b">npm modules</code>是一个很好的方法。</p><p id="f269" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">要执行前面的示例，我们只需在控制台的项目文件夹中执行。</p><pre class="lz ma mb mc gt md lx me mf aw mg bi"><span id="b865" class="mh jz iq lx b gy mi mj l mk ml">npm link</span></pre><p id="519f" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">然后，我们可以使用以下命令来执行它:</p><pre class="lz ma mb mc gt md lx me mf aw mg bi"><span id="9831" class="mh jz iq lx b gy mi mj l mk ml">npx wappalyzer-to-md</span></pre><p id="0fa3" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">并在控制台中获得控制台输出。</p><pre class="lz ma mb mc gt md lx me mf aw mg bi"><span id="0e72" class="mh jz iq lx b gy mi mj l mk ml">-- Starting Execution --<br/>-- 📋 Markdown Copied 📋 --</span></pre><h1 id="ab10" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">笑话设置<code class="fe lu lv lw lx b">npm test</code></h1><p id="edda" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们添加uni测试配置，以便能够实现前面单元测试中描述的工作流的每个部分。为此，让我们安装jest配置</p><pre class="lz ma mb mc gt md lx me mf aw mg bi"><span id="3108" class="mh jz iq lx b gy mi mj l mk ml">npm install --save-dev jest babel-jest</span></pre><p id="94f6" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">在<code class="fe lu lv lw lx b">test</code>脚本中拥有<code class="fe lu lv lw lx b">jest --watchAll</code>让我能够执行<code class="fe lu lv lw lx b">npm test</code></p><p id="4cd4" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">我得到了这些问题:<code class="fe lu lv lw lx b">ReferenceError: regeneratorRuntime is not defined</code>在这里描述了<a class="ae ly" href="https://github.com/babel/babel/issues/5085" rel="noopener ugc nofollow" target="_blank"/>，我通过在<code class="fe lu lv lw lx b">.babelrc</code>中指定巴别塔的目标得到了解决。</p><pre class="lz ma mb mc gt md lx me mf aw mg bi"><span id="aa51" class="mh jz iq lx b gy mi mj l mk ml">{<br/>  "presets": [<br/>    [<br/>      "@babel/preset-env", {<br/>        "targets": {<br/>          "node": "current"<br/>        }<br/>      }<br/>    ]<br/>  ]<br/>}</span></pre><p id="1815" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">然后我就可以开始用任何一个<code class="fe lu lv lw lx b">js</code>项目像往常一样运行<code class="fe lu lv lw lx b">npm test</code>来编码了。</p><h1 id="9a28" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">实施计划</h1><p id="fa2d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">对于实现，我们只需要3个库两个已经描述过的库<code class="fe lu lv lw lx b">wappalyzer</code>和<code class="fe lu lv lw lx b">clipboardy</code>以及不可或缺的库<code class="fe lu lv lw lx b">lodash</code>。</p><pre class="lz ma mb mc gt md lx me mf aw mg bi"><span id="cc12" class="mh jz iq lx b gy mi mj l mk ml">npm install lodash clipboardy wappalyzer</span></pre><p id="7af2" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">我的<a class="ae ly" href="https://github.com/robertovg/wappalyzer-to-md" rel="noopener ugc nofollow" target="_blank"> Github </a>账户里有完整的项目，你可以检查、使用、修改或改进它。</p><p id="f61e" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">基本上，我为<code class="fe lu lv lw lx b">cli.js</code>主干中描述的每个步骤创建了以下文件夹结构:</p><ul class=""><li id="6f71" class="my mz iq ky b kz mm ld mn lh na ll nb lp nc lt nd ne nf ng bi translated"><strong class="ky ir">验证</strong>:进行参数验证，因为在cli中输入来自调用参数。</li><li id="0cd2" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated"><strong class="ky ir">数据</strong>:包装使用<code class="fe lu lv lw lx b">Wappalyzer</code> npm模块的逻辑并测试。</li><li id="b56e" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated"><strong class="ky ir">逻辑</strong>:对我来说，这个程序的逻辑是将Json输出从<code class="fe lu lv lw lx b">Wappalyzer</code>转移到我试图创建的“标准”markdown。以优雅的方式创作，非常直，非常令人兴奋🤓</li><li id="2b6f" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated"><strong class="ky ir">输出</strong>:在脚本中，我们没有查看，但是我们有输出逻辑，所以我再次决定将<code class="fe lu lv lw lx b">clipboardy</code>逻辑分离出来，放在逻辑文件夹中。</li></ul><p id="9c06" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">这些是小脚本项目的主要部分，我认为了解每个部分如何工作的最好方法，正如我认为我们应该一直做的那样，只是阅读每个文件夹上的<code class="fe lu lv lw lx b">specs</code>测试，然后理解编排脚本片段的简单的<code class="fe lu lv lw lx b">cli.js</code>文件。</p><p id="3f4a" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">此外，要在注册脚本项目之前执行，我们应该<code class="fe lu lv lw lx b">npm link</code>该项目并使用有效参数再次执行它，如:</p><pre class="lz ma mb mc gt md lx me mf aw mg bi"><span id="ae11" class="mh jz iq lx b gy mi mj l mk ml">npx wappalyzer-to-md <a class="ae ly" href="https://robertovg.com/" rel="noopener ugc nofollow" target="_blank">https://robertovg.com</a></span></pre><p id="4654" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">我们将在剪贴板上有一个我们想要提取🥳.的减价文件</p><h1 id="ffee" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">在npmjs.com注册将被广泛使用🤔。</h1><p id="85d8" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">所以最后一步是注册到npm，这样我们就可以在没有源代码的情况下使用它，这是一个非常有趣的方法，老实说，这是我第一次想到在npm上注册一个不是作为<code class="fe lu lv lw lx b">node module</code>而是作为<code class="fe lu lv lw lx b">npm script</code>使用的东西。</p><p id="064f" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">很简单，这是由<code class="fe lu lv lw lx b">npm publish</code>一如既往地完成的，首先，你需要在<a class="ae ly" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank">npmjs.com</a>建立一个账户，并通过<code class="fe lu lv lw lx b">npm login</code>调用登录npm。</p><p id="8a98" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">那么任何打电话的人都可以得到这个包</p><pre class="lz ma mb mc gt md lx me mf aw mg bi"><span id="5abf" class="mh jz iq lx b gy mi mj l mk ml">npx wappalyzer-to-md &lt;url&gt;</span></pre><p id="6943" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">并在npm <a class="ae ly" href="https://www.npmjs.com/package/wappalyzer-to-md" rel="noopener ugc nofollow" target="_blank">寄存器</a>中公开列出。</p><h1 id="bcd2" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="2a8e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这里没有什么疯狂的，但对我来说，用我的web工具集制作一个脚本很有趣。如果我需要再次解决脚本挑战，当我看到未来的机会时，我会尝试使用这种方法。</p><p id="3203" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">你曾经这样使用过<code class="fe lu lv lw lx b">npm script</code>吗？你认为我使用它的方式有所改进吗？或者也许你有任何疑问？我总是很高兴从任何反馈中学习，希望这不仅对我有用，而且对任何面临问题的人都有用，这些问题可以在<code class="fe lu lv lw lx b">npm scripts</code>之前解决。</p><p id="aa42" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">我希望你喜欢阅读🤗。</p><p id="b3ba" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated"><em class="mu">最初发表于</em><a class="ae ly" href="https://robertovg.com/blog/writing-scripts-as-frontend-with-es6-and-jest" rel="noopener ugc nofollow" target="_blank">T5【robertovg.com】</a><em class="mu">。</em></p></div></div>    
</body>
</html>