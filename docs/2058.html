<html>
<head>
<title>Shift your CI scripts to docker build</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将您的CI脚本转移到docker build</h1>
<blockquote>原文：<a href="https://itnext.io/shift-your-ci-scripts-to-docker-build-92453bca9f75?source=collection_archive---------0-----------------------#2019-03-25">https://itnext.io/shift-your-ci-scripts-to-docker-build-92453bca9f75?source=collection_archive---------0-----------------------#2019-03-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/dfa62b3c297750bdee4b3a2e7c341a41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6VMsQZnhnpMP8asKqZ26zw.png"/></div></div></figure><p id="0a10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">典型场景:您的团队维护几十个Jenkinsfile/。gitlab-ci.yml/whatever,每一个项目都有其特定的需求。您已经尝试从一个repo到另一个repo重用这些持续集成脚本。但是这很难，因为每个项目都有自己的技术栈、版本、对其他工具的依赖性等等。</p><p id="1a0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有，您梦想能够在本地测试您的CI管道，而不是在CI服务器中调试。</p><p id="fa88" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我说的对吗？然后，<a class="ae kw" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">多级码头工打造</strong> </a>都是冲着你来的。</p><p id="b4ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种技术已经存在很多年了，但是用户通常没有意识到它的全部潜力。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="b47c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想法很简单:<strong class="ka ir">将多个Dockerfile文件合并到同一个Dockerfile文件</strong>。在构建过程中，他们每个人都可以执行不同的任务。</p><p id="b960" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看一个例子。我已经包含了一些额外的复杂性来演示高级概念，但是到目前为止，还是把重点放在本质上。请参考<a class="ae kw" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">官方文件</a>了解kickstart。这个职位的特点是展示竞争情报的能力。</p><p id="3b5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一阶段进行声纳测试:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="07d1" class="ln lo iq lj b gy lp lq l lr ls">FROM newtmitch/sonar-scanner AS sonar<br/>COPY src src<br/>RUN sonar-scanner</span></pre><p id="293e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一阶段是安装依赖项并构建应用程序:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="09f3" class="ln lo iq lj b gy lp lq l lr ls">FROM node:11 AS build<br/>WORKDIR /usr/src/app<br/>COPY . .<br/>RUN yarn install \<br/> yarn run lint \<br/> yarn run build \<br/> yarn run generate-docs<br/>LABEL stage=build</span></pre><p id="9d09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一个，单元测试:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="75ce" class="ln lo iq lj b gy lp lq l lr ls">FROM build AS unit-tests<br/>RUN yarn run unit-tests<br/>LABEL stage=unit-tests</span></pre><p id="152e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第三，把文件推给S3:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="64ac" class="ln lo iq lj b gy lp lq l lr ls">FROM containerlabs/aws-sdk AS push-docs<br/>ARG push-docs=false<br/>COPY --from=build docs docs<br/>RUN [[ "$push-docs" == true ]] &amp;&amp; aws s3 cp -r docs s3://my-docs-bucket/</span></pre><p id="ce5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，最后一个阶段是唯一一个将反映在结果图像中的阶段。它使用较小的基础图像，并且只有所需的伪像:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="7fca" class="ln lo iq lj b gy lp lq l lr ls">FROM node:11-slim<br/>EXPOSE 8080<br/>WORKDIR /usr/src/app<br/>COPY --from=build /usr/src/app/node_modules node_modules<br/>COPY --from=build /usr/src/app/dist dist<br/>USER node<br/>CMD ["node", "./dist/server/index.js"]</span></pre><p id="9514" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Jenkins文件变得简单多了(Kubernetes上Jenkins的例子):</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="4614" class="ln lo iq lj b gy lp lq l lr ls">#!/usr/bin/env groovy</span><span id="43cb" class="ln lo iq lj b gy lt lq l lr ls">podTemplate(label: "example", name: "example", <br/>  containers: [<br/>    containerTemplate(name: 'dind', <br/>privileged: true, image: 'docker:18.06-dind', command: 'dockerd-entrypoint.sh'),<br/>    containerTemplate(name: 'docker', image: 'docker:18.06', command: 'cat', ttyEnabled: true)<br/>  ],<br/>  envVars: [<br/>          envVar(key: 'DOCKER_HOST', value: 'tcp://localhost:2375')<br/>  ]<br/>){</span><span id="8943" class="ln lo iq lj b gy lt lq l lr ls">node('example'){</span><span id="75c9" class="ln lo iq lj b gy lt lq l lr ls">container('docker'){</span><span id="b35d" class="ln lo iq lj b gy lt lq l lr ls">stage('checkout'){<br/>        checkout scm<br/>      }</span><span id="41bd" class="ln lo iq lj b gy lt lq l lr ls">stage('Docker build + push'){<br/>        sh """#!/bin/bash<br/>          docker build -t test --build-arg push-docs=true .<br/>          docker push test<br/>        """<br/>      }</span><span id="e870" class="ln lo iq lj b gy lt lq l lr ls">stage('deploy'){<br/>        .......<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="9c62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它可以用于几乎每个项目！</p><p id="4f2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">主要优势:</p><ul class=""><li id="d1c5" class="lu lv iq ka b kb kc kf kg kj lw kn lx kr ly kv lz ma mb mc bi translated">它可以从一个CI系统重用到另一个CI系统(例如，从Jenkins迁移到GitHub actions)。这对开源项目来说尤其方便。</li><li id="8db8" class="lu lv iq ka b kb md kf me kj mf kn mg kr mh kv lz ma mb mc bi translated">你可以通过在本地运行docker build来测试它。</li><li id="29f5" class="lu lv iq ka b kb md kf me kj mf kn mg kr mh kv lz ma mb mc bi translated">与构建和测试源代码相关的一切都在docker文件中。因此，CI脚本保持了对源代码的抽象。</li><li id="221c" class="lu lv iq ka b kb md kf me kj mf kn mg kr mh kv lz ma mb mc bi translated">人为错误的空间更小:每一步都不可避免地在无特权的docker容器中执行。你甚至可以通过使用像<a class="ae kw" href="https://github.com/GoogleContainerTools/kaniko" rel="noopener ugc nofollow" target="_blank"> Kaniko </a>这样的工具来避免docker守护进程。</li></ul><p id="ffb9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总的来说，特定于项目的一切都是自包含的，CI脚本可以从一个存储库重用到另一个存储库，从而使基础设施更简单、更便宜、更易于维护。给它一个机会，将尽可能多的工作负载转移到Dockerfile文件中！</p><h1 id="5442" class="mi lo iq bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">额外提示</h1><p id="9711" class="pw-post-body-paragraph jy jz iq ka b kb nf kd ke kf ng kh ki kj nh kl km kn ni kp kq kr nj kt ku kv ij bi translated">有一些警告，但这些都很容易克服。我将告诉你其中的两个:</p><p id="ecb9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">按需跳过特定步骤</strong></p><p id="5157" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，我在S3上包含了一个将生成的文档推到桶中的阶段。只有在我的CI系统中执行构建时，这才是有用的，在这里，我提供凭证来写入这个bucket。</p><p id="92fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我用ARG命令设置了一个build参数。默认情况下，它是假的，但是在我的CI服务器中，我运行<code class="fe nk nl nm lj b">docker build --build-arg push-docs=true</code>，然后命令<code class="fe nk nl nm lj b">aws s3 cp</code>被执行。</p><p id="7533" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">导出测试报告或任何其他工件</strong></p><p id="b754" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在docker build中执行所有操作的最重要的警告是工件会保留在中间docker映像中。例如，对我来说，将测试结果放在Jenkins工作区来生成统计数据是很有用的。</p><p id="e068" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用标签很容易从任何中间阶段拿走任何神器。</p><p id="9436" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我把第二阶段标为<code class="fe nk nl nm lj b">stage=test</code>。所以在docker构建之后，我可以运行一个小脚本来获得文件test-results.xml</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="a26e" class="ln lo iq lj b gy lp lq l lr ls">docker cp $(docker create — name temp $(docker image ls — filter label=stage=test -q | head -n 1)):/usr/src/app/tests-results.xml .; docker rm temp</span></pre><p id="02a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它使用<code class="fe nk nl nm lj b">docker image ls</code>来获得这个阶段的图像的ID和<code class="fe nk nl nm lj b">docker cp</code>来复制文件。</p><p id="3281" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个更好的解决方案是使用更多的标签从其他类似的构建中筛选出您的特定构建。</p><p id="51c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您已经到达终点，所以这里是最后的建议:使用<a class="ae kw" href="https://docs.docker.com/develop/develop-images/build_enhancements/" rel="noopener ugc nofollow" target="_blank"> BuildKit </a>。😉</p><p id="68ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://ignaciomillan.com" rel="noopener ugc nofollow" target="_blank">ignaciomillan.com</a></p></div></div>    
</body>
</html>