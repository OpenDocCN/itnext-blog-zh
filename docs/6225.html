<html>
<head>
<title>Lessons learned from building a WebSocket server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建WebSocket服务器的经验教训</h1>
<blockquote>原文：<a href="https://itnext.io/lessons-learned-from-building-a-websocket-server-e9bc0bd3ef80?source=collection_archive---------0-----------------------#2021-09-23">https://itnext.io/lessons-learned-from-building-a-websocket-server-e9bc0bd3ef80?source=collection_archive---------0-----------------------#2021-09-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f82b4ed0fad954c3da68b6d386e73c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K1KRjSv31msGPI7wl9TKbQ.png"/></div></div></figure><p id="fe41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Appwrite是一个开源、自托管的后端即服务，旨在通过各种编程语言提供的SDK简化应用开发。</p><p id="ace7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在0.10.0版本的实时API发布之前，应用程序只能与我们的REST API通信。</p><div class="kx ky gp gr kz la"><a href="https://dev.to/appwrite/it-s-here-announcing-appwrite-0-10-and-the-new-appwrite-realtime-api-lbm" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd ir gy z fp lf fr fs lg fu fw ip bi translated">它在这里！宣布Appwrite 0.10和新的实时API！</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">经过长时间的期待和我们在alpha发布期间从Appwrite社区得到的巨大反馈，我们非常激动…</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">开发到</p></div></div><div class="lj l"><div class="lk l ll lm ln lj lo jw la"/></div></div></a></div><p id="aa57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">REST APIs在过去一直是数据交付的流行架构。那么，为什么我们现在需要实时呢？</p><p id="a070" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的REST API工作得很好，也很简单，但是为了让我们允许更多的灵活性，并允许开发人员创建新的用例，如游戏开发和反应式应用程序，我们需要添加一个新的API层来进行实时交互。</p><p id="3c50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">API客户机不是在下一次查询时才获得新数据，而是立即将新数据推送给它们。如果开发人员已经在查询REST API的数据变化，这不仅仅意味着他们想要更快地访问数据，而是强烈地表明他们真的想要一个实时API。</p><p id="f02b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实时API提供了更令人愉快的开发体验，可以显著降低应用程序处理开销和代码复杂性。一旦数据被实时传输到系统中，您就可以让开发人员专注于为产品增加价值。</p><h1 id="0708" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">体系结构</h1><p id="2710" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">因为实时服务是在已经存在的REST API之上实现的，所以通过实时发送的所有消息都是从HTTP服务器触发的。这意味着如果一个资源被创建或更新，WebSocket服务器将被触发发送这个动作给它的订阅者。</p><p id="5716" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">REST和WebSocket之间数据交换的主干是一个<a class="ae kw" href="https://redis.io" rel="noopener ugc nofollow" target="_blank"> Redis </a>实例。我们使用一个单一的<a class="ae kw" href="https://redis.io/topics/pubsub" rel="noopener ugc nofollow" target="_blank"> Pub/Sub </a>频道，这是WebSocket服务器的真实来源。如果通过REST API添加新资源，HTTP服务器将在这个通道中发布有效负载和元数据。WebSocket服务器订阅通道，处理消息，决定允许哪个客户端接收消息，并将其发送到目标客户端。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/d897fca061bf8633c1ca6a1ba966e922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vtow4157ezfuiSMqJhDzsQ.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">体系结构</figcaption></figure><h1 id="ecaf" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">数据流</h1><p id="a19b" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">在Appwrite中，来自REST API的资源由项目分隔，由权限保护，事件在通道中分类。当客户端建立到实时服务器的连接时，项目标识符将与信息一起发送，以验证到用户的连接以及客户端将通过其接收消息的通道。下面我们以<strong class="ka ir">汽车</strong>资源为例，告诉WebSocket服务器订阅<strong class="ka ir">汽车</strong>频道。</p><p id="d2f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">WebSocket服务器现在将用户、项目和通道的所有角色分配给客户端的唯一连接标识符。</p><p id="354b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果<strong class="ka ir">汽车</strong>资源现在通过REST API得到更新，HTTP服务器将这个事件及其有效负载发布到Redis通道。然后，WebSocket服务器将接收这个事件，并开始检查这个事件的接收者是谁。</p><p id="55f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">客户端需要满足以下条件:<br/> -项目ID必须相等。<br/> -资源的权限必须符合用户的角色。<br/> -必须订阅该频道。</p><p id="7391" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，WebSocket服务器会将资源的有效负载发送给所有满足条件的客户端。</p><h1 id="f6b5" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">数据结构</h1><p id="fdab" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">速度对于构建实时更新的应用程序至关重要。我们的数据结构需要尽可能快地被处理，以决定哪个客户机应该并被允许接收一个事件。为此，我们在内存中维护2个散列表。其中一个保存所有<strong class="ka ir">订阅</strong>，另一个保存所有<strong class="ka ir">连接</strong>。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/50331564c46db4ff8a639cb9b1ecd3cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dGR832x1OlRMVVRBJbPpNg.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">捐款</figcaption></figure><p id="1724" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看前面的条件，我们可以看到这个树反映的模式。您可能会意识到这种结构有一个缺点，即连接ID有许多重复的数据条目。但是，这个缺点是故意的，有特定的原因——速度。</p><p id="f7ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在WebSocket服务器中，用内存换取速度是必不可少的。这种结构允许我们，即使有大量的订阅者，也能快速识别他们并将消息转发给他们，即使这可能会占用更多的内存。</p><p id="d7b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是我们实现的一个例子，它将订阅者平均分布在20个不同的通道上，然后使用一个事件来收集该事件的所有订阅者。</p><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="2b98" class="nh lq iq nd b gy ni nj l nk nl">+----------------+-------------+--------------+<br/>| Subscriptions  |  Time used  |  Memory used |<br/>+----------------+-------------+--------------+<br/>|        10,000  |  0.022ms    |  11MB        |<br/>|       100,000  |  0.238ms    |  90MB        |<br/>|       500,000  |  1.525ms    |  427MB       |<br/>|     1,000,000  |  3.678ms    |  852MB       |<br/>|     5,000,000  |  19.334ms   |  4,289MB     |<br/>+----------------+-------------+--------------+</span></pre><p id="c1d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些数字对于日常应用来说已经足够快了，尤其是考虑到一台WebSocket服务器不可能同时维护超过一百万个连接。由于WebSocket服务器是无状态的，并且只管理自己的订阅，所以它可以很容易地进行水平伸缩，平衡工作。</p><p id="949c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们来看下一个数据结构，以及我们首先需要它的原因。</p><p id="06a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们假设一个客户端连接到我们的WebSocket服务器并订阅了一些频道。一段时间后，客户端断开连接，我们必须清理他们，并从所有通道中删除他们的连接。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/307f1c0c25c263af95bf7b23350ee4d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JLJndNXDQzx46OJ5P1D03Q.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">连接</figcaption></figure><p id="bd30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了避免识别每一个遗留物的无休止的循环，我们有一个辅助数据表来保存项目和每个连接的角色，以便于我们访问。使用这些数据，我们可以删除订阅者的所有信息，而不需要太多的搜索。</p><h1 id="51fb" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">绊脚石</h1><p id="fe08" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">当然，我们第一次并没有把所有事情都做对。每当我们遇到并解决了一个障碍，下一个就已经在那里等着我们了。</p><h2 id="1359" class="nh lq iq bd lr nn no dn lv np nq dp lz kj nr ns md kn nt nu mh kr nv nw ml nx bi translated">权限变更</h2><p id="302e" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">我们遇到的第一个障碍是:如果用户的权限在连接时发生变化，会发生什么？如果用户被停用，而连接仍然打开，该怎么办？</p><p id="f1ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">WebSocket服务器不会知道这一变化，并将继续发送用户在连接开始时被允许接收的所有消息。这将导致向未被授权读取资源的人公开该资源。</p><p id="cd50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了防止这种现象，我们在发送到WebSocket服务器的消息中添加了一个标志，该标志指示特定用户的权限是否已经更改。当WebSocket服务器收到这个消息时，它会检查这个用户当前是否已连接，并将他们的角色与后端的角色进行匹配。</p><h2 id="dbb4" class="nh lq iq bd lr nn no dn lv np nq dp lz kj nr ns md kn nt nu mh kr nv nw ml nx bi translated">操作系统</h2><p id="646b" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">Linux的网络栈为许多工作负载提供了相同的缺省值，但是该栈没有针对100多万个并发连接进行调整。我们预计会面临某种形式的<a class="ae kw" href="https://en.wikipedia.org/wiki/C10k_problem" rel="noopener ugc nofollow" target="_blank"> C10k问题</a>，所以我们提前准备了我们的系统<a class="ae kw" href="https://www.ibm.com/support/pages/tuning-and-debugging-maximum-connections-accepted-messagesight-v20" rel="noopener ugc nofollow" target="_blank">【1】</a><a class="ae kw" href="https://www.linkedin.com/pulse/ec2-tuning-1m-tcp-connections-using-linux-stephen-blum/" rel="noopener ugc nofollow" target="_blank">【2】</a><a class="ae kw" href="https://cromwell-intl.com/open-source/performance-tuning/tcp.html" rel="noopener ugc nofollow" target="_blank">【3】</a>:<br/>-增加了系统的默认TCP缓冲区大小<br/> -增加了默认IPv4端口范围<br/> -增加了打开文件和文件句柄的限制</p><p id="6536" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管进行了这种调整，我们还是达到了大约260，000个连接的极限——超过这个极限，HTTP服务器就停止响应我们的客户机。我们观察到我们的服务器没有完成<a class="ae kw" href="https://docs.microsoft.com/en-us/troubleshoot/windows-server/networking/three-way-handshake-via-tcpip" rel="noopener ugc nofollow" target="_blank"> TCP三次握手</a>:它将从客户端接收SYN数据包(正如用<a class="ae kw" href="https://www.tcpdump.org/" rel="noopener ugc nofollow" target="_blank"> tcpdump </a>观察到的，但是没有用ACK响应。</p><p id="5b8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">经过几个小时毫无结果的调试后，我们联系了其他维护人员来关注这个问题。通过开源协作的力量，我们在几分钟内就找到了罪犯:</p><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="fa30" class="nh lq iq nd b gy ni nj l nk nl"><br/>$ cat /proc/sys/net/netfilter/nf_conntrack_max<br/>262144<br/></span></pre><p id="16ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为WebSocket连接是长期的，所以我们需要增加网络堆栈中的连接跟踪限制。一旦增加，我们轻松地一路航行到100万连接。</p><h2 id="1d9a" class="nh lq iq bd lr nn no dn lv np nq dp lz kj nr ns md kn nt nu mh kr nv nw ml nx bi translated">异步交付</h2><p id="ddcd" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">当我们检查发送消息的性能时，一切都进行得很顺利，也就是说，直到我们运行更高规模的测试，并对非常差的结果感到惊讶。罪魁祸首是我们串行发送每条消息，而不是并行发送。</p><p id="afa7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是，解决方案只需要几行代码。</p><h2 id="dddb" class="nh lq iq bd lr nn no dn lv np nq dp lz kj nr ns md kn nt nu mh kr nv nw ml nx bi translated">使用Cookies进行身份验证</h2><p id="de2e" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">WebSocket服务器的第一个实现只进行单向通信，即向客户端发送更新。回想起来，这是一个问题，因为我们当前的实现使用了HTTP-only cookie，该cookie通过握手传输到WebSocket服务器。</p><p id="d0a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">后来，在开发一个演示应用程序时，我们注意到在某些情况下这个cookie不会被发送，例如，当客户机和服务器在不同的域上时。</p><p id="ecd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">经过一番研究，我们发现握手根本不是一种身份验证的方法。原因可以从Chrome的WebSocket实现的维护者那里找到。这个问题可以通过WebSocket协议上的消息进行额外的身份验证来解决。如果用户没有通过cookie进行身份验证，我们决定通过消息进行身份验证，并将cookie的令牌发送到WebSocket服务器。</p><p id="2ac7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，仅仅依靠握手进行身份验证显然不是一个好主意。</p><h2 id="2436" class="nh lq iq bd lr nn no dn lv np nq dp lz kj nr ns md kn nt nu mh kr nv nw ml nx bi translated">外卖食品</h2><p id="55d6" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">当然，上述方法可能并不适用于每一个用例——但是在这一点上它们适用于我们。正如<a class="ae kw" href="https://en.wikipedia.org/wiki/Donald_Knuth" rel="noopener ugc nofollow" target="_blank"> Donald Knuth </a>在他的书<em class="ny">计算机编程的艺术</em>中所说:</p><blockquote class="nz oa ob"><p id="81e1" class="jy jz ny ka b kb kc kd ke kf kg kh ki oc kk kl km od ko kp kq oe ks kt ku kv ij bi translated">真正的问题是程序员在错误的地方和错误的时间花了太多的时间担心效率；过早的优化是编程中所有罪恶(或者至少是大部分罪恶)的根源。</p></blockquote><p id="3a2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以对我们的数据结构进行微优化，让更多的用户获得更好的结果。但是，在负载平衡器后面添加WebSocket服务器的另一个实例并进行水平扩展会更容易。</p><p id="b6c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只要这对我们有用，我们就会听从唐纳德的建议。</p><h1 id="49f6" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">信用</h1><p id="6c73" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">感谢您的关注，我们希望您喜欢这篇文章！</p><p id="6a22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是一些关于Appwrite的便捷链接:</p><p id="eaf3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">- <a class="ae kw" href="https://appwrite.io" rel="noopener ugc nofollow" target="_blank"> Appwrite首页</a><br/>-<a class="ae kw" href="https://github.com/appwrite" rel="noopener ugc nofollow" target="_blank">Appwrite Github</a>T5】-<a class="ae kw" href="https://appwrite.io/discord" rel="noopener ugc nofollow" target="_blank">Appwrite不和</a></p></div></div>    
</body>
</html>