<html>
<head>
<title>Kubernetes Journey — Up and running out of the cloud — How to setup the HAProxy Cluster with high availability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes之旅—启动并运行云—如何设置具有高可用性的HAProxy集群</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-journey-up-and-running-out-of-the-cloud-how-to-setup-the-haproxy-cluster-with-high-ee5eb9a7f2e1?source=collection_archive---------1-----------------------#2020-02-24">https://itnext.io/kubernetes-journey-up-and-running-out-of-the-cloud-how-to-setup-the-haproxy-cluster-with-high-ee5eb9a7f2e1?source=collection_archive---------1-----------------------#2020-02-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/622196f8233dce66fdadd1848d671721.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V3FJMB8U8SRnpDsIs0amaA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Denys Nevozhai 在<a class="ae kc" href="https://unsplash.com/search/photos/high-avaibility?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="80de" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">你好。我们终于回到了我们的<strong class="km ir"> Kubernetes之旅——从云中跑出来</strong>。现在，我们终于开始着手进行一些实际的编码和配置，我希望保持良好的速度，发布下一篇文章来完成这一旅程。</p><p id="c9e2" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在最后一篇文章的<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-journey-up-and-running-out-of-the-cloud-starting-the-actual-setup-737c0f3e0fb1">中，我们已经开始执行将构成我们的解决方案的组件的实际配置。我们已经配置了我们的<strong class="km ir">网关</strong>实例以及一个<strong class="km ir"> BusyBox </strong>实例，这将允许我们连接到组成我们的解决方案的所有实例，这些实例驻留在与我们的主机不同的网络中。</a></p><p id="0186" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在本文中，我们将深入探讨如何借助<strong class="km ir"> Corosync </strong>和<strong class="km ir"> Pacemaker </strong>为<strong class="km ir"> kube-apiserver </strong>配置具有高可用性的<strong class="km ir"> HAProxy集群</strong>。在我们的<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-journey-up-and-running-out-of-the-cloud-technology-stack-9c472aafac4e">技术堆栈文章</a>中，我们已经谈论了很多关于这些组件的内容。请参考它刷新。</p><p id="307f" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">说够了。让我们玩得开心！</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="bd95" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">本节展示了如何设置由浮动IP和<a class="ae kc" href="https://clusterlabs.org/corosync.html" rel="noopener ugc nofollow" target="_blank"><strong class="km ir">Corosync</strong></a>/<a class="ae kc" href="https://clusterlabs.org/pacemaker/" rel="noopener ugc nofollow" target="_blank"><strong class="km ir">定拍器</strong> </a>集群堆栈支持的高可用性<strong class="km ir"> HAProxy负载平衡器</strong>。</p><p id="923d" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">浮动IP也称为“共享”或“虚拟”IP地址。浮动IP是分配给最终可能出现故障的节点的正常IP地址。对于故障转移，具有相似特征(被动)的节点与主(主动)节点一起以主动/被动模式运行。如果发生故障，这个浮动IP将自动透明地分配给被动节点，使其成为主动节点，避免停机。</p><p id="08be" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">每个<strong class="km ir"> HAProxy </strong>负载平衡器将被配置为在<strong class="km ir"> kube-apiserver </strong>之间分割流量。如果主负载均衡器关闭，<strong class="km ir">浮动IP </strong>将自动移动到第二个负载均衡器，允许它继续服务而不停机。</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div class="gh gi li"><img src="../Images/0320ae403f6a6f89875c318acdec2c64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*NMDqdUBOsz7Pqzx9qUE8HA.gif"/></div></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="005f" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">如果你不想等到所有的文章都发表了，又想马上动手，可以随意克隆项目的Github repo。它完全实用，文档也在不断改进。</p><div class="ln lo gp gr lp lq"><a href="https://github.com/mvallim/kubernetes-under-the-hood" rel="noopener  ugc nofollow" target="_blank"><div class="lr ab fo"><div class="ls ab lt cl cj lu"><h2 class="bd ir gy z fp lv fr fs lw fu fw ip bi translated">罩下的姆瓦利姆/库伯内特斯</h2><div class="lx l"><h3 class="bd b gy z fp lv fr fs lw fu fw dk translated">它甚至还包括一张幻灯片，解释了它吸引目标受众的原因…</h3></div><div class="ly l"><p class="bd b dl z fp lv fr fs lw fu fw dk translated">github.com</p></div></div><div class="lz l"><div class="ma l mb mc md lz me jw lq"/></div></div></a></div></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="034c" class="mf mg iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">HAProxy</h1><p id="a5f2" class="pw-post-body-paragraph kk kl iq km b kn nd kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld nh lf lg lh ij bi translated"><em class="ni">“ha proxy是一个免费的、非常快速和可靠的解决方案，为基于TCP和HTTP的应用程序提供高可用性、负载平衡和代理。它特别适用于高流量的网站，并为世界上许多访问量最大的网站提供支持。多年来，它已经成为事实上的标准开源负载平衡器，现在与大多数主流Linux发行版一起提供，并且通常默认部署在云平台中。因为它不做广告，我们只知道它在管理员报告时被使用:-)" </em></p><blockquote class="nj nk nl"><p id="f5dc" class="kk kl ni km b kn ko kp kq kr ks kt ku nm kw kx ky nn la lb lc no le lf lg lh ij bi translated">参考:<a class="ae kc" href="http://www.haproxy.org/" rel="noopener ugc nofollow" target="_blank">http://www.haproxy.org/</a><br/><em class="iq">完整解释在我们的</em> <a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-journey-up-and-running-out-of-the-cloud-technology-stack-9c472aafac4e"> <em class="iq">技术栈</em> </a> <em class="iq">中。</em></p></blockquote></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="f312" class="mf mg iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">科罗sync</h1><p id="6bc0" class="pw-post-body-paragraph kk kl iq km b kn nd kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld nh lf lg lh ij bi translated">Corosync集群引擎是一个组通信系统，具有在应用程序中实现高可用性的附加功能。该项目提供了四个C应用程序编程接口特性:</p><ul class=""><li id="1aa3" class="np nq iq km b kn ko kr ks kv nr kz ns ld nt lh nu nv nw nx bi translated">用于创建复制状态机的具有扩展虚拟同步保证的封闭进程组通信模型。</li><li id="5115" class="np nq iq km b kn ny kr nz kv oa kz ob ld oc lh nu nv nw nx bi translated">一个简单的可用性管理器，它在应用程序失败时重新启动应用程序进程。</li><li id="2fe3" class="np nq iq km b kn ny kr nz kv oa kz ob ld oc lh nu nv nw nx bi translated">一个配置和统计内存数据库，提供设置、检索和接收信息更改通知的能力。</li><li id="2b7a" class="np nq iq km b kn ny kr nz kv oa kz ob ld oc lh nu nv nw nx bi translated">当达到或失去仲裁时通知应用程序的仲裁系统。</li></ul><blockquote class="nj nk nl"><p id="2746" class="kk kl ni km b kn ko kp kq kr ks kt ku nm kw kx ky nn la lb lc no le lf lg lh ij bi translated"><em class="iq">完整解释在我们的</em> <a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-journey-up-and-running-out-of-the-cloud-technology-stack-9c472aafac4e"> <em class="iq">技术栈</em> </a> <em class="iq">中。</em></p></blockquote></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="1ebd" class="mf mg iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">起搏器</h1><p id="7fe0" class="pw-post-body-paragraph kk kl iq km b kn nd kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld nh lf lg lh ij bi translated">Pacemaker是一个高级的、可伸缩的高可用性集群资源管理器。</p><p id="c3c8" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">它支持“N节点”集群，具有管理资源和依赖关系的强大功能。</p><p id="e0af" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">它将在初始化时、机器启动或关闭时、相关资源出现故障时运行脚本，并且可以配置为定期检查资源健康状况。</p><blockquote class="nj nk nl"><p id="6b51" class="kk kl ni km b kn ko kp kq kr ks kt ku nm kw kx ky nn la lb lc no le lf lg lh ij bi translated"><em class="iq">完整解释在我们的</em> <a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-journey-up-and-running-out-of-the-cloud-technology-stack-9c472aafac4e"> <em class="iq">技术栈</em> </a> <em class="iq">中。</em></p></blockquote><h2 id="b37d" class="od mg iq bd mh oe of dn ml og oh dp mp kv oi oj mt kz ok ol mx ld om on nb oo bi translated">资源代理</h2><p id="11fc" class="pw-post-body-paragraph kk kl iq km b kn nd kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld nh lf lg lh ij bi translated">资源代理是允许Pacemaker管理它一无所知的服务的抽象。它们包含当集群希望启动、停止或检查服务的健康状况时该做什么的逻辑。</p><p id="2d7b" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><code class="fe op oq or os b"><strong class="km ir">ocf:heartbeat:IPaddr2</strong></code></p><p id="9158" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这个特定于Linux的资源管理IP别名IP地址。它可以添加或删除一个IP别名。此外，如果作为克隆资源调用，它还可以实现群集别名IP功能。</p><blockquote class="nj nk nl"><p id="8f6f" class="kk kl ni km b kn ko kp kq kr ks kt ku nm kw kx ky nn la lb lc no le lf lg lh ij bi translated"><em class="iq">更多信息</em><a class="ae kc" href="http://linux-ha.org/doc/man-pages/re-ra-IPaddr2.html" rel="noopener ugc nofollow" target="_blank"><em class="iq">http://linux-ha.org/doc/man-pages/re-ra-IPaddr2.html</em></a></p></blockquote><p id="d39d" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><code class="fe op oq or os b"><strong class="km ir">ocf:heartbeat:haproxy</strong></code></p><p id="7a94" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在高可用性设置中将haproxy守护程序作为OCF资源进行管理。</p><blockquote class="nj nk nl"><p id="938e" class="kk kl ni km b kn ko kp kq kr ks kt ku nm kw kx ky nn la lb lc no le lf lg lh ij bi translated"><em class="iq">更多信息</em><a class="ae kc" href="https://raw.githubusercontent.com/russki/cluster-agents/master/haproxy" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://raw . githubusercontent . com/russki/cluster-agents/master/ha proxy</em></a></p></blockquote></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="e388" class="mf mg iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">创建虚拟机</h1><pre class="lj lk ll lm gt ot os ou ov aw ow bi"><span id="9633" class="od mg iq os b gy ox oy l oz pa">~/kubernetes-under-the-hood$ for instance in hapx-node01 hapx-node02; do \<br/>./create-image.sh \<br/>   -k ~/.ssh/id_rsa.pub \<br/>   -u hapx/user-data \<br/>   -n hapx/network-config \<br/>   -i hapx/post-config-interfaces \<br/>   -r hapx/post-config-resources \<br/>   -o ${instance} \<br/>   -l debian \<br/>   -b debian-base-image done</span></pre><h1 id="7a57" class="mf mg iq bd mh mi pb mk ml mm pc mo mp mq pd ms mt mu pe mw mx my pf na nb nc bi translated">因素</h1><ul class=""><li id="d714" class="np nq iq km b kn nd kr ne kv pg kz ph ld pi lh nu nv nw nx bi translated"><code class="fe op oq or os b"><strong class="km ir">-k</strong></code>用于将<strong class="km ir">公钥</strong>从您的主机复制到新创建的虚拟机。</li><li id="d4d7" class="np nq iq km b kn ny kr nz kv oa kz ob ld oc lh nu nv nw nx bi translated"><code class="fe op oq or os b"><strong class="km ir">-u</strong></code>用于指定<strong class="km ir">用户数据</strong>文件，该文件将作为参数传递给创建我们之前提到的cloud-init ISO文件的命令(查看脚本的源代码以更好地理解它的用法)。默认为'<strong class="km ir">/数据/用户数据</strong>'。</li><li id="d8e1" class="np nq iq km b kn ny kr nz kv oa kz ob ld oc lh nu nv nw nx bi translated"><code class="fe op oq or os b"><strong class="km ir">-m</strong></code>用于指定<strong class="km ir">元数据</strong>文件，该文件将作为参数传递给创建我们之前提到的cloud-init ISO文件的命令(查看脚本的源代码以更好地理解它的用法)。默认为“<strong class="km ir">/数据/元数据</strong>”。</li><li id="c506" class="np nq iq km b kn ny kr nz kv oa kz ob ld oc lh nu nv nw nx bi translated"><code class="fe op oq or os b"><strong class="km ir">-n</strong></code>用于传递配置文件，cloud-init将使用该文件为实例配置<strong class="km ir">网络</strong>。</li><li id="47fc" class="np nq iq km b kn ny kr nz kv oa kz ob ld oc lh nu nv nw nx bi translated"><code class="fe op oq or os b"><strong class="km ir">-i</strong></code>用于传递一个配置文件，我们的脚本将使用该文件修改由<strong class="km ir"> VirtualBox </strong>管理的<strong class="km ir">网络接口</strong>，该接口连接到将从该映像创建的实例。</li><li id="7462" class="np nq iq km b kn ny kr nz kv oa kz ob ld oc lh nu nv nw nx bi translated"><code class="fe op oq or os b"><strong class="km ir">-r</strong></code>用于传递一个配置文件，我们的脚本将使用该文件来配置由<strong class="km ir"> VirtualBox </strong>分配给我们实例的<strong class="km ir">数量的处理器和</strong>数量的内存。</li><li id="9c9b" class="np nq iq km b kn ny kr nz kv oa kz ob ld oc lh nu nv nw nx bi translated"><code class="fe op oq or os b"><strong class="km ir">-o</strong></code>用于传递将分配给我们实例的<strong class="km ir">主机名</strong>。这也将是<strong class="km ir"> VirtualBox </strong>用来引用我们的实例的名称。</li><li id="4b5f" class="np nq iq km b kn ny kr nz kv oa kz ob ld oc lh nu nv nw nx bi translated"><code class="fe op oq or os b"><strong class="km ir">-l</strong></code>用于通知我们要使用哪个Linux发行版(<strong class="km ir"> debian </strong>或<strong class="km ir"> ubuntu </strong>)配置文件(注意这是用来指定<a class="ae kc" href="https://github.com/mvallim/kubernetes-under-the-hood/blob/master/data" rel="noopener ugc nofollow" target="_blank">数据</a>下的哪个文件夹被引用)。默认为'<strong class="km ir"> debian </strong>'。</li><li id="bee2" class="np nq iq km b kn ny kr nz kv oa kz ob ld oc lh nu nv nw nx bi translated"><code class="fe op oq or os b"><strong class="km ir">-b</strong></code>用于指定应该使用哪个<strong class="km ir">基础图像</strong>。这是我们执行上一篇文章中的安装步骤时，在<strong class="km ir"> VirtualBox </strong>上创建的映像名称。</li><li id="2d19" class="np nq iq km b kn ny kr nz kv oa kz ob ld oc lh nu nv nw nx bi translated"><code class="fe op oq or os b"><strong class="km ir">-s</strong></code>用于传递一个配置文件，我们的脚本将使用该文件在<strong class="km ir"> VirtualBox </strong>上配置<strong class="km ir">虚拟磁盘</strong>。你会注意到这仅用于<strong class="km ir"> Gluster </strong>配置步骤。</li><li id="8d2d" class="np nq iq km b kn ny kr nz kv oa kz ob ld oc lh nu nv nw nx bi translated"><code class="fe op oq or os b"><strong class="km ir">-a</strong></code>我们的实例<strong class="km ir">创建后是否应该初始化</strong>。默认为<strong class="km ir">真</strong>。</li></ul><p id="169f" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir">预期输出:</strong></p><pre class="lj lk ll lm gt ot os ou ov aw ow bi"><span id="ac7a" class="od mg iq os b gy ox oy l oz pa">Total translation table size: 0<br/>Total rockridge attributes bytes: 417<br/>Total directory bytes: 0<br/>Path table size(bytes): 10<br/>Max brk space used 0<br/>187 extents written (0 MB)<br/>0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100%<br/>Machine has been successfully cloned as "hapx-node01"<br/>Waiting for VM "hapx-node01" to power on...<br/>VM "hapx-node01" has been successfully started.<br/>Total translation table size: 0<br/>Total rockridge attributes bytes: 417<br/>Total directory bytes: 0<br/>Path table size(bytes): 10<br/>Max brk space used 0<br/>187 extents written (0 MB)<br/>0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100%<br/>Machine has been successfully cloned as "hapx-node02"<br/>Waiting for VM "hapx-node02" to power on...<br/>VM "hapx-node02" has been successfully started.</span></pre><h2 id="e3d2" class="od mg iq bd mh oe of dn ml og oh dp mp kv oi oj mt kz ok ol mx ld om on nb oo bi translated">配置您的本地路由</h2><p id="4b26" class="pw-post-body-paragraph kk kl iq km b kn nd kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld nh lf lg lh ij bi translated">您需要在本地计算机上添加一个路由来访问Virtualbox内部网络。</p><pre class="lj lk ll lm gt ot os ou ov aw ow bi"><span id="739d" class="od mg iq os b gy ox oy l oz pa">sudo ip route add 192.168.4.0/27 via 192.168.4.30 dev vboxnet0<br/><br/>sudo ip route add 192.168.4.32/27 via 192.168.4.62 dev vboxnet0</span></pre><h2 id="70cd" class="od mg iq bd mh oe of dn ml og oh dp mp kv oi oj mt kz ok ol mx ld om on nb oo bi translated">访问BusyBox</h2><p id="7ed7" class="pw-post-body-paragraph kk kl iq km b kn nd kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld nh lf lg lh ij bi translated">我们需要让BusyBox IP通过ssh访问它:</p><pre class="lj lk ll lm gt ot os ou ov aw ow bi"><span id="cae7" class="od mg iq os b gy ox oy l oz pa">vboxmanage guestproperty get busybox "/VirtualBox/GuestInfo/Net/0/V4/IP"</span></pre><p id="cef5" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">预期产出:</p><pre class="lj lk ll lm gt ot os ou ov aw ow bi"><span id="a5f0" class="od mg iq os b gy ox oy l oz pa">Value: 192.168.4.57</span></pre><p id="759f" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">使用返回值通过ssh访问虚拟机:</p><pre class="lj lk ll lm gt ot os ou ov aw ow bi"><span id="d42c" class="od mg iq os b gy ox oy l oz pa">~$ ssh debian@192.168.4.57</span></pre><p id="5c06" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">预期产出:</p><pre class="lj lk ll lm gt ot os ou ov aw ow bi"><span id="c4ce" class="od mg iq os b gy ox oy l oz pa">Linux busybox 4.9.0-11-amd64 #1 SMP Debian 4.9.189-3+deb9u2 (2019-11-11) x86_64<br/><br/>The programs included with the Debian GNU/Linux system are free software;<br/>the exact distribution terms for each program are described in the<br/>individual files in /usr/share/doc/*/copyright.<br/><br/>Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent<br/>permitted by applicable law.</span></pre></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="eb6d" class="mf mg iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated"><strong class="ak">访问HAProxy节点</strong></h1><p id="9bc5" class="pw-post-body-paragraph kk kl iq km b kn nd kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld nh lf lg lh ij bi translated">访问BusyBox并进入ssh会话后，只需按名称访问实例，在我们的例子中，我们希望访问hapx-node01。</p><pre class="lj lk ll lm gt ot os ou ov aw ow bi"><span id="9515" class="od mg iq os b gy ox oy l oz pa">debian@busybox:~$ ssh hapx-node01</span></pre><h1 id="7adf" class="mf mg iq bd mh mi pb mk ml mm pc mo mp mq pd ms mt mu pe mw mx my pf na nb nc bi translated">配置起搏器</h1><p id="cd95" class="pw-post-body-paragraph kk kl iq km b kn nd kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld nh lf lg lh ij bi translated">在进行起搏器配置之前，有必要进行一些观察。</p><p id="cf6b" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir"> <em class="ni"> 1 </em> </strong> —让我们检查IP配置，使用<code class="fe op oq or os b">ip addr</code>:</p><pre class="lj lk ll lm gt ot os ou ov aw ow bi"><span id="f5e2" class="od mg iq os b gy ox oy l oz pa">debian@hapx-node01:~$ ip addr show enp0s3.41<br/><br/>3: enp0s3.41@enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000<br/>    link/ether 08:00:27:a4:ce:07 brd ff:ff:ff:ff:ff:ff<br/>    inet6 fe80::a00:27ff:fea4:ce07/64 scope link<br/>      valid_lft forever preferred_lft forever</span></pre><p id="b491" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">如您所见，我们仍然没有在任何网络接口上配置集群的IP ( <code class="fe op oq or os b">192.168.4.20</code>)。</p><p id="a25e" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir"> <em class="ni"> 2 </em> </strong> —让我们使用<code class="fe op oq or os b">crm status</code>检查起搏器配置</p><pre class="lj lk ll lm gt ot os ou ov aw ow bi"><span id="1b68" class="od mg iq os b gy ox oy l oz pa">debian@hapx-node01:~$ sudo crm status<br/><br/>Stack: corosync<br/>Current DC: hapx-node02 (version 1.1.16-94ff4df) - partition with quorum<br/>Last updated: Sun Feb  2 19:53:25 2020<br/>Last change: Sun Feb  2 19:51:43 2020 by hacluster via crmd on hapx-node02<br/><br/>2 nodes configured<br/>0 resources configured<br/><br/>Online: [ hapx-node01 hapx-node02 ]<br/><br/>No resources</span></pre><p id="852c" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这里我们注意到我们只有两个活动的和已配置的节点(<code class="fe op oq or os b">hapx-node01</code>和<code class="fe op oq or os b">hapx-node02</code>)，但是没有资源来组成我们的集群(<code class="fe op oq or os b">virtual-ip-resource</code>和<code class="fe op oq or os b">haproxy-resource</code>)。</p><p id="b37b" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir"> <em class="ni"> 3 </em> </strong> —让我们使用<code class="fe op oq or os b">crm configure</code>配置起搏器上的资源</p><p id="675e" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这里我们将虚拟IP定义为<code class="fe op oq or os b">192.168.4.20</code>。这将是我们的K8S群集(控制平面端点)的IP地址。</p><p id="8428" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">此时，我们将使用<a class="ae kc" href="https://crmsh.github.io/" rel="noopener ugc nofollow" target="_blank"> crmsh </a>工具配置我们的<strong class="km ir"> HAProxy集群</strong>的特性。crmsh是Pacemaker高可用性堆栈的集群管理外壳。</p><p id="98f6" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">以下步骤可以在任何节点上运行，因为现在Corosync应该保持集群配置同步。</p><blockquote class="nj nk nl"><p id="afdc" class="kk kl ni km b kn ko kp kq kr ks kt ku nm kw kx ky nn la lb lc no le lf lg lh ij bi translated"><strong class="km ir">注</strong>:下面每一行代表一个命令，应该在命令行单独输入。</p></blockquote><pre class="lj lk ll lm gt ot os ou ov aw ow bi"><span id="018e" class="od mg iq os b gy ox oy l oz pa">debian@hapx-node01:~$ cat &lt;&lt;EOF | sudo crm configure<br/>property stonith-enabled=no<br/>property no-quorum-policy=ignore<br/>property default-resource-stickiness=100<br/>primitive virtual-ip-resource ocf:heartbeat:IPaddr2 params ip="192.168.4.20" broadcast=192.168.4.31 nic=enp0s3.41 cidr_netmask=27 meta migration-threshold=2 op monitor interval=20 timeout=60 on-fail=restart<br/>primitive haproxy-resource ocf:heartbeat:haproxy op monitor interval=20 timeout=60 on-fail=restart<br/>colocation loc inf: virtual-ip-resource haproxy-resource<br/>order ord inf: virtual-ip-resource haproxy-resource<br/>commit<br/>bye<br/>EOF</span></pre><p id="937c" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir"> <em class="ni"> 4 </em> </strong> —让我们使用<code class="fe op oq or os b">ip addr</code>再次检查我们的IP配置:</p><pre class="lj lk ll lm gt ot os ou ov aw ow bi"><span id="eb14" class="od mg iq os b gy ox oy l oz pa">debian@hapx-node01:~$ ip addr show enp0s3.41</span><span id="a2ba" class="od mg iq os b gy pj oy l oz pa">3: enp0s3.41@enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000<br/>    link/ether 08:00:27:a4:ce:07 brd ff:ff:ff:ff:ff:ff<br/>    inet 192.168.4.20/27 brd 192.168.4.31 scope global enp0s3.41<br/>      valid_lft forever preferred_lft forever<br/>    inet6 fe80::a00:27ff:fea4:ce07/64 scope link<br/>      valid_lft forever preferred_lft forever</span></pre><p id="db2e" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">瞧啊。现在，我们的集群的IP已经在<code class="fe op oq or os b">enp0s3.41</code>界面中正确配置和管理了。</p><p id="2aba" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir"> <em class="ni"> 5 </em> </strong> —让我们使用<code class="fe op oq or os b">crm status</code>从我们的集群中获得更多信息:</p><pre class="lj lk ll lm gt ot os ou ov aw ow bi"><span id="5632" class="od mg iq os b gy ox oy l oz pa">debian@hapx-node01:~$ sudo crm status</span><span id="6b91" class="od mg iq os b gy pj oy l oz pa">Stack: corosync<br/>Current DC: hapx-node01 (version 1.1.16-94ff4df) - partition with quorum<br/>Last updated: Sun Feb  2 19:19:16 2020<br/>Last change: Sun Feb  2 19:04:37 2020 by root via cibadmin on hapx-node01</span><span id="4f7d" class="od mg iq os b gy pj oy l oz pa">2 nodes configured<br/>2 resources configured</span><span id="b051" class="od mg iq os b gy pj oy l oz pa">Online: [ hapx-node01 hapx-node02 ]</span><span id="451f" class="od mg iq os b gy pj oy l oz pa">Full list of resources:</span><span id="8afd" class="od mg iq os b gy pj oy l oz pa">virtual-ip-resource    (ocf::heartbeat:IPaddr2):       Started hapx-node01<br/>haproxy-resource       (ocf::heartbeat:haproxy):       Started hapx-node01</span></pre><p id="46ca" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在这里，我们可以看到节点和资源都处于活动状态并已配置好。</p><p id="b026" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">仔细观察，我们可以看到<code class="fe op oq or os b">hapx-node01</code>节点就是分配了这两个资源(<code class="fe op oq or os b">virtual-ip-resource</code>和<code class="fe op oq or os b">haproxy-resource</code>)的节点。这非常合理，因为我们将这些资源配置为总是在同一个节点上分配。</p><p id="eccf" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir">起搏器参数解释(TL；博士):</strong></p><ul class=""><li id="47d9" class="np nq iq km b kn ko kr ks kv nr kz ns ld nt lh nu nv nw nx bi translated"><code class="fe op oq or os b">property stonith-enabled=no</code></li></ul><p id="b90b" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><code class="fe op oq or os b">STONITH</code>具有保护您的数据免受损坏和应用程序因多个节点同时无意访问而不可用的功能。例如，仅仅因为一个节点没有响应，并不意味着它已经停止访问其数据。100%确保您的数据安全的唯一方法是，在允许另一个节点访问数据之前，确保该节点确实处于离线状态。<br/> <code class="fe op oq or os b">STONITH</code>也在服务无法停止的情况下发挥作用。在这种情况下，集群使用<code class="fe op oq or os b">STONITH</code>强制节点离线，从而可以安全地在其他地方启动服务。</p><p id="e7dc" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><code class="fe op oq or os b">STONITH</code>是“射中对方头部”的缩写，是最流行的数据保护机制。<br/>为确保您数据的完整性，默认情况下会激活<code class="fe op oq or os b">STONITH</code>。<br/>在我们的例子中，由于我们既不访问数据库也不访问文件等数据，保持<code class="fe op oq or os b">STONITH</code>活动没有意义。为此，我们将其设置为<code class="fe op oq or os b">stonith-enabled=no</code></p><ul class=""><li id="44d1" class="np nq iq km b kn ko kr ks kv nr kz ns ld nt lh nu nv nw nx bi translated"><code class="fe op oq or os b">property no-quorum-policy=ignore</code></li></ul><p id="2566" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><code class="fe op oq or os b">no-quorum-policy</code>参数决定了当没有足够的节点组成集群时集群的行为。为了避免出现<a class="ae kc" href="https://en.wikipedia.org/wiki/Split-brain_(computing)" rel="noopener ugc nofollow" target="_blank">裂脑</a>情况，集群将仅在达到法定人数时才做出响应。举例来说，假设一个集群有五个节点，由于网络故障，创建了两个独立的组:一个组有三个节点，另一个组有两个节点。在这种情况下，只有具有三个节点的组能够获得多数票。因此，只有包含三个节点的组才能利用群集资源。这种配置非常重要，因为如果只有两个节点的组也能够使用它们，就会有资源损坏的风险。<code class="fe op oq or os b">no-quorum-policy</code>参数的默认值是<code class="fe op oq or os b">stop</code>。</p><p id="8dce" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在我们的示例中，我们只有两个节点。因此，如果其中一个由于任何原因离线，我们的整个集群将由于缺少法定人数(&gt; 50%)而停止运行。为了避免这种情况，我们将策略配置为<code class="fe op oq or os b">ignore</code>，不需要做任何其他事情。在生产场景中，最好至少有3个节点，以确保更高的可用性。</p><ul class=""><li id="00fb" class="np nq iq km b kn ko kr ks kv nr kz ns ld nt lh nu nv nw nx bi translated"><code class="fe op oq or os b">property default-resource-stickiness=100</code></li></ul><p id="7d27" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><code class="fe op oq or os b">default-resource-stickiness</code>决定了集群资源将被分配到哪里。默认行为是将资源放回它们被分配到的原始节点。这意味着，出现故障后，资源将被分配到集群中的另一个节点，当原始节点恢复正常状态时，资源将被移回该节点。这并不理想，因为用户将两次面临不一致的场景。为了避免这种情况，您可以为<code class="fe op oq or os b">default-resource-stickiness</code>参数设置一个权重(在-1.000.000和1.000.000之间):<code class="fe op oq or os b">0</code>意味着资源将被移回其原始节点；正值表示资源应该保留在原来的位置。</p><p id="2d35" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在我们的例子中，我们任意将其设置为<code class="fe op oq or os b">100</code>。</p><ul class=""><li id="0c40" class="np nq iq km b kn ko kr ks kv nr kz ns ld nt lh nu nv nw nx bi translated"><code class="fe op oq or os b">primitive virtual-ip-resource ocf:heartbeat:IPaddr2 params ip="192.168.4.20" broadcast=192.168.4.31 nic=enp0s3.41 cidr_netmask=27 meta migration-threshold=2 op monitor interval=20 timeout=60 on-fail=restart</code></li></ul><p id="1f51" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><code class="fe op oq or os b">primitive</code> -表示应该作为单个实例存在于整个集群中的资源。例如，一个IP可以被配置为一个原始资源，并且在任何给定的时间集群中应该只有一个该资源的实例。</p><p id="2dd0" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><code class="fe op oq or os b">virtual-ip-resource</code> -我们给我们的资源起的一个独特的名字。</p><p id="5ff9" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><code class="fe op oq or os b">ocf:heartbeat:IPaddr2</code>-OCF集群资源代理。</p><p id="59ce" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><code class="fe op oq or os b">meta migration-threshold</code> -创建资源时，您可以将其配置为在给定数量的故障发生后移动到不同的节点。该参数用于此目的。达到限制后，当前节点将无法拥有资源，直到发生以下情况之一</p><p id="f675" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">管理员重置资源的<code class="fe op oq or os b">failcount</code>值。<br/> ○达到资源的<code class="fe op oq or os b">failure-timeout</code>值。<br/> ○默认<code class="fe op oq or os b">migration-threshold</code>为<code class="fe op oq or os b">INFINITY</code>。在内部，这被定义为一个非常高但有限的值。将此项设置为0将禁用给定资源的阈值行为。</p><ul class=""><li id="64ed" class="np nq iq km b kn ko kr ks kv nr kz ns ld nt lh nu nv nw nx bi translated"><code class="fe op oq or os b">params</code> -资源代理的参数:</li></ul><p id="6971" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><code class="fe op oq or os b">ip</code>-IP v4地址以四点符号配置，例如“192.168.1.1”。(必需，字符串，无默认值)</p><p id="3cec" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><code class="fe op oq or os b">nic</code>-IP地址将在其上联机的基本网络接口。如果留空，脚本将尝试从路由表中确定这一点。不要在此处以<code class="fe op oq or os b">eth0:1</code>或任何形式指定别名接口；相反，请仅指定基接口。前提条件:必须至少有一个静态IP地址分配给网络接口，该地址不由群集管理。如果您不能在接口上分配任何静态IP地址，请修改这个内核参数:<code class="fe op oq or os b">sysctl -w net.ipv4.conf.all.promote_secondaries=1</code>(或每设备)。(可选，字符串，默认eth0)</p><p id="15bc" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><code class="fe op oq or os b">cidr_netmask</code>-CIDR格式接口的网络掩码(例如24而不是255.255.255.0)。如果未指定，脚本也将尝试从路由表中确定这一点。(可选，字符串，无默认值)</p><p id="2c21" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><code class="fe op oq or os b">broadcast</code> -与IP相关的广播地址。如果留空，脚本将根据网络掩码来确定。(可选，字符串，无默认值)</p><ul class=""><li id="9d22" class="np nq iq km b kn ko kr ks kv nr kz ns ld nt lh nu nv nw nx bi translated"><code class="fe op oq or os b">op</code> -配置监控操作:</li></ul><p id="dd74" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><code class="fe op oq or os b">monitor</code> -要执行的动作。常用值:<code class="fe op oq or os b">monitor</code>、<code class="fe op oq or os b">start</code>、<code class="fe op oq or os b">stop</code></p><p id="711b" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><code class="fe op oq or os b">interval</code> -如果设置为非零值，则创建一个循环操作，以该频率(秒)重复。非零值只有在动作名称设置为monitor时才有意义。资源启动完成后，将立即执行重复的监视操作，后续的监视操作将被安排在前一个监视操作完成时开始。例如，如果在01:00:00执行带有<code class="fe op oq or os b">interval=20s</code>的监控动作，下一个监控动作不会在01:00:20发生，而是在第一个监控动作完成后20秒发生。</p><p id="563d" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">如果设置为零(默认值)，则此参数允许您提供用于集群创建的操作的值。例如，如果间隔设置为零，操作的名称设置为start，超时值设置为40，那么Pacemaker在启动该资源时将使用40秒的超时。具有零间隔的监视操作允许您设置探头的超时/失败/启用值，Pacemaker在启动时获取所有资源的当前状态，而不需要默认值。</p><p id="7665" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><code class="fe op oq or os b">timeout</code> -如果操作没有在该参数设定的时间内完成，则操作被中止并视为失败。如果使用pcs资源操作默认值命令设置，默认值为超时值；如果未设置，默认值为20秒。如果您发现系统中包含的资源需要的时间超过了系统允许的执行时间(如启动、停止或监视)，请调查原因，如果预计执行时间会很长，您可以增加该值。</p><p id="1f0d" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">超时值不是任何类型的延迟，如果操作在超时期限结束前返回，群集也不会等待整个超时期限。</p><p id="d261" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><code class="fe op oq or os b">on-fail</code> -此操作失败时要采取的操作。</p><p id="18a2" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">允许的值:<br/> ○ <code class="fe op oq or os b">ignore</code> -假设资源没有失败。<br/> ○ <code class="fe op oq or os b">block</code> -不要对资源执行任何进一步的操作。<br/> ○ <code class="fe op oq or os b">stop</code> -停止资源，不要在其他地方启动它。<br/> ○ <code class="fe op oq or os b">restart</code> -停止资源并再次启动它(可能在不同的节点上)。<br/> ○ <code class="fe op oq or os b">fence</code> - STONITH资源出现故障的节点。<br/> ○ <code class="fe op oq or os b">standby</code> -将所有资源从资源出现故障的节点上移走。</p><blockquote class="nj nk nl"><p id="d184" class="kk kl ni km b kn ko kp kq kr ks kt ku nm kw kx ky nn la lb lc no le lf lg lh ij bi translated">参考:<a class="ae kc" href="http://www.linux-ha.org/doc/man-pages/re-ra-IPaddr2.html" rel="noopener ugc nofollow" target="_blank">http://www.linux-ha.org/doc/man-pages/re-ra-IPaddr2.html</a><br/>参考:<a class="ae kc" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/high_availability_add-on_reference/s1-resourceoperate-haar" rel="noopener ugc nofollow" target="_blank">https://access . red hat . com/documentation/en-us/red _ hat _ enterprise _ Linux/7/html/high _ avail ability _ add-on _ Reference/S1-resource operate-Haar</a></p></blockquote><ul class=""><li id="3290" class="np nq iq km b kn ko kr ks kv nr kz ns ld nt lh nu nv nw nx bi translated"><code class="fe op oq or os b">primitive haproxy-resource ocf:heartbeat:haproxy op monitor interval=20 timeout=60 on-fail=restart<br/></code>解释同上。</li><li id="ed17" class="np nq iq km b kn ny kr nz kv oa kz ob ld oc lh nu nv nw nx bi translated"><code class="fe op oq or os b">colocation loc inf: virtual-ip-resource haproxy-resource</code></li></ul><p id="f393" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><code class="fe op oq or os b">colocation</code>限制允许您告诉集群资源如何相互依赖。它有一个重要的副作用:它会影响资源分配给节点的顺序。</p><p id="2262" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">仔细想想:集群不能将<code class="fe op oq or os b">A</code>和<code class="fe op oq or os b">B</code>共存，除非它知道<code class="fe op oq or os b">B</code>在哪里。因此，在设置<code class="fe op oq or os b">colocation</code>限制时，考虑<code class="fe op oq or os b">A</code>是否需要与<code class="fe op oq or os b">B</code>同地办公或者<code class="fe op oq or os b">B</code>是否需要与<code class="fe op oq or os b">A</code>同地办公是非常重要的。</p><p id="56cc" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在我们的情况下，由于<code class="fe op oq or os b">haproxy-resource</code>应该与<code class="fe op oq or os b">virtual-ip-resource</code>位于同一位置，因此<code class="fe op oq or os b">haproxy-resource</code>将被分配到与<code class="fe op oq or os b">virtual-ip-resource</code>相同的节点上。</p><ul class=""><li id="6e2c" class="np nq iq km b kn ko kr ks kv nr kz ns ld nt lh nu nv nw nx bi translated"><code class="fe op oq or os b">order ord inf: virtual-ip-resource haproxy-resource</code></li></ul><p id="b73b" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><code class="fe op oq or os b">order</code>约束告诉集群资源的分配顺序。在这种情况下，我们通知<code class="fe op oq or os b">virtual-ip-resource</code>应该总是在<code class="fe op oq or os b">haproxy-resource</code>之前分配。<br/>排序约束只影响资源的创建顺序。它们不会导致资源位于同一节点上。</p><h2 id="1858" class="od mg iq bd mh oe of dn ml og oh dp mp kv oi oj mt kz ok ol mx ld om on nb oo bi translated">理解用户数据文件(TL；灾难恢复)</h2><p id="29a0" class="pw-post-body-paragraph kk kl iq km b kn nd kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld nh lf lg lh ij bi translated">云初始化<strong class="km ir"> HAProxy </strong>配置文件可以在这里<a class="ae kc" href="https://github.com/mvallim/kubernetes-under-the-hood/blob/master/data/debian/hapx/user-data" rel="noopener ugc nofollow" target="_blank"/>找到。这为<strong class="km ir"> Kube主节点</strong>建立了负载平衡。</p><p id="2232" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">下面您可以找到相同的文件注释，以便于理解:</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="pk pl l"/></div></figure><h1 id="6620" class="mf mg iq bd mh mi pb mk ml mm pc mo mp mq pd ms mt mu pe mw mx my pf na nb nc bi translated">查看HAProxy统计页面</h1><p id="360d" class="pw-post-body-paragraph kk kl iq km b kn nd kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld nh lf lg lh ij bi translated">现在一切都设置好了，您可以通过我们刚刚配置的<strong class="km ir">虚拟IP </strong>访问HAProxy统计数据。</p><p id="c8df" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在<a class="ae kc" href="http://192.168.4.20:32700/" rel="noopener ugc nofollow" target="_blank">打开浏览器，http://192.168.4.20:32700 </a></p><p id="aa52" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><em class="ni">用户:</em> <code class="fe op oq or os b"><em class="ni">admin</em></code> <em class="ni"> <br/>密码:</em> <code class="fe op oq or os b"><em class="ni">admin</em></code></p><p id="b759" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">它将显示:</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pm"><img src="../Images/513b7629237f6b4ba092bb3989716155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aUZUGEJGphOM0zRF.png"/></div></div></figure><p id="70aa" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">请注意所有控制平面端点均为<strong class="km ir"> <em class="ni">向下</em> </strong></p><ul class=""><li id="ee73" class="np nq iq km b kn ko kr ks kv nr kz ns ld nt lh nu nv nw nx bi translated">kube-mast01:6443</li><li id="b398" class="np nq iq km b kn ny kr nz kv oa kz ob ld oc lh nu nv nw nx bi translated">kube-mast02:6443</li><li id="5d6c" class="np nq iq km b kn ny kr nz kv oa kz ob ld oc lh nu nv nw nx bi translated">kube-mast03:6443</li></ul><p id="b5cd" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">一旦我们设置了Kubernetes主节点，这个问题就会解决。</p><h1 id="7f57" class="mf mg iq bd mh mi pb mk ml mm pc mo mp mq pd ms mt mu pe mw mx my pf na nb nc bi translated">测试高可用性</h1><p id="8a8e" class="pw-post-body-paragraph kk kl iq km b kn nd kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld nh lf lg lh ij bi translated">关闭两个虚拟机中的一个(<code class="fe op oq or os b">hapx-node01</code>或<code class="fe op oq or os b">hapx-node02</code>)，并在打开<strong class="km ir"> HAProxy </strong>统计的浏览器中按<code class="fe op oq or os b">F5</code>。不应注意到任何差异或错误。:)</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="f728" class="mf mg iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated"><strong class="ak">结论</strong></h1><p id="3a56" class="pw-post-body-paragraph kk kl iq km b kn nd kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld nh lf lg lh ij bi translated">在本文中，我们深入探讨了配置一个由<strong class="km ir"> Corosync </strong>和<strong class="km ir"> Pacemaker </strong>支持的具有高可用性的<strong class="km ir"> HAProxy集群</strong>。我们单独配置了每个组件，还配置了一个弹性IP，允许<strong class="km ir"> HAProxy集群</strong>在其任何节点出现故障时透明地进行故障转移。</p><p id="d12e" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我希望您在配置集群的过程中获得了乐趣，并学到了一些有用的东西。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="cd4d" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在下一篇文章中，我们将看到如何配置具有高可用性的<strong class="km ir"> Kubernetes主</strong>实例。敬请期待！</p><p id="66da" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">如果你认为这是有帮助的，请留下你的👏以及下面的反馈。不断完善这个系列的内容非常重要。</p><p id="9e1d" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我再次强烈推荐您关注我的Medium，这样您就不会错过本系列中发表的任何新文章。如果你错过了本系列的第一篇文章，你可以在这里查看<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-journey-up-and-running-out-of-the-cloud-introduction-f04a811c92a5"/>。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="fe1d" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">回头见！！</p><p id="75f5" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">再见。</p></div></div>    
</body>
</html>