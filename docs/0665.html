<html>
<head>
<title>Large scale front end architecture and modular design in SAP UI5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SAP UI5中的大规模前端架构和模块化设计</h1>
<blockquote>原文：<a href="https://itnext.io/large-scale-front-end-architecture-in-sap-ui5-207ce0ddbe0?source=collection_archive---------5-----------------------#2018-05-02">https://itnext.io/large-scale-front-end-architecture-in-sap-ui5-207ce0ddbe0?source=collection_archive---------5-----------------------#2018-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0c5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单介绍一下我，我是SAP的首席前端开发人员。在我的职业生涯中，我参与了许多大型复杂的前端应用。几年前，我开始了SAP UI5之旅。欢迎你在LinkedIn<a class="ae kl" href="https://www.linkedin.com/in/haojia" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/haojia</a>和GitHub <a class="ae kl" href="https://github.com/haojia321" rel="noopener ugc nofollow" target="_blank"> haojia321 </a>上关注我。</p><p id="be70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天，我想分享一些我在设计大规模前端架构以及如何在SAP UI5中实现它方面的经验。所以会有两个话题:1。大规模前端架构的总体设计。2.如何在SAP UI5中实现？</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h2 id="7eed" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">第一部分。大规模前端架构的总体设计</h2><p id="b1a0" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">所有好的应用程序应该:</p><ol class=""><li id="73eb" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated">易于修改和扩展。</li><li id="0181" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">便于多个团队同时工作，而不用担心弄乱应用程序的其他部分。</li><li id="05c1" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">易于人们理解的设计。</li></ol><p id="b196" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我通过将应用分成多个<strong class="jp ir">模块</strong>和<strong class="jp ir">将应用逻辑抽象</strong>到不同层来实现。</p><p id="34c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://en.wikipedia.org/wiki/Modular_design#In_computer_hardware" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">模块化设计</strong> </a> <strong class="jp ir"> </strong>在我们的日常生活中无处不在。我想以模块化硬件计算机为例:</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mf"><img src="../Images/9685f77f9cad2794901a5a6de5263f7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-k4nTu_rFy7p9SX_BnuKnw.jpeg"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">计算机硬件的模块化设计</figcaption></figure><p id="775d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">电脑机箱内有很多组件:CPU、硬盘、显卡和散热风扇等。如果我认为CPU是我的电脑的性能瓶颈，我可以简单地买一个更好的CPU来取代旧的。那简单又快速。我不需要担心它会损坏电脑的其他组件。现在回到我们的前端世界。我如何确定应该把哪些部分放入一个模块中？嗯，这要视情况而定，但是我的指导方针是你应该把那些密切相关的UI页面合并到一个模块中。图表应该是这样的:</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mv"><img src="../Images/c0305b404e2a14c5c6cd3e609933400a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2aKKG2890aThya1S2zHP1Q.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">前端应用中的模块化设计</figcaption></figure><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mw"><img src="../Images/872b5ff4ecf722ed24c68717f2ea188b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_tpzFl3DHj1RKErmCGbZpw.jpeg"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">可重用UI组件</figcaption></figure><ul class=""><li id="6c4d" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk mx lx ly lz bi translated">应用程序容器根据需要创建和呈现其他模块。应用程序容器只做这个，不做别的。</li><li id="3d9c" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk mx lx ly lz bi translated">每个模块不应该知道彼此。</li><li id="d4d3" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk mx lx ly lz bi translated">应该有一个全局级的EventBus通信机制。每个模块只能通过<strong class="jp ir"> EventBus </strong>进行通信。</li><li id="e59d" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk mx lx ly lz bi translated">与模块化设计相比，UI组件粒度更小。UI组件应该是可以跨所有模块重用的通用UI元素。它可以是一个按钮，列表或警告弹出窗口等。这里有一个关于<a class="ae kl" href="https://guide.meteor.com/ui-ux.html#components" rel="noopener ugc nofollow" target="_blank"> <em class="my"> UI组件</em> </a>的很好的指南。</li></ul></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h2 id="bb90" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">第二部分。如何在Open UI5或SAP UI5中实现</h2><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mz"><img src="../Images/a6e2a9f7a7b98c0f8668b3e656e20834.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LuEFpKVC3oHfttWFac6K0w.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">打开UI5</figcaption></figure><p id="6e2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本部分的先决条件是你应该对open UI5或SAP UI5框架有基本的了解。如果你不知道，我强烈建议你先停下来查看一下 <a class="ae kl" href="http://openui5.org/" rel="noopener ugc nofollow" target="_blank"> <em class="my">打开UI5 </em> </a> <em class="my">文档。</em></p><p id="1fd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2.1概述</strong></p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi na"><img src="../Images/5936672e280ae243c16ffbf78ebe36a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tl1W11HhKGcmR3B-BkH5YQ.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">UI5中的大规模架构</figcaption></figure><p id="a7a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/haojia321/modular-design-in-sap-ui5" rel="noopener ugc nofollow" target="_blank">我在github中创建了一个演示来演示实现</a>。在这个演示中，我创建了ApplicationContainer模块和两个子模块，Student和Exam。</p><ul class=""><li id="08a5" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk mx lx ly lz bi translated">学生模块有两个页面:编辑学生和搜索学生。</li><li id="d980" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk mx lx ly lz bi translated">考试模块有两个页面:编辑考试和搜索考试。</li><li id="0776" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk mx lx ly lz bi translated">ApplicationContainer有一个菜单栏和主显示区。</li><li id="5b40" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk mx lx ly lz bi translated">ApplicationContainer只有一个路由模式:“{module}&amp;:all*:”。它将适合所有的页面。它所做的就是根据需要加载模块，并将模块渲染到相应的UI区域。</li><li id="caac" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk mx lx ly lz bi translated">用户点击菜单栏中的链接后，每个模块将根据需要呈现在主显示区域中。</li><li id="37b7" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk mx lx ly lz bi translated">为了简化演示，主显示区每次只能显示一个模块。其他模块可以呈现在主显示区域，但是它们将被隐藏。</li></ul><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nb"><img src="../Images/79e6209ee088104ff3aa1564f37eee76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6a34sIfY6YUNIQQ4YDe4mA.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">演示的用户界面</figcaption></figure><p id="b5c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2.2如何构建模块</strong></p><p id="8d0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">UI5推荐使用UIComponent.js和manifest.json来设置项目。我的实现遵循它。<strong class="jp ir">【注:UI5中的UIComponent.js与我们在第1部分提到的UI组件设计是不同的概念。相应的术语在UI5中称为UI控件。SAP UI5有一个非常健壮的</strong> <a class="ae kl" href="https://openui5.hana.ondemand.com/#/controls" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> UI控件库</strong> </a> <strong class="jp ir">。] </strong></p><p id="db24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我利用UIComponent.js实现了一个模块设计。UIComponent.js的好处是:</p><ul class=""><li id="6b48" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk mx lx ly lz bi translated">它在框架层次上与其他模块相隔离。</li><li id="d464" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk mx lx ly lz bi translated">它可以像插入/拔出USB驱动器一样轻松更换。</li><li id="0e2a" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk mx lx ly lz bi translated">每个模块加载自己的css文件和i18n标签。</li><li id="fe6c" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk mx lx ly lz bi translated">每个模块捆绑自己的资源文件，带来更好的网络性能。</li><li id="8fca" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk mx lx ly lz bi translated">每个模块都可以单独测试。</li></ul><p id="9a96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2.3如何在ApplicationContainer中渲染显示模块</strong></p><p id="f0be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我创建了一个ComponentLoader控件。ApplicationContainer组成ComponentLoader。它使用ComponentLoader将相应的组件呈现和显示到特定的DIV/control中。请检查我的演示代码了解更多细节。</p><p id="565a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2.4导航</strong></p><p id="5740" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">UI5使用路由模式来表示浏览器url地址。让我们仔细看看路线模式:</p><ul class=""><li id="c882" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk mx lx ly lz bi translated">学生模块有2条路线，模式是:“编辑/{id}”和“学生搜索”。</li><li id="f1d8" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk mx lx ly lz bi translated">考试模块有2条路线，模式为:“编辑/{id}”和“搜索”。</li><li id="ee52" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk mx lx ly lz bi translated">ApplicationContainer只有一种模式“{module}&amp;:all*:”</li></ul><p id="f50f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，学生和考试模块都有路由模式“edit/{id}”。因此，当您在浏览器url地址栏中输入“edit/{id}”时，ApplicationContainer不知道应该选择哪个模块并进行初始化。那么我们如何解决这个问题呢？我想出了以下一些方法:</p><p id="8d14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">方法1: <br/> </strong> <a class="ae kl" href="https://openui5.hana.ondemand.com/#/topic/2c66fb3eb775426087401117cfa6a94e" rel="noopener ugc nofollow" target="_blank">根据SAPUI5文档</a>，可以在模块路由配置文件中定义一个父路由。但是这不是一个好主意，因为这个模块将与一个特定的父模块耦合。这将限制模块的可重用性。子模块(学生和考试模块)不应该知道父模块(应用程序容器)。</p><p id="e498" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">方法2(演示使用了这种方法):</strong></p><p id="dc81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我创建了一个名为ModularRouter的新路由器，它是从sap.m.routing.Router扩展而来的。</p><ol class=""><li id="2aec" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated">ModularRouter在运行时向模块的路由模式添加前缀。前缀值由模块的创建者传递，在本例中是ApplicationContainer。</li><li id="2cd2" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">ModularRouter接受一个回调函数，该函数将在路由器初始化后被调用。当您在创建了一个模块并呈现到页面中之后想要做一些事情时，这非常有用。</li></ol><p id="9f8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看application container manifest . JSON:</p><pre class="mg mh mi mj gt nc nd ne nf aw ng bi"><span id="7749" class="kt ku iq nd b gy nh ni l nj nk">"sap.ui5": {<br/>    "_version": "1.1.0",<br/>    <strong class="nd ir"><em class="my">"componentUsages": {<br/>        "student": {<br/>            "name": "com.haojia.test.student",<br/>            "componentData": {<br/>                "routePatternPrefix": "student&amp;/"<br/>            }<br/>        },<br/>        "exam": {<br/>            "name": "com.haojia.test.exam",<br/>            "componentData": {<br/>                "routePatternPrefix": "exam&amp;/"<br/>            }<br/>        }<br/>    }</em></strong>,<br/>    "dependencies": {<br/>        "minUI5Version": "1.30",<br/>        "libs": {<br/>            "sap.m": {}<br/>        },<br/>        <strong class="nd ir"><em class="my">"components": {<br/>            "com.haojia.test.student": {}<br/>        }</em></strong><br/>    },<br/>    "rootView": "com.haojia.test.applicationContainer.view.App",<br/>    "routing": {<br/>        "config": {<br/>            "routerClass": "com.haojia.test.util.ModularRouter",<br/>            "viewType": "XML",<br/>            "viewPath": "com.haojia.test.adminLayout.view",<br/>            "transition": "show",<br/>            "controlId": "app",<br/>            "clearTarget": true,<br/>            "controlAggregation": "pages"<br/>        },<br/>        "routes": [{<br/>            "name": "App",<br/>            <strong class="nd ir"><em class="my">"pattern": "{module}&amp;:all*:"</em></strong><br/>        }]<br/>    }<br/>}</span></pre><p id="8ef3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意粗体的文字。作为父模块，它将学生模块定义为依赖模块。并通过<a class="ae kl" href="https://openui5.hana.ondemand.com/#/api/sap.ui.core.Component/methods/getComponentData" rel="noopener ugc nofollow" target="_blank"> componentData </a>传递routePatternPrefix。通过这样做，我们可以动态地向路由模式添加前缀，以解决多模块模式冲突问题。</p><p id="4a85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个模块都有自己的路由器和模式定义。但是浏览器的url栏对每个模块都是全局的。也就是说，一个url可以被多个模块匹配。所以模式X有可能同时被ApplicationContainer和Student模块匹配。为了利用这一点，ApplicationContainer只有一个路由模式:“{module}&amp;:all*:”。这是一个模糊模式匹配，将匹配每个模块。</p><p id="1441" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们举一个真实的url例子，假设浏览器地址栏中当前的url是<a class="ae kl" href="http://www.haojia.space#/student&amp;/edit/abc" rel="noopener ugc nofollow" target="_blank">http://www . haojia . space #/student&amp;/edit/ABC</a></p><ol class=""><li id="0266" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated">因为ApplicationContainer的路由模式是“{module}&amp;:all*:”，所以模式将匹配，并且{module}参数是“student”。ApplicationContainer将基于{module}参数创建和呈现学生模块。</li><li id="4a0e" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">然后创建学生模块。编辑路由模式是“edit/{id}”，但是由于我们在manifest.json中定义了<strong class="jp ir"><em class="my">routePatternPrefix</em></strong>，它的运行时路由模式现在是“student &amp; /edit/{id}”。宾果，该网址将匹配编辑路线没有冲突了！</li></ol><p id="29ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.5模块间的导航</p><p id="523d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模块互不认识。但是如果你需要从模块A导航到模块B呢？我们使用SAP EventBus进行跨模块通信。模块A将事件发布到ApplicationContainer。然后，ApplicationContainer相应地呈现目标模块B。</p></div></div>    
</body>
</html>