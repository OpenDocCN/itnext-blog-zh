<html>
<head>
<title>React Internals: Deep Dive React Server Components (as it is)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React内部:深入研究React服务器组件(按原样)</h1>
<blockquote>原文：<a href="https://itnext.io/react-internals-deep-dive-react-server-components-as-it-is-d8e5f3d5c375?source=collection_archive---------5-----------------------#2021-06-20">https://itnext.io/react-internals-deep-dive-react-server-components-as-it-is-d8e5f3d5c375?source=collection_archive---------5-----------------------#2021-06-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1ab02f526fbbe2c835569f3c499d0336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OCWBiG-NyKNbxF0-Qy0u8Q.png"/></div></div></figure><p id="920a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">React服务器组件是2020年12月发布的一个实验性功能，它是客户端渲染(CSR)和服务器端渲染(SSR)的一种混合。但是它是如何将它们混合在一起的，这正是我们在这篇文章中要探讨的。</p><blockquote class="kz la lb"><p id="991b" class="kb kc lc kd b ke kf kg kh ki kj kk kl ld kn ko kp le kr ks kt lf kv kw kx ky im bi translated">免责声明:由于react服务器组件仍然是高度实验性的，并不时更新，这篇文章在2021年6月后可能不正确。</p></blockquote><h1 id="aad9" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">CSR与SSR</h1><p id="f54d" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">CSR和SSR之间的斗争永远不会结束，有大量的文章和讨论来分析它们的利弊。作为一名软件开发人员/架构师，开始一个全新的项目时，您可能总是会面临这样的困境:当没有过去的遗留或依赖时，选择使用哪一个。但是如果我们重新思考这个问题，实际上我们不必只选择其中一个，而是利用他们两个，因为他们比另一个做得更好。我个人的决策建议是:</p><blockquote class="mj"><p id="0b7e" class="mk ml it bd mm mn mo mp mq mr ms ky dk translated">CSR用于交互性，SSR用于数据获取。</p></blockquote><p id="b6a5" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">CSR离用户很近，所以当你需要尽快与用户交互，甚至不需要从服务器获取任何数据时，使用更多的CSR，因为它运行在浏览器内部，提供最好的交互性。</p><p id="f5fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">SSR靠近数据存储，所以当从数据存储中检索数据时，计算并向用户呈现视图。使用SSR可能会节省一些网络传输时间，并且只向用户发送关键数据。</p><blockquote class="kz la lb"><p id="3749" class="kb kc lc kd b ke kf kg kh ki kj kk kl ld kn ko kp le kr ks kt lf kv kw kx ky im bi translated">在比较CSR和SSR时，还有其他经常提到的重要话题(如SEO ),在这里我不会讨论它们，因为我想保持简单，只强调一些基本特征。</p></blockquote><p id="6ed4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从技术上讲，同时使用CSR和SSR是完全可行的，但是这种混合模式的维护成本通常很高，如果您喜欢更干净的前端架构，这看起来是不可行的。但是使用React服务器组件，可能更有可能以适当且低维护成本的方式实现CSR和SSR前端的混合。</p><h1 id="69b4" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">React服务器组件如何工作</h1><blockquote class="kz la lb"><p id="5cba" class="kb kc lc kd b ke kf kg kh ki kj kk kl ld kn ko kp le kr ks kt lf kv kw kx ky im bi translated">要了解react服务器组件的基础知识，强烈建议在这里观看视频<a class="ae my" href="https://reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><p id="d0a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在React服务器组件约定中，组件被拆分为<code class="fe mz na nb nc b">*.server.js</code>和<code class="fe mz na nb nc b">*.client.js</code>来表示它们在哪里被执行。使用<code class="fe mz na nb nc b">*.server.js</code>组件可以加速数据获取(因为它靠近数据存储)并减少包的大小(一些非视图js库如moment.js不会被发送到客户端)。对于<code class="fe mz na nb nc b">*.client.js</code>组件，实际上它们就像你之前写的任何react组件一样，但是可以与<code class="fe mz na nb nc b">*.server.js</code>组件无缝集成，这是一个巨大的优势。但这些好处在技术上是如何来的，是我们接下来要讨论的关键话题。</p><p id="7bc0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要研究底层的魔力，最好的起点是<a class="ae my" href="https://github.com/reactjs/server-components-demo" rel="noopener ugc nofollow" target="_blank">服务器-组件-演示</a>存储库。在克隆、运行和试验之后，你会很快在网络响应中发现一个API <code class="fe mz na nb nc b">/react</code>在前端有一些交互时被调用。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8f49c945b3dd4aa1ce5531f6d520efbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rPn0fFIlnuqbvcG2D7-aNg.png"/></div></div></figure><p id="8786" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个API的响应非常有趣，因为它看起来像react组件的序列化版本:</p><figure class="nd ne nf ng gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="adeb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这给我们带来了一个假设，即服务器组件可能以JSON中的序列化格式发送给客户机。详细信息可以在react存储库中的<a class="ae my" href="https://github.com/facebook/react/tree/master/packages/react-server" rel="noopener ugc nofollow" target="_blank"> react-server </a>包中找到:</p><div class="nj nk gp gr nl nm"><a href="https://github.com/facebook/react/blob/master/packages/react-server/src/ReactFlightServerConfigStream.js#L23" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd iu gy z fp nr fr fs ns fu fw is bi translated">facebook/react</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">一个用于构建用户界面的声明式、高效且灵活的JavaScript库。- facebook/react</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">github.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa jz nm"/></div></div></a></div><div class="nj nk gp gr nl nm"><a href="https://github.com/facebook/react/blob/master/packages/react-server/src/ReactFlightServer.js" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd iu gy z fp nr fr fs ns fu fw is bi translated">facebook/react</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">一个用于构建用户界面的声明式、高效且灵活的JavaScript库。- facebook/react</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">github.com</p></div></div><div class="nv l"><div class="ob l nx ny nz nv oa jz nm"/></div></div></a></div><p id="6403" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总之，<code class="fe mz na nb nc b">*.server.js</code>组件实际上是在服务器端渲染的组件，渲染结果被序列化并以JSON格式发送到客户端。这意味着您不能在<code class="fe mz na nb nc b">*.server.js</code>组件中使用函数(包括事件处理程序)、引用和大多数挂钩，因为它们与<code class="fe mz na nb nc b">*.client.js</code>组件不在同一上下文中。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/af8297d58d12c91ae4007df871fa294b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*wsep4eUFcnZy8Eey-n5iXw.png"/></div><figcaption class="od oe gj gh gi of og bd b be z dk translated">用一张图解释</figcaption></figure><h1 id="3e1a" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结论</h1><p id="4cae" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">在我看来，我认为React服务器组件是一个打破CSR和SSR之间孤岛的新实验。这并不意味着取代它们中的任何一个，而是使开发者能够充分利用它们。它是否会成为一个流行的特性还不得而知，但至少作为开发者我们可以有一个新的选择，它的实现方式也可以成为未来任何具有类似目的的框架的一个很好的参考。</p></div></div>    
</body>
</html>