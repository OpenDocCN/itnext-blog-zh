<html>
<head>
<title>How V8 optimizes functions in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">V8如何优化JavaScript中的函数？</h1>
<blockquote>原文：<a href="https://itnext.io/v8-function-optimization-2a9c0ececf5e?source=collection_archive---------5-----------------------#2019-08-09">https://itnext.io/v8-function-optimization-2a9c0ececf5e?source=collection_archive---------5-----------------------#2019-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/306f5652c1986ba4406717a8c952c8db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fs1svPl7qb9XMOrO6LK_ow.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">CC0公共领域，来源:Pxhere</figcaption></figure><div class=""/><div class=""><h2 id="fc40" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">JS引擎是复杂的软件。我想快速解释一下V8用来加速你的…</h2></div><blockquote class="ku kv kw"><p id="c71e" class="kx ky kz la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><em class="jf">如果您不想在您的计算机上运行它，请跳到“</em>我们要优化什么？”</p></blockquote><p id="4330" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">首先，我们需要安装V8以便能够在没有整个包(节点或web浏览器)的情况下运行它。我为Linux用户创建了一个描述这个过程的要点。</p><p id="7753" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated"><a class="ae lx" href="https://gist.github.com/burnpiro/d85d836200df93af892877c2cf37f12c" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/burn piro/d85d 836200 df 93 af 892877 C2 cf 37 f 12 c</a></p><p id="31fc" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">如果你是Mac用户，它应该也适用于你。如果您在安装过程中有任何问题，请参考<a class="ae lx" href="https://v8.dev/docs/build" rel="noopener ugc nofollow" target="_blank">正式文件</a></p><p id="81d8" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">安装后，您应该能够运行如下代码</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="42a7" class="mh mi jf md b gy mj mk l ml mm">// index.js<br/><br/>console.log('it works');</span></pre><p id="60d7" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">通过打电话</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="20aa" class="mh mi jf md b gy mj mk l ml mm">d8 index.js</span></pre><h1 id="b0b8" class="mn mi jf bd mo mp mq mr ms mt mu mv mw kl mx km my ko mz kp na kr nb ks nc nd bi translated">我们试图优化什么？</h1><p id="266a" class="pw-post-body-paragraph kx ky jf la b lb ne kg ld le nf kj lg lu ng lj lk lv nh ln lo lw ni lr ls lt ij bi translated">我们的测试函数如下所示:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="dc84" class="mh mi jf md b gy mj mk l ml mm">function test(obj: any): string {<br/>  let result = '';<br/>  for (let i = 0; i &lt; N; i += 1) {<br/>    result += obj.a + obj.b;<br/>  }<br/>  return result;<br/>}</span></pre><p id="a83a" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">让我们假设这个函数在脚本执行过程中被调用了数千次，因此快速运行是非常重要的。在我解释如何在V8中进行优化之前，我们需要知道什么是形状以及线内缓存(IC)是如何工作的。</p><h1 id="53f0" class="mn mi jf bd mo mp mq mr ms mt mu mv mw kl mx km my ko mz kp na kr nb ks nc nd bi translated">形状(V8中的地图)</h1><blockquote class="ku kv kw"><p id="197e" class="kx ky kz la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><em class="jf">这个形状的学名是“隐藏类”,特别是在JS中，这可能会令人困惑，所以每个人都有不同的称呼，但FF团队介绍的名称可能是最好的。</em></p></blockquote><p id="0e36" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated"><code class="fe nj nk nl md b">Shape</code>包含了很多staff，但是当人们使用这个名字时，他们大多把它称为对象属性的<code class="fe nj nk nl md b">descriptors</code>表。Shape还存储其他信息，比如对象的大小以及指向构造函数和原型的指针。我很快会在例子中展示给你们看。</p><p id="b349" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">让我们从一个简单的对象开始:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="5b42" class="mh mi jf md b gy mj mk l ml mm">const obj = {<br/>  x: 1,<br/>  y: 1,<br/>};</span></pre><p id="79be" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">它在V8中的表示如下</p><figure class="ly lz ma mb gt is gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/af4974c4ae9f7d5f0f6951d456fad3e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*JZlSq4mlPkvlD0GBDhXXww.png"/></div></figure><p id="e9f4" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">如果你观察它，在对象值和它们的描述之间有一个明显的区别。该对象的每个属性都根据形状中定义的<code class="fe nj nk nl md b">offset</code>存储在内存中。在我们的例子中，属性<code class="fe nj nk nl md b">x</code>与<code class="fe nj nk nl md b">offset: 12</code>一起存储，后者告诉v8通过将指针偏移12来寻找<code class="fe nj nk nl md b">obj.x</code>值。</p><figure class="ly lz ma mb gt is gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/9f6c951a9033b694fca9fce55efef748.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*Akot1ScY_X1Fkns7Hd0Oaw.png"/></div></figure><p id="ec64" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">好了，现在你知道什么是形状了，但是为什么它这么有用呢？</p><h1 id="d6ad" class="mn mi jf bd mo mp mq mr ms mt mu mv mw kl mx km my ko mz kp na kr nb ks nc nd bi translated">形状的有用性</h1><p id="0774" class="pw-post-body-paragraph kx ky jf la b lb ne kg ld le nf kj lg lu ng lj lk lv nh ln lo lw ni lr ls lt ij bi translated">当您创建一个对象时，如果您的系统中有一个类似的对象，您不会真的想再次存储关于它的所有信息。这就是V8重新使用其形状的原因。</p><figure class="ly lz ma mb gt is gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/21d0797ed0f09ca74d55614bff47b706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*3Pi4zPhRlZ5U-9SkyKSL8Q.png"/></div></figure><p id="e584" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">造成这种情况的代码可能如下所示</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="49a7" class="mh mi jf md b gy mj mk l ml mm">const obj1 = {<br/>  x: 1,<br/>  y: 1,<br/>};<br/>const obj2 = {<br/>  x: 3,<br/>  y: 4,<br/>};<br/>const obj3 = {<br/>  x: 5,<br/>  y: 6,<br/>};</span></pre><h1 id="6392" class="mn mi jf bd mo mp mq mr ms mt mu mv mw kl mx km my ko mz kp na kr nb ks nc nd bi translated">并非所有具有相同“结构”的物体都具有相同的形状</h1><p id="bfea" class="pw-post-body-paragraph kx ky jf la b lb ne kg ld le nf kj lg lu ng lj lk lv nh ln lo lw ni lr ls lt ij bi translated">如果你比较这两个物体</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="6f12" class="mh mi jf md b gy mj mk l ml mm">const obj1 = {<br/>  x: 1,<br/>  y: 1,<br/>};<br/>const obj2 = {};<br/>obj2.x = 1;<br/>obj2.y = 1;</span></pre><p id="4aa8" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">他们可能看起来一样，但他们有不同的形状。我们已经讨论过的第一个的形状。第二个的形状在这里</p><figure class="ly lz ma mb gt is gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/d32aa7ef15665aa85532bc2e7d198b62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*x-4XwWL8TmpE1eS8LnwY4A.png"/></div></figure><p id="011c" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">在代码执行过程中，V8创建了3个不同的形状和它们之间的过渡来描述最终结果。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="08ca" class="mh mi jf md b gy mj mk l ml mm">const obj2 = {};<br/>// Shape M0<br/>// add "x": Transition to M1, offset 12<br/><br/>obj2.x = 1;<br/>// Shape M1<br/>// "x": at offset 12<br/>// add "y": Transition to M2, offset 16<br/><br/>obj2.y = 1;<br/>// Shape M2<br/>// "x": at offset 12<br/>// "y": at offset 16</span></pre><p id="1552" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">创建类时也是如此</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="4cf8" class="mh mi jf md b gy mj mk l ml mm">class MyComponent {<br/>  constructor(size, name) {<br/>    // Shape M0<br/><br/>    this.size = size;<br/>    // Shape M1<br/>    // "size": at some offset<br/><br/>    this.name = name;<br/>    // Shape M2<br/>    // "size": at some offset<br/>    // "name": at some other offset<br/>  }<br/>}</span></pre><p id="cfc1" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">100%诚实地说，V8不会存储整个形状，当它在它们之间转换时。</p><figure class="ly lz ma mb gt is gh gi paragraph-image"><div class="gh gi no"><img src="../Images/93002e14db984c3803283de5b8a39b60.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*APa53TA3aYS1tH3bpthI8Q.png"/></div></figure><p id="bfe4" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">它不会将关于<code class="fe nj nk nl md b">x</code>属性的信息复制到<code class="fe nj nk nl md b">Shape M2</code>中。这使得它可以在拥有不同对象时形成树状结构。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="3078" class="mh mi jf md b gy mj mk l ml mm">const obj1 = {};<br/>obj1.x = 1;<br/>const obj2 = {};<br/>obj2.x = 1;<br/>obj2.y = 1;<br/>const obj3 = {};<br/>obj3.x = 1;<br/>obj3.z = 1;<br/>obj3.k = 1;<br/>const obj4 = {};<br/>obj4.i = 1;<br/>obj4.j = 'test';<br/>obj4.k = 1;</span></pre><figure class="ly lz ma mb gt is gh gi paragraph-image"><div class="gh gi np"><img src="../Images/8c85daa89b9da4e097af7143245b5bb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*8whXDNKJfNnd_WPhJewYTw.png"/></div></figure><p id="5a87" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">注意，即使我们使用相同的属性名作为第三属性，在<code class="fe nj nk nl md b">obj3</code>和<code class="fe nj nk nl md b">obj4</code>中，这是两个不同的形状。原因是因为形状与过渡有关。如果你有一个代表<code class="fe nj nk nl md b">k</code>属性的全局形状，它需要定义<code class="fe nj nk nl md b">offset</code>属性。这可能适用于内存中的相同对象结构(偏移量是根据对象的其余部分在属性之前占用的空间大小来设置的)。因此，如果你有一个类似于<code class="fe nj nk nl md b">obj4</code>的对象，那么属性<code class="fe nj nk nl md b">k</code>可能与属性<code class="fe nj nk nl md b">k</code>在<code class="fe nj nk nl md b">obj3</code>上有不同的偏移量(过渡到形状M7是不同的)。</p><h1 id="e4dc" class="mn mi jf bd mo mp mq mr ms mt mu mv mw kl mx km my ko mz kp na kr nb ks nc nd bi translated">内嵌高速缓存</h1><p id="d7bd" class="pw-post-body-paragraph kx ky jf la b lb ne kg ld le nf kj lg lu ng lj lk lv nh ln lo lw ni lr ls lt ij bi translated">也许这次从代码开始？</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="9e63" class="mh mi jf md b gy mj mk l ml mm">const N = 1000000;<br/>const obj1 = {};<br/>obj1.name = 'Jake';<br/><br/>function getMeName(o) {<br/>  return o.name;<br/>}<br/><br/>for (let i = 0; i &lt; N; i += 1) {<br/>  getMeName(obj1);<br/>}</span></pre><p id="91ba" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">然后像这样运行这段代码</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="4157" class="mh mi jf md b gy mj mk l ml mm">d8 --trace-ic index.js</span></pre><blockquote class="ku kv kw"><p id="b9e3" class="kx ky kz la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><em class="jf">题外话:你可能想知道为什么我们要运行函数那么多次。这是因为V8不会尝试优化功能，除非该功能被标记为</em> <code class="fe nj nk nl md b"><em class="jf">hot</em></code> <em class="jf">。并且多次运行函数时会得到</em> <code class="fe nj nk nl md b"><em class="jf">hot</em></code> <em class="jf">状态。</em></p></blockquote><p id="b012" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">现在您可以在浏览器中打开<code class="fe nj nk nl md b">path/to/v8/tools/ic-explorer.html</code>。该页面允许您探索内联缓存的情况。</p><figure class="ly lz ma mb gt is gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/a01428ae0b90d6117b708b476e0467e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*G6v1cHnRsDje19FV8aAD7A.png"/></div></figure><p id="0c2d" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">它的一个重要部分是<code class="fe nj nk nl md b">state</code>，它可以是以下状态之一:</p><ul class=""><li id="1eda" class="nr ns jf la b lb lc le lf lu nt lv nu lw nv lt nw nx ny nz bi translated">0未初始化</li><li id="f9ab" class="nr ns jf la b lb oa le ob lu oc lv od lw oe lt nw nx ny nz bi translated">。前单形</li><li id="8815" class="nr ns jf la b lb oa le ob lu oc lv od lw oe lt nw nx ny nz bi translated">1单态</li><li id="44ec" class="nr ns jf la b lb oa le ob lu oc lv od lw oe lt nw nx ny nz bi translated">^重新计算处理程序</li><li id="1ed3" class="nr ns jf la b lb oa le ob lu oc lv od lw oe lt nw nx ny nz bi translated">多态磷</li><li id="3a4d" class="nr ns jf la b lb oa le ob lu oc lv od lw oe lt nw nx ny nz bi translated">巨型的</li><li id="1068" class="nr ns jf la b lb oa le ob lu oc lv od lw oe lt nw nx ny nz bi translated">g通用</li></ul><p id="aec2" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">在我们的例子中<code class="fe nj nk nl md b">state</code>被设置为单态，这意味着该函数被优化为只接收具有一个定义形状的对象。</p><p id="7086" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">现在让我们来定义什么是真正的IC…</p><p id="d0a8" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">不幸的是，我们不得不采取强硬的手段。通过查看一些字节码(如果你感兴趣的话，有一篇关于理解字节码的博客文章，作者是Franziska Hinkelmann。要做到这一点，只需运行</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="bc1e" class="mh mi jf md b gy mj mk l ml mm">d8 --print-bytecode index.js</span></pre><p id="f03d" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">它的输出很长，但我们对最后一部分感兴趣。寻找<code class="fe nj nk nl md b">generated bytecode for function getMeName</code>。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="fceb" class="mh mi jf md b gy mj mk l ml mm">...<br/>[generated bytecode for function: getMeName]<br/>Parameter count 2<br/>Register count 0<br/>Frame size 0<br/>   69 E&gt; 0x2d34c959f9d6 @    0 : a5                StackCheck<br/>   86 S&gt; 0x2d34c959f9d7 @    1 : 28 02 00 00       LdaNamedProperty a0, [0], [0]<br/>   91 S&gt; 0x2d34c959f9db @    5 : a9                Return<br/>Constant pool (size = 1)<br/>0x2d34c959f989: [FixedArray] in OldSpace<br/> - map: 0x0741c8840789 &lt;Map&gt;<br/> - length: 1<br/>           0: 0x0741c8843eb9 &lt;String[#4]: name&gt;<br/>Handler Table (size = 0)</span></pre><p id="b5a3" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">在<code class="fe nj nk nl md b">LdaNamedProperty</code>上看。这个方法负责从<code class="fe nj nk nl md b">a0</code>(参数0)中提取命名属性。属性名(在我们的例子中是<code class="fe nj nk nl md b">name</code>)由来自<code class="fe nj nk nl md b">Constant pool</code>的<code class="fe nj nk nl md b">[0]</code>常量决定。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="f717" class="mh mi jf md b gy mj mk l ml mm">- map: 0x0741c8840789 &lt;Map&gt;<br/> - length: 1<br/>           0: 0x0741c8843eb9 &lt;String[#4]: name&gt;</span></pre><p id="c3e2" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">从参数中获取属性值后，函数将它存储在累加器中(函数最后返回累加器)。</p><p id="dad7" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">这个过程产生了我们称之为<code class="fe nj nk nl md b">Inline Cache</code> ( <code class="fe nj nk nl md b">IC</code>)的东西。每次使用不同的对象形状运行函数时，它都会创建一个新的IC条目。</p><figure class="ly lz ma mb gt is gh gi paragraph-image"><div class="gh gi of"><img src="../Images/cb9e030129f2ded752931e21c1ad7b5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*3HM28YfUpzieGuY-FdHlkg.png"/></div></figure><p id="1bf0" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">我们称这个物体为<code class="fe nj nk nl md b">getMeName</code>，它给出了M0的形状。首先，函数的运行如前所述，因此V8必须在<code class="fe nj nk nl md b">a0</code>上查找命名属性，并将其存储到<code class="fe nj nk nl md b">acc</code>中。运行字节码后，它创建包含两个内容的IC:</p><ul class=""><li id="1d2a" class="nr ns jf la b lb lc le lf lu nt lv nu lw nv lt nw nx ny nz bi translated">形状</li><li id="6c5f" class="nr ns jf la b lb oa le ob lu oc lv od lw oe lt nw nx ny nz bi translated">去酒店的路</li></ul><p id="8aa7" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">现在，如果我们对一个具有相同形状的对象再次调用相同的函数:</p><figure class="ly lz ma mb gt is gh gi paragraph-image"><div class="gh gi of"><img src="../Images/2a3d00c08af0ee8553e7cd6a42ddf299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*tcVstEB_Xp-Frhij58VF1A.png"/></div></figure><p id="1e0b" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">V8将当前形状与存储在IC中的形状进行比较，并跳过调用<code class="fe nj nk nl md b">LdaNamedProperty</code>的整个过程，因为这种形状有一个“快捷方式”，存储在IC中。这样我们就可以很好地优化函数调用。但是如果我们用不同的对象(不同的形状)调用这个函数呢？</p><figure class="ly lz ma mb gt is gh gi paragraph-image"><div class="gh gi og"><img src="../Images/21c84667d51122411a78990d8b7cd1ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*d8wjWG0ClMYwwIzr1Z9Ctw.png"/></div></figure><p id="7c1c" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">V8为shape M1创造了另一个IC。之后，我们有了两种形状的“捷径”。但是V8一个功能能造多少个IC呢？很多…唯一的问题是，每次都有一个去优化。</p><h1 id="35b2" class="mn mi jf bd mo mp mq mr ms mt mu mv mw kl mx km my ko mz kp na kr nb ks nc nd bi translated">功能状态</h1><p id="ede4" class="pw-post-body-paragraph kx ky jf la b lb ne kg ld le nf kj lg lu ng lj lk lv nh ln lo lw ni lr ls lt ij bi translated">您的函数可能处于不同的状态，但我们最感兴趣的是其中的3种:</p><ul class=""><li id="04df" class="nr ns jf la b lb lc le lf lu nt lv nu lw nv lt nw nx ny nz bi translated">单态-1ic</li><li id="5b2d" class="nr ns jf la b lb oa le ob lu oc lv od lw oe lt nw nx ny nz bi translated">多态—2–4个集成电路</li><li id="3274" class="nr ns jf la b lb oa le ob lu oc lv od lw oe lt nw nx ny nz bi translated">巨型→5 IC</li></ul><p id="b4e5" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">当V8决定是否应该优化函数时，它检查当前函数状态。其中只有两个可以优化:单态和多态。达到5 ICs V8基本上就是<strong class="la jg"> <em class="kz">“完全不知道自己要去哪，就到此为止吧”</em> </strong>。此时<strong class="la jg">涡扇</strong>不会在IC中存储任何东西，相反，它会回到全局缓存中。通常，如果你的函数是巨型的，这并不重要，但是如果这个函数经常运行，你可以考虑通过减少它接受的不同形状的数量来优化它。</p><h1 id="5838" class="mn mi jf bd mo mp mq mr ms mt mu mv mw kl mx km my ko mz kp na kr nb ks nc nd bi translated">回到我们的功能</h1><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="06a0" class="mh mi jf md b gy mj mk l ml mm">const N = 10000;<br/><br/>let a = { a: 'Jack', b: 'Sparrow' };<br/>let b = { tmp: 3, a: 'Charles', b: 'Xavier' };<br/>let c = { tmp: 3, tmp2: 3, a: 'Frodo', b: 'Baggins' };<br/>let d = { tmp: 3, tmp2: 3, tmp3: 3, a: 'Legolas', b: 'Thranduilion' };<br/>let e = { tmp: 3, tmp2: 3, tmp3: 3, tmp4: 3, a: 'Indiana', b: 'Jones' };<br/>let f = { tmp: 3, tmp2: 3, tmp3: 3, tmp4: 3, tmp5: 3, a: 'Gandalf', b: 'The Grey' };<br/>let f2 = { tmp: 3, tmp2: 3, tmp3: 3, tmp4: 3, tmp5: 3, a: 'Jack', b: 'Sparrow' };<br/>let f3 = { tmp: 3, tmp2: 3, tmp3: 3, tmp4: 3, tmp5: 3, a: 'Charles', b: 'Xavier' };<br/>let f4 = { tmp: 3, tmp2: 3, tmp3: 3, tmp4: 3, tmp5: 3, a: 'Frodo', b: 'Baggins' };<br/>let f5 = { tmp: 3, tmp2: 3, tmp3: 3, tmp4: 3, tmp5: 3, a: 'Legolas', b: 'Thranduilion' };<br/>let f6 = { tmp: 3, tmp2: 3, tmp3: 3, tmp4: 3, tmp5: 3, a: 'Indiana', b: 'Jones' };<br/><br/>function test(obj) {<br/>  let result = '';<br/>  for (let i = 0; i &lt; N; i += 1) {<br/>    result += obj.a + obj.b;<br/>  }<br/>  return result;<br/>}<br/>function test2(obj) {<br/>  let result = '';<br/>  for (let i = 0; i &lt; N; i += 1) {<br/>    result += obj.a + obj.b;<br/>  }<br/>  return result;<br/>}<br/><br/>const startT1 = Date.now();<br/>for(let i = 0; i &lt; N; i += 1) {<br/>	test(f);<br/>	test(f2);<br/>	test(f3);<br/>	test(f4);<br/>	test(f5);<br/>	test(f6);<br/>}<br/>console.log("test with one shape:", Date.now() - startT1, "ms.");<br/><br/>const startT2 = Date.now();<br/>for(let i = 0; i &lt; N; i += 1) {<br/>	test2(a);<br/>	test2(b);<br/>	test2(c);<br/>	test2(d);<br/>	test2(e);<br/>	test2(f);<br/>}<br/>console.log("test with multiple shape:", Date.now() - startT2, "ms.");</span></pre><p id="c46f" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">执行此代码后，它会打印:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="c4e5" class="mh mi jf md b gy mj mk l ml mm">test with one shape: 3015 ms. <br/>test with multiple shape: 12329 ms.</span></pre><p id="bc85" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">刚刚发生了什么？首先，我们已经为每个测试设置了6*10⁸操作数(6 x 10000 x 10000)。第一个函数<code class="fe nj nk nl md b">test</code>以相同的形状再次被调用(不同的对象，相同的形状)。第二个函数<code class="fe nj nk nl md b">test2</code>用6种不同的形状调用，因此V8没有优化它。</p><p id="38bf" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">如果你打开<code class="fe nj nk nl md b">v8/tools/ic-explorer.html</code>，用<code class="fe nj nk nl md b">d8 --trace-ic index.js</code>运行上面的代码。你可以将<code class="fe nj nk nl md b">v8.log</code>载入<code class="fe nj nk nl md b">ic-explorer</code>。不想做的，这里截图。</p><p id="fd94" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated"><code class="fe nj nk nl md b">test(obj)</code>:</p><figure class="ly lz ma mb gt is gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/2dd36e17307f82c9c0e05017049f27a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*Mk64YiDOwXK7etBK5VyyrA.png"/></div></figure><p id="a865" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated"><code class="fe nj nk nl md b">test2(obj)</code>:</p><figure class="ly lz ma mb gt is gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/b9e4a13b32c8a91afb7a8bef1f8823af.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*3cyqqQhuPsnqRdWgzHQDQQ.png"/></div></figure><p id="54de" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">测试结果很明显，<code class="fe nj nk nl md b">test()</code>比<code class="fe nj nk nl md b">test2()</code>快7.8倍。</p><p id="508a" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">你可能会问，如果看起来一样，为什么要创建<code class="fe nj nk nl md b">test2()</code>？这是因为在用一个形状运行<code class="fe nj nk nl md b">test()</code>之后，它已经为它进行了优化。我不想影响第二次运行的性能，但仍然希望将其保存在一个文件中。</p><h1 id="67d6" class="mn mi jf bd mo mp mq mr ms mt mu mv mw kl mx km my ko mz kp na kr nb ks nc nd bi translated">额外的</h1><p id="c103" class="pw-post-body-paragraph kx ky jf la b lb ne kg ld le nf kj lg lu ng lj lk lv nh ln lo lw ni lr ls lt ij bi translated">我已经提到过，shape不仅仅包含关于添加属性的信息。以下是为<code class="fe nj nk nl md b">let b</code>创建的形状的示例:</p><figure class="ly lz ma mb gt is gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/5ba4ef1346f24e6877c5a84d584217ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*wcbXRNJ3QOr8pTOcQ8wdhg.png"/></div></figure><p id="5d06" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">如果您愿意，可以通过运行以下命令为您的代码生成该文件</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="f69f" class="mh mi jf md b gy mj mk l ml mm">d8 --trace-maps index.js</span></pre><p id="5e76" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated">并将<code class="fe nj nk nl md b">v8.log</code>上传到<code class="fe nj nk nl md b">v8/tools/map-processor.html</code>中。当它生成图表时，点击<code class="fe nj nk nl md b">Transitions</code>并在页面底部浏览它们的列表。</p></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><p id="da3e" class="pw-post-body-paragraph kx ky jf la b lb lc kg ld le lf kj lg lu li lj lk lv lm ln lo lw lq lr ls lt ij bi translated"><em class="kz">最初发布于</em><a class="ae lx" href="https://erdem.pl/2019/08/v-8-function-optimization" rel="noopener ugc nofollow" target="_blank"><em class="kz">https://erdem . pl</em></a><em class="kz">。</em></p></div></div>    
</body>
</html>