<html>
<head>
<title>Go, Timer!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">去吧，计时器！</h1>
<blockquote>原文：<a href="https://itnext.io/go-timer-101252c45166?source=collection_archive---------1-----------------------#2022-03-30">https://itnext.io/go-timer-101252c45166?source=collection_archive---------1-----------------------#2022-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a617" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Go计时器的详细信息以及来自Kubernetes的使用示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1f0eaae7ac6492708b08399090a4b09e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1-qpyDnHjngROm9e"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来自unsplash，<a class="ae ky" href="https://unsplash.com/photos/p3Pj7jOYvnM" rel="noopener ugc nofollow" target="_blank"> @Veri_Ivanova </a></figcaption></figure><p id="a8d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b"><strong class="lb iu">Timer</strong></code>是Go众多巧妙设计之一。当实现单次或多次计时时，它只公开有限数量的API，封装相对复杂的底层数据结构和并发操作。</p><p id="6f1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在阅读Kubernetes调度程序的源代码时，我了解了更多关于Go timer的应用程序及其在<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/kubernetes/utils/" rel="noopener ugc nofollow" target="_blank">kubernetes/utils</a></code>中封装的附加功能。在这篇文章中，我想分享我所吸收的内容，并尝试涵盖它的所有实现，并使用Kubernetes源代码进行更多扩展。</p><h1 id="6bce" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">如何使用计时器</h1><p id="78fd" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">Go-timer是指<a class="ae ky" href="https://github.com/golang/go/blob/master/src/time/sleep.go" rel="noopener ugc nofollow" target="_blank">睡眠中的<code class="fe lv lw lx ly b">Timer</code>，go </a>。</p><h2 id="f814" class="mw ma it bd mb mx my dn mf mz na dp mj li nb nc ml lm nd ne mn lq nf ng mp nh bi translated">NewTimer和AfterFunc</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/c46256ac23e87a7923e10ade7bf763a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5dHCT7CRNMgUMOc0"/></div></div></figure><p id="cc64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">评论解释了它的用法。只能用<code class="fe lv lw lx ly b">NewTimer</code>或<code class="fe lv lw lx ly b">AfterFunc</code>创建。当计时器结束时，一个事件将被发送到<code class="fe lv lw lx ly b">C</code>，然后我们可以通过<code class="fe lv lw lx ly b">select</code>消费这个事件。参见下面的范例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="fc45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里打印的是<code class="fe lv lw lx ly b">default</code>，因为<code class="fe lv lw lx ly b">select</code>在定时器触发之前已经执行过了。有两种常见的方法来纠正这一点。</p><ul class=""><li id="7dba" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">直接阻塞程序，等待定时器被触发。</li><li id="8560" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">将<code class="fe lv lw lx ly b">select</code>置于<code class="fe lv lw lx ly b">for</code>循环中，以确保定时器的逻辑可以被触发。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="605d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一点需要注意的是<code class="fe lv lw lx ly b">break</code>只能跳出<code class="fe lv lw lx ly b">select</code>，导致for循环不停的执行。为了打破整个for循环，需要一个标签。但是，很多开发者不喜欢这种可读性低的方法，他们会转向解耦性更强的<code class="fe lv lw lx ly b">AfterFunc</code>，通过<code class="fe lv lw lx ly b">Callback</code>函数执行相关逻辑。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="95f3" class="mw ma it bd mb mx my dn mf mz na dp mj li nb nc ml lm nd ne mn lq nf ng mp nh bi translated">重置计时器</h2><p id="8e23" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><code class="fe lv lw lx ly b">NewTimer</code>和<code class="fe lv lw lx ly b">AfterFunc</code>都是一次性执行，如果要多次使用，可以用<code class="fe lv lw lx ly b">Reset</code>的方法重置定时器。让我们对上面的例子稍加修改，在<code class="fe lv lw lx ly b">sleep</code>调用后添加以下几行来实现它。</p><pre class="kj kk kl km gt nz ly oa ob aw oc bi"><span id="412d" class="mw ma it ly b gy od oe l of og">c.Reset(1 * time.Second)<br/>time.Sleep(2 * time.Second)</span></pre><p id="9167" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，必须对已经执行或过期的计时器进行复位，这一点在<a class="ae ky" href="https://pkg.go.dev/time#Timer.Reset" rel="noopener ugc nofollow" target="_blank">官方文件</a>中有所标注。</p><blockquote class="oh oi oj"><p id="fc5d" class="kz la ok lb b lc ld ju le lf lg jx lh ol lj lk ll om ln lo lp on lr ls lt lu im bi translated">对于用NewTimer创建的计时器，只能在通道耗尽的停止或过期计时器上调用Reset。</p></blockquote><p id="1b03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最好的方法是<code class="fe lv lw lx ly b">Stop</code>方法，除非你确定当你调用<code class="fe lv lw lx ly b">Reset</code>时定时器已经被触发，就像上面的例子一样。</p><p id="860a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">官方推荐</p><pre class="kj kk kl km gt nz ly oa ob aw oc bi"><span id="33ef" class="mw ma it ly b gy od oe l of og">if !t.Stop() {<br/>  &lt;-t.C   // drain the timer if it is not stopped<br/>}<br/>t.Reset(d)</span></pre><p id="28da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是会出现“阻塞”</p><ul class=""><li id="40a2" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">当定时器(用<code class="fe lv lw lx ly b">NewTimer</code>创建)超时时，<code class="fe lv lw lx ly b">Stop</code>也将返回false，那么<code class="fe lv lw lx ly b">&lt;- t.C</code>将被阻塞，因为通道中没有值。</li><li id="6c0b" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">用<code class="fe lv lw lx ly b">AfterFunc</code>创建定时器时，内部没有<code class="fe lv lw lx ly b">chan</code>域，也没有清空通道的操作，代码也会被阻塞。</li></ul><p id="76f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而<code class="fe lv lw lx ly b">select</code>是最好的避免两种情况下的bug。</p><pre class="kj kk kl km gt nz ly oa ob aw oc bi"><span id="fdef" class="mw ma it ly b gy od oe l of og">if !t.Stop() {<br/>   select {<br/>     case &lt;-t.C: <em class="ok">// try to drain the channel<br/>     </em>default:<br/>   }<br/>}<br/>t.Reset(d)</span></pre><h2 id="ae91" class="mw ma it bd mb mx my dn mf mz na dp mj li nb nc ml lm nd ne mn lq nf ng mp nh bi translated">在...之后</h2><p id="655c" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">除了<code class="fe lv lw lx ly b">NewTimer</code>和<code class="fe lv lw lx ly b">AfterFunc</code>之外的另一种触发定时器的方式是<code class="fe lv lw lx ly b">time.After(d Duration)</code>，它直接返回定时器中的通道对象，而不是返回定时器对象，通常直接用在<code class="fe lv lw lx ly b">select</code>中，作为一种故障保护手段，保证<code class="fe lv lw lx ly b">select</code>语句不会一直被阻塞。常见的用法是</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="75b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与额外创建一个定时器相比，这种方法更简单。但是当你在一个<code class="fe lv lw lx ly b">select</code>子句中使用两个<code class="fe lv lw lx ly b">After</code>时，可能会出现问题。等待时间更长的人可能永远没有机会执行。比如下面的代码只会打印<code class="fe lv lw lx ly b">str</code>而不会堆叠<code class="fe lv lw lx ly b">str</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d4e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因是在第一个<code class="fe lv lw lx ly b">After</code>被执行后，两个<code class="fe lv lw lx ly b">Afters</code>都将被重置，因此等待时间更长的计时器将永远不会被触发，除非您在循环之外定义计时器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="04c1" class="mw ma it bd mb mx my dn mf mz na dp mj li nb nc ml lm nd ne mn lq nf ng mp nh bi translated">心脏</h2><p id="630f" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><code class="fe lv lw lx ly b">Ticker</code>是无需手动复位即可重复执行的定时器。如果您将计时器视为Kubernetes中的作业对象，那么Ticker就是<code class="fe lv lw lx ly b">CronJob</code>。</p><p id="7203" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的用法基本上和Timer一样，但是它的定义初始化了一个<code class="fe lv lw lx ly b">period</code>来标记两次执行之间的间隔。并且记得单独初始化，而不是放入<code class="fe lv lw lx ly b">select</code>中，否则会重复初始化，造成内存泄漏。见反面例子。</p><pre class="kj kk kl km gt nz ly oa ob aw oc bi"><span id="148f" class="mw ma it ly b gy od oe l of og">for {<br/>   select {<br/>   case &lt;-time.Tick(1 * time.Second): <em class="ok">// memory leak<br/>      </em>fmt.Println("repeat logic")<br/>   }<br/>}</span></pre><h1 id="68eb" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">什么是计时器</h1><p id="1a7d" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">掌握了上面列出的5种方法，我们现在可以在大多数情况下优雅地使用定时器。那么定时器的实现呢？这并不简单，因为Golang将它封装得非常好。</p><p id="6daf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">NewTimer</code>和<code class="fe lv lw lx ly b">AfterFunc</code>代码向我们展示了实际实现计时器逻辑的是<a class="ae ky" href="https://github.com/golang/go/blob/018b78cc5b4b08447076f143271c249c0dde1297/src/runtime/time.go#L18" rel="noopener ugc nofollow" target="_blank"> runtimeTimer </a>对象及其相关方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/f827244206510eb8885f60057a01e8ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*46pyRmG2I4wRq0-J"/></div></div></figure><p id="c251" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">sleep.timer</code>真正起作用的是什么</p><ul class=""><li id="e9c2" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated"><code class="fe lv lw lx ly b">when</code>，定时器被触发的时间。</li><li id="fc80" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><code class="fe lv lw lx ly b">f</code>，回调执行方法。<code class="fe lv lw lx ly b">NewTimer</code>采用<code class="fe lv lw lx ly b">sendTime</code>方法简单地向通道发送当前事件，而<code class="fe lv lw lx ly b">AfterFunc</code>执行一个goroutine调用<code class="fe lv lw lx ly b">arg</code>中的方法。</li><li id="37f1" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><code class="fe lv lw lx ly b">arg</code>参数，用于<code class="fe lv lw lx ly b">f</code>的参数。一个通道传入<code class="fe lv lw lx ly b">NewTimer</code>，一个<code class="fe lv lw lx ly b">func</code>传入<code class="fe lv lw lx ly b">AfterFunc</code>。</li></ul><p id="9ee9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所见，底层的<code class="fe lv lw lx ly b">runtimeTimer</code>本身不需要通道，所以<code class="fe lv lw lx ly b">AfterFunc</code>的实现不是通过通道。</p><p id="4f83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到<code class="fe lv lw lx ly b">runtimeTimer</code>，它在内部使用<code class="fe lv lw lx ly b">puintptr</code>类型，本质上是一个指向当前<code class="fe lv lw lx ly b">g</code>堆栈的指针。如果有兴趣，了解更多关于<a class="ae ky" href="https://laptrinhx.com/detailed-explanation-of-annual-best-golang-gmp-scheduling-1878446399/" rel="noopener ugc nofollow" target="_blank"> Go GMP调度</a>的信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/bb81b4a4ca1ec5f444a483da60b1c61b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iJK4Mw6A6KbNYeJT"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/5eb2393ad46f8bf4f867f6222dc3791a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U-5pSDoXoGssLKYZ"/></div></div></figure><p id="92a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在复杂的<code class="fe lv lw lx ly b">runtimeTimer</code>中，主要有三个逻辑与<code class="fe lv lw lx ly b">time.Timer</code>有关。</p><ul class=""><li id="8536" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated"><strong class="lb iu">增加定时器</strong>，其主要逻辑在<code class="fe lv lw lx ly b">doaddtimer(pp *p, t *timer)</code>中。</li></ul><p id="6039" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于<code class="fe lv lw lx ly b">btree</code>的结构在底层维护定时器的顺序，因此所有插入、执行和复位定时器的操作都涉及到“树”。一个父节点包含4个子节点，在执行<code class="fe lv lw lx ly b">insert</code>时，需要确定新的定时器是否执行的更早。如果是，则需要替换当前父节点。这就是<code class="fe lv lw lx ly b">siftupTimer</code>方法的工作原理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/3575c446eabf9236f2693ea1bea02af8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xPgTpC244hlShZlH"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/96887874f9e120dc740c0c5a106bd15e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ptQjeJC2Ixz9qQ5j"/></div></div></figure><ul class=""><li id="68e4" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated"><strong class="lb iu">执行定时器</strong>。其主要逻辑发生在<code class="fe lv lw lx ly b">runtimer(pp *p, now int64)</code>。</li></ul><p id="5570" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过获取最近的定时器，<code class="fe lv lw lx ly b">p</code>决定是否执行定时器，它将只在<code class="fe lv lw lx ly b">Waiting</code>状态下执行定时器。</p><p id="2032" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个主要逻辑在于定时器执行。首先，确定是否需要重复。如果是，计算下一次执行时间，并将计时器添加到队列中。否则，删除计时器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/3f58b55058cf7654a15a43fcfc9cbe46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*trEK7Xp9jZUkgLwG"/></div></div></figure><p id="031c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后获取当前<code class="fe lv lw lx ly b">P</code>，解锁并执行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/182a515cb13f47fa5d4bdca3398e6532.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*huK1WTPAi0PGYtTl"/></div></div></figure><ul class=""><li id="ed4a" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated"><strong class="lb iu">修改定时器状态</strong>。<code class="fe lv lw lx ly b">Stop</code>和<code class="fe lv lw lx ly b">Reset</code>将分别调用<code class="fe lv lw lx ly b">stopTimer(t *timer)</code>和<code class="fe lv lw lx ly b">resettimer(t *timer, when int64)</code>方法。前者执行删除逻辑，包括树节点的重新排列。后者确保只有当定时器处于<code class="fe lv lw lx ly b">timerNoStatus, timerRemoved</code>状态时，它才能被重新排队，否则它将返回错误。这也是为什么在使用定时器之前必须执行<code class="fe lv lw lx ly b">Stop</code>方法的原因。</li></ul><h1 id="b512" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">扩展计时器</h1><p id="3eb3" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">让我们来看看<code class="fe lv lw lx ly b">timer</code>在Kubernetes中的一些有趣应用。</p><h2 id="6e27" class="mw ma it bd mb mx my dn mf mz na dp mj li nb nc ml lm nd ne mn lq nf ng mp nh bi translated">时钟。计时器</h2><p id="41aa" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><a class="ae ky" href="https://github.com/kubernetes/utils/blob/master/clock/clock.go" rel="noopener ugc nofollow" target="_blank">时钟。Timer </a>工具类在调度器中使用较多，是Kubernetes中Go Timer和Ticker的一个包，并增加了时间相关的参数，集所有功能于一身。从时钟接口的定义来看，<code class="fe lv lw lx ly b">PassiveClock</code>包含了<code class="fe lv lw lx ly b">Now</code>和<code class="fe lv lw lx ly b">Since</code>两种常用的时间方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/1da72c38f2293aa10c7df4e201233c7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EeHOI2hGoEJMvyY4"/></div></div></figure><p id="b9c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将Clock与<code class="fe lv lw lx ly b">AfterFunc</code>和<code class="fe lv lw lx ly b">NewTricker</code>组合成一个新的接口，可以支持不同的应用场景。另外，提供<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/kubernetes/utils/blob/3a6ce19ff2f91f3dc49243f90f7834a0f1e4aaf3/clock/clock.go#L85" rel="noopener ugc nofollow" target="_blank">RealClock</a></code>来实现所有相关的方法。</p><h2 id="31be" class="mw ma it bd mb mx my dn mf mz na dp mj li nb nc ml lm nd ne mn lq nf ng mp nh bi translated">时间工作者</h2><p id="03d5" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在<a class="ae ky" href="https://github.com/kubernetes/kubernetes/blob/2a821d787b7f21fbb399b0a0bf6d3fa0c79f4293/pkg/controller/nodelifecycle/scheduler/timed_workers.go#L45" rel="noopener ugc nofollow" target="_blank">的TimedWorker </a>中，直接使用<code class="fe lv lw lx ly b">clock.Timer</code>，用<code class="fe lv lw lx ly b">AfterFunc</code>初始化一个包含执行方法的Worker。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/ff8deb7caeaced36f6d5bb8089be7992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/0*IjvV9J_z0ixY-y-f"/></div></figure><p id="33ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TimedWorker通过一个<a class="ae ky" href="https://github.com/kubernetes/kubernetes/blob/2a821d787b7f21fbb399b0a0bf6d3fa0c79f4293/pkg/controller/nodelifecycle/scheduler/timed_workers.go#L76" rel="noopener ugc nofollow" target="_blank"> TimedWorkerQueue </a>保存，最终在TaintManager中的<a class="ae ky" href="https://github.com/kubernetes/kubernetes/blob/56062f7f4fc56e038f9ab99042457183896c47bb/pkg/controller/nodelifecycle/scheduler/taint_manager.go#L180" rel="noopener ugc nofollow" target="_blank">tainviewonqueue</a>中使用。</p><p id="6648" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调度器还使用<code class="fe lv lw lx ly b">native time.Timer</code>在<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/kubernetes/kubernetes/blob/0b8a665d508a861713398d0480e4789802c70607/pkg/scheduler/framework/runtime/framework.go#L258" rel="noopener ugc nofollow" target="_blank">waitingPodsMap</a></code>中构建<a class="ae ky" href="https://github.com/kubernetes/kubernetes/blob/ea0764452222146c47ec826977f49d7001b0ea8c/pkg/scheduler/framework/runtime/waiting_pods_map.go#L75" rel="noopener ugc nofollow" target="_blank">插件映射</a>。这个PluginMap包含实现CSI、CNI和CRI接口的插件，并使调度器能够根据状态<a class="ae ky" href="https://github.com/kubernetes/kubernetes/blob/ea0764452222146c47ec826977f49d7001b0ea8c/pkg/scheduler/framework/runtime/waiting_pods_map.go#L130" rel="noopener ugc nofollow" target="_blank">允许</a>或<a class="ae ky" href="https://github.com/kubernetes/kubernetes/blob/ea0764452222146c47ec826977f49d7001b0ea8c/pkg/scheduler/framework/runtime/waiting_pods_map.go#L152" rel="noopener ugc nofollow" target="_blank">拒绝</a> pod。</p><h2 id="e12c" class="mw ma it bd mb mx my dn mf mz na dp mj li nb nc ml lm nd ne mn lq nf ng mp nh bi translated">补偿</h2><p id="819e" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">你可能用过<a class="ae ky" href="https://github.com/kubernetes/kubernetes/blob/353f0a5eabe4bd8d31bb67275ee4beeb4655be3f/staging/src/k8s.io/apimachinery/pkg/util/wait/wait.go#L196" rel="noopener ugc nofollow" target="_blank">抖动</a>，一个<a class="ae ky" href="https://github.com/kubernetes/kubernetes/blob/353f0a5eabe4bd8d31bb67275ee4beeb4655be3f/staging/src/k8s.io/apimachinery/pkg/util/wait/wait.go#L315" rel="noopener ugc nofollow" target="_blank"> utils/wait </a>包里的小工具。Backoff也是<a class="ae ky" href="https://github.com/kubernetes/kubernetes/blob/353f0a5eabe4bd8d31bb67275ee4beeb4655be3f/staging/src/k8s.io/apimachinery/pkg/util/wait/wait.go#L315" rel="noopener ugc nofollow" target="_blank"> utils/wait </a>包中的一个工具，但并不普遍。但是我们不应该在这里跳过它，因为它使用了<code class="fe lv lw lx ly b">clock</code>。</p><p id="eccc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当实现<code class="fe lv lw lx ly b">Backoff</code>方法时，需要创建或重置定时器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/ae89df9b32a732c5eaf264924596efe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sxO-x8sUOVTz_lQa"/></div></div></figure><p id="9f70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/kubernetes/kubernetes/blob/353f0a5eabe4bd8d31bb67275ee4beeb4655be3f/staging/src/k8s.io/apimachinery/pkg/util/wait/wait.go#L442" rel="noopener ugc nofollow" target="_blank">Poll</a></code>的方法也很实用。它可以在一定时间内周期性地执行某个<code class="fe lv lw lx ly b">conditionFunc</code>(<code class="fe lv lw lx ly b">interval</code>)，直到条件为真或超时。这里，定时执行和超时是由本机定时器实现的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/48004705beffd6091e24694de799f18e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*26mtUA9CG1GTyfYy"/></div></div></figure><p id="743b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个方法几乎包含了我们开头提到的标准<code class="fe lv lw lx ly b">timer</code>和<code class="fe lv lw lx ly b">ticker</code>用法。</p><ul class=""><li id="d2d4" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">定义一个Ticker，它可以周期性地触发事件到<code class="fe lv lw lx ly b">tick.C</code>，然后将事件发送到另一个通道。</li><li id="770c" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">定义一个定时器，包括超时，在for循环中使用<code class="fe lv lw lx ly b">select</code>接收其通道。如果被触发，则返回。</li><li id="2188" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">从<code class="fe lv lw lx ly b">contionFunc</code>监控上下文。一旦接收到一个<code class="fe lv lw lx ly b">Done</code>事件，直接结束。</li></ul><p id="897f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">timer</code>和<code class="fe lv lw lx ly b">ticker</code>都增加了<code class="fe lv lw lx ly b">defer Stop</code>调用，以避免因未被触发而导致内存泄漏。</p><h2 id="022e" class="mw ma it bd mb mx my dn mf mz na dp mj li nb nc ml lm nd ne mn lq nf ng mp nh bi translated">长队</h2><p id="5c25" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">现在，来看一个用<code class="fe lv lw lx ly b">clock</code>实现<code class="fe lv lw lx ly b">workqueue</code>的客户端go的例子。细节在这个<a class="ae ky" href="https://github.com/kubernetes/kubernetes/blob/a88462e901710ab5df1fa6e99a046aa921dcdd55/staging/src/k8s.io/client-go/util/workqueue/delaying_queue.go#L30" rel="noopener ugc nofollow" target="_blank"> delayingQueue </a>中，执行一个<a class="ae ky" href="https://github.com/kubernetes/kubernetes/blob/a88462e901710ab5df1fa6e99a046aa921dcdd55/staging/src/k8s.io/client-go/util/workqueue/delaying_queue.go#L70" rel="noopener ugc nofollow" target="_blank"> waitingLooop </a>方法来决定队列中的作业是否需要被弹出执行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/d1238f09add9a41fd73c35d6a4e5bf33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/0*p0UGoyMXGmoT3eaG"/></div></figure><p id="c242" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过不断减少等待时间来定义一个新的<code class="fe lv lw lx ly b">clock.Timer</code>。thank然后监听计时器的通道，并最终将数据添加到队列中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/617a710c7f7cbcc2efe6c3b95bc9623f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/0*56eT5lO1meCNLD84"/></div></div></figure><p id="d8f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Timer</code>在Kubernetes中被广泛使用，但不是那么统一，因为使用原生<code class="fe lv lw lx ly b">timer</code>或<code class="fe lv lw lx ly b">ticker</code>的旧代码没有被完全重构为<code class="fe lv lw lx ly b">clock</code>，尽管<code class="fe lv lw lx ly b">clock</code>已经可以覆盖所有的定时器应用场景。</p><h1 id="3f51" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结束了</h1><p id="930e" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><code class="fe lv lw lx ly b">Timer</code>只是Go的一个小功能，但如何合理使用避免各种bug，却绝非易事。在更多情况下，在涉及超时、定时执行或等待的情况下，用<code class="fe lv lw lx ly b">timer</code>和动作组合编写逻辑是<code class="fe lv lw lx ly b">timer</code>的最佳实践。</p><p id="65bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，还有更多值得探索的地方。但在此之前，使用它，掌握它。</p><p id="fba1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>