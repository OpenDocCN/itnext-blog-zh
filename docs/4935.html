<html>
<head>
<title>How to store passwords and API keys in project code.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在项目代码中存储密码和API密钥？</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-store-passwords-and-api-keys-in-project-code-1eaf5cb235c9?source=collection_archive---------0-----------------------#2020-10-28">https://itnext.io/how-to-store-passwords-and-api-keys-in-project-code-1eaf5cb235c9?source=collection_archive---------0-----------------------#2020-10-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f06a5a685c4755d337d8ccd110c12321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4lQkLTc5U6_x_BAuAYIxqw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">劳伦·曼克在Unsplash<a class="ae kc" href="https://unsplash.com/collections/8278420/web-mockups-?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">上的照片</a></figcaption></figure><p id="3ba6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，您的自动化脚本会有秘密凭证或API密钥，您需要在您的应用程序中使用这些凭证或密钥，并且您更愿意从您的密钥库中轻松提取它们。</p><p id="fe99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您正在使用动态生成的秘密，存储该信息的最有效方法是使用Keystore API。您不应该在没有首先加密这些数据的情况下将它们储存在共享偏好设置中，因为在执行数据备份时会提取它们。</p><p id="9407" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了存储固定的API密钥，在源代码中存储机密有以下常见策略:</p><ul class=""><li id="bef9" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">隐藏在项目代码中。</li><li id="a404" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">隐藏在BuildConfigs中。</li><li id="3faa" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">格拉德。</li><li id="4afd" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">隐藏在路径环境中。</li><li id="c650" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">火焰基地。</li></ul><p id="77fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">存储机密的最简单方法是将它们保存为资源文件，不要签入源代码控制。</p><p id="5ce4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lp translated">项目代码中的idden。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="9a19" class="mh mi iq md b gy mj mk l ml mm"><em class="mn">/**<br/> * The class Service.<br/> */<br/></em><strong class="md ir">public class </strong>Service {<br/><br/>    <em class="mn">/**<br/>     * The constant APP_KEY.<br/>     */<br/>    </em><strong class="md ir">public final static </strong>String <strong class="md ir"><em class="mn">APP_KEY </em></strong>= <strong class="md ir">"jk433g34hg3"</strong>;<br/>    <br/>    <em class="mn">/**<br/>     * The constant APP_SECRET.<br/>     */<br/>    </em><strong class="md ir">public final static </strong>String <strong class="md ir"><em class="mn">APP_SECRET </em></strong>= <strong class="md ir">"987dwdqwdqw90"</strong>;<br/>    <em class="mn">/**<br/>     * The constant ACCESS_TYPE.<br/>     */<br/>    </em><strong class="md ir">public final static </strong>AccessType <strong class="md ir"><em class="mn">ACCESS_TYPE </em></strong>= AccessType.HARD;<br/>    <br/><br/><em class="mn">// SOME MORE CODE HERE<br/></em>}</span></pre><p id="f450" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">密码和API密钥存储在项目代码中并直接使用。</p><p id="a217" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种策略的缺点是:</p><ul class=""><li id="e6b1" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">当使用存储库时，数据将对第三方可用。</li><li id="2d44" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">数据分散在整个项目中。不存在所有密钥和密码都存储在一个地方的情况。</li><li id="d592" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">密码和API密钥写在项目代码中，我们不能通过任何管理工具从外部使用它们。</li></ul><p id="ace9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lp translated">BuildConfigs中的idden。</p><p id="1418" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，在根目录下创建一个文件<code class="fe mo mp mq md b">apikey.properties</code>，其中包含不同密钥的值:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="62d0" class="mh mi iq md b gy mj mk l ml mm">APP_KEY <!-- -->= <!-- -->jk433g34hg3<br/>APP_SECRET <!-- -->= <!-- -->987dwdqwdqw90<br/>ACCESS_TYPE <!-- -->= <!-- -->AccessType.HARD</span></pre><p id="7056" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了避免这些密钥出现在您的存储库中，请确保通过将添加到您的。gitignore文件。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="b1fb" class="mh mi iq md b gy mj mk l ml mm"><em class="mn">/**<br/> * The class Properties reader.<br/> */<br/></em><strong class="md ir">public final class </strong>PropertiesReader {<br/><br/>    <em class="mn">/**<br/>     * Constant LOGGER.<br/>     */<br/>    </em><strong class="md ir">private static final </strong>Logger <strong class="md ir"><em class="mn">LOGGER </em></strong>= LoggerFactory.<em class="mn">getLogger</em>(PropertiesReader.<strong class="md ir">class</strong>);<br/><br/>    <em class="mn">/**<br/>     * Constant PROPERTIES.<br/>     */<br/>    </em><strong class="md ir">private static final </strong>Properties <strong class="md ir"><em class="mn">PROPERTIES</em></strong>;<br/><br/>    <em class="mn">/**<br/>     * Constant PROP_FILE.<br/>     */<br/>    </em><strong class="md ir">private static final </strong>String <strong class="md ir"><em class="mn">PROP_FILE </em></strong>= <strong class="md ir">"</strong>apikey<strong class="md ir">.properties"</strong>;<br/><br/>    <em class="mn">/**<br/>     * Default private constructor PropertiesReader.<br/>     */<br/>    </em><strong class="md ir">private </strong>PropertiesReader() {<br/>    }<br/><br/>    <strong class="md ir">static </strong>{<br/>        <strong class="md ir"><em class="mn">PROPERTIES </em></strong>= <strong class="md ir">new </strong>Properties();<br/>        <strong class="md ir">final </strong>URL props = ClassLoader.<em class="mn">getSystemResource</em>(<strong class="md ir"><em class="mn">PROP_FILE</em></strong>);<br/>        <strong class="md ir">try </strong>{<br/>            <strong class="md ir"><em class="mn">PROPERTIES</em></strong>.load(props.openStream());<br/>        } <strong class="md ir">catch </strong>(IOException ex) {<br/><br/>            <strong class="md ir">if </strong>(<strong class="md ir"><em class="mn">LOGGER</em></strong>.isDebugEnabled()) {<br/>                <strong class="md ir"><em class="mn">LOGGER</em></strong>.debug(ex.getClass().getName() + <strong class="md ir">"PropertiesReader method"</strong>);<br/>            }<br/>        }<br/>    }<br/><br/>   <em class="mn">/**<br/> * Method getProperty.<br/> *<br/> * </em><strong class="md ir"><em class="mn">@param name </em></strong><em class="mn">String name file.<br/> * </em><strong class="md ir"><em class="mn">@return </em></strong><em class="mn">Return property<br/> */<br/></em><strong class="md ir">public static </strong>String getProperty(<strong class="md ir">final </strong>String name) {<br/><br/>    <strong class="md ir">return <em class="mn">PROPERTIES</em></strong>.getProperty(name);<br/>}</span></pre><p id="3ccc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并在项目中使用:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="091d" class="mh mi iq md b gy mj mk l ml mm">PropertiesReader.getProperty("APP_KEY");</span><span id="1053" class="mh mi iq md b gy mr mk l ml mm">PropertiesReader.getProperty("APP_SECRET");</span><span id="7fb9" class="mh mi iq md b gy mr mk l ml mm">PropertiesReader.getProperty("ACCESS_TYPE");</span></pre><p id="dfa9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种策略的优点是:</p><ul class=""><li id="8734" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">所有的密钥和密码都在一个地方，我们可以看到我们使用的外部系统。</li></ul><p id="a70f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种策略的缺点是:</p><ul class=""><li id="2312" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">密码和API密钥写在项目代码中，我们不能通过任何管理工具从外部使用它们。</li></ul><p id="f3a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lp translated">radle是一个用于多语言软件开发的构建自动化工具。</p><p id="41a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用Gradle来保护密码或API密钥。</p><p id="2c2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您需要用gradle.properties文件中的键创建一个变量:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="d546" class="mh mi iq md b gy mj mk l ml mm">APP_KEY <!-- -->= <!-- -->jk433g34hg3<br/>APP_SECRET <!-- -->=<!-- -->987dwdqwdqw90<br/>ACCESS_TYPE <!-- -->= <!-- -->AccessType.HARD</span></pre><p id="8593" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">设置要构建的变量。格拉德:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="dc69" class="mh mi iq md b gy mj mk l ml mm">buildTypes.each {</span><span id="80cf" class="mh mi iq md b gy mr mk l ml mm">it.buildConfigField 'String', 'APP_KEY', AppKey</span><span id="96b6" class="mh mi iq md b gy mr mk l ml mm">it.buildConfigField 'String', 'APP_SECRET', AppSecret</span><span id="8934" class="mh mi iq md b gy mr mk l ml mm">it.buildConfigField 'String', 'ACCESS_TYPE', AccessType<br/>}</span></pre><p id="2303" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用BuildConfig访问它:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="3e53" class="mh mi iq md b gy mj mk l ml mm">BuildConfig.AppKey</span><span id="a27c" class="mh mi iq md b gy mr mk l ml mm">BuildConfig.AppSecret</span><span id="8006" class="mh mi iq md b gy mr mk l ml mm">BuildConfig.AccessType</span></pre><p id="9e35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种策略的优点是:</p><ul class=""><li id="1d1e" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">所有密钥和密码都在一个地方。</li></ul><p id="106a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种策略的缺点是:</p><ul class=""><li id="0d16" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">密码和API密钥写在项目代码中，我们不能通过任何管理工具从外部使用它们。</li></ul><p id="4c78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lp translated"><span class="l lq lr ls bm lt lu lv lw lx di"> H </span>路径环境中的idden。</p><p id="5282" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">PATH环境变量类似Unix的操作系统、DOS、OS/2和Microsoft Windows，它是可执行文件所在的一组目录。基本上，每个正在运行的进程或用户会话都有自己的path变量。</p><p id="db09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要在Windows操作系统中找出该变量的内容，您需要调用以下命令:</p><p id="2575" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">回声%路径% </strong></p><p id="1968" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于Linux操作系统:</p><p id="63a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">回声$路径</strong></p><p id="190b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将显示在PATH变量中注册的所有目录的列表，并且可执行文件可以放在任何目录中。</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/b8da56504d40c7b48facadd08d9b007c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vQEtICOrNvAYj4z65YG0_w.png"/></div></figure><p id="1801" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以通过以下方式使用环境变量:</p><p id="9847" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建了一个简单的shell脚本。这个文件不会存储在git中。它将被添加到。gitignore文件。每个QA工程师在他们的本地设备上都有这个shell文件，所有的密钥都存储在这个文件中。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="df84" class="mh mi iq md b gy mj mk l ml mm">create setenv.sh</span></pre><p id="0f16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在setenv.sh shell脚本文件中创建3个变量:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="4d71" class="mh mi iq md b gy mj mk l ml mm">export APP_KEY=jk433g34hg3</span><span id="b8a8" class="mh mi iq md b gy mr mk l ml mm">export APP_SECRET=987dwdqwdqw90</span><span id="4616" class="mh mi iq md b gy mr mk l ml mm">export ACCESS_TYPE=AccessType.HARD</span></pre><p id="5946" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并使用以下命令将从加载到环境变量:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="a3bf" class="mh mi iq md b gy mj mk l ml mm">source ./setenv.sh</span></pre><p id="eeb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并调用项目代码:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="6443" class="mh mi iq md b gy mj mk l ml mm">String apiKey = System.getenv("API_KEY");</span><span id="0a3c" class="mh mi iq md b gy mr mk l ml mm">String appSecret = System.getenv("<!-- -->APP_SECRET<!-- -->");</span><span id="1b62" class="mh mi iq md b gy mr mk l ml mm">String accessType = System.getenv("<!-- -->ACCESS_TYPE<!-- -->");</span></pre><p id="56f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种策略的优点是:</p><ul class=""><li id="81b9" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">我们不将密钥存储在git存储库中，它们存储在外部。</li><li id="8f73" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">环境变量可以通过管理工具来设置。</li><li id="4c7d" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">此外，您可以将环境变量存储在管理工具的配置文件、<strong class="kf ir"> systemd </strong>或Docker配置文件中。</li></ul><p id="0692" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种策略的缺点是:</p><ul class=""><li id="922a" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">我们需要一个shell脚本。</li></ul><p id="a2c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lp translated">irebase是谷歌的移动平台，可以帮助你快速开发高质量的应用并发展你的业务。</p><p id="6020" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用firebase数据库或firebase RemoteConfig(默认值为Null):</p><ol class=""><li id="3c13" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la mt lh li lj bi translated">加密您的密钥。</li><li id="4bfc" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la mt lh li lj bi translated">将其保存在Firebase数据库中。</li><li id="da3f" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la mt lh li lj bi translated">在应用程序启动期间或必要时获取。</li><li id="b249" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la mt lh li lj bi translated">解密密钥并使用它们。</li></ol><p id="930f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种策略的优点是:</p><ul class=""><li id="6763" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">对Firebase的访问是受保护的，因此只有拥有签名证书的应用程序才能进行API调用。</li><li id="0e7f" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">加密/解密</li><li id="2b2a" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">速度</li></ul><p id="6f2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lp translated"><span class="l lq lr ls bm lt lu lv lw lx di"> F </span>对我个人来说，环境变量是存储机密信息和重要项目设置的最正确、最优秀的方式。</p><p id="a4ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lp translated"><span class="l lq lr ls bm lt lu lv lw lx di">到</span>现在，您应该意识到在公共和私有Git存储库中存储敏感信息(如API密钥和密码)的危险。</p><p id="013e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">理解您的存储库可能暴露的潜在方式是评估和减轻与信息泄漏相关的风险的关键。</p><p id="2148" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文还提出了一些不同的解决方案，让您可以加密API密钥和密码，这样您就可以安全地使用您的代码库。</p><p id="463f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我相信有更多的解决方案可以帮助你达到同样的效果。</p></div></div>    
</body>
</html>