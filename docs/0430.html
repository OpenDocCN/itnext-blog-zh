<html>
<head>
<title>Acceptance Test Driven Development with React/Redux — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React/Redux的验收测试驱动开发—第2部分</h1>
<blockquote>原文：<a href="https://itnext.io/acceptance-test-driven-test-with-react-redux-part-2-127949a6e47e?source=collection_archive---------3-----------------------#2018-03-09">https://itnext.io/acceptance-test-driven-test-with-react-redux-part-2-127949a6e47e?source=collection_archive---------3-----------------------#2018-03-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4fa7eaec65cd6cb18252b868d579d6a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-myE2XGfqOFuLiJX."/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@andrewtneel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安德鲁·尼尔</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上发表的“一个带着笔记本电脑、记事本、智能手机和一杯咖啡的平板电脑”</figcaption></figure><p id="6953" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="lb">更新1 </em> </strong> : <em class="lb">本文是一个系列的一部分，查看完整系列:</em> <a class="ae kc" href="https://medium.com/@juntao.qiu/acceptance-test-driven-test-with-react-redux-part-1-7ae8cb4fab00" rel="noopener">第一部分</a>、<em class="lb"> </em> <a class="ae kc" href="https://medium.com/@juntao.qiu/acceptance-test-driven-test-with-react-redux-part-2-127949a6e47e" rel="noopener">第二部分</a>、<a class="ae kc" href="https://medium.com/@juntao.qiu/acceptance-test-driven-test-with-react-redux-part-3-903e1e58e706" rel="noopener">第三部分</a>、<a class="ae kc" href="https://medium.com/@juntao.qiu/acceptance-test-driven-development-with-react-redux-part-4-5db545953ed3" rel="noopener">第四部分</a>和<a class="ae kc" href="https://medium.com/@juntao.qiu/acceptance-test-driven-development-with-react-redux-part-5-995577d28eff" rel="noopener">第五部分</a>。</p><p id="d68d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="lb">更新2 </em> </strong>:我出版了一本名为<a class="ae kc" href="https://leanpub.com/build-react-app-with-atdd" rel="noopener ugc nofollow" target="_blank"> <em class="lb">用验收测试驱动开发构建React应用</em> </a>的书，涵盖了更多关于ATDD和React的话题和实践，<a class="ae kc" href="https://leanpub.com/build-react-app-with-atdd" rel="noopener ugc nofollow" target="_blank">请查看</a>！</p><h1 id="37d1" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">包装管理</h1><p id="0808" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">让我们先从一些简单的包安装和配置开始。确保您已经在本地安装了<code class="fe mf mg mh mi b">node.js</code>，之后，您可以使用<code class="fe mf mg mh mi b">npm</code>来安装构建我们的<code class="fe mf mg mh mi b">Bookish</code>应用程序所需的工具:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="5d97" class="mr ld iq mi b gy ms mt l mu mv">npm install yarn create-react-app --global</span></pre><h1 id="f335" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">创建-反应-应用</h1><p id="1228" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">安装完成后，我们可以使用脸书提供的<code class="fe mf mg mh mi b">create-react-app</code>来创建我们的项目:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="b471" class="mr ld iq mi b gy ms mt l mu mv">create-react-app bookish-react</span></pre><p id="a10c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mf mg mh mi b">create-react-app</code>会默认帮我们安装<code class="fe mf mg mh mi b">react</code>、<code class="fe mf mg mh mi b">react-dom</code>和一个名为<code class="fe mf mg mh mi b">react-scripts</code>的命令行工具。并且它会自动下载那些库和它们的依赖项，比如<code class="fe mf mg mh mi b">webpack</code>、<code class="fe mf mg mh mi b">babel</code>等等。通过使用<code class="fe mf mg mh mi b">create-react-app</code>,我们基本上可以进行零配置来启动和运行应用程序。</p><p id="56f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建完成后，按照控制台日志的建议，我们需要跳转到<code class="fe mf mg mh mi b">bookish-react</code>文件夹，并运行<code class="fe mf mg mh mi b">yarn start</code>:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="6340" class="mr ld iq mi b gy ms mt l mu mv">cd bookish-react<br/>yarn start</span></pre><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/bbb4715f76c9f66870d2f510ee1a140d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kLp1A3yUGzw5MCrFGzFCaw.png"/></div></div></figure><p id="ffc4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且将会有一个新的浏览器标签自动打开，地址为<code class="fe mf mg mh mi b">http://localhost:3000</code>，用户界面应该是这样的:</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/2288d7fc8467a15b082f1ab66510706b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZCm3H65486N1l8ajDMiOgA.png"/></div></div></figure><h1 id="41c8" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">项目结构</h1><p id="1a20" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">我们不需要所有由<code class="fe mf mg mh mi b">create-react-app</code>生成的文件，让我们先做一些清理工作。我们可以这样删除<code class="fe mf mg mh mi b">src</code>文件夹中所有不相关的文件:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="3999" class="mr ld iq mi b gy ms mt l mu mv">src<br/>├── App.css<br/>├── App.js<br/>├── index.css<br/>└── index.js</span></pre><p id="a76d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并按如下方式修改文件内容:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="f0fc" class="mr ld iq mi b gy ms mt l mu mv">import React, { Component } from 'react';<br/>-import logo from './logo.svg';<br/> import './App.css';<br/> <br/> class App extends Component {<br/>   render() {<br/>     return (<br/>       &lt;div className="App"&gt;<br/>-        &lt;header className="App-header"&gt;<br/>-          &lt;img src={logo} className="App-logo" alt="logo" /&gt;<br/>-          &lt;h1 className="App-title"&gt;Welcome to React&lt;/h1&gt;<br/>-        &lt;/header&gt;<br/>-        &lt;p className="App-intro"&gt;<br/>-          To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.<br/>-        &lt;/p&gt;<br/>+        &lt;h1&gt;Hello world&lt;/h1&gt;<br/>       &lt;/div&gt;<br/>     );<br/>   }</span><span id="23f4" class="mr ld iq mi b gy my mt l mu mv">import React from 'react';<br/> import ReactDOM from 'react-dom';<br/> import './index.css';<br/> import App from './App';<br/>-import registerServiceWorker from './registerServiceWorker';<br/> <br/>-ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));<br/>-registerServiceWorker();<br/>+ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));</span></pre><p id="273c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也清理CSS文件内容:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="f8f6" class="mr ld iq mi b gy ms mt l mu mv">- .App {<br/>-   text-align: center;<br/>- }<br/>-<br/>-.App-logo {<br/>-  animation: App-logo-spin infinite 20s linear;<br/>-  height: 80px;<br/>-}<br/>-<br/>-.App-header {<br/>-  background-color: #222;<br/>-  height: 150px;<br/>-  padding: 20px;<br/>-  color: white;<br/>-}<br/>-<br/>-.App-title {<br/>-  font-size: 1.5em;<br/>-}<br/>-<br/>-.App-intro {<br/>-  font-size: large;<br/>-}<br/>-<br/>-@keyframes App-logo-spin {<br/>-  from { transform: rotate(0deg); }<br/>-  to { transform: rotate(360deg); }<br/>-}</span></pre><p id="7d43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到了这样的用户界面:</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/ea54a661f9a084adf651e3e51abffc6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pa8CWhdhB9CROlWZIHUNOg.png"/></div></div></figure><h1 id="ad16" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">操纵木偶的人</h1><p id="6c5d" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">之后，我们需要首先设置<code class="fe mf mg mh mi b">acceptance tests</code>环境。在本书中，我们将使用<code class="fe mf mg mh mi b">Puppeteer</code>来做UI测试。来自Google的<code class="fe mf mg mh mi b">Puppeteer</code>是建立在Headless Chrome之上的，它提供了很多API来做DOM操作、JavaScript评估，这些可以用来运行<code class="fe mf mg mh mi b">UI</code>测试。</p><p id="a549" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们需要在本地安装它:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="603c" class="mr ld iq mi b gy ms mt l mu mv">yarn add puppeteer --dev</span></pre><p id="8a3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe mf mg mh mi b">--dev</code>选项意味着我们只是将它作为开发阶段的依赖项添加，我们不想将它包含在生产代码中。</p><h1 id="44dc" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">我们的第一个2端测试</h1><p id="88e1" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">TDD最困难的事情可能是从哪里开始，我们如何编写第一个测试？</p><p id="df92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的第一个测试可能是:</p><ul class=""><li id="5ffd" class="mz na iq kf b kg kh kk kl ko nb ks nc kw nd la ne nf ng nh bi translated">确保页面上有一个<code class="fe mf mg mh mi b">Heading</code>元素，内容是<code class="fe mf mg mh mi b">Bookish</code></li></ul><p id="7b52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">乍一看，这个测试看起来毫无用处，但实际上，它可以确保:</p><ul class=""><li id="508e" class="mz na iq kf b kg kh kk kl ko nb ks nc kw nd la ne nf ng nh bi translated">前端代码可以编译和翻译</li><li id="9b80" class="mz na iq kf b kg ni kk nj ko nk ks nl kw nm la ne nf ng nh bi translated">浏览器可以正确地呈现我们的页面(没有任何脚本错误)</li></ul><p id="097b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，首先我们创建一个包含以下内容的文件<code class="fe mf mg mh mi b">e2e.test.js</code>:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="38b6" class="mr ld iq mi b gy ms mt l mu mv">import puppeteer from 'puppeteer'</span><span id="e503" class="mr ld iq mi b gy my mt l mu mv">const appUrlBase = 'http://localhost:3000'</span><span id="ea03" class="mr ld iq mi b gy my mt l mu mv">let browser<br/>let page</span><span id="62c6" class="mr ld iq mi b gy my mt l mu mv">beforeAll(async () =&gt; {<br/>  browser = await puppeteer.launch({})<br/>  page = await browser.newPage()<br/>})</span><span id="1a4a" class="mr ld iq mi b gy my mt l mu mv">describe('Bookish', () =&gt; {<br/>  test('Heading', async () =&gt; {<br/>    await page.goto(`${appUrlBase}/`)<br/>    await page.waitForSelector('h1')<br/>    const result = await page.evaluate(() =&gt; {<br/>      return document.querySelector('h1').innerText<br/>    })</span><span id="9058" class="mr ld iq mi b gy my mt l mu mv">    expect(result).toEqual('Bookish')<br/>  })<br/>})</span><span id="54e4" class="mr ld iq mi b gy my mt l mu mv">afterAll(() =&gt; {<br/>  browser.close()<br/>})</span></pre><p id="2824" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我知道这看起来有点吓人，但实际上很简单。我们一块一块来回顾一下。</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="85ea" class="mr ld iq mi b gy ms mt l mu mv">import puppeteer from 'puppeteer'</span></pre><p id="903c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们导入<code class="fe mf mg mh mi b">puppeteer</code>，然后指定<code class="fe mf mg mh mi b">devServer</code>地址，因此<code class="fe mf mg mh mi b">Puppeteer</code>知道是否访问应用程序</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="dc20" class="mr ld iq mi b gy ms mt l mu mv">const appUrlBase = 'http://localhost:3000'</span></pre><p id="62d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mf mg mh mi b">beforeAll</code>钩子中，我们以<code class="fe mf mg mh mi b">headless</code>模式启动Chrome:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="57b1" class="mr ld iq mi b gy ms mt l mu mv">beforeAll(async () =&gt; {<br/>  browser = await puppeteer.launch({})<br/>  page = await browser.newPage()<br/>})</span></pre><p id="15e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后停在<code class="fe mf mg mh mi b">afterAll</code>钩上。</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="ed33" class="mr ld iq mi b gy ms mt l mu mv">afterAll(() =&gt; {<br/>  browser.close()<br/>})</span></pre><h2 id="a72b" class="mr ld iq bd le nn no dn li np nq dp lm ko nr ns lq ks nt nu lu kw nv nw ly nx bi translated">异步和等待</h2><p id="1862" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">注意这里我们将<code class="fe mf mg mh mi b">beforeAll</code>中的匿名函数标记为<code class="fe mf mg mh mi b">async</code>，并在<code class="fe mf mg mh mi b">puppeteer.launch()</code>前放置一个<code class="fe mf mg mh mi b">await</code>关键字。</p><p id="8583" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mf mg mh mi b">async</code>和<code class="fe mf mg mh mi b">await</code>是ES6语法，可以使JavaScript中的异步编程更加容易。让我们看一个简单的例子:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="77e9" class="mr ld iq mi b gy ms mt l mu mv">function fetchContactById(id) {<br/>  return fetch(`http://localhost:8080/contacts/${id}`).then((response) =&gt; {<br/>    return response.json()<br/>  })<br/>}</span></pre><p id="2d5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在函数<code class="fe mf mg mh mi b">fetchContactById</code>中，我们使用<code class="fe mf mg mh mi b">fetch</code>发送http请求并返回json响应(作为一个<code class="fe mf mg mh mi b">Promise</code>对象)。然后我们可以通过以下方式消费这个<code class="fe mf mg mh mi b">Promise</code>对象:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="fea5" class="mr ld iq mi b gy ms mt l mu mv">function main() {<br/>  fetchContactById(1).then((contact) =&gt; {<br/>    console.log(contact.name)<br/>  })  <br/>}</span></pre><p id="7734" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是通过使用<code class="fe mf mg mh mi b">async/await</code>，我们可以简单地定义一个<code class="fe mf mg mh mi b">variable</code>来等待函数调用的返回——进程被阻塞——一旦底层的<code class="fe mf mg mh mi b">Promise</code>被解析，contact就有了正确的值，控制进程返回并对<code class="fe mf mg mh mi b">console.log</code>进行求值。</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="dbb3" class="mr ld iq mi b gy ms mt l mu mv">async function main() {<br/>  const contact = await fetchContactById(1)<br/>  console.log(contact.name)<br/>}</span></pre><p id="ac24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能会说没有太大的区别，但是如果我们稍微增强一下上面的例子，比如说，通过添加另一个API调用<code class="fe mf mg mh mi b">fetchUserById</code>，我们需要该API的返回值来发送<code class="fe mf mg mh mi b">fetchContactById</code>:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="7685" class="mr ld iq mi b gy ms mt l mu mv">function fetchUserById(id) {<br/>  return fetch(`http://localhost:8080/users/${id}`).then((response) =&gt; {<br/>    return response.json()<br/>  })  <br/>}</span></pre><p id="9038" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后代码变成了这样:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="9370" class="mr ld iq mi b gy ms mt l mu mv">function main() {<br/>  fetchUserById('juntao').then((user) =&gt; {<br/>    fetchContactById(user.id).then((contact) =&gt; {<br/>      console.log(contact.name)<br/>    })<br/>  })<br/>}</span></pre><p id="2d36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果一个接一个地发送请求，缩进可能会不断增加，但是通过使用<code class="fe mf mg mh mi b">await/async</code>对，代码将会非常清楚，如下所示:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="7651" class="mr ld iq mi b gy ms mt l mu mv">async function amain() {<br/>  const user = await fetchUserById('juntao')<br/>  const contact = await fetchContactById(user.id)<br/>  console.log(contact.name)<br/>}</span></pre><p id="8f58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那就紧凑利落多了！</p><p id="2223" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后让我们来看看主程序块:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="00f8" class="mr ld iq mi b gy ms mt l mu mv">describe('Bookish', () =&gt; {<br/>  test('Heading', async () =&gt; {<br/>    await page.goto(`${appUrlBase}/`)<br/>    await page.waitForSelector('h1')<br/>    const result = await page.evaluate(() =&gt; {<br/>      return document.querySelector('h1').innerText<br/>    })</span><span id="4fb1" class="mr ld iq mi b gy my mt l mu mv">    expect(result).toEqual('Bookish')<br/>  })<br/>})</span></pre><p id="ae3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在测试用例中，我们使用<code class="fe mf mg mh mi b">puppeteer</code>访问端口<code class="fe mf mg mh mi b">3000</code>，等待<code class="fe mf mg mh mi b">h1</code>出现，然后调用<code class="fe mf mg mh mi b">evaluate</code>调用原生DOM脚本:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="b3c7" class="mr ld iq mi b gy ms mt l mu mv">document.querySelector('h1').innerText</span></pre><p id="3fe7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们得到了<code class="fe mf mg mh mi b">h1</code>的内容，我们就可以做一个断言:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="ca95" class="mr ld iq mi b gy ms mt l mu mv">expect(result).toEqual('Bookish')</span></pre><p id="60a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于<code class="fe mf mg mh mi b">create-react-app</code>已经在中构建了<code class="fe mf mg mh mi b">jest</code>测试框架，我们可以简单地运行以下命令来运行测试:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="4a6d" class="mr ld iq mi b gy ms mt l mu mv">yarn test</span></pre><p id="6888" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，我们还没有任何实现，测试失败了:</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/7448d2264bb3d7ae6360498442911bac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ykEnCV9VaaIAzARBzT_9w.png"/></div></div></figure><p id="f29f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还记得<code class="fe mf mg mh mi b">red-green-refactor</code>周期吗？既然测试现在失败了(红色)，我们应该让它先通过。我们可以简单地修改<code class="fe mf mg mh mi b">h1</code>到<code class="fe mf mg mh mi b">Bookish</code>中的内容:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="c528" class="mr ld iq mi b gy ms mt l mu mv">class App extends Component {<br/>  render() {<br/>    return (<br/>      &lt;div className="App"&gt;<br/>        &lt;h1&gt;Bookish&lt;/h1&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/f0e818b02ccee81621ce343a7e37a0ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jmaeeyptxlb-CtclpFcPlw.png"/></div></div></figure><p id="4e11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了，测试通过了。循环往复，emm，重构。但是现在，看起来没问题，所以我们可以跳过这个。</p><h1 id="4377" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">将代码提交到CVS</h1><p id="e871" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">好了，我们现在有了一个验收测试及其实现，我们可以将代码放入版本控制中，以防将来需要回顾。</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="d45a" class="mr ld iq mi b gy ms mt l mu mv">git init</span></pre><p id="26f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本地提交</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="db93" class="mr ld iq mi b gy ms mt l mu mv">git add .<br/>git commit -m "make the first e2e test pass"</span></pre><p id="c286" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在看看我们得到了什么:</p><ul class=""><li id="48d0" class="mz na iq kf b kg kh kk kl ko nb ks nc kw nd la ne nf ng nh bi translated">运行验收测试</li><li id="76bc" class="mz na iq kf b kg ni kk nj ko nk ks nl kw nm la ne nf ng nh bi translated">一个页面可以把<code class="fe mf mg mh mi b">Bookish</code>渲染成一个<code class="fe mf mg mh mi b">heading</code></li></ul><p id="50f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了，我们可以开始真正的需求实现了。</p></div></div>    
</body>
</html>