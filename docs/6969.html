<html>
<head>
<title>Move semantics and rvalue references: Modern C++ fundamentals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">移动语义和右值引用:现代C++基础</h1>
<blockquote>原文：<a href="https://itnext.io/move-semantics-and-rvalue-references-modern-c-fundamentals-cbbe38760c05?source=collection_archive---------0-----------------------#2022-04-29">https://itnext.io/move-semantics-and-rvalue-references-modern-c-fundamentals-cbbe38760c05?source=collection_archive---------0-----------------------#2022-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="61ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎来到现代C++基础系列，在这里我们一次深入一个主题。今天，我们将讨论C++11中引入的移动语义、值类别和<em class="kl">右值</em>引用。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/93c72fb9ff2dcc40ff6b67973ecb0676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q4aNOYkO1JiR6W_3UI-08A.png"/></div></div></figure><p id="baf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，这是我们必须从一点前期理论开始的话题之一。值得注意的是，我们需要讨论价值类别。</p><h1 id="ca50" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">价值类别</h1><ul class=""><li id="89dd" class="lw lx iq jp b jq ly ju lz jy ma kc mb kg mc kk md me mf mg bi translated"><em class="kl"> glvalues: </em>有标识的表达式；也就是说，可以确定两个表达式是否引用同一个底层实体</li><li id="0cf4" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><em class="kl">右值:</em>可以“移出”的表达式</li></ul><p id="6992" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两个类别结合在一起:</p><ul class=""><li id="ca9a" class="lw lx iq jp b jq jr ju jv jy mm kc mn kg mo kk md me mf mg bi translated"><em class="kl">左值:</em>有标识，不能移动</li><li id="4580" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><em class="kl"> xvalues: </em>有一个标识，可以从</li><li id="9af7" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><em class="kl"> prvalues: </em>没有标识，可以从</li><li id="d6ea" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">没有身份且不能“移出”的未使用的表达式类别</li></ul><h2 id="7508" class="mp kz iq bd la mq mr dn le ms mt dp li jy mu mv lm kc mw mx lq kg my mz lu na bi translated">lvalue与prvalue</h2><p id="84b3" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">为了演示，我们将对比<em class="kl">左值</em>和<em class="kl">pr值</em>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3ec2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">变量名<em class="kl"> x </em>和<em class="kl"> y </em>为<em class="kl">左值。</em>值得注意的是，变量、函数、模板参数对象或数据成员的任何名称都是一个左值。</p><p id="bfdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">变量<em class="kl"> x </em>和<em class="kl"> y </em>是不同的实体，实际上我们可以使用断言来验证这个事实(第2行)。整数常量是<em class="kl"> prvalues </em>，两个常量的含义相同，但是讨论它们是一个还是多个实体没有意义。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b9ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重要的是，表达式有多复杂并不重要。只要保持同一性，表达式就是一个<em class="kl">左值</em>。所以在这里，内联lambda调用是一个<em class="kl">左值</em>表达式。我们还可以验证调用结果和名称<em class="kl"> x </em>是指带有断言的同一个实体。然而，lambda本身没有身份；所以是一个<em class="kl"> prvalue </em>。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="929f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">左值</em>和<em class="kl">pr值</em>的另一个典型例子是导致引用(对于<em class="kl">左值</em>)或非引用(对于<em class="kl">pr值</em>)的函数调用和运算符表达式。</p><h2 id="6f65" class="mp kz iq bd la mq mr dn le ms mt dp li jy mu mv lm kc mw mx lq kg my mz lu na bi translated">x值</h2><p id="9b3e" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">所以，剩下要讨论的一个类别是<em class="kl"> xvalues </em>，其中<em class="kl"> </em>是指定为过期的<em class="kl">GL values</em>(<em class="kl">x values</em>=过期值)。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1843" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们使用<em class="kl"> std::move </em> cast(第5行)手动指定<em class="kl"> name </em>为过期。结果是，对同一个实体的唯一有效操作(通常)是覆盖它的状态(第7行)。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="5334" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于特定的行为可以通过重载移动构造和移动赋值操作符来控制，所以有些类提供了额外的保证:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d59e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">过期的<em class="kl"> unique_ptr </em>保证是<em class="kl"> nullptr </em>。</p><h2 id="f3d7" class="mp kz iq bd la mq mr dn le ms mt dp li jy mu mv lm kc mw mx lq kg my mz lu na bi translated">可以“移出”</h2><p id="3b7f" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">最后，我们再来谈谈<em class="kl">右值</em>以及它对<em class="kl">“从”</em>的意义。</p><p id="fb33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在C++11之前，当我们想从一个已存在的值中表现出一个新值时，我们唯一的选择就是复制构造。但是，考虑到当我们有一个<em class="kl"> xvalue </em>时，源值的内容注定要过期。</p><p id="7fca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在许多情况下，制作副本将是低效的，因为我们可以从源值中提取内容。类似地，<em class="kl"> prvalues </em>也可以被分解，因为它们不存在于当前表达式之后。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b513" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，我们利用move-construction(第2行)和move-assignment(第3、4行)来快速交换两个字符串(通常只需要重新分配三个64位值，不需要分配内存)。</p><h2 id="4dfd" class="mp kz iq bd la mq mr dn le ms mt dp li jy mu mv lm kc mw mx lq kg my mz lu na bi translated">何时移动-铸造</h2><p id="3fa4" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">最后，让我们讨论一下什么时候应该在代码中使用<em class="kl"> std::move </em>强制转换。幸运的是，这个很简单:</p><p id="8bb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">向函数调用(或运算符表达式)传递左值时使用std::move cast，不再需要底层实体的状态。</em> </strong></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="7aad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当与遗留的(或设计不良的)界面交互时，严格遵循这条规则可能会降低性能。然而，这是一个很好的基线。在其他上下文中使用<em class="kl"> std::move </em>强制转换，特别是在<em class="kl"> prvalues </em>或返回表达式中，会阻止编译器优化，应该避免。</p><h2 id="6da6" class="mp kz iq bd la mq mr dn le ms mt dp li jy mu mv lm kc mw mx lq kg my mz lu na bi translated">值类型汇总</h2><p id="14df" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">需要记住的要点:</p><ul class=""><li id="b40a" class="lw lx iq jp b jq jr ju jv jy mm kc mn kg mo kk md me mf mg bi translated"><strong class="jp ir"> <em class="kl">左值</em>表达式具有同一性</strong> <br/>值得注意的是，名称表达式是<em class="kl">左值，</em>以及任何导致引用命名实体的复合表达式也是<em class="kl">左值</em></li><li id="c753" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><strong class="jp ir"> <em class="kl"> prvalues </em>没有标识</strong> <br/>所有文字都是<em class="kl"> prvalues </em>(字符串文字除外，它们是<em class="kl">左值</em>)，表示临时值的表达式也是如此</li><li id="dce7" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><strong class="jp ir"><em class="kl">x值</em>是将<em class="kl">左值</em>表达式标记为过期</strong>的结果</li><li id="fa04" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><strong class="jp ir">当不再需要底层变量的内容时，对<em class="kl">左值</em>表达式使用移动转换</strong></li></ul><h1 id="8a8d" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">右值引用</h1><p id="568e" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">为了编写能够利用移动语义的代码，我们需要讨论硬币的另一面:<em class="kl">右值</em>引用。</p><p id="0bf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们来看看在使用C++11之前的引用和常量引用重载方法时，调用是如何被解析的:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="4a51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，<em class="kl"> prvalues </em>绑定到常量引用(第9行)，可修改的<em class="kl"> lvalues </em>绑定到引用(第12行)，<em class="kl"> xvalues </em>绑定到常量引用(第13行)，不可修改的<em class="kl"> lvalues </em>绑定到常量引用(第16行)。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="77b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们添加第三个接受右值引用的重载，情况将会改变:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="91ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">规则是:</strong></p><ul class=""><li id="c6fd" class="lw lx iq jp b jq jr ju jv jy mm kc mn kg mo kk md me mf mg bi translated"><strong class="jp ir"> <em class="kl">右值</em> ( <em class="kl"> prvalues </em>和<em class="kl"> xvalues </em> ) </strong>将绑定到常量引用或<em class="kl">右值</em>引用，但优先选择<em class="kl">右值</em>引用</li><li id="b2aa" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><strong class="jp ir">可修改的<em class="kl">左值</em></strong></li><li id="62e7" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><strong class="jp ir">不可修改的<em class="kl">左值</em> </strong>将只绑定到常量引用</li></ul></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="05da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的例子可能会让你感到困惑:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5b32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们用<em class="kl"> x、</em>调用<em class="kl"> accepts_int </em>时，它解析为引用调用，尽管<em class="kl"> x </em>属于引用int的类型<em class="kl">右值</em>。要理解为什么我们需要回到本文的第一部分。请记住，任何带有标识和名称的表达式都是一个左值。因此，这里的<em class="kl"> x </em>是一个<em class="kl">左值，</em>它将绑定到一个引用。</p><p id="a9f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们写<em class="kl"> int &amp; &amp; x = 10 </em>时，我们取一个<em class="kl"> prvalue </em>(常量10)，给它一个名字和一个生存期。正因为如此，对函数没有区别<em class="kl">int x = 10；</em>和<em class="kl">int&amp;T59】x = 10；。</em>值得注意的是，两者都是可变的整数变量，它们的生存期超过了函数调用。</p><h1 id="5ee7" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">利用移动语义</h1><p id="f36c" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">到目前为止，我们已经讨论了合成的例子，但是现在是时候讨论移动语义的典型用例了，为你的类实现移动语义。</p><p id="652d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设您的类正在实现自定义资源管理。在这种情况下，您可以通过在典型的复制构造函数、复制赋值函数和析构函数之上实现移动构造函数和移动赋值函数来利用移动语义。</p><p id="437a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个带有移动语义的简单堆栈实现的示例:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b6aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们是利用C++14 <em class="kl"> std::exchange </em>，缩短了<em class="kl"> x = other.x的两步过程；other.x =值；</em>成单一语句。当您对比复制构造函数(第5行)和移动构造函数(第25行)以及复制赋值(第12行)和移动赋值(第29行)时，您可以看到制作副本和分解另一个实例的内容之间的区别。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="fd8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您的类没有实现自定义资源管理，您可能能够坚持零规则:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c5d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只要不声明任何自定义的复制或移动构造函数，复制或移动赋值或析构函数，所有这些都将由编译器提供。这里需要注意的是，默认实现将进行简单的分段复制/移动，这仅适用于不实现手动资源管理的类型。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="cc73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">移动语义还释放了实现只移动类型的潜力。唯一资源句柄需要只移动类型，例如<em class="kl"> unique_ptr </em>。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="bdc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">声明移动构造函数或移动赋值(即使是默认的)会禁用默认的复制构造函数和复制赋值。声明move构造函数也删除了默认的默认构造函数(因此，我们在第2行重新默认了它)。</p><h2 id="cb22" class="mp kz iq bd la mq mr dn le ms mt dp li jy mu mv lm kc mw mx lq kg my mz lu na bi translated">这种类型</h2><p id="3112" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">最后，在C++11之前，我们可以根据实例是常量还是可变的来重载方法。在C++11中，我们可以进一步重载实例是否是一个<em class="kl">右值</em>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="7440" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">感谢您的阅读</h1><p id="0fff" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">如果您喜欢这篇文章，您可能也会喜欢:</p><div class="nn no gp gr np nq"><a rel="noopener  ugc nofollow" target="_blank" href="/the-114-standard-c-algorithms-introduction-2a75a2df4300"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">114种标准C++算法。介绍</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">欢迎来到关于C++标准算法的新系列。标准算法提供了安全和优化的构建模块…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">itnext.io</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe kw nq"/></div></div></a></div><div class="nn no gp gr np nq"><a rel="noopener  ugc nofollow" target="_blank" href="/save-your-sanity-and-time-beyond-clang-format-2b929b9120b8"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">节省你的理智和时间——不要拘泥于形式。</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">作为一名软件工程师，你能做的最有影响力的事情之一就是自动化重复的活动。一个领域，在…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">itnext.io</p></div></div><div class="nz l"><div class="of l ob oc od nz oe kw nq"/></div></div></a></div><p id="2ebf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还在T4的YouTube上发布视频。你有问题吗？在Twitter或LinkedIn上联系我。</p></div></div>    
</body>
</html>