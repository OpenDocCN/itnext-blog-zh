<html>
<head>
<title>Refactoring in Go: goroutine concurrency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的重构:goroutine并发</h1>
<blockquote>原文：<a href="https://itnext.io/refactoring-in-go-goroutine-concurrency-fccbe7093c04?source=collection_archive---------3-----------------------#2018-08-13">https://itnext.io/refactoring-in-go-goroutine-concurrency-fccbe7093c04?source=collection_archive---------3-----------------------#2018-08-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/becd03b9492e08c557a6db26ba9cd7c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ENU2Yq6ur2eHS0I1"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">约翰·卡莱尔在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="8dc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">惊喜！这几天我写围棋。</p><p id="6c21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近，我在野外发现了一些代码，它们使用了简单的并发解决方案。鉴于我多次看到类似的模式，我的理论是，它可能是受基本的goroutines示例代码的启发。</p><h1 id="a783" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">场景</h1><p id="79e7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">假设您想要运行特定数量的易于并行化的任务(没有副作用，没有外部依赖性，等等)。)，并且您希望存储它们每个的结果。在围棋中做到这一点的方法是使用Goroutines。</p><p id="43cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我重构的真实代码通过调用<code class="fe me mf mg mh b">net.LookupHost</code> 100次来计算我们系统中的平均DNS延迟。让我们看看。</p><h1 id="35f4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在野外发现的实际代码</h1><p id="e155" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这是在野外发现的(改编并简化的)代码。看一看，下面我们来讨论一下:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1bc3" class="mq lc iq mh b gy mr ms l mt mu">func AverageLatency(host string) (latency int64, err error) {<br/>    CONCURRENCY := 4<br/>    REQUESTS_LIMIT := 100<br/><br/>    dnsRequests := make(chan int, REQUESTS_LIMIT)<br/>    results := make(chan int64, REQUESTS_LIMIT)<br/>    errorsResults := make(chan string, REQUESTS_LIMIT)<br/><br/>    for w := 1; w &lt;= CONCURRENCY; w++ {<br/>        go dnsTest(dnsRequests, results, errorsResults, host)<br/>    }<br/><br/>    for j := 1; j &lt;= REQUESTS_LIMIT; j++ {<br/>        dnsRequests &lt;- j<br/>    }<br/>    close(dnsRequests)<br/><br/>    requestsDone := 1<br/>    for a := 1; a &lt;= REQUESTS_LIMIT; a++ {<br/>        select {<br/>        case latencyLocal := &lt;-results:<br/>            latency = latency + latencyLocal<br/>            requestsDone = requestsDone + 1<br/>        case errorMsg := &lt;-errorsResults:<br/>            return 0, errors.New(errorMsg)<br/>        case &lt;-time.After(time.Second * DURATION_SECONDS):<br/>            return latency / int64(requestsDone), nil<br/>        }<br/>    }<br/>    return latency / int64(requestsDone), nil<br/>}<br/><br/><br/>func dnsTest(jobs &lt;-chan int, results chan&lt;- int64, errResults chan&lt;- string, host string) {<br/>    for range jobs {<br/>        start := time.Now()<br/>        if _, err := net.LookupHost(host); err != nil {<br/>            errResults &lt;- err.Error()<br/>        }<br/>        results &lt;- time.Since(start).Nanoseconds() / int64(time.Millisecond)<br/>    }<br/>}</span></pre><p id="43eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">主代码按顺序执行以下步骤:</p><ul class=""><li id="cc99" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated">启动<code class="fe me mf mg mh b">CONCURRENCY</code>个goroutines <code class="fe me mf mg mh b">dnsTest</code></li><li id="e5c9" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">使用通道向goroutines发送<code class="fe me mf mg mh b">REQUESTS_LIMIT</code>个作业(DNS请求)</li><li id="45db" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">关闭dnsRequests通道，通知goroutines不再有作业了(这样它们就不会一直等待)</li><li id="f913" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">它等待来自<code class="fe me mf mg mh b">results</code>的<code class="fe me mf mg mh b">REQUESTS_LIMIT</code>数量的值，我们将每个值添加到<code class="fe me mf mg mh b">latency</code>变量中。它还监听错误和超时，如果出现任何错误和超时，就退出函数。</li><li id="0f86" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">在超时的情况下，它用我们到目前为止得到的值计算平均延迟，然后退出。</li><li id="2028" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">最后，它将<code class="fe me mf mg mh b">latency</code>中累积的值除以完成的请求数量，以确定平均延迟。</li></ul><p id="9c03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">咻。那是一种做它的方法…但是它是惯用的吗？</p><h1 id="2f20" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Goroutines很便宜，让我们利用这一点</h1><p id="8716" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Goroutines是轻量级线程，这意味着我们可以在不太影响程序性能的情况下启动大量线程。那么，为什么不推出和我们现有的工作一样多的goroutines呢？这样我们就摆脱了一个仅仅用于迭代的渠道，以及所有与之相伴的业务逻辑。我们还可以将goroutine代码移到循环内部，假设它足够小:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="84f7" class="mq lc iq mh b gy mr ms l mt mu">func AverageLatency(host string) (latency int64, err error) {<br/>    REQUESTS_LIMIT := 100<br/><br/>    results := make(chan int64, REQUESTS_LIMIT)<br/>    errorsResults := make(chan string, REQUESTS_LIMIT)<br/><br/>    <strong class="mh ir">for w := 1; w &lt;= REQUESTS_LIMIT; w++ {<br/>        go func() {<br/>            start := time.Now()<br/>            if _, err := net.LookupHost(host); err != nil {<br/>                errorResults &lt;- err.Error()<br/>                return<br/>            }<br/>            results &lt;- time.Since(start).Nanoseconds() / int64(time.Millisecond)<br/>        }<br/>    }</strong><br/><br/>    requestsDone := 1<br/>    for a := 1; a &lt;= REQUESTS_LIMIT; a++ {<br/>        select {<br/>        case latencyLocal := &lt;-results:<br/>            latency = latency + latencyLocal<br/>            requestsDone = requestsDone + 1<br/>        case errorMsg := &lt;-errorsResults:<br/>            return 0, errors.New(errorMsg)<br/>        case &lt;-time.After(time.Second * DURATION_SECONDS):<br/>            return latency / int64(requestsDone), nil<br/>        }<br/>    }<br/>    return latency / int64(requestsDone), nil<br/>}</span></pre><p id="e922" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码现在更清晰了。我们循环<code class="fe me mf mg mh b">REQUESTS_LIMIT</code>次，每次都创建一个goroutine来检查查找主机的延迟。然后我们等待通道<code class="fe me mf mg mh b">results</code>、<code class="fe me mf mg mh b">errorResults</code>和<code class="fe me mf mg mh b">time.After(..)</code>产生值<code class="fe me mf mg mh b">REQUESTS_LIMIT</code>次。</p><h1 id="89f0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">利用等待组和清理</h1><p id="fc17" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我对最后一个循环不太满意，它看起来有点脆弱，Go有更优雅的工具来帮助从生成的gouroutines中收集结果。其中之一就是<code class="fe me mf mg mh b">WaitGroup</code>。一个<code class="fe me mf mg mh b">Waitgroup</code>是一个等待一组例行程序完成的构造，而不需要我们做太多。我们只需使用<code class="fe me mf mg mh b">WaitGroup.Add</code>增加我们运行的每个goroutine的<code class="fe me mf mg mh b">WaitGroup</code>计数器，当一个goroutine结束时，我们调用<code class="fe me mf mg mh b">WaitGroup.Done</code>。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4b50" class="mq lc iq mh b gy mr ms l mt mu">func AverageLatency(host string) (latency int64, err error) {<br/>    REQUESTS_LIMIT := 100<br/>    results := make(chan int64, REQUESTS_LIMIT)<br/>    errorsResults := make(chan string, REQUESTS_LIMIT)<br/><br/>    <strong class="mh ir">var wg sync.WaitGroup<br/>    wg.Add(REQUESTS_LIMIT)</strong><br/><br/>    for j := 0; j &lt; REQUESTS_LIMIT; j++ {<br/>        go func() {<br/>            <strong class="mh ir">defer wg.Done()</strong><br/>            start := time.Now()<br/>            if _, err := net.LookupHost(host); err != nil {<br/>                errorResults &lt;- err.Error()<br/>                return<br/>            }<br/>            results &lt;- time.Since(start).Nanoseconds() / int64(time.Millisecond)<br/>        }<br/>    }<br/><br/>    <strong class="mh ir">wg.Wait()</strong><br/><br/>    ...<br/>}</span></pre><p id="539c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时，我们不需要通道来收集错误和结果，我们可以使用更传统的数据类型。</p><p id="cb9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还想收集错误的数量，以便进行监控，而不仅仅是在出现一个错误时返回。如果我们想查看实际的错误消息，可以手动检查日志:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0c31" class="mq lc iq mh b gy mr ms l mt mu"><strong class="mh ir">type Metrics struct {<br/>    AverageLatency float64<br/>    RequestCount   int64<br/>    ErrorCount     int64<br/>}</strong><br/><br/>func AverageLatency(host string) Metrics {<br/>    REQUESTS_LIMIT := 100<br/>    var errors int64<br/>    results := make([]int64, 0, DEFAULT_REQUESTS_LIMIT)<br/><br/>    <strong class="mh ir">var wg sync.WaitGroup<br/>    wg.Add(REQUESTS_LIMIT)</strong><br/><br/>    for j := 0; j &lt; REQUESTS_LIMIT; j++ {<br/>        go func() {<br/>            <strong class="mh ir">defer wg.Done()</strong><br/>            start := time.Now()<br/>            if _, err := net.LookupHost(host); err != nil {<br/>                fmt.Printf("%s", err.Error())<strong class="mh ir"><br/>                atomic.AddInt64(&amp;errors, 1)</strong><br/>                return<br/>            }<br/>            <strong class="mh ir">append(results, time.Since(start).Nanoseconds() / int64(time.Millisecond))</strong><br/>        }<br/>    }<br/><br/>    <strong class="mh ir">wg.Wait()</strong><br/><br/>    return CalculateStats(&amp;results, &amp;errors)<br/>}</span></pre><p id="0081" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了一个新的类型<code class="fe me mf mg mh b">Metrics</code>来对我们想要监控的值进行分组。我们现在将<code class="fe me mf mg mh b">wg</code>计数器设置为我们计划执行的请求数，并且当每个goroutine完成时，我们调用<code class="fe me mf mg mh b">wg.Done</code>,不管它是否成功。然后我们等待所有的goroutines完成。我们还将所有的统计数据计算提取到一个外部的<code class="fe me mf mg mh b">CalculateStats</code>函数中，这样<code class="fe me mf mg mh b">AverageLatency</code>就可以专注于收集原始值。</p><p id="2323" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了完整起见，<code class="fe me mf mg mh b">CalculateStats</code>可能是这样的:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9a61" class="mq lc iq mh b gy mr ms l mt mu">// Takes amount of requests and errors and returns some stats on a <br/>// `Metrics` struct<br/>func CalculateStats(results *[]int64, errors *int64) Metrics {<br/>    successfulRequests := len(*results)<br/>    errorCount := atomic.LoadInt64(errors)<br/><br/>    // Sum up all the latencies<br/>    var totalLatency int64 = 0<br/>    for _, value := range *results {<br/>        totalLatency += value<br/>    }<br/><br/>    avgLatency := float64(-1)<br/><br/>    if successfulRequests &gt; 0 {<br/>        avgLatency = float64(totalLatency) / float64(successfulRequests)<br/>    }<br/><br/>    return Metrics{<br/>        avgLatency,<br/>        int64(successfulRequests),<br/>        errorCount<br/>    }<br/>}</span></pre><h1 id="c4ec" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">等等，暂停在哪里？！</h1><p id="b0a9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">哦，对了。在上次重构中，我们似乎忘记了恢复超时，不是吗？</p><p id="ca34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe me mf mg mh b">WaitGroup</code>时设置超时有点麻烦，但是使用通道变得容易了。我们不再直接调用<code class="fe me mf mg mh b">wg.Wait</code>，而是将该调用封装在一个名为<code class="fe me mf mg mh b">waitWithTimeout</code>的新函数中:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3cbc" class="mq lc iq mh b gy mr ms l mt mu">func waitWithTimeout(wg *sync.WaitGroup, timeout time.Duration) bool {<br/>    c := make(chan struct{})<br/>    go func() {<br/>        defer close(c)<br/>        wg.Wait()<br/>    }()<br/><br/>    select {<br/>    case &lt;-c:<br/>        return false<br/>    case &lt;-time.After(timeout):<br/>        return true<br/>    }<br/>}</span></pre><p id="dc5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们创建了一个一旦<code class="fe me mf mg mh b">wg.Wait()</code>运行就会关闭的通道，这意味着所有的goroutines都已完成。然后我们使用一个<code class="fe me mf mg mh b">select</code>语句来返回所有的goroutines完成的时间，或者已经过了<code class="fe me mf mg mh b">timeout</code>的时间。在这种情况下，我们返回<code class="fe me mf mg mh b">true</code>来通知超时已经发生。</p><p id="87e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的最终<code class="fe me mf mg mh b">AverageLatency</code>将最终看起来像这样:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e823" class="mq lc iq mh b gy mr ms l mt mu">func AverageLatency(host string) Metrics {<br/>    REQUESTS_LIMIT := 100<br/>    var errors int64<br/>    results := make([]int64, 0, REQUESTS_LIMIT)<br/><br/>    var wg sync.WaitGroup<br/>    wg.Add(REQUESTS_LIMIT)<br/><br/>    for j := 0; j &lt; REQUESTS_LIMIT; j++ {<br/>        go func() {<br/>            defer wg.Done()<br/>            start := time.Now()<br/>            if _, err := net.LookupHost(host); err != nil {<br/>                fmt.Printf("%s", err.Error())<br/>                atomic.AddInt64(&amp;errors, 1)<br/>                return<br/>            }<br/>            append(results, time.Since(start).Nanoseconds() / int64(time.Millisecond))<br/>        }<br/>    }<br/><br/>    <strong class="mh ir">if waitWithTimeout(&amp;wg, time.Duration(time.Second*DURATION_SECONDS)) {<br/>        fmt.Println("There was a timeout waiting for DNS requests to finish")<br/>    }</strong><br/>    return CalculateStats(&amp;results, &amp;errors)<br/>}</span></pre><p id="d416" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在超时的情况下，我们只显示一条消息，因为我们仍然想知道发出了多少个请求和错误，而不管是否超时。</p><h1 id="6ae6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">奖金:比赛条件！！</h1><p id="7e37" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">哈，我敢肯定你认为就是这样，世界上的一切都是好的。但是没有！我在代码中加入了一个竞争条件。你们中的一些人可能已经发现了。对于没有看过的人，我会让你看一下上面的代码。我会等的。</p><p id="2791" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你找到了吗？就算你找到了也没关系，我不会对你评头论足，我自己可能也找不到。不管怎样，谢谢你迁就我！</p><p id="7fe5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，让我们来看看这整个比赛条件是怎么回事。</p><h2 id="7776" class="mq lc iq bd ld nj nk dn lh nl nm dp ll ko nn no lp ks np nq lt kw nr ns lx nt bi translated">在Go中，事情很少是线程安全的</h2><p id="7bd3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">每当我们用Goroutines操作时，我们必须小心修改外部变量，因为它们通常不是线程安全的。在我们的主goroutine中，我们通过使用<code class="fe me mf mg mh b">atomic.AddInt64</code>以线程安全的方式存储错误，但是我们将延迟存储在<code class="fe me mf mg mh b">results</code>片上，这不是线程安全的。绝对不能保证<code class="fe me mf mg mh b">results</code>中的条目数量与我们尝试的请求数量相匹配。哎呀。</p><p id="3b49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在围棋中，有几种方法可以解决这个问题，例如:</p><ul class=""><li id="c986" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated">返回使用通道而不是切片来收集延迟</li><li id="a6bb" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">使用互斥体来控制对<code class="fe me mf mg mh b">results</code>的访问</li><li id="c35b" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">使用缓冲容量为1的通道作为队列，并在那里发送延迟</li></ul><p id="0a64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">鉴于我们已经深陷goroutines，我选择使用第三种方法。这也是我发现的最惯用的方法:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2d14" class="mq lc iq mh b gy mr ms l mt mu">func AverageLatency(host string) Metrics {<br/>    REQUESTS_LIMIT := 100<br/>    var errors int64<br/>    results := make([]int64, 0, REQUESTS_LIMIT)<strong class="mh ir"><br/>    successfulRequestsQueue := make(chan int64, 1)</strong><br/><br/>    var wg sync.WaitGroup<br/>    wg.Add(DEFAULT_REQUESTS_LIMIT)<br/><br/>    for j := 0; j &lt; REQUESTS_LIMIT; j++ {<br/>        go func() {<br/>            start := time.Now()<br/><br/>            if _, err := net.LookupHost(host); err != nil {<br/>                atomic.AddInt64(&amp;errors, 1)<br/>                wg.Done()<br/>                return<br/>            }<br/><br/>            <strong class="mh ir">successfulRequestsQueue &lt;- time.Since(start).Nanoseconds() / 1e6</strong><br/>        }()<br/>    }<br/><br/>    <strong class="mh ir">go func() {<br/>        for t := range successfulRequestsQueue {<br/>            results = append(results, t)<br/>            wg.Done()<br/>        }<br/>    }()</strong><br/><br/>    if waitTimeout(&amp;wg, time.Duration(time.Second*DURATION_SECONDS)) {<br/>        fmt.Println("There was a timeout waiting for DNS requests to finish")<br/>    }<br/>    return CalculateDNSReport(&amp;results, &amp;errors)<br/>}</span></pre><p id="f6bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们正在创建一个只能缓冲一个值的通道<code class="fe me mf mg mh b">successfulRequestsQueue</code>，有效地创建了一个同步队列。我们现在可以将延迟结果发送到那里，而不是直接将其附加到<code class="fe me mf mg mh b">results</code>。然后，我们在<code class="fe me mf mg mh b">successfulRequestsQueue</code>中循环所有输入延迟，并将其附加到该goroutine中的<code class="fe me mf mg mh b">results</code>。我们还将<code class="fe me mf mg mh b">wg.Done()</code>调用移到了<code class="fe me mf mg mh b">append</code>之后。通过这种方式，我们可以确保每个结果都会得到处理，并且不会出现竞争情况。</p><h1 id="642e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="579b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以进一步重构这段代码，但是出于本文的目的，我认为我们现在可以停止了。万一你想继续下去，我提出一些改进:</p><ul class=""><li id="d7d5" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated">让计算函数(现在是<code class="fe me mf mg mh b">net.LookupHost</code>)通用化，这样我们就可以在测试中使用不同的函数。</li><li id="c267" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">如果没有goroutines，您将如何编写这段代码？</li><li id="dfd3" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">使代码完全独立于上下文，这样我们就可以在任何时候使用它来存储许多操作的结果。</li></ul></div></div>    
</body>
</html>