<html>
<head>
<title>Tail recursion in swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">swift中的尾部递归</h1>
<blockquote>原文：<a href="https://itnext.io/tail-recursion-in-swift-6aa73ed7bf56?source=collection_archive---------4-----------------------#2021-07-19">https://itnext.io/tail-recursion-in-swift-6aa73ed7bf56?source=collection_archive---------4-----------------------#2021-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/a0652cac4e9b46d681f8eb6d9969b44e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FHGk0Cz1gpxpmk2j85e1dw.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="7ca6" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">它是什么以及如何避免调用堆栈溢出的示例。</h2></div><p id="b724" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">到目前为止，作为一名iOS开发人员，除了我在大学学到的东西之外，我很少接触调用栈。我工作过的大多数应用程序都不是资源密集型的。我曾经开发过复杂的应用程序，但是这种复杂性主要是为了提供良好的用户体验。</p><p id="9375" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在过去的两年里，作为我博士研究的一部分，我一直在开发一个分析源代码历史的swift应用程序。对于非常大的应用程序和很长的源代码历史，我有时会遇到我的工具因<strong class="kv jf">分段错误</strong>而崩溃的问题。当时，我并不知道问题出在哪里，但我知道，当要分析的数据变得太大时，就会出现这种情况。我稍后将回到这一点。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="ba1d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在做一个C和汇编编程课程的项目时，我偶然发现了尾部递归优化，并决定在swift中尝试一下。</p><h2 id="1468" class="lx ly je bd lz ma mb dn mc md me dp mf lc mg mh mi lg mj mk ml lk mm mn mo mp bi translated"><strong class="ak">什么是尾递归？</strong></h2><p id="279a" class="pw-post-body-paragraph kt ku je kv b kw mq kf ky kz mr ki lb lc ms le lf lg mt li lj lk mu lm ln lo im bi translated">一个<strong class="kv jf">递归函数</strong>是一个调用自身的函数，例如下面的函数将打印出从n到0的所有数字。</p><figure class="mv mw mx my gt iv"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="2fa7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">尾部递归函数</strong>是一个递归函数，其中对自身的调用位于函数的末尾，如下例所示:</p><figure class="mv mw mx my gt iv"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="f72f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这些函数以相反的顺序打印出数字，但在其他方面具有相同的功能:打印出n和0之间的所有数字。</p><h2 id="bf33" class="lx ly je bd lz ma mb dn mc md me dp mf lc mg mh mi lg mj mk ml lk mm mn mo mp bi translated">为什么重要？</h2><p id="9855" class="pw-post-body-paragraph kt ku je kv b kw mq kf ky kz mr ki lb lc ms le lf lg mt li lj lk mu lm ln lo im bi translated">让我们编译这些程序并运行它们。可以通过调用以下命令来编译程序:</p><blockquote class="nb nc nd"><p id="7ae7" class="kt ku ne kv b kw kx kf ky kz la ki lb nf ld le lf ng lh li lj nh ll lm ln lo im bi translated">xcrun swift c-O tail . swift-or result</p></blockquote><p id="4e93" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这些程序可以通过调用</p><blockquote class="nb nc nd"><p id="9e80" class="kt ku ne kv b kw kx kf ky kz la ki lb nf ld le lf ng lh li lj nh ll lm ln lo im bi translated">。/结果</p></blockquote><p id="79d7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们来试试小n (n=3)。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ni"><img src="../Images/a2dab070d94d395b68c0a8975722d35e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l4LWcrFdPcD0i-PMZLnABQ.jpeg"/></div></div></figure><p id="eae0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在让我们尝试一个大的n (n=10000)。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ni"><img src="../Images/e0f362bbe8864eff58834351c880a24b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t7_uEt50Ogy9VKxw4qmAyw.jpeg"/></div></div></figure><p id="b053" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这里我们回到<strong class="kv jf">分段故障。</strong>这只发生在无尾递归程序中。为什么会这样？什么是分段故障，为什么只有一个程序崩溃？为了回答这些问题，我将从调用堆栈开始。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="7177" class="lx ly je bd lz ma mb dn mc md me dp mf lc mg mh mi lg mj mk ml lk mm mn mo mp bi translated">什么是调用栈？</h2><p id="85e8" class="pw-post-body-paragraph kt ku je kv b kw mq kf ky kz mr ki lb lc ms le lf lg mt li lj lk mu lm ln lo im bi translated">当一个方法在程序中被调用时，它被添加到调用堆栈中。当在这个方法中调用另一个方法时，它也被添加到调用堆栈中。当方法返回时，它将从调用堆栈中移除。</p><p id="1d99" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">因此，来自递归函数的重复方法调用都被添加到调用堆栈中，直到满足停止条件并且最后一个方法调用返回。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/7163f82a95106fbd21a744eb93e9cd8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*ba6Ht_9uL6vMdjDlCyFOtw.png"/></div></figure><h2 id="7a6c" class="lx ly je bd lz ma mb dn mc md me dp mf lc mg mh mi lg mj mk ml lk mm mn mo mp bi translated">什么是分段故障？</h2><p id="7265" class="pw-post-body-paragraph kt ku je kv b kw mq kf ky kz mr ki lb lc ms le lf lg mt li lj lk mu lm ln lo im bi translated">调用堆栈存储在堆栈内存段中。左图显示了内存布局。</p><p id="bcaf" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">当向调用堆栈添加太多方法调用时，分配给调用堆栈的有限内存将变满，调用堆栈外的内存位置将被覆盖。首先是堆，然后是未初始化的内存，已初始化的内存，最后是文本段。</p><p id="9b90" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">试图写入文本段会导致分段错误，程序执行会暂停。这是一种安全机制。</p><h2 id="5232" class="lx ly je bd lz ma mb dn mc md me dp mf lc mg mh mi lg mj mk ml lk mm mn mo mp bi translated">尾部递归优化。</h2><p id="f05a" class="pw-post-body-paragraph kt ku je kv b kw mq kf ky kz mr ki lb lc ms le lf lg mt li lj lk mu lm ln lo im bi translated">Swift使用尾部递归优化，这意味着如果递归函数中的方法调用位于函数的末尾，编译器能够使用跳转语句而不是方法调用。这意味着递归中对自身的调用不会添加到调用堆栈中。</p><p id="824f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">当我们使用Hopper反编译前面的两个程序时，我们看到每个程序的汇编代码都有很大的不同。</p><p id="141d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">带有递归函数的程序产生汇编代码，如下所示。我们可以看到在方法_$s4main4test2nySi_tF中有一个对iself的方法调用。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nk"><img src="../Images/05d62a97e1499b0261c8ec578166982c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K8wMAWy_MkbmvoRPuTRB6g.png"/></div></div></figure><p id="32f2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">另一方面，具有尾部递归的程序得到了优化。我们可以看到，有一个跳转(jg)指令，而不是方法调用。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nl"><img src="../Images/1edf3ed11350a58c9a4d418068b1b714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hVM08gdsdCPUG9nN4PYLrw.jpeg"/></div></div></figure><p id="f9e8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我一直喜欢编写递归函数，但我从未想过使用它们会有缺点。当然，上面的例子是应该使用循环编写的，但是仍然是一个很好的例子，说明意外溢出调用堆栈是多么容易。</p><p id="4c97" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我现在知道为什么我的源代码分析工具在非常大的应用程序中崩溃了，我将致力于优化代码以防止它在未来发生。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="8ddd" class="lx ly je bd lz ma mb dn mc md me dp mf lc mg mh mi lg mj mk ml lk mm mn mo mp bi translated">外卖</h2><ul class=""><li id="0afc" class="nm nn je kv b kw mq kz mr lc no lg np lk nq lo nr ns nt nu bi translated">如果可能的话，最好使用循环而不是递归。</li><li id="5fc0" class="nm nn je kv b kw nv kz nw lc nx lg ny lk nz lo nr ns nt nu bi translated">编写递归函数时，如果可能的话，在方法的末尾编写对自身的调用。</li></ul></div></div>    
</body>
</html>