<html>
<head>
<title>11 ways to check for palindromes in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中检查回文的11种方法</h1>
<blockquote>原文：<a href="https://itnext.io/11-way-to-check-for-palindromes-in-javascript-85dbfe7dfb5d?source=collection_archive---------0-----------------------#2019-10-21">https://itnext.io/11-way-to-check-for-palindromes-in-javascript-85dbfe7dfb5d?source=collection_archive---------0-----------------------#2019-10-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/f81fb9b6436f4159dd7394c1a6bcdef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2_qID8QdEn5euxPnLpZ_UA.png"/></div></div></figure><div class=""/><h1 id="39d0" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">挑战</h1><p id="6069" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">写一个函数，给定一个字符串，如果该字符串是回文，则返回true，否则返回false。这是一个经常出现在工作面试和代码挑战中的问题，JavaScript也不例外。</p><p id="7434" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这篇文章中，我将介绍<strong class="ky jc"> 8 </strong>解决这个算法挑战的不同方法，并谈一谈每种方法的性能和优缺点。</p><p id="65d1" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">此外，我将介绍<strong class="ky jc"> 3 </strong>估算一个字符串有多“接近”成为一个回文的方法——100%是一个完美的回文，0%是尽可能远离一个回文。</p><h1 id="2b18" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">定义</h1><p id="56eb" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">好的，首先让我们直接得到回文的定义。</p><blockquote class="lz ma mb"><p id="9611" class="kw kx mc ky b kz lu lb lc ld lv lf lg md lw lj lk me lx ln lo mf ly lr ls lt ij bi translated">一个<strong class="ky jc">回文</strong>是一个单词、数字、短语或其他向前和向后读起来一样的字符序列，例如<em class="jb"> taco cat </em>或<em class="jb"> madam </em>或<em class="jb"> racecar </em>或数字<em class="jb"> 10801。</em></p><p id="e7bf" class="kw kx mc ky b kz lu lb lc ld lv lf lg md lw lj lk me lx ln lo mf ly lr ls lt ij bi translated">当考虑到对大写字母、标点符号和单词分隔符的调整时，可以写出句子长度的回文，例如“一个人，一个计划，一条运河，巴拿马！”，“我看到的是一辆车还是一只猫？”或者“尼克松没有x”。</p><p id="ae83" class="kw kx mc ky b kz lu lb lc ld lv lf lg md lw lj lk me lx ln lo mf ly lr ls lt ij bi translated"><em class="jb"> - </em>维基百科</p></blockquote><h1 id="feec" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">设置</h1><p id="cf90" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">根据定义，我们需要去除潜在的非字母数字字符，从而转换成小写字母。<br/>所以在下面的所有解决方案中，我们将使用这个<em class="mc"> clean </em>函数来获得一个干净的字符序列</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mg"><img src="../Images/e71e36e3fd04a64687209740689f10f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L3fgnXMouJMRYK2If_gf3g.png"/></div></div></figure><p id="b3c0" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这些解决方案中的每一个都针对3种情况进行了性能测试:<br/>-10个字符的小型回文<br/>-1000个字符的中型回文<br/>-5000个字符的大型回文</p><p id="e235" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">使用<a class="ae ml" href="https://nodejs.org/api/perf_hooks.html#perf_hooks_performance_now" rel="noopener ugc nofollow" target="_blank"> performance.now() </a>在NodeJS进程中运行测试</p><h1 id="1c3b" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">1.使用for循环</h1><p id="f974" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们从一个非常简单的方法开始。<br/>解决方案是使用for循环遍历字符。<br/>对于位置<em class="mc"> i </em>的每个字符，我们从末尾开始与位置<em class="mc"> i </em>的字符进行比较。如果这些中的任何一个不相等，我们可以拒绝作为回文的输入，并退出循环，返回false。</p><p id="0a46" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们也只需要遍历字符串的一半，因为遍历整个字符串将会对每个字符进行两次比较。<br/>因此，我们保证只做string.length / 2总迭代。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mg"><img src="../Images/ba158ffa97dc6e60951898a2293eeba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g6YNw4ha90gm5TQUitD6jQ.png"/></div></div></figure><p id="b40a" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">性能:<br/> </strong>小型:0.0731毫秒<br/>中型:0.1267毫秒<br/>大型:0.6272毫秒</p><p id="61ea" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">优点<br/> </strong>表现非常出色，即使是在大型琴弦上。<br/>我们能够在发现第一次违规后立即退货。</p><p id="8716" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">缺点<br/> </strong>在ES6和Bable的世界里，for循环已经不是最常用的了，这个解决方案读起来有点“笨拙”。</p><h1 id="db6a" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">2.用于…的</h1><p id="515b" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这个方法与前面的类似，但是我们没有使用常规的for循环，而是使用for…of</p><p id="146c" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">使用这种方法，我们将字符串转换成数组，然后遍历每个元素。<br/>对于每个元素，我们使用<em class="mc"> pop() </em>移除数组的最后一个元素，然后将当前元素与那个元素进行比较。<br/>同样，如果这些不相等，这不是一个回文，我们退出并返回false。</p><p id="81a8" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">由于我们在迭代时使用突变减少了数组，所以我们仍然只进行string.length / 2次总迭代。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mg"><img src="../Images/7f0ba9c608b04a48cda345639ffba122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QTMwZq7z2BimZCs4XnsXMg.png"/></div></div></figure><p id="b704" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">性能:<br/> </strong>小:0.0415毫秒<br/>中:0.0966毫秒<br/>大:0.9997毫秒</p><p id="4538" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">优点<br/> </strong>表现不错，看起来还算可读。<br/>我们能够在发现第一次违规后立即返回。</p><p id="0e17" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">缺点<br/> </strong>我们强制性地改变了数组，这让我们损失了一些性能。</p><h1 id="7117" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">3.使用分割、反转和连接</h1><p id="0f3e" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">好了，让我们转而使用一些JavaScripts的内置方法。<br/>这个解决方案非常直观——我们将简单地反转字符串，并将其与原始字符串进行比较。如果它们相等，这就是一个回文。</p><p id="af6b" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这个解决方案中，我们使用内置的方法<em class="mc"> split() </em>将一个字符串拆分成一个数组，<em class="mc"> reverse() </em>将一个数组的顺序反转，<em class="mc"> join </em>将数组的元素连接成一个字符串。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mg"><img src="../Images/8875e8035151bb463cdf132f59e5ca3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_e-g6-iuW473qnsy7OFUrg.png"/></div></div></figure><p id="269f" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">性能:<br/> </strong>小型:0.1633毫秒<br/>中型:0.1986毫秒<br/>大型:1.5192毫秒</p><p id="92f0" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">优点<br/>优点</strong>简洁，可读性很强。<br/>很容易理解是怎么回事。</p><p id="25ef" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">缺点<br/>T35】不是表现最好的，即在小琴弦上。</strong></p><h1 id="d750" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">4.使用forEach</h1><p id="f138" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">该解决方案与解决方案1和2非常相似。<br/>我们将把字符串转换成一个数组，然后对它应用<em class="mc"> forEach </em>。<br/>对于每次迭代，我们都进行与解决方案1中相同的比较，但这次我们将从外部范围标记一个变量<code class="fe mm mn mo mp b"><em class="mc">isPalindrome</em></code> <em class="mc"> </em>，如果有违反的话。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mg"><img src="../Images/b04563976a28faf78fe104cc98d611c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XiMadPBFAc7bChcJOc_JLg.png"/></div></div></figure><p id="170f" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">性能:<br/> </strong>小型:0.0444毫秒<br/>中型:0.1487毫秒<br/>大型:1.2537毫秒</p><p id="0d01" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">优点<br/> </strong>使用ES6方法加分。<br/>整体可读性更强，容易理解。</p><p id="cd27" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">缺点<br/> </strong>与<em class="mc"> forEach </em>我们不能中断迭代，也不能保证只做string.length / 2总迭代。这让我们损失了一些性能。</p><h1 id="5e85" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">5.使用地图</h1><p id="e92d" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这个解决方案有点不同。我们再次将字符串转换成一个数组，但是这次我们在它上面应用了<em class="mc"> map </em>。</p><p id="e8f5" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">使用<em class="mc">映射，</em>我们返回一个新数组，每个元素的<em class="mc">为真</em>或<em class="mc">为假</em>，代表这个字符是否从末尾匹配同一个字符。</p><p id="c8ed" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">最后，我们使用<em class="mc"> some </em>来检查新数组是否包含一个<em class="mc"> false。</em> <br/>如果该字符串不为回文，否则不为。</p><p id="4e1b" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">Info: some()将接受一个谓词函数，并在数组中的所有元素上测试它。如果一个或多个元素测试失败，some()返回false。否则为真。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mg"><img src="../Images/22d88c90615feec2ddea8df1be6cee21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TQKj-cgdlc14K4si3mvK2A.png"/></div></div></figure><p id="1497" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">性能:<br/> </strong>小型:0.0644毫秒<br/>中型:0.1560毫秒<br/>大型:0.9630毫秒</p><p id="2538" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">优点<br/> </strong>使用ES6方法加分。</p><p id="9729" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">缺点<br/> </strong>带<em class="mc">映射</em>我们不能中断迭代，也不能保证只做string.length / 2总迭代。<br/>此外，我们必须创建一个新的列表，这需要额外的内存，并且我们必须遍历这个新列表——有可能——一次额外的时间。这让我们损失了一些性能。</p><h1 id="902f" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">6.使用reduce</h1><p id="8894" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这个解决方案类似于使用<em class="mc"> forEach </em>，相反，我们使用<em class="mc"> reduce </em>。<br/>这里的关键区别在于，我们必须使用<em class="mc"> forEach、</em>在外部作用域中标记一个变量，我们可以使用<em class="mc"> reduce将这个标记传递给下一次迭代。</em></p><p id="a783" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这允许我们直接返回<em class="mc">减少</em>的结果。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mg"><img src="../Images/d77a24d69a74a6f61902bf2175f6bcb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RzVECUvgD260q0-aQ9gh9A.png"/></div></div></figure><p id="4dba" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">性能:<br/> </strong>小型:0.0425毫秒<br/>中型:0.1830毫秒<br/>大型:0.8459毫秒</p><p id="b489" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">优点<br/> </strong>使用ES6方法加分。</p><p id="8712" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">缺点<br/> </strong>与<em class="mc">减少</em>我们不能中断迭代，也不能确保只做string.length / 2总迭代。<br/>如果检查过早失败，我们继续将<em class="mc"> false </em>传递给下一次迭代。这看起来很浪费，尤其是在更大的弦上。</p><h1 id="049a" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">7.使用每</h1><p id="1d73" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这种方法实际上是我个人最喜欢的检查回文的方法。<br/>我们将字符串转换成一个数组，然后对它应用<em class="mc">每一个</em>。</p><p id="20b2" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><em class="mc">信息:every()将接受一个谓词函数，并在数组中的所有元素上测试它。<br/>单个测试一失败，every()立即返回false。</em></p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mq"><img src="../Images/69b3a6ca6d8bb04eed4c04f799d9964b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JZuOFd2gzwTAaDCpQsaBpg.png"/></div></div></figure><p id="2aad" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">性能:<br/> </strong>小型:0.0414毫秒<br/>中型:0.1977毫秒<br/>大型:1.4204毫秒</p><p id="d80c" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">优点<br/>优点</strong>非常简洁易读。<br/>一个字符不匹配就会早破。</p><p id="5f66" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">缺点<br/> </strong>我们不能保证只做string.length / 2总迭代次数。<br/>在一个回文的情况下，<em class="mc">每一个</em>都会继续迭代整个数组。</p><h1 id="abc7" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">8.使用递归</h1><p id="ddf8" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">最后，让我们用递归来解决这个问题。这个想法是比较字符串的第一个和最后一个字符。如果它们相等，我们将创建一个移除了第一个和最后一个字母的子串，并再次将其应用于我们的递归函数，直到我们遇到不匹配，或者我们得到一个空串(或者长度为1的串)。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mg"><img src="../Images/a32aef91f700c2dfcd3d0421cde93f25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_jJWdLERUsBumPOFsiI4sw.png"/></div></div></figure><p id="1c98" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">性能:<br/> </strong>小型:0.0842毫秒<br/>中型:5.1806毫秒<br/>大型:108.5716毫秒</p><p id="21ea" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">面试官可能会因为你知道如何处理递归而给你加分。<br/>除此之外，这个解决方案可能没什么好的。</p><p id="6adb" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">另一方面，这里有一些考虑因素。<br/>我们正在开放许多函数闭包，并且正在建立一个——潜在的——大型调用栈。</p><p id="af50" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">请注意，与之前的任何解决方案相比，大弦的性能在这里都是惊人的。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><p id="dabe" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，让我们想象一下，面试官问你是否有一种方法可以估计一个给定的字符串离一个回文有多近。</p><p id="bf1d" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这里应该出现的第一个问题是:“接近”是什么意思？<br/> <em class="mc">接近</em>在正确的位置上匹配吗？<br/> <em class="mc"> Close </em>我们要交换多少个字母才能得到一个回文？<br/> <em class="mc">接近</em>字母表中不匹配的字母相距多远？<br/> <em class="mc">接近</em>就完全不同的东西而言？——这可以有很多种解释。</p><p id="f9fe" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这里，我将介绍3种解决这个问题的方法。我将使用以下测试字符串进行验证。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mg"><img src="../Images/4c65397a7634cd4ad95df32568c27617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JmsvPIo61Cfnb3s72QltwA.png"/></div></div></figure><h1 id="0c7b" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">计算匹配百分比</h1><p id="44da" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">还记得我们如何使用<em class="mc">映射</em>来创建一个<em class="mc">真/假</em>值的列表，表示给定位置上的字符是否与另一端的相应字符匹配吗？</p><p id="8a7d" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们可以使用<em class="mc">过滤器</em>来统计<em class="mc">假</em>值的数量，而不是使用<em class="mc">一些</em>来检查列表中是否有<em class="mc">假</em>值。<br/>现在我们可以用这个数除以字符串的总长度，得到匹配百分比。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mg"><img src="../Images/aa423a098ad2f9016cf54101e1bd9175.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GLurG95wqKazyMOum4nsBg.png"/></div></div></figure><p id="0b42" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">结果:<br/></strong>100.00%<br/>80.95%<br/>27.27%<br/>0.00%<br/>0.00%</p><p id="4a42" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">性能:<br/> </strong>小型:0.0718毫秒<br/>中型:0.2233毫秒<br/>大型:1.4426毫秒</p><h1 id="ac27" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">使用余弦相似度</h1><p id="f7cc" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这种方法更高级一点。</p><p id="c2d0" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这个想法是，我们要把字符串分成两个相等的部分，然后还原其中的一部分。<br/>然后我们将它们转换成它们在<em class="mc"> n </em>维度中的矢量表示，<em class="mc"> n </em>是半弦的长度。然后我们要测量这些向量之间的角度。<br/>角度越大，琴弦之间的不匹配越大。</p><p id="30a7" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们一步一步地研究这个算法。</p><p id="92f9" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">将字符串拆分成两个偶数半字符串</strong> <br/>(如果它们不是偶数，我们可以把中间的字符去掉)</p><p id="46e0" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">反转下半串<br/> </strong>反转下半串使用<em class="mc">拆分，反转</em>和<em class="mc">连接。</em></p><p id="641f" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">将两个半字符串转换成向量</strong> <br/>这里棘手的部分是找到一种将字符表示成数字的好方法，这种数字包括字符本身及其在字符串中的位置。<br/>通过这种方法，我使用字符charCode(减去96，这样‘a’变成1，‘b’变成2，等等。)，然后从该数字中减去数组中的位置。</p><p id="a6aa" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我减去96的原因是，在<a class="ae ml" href="https://www.w3schools.com/charsets/ref_html_ascii.asp" rel="noopener ugc nofollow" target="_blank"> ASCII表中,‘a’是第97个字符。</a></p><p id="b306" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">计算两个向量的点积<br/> </strong>我们可以使用以下公式计算点积</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div class="gh gi my"><img src="../Images/4e0fd68ef7c65c182a3d186e9617ab2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:286/1*iiFLxiWSjsD7aVQ4f29pLQ.gif"/></div></figure><p id="3d8c" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">计算每个矢量的大小<br/> </strong>我们可以使用以下公式计算每个矢量的大小</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/9569d2764c84bb0fa0e99bb2cd211f15.png" data-original-src="https://miro.medium.com/v2/resize:fit:232/1*X-uJJ5NlygjIICEnfT89DQ.gif"/></div></figure><p id="61eb" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">计算矢量间夹角的余弦值<br/> </strong>现在，让我们用下面的公式计算矢量间夹角的余弦值</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div class="gh gi na"><img src="../Images/fc2eb4f71d4ab49fe7e0cab34f3481b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:244/1*r8u8jevJ6TfQQf0YT9ffWw.gif"/></div></figure><p id="a563" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">转换成百分比</strong> <br/>因为角度的余弦在[-1]范围内；1]，我们想把这个转换成百分比，其中-1代表0%，1代表100%。<br/>我们简单的把余弦加1再除以to，最后乘以100。</p><p id="7ba4" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">通过使用这种方法，我们可以估计两个半弦有多相似。<br/>由于我们使用charCode作为变量，这里考虑了字母表中不匹配字符之间的距离。</p><p id="9d06" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果算法返回100%，我们就有了一个完美的回文。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nb"><img src="../Images/dbe71ca3516d802314370457124afa28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AW_0lJJ_lSjjq4Dg8qhDpQ.png"/></div></div></figure><p id="11aa" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">结果:<br/></strong>100.00%<br/>90.04%<br/>57.90%<br/>69.17%<br/>12.37%</p><p id="f592" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">性能:<br/> </strong>小型:0.0314毫秒<br/>中型:0.2597毫秒<br/>大型:1.5066毫秒</p><h1 id="8e17" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">使用Levenshtein距离</h1><p id="80aa" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这种方法也更高级一些，我们需要用到一些数学知识。</p><p id="3fe8" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">就像前面的方法一样，我们首先将字符串分成两个半字符串，然后还原第二个半字符串。</p><p id="0b01" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，这个想法是计算这两个字符串之间的Levenshtein距离，并将其转换为百分比的度量。</p><p id="f2d3" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">Levenshtein距离</strong>是将一个单词变成另一个单词所需的最小单字符编辑次数。<br/>我们可以使用以下公式计算Levenshtein距离</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/39e998e16167f73f955cef736233ebc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*HtySua5pYr9tbw-c3-AlMQ.png"/></div></figure><p id="04ea" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">单字符编辑可以是<em class="mc">插入、</em>替换<em class="mc">或</em>删除。</p><p id="ae07" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">例如，如果我们计算“本田”和“现代”这两个词的Levenshtein距离，我们得到<em class="mc"> 3。</em></p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/2bd1069a025416baae7459e5431dfb2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*vmb49cQEea6qDvuZevvwZw.jpeg"/></div></figure><p id="93c7" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们需要<em class="mc">删除</em>中的字母“<em class="mc"> Y </em>”，<em class="mc">将</em>中的字母“<em class="mc"> O </em>”替换为“<em class="mc"> U </em>”，<em class="mc">插入</em>an<em class="mc">【I】</em>，总共3次编辑。</p><p id="56f8" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们来看看这个设置，看看我们如何用它来近似一个字符串的回文。</p><p id="3650" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">将字符串拆分成两个偶数半字符串</strong> <br/>(如果它们不是偶数，我们可以把中间的字符去掉)</p><p id="d6ad" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">反转下半串<br/> </strong>反转下半串使用<em class="mc">拆分，反转</em>和<em class="mc">连接。</em></p><p id="7230" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">创建一个矩阵<br/> </strong>我们要创建一个大小为<em class="mc">n</em><em class="mc">n</em>的矩阵，其中<em class="mc"> n </em>是半串长度的大小。</p><p id="3247" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">填充矩阵<br/> </strong>我们将从左上角开始填充这个矩阵。</p><p id="0796" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">统计编辑<br/> </strong>我们遍历矩阵，统计需要我们进行的编辑。<br/>水平和垂直方向的每次“跳转”将分别被计为一次<em class="mc">删除</em>和一次<em class="mc">插入</em>。</p><p id="c09c" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">换算成百分比<br/> </strong>最后我们将这个换算成百分比。最后一步很简单——我们简单地用半弦的长度除以Levenshtein距离。现在我们得到了“倒置的”百分比，所以我们需要从1中减去结果。最后，我们乘以100。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/c2c690eb3621e7d0aa18bdea9a3d8c73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DPtC1bcqhQ2cVENflutlIA.png"/></div></div></figure><p id="2592" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">结果:<br/></strong>100.00%<br/>80.00%<br/>27.27%<br/>6.67%<br/>0.00%</p><p id="aa8f" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">性能:<br/> </strong>小型:0.0635毫秒<br/>中型:32.5343毫秒<br/>大型:616.9648毫秒</p><h1 id="fc74" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="8ba6" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们现在已经看了8种不同的方法来检查一个给定的字符串是否是一个回文，以及3种不同的方法来估计一个给定的字符串有多接近一个回文。</p><p id="3df1" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">就性能而言，检查回文的最佳方式是使用传统的for循环或for…of循环。</p><p id="01d3" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">就可读性而言，这取决于偏好。<br/>我的首选是使用<em class="mc"> every的解决方案7。<br/> </em>方案3也很干净好看。</p><p id="6fe0" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">就一个回文的近似而言，我们看到它如何高度依赖于我们所说的“接近”一个回文是什么意思，以及我们选择使用哪种算法。当某个东西是完美的回文，而某个东西肯定不是时，我提供的3种方法都是一致的。<br/>但是介于两者之间的频谱导致了各种不同的近似值，这取决于实现方式和我们对“接近”的定义。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><p id="bd1f" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">感谢您的阅读！如果你喜欢这篇文章，请鼓掌👏扣几下吧！</strong></p><p id="7762" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">如果你想了解更多关于如何充分利用JavaScript的知识，可以看看我的另一篇文章:</strong> <a class="ae ml" rel="noopener ugc nofollow" target="_blank" href="/javascript-wizard-tips-and-tricks-1b91025a0d62"> <strong class="ky jc"> JavaScript向导:技巧&amp;技巧</strong> </a></p><p id="35a4" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">你也可以在 <a class="ae ml" href="https://twitter.com/silindsoftware" rel="noopener ugc nofollow" target="_blank"> <strong class="ky jc">推特</strong> </a> <strong class="ky jc">上关注我，我会在那里发布更多类似的内容。</strong></p><h1 id="6b6d" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">来源</h1><div class="ip iq gp gr ir nf"><a href="https://en.wikipedia.org/wiki/Palindrome" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd jc gy z fp nk fr fs nl fu fw ja bi translated">回文</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">回文是一个单词、数字、短语或其他字符序列，它的前后读起来是一样的，比如…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">en.wikipedia.org</p></div></div><div class="no l"><div class="np l nq nr ns no nt ix nf"/></div></div></a></div><div class="ip iq gp gr ir nf"><a href="https://en.wikipedia.org/wiki/Cosine_similarity" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd jc gy z fp nk fr fs nl fu fw ja bi translated">余弦相似性</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">余弦相似性是内积空间中两个非零向量之间相似性的一种度量</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">en.wikipedia.org</p></div></div></div></a></div><div class="ip iq gp gr ir nf"><a href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd jc gy z fp nk fr fs nl fu fw ja bi translated">莱文斯坦距离</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">在信息论、语言学和计算机科学中，Levenshtein距离是一个字符串度量，用于测量…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">en.wikipedia.org</p></div></div></div></a></div><div class="ip iq gp gr ir nf"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd jc gy z fp nk fr fs nl fu fw ja bi translated">Array.prototype.every()</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">every()方法测试数组中的所有元素是否都通过了由提供的函数实现的测试。它…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">developer.mozilla.org</p></div></div><div class="no l"><div class="nu l nq nr ns no nt ix nf"/></div></div></a></div><div class="ip iq gp gr ir nf"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd jc gy z fp nk fr fs nl fu fw ja bi translated">Array.prototype.some()</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">some()方法测试数组中是否至少有一个元素通过了由提供的函数实现的测试…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">developer.mozilla.org</p></div></div><div class="no l"><div class="nv l nq nr ns no nt ix nf"/></div></div></a></div></div></div>    
</body>
</html>