<html>
<head>
<title>Testing observables and promises in Angular:</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试角度的可观测性和承诺；</h1>
<blockquote>原文：<a href="https://itnext.io/testing-observables-and-promises-in-angular-ac49575d27b4?source=collection_archive---------0-----------------------#2021-06-30">https://itnext.io/testing-observables-and-promises-in-angular-ac49575d27b4?source=collection_archive---------0-----------------------#2021-06-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1177" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从angular组件测试服务调用的快速指南。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/762469821344810ea7d7231e344eb640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2effs38F9B_H9_Fz8gfRfg.jpeg"/></div></div></figure><h1 id="a428" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">我们正在测试的方法:</h1><pre class="kg kh ki kj gt lj lk ll lm aw ln bi"><span id="b501" class="lo ks iq lk b gy lp lq l lr ls"><em class="lt">/**<br/> * Sends the screenshot to the backend api and shows loading   indicators<br/> * </em><strong class="lk ir"><em class="lt">@param </em></strong><em class="lt">$event<br/> */<br/></em>async submitFeedback() {<br/>  this.sendingFeedback = true;<br/><br/>  // Take a screenshot<br/>  const screenshot = await this.takeScreenshot();<br/><br/>  this.feedbackService.sendImage(screenshot).subscribe((res) =&gt; {<br/>    this.sendingFeedback = false;<br/>    this.displaySuccessModal();<br/>  }, (error =&gt; {<br/>    this.sendingFeedback = false;<br/>    this.displayErrorModal();<br/>  }))<br/>}</span></pre><h1 id="c298" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">我们想要测试的是:</h1><p id="f10d" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">让我们在观察完成后测试我们的组件是否正确执行。</p><ul class=""><li id="7cc3" class="mq mr iq lw b lx ms ma mt md mu mh mv ml mw mp mx my mz na bi translated">当服务成功响应时，它应该显示一个成功模式。</li><li id="7674" class="mq mr iq lw b lx nb ma nc md nd mh ne ml nf mp mx my mz na bi translated">当服务响应一个错误时，它应该显示一个错误模式。</li></ul><h1 id="bd3a" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">测试可观察到的成功/失败的代码示例:</h1><pre class="kg kh ki kj gt lj lk ll lm aw ln bi"><span id="947b" class="lo ks iq lk b gy lp lq l lr ls">import { <strong class="lk ir"><em class="lt">NO_ERRORS_SCHEMA </em></strong>} from '@angular/core';<br/>import { ComponentFixture, fakeAsync, flushMicrotasks, <strong class="lk ir"><em class="lt">TestBed </em></strong>} from '@angular/core/testing';<br/>import { FeedbackButtonComponent } from './feedback-button.component';<br/>import { of, throwError } from 'rxjs';<br/>import { HttpClientModule } from '@angular/common/http';<br/>import { FeedbackService } from '../feedback.service';<br/><br/>describe('ButtonComponent', () =&gt; {<br/>  let component: FeedbackButtonComponent;<br/>  let fixture: ComponentFixture&lt;FeedbackButtonComponent&gt;;<br/>  const feedbackServiceSpy = jasmine.createSpyObj('FeedbackService', ['']);<br/><br/>  beforeEach(async () =&gt; {<br/>    await <strong class="lk ir"><em class="lt">TestBed</em></strong>.configureTestingModule({<br/>      schemas: [<strong class="lk ir"><em class="lt">NO_ERRORS_SCHEMA</em></strong>],<br/>      declarations: [ FeedbackButtonComponent ],<br/>      providers: [{<br/>        provide: FeedbackService, useValue: feedbackServiceSpy<br/>      }],<br/>      imports: [ HttpClientModule ]<br/>    })<br/>    .compileComponents();<br/>  });<br/><br/><br/>  beforeEach(() =&gt; {<br/>    fixture = <strong class="lk ir"><em class="lt">TestBed</em></strong>.createComponent(FeedbackButtonComponent);<br/>    component = fixture.componentInstance;<br/>    fixture.detectChanges();<br/>  });<br/><br/>  it('should create', () =&gt; {<br/>    expect(component).toBeTruthy();<br/>  });<br/><br/>  describe('sendImageToServerObservable', () =&gt; {<br/><br/>    beforeEach(() =&gt; {<br/>      const fakeScreenshot = { fakeScreenshot: true };<br/>      spyOn(component, 'displaySuccessModal');<br/>      spyOn(component, 'takeScreenshot').and.callFake(() =&gt; new <strong class="lk ir"><em class="lt">Promise</em></strong>((resolve =&gt; resolve(fakeScreenshot))));<br/>    })<br/><br/>    it('should display the error message modal if an error is returned', fakeAsync(() =&gt; {<br/>      component['feedbackService'].sendImage = () =&gt; throwError({ error: true });<br/>      component.submitFeedback();<br/>      flushMicrotasks();<br/>      expect(component.displayErrorModal).toHaveBeenCalled();<br/>    }))<br/><br/>    it('should display the success message modal if an error is returned', fakeAsync(() =&gt; {<br/>      component['feedbackService'].sendImage = () =&gt; of({ success: true });<br/>      component.submitFeedback();<br/>      flushMicrotasks();<br/>      expect(component.displaySuccessModal).toHaveBeenCalled();<br/>    }))<br/>  })<br/>});</span></pre><h2 id="7be2" class="lo ks iq bd kt ng nh dn kx ni nj dp lb md nk nl ld mh nm nn lf ml no np lh nq bi translated">测试设置需要注意的重要事项:</h2><ul class=""><li id="9ac3" class="mq mr iq lw b lx ly ma mb md nr mh ns ml nt mp mx my mz na bi translated">在尝试测试一个方法是否被调用之前，您必须先探查该方法。例如，因为我们想测试是否已经调用了<code class="fe nu nv nw lk b">component.takeScreenshot</code>,所以我们需要在调用submitFeedback方法之前调用它。</li><li id="4457" class="mq mr iq lw b lx nb ma nc md nd mh ne ml nf mp mx my mz na bi translated">用<code class="fe nu nv nw lk b">fakeAsync</code>包装it函数来模拟异步操作，然后在运行测试断言之前用<code class="fe nu nv nw lk b">flushMicrotasks</code>跟进。</li><li id="f0d6" class="mq mr iq lw b lx nb ma nc md nd mh ne ml nf mp mx my mz na bi translated"><code class="fe nu nv nw lk b">fakeAsync</code>为您提供了一种在断言之前运行异步代码<em class="lt">的简单方法。它将确保没有异步工作剩余，你可以简单地调用使用你的<code class="fe nu nv nw lk b">expect</code>语句。我不会试图在这里详细解释一切，但如果你想了解更多，我强烈建议你阅读这篇文章:<a class="ae nx" href="https://blog.nrwl.io/controlling-time-with-zone-js-and-fakeasync-f0002dfbf48c" rel="noopener ugc nofollow" target="_blank">https://blog . nrwl . io/controlling-time-with-zone-js-and-fake async-f 0002 DFB f48 c</a></em></li></ul><h2 id="e784" class="lo ks iq bd kt ng nh dn kx ni nj dp lb md nk nl ld mh nm nn lf ml no np lh nq bi translated">使用jasmine.createSpyObj和提供程序测试设置:</h2><p id="1791" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">如上面的代码示例所示，您将看到我如何使用<code class="fe nu nv nw lk b">jasmine.createSpyObj</code>为服务创建一个spy来设置您的单元测试。注意，您必须将这个spy添加到providers数组中，以便您的组件知道您正在使用这个spy，而不是实际的服务。</p><h1 id="a37d" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">结论:</h1><h1 id="e71a" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">感谢阅读。如果你学到了什么，点击跟随按钮！</h1></div></div>    
</body>
</html>