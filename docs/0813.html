<html>
<head>
<title>Valid and Invalid in Angular Forms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度形式的有效和无效</h1>
<blockquote>原文：<a href="https://itnext.io/valid-and-invalid-in-angular-forms-61cfa3f2a0cd?source=collection_archive---------1-----------------------#2018-06-03">https://itnext.io/valid-and-invalid-in-angular-forms-61cfa3f2a0cd?source=collection_archive---------1-----------------------#2018-06-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/dcaa41fdc1366a0a9a64260d4c4f38df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-YOiKwsu6t12Fwah7UshsQ.png"/></div></div></figure><p id="2e3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Angular中，验证表单最常见的方法之一是禁用提交按钮。这是一种很好的方式(和有用的消息一起)来告诉用户表单中有些地方不对劲。</p><p id="3954" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，要禁用按钮，我们使用这样的东西</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="e9cd" class="lf lg iq lb b gy lh li l lj lk">...<br/>&lt;button type="submit" [disabled]="form.invalid"&gt;SEND&lt;/button&gt;<br/>...<br/>&lt;button type="submit" [disabled]="!form.valid"&gt;SEND&lt;/button&gt;</span></pre><p id="da62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以上面有两种最常见的方法可以在表单无效时禁用按钮。你有没有想过<code class="fe ll lm ln lb b">form.invalid </code>和<code class="fe ll lm ln lb b">!form.valid</code>的区别？虽然在逻辑上它们必须是相同的，但实际上它们之间有细微的差别。为了演示这一点，我们将创建一个简单的表单，其中一个输入检查给定的电子邮件是否存在于数据库中。为此，我们将使用反应式表单和自定义异步验证器。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="5274" class="lf lg iq lb b gy lh li l lj lk">&lt;form [formGroup]="form"&gt;</span><span id="3a3d" class="lf lg iq lb b gy lo li l lj lk">  &lt;input placeholder="Enter your email" formControlName="email"/&gt;</span><span id="cdf3" class="lf lg iq lb b gy lo li l lj lk">  &lt;button type="submit" [disabled]="form.invalid"&gt;SEND&lt;/button&gt;</span><span id="12b0" class="lf lg iq lb b gy lo li l lj lk">   &lt;div *ngIf="form.get('email').pending"&gt;<br/>      &lt;img src="loader.gif" &gt;<br/>   &lt;/div&gt;<br/>&lt;/form&gt;</span></pre><p id="1f66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以标记非常简单，我们有一个表单，里面有一个输入。我们还有一个提交表单的按钮，该按钮被<code class="fe ll lm ln lb b">form.invalid</code>禁用。</p><p id="8c60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也有一个div来显示一个简单的加载微调，而我们将检查给定的电子邮件在数据库中的存在。</p><p id="36cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在一个. ts文件中，我们使用FormBuilder创建了我们的表单。我们应用了Angular的<code class="fe ll lm ln lb b">required </code>和<code class="fe ll lm ln lb b">email </code>验证器以及一个定制的异步验证器来检查邮件。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="0871" class="lf lg iq lb b gy lh li l lj lk">form: FormGroup;</span><span id="a703" class="lf lg iq lb b gy lo li l lj lk">constructor(private fb: FormBuilder) {}</span><span id="4a5c" class="lf lg iq lb b gy lo li l lj lk">ngOnInit() {<br/>    this.form = this.fb.group({<br/>      email: ['', [Validators.required, Validators.email], <br/>              this.checkValidEmail]<br/>    })<br/>  }</span></pre><p id="39c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的<code class="fe ll lm ln lb b">this.checkValidEmail</code>是我们的自定义验证器，它只是一个函数。在实际应用中，你可能需要一个服务，向数据库发送请求，检查电子邮件是否存在并返回结果。为了简单起见，我们将使用<code class="fe ll lm ln lb b">setTimeout()</code>模拟对后端的调用。重要的是调用后端(或者用<code class="fe ll lm ln lb b">setTimeout()</code>模拟它)是一个异步操作，所以我们不能使用标准的验证器或者定制的同步验证器。</p><p id="6864" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们的<code class="fe ll lm ln lb b">checkValidEmail</code>函数会将输入字段中的给定电子邮件与静态电子邮件进行比较。如果它们匹配，这意味着电子邮件正忙，我们需要通知用户选择另一个电子邮件，我们还需要禁用按钮。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="6d69" class="lf lg iq lb b gy lh li l lj lk">checkValidEmail(control: AbstractControl) {<br/>    return new Promise((resolve, reject) =&gt; {<br/>      setTimeout(() =&gt; {<br/>        if (control.value === 'super@secret.com') {<br/>            resolve({ emailIsTaken: true })<br/>        } else {resolve(null)}<br/>      }, 2000)<br/>    })<br/>}</span></pre><p id="5d65" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以现在我们准备好了。让我们来看看浏览器</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/8ab349c363596406ae4f5fb77fc54b47.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/1*LbcIpsrAEwjpy5gUBRSV5Q.gif"/></div></figure><p id="250e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，最初该按钮是禁用的，但当我们插入电子邮件时，该按钮变为启用，2秒钟后(时间设置在<code class="fe ll lm ln lb b">setTimeout()</code>)该按钮再次变为禁用，因为该电子邮件确实在“数据库”中。</p><p id="b1bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">启用短时按钮的原因是除了<code class="fe ll lm ln lb b">valid </code>和<code class="fe ll lm ln lb b">invalid</code>之外还有一个状态。那就是<code class="fe ll lm ln lb b">pending </code>州。最初<code class="fe ll lm ln lb b">pending </code>被设置为<strong class="ka ir">假</strong>，但是当我们使用异步验证器时，挂起变为<strong class="ka ir">真</strong>，<code class="fe ll lm ln lb b">valid </code>和<code class="fe ll lm ln lb b">invalid </code>变为<strong class="ka ir">假</strong>。</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lq"><img src="../Images/683062aef7e93730a246a0f14c456a1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z1U9g7Ga_QyxQQImz8pumQ.png"/></div></div></figure><p id="5779" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们的异步验证器开始工作时，状态变为<code class="fe ll lm ln lb b">pending </code>并且<code class="fe ll lm ln lb b">invalid</code>变为<strong class="ka ir">假</strong>，这意味着表单是有效的。这就是为什么当使用带有异步验证器的<code class="fe ll lm ln lb b">form.invalid</code>时，我们会得到这种行为。想象一下，这个操作可能需要3秒甚至更多的时间，当它挂起时，按钮将被启用，用户可以单击并提交表单。</p><p id="c873" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们用<code class="fe ll lm ln lb b">!form.valid</code>代替<code class="fe ll lm ln lb b">form.invalid</code>时，情况就不同了。因为在未决状态下<code class="fe ll lm ln lb b">valid </code>变为<strong class="ka ir">假</strong>，按钮将被禁用，直到我们得到结果，根据该结果，我们启用或不启用按钮。</p><p id="3c2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以希望现在能清楚为什么使用<code class="fe ll lm ln lb b">[disabled]=”!form.valid”</code>比<code class="fe ll lm ln lb b">[disabled]=”form.invalid”</code>更安全。</p><p id="eaa8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读。完整的代码可从<a class="ae lr" href="https://stackblitz.com/edit/angular-p4bz6e" rel="noopener ugc nofollow" target="_blank">这里</a>获得</p></div></div>    
</body>
</html>