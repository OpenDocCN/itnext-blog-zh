# 🔥如何无限制地缩放角度

> 原文：<https://itnext.io/how-to-scale-angular-without-limits-e6a6ca15111?source=collection_archive---------1----------------------->

极限总是在你的头脑中，清空你的头脑和秤

![](img/0a6315fcda61d8423d0f63c236f9848f.png)[](https://medium.com/subscribe/@easy-web) [## 每当维塔利·舍甫琴科发表文章时，就收到一封电子邮件。

### 每当维塔利·舍甫琴科发表文章时，就收到一封电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…

medium.com](https://medium.com/subscribe/@easy-web) 

# 内容

*   [**简介**](#48fc)
*   [**不可伸缩心态的罪过**](#12dd)
*   [**清空你的头脑和秤**](#7521)
*   [**角度可扩展设计的基石**](#e92b)
*   [**在缩放角度时各个击破**](#34f5)
*   [**结论**](#495b)
*   [**了解更多**](#a554)

# 介绍

你能想到的最具扩展性的模式是什么？ 也许是 universe🪐或者你的腹部脂肪🍔，那*分形*怎么样。这是一个无限的模式，它的每一部分都有完整的模式。看起来是这样的:

![](img/1438c15082120738a6f0e8c6f6e4d335.png)

如果我告诉你，我们可以使用*分形*原理之一来扩展我们的架构。但是首先，让我们谈谈可伸缩性。

# 不可扩展思维的罪恶

每个成长中的产品总有一天会面临扩展问题。你觉得你永远不会遇到它，这意味着你的架构还没有准备好。每个人都害怕那一天，因为它会花费你大量的金钱和时间，这也是金钱。让我们思考一下，为了让我们的未来不那么有压力，我们需要避免的心态。

**不知道未来。没有人知道未来。如果你不是*医生当然奇怪*🧙‍♂️.但这并不能成为不考虑特性缩放的借口。另一方面，试图过多地预测未来也不是一个好主意，它会减缓发展，并导致过度工程化。解决方案是遵循*最佳实践*、*框架标准*并留出更多扩展空间。**

我没有足够的时间。你当然不会🤷‍♀️，在这个快节奏的世界里，每个公司都希望交付得更快、更多。否则，这个行业将会消亡。这种心态让你思考不够，肯定会导致不愉快的后果。一般的规则是，喘口气，暂停一下，想想如何将你的应用分成封装的部分，并解除它们之间的依赖。请记住，架构不必是理想的，对于您的任何情况，都已经有现成的解决方案，只需借鉴和适应即可。

考虑产品而不是团队。团队是随着产品一起成长的，你需要时刻记住，团队也需要扩展。团队规模的缺乏👨‍👩‍👧‍👦将使我们与不可预防的问题作斗争:失去核心工程师就等于失去业务领域的一部分，团队内部和团队之间的知识共享，不同团队之间的知识分散，使每个新工程师入职都感觉像一场灾难。为了避免这个问题——你必须像对待产品一样对待团队:*封装*和*解耦*。

# 清空你的头脑和秤

很明显，在架构设计过程中，你必须非常谨慎。但是有太多的书籍和理论描述了不同的可扩展架构的方式。同时，有很多人有他们的经验和观点，这可能会引起彼此的争议。那么哪种方式是正确的，最好的呢？答案是——他们都是好的，值得活下去，但如果我告诉你，你不必进行所有这些讨论。大型科技公司已经经历了各种规模问题，迄今为止，没有人发明出比 mono repo 更好的东西。

mono repo——仅仅是一个包含所有项目的仓库，包括前端和后端。让我们看看主要的*单报告*原则:

**复用性**。您可以在您的所有项目之间共享数据，以及*实用工具* *功能*、 *UI 组件、*和*接口*。不仅是前端应用之间，甚至是*前端*和*后端*之间。

**一致性**。这个原理来源于上一个。您可以导入相同的实例版本，而不是为每个项目复制每个依赖项。因此，当你更新依赖关系时，它会在 *monorepo* 应用之间传播。

**标准化**。尽管团队在选择技术栈方面有灵活性，但是定义公共工具变得更加容易，比如构建和测试。这个原则也适用于代码和分支最佳实践。

**团队可扩展性**。团队是原子的，并且拥有他们的项目或库的所有权。同时， *monorepo* 鼓励团队在遵循共同标准的基础上进行更多的合作。

# 角度可扩展设计的基石

在回顾了高级别的可伸缩性之后，是时候深入了解如何无限制地扩展*角度*了。首先，让我们谈谈我们的架构将由哪些主要组件组成。

**角度模块**——我们大型应用程序中最精细的部分。模块封装了一小部分逻辑，由一组*组件、服务、指令、*等组成。它们也可以互相注射。这个想法很简单，当复杂性增加时，包装逻辑和嵌套。

**项目**。当我们的项目变得越来越大，必须由多个团队维护时，这是开始分解成更小的子项目的信号。如果是有一个*外壳*项目和多个*微**app*的嵌套，可以通过 [***微前端架构***](https://medium.com/@easy-web/how-micro-frontend-changes-the-future-of-angular-bb4deb2cfdad) 进行伸缩。如果你对如何实现感兴趣，可以查看这里的[](https://medium.com/@easy-web/building-angular-micro-frontend-with-ngrx-state-sharing-and-nx-cli-7e9af10ebd03)*。或者，如果您不需要嵌套子项目，您可以简单地创建一个新项目。*

***图书馆。**这是所有共享数据所在的地方: *UI 组件，数据存储，实用函数*。这个库就像一个本地节点包。如果*库*处于*单个项目级别*，它在*模块*之间共享数据。否则，如果是跨项目或微应用，则进入*工作区*级别。*

***工作区**。其实是我们的 *monorepo* 。它由一组共享数据的*项目*和*库*组成。*

# *在缩放角度时各个击破*

*在你的一生中，你一定已经听过这个概念成千上万次了。这是明智和强大的，足以用在我们的情况下。我们可以从单个 Angular 项目的文件夹结构开始，然后将其扩展。*

*这个假想的应用程序将被称为**书架，**它由两个*功能组成:* **登录**和**书籍**。当用户*登录*时，应用程序将我们重定向到*图书的图库*，在那里我们可以选择图书并打开一个包含*图书详细信息*的新页面。*

*简单明了，现在我们来谈谈术语:*

*   ***特性。**一大块业务逻辑，通常与页面相关，封装在单个模块中。当它开始增长并有许多子页面时，它可以被更精细地分组，例如:*

```
***-features
    -login
    -books-gallery***
```

*并扩展到:*

```
*-features
    -login
    **-books**
        **-books-gallery**
            -components
            -services
            -utils
            -types
            -configs
       ** -books-details***
```

*   ***libs。**它只是一个桶，我们将所有在*特性*之间共享的可重用数据放在里面。它可能包含*小部件*、 *UI 组件*、*数据存储、实用程序、类型、配置。**

```
***-libs
    -ui-components
    -widgets
    -data-store
    -utils
    -types
    -configs***
```

*   ***用户界面组件**。这些是虚拟组件，非常特定于用户界面。你可以把它想象成一个 UI 库——类似素材 UI，由*按钮*、*卡片*、*对话框*组成。它们是可以在其他项目中重用以保持一致性的组件。*
*   ***小工具。**小型企业组件，积木式的多个 ***功能*** 。也可能由 ***ui 组件*** *，*组成，例如 **book-card** (里面有 ***ui 组件***——*卡片*，*按钮*；用于多个 ***功能*** — *书籍—图库*、*书籍—详情*。*
*   ***数据存储**。包含可共享的*状态*和 API 相关逻辑，可以注入到其他 ***特性*** 中。例如 *NgRx 商店*。*
*   ***实用工具。**简单助手功能用于*特征*。可以驻留在单个特征中，因为它不可重用。*
*   ***类型**。只是可共享的*类型，接口，枚举*。*
*   ***配置**。存放所有可重复使用的*常量*和*模拟*的文件夹。*

*我们最终的单一项目结构将如下所示:*

```
***-features
    -login
    -books
        -books-gallery**
            -components
            -services
           ** -utils
            -types
            -configs**
      **  -books-details**
**-libs
    -ui-components
    -widgets
    -data-store
    -utils
    -types
    -configs***
```

*该结构可以根据项目的需要进行扩展和改进，但这种架构足以自信地扩展。*

**接下来是什么？想象一下，我们的应用变得越来越大，而*功能*变得太大，以至于我们不得不专门成立一个团队来维护它。是时候进一步扩展它并将*特性*分离到它自己的项目中了。这里是我们可以获得 *monorepo* 和微前端的好处的地方，如果你想亲自尝试一下，可以查看这篇 [**文章**](https://medium.com/@easy-web/building-angular-micro-frontend-with-ngrx-state-sharing-and-nx-cli-7e9af10ebd03) 。这是我们最终的可扩展架构的样子:**

```
***-apps
    -login
        -features
        -libs
    -books
        -features
        -libs
    -shell
-libs**
    **-ui-components
    -widgets
    -data-store
    -utils
    -types
    -configs***
```

*你可能已经注意到了名为**“shell”的新应用。**在*微前端*世界中使用，定义懒加载其他*微 app* 的主机应用，在 [**了解更多**](#a554) 部分找到所有参考。*

# *结论*

*这种结构并不局限于 Angular，稍加调整就可以应用到其他任何前端框架上。 ***如果你学到了新的东西*** 又不想错过下一期刊物，就跟我来鼓掌吧。*

*请在评论中告诉我你在应用程序中使用什么文件夹结构？*

*[](https://medium.com/subscribe/@easy-web) [## 每当维塔利·舍甫琴科发表文章时，就收到一封电子邮件。

### 每当维塔利·舍甫琴科发表文章时，就收到一封电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…

medium.com](https://medium.com/subscribe/@easy-web)* 

# *了解更多信息*

*[](https://medium.com/@easy-web/how-micro-frontend-changes-the-future-of-angular-bb4deb2cfdad) [## 微前端如何改变 Angular 的未来？

### 让我们来看看为什么 Angular 是最好的微前端

medium.com](https://medium.com/@easy-web/how-micro-frontend-changes-the-future-of-angular-bb4deb2cfdad) [](https://medium.com/@easy-web/building-angular-micro-frontend-with-ngrx-state-sharing-and-nx-cli-7e9af10ebd03) [## 🔥利用 NgRx 状态共享和 NX cli 构建角度微前端

### 如何在几乎不编码的情况下构建健壮的微前端架构；)

medium.com](https://medium.com/@easy-web/building-angular-micro-frontend-with-ngrx-state-sharing-and-nx-cli-7e9af10ebd03) [](https://javascript.plainenglish.io/the-evolution-of-asynchronous-patterns-in-javascript-64efc8938b16) [## 🔥JavaScript 中异步模式的演变

### 让我们谈谈 JavaScript 中使用的异步模式

javascript.plainenglish.io](https://javascript.plainenglish.io/the-evolution-of-asynchronous-patterns-in-javascript-64efc8938b16)*