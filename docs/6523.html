<html>
<head>
<title>Using HTMLParser2, DOMUtils, to process HTML and XML in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用HTMLParser2，DOMUtils处理Node.js中的HTML和XML</h1>
<blockquote>原文：<a href="https://itnext.io/using-htmlparser2-domutils-to-process-html-and-xml-in-node-js-5027ba63c181?source=collection_archive---------2-----------------------#2021-12-09">https://itnext.io/using-htmlparser2-domutils-to-process-html-and-xml-in-node-js-5027ba63c181?source=collection_archive---------2-----------------------#2021-12-09</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="7c3e" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">Node.js简化了服务器端DOM处理</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/059963615d2bd6379cddb8d4e17b51ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rbgrcD4tW79UGGy8.jpg"/></div></div></figure><p id="90fe" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv"> HTMLParser2是Node.js包(domhandler、domutils、css-select、dom-serializer)集群的一部分，支持对HTML和XML DOM对象树的强大操作。这些包不仅可以用于web抓取，还可以用于服务器端的DOM操作，它们构成了Cheerio的大部分基础，Cheerio是Node.js包，用于在Node.js上进行类似jQuery的DOM操作。</strong></p><p id="56d8" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">似乎大多数人使用HTMLParser2及其相关包进行Web抓取。这意味着下载一个页面并从该页面的HTML中解析出数据。虽然这可以用来创建非常有用的信息资源，但是这些包可以用于许多其他任务，包括HTML和XML数据的服务器端DOM操作。这些包中的每一个都专注于一个特定的目的，当一起使用时，程序员可以获得强大的能力来接收XML或HTML文档、提取数据和转换这些文档。</p><p id="01cd" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">不幸的是，这些软件包的文档并不清楚。我写这篇文章的目的是为理解如何使用它们创建一个有用的资源。</p><p id="5761" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我是作为一个静态网站生成器平台AkashaCMS的作者来处理这个问题的。AkashaCMS的一个核心特性是使用Cheerio实现服务器端的DOM操作，以创建最终的HTML显示给访问者。在某些情况下，它会修复HTML，重写URL，或者将自定义标签如<code class="fe lr ls lt lu b">&lt;embed-video&gt;</code>转换成YouTube视频播放器。</p><p id="c213" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在使用Cheerio时，我没有注意实现。在诊断最新Cheerio版本的问题时，我开始感兴趣。作为回应，我想深入了解Node.js中的XML和HTML处理。第一站是探索HTMLParser2、DOMHandler、DOMUtils、CSS-Select和DOM-Serializer。</p><p id="7d13" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我还对Node.js中服务器端DOM操作的选项范围感兴趣。我知道在前端工程中，许多人正在逐步淘汰jQuery，因为DOM API的改进使得jQuery变得不那么必要了。我很好奇是否有Node.js包用jQuery API的简洁性实现了DOM操作。</p><p id="5121" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">本文的目标包括用DOMHandler和DOMUtils评估DOM操作。</p><h1 id="3a8a" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated">如果没有浏览器，DOM是什么？</h1><p id="9180" class="pw-post-body-paragraph kv kw iu kx b ky mn jv la lb mo jy ld le mp lg lh li mq lk ll lm mr lo lp lq in bi translated">我们需要谈谈大教堂的事。DOM不仅仅是web浏览器基于网页内容生成的东西。在正常情况下，对于web浏览器中显示的每个网页，浏览器都将其转换为DOM，然后我们使用CSS来设置DOM的样式，并使用JavaScript来操作它。通过浏览器端的DOM操作，可以在web浏览器中实现非常高级的应用程序。</p><p id="b835" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在这种情况下，DOM意味着文档对象模型，它是一个跨平台和独立于语言的接口，将XML或HTML文档视为一个树结构，其中每个节点都是表示文档一部分的对象。DOM用一个逻辑树表示一个文档。</p><p id="4c3a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">换句话说，XML和HTML看起来像文本，但它们实际上是序列化的数据结构。HTML或XML文本是序列化格式。读取这些文件的软件，如web浏览器，将文本表示反序列化为DOM结构。因此，有可能将XML/HTML反序列化为DOM，操纵DOM，然后将其序列化回XML或HTML。</p><p id="691b" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">DOM是自20世纪90年代以来不断发展的标准。实现存在于多种编程语言中。标准DOM模型涉及各种类型的节点对象，这些节点对象具有属性，并且包含零个或多个子节点对象。一种类型是元素对象，代表我们在XML或HTML中熟悉的<code class="fe lr ls lt lu b">&lt;tag&gt;</code>。</p><p id="f442" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这就是我们前进的方向，使用实现类似于Node.js上DOM标准的API的包。DOM API从来不局限于浏览器，因为它存在于多种语言中。</p><h1 id="2a19" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated">为HTMLParser2、DOMHandler、DOMUtils、CSS-Select和DOM-Serializer设置Node.js项目</h1><p id="f040" class="pw-post-body-paragraph kv kw iu kx b ky mn jv la lb mo jy ld le mp lg lh li mq lk ll lm mr lo lp lq in bi translated">为了探究这些包，让我们用几个示例脚本建立一个简单的项目。在此之前，您当然必须在您的计算机上安装Node.js。我目前运行的是Node.js 16.13.0，但我相信它可以在14.x上运行。</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="5d36" class="mw lw iu lu b gz mx my l mz na">$ npm init -y<br/>Wrote to /Volumes/Extra/ws/techsparx.com/projects/node.js/htmlparser2/package.json:<br/><br/>{<br/>  "name": "htmlparser2",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>  },<br/>  "keywords": [],<br/>  "author": "David Herron &lt;david@davidherron.com&gt;",<br/>  "license": "ISC"<br/>}<br/><br/>$ npm install htmlparser2 domhandler domutils css-select dom-serializer --save<br/><br/>added 11 packages, and audited 12 packages in 3s<br/><br/>10 packages are looking for funding<br/>  run `npm fund` for details<br/><br/>found 0 vulnerabilities</span></pre><p id="5c29" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我将目录命名为<code class="fe lr ls lt lu b">htmlparser2</code>，因此<code class="fe lr ls lt lu b">npm init -y</code>导致<code class="fe lr ls lt lu b">package.json</code>将项目命名为<code class="fe lr ls lt lu b">htmlparser</code>。否则，这给了我们一个包含这一组包的空白项目。</p><p id="e9d8" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">另一项任务是获取一个或多个您可以使用的HTML文件。我使用的文件来自AkashaRender测试套件之一，因此它有一些自定义标记。</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="0e58" class="mw lw iu lu b gz mx my l mz na">&lt;!doctype html&gt; <br/>&lt;!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ --&gt; <br/>&lt;!--[if lt IE 7]&gt; &lt;html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"&gt; &lt;![endif]--&gt; <br/>&lt;!--[if IE 7]&gt;    &lt;html class="no-js lt-ie9 lt-ie8" lang="en"&gt; &lt;![endif]--&gt; <br/>&lt;!--[if IE 8]&gt;    &lt;html class="no-js lt-ie9" lang="en"&gt; &lt;![endif]--&gt; <br/>&lt;!-- Consider adding a manifest.appcache: h5bp.com/d/Offline --&gt; <br/>&lt;!--[if gt IE 8]&gt;&lt;!--&gt; &lt;html class="no-js" lang="en"&gt; &lt;!--&lt;![endif]--&gt; <br/>&lt;head&gt; <br/>&lt;meta charset="utf-8" /&gt;<br/>&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; <br/>&lt;meta name="viewport" <br/>      content="width=device-width, initial-scale=1.0"/&gt; <br/>&lt;title&gt;Show Content&lt;/title&gt; <br/>&lt;meta name="foo" content="bar"/&gt; <br/>&lt;funky-bump&gt;&lt;/funky-bump&gt; <br/>&lt;ak-stylesheets&gt;&lt;/ak-stylesheets&gt; <br/>&lt;ak-headerJavaScript&gt;&lt;/ak-headerJavaScript&gt; <br/>&lt;rss-header-meta href="/rss-for-header.xml"&gt;&lt;/rss-header-meta&gt; <br/>&lt;external-stylesheet href="http://external.site/foo.css"&gt;&lt;/external-stylesheet&gt; <br/>&lt;dns-prefetch control="we must have control"    <br/>              dnslist="foo1.com,foo2.com,foo3.com"&gt;&lt;/dns-prefetch&gt; <br/>&lt;site-verification google="We are good"&gt;&lt;/site-verification&gt; <br/>&lt;xml-sitemap&gt;&lt;/xml-sitemap&gt; <br/>&lt;xml-sitemap href="/foo-bar-sitemap.xml"<br/>             title="Foo Bar Sitemap"&gt;&lt;/xml-sitemap&gt; <br/>&lt;/head&gt; <br/>&lt;body&gt; <br/>&lt;h1&gt;Show Content&lt;/h1&gt; <br/>&lt;section id="teaser"&gt;&lt;ak-teaser&gt;&lt;/ak-teaser&gt;&lt;/section&gt; <br/>&lt;article id="original"&gt;<br/>     &lt;div class="article-head"&gt;&lt;h2&gt;Article title&lt;/h2&gt;&lt;/div&gt;<br/>     &lt;show-content id="simple" <br/>                   href="/shown-content.html"&gt;&lt;/show-content&gt;<br/>     show-content id="dest" dest="http://dest.url" <br/>                  href="/shown-content.html"&gt;&lt;/show-content&gt;<br/>     &lt;show-content id="template"<br/>              template="ak_show-content-card.html.ejs"<br/>              href="/shown-content.html"<br/>              content-image="/imgz/shown-content-image.jpg"&gt;<br/>     Caption text<br/>     &lt;/show-content&gt;<br/>     &lt;p&gt;&lt;show-content id="template2"<br/>              template="ak_show-content-card.html.ejs"<br/>              href="/shown-content.html"<br/>             dest="http://dest.url"<br/>             content-image="/imgz/shown-content-image.jpg"&gt;<br/>     Caption text<br/>     &lt;/show-content&gt;&lt;/p&gt;<br/>&lt;/article&gt;<br/>&lt;ak-footerJavaScript&gt;&lt;/ak-footerJavaScript&gt; <br/>&lt;/body&gt; <br/>&lt;/html&gt;</span></pre><p id="10f3" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">你可以随意使用这个文件，或者任何你感兴趣的HTML文件。我自己当然对将这些定制标签转换成底层HTML的能力感兴趣。但这并不是唯一可能的应用，因为服务器端DOM操作的可能性是无限的。例如，可以在服务器上生成SVG文件，以便在浏览器中显示。</p><h1 id="bea4" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated">解析HTML文件，将其序列化为HTML</h1><p id="8419" class="pw-post-body-paragraph kv kw iu kx b ky mn jv la lb mo jy ld le mp lg lh li mq lk ll lm mr lo lp lq in bi translated">让我们从一个简单的例子开始，即将HTML读入DOM树，然后立即将其序列化为HTML。换句话说，在我们开始跑步之前，我们需要学习爬行。</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="607f" class="mw lw iu lu b gz mx my l mz na">import { default as htmlparser2, Parser } from "htmlparser2"; <br/>import { default as render } from "dom-serializer"; <br/>import { default as fs, promises as fsp } from 'fs';  <br/>const rawHtml = await fsp.readFile(process.argv[2], 'utf8');  <br/>const dom = htmlparser2.parseDocument(rawHtml);  <br/>console.log(dom);  <br/>const serilzd = render(dom);  <br/>console.log(serilzd);</span></pre><p id="fd1f" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这是用ES6模块格式写的。您可能会对这里的关键字<code class="fe lr ls lt lu b">await</code>感到困惑，但是从Node.js 14.x开始，在ES6模块的顶层使用await成为可能。要了解更多信息，请参见:<a class="ae nb" href="https://techsparx.com/nodejs/async/top-level-async.html" rel="noopener ugc nofollow" target="_blank"> Node.js脚本编写者:顶级异步/等待现已推出</a></p><p id="f5b1" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我们将文件读入内存，然后使用<code class="fe lr ls lt lu b">parseDocument</code>方法将其直接解析成DOM结构。</p><p id="0ef4" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><code class="fe lr ls lt lu b">htmlparser2</code>包是一个SAX风格的解析器，这意味着它会发出事件，记录它在传入文本中找到的语法元素。那些事件不是DOM对象树。相反，<code class="fe lr ls lt lu b">domhandler</code>包使用这些事件来产生一个DOM对象树。因此，<code class="fe lr ls lt lu b">parseDocument</code>方法必须在后台实例化<code class="fe lr ls lt lu b">domhandler</code>来实现。</p><p id="ea4f" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">接下来是<code class="fe lr ls lt lu b">render</code>功能。这需要一个由<code class="fe lr ls lt lu b">domhandler</code>生成的DOM树，并将其序列化为HTML</p><p id="2437" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">不幸的是，当我们运行这个脚本时，我们得到了一个错误:<code class="fe lr ls lt lu b">TypeError: render is not a function</code>。也就是说，虽然这个包是在TypeScript中实现的，但它明确针对CommonJS环境，在ES6上不能很好地工作。</p><p id="dd6b" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">因此我们必须把这个例子改写成这样:</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="8d4c" class="mw lw iu lu b gz mx my l mz na">const htmlparser2 = require('htmlparser2'); <br/>const render = require('dom-serializer').default; <br/>const fs = require('fs'); <br/>const fsp = require('fs').promises;  </span><span id="5e34" class="mw lw iu lu b gz nc my l mz na">(async () =&gt; {<br/>      const rawHtml = await fsp.readFile(process.argv[2], 'utf8');<br/>      const dom = htmlparser2.parseDocument(rawHtml);<br/>      console.log(dom);<br/>      const serilzd = render(dom);<br/>      console.log(serilzd);<br/>})().catch(err =&gt; {<br/>    console.error(err);<br/>});</span></pre><p id="0263" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这是相同的脚本，但是使用了CommonJS模块语法。因为我们不能使用顶级的<code class="fe lr ls lt lu b">await</code>，我们必须实现一个<code class="fe lr ls lt lu b">async</code>函数来运行脚本。</p><p id="b915" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">让我们确保您理解这些示例中使用的代码结构。它从一个匿名箭头函数开始:</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="69f1" class="mw lw iu lu b gz mx my l mz na">async () =&gt; { ... }</span></pre><p id="4753" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">围绕它的是一个函数调用:</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="5d2b" class="mw lw iu lu b gz mx my l mz na">(async () =&gt; { ... })()</span></pre><p id="37ab" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">匿名函数在括号内被实例化，然后立即被调用。如果你想传入参数，应该是这样的:</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="a032" class="mw lw iu lu b gz mx my l mz na">(async (fileName) =&gt; {<br/>    const rawHtml = await fsp.readFile(fileName, 'utf8');<br/>    ...<br/>})(process.argv[2])</span></pre><p id="16d6" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这个程序本身只是将HTML解析成DOM，然后立即打印出来。您的输出应该等同于输入文件。可能会有细微的差别，但是HTML的本质允许以多种方式表示同一个数据结构。重要的是输出和输入在语义上是否相同。</p><h1 id="7822" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated">从HTML输入产生XHTML输出</h1><p id="4411" class="pw-post-body-paragraph kv kw iu kx b ky mn jv la lb mo jy ld le mp lg lh li mq lk ll lm mr lo lp lq in bi translated">如果您的用例是将HTML转换成XHTML，那该怎么办？通过对脚本的微小调整，我们生成了XHTML。</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="acdf" class="mw lw iu lu b gz mx my l mz na">const serilzd = render(dom, {<br/>     xmlMode: true <br/>});</span></pre><p id="9bf1" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这将序列化更改为XML模式，也称为XHTML。</p><p id="8723" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在这种情况下，你会发现许多变化。例如，<code class="fe lr ls lt lu b">&lt;meta&gt;</code>标签现在有一个结束斜杠，使它们成为<code class="fe lr ls lt lu b">&lt;meta/&gt;</code>，而有结束标记(<code class="fe lr ls lt lu b">&lt;tag&gt;&lt;/tag&gt;</code>)的标签现在是一个单独的标签(<code class="fe lr ls lt lu b">&lt;tag/&gt;</code>)。</p><h1 id="9e05" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated">使用CSS-Select查找DOM元素</h1><p id="b4c2" class="pw-post-body-paragraph kv kw iu kx b ky mn jv la lb mo jy ld le mp lg lh li mq lk ll lm mr lo lp lq in bi translated">一个典型的任务是使用“选择器”在DOM中搜索一个项目，以提取一些数据或操作DOM。在HTMLParser2世界中，<code class="fe lr ls lt lu b">css-select</code>包实现了一个从CSS4和jQuery派生的选择器语法。</p><p id="b69a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">它不提供任何DOM操作，只提供基于选择器选择DOM节点的能力。</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="a9c9" class="mw lw iu lu b gz mx my l mz na">// Demonstrate CSS selectors to extract data from XML or HTML  <br/>const htmlparser2 = require('htmlparser2'); <br/>const render = require('dom-serializer').default; <br/>const CSSselect = require("css-select"); <br/>const fs = require('fs'); <br/>const fsp = require('fs').promises; <br/>const util = require('util');  </span><span id="0287" class="mw lw iu lu b gz nc my l mz na">(async () =&gt; {<br/>      const rawHtml = await fsp.readFile(process.argv[2], 'utf8');<br/>      const dom = htmlparser2.parseDocument(rawHtml);<br/>      for (let h1 of CSSselect.selectAll('h1', dom)) {<br/>         console.log(`h1 ${render(h1)}`);<br/>      }<br/>      for (let articleHead of <br/>             CSSselect.selectAll('article .article-head', dom)) {<br/>         console.log(`articleHead ${render(articleHead)}`);<br/>      }<br/>      for (let articleHead of <br/>             CSSselect.selectAll('article .article-head h1,h2,h3,h4,h5,h6', dom)) {<br/>         console.log(`articleHead Hn ${render(articleHead)}`);<br/>      }<br/>      console.log(CSSselect.selectAll(<br/>                      'article .article-head', dom));  <br/>})().catch(err =&gt; {<br/>     console.error(err);<br/>});</span></pre><p id="5381" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这个例子显示了使用<code class="fe lr ls lt lu b">CSSselect.selectAll</code>选择所有匹配选择器的元素，然后打印所选元素的HTML。最后一个用法打印原始的DOM数据结构，这样我们可以熟悉一下<code class="fe lr ls lt lu b">domhandler</code>生成的DOM数据结构。</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="36e3" class="mw lw iu lu b gz mx my l mz na">$ node css-selector.js example1.html <br/>h1 &lt;h1&gt;Show Content&lt;/h1&gt;<br/>articleHead &lt;div class="article-head"&gt;&lt;h2&gt;Article title&lt;/h2&gt;&lt;/div&gt;<br/>articleHead Hn &lt;h2&gt;Article title&lt;/h2&gt;<br/>[<br/>  &lt;ref *1&gt; Element {<br/>    type: 'tag',<br/>    parent: Element {<br/>      type: 'tag',<br/>      parent: [Element],<br/>      prev: [Text],<br/>      next: [Text],<br/>      startIndex: null,<br/>      endIndex: null,<br/>      children: [Array],<br/>      name: 'article',<br/>      attribs: [Object]<br/>    },<br/>    prev: Text {<br/>      type: 'text',<br/>      parent: [Element],<br/>      prev: null,<br/>      next: [Circular *1],<br/>      startIndex: null,<br/>      endIndex: null,<br/>      data: '\n    '<br/>    },<br/>    next: Text {<br/>      type: 'text',<br/>      parent: [Element],<br/>      prev: [Circular *1],<br/>      next: [Element],<br/>      startIndex: null,<br/>      endIndex: null,<br/>      data: '\n    '<br/>    },<br/>    startIndex: null,<br/>    endIndex: null,<br/>    children: [ [Element] ],<br/>    name: 'div',<br/>    attribs: { class: 'article-head' }<br/>  }<br/>]</span></pre><p id="9662" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">输出中的前三行显示了选择器找到的HTML。我们通过使用<code class="fe lr ls lt lu b">render</code>函数运行所选的DOM子树，得到该子树的HTML代码片段。</p><p id="d1f2" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">对DOM中选择的元素使用<code class="fe lr ls lt lu b">render</code>将序列化所选元素下的DOM节点。</p><p id="dfb0" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">最后一个显示了从这个方法返回的实际DOM数据。因为它是<code class="fe lr ls lt lu b">selectAll</code>，所以它返回一个匹配的数组。这个数组有一个对象，一个<code class="fe lr ls lt lu b">Element</code>实例。它有类型<code class="fe lr ls lt lu b">tag</code>，标签名为<code class="fe lr ls lt lu b">div</code>，有一个包含<code class="fe lr ls lt lu b">article-head</code>的<code class="fe lr ls lt lu b">class</code>属性的<code class="fe lr ls lt lu b">attribs</code>数组，所有这些都与文档中的HTML相匹配。<code class="fe lr ls lt lu b">children</code>元素是一个包含该元素的DOM对象数组。有<code class="fe lr ls lt lu b">parent</code>、<code class="fe lr ls lt lu b">prev</code>和<code class="fe lr ls lt lu b">next</code>对象，这样任何接收到这个DOM对象的人都可以遍历树。</p><p id="fccc" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">回头参考我们实现的代码。虽然循环结构相当简单，但不如等价的jQuery代码简洁。但是，请注意，<code class="fe lr ls lt lu b">selectAll</code>方法返回一个数组。这意味着该示例的内部部分可以这样实现:</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="f8cf" class="mw lw iu lu b gz mx my l mz na">CSSselect.selectAll('h1', dom).forEach(h1 =&gt; {<br/>     console.log(`h1 ${render(h1)}`); <br/>});<br/>CSSselect.selectAll('article .article-head', dom) <br/>                  .forEach(articleHead =&gt; {<br/>     console.log(`articleHead ${render(articleHead)}`); <br/>});<br/>CSSselect.selectAll('article .article-head h1,h2,h3,h4,h5,h6', dom) <br/>                  .forEach(articleHead =&gt; {<br/>     console.log(`articleHead Hn ${render(articleHead)}`); <br/>});</span></pre><p id="dfe4" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这使用了<code class="fe lr ls lt lu b">Array.forEach</code>方法，更接近于等效的jQuery代码。这意味着我们可以使用其他操作，如<code class="fe lr ls lt lu b">Array.map</code>或<code class="fe lr ls lt lu b">Array.filter</code>方法。</p><h1 id="cf12" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated">使用DOMUtils操作DOM</h1><p id="8cee" class="pw-post-body-paragraph kv kw iu kx b ky mn jv la lb mo jy ld le mp lg lh li mq lk ll lm mr lo lp lq in bi translated">接下来，让我们做一点DOM操作。在这个HTML文档中，你可以看到几个定制的HTML标签。让我们实现代码来将定制标签转换成正确的HTML。</p><p id="ca3f" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">为此，我们将使用CSS-Select来选择要处理的DOM元素，然后使用DOMUtils包中的函数来处理这些元素。</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="f9c8" class="mw lw iu lu b gz mx my l mz na">const htmlparser2 = require('htmlparser2'); <br/>const domhandler = require('domhandler'); <br/>const domutils = require('domutils'); <br/>const render = require('dom-serializer').default; <br/>const CSSselect = require("css-select"); <br/>const fs = require('fs'); <br/>const fsp = require('fs').promises; <br/>const util = require('util');  </span><span id="90a0" class="mw lw iu lu b gz nc my l mz na">(async () =&gt; {<br/>      const rawHtml = await fsp.readFile(process.argv[2], 'utf8');<br/>      const dom = htmlparser2.parseDocument(rawHtml);</span><span id="e68f" class="mw lw iu lu b gz nc my l mz na">      for (let fb of CSSselect.selectAll('funky-bump', dom)) {<br/>         domutils.removeElement(fb);<br/>      }<br/>      for (let sm of CSSselect.selectAll('xml-sitemap', dom)) {<br/>         // console.log(sm);<br/>         if (sm.attribs.href) {<br/>             const template = <br/>               '&lt;link rel="sitemap" type="application/xml" href=""/&gt;';<br/>             const link = htmlparser2.parseDocument(template);<br/>             const links = CSSselect.selectAll('link', link);<br/>             links[0].attribs.href = sm.attribs.href;<br/>             // console.log(`sitemap link ${render(link)}`);<br/>             domutils.replaceElement(sm, link);<br/>         } else {<br/>             domutils.removeElement(sm);<br/>         }<br/>      }<br/>      const serilzd = render(dom);<br/>      console.log(serilzd);<br/>})().catch(err =&gt; {<br/>      console.error(err); <br/>});</span></pre><p id="7943" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">第一个循环寻找<code class="fe lr ls lt lu b">&lt;funky-bump&gt;</code>元素，并简单地删除标签。我添加这个标签是为了调试目的，它不需要显示在生产网站中。</p><p id="a7db" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">问问自己，将URL插入DOM元素的<code class="fe lr ls lt lu b">href</code>属性，然后再插入页面的DOM，最安全的方法是什么？请记住，HTML不是文本格式，而是表示为文本的数据结构。我的信念是，最好将HTML作为一种数据结构来操作，而不是通过文本替换。</p><p id="68e7" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">如果您使用JavaScript模板字符串，难道没有一系列可能的脚本注入攻击吗？我的意思是:</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="058a" class="mw lw iu lu b gz mx my l mz na">const replacement = `&lt;link rel="sitemap" type="application/xml" href="${sm.attribs.href}"/&gt;`;</span></pre><p id="c601" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">虽然这要简单得多，但它不是容易注入恶意URL吗？</p><p id="f5b2" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在这段代码的另一个分支中，如果没有提供<code class="fe lr ls lt lu b">href</code>，我们就使用<code class="fe lr ls lt lu b">removeElement</code>。</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="ae16" class="mw lw iu lu b gz mx my l mz na">$ node manipulate.js example1.html <br/>&lt;!doctype html&gt;<br/>     ... <br/>&lt;head&gt; <br/>&lt;meta charset="utf-8"&gt;<br/>&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt; <br/>&lt;meta name="viewport" <br/>      content="width=device-width, initial-scale=1.0"&gt; <br/>&lt;title&gt;Show Content&lt;/title&gt; <br/>&lt;meta name="foo" content="bar"&gt;  <br/>&lt;ak-stylesheets&gt;&lt;/ak-stylesheets&gt; <br/>&lt;ak-headerjavascript&gt;&lt;/ak-headerjavascript&gt; <br/>&lt;rss-header-meta href="/rss-for-header.xml"&gt;&lt;/rss-header-meta&gt; <br/>&lt;external-stylesheet <br/>          href="http://external.site/foo.css"&gt;&lt;/external-stylesheet&gt; <br/>&lt;dns-prefetch control="we must have control"       <br/>          dnslist="foo1.com,foo2.com,foo3.com"&gt;&lt;/dns-prefetch&gt; <br/>&lt;site-verification google="We are good"&gt;&lt;/site-verification&gt;  <br/>&lt;link rel="sitemap" type="application/xml" href="/foo-bar-sitemap.xml"&gt; <br/>&lt;/head&gt; <br/>&lt;body&gt;<br/>     ... <br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="36fe" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">而且，这就是结果。与任何减速带一样，<code class="fe lr ls lt lu b">&lt;funky-bump&gt;</code>元素消失了。<code class="fe lr ls lt lu b">xml-sitemap</code>元素已被正确的<code class="fe lr ls lt lu b">&lt;link&gt;</code>标签替换。</p><p id="b316" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">还有更多的标签可以实现DOM操作，但是我们会看到如何进行。对于每个元素，我们处理提供的属性，然后使用<code class="fe lr ls lt lu b">replaceElement</code>用正确的HTML元素进行替换。</p><h1 id="564e" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated">在Node.js上使用Cheerio进行DOM操作</h1><p id="f57d" class="pw-post-body-paragraph kv kw iu kx b ky mn jv la lb mo jy ld le mp lg lh li mq lk ll lm mr lo lp lq in bi translated">DOMUtils让我们可以操纵DOM。但是，让我们看看它是如何与啦啦队相抗衡的。</p><p id="f9a3" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">安装:</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="f851" class="mw lw iu lu b gz mx my l mz na">$ npm install cheerio --save</span></pre><p id="af34" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在撰写本文时，安装了<code class="fe lr ls lt lu b">cheerio@1.0.0-rc.10</code>。顾名思义，Cheerio团队还是觉得不配叫<code class="fe lr ls lt lu b">1.0</code>。</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="3f98" class="mw lw iu lu b gz mx my l mz na">const cheerio = require('cheerio');<br/>const fs = require('fs');<br/>const fsp = require('fs').promises;<br/>const util = require('util');<br/><br/>(async () =&gt; {<br/><br/>    const rawHtml = await fsp.readFile(process.argv[2], 'utf8');<br/><br/>    // const dom = htmlparser2.parseDocument(rawHtml);<br/>    const $ = cheerio.load(rawHtml, {<br/>        _useHtmlParser2: true<br/>    });<br/>    $('funky-bump').remove();<br/>    for (let sm of $('xml-sitemap')) {<br/>        if (!$(sm).attr('href')) $(sm).remove();<br/>        else {<br/>            let $template = cheerio.load(<br/>                    '&lt;link rel="sitemap" type="application/xml" href=""/&gt;',<br/>                    null, false);<br/>            $template('link').attr('href', $(sm).attr('href'));<br/>            $(sm).replaceWith($template.html());<br/>        }<br/>    }<br/><br/>    console.log($.html());<br/>    // console.log($.root().html());<br/>})().catch(err =&gt; {<br/>    console.error(err);<br/>});</span></pre><p id="93fc" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这实现了与前一个例子相同的操作。由于类似jQuery的API，代码更加简洁。</p><p id="e9f4" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">因为我的示例HTML使用了非标准的定制HTML标记，所以使用Cheerio的默认设置存在问题。默认情况下，它使用HTML的<code class="fe lr ls lt lu b">parser5</code>包。该模式的默认设置是将<code class="fe lr ls lt lu b">&lt;head&gt;</code>中的定制标签移动到<code class="fe lr ls lt lu b">&lt;body&gt;</code>中。您可以通过注释掉<code class="fe lr ls lt lu b">_useHtmlParser2</code>选项来看到这一点。顾名思义，未记录的选项强制使用<code class="fe lr ls lt lu b">htmlparser2</code>，否则将使用<code class="fe lr ls lt lu b">parser5</code>。</p><p id="c3ac" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">使用<code class="fe lr ls lt lu b">htmlparser2</code>的方法是注释掉的代码行。但是，该版本会出现不可理解的错误消息。使用这个选项(通过仔细阅读源代码找到的)可以工作，产生与上一节相同的输出。</p><p id="b266" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">当创建<code class="fe lr ls lt lu b">$template</code>变量时，我们再次使用了<code class="fe lr ls lt lu b">cheerio.load</code>，就像我们在上一节中所做的一样。这个方法解析HTML并生成一个适合Cheerio使用的DOM树。<code class="fe lr ls lt lu b">null</code>和<code class="fe lr ls lt lu b">false</code>选项对于确保它被视为HTML片段是必要的。否则生成的DOM会被<code class="fe lr ls lt lu b">&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code>包装，这会导致不必要的行为。</p><p id="666e" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在Cheerio中，<code class="fe lr ls lt lu b">.html()</code>方法将DOM序列化为文本。记录了<code class="fe lr ls lt lu b">root</code>方法来访问文档的根。因此，使用第二种(注释掉的)方法将DOM序列化为文本似乎更正确，但是在这个例子中，<code class="fe lr ls lt lu b">$.html()</code>和<code class="fe lr ls lt lu b">$.root().html()</code>产生了相同的结果。</p><h1 id="8511" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated">处理RSS源</h1><p id="66f2" class="pw-post-body-paragraph kv kw iu kx b ky mn jv la lb mo jy ld le mp lg lh li mq lk ll lm mr lo lp lq in bi translated">HTMLParser2包包含用于解析RSS或Atom提要的内置模式。让我们用RSS提要来旋转一下。</p><p id="0ab3" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">让我们从获取提要开始。</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="1b6f" class="mw lw iu lu b gz mx my l mz na">$ wget <a class="ae nb" href="https://akashacms.com/news/rss.xml" rel="noopener ugc nofollow" target="_blank">https://akashacms.com/news/rss.xml</a></span></pre><p id="6fe6" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">有一整个世界的RSS源，你不必选择这个。</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="2076" class="mw lw iu lu b gz mx my l mz na">const htmlparser2 = require('htmlparser2'); <br/>const fs = require('fs'); <br/>const fsp = require('fs').promises;  </span><span id="ab37" class="mw lw iu lu b gz nc my l mz na">(async () =&gt; {<br/>      const rawRSS = await fsp.readFile(process.argv[2], 'utf8');<br/>      const feed = htmlparser2.parseFeed(rawRSS, {});<br/>      console.log(feed);<br/>})().catch(err =&gt; {<br/>      console.error(err); <br/>});</span></pre><p id="95f1" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">Node.js提供了大量的RSS和Atom解析包，这很容易使用。</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="bb85" class="mw lw iu lu b gz mx my l mz na">$ node feed1.js rss.xml<br/>{<br/>  type: 'rss',<br/>  id: '',<br/>  items: [<br/>    {<br/>      media: [],<br/>      id: 'https://akashacms.com/news/2021/06/stacked-dirs.html',<br/>      title: '&lt;![CDATA[Stacked Directories - A directory/file watcher for static website generators]]&gt;'<br/>    },<br/>    {<br/>      media: [],<br/>      id: 'https://akashacms.com/news/2021/05/gridjs.html',<br/>      title: '&lt;![CDATA[Using GridJS for fancy searchable HTML tables on statically generated websites]]&gt;'<br/>    },<br/>   ...<br/>  ]<br/>}</span></pre><p id="3c69" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这很简单，但是你可能会问<code class="fe lr ls lt lu b">&lt;![CDATA[...]]&gt;</code>是什么。这是一个叫做CDATA的HTML结构，它很大程度上是透明的。它恰好在AkashaCMS生成的RSS提要中:</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="c566" class="mw lw iu lu b gz mx my l mz na">&lt;title&gt;&lt;![CDATA[Stacked Directories - A directory/file watcher for static website generators]]&gt;&lt;/title&gt;</span></pre><p id="4894" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">如果我们添加一些选项，像这样:</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="85e7" class="mw lw iu lu b gz mx my l mz na">const feed = htmlparser2.parseFeed(rawRSS, {<br/>  recognizeCDATA: true,<br/>  decodeEntities: true,<br/>  recognizeSelfClosing: true <br/>});</span></pre><p id="3a8c" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">那么输出会提高:</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="d898" class="mw lw iu lu b gz mx my l mz na">items:<br/>  [<br/>    {<br/>      media: [],<br/>      id: 'https://akashacms.com/news/2021/06/stacked-dirs.html',<br/>      title: '&lt;![CDATA[Stacked Directories - A directory/file watcher for static website generators]]&gt;',<br/>      description: "It's very convenient when a ...." <br/>    },<br/>    {<br/>      media: [],<br/>      id: 'https://akashacms.com/news/2021/05/gridjs.html',<br/>      title: '&lt;![CDATA[Using GridJS for fancy searchable HTML tables on statically generated websites]]&gt;',<br/>      description: "There's a wide variety of ...." <br/>    }<br/>    ...<br/>  ]</span></pre><p id="a31b" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">描述现在显示出来了，它没有CDATA标记。但是CDATA结构仍然存在。这可以通过手动编辑XML从RSS提要中删除CDATA结构来从输出中删除。</p><p id="3724" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">HTMLParser2文档实际上建议使用其他RSS提要处理器包。但是，这个例子让我们体验了使用HTMLParser2不仅操作HTML，还操作XML文件。</p><h1 id="4b20" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated">XML文件处理</h1><p id="c863" class="pw-post-body-paragraph kv kw iu kx b ky mn jv la lb mo jy ld le mp lg lh li mq lk ll lm mr lo lp lq in bi translated">在上一节中，我们使用<code class="fe lr ls lt lu b">htmlparser2</code>中的专用函数处理了一个XML文件，特别是一个RSS提要。但是，这个包可以用于一般的XML操作。</p><p id="dc3a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">让我们从一个简单的XML文件开始:</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="2883" class="mw lw iu lu b gz mx my l mz na">&lt;data&gt;<br/>     &lt;hello&gt;World&lt;/hello&gt;<br/>     &lt;table&gt;<br/>         &lt;row id="1" brand="Tesla" mode="electric"/&gt;<br/>         &lt;row id="2" brand="Dodge" mode="gas guzzler"/&gt;<br/>         &lt;row id="3" brand="Ford"<br/>                     mode="multiple, possibly moving to electric"/&gt;<br/>         &lt;row id="4" brand="GM" <br/>                     mode="multiple, possibly moving to electric"/&gt;<br/>         &lt;row id="5" brand="VW"<br/>                     mode="forced move to electric after emissions fraud conviction"/&gt;<br/>     &lt;/table&gt; <br/>&lt;/data&gt;</span></pre><p id="fd09" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">FWIW，我在世界上的一些工作包括写关于电动汽车的新闻文章。</p><p id="538e" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">首先，让我们复制第一个读取文件并立即序列化它的示例:</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="49ad" class="mw lw iu lu b gz mx my l mz na">const htmlparser2 = require('htmlparser2'); <br/>const render = require('dom-serializer').default; <br/>const fs = require('fs'); <br/>const fsp = require('fs').promises; <br/>const util = require('util');  </span><span id="69e4" class="mw lw iu lu b gz nc my l mz na">(async () =&gt; {<br/>      const rawHtml = await fsp.readFile(process.argv[2], 'utf8');<br/>      const dom = htmlparser2.parseDocument(rawHtml, {<br/>         xml: true,<br/>         recognizeSelfClosing: true<br/>      });<br/>      const serilzd = render(dom);<br/>      console.log(serilzd);<br/>})().catch(err =&gt; {<br/>      console.error(err); <br/>});</span></pre><p id="ff1c" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这个例子是这样运行的:</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="e4a8" class="mw lw iu lu b gz mx my l mz na">$ node xml-simple.js data.xml<br/>  &lt;data&gt;<br/>     &lt;hello&gt;World&lt;/hello&gt;<br/>     &lt;table&gt;<br/>         &lt;row id="1" brand="Tesla" mode="electric"&gt;&lt;/row&gt;<br/>         &lt;row id="2" brand="Dodge" mode="gas guzzler"&gt;&lt;/row&gt;<br/>         &lt;row id="3" brand="Ford" mode="multiple, possibly moving to electric"&gt;&lt;/row&gt;<br/>         &lt;row id="4" brand="GM" mode="multiple, possibly moving to electric"&gt;&lt;/row&gt;<br/>         &lt;row id="5" brand="VW" mode="forced move to electric after emissions fraud conviction"&gt;&lt;/row&gt;<br/>     &lt;/table&gt; <br/>&lt;/data&gt;</span></pre><p id="a0c9" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">如你所见，输出等于输入。例如，自结束标签被转换成<code class="fe lr ls lt lu b">&lt;row&gt;&lt;/row&gt;</code>形式。但是，语义上是一样的。</p><p id="33b0" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">区别在于传递给<code class="fe lr ls lt lu b">parseDocument</code>的两个选项启用了XML模式和识别自结束标签。</p><p id="26d6" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">接下来，让我们使用带有XML的CSS-Select包:</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="e209" class="mw lw iu lu b gz mx my l mz na">const htmlparser2 = require('htmlparser2'); <br/>const render = require('dom-serializer').default; <br/>const CSSselect = require("css-select"); <br/>const fs = require('fs'); <br/>const fsp = require('fs').promises; <br/>const util = require('util');  </span><span id="bcd2" class="mw lw iu lu b gz nc my l mz na">(async () =&gt; {<br/>      const rawHtml = await fsp.readFile(process.argv[2], 'utf8');<br/>      const dom = htmlparser2.parseDocument(rawHtml, {<br/>         xml: true,<br/>         recognizeSelfClosing: true<br/>      });<br/>      for (let row of CSSselect.selectAll('row', dom)) {<br/>         console.log(`${row.attribs.brand} - ${row.attribs.mode}`);<br/>      }<br/>})().catch(err =&gt; {<br/>      console.error(err); <br/>});</span></pre><p id="d59d" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">运行方式如下:</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="b610" class="mw lw iu lu b gz mx my l mz na">$ node xml-table.js data.xml <br/>Tesla - electric <br/>Dodge - gas guzzler <br/>Ford - multiple, possibly moving to electric <br/>GM - multiple, possibly moving to electric <br/>VW - forced move to electric after emissions fraud conviction</span></pre><p id="1f3a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我们能够轻松地从XML文件中提取数据。</p><p id="ae20" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">最后，让我们尝试一点DOM操作。我们将删除<code class="fe lr ls lt lu b">&lt;hello&gt;</code>标签，然后给每个<code class="fe lr ls lt lu b">&lt;row&gt;</code>添加一个属性。</p><p id="9dd1" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这个程序是这样运行的:</p><pre class="kk kl km kn gu ms lu mt mu aw mv bi"><span id="79aa" class="mw lw iu lu b gz mx my l mz na">const htmlparser2 = require('htmlparser2'); <br/>const render = require('dom-serializer').default; <br/>const domutils = require('domutils'); <br/>const CSSselect = require("css-select"); <br/>const fs = require('fs'); <br/>const fsp = require('fs').promises; <br/>const util = require('util');  </span><span id="8369" class="mw lw iu lu b gz nc my l mz na">(async () =&gt; {<br/>      const rawHtml = await fsp.readFile(process.argv[2], 'utf8');<br/>      const dom = htmlparser2.parseDocument(rawHtml, {<br/>         xml: true,<br/>         recognizeSelfClosing: true<br/>      });<br/>      for (let row of CSSselect.selectAll('row', dom)) {<br/>         row.attribs.seen = "yes";<br/>      }<br/>      for (let hello of CSSselect.selectAll('hello', dom)) {<br/>         domutils.removeElement(hello);<br/>      }<br/>      const serilzd = render(dom);<br/>      console.log(serilzd);<br/>})().catch(err =&gt; {<br/>      console.error(err); <br/>});</span></pre><p id="554e" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这个例子使用了我们前面讨论过的相同的DOMUtils函数。我们看到，我们用来修改HTML DOM的工具也适用于XML DOM。</p><h1 id="feb9" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated">摘要</h1><p id="2139" class="pw-post-body-paragraph kv kw iu kx b ky mn jv la lb mo jy ld le mp lg lh li mq lk ll lm mr lo lp lq in bi translated">有很多Node.js包可以用来处理HTML、XML甚至RSS提要。我们在这里所做的是探索这些包的一个集群。这为我们使用这些包读取XML/HTML文件、提取数据或操纵它们的结构提供了一个良好的起点和基础。</p><p id="f8ce" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">但是关于软件包提供的API是否比jQuery和Cheerio更容易使用的问题呢？</p><p id="e539" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">使用DOMUtils和CSS-Select不如使用jQuery API简洁。但是这已经很接近了，尤其是在与普通的JavaScript编程特性相结合的情况下。可以说，这样访问和更改属性更容易，因为它使用普通的JavaScript对象访问和赋值操作符，而不是像在jQuery中那样使用<code class="fe lr ls lt lu b">attr</code>函数。</p><p id="0e19" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我们没有做全面的比较来看Cheerio/jQuery或者DOMUtils等人是否提供了更多的API函数。我们可以看到，这些包提供了或多或少相同的功能，优势是更接近DOM API标准，并且能够用普通的JavaScript代码直接操作DOM对象。</p><h1 id="e0cf" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated">链接</h1><p id="62da" class="pw-post-body-paragraph kv kw iu kx b ky mn jv la lb mo jy ld le mp lg lh li mq lk ll lm mr lo lp lq in bi translated"><strong class="kx iv"> HTMLParser2 </strong></p><ul class=""><li id="195a" class="nd ne iu kx b ky kz lb lc le nf li ng lm nh lq ni nj nk nl bi translated"><a class="ae nb" href="https://www.npmjs.com/package/htmlparser2" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/htmlparser2</a></li><li id="02c9" class="nd ne iu kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated"><a class="ae nb" href="https://feedic.com/htmlparser2/" rel="noopener ugc nofollow" target="_blank">https://feedic.com/htmlparser2/</a></li></ul><p id="3ea9" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv"> DOMHandler </strong></p><ul class=""><li id="e16a" class="nd ne iu kx b ky kz lb lc le nf li ng lm nh lq ni nj nk nl bi translated">【https://www.npmjs.com/package/domhandler T4】</li><li id="3402" class="nd ne iu kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated"><a class="ae nb" href="https://github.com/fb55/domhandler" rel="noopener ugc nofollow" target="_blank">https://github.com/fb55/domhandler</a></li></ul><p id="76d1" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv"> DOMUtils </strong></p><ul class=""><li id="0ddd" class="nd ne iu kx b ky kz lb lc le nf li ng lm nh lq ni nj nk nl bi translated"><a class="ae nb" href="https://github.com/fb55/domutils" rel="noopener ugc nofollow" target="_blank">https://github.com/fb55/domutils</a></li><li id="6beb" class="nd ne iu kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated"><a class="ae nb" href="https://www.npmjs.com/package/domutils" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/domutils</a></li><li id="b13d" class="nd ne iu kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated"><a class="ae nb" href="https://domutils.js.org/" rel="noopener ugc nofollow" target="_blank">https://domutils.js.org/</a></li></ul><p id="e691" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv"> CSS选择</strong></p><ul class=""><li id="1409" class="nd ne iu kx b ky kz lb lc le nf li ng lm nh lq ni nj nk nl bi translated"><a class="ae nb" href="https://www.npmjs.com/package/css-select" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/css-select</a></li><li id="88df" class="nd ne iu kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated"><a class="ae nb" href="https://github.com/fb55/css-select" rel="noopener ugc nofollow" target="_blank">https://github.com/fb55/css-select</a></li><li id="9c0c" class="nd ne iu kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated"><a class="ae nb" href="https://feedic.com/css-select/" rel="noopener ugc nofollow" target="_blank">https://feedic.com/css-select/</a></li></ul><p id="054a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv"> DOM序列化器</strong></p><ul class=""><li id="513c" class="nd ne iu kx b ky kz lb lc le nf li ng lm nh lq ni nj nk nl bi translated"><a class="ae nb" href="https://www.npmjs.com/package/dom-serializer" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/dom-serializer</a></li><li id="d3ad" class="nd ne iu kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated"><a class="ae nb" href="https://github.com/cheeriojs/dom-serializer" rel="noopener ugc nofollow" target="_blank">https://github.com/cheeriojs/dom-serializer</a></li></ul><h1 id="2337" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated">关于作者</h1><p id="5ed5" class="pw-post-body-paragraph kv kw iu kx b ky mn jv la lb mo jy ld le mp lg lh li mq lk ll lm mr lo lp lq in bi translated"><a class="ae nb" href="https://davidherron.com" rel="noopener ugc nofollow" target="_blank"> <strong class="kx iv"> <em class="nr">大卫·赫伦</em> </strong> </a> <em class="nr">:大卫·赫伦是一名作家和软件工程师，专注于技术的明智使用。他对太阳能、风能和电动汽车等清洁能源技术特别感兴趣。David在硅谷从事了近30年的软件工作，从电子邮件系统到视频流，再到Java编程语言，他已经出版了几本关于Node.js编程和电动汽车的书籍。了解更多请访问</em><a class="ae nb" href="https://davidherron.com" rel="noopener ugc nofollow" target="_blank"><em class="nr"/></a></p><p id="ec24" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">【https://techsparx.com】最初发表于<a class="ae nb" href="https://techsparx.com/nodejs/web/htmlparser2.html" rel="noopener ugc nofollow" target="_blank"><em class="nr"/></a><em class="nr">。</em></p></div></div>    
</body>
</html>