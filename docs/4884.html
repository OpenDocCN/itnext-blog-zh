<html>
<head>
<title>Recursively Clean Firestore FieldValue.delete()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归清理Firestore FieldValue.delete()</h1>
<blockquote>原文：<a href="https://itnext.io/recursively-clean-firestore-fieldvalue-delete-60b7dff00bf4?source=collection_archive---------3-----------------------#2020-10-15">https://itnext.io/recursively-clean-firestore-fieldvalue-delete-60b7dff00bf4?source=collection_archive---------3-----------------------#2020-10-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5647" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何递归地从你刚刚更新并存在内存中的文档对象中移除删除方法。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cda6f4def6e13c76606ea5360b2f5097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2lFmIJDlVr6D_q8iAchhxw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@thecreative_exchange?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的创意交流</a>拍摄</figcaption></figure><p id="3db3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天早上我必须改进我们在<a class="ae ky" href="https://deckdeckgo.com" rel="noopener ugc nofollow" target="_blank"> DeckDeckGo </a>中使用的一个函数，以便在持久化之后递归地清理对象。因为我目前很忙，但不想过多地忽视我的博客习惯，所以我认为这个小小的“黑客”将是一篇新博文的好主题🤗。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d6eb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">介绍</h1><p id="bbf4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当您使用<a class="ae ky" href="https://firebase.google.com/docs/firestore/" rel="noopener ugc nofollow" target="_blank">云Firestore </a>时，为了从文档中删除特定字段，您必须在更新文档时使用<code class="fe mz na nb nc b">FieldValue.delete()</code>方法(如<a class="ae ky" href="https://firebase.google.com/docs/firestore/manage-data/delete-data" rel="noopener ugc nofollow" target="_blank">文档</a>所示)。</p><p id="3780" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您的数据库包含如下所示的文档:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="1c13" class="nh md it nc b gy ni nj l nk nl">{<br/>  description: 'Hello World'<br/>}</span></pre><p id="abd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你必须使用上面的方法来删除它，因为将它设置为<code class="fe mz na nb nc b">null</code>不会删除属性，但是“仅仅”将它的值设置为<code class="fe mz na nb nc b">null</code>。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="24c0" class="nh md it nc b gy ni nj l nk nl">import * as firebase from 'firebase/app';<br/>import 'firebase/firestore';<br/><br/>const firestore = firebase.firestore();<br/><br/>const ref = firestore.collection('users').doc('david');</span><span id="6297" class="nh md it nc b gy nm nj l nk nl">const user = {<br/>  description: firebase.firestore.FieldValue.<em class="nn">delete</em>()<br/>};</span><span id="4cc3" class="nh md it nc b gy nm nj l nk nl">await ref.update(user);</span></pre><p id="3075" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这种方法，上述文档的例子在数据库中变成了<code class="fe mz na nb nc b">{}</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="43bc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">问题</h1><p id="4422" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这种方法非常有效，但是会导致一个问题。事实上，如果你在本地对象更新后不刷新它，它仍然会包含方法<code class="fe mz na nb nc b">FieldValue.delete()</code>，这并不反映它在数据库中的有效值。</p><p id="5191" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具体来说，在上面的例子中，如果我们将<code class="fe mz na nb nc b">user</code>输出到控制台，它的输出将如下所示。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="8e00" class="nh md it nc b gy ni nj l nk nl">{<br/>  description: n {h_: n}<br/>}</span></pre><p id="73fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果对象更新后仍在使用，特别是当它是一个状态时，这可能会导致应用程序中出现一些意外的行为。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="5605" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了克服这个问题，一个解决方案是显式地从Firestore获取最新更新的文档，如果您已经开发了一些轮询来获取信息，或者如果您正在使用诸如<a class="ae ky" href="https://github.com/angular/angularfire" rel="noopener ugc nofollow" target="_blank"> AngularFire </a>或<a class="ae ky" href="https://github.com/firebase/firebase-js-sdk/tree/master/packages/rxfire" rel="noopener ugc nofollow" target="_blank"> RxFire </a>之类的库，这也会自动发生。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6c96" class="nh md it nc b gy ni nj l nk nl">import * as firebase from 'firebase/app';<br/>import 'firebase/firestore';<br/><br/>const firestore = firebase.firestore();<br/><br/>const ref = firestore.collection('users').doc('david');</span><span id="1fef" class="nh md it nc b gy nm nj l nk nl">let user = {<br/>  description: firebase.firestore.FieldValue.<em class="nn">delete</em>()<br/>};</span><span id="fe86" class="nh md it nc b gy nm nj l nk nl">await ref.update(user);</span><span id="9e99" class="nh md it nc b gy nm nj l nk nl">user = ref.get();</span><span id="437c" class="nh md it nc b gy nm nj l nk nl">console.log(user); // {}</span></pre><p id="4955" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种解决方案的优点是让您的对象与数据库保持同步，但缺点是需要额外的查询。</p><p id="5c04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，当你使用<a class="ae ky" href="https://firebase.google.com/docs/firestore/" rel="noopener ugc nofollow" target="_blank"> Cloud Firestore </a>时，你会根据你执行的读取、写入和删除次数<a class="ae ky" href="https://cloud.google.com/firestore/pricing" rel="noopener ugc nofollow" target="_blank">付费。因此，根据其频率，多一个查询会导致更多的成本。</a></p><p id="e223" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么我想到了递归清理方法<code class="fe mz na nb nc b">FieldValue.delete()</code>，为什么我有了“黑客”的想法😎。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="16ce" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">解决办法</h1><p id="6624" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下面的函数<code class="fe mz na nb nc b">filterDelete</code>迭代一个对象的所有<code class="fe mz na nb nc b">keys</code>，并识别出那些必须被忽略的(<code class="fe mz na nb nc b">shouldAttributeBeCleaned</code>)，这些包含了方法<code class="fe mz na nb nc b">FieldValue.delete()</code>。</p><p id="c576" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有被忽略，那么它递归调用当前子节点的函数<code class="fe mz na nb nc b">filterDelete</code>，直到所有子节点都以同样的方式被处理。</p><p id="8ddb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，当缩减器用空对象<code class="fe mz na nb nc b">{}</code>初始化时，它还必须检查对象的有效值是否不为空，以便不将空叶子添加到累加器中。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="2177" class="nh md it nc b gy ni nj l nk nl">export function filterDelete&lt;T&gt;(obj: T): T {<br/>  if (typeof obj !== 'object' || Array.isArray(obj)) {<br/>    return obj;<br/>  }<br/><br/>  return Object.keys(obj)<br/>    .filter((key) =&gt; !shouldAttributeBeCleaned(obj[key]))<br/>    .reduce((res, key) =&gt; {<br/>      const value: T = filterDelete(obj[key]);<br/><br/>      if (value &amp;&amp; typeof value === 'object') {<br/>        if (Object.keys(value).length &gt; 0) {<br/>          res[key] = value;<br/>        }<br/>      } else {<br/>        res[key] = value;<br/>      }<br/><br/>      return res;<br/>    }, {} as T);<br/>}<br/><br/>function shouldAttributeBeCleaned&lt;T&gt;(attr: T): boolean {<br/>  if (typeof attr !== 'object' || Array.isArray(attr)) {<br/>    return false;<br/>  }<br/><br/>  return JSON.stringify(attr) === JSON.stringify(firebase.firestore.FieldValue.<em class="nn">delete</em>());<br/>}</span></pre><p id="2d00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多亏了这个函数，我能够实现与从数据库中获取更新文档完全相同的行为。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="aca5" class="nh md it nc b gy ni nj l nk nl">import * as firebase from 'firebase/app';<br/>import 'firebase/firestore';<br/><br/>const firestore = firebase.firestore();<br/><br/>const ref = firestore.collection('users').doc('david');</span><span id="3ea6" class="nh md it nc b gy nm nj l nk nl">let user = {<br/>  description: firebase.firestore.FieldValue.<em class="nn">delete</em>()<br/>};</span><span id="df5c" class="nh md it nc b gy nm nj l nk nl">await ref.update(user);</span><span id="6aed" class="nh md it nc b gy nm nj l nk nl">console.log(filterDelete(user)); // {}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fbac" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">限制</h1><p id="c571" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这种策略的主要限制是它依赖于<a class="ae ky" href="https://github.com/firebase/firebase-js-sdk" rel="noopener ugc nofollow" target="_blank"> Firebase </a>库。每次更新后，检查它是否仍然工作是值得的，因为方法<code class="fe mz na nb nc b">FieldValue.delete()</code>的检测可能必须在版本之间改变。我以前也遇到过这种情况，所以如果你想使用这个功能，一定要小心。</p><p id="3d88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您使用它，我还可以建议您特别注意更新和清理之间的错误处理，因为您可能希望避免本地对象的值不等于它们的数据库值(“不同步”)的情况。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b469" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="0f3a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可能会注意到上述解决方案中的一些潜在改进。DeckDeckGo是开源的，因此我将非常乐意得到您对此函数的<a class="ae ky" href="https://github.com/deckgo/deckdeckgo/blob/master/studio/src/app/utils/editor/firestore.utils.tsx" rel="noopener ugc nofollow" target="_blank">代码源的贡献。毕竟现在还是2020年的Hacktoberfest😎。</a></p><p id="c2a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到无限和更远的地方！</p><p id="acda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大卫</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="3398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Twitter上联系我，为什么不试试在T2的DeckDeckGo上做你的下一次演讲。</p><p id="b1c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将你的幻灯片作为渐进式网络应用程序部署在网上，甚至可以将你的幻灯片的源代码推送到GitHub。</p></div></div>    
</body>
</html>