<html>
<head>
<title>The concept of the right locator for Selenium WebDriver automated scripts.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Selenium WebDriver自动化脚本的正确定位器的概念。</h1>
<blockquote>原文：<a href="https://itnext.io/the-concept-of-the-right-locator-for-selenium-webdriver-automated-scripts-5b8c6bf528e5?source=collection_archive---------1-----------------------#2020-06-07">https://itnext.io/the-concept-of-the-right-locator-for-selenium-webdriver-automated-scripts-5b8c6bf528e5?source=collection_archive---------1-----------------------#2020-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fa69314028578db4d4802c7ac9363a9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0m1ZmQ8XicAtCUfL0EOIvg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">卡尔·海尔达尔在<a class="ae kc" href="https://unsplash.com/@carlheyerdahl?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a96a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您创建自动化测试，那么您可能会花费大量的自动化脚本开发时间来寻找页面上的元素，比如按钮和输入。然而，找到正确的web元素是很有挑战性的，尤其是当它们缺少惟一的id或类名时。例如角形框架。这个框架完美地方便了前端开发者的开发。然而，这使得自动化脚本开发人员的生活非常困难。问题是Angular创建的页面元素带有每次页面刷新后生成的标识符。这使得不可能使用它们来自动化测试。</p><p id="92ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我将尝试描述CSS和XPath定位器。两者有什么区别？哪个定位器“更好”或“更差”，哪个“更快”和“正确”。实际上，什么是“正确的”定位器，如何实现它，以及如何使用它？</p><p id="835a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有初露头角的自动化测试工程师我建议在阅读这篇文章之前先阅读和学习CSS和XPath (CSS和XPath)</p><p id="a364" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有这些知识，首先，你将很难理解它是关于什么的，其次，你将无法编写UI自动化脚本。</p><p id="d883" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Web元素是呈现在网页上的单个实体。用户在网页上看到的一切(甚至一些他看不到的东西)都是元素:标题、按钮、输入字段、文本区域。元素在HTML中由标记名、属性和内容指定。它们也可能有子元素，例如包含行的表。CSS可以应用于元素，用颜色、大小、位置等来设计它们的样式。编程语言通常将Web元素作为文档<strong class="kf ir">对象模型(DOM) </strong>中的节点来访问。</p><p id="0af5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Web元素和定位器是两回事。为什么需要定位器？作为人类用户，我们与网页进行视觉交互:我们通过浏览器查看、滚动、点击和输入。然而，测试自动化以编程的方式与Web页面进行交互:它需要一种编码的方式来查找和操作那些相同的元素。传统的自动化不会像人一样“看”页面，而是搜索DOM。Selenium WebDriver分离了元素位置和交互的关注点。WebDriver提供了以下定位器:</p><ul class=""><li id="455d" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">身份证明</li><li id="9f22" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">名字</li><li id="12c7" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">类别名</li><li id="066e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">CSS选择器</li><li id="6035" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">XPath</li></ul><p id="a4ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我有意排除了链接文本和部分链接文本。使用这些定位器被认为是不好的做法。页面上的文本可能会不断变化。此外，Selenium WebDriver中的这些定位器类型被标记为不推荐使用，可以在未来的版本中删除。</p><p id="d0f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你如何在网页上找到元素？为了简化，我使用谷歌的Chrome开发工具。要在Chrome中检查任何网页，只需在页面的任何地方点击F12。</p><p id="9217" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数课程、书籍和文章都说，能够编写正确的定位器是非常重要和必要的。在这种情况下，没有给出“正确的”定位器的概念，也没有明确的定义。</p><p id="dffd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看，比如，这些定位器哪个是对的？</p><p id="836b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">找到元素是成功的一半。形成唯一的定位器查询是另一半。如果定位器太宽泛，那么它可能会返回误报。然而，如果一个定位器太具体，那么每当DOM改变时，它就很容易被破坏，并且对其他人来说也很难阅读。最好的原则是:编写唯一标识目标元素的最简单的定位器查询。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="1321" class="ly lz iq lu b gy ma mb l mc md"><strong class="lu ir">CSS<br/></strong>article[class='post']<br/><strong class="lu ir">XPath</strong><br/><em class="me">//article[@class='post']</em></span></pre><p id="c80e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我个人认为第一种选择要好得多。为什么？他更简洁易读，更容易理解。</p><p id="71c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总的来说，说实话，我更喜欢用这个优先顺序:</p><ul class=""><li id="64b1" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">ID(如果唯一)</li><li id="61c0" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">名称(如果唯一)</li><li id="0cff" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">类别名</li><li id="732a" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">CSS选择器</li><li id="3e9a" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">没有文本或索引的XPath</li><li id="caae" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">带文本和/或索引的XPath</li></ul><p id="2fc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的大多数自动化脚本中。这就是为什么:</p><p id="29f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一的id、名称和类名使得定位器非常容易编写:查询很短，不需要额外的锚点。总是鼓励团队中的开发人员使用唯一的标识符，比如所有元素的类名。然而，许多元素没有它们，这意味着定位器必须依靠更复杂的CSS选择器和XPath。</p><p id="d595" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">层叠样式表(CSS) </strong>是一种样式表语言，用于描述以HTML等标记语言编写的文档的表示。</p><p id="1107" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当在CSS和XPath之间选择时，我更喜欢选择CSS。</p><p id="4585" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原因如下:</p><p id="e228" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1) CSS定位器可读性更强:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="9e58" class="ly lz iq lu b gy ma mb l mc md"><strong class="lu ir">CSS</strong><br/>div[id='sb_ifc0']<br/><strong class="lu ir">XPath</strong><br/><em class="me">//*[@id='sb_ifc0']</em></span></pre><p id="d69b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2)CSS更快。我将不再赘述，也不再举例分析。如果你非常关心和关注这个问题，需要关注链接<a class="ae kc" href="http://sidelnikovmike.blogspot.ru/2013/11/selenium-css-xpath.html" rel="noopener ugc nofollow" target="_blank"> Selenium — CSS还是XPath speed？</a></p><p id="1cf0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3)几乎所有的浏览器都实现了CSS引擎，这样开发者就可以在自己的项目中使用CSS表格。</p><p id="6017" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4) CSS不断更新(CSS2，CSS2.1，CSS3)。</p><p id="cb69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，CSS的缺点也是存在的:</p><ol class=""><li id="a185" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la mf lh li lj bi translated">我们只能深入DOM层次结构。</li><li id="a23f" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la mf lh li lj bi translated">您不能访问父节点。</li><li id="dab9" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la mf lh li lj bi translated">不能通过文本搜索元素。</li></ol><p id="1190" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">XPath(XML path)</strong>—XML文档元素的查询语言。为访问XSLT转换文件中的XML文档部分而设计的是标准联盟<br/> <a class="ae kc" href="https://www.w3.org/" rel="noopener ugc nofollow" target="_blank"> W3C </a>。由于许多浏览器都支持XHTML，所以我们可以使用XPath来查找网页上的元素。</p><ol class=""><li id="d080" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la mf lh li lj bi translated">XPath的速度不逊于(或略逊于)CSS。</li><li id="8879" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la mf lh li lj bi translated">因为XPath与编程语言非常相似。它清晰易读，有可能理解我们谈论的是什么元素。</li><li id="8482" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la mf lh li lj bi translated">使用XPath，由于建立了关系链，您可以访问页面中最隐藏的元素。</li><li id="2bce" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la mf lh li lj bi translated">XPath最重要的优点是我们可以在DOM层次结构中来回移动。这意味着使用XPath我们可以找到父元素和子元素。</li></ol><p id="45d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">我个人的观点是</strong> : CSS定位器更适合用在我的Selenium自动化脚本中。</p><p id="7199" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的定位器非常漂亮、简洁，可读性很强:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="88cb" class="ly lz iq lu b gy ma mb l mc md"><strong class="lu ir">CSS<br/></strong>div[class='_Rm']<br/><strong class="lu ir">XPath</strong><br/><em class="me">//*[@class='_Rm' and contains(text(),'www.seleniumhq.org')]</em></span></pre><p id="7478" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，错误和误报经常发生。Chrome DevTools让测试定位器变得容易，但它不是万能的。<br/>有时，当我不明白为什么定位器对自动化脚本不起作用时，我会做以下事情:</p><ol class=""><li id="efb4" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la mf lh li lj bi translated">从我的IDE调试运行测试用例。</li><li id="c6d7" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la mf lh li lj bi translated">在定位器上设置断点。等待测试用例在断点处停止。</li><li id="e0c6" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la mf lh li lj bi translated">在当前Chrome窗口中输入DevTools。</li><li id="af9a" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la mf lh li lj bi translated">检查DOM并测试活动页面上的定位器。</li></ol><p id="f692" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">片状测试。</strong></p><p id="34df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对我来说,“正确的”定位器是工作稳定、美观、简洁、可读性强的定位器。创建这样一个定位器所需的时间不超过10分钟。</p><h1 id="2158" class="mg lz iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">引入易变的测试缓解工具</h1><p id="b15d" class="pw-post-body-paragraph kd ke iq kf b kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated">这是一个新的<a class="ae kc" href="https://github.com/gradle/test-retry-gradle-plugin" rel="noopener ugc nofollow" target="_blank"> Gradle插件</a>并构建了扫描改进，旨在减轻你的古怪测试。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="3aab" class="ly lz iq lu b gy ma mb l mc md">plugins {<br/>    id 'org.gradle.test-retry' version '1.0.0'<br/>}<br/><br/>test {<br/>    retry {<br/>        failOnPassedAfterRetry = true<br/>        maxFailures = 42<br/>        maxRetries = 1<br/>    }<br/>}</span></pre></div></div>    
</body>
</html>