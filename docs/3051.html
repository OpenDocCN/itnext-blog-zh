<html>
<head>
<title>How to perfectly handle user-interactions with redux-saga</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用redux-saga完美处理用户交互</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-perfectly-handle-user-interactions-with-redux-saga-5e5944e3ed8b?source=collection_archive---------3-----------------------#2019-09-23">https://itnext.io/how-to-perfectly-handle-user-interactions-with-redux-saga-5e5944e3ed8b?source=collection_archive---------3-----------------------#2019-09-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e0bdf40fe1eb852442860fc7160d385a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JUcVPZPzBFuDHmOXKyj_JA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@ryoji__iwata?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">岩田良治</a>在<a class="ae kf" href="https://unsplash.com/s/photos/saga?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="59fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常，像redux-thunk或redux中间件这样的东西被用来处理redux动作触发的副作用，例如，redux动作可以由按钮点击触发。但是如果您需要处理像鼠标或滚动事件这样的用户交互呢？您是否会创建一个组件，将所有事件传输到redux存储循环中？</p><p id="cfbf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我不这么认为，这有一些常识性的限制。您必须以其他方式将这些事件传递给副作用处理逻辑。</p><p id="c5cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最简单的解决方案是使用<code class="fe le lf lg lh b">addEventListerner</code>并通过直接调用<code class="fe le lf lg lh b">store.dispatch</code>来分派动作，但是这并不理想。我们希望能够做异步的事情，节流/反跳，如果需要，等待其他行动，自由订阅/取消订阅事件。</p><p id="237d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我相信有很多方法可以做到这一点，但今天我想谈谈redux-saga的方法，以及如何使用它来处理redux之外触发的副作用。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h2 id="6828" class="lp lq it bd lr ls lt dn lu lv lw dp lx kr ly lz ma kv mb mc md kz me mf mg mh bi translated">向传奇传递事件</h2><p id="d515" class="pw-post-body-paragraph kg kh it ki b kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">将事件传递到另一个模块或组件的好方法是什么？</p><p id="f29d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们希望控制saga之外的订阅/退订，以减少逻辑并保持整洁。此外，我们可能想分享传奇之间的事件。听起来我们应该为此使用<a class="ae kf" href="https://www.wikiwand.com/en/Stream_(computing)" rel="noopener ugc nofollow" target="_blank">流</a>！</p><p id="d527" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">流很容易映射、减少、节流或去抖，并作为参数传递，这很好。此外，创建DOM事件流也很容易。</p><p id="7fee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好的，很好，接下来我们需要用streams制作一个传奇作品。为了处理动作，有一组<code class="fe le lf lg lh b">take</code>效果<a class="ae kf" href="https://redux-saga.js.org/docs/api/#takepattern" rel="noopener ugc nofollow" target="_blank">可用</a>，它们接收模式或通道。</p><p id="45a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">模式是像动作类型或<code class="fe le lf lg lh b">"*"</code>(对于所有动作)这样的字符串，或者这样的字符串的数组。<a class="ae kf" href="https://redux-saga.js.org/docs/api/#channel" rel="noopener ugc nofollow" target="_blank"> Channel </a>是saga用来在任务间发送和接收消息的对象，队列中的消息一直存在，直到第一个感兴趣的接收者请求它，这与streams有点不同，streams不存储消息，如果没有接收者或相同的消息可以被多个接收者接收，则消息将无处可去。</p><p id="77d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们可以使用通道作为媒介，将事件从一个流传递到一个传奇的生效中。这很简单:</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/271a8ecbe9bd66b47051b0921e3eb1a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sjKMu2Qmn0ATR6f0vuE9hg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><code class="fe le lf lg lh b">toChannel(stream, limit)</code>功能</figcaption></figure><p id="e98f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们可以简单地从DOM事件中创建一个通道时，为什么还要创建一个流，然后将它转换成通道呢？这是一个很好的问题，我想说这使得事情在未来变得不那么复杂。</p><p id="bd52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一般来说，你不希望一个频道有多个接收器(除非在极少数情况下，你真的需要它)。所以他们通常在提供生效之前创建，对于每一个新的效果应该创建一个新的通道，否则，消息不会被传递到每个<code class="fe le lf lg lh b">take</code>效果任务，而只会传递到第一个准备好接受消息的。因此，拥有一个流(可以很容易地被复制、映射、简化成另一个流)和<code class="fe le lf lg lh b">toChannel</code>函数看起来更方便，而不是为每个新创建的通道编写逻辑。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h2 id="5e65" class="lp lq it bd lr ls lt dn lu lv lw dp lx kr ly lz ma kv mb mc md kz me mf mg mh bi translated">传奇故事</h2><p id="e604" class="pw-post-body-paragraph kg kh it ki b kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">看起来一切准备就绪，可以开始处理交互了。</p><p id="6638" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">举个例子，如果鼠标在一段时间内没有活动，我们需要触发一个动作，让我们来处理这种情况。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ms"><img src="../Images/8d5aa84dfde0ae7e130b5f2e10fa1a32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XisqOSkAfgz2BpMjazwU-w.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">活动跟踪传奇</figcaption></figure><p id="df09" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Saga显得很单薄，5行代码，大多是鼠标事件和redux store之间的胶水。但我喜欢的是，我们只是将激烈的全局事件源转换为简单的redux store动作，而不必再定义一个根组件，将许多动作分派到redux store中，并在中间件中过滤它们。</p><p id="464c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面对一个传奇的最初描述听起来很有趣，可能不太容易实现，但是redux-saga + streams将它变成了一个简单但有些无聊的任务。</p><p id="535f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这太棒了！</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h2 id="6e6d" class="lp lq it bd lr ls lt dn lu lv lw dp lx kr ly lz ma kv mb mc md kz me mf mg mh bi translated">结论</h2><p id="24e8" class="pw-post-body-paragraph kg kh it ki b kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">在sagas中使用流可能听起来与复杂抽象的简化相反，但事实上，它只需要一点时间来适应，并以巨大的能力处理交互，这可以与一个结构更好的redux商店结合，以构建优秀和高性能的客户端应用程序。</p></div></div>    
</body>
</html>