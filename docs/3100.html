<html>
<head>
<title>Introduction to Stateful Services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有状态服务简介</h1>
<blockquote>原文：<a href="https://itnext.io/introduction-to-stateful-services-kubernetes-6018fd99338d?source=collection_archive---------3-----------------------#2019-10-03">https://itnext.io/introduction-to-stateful-services-kubernetes-6018fd99338d?source=collection_archive---------3-----------------------#2019-10-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b1ecf00053a6edb82504ecf3e5d3eec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZR-rR9sCTRgQHONbxzZSCQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Kubernetes标志</figcaption></figure></div><div class="ab cl kf kg hx kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="im in io ip iq"><p id="8261" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi lk translated">ubernetes是一个容器编排工具，用于扩展、部署和管理容器化的应用程序。这些是Kubernetes中部署pod的方法:ReplicaSet、Deployments、StatefulSets和DeamonSet。</p><p id="6db1" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">一个问题出现了，为什么我们需要有状态集合？ </p><p id="cdfe" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">在写这篇博客的时候，我假设你熟悉Kubernetes的基础知识。而且，您以前知道容器、pod、持久性卷等术语的含义。</p><h1 id="efa6" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">状态集</h1><p id="8745" class="pw-post-body-paragraph km kn it ko b kp ms kr ks kt mt kv kw kx mu kz la lb mv ld le lf mw lh li lj im bi translated">ReplicaSet、Deployments和DaemonSet可以与无状态应用程序无缝协作，但它们不适合有状态应用程序，如MySQL、Kafka等。这就是StatefulSets发挥作用的地方。想象一个场景，你想按顺序部署你的容器，这是可能的。这个博客是关于有状态集合的，因为我们正在讨论有状态应用程序。</p><p id="9d1c" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">Kubernetes中的StatefulSets用于有状态应用程序。状态集中的pod使用唯一的身份和稳定的主机名来命名。它将状态信息和其他弹性数据存储在永久卷中。这个持久卷附加到基于云的存储。它将负责维护应用程序的状态。</p><p id="19e5" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">StatefulSet上下文中的持久卷声明，因此当创建StatefulSet和每个副本时，Kubernetes将继续为StatefulSet中的每个副本创建不同的磁盘。</p><p id="4389" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">现在，当Kubernetes开始的时候，你能做复制的唯一方法是使用一个复制集。有了副本集，每个副本都被完全相同地对待。他们在应用程序名称的末尾有随机散列。如果发生缩放事件，例如缩小，则随机选择一个容器并删除。这些特征使得ReplicaSet很难映射到有状态的应用程序。许多有状态的应用程序希望它们的主机名保持不变。因此，使用复制集和有状态应用程序的复杂性导致了有状态集的最终发展。Kubernetes中的StatefulSets类似于ReplicaSet，但是它增加了一些保证，使得在Kubernetes内部管理有状态应用程序更加容易。</p></div><div class="ab cl kf kg hx kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="im in io ip iq"><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="3742" class="ng lv it nc b gy nh ni l nj nk">apiVersion: apps/v1<br/>kind: StatefulSet<br/>metadata:<br/>  name: mysql<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: mysql<br/>  serviceName: mysql<br/>  replicas: 3<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: mysql<br/>    spec:<br/>      initContainers:<br/>      - name: init-mysql<br/>        image: mysql:5.7<br/>        command:<br/>        - bash<br/>        - "-c"<br/>        - <em class="lt">|<br/>          set -ex<br/>          # Generate mysql server-id from pod ordinal index.<br/>          [[ `hostname` =~ -([0-9]+)$ ]] || exit 1<br/>          ordinal=${BASH_REMATCH[1]}<br/>          echo [mysqld] &gt; /mnt/conf.d/server-id.cnf<br/>          # Add an offset to avoid reserved server-id=0 value.<br/>          echo server-id=$((100 + $ordinal)) &gt;&gt; /mnt/conf.d/server-id.cnf<br/>          # Copy appropriate conf.d files from config-map to emptyDir.<br/>          if [[ $ordinal -eq 0 ]]; then<br/>            cp /mnt/config-map/master.cnf /mnt/conf.d/<br/>          else<br/>            cp /mnt/config-map/slave.cnf /mnt/conf.d/<br/>          fi</em><br/>        volumeMounts:<br/>        - name: conf<br/>          mountPath: /mnt/conf.d<br/>        - name: config-map<br/>          mountPath: /mnt/config-map<br/>  volumeClaimTemplates:<br/>  - metadata:<br/>      name: data<br/>    spec:<br/>      accessModes: ["ReadWriteOnce"]<br/>      resources:<br/>        requests:<br/>          storage: 10Gi</span></pre><p id="73d2" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">stateful set的工作方式类似于部署，但是在stateful set中，容器的部署是按顺序进行的。它不是一次性部署所有容器，而是一个接一个地顺序部署。一旦第一个pod部署完毕并准备就绪，那么只有第二个pod可以启动。为了有正确的参考，这些pod有一个带有唯一ID的名称，以显示其唯一的身份。因此，举例来说，如果有3个MySQL的豆荚，名称将是mysql-0，mysql-1和mysql-2。而且，如果这些pod中的任何一个出现故障，StatefulSets将部署一个同名的新pod。StatefulSets需要无头服务来管理唯一标识。下图显示了StatefulSets的体系结构:</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/44bdb294b7b95a6ec72ad85d52b81ebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1TVMvhJpYYurIsfZ"/></div></div></figure><h1 id="633e" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">在状态集中缩放</h1><p id="aa67" class="pw-post-body-paragraph km kn it ko b kp ms kr ks kt mt kv kw kx mu kz la lb mv ld le lf mw lh li lj im bi translated">当Kubernetes决定扩大或缩小一个StatefulSet时，它以一种很好理解的方式来做。例如，当您最初创建StatefulSet时，会创建第一个副本，Kubernetes会等待它变得健康和可用，然后再创建第二个副本。这意味着当创建第二个副本时，您可以依赖第零个索引(第一个副本)可供您连接。它可以指向StatefulSet的原始成员。这使得在创建有状态应用程序时声明初始领导者和许多其他必要的事情变得更加容易。</p><p id="793a" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">同样，当您缩小规模时，Kubernetes将从最高的索引开始删除。因此，如果您从三个副本缩减到两个副本，将从删除索引2处的副本开始。</p><h1 id="dac4" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">结论</h1><p id="6464" class="pw-post-body-paragraph km kn it ko b kp ms kr ks kt mt kv kw kx mu kz la lb mv ld le lf mw lh li lj im bi translated">因此，希望这能给你一个有状态应用程序是如何在Kubernetes中部署的，以及你如何为这样的应用程序使用StatefulSets的例子。这篇博客之后的下一步是建立一个StatefulSet。</p><p id="abae" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi">— — — — —</p><p id="5688" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">我在Kubernetes做咨询，如果你有任何疑问，请随时联系我。(https://danielckv.com | | contact@danielckv.com)</p></div></div>    
</body>
</html>