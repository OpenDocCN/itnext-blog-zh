<html>
<head>
<title>Popular UI architectures compared &amp; how Blazor+Fusion UI fits in there</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较流行的用户界面架构&amp; Blazor+Fusion用户界面如何适应</h1>
<blockquote>原文：<a href="https://itnext.io/the-most-popular-ui-architectures-and-how-fusion-based-ui-fits-in-there-fb47e45038a7?source=collection_archive---------1-----------------------#2021-05-19">https://itnext.io/the-most-popular-ui-architectures-and-how-fusion-based-ui-fits-in-there-fb47e45038a7?source=collection_archive---------1-----------------------#2021-05-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b411" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我最近做的一个有趣的观察是，几乎所有的UI架构都非常相似。</p><p id="9b27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">让我们从</strong> <a class="ae kl" href="https://facebook.github.io/flux/docs/in-depth-overview/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">通量</strong> </a> <strong class="jp ir"> : </strong>开始</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/6455e123c45c96751083fb990c64ae84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UfiVDD7kFF3C3aoQV5WUPg.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">Flux UI架构</figcaption></figure><p id="f501" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里发生的事情的简要描述:</p><ul class=""><li id="ae92" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">视图:<br/> -通过将来自商店的数据转换为实际的UI控件来呈现UI<br/>-将用户动作转换为动作对象，并将它们提供给Dispatcher</li><li id="6ed5" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">调度程序将操作发送到商店</li><li id="8e24" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">存储应用动作并通知视图那里发生的变化。</li></ul><p id="747e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">现在，我们来看看</strong><a class="ae kl" href="https://redux.js.org/tutorials/fundamentals/part-1-overview" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">Redux</strong></a><strong class="jp ir">:</strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lq"><img src="../Images/571d6b43427989deca20d3b24eafb1b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X2-ooCm1JdIeewVO3mLM5w.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">Redux UI架构</figcaption></figure><p id="6959" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">什么变了？</p><ul class=""><li id="f0a5" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">Dispatcher被Reducers取代——通常它们只是基于旧状态和当前动作生成新状态的函数</li><li id="b01f" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">尽管这里单独显示了Reducers，但它们通常是存储的一部分，即与Flux相比，Redux定义了存储更新的特定方式。</li></ul><p id="2a23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">好的，那么</strong><a class="ae kl" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">MVC</strong></a><strong class="jp ir">呢？</strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lr"><img src="../Images/cbeca1428fbe9ffe265563c2a883a024.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Tf0uMmdKY6mlYF4l1vV9g.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">MVC架构—稍作调整:)</figcaption></figure><p id="1c0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能会注意到这张图片与上一张非常相似——这是因为我决定在图上保留动作，尽管<em class="ls"> MVC暗示视图在用户动作上调用控制器方法，所以实际上，视图直接调用动作处理程序</em>。但除此之外:</p><ul class=""><li id="58c4" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">控制器取代了减速器</li><li id="3c2d" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">模型(通常是可变的)取代了存储(通常是不可变的)</li><li id="8293" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">最后，这里负责变更通知的是控制器，而不是模型/商店。</li></ul><p id="51a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">最后，MVC+</strong><a class="ae kl" href="https://knockoutjs.com/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">knockout . js</strong></a><strong class="jp ir">/</strong><a class="ae kl" href="https://mobx.js.org/README.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">MobX</strong></a><strong class="jp ir">，或者MVC+</strong><a class="ae kl" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">MVVM</strong></a><strong class="jp ir">:</strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lt"><img src="../Images/bd6943db46e3a5310721ab222377f99d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-GoWmMxRYRLATfRDi2Nszg.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">MVC + MVVM架构</figcaption></figure><p id="84bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">区别？</p><ul class=""><li id="e064" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">模型(MVVM术语中的视图模型)在这里是<em class="ls">可观察的</em>，所以他们是负责变更通知的人，而不是控制器。</li></ul><p id="90c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们试图概括这一点，很容易发现到处都是相同的<em class="ls">视图-动作-动作处理程序-模型</em>链——这是一个简单的<em class="ls">动作-反应</em>链，其中“反应”被分解为几个子组件。这就是为什么所有的UI架构都如此相似。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><p id="ab3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果你读了我以前的帖子，你会知道我主要写的是关于<a class="ae kl" href="https://github.com/servicetitan/Stl.Fusion" rel="noopener ugc nofollow" target="_blank"> Fusion </a>的，所以<strong class="jp ir">我也会简单地介绍一下Fusion UI架构:</strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mb"><img src="../Images/0d1db709b4615982908fe0df07b92c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TFRHBY1mimpqJUa0ntsE-g.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">融合用户界面架构</figcaption></figure><p id="61fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看起来很相似，但是有点复杂，对吗？这是因为<em class="ls">之前我们只描述了客户端模型&amp;的状态，但是这张图涵盖了一切，也就是服务器端组件！</em></p><p id="3c2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么基于Fusion的UI更新管道是如何工作的呢？</p><ul class=""><li id="4c5c" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">视图产生动作。融合意味着在服务器端使用CQRS架构，所以所有的动作都是命令。</li><li id="3383" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">命令被发送到客户端<a class="ae kl" href="https://github.com/servicetitan/Stl.Fusion.Samples/blob/master/docs/tutorial/Part09.md" rel="noopener ugc nofollow" target="_blank">CommandR</a>——Fusion的<a class="ae kl" href="https://github.com/jbogard/MediatR" rel="noopener ugc nofollow" target="_blank">mediator</a>版本，它或者在本地执行命令，或者根据命令的类型将命令发送到服务器端CommandR实例。</li><li id="8608" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">最后，服务器端CommandR调用与该命令相关联的命令处理程序，这改变了基本事实并使受这些改变影响的<a class="ae kl" href="https://github.com/servicetitan/Stl.Fusion.Samples/blob/master/docs/tutorial/Part01.md" rel="noopener ugc nofollow" target="_blank">计算服务</a>端点无效。</li><li id="2656" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">一连串的失效最终会影响客户端<a class="ae kl" href="https://github.com/servicetitan/Stl.Fusion.Samples/blob/master/docs/tutorial/Part04.md" rel="noopener ugc nofollow" target="_blank">副本服务</a>端点(服务器端计算服务的融合感知客户端)、使用它们的客户端计算服务，并最终到达受影响视图的<a class="ae kl" href="https://github.com/servicetitan/Stl.Fusion.Samples/blob/master/docs/tutorial/Part03.md" rel="noopener ugc nofollow" target="_blank">状态</a>。这使得这些状态对象重新计算它们的值。</li><li id="361c" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">当一个状态完成其值的重新计算时，使用它的视图被重新呈现。</li></ul><p id="5bbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以上图更详细的版本是:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mc"><img src="../Images/2e489efb411b3f05d2a8bc030d185ce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zqPP92OTGATg-ns0Ig_26Q.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">融合UI架构；客户端和服务器端组件显示在同一张图中</figcaption></figure><p id="6022" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能会注意到，这里没有显示失效(~更改通知)——这是因为在Fusion的情况下，它们总是以与任何查询相反的方向“流动”。</p><p id="759a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，所有这些看起来非常类似于MVC + MobX或者基于<a class="ae kl" href="https://recoiljs.org/" rel="noopener ugc nofollow" target="_blank">反冲</a>的UI，但是:</p><ol class=""><li id="cb1e" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk md li lj lk bi translated">Fusion中没有“可观察模型”的概念，它是围绕“可观察查询端点”(计算服务)构建的，可自动跟踪它们所依赖的其他端点。你可以在服务器端和客户端使用计算服务，所以最终，<em class="ls">你在任何地方都使用相同的抽象。</em></li><li id="a028" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk md li lj lk bi translated">由于客户端计算服务(生成视图模型的服务)可能会使用服务器端计算服务，所以您不需要担心将每个更改都应用到服务器端基本事实和客户端模型。<em class="ls">一旦客户端模型“看到”组成它们的数据片段(包括服务器端的)发生了变化，它们就会被简单地重新计算</em>。</li><li id="a203" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk md li lj lk bi translated">你不需要减速器和商店。您的客户端代码变得<a class="ae kl" href="https://github.com/servicetitan/Stl.Fusion#enough-talk-show-me-the-code" rel="noopener ugc nofollow" target="_blank">简单，因为它必须</a>——也就是说，它只构建您想要显示的模型，其余的(更改时的更新)自动发生！</li><li id="cf9b" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk md li lj lk bi translated">您甚至不需要考虑它们是如何交付给客户端的——即<a class="ae kl" href="https://medium.com/swlh/how-similar-is-stl-fusion-to-signalr-e751c14b70c3" rel="noopener">不需要处理SignalR，一旦您显示了一些UI组件，就考虑要订阅/取消订阅的主题，考虑如何确保您的UI最终是一致的，等等。</a></li></ol><p id="0b8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这一切听起来很有趣，请查看:</p><ul class=""><li id="1a15" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">融合GitHub库:<a class="ae kl" href="https://github.com/servicetitan/Stl.Fusion" rel="noopener ugc nofollow" target="_blank">https://github.com/servicetitan/Stl.Fusion</a></li><li id="0451" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">融合样本:<a class="ae kl" href="https://github.com/servicetitan/Stl.Fusion.Samples" rel="noopener ugc nofollow" target="_blank">https://github.com/servicetitan/Stl.Fusion.Samples</a></li></ul></div></div>    
</body>
</html>