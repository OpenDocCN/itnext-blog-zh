<html>
<head>
<title>Rust on the front-end</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">前端生锈</h1>
<blockquote>原文：<a href="https://itnext.io/rust-front-end-e5aa3ad54b30?source=collection_archive---------2-----------------------#2021-07-04">https://itnext.io/rust-front-end-e5aa3ad54b30?source=collection_archive---------2-----------------------#2021-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8f43bfd5fd824bacaf4a4b2a895bf1cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o2-48ngCc6_dhKb2jlrE7w.jpeg"/></div></div></figure><p id="4d52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，JavaScript是浏览器中唯一普遍存在的语言。它使得JavaScript比它的设计(和它的相关缺陷)允许的更受欢迎。因此:</p><ul class=""><li id="2eeb" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">JavaScript开发人员的数量已经有了巨大而稳定的增长</li><li id="8e25" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">围绕前端JavaScript的生态系统已经变得更大、更复杂</li><li id="8e66" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">变化的速度越来越快，以至于开发人员抱怨JavaScript疲劳</li><li id="3041" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">有趣的是，JavaScript通过Node.js偷偷潜入后端</li><li id="a905" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">等等。</li></ul><p id="66bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不想就JavaScript的优点发起一场圣战，但我想，它之所以能存活至今，是因为它在浏览器中的作用。特别是，当前的架构将执行代码的责任从服务器转移到了客户端，这给后者带来了很大的压力。提高性能的方法不多:要么购买更大的客户机，要么改进JavaScript引擎。</p><p id="031a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来了<a class="ae lk" href="https://webassembly.org/" rel="noopener ugc nofollow" target="_blank"> WebAssembly </a>。</p><blockquote class="ll lm ln"><p id="3cdd" class="jy jz lo ka b kb kc kd ke kf kg kh ki lp kk kl km lq ko kp kq lr ks kt ku kv ij bi translated"><em class="iq"> WebAssembly(缩写Wasm)是一种基于堆栈的虚拟机的二进制指令格式。Wasm被设计为编程语言的可移植编译目标，支持客户端和服务器应用程序在web上的部署。</em></p></blockquote><p id="a486" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Wasm并不是为了完全取代浏览器中的JavaScript而设计的(还没有？)，而是为了提高整体性能。虽然Rust是为系统编程而设计的，但它提供了对WebAssembly的编译。</p><p id="f18d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是开始锈焦点系列的第五篇文章。其他职位包括:</p><ol class=""><li id="dbb2" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv ls lc ld le bi translated"><a class="ae lk" href="https://blog.frankel.ch/start-rust/1/" rel="noopener ugc nofollow" target="_blank">我的第一杯铁锈</a></li><li id="333e" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv ls lc ld le bi translated"><a class="ae lk" href="https://blog.frankel.ch/start-rust/2/" rel="noopener ugc nofollow" target="_blank">我的第二杯铁锈</a></li><li id="d58c" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv ls lc ld le bi translated"><a class="ae lk" href="https://blog.frankel.ch/start-rust/3/" rel="noopener ugc nofollow" target="_blank">生锈练习—第一部分</a></li><li id="482e" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv ls lc ld le bi translated"><a class="ae lk" href="https://blog.frankel.ch/start-rust/4/" rel="noopener ugc nofollow" target="_blank">生锈练习—第二部分</a></li><li id="a6d9" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv ls lc ld le bi translated"><em class="lo">前端生锈</em>(本岗位)</li></ol><h1 id="01e8" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">Rust和web组装</h1><p id="3ead" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">学锈是一个漫长的过程；学习Rust和WebAssembly更是如此。幸运的是，好心人已经让旅程变得轻松了一些。他们专门为这个主题写了一整本免费的在线教程，可以在友好的开源许可下获得。</p><p id="cd8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为学习者和培训师，我知道创建一个好的教程有多难:</p><ol class=""><li id="6d4f" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv ls lc ld le bi translated">要么你提供一个一步一步前进的路径，一路上都有解决方案，这就变成了一个复制粘贴的问题</li><li id="993b" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv ls lc ld le bi translated">或者你提供一些不太详细的东西，但是你冒着一些学习者被阻止和不能完成的风险</li></ol><p id="1de9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这本书避免了这两个陷阱，因为它遵循第一种模式，但在每章的结尾提供了可选的问题。为了避免阻塞问题，每个问题都提供了一个通用的提示来引导学习者找到解决方案。如果你不能(或不想)解决一个特定的问题，你可以继续下一章。注意，在<a class="ae lk" href="https://github.com/ajavageek/rust-game-of-life" rel="noopener ugc nofollow" target="_blank">关联的Git存储库</a>中，每次提交要么引用一个标准的复制粘贴步骤，要么引用一个要解决的问题。</p><p id="645b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，这本书提供了两个部分，适当的教程和参考部分。因此，您可以在教程中查找相关的文档，并在教程结束后加深理解。</p><h1 id="e0c6" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">生锈的项目</h1><p id="584e" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">教程的第一步集中在<a class="ae lk" href="https://rustwasm.github.io/docs/book/game-of-life/setup.html" rel="noopener ugc nofollow" target="_blank">设置</a>上。它很短，是最“抄袭”的。原因是它利用了<a class="ae lk" href="https://github.com/cargo-generate/cargo-generate" rel="noopener ugc nofollow" target="_blank"> cargo-generate </a>，这是一个cargo插件，允许通过使用现有的Git存储库作为模板来创建一个新项目。在我们的例子中，模板是一个准备编译成Wasm的<a class="ae lk" href="https://github.com/rustwasm/wasm-pack-template" rel="noopener ugc nofollow" target="_blank"> Rust项目</a>。该项目的结构是:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="7c5e" class="nf lu iq nb b gy ng nh l ni nj">wasm-game-of-life/<br/>├── Cargo.toml<br/>└── src<br/>    ├── lib.rs<br/>    └── utils.rs</span></pre><p id="3da6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是“标准”Rust项目的结构。现在是查看<code class="fe nk nl nm nb b">Cargo.toml</code>文件的好时机。它扮演了一个<code class="fe nk nl nm nb b">pom.xml</code>的角色，列出了关于包、依赖项、编译提示等的元信息。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="1f63" class="nf lu iq nb b gy ng nh l ni nj">[package]                                              # 1<br/>name = "wasm-game-of-life"<br/>version = "0.1.0"<br/>authors = ["Nicolas Frankel &lt;nicolas@frankel.ch&gt;"]<br/>edition = "2018"</span><span id="6f67" class="nf lu iq nb b gy nn nh l ni nj">[lib]                                                  # 2<br/>crate-type = ["cdylib", "rlib"]                        # 3</span><span id="294b" class="nf lu iq nb b gy nn nh l ni nj">[features]<br/>default = ["console_error_panic_hook"]</span><span id="c7a4" class="nf lu iq nb b gy nn nh l ni nj">[dependencies]<br/>wasm-bindgen = "0.2.63"                                # 4</span><span id="9f53" class="nf lu iq nb b gy nn nh l ni nj"># Rest of the file omitted for clarity purposes</span></pre><ol class=""><li id="3743" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv ls lc ld le bi translated">关于包的元信息</li><li id="ff03" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv ls lc ld le bi translated">生成一个库，而不是二进制</li><li id="d429" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv ls lc ld le bi translated">产生一个锈库和一个动态系统库</li><li id="b404" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv ls lc ld le bi translated">产生Wasm的依赖项</li></ol><h1 id="5358" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">集成前端</h1><p id="dbd9" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">目前这个项目并不十分有趣:你看不到奇迹发生。教程的下一步是添加一个web接口，与编译到Wasm的Rust代码进行交互。</p><p id="259d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和上一步一样，一个命令允许从GitHub复制代码。这里的命令是<code class="fe nk nl nm nb b">npm</code>，模板是<a class="ae lk" href="https://github.com/rustwasm/create-wasm-app" rel="noopener ugc nofollow" target="_blank"> create-wasm-app </a>。让我们运行命令:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="43d4" class="nf lu iq nb b gy ng nh l ni nj">npm init wasm-app www</span></pre><p id="fec9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将输出以下结构:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="143d" class="nf lu iq nb b gy ng nh l ni nj">wasm-game-of-life/<br/>└── www/<br/>    ├── package.json                   <br/>    ├── webpack.config.js               <br/>    ├── index.js                       <br/>    ├── bootstrap.js                   <br/>    └── index.html</span></pre><p id="3995" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">NPM项目<code class="fe nk nl nm nb b">Cargo.toml</code>的镜像，配置为Wasm Webpack配置进入“应用”的主入口点:调用<code class="fe nk nl nm nb b">index.js</code>的Wasm代码异步加载器包装器</p><p id="b682" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，如果我们完成了所需的构建步骤，就有可能执行整个代码链:</p><ol class=""><li id="044f" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv ls lc ld le bi translated">将Rust代码编译到Wasm</li><li id="5456" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv ls lc ld le bi translated">生成JavaScript适配器代码。只需调用一次<code class="fe nk nl nm nb b">wasm-pack</code>，就可以运行第一步和前一步。检查<code class="fe nk nl nm nb b">pkg</code>文件夹中生成的文件。</li><li id="8bf8" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv ls lc ld le bi translated">得到NPM与<code class="fe nk nl nm nb b">npm install</code>的依赖关系</li><li id="f15e" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv ls lc ld le bi translated">用<code class="fe nk nl nm nb b">npm run start</code>运行本地网络服务器</li></ol><p id="4440" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">浏览到<a class="ae lk" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>应该会显示一条简单的<code class="fe nk nl nm nb b">alert()</code>消息。</p><p id="9d11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本节末尾的练习是将<code class="fe nk nl nm nb b">alert()</code>改为<code class="fe nk nl nm nb b">prompt()</code>以提供参数化。您应该相应地更改Rust代码并重新编译它。web服务器应该动态地重新加载新代码，以便刷新页面时显示更新后的代码。</p><p id="2431" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在这篇文章背后的想法不是重做整个教程，而是专注于有趣的部分。由于前端生锈，它归结为:</p><ol class=""><li id="1758" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv ls lc ld le bi translated">从JavaScript调用Rust</li><li id="a850" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv ls lc ld le bi translated">从Rust调用JavaScript</li><li id="9996" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv ls lc ld le bi translated">从Rust调用浏览器API</li></ol><h1 id="8930" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">从JavaScript调用Rust</h1><p id="dc06" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">要从JavaScript调用Rust，需要将Rust代码编译成Wasm，并提供瘦JavaScript包装器。对于模板项目，这已经配置好了。你只需要在你想使用的Rust功能上使用<code class="fe nk nl nm nb b">wasm-bindgen</code>宏。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="9bb1" class="nf lu iq nb b gy ng nh l ni nj">#[wasm_bindgen]           # 1<br/>pub fn foo() {<br/>    // do something<br/>}</span></pre><ol class=""><li id="1fee" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv ls lc ld le bi translated">神奇宏！</li></ol><p id="c2f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在JavaScript方面:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="eb58" class="nf lu iq nb b gy ng nh l ni nj">import * as wasm from "hello-wasm-pack";       // 1</span><span id="a543" class="nf lu iq nb b gy nn nh l ni nj">wasm.foo();                                    // 2</span></pre><ol class=""><li id="839a" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv ls lc ld le bi translated">将<code class="fe nk nl nm nb b">hello-wasm-pack</code>包中的所有内容导入到<code class="fe nk nl nm nb b">wasm</code>名称空间中</li><li id="0343" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv ls lc ld le bi translated">你现在可以调用<code class="fe nk nl nm nb b">foo()</code></li></ol><h1 id="98a4" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">从Rust调用JavaScript</h1><p id="4c4c" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">教程背后的指导原则是<a class="ae lk" href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" rel="noopener ugc nofollow" target="_blank">康威的《生活的游戏</a>。要初始化电路板，一种方法是随机将每个单元设置为死或活。因为随机化应该在运行时发生，所以我们需要使用JavaScript的<code class="fe nk nl nm nb b">Math.random()</code>。因此，我们还需要从Rust调用JavaScript函数。</p><p id="d434" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本设置通过<code class="fe nk nl nm nb b">extern</code>关键字使用外部函数接口:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="9804" class="nf lu iq nb b gy ng nh l ni nj">#[wasm_bindgen]<br/>extern "C" {                                 # 1<br/>    #[wasm_bindgen(js_namespace = Math)]     # 2<br/>    fn random() -&gt; f64;<br/>}</span><span id="3d1e" class="nf lu iq nb b gy nn nh l ni nj">#[wasm_bindgen]<br/>fn random_boolean() -&gt; bool {<br/>    random() &lt; 0.5                           # 3<br/>}</span></pre><ol class=""><li id="78d0" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv ls lc ld le bi translated">这不是C代码，但无论如何这是正确的语法</li><li id="356a" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv ls lc ld le bi translated">生成Rust接口，这样它就可以编译</li><li id="eccf" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv ls lc ld le bi translated">使用它</li></ol><p id="62e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这种方法可行，但是非常容易出错。或者，<code class="fe nk nl nm nb b">js-sys</code>板条箱提供所有现成可用的绑定:</p><blockquote class="ll lm ln"><p id="81bf" class="jy jz lo ka b kb kc kd ke kf kg kh ki lp kk kl km lq ko kp kq lr ks kt ku kv ij bi translated"><em class="iq">绑定到JavaScript的标准内置对象，包括它们的方法和属性。</em></p><p id="b716" class="jy jz lo ka b kb kc kd ke kf kg kh ki lp kk kl km lq ko kp kq lr ks kt ku kv ij bi translated">这不包括任何Web、节点或任何其他JS环境API。只有ECMAScript标准保证在全局范围内存在的东西。</p><p id="89db" class="jy jz lo ka b kb kc kd ke kf kg kh ki lp kk kl km lq ko kp kq lr ks kt ku kv ij bi translated"><a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" rel="noopener ugc nofollow" target="_blank">T13】https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ ObjectsT15】</a></p><p id="0bcf" class="jy jz lo ka b kb kc kd ke kf kg kh ki lp kk kl km lq ko kp kq lr ks kt ku kv ij bi translated">— <a class="ae lk" href="https://rustwasm.github.io/wasm-bindgen/api/js_sys/" rel="noopener ugc nofollow" target="_blank">机箱js_sys </a></p></blockquote><p id="e2bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要设置板条箱，您只需将它添加到Toml:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="9446" class="nf lu iq nb b gy ng nh l ni nj">[dependencies]<br/>js-sys = { version = "0.3.50", optional = true }  # 1</span><span id="bfdf" class="nf lu iq nb b gy nn nh l ni nj">[features]<br/>default = ["js-sys"]                              # 2</span></pre><ol class=""><li id="7cd4" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv ls lc ld le bi translated">将依赖项添加为可选项</li><li id="f910" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv ls lc ld le bi translated">激活可选功能</li></ol><p id="93a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">说实话，我不明白为什么要设置依赖关系<code class="fe nk nl nm nb b">optional</code>并在另一行激活它。我暂时就说到这里。</p><p id="dd69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前面的配置允许以下代码:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="f3b9" class="nf lu iq nb b gy ng nh l ni nj">use js_sys::Math;               # 1</span><span id="ec63" class="nf lu iq nb b gy nn nh l ni nj">#[wasm_bindgen]<br/>fn random_boolean() -&gt; bool {<br/>    Math::random() &lt; 0.5        # 2<br/>}</span></pre><ol class=""><li id="e47a" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv ls lc ld le bi translated">使用<code class="fe nk nl nm nb b">js_sys</code>箱中的<code class="fe nk nl nm nb b">Math</code></li><li id="46db" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv ls lc ld le bi translated">用Rust编译器编译好，并在运行时调用JavaScript的<code class="fe nk nl nm nb b">Math.random()</code></li></ol><h1 id="4c6a" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">从Rust调用浏览器API</h1><p id="0479" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated"><code class="fe nk nl nm nb b">js-sys</code>箱允许我们在Rust代码中调用JavaScript APIs。然而，要调用客户端API，例如<code class="fe nk nl nm nb b">console-log</code>，就需要<code class="fe nk nl nm nb b">web_sys</code>箱。</p><blockquote class="ll lm ln"><p id="c641" class="jy jz lo ka b kb kc kd ke kf kg kh ki lp kk kl km lq ko kp kq lr ks kt ku kv ij bi translated"><em class="iq">Web API的原始API绑定</em></p><p id="d236" class="jy jz lo ka b kb kc kd ke kf kg kh ki lp kk kl km lq ko kp kq lr ks kt ku kv ij bi translated">这是一个从浏览器WebIDL程序生成的crate，它提供了浏览器在web上提供的所有API的绑定。</p><p id="122d" class="jy jz lo ka b kb kc kd ke kf kg kh ki lp kk kl km lq ko kp kq lr ks kt ku kv ij bi translated">默认情况下，这个板条箱在编译时包含的内容非常少，因为几乎所有暴露的API都由Cargo特性控制。在crates/web-sys/Cargo.toml中可以找到详尽的功能列表，但是web-sys的经验法则是每种类型都有自己的Cargo功能(以类型命名)。使用API需要启用API中使用的所有类型的特性，API应该在文档中提到它们需要什么特性。</p><p id="7c6b" class="jy jz lo ka b kb kc kd ke kf kg kh ki lp kk kl km lq ko kp kq lr ks kt ku kv ij bi translated">— <a class="ae lk" href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/" rel="noopener ugc nofollow" target="_blank">板条箱web_sys </a></p></blockquote><p id="5f53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是如何配置它:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="3a01" class="nf lu iq nb b gy ng nh l ni nj">[dependencies]<br/>web-sys = { version = "0.3", features = ["console"] }</span></pre><p id="9c49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以这样使用板条箱:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="232a" class="nf lu iq nb b gy ng nh l ni nj">extern crate web_sys;                                 # 1</span><span id="e6cd" class="nf lu iq nb b gy nn nh l ni nj">use web_sys::console;                                 # 2</span><span id="5670" class="nf lu iq nb b gy nn nh l ni nj">#[wasm_bindgen]<br/>impl Foo {<br/>    pub fn new() -&gt; Foo {<br/>        utils::set_panic_hook();<br/>        Universe {}<br/>    }</span><span id="514e" class="nf lu iq nb b gy nn nh l ni nj">    pub fn log(&amp;self) {<br/>        console::log_1("Hello from console".into());  # 3<br/>    }<br/>}</span></pre><ol class=""><li id="c6e5" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv ls lc ld le bi translated">要求<code class="fe nk nl nm nb b">web-sys</code>创建。我不确定是否(或为什么)需要<code class="fe nk nl nm nb b">extern</code>。</li><li id="fb4f" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv ls lc ld le bi translated">使用<code class="fe nk nl nm nb b">console</code>包</li><li id="89c0" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv ls lc ld le bi translated"><code class="fe nk nl nm nb b">console::log_1()</code>在运行时翻译成带有一个参数的<code class="fe nk nl nm nb b">console.log()</code></li></ol><h1 id="96e3" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">结论</h1><p id="21cd" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">在本帖中，我们详细介绍了在浏览器中使用Rust的三个要点:从JavaScript调用Rust，从Rust调用JavaScript，从Rust调用浏览器API。</p><p id="3288" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是最后的结果。我只能鼓励你自己尝试一下教程。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1198" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章的完整源代码可以在Github上找到。</p><h1 id="66ab" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">为了更进一步:</h1><ul class=""><li id="6b82" class="kw kx iq ka b kb mr kf ms kj nq kn nr kr ns kv lb lc ld le bi translated"><a class="ae lk" href="https://rustwasm.github.io/docs/book/" rel="noopener ugc nofollow" target="_blank">锈与web组装书</a></li><li id="38fe" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae lk" href="https://doc.rust-lang.org/cargo/reference/manifest.html" rel="noopener ugc nofollow" target="_blank">舱单格式参考</a></li><li id="eb00" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae lk" href="https://doc.rust-lang.org/reference/linkage.html" rel="noopener ugc nofollow" target="_blank">联动</a></li><li id="2e7d" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae lk" href="https://rustwasm.github.io/docs/wasm-bindgen/" rel="noopener ugc nofollow" target="_blank">wasm-bindgen指南</a></li></ul></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="71af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lo">原载于</em> <a class="ae lk" href="https://blog.frankel.ch/start-rust/5/" rel="noopener ugc nofollow" target="_blank"> <em class="lo">一个Java极客</em></a><em class="lo">2021年7月4日</em></p></div></div>    
</body>
</html>