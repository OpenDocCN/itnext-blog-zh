<html>
<head>
<title>Caching the results of polled endpoints</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缓存轮询端点的结果</h1>
<blockquote>原文：<a href="https://itnext.io/caching-the-results-of-polled-endpoints-f3670b41c4e6?source=collection_archive---------6-----------------------#2021-12-15">https://itnext.io/caching-the-results-of-polled-endpoints-f3670b41c4e6?source=collection_archive---------6-----------------------#2021-12-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="b518" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">通过以下方式获得更好性能的指南</h2><div class=""/><div class=""><h2 id="0a96" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">轮询是检查服务器结果的一种简单方法。但是由于服务器使用的增加，每隔几秒钟运行一次功能可能要花钱。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/7caf566fe8e9449a8b00f2c71cca7fbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UW6Ghyh9l0G9mpnkgINWXg.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fwww.majorel.com%2Ffuture-customer%2Fshowcases%2Fmore-than-just-data-storage-informed-decisions-thanks-to-data-warehouse%2F&amp;psig=AOvVaw3MwPhXX75liPjVTecVh4sY&amp;ust=1639685665485000&amp;source=images&amp;cd=vfe&amp;ved=0CAsQjRxqFwoTCLDnuKHP5vQCFQAAAAAdAAAAABAD" rel="noopener ugc nofollow" target="_blank">学分</a></figcaption></figure><h2 id="987a" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">介绍</h2><p id="7e39" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">有两种类型的轮询。“长轮询”是指向服务器发出请求，但不关闭请求。当服务器发送回数据时，该函数将完成，然后再次调用自身，以查看服务器是否还有数据。“轮询”是一种更简单的方法，其中函数被包装在一个<strong class="mf jd"> setInterval </strong>方法中并被调用，直到间隔被清除。当满足某个条件时，例如在工作时间之外，可以清除时间间隔。或者直接从另一个方法调用。</p><h2 id="2059" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">场景</h2><p id="3bcb" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">这里的场景是一个办公室安装了一个新的电话系统。这个电话系统需要告诉管理员用户何时在通话以及谁在。电话系统的结果可以是一个相当大的对象，每个办公室有部门，每个部门有电话，每个电话有一个配置。</p><p id="222b" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">轮询电话端点将为每个响应返回大量数据。取而代之的是获取另一个端点，比如返回不可用电话id列表的<strong class="mf jd">"/不可用电话"</strong>，这可能是一个更好的方法。这将返回一个小得多的数据集，可用于更新静态电话条目。</p><h2 id="1cca" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">轮询方法</h2><p id="06d3" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">下面是获取电话系统和ID的轮询方法设置的示例。方法很简单，它调用手机的网址，然后开始间隔。稍后，可以添加一个条件来查看是否应该清除间隔。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="a097" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">一旦电话端点被调用并且不可用的端点已经返回它的时间来更新静态电话数据。下面的代码是如何做到这一点的简化版本。</p><p id="8512" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">首先，代码检查从不可用电话的数组中生成的密钥是否以前被见过。如果有，就可以从缓存中返回。如果没有，那么必须运行剩余的代码来更新每个部门的每个电话。</p><p id="2858" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">如果一家公司有10个人在为它工作，这可能没什么可担心的。但是一个拥有超过1000名员工的大型组织将开始出现一些性能问题，并且由于正常运行时间的原因，服务器成本会增加。</p><p id="724c" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">通过使用下面的方法，一旦手机被更新，它们可以被存储在缓存中以备后用。这也可以提供更好的大O性能，因为它从O(n)变为O(1 ),因为我们是通过一个键而不是通过迭代来访问电话。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="f8d5" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">如果你想自己测试这段代码，这里有一个<a class="ae lh" href="https://codesandbox.io/s/long-poll-caching-example-1xbfd" rel="noopener ugc nofollow" target="_blank">code sandbox</a>。</p><h2 id="0165" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">结论</h2><p id="8ca8" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">当每一毫秒都很重要时，缓存可能不会随时间发生太大变化的静态资产是一种节省内存的好方法。下面是一些不同时间和数量的结果图。</p><p id="b597" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">运行100次最大未缓存时间为10.75毫秒，最大缓存时间为5.76毫秒</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nd"><img src="../Images/55bce3b84e6322cc4c0d803bc8ce7818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WgZmT2EMqj-zBbk0KGGHGA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">未缓存100</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nd"><img src="../Images/03b8119066d178c30578986a51b59a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4adPQFS-ScdRO37wla4saQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">缓存100</figcaption></figure><p id="bdaa" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">结果对于运行300次的示例，可以看到未缓存的代码每次都以更高的时间间隔运行。未缓存总数的总毫秒数为1011.62毫秒，而缓存总数为672.43毫秒</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ne"><img src="../Images/ec42b80eb23133282d980043a5ac15e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u05eFv_OItZgx5REiB9vkA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">未兑现300</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nf"><img src="../Images/3ddd83b476c930bebbbaa9777bf997a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NwizG7xprn4iaRniEpuXpA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">缓存300</figcaption></figure><p id="d037" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">为了进一步展示这些结果如何影响一个组织</p><p id="913c" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">每分钟:20.35秒</p><p id="4389" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">每小时:节省2分56秒</p><p id="2bca" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">每天:29分26秒</p><p id="0ddf" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">希望这篇文章能帮助你在应用程序上节省一些内存和时间。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="b42c" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">如果您想注册访问更多媒体内容，请点击以下<a class="ae lh" href="https://thewebuiguy.com/membership" rel="noopener ugc nofollow" target="_blank">链接</a>。这将使我能够写更多的故事，通过一个小的委员会从媒体。</p></div></div>    
</body>
</html>