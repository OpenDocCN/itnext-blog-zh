<html>
<head>
<title>Solving Riddles with 0 lines of program in Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用打字稿中的0行程序解谜</h1>
<blockquote>原文：<a href="https://itnext.io/solving-riddles-with-0-lines-of-program-b23994072dd0?source=collection_archive---------2-----------------------#2020-05-31">https://itnext.io/solving-riddles-with-0-lines-of-program-b23994072dd0?source=collection_archive---------2-----------------------#2020-05-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="3f69" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">事实和推论</h1><p id="9f4a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">考虑以下事实</p><ul class=""><li id="48de" class="lj lk iq kn b ko ll ks lm kw ln la lo le lp li lq lr ls lt bi translated">所有的人都是凡人</li><li id="864e" class="lj lk iq kn b ko lu ks lv kw lw la lx le ly li lq lr ls lt bi translated">苏格拉底是一个人</li></ul><p id="b018" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw lz ky kz la ma lc ld le mb lg lh li ij bi translated">从以上事实很容易推断出苏格拉底是一个凡人。但是，如果存在一种能够从给定的事实中推断出结果的语言，那不是很神奇吗？</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="1ec7" class="jn jo iq bd jp jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk bi translated">输入序言</h1><p id="30da" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Prolog是一种逻辑编程语言。它的使用主要是在传统人工智能领域的学术研究。它给了我们一种语言，可以翻译上述逻辑语句时，可以查询。这种语言因此可以用来解决逻辑谜语！</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6e27" class="mx jo iq mt b gy my mz l na nb">mortal(X) :- human(X).<br/>human(socrates).</span></pre><p id="9732" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw lz ky kz la ma lc ld le mb lg lh li ij bi translated">上述语句是从英语到prolog的逻辑的直接翻译。如果我们质疑前提，</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="30ef" class="mx jo iq mt b gy my mz l na nb">human(X)</span></pre><p id="963a" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw lz ky kz la ma lc ld le mb lg lh li ij bi translated">给出以下结果</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="faeb" class="mx jo iq mt b gy my mz l na nb">X = socrates</span></pre><p id="63aa" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw lz ky kz la ma lc ld le mb lg lh li ij bi translated">你可以在这个<a class="ae nc" href="https://curiosity-driven.org/prolog-interpreter" rel="noopener ugc nofollow" target="_blank">网站</a>试用Prolog</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="1224" class="jn jo iq bd jp jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk bi translated">typescript——逻辑编程的独特竞争者</h1><p id="d985" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Typescript是带有类型注释的javascript的上标。它给了我们一个非常高级的类型系统，可以消除使用普通javascript时可能出现的许多潜在错误。</p><p id="6133" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw lz ky kz la ma lc ld le mb lg lh li ij bi translated">但是拥有一个可证明的类型系统并不是typescript的目标(正如他们所说的<a class="ae nc" href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals" rel="noopener ugc nofollow" target="_blank"/>)。</p><p id="fcbe" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw lz ky kz la ma lc ld le mb lg lh li ij bi translated">但是，我们能放弃typescript中的prolog吗？让我们在放弃梦想之前尝试一下吧！</p><figure class="mo mp mq mr gt ne gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/825931877a10fd7fdd697b48b9e23f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/1*J9kW2mZZ0zLqVWQW-vQleg.gif"/></div></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="3352" class="jn jo iq bd jp jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk bi translated">将事实编码为类型</h1><p id="0811" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">与prolog类似，事实可以在typescript中表示为类型。</p><figure class="mo mp mq mr gt ne gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/ac818b46e9cb5291f407313e537d3eb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*LPal3PRLDxO7ztzF55JPcw.gif"/></div></figure><p id="19c7" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw lz ky kz la ma lc ld le mb lg lh li ij bi translated">在typescript中进行推断要简单得多。仅仅停留在类型上就能给出推断的结果。</p><p id="fe9b" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw lz ky kz la ma lc ld le mb lg lh li ij bi translated">让我们看看另一个例子的家谱。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="3d51" class="mx jo iq mt b gy my mz l na nb">type CtoF = {<br/>    Ram: 'Dashrath',<br/>    Lakshman: 'Dashrath',<br/>    Lava: 'Ram',<br/>    Kusa: 'Ram',<br/>    Bharath: 'Dashrath'<br/>}</span><span id="a846" class="mx jo iq mt b gy ni mz l na nb">type CtoM = {<br/>    Ram: 'Kousalya',<br/>    Lava: 'Sita',<br/>    Lakshman: 'Sumitra'<br/>}</span></pre><p id="4f2d" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw lz ky kz la ma lc ld le mb lg lh li ij bi translated">以上是孩子对父亲和孩子对母亲的事实模型。如您所见，与prolog的mathy语法相比，在类型中编码事实非常类似于创建一个键值对。</p><h1 id="ab5f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">在类型系统中编码逻辑查询</h1><p id="af66" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们试着从事实中问出祖父</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="df26" class="mx jo iq mt b gy my mz l na nb">type GrandFather&lt;X extends keyof CtoF&gt; = CtoF[X] extends keyof CtoF ? CtoF[CtoF[X]]: never</span></pre><figure class="mo mp mq mr gt ne gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/fe2755cd69628ef4e2e84eece759126d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*7CJnckG5W7YCevJnIv6gRQ.gif"/></div></figure><p id="e1b3" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw lz ky kz la ma lc ld le mb lg lh li ij bi translated">同样，我们可以定义其他查询，如兄弟姐妹、父母等。这些例子也可以在Prolog入门部分找到。这是整个程序。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="bcb4" class="mx jo iq mt b gy my mz l na nb">type KeyFromValue&lt;V, T extends Record&lt;PropertyKey, PropertyKey&gt;&gt; = {<br/>  [K in keyof T]: V extends T[K] ? K : never<br/>}[keyof T];</span><span id="5ae4" class="mx jo iq mt b gy ni mz l na nb">type Invert&lt;T extends Record&lt;PropertyKey, PropertyKey&gt;&gt; = {<br/>  [V in T[keyof T]]: KeyFromValue&lt;V, T&gt;<br/>};</span><span id="0283" class="mx jo iq mt b gy ni mz l na nb">type CtoF = {<br/>    Ram: 'Dashrath',<br/>    Lakshman: 'Dashrath',<br/>    Lava: 'Ram',<br/>    Kusa: 'Ram',<br/>    Bharath: 'Dashrath'<br/>}</span><span id="8afb" class="mx jo iq mt b gy ni mz l na nb">type CtoM = {<br/>    Ram: 'Kousalya',<br/>    Lava: 'Sita',<br/>    Lakshman: 'Sumitra'<br/>}</span><span id="f561" class="mx jo iq mt b gy ni mz l na nb">type FtoC = Invert&lt;CtoF&gt;</span><span id="f993" class="mx jo iq mt b gy ni mz l na nb">type MtoC = Invert&lt;CtoM&gt;</span><span id="a08b" class="mx jo iq mt b gy ni mz l na nb">type Parents&lt;X extends keyof CtoF &amp; keyof CtoM&gt; = CtoF[X] | CtoM[X]</span><span id="aa70" class="mx jo iq mt b gy ni mz l na nb">type GrandFather&lt;X extends keyof CtoF&gt; = CtoF[X] extends keyof CtoF ? CtoF[CtoF[X]]: never</span><span id="abf4" class="mx jo iq mt b gy ni mz l na nb">type Children&lt;X extends (keyof FtoC | keyof MtoC)&gt; =<br/>    X extends keyof FtoC ? FtoC[X] :<br/>    X extends keyof MtoC ? MtoC[X] :<br/>    never</span><span id="4325" class="mx jo iq mt b gy ni mz l na nb">type Siblings&lt;X extends keyof CtoF &amp; keyof CtoM&gt; = Exclude&lt;KeyFromValue&lt;Parents&lt;X&gt;, CtoF&gt; | KeyFromValue&lt;Parents&lt;X&gt;, CtoM&gt;, X&gt;</span><span id="b9cb" class="mx jo iq mt b gy ni mz l na nb">type inf = Parents&lt;'Lakshman'&gt;</span><span id="8e11" class="mx jo iq mt b gy ni mz l na nb">type inf2 = GrandFather&lt;'Lava'&gt;</span><span id="8a4b" class="mx jo iq mt b gy ni mz l na nb">type inf6 = Siblings&lt;'Ram'&gt;</span><span id="36be" class="mx jo iq mt b gy ni mz l na nb">type i5 = Children&lt;'Ram'&gt;</span></pre><p id="c416" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw lz ky kz la ma lc ld le mb lg lh li ij bi translated">以及更多的推论</p><figure class="mo mp mq mr gt ne gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/ee0e061e903ee64503642912974de81f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*dTWebRzYSLq_40oyvUcm-Q.gif"/></div></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="3d9c" class="jn jo iq bd jp jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk bi translated">点击诱饵标题推断</h1><p id="cc80" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">好吧，关于点击诱饵标题，我们只是写了这么多，它怎么算作0零线？如果复制粘贴<a class="ae nc" href="https://www.typescriptlang.org/play" rel="noopener ugc nofollow" target="_blank">游乐场</a>中的代码，可以看到右边生成的js代码什么都没有。从技术上讲，我们写了0行程序，而我们写的只是类型！</p><figure class="mo mp mq mr gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nj"><img src="../Images/eb4b4df877a3d825a0976a1ba2904807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z5TEPw_lpp1C81A1aBBbsQ.png"/></div></div></figure><p id="16e5" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw lz ky kz la ma lc ld le mb lg lh li ij bi translated">这个实验的关键是，</p><h1 id="3bfc" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">“类型是事实&amp; IDE根据我们编写的约束从中推断出进一步的事实”</h1><p id="6ee0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">另一个类比是，当程序由运行时执行时，类型由类型检查器在编译时理解和推断，在我们的例子中是IDE本身。</p><p id="58bf" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw lz ky kz la ma lc ld le mb lg lh li ij bi translated">像这样的系统被数学人称为<strong class="kn ir">定理证明者</strong>使用，许多其他语言可能会跟随这种趋势，在编译时推断事实，防止运行时灾难，如未捕获的异常、内存泄漏等。这种基于类型的工具对开发人员来说是一个福音，慢慢地向软件开发自动化迈出了一小步。</p><p id="edf1" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw lz ky kz la ma lc ld le mb lg lh li ij bi translated">之所以能够用类型系统来表示逻辑，是因为一种叫做<strong class="kn ir">库里—霍华德同构</strong>的现象。你使用的每一种静态类型编程语言，你声明的类型是<strong class="kn ir">定理</strong>，而满足它们的程序是<strong class="kn ir">证明</strong>。一些语言利用了这一特性，而不是像prolog那样的逻辑，它们利用类型本身来证明它们的定理。其中包括精益、Coq、Idris等，它们实现了各种类型的理论。</p></div></div>    
</body>
</html>