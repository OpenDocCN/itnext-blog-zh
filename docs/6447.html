<html>
<head>
<title>Getting image metadata (EXIF) using Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js获取图像元数据(EXIF)</h1>
<blockquote>原文：<a href="https://itnext.io/getting-image-metadata-exif-using-node-js-bd14aeee981d?source=collection_archive---------0-----------------------#2021-11-19">https://itnext.io/getting-image-metadata-exif-using-node-js-bd14aeee981d?source=collection_archive---------0-----------------------#2021-11-19</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj jr"><img src="../Images/b3790e318898517b3df45c57fbd969ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Z_R70gD9mIIObGsvUbV3Q.png"/></div></div><figcaption class="kc kd gk gi gj ke kf bd b be z dk translated">作者图片</figcaption></figure><p id="03b4" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">我们可以在图像中存储额外的数据，比如地理位置坐标、文本字符串等等。虽然有很好的GUI应用程序来处理这些数据，但我们有时需要在Node.js程序中处理这些数据。例如，静态网站生成器平台，如AkashaCMS，可能使用存储在图像中的元数据来自动提供标题或工具提示文本。在本教程中，我们将探索如何读取Node.js中的元数据。</p><p id="d0d0" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">本文的目标是了解如何在Node.js程序中访问图像元数据。</p><p id="6454" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">准确地说，什么是图像元数据？它是图像文件中像素以外的额外数据。像素是我们看到的图像的视觉部分。但是，图像中还可以包含其他非视觉数据项。其中大部分是关于相机、曝光甚至地理位置的数据，但也有可能附加任意信息。</p><p id="264c" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">一种可能的用途是按照拍摄地点对图像进行分类。或者，我们可以存储描述、标题或其他文本项，这些内容将由内容管理系统显示。正如我们将看到的，在图像中可能存储的数据有一个很长的列表。</p><p id="7037" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">访问这些数据的基本原理是，我们需要使用它们来帮助驱动应用程序，向用户显示一些数据，或者做其他任何事情。如何使用这些数据取决于您，但是第一步是知道如何检索这些数据。因为有几个用于这个目的的包，我们将展示每个包的小示例脚本。</p><p id="e6b8" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">有几种元数据格式可用:</p><figure class="lf lg lh li gu jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj le"><img src="../Images/8225e8fd9d1a8038f6a7a4c00d5779b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H6mDx6dMuOlTfPrGt90XtA.png"/></div></div><figcaption class="kc kd gk gi gj ke kf bd b be z dk translated">作者图片</figcaption></figure><p id="b468" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这很好，为了在实践中了解这意味着什么，让我们在Gimp中打开一张照片。</p><figure class="lf lg lh li gu jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj lj"><img src="../Images/d45fdbe4b391abf93ba38b6a724fa30f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wkis2wtAJz_LNGui.jpg"/></div></div><figcaption class="kc kd gk gi gj ke kf bd b be z dk translated">作者图片</figcaption></figure><p id="49e8" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这张图片拍摄于2013年7月，第二届BC-BC电动车耐力跑期间。BC-BC赛事的特色是一场从不列颠哥伦比亚到下加利福尼亚的比赛，展示了电动汽车即使在2013年也能长距离行驶的能力。现在，这似乎是一件司空见惯的事情，因为几家电动汽车制造商正在提供远程电动汽车，但在2013年，这种想法是胡说八道，任何电动汽车都可以进行如此长的旅程。十几辆或更多的汽车参与其中，现在这种旅行已经很平常了，这要归功于快速充电基础设施的增加。这张照片是在红木城的一家汽车经销店拍摄的，它是该活动的众多中途站之一。但是我已经分心了。</p><p id="b5ff" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这里的要点是——在Gimp v2.10中——你打开一个图像文件，然后在<em class="lk">图像</em>菜单中你会发现一个<em class="lk">元数据</em>子菜单，它有一个选择来<em class="lk">编辑</em>元数据，还有一个选择来<em class="lk">查看</em>它。这张照片是用奥林巴斯E-PL2拍摄的，这是我当时拥有的一台微型四分之三无反光镜相机。我已经向下滚动到曝光区域，我看到图像稍微曝光过度，因为曝光偏差在<em class="lk"> 0 EV </em>。我现在知道通常最好设置为<em class="lk"> -2/3 EV </em>，但是我又分心了。真正的要点是有奥林巴斯特有的EXIF价值观和通用的EXIF。图片价值观。它还有XMP和IPTC数据的选项卡，在本例中这两个选项卡都是空的。</p><p id="1a2b" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">有接近无数的图形用户界面应用程序用于编辑图像中的EXIF、XMP和IPTC的数据。其中一些提供批量编辑，也就是说一次为一组图片设置值。对于其他的，比如Gimp，一次只能编辑一个图像文件。</p><p id="d069" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">有一些开源命令行工具，如<code class="fe ll lm ln lo b">exif</code>、<code class="fe ll lm ln lo b">exiv2</code>、<code class="fe ll lm ln lo b">exempi</code>和<code class="fe ll lm ln lo b">exiftool</code>，它们不仅可以读取和写入EXIF值，还可以读取和写入更多值。我使用macOS，并使用MacPorts，四个工具是使用以下命令安装的:</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="92c7" class="lt lu iu lo b gz lv lw l lx ly">$ sudo port install exif exiv2 exempi exiftool<br/> ... <br/>$ exif /Volumes/david/media/2013-07-02-BC-BC/P7050342.JPG <br/>$ exiv2 pr /Volumes/david/media/2013-07-02-BC-BC/P7050342.JPG <br/>$ exempi -x /Volumes/david/media/2013-07-02-BC-BC/P7050342.JPG <br/>$ exiftool -l /Volumes/david/media/2013-07-02-BC-BC/P7050342.JPG</span></pre><p id="cf58" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">有关进一步的用法，请参见每个命令的相应帮助信息。</p><p id="f1f6" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">一个相关的工具是ImageMagick套件。顾名思义，这是一组用图像表演魔术的工具。其中一个工具，<code class="fe ll lm ln lo b">identify</code>，对于检查图像数据很有用。</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="fd42" class="lt lu iu lo b gz lv lw l lx ly">$ identify -verbose \<br/>       /Volumes/david/media/2013-07-02-BC-BC/P7050342.JPG</span></pre><p id="85b7" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这些不同的工具以不同的方式呈现相同的数据。很难指出哪种工具比其他工具更好。Exiftool提供了令人眼花缭乱的长选项列表，但代价是令人困惑的冗长文档。幸运的是，Exiv2的文档更容易理解。</p><p id="d904" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">但是，介绍够了。本文的重点是，我们如何在Node.js程序中访问图像元数据？</p><p id="7318" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">我们的攻击计划是在npm注册表中搜索读取图像元数据的包，这些包可能会更改这些数据，并对它们进行测试。</p><p id="924f" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">我们将创建几个小脚本，所以让我们从创建一个项目目录并初始化<code class="fe ll lm ln lo b">package.json</code>开始:</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="4adf" class="lt lu iu lo b gz lv lw l lx ly">$ mkdir image-metadata <br/>$ cd image-metadata <br/>$ npm init -y</span></pre><p id="9ca8" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这当然是我们为每个Node.js项目所做的。</p><h1 id="dd73" class="lz lu iu bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">使用<code class="fe ll lm ln lo b">exif-parser</code>从图像中读取EXIF标签</h1><p id="8349" class="pw-post-body-paragraph kg kh iu ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld in bi translated">对于第一个脚本，让我们安装<code class="fe ll lm ln lo b">exif-parser</code>包:</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="8122" class="lt lu iu lo b gz lv lw l lx ly">$ npm install exif-parser --save  <br/>+ exif-parser@0.1.12 <br/>added 1 package from 1 contributor and audited 1 package in 1.915s<br/>found 0 vulnerabilities</span></pre><p id="4499" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这是一个相对流行的包，它的主要目的是从图像中读取EXIF数据。</p><p id="e776" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">根据<a class="ae nb" href="https://www.npmjs.com/package/exif-parser" rel="noopener ugc nofollow" target="_blank"> exif-parser文档</a>，我们为它提供一个缓冲区，调用<code class="fe ll lm ln lo b">parse</code>方法，然后我们得到一个名为<code class="fe ll lm ln lo b">tags</code>的对象。这很简单。</p><p id="b403" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">我们将编写简单的脚本，使用ES6模块，并使用顶级异步，如下所述:<a class="ae nb" href="https://techsparx.com/nodejs/async/top-level-async.html" rel="noopener ugc nofollow" target="_blank"> Node.js脚本编写者:顶级异步/等待现在可用</a></p><p id="d781" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">创建一个名为<code class="fe ll lm ln lo b">exif-parser.mjs</code>的文件，包含以下内容:</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="edc4" class="lt lu iu lo b gz lv lw l lx ly">import { promises as fs } from 'fs'; <br/>import ExifParser from 'exif-parser';  </span><span id="4b69" class="lt lu iu lo b gz nc lw l lx ly">const imgbuffer = await fs.readFile(process.argv[2]); <br/>const parser = ExifParser.create(imgbuffer); </span><span id="ecff" class="lt lu iu lo b gz nc lw l lx ly">parser.enableBinaryFields(true); <br/>parser.enableTagNames(true); <br/>parser.enableImageSize(true); <br/>parser.enableReturnTags(true);  </span><span id="387e" class="lt lu iu lo b gz nc lw l lx ly">const img = parser.parse();  </span><span id="284b" class="lt lu iu lo b gz nc lw l lx ly">console.log(img.tags);</span></pre><p id="11e0" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">我们在命令行中读取名为。如果我们不提供一个<code class="fe ll lm ln lo b">encoding</code>，那么<code class="fe ll lm ln lo b">fs.readFile</code>方法将返回一个包含文件数据的<code class="fe ll lm ln lo b">Buffer</code>。这正是我们需要的<code class="fe ll lm ln lo b">ExifParser.create</code>功能。接下来我们要做的是确保设置了一些选项，然后我们调用<code class="fe ll lm ln lo b">parse</code>，最后打印标签:</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="d3b6" class="lt lu iu lo b gz lv lw l lx ly">$ node exif-parser.mjs \<br/>       /Volumes/david/media/2013-07-02-BC-BC/P7050342.JPG <br/>{<br/> ImageDescription: 'OLYMPUS DIGITAL CAMERA ',<br/> Make: 'OLYMPUS IMAGING CORP. ',<br/> Model: 'E-PL2 ',<br/> XResolution: 314,<br/> YResolution: 314,<br/> ResolutionUnit: 2,<br/> ...<br/>}</span></pre><p id="babe" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">我们走吧，简单易用的方法来读取EXIF标签。我看到的唯一问题是，这遗漏了Gimp在这个文件中显示的许多数据。也就是说，Gimp显示了大量特定于Olympus的标记，这里没有显示。</p><h1 id="8bf7" class="lz lu iu bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">使用<code class="fe ll lm ln lo b">exifreader</code>读取图像元数据</h1><p id="a8d6" class="pw-post-body-paragraph kg kh iu ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld in bi translated">让我们进入下一个包，<code class="fe ll lm ln lo b">exifreader</code>。它支持多种图像类型，还支持Exif、IPTC、XMP、ICC和MPF元数据。这可能是一个非常好的选择。</p><p id="7ddb" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">安装:</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="7c82" class="lt lu iu lo b gz lv lw l lx ly">$ npm install exifreader --save </span><span id="e991" class="lt lu iu lo b gz nc lw l lx ly">+ exifreader@4.0.0<br/>added 2 packages from 1 contributor and audited 3 packages in 4.157s <br/>found 0 vulnerabilities</span></pre><p id="8064" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated"><a class="ae nb" href="https://www.npmjs.com/package/exifreader" rel="noopener ugc nofollow" target="_blank">文档页面</a>说如果我们想要一个有限版本的包来支持有限的需求，我们可以生成一个定制的模块。以这种方式安装支持所有文件类型和元数据类型。</p><p id="044c" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">现在创建一个名为<code class="fe ll lm ln lo b">exifreader.mjs</code>的文件，包含:</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="c7cc" class="lt lu iu lo b gz lv lw l lx ly">import { promises as fs } from 'fs'; <br/>import ExifReader from 'exifreader';   <br/>const imgbuffer = await fs.readFile(process.argv[2]); </span><span id="0e62" class="lt lu iu lo b gz nc lw l lx ly">//////// You can do this instead <br/>// const tags = await ExifReader.load(process.argv[2]); </span><span id="93ba" class="lt lu iu lo b gz nc lw l lx ly">const tags = ExifReader.load(imgbuffer, {<br/>     expanded: true,<br/>     includeUnknown: true <br/>});  </span><span id="6306" class="lt lu iu lo b gz nc lw l lx ly">console.log(tags);</span></pre><p id="300c" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">有一个options对象，在本例中，我们设置了每个记录的选项。</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="a1ed" class="lt lu iu lo b gz lv lw l lx ly">$ node exifreader.mjs /Volumes/david/media/2013-07-02-BC-BC/P7050342.JPG  <br/>{<br/>   file: {<br/>     'Bits Per Sample': { value: 8, description: '8' },<br/>     'Image Height': { value: 3024, description: '3024px' },<br/>     'Image Width': { value: 4032, description: '4032px' },<br/>     'Color Components': { value: 3, description: '3' },<br/>     Subsampling: {<br/>         value: [Array], description: 'YCbCr4:2:2 (2 1)' }<br/>   },<br/>   Thumbnail: {<br/>     Compression: { id: 259, value: 6, description: 6 },<br/>     XResolution: { id: 282, value: [Array], description: '72' },<br/>     YResolution: { id: 283, value: [Array], description: '72' },<br/>     ResolutionUnit: { id: 296, value: 2, description: 'inches' },<br/>     JPEGInterchangeFormat: {<br/>          id: 513, value: 11476, description: 11476 },<br/>     JPEGInterchangeFormatLength: {<br/>          id: 514, value: 6929, description: 6929 },<br/>     type: 'image/jpeg',<br/>     image: ArrayBuffer { ... },<br/>     base64: [Getter]<br/>   },<br/>   exif: {<br/>     ImageDescription: {<br/>       id: 270,<br/>       value: [Array],<br/>       description: 'OLYMPUS DIGITAL CAMERA         '<br/>     },<br/>     Make: { id: 271, value: [Array],<br/>       description: 'OLYMPUS IMAGING CORP.  ' },<br/>     Model: { id: 272, value: [Array],<br/>       description: 'E-PL2           ' },<br/>     XResolution: { id: 282, value: [Array], description: '314' },<br/>     YResolution: { id: 283, value: [Array], description: '314' },<br/>     ResolutionUnit: { id: 296, value: 2, description: 'inches' },<br/>     ...<br/>   },<br/>  iptc: {<br/>     'Model Version': { id: 256, value: [Array], description: '4' },<br/>     'Coded Character Set': {<br/>          id: 346, value: [Array], description: 'UTF-8' },<br/>     'Record Version': {<br/>          id: 512, value: [Array], description: '4' },<br/>     'By-line': {<br/>          id: 592, value: [Array], description: 'Picasa' }   },<br/>   xmp: {<br/>     about: { value: '', attributes: {}, description: '' },<br/>     ModifyDate: {<br/>       value: '2013-07-08T15:40:38-07:00',<br/>       attributes: {},<br/>       description: '2013-07-08T15:40:38-07:00'<br/>     },<br/>     creator: {<br/>       value: [Array], attributes: {}, description: 'Picasa' }<br/>   }<br/> }</span></pre><p id="2fab" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">返回的对象有五个字段:<code class="fe ll lm ln lo b">file</code>，描述文件，<code class="fe ll lm ln lo b">Thumbnail</code>，包含缩略图，<code class="fe ll lm ln lo b">exif</code>，包含EXIF数据，<code class="fe ll lm ln lo b">iptc</code>，包含IPTC数据，<code class="fe ll lm ln lo b">xmp</code>，包含XMP数据。它是一种很好的数据结构，很容易理解。</p><h1 id="080e" class="lz lu iu bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">使用<code class="fe ll lm ln lo b">exiftool-vendored</code>读取图像元数据</h1><p id="0b50" class="pw-post-body-paragraph kg kh iu ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld in bi translated">有两个Node.js包围绕着<code class="fe ll lm ln lo b">exiftool</code>程序，<code class="fe ll lm ln lo b">exiftool</code>和<code class="fe ll lm ln lo b">exiftool2</code>，看起来它们不是好的选择。相反，<code class="fe ll lm ln lo b">exiftool-vendored</code>看起来更像是<code class="fe ll lm ln lo b">exiftool</code>的包装。</p><p id="8341" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">现在的情况是<code class="fe ll lm ln lo b">exiftool</code>是一个Perl脚本，可以作为常规命令行工具使用。这些包装器包在后台执行这个脚本，而不是在Node.js中实现元数据解析，让<code class="fe ll lm ln lo b">exiftool-vendored</code>有趣的是高质量的API。</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="17e5" class="lt lu iu lo b gz lv lw l lx ly">$ npm install exiftool-vendored --save </span><span id="a357" class="lt lu iu lo b gz nc lw l lx ly">+ exiftool-vendored@15.6.0<br/>added 6 packages from 6 contributors and audited 10 packages in 13.673s<br/>found 0 vulnerabilities</span></pre><p id="dea4" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">文档站点<a class="ae nb" href="https://photostructure.github.io/exiftool-vendored.js/" rel="noopener ugc nofollow" target="_blank">给出了这个包能做什么的感觉。也就是说，它能够从图像文件中读取一个很长的元数据项列表，其中支持的标签来自一个很大的样本图像库。在某些情况下，文档还会让您参考<code class="fe ll lm ln lo b">exiftool</code>文档。</a></p><p id="46a1" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">要参考的一个重要页面是<a class="ae nb" href="https://photostructure.github.io/exiftool-vendored.js/interfaces/Tags.html" rel="noopener ugc nofollow" target="_blank">支持的标签列表</a>。</p><p id="df64" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">现在，创建一个名为<code class="fe ll lm ln lo b">exiftool-vendored.mjs</code>的文件，其中包含:</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="0150" class="lt lu iu lo b gz lv lw l lx ly">import { exiftool } from 'exiftool-vendored'; </span><span id="6874" class="lt lu iu lo b gz nc lw l lx ly">// The `exiftool` import is a prebaked instance of the ExifTool class with <br/>// sensible defaults.  If you want different defaults, change the  <br/>// import statement and run this instead:  <br/>// const exiftool = new ExifTool({ taskTimeoutMillis: 5000 })</span><span id="e921" class="lt lu iu lo b gz nc lw l lx ly">const tags = await exiftool.read(process.argv[2]);<br/>console.log(tags);<br/>exiftool.end();</span></pre><p id="36bb" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">正如评论中所说，您可以通过自己调用<code class="fe ll lm ln lo b">ExifTool</code>构造函数来创建一个定制的<code class="fe ll lm ln lo b">exiftool</code>实例。</p><p id="9b06" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">调用<code class="fe ll lm ln lo b">exiftool.read</code>异步读取已命名的图像文件，并返回一个<code class="fe ll lm ln lo b">tags</code>对象。我们也可以用它来写标签，等等。</p><p id="29ca" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">需要调用<code class="fe ll lm ln lo b">exiftool.end</code>以便脚本退出。</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="5b48" class="lt lu iu lo b gz lv lw l lx ly">$ node exiftool-vendored.mjs /Volumes/david/media/2013-07-02-BC-BC/P7050342.JPG  <br/>{<br/>   SourceFile: '/Volumes/david/media/2013-07-02-BC-BC/P7050342.JPG',<br/>   errors: [],   ExifToolVersion: 12.34,<br/>   FileName: 'P7050342.JPG',<br/>   Directory: '/Volumes/david/media/2013-07-02-BC-BC',<br/>   FileSize: '4.3 MiB',<br/>   FileModifyDate: ExifDateTime {<br/>     year: 2013,<br/>     month: 7,<br/>     day: 5,<br/>     hour: 10,<br/>     minute: 52,<br/>     second: 4,<br/>     millisecond: 0,<br/>     tzoffsetMinutes: -420,<br/>     rawValue: '2013:07:05 10:52:04-07:00',<br/>     zoneName: 'UTC-7'<br/>   },<br/>   ... <br/>}</span></pre><p id="12cd" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这将打印出返回的对象。需要注意的一件重要事情是，这个对象没有列出IPTC或XMP字段等。发生的事情是，我在这里使用的图像不包含这些种类的标签。</p><p id="99a7" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">底层工具<code class="fe ll lm ln lo b">exiftool</code>支持其他类型的元数据。并且查阅标签文档页面验证它将读取所有受<code class="fe ll lm ln lo b">exiftool</code>支持的标签。</p><h1 id="53bd" class="lz lu iu bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">使用<code class="fe ll lm ln lo b">imagemagick</code>读取图像元数据</h1><p id="67c5" class="pw-post-body-paragraph kg kh iu ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld in bi translated">ImageMagick包是一套全面的工具，不仅可以读取图像元数据，还可以执行各种切片和切割操作。那个包裹的细节见http://www.imagemagick.org/<a class="ae nb" href="http://www.imagemagick.org/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="a88e" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">Node.js 的<a class="ae nb" href="https://www.npmjs.com/package/imagemagick" rel="noopener ugc nofollow" target="_blank"> imagemagick包是命令行工具的包装器。要使用此软件包，您必须首先安装ImageMagick。幸运的是，它很容易获得，例如通过MacPorts或macOS上的HomeBrew，或者在Linux发行版的标准包管理器中。</a></p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="05f2" class="lt lu iu lo b gz lv lw l lx ly">$ npm install imagemagick --save </span><span id="a967" class="lt lu iu lo b gz nc lw l lx ly">+ imagemagick@0.1.3 <br/>added 1 package from 1 contributor and audited 11 packages in 8.568s <br/>found 0 vulnerabilities</span></pre><p id="8095" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">然后创建一个名为<code class="fe ll lm ln lo b">imagemagick.mjs</code>的文件，其中包含:</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="4f5d" class="lt lu iu lo b gz lv lw l lx ly">import im from 'imagemagick';  </span><span id="fbb6" class="lt lu iu lo b gz nc lw l lx ly">const metadata = await new Promise((resolve, reject) =&gt; {<br/>     im.readMetadata(process.argv[2], function(err, metadata) {<br/>         if (err) reject(err);<br/>         else resolve(metadata);<br/>     });<br/>});  </span><span id="342c" class="lt lu iu lo b gz nc lw l lx ly">console.log(metadata);  </span><span id="92ce" class="lt lu iu lo b gz nc lw l lx ly">const identified = await new Promise((resolve, reject) =&gt; {<br/>     im.identify(process.argv[2], function(err, metadata) {<br/>         if (err) reject(err);<br/>         else resolve(metadata);<br/>     }); <br/>});  </span><span id="51f3" class="lt lu iu lo b gz nc lw l lx ly">console.log(identified);</span></pre><p id="3ff4" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">首先，这个包是对Node.js旧时代的回归，在那里所有的事情都是通过回调函数来完成的。这个包的一个主要问题是，它已经九年没有更新了，因此对Promise的一无所知，因此我们不能对这个包使用<code class="fe ll lm ln lo b">await</code>。这意味着我们必须用一个承诺包装来包裹它，如下所示。</p><p id="7c46" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">我们演示了两种读取元数据的方法。</p><p id="5001" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated"><code class="fe ll lm ln lo b">readMetadata</code>方法调用<code class="fe ll lm ln lo b">identify</code> CLI工具。它解析输出，并返回包含数据的对象。</p><p id="437c" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">可选地，我们可以使用<code class="fe ll lm ln lo b">identify</code>方法，该方法也调用<code class="fe ll lm ln lo b">identify</code> CLI工具，解析输出，并返回包含数据的对象。这两个物体相似，但不同。你可能更喜欢其中一个。</p><h1 id="99d0" class="lz lu iu bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">使用<code class="fe ll lm ln lo b">sharp</code>读取图像元数据</h1><p id="295c" class="pw-post-body-paragraph kg kh iu ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld in bi translated">Sharp是一个现代的图像处理包，是JavaScript的原生包。您不需要使用命令行工具，而是需要处理一个很好的JavaScript API。它有许多方法，其中之一是读取图像元数据，甚至更改元数据的能力。</p><p id="002f" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">完整文档:<a class="ae nb" href="https://sharp.pixelplumbing.com/" rel="noopener ugc nofollow" target="_blank">https://sharp.pixelplumbing.com/</a></p><p id="788d" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">包主页:<a class="ae nb" href="https://www.npmjs.com/package/sharp" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/sharp</a></p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="3a6f" class="lt lu iu lo b gz lv lw l lx ly">$ npm install sharp --save  <br/>+ sharp@0.29.3 <br/>added 67 packages from 197 contributors and audited 78 packages in 44.277s  <br/>found 0 vulnerabilities</span></pre><p id="1720" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">因为这依赖于一个本地代码库libvips，所以它要么下载一个预编译的库，要么编译这个库，作为<code class="fe ll lm ln lo b">npm install</code>阶段的一部分。</p><p id="6be6" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">创建一个名为<code class="fe ll lm ln lo b">sharp.mjs</code>的文件，其中包含:</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="9691" class="lt lu iu lo b gz lv lw l lx ly">import sharp from 'sharp';  <br/>const data = await sharp(process.argv[2]).metadata(); <br/>console.log(data);</span></pre><p id="64e3" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">Sharp是一个现代的软件包，它使用了一个富有表现力的API。这意味着<code class="fe ll lm ln lo b">sharp</code>函数返回一个带有支持链接操作的API方法的对象。目前我们感兴趣的是元数据，它是我们用这种方法得到的。</p><p id="72ab" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这看起来很简单，但是…</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="4c4b" class="lt lu iu lo b gz lv lw l lx ly">$ node sharp.mjs /Volumes/david/media/2013-07-02-BC-BC/P7050342.JPG<br/>{<br/>   format: 'jpeg',<br/>   width: 4032,<br/>   height: 3024,<br/>   space: 'srgb',<br/>   channels: 3,<br/>   depth: 'uchar',<br/>   density: 314,<br/>   chromaSubsampling: '4:2:0',<br/>   isProgressive: false,<br/>   hasProfile: false,<br/>   hasAlpha: false,<br/>   exif: &lt;Buffer 45 78 69 66 ... &gt;,<br/>   iptc: &lt;Buffer 50 68 6f 74 ... &gt;,<br/>   xmp: &lt;Buffer 3c 3f 78 70 ... &gt;<br/> }</span></pre><p id="774f" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">结果是<code class="fe ll lm ln lo b">exif</code>、<code class="fe ll lm ln lo b">iptc</code>和<code class="fe ll lm ln lo b">xmp</code>字段包含原始数据，而不是经过解析的数据。哈姆。这是一个不透明的物体，我们无法从它那里获取磁场。这不是希望的结果，也不符合夏普的其他功能。</p><p id="efd2" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">换句话说，Sharp还包括一个在创建新图像时设置元数据字段的方法。使用Sharp文档中的示例，让我们编写另一个脚本，<code class="fe ll lm ln lo b">sharp-add-copyright.mjs</code>:</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="4b62" class="lt lu iu lo b gz lv lw l lx ly">import sharp from 'sharp';  <br/>const data = await sharp(process.argv[2])<br/>     .withMetadata({<br/>         exif: {<br/>             IFD0: {<br/>                 Copyright: process.argv[3]<br/>             }<br/>         }<br/>     })<br/>     .toFile(process.argv[4]);</span></pre><p id="9e1c" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">此示例将图像输入到Sharp处理流，将版权数据添加到EXIF，并将结果输出到新文件。顺便说一下，这是Sharp使用的典型模式，即从输入到输出构建一个处理管道。</p><p id="e0eb" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">我们可以这样运行这个例子:</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="af02" class="lt lu iu lo b gz lv lw l lx ly">$ node sharp-add-copyright.mjs \<br/>       /Volumes/david/media/2013-07-02-BC-BC/P7050342.JPG \ <br/>       'David Herron' \<br/>       img-copyright.jpg</span></pre><p id="4483" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">我拍摄了这张照片，所以我应该得到版权。接下来，在输入文件和输出文件上运行<code class="fe ll lm ln lo b">exif</code>命令，您会看到输出文件现在列出了:</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="39f0" class="lt lu iu lo b gz lv lw l lx ly">Copyright           |David Herron (Photographer) - [None] (Editor)</span></pre><p id="fe3e" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这是很好的，我们可以修改EXIF设置使用夏普。但是，如果夏普能够展示EXIF、IPTC和XMP标签的结构，难道不是很有意义吗？为什么它做不到这一点？</p><h1 id="2e3d" class="lz lu iu bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">设置EXIF/IPTC/XMP元数据值</h1><p id="14e3" class="pw-post-body-paragraph kg kh iu ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld in bi translated">这使我们面临一个共同的任务，不仅要读取元数据值，还要修改它们。我们已经演示了几种在Node.js应用程序中读取元数据值的方法，我们可以使用这些方法来构建基于元数据的图像索引。但是，要创建一个有用的索引，我们需要设置元数据值。在互联网上发布图片之前，我们不应该在元数据中附上版权声明吗？</p><p id="023e" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">让我们从命令行工具开始。在ImageMagick套件中，似乎必须有一个使用<code class="fe ll lm ln lo b">convert</code>或<code class="fe ll lm ln lo b">mogrify</code>命令设置EXIF值的咒语。但是我没能解决这个问题。相反，我发现<code class="fe ll lm ln lo b">exiftool</code>命令更简单。</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="b6a7" class="lt lu iu lo b gz lv lw l lx ly">$ exiftool -copyright='David Herron' -artist='David Herron' \<br/> /Volumes/david/media/ 2013-07-02-BC-BC/P7050342.JPG <br/>$ exif /Volumes/david/media/ 2013-07-02-BC-BC/P7050342.JPG <br/>... <br/>Artist    |David Herron <br/>... <br/>Copyright |David Herron (Photographer) - [None] (Editor) <br/>...</span></pre><p id="2e34" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">从Node.js脚本驱动它的最有效方式是使用<code class="fe ll lm ln lo b">shelljs</code>包。Shelljs帮助您编写通常作为shell脚本编写的内容，但是这些脚本更易于移植，可以在Windows上不加修改地运行(例如)。</p><p id="9c5e" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">经过一些试验，我最终得到了下面的脚本:</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="1520" class="lt lu iu lo b gz lv lw l lx ly">import { default as shell } from 'shelljs';  </span><span id="f1ac" class="lt lu iu lo b gz nc lw l lx ly">const artist = process.argv[2]; <br/>const fn = process.argv[3];  <br/>shell.exec(`exiftool -copyright -artist ${fn}`);  <br/>shell.exec(`exiftool -copyright='${artist}' -artist='${artist}' ${fn}`);  <br/>shell.exec(`exiftool -copyright -artist ${fn}`);</span></pre><p id="36ac" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这个脚本演示了这种变化，因此比通常的脚本更加冗长。</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="effa" class="lt lu iu lo b gz lv lw l lx ly">$ node shelljs-add-exif.mjs 'David Herron' \<br/> /Volumes/david/media/2013-07-02-BC-BC/P7050340.JPG</span><span id="f546" class="lt lu iu lo b gz nc lw l lx ly">Copyright :<br/>Artist :<br/> 1 image files updated <br/>Copyright : David Herron <br/>Artist : David Herron</span></pre><p id="988f" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">浏览一下shelljs文档会给你各种各样的想法。</p><p id="05b5" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">请注意，该脚本正在打印每个命令的输出。这可以通过自定义以下内容来更改:</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="8fb3" class="lt lu iu lo b gz lv lw l lx ly">shell.exec(`exiftool -copyright='${artist}' -artist='${artist}' ${fn}`,<br/>      (code, stdout, stderr) =&gt; {<br/>         // code is the process exit code<br/>         // stdout is the text from the standard output<br/>         // stderr is the text from the standard error output <br/>});</span></pre><p id="108b" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">例如，可以通过使用<code class="fe ll lm ln lo b">shell.cp</code>命令在修改文件之前复制它来改进这个脚本。另一个想法是使用GUI应用程序进行初始筛选，设置EXIF标签来标记每个图像的处理，然后脚本查询哪些文件设置了某些EXIF/XMP/etc标签，并执行给定的操作。</p><p id="88ab" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">类似的工具是<code class="fe ll lm ln lo b">zx</code>(<a class="ae nb" href="https://npmjs.com/package/zx" rel="noopener ugc nofollow" target="_blank">https://npmjs.com/package/zx</a>)。</p><p id="fea2" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">在<a class="ae nb" href="https://exiftool.org/" rel="noopener ugc nofollow" target="_blank">https://exiftool.org/</a>有大量关于图像元数据的细节..虽然<code class="fe ll lm ln lo b">exiftool</code>命令非常强大，但在清晰度和易用性方面还有很多不足之处。项目页面是这样说的:</p><blockquote class="nd ne nf"><p id="d5a2" class="kg kh lk ki b kj kk kl km kn ko kp kq ng ks kt ku nh kw kx ky ni la lb lc ld in bi translated"><em class="iu">如果你觉得有必要将“find”或“awk”与ExifTool结合使用，那么你很可能还没有发现ExifTool的全部威力。</em></p></blockquote><p id="e8ea" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">我对此有不同的看法。人们在使用ExifTool时转向其他工具，这表达了他们对不同用户界面的渴望。“非常棒的工具”一定要有“很长的学习曲线”吗？我相信让普通人也能理解的用户界面或API是很重要的。</p><p id="9a9f" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">另一个工具exi v2(<a class="ae nb" href="https://exiv2.org/index.html" rel="noopener ugc nofollow" target="_blank">https://exiv2.org/index.html</a>)与ExifTool大致相同。它支持与ExifTool相同的元数据类型，其网站也有大量关于图像元数据的信息。因为它是用C++实现的，所以更容易集成到其他应用程序中。它的命令行工具更容易理解。例如:</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="6ff3" class="lt lu iu lo b gz lv lw l lx ly">$ exiv2 -M"reg myprefix http://ns.myprefix.me/" \<br/> -M"add Xmp.myprefix.Whom Mr. Smith" \<br/> -M"set Exif.Image.Artist Mr. Smith" \<br/> image.jpg</span></pre><p id="ab58" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这演示了如何使用一种相当容易理解的语法来设置多个元数据值。需要<code class="fe ll lm ln lo b">reg</code>命令，以便XMP支持知道如何记录<code class="fe ll lm ln lo b">Xmp.myprefix</code>。</p><p id="b4ab" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这将打印所有元数据。</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="91fc" class="lt lu iu lo b gz lv lw l lx ly">$ exiv2 -g Whom -g Artist \<br/>       /Volumes/david/media/2013-07-02-BC-BC/P7050341.JPG <br/>Exif.Image .Artist Ascii 13 David Herron <br/>Xmp.myprefix .Whom XmpText 12 David Herron</span></pre><p id="68a7" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated"><code class="fe ll lm ln lo b">-g</code>选项是我们在元数据中搜索特定值的方式。</p><p id="e3b8" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">Exiv2有一个Node.js模块，我们在荣誉奖部分简单讨论一下。</p><h1 id="1bff" class="lz lu iu bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">剥离图像元数据</h1><p id="d1c5" class="pw-post-body-paragraph kg kh iu ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld in bi translated">另一个常见的任务是剥离元数据以最小化任何隐私问题。例如，您的手机图像通常具有地理位置数据。给脸书贴上你在杂货店发现的一个有趣的标志，你会立刻通知任何查看这张图片的人照片拍摄地的纬度/经度。这类信息可能会被用来对付你。</p><p id="a583" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">使用ImageMagick，我们可以这样做:</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="5b8a" class="lt lu iu lo b gz lv lw l lx ly">$ convert /Volumes/david/media/2013-07-02-BC-BC/P7050340.JPG \<br/>         -strip \<br/>         img-stripped.jpg <br/>$ exif img-stripped.jpg  <br/>Corrupt data The data provided does not follow the specification. <br/>ExifLoader: The data supplied does not seem to contain EXIF data.</span></pre><p id="d9e1" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">结果是一个完美的JPEG，但是没有EXIF/XMP/etc数据。</p><p id="73f6" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">使用Exiv2，<code class="fe ll lm ln lo b">-d</code>选项相当于<code class="fe ll lm ln lo b">-strip</code>命令。或者，您可以使用<code class="fe ll lm ln lo b">-M del Exif.foo.bar</code>来针对特定的标签进行删除。</p><p id="6a37" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">对前面显示的<code class="fe ll lm ln lo b">sharp-add-copyright.mjs</code>脚本的简单修改可以去掉特定的元数据标签。例如，显示相机类型或曝光的标签不构成隐私问题，而地理定位标签则构成。修改该脚本，将这些标记设置为空值，就可以达到这个目的。</p><h1 id="3a81" class="lz lu iu bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">荣誉奖</h1><p id="156f" class="pw-post-body-paragraph kg kh iu ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld in bi translated">在研究这篇文章的过程中，我遇到了一些很有前途的工具，但它们还不够有用。</p><p id="808b" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">Node.js 的<a class="ae nb" href="https://www.npmjs.com/package/exiv2" rel="noopener ugc nofollow" target="_blank"> Exiv2包与Exiv2 C++库接口。文档显示了一个非常好的API。但是，它只与Node.js v0.8.x兼容，与当前的Node.js不兼容。</a></p><p id="3eb8" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated"><a class="ae nb" href="https://www.npmjs.com/package/@11ways/exiv2" rel="noopener ugc nofollow" target="_blank"> @11ways/exiv2包</a>可能是为modern Node.js更新它的一个分支，事实上，它在macOS上与Node.js 16.x一起安装，但在这样做时会打印出无数警告。以下程序成功读取了图像元数据:</p><pre class="lf lg lh li gu lp lo lq lr aw ls bi"><span id="a16f" class="lt lu iu lo b gz lv lw l lx ly">import { default as ex } from '@11ways/exiv2';  </span><span id="1121" class="lt lu iu lo b gz nc lw l lx ly">const tags = await new Promise((resolve, reject) =&gt; {<br/>     ex.getImageTags(process.argv[2], function(err, tags) {<br/>         if (err) reject(err);<br/>         else resolve(tags);<br/>     }); <br/>});  </span><span id="c8f8" class="lt lu iu lo b gz nc lw l lx ly">console.log(tags);</span></pre><p id="52e7" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">因为原API是7年的，不支持承诺等。据推测，<code class="fe ll lm ln lo b">@11ways</code>团队正在开发这个包，如果没有别的事情，他们还有一堆警告要解决。</p><p id="8322" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">Node.js 的<a class="ae nb" href="https://www.npmjs.com/package/exifer" rel="noopener ugc nofollow" target="_blank"> Exifer包看起来很有前途。要读取EXIF、IPTC或XMP标签，需要使用附加软件包。但是在测试中，它似乎不能正常工作。</a></p><p id="8dbf" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">Node.js 的<a class="ae nb" href="https://github.com/hMatoba/piexifjs" rel="noopener ugc nofollow" target="_blank"> piexif包看起来很有前途。虽然文档表明它可以读取元数据，也可以插入元数据，但并不完全清楚该怎么做。</a></p><h1 id="4fe1" class="lz lu iu bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">摘要</h1><p id="1910" class="pw-post-body-paragraph kg kh iu ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld in bi translated">我们已经了解了一系列读取和操作图像元数据的工具。</p><p id="9fd6" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">Node.js对该区域的支持很弱。虽然有几个软件包很好地支持读取图像元数据，但是一旦你想要操作(添加、删除或更改)元数据，你就只能使用其他工具了。但是如果我们的目标是交付Node.js应用程序或服务，我们就有所欠缺。</p><p id="9141" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">我们对Node.js代码的最佳选择是集成Exiv2命令行界面。要探索的另一个步骤是更新它的Node.js包以支持现代Node.js版本。</p><p id="bc32" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">另一个探索的步骤是让Sharp包交付解析的EXIF/IPTC/XMP数据。Sharp的优势在于它是一个通用的图像操作库，可以按原样用于设置元数据值。</p><h1 id="28c6" class="lz lu iu bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">关于作者</h1><p id="6ac8" class="pw-post-body-paragraph kg kh iu ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld in bi translated"><a class="ae nb" href="https://techsparx.com/about.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iv"> <em class="lk">大卫·赫伦</em> </strong> </a> <em class="lk">:大卫·赫伦是一名作家和软件工程师，专注于技术的明智使用。他对太阳能、风能和电动汽车等清洁能源技术特别感兴趣。David在硅谷从事了近30年的软件工作，从电子邮件系统到视频流，再到Java编程语言，他已经出版了几本关于Node.js编程和电动汽车的书籍。</em></p><p id="b997" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated"><em class="lk">最初发表于</em><a class="ae nb" href="https://techsparx.com/nodejs/graphics/image-metadata.html" rel="noopener ugc nofollow" target="_blank"><em class="lk">https://techsparx.com</em></a><em class="lk">。</em></p></div></div>    
</body>
</html>