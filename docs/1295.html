<html>
<head>
<title>Refactoring in Swift: Typealias-ing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的重构:类型别名化</h1>
<blockquote>原文：<a href="https://itnext.io/refactoring-swift-using-typealias-93b3c03bb5a9?source=collection_archive---------2-----------------------#2018-09-02">https://itnext.io/refactoring-swift-using-typealias-93b3c03bb5a9?source=collection_archive---------2-----------------------#2018-09-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a894" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">除了将JSON定义为[String: Any]之外，Typealiases还可以有更多用途</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3e7b00ef308212d1e2efb87206b3dfde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0g9v_DDfTL7nNqlk"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe kv kw kx ky b">typealias Swift = Apodidae. </code>翠鸟无血缘关系。</figcaption></figure><h2 id="c48f" class="kz la iq bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">经典用途</h2><p id="01b4" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md li me mf mg lm mh mi mj lq mk ml mm mn ij bi translated">您可能以前见过或使用过这些类型别名之一:</p><pre class="kg kh ki kj gt mo ky mp mq aw mr bi"><span id="2a3f" class="kz la iq ky b gy ms mt l mu mv"><em class="mw">// To give commonly used structures a name</em><br/>typealias JSON = [String: Any]</span><span id="2d12" class="kz la iq ky b gy mx mt l mu mv"><em class="mw">// To combine two or more protocols into a protocol composition</em><br/>typealias UserAPI = GetUserInterface &amp; UpdateUserInterface</span><span id="62a9" class="kz la iq ky b gy mx mt l mu mv"><em class="mw">// To make a closure type more readable</em><br/>typealias Callback = <!-- -->(() -&gt; ())</span></pre><p id="eff8" class="pw-post-body-paragraph lv lw iq lx b ly my jr ma mb mz ju md li na mf mg lm nb mi mj lq nc ml mm mn ij bi translated">本文不讨论这些情况——有一种更简单的方法可以改进代码！</p><h2 id="a613" class="kz la iq bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">单位清晰度</h2><p id="dae5" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md li me mf mg lm mh mi mj lq mk ml mm mn ij bi translated">前几天，我编写了一个包含一些商业逻辑的函数来计算一顿饭中的卡路里数。结果是这样的:</p><pre class="kg kh ki kj gt mo ky mp mq aw mr bi"><span id="95d4" class="kz la iq ky b gy ms mt l mu mv">func calculate(carbs: Float, protein: Float, fat: Float) -&gt; Float</span></pre><p id="33d4" class="pw-post-body-paragraph lv lw iq lx b ly my jr ma mb mz ju md li na mf mg lm nb mi mj lq nc ml mm mn ij bi translated">现在，<em class="mw">我</em>知道这个函数取什么单位，返回什么单位，但是其他人会知道吗？</p><p id="d36f" class="pw-post-body-paragraph lv lw iq lx b ly my jr ma mb mz ju md li na mf mg lm nb mi mj lq nc ml mm mn ij bi translated">考虑一下<code class="fe kv kw kx ky b">TimeInterval</code>。它实际上是一个<code class="fe kv kw kx ky b">Double</code>，但是每当我们看到一个<code class="fe kv kw kx ky b">TimeInterval</code>时，我们立即知道该值是以秒为单位的预期值。</p><pre class="kg kh ki kj gt mo ky mp mq aw mr bi"><span id="bb2d" class="kz la iq ky b gy ms mt l mu mv"><em class="mw">// UIView.h</em><br/>func animate(withDuration duration: TimeInterval, animations: @escaping () -&gt; Swift.Void)</span></pre><p id="dffc" class="pw-post-body-paragraph lv lw iq lx b ly my jr ma mb mz ju md li na mf mg lm nb mi mj lq nc ml mm mn ij bi translated">我的<code class="fe kv kw kx ky b">calculate</code>功能甚至可以在添加文档注释之前得到改进:</p><pre class="kg kh ki kj gt mo ky mp mq aw mr bi"><span id="66cd" class="kz la iq ky b gy ms mt l mu mv"><em class="mw">/// A weight representation in Grams<br/></em>typealias Grams = Float</span><span id="0773" class="kz la iq ky b gy mx mt l mu mv"><em class="mw">/// Kilo-calories</em><br/>typealias kCal = Float</span><span id="e70a" class="kz la iq ky b gy mx mt l mu mv">func calculate(carbs: Grams, protein: Grams, fat: Grams) -&gt; kCal</span></pre><p id="a461" class="pw-post-body-paragraph lv lw iq lx b ly my jr ma mb mz ju md li na mf mg lm nb mi mj lq nc ml mm mn ij bi translated">看起来那些论点根本不是用国际单位制的！</p><h2 id="06af" class="kz la iq bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">传统API</h2><p id="50b1" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md li me mf mg lm mh mi mj lq mk ml mm mn ij bi translated">类型别名还有许多其他类似的用途。在我们当前的项目中，我们在与以整数形式返回布尔值的API集成时使用了它们(是的，🙄).这是我们从其中一个端点获得的结果的模型:</p><pre class="kg kh ki kj gt mo ky mp mq aw mr bi"><span id="73a8" class="kz la iq ky b gy ms mt l mu mv">struct BadgeInfo: Decodable {<br/>            <br/>    let lunch_flg: Int <em class="mw">// 0 or 1</em><br/>    let dinner_flg: Int <em class="mw">// 0 or 1</em><br/>    let snack_flg: Int <em class="mw">// 0 or 1</em><br/>}</span></pre><p id="4eda" class="pw-post-body-paragraph lv lw iq lx b ly my jr ma mb mz ju md li na mf mg lm nb mi mj lq nc ml mm mn ij bi translated">这并不理想，但是我们可以确保需要与这些模型交互的其他开发人员意识到这三个属性只能是<code class="fe kv kw kx ky b">0</code>或<code class="fe kv kw kx ky b">1</code>，而不需要他们检查模型文件的注释:</p><pre class="kg kh ki kj gt mo ky mp mq aw mr bi"><span id="29dd" class="kz la iq ky b gy ms mt l mu mv"><em class="mw">/// An integer that can only be zero or one (support for </em>🙄<em class="mw"> API)</em><br/>typealias BoolInt = Int</span><span id="acfa" class="kz la iq ky b gy mx mt l mu mv">struct BadgeInfo: Decodable {<br/>            <br/>    let lunch_flg: BoolInt<br/>    let dinner_flg: BoolInt<br/>    let snack_flg: BoolInt<br/>}</span></pre><p id="ad9c" class="pw-post-body-paragraph lv lw iq lx b ly my jr ma mb mz ju md li na mf mg lm nb mi mj lq nc ml mm mn ij bi translated">你现在就可以对你的项目这样做——它只改变了一个文件，而且(在我看来)它使你的代码更具可读性。</p><h2 id="0038" class="kz la iq bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">会员人数</h2><p id="590b" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md li me mf mg lm mh mi mj lq mk ml mm mn ij bi translated">我最喜欢的typealias的另一个用途是跟踪标识符:</p><pre class="kg kh ki kj gt mo ky mp mq aw mr bi"><span id="d6a1" class="kz la iq ky b gy ms mt l mu mv">typealias MemberIdentifier = String<br/>typealias PassengerIdentifier = String</span></pre><p id="1582" class="pw-post-body-paragraph lv lw iq lx b ly my jr ma mb mz ju md li na mf mg lm nb mi mj lq nc ml mm mn ij bi translated">如果您可以在需要成员编号时使用这些标识符，那么任何阅读您的代码的人都会立即清楚哪个参数需要哪个标识符。</p><pre class="kg kh ki kj gt mo ky mp mq aw mr bi"><span id="4931" class="kz la iq ky b gy ms mt l mu mv"><em class="mw">// Before - are we linking with the membership id or passenger id?</em><br/>func link(user: String, to flight: Flight)</span><span id="4e9e" class="kz la iq ky b gy mx mt l mu mv"><em class="mw">// After - aha! (of course, the argument name could be tidied too..)</em><br/>func link(user: PassengerIdentifier, to flight: Flight)</span></pre><p id="52e6" class="pw-post-body-paragraph lv lw iq lx b ly my jr ma mb mz ju md li na mf mg lm nb mi mj lq nc ml mm mn ij bi translated">我们在这个场景中发现的另一个受欢迎的副作用是:我们的静态模拟API返回整数形式的成员数，但是当我们第一次被允许访问真正的模拟时，我们发现成员数实际上是字符串。将<code class="fe kv kw kx ky b">MemberIdentifier</code>的定义从<code class="fe kv kw kx ky b">Int</code>更改为<code class="fe kv kw kx ky b">String</code>，然后清除一些编译错误，这比对每个引用都进行更改要快得多！</p><h2 id="e0c4" class="kz la iq bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">还有更多</h2><p id="0e85" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md li me mf mg lm mh mi mj lq mk ml mm mn ij bi translated">类型别名是一种不断出现的语言特性。作为这篇文章的结尾，下面是一些关于下次编写函数时如何使用类型化的灵感:</p><pre class="kg kh ki kj gt mo ky mp mq aw mr bi"><span id="5199" class="kz la iq ky b gy ms mt l mu mv"><em class="mw">// It's clear that the angle is in Radians and not Degrees</em><br/>func pointOnCircumference(given angle: Radians) -&gt; CGPoint</span><span id="0c07" class="kz la iq ky b gy mx mt l mu mv"><em class="mw">// This can be used for a number that must be from 0.0 to 1.0</em><br/>typealias Percentage = Float</span><span id="67bd" class="kz la iq ky b gy mx mt l mu mv"><em class="mw">// Sometimes UIKit APIs still use NSAttributedStringKeys as strings<br/>// But don't make your attribute dictionaries [String: Any]!</em><br/>let someLegacyAttributes: [NSAttributedStringKey.RawValue: Any]</span><span id="4779" class="kz la iq ky b gy mx mt l mu mv"><em class="mw">// For when you are passing around a dictionary of <br/>// ["English": "en", "Japanese": "ja"...]</em><br/>typealias Language = String<br/>typealias LanguageCode = String<br/>let languageMap: [Language: LanguageCode] = ...</span></pre></div></div>    
</body>
</html>