<html>
<head>
<title>Exploring Kubernetes Liveness- and Readiness-probes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Kubernetes活性和就绪性探针</h1>
<blockquote>原文：<a href="https://itnext.io/exploring-kubernetes-liveness-and-readiness-probes-e9bbc7d899be?source=collection_archive---------0-----------------------#2018-09-08">https://itnext.io/exploring-kubernetes-liveness-and-readiness-probes-e9bbc7d899be?source=collection_archive---------0-----------------------#2018-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="69d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">代号和事情:</em><a class="ae km" href="https://github.com/trondhindenes/K8sProbeTester" rel="noopener ugc nofollow" target="_blank">【https://github.com/trondhindenes/K8sProbeTester】</a></p><p id="4d16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不久前，我们的一个开发人员注意到他们的一个rest apis在部署期间宕机了几秒钟，尽管我们觉得我们调整了部署清单，添加了探测和延迟等等。这导致了一些来回，我从来没有时间坐下来好好想想。直到现在。我和我的两个最好的朋友(coffee和quiet)决定坐下来，弄清楚这些东西在激动人心但相对复杂的Kubernetes世界中究竟是如何工作的。</p><p id="7621" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和往常一样，我试图通过建立一个环境来解决问题，这个环境允许我尽可能快地围绕一个问题进行迭代。我做的第一件事是创建一个超级简单的Docker映像，它具有一个可以从Kubernetes探测的健康端点，并添加一个可选的START_WAIT_SECS环境变量，我可以用它来模拟一个缓慢启动的应用程序。这是我最基本的kubernetes清单:</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="7f5e" class="kw kx iq ks b gy ky kz l la lb">---<br/>kind: Deployment<br/>apiVersion: extensions/v1beta1<br/>metadata:<br/>  name: k8sprobetester-v1<br/>  namespace: default<br/>  labels:<br/>    app: k8sprobetester<br/>spec:<br/>  replicas: 3<br/>  selector:<br/>    matchLabels:<br/>      app: k8sprobetester<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: k8sprobetester<br/>    spec:<br/>      containers:<br/>      - image: "trondhindenes/k8sprobetester:latest"<br/>        name: k8sprobetester<br/>        env:<br/>          - name: START_WAIT_SECS<br/>            value: '0'</span></pre><p id="d8f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所注意到的，这非常简单，没有任何花哨的东西。我正在使用我的本地minikube实例，这意味着如果我添加一个服务定义，minikube可以给我一个可到达的url:</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="2f2e" class="kw kx iq ks b gy ky kz l la lb">---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: k8sprobetester<br/>  namespace: default<br/>spec:<br/>  selector:<br/>    app: k8sprobetester<br/>  type: NodePort<br/>  ports:<br/>  - name: http<br/>    port: 80<br/>    targetPort: 80</span></pre><p id="9783" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行“minikube service k8sprobetester ”,我得到了一个可以用来测试它的url(您的端口可能会不同):<a class="ae km" href="http://192.168.99.100:32500/healthz" rel="noopener ugc nofollow" target="_blank">http://192 . 168 . 99 . 100:32500/healthz</a>。</p><p id="635b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不，我们有一个实验室来测试东西。我还将START_WAIT_SECS设置为15来模拟一个缓慢启动的应用程序。我们还需要一些东西来让Kubernetes相信需要调用一个更改，所以我添加了第二个随机环境变量，我只是不断地更改它的值。</p><p id="2148" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，您可以使用以下命令查看从一个“版本”到下一个“版本”的展示(最好有4个控制台，每个控制台一个:</p><p id="357d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">观看kubectl首次展示状态部署k8sprobetester-v1 <br/>观看kubectl get pods <br/>观看curl<a class="ae km" href="http://192.168.99.100:32500/healthz" rel="noopener ugc nofollow" target="_blank">http://192 . 168 . 99 . 100:32500/healthz</a></p><p id="4d4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个用于调用类似<code class="fe lc ld le ks b">kubectl apply.</code>的命令</p><p id="142e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个版本的部署中，没有进行探测，尽管我们有3个pod副本，但没有任何东西告诉Kubernetes在部署新版本时不应该同时拆除所有副本。这再加上等待时间，将导致我们的应用在部署期间停机5-10秒。我们不想那样。</p><p id="e9da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们能做的第一件事，是告诉Kubernetes应该如何部署我们的应用程序。我们可以通过“部署策略”来实现这一点，它可能看起来像这样:</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="a960" class="kw kx iq ks b gy ky kz l la lb">---<br/>kind: Deployment<br/>apiVersion: extensions/v1beta1<br/>metadata:<br/>  name: k8sprobetester-v1<br/>  namespace: default<br/>  labels:<br/>    app: k8sprobetester<br/>spec:<br/>  replicas: 3<br/>  selector:<br/>    matchLabels:<br/>      app: k8sprobetester<br/>  strategy:<br/>    type: RollingUpdate<br/>    rollingUpdate:<br/>      maxUnavailable: 10%<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: k8sprobetester<br/>    spec:<br/>      containers:<br/>      - image: "trondhindenes/k8sprobetester:latest"<br/>        name: k8sprobetester<br/>        env:<br/>          - name: START_WAIT_SECS<br/>            value: '15'<br/>          - name: SOME_OTHER_VAR<br/>            value: yasssd</span></pre><p id="aa56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们指定在滚动更新期间，最多有10%的资源不可用。Kubernetes有一些内置的智能，可以计算出10%在吊舱数量方面意味着什么。现在的问题是，即使移除我们的一个吊舱也会使我们下降到10%以下，所以部署根本无法开始。让我们将其调整到40%，这允许单个pod关闭(根据kubernetes参考文档，您也可以使用常规数字而不是百分比，默认为“1”)。</p><p id="c00f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就其本身而言，这对我们的部署没有太大影响，因为Kubernetes没有办法知道pod是否真正启动了，所以它假设一旦pod达到“运行”状态，一切都好。当然，我们的慢启动容器不是这样的。所以，我们需要一些东西来通知它，为此我们可以使用探针。探针有不同的形状和形式，但是因为我们在这里使用的是rest api，所以我们使用“http”探针类型。</p><p id="5e19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是添加了LivenessProbe的部署。请注意，我已经将initialDelaySeconds设置为20，因为我们知道我们的应用程序使用了15秒来启动:</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="8007" class="kw kx iq ks b gy ky kz l la lb">---<br/>kind: Deployment<br/>apiVersion: extensions/v1beta1<br/>metadata:<br/>  name: k8sprobetester-v1<br/>  namespace: default<br/>  labels:<br/>    app: k8sprobetester<br/>spec:<br/>  replicas: 3<br/>  selector:<br/>    matchLabels:<br/>      app: k8sprobetester<br/>  strategy:<br/>    type: RollingUpdate<br/>    rollingUpdate:<br/>      maxUnavailable: 40%<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: k8sprobetester<br/>    spec:<br/>      containers:<br/>      - image: "trondhindenes/k8sprobetester:latest"<br/>        name: k8sprobetester<br/>        env:<br/>          - name: START_WAIT_SECS<br/>            value: '15'<br/>          - name: SOME_OTHER_VAR<br/>            value: yasss<br/>        livenessProbe:<br/>          httpGet:<br/>            path: /healthz<br/>            port: 80<br/>            httpHeaders:<br/>              - name: Host<br/>                value: KubernetesLivenessProbe<br/>          initialDelaySeconds: 20</span></pre><p id="6c2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当开发人员带着一个WTF来到我面前时，这与我们正在运行的配置差不多。为什么Kubernetes在第一个开始之前就拆掉了正在运行的吊舱？答案是:我们需要另一种类型的探针:<em class="kl"> readinessProbe。</em>事实证明，Kubernetes有两种不同的方法来跟踪pod的健康状况，一种是在部署期间，另一种是在部署之后。LivenessProbe是导致Kubernetes用一个新的pod替换一个失败的pod的原因，但它在应用程序的部署过程中绝对没有影响。另一方面，Kubernetes使用就绪探测来确定pod是否成功启动。让我们添加一个，使用与实时nessprobe相同的设置:</p><p id="6aa2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在进行新的部署，您应该看到“READY”列在达到“1”之前需要一段时间，这意味着尽管pod已经启动，但Kubernetes并不认为pod已经准备好:</p><figure class="kn ko kp kq gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lf"><img src="../Images/a04e9c7bba81e4bf30576dcd45e02f38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8hqzZjOSi564TmdpHxA6rA.png"/></div></div></figure><p id="5472" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，您应该能够在部署过程中持续点击服务，并且永远不会出现任何错误。</p><p id="913a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如何跟踪启动过程中的实际故障呢？让我们看看Kubernetes是如何处理这个问题的。我在我的图像中添加了另一个标志，允许我在一定百分比的实例化中崩溃pod(如果你看代码，它不是非常精确，但是已经足够好了)。</p><p id="cd38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">新的部署如下所示:</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="d1a1" class="kw kx iq ks b gy ky kz l la lb">---<br/>kind: Deployment<br/>apiVersion: extensions/v1beta1<br/>metadata:<br/>  name: k8sprobetester-v1<br/>  namespace: default<br/>  labels:<br/>    app: k8sprobetester<br/>spec:<br/>  replicas: 5<br/>  selector:<br/>    matchLabels:<br/>      app: k8sprobetester<br/>  strategy:<br/>    type: RollingUpdate<br/>    rollingUpdate:<br/>      maxUnavailable: 30%<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: k8sprobetester<br/>    spec:<br/>      containers:<br/>      - image: "trondhindenes/k8sprobetester:latest"<br/>        name: k8sprobetester<br/>        env:<br/>          - name: START_WAIT_SECS<br/>            value: '15'<br/>          - name: CRASH_FACTOR<br/>            value: '30'<br/>          - name: SOME_OTHER_VAR<br/>            value: yassf<br/>        livenessProbe:<br/>          httpGet:<br/>            path: /healthz<br/>            port: 80<br/>            httpHeaders:<br/>              - name: Host<br/>                value: KubernetesLivenessProbe<br/>          initialDelaySeconds: 20<br/>        readinessProbe:<br/>          httpGet:<br/>            path: /healthz<br/>            port: 80<br/>            httpHeaders:<br/>              - name: Host<br/>                value: KubernetesLivenessProbe<br/>          initialDelaySeconds: 20</span></pre><p id="a137" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，我们将崩溃因子设置为30(这意味着应用程序在启动时大约有30%的时间会崩溃)，并将副本的数量增加到5个。</p><p id="f573" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">部署时，您应该看到Kubernetes注意到一些pod崩溃，并不断重试，直到所有5个pod都处于“就绪”状态，这可能需要几分钟时间。您还应该看到，我们对“healthz”URL的“ping”实际上从未停止过，因此我们在部署期间经受住了多次应用程序故障。</p><p id="33ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一点:把这些事情做好从来都不容易，这可能需要Kubernetes的“所有者”和应用/服务所有者共同努力，在逐个服务的基础上进行调整。关于开始轮询的速度(例如，您可以更快地开始探测，但要增加一些容错能力)和其他设置也有很多需要调整的地方，但多亏了令人敬畏的Kubernetes api文档，所有这些东西都可供您阅读。</p><p id="142b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于RiksTV的我们来说，这是紧张学习的一年，因为我们已经开始在Kubernetes上提供真正面向客户的服务，一些事情告诉我，我们还有很长的路要走。</p><p id="4db6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我鼓励您深入研究Kubernetes提供的有关部署的选项，DeploymentSpec类型的参考文档是一个非常好的起点:<a class="ae km" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.11/#deploymentspec-v1-apps" rel="noopener ugc nofollow" target="_blank">https://Kubernetes . io/docs/reference/generated/Kubernetes-API/v 1.11/# deployment spec-v1-apps</a></p><p id="0c51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">愿你的部署永不失败，愿你的探测器保护你。</p></div></div>    
</body>
</html>