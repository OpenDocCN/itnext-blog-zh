<html>
<head>
<title>Ansible: Tasks vs Roles vs Handlers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ansible:任务vs角色vs处理程序</h1>
<blockquote>原文：<a href="https://itnext.io/ansible-tasks-vs-roles-vs-handlers-72f60b8a6578?source=collection_archive---------6-----------------------#2020-07-27">https://itnext.io/ansible-tasks-vs-roles-vs-handlers-72f60b8a6578?source=collection_archive---------6-----------------------#2020-07-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0a5bf54a6aef422e300807c5049e8d54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LHGZxVcLUIRrd6Fk.jpg"/></div></div></figure><p id="3ce2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Ansible中运行任务可以用不同的方式完成，这对于那些刚开始使用自动化和服务器编排的人来说可能会非常混乱。在这篇文章中，我将解释其中的区别，以及为什么在某些情况下你应该使用其中的一个。如果我在开始使用Ansible的时候就有这篇文章，它会节省我几个小时的研究时间，所以希望这能帮助你。</p><h1 id="3134" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">任务</h1><p id="17d9" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">任务是…嗯，任务。它们特定于一个工作流，在Ansible中称为行动手册。如果你读了我上周的文章<a class="ae mc" href="https://roelofjanelsinga.com/articles/automating-laravel-deployment-using-ansible" rel="noopener ugc nofollow" target="_blank">使用Ansible </a>自动化Laravel部署，你会在文章底部看到我分享的配置。此配置使用了任务。这些任务特定于特定的行动手册，不能与其他行动手册共享。这是你应该使用角色的事情。</p><p id="62cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用任务而不是角色或处理程序的一个优点是，您可以将任务的详细信息作为整个行动手册保存在同一个文件中。当您执行它时，您可以很快看到您的整个行动手册将会做什么。这对于较小的剧本很好，比如我分享的剧本，但是当剧本变长时就很难理解了。这就是角色可能提供出路的地方。</p><h1 id="51ab" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">角色</h1><p id="edae" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">角色是以通用名称分组的任务的集合。如果我们使用我上周分享的配置，我们可以将它转换成包含角色而不是任务的剧本。这看起来像下面的配置。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="5b72" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此配置的角色是“部署_laravel_app”。为了理解这里发生的事情，我需要给你一个文件夹结构:</p><pre class="md me mf mg gt mj mk ml mm aw mn bi"><span id="a908" class="mo la it mk b gy mp mq l mr ms">├── <strong class="mk iu">deploy_laravel_app</strong> <br/>│   ├── <strong class="mk iu">handlers</strong> <br/>│   │   └── <strong class="mk iu">main</strong>.yml <br/>│   └── <strong class="mk iu">tasks</strong> <br/>│       └── <strong class="mk iu">main</strong>.yml <br/>└── <strong class="mk iu">playbook</strong>.yml</span></pre><p id="5350" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里你可以看到我们上面使用的“playbook.yml”和一个名为“deploy_laravel_app”的文件夹。文件夹名称决定了剧本中角色的名称。该角色包含两个文件夹，处理程序和任务。我们将在下一节关注处理程序，但是现在我们将关注tasks文件夹。此文件夹包含main.yml。这是ansible在尝试查找特定角色的任务时将查找的默认文件名。</p><p id="fd03" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">main.yml包含以下配置:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="dfbb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，您可以看到两个我们在配置中还没有看到的新东西。前一篇博文中的任务的“when”属性不见了，取而代之的是“notify”属性。这两个属性做同样的事情，因为它们都是正在运行的任务，但前提是任务的状态是“已更改”而不是“正常”。换句话说，这意味着“通知”中的任务只有在任务对应用程序的状态做出改变时才被执行。在这种情况下，如果我们从Git中提取新的变更，那么只有这样那些任务才会被执行。然而,“when”和“notify”属性之间的区别是:when属性是在任务上注册的，这意味着执行的顺序不会改变。在“通知”属性下执行的任务是处理程序。处理程序在所有其他任务完成后执行。</p><p id="bde3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">执行顺序如下所示:</p><p id="501a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">1.任务<br/> 2。角色<br/> 3。经理人</p><p id="856f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，如果您有多个角色，每个角色调用不同的处理程序，所有角色将首先执行它们的任务，然后执行所有需要执行的处理程序。</p><p id="d150" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用角色而不是任务的优点是剧本很小，但是您也创建了可以添加到多个剧本中的可重用流程。在这种情况下，变量的使用非常重要。缺点是，您将无法看到剧本实际上在运行什么，以及不同的任务是在哪个脚本中执行的。您必须查看多个目录，才能找出哪个时间点正在运行什么。</p><h1 id="7233" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">经理人</h1><p id="255a" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">处理程序是任务，但是它们在剧本的最后执行。如果您将此与JavaScript执行周期进行比较，您可以说处理程序是附加到任务列表中的附加任务，而不是在两个其他任务之间执行。在上一节中，我向您展示了我们正在使用的文件夹结构。现在让我们看看handlers文件夹中main.yml的内容。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="1e06" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这看起来像来自<a class="ae mc" href="https://roelofjanelsinga.com/articles/automating-laravel-deployment-using-ansible" rel="noopener ugc nofollow" target="_blank">的配置中的任务，使用Ansible </a>自动化Laravel部署。唯一的区别是这些名称与角色中任务的“通知”部分中使用的名称相同。这些被视为角色中的唯一标识符，它使用名称来确定要运行哪些处理程序。</p><p id="add7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">处理程序的优点是，你可以非常容易地执行某些任务，例如“安排”一个清理命令。这样，它就不会妨碍主要任务的执行，但也不会让你忘记。</p><p id="9a86" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对我个人来说，最大的缺点是您不能像对角色和任务那样给处理程序一个描述性的名称。</p><h1 id="0903" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="400b" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">使用Ansible执行任务有几种方式:任务、角色和处理程序。它们都有不同的用例，并且各有优缺点。</p><ul class=""><li id="e428" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated">任务:对要执行的任务有一个清晰的概述，但是对于较长的行动手册来说可能会变得难以理解。</li><li id="41ac" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">角色:可以调度其他任务的可重用任务，但是很难确定执行了哪些任务。</li><li id="32c8" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">处理程序:要在最后执行的简单任务，但是你不能给它们一个好听的、描述性的名字。</li></ul><p id="bf41" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望这篇文章能帮助你理解在一个可行的剧本中你可以执行的动作之间的区别。我花了几个小时才弄清楚它们的区别和工作原理，所以我希望这能澄清这一点。</p><p id="cec4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">发布时间:2020年6月10日</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="a890" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="no">最初发表于</em><a class="ae mc" href="https://roelofjanelsinga.com/articles/ansible-difference-between-tasks-and-roles" rel="noopener ugc nofollow" target="_blank"><em class="no">【https://roelofjanelsinga.com】</em></a><em class="no">。</em></p></div></div>    
</body>
</html>