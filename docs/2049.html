<html>
<head>
<title>Writing a Full Featured Maven Pom</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写全功能的Maven Pom</h1>
<blockquote>原文：<a href="https://itnext.io/writing-a-full-featured-maven-pom-f5b874eef312?source=collection_archive---------0-----------------------#2019-03-23">https://itnext.io/writing-a-full-featured-maven-pom-f5b874eef312?source=collection_archive---------0-----------------------#2019-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/81275a49cdbc000d74f3a842f4c1c093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GvtZw4QPovl9OhjV0hmabw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由CCO旗下<a class="ae kf" href="https://www.pexels.com/photo/2-hands-holding-1-jigsaw-puzzle-piece-each-164531/" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae kf" href="https://www.pexels.com/@pixabay" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><p id="b123" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Maven是一个具有结构化构建管道的构建工具。它合金广泛的<br/>定制为您自己的需求。你可以在pom中使用很少的<br/>来构建。但是一个好的构建，遵循你可能应该<br/>在CI/CD管道中做的所有事情，需要更多的时间。</p><p id="bb9d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将讨论所有不同的部分和我们推荐的配置。如果您想直接跳过完整的代码和示例，可以在我的GitRepo:</p><div class="le lf gp gr lg lh"><a href="https://github.com/efenglu/maven" rel="noopener  ugc nofollow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">埃丰卢/马文</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">包含带有许多插件的pom的示例项目</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">github.com</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv jz lh"/></div></div></a></div><h2 id="3918" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">基本信息</h2><p id="ab23" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">每个项目都应该描述自己。对于maven来说，这意味着至少要定义:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="2293" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是你真的应该包括:</p><ul class=""><li id="ffc7" class="na nb it ki b kj kk kn ko kr nc kv nd kz ne ld nf ng nh ni bi translated"><strong class="ki iu">名称</strong>:项目的人类可读名称</li><li id="87bc" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated">描述:更多关于你的项目的人性化的东西</li><li id="373c" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><strong class="ki iu"> URL </strong>:获取项目信息的主URL，通常与scm url相同，但不总是如此</li><li id="f623" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><strong class="ki iu">问题管理</strong>:用户有问题可以去哪里</li><li id="bfa0" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><strong class="ki iu">许可证</strong>:什么许可证控制你的代码的使用</li><li id="d6cd" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><strong class="ki iu"> SCM </strong>:代码存放在哪里</li></ul><p id="6b32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">示例:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="9c53" class="no lx it bd ly np nq nr mb ns nt nu me nv nw nx mh ny nz oa mk ob oc od mn oe bi translated">编码</h1><p id="bb89" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">Maven需要知道它应该如何处理你的文本。这是通过enoding项目完成的。</p><p id="08da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">几乎总是这是<strong class="ki iu">UTF 8</strong>:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h1 id="f133" class="no lx it bd ly np om nr mb ns on nu me nv oo nx mh ny op oa mk ob oq od mn oe bi translated">编译程序</h1><p id="92db" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">现在我们已经有了基础知识，我们需要开始编码，我们所说的编码当然是指编译。</p><h2 id="fcbb" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">Java 语言(一种计算机语言，尤用于创建网站)</h2><p id="74a1" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">默认情况下，javac编译器基本上已经设置好了。但是，我们需要做一些家务。</p><ul class=""><li id="d840" class="na nb it ki b kj kk kn ko kr nc kv nd kz ne ld nf ng nh ni bi translated">选择我们要针对的源代码和编译类的java版本</li><li id="3a94" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated">包括调试标志</li><li id="45d4" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated">任何其他javac标志或自定义参数</li></ul><p id="c85e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于我们的大多数项目，我们遵循一个非常简单的模式:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="dea7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">进一步阅读</p><ul class=""><li id="7b5e" class="na nb it ki b kj kk kn ko kr nc kv nd kz ne ld nf ng nh ni bi translated"><a class="ae kf" href="https://maven.apache.org/plugins/maven-compiler-plugin/" rel="noopener ugc nofollow" target="_blank"> Apache Maven编译器插件</a></li></ul></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h2 id="3b36" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">绝妙的</h2><p id="ca43" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">对于我们的大多数项目，我们使用的是<a class="ae kf" href="http://spockframework.org" rel="noopener ugc nofollow" target="_blank"> Spock测试框架。这意味着我们需要编译groovy代码来运行测试。</a></p><p id="de97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经尝试了各种各样的groovy编译器。各有利弊。</p><p id="6f71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">目前我们选择了GMavenPlus。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="5622" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">进一步阅读</p><ul class=""><li id="31d0" class="na nb it ki b kj kk kn ko kr nc kv nd kz ne ld nf ng nh ni bi translated"><a class="ae kf" href="https://github.com/groovy/GMavenPlus" rel="noopener ugc nofollow" target="_blank"> GMavenPlus </a></li></ul></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h2 id="1ac6" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">龙目岛</h2><p id="634b" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">Lombok是降低Java代码复杂性的一个好方法。我们在创建POJO时广泛使用它</p><p id="41d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在很大程度上，简单地包括lombok作为一个<strong class="ki iu">提供</strong>依赖<em class="or">应该</em>足够了。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="eef4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">延伸阅读:</p><ul class=""><li id="4fb9" class="na nb it ki b kj kk kn ko kr nc kv nd kz ne ld nf ng nh ni bi translated"><a class="ae kf" href="https://projectlombok.org" rel="noopener ugc nofollow" target="_blank">龙目岛</a></li><li id="9871" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><a class="ae kf" href="https://projectlombok.org/setup/maven" rel="noopener ugc nofollow" target="_blank">龙目岛美文</a></li></ul></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h1 id="fffa" class="no lx it bd ly np om nr mb ns on nu me nv oo nx mh ny op oa mk ob oq od mn oe bi translated">代码生成</h1><p id="2774" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">这是一个可选的部分。有许多工具<em class="or">通过在构建时为你生成代码来帮助你。这方面有几个不同的例子。</em></p><h2 id="5f39" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">原蟾蜍</h2><p id="b068" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">协议缓冲区是一种快速发展的二进制交换格式，最初由Google编写。协议缓冲器在<em class="or">中定义。原型</em>文件。这些然后<em class="or">编译</em>成各种语言。</p><p id="a7eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是我们如何着手<em class="or">编译</em>我们的原型文件:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="ed83" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> os-maven-plugin </strong>将检测我们的构建环境平台。这然后用于确定下载哪个平台特定的<em class="or">协议</em>可执行文件。然后<strong class="ki iu"> protobuf-maven-plugin </strong>使用该可执行文件编译实际的<em class="or">。将原型</em>文件转换成java代码。</p><p id="6081" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">延伸阅读:</p><ul class=""><li id="751d" class="na nb it ki b kj kk kn ko kr nc kv nd kz ne ld nf ng nh ni bi translated"><a class="ae kf" href="https://developers.google.com/protocol-buffers/" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a></li><li id="52cb" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><a class="ae kf" href="https://www.xolstice.org/protobuf-maven-plugin/" rel="noopener ugc nofollow" target="_blank"> Maven Protobuf插件</a></li></ul></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h1 id="79ea" class="no lx it bd ly np om nr mb ns on nu me nv oo nx mh ny op oa mk ob oq od mn oe bi translated">单元测试</h1><p id="e248" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">好的单元测试对于任何成功项目的未来和现在都是至关重要的。</p><p id="8573" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幸运的是，设置单元测试相当容易:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f45d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能已经注意到了includes元素。我们为我们的测试执行一个命名标准。对于JUnit测试，它们必须以“<strong class="ki iu">测试</strong>”、“<strong class="ki iu">测试</strong>”结尾，或者以“<strong class="ki iu">规格</strong>”、“<strong class="ki iu">规格</strong>”或Spock规格结尾。</p><p id="edfb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">延伸阅读:</p><ul class=""><li id="c49a" class="na nb it ki b kj kk kn ko kr nc kv nd kz ne ld nf ng nh ni bi translated"><a class="ae kf" href="https://maven.apache.org/surefire/maven-surefire-plugin/index.html" rel="noopener ugc nofollow" target="_blank"> Maven Surefire插件</a></li></ul></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h1 id="51bd" class="no lx it bd ly np om nr mb ns on nu me nv oo nx mh ny op oa mk ob oq od mn oe bi translated">代码覆盖率</h1><p id="434d" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">确保代码得到实际测试是至关重要的。确定代码是否经过测试的一个很好的度量是代码覆盖率。这不是一个完美的衡量标准，你可能永远不会要求100%的覆盖率。但是这是确保<br/>至少在某种程度上符合测试的好方法。但话说回来，我们都遵循TDD，这应该不是问题，对不对？</p><p id="1882" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谈到代码覆盖率，有两个大玩家，Jacoco和Cobertura。我们用Jacoco。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="ef1d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们强制执行70%的代码覆盖率。我们还从覆盖率统计中过滤所有的测试类。<br/> <br/>延伸阅读:</p><ul class=""><li id="7ee7" class="na nb it ki b kj kk kn ko kr nc kv nd kz ne ld nf ng nh ni bi translated"><a class="ae kf" href="https://www.eclemma.org/jacoco/trunk/doc/maven.html" rel="noopener ugc nofollow" target="_blank"> Jacoco Maven插件</a></li></ul></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h1 id="4ab7" class="no lx it bd ly np om nr mb ns on nu me nv oo nx mh ny op oa mk ob oq od mn oe bi translated">集成测试</h1><p id="f23e" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">有些测试比其他测试耗时更长。有些测试更复杂，需要更多的设置和资源。这些是集成测试很好的例子。大多数集成测试都在构建过程的后期运行。有时候，集成测试根本不会在开发人员工作站上运行。</p><p id="2b41" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们遵循将集成测试放入一个<em class="or"> src/it/java </em>路径结构的模式。</p><p id="7aed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将集成测试与常规测试区分开来。然而，由于maven】并没有真正认识到集成测试的概念，因此也有必要对测试进行不同的命名，因为所有的测试<br/>都被编译到一个测试类路径中。</p><p id="3682" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于我们的项目，所有集成测试必须在* <strong class="ki iu"> IT中结束。* </strong>。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h1 id="11b1" class="no lx it bd ly np om nr mb ns on nu me nv oo nx mh ny op oa mk ob oq od mn oe bi translated">静态代码分析</h1><p id="7b0c" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">静态代码分析是防止错误发生的另一种方法。您可以扫描您的代码库，查找常见的编程错误，并尽早发现它们。您还可以确保代码质量和编码标准的水平，以确保代码易于阅读。</p><p id="0cd8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有许多不同的SCA工具:</p><ul class=""><li id="e854" class="na nb it ki b kj kk kn ko kr nc kv nd kz ne ld nf ng nh ni bi translated"><a class="ae kf" href="http://(https://maven.apache.org/plugins/maven-checkstyle-plugin/" rel="noopener ugc nofollow" target="_blank">检查样式</a></li><li id="4fa3" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><a class="ae kf" href="https://maven.apache.org/plugins/maven-pmd-plugin/" rel="noopener ugc nofollow" target="_blank"> PMD </a></li><li id="67c2" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><a class="ae kf" href="https://maven.apache.org/plugins/maven-pmd-plugin/cpd-mojo.html" rel="noopener ugc nofollow" target="_blank"> CPD </a></li><li id="c83e" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><a class="ae kf" href="https://spotbugs.github.io" rel="noopener ugc nofollow" target="_blank">spot bugs</a>(Findbugs的继任者)</li><li id="6cc1" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><a class="ae kf" href="https://gleclaire.github.io/codenarc-maven-plugin/" rel="noopener ugc nofollow" target="_blank"> Codenarc </a></li><li id="d859" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated">等等</li></ul><h2 id="3cc4" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">检查样式</h2><p id="002d" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">Checkstyle强制代码格式化，并检查一些非常基本的不良编程实践。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="6b4e" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">值得注意的事情</h2><p id="ead5" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">我们在<strong class="ki iu">插件管理</strong>部分配置checkstyle，以确保如果用户从命令行调用checkstyle，他们将获得正确的配置。</p><p id="d351" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还建议您定义自己的checkstyle配置。您应该将它作为自己的工件部署，并在checkstyle插件中使用它。您可以看到我在添加到checkstyle插件的依赖项中定义了自己的版本。这个jar可用于类路径上的checkstyle，并且可以使用<strong class="ki iu"> configLocation </strong>元素从该jar加载资源。</p></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h1 id="9b09" class="no lx it bd ly np om nr mb ns on nu me nv oo nx mh ny op oa mk ob oq od mn oe bi translated">Maven Enforcer</h1><p id="4459" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">就像代码SCA一样，Maven Enforcer是对maven poms的一种静态代码分析。</p><p id="18e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用enforcer来确保:</p><ul class=""><li id="47c9" class="na nb it ki b kj kk kn ko kr nc kv nd kz ne ld nf ng nh ni bi translated"><strong class="ki iu">要求版本</strong> : 3.5.0</li><li id="55ed" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><strong class="ki iu">要求免除</strong> : 1.8.0</li><li id="e9b6" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><strong class="ki iu">required No repositories</strong>:我们的pom中没有其他存储库元素</li><li id="a87b" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><strong class="ki iu">requireleasedeps</strong>:我们没有在发布工件中引用快照工件</li><li id="63d3" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated">requireUpperBoundDeps :我们的依赖关系中没有版本冲突</li></ul><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="6cea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">进一步阅读</p><ul class=""><li id="b1b0" class="na nb it ki b kj kk kn ko kr nc kv nd kz ne ld nf ng nh ni bi translated"><a class="ae kf" href="http://(https://maven.apache.org/enforcer/maven-enforcer-plugin/" rel="noopener ugc nofollow" target="_blank"> Maven Enforcer插件</a></li></ul></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h1 id="e24c" class="no lx it bd ly np om nr mb ns on nu me nv oo nx mh ny op oa mk ob oq od mn oe bi translated">Maven依赖性分析器</h1><p id="80a6" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">随着依赖项数量的增长，对我们的依赖项进行静态分析也变得很有必要。</p><ul class=""><li id="1d2e" class="na nb it ki b kj kk kn ko kr nc kv nd kz ne ld nf ng nh ni bi translated">我们还在使用它们吗？</li><li id="bad9" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated">我们的代码从可传递依赖项中导入类吗？</li></ul><p id="d653" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这通常是个坏主意。如果一个依赖库提供了一个我们过渡使用的依赖，如果这个库突然移除了这个依赖会发生什么？一般来说，如果你有一个依赖，你也应该把它叫出来。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h1 id="1a1a" class="no lx it bd ly np om nr mb ns on nu me nv oo nx mh ny op oa mk ob oq od mn oe bi translated">包装</h1><p id="a055" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">Maven已经向创建的清单文件中添加了一些内容。但是我们可能应该增加一些其他的。</p><h2 id="9fa7" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">添加Git信息</h2><p id="9492" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">我们喜欢将代码编译时使用的提交、标记/分支信息放入jar本身。为此，我们需要获取git信息，以便在pom中使用它。<a class="ae kf" href="https://github.com/git-commit-id/maven-git-commit-id-plugin" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu">git-commit-id-plugin</strong></a>将这些信息作为属性添加到pom中。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="9b01" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">最有男子气概的参赛作品</strong></p><p id="d723" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们已经获得了所需的所有信息，让我们将它作为清单条目添加到生产的jar中。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="1fae" class="no lx it bd ly np nq nr mb ns nt nu me nv nw nx mh ny nz oa mk ob oc od mn oe bi translated">源罐</h1><p id="f454" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">当您将代码发布到工件存储库时，同时发布一个源代码jar是很重要的。这将允许消费者很容易地查看您的代码。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="7fef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">延伸阅读:</p><ul class=""><li id="23ea" class="na nb it ki b kj kk kn ko kr nc kv nd kz ne ld nf ng nh ni bi translated"><a class="ae kf" href="https://maven.apache.org/plugins/maven-source-plugin/" rel="noopener ugc nofollow" target="_blank"> Maven源码插件</a></li></ul></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h1 id="0e49" class="no lx it bd ly np om nr mb ns on nu me nv oo nx mh ny op oa mk ob oq od mn oe bi translated">胖罐子？</h1><p id="dec5" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">有时有必要将所有的依赖项都汇总到一个jar文件中。这在运行脚本时很有用。胖罐子也有缺点。你可能会遇到类路径冲突、文件<br/>重复和其他文件冲突的问题，<br/> <br/>没有一个构建fat jars的工具是完美的，但是我在使用<a class="ae kf" href="https://maven.apache.org/plugins/maven-shade-plugin/" rel="noopener ugc nofollow" target="_blank">着色器插件</a>时运气最好。它做得很好的一件事是加入spring，并提供jars服务。这些jar通常有驻留在jar的MANIFEST文件夹中的文件。但是在构建fat jar时，它们经常会发生冲突，导致您丢失一些必要的配置信息。着色器插件将通过尽可能地合并和组合这些文件来避免这种情况。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h1 id="8218" class="no lx it bd ly np om nr mb ns on nu me nv oo nx mh ny op oa mk ob oq od mn oe bi translated">共享配置</h1><p id="9e80" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">好的，那就很多了。您的pom现在可能已经超过1000行了。不仅如此，它非常复杂，难以复制。当然，它做了我们想要的一切，但是如果我们不能轻松地在许多项目中维护配置，那有什么好处呢？</p><p id="af66" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实际上有两种方法可以做到这一点。没有一个是完美的，但他们在一起可以非常接近。</p><h2 id="3672" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">父POM</h2><p id="d305" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">Maven支持pom配置继承的概念。通过在pom中指定一个<strong class="ki iu"> <em class="or">父</em> </strong>元素，可以很容易地做到这一点。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="5f04" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">子节点现在将从父节点接收所有配置。您可以覆盖孩子中的设置，并向您的hearts内容添加附加内容。</p><p id="b464" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">父母是设置<strong class="ki iu"> <em class="or">依赖管理</em> </strong>和<strong class="ki iu"> <em class="or">插件管理</em> </strong>部分的好地方。这确保了你所有的子模块将在他们的构建中使用相同版本的依赖和相同版本的插件。</p><p id="bd00" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一些需要注意的事情。</p><p id="1cb1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很难排除某些东西。也就是说，如果父母定义了一个插件，孩子就不容易关掉它。因此，在将所有配置添加到单个monster父节点时要小心。</p><p id="bdd5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是第二种方法有用的地方</p><h2 id="3113" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">瓷砖</h2><p id="f790" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">Maven本身并不支持配置组合的概念。但是一个名为<a class="ae kf" href="https://github.com/repaint-io/maven-tiles" rel="noopener ugc nofollow" target="_blank"> Maven Tiles </a>的第三方工具带来了这种能力。</p><p id="95a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Maven tiles允许您在项目配置中编写:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="c106" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">注意:</strong>您不能将父级中的图块作为所有子级获取图块的方式。事情不是这样的。瓷砖应该直接用在需要的地方。</p><h2 id="a6e7" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">瓷砖中的瓷砖</h2><p id="ddc5" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">当然，您可以使用另一个图块将图块组合在一起，而不必在特定模块中列出您想要的所有图块。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="f7f9" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">父Pom和瓷砖</h2><p id="d48d" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">我建议你在你的父POM中使用一些常见的配置，并在大多数构建配置方面使用tiles。<br/><br/><strong class="ki iu"/>是否包含在您的父pom中:</p><ul class=""><li id="d0ba" class="na nb it ki b kj kk kn ko kr nc kv nd kz ne ld nf ng nh ni bi translated">基本项目配置(scm、url、问题管理等)</li><li id="0d32" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated">插件管理</li><li id="27b5" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated">依赖性管理</li><li id="082b" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated">项目编码</li></ul><p id="ace4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">不要</strong>在您的父pom中包含:</p><ul class=""><li id="78d1" class="na nb it ki b kj kk kn ko kr nc kv nd kz ne ld nf ng nh ni bi translated">属国</li><li id="8217" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated">瓷砖</li></ul><p id="d55c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在你所有的叶项目中使用tiles来以可重复的方式配置构建。</p><h1 id="e219" class="no lx it bd ly np nq nr mb ns nt nu me nv nw nx mh ny nz oa mk ob oc od mn oe bi translated">完成的示例</h1><p id="83b6" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">现在我们有了自己的tiles和一些父POM，我们有了很多精彩的特性来帮助我们成为优秀的程序员，成为未来灵活社区的积极成员。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="bcc3" class="no lx it bd ly np nq nr mb ns nt nu me nv nw nx mh ny nz oa mk ob oc od mn oe bi translated">变平</h1><p id="4f28" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">哦，等等，还有呢！</p><p id="cb2f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在你有了你的父母和所有的插件，你还有最后一个机会。如果有人使用你的库，他们也必须下载你所有的父POM。最重要的是，您部署到您的工件存储库中的所有POM将仍然包含您的所有构建配置。</p><p id="39c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了清理那些pom并消除下载父对象的需要，我们可以<em class="or">展平</em>一个POM。</p><p id="06f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">扁平化pom会将所有的依赖项合并到一个pom中。它还在部署时从pom中删除了许多不必要的信息。比如，<strong class="ki iu">插件</strong>，<strong class="ki iu">属性</strong>，<strong class="ki iu">报告，</strong>等等。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="d3d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">进一步阅读</p><ul class=""><li id="0456" class="na nb it ki b kj kk kn ko kr nc kv nd kz ne ld nf ng nh ni bi translated"><a class="ae kf" href="https://www.mojohaus.org/flatten-maven-plugin/" rel="noopener ugc nofollow" target="_blank">展平Maven插件</a></li></ul><h1 id="78f6" class="no lx it bd ly np nq nr mb ns nt nu me nv nw nx mh ny nz oa mk ob oc od mn oe bi translated">结论</h1><p id="b148" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">我们在这里讨论了很多东西，仅仅触及了你如何定制我们在这里提到的插件的表面。希望这为您自己的maven努力提供了一个构建块。</p><p id="5be6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不要忘记在我的github repo查看所有提到的代码，以及完整的示例和每个插件的图片:</p><div class="le lf gp gr lg lh"><a href="https://github.com/efenglu/maven" rel="noopener  ugc nofollow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">埃丰卢/马文</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">包含带有许多插件的pom的示例项目</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">github.com</p></div></div><div class="lq l"><div class="os l ls lt lu lq lv jz lh"/></div></div></a></div></div></div>    
</body>
</html>