<html>
<head>
<title>Nullish Coalescing for JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript的无效合并</h1>
<blockquote>原文：<a href="https://itnext.io/nullish-coalescing-for-javascript-ec961357bae1?source=collection_archive---------4-----------------------#2019-11-29">https://itnext.io/nullish-coalescing-for-javascript-ec961357bae1?source=collection_archive---------4-----------------------#2019-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c277ebab3a14eea8f35fd7d236247171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AM04yjlVdtPvZXs3.jpg"/></div></div></figure><p id="0ace" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Nullish合并提案已经被移到第3阶段，也就是说，很快它将被添加到JS标准中，让我们看看它如何帮助我们。</p><p id="5f09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你检查过多少次一个变量是否是<code class="fe kw kx ky kz b">null</code>？不是<code class="fe kw kx ky kz b">undefined</code>、<code class="fe kw kx ky kz b">''</code>或<code class="fe kw kx ky kz b">false</code>，而只是<code class="fe kw kx ky kz b">null</code>，我通常会为此添加一个if条件<code class="fe kw kx ky kz b">variable === null</code>，我已经这样做了无数次。</p><p id="90f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑下面的代码</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="1b87" class="li lj iq kz b gy lk ll l lm ln">let<em class="lo"> </em>counter;<br/>if(<em class="lo">response.</em>data === null) counter = 1;<br/>else counter = <em class="lo">response.</em>data;</span></pre><p id="ff47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们可以轻松地做到这一点，而不需要那么多代码来检查它是否是<code class="fe kw kx ky kz b">null</code>会怎么样。无效合并就是这样做的。这是它的外观和工作原理。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="3c8f" class="li lj iq kz b gy lk ll l lm ln">let<em class="lo"> </em>counter<em class="lo"> </em>=<em class="lo"> response.data </em>??<em class="lo"> </em>1;<br/>//<em class="lo"> now if data is 0 counter value is 0<br/></em>//<em class="lo"> if it is null or undefined we set it to 1;</em></span></pre><p id="5020" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，只有当值为<code class="fe kw kx ky kz b">undefined</code>或<code class="fe kw kx ky kz b">null</code>时，才会使用默认值。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="e539" class="li lj iq kz b gy lk ll l lm ln">result = actualValue ?? defaultValue</span></pre><p id="2ca4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看当我们使用逻辑OR运算符时会得到什么。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="82d4" class="li lj iq kz b gy lk ll l lm ln">let<em class="lo"> </em>counter<em class="lo"> </em>=<em class="lo"> response.data </em>||<em class="lo"> </em>1;<br/>//<em class="lo"> here even if the value is 0, that is the value is defined<br/></em>//<em class="lo"> we still get 1, which we don't want.</em></span></pre><p id="a159" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">概括地说,“无效聚结”本质上是</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="d0c1" class="li lj iq kz b gy lk ll l lm ln">a ?? b<br/>a !== undefined &amp;&amp; a !== null ? a : b</span></pre><h1 id="4d9a" class="lp lj iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">当前状态和如何使用</h1><p id="ec3c" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">您可以查看<a class="ae mr" href="http://kangax.github.io/compat-table/esnext/#test-nullish_coalescing_operator_(??)" rel="noopener ugc nofollow" target="_blank"> ECMAScript下一个兼容性表</a>,以了解。？支持运算符。</p><p id="5a39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">巴别塔有插件<code class="fe kw kx ky kz b">@babel/plugin-proposal-nullish-coalescing-operator</code></p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><p id="87da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lo">原载于2019年11月29日</em><a class="ae mr" href="https://solankiamit.com/nullish-coalescing-for-javascript" rel="noopener ugc nofollow" target="_blank"><em class="lo">https://solankiamit.com</em></a><em class="lo">。</em></p></div></div>    
</body>
</html>