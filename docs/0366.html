<html>
<head>
<title>Indexing and MongoDB Query Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">索引和MongoDB查询性能</h1>
<blockquote>原文：<a href="https://itnext.io/indexing-and-mongodb-query-performance-a8a6a64c4308?source=collection_archive---------1-----------------------#2018-02-27">https://itnext.io/indexing-and-mongodb-query-performance-a8a6a64c4308?source=collection_archive---------1-----------------------#2018-02-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="50bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇短文将研究在各种(虚拟)服务器硬件配置下，针对索引和非索引集合的MongoDB查询的性能。我们将研究通过索引可能获得的性能提升，并简要讨论它们的含义。这并不意味着对索引或MongoDB主题的明确处理。您的里程可能会有所不同。</p><p id="7a8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们几乎所有的时间都将在mongo shell中度过。本文假设读者已经在本地安装了MongoDB，并且对MongoDB和mongo shell命令有基本的了解。mongo shell是一个JavaScript环境；我们将在下面的例子中使用基本的JavaScript。</p><p id="1eb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要很好地介绍MongoDB，请参考Jim Medlock的文章。</p><h2 id="fd5d" class="ko kp iq bd kq kr ks dn kt ku kv dp kw jy kx ky kz kc la lb lc kg ld le lf lg bi translated">指数</h2><p id="0e1f" class="pw-post-body-paragraph jn jo iq jp b jq lh js jt ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk ij bi translated"><a class="ae kl" href="https://docs.mongodb.com/manual/indexes/" rel="noopener ugc nofollow" target="_blank"> MongoDB索引</a>是在集合级别定义的，可以在集合文档中的任何字段(或字段组合)上创建。默认情况下，MongoDB在<code class="fe lm ln lo lp b">_id</code>字段上创建一个索引。我们可以创建额外的索引来支持应用程序的访问模式。这仅仅意味着我们应该为通常包含在查询中的字段创建索引。<a class="ae kl" href="https://docs.mongodb.com/manual/applications/indexes/" rel="noopener ugc nofollow" target="_blank">参见此处</a>了解更多关于索引策略的信息。</p><h2 id="ff13" class="ko kp iq bd kq kr ks dn kt ku kv dp kw jy kx ky kz kc la lb lc kg ld le lf lg bi translated">设置</h2><p id="6593" class="pw-post-body-paragraph jn jo iq jp b jq lh js jt ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk ij bi translated">我们需要一个数据库。在mongo shell中，<code class="fe lm ln lo lp b">use</code>命令创建(或切换到)一个指定的数据库。我们称我们的为<code class="fe lm ln lo lp b">indexingdemo</code>:</p><p id="f07f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lm ln lo lp b">use indexingdemo</code></p><p id="5fd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们需要一些文件。我们将在mongo shell中使用JavaScript来生成一个包含300万个文档的数组。然后，我们可以将数组批量插入数据库。我们的收集将包括递增的学生id和随机测验，考试和家庭作业的分数。</p><p id="4b11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我使用一个嵌套的<code class="fe lm ln lo lp b">for</code>循环来填充一个<code class="fe lm ln lo lp b">docs</code>数组；1百万次外部迭代* 3次内部迭代=总共3百万个文档:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="1609" class="ko kp iq lp b gy ly lz l ma mb">var docs = [];<br/>for (var i = 0; i &lt; 1000000; i++) {<br/>  var types = ["quiz", "exam", "homework"];<br/>  for (var j = 0; j &lt; 3; j++) {<br/>    docs.push({<br/>      student : i,<br/>      type    : types[j],<br/>      score   : Math.round(Math.random()*100)<br/>    });<br/>  }<br/>}</span></pre><figure class="lq lr ls lt gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mc"><img src="../Images/a9b2fe7aa3c73aedd39456d821ac7ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WyARCvoTy0qvIfehLbzY5A.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">生成300万个文档…</figcaption></figure><p id="1219" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后<code class="fe lm ln lo lp b">insert</code>将文档数组放入<code class="fe lm ln lo lp b">scores</code>集合(将动态创建):</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="d9c9" class="ko kp iq lp b gy ly lz l ma mb">db.scores.insert(docs)</span></pre><p id="0696" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可能需要几分钟的时间，取决于您的硬件速度。完成后，MongoDB将返回一个<code class="fe lm ln lo lp b">BulkWriteResult</code>。<code class="fe lm ln lo lp b">nInserted</code>属性应该等于3000000:</p><figure class="lq lr ls lt gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mc"><img src="../Images/18d1583ae9a6ccce85191e955e78cf9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*343CFrUqD9TnH1OlBTt1LA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">…以及插入结果。</figcaption></figure><p id="4bab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以查询我们的数据库。例如，我们可能想要查看某个学生的所有分数:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="3e6f" class="ko kp iq lp b gy ly lz l ma mb">db.scores.find({ student: 585534 }).pretty()</span></pre><figure class="lq lr ls lt gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mc"><img src="../Images/d435d00f61543983c8692a8afb57d031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cwlwNE1dCLA5MLEX464fYQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">锁住。格式化结果的pretty()方法。</figcaption></figure><p id="0fd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的查询返回3个文档——分别对应学生的<code class="fe lm ln lo lp b">quiz</code>、<code class="fe lm ln lo lp b">exam</code>和<code class="fe lm ln lo lp b">homework</code>分数。</p><p id="9414" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在创建我们的索引之前，让我们获得一个性能基线。我们可以将<code class="fe lm ln lo lp b">.explain()</code>方法链接到查询的末尾，传入<code class="fe lm ln lo lp b">"executionStats"</code>以返回详细的性能信息:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="cf95" class="ko kp iq lp b gy ly lz l ma mb">db.scores.find({ student: 585534 }).explain("executionStats")</span></pre><p id="6af9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这产生了大量的输出。向上滚动一点找到属性<code class="fe lm ln lo lp b">executionTimeMillis</code>。在比较测试运行时，我们将使用这个执行时间。</p><figure class="lq lr ls lt gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mc"><img src="../Images/022bd4f693a63569919942ac2d50c91c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YlKV8uUIgOjuGO2ufdmw8Q.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">执行时间:大约1秒</figcaption></figure><p id="84f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们创建我们的索引。假设查询通常包括<code class="fe lm ln lo lp b">student</code>和<code class="fe lm ln lo lp b">type</code>字段。我们将在<code class="fe lm ln lo lp b">student</code>和<code class="fe lm ln lo lp b">type</code>上创建一个<a class="ae kl" href="https://docs.mongodb.com/manual/core/index-compound/" rel="noopener ugc nofollow" target="_blank">复合索引</a>。这将支持仅针对<code class="fe lm ln lo lp b">student</code>或<code class="fe lm ln lo lp b">student</code>和<code class="fe lm ln lo lp b">type</code>的高效查询。</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="0acb" class="ko kp iq lp b gy ly lz l ma mb">db.scores.createIndex({ student: 1, type: 1 })</span></pre><figure class="lq lr ls lt gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mc"><img src="../Images/4717968e46d75477bc0930779ee3585c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eU_sdkACPj2iHHpHNx2xEw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">创建复合索引</figcaption></figure><p id="af04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意<code class="fe lm ln lo lp b">"numIndexesBefore" : 1</code>——之前的索引是MongoDB为<code class="fe lm ln lo lp b">ObjectId</code>自动创建的。</p><p id="ae48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们重新运行测试查询:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="fc17" class="ko kp iq lp b gy ly lz l ma mb">db.scores.find({ student: 585534 }).explain("executionStats")</span></pre><p id="b5f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该注意到查询<em class="mo">感觉</em>更快了——它应该几乎瞬间完成。因为——哈哈！—确实如此:</p><figure class="lq lr ls lt gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mc"><img src="../Images/6b0c162fcc2b7c3b1080d2a8e6dcb40d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ZT0Dh3MqYb_LjnVDqL15g.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">是的——零毫秒</figcaption></figure><p id="aeba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，<code class="fe lm ln lo lp b">executionTimeMillis</code>0毫秒并不意味着<em class="mo">零</em>时间。如果我多次重新运行该查询，我偶尔会看到一些非零结果。无论哪种方式，索引查询都是<em class="mo">快</em>。</p><p id="4de5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以上结果是在VirtualBox虚拟机中获得的。Windows 7 Pro x64主机操作系统+ Ubuntu 16.04来宾操作系统，使用2个CPU内核(英特尔酷睿i5–3470)和4GB内存。以今天的标准来看不是精英硬件。</p><h2 id="c2f5" class="ko kp iq bd kq kr ks dn kt ku kv dp kw jy kx ky kz kc la lb lc kg ld le lf lg bi translated">缩放比例</h2><p id="d21f" class="pw-post-body-paragraph jn jo iq jp b jq lh js jt ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk ij bi translated">由于这是一台虚拟机，并且我可以控制系统资源，因此我可以通过调整虚拟机的设置来检查性能如何跨各种(虚拟)硬件配置进行扩展。在VirtualBox中，这就像移动滑块一样简单。我们来玩玩CPU核数和RAM。</p><figure class="lq lr ls lt gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mp"><img src="../Images/1a0e7aaa10a03b26a382dff3a5ba5873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T2qK3D1xpamx8LZ3YlLo7g.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">什么缩放？</figcaption></figure><p id="6851" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个配置的索引结果(蓝色)位于每个非索引结果(橙色)的左侧，不容易看到！图表中的每个条形代表以下每种CPU/RAM组合的5次运行的平均值:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="36d1" class="ko kp iq lp b gy ly lz l ma mb">                       Indexed avg     Non-Indexed avg<br/>--------------------------------------------------------<br/>2 cores, 4 GB RAM         0 ms             1100 ms<br/>2 cores, 3 GB RAM         0 ms             1113 ms<br/>2 cores, 2 GB RAM         0 ms             1062 ms<br/>2 cores, 1 GB RAM         2 ms             1196 ms</span><span id="30d8" class="ko kp iq lp b gy mq lz l ma mb">1 cores, 4 GB RAM         1 ms             1102 ms<br/>1 cores, 3 GB RAM         2 ms             1088 ms<br/>1 cores, 2 GB RAM         1 ms             1061 ms<br/>1 cores, 1 GB RAM         2 ms             1140 ms</span></pre><p id="4301" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是怎么回事？首先，我们可以概括出，我们的示例查询的性能不受CPU内核数量或系统RAM ≥ 1GB的限制。在所有配置中，索引查询在<em class="mo">零点</em>的1–2毫秒内执行，非索引查询在1秒多一点的时间内完成。</p><h2 id="5131" class="ko kp iq bd kq kr ks dn kt ku kv dp kw jy kx ky kz kc la lb lc kg ld le lf lg bi translated">为什么？</h2><p id="9601" class="pw-post-body-paragraph jn jo iq jp b jq lh js jt ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk ij bi translated">没有索引，MongoDB必须执行完整的集合扫描，这意味着访问磁盘。我的主机系统有一个重要的MX100 SATA3固态硬盘。我怀疑非索引结果受到了磁盘I/O的限制。为了测试这一点，我创建了一个150万文档的集合(原始大小的一半),并重新运行了查询。除了上面使用的最小/最大配置之外，我没有测试虚拟机配置。以下结果是5次运行的平均值:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="4f2c" class="ko kp iq lp b gy ly lz l ma mb">                      Indexed avg      Non-Indexed avg<br/>--------------------------------------------------------<br/>2 cores, 4 GB RAM         0 ms              <strong class="lp ir">497 ms</strong><br/>1 cores, 1 GB RAM         1 ms              <strong class="lp ir">552 ms</strong></span></pre><p id="4299" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">针对150万个文档集合的非索引查询大约在半秒钟内执行。与300万文档集合相比:一半的文档=一半的时间。这支持了我的假设re:在磁盘I/O受限的环境中进行完全收集扫描。</p><p id="80e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是索引查询缺乏伸缩性怎么办？回想一下，不管硬件配置如何，我们的结果基本上都是0毫秒。要回答这个问题，我们先来看看指数的大小:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="eab3" class="ko kp iq lp b gy ly lz l ma mb">db.scores.totalIndexSize()</span></pre><figure class="lq lr ls lt gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mc"><img src="../Images/c796631f2d61af53083731fb6ac71672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QC92ZivT7HbBSfjKfhC5zQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">索引大小(字节)</figcaption></figure><p id="dd5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的索引是85，639，168字节(81.67 MB)。为了获得最佳性能，<a class="ae kl" href="https://docs.mongodb.com/manual/tutorial/ensure-indexes-fit-ram/" rel="noopener ugc nofollow" target="_blank">索引应该适合可用的RAM </a>。即使只有1 GB的系统内存，也有足够的内存来保存我们的索引。</p><h2 id="7990" class="ko kp iq bd kq kr ks dn kt ku kv dp kw jy kx ky kz kc la lb lc kg ld le lf lg bi translated">结论</h2><p id="9013" class="pw-post-body-paragraph jn jo iq jp b jq lh js jt ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk ij bi translated">主要的收获是显而易见的:<strong class="jp ir">创建索引来支持您的查询</strong>——好处是难以置信的！否则，查询需要完全收集扫描，这受到服务器的磁盘子系统I/O的限制。服务器CPU和RAM资源比预期的要少。对于那些使用像数字海洋和OVH这样的VPS主机提供商的廉价产品的人来说，这是令人鼓舞的。</p></div></div>    
</body>
</html>