<html>
<head>
<title>Building Node.js REST servers from OpenAPI specifications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">根据OpenAPI规范构建Node.js REST服务器</h1>
<blockquote>原文：<a href="https://itnext.io/building-node-js-rest-servers-from-openapi-specifications-f15e8b885793?source=collection_archive---------5-----------------------#2022-05-25">https://itnext.io/building-node-js-rest-servers-from-openapi-specifications-f15e8b885793?source=collection_archive---------5-----------------------#2022-05-25</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="2fd0" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">快速从API规范到运行服务器</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/6b41e13542ab6a73cd1e0d1cd3f25819.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bBstuMLJnJZw_KSx.jpg"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</figcaption></figure><p id="4b4b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> OpenAPI规范旨在帮助创建服务器或客户端API实现。在本文中，我们将探索如何快速实现运行在Node.js上的OpenAPI规范中的服务器代码，最好使用TypeScript。</strong></p><p id="59e5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">本文的目标是创建一个可维护的Node.js/JavaScript/TypeScript服务器，实现OpenAPI规范中定义的REST服务。在这种情况下，我们不会从代码中生成OpenAPI规范文件，而是使用OpenAPI规范来驱动服务器。一些框架走另一条路，从代码中生成OpenAPI规范。这个模型在某些情况下是有用的。但是，在很多情况下，我们需要实现一个与现有API兼容的服务器，其中有一个已发布的OpenAPI规范。在这种情况下，我们需要从OpenAPI规范中生成服务器，而不是从代码中生成OpenAPI规范。</p><p id="b7e9" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们所说的<em class="lv">可维护的服务器代码</em>是什么意思？API会改变。当您需要更新到API的更高版本时，您的服务器实现会发生什么？一个可维护的场景是，您可以更新正在使用的OpenAPI规范，而不必从头开始重新创建您的实现。在某些情况下，从更改的API规范重新生成源代码会覆盖现有代码。如果您定制的代码被覆盖，您需要重新创建定制。相反，我们必须能够毫不费力地快速更新我们的服务器代码。这是因为我们必须在迭代OpenAPI规范和测试服务器实现变化之间有一个紧密的循环。</p><p id="5a04" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">OpenAPI规范的核心是<code class="fe lw lx ly lz b">paths</code>结构，其中每一项都是我们API中的一个URL路径。这些URL显然对应于如下的路由处理程序:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="79bd" class="me mf iu lz b gz mg mh l mi mj">router.get('/todos/all', ...) <br/>router.put('/todos', ... ) <br/>router.delete('/todos/123', ...)</span></pre><p id="5753" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这意味着OpenAPI服务器框架必须以某种方式生成这些路由处理程序。服务器框架应该建立在像Express或Fastify这样的现有框架之上。OpenAPI框架既可以生成源代码，我们可以根据业务逻辑定制源代码，也可以根据指定的API在内部处理匹配请求。OpenAPI路径声明中的<code class="fe lw lx ly lz b">operationId</code>属性必须连接到包含我们代码的JavaScript函数(我们的目标是Node.js)。还有像对象模式这样的东西，它们必须对应于数据类型，等等。</p><p id="e812" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">对于URL路径和请求动词的每个组合，都有一个对应的<code class="fe lw lx ly lz b">operationId</code>。Node.js服务器的<code class="fe lw lx ly lz b">operationId</code>对应于一个JavaScript函数。因此，OpenAPI服务器框架应该处理URL和请求动词的匹配，确保传入数据匹配OpenAPI规范中的任何内容，然后调用对应于<code class="fe lw lx ly lz b">operationId</code>的函数。</p><p id="1e2d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">带有示例代码的存储库:<a class="ae mk" href="https://github.com/robogeek/typescript-todo-service" rel="noopener ugc nofollow" target="_blank">https://github.com/robogeek/typescript-todo-service</a></p><p id="f115" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">该存储库包含TODO服务的示例OpenAPI文件。在撰写本文时，TODO服务还没有在真实的应用程序中进行测试。它是根据之前的教程<a class="ae mk" href="https://techsparx.com/nodejs/examples/todo-bootstrap/index.html" rel="noopener ugc nofollow" target="_blank">设计的，包含Express、Bootstrap v5、Socket的单页多用户应用程序。IO，Sequelize </a>，因此这个API应该工作。然而，本文的目的不是创建一个工作应用程序，而只是演示如何从一个OpenAPI规范开始，并快速搭建服务器实现的起点。我们所需要的就是见证操作处理函数的执行。</p><p id="3950" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这个存储库还包含使用规范构建服务器的例子。</p><h1 id="c88d" class="ml mf iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">使用Exegesis和Exegesis-Express创建OpenAPI服务器</h1><p id="86d2" class="pw-post-body-paragraph kz la iu lb b lc nc jv le lf nd jy lh li ne lk ll lm nf lo lp lq ng ls lt lu in bi translated">注释库实现了OpenAPI 3，但是你可能想要使用<code class="fe lw lx ly lz b">exegesis-express</code>或者<code class="fe lw lx ly lz b">exegesis-koa</code>。让我们用速成版兜一圈。</p><ul class=""><li id="4876" class="nh ni iu lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">github:<a class="ae mk" href="https://github.com/exegesis-js/exegesis-express" rel="noopener ugc nofollow" target="_blank">https://github.com/exegesis-js/exegesis-express</a></li><li id="dc5d" class="nh ni iu lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">源代码:<a class="ae mk" href="https://github.com/robogeek/typescript-todo-service/servers/exegesis-express" rel="noopener ugc nofollow" target="_blank">https://github . com/robogeek/typescript-todo-service/servers/exegesis-express</a></li></ul><p id="2ab0" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">通过安装这些包来设置Node.js项目目录</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="4b63" class="me mf iu lz b gz mg mh l mi mj">$ npm init -y <br/>$ npm install express exegesis-express cookie-parser body-parser <br/>$ npm install @types/cookie-parser @types/errorhandler \<br/>      @types/express @types/method-override @types/morgan \<br/>      @types/node typescript nodemon</span></pre><p id="5e08" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">对于典型的ExpressJS服务器来说，这是一组非常有用的包。截至本文撰写时，Express v4仍然是当前版本，Express v5处于Beta 1中。如果您希望支持的不仅仅是OpenAPI路径，那么这套Express中间件非常有用。</p><p id="c914" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们正在安装TypeScript，以及几个类型包。最后，Nodemon对于监控源代码和重新加载服务器以获得更好的开发人员工作流非常有用。</p><p id="2f76" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe lw lx ly lz b">todo.yml</code>文件必须做一些小的修改，所以将它复制到项目目录中，并对<code class="fe lw lx ly lz b">paths</code>下的每个条目进行修改</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="7733" class="me mf iu lz b gz mg mh l mi mj">paths:<br/>   /todo:<br/>     post:<br/>       ...<br/>       x-exegesis-controller: todoController<br/>       ...</span></pre><p id="9152" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在OpenAPI中，<code class="fe lw lx ly lz b">x-</code>用于厂商扩展。在这种情况下，注释是供应商，因此是<code class="fe lw lx ly lz b">x-exegesis</code>，这个特殊的扩展是命名一个模块，在那里可以找到一个<em class="lv">控制器函数</em>。在OpenAPI中，每个<code class="fe lw lx ly lz b">paths</code>条目都有一个<code class="fe lw lx ly lz b">operationId</code>参数，它是对应于路径的操作的可读名称。</p><p id="3dc0" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">比如<code class="fe lw lx ly lz b">/todo</code>上的岗位对应<code class="fe lw lx ly lz b">createTodo</code>操作。<code class="fe lw lx ly lz b">x-exegesis-controller</code>参数命名一个模块，在该模块中，注释查找名称与<code class="fe lw lx ly lz b">operationID</code>参数匹配的函数。因此，解释学将调用<code class="fe lw lx ly lz b">todoController.createTodo</code>来匹配这个<code class="fe lw lx ly lz b">paths</code>条目的请求。</p><p id="092c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您可能已经注意到我们安装了TypeScript编译器和一些类型包。这意味着我们需要像这样初始化一个<code class="fe lw lx ly lz b">tsconfig.json</code>:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="3ade" class="me mf iu lz b gz mg mh l mi mj">{<br/>     "include": [ "lib/**/*" ],<br/>     "compilerOptions": {<br/>         "lib": [ "es6", "es2021", "esnext" ],<br/>         "target": "es2022",<br/>         "module": "commonjs",<br/>         "moduleResolution": "Node",<br/>         "outDir": "dist",<br/>         "rootDir": "./lib",<br/>         "experimentalDecorators": true,<br/>         "emitDecoratorMetadata": true,<br/>         "declaration": true,<br/>         "declarationMap": true,<br/>         "inlineSourceMap": true,<br/>         "inlineSources": true<br/>     } <br/>}</span></pre><p id="559e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这意味着在<code class="fe lw lx ly lz b">lib</code>目录中查找源文件，并编译成<code class="fe lw lx ly lz b">dist</code>，编译成CommonJS模块格式。我开始使用ES6模块格式，但是Exegesis使用<code class="fe lw lx ly lz b">require</code>来加载控制器模块，这需要将TypeScript编译成CommonJS格式。</p><p id="00d0" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在<code class="fe lw lx ly lz b">lib/index.ts</code>中，创建一个脚本来连接Express服务器，并使用注释来处理OpenAPI请求。通常在Express应用程序中，我们会使用Router对象来处理路由，但是Exegesis可以处理所有符合OpenAPI规范的路由。</p><p id="2cac" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">该函数由注释小组提供的教程示例修改而来:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="8efb" class="me mf iu lz b gz mg mh l mi mj">async function createServer() {<br/>     // See <a class="ae mk" href="https://github.com/exegesis-js/exegesis/blob/master/docs/Options.md" rel="noopener ugc nofollow" target="_blank">https://github.com/exegesis-js/exegesis/blob/master/docs/Options.md</a><br/>     const options = {<br/>         controllers: path.resolve(__dirname, 'controllers'),<br/>         allowMissingControllers: false,<br/>     };<br/>     // This creates an exegesis middleware,<br/>     // which can be used with express,<br/>     // connect, or even just by itself.<br/>     const exegesisMiddleware = await exegesisExpress.middleware(<br/>         path.resolve(__dirname, '../todo.yml'),<br/>         options<br/>     );<br/>     const app: express.Express = express();<br/>     // If you have any body parsers, this should go before them.<br/>     app.use(exegesisMiddleware);<br/>     app.use(bodyParser.json());<br/>     app.use(bodyParser.urlencoded({<br/>         extended: true<br/>     }));<br/>     app.use(cookieParser('keyboard mouse'));<br/>     // Return a 404<br/>     app.use((req, res) =&gt; {<br/>         res.status(404).json({ message: `Not found` });<br/>     });<br/>     // Handle any unexpected errors<br/>     app.use((err, req, res, next) =&gt; {<br/>         res.status(500).json({ <br/>                 message: `Internal error: ${err.message}` <br/>         });<br/>     });<br/>      const server = http.createServer(app);<br/>      return server; <br/>}</span></pre><p id="0965" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><em class="lv">选项</em>对象，顾名思义，配置注释。在这种情况下，我们配置一个目录，在其中查找包含与操作相对应的功能的控制器模块。它将返回并调用<code class="fe lw lx ly lz b">require('moduleName')</code>来加载模块，然后调用<code class="fe lw lx ly lz b">MODULE['operationID']</code>来处理操作。因此，要使用<code class="fe lw lx ly lz b">require</code>加载，控制器模块必须为CommonJS格式。</p><p id="40e5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">调用<code class="fe lw lx ly lz b">exegesisExpress.middleware</code>生成一个中间件函数来手动表达。它包含OpenAPI规范，以及options对象。然后我们使用<code class="fe lw lx ly lz b">app.use</code>将这个函数传递给Express。</p><p id="90f1" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这个函数的其余部分是Express应用程序的典型设置。请注意，您可以在注释的同时使用其他Express中间件。对于错误处理，有一个无所不包的处理程序，它将为任何没有被处理的请求执行，并且配置了一个错误处理程序。要启动服务器运行，当然要调用<code class="fe lw lx ly lz b">server.listen()</code>。</p><p id="fb97" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在<code class="fe lw lx ly lz b">lib/controllers</code>中创建一个名为<code class="fe lw lx ly lz b">todoController.ts</code>的文件，包含以下内容:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="be5e" class="me mf iu lz b gz mg mh l mi mj">import * as util from 'util';  </span><span id="5114" class="me mf iu lz b gz nv mh l mi mj">export function createTodo(context) {<br/>   return {<br/>     message: `Hello createTodo ${util.inspect(context.params)}`   <br/>   }; <br/>}  </span><span id="7e6e" class="me mf iu lz b gz nv mh l mi mj">export function listTodos(context) {<br/>   return { <br/>      message: `Hello listTodos ${util.inspect(context.params)}` <br/>   }; <br/>}  </span><span id="970e" class="me mf iu lz b gz nv mh l mi mj">export function getTodoById(context) {<br/>   return { message: `Hello getTodoById ${util.inspect(context.params)}` }; <br/>}  </span><span id="7a25" class="me mf iu lz b gz nv mh l mi mj">export function patchTodoById(context) {<br/>   return { message: `Hello patchTodoById ${util.inspect(context.params)}` }; <br/>}  </span><span id="a3ed" class="me mf iu lz b gz nv mh l mi mj">export function deleteTodo(context) {<br/>   return { message: `Hello deleteTodo ${util.inspect(context.params)}` }; <br/>}</span></pre><p id="7d5e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这些函数名与<code class="fe lw lx ly lz b">todo.yml</code>中的<code class="fe lw lx ly lz b">operationID</code>值相匹配。换句话说，对于与规范中相应条目相匹配的请求，将执行这些函数。</p><p id="8a7b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">结果是，您可以通过配置Express应用程序，然后创建这些操作处理函数来创建OpenAPI服务器。</p><p id="0206" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe lw lx ly lz b">context</code>对象特定于注释，它包含关于请求的所有信息。</p><p id="1638" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">为了简化开发，在<code class="fe lw lx ly lz b">package.json</code>中使用这些脚本:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="ae12" class="me mf iu lz b gz mg mh l mi mj">"scripts": {<br/>     "build": "tsc",<br/>     "watch": "tsc -w",<br/>     "serve": "node ./dist/index.js",<br/>     "monitor": "nodemon --config nodemon.json dist/index.js" <br/>},</span></pre><p id="f2ec" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe lw lx ly lz b">build</code>和<code class="fe lw lx ly lz b">watch</code>脚本负责将源代码构建到<code class="fe lw lx ly lz b">dist</code>目录中。<code class="fe lw lx ly lz b">serve</code>脚本将启动服务器，而<code class="fe lw lx ly lz b">monitor</code>脚本使用<code class="fe lw lx ly lz b">nodemon</code>，这样每当代码被重新构建时，服务器将自动重启。也可以使用<code class="fe lw lx ly lz b">nodemon</code>自动执行单元测试。</p><p id="7ea0" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">服务器运行后，您可以像这样运行它:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="1d51" class="me mf iu lz b gz mg mh l mi mj">$ curl -f http://localhost:3000/todos/all {"message":"Hello listTodos {<br/>       query: {}, header: {}, server: {}, path: {}, cookie: {}  <br/>}"} <br/>$ curl -f http://localhost:3000/todos/111 {"message":"Hello getTodoById {<br/>       query: {}, header: {}, server: {}, path: { id: '111' }, cookie: {}  <br/>}","complete":false} <br/>$ curl -X DELETE -f http://localhost:3000/todos/111 {"message":"Hello deleteTodo {<br/>       query: {}, header: {}, server: {}, path: { id: '111' },<br/>       cookie: {}  }"}</span></pre><p id="8844" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe lw lx ly lz b">getTodoById</code>和<code class="fe lw lx ly lz b">deleteTodo</code>的区别在于后者是一个HTTP删除请求。我们通过在CURL命令行上传递<code class="fe lw lx ly lz b">-X DELETE</code>来调用它。</p><p id="f168" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">因此，注释是一个有吸引力的选择，因为我们可以自由地完全定制Express应用程序，以服务于API之外的其他目的。</p><h1 id="6dd9" class="ml mf iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">使用OpenAPI-Backend创建OpenAPI服务器</h1><p id="1a99" class="pw-post-body-paragraph kz la iu lb b lc nc jv le lf nd jy lh li ne lk ll lm nf lo lp lq ng ls lt lu in bi translated">下一个使用OpenAPI创建REST服务器的例子也使用了类似的方法。通过<code class="fe lw lx ly lz b">openapi-backend</code>,我们给这个包一个OpenAPI规范，它为我们处理请求。然后我们提供一些框架调用的处理函数。</p><ul class=""><li id="0150" class="nh ni iu lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">https://www.npmjs.com/package/openapi-backend</li><li id="27dc" class="nh ni iu lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">文档:<a class="ae mk" href="https://github.com/anttiviljami/openapi-backend/blob/master/DOCS.md" rel="noopener ugc nofollow" target="_blank">https://github . com/anttiviljami/open API-back end/blob/master/docs . MD</a></li><li id="bf8c" class="nh ni iu lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">完整的Express/TypeScript示例:<a class="ae mk" href="https://github.com/anttiviljami/openapi-backend/tree/master/examples/express-typescript" rel="noopener ugc nofollow" target="_blank">https://github . com/anttiviljami/open API-back end/tree/master/examples/Express-TypeScript</a></li><li id="e8c3" class="nh ni iu lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">源代码:<a class="ae mk" href="https://github.com/robogeek/typescript-todo-service/servers/openapi-backend" rel="noopener ugc nofollow" target="_blank">https://github . com/robogeek/typescript-todo-service/servers/open API-back end</a></li></ul><p id="e615" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">通过安装这些包来设置Node.js项目目录</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="e36b" class="me mf iu lz b gz mg mh l mi mj">$ npm init -y <br/>$ npm install express openapi-backend cookie-parser body-parser <br/>$ npm install @types/cookie-parser @types/errorhandler \<br/>        @types/express @types/method-override @types/morgan \<br/>        @types/node typescript nodemon</span></pre><p id="59fc" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">对于典型的ExpressJS服务器来说，这是一组非常有用的包。在撰写本文时，Express v4仍然是当前版本，但是Express v5处于Beta 1中。因此，下面显示的代码是针对Express v4编写的。设置类似于我们为注释所做的，只是包名不同。</p><p id="99a7" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">使用<code class="fe lw lx ly lz b">openapi-backend</code>不需要修改<code class="fe lw lx ly lz b">todo.yml</code>，因为它不使用任何供应商扩展。</p><p id="f75b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">像注释一样，我们为<code class="fe lw lx ly lz b">openapi-backend</code>提供处理函数。当框架匹配一个请求时，它调用处理函数。</p><p id="4c32" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">对于TypeScript配置，可以使用相同的<code class="fe lw lx ly lz b">tsconfig.json</code>，但是增加了一项:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="66f9" class="me mf iu lz b gz mg mh l mi mj">"esModuleInterop": true,</span></pre><p id="977a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这提高了ES6和CommonJS模块之间的互操作性。</p><p id="31be" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在<code class="fe lw lx ly lz b">lib</code>目录下创建一个名为<code class="fe lw lx ly lz b">index.ts</code>的文件。因为需要实现的处理函数很少，所以我们可以将所有的东西放入一个源文件中。</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="bd8d" class="me mf iu lz b gz mg mh l mi mj">import 'source-map-support/register'; <br/>import OpenAPIBackend from 'openapi-backend'; <br/>import Express from 'express'; import morgan from 'morgan';  <br/>import type { Request } from 'openapi-backend';  </span><span id="16f2" class="me mf iu lz b gz nv mh l mi mj">const app = Express(); app.use(Express.json());  </span><span id="983c" class="me mf iu lz b gz nv mh l mi mj">// create api with your definition file or object const api = new OpenAPIBackend({<br/>      definition: '../../todo.yml', <br/>});  </span><span id="c03b" class="me mf iu lz b gz nv mh l mi mj">// register your framework specific request handlers here<br/>api.register({<br/>     createTodo: (c, req, res) =&gt; {<br/>         return res.status(200).json({<br/>             operationId: `createTodo`,<br/>             method: c.request.method,<br/>             path: c.request.path,<br/>             params: c.request.params,<br/>             headers: c.request.headers,<br/>             query: c.request.query,<br/>             body: c.request.body,<br/>             requestBody: c.request.requestBody,<br/>             result: 'ok'<br/>         });<br/>     },<br/>     listTodos: (c, req, res) =&gt; {<br/>         return res.status(200).json({<br/>             operationId: `listTodos`,<br/>             // Ditto<br/>             result: 'ok'<br/>         });<br/>     },<br/>     getTodoById: (c, req, res) =&gt; {<br/>         return res.status(200).json({<br/>             operationId: `getTodoById`,<br/>             // Ditto<br/>             result: 'ok'<br/>         });<br/>     },<br/>     patchTodoById: (c, req, res) =&gt; {<br/>         return res.status(200).json({<br/>             operationId: `patchTodoById`,<br/>             // Ditto<br/>             result: 'ok'<br/>         });<br/>     },<br/>     deleteTodo: (c, req, res) =&gt; {<br/>         return res.status(200).json({<br/>             operationId: `deleteTodo`,<br/>             // Ditto<br/>             result: 'ok'<br/>          });<br/>     },<br/>     validationFail: (c, req, res) =&gt; res.status(400).json({ err: c.validation.errors }),<br/>     notFound: (c, req, res) =&gt; res.status(404).json({ err: 'not found' }),<br/>});  </span><span id="29ea" class="me mf iu lz b gz nv mh l mi mj">// initalize the backend <br/>api.init(); <br/> <br/>// logging <br/>app.use(morgan('combined'));<br/>  <br/>// use as express middleware <br/>app.use((req, res) =&gt; api.handleRequest(req as Request, req, res));</span><span id="e533" class="me mf iu lz b gz nv mh l mi mj"> // start server <br/>app.listen(9000, () =&gt; console.info('api listening at http://localhost:9000'));</span></pre><p id="87bc" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这是普通的Express应用程序设置。<code class="fe lw lx ly lz b">OpenAPIBackend</code>对象使用OpenAPI规范，并包含许多有用的函数。其中一个功能<code class="fe lw lx ly lz b">handleRequest</code>是如何匹配和处理入站请求。</p><p id="0ce5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">想想标有<em class="lv"> use as express middleware </em>的行。从技术上来说，<a class="ae mk" href="https://expressjs.com/en/guide/writing-middleware.html" rel="noopener ugc nofollow" target="_blank">根据中间件的Express文档</a>，这不是中间件的用法，但这是吹毛求疵。中间件函数有三个参数，第三个是下一个的<em class="lv">，下一个</em>的<em class="lv">被调用以将请求沿链向下传递。继续吹毛求疵，这是一个无所不包的路由处理程序，意味着所有入站请求都由该行处理。既然我已经表达了这种吹毛求疵，让我们继续。</em></p><p id="6e53" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们传递给<code class="fe lw lx ly lz b">api.register</code>一个包含所谓的<em class="lv">操作处理程序</em>的对象。这个名字表达了它们的作用，因为它们是你在OpenAPI规范中声明的操作的处理函数。这些函数接收三个参数，一个<em class="lv">上下文</em>以及普通的<em class="lv">请求</em>和<em class="lv">响应</em>对象。上下文对象包含许多关于请求的有用数据。</p><p id="7d39" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您还会注意到两个额外的处理函数。有几个特殊的处理程序来满足错误处理需求:</p><ul class=""><li id="be47" class="nh ni iu lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated"><strong class="lb iv"> validationFail </strong>:当输入数据不符合规范时被调用。</li><li id="b96d" class="nh ni iu lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><strong class="lb iv"> notFound </strong>:如果路径与规范中的任何内容都不匹配，就会被调用。</li><li id="fc88" class="nh ni iu lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><strong class="lb iv"> methodNotAllowed </strong>:如果请求方法(GET、POST、PATCH等)与该路径规范中允许的操作不匹配，则调用该方法。</li><li id="115b" class="nh ni iu lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><strong class="lb iv"> notImplemented </strong>:如果没有为操作ID注册操作处理程序，则被调用。</li><li id="29c2" class="nh ni iu lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><strong class="lb iv"> unauthorizedHandler </strong>:如果安全检查失败就会被调用。</li><li id="94aa" class="nh ni iu lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><strong class="lb iv"> postResponseHandler </strong>:对响应进行后处理，允许你检查响应是否有效。</li></ul><p id="69f1" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">考虑这是如何构成的，以及您的Express应用程序可能如何处理规范中列出的路线以外的其他路线。显然，对于那些要识别的其他路由，它们应该在添加<code class="fe lw lx ly lz b">api.handleRequest</code>之前被附加。另一种方法是<code class="fe lw lx ly lz b">OpenAPIBackend</code>选项对象有一个参数<code class="fe lw lx ly lz b">apiRoot</code>，用于设置API处理的树根。</p><p id="c763" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">使用<code class="fe lw lx ly lz b">OpenAPIBackend</code>对象还可以做更多的事情，所以值得一读文档。</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="b01b" class="me mf iu lz b gz mg mh l mi mj">$ curl -f <a class="ae mk" href="http://localhost:9000/todos/all" rel="noopener ugc nofollow" target="_blank">http://localhost:9000/todos/all</a><br/>{"operationId":"listTodos","method":"get","path":"/todos/all",<br/>   "params":{},"headers":{"host":"localhost:9000",<br/>   "user-agent":"curl/7.81.0","accept":"*/*"},<br/>   "query":{},"body":{},"requestBody":{},"result":"ok"}  <br/>$ curl -X PATCH -f <a class="ae mk" href="http://localhost:9000/todos/111" rel="noopener ugc nofollow" target="_blank">http://localhost:9000/todos/111</a><br/>{"operationId":"patchTodoById","method":"patch","path":"/todos/111",<br/>   "params":{"id":"111"},"headers":{"host":"localhost:9000",<br/>   "user-agent":"curl/7.81.0","accept":"*/*"},<br/>   "query":{},"body":{},"requestBody":{},"result":"ok"}  <br/>$ curl -X DELETE -f <a class="ae mk" href="http://localhost:9000/todos/111" rel="noopener ugc nofollow" target="_blank">http://localhost:9000/todos/111</a><br/>{"operationId":"deleteTodo","method":"delete","path":"/todos/111",<br/>   "params":{"id":"111"},"headers":{"host":"localhost:9000",<br/>   "user-agent":"curl/7.81.0","accept":"*/*"},<br/>   "query":{},"body":{},"requestBody":{},"result":"ok"}  <br/>$ curl -X PATCH -f http://localhost:9000/todoz <br/>curl: (22) The requested URL returned error: 404</span></pre><p id="e118" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">下面是一些针对服务器的示例查询。这些证明我们正在执行预期的操作处理函数。</p><p id="d101" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">像注释一样，OpenAPI-Backend很有吸引力，因为我们可以完全定制Express应用程序。</p><h1 id="6c94" class="ml mf iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">使用Swagger-Codegen-v3和OAS3-Tools创建OpenAPI服务器</h1><p id="b8e3" class="pw-post-body-paragraph kz la iu lb b lc nc jv le lf nd jy lh li ne lk ll lm nf lo lp lq ng ls lt lu in bi translated">Swagger规范和工具的创造者Smart Bear创建了一个名为Swagger Codegen的规范。它处理从OpenAPI规范生成代码，并为几种语言这样做。为Node.js/Express生成的代码使用了OAS3-Tools</p><ul class=""><li id="73be" class="nh ni iu lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">https://hub.docker.com/r/swaggerapi/swagger-codegen-cli-v3</li><li id="6d61" class="nh ni iu lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">github:<a class="ae mk" href="https://github.com/bug-hunters/oas3-tools" rel="noopener ugc nofollow" target="_blank">https://github.com/bug-hunters/oas3-tools</a></li></ul><p id="9922" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这两者都没有很好的记录，所以下面是从实验和阅读源代码中收集的。</p><p id="9e86" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">例如，以这种方式运行它会根据OpenAPI 3规范为Node.js/Express生成代码:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="2af5" class="me mf iu lz b gz mg mh l mi mj">$ docker run --rm -v ${PWD}:/local swaggerapi/swagger-codegen-cli-v3 \<br/>   generate \<br/>   -i /local/todo.yml \<br/>   -l nodejs-server \<br/>   -o /local/servers/swagger-codegen</span></pre><p id="7971" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这将当前目录挂载为Docker容器中的<code class="fe lw lx ly lz b">/local</code>，该容器包含3.x版本的Swagger Codegen。命令行告诉<em class="lv">使用<code class="fe lw lx ly lz b">nodejs-server</code>语言从<code class="fe lw lx ly lz b">todo.yml</code>生成</em>代码到指定的输出目录。</p><p id="9f9e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这很简单。但是，研究生成的代码，如果我们重新生成代码，似乎没有办法避免覆盖定制。看起来我们被期望把这作为一种生成起始项目的方法。但是，我注意到这只是使用了<code class="fe lw lx ly lz b">oas3-tools</code>包，使用该包实现服务器非常容易。因此，与其进一步探索Swagger Codegen，不如让我们转向<code class="fe lw lx ly lz b">oas3-tools</code>。</p><p id="3eb0" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">OAS3-Tools被描述为从<code class="fe lw lx ly lz b">apigee-127/swagger-tools</code>分叉，以实现OpenAPI3。文档不多，但有简单明了的示例代码。不幸的是，使用OAS3-Tools在TypeScript中实现服务器遇到了类型定义的多个问题。因此，不建议将OAS3-Tools与TypeScript一起使用。</p><p id="4c62" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">让我们检查为TODO服务生成的代码:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="a782" class="me mf iu lz b gz mg mh l mi mj">var path = require('path'); <br/>var http = require('http');  <br/>var oas3Tools = require('oas3-tools'); <br/>var serverPort = 8080;  <br/>// swaggerRouter configuration <br/>var options = {<br/>     routing: {<br/>         controllers: path.join(__dirname, './controllers')<br/>     }, <br/>};  </span><span id="8078" class="me mf iu lz b gz nv mh l mi mj">var expressAppConfig = oas3Tools.expressAppConfig(path.join(__dirname, 'api/openapi.yaml'), options); <br/>var app = expressAppConfig.getApp();  </span><span id="a82e" class="me mf iu lz b gz nv mh l mi mj">// Initialize the Swagger middleware<br/>http.createServer(app).listen(serverPort, function () {<br/>     console.log('Your server is listening on port %d (http://localhost:%d)', serverPort, serverPort);<br/>     console.log('Swagger-ui is available on http://localhost:%d/docs', serverPort); <br/>});</span></pre><p id="7116" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">文件<code class="fe lw lx ly lz b">todo.yml</code>作为<code class="fe lw lx ly lz b">api/openapi.yaml</code>被复制到生成的源代码树中。该文件中使用了几个供应商扩展名。</p><p id="77a7" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><em class="lv">选项</em>对象用于配置OAS 3-工具。还有更多可用的字段，它可以配置Swagger UI或数据验证等。此处的<em class="lv">控制器</em>设置给出了一个目录，在该目录中搜索包含操作处理函数的模块。</p><p id="a129" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">功能<code class="fe lw lx ly lz b">oas3Tools.expressAppConfig</code>和<code class="fe lw lx ly lz b">expressAppConfig.getApp</code>消耗<code class="fe lw lx ly lz b">todo.yml</code>中的设置并产生一个快速应用。定制Express应用程序的唯一能力是通过options对象。</p><p id="fe71" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在<code class="fe lw lx ly lz b">controllers</code>目录中创建了一个名为<code class="fe lw lx ly lz b">Default.js</code>的文件。在<code class="fe lw lx ly lz b">openapi.yaml</code>中的供应商扩展中，有一个引用了<code class="fe lw lx ly lz b">Default</code>。该文件包含操作处理函数:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="4214" class="me mf iu lz b gz mg mh l mi mj">module.exports.createTodo = function createTodo (req, res, next, body) {<br/>   ... <br/>};  </span><span id="7c66" class="me mf iu lz b gz nv mh l mi mj">module.exports.deleteTodo = function deleteTodo (req, res, next, id) {<br/>   ... <br/>};  </span><span id="2d96" class="me mf iu lz b gz nv mh l mi mj">module.exports.getTodoById = function getTodoById (req, res, next, id) {<br/>   ... <br/>};  </span><span id="9e44" class="me mf iu lz b gz nv mh l mi mj">module.exports.listTodos = function listTodos (req, res, next) {<br/>   ... <br/>};  </span><span id="3a00" class="me mf iu lz b gz nv mh l mi mj">module.exports.patchTodoById = function patchTodoById (req, res, next, body, id) {<br/>   ... <br/>};</span></pre><p id="53e8" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这些显然意味着Express中间件功能，但是还有额外的参数，因为签名大多匹配Express中间件。缺少OAS3-Tools文档意味着我们不知道如何确定哪些处理函数需要额外的参数，也不知道这些额外的参数是什么。</p><p id="d94f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">OpenAPI规范的任何迭代都将覆盖这个文件。这意味着当您重新生成源代码时，您对此文件所做的任何定制都将丢失。默认实现调用另一个文件<code class="fe lw lx ly lz b">DefaultService.js</code>中的代码，但是当重新生成源代码时，该文件也会被覆盖。</p><p id="9f9a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">换句话说，我们不推荐使用Swagger Codegen，因为它会覆盖您可能要定制的源代码。</p><p id="1cbd" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">但是，可以推荐使用OAS3工具。这是一个易于使用的框架。不幸的是，正如刚刚讨论的，方法签名没有被记录。这将使创建操作处理函数变得困难。</p><p id="ad43" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">使用OAS3-Tools的另一个问题是，options对象的定义方式不便于在TypeScript中使用。并非所有人都使用TypeScript，但在我看来，它比直接的JavaScript更可取。options对象的定义方式是，TypeScript要求我们填写每个字段，而大多数字段显然是可选的。</p><p id="710c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">OAS3-Tools的一个大问题是您无法控制Express应用程序对象的配置。如果它的预配置应用程序不能满足您的需求，您就不走运了。</p><p id="fa8f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">换句话说，这是一个有趣的工具，但我们不能推荐Swagger-Condegen。OAS3-Tools更有趣，但仍然不可用。对于OAS3-Tools团队来说，两个简单的解决方法是添加文档和定义options对象，以便从TypeScript中轻松使用。</p><h1 id="c575" class="ml mf iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">OpenAPI-Generator同上</h1><p id="c00d" class="pw-post-body-paragraph kz la iu lb b lc nc jv le lf nd jy lh li ne lk ll lm nf lo lp lq ng ls lt lu in bi translated">OpenAPI-Generator项目很大，涵盖了客户机和服务器上OpenAPI规范的代码生成，使用了一长串语言。这看起来是一个有趣的项目，可能会非常有用。但是最初的试运行显示了OAS3-Tools的许多问题。</p><p id="2f9d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">github:<a class="ae mk" href="https://github.com/OpenAPITools/openapi-generator" rel="noopener ugc nofollow" target="_blank">https://github.com/OpenAPITools/openapi-generator</a></p><p id="d922" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这个工具是用Java实现的，执行它的最佳方式似乎是使用Docker容器，如下所示:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="f8ae" class="me mf iu lz b gz mg mh l mi mj">$ docker run --rm -v "${PWD}:/local" openapitools/openapi-generator-cli \<br/>     generate \<br/>     -i /local/todo.yml \<br/>     -o /local/servers/openapi-generator \<br/>     -g nodejs-express-server</span></pre><p id="3601" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这种用法非常类似于Swagger-Codegen工具。</p><p id="30ae" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">生成的代码比使用Swagger-Codegen更广泛。但是，它有刚才提到的同样的问题。它生成的一些文件可能需要定制，但在生成新代码时会被覆盖。</p><p id="e952" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这个工具有一个很长的选项列表，也许在这些选项中有一个解决这个问题的方法。</p><h1 id="d081" class="ml mf iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">摘要</h1><p id="8c72" class="pw-post-body-paragraph kz la iu lb b lc nc jv le lf nd jy lh li ne lk ll lm nf lo lp lq ng ls lt lu in bi translated">这里显示的包是通过查看<code class="fe lw lx ly lz b">npmjs.com</code>网站上OpenAPI包的许多页面搜索结果找到的。对于从OpenAPI规范开发服务器来说，它们是最有前途的。</p><p id="ca99" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">其他一些包允许您编写一个服务器实现，并在JSDOC注释中使用标记，或者使用TypeScript decorators来描述API细节。这些包提供的工具然后被用来生成OpenAPI规范。这样做是为了节省您自己创建规范的努力，因为创建一个大型的OpenAPI规范是一项非常重要的任务。</p><p id="2146" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">其中，最有前途的是OpenAPI-Backend和Exegesis。因为它们不生成代码，所以不会覆盖您自定义的文件。相反，您创建一个实现，框架根据OpenAPI规范在内部配置自己。对于开发来说，这是非常方便的。</p><h1 id="308b" class="ml mf iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">关于作者</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nw"><img src="../Images/aa96a903ad1f239438ae6f035056e77e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*pV0-zU94mK2hrYWD.jpg"/></div></figure><p id="ea39" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><a class="ae mk" href="https://davidherron.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iv">大卫·赫伦</strong> </a> <strong class="lb iv"> </strong>:大卫·赫伦是一名作家和软件工程师，专注于技术的明智使用。他对太阳能、风能和电动汽车等清洁能源技术特别感兴趣。David在硅谷从事了近30年的软件工作，从电子邮件系统到视频流，再到Java编程语言，他已经出版了几本关于Node.js编程和电动汽车的书籍。</p></div><div class="ab cl nx ny hy nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="in io ip iq ir"><p id="d7fe" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><em class="lv">最初发表于</em><a class="ae mk" href="https://techsparx.com/software-development/openapi/openapi-nodejs-servers.html" rel="noopener ugc nofollow" target="_blank"><em class="lv">https://techsparx.com</em></a><em class="lv">。</em></p></div></div>    
</body>
</html>