<html>
<head>
<title>Adding security layers to your App on OpenShift — Part 1: Deployment and TLS Ingress</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在OpenShift上为您的应用添加安全层—第1部分:部署和TLS入口</h1>
<blockquote>原文：<a href="https://itnext.io/adding-security-layers-to-your-app-on-openshift-part-1-deployment-and-tls-ingress-9ef752835599?source=collection_archive---------1-----------------------#2019-07-05">https://itnext.io/adding-security-layers-to-your-app-on-openshift-part-1-deployment-and-tls-ingress-9ef752835599?source=collection_archive---------1-----------------------#2019-07-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="566d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天，保护你的应用程序是必须的，但是如果你没有在一开始就考虑它，那么在不修改代码的情况下引入它是很困难的。幸运的是，像<a class="ae kl" href="http://kubernetes.io" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>这样的容器和平台带来的新的云原生模式提供了简单的方法来解决安全问题，而无需接触代码。</p><p id="232e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个博客系列中，我们将经历许多阶段来保护现有的<code class="fe km kn ko kp b">fruits-catalog</code>应用程序。一步一步来，我们将添加新的安全层，以实现最先进的安全应用。我们将使用<a class="ae kl" href="http://www.openshift.com" rel="noopener ugc nofollow" target="_blank"> OpenShift </a>、<a class="ae kl" href="http://www.keycloak.org" rel="noopener ugc nofollow" target="_blank"> Keycloak </a>和<a class="ae kl" href="http://vaultproject.io" rel="noopener ugc nofollow" target="_blank"> Hashicorp Vault </a>的高级功能来增强不同的安全方面，并且只通过修改配置或添加新代码的轻量级部分(不修改现有代码)。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/bcf6ac4486caa824e59fffd7e1ed83cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uy0OGXAfShMhn3lOcGSTTQ.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">第1部分—在OpenShift上部署TLS入口</figcaption></figure><p id="8a1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章是一个更大的系列文章的一部分，讲述了如何给现有的应用程序增加安全层。目前公布的其他部分有:</p><ul class=""><li id="f3c8" class="lh li iq jp b jq jr ju jv jy lj kc lk kg ll kk lm ln lo lp bi translated"><em class="lg">第1部分——部署和TLS入口(本文)</em></li><li id="0a37" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-2-8320018bcdd1" rel="noopener"> <em class="lg">第二部分——使用Keycloak的认证和授权</em> </a></li><li id="5b40" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-3-secret-management-with-vault-8efd4ec29ec4" rel="noopener"> <em class="lg">第三部分——金库秘密管理</em> </a></li><li id="bc3f" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-4-dynamic-secrets-with-vault-b5fe1fc7709b" rel="noopener"> <em class="lg">第四部分——带金库的动态秘密</em> </a></li><li id="8a71" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-5-mutual-tls-with-istio-a8800c2e4df4" rel="noopener"> <em class="lg">第5部分——与Istio </em> </a>的相互TLS</li><li id="9030" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-6-pki-as-a-service-with-vault-and-cert-e6dbbe7028c7" rel="noopener"> <em class="lg">第6部分—使用保管库和证书管理器的PKI服务</em> </a></li></ul><p id="b2e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每篇文章都遵循相同的结构以保持易懂:我们想要达到什么？如何应用？怎么查？它是如何工作的？在结束之前。这个博客系列的源代码和技术资源位于我的GitHub库:<a class="ae kl" href="https://github.com/lbroudoux/secured-fruits-catalog-k8s" rel="noopener ugc nofollow" target="_blank">https://github.com/lbroudoux/secured-fruits-catalog-k8s</a></p><h1 id="5e80" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">介绍</h1><p id="8046" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated"><code class="fe km kn ko kp b">fruits-catalog</code>应用程序是一个非常简单的应用程序，由3个组件组成:一个<a class="ae kl" href="http://angular.io" rel="noopener ugc nofollow" target="_blank"> Angular </a>前端，一个<a class="ae kl" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>后端和一个<a class="ae kl" href="https://www.mongodb.com" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>数据存储。相当经典！起初，应用程序并没有被认为是在容器中运行的。如果您的机器上运行着MongoDB数据库，那么您可以通过克隆存储库并启动应用程序来轻松地进行测试:</p><pre class="kr ks kt ku gt my kp mz na aw nb bi"><span id="5980" class="nc lw iq kp b gy nd ne l nf ng">$ git clone <a class="ae kl" href="https://github.com/lbroudoux/secured-fruits-catalog-k8s" rel="noopener ugc nofollow" target="_blank">https://github.com/lbroudoux/secured-fruits-catalog-k8s</a><br/>[...]<br/>$ cd <a class="ae kl" href="https://github.com/lbroudoux/secured-fruits-catalog-k8s" rel="noopener ugc nofollow" target="_blank">secured-fruits-catalog-k8s</a><br/>$ mvn package -Pprod<br/>[...]<br/>$ java -jar target/fruits-catalog-1.0.0-SNAPSHOT.jar<br/>[...]<br/>2019-06-21 16:43:13.933  INFO 29503 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''<br/>2019-06-21 16:43:13.935  INFO 29503 --- [           main] c.g.l.f.c.FruitsCatalogApplication       : Started FruitsCatalogApplication in 8.216 seconds (JVM running for 8.963)</span></pre><p id="8fc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦应用程序完成启动，你可以将浏览器指向<code class="fe km kn ko kp b"><a class="ae kl" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank">http://localhost:8080</a></code>来检查结果，你应该会看到一个漂亮的GUI来显示你的目录(现在是空的)。可以开始加<code class="fe km kn ko kp b">apple, orange, grape, banana, cherry, lemon</code>等等……(尊重案例看图标)</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nh"><img src="../Images/0df931fb595eb57f4ccaae093747ba72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LD3WugkdfdiJzrmVAJak_A.png"/></div></div></figure><blockquote class="ni nj nk"><p id="059c" class="jn jo lg jp b jq jr js jt ju jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj kk ij bi translated">顺便说一下，感谢<a class="ae kl" href="https://www.flaticon.com/authors/freepik" rel="noopener ugc nofollow" target="_blank"> Freepik </a>为nice<a class="ae kl" href="http://creativecommons.org/licenses/by/3.0/" rel="noopener ugc nofollow" target="_blank">Creative Commons BY 3.0</a>授权图标！</p></blockquote><p id="2620" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了为应用程序部署这一系列增强，您需要一个Kubernetes集群。为了便于使用，我们实际上选择了<a class="ae kl" href="http://www.openshift.com" rel="noopener ugc nofollow" target="_blank"> OpenShift </a>发行版。</p><blockquote class="ni nj nk"><p id="546d" class="jn jo lg jp b jq jr js jt ju jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj kk ij bi translated">OpenShift <strong class="jp ir">是一个</strong> Kubernetes发行版，所以每个Kubernetes API和命令行工具都可以使用。即使为了节省时间，我把重点放在了OpenShift上，但是每个概念和附加功能都可以应用到普通的Kube安装上。</p></blockquote><h1 id="cca1" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">我们想在这部分实现什么？</h1><p id="92a4" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">在第一部分中——作为热身——我们将简单地看看如何将该应用程序作为容器轻松部署到OpenShift Kubernetes发行版上。我们还将看到如何使用Kubernetes secrets，并在进入集群时使用<a class="ae kl" href="https://en.wikipedia.org/wiki/Transport_Layer_Security" rel="noopener ugc nofollow" target="_blank"> TLS </a>来保护传输层。</p><p id="788c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上，我们希望拥有以下架构，如下图所示:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi no"><img src="../Images/74048a209278bd4ceb0a0eefbb76ed9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LYrh6yXB6HI3OutK17jdSQ.png"/></div></div></figure><p id="577a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从安全性的角度来看，第一次转换的好处可以总结为:</p><ul class=""><li id="71ba" class="lh li iq jp b jq jr ju jv jy lj kc lk kg ll kk lm ln lo lp bi translated">作为容器部署的组件可以利用底层主机系统的多租户、隔离和资源密集化特性。请看一下<a class="ae kl" href="https://www.redhat.com/en/resources/container-security-openshift-cloud-devops-whitepaper" rel="noopener ugc nofollow" target="_blank">集装箱安全的十层</a>白皮书，</li><li id="4af1" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated">Kubernetes / OpenShift允许对向其他服务和外部世界公开的内容进行细粒度控制。部署单元(又名Pod)不再是公开的和可直接寻址的，</li><li id="3955" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated">数据库凭据作为机密进行管理，独立于应用程序部署。他们可以使用强大的<a class="ae kl" href="https://docs.openshift.com/container-platform/3.11/architecture/additional_concepts/authorization.html" rel="noopener ugc nofollow" target="_blank"> RBAC模型</a>由专门的操作人员观看/编辑，</li><li id="350f" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated">在TLS的支持下，通过OpenShift <a class="ae kl" href="https://docs.openshift.com/container-platform/3.11/dev_guide/routes.html" rel="noopener ugc nofollow" target="_blank">路由</a>控制对外部世界的暴露。</li></ul><h1 id="a98c" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">如何应用？</h1><p id="3572" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">假设您有某种OpenShift集群实例正在运行并且可用。根据您的环境和需求，此实例可以采用多种形式:</p><ul class=""><li id="11b7" class="lh li iq jp b jq jr ju jv jy lj kc lk kg ll kk lm ln lo lp bi translated">在您的站点或您的云实例上完全成熟的OpenShift集群，参见如何<a class="ae kl" href="https://docs.openshift.com/container-platform/3.11/install_config/index.html" rel="noopener ugc nofollow" target="_blank">在您的站点上安装open shift</a>，</li><li id="4d77" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated">Red Hat Container开发工具包，了解如何<a class="ae kl" href="http://developers.redhat.com/products/cdk/get-started/" rel="noopener ugc nofollow" target="_blank">开始使用CDK </a>，</li><li id="905f" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated">笔记本电脑上的轻量级Minishift，请参见<a class="ae kl" href="https://github.com/minishift/minishift" rel="noopener ugc nofollow" target="_blank"> Minishift项目页面</a>。</li></ul><p id="7b8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">登录到OpenShift环境后，开始为我们的组件创建一个新项目(Kubernetes名称空间++)。</p><pre class="kr ks kt ku gt my kp mz na aw nb bi"><span id="3d28" class="nc lw iq kp b gy nd ne l nf ng">$ oc new-project fruits-catalog --display-name="Fruits Catalog"</span></pre><p id="da48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，从您的存储库克隆的根开始，在您的项目中创建新元素。首先，在放松了一些约束之后，部署一个新的MongoDB数据库:</p><pre class="kr ks kt ku gt my kp mz na aw nb bi"><span id="7f7a" class="nc lw iq kp b gy nd ne l nf ng">$ oc adm policy add-scc-to-user anyuid -z default -n fruits-catalog<br/>$ oc adm policy add-scc-to-user privileged -z default -n fruits-catalog<br/>$ oc new-app mongodb-persistent --name=mongodb -p DATABASE_SERVICE_NAME=mongodb -p MONGODB_DATABASE=sampledb -l app=fruits-catalog -n fruits-catalog</span></pre><blockquote class="ni nj nk"><p id="e24e" class="jn jo lg jp b jq jr js jt ju jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj kk ij bi translated">因此，现在放松一些约束并允许<code class="fe km kn ko kp b"><em class="iq">anyuid</em></code>和<code class="fe km kn ko kp b"><em class="iq">privileged</em></code>并不是强制性的，我们将在第5部分中需要它来进行高级调整。</p></blockquote><p id="38f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">OpenShift上的MongoDB部署会自动为您创建一个新的Kubernetes secret，使用admin、用户名和密码来连接数据库。然后，只需使用以下命令将我们的应用程序作为新的OpenShift <code class="fe km kn ko kp b">DeploymentConfig</code>部署到您的集群上:</p><pre class="kr ks kt ku gt my kp mz na aw nb bi"><span id="ceec" class="nc lw iq kp b gy nd ne l nf ng">$ mvn fabric8:deploy -Popenshift<br/>[...]</span></pre><p id="c658" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在一切部署之前等待几分钟——您可以从控制台或从<code class="fe km kn ko kp b">oc logs</code>命令检查日志。之后，在检查pod和路线时，您应该会看到类似的内容:</p><pre class="kr ks kt ku gt my kp mz na aw nb bi"><span id="1475" class="nc lw iq kp b gy nd ne l nf ng">$ oc get pods -n fruits-catalog                                                                                         NAME                                   READY     STATUS      RESTARTS   AGE<br/>fruits-catalog-1-xx7nd                 1/1       Running     0          1h<br/>fruits-catalog-s2i-1-build             0/1       Completed   0          1h<br/>mongodb-1-t85wm                        1/1       Running     0          1h</span><span id="9003" class="nc lw iq kp b gy np ne l nf ng">$ oc get routes                                                                                                                          NAME             HOST/PORT                                                  PATH      SERVICES         PORT      TERMINATION   WILDCARD<br/>fruits-catalog   fruits-catalog-fruits-catalog-2.apps.x.x.x.x.nip.io             fruits-catalog   8080                  None</span></pre><p id="d671" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哇！所有这些对象都是用一个简单的命令创建的！这就是<a class="ae kl" href="https://maven.fabric8.io/" rel="noopener ugc nofollow" target="_blank"> Maven Fabric8 </a>插件的神奇之处，它使用一些约定(你可以用片段覆盖)为你创建所有这些资源。您可以看到，默认路由是在没有终端的情况下创建的。最后，您必须修补路由，以便添加边缘TLS终端:</p><pre class="kr ks kt ku gt my kp mz na aw nb bi"><span id="10de" class="nc lw iq kp b gy nd ne l nf ng">$ oc patch route/fruits-catalog --type=json -p '[{"op":"add", "path":"/spec/tls", "value":{"termination":"edge"}}]' -n fruits-catalog</span></pre><p id="0e80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，您应该已经为第一部分做好了一切准备！</p><h1 id="f4c0" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">检查它是否按预期工作</h1><p id="edaf" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">只需使用之前升级的路由的URL打开浏览器窗口，并检查应用程序是否按预期运行。应用程序现在使用TLS提供服务，您可以访问证书的详细信息。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nq"><img src="../Images/9ff153200f11be4a2666c1e392f43d05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QRBGgiWRyXlG5M9Dyq2ZBQ.png"/></div></div></figure><p id="6015" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在上面的截图中发现了一些错误，因为我的安装使用了一个定制的证书颁发机构来生成自签名证书，但是你可以很容易地配置OpenShift来使用外部提供者，比如<a class="ae kl" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank"> Let'sEncrypt </a>。</p><p id="382d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们看到我们的应用程序正在与我们的后端对话，而没有对它进行配置。嗯，事实并非如此…事情并没有神奇到那种地步。看看回购中的<code class="fe km kn ko kp b"><a class="ae kl" href="https://github.com/lbroudoux/secured-fruits-catalog-k8s/blob/master/src/main/fabric8/deployment.yml#L34" rel="noopener ugc nofollow" target="_blank">src/main/figure8/deployment.yml</a></code>片段。您会注意到我们已经做好了准备，以便我们的应用程序能够从Kubernetes secret中的凭证检索并构建一个连接字符串。</p><pre class="kr ks kt ku gt my kp mz na aw nb bi"><span id="611c" class="nc lw iq kp b gy nd ne l nf ng">env:<br/>  - name: SPRING_DATA_MONGODB_USER<br/>    valueFrom:<br/>      secretKeyRef:<br/>        key: database-user<br/>        name: mongodb<br/>  - name: SPRING_DATA_MONGODB_PASSWORD<br/>    valueFrom:<br/>      secretKeyRef:<br/>        key: database-password<br/>        name: mongodb<br/>  - name: SPRING_DATA_MONGODB_URI<br/>    value: mongodb://${SPRING_DATA_MONGODB_USER}:${SPRING_DATA_MONGODB_PASSWORD}@mongodb/sampledb</span></pre><p id="2205" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还记得这个秘密是在部署MongoDB pod时创建的吗？然后，即使我们不知道实际值，我们现在也能够引用和使用它。<code class="fe km kn ko kp b">SPRING_DATA_*</code>环境变量是从这些值中创建的，这些典型的变量是应用程序在启动时创建连接时所熟知的。</p><h1 id="82a8" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">结论和下一步</h1><p id="9836" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">在第一部分中，我们看到了使用简单的Maven Fabric8插件如何帮助我们轻松地将应用程序部署到OpenShift Kubernetes发行版。将我们的应用程序部署为容器使我们能够利用平台服务的优势，如应用程序的秘密管理。此外，它允许与主机系统的有效隔离、资源控制和多租户。最后，它允许我们通过TLS轻松地控制我们的应用程序的公开，而不必修改它、配置Java密钥库、信任库或这类东西。</p><p id="884d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个小小的热身之后，我们将进入正题:我们将看到如何使用Keycloak为我们的应用程序添加身份验证和授权。敬请期待第二部分！</p></div></div>    
</body>
</html>