<html>
<head>
<title>Testing browser window.location in Angular application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试浏览器窗口。角度应用程序中的位置</h1>
<blockquote>原文：<a href="https://itnext.io/testing-browser-window-location-in-angular-application-e4e8388508ff?source=collection_archive---------0-----------------------#2018-05-11">https://itnext.io/testing-browser-window-location-in-angular-application-e4e8388508ff?source=collection_archive---------0-----------------------#2018-05-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0bd95812b239e45f9f13e77aafbe7127.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dEKmqZ-h0LuQAnRNbv_Bew.png"/></div></div></figure><p id="df5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们走之前，我需要澄清一些存在于角度世界与位置物体的混淆。有来自<code class="fe kw kx ky kz b">@angular/common</code>的位置和默认可用的本地DOM位置。尽管Angular的版本提供了<code class="fe kw kx ky kz b">.go()</code>功能，但实际上它只与路由器交互，并不像DOM object那样重新加载页面。所以，对于真正的浏览器交互，你必须使用DOM版本，这给你带来了一个问题如何测试它？</p><p id="4405" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是，不可能窥探它，因为它不是一个可写的对象。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="3bc1" class="li lj iq kz b gy lk ll l lm ln">const spy = spyOn(location, ‘assign’).and.stub();<br/>...</span><span id="3695" class="li lj iq kz b gy lo ll l lm ln">Error: &lt;spyOn&gt; : assign is not declared writable or has no setter</span></pre><p id="efca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你尝试这样做，这是典型的Jasmine错误。</p><h2 id="2f2c" class="li lj iq bd lp lq lr dn ls lt lu dp lv kj lw lx ly kn lz ma mb kr mc md me mf bi translated">救助依赖注射</h2><p id="1095" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">我们需要用依赖注入机制将它注入我们的组件，而不是直接操纵<code class="fe kw kx ky kz b">location</code>。注射后，我们可以用双倍测试来代替它。</p><p id="33f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">DI工作原理简介。如果您熟悉它，只需跳到代码示例。这是某个模块中的典型提供商部分</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="9664" class="li lj iq kz b gy lk ll l lm ln">providers: [<br/>  MyService,  // short way<br/>  { provide: MyService, useClass: MyService } // full way<br/>]</span></pre><p id="e17d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模块中的每个提供者声明实际上等同于完整的提供者描述，其中<code class="fe kw kx ky kz b">MyService</code>不是作为类名，而是作为一个<em class="ml">标记</em>来标识您的服务。这个标记Angular取自关于类的TypeScript元数据。详见<a class="ae mm" href="https://angular.io/guide/dependency-injection" rel="noopener ugc nofollow" target="_blank">依赖注入指南</a>。</p><p id="1102" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望Angular为我们提供了<code class="fe kw kx ky kz b">InjectionToken</code>类，我们可以用它来生成任何自定义令牌。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="2efb" class="li lj iq kz b gy lk ll l lm ln">import { <a class="ae mm" href="https://angular.io/api/core/InjectionToken" rel="noopener ugc nofollow" target="_blank">InjectionToken</a> } from '@angular/core';<br/>...<br/>export const LOCATION_TOKEN = new InjectionToken&lt;Location&gt;('Window location object');</span></pre><p id="d174" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了能够使用这个令牌，我们必须使用Angular中也提供的特殊属性装饰器<code class="fe kw kx ky kz b">@Inject</code>。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="6521" class="li lj iq kz b gy lk ll l lm ln">@Inject(LOCATION_TOKEN) private location: Location</span></pre><p id="0b72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们把所有的部分结合在一起</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="9cc5" class="li lj iq kz b gy lk ll l lm ln">export const LOCATION_TOKEN = new InjectionToken&lt;Location&gt;('Window location object');</span><span id="d05e" class="li lj iq kz b gy lo ll l lm ln">@Component({<br/>  providers: [<br/>    { provide: LOCATION_TOKEN, useValue: window.location }<br/>  ]<br/>})<br/>export class SomeComponent {<br/>  constructor(@Inject(LOCATION_TOKEN) private location: Location) {}</span><span id="5c75" class="li lj iq kz b gy lo ll l lm ln">  useIt() {<br/>    this.location.assign('xxx');<br/>  }<br/>}</span></pre><p id="027a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种技术不仅可以用于注入位置对象，还可以用于注入没有特定类的任何其他实体，如其他WebAPI对象、应用程序配置等。</p></div></div>    
</body>
</html>