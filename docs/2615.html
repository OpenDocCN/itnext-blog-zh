<html>
<head>
<title>Associative PHP arrays in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的关联PHP数组</h1>
<blockquote>原文：<a href="https://itnext.io/associative-php-arrays-in-typescript-49cffc5a2051?source=collection_archive---------5-----------------------#2019-06-24">https://itnext.io/associative-php-arrays-in-typescript-49cffc5a2051?source=collection_archive---------5-----------------------#2019-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b2cc9d571fedb1a0fdf2cd606861744a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pm-RsajxOlOEQBrYwAejEw.png"/></div></div></figure><p id="9f5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">PHP中关联数组的概念有点不常见；大多数语言用地图、列表、字典或类似的结构来实现这个概念。而且，即使PHP中的关联数组是可能的(并且被大量使用)，但是一旦您想在JSON API中使用它们，它们就会变得有点混乱。</p><h1 id="242e" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">JSON中的关联数组</h1><p id="198b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们看看JSON响应中的关联数组会发生什么。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="26f6" class="mi kx iq me b gy mj mk l ml mm">$data = []; <br/>// Becomes [] in JSON</span><span id="fbcc" class="mi kx iq me b gy mn mk l ml mm">$data = ["one", "two", "three"];<br/>// Becomes ["one", "two, "three"] in JSON</span><span id="02a7" class="mi kx iq me b gy mn mk l ml mm">$data = [0 =&gt; "foo", 137 =&gt; "bar"];<br/>// Becomes { "0": "foo", "137": "bar" } in JSON</span><span id="22b3" class="mi kx iq me b gy mn mk l ml mm">$data = ["foo", 3 =&gt; "bar", "hello" =&gt; "world"];<br/>// Becomes { "0": "foo", "3": "bar", "hello": "world" } in JSON</span></pre><p id="34f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您所看到的，JSON中只有“真正的”数组才是数组，而关联项将数组转化为对象。</p><h1 id="d042" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">合适的类型</h1><p id="d221" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">因为关联数组要么成为一个对象，要么成为一个数组，所以正确的类型应该是<code class="fe mo mp mq me b">object | []</code>。这实际上很简单，但是我们可以通过为关联数组引入我们自己的类型来做得更好——包括一个泛型来获取关于数组元素类型的信息。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="fda5" class="mi kx iq me b gy mj mk l ml mm">type AssociativeArray&lt;T = unknown&gt; = {[key: string]: T | undefined} | T[];</span></pre><p id="df44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mo mp mq me b">T</code>最终可能会被省略，但是为我们的数组提供了额外的类型信息。</p><p id="f28a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个<a class="ae mr" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types" rel="noopener ugc nofollow" target="_blank">联合类型</a>告诉TypeScript，我们要么处理一个由键-值对组成的对象，其中键是一个字符串，值是类型<code class="fe mo mp mq me b">T</code>、<strong class="ka ir">或</strong>一个包含元素<code class="fe mo mp mq me b">T</code>的简单数组(也包括空数组)。这听起来可能有点复杂，但是如果我们再看一个例子，一切都应该清楚了(假设<code class="fe mo mp mq me b">getData</code>从我们的API中检索数据):</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="7e8d" class="mi kx iq me b gy mj mk l ml mm">// $data = [];<br/>const data: AssociativeArray = getData(); <br/>// not specifying `T` means that the type remains unknown</span><span id="f50d" class="mi kx iq me b gy mn mk l ml mm">// $data = ["one", "two", "three"];<br/>const data: AssociativeArray&lt;string&gt; = getData();<br/>data[0]; // equals "one"<br/>data[1].toFixed(); // error: `toFixed` does not exist on strings!</span><span id="4cbd" class="mi kx iq me b gy mn mk l ml mm">// $data = [0 =&gt; "foo", 137 =&gt; "bar"];<br/>const data: AssociativeArray&lt;string&gt; = getData();<br/>data[0]; // equals "foo"<br/>data[137]; // equals "bar"</span><span id="f0fd" class="mi kx iq me b gy mn mk l ml mm">// $data = ["foo", 3 =&gt; "bar", "hello" =&gt; "world"]<br/>const data: AssociativeArray&lt;string&gt; = getData();<br/>data["0"]; // equals "foo"<br/>data["3"]; // equals "bar"<br/>data["hello"]; // equals "world"<br/>data["hello"].toFixed(); // error: `toFixed` does not exist on strings!</span><span id="44d1" class="mi kx iq me b gy mn mk l ml mm">// $data = [1, 2, 3]<br/>const data: AssociativeArray&lt;number&gt; = getData();<br/>data[0]; // equals 1</span><span id="8c43" class="mi kx iq me b gy mn mk l ml mm">// $data = [[], [1, 2, 3]]<br/>const data: AssociativeArray&lt;number[]&gt; = getData();<br/>data[0]; // equals []<br/>data[1]; // equals [1, 2, 3]<br/>data[1][0]; // equals 1<br/>data[1][0].substr(0, 5); // error: `substr` does not exist on numbers!</span></pre><p id="c5c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">多亏了这个泛型，我们很容易就能知道数组里面有什么。</p><h1 id="d00d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">地图</h1><p id="85c7" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">正如开始时提到的，许多语言以映射(或列表，或任何你想叫它们的东西)的形式实现关联数组。<a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank">JavaScript</a>中也存在映射，因此我们也可以通过简单地使用<code class="fe mo mp mq me b">Object.entries</code>将我们的JSON响应转换成映射:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="3641" class="mi kx iq me b gy mj mk l ml mm">// Data from our API<br/>const data =  {<br/>  "foo": "bar",<br/>  "hello": "world"<br/>};</span><span id="1fbc" class="mi kx iq me b gy mn mk l ml mm">const map = new Map&lt;string, string&gt;(Object.entries(data));</span><span id="83cb" class="mi kx iq me b gy mn mk l ml mm">map.get('foo'); // equals "bar"<br/>map.get('hello'); // equals "world"</span></pre><p id="ec86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">TypeScript中的映射是通用的，允许我们指定键<strong class="ka ir">和</strong>值的类型</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><p id="2aa8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢这篇文章，请留下👏，关注我上 <a class="ae mr" href="https://twitter.com/nehalist" rel="noopener ugc nofollow" target="_blank"> <em class="mz">推特</em> </a> <em class="mz">并订阅</em> <a class="ae mr" href="https://nehalist.io/newsletter/" rel="noopener ugc nofollow" target="_blank"> <em class="mz">我的快讯</em> </a> <em class="mz">。原载于2019年6月24日</em><a class="ae mr" href="https://nehalist.io/associative-php-arrays-in-typescript" rel="noopener ugc nofollow" target="_blank"><em class="mz">https://nehalist . io</em></a><em class="mz">。</em></p></div></div>    
</body>
</html>