<html>
<head>
<title>Cloud Native CI/CD with Tekton — Building Custom Tasks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Tekton构建云本机CI/CD—构建定制任务</h1>
<blockquote>原文：<a href="https://itnext.io/cloud-native-ci-cd-with-tekton-building-custom-tasks-663e63c1f4fb?source=collection_archive---------5-----------------------#2021-04-14">https://itnext.io/cloud-native-ci-cd-with-tekton-building-custom-tasks-663e63c1f4fb?source=collection_archive---------5-----------------------#2021-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a650" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何使用Tekton管道在Kubernetes上为云原生CI/CD使用、构建和部署定制任务…</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9fd1f7e12025b3380e74f8d248ee90f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B1MKU3tnp6HEpMOrdKxbKQ.png"/></div></div></figure><p id="5b4d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我们将继续我们在<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/cloud-native-ci-cd-with-tekton-laying-the-foundation-a377a1b59ac0">上一篇文章</a>中停止的地方，在那篇文章中，我们部署了我们的Tekton Pipelines环境，我们将详细探讨如何找到、构建和定制Tekton任务，以便为我们的管道创建所有必要的构建模块。除此之外，我们还将研究如何维护和测试我们新构建的任务，同时使用所有最佳实践来创建可重用、可测试、结构良好且简单的任务。</p><p id="a0b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您还没有这样做，那么请查阅上一篇文章，让您的Tekton开发环境启动并运行，这样您就可以按照本文中的示例进行操作了。</p><p id="4df7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr">注:本文使用的所有代码和资源都可以在</em> <code class="fe ls lt lu lv b"><a class="ae lq" href="https://github.com/MartinHeinz/tekton-kickstarter" rel="noopener ugc nofollow" target="_blank"><em class="lr">tekton-kickstarter</em></a></code> <a class="ae lq" href="https://github.com/MartinHeinz/tekton-kickstarter" rel="noopener ugc nofollow" target="_blank"> <em class="lr">资源库</em> </a>中获得</p><h1 id="f623" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">什么是任务？</h1><p id="5b57" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">Tekton <em class="lr">任务</em>是管道的基本构件。任务是执行某个特定任务的一系列步骤。任务中的每个步骤都是任务窗格中的一个容器。将相关步骤的这种序列隔离到单个可重用的任务中，为Tekton提供了很大的通用性和灵活性。它们可以像运行单个<code class="fe ls lt lu lv b">echo</code>命令一样简单，也可以像构建Docker然后通过映像摘要输出推入注册表一样复杂。</p><p id="c77a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除任务外，<em class="lr">集群任务</em>也可用。它们与基本任务没有太大区别，因为它们只是集群范围的任务。这些对于执行基本操作的通用任务非常有用，比如克隆存储库或运行<code class="fe ls lt lu lv b">kubectl</code>命令。使用ClusterTasks有助于避免代码重复，并有助于提高可重用性。但是要注意对集群任务的修改，因为对它们的任何更改都可能影响集群中所有其他名称空间中的许多其他管道。</p><p id="ce7c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们想要执行一个任务或集群任务时，我们创建<em class="lr"> TaskRun </em>。在编程术语中，你也可以把一个任务看作一个类，把TaskRun看作它的实例。</p><p id="aa47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果上面的解释不够清楚，那么一个小例子可能会有所帮助。下面是我们可以创建的最简单的任务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="5902" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个名为<code class="fe ls lt lu lv b">echo</code>的简单任务确实做到了——它运行一个<code class="fe ls lt lu lv b">ubuntu</code>容器，并向其中注入执行<code class="fe ls lt lu lv b">echo 'Hello world!'</code>的脚本。现在我们有了一个任务，我们也可以运行它，或者换句话说，创建TaskRun。我们可以为此创建一个YAML文件并应用它，或者我们也可以使用<code class="fe ls lt lu lv b">tkn</code> CLI:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6a96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就这么简单！我们已经运行了我们的第一个任务，现在让我们转到一些更有用的东西，并探索已经存在的任务…</p><h1 id="1ac6" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">不要重新发明轮子</h1><p id="3c02" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">这篇文章是关于创建和定制Tekton任务的，但是我们不要试图在这里重新发明一个轮子。相反，让我们使用Tekton社区已经创建的内容。可以使用的现有任务的主要来源是<em class="lr"> Tekton目录</em>。这是一个由Tekton维护者审查的可靠的、有组织的任务的存储库。除了Tekton目录存储库，您还可以使用<a class="ae lq" href="https://hub.tekton.dev/" rel="noopener ugc nofollow" target="_blank"> Tekton Hub </a>，它列出了所有与目录相同的任务，但在导航视图上更容易一些。它还列出了每个任务的等级，这可能是一个有用的质量指标。</p><p id="3276" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个目录中，您应该能够找到所有基本的东西，比如获取存储库(<code class="fe ls lt lu lv b">git-clone</code>)、构建和推送Docker映像(<code class="fe ls lt lu lv b">kaniko</code>或<code class="fe ls lt lu lv b">buildah</code>)或发送Slack通知(<code class="fe ls lt lu lv b">send-to-webhook-slack</code>)的任务。因此，在您决定构建自定义任务之前，请尝试检查目录中常见问题的现有解决方案。</p><p id="3c8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您浏览了Tekton目录或Tekton hub，您可能会注意到每个任务的安装只是一个单独的<code class="fe ls lt lu lv b">kubectl apply -f ...</code>。这很简单，但是如果您依赖于其中的许多任务，并且希望在版本控制中跟踪它们，而不是复制粘贴它们的所有YAML，那么您可以使用<code class="fe ls lt lu lv b"><a class="ae lq" href="https://github.com/MartinHeinz/tekton-kickstarter" rel="noopener ugc nofollow" target="_blank">tekton-kickstarter</a></code> <a class="ae lq" href="https://github.com/MartinHeinz/tekton-kickstarter" rel="noopener ugc nofollow" target="_blank">存储库</a>中的方便脚本，它将获取远程YAML URL的列表，例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="fada" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过调用<code class="fe ls lt lu lv b">make catalog</code>，将它们应用到集群中。</p><h1 id="5ba9" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">布局</h1><p id="bbe6" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">在我们开始定制任务之前，确定布局是个好主意，这将使它们易于导航、测试和部署。我们可以从Tekton目录存储库中获得一些灵感，并使用以下目录结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="4613" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将所有任务存储在一个名为<code class="fe ls lt lu lv b">tasks</code>的目录中。在这里，我们为每个任务创建一个目录，其中包含一个包含任务本身的YAML文件和一个包含测试所需资源的目录(<code class="fe ls lt lu lv b">tests</code>)。这些将是在<code class="fe ls lt lu lv b">run.yaml</code>中运行的任务，以及在<code class="fe ls lt lu lv b">resources.yaml</code>中执行测试所需的任何额外资源。例如，可以是用于执行数据库备份任务的PVC，或者用于执行应用程序扩展任务的部署。</p><p id="3379" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在前面提到的结构中显示的另一个文件是<code class="fe ls lt lu lv b">catalog.yaml</code>，它包含要从远程安装的任务列表。</p><p id="1eb4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了方便起见(如果使用<code class="fe ls lt lu lv b">tekton-kickstarter</code>)，所有这些都可以用一个命令安装，这个命令是<code class="fe ls lt lu lv b">make deploy-tasks</code>，它遍历<code class="fe ls lt lu lv b">tasks</code>目录并将所有任务应用到您的集群，同时忽略所有测试资源。</p><h1 id="4433" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">建造定制的</h1><p id="c961" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">如果你在目录中找不到合适的工作任务，那么是时候自己写了。在文章的开头，我展示了非常简单的“Hello world”示例，但是Tekton任务可能会变得更加复杂，所以让我们来看一下我们可以利用的所有配置选项和功能。</p><p id="3594" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们从简单的开始，介绍我们在构建任何任务时都需要的基础知识。这些是任务步骤的任务参数和脚本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6bd7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用上面的<code class="fe ls lt lu lv b">deploy</code>任务，我们可以执行Kubernetes部署的简单展示，方法是在<code class="fe ls lt lu lv b">name</code>参数中为它提供部署的名称，并可选地提供它所在的<code class="fe ls lt lu lv b">namespace</code>。我们传递给任务的这些参数在脚本执行前在<code class="fe ls lt lu lv b">script</code>部分被展开。为了告诉Tekton扩展参数，我们使用了<code class="fe ls lt lu lv b">$(params.name)</code>符号。这也可以用于spec的其他部分，而不仅仅是脚本。</p><p id="ba46" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们仔细看看<code class="fe ls lt lu lv b">script</code>部分——我们从<em class="lr"> shebang </em>开始，以确保我们将使用<code class="fe ls lt lu lv b">bash</code>。然而，这并不意味着你总是必须使用<code class="fe ls lt lu lv b">bash</code>，就像你可以使用Python和<code class="fe ls lt lu lv b">#!/usr/bin/env python</code>一样，这完全取决于你的偏好和所用图像中的可用内容。在shebang之后，我们还使用了<code class="fe ls lt lu lv b">set -xe</code>,它告诉脚本回显每个正在执行的命令——你不必这样做，但这在调试过程中非常有帮助。</p><p id="1a95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者，如果您不需要整个脚本，而只需要一个命令，那么您可以用<code class="fe ls lt lu lv b">command</code>替换<code class="fe ls lt lu lv b">script</code>部分。这就是使用<code class="fe ls lt lu lv b">kubectl wait</code>执行应用程序健康检查的简单任务的情况(注意:对于剩余的示例，省略任务体中明显的/不相关的部分):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="386a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这与pods中的<code class="fe ls lt lu lv b">command</code>指令的工作方式是一样的，所以如果你有很多参数，它会变得冗长和难以阅读。出于这个原因，我更喜欢在几乎所有事情上使用<code class="fe ls lt lu lv b">script</code>，因为它可读性更好，也更容易更新/更改。</p><p id="8498" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">任务中可能需要的另一个常见东西是某种类型的存储，您可以在其中写入数据，供任务中的后续步骤或管道中的其他任务使用。最常见的用例是<a class="ae lq" href="https://github.com/tektoncd/catalog/tree/master/task/git-clone/0.2" rel="noopener ugc nofollow" target="_blank">获取git repo </a>的地方。这种存储在Tekton中称为<code class="fe ls lt lu lv b">workspace</code>，以下示例显示了使用<code class="fe ls lt lu lv b">rmdir</code>装载和清除存储的任务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="74f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的<code class="fe ls lt lu lv b">clean</code>任务包括<code class="fe ls lt lu lv b">workspace</code>部分，该部分定义了工作空间的名称和它应该被挂载的路径。为了使更新<code class="fe ls lt lu lv b">mountPath</code>更容易，Tekton提供了一个<code class="fe ls lt lu lv b">$(workspaces.ws-name.path)</code>格式的变量，可以在脚本中使用它来引用路径。</p><p id="4acf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，定义工作区非常简单，但是支持工作区的磁盘不会凭空出现。因此，当我们执行要求工作空间的任务时，我们还需要为它创建PVC。为上述任务创建所需PVC的任务运行如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="574f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">工作区非常通用，因此不仅可以用于在任务/管道运行期间存储一些临时数据，还可以用作长期存储，如下例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b57c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该任务可以使用<code class="fe ls lt lu lv b">pg_dump</code>实用程序执行PostgreSQL数据库备份。在本例中，脚本从参数中指定的主机和数据库中获取数据库数据，并将其传输到由PVC支持的工作区。</p><p id="1153" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我潜入这个例子的另一个你会经常遇到的特性是从<em class="lr"> ConfigMaps </em>或<em class="lr"> Secrets </em>注入环境变量的能力。这在<code class="fe ls lt lu lv b">env</code>部分完成。这与Pods的工作方式完全相同，因此您可以参考API的这一部分。</p><p id="2084" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">回到本例的主题——用于数据库备份的PVC——考虑到我们希望该数据是持久的，我们不能使用前面所示的使用<code class="fe ls lt lu lv b">volumeClaimTemplate</code>创建的PVC，因为那样会在任务完成后被清除，所以我们需要单独创建PVC，并以这种方式将其传递给任务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2f34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们用<code class="fe ls lt lu lv b">persistentVolumeClaim</code>代替<code class="fe ls lt lu lv b">volumeClaimTemplate</code>，我们指定现有PVC的名称，它也在上面的代码片段中定义。这个例子还假设在指定的主机上运行着PostgreSQL数据库——完整的代码包括PostgreSQL部署检验文件<a class="ae lq" href="https://github.com/MartinHeinz/tekton-kickstarter/tree/master/tasks/pg-dump/tests" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><p id="0230" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">类似于环境变量的注入，我们也可以使用工作区将整个配置图或秘密(或其中的一些密钥)作为一个文件注入。例如，当您希望将整个<code class="fe ls lt lu lv b">.pem</code>证书从任务中的Secret或作为一个将GitHub存储库映射到应用程序名称的配置文件时，这可能很有用，如下例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b3ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此任务获取存储库URL，并使用它在文件中查找匹配的应用程序名称，该文件是上面显示的配置图的一部分。这是使用<code class="fe ls lt lu lv b">yq</code>实用程序完成的，然后输出到一个名为<code class="fe ls lt lu lv b">/tekton/results/...</code>的特殊目录中的文件。这个目录存储了任务的<code class="fe ls lt lu lv b">results</code>，这是我们还没有提到的一个特性(和YAML部分)。</p><p id="21cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">任务结果是任务可以输出的小块数据，随后可以被后续任务使用。要使用这些，必须在<code class="fe ls lt lu lv b">results</code>部分指定结果变量的名称，然后向<code class="fe ls lt lu lv b">/tekton/results/result-var-name</code>写一些东西。此外，正如您在上面的脚本中肯定注意到的，在将结果写入文件之前，我们使用<code class="fe ls lt lu lv b">tr</code>从结果中去掉了换行符，这是因为结果应该是简单的输出——理想情况下只是一个单词——而不是一大块文本。如果您决定将更长的内容(多行)写入结果，如果不去除换行符，您可能会丢失部分值或只看到空字符串。</p><p id="3bcc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，为了使用任务——比如这个任务——使用来自配置映射的工作空间，我们必须以如下方式在<code class="fe ls lt lu lv b">workspaces</code>部分指定配置映射:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ba62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后我想展示的是边车容器的用法。这些并不常见，但是当您需要在任务执行期间运行一些服务(您的任务依赖于这些服务)时，它们会很有用。一个这样的服务可以是具有暴露套接字的Docker守护进程sidecar。为了演示这一点，我们可以创建一个任务，使用名为<a class="ae lq" href="https://github.com/wagoodman/dive" rel="noopener ugc nofollow" target="_blank"> Dive </a>的工具执行Docker映像效率分析:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e2d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如您在这里看到的，<code class="fe ls lt lu lv b">sidecars</code>部分与Pod规范中任何容器的定义都非常相似。除了我们在前面的例子中看到的常见内容，这里我们还指定了在任务步骤中sidecar和container之间共享的<code class="fe ls lt lu lv b">volumes</code>——在本例中，其中一个是Dive container附加到的<code class="fe ls lt lu lv b">dind-socket</code>中的Docker存储。</p><p id="73d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这涵盖了Tekton任务的大部分特性，但是有一点我到目前为止还没有提到，而你在阅读Tekton文档时肯定会遇到，那就是<a class="ae lq" href="https://github.com/tektoncd/pipeline/blob/main/docs/resources.md" rel="noopener ugc nofollow" target="_blank"><em class="lr">pipeline resource</em></a>对象，它可以用作任务的输入或输出——例如GitHub sources作为输入，Docker image作为输出。那么，为什么我还没有提到呢？PipelineResource是Tekton的一部分，出于几个原因，我不喜欢使用它:</p><ul class=""><li id="df15" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">与我们目前使用的所有其他资源类型不同，它仍然处于alpha阶段</li><li id="6b02" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">管线资源非常少。它大部分只是Git、Pull请求和图像资源。</li><li id="4ce1" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">很难对它们进行故障排除。</li></ul><p id="98ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你需要更多的理由不使用它们(现在)，那么看看这里的文档部分<a class="ae lq" href="https://github.com/tektoncd/pipeline/blob/main/docs/resources.md#why-arent-pipelineresources-in-beta" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="2c50" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们查看的所有这些示例中，我们看到了许多YAML部分、选项和功能，这显示了Tekton的灵活性，但这自然使其API规范非常复杂。<code class="fe ls lt lu lv b">kubectl explain</code>不幸的是对探索API没有帮助，但是API规范可以在<a class="ae lq" href="https://github.com/tektoncd/pipeline/blob/master/docs/api-spec.md" rel="noopener ugc nofollow" target="_blank">文档</a>中找到，但是缺少。所以，如果你很难找到你能在YAML的哪个部分放什么，那么你最好的选择是依靠在<a class="ae lq" href="https://github.com/tektoncd/pipeline/blob/master/docs/tasks.md#configuring-a-task" rel="noopener ugc nofollow" target="_blank">任务文档</a>的开头列出的字段或者在这里的例子<a class="ae lq" href="https://github.com/tektoncd/pipeline/tree/master/examples/v1beta1" rel="noopener ugc nofollow" target="_blank">，但是确保你在你的Tekton版本的正确分支上，否则你可能花费很长时间调试为什么你看起来正确的任务不能被Tekton控制器验证。</a></p><h1 id="c30f" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">运行和测试</h1><p id="0e2c" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">到目前为止，我们大部分时间只是谈论任务，并没有太多关于任务运行的内容。这是因为——在我看来——单独的任务运行最适合测试，而不是真正定期运行任务。为此，您应该使用管道，这将是下一篇文章的主题。</p><p id="c8d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">说到测试——当我们完成了任务的实现后，就该运行一些测试了。对于简单明了的测试，我推荐使用本文前面提到的布局。使用它应该有助于您以一种允许您独立于其目录之外的任何资源来测试它的方式来封装任务。</p><p id="c60b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后执行实际的测试，在<code class="fe ls lt lu lv b">.../tests/resources.yaml</code>(如果有的话)中应用资源/依赖关系，然后在<code class="fe ls lt lu lv b">.../tests/run.yaml</code>中应用实际的测试就足够了。测试实际上只是使用您的定制任务的一组任务运行，因此对于这种基本的测试方法，不需要任何设置/拆卸或额外的脚本——只需要<code class="fe ls lt lu lv b">kubectl apply -f resources.yaml</code>和<code class="fe ls lt lu lv b">kubectl apply -f run.yaml</code>。简单测试的例子可以在<a class="ae lq" href="https://github.com/MartinHeinz/tekton-kickstarter/tree/master/tasks" rel="noopener ugc nofollow" target="_blank"> tekton-kickstarter </a>或tekton目录库中找到每个任务的目录。</p><p id="4f3b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不过，一般来说，对于这两个项目的存储库中的任何特定任务，您都可以运行以下命令来执行测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c61a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对我个人来说——当涉及到测试任务时——使用上面的基本测试方法进行验证和特别测试就足够了。然而，如果您最终创建了大量的定制任务，并且想要全力以赴，那么您可以采用Tekton catalog中的方法，并利用其存储库中的测试脚本。如果您决定走这条路线，并严格遵循布局和测试，您可能还想尝试将任务贡献给Tekton目录，以便整个社区可以从更多高质量的任务中受益。😉</p><p id="3756" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">至于你为此需要的脚本，你需要在你的代码中包含Tekton目录中的<code class="fe ls lt lu lv b"><a class="ae lq" href="https://github.com/tektoncd/catalog/tree/master/test" rel="noopener ugc nofollow" target="_blank">test</a></code> <a class="ae lq" href="https://github.com/tektoncd/catalog/tree/master/test" rel="noopener ugc nofollow" target="_blank">目录</a>以及<em class="lr"> Go </em>依赖项(<code class="fe ls lt lu lv b">vendor</code>目录)，然后在这里遵循文档<a class="ae lq" href="https://github.com/tektoncd/catalog/blob/master/CONTRIBUTING.md#end-to-end-testing" rel="noopener ugc nofollow" target="_blank">中的E2E测试指南。</a></p><p id="30ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">无论您选择基本的还是“全力以赴”的测试方法，都要确保您测试的不仅仅是任务和管道中的快乐路径，否则当它们被部署到<em class="lr">“野外”</em>时，您可能最终会看到许多bug。</p><h1 id="c7fb" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">最佳实践</h1><p id="f475" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">在您实现并测试了您的定制任务之后，最好回去确保您的任务遵循最佳开发实践，这将使它们在长期内更具可重用性和可维护性。</p><p id="804b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你能做的最简单的事情也能带来最大的好处——就是使用<code class="fe ls lt lu lv b">yamllint</code>——YAML文件的一个过磅器。这个技巧不仅适用于Tekton任务，也适用于所有的YAML文件，因为它们可能很难正确处理所有的缩进，但是特别重要的是，任务定义可能会变得很长很复杂，有许多级别的缩进，因此保持它们的可读性和有效性可以节省一些不必要的调试，并有助于保持它们的可维护性。你可以在我的资源库中找到一个我喜欢使用的定制<code class="fe ls lt lu lv b"><a class="ae lq" href="https://github.com/MartinHeinz/tekton-kickstarter/blob/master/.yamllint" rel="noopener ugc nofollow" target="_blank">.yamlint</a></code> <a class="ae lq" href="https://github.com/MartinHeinz/tekton-kickstarter/blob/master/.yamllint" rel="noopener ugc nofollow" target="_blank">配置</a>，但是你应该定制它以适合你的代码风格和格式。只要确保你不时地运行<code class="fe ls lt lu lv b">yamllint</code>(最好是在CI/CD中)来保持事物的完整性和有效性。</p><p id="4b01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">至于实际的Tekton最佳实践——我可以给你一个很大的列表，但大部分都是Tekton维护者推荐的，所以我不会在这里复制粘贴，我只是给你指出相关的资源:</p><ul class=""><li id="47c4" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated"><a class="ae lq" href="https://github.com/tektoncd/catalog/blob/master/recommendations.md" rel="noopener ugc nofollow" target="_blank">任务创作建议</a></li><li id="d4b8" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><a class="ae lq" href="https://github.com/tektoncd/community/blob/main/design-principles.md" rel="noopener ugc nofollow" target="_blank">泰克顿设计原则</a></li><li id="4def" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><a class="ae lq" href="https://github.com/tektoncd/catalog/blob/master/CONTRIBUTING.md#guidelines" rel="noopener ugc nofollow" target="_blank">泰克顿投稿指南</a></li></ul><h1 id="3742" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结束语</h1><p id="7178" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">在本文中，我们看到了Tekton的灵活性和通用性，这种灵活性也带来了构建或测试任务的复杂性。因此，最好使用社区创建的现有任务，而不是自己重新发明一个轮子。然而，如果没有合适的任务可用，而您必须构建自己的任务，请确保为您的任务编写测试，并遵循上面提到的最佳实践，以保持您的任务的可维护性和可靠性。</p><p id="45a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章之后，我们应该有足够的经验以及大量的个人定制任务，我们可以用它们来开始构建我们的管道。这正是我们在本系列的下一篇文章中要做的事情，我们将探索如何构建功能全面的管道来构建、部署、测试您的应用程序等等。</p><p id="63ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，如果您还没有这样做，请确保查看<a class="ae lq" href="https://github.com/MartinHeinz/tekton-kickstarter" rel="noopener ugc nofollow" target="_blank"> tekton-kickstarter资源库</a>，在那里您可以找到本文中的所有任务和示例，以及您将在下一篇文章中看到的管道。😉</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><p id="7d6c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr">本文最初发布于</em><a class="ae lq" href="https://martinheinz.dev/blog/47?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=blog_post_47" rel="noopener ugc nofollow" target="_blank"><em class="lr">martinheinz . dev</em></a></p><div class="nq nr gp gr ns nt"><a rel="noopener  ugc nofollow" target="_blank" href="/cloud-native-ci-cd-with-tekton-laying-the-foundation-a377a1b59ac0"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">使用Tekton的云原生CI/CD—奠定基础</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">是时候通过Tekton Pipelines在Kubernetes上开始您的云原生CI/CD之旅了…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">itnext.io</p></div></div><div class="oc l"><div class="od l oe of og oc oh ks nt"/></div></div></a></div><div class="nq nr gp gr ns nt"><a rel="noopener  ugc nofollow" target="_blank" href="/hardening-docker-and-kubernetes-with-seccomp-a88b1b4e2111"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">用seccomp强化Docker和Kubernetes</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">您的容器可能不像您想象的那样安全，但是seccomp配置文件可以帮助您解决这个问题…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">itnext.io</p></div></div><div class="oc l"><div class="oi l oe of og oc oh ks nt"/></div></div></a></div><div class="nq nr gp gr ns nt"><a href="https://towardsdatascience.com/deploy-any-python-project-to-kubernetes-2c6ad4d41f14" rel="noopener follow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">将任何Python项目部署到Kubernetes</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">是时候深入Kubernetes，使用这个成熟的项目模板将您的Python项目带到云中了！</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">towardsdatascience.com</p></div></div><div class="oc l"><div class="oj l oe of og oc oh ks nt"/></div></div></a></div></div></div>    
</body>
</html>