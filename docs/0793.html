<html>
<head>
<title>Getting Go onto Internet of Things</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">走向物联网</h1>
<blockquote>原文：<a href="https://itnext.io/getting-go-onto-internet-things-582396ff2760?source=collection_archive---------6-----------------------#2018-05-30">https://itnext.io/getting-go-onto-internet-things-582396ff2760?source=collection_archive---------6-----------------------#2018-05-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b957" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何使用Yocto为嵌入式Linux目标编译Go代码</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/b1005ee0eed72c2ef5672e30f25c6f59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KiWovhb0qwosGAeq3_mTVw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">大量生产地鼠</figcaption></figure><p id="1273" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Go主要被认为是创建高性能云应用程序的语言。开发者可能忽略的是，Go对于开发物联网设备来说也很棒。其高效处理请求的能力、易于开发、合理的内存占用以及与C良好接口的能力，使其成为物联网项目中Java、C++或Python的绝佳替代品。</p><p id="38ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于大多数Go开发者来说，在瞄准物联网设备时，最大的挑战不是编写代码，而是编译代码。有几种技术可以用来交叉编译，所有这些技术都需要向Go编译器传递不同的标志。嵌入式目标的有限磁盘空间也可能激励开发人员选择非传统的二进制架构，例如启用链接库，这会使构建标志更加复杂。出于这些原因，对于来自编译“刚刚工作”的云平台的开发人员来说，Go embedded编译可能会特别令人沮丧。</p><p id="e7a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将解释如何通过使用Yocto构建系统来简化物联网嵌入式主板的Go编译。我将首先回顾一下我为什么选择Yocto，以及它是如何工作的。我不会深入讨论如何为一个板设置Yocto开发环境，因为这通常是由制造商或开源社区提供的。相反，我将关注如何通过创建Yocto输入文件类型:bitbake recipes来编译Go代码。这将通过展示一个非常简单的方法来完成，该方法将编译<a class="ae lb" href="https://github.com/golang/example" rel="noopener ugc nofollow" target="_blank">官方Go项目示例</a>，然后检查Yocto从中生成的输出。接下来，我将介绍一些在go菜谱中定制的公共参数，以定制一个构建。然后，我将介绍一些可能需要在特殊情况下使用的更高级的围棋食谱类型。最后，我将简要讨论一下我使用Yocto编译Go经验。</p><h1 id="8057" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">为什么要用Yocto交叉编译？</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/2109a4fc967c1559ddeccd79a175aa25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/0*fVP3eWS7Ar6lv2ka.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">Yocto环境——在<a class="ae lb" href="https://www.yoctoproject.org/docs/2.4.2/mega-manual/mega-manual.html" rel="noopener ugc nofollow" target="_blank"> Yocto Mega手册</a>中有更多解释</figcaption></figure><p id="c850" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有许多构建系统旨在帮助自动交叉编译，但是没有一个像Yocto 那样同时迎合新手和专业人士。它非常受片上系统/模块/板制造商的欢迎，并且也支持爱好嵌入式板(<a class="ae lb" href="http://www.jumpnowtek.com/beaglebone/BeagleBone-Systems-with-Yocto.html" rel="noopener ugc nofollow" target="_blank"> BeagleBone板</a>和<a class="ae lb" href="http://www.jumpnowtek.com/rpi/Raspberry-Pi-Systems-with-Yocto.html" rel="noopener ugc nofollow" target="_blank"> Raspberry Pi </a>)。Yocto的工作原理是将构建Linux映像的过程分解成组件，并允许通过“bitbake recipes”为每个组件提供适应性编译指令(Yocto使用的主要工具称为bitbake)。配方获取关于目标的信息，并编译使用它们的指令，以生成映像(OS+应用程序)或部署包(apt-get、dnf、yum等)。).为了简化配方的创建，有配方库、bitbake类和包含文件，它们极大地简化了特定语言的编译。最近Yocto版本，Rocko onward，通过这样的库扩展了对Go的支持。结果是，一个10行的bitbake方法可以让Go应用程序在Yocto支持的数百块板上构建。</p><h1 id="eb09" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">基本的默认配方</h1><p id="b694" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">以下是用于<a class="ae lb" href="https://github.com/golang/example" rel="noopener ugc nofollow" target="_blank"> Go示例项目</a>的bitbake工作配方。本节将解释它是如何被创建的，以及它所控制的一些基本编译机制。该配方确实需要一个额外的配方用于<code class="fe mg mh mi mj b">golang/x</code>库，该配方在<strong class="jp ir">高级配方</strong>部分给出并解释。一旦两个文件都在Yocto搜索路径中，那么就可以构建Go示例项目了。</p><h2 id="5d3c" class="mk ld iq bd le ml mm dn li mn mo dp lm jy mp mq lq kc mr ms lu kg mt mu ly mv bi translated">创建基本围棋程序</h2><pre class="km kn ko kp gt mw mj mx my aw mz bi"><span id="eb38" class="mk ld iq mj b gy na nb l nc nd">//github.com-golang-example.bb                                                                                                                           DESCRIPTION = "The Go Example Project"</span><span id="2df5" class="mk ld iq mj b gy ne nb l nc nd">SRC_URI = "git://github.com/golang/example.git;protocol=https;"<br/>SRCREV = "${AUTOREV}"<br/>LICENSE = "Apache-2.0"<br/>LIC_FILES_CHKSUM = "file://${WORKDIR}/${PN}-${PV}/src/${GO_IMPORT}/LICENSE;md5=3b83ef96387f14655fc854ddc3c6bd57"</span><span id="0375" class="mk ld iq mj b gy ne nb l nc nd">DEPENDS += "golang.org-x"</span><span id="2368" class="mk ld iq mj b gy ne nb l nc nd">inherit go<br/>GO_IMPORT = "github.com/golang/example"</span></pre><p id="6d91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Go bitbake配方文件是根据某些指南命名的。<a class="ae lb" href="https://blog.gopheracademy.com/advent-2015/go-in-a-yocto-project/" rel="noopener ugc nofollow" target="_blank"> Yocto/Go社区</a>想出了一个主意，通过用“<code class="fe mg mh mi mj b">-</code>”替换“<code class="fe mg mh mi mj b">/</code>”，使文件名尽可能地反映Go导入字符串，以简化依赖性管理。关于文件名是否应该在Go导入路径中保留顶级域，存在一些分歧，因此这可能不在其他开发人员的配方文件名中。对于Go示例项目，Go导入路径应该是<code class="fe mg mh mi mj b">github.com/golang/example</code>，因此配方文件名应该是<code class="fe mg mh mi mj b">github.com-golang-example.bb</code>。</p><p id="58ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单配方包含几个字段，这些字段并不是Go配方所独有的，它们与描述、源位置和许可证有关。描述字段是一个快速的简介，解释食谱的用途。<code class="fe mg mh mi mj b">SRC_URI</code>和<code class="fe mg mh mi mj b">SRCREV</code>字段是为了告诉Yocto在哪里可以找到源代码。在这种情况下，<code class="fe mg mh mi mj b">SRC_URI</code>字段告诉yocto通过https使用git从github下载源代码，<code class="fe mg mh mi mj b">SRCREV</code>字段有特殊的值<code class="fe mg mh mi mj b">${AUTOREV}</code>,告诉Yocto从存储库头部获取。还可以定制这些字段，以选择代码的特定分支或提交，从而进行更严格的版本控制。Go recipes中不同的一个默认行为是，代码不是下载到<code class="fe mg mh mi mj b">${WORKDIR}/${PN}-${PV}/src/</code>，而是下载到<code class="fe mg mh mi mj b">${WORKDIR}/${PN}-${PV}/src/${GO_IMPORT} </code>，因为GOPATH是在<code class="fe mg mh mi mj b">${WORKDIR}/${PN}-${PV}</code>创建的。许可字段<code class="fe mg mh mi mj b">LICENSE</code>和<code class="fe mg mh mi mj b">LIC_FILES_CHKSUM</code>传达许可文件类型、位置和校验和。在这个例子中，我们告诉Yocto许可证文件在克隆的git存储库中，并提供它的MD5校验和。如果您的项目没有标准许可证或根本没有许可证，那么用<code class="fe mg mh mi mj b">CLOSED</code>替换<code class="fe mg mh mi mj b">LICENSE </code>字段值或在<code class="fe mg mh mi mj b">${COMMON_LICENSE_DIR}</code>中找到一个类似的许可证。这些领域出现在大多数Yocto食谱上，所以如果有任何问题，那么Yocto上的通用教程应该会提供答案。</p><p id="ddde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">依赖关系也需要在配方中传达。这是通过向<code class="fe mg mh mi mj b">DEPENDS</code>域添加其他配方名称来完成的。我们不能使用<code class="fe mg mh mi mj b">go get</code>命令，所以我们必须用其他Yocto配方替换这个功能。虽然这可能很麻烦，但是食谱可以被其他包重用，从而更容易重用。对于我们的例子，Go Example项目需要<code class="fe mg mh mi mj b">golang-x</code>库。这些紧密耦合库的配方更高级，我将在<strong class="jp ir">高级配方-多包配方</strong>部分中介绍。目前，我们只需要知道这个配方的名称是<code class="fe mg mh mi mj b">golang.org-x.bb</code>，并通过将<code class="fe mg mh mi mj b">DEPENDS += "golang-x"</code>插入配方来添加它作为一个依赖项。</p><p id="aacc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一步是添加Go配方库。<code class="fe mg mh mi mj b">include go</code>语句继承了<code class="fe mg mh mi mj b">go.bbclass</code>语句，后者添加了Go编译函数并在后台修改现有行为。这就是为什么菜谱使用<code class="fe mg mh mi mj b">GO_IMPORT </code>字段值将源代码下载到一个特殊的目录中。该语句还向我们的配方添加了其他特殊参数，我们将在后面的小节中探讨这些参数。</p><h2 id="78fb" class="mk ld iq bd le ml mm dn li mn mo dp lm jy mp mq lq kc mr ms lu kg mt mu ly mv bi translated">构建和结果</h2><p id="ac05" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">假设您已经激活了Yocto环境，构建这个项目非常简单。首先，确保<code class="fe mg mh mi mj b">github.com-golang-example.bb</code>和<code class="fe mg mh mi mj b">golang.org-x.bb </code>位于Yocto可以找到它们的目录中(如果遇到问题，将它们放在其他可用的<code class="fe mg mh mi mj b">bb </code>文件旁边会有帮助)。接下来，如果项目之前已经构建过，您可能需要使用命令<code class="fe mg mh mi mj b">bitbake -c cleanall github.com-golang-example</code>删除旧的工件。然后运行命令<code class="fe mg mh mi mj b">bitbake github.com-golang-example</code>开始主要构建。这将自动构建<code class="fe mg mh mi mj b">golang-x </code>库以及Go编译所需的所有其他工具。</p><p id="7068" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在编译过程中，Yocto将尝试编译代码，然后打包进行部署。编译器标志由配方抽象，以及什么二进制文件放入什么包中。通常包类型是RPM，但也可以是其他格式。在成功的标准构建之后，您应该能够在<code class="fe mg mh mi mj b">&lt;YOCTO-DIR&gt;/tmp/deploy/rpm </code>目录中找到包含配方名称<code class="fe mg mh mi mj b">github.com-golang-example </code>的rpm。名称以<code class="fe mg mh mi mj b">github.com-golang-example-1.0-r0 </code>开头的RPM包含主要应用程序，可以使用<code class="fe mg mh mi mj b">dnf</code>或<code class="fe mg mh mi mj b">rpm</code>安装到您的目标上。</p><pre class="km kn ko kp gt mw mj mx my aw mz bi"><span id="7da0" class="mk ld iq mj b gy na nb l nc nd">Error:<br/> Problem: conflicting requests<br/>  - nothing provides go-runtime &gt;= 1.9.4 needed by github.com-golang-example-1.0-r0.cortexa7hf_neon</span></pre><p id="0b60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你试图安装这个RPM时，你可能会得到上面的错误。原因是Go应用程序的默认bitbake编译器配置在<code class="fe mg mh mi mj b">shared</code>模式下生成二进制文件，并将它们链接到<code class="fe mg mh mi mj b">go-runtime </code>库。你可以在这里阅读更多关于共享构建模式<a class="ae lb" href="http://blog.ralch.com/tutorial/golang-sharing-libraries/" rel="noopener ugc nofollow" target="_blank">的信息。这可能是为了减少嵌入式目标的二进制大小，以便许多Go应用程序都可以共享运行时。<code class="fe mg mh mi mj b">go-runtime-1.9.4</code> RPM应该在您找到主应用程序RPM的同一个文件夹中，并且可以在没有任何其他依赖的情况下安装。在安装了<code class="fe mg mh mi mj b">go-runtime</code>包之后，你应该能够正确无误地安装主RPM，并且所有生成的二进制文件都将被放置在<code class="fe mg mh mi mj b">/usr/bin</code>中。</a></p><h1 id="a93f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">其他生成的rpm</h1><p id="5b5b" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">除了包含已编译的Go应用程序的RPM之外，还有四个默认生成的RPM。我将简要回顾一下这些rpm的用途，以及它们在我们的示例项目中包含的内容。</p><h2 id="f025" class="mk ld iq bd le ml mm dn li mn mo dp lm jy mp mq lq kc mr ms lu kg mt mu ly mv bi translated">pTest RPM— <code class="fe mg mh mi mj b">github.com-golang-example-ptest-1.0-r0</code></h2><p id="7425" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">缺省情况下，Go bitbake方法创建一个rpm，其中填充了与一个包相关联的已编译Go测试。如果你安装了这个rpm，你可以通过进入<code class="fe mg mh mi mj b">/usr/lib</code>中的相应目录并运行<code class="fe mg mh mi mj b">run-ptest</code>来运行所有的测试。下面是正在运行的ptest的一个示例:</p><pre class="km kn ko kp gt mw mj mx my aw mz bi"><span id="161c" class="mk ld iq mj b gy na nb l nc nd">:~# /usr/lib/github.com-golang-example/ptest/run-ptest<br/>=== RUN   TestIsTagged<br/>--- PASS: TestIsTagged (0.02s)<br/>=== RUN   TestIntegration<br/>--- PASS: TestIntegration (0.04s)<br/>PASS<br/>=== RUN   TestReverse<br/>--- PASS: TestReverse (0.00s)<br/>PASS<br/>PASS: github.com-golang-example</span></pre><h2 id="cbde" class="mk ld iq bd le ml mm dn li mn mo dp lm jy mp mq lq kc mr ms lu kg mt mu ly mv bi translated">开发速度— <code class="fe mg mh mi mj b">github.com-golang-example-dev-1.0-r0</code></h2><p id="be61" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">静态开发RPM包含所有用于开发的源文件，并将它们安装到一个<code class="fe mg mh mi mj b">/usr/lib/go</code>中。这可以作为控制源的另一种方法。在Go示例项目中，静态开发RPM将安装:</p><pre class="km kn ko kp gt mw mj mx my aw mz bi"><span id="42a3" class="mk ld iq mj b gy na nb l nc nd">/usr/lib/go/src/github.com/golang/example/LICENSE<br/>/usr/lib/go/src/github.com/golang/example/README.md<br/>/usr/lib/go/src/github.com/golang/example/appengine-hello<br/>/usr/lib/go/src/github.com/golang/example/appengine-hello/README.md<br/>/usr/lib/go/src/github.com/golang/example/appengine-hello/app.go<br/>/usr/lib/go/src/github.com/golang/example/appengine-hello/app.yaml<br/>/usr/lib/go/src/github.com/golang/example/appengine-hello/static<br/>...<br/>...<br/>...<br/>/usr/lib/go/src/github.com/golang/example/stringutil/reverse_test.go<br/>/usr/lib/go/src/github.com/golang/example/template<br/>/usr/lib/go/src/github.com/golang/example/template/image.tmpl<br/>/usr/lib/go/src/github.com/golang/example/template/index.tmpl<br/>/usr/lib/go/src/github.com/golang/example/template/main.go</span></pre><h2 id="918c" class="mk ld iq bd le ml mm dn li mn mo dp lm jy mp mq lq kc mr ms lu kg mt mu ly mv bi translated">dbg RPM — <code class="fe mg mh mi mj b">github.com-golang-example-dbg-1.0-r0</code></h2><p id="d1cf" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">DBG包包含生成的应用程序和测试的调试符号。调试符号可由<code class="fe mg mh mi mj b">gdb</code>至<a class="ae lb" href="https://golang.org/doc/gdb" rel="noopener ugc nofollow" target="_blank">主动调试Go代码</a>使用。对于Go示例项目，dbg RPM将安装:</p><pre class="km kn ko kp gt mw mj mx my aw mz bi"><span id="eda2" class="mk ld iq mj b gy na nb l nc nd">/usr/bin/.debug/defsuses<br/>/usr/bin/.debug/doc<br/>/usr/bin/.debug/gotypes<br/>/usr/bin/.debug/hello<br/>/usr/bin/.debug/hugeparam<br/>/usr/bin/.debug/implements<br/>/usr/bin/.debug/lookup<br/>/usr/bin/.debug/nilfunc<br/>/usr/bin/.debug/outyet<br/>/usr/bin/.debug/pkginfo<br/>/usr/bin/.debug/skeleton<br/>/usr/bin/.debug/template<br/>/usr/bin/.debug/typeandvalue<br/>/usr/lib/github.com-golang-example/ptest/github.com/golang/example/outyet/.debug/outyet.test<br/>/usr/lib/github.com-golang-example/ptest/github.com/golang/example/stringutil/.debug/stringutil.test<br/>/usr/src/debug/github.com-golang-example/1.0-r0/build/src/github.com/golang/example/outyet/main.go<br/>/usr/src/debug/github.com-golang-example/1.0-r0/build/src/github.com/golang/example/outyet/main_test.go<br/>/usr/src/debug/github.com-golang-example/1.0-r0/build/src/github.com/golang/example/stringutil/reverse.go<br/>/usr/src/debug/github.com-golang-example/1.0-r0/build/src/github.com/golang/example/stringutil/reverse_test.go</span></pre><h2 id="e5cb" class="mk ld iq bd le ml mm dn li mn mo dp lm jy mp mq lq kc mr ms lu kg mt mu ly mv bi translated">静态设备转速— <code class="fe mg mh mi mj b">github.com-golang-example-staticdev-1.0-r0</code></h2><p id="fed2" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">staticdev RPM包含包中使用的编译好的Go库。这些可以用来加速编译。对于Go示例项目，这个RPM将安装:</p><pre class="km kn ko kp gt mw mj mx my aw mz bi"><span id="28d7" class="mk ld iq mj b gy na nb l nc nd">/usr/lib/go/pkg/linux_arm_dynlink/github.com/golang/example/appengine-hello.a<br/>/usr/lib/go/pkg/linux_arm_dynlink/github.com/golang/example/stringutil.a</span></pre><h1 id="8020" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">修改基本配方</h1><h2 id="2634" class="mk ld iq bd le ml mm dn li mn mo dp lm jy mp mq lq kc mr ms lu kg mt mu ly mv bi translated">生成单个非链接的可执行文件</h2><p id="575a" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">缺省情况下，Go bitbake配方会生成链接到Go运行时库的应用程序。这可能会使部署和依赖性管理变得复杂。出于这些和其他原因，您可能希望让Yocto将Go应用程序构建为完全包含的应用程序的默认二进制类型。为此，只需将<code class="fe mg mh mi mj b">GO_LINKSHARED = ""</code>添加到食谱中。结果是主RPM将具有相同的名称，但是不需要安装<code class="fe mg mh mi mj b">go-runtime</code> rpm。</p><h2 id="d460" class="mk ld iq bd le ml mm dn li mn mo dp lm jy mp mq lq kc mr ms lu kg mt mu ly mv bi translated">范围构建</h2><p id="b43b" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">默认情况下，尝试在一个项目中构建所有可能的产品。这是通过在Go导入字符串的末尾向Go编译器发出<code class="fe mg mh mi mj b">...</code>参数来实现的。当您只想编译一个库而不是相关的命令时，这可能会很麻烦。为了防止这种情况，您可以通过改变配方中的<code class="fe mg mh mi mj b">GO_INSTALL</code>字段来确定构建的范围。例如，要将构建范围限定在顶层目录中的包，您可以在recipe中输入<code class="fe mg mh mi mj b">GO_INSTALL = "${GO_IMPORT}”</code>。</p><h2 id="3ddf" class="mk ld iq bd le ml mm dn li mn mo dp lm jy mp mq lq kc mr ms lu kg mt mu ly mv bi translated">禁用测试</h2><p id="fcb8" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">有时，测试需要额外的包，或者还没有准备好在目标环境中运行，开发人员希望不要构建它们。要告诉Yocto不要构建测试，您可以将<code class="fe mg mh mi mj b">PTEST_ENABLED="0"</code>添加到配方中。这将防止产生<code class="fe mg mh mi mj b">ptest</code> rpm。</p><h1 id="99ce" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">高级食谱</h1><h2 id="1b57" class="mk ld iq bd le ml mm dn li mn mo dp lm jy mp mq lq kc mr ms lu kg mt mu ly mv bi translated">多包食谱— Golang.org-X库</h2><p id="c059" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">有些Go包与其他包耦合得如此紧密，以至于最好将它们组合到一个Yocto菜谱中。最常见的例子是<code class="fe mg mh mi mj b">golang-x </code>库。它们是许多围棋项目所需要的，也是相互依赖的。以下是多包bitbake配方，将导入所有<code class="fe mg mh mi mj b">golang-x</code>配方，以确保满足依赖性。</p><pre class="km kn ko kp gt mw mj mx my aw mz bi"><span id="e5b1" class="mk ld iq mj b gy na nb l nc nd">//golang.org-x.bb<br/>DESCRIPTION = "Go X libraries"</span><span id="567c" class="mk ld iq mj b gy ne nb l nc nd">SRC_URI = "\<br/>         git://github.com/golang/net.git;protocol=https;name=net;destsuffix=${PN}-${PV}/src/golang.org/x/net \<br/>         git://github.com/golang/text.git;protocol=https;name=text;destsuffix=${PN}-${PV}/src/golang.org/x/text \<br/>         git://github.com/golang/tools.git;protocol=https;name=tools;destsuffix=${PN}-${PV}/src/golang.org/x/tools \<br/>         git://github.com/golang/crypto.git;protocol=https;name=crypto;destsuffix=${PN}-${PV}/src/golang.org/x/crypto \<br/>         git://github.com/golang/sys.git;protocol=https;name=sys;destsuffix=${PN}-${PV}/src/golang.org/x/sys \<br/>         "<br/> SRCREV_text = "${AUTOREV}"<br/> SRCREV_net = "${AUTOREV}"<br/> SRCREV_crypto = "${AUTOREV}"<br/> SRCREV_tools = "${AUTOREV}"<br/> SRCREV_sys = "${AUTOREV}"</span><span id="5157" class="mk ld iq mj b gy ne nb l nc nd">LICENSE = "MIT"<br/> LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4f302"</span><span id="c9a5" class="mk ld iq mj b gy ne nb l nc nd">inherit go<br/> GO_IMPORT = "golang.org/x"</span></pre><p id="ba59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个食谱在几个方面不同于基本的围棋食谱。首先，所有给定的<code class="fe mg mh mi mj b">SRC_URI </code>值都有两个额外的参数:<code class="fe mg mh mi mj b">name </code>和<code class="fe mg mh mi mj b">destsuffix</code>。<code class="fe mg mh mi mj b">name </code>参数用于将源标识为子包的一部分。<code class="fe mg mh mi mj b">destsuffix </code>参数是告诉Yocto手动将源文件放在哪里。这是必需的，因为每个包都有自己的<code class="fe mg mh mi mj b">GO_IMPORT</code>值，所以我们不能依赖默认行为。下一个区别是每个子包都有自己的<code class="fe mg mh mi mj b">SRCREV </code>字段。现在它们都被设置为从它们相应的库的头部拉出来，但是这可以用来单独地对它们进行版本控制。最后一个区别是引用的<code class="fe mg mh mi mj b">LICENSE </code>不在存储库中，而是内置在Yocto中。这并不是多包方法所独有的，只有在这种情况下才需要，因为库有一个非典型的许可(Go许可)。</p><h2 id="180e" class="mk ld iq bd le ml mm dn li mn mo dp lm jy mp mq lq kc mr ms lu kg mt mu ly mv bi translated">Cgo食谱— github.com-mattn-go-sqlite3</h2><blockquote class="nf ng nh"><p id="b1d2" class="jn jo ni jp b jq jr js jt ju jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj kk ij bi translated">交叉编译时，必须指定一个C交叉编译器供cgo使用。— cgo GoDoc</p></blockquote><p id="a6a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Cgo从两个方面使Yocto食谱变得复杂。第一种方式是，当交叉编译时，go编译器必须被明确告知cgo正在被使用，而不像传统的Go编译那样只是指出这一点。要在Yocto中做到这一点，必须将<code class="fe mg mh mi mj b">CGO_ENABLED = "1"</code>添加到配方中。第二种方式是必须考虑C的依赖性。这包括库，也可能包括链接器标志，具体取决于代码中的cgo指令。库通常是通过<code class="fe mg mh mi mj b">DEPENDS</code>将它们的配方作为依赖项添加进来的。链接器标志由<code class="fe mg mh mi mj b">LDFLAGS</code>处理，值就像gcc参数一样给出(例如:pthread库的<code class="fe mg mh mi mj b">LDFALGS = "-lpthread”</code>)。Yocto还设置了许多其他标志，总体来说，Yocto极大地简化了cgo交叉编译。</p><pre class="km kn ko kp gt mw mj mx my aw mz bi"><span id="a9f9" class="mk ld iq mj b gy na nb l nc nd">//github.com-mattn-go-sqlite3.bb<br/>DESCRIPTION = "The mattn SQLite3 Go Library"<br/>GO_IMPORT = "github.com/mattn/go-sqlite3"</span><span id="8a09" class="mk ld iq mj b gy ne nb l nc nd">inherit go</span><span id="7b6a" class="mk ld iq mj b gy ne nb l nc nd">DEPENDS="sqlite3"</span><span id="867b" class="mk ld iq mj b gy ne nb l nc nd">SRC_URI = "git://github.com/mattn/go-sqlite3.git;protocol=https;"<br/>SRCREV = "${AUTOREV}"<br/>LICENSE = "MIT"<br/>LIC_FILES_CHKSUM = "file://${S}/src/${GO_IMPORT}/LICENSE;md5=2b7590a6661bc1940f50329c495898c6"</span><span id="7b96" class="mk ld iq mj b gy ne nb l nc nd">CGO_ENABLED = "1"</span></pre><h1 id="5690" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">讨论</h1><p id="bc86" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">Yocto已经真正开始在围棋开发方面取得进展。在Rocko版本之前，有几个不同版本的Go配方库正在使用，所有这些都需要在使用它们的Go配方中设置不同的选项。这意味着很难为每个人都可以使用的依赖关系创建配方。在Rocko和更高版本中，Yocto已经标准化了Go菜谱库，并极大地扩展了它们的功能。总的来说，它使得编译过程变得非常容易。</p><p id="6ac0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Yocto和Go目前的一个不足之处是依赖性管理。没有一个包含Go软件包配方的中央存储库，尽管现在使用Go标准配方库应该更容易创建。理想情况下，一旦Go开始用<code class="fe mg mh mi mj b">vgo</code>标准化版本控制，Yocto的配方就可以通过编程生成。同时，食谱写作并不困难，所以即使一个项目需要10个包，你通常可以在一个小时内写完。虽然有点烦人，但Yocto提供的功能远不止这些。</p></div></div>    
</body>
</html>