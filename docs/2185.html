<html>
<head>
<title>Strangling a Monolith application with Micro Frontends using Server Side Includes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用服务器端的微前端扼杀一个整体应用程序包括</h1>
<blockquote>原文：<a href="https://itnext.io/strangling-a-monolith-to-micro-frontends-decoupling-presentation-layer-18a33ddf591b?source=collection_archive---------3-----------------------#2019-04-13">https://itnext.io/strangling-a-monolith-to-micro-frontends-decoupling-presentation-layer-18a33ddf591b?source=collection_archive---------3-----------------------#2019-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4ce542ca505ceef16ed2819bae4d3f46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NWSjaVeijf2d_cQ0.jpg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">独石湖——斯纳巴兹</figcaption></figure><p id="dbaa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">敏捷思维促进了过程、产品和业务的迭代。如今，e <a class="ae la" href="https://www.thoughtworks.com/books/building-evolutionary-architectures" rel="noopener ugc nofollow" target="_blank">进化架构</a>随着时间的推移，正在实现架构的增量变化。</p><p id="ac90" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">迁移大型整体构件的最常见方法有:</p><ul class=""><li id="2a92" class="lb lc iq ke b kf kg kj kk kn ld kr le kv lf kz lg lh li lj bi translated"><strong class="ke ir">大爆炸:</strong>包括从零开始迁移遗留系统。风险很高，因为未记录的功能可能会丢失，并且价值交付会下降，因为即将到来的功能需要同时在两个系统上实现，或者根本不实现。</li><li id="9ce0" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><a class="ae la" href="https://www.martinfowler.com/bliki/StranglerApplication.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">扼杀者</strong> </a> <strong class="ke ir"> : </strong>包括稳步地将遗留系统的责任转移到新的系统或服务，我喜欢称之为<em class="lp">遗留代码即服务</em>。这种方法需要更多的时间来扼杀这个庞然大物，但能让你不断地传递价值。</li></ul><h1 id="e81d" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">扼杀整体应用程序的旅程</h1><p id="d891" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">如今，很容易选择诸如<a class="ae la" href="https://github.com/nuxt/nuxt.js" rel="noopener ugc nofollow" target="_blank"> Nuxt.js </a>和<a class="ae la" href="https://github.com/zeit/next.js/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>之类的框架来使用React和Vue.js通用地呈现页面，这也被称为同构应用，但是对于使用自己的模板引擎的框架来说很难，对于诸如Ruby on Rails、Laravel或Flask之类的非javascript框架来说更难。</p><h1 id="59ad" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">Airbnb + Hypernova案例研究</h1><p id="0edd" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">Airbnb一直在稳步迁移他们基于Ruby on Rails构建的系统，将前端代码迁移到一个一致的架构，使用<a class="ae la" href="https://github.com/airbnb/hypernova" rel="noopener ugc nofollow" target="_blank"> Hypernova </a>作为服务器端渲染服务。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/3925627c186a358894caef2645a31687.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XvXtfgr17hqhuB5kcMVqlw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Airbnb使用Hypernova作为SSR服务</figcaption></figure><ul class=""><li id="6f87" class="lb lc iq ke b kf kg kj kk kn ld kr le kv lf kz lg lh li lj bi translated">用户请求Ruby on Rails服务器上的一个页面。</li><li id="b65a" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated">服务器收集必要的数据来呈现页面。</li><li id="31de" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated">ERB模板使用自定义呈现器向Hypernova服务器请求组件。</li><li id="3711" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated">Hypernova服务器使用React呈现所有请求的组件，并将它们发送回Ruby on Rails服务器。</li><li id="7f11" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated">组件由ERB注入到生成的页面中。</li><li id="a5e7" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated">Ruby on Rails将HTML标记和javascript文件发送回浏览器。</li><li id="85a5" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated">在浏览器上，JavaScript用于逐步增强应用程序并使其动态化。</li></ul><p id="f6c7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用这种架构，Airbnb可以重用他们的React组件进行服务器端和客户端渲染，并将他们构建在Ruby on Rails上的Monolith的呈现解耦。</p><p id="8a6b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里是Airbnb工程团队写的一篇详细的<a class="ae la" href="https://medium.com/airbnb-engineering/operationalizing-node-js-for-server-side-rendering-c5ba718acfc9" rel="noopener">文章</a>。</p><h1 id="fed1" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">在拉弗尔使用超新星</h1><p id="466e" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">Laravel 是一个PHP web框架，用于构建现代web应用程序，类似于其他框架，如ASP.net MVC、Ruby on Rails和AdonisJS。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/8728220ce6c0f7bd884a30d3a6cf630c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QYHy7sgAp_oappcQm3oXhA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Laravel应用程序图</figcaption></figure><p id="5624" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Laravel<strong class="ke ir">T5【使用<a class="ae la" href="https://laravel.com/docs/5.8/blade" rel="noopener ugc nofollow" target="_blank"> Blade </a>作为服务器端渲染的模板引擎，<a class="ae la" href="https://laravel-mix.com/" rel="noopener ugc nofollow" target="_blank"> Laravel Mix </a>编译Javascript、CSS、<a class="ae la" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue.js </a>组件等资产用于客户端渲染。</strong></p><h2 id="f2aa" class="mz lr iq bd ls na nb dn lw nc nd dp ma kn ne nf me kr ng nh mi kv ni nj mm nk bi translated">在Hypernova上支持Vue.js</h2><p id="254c" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">Airbnb Hypernova不支持Vue.js开箱即用，但它使我们能够开发自己的Hypernova绑定，所以我创建了<a class="ae la" href="https://github.com/ara-framework/hypernova-vue" rel="noopener ugc nofollow" target="_blank"> hypernova-vue </a>。</p><p id="3d85" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我写了这篇<a class="ae la" href="https://medium.com/js-dojo/using-vue-js-with-hypernova-server-ce792dcf1ac7" rel="noopener">文章</a>关于如何使用Vue.js和Hypernova，你也可以使用这个<a class="ae la" href="https://github.com/ara-framework/create-hypernova-vue" rel="noopener ugc nofollow" target="_blank">生成器</a>。</p><h2 id="d175" class="mz lr iq bd ls na nb dn lw nc nd dp ma kn ne nf me kr ng nh mi kv ni nj mm nk bi translated">第一种方法— Hypernova客户端</h2><p id="a39e" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">一旦hypernova服务器被配置为使用Vue.js，我就在Blade中创建了一个自定义指令，以便将Hypernova组件放置在Blade视图中。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/128a78c9230fd25e420c2032f849ba0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S2z2POcQPj93hPHOPW3Xmg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">AppServiceProvider.php的超新星刀锋指令</figcaption></figure><p id="bdec" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Hypernova指令使用一个facade将请求的组件推送到<a class="ae la" href="https://github.com/wayfair/hypernova-php" rel="noopener ugc nofollow" target="_blank"> hypernova-php </a>客户端，并在模板视图中添加一个占位符，这是稍后放置呈现的组件所必需的。</p><p id="0dda" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">hypernova客户端是一个单独的客户端，所以我们可以持久化所请求的组件，以便稍后从hypernova服务器获取它们。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/7b79b658ca444dbc0bc3b56946b99155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uNiuVG_kSAmhJEYu5SbKGg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">超级新星级-推工作</figcaption></figure><p id="b62f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，Blade基于模板视图呈现页面，Laravel中间件使用Facade修改原始响应。幕后的门面使用Hypernova客户端向Hypernova服务器请求组件，并且仅在一个步骤中用呈现的组件替换占位符。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/db216b72f8eacd18392f51184b916997.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DviqaLnCp4ZQ2eJGDDU5zQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Hypernova中间件</figcaption></figure><p id="ea26" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我采用了laravel-hypernova 包的一些想法，但是我没有使用它，因为这个库与Laravel 5.8不兼容，而且我在处理hypernova服务器传入的错误时遇到了问题。</p><h2 id="c253" class="mz lr iq bd ls na nb dn lw nc nd dp ma kn ne nf me kr ng nh mi kv ni nj mm nk bi translated">使用超新星指令</h2><p id="3b97" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">Laravel控制器只需要使用<code class="fe no np nq nr b">view</code>函数将视图名称和数据传递给Blade。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/af6ff9d17c92c9bf2f0ac8bb2be2ef5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T-gezAxtOVXAlseflPcG3A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">返回路由处理程序中的视图</figcaption></figure><p id="9427" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">默认布局包含HTML文档，并使用hypernova指令定义了一个<em class="lp">导航条</em>组件。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/ca1b7fe4c864d435386ec3e7c139f27d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vu6MKhmZWtvevmXyDGkVGw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用刀片的默认布局</figcaption></figure><p id="bdfa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="lp"> welcome </em>视图使用默认布局，并使用hypernova指令定义了一个<em class="lp"> Home </em>组件。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/fc48e70bab456bdf0fac477256a2bf33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*57yntK3ubKXJdnZt2ibtTA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">欢迎查看</figcaption></figure><p id="0600" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">HTML呈现后，结果如下:</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/8046adb1e9aa65a94462e9b726332a9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ehyk4yTV-CsVB8ikJ1QMLQ.png"/></div></div></figure><p id="a211" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">页面使用相同的Vue.js组件在服务器端呈现，在客户端动态呈现，这对于SEO来说非常酷。</p><p id="1c12" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我使用Hypernova服务器使Laravel能够通用渲染Vue.js组件，但它仍然与一些实现细节有关。Laravel需要使用Hypernova客户端直接与Hypernova服务器交互，因此该架构需要为每种语言或web框架开发一个Hypernova客户端。</p><h2 id="f411" class="mz lr iq bd ls na nb dn lw nc nd dp ma kn ne nf me kr ng nh mi kv ni nj mm nk bi translated">超新星代理方法</h2><p id="67d5" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">在深入分析该架构后，我发现了一个与微前端原理紧密相关的通用通信接口。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/526c2558bd554cba901d4b1669048734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*at3IS_kF3DpWD1gJfnEyTw.png"/></div></div></figure><p id="c3fc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Blade生成的HTML包含占位符，其中包含向hypernova服务器生成批处理请求所需的所有信息，即使Hypernova服务器无法呈现视图，客户端脚本也会在浏览器上呈现组件，使前端具有弹性。</p><p id="cc3e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">基于Laravel中间件方法，我决定在客户端和Laravel应用程序之间放置一个<a class="ae la" href="https://www.cloudflare.com/learning/cdn/glossary/reverse-proxy/" rel="noopener ugc nofollow" target="_blank">反向代理</a>，以便<a class="ae la" href="https://kb.iu.edu/d/bfsa" rel="noopener ugc nofollow" target="_blank">服务器端包含来自Hypernova服务器的</a> (SSI)视图。</p><p id="84c8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我尝试使用<a class="ae la" href="https://openresty.org/en/" rel="noopener ugc nofollow" target="_blank"> OpenResty </a>对<a class="ae la" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> Nginx </a>进行扩展，但是我发现使用Lua的HTML解析器和HTTP客户端存在一些实现限制。</p><p id="0b98" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，在研究了很多之后，我决定选择<a class="ae la" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>来开发它。Go有一个现成的HTTP客户端和反向代理服务器模块，还有一个非常酷的<a class="ae la" href="https://github.com/PuerkitoBio/goquery" rel="noopener ugc nofollow" target="_blank">库</a>，可以使用查询选择器解析和改变DOM。</p><h2 id="428a" class="mz lr iq bd ls na nb dn lw nc nd dp ma kn ne nf me kr ng nh mi kv ni nj mm nk bi translated">Hypernova代理如何工作</h2><p id="9f3e" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">使用Hypernova代理Laravel只需要使用Hypernova指令，以便呈现Hypernova代理用于服务器端的占位符，包括页面中的Hypernova视图，就像我们之前使用Laravel中间件一样，但是现在我们可以重用Hypernova代理，以便使用其他web框架通用地呈现视图。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/44485f8366dffe3052a9f4b7ef60137f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DBqL7UW29ym-dJV_l92IXw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">超级新星代理</figcaption></figure><ul class=""><li id="19db" class="lb lc iq ke b kf kg kj kk kn ld kr le kv lf kz lg lh li lj bi translated">用户请求Hypernova代理上的页面</li><li id="67cc" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated">Hypernova代理将请求传递给Laravel服务器。</li><li id="eb5f" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated">Laravel服务器收集必要的数据来呈现页面。</li><li id="9485" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated">Blade使用模板vue和<a class="ae la" href="https://github.com/marconi1992/hypernova-blade-directive" rel="noopener ugc nofollow" target="_blank"> hypernova指令</a>呈现页面(div标签包含组件的唯一id和名称，脚本标签包含组件的数据)</li></ul><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/61c6c16236ab2eb11f889623a45f3638.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_5Zfsr-gJiU3ySP0c7hqVQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Laravel服务器中Blad呈现的HTML页面</figcaption></figure><ul class=""><li id="5e33" class="lb lc iq ke b kf kg kj kk kn ld kr le kv lf kz lg lh li lj bi translated">Laravel服务器将HTML页面发送回Hypernova代理。</li><li id="0a9d" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated">当响应<code class="fe no np nq nr b">content-type</code>为<code class="fe no np nq nr b">text/html</code>时，Hypernova代理解析HTML以便为Hypernova服务器创建JSON请求，否则，它发回响应而不修改它。</li><li id="6c21" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated">Hypernova代理向Hypernova服务器请求视图。</li></ul><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/2710c6dea58af735dde33ea9892972d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QNCMT9bBtjSCXWmyFSg_gA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Hypernova服务器的有效负载请求</figcaption></figure><ul class=""><li id="2f74" class="lb lc iq ke b kf kg kj kk kn ld kr le kv lf kz lg lh li lj bi translated">Hypernova服务器使用Vue.js组件呈现所有请求的视图，并将它们发送回Hypernova代理。</li></ul><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/805f92dbe718e98354b1a61f3df1f859.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PYUKn70EbaqdZKEk2AY_Yw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Hypernova服务器响应</figcaption></figure><ul class=""><li id="5f0f" class="lb lc iq ke b kf kg kj kk kn ld kr le kv lf kz lg lh li lj bi translated">Hypernova代理用成功结果的HTML替换占位符，并保留错误结果的占位符，以便客户端脚本在浏览器中呈现它们。</li><li id="445a" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated">Hypernova代理将修改后的响应发送回用户。</li><li id="bf4c" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated">在浏览器上，JavaScript用于逐步增强应用程序并使其动态化。</li></ul><h1 id="cd61" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">结论</h1><p id="ee0d" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">这种架构使得从monolith到新服务的域分发变得容易，我们也可以开发新的服务，例如使用Express.js和Mustache.js partials来生成Hypernova代理请求Hypernova服务器的视图所需的预期标记。</p><h2 id="89db" class="mz lr iq bd ls na nb dn lw nc nd dp ma kn ne nf me kr ng nh mi kv ni nj mm nk bi translated">资源</h2><div class="ob oc gp gr od oe"><a href="https://github.com/marconi1992/strangling-monolith-to-microfrontends" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">Marconi 1992/扼制-整体到微前端</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">演示扼杀整体到微前端。促成马可尼1992/扼杀-整体到微前端…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">github.com</p></div></div><div class="on l"><div class="oo l op oq or on os jw oe"/></div></div></a></div><ul class=""><li id="31fe" class="lb lc iq ke b kf kg kj kk kn ld kr le kv lf kz lg lh li lj bi translated"><a class="ae la" href="https://www.thoughtworks.com/books/building-evolutionary-architectures" rel="noopener ugc nofollow" target="_blank">建造进化建筑</a></li><li id="037f" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><a class="ae la" href="https://medium.com/airbnb-engineering/operationalizing-node-js-for-server-side-rendering-c5ba718acfc9" rel="noopener">为服务器端渲染操作Node.js】</a></li><li id="280f" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><a class="ae la" href="https://www.martinfowler.com/bliki/StranglerApplication.html" rel="noopener ugc nofollow" target="_blank">扼杀者应用</a></li><li id="8af3" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><a class="ae la" href="https://medium.com/js-dojo/using-vue-js-with-hypernova-server-ce792dcf1ac7" rel="noopener">在Hypernova服务器上使用vue . js</a></li><li id="d737" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><a class="ae la" href="https://medium.com/js-dojo/micro-frontends-using-vue-js-react-js-and-hypernova-af606a774602" rel="noopener">使用Vue.js、React.js和Hypernova的微前端</a></li></ul><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/2deac8afefd57c32e8eeb373733bb7f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:4/format:webp/1*aC4-hlpkc-MQq77rdtDHZg.png"/></div></figure></div></div>    
</body>
</html>