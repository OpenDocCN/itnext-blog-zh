<html>
<head>
<title>Java Memory Model fundamentals or How to build stormtrooper clones army in a correct way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java内存模型基础或者如何以正确的方式建立克隆人冲锋队</h1>
<blockquote>原文：<a href="https://itnext.io/java-memory-model-fundamentals-or-how-to-build-stormtrooper-clones-army-in-a-correct-way-f20403504294?source=collection_archive---------7-----------------------#2019-05-20">https://itnext.io/java-memory-model-fundamentals-or-how-to-build-stormtrooper-clones-army-in-a-correct-way-f20403504294?source=collection_archive---------7-----------------------#2019-05-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7ff1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你好。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/f3fe812e9e088bfd1218045b3259a4c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XTGmbWV13ZBE-sMX"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/@andreuuuw?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安德鲁·伍尔夫</a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6ce4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在以前的帖子中，我们讨论了几个Java概念，这些概念可能会在Java面试中被问到。这篇文章将通过讨论Java内存模型(<code class="fe lc ld le lf b">JMM</code>)来继续这个话题。</p><p id="f409" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，我理解你的感受，如果这个话题听起来很无聊，甚至对你来说不那么重要。但是在我看来，在不知道它是如何工作的情况下使用任何工具都是危险的。我们，工程师，对我们为不同的服务和企业所制造的产品质量负责。如果我们不知道我们使用的工具，它可能会给我们带来一些意想不到的问题，如果不知道底层的原则，这些问题将很难或不可能被发现。</p><p id="1e3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我用下面的例子来证明:想象一下，在一个阳光明媚的日子里，达斯·维德来到帝国软件工程师办公室，让他制作工具，用冲锋队的原型和与叛军作战所需的士兵数量，为他制造出冲锋队克隆人军队。工程师回答说这是小菜一碟，几分钟就能完成。所以，他开始设计冲锋队模型:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="c62d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后创建一个<code class="fe lc ld le lf b">CloneBuilderService</code>:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="c833" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于所提供的评估，他很着急，没有空间来编写测试(请不要这样做)，所以他将这个<code class="fe lc ld le lf b">CloneBuilderService</code>提供给达斯·维达。嗯，这天晚些时候黑魔王收到一份报告，说有人在最近的星球上发现了叛军小队。只有六个叛军，所以用100个冲锋队消灭敌人绰绰有余。</p><p id="ed8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我来介绍一下反叛者模型:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="d316" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">叛军和冲锋队之间的战斗是一步一步的战斗，冲锋队攻击第一个活着的叛军，然后叛军攻击第一个活着的冲锋队，之后，进行检查以了解战斗是否结束。活下来的队伍就是赢家。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="f850" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我知道，检查算法可以写得更有效，但我的目标是通过降低性能来增加代码的可读性。</p><p id="e841" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看起来，数学上的反叛者没有机会。我同意这一点！但是正如我在本文开头提到的，不了解底层Java概念可能会导致巨大的问题。</p><p id="9c69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看，运行<code class="fe lc ld le lf b">BattleMain</code>会有什么结果:</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="6427" class="lm ln iq lf b gy lo lp l lq lr">The squad of clones is built. The size is 100</span><span id="23ef" class="lm ln iq lf b gy ls lp l lq lr">Rebel [name='Gregar Typho', weapon='Gun'] is killed <br/>StormTrooper [name='Stormtrooper Prototype', weapon='Blaster'] is killed</span><span id="a3b9" class="lm ln iq lf b gy ls lp l lq lr">Rebels win the battle!</span></pre><p id="1a55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">怎么会这样如果你看到了问题的原因，并且理解了它的本质——干得好，伙计们！如果没有，也没关系，因为我们将在不久的将来回到这个话题。</p><p id="9aed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望，我已经解释了研究这些概念的原因，比如<code class="fe lc ld le lf b">JMM</code>。所以，让我们开始旅程吧！</p><p id="27f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lc ld le lf b">JMM</code>分成两个主要区域:<code class="fe lc ld le lf b">Stack</code>和<code class="fe lc ld le lf b">Heap</code>。为了简单起见，让我们想象一下，它们都只是负责存储不同数据的数据结构。</p><h2 id="b056" class="lm ln iq bd lt lu lv dn lw lx ly dp lz jy ma mb mc kc md me mf kg mg mh mi mj bi translated">堆栈</h2><p id="7242" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated"><code class="fe lc ld le lf b">Stack</code>内存是底层的堆栈数据结构。<br/>如果你不知道这样的数据结构，没问题，用现实世界的例子很容易理解。想象一下，你有5本书(<code class="fe lc ld le lf b">A</code>、<code class="fe lc ld le lf b">B</code>、<code class="fe lc ld le lf b">C</code>、<code class="fe lc ld le lf b">D</code>、<code class="fe lc ld le lf b">E</code>)。你拿起书<code class="fe lc ld le lf b">A</code>并把它放在流上，然后你拿起书<code class="fe lc ld le lf b">B</code>并把它放在书<code class="fe lc ld le lf b">A</code>上，以此类推，直到没有书剩下。现在你有一列书，其中书<code class="fe lc ld le lf b">A</code>是最低的，书<code class="fe lc ld le lf b">E</code>是最高的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mp"><img src="../Images/f27abb13b7a2039a9731d89061f44850.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XZzW-_7kjQ-iPLjW"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">摩根·哈珀·尼科尔斯在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="01ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你需要拿书<code class="fe lc ld le lf b">A</code>，你必须先拿书<code class="fe lc ld le lf b">E</code>，然后再拿<code class="fe lc ld le lf b">D</code>-&gt;-<code class="fe lc ld le lf b">C</code>-&gt;-<code class="fe lc ld le lf b">B</code>，然后你才能拿<code class="fe lc ld le lf b">A</code>本身。在计算机科学中，它被称为<code class="fe lc ld le lf b">Last-In-First-Out</code> ( <a class="ae lb" href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank"> LIFO </a>)，因为最后一个被放入数据结构的对象将是第一个从中取出数据的对象。</p><p id="b5bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望，这是明确的，我们可以回到Java。</p><p id="b41b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lc ld le lf b">Stack</code>存储器用于存储:</p><ol class=""><li id="83db" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated"><em class="mz">原始类型(变量名及其值):</em></li></ol><p id="7928" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们想象一下，我们有以下代码示例:</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="46f8" class="lm ln iq lf b gy lo lp l lq lr">int a = 1;           // line 1<br/>boolean b = true;    // line 2</span></pre><p id="1ffd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所料，在执行第1行之后，<code class="fe lc ld le lf b">Stack</code>看起来如下:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi na"><img src="../Images/62e9e515b38789a5b09903be3c327221.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/1*0P5OT2ijlglug1nSda7G_Q.png"/></div></figure><p id="f09d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第二行之后:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi na"><img src="../Images/3e08167e4b7214d6baf158812386cfda.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/1*rpFocicJhGyb30Wi3vmo2w.png"/></div></figure><p id="7f91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果没有更多的代码，<code class="fe lc ld le lf b">Stack</code>将通过逐个删除每个元素来释放:<code class="fe lc ld le lf b">b</code>将首先被删除，<code class="fe lc ld le lf b">a</code>—<code class="fe lc ld le lf b">b</code>之后:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi na"><img src="../Images/384de86ba71ad9aca9532b66dc3c762e.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/1*CZIpVE_Wrcda_drTcDFE9w.png"/></div></figure><p id="cf0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mz"> 2。对复杂数据类型(对象)的引用:</em></p><p id="f7af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它比基本类型部分稍微复杂一点。但是别担心，我们很快就会明白一切。</p><p id="439b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不介绍<code class="fe lc ld le lf b">Heap</code>就不可能解释这一部分。</p><h2 id="7200" class="lm ln iq bd lt lu lv dn lw lx ly dp lz jy ma mb mc kc md me mf kg mg mh mi mj bi translated">垃圾堆</h2><p id="dad4" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated"><code class="fe lc ld le lf b">Heap</code>用于存储可以在应用程序间共享的复杂对象的值。同样，为了简单起见，让我们假设它是某种数据结构，以无序的方式存储元素，但提供快速访问它们的机制。我建议使用这里的<code class="fe lc ld le lf b">HashMap</code>(在现实生活中，<code class="fe lc ld le lf b">Heap</code>的结构要复杂得多，但我们不打算潜得这么深)。</p><p id="e3b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你对<code class="fe lc ld le lf b">HashMap</code>不熟悉，我们来修复一下这个。<code class="fe lc ld le lf b">HashMap</code>是一种键值数据结构。这是什么意思？这意味着我们放入的每个元素都包含了<code class="fe lc ld le lf b">key</code>和<code class="fe lc ld le lf b">value</code>。<code class="fe lc ld le lf b">key</code>用于快速访问元素值。</p><p id="0b5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现实世界的例子是，当您访问一家银行时，员工要求您说出您的身份证号码(或护照号码——取决于国家),然后使用身份证号码(<code class="fe lc ld le lf b">key</code>)，员工获得您的帐户数据(<code class="fe lc ld le lf b">value</code>)以进行进一步的操作。</p><p id="a0a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">把<code class="fe lc ld le lf b">Heap</code>当成<code class="fe lc ld le lf b">HashMap</code>来讲，<code class="fe lc ld le lf b">key</code>是内存地址，<code class="fe lc ld le lf b">value</code>是对象值本身。例如，假设我们有以下代码示例:</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="cb47" class="lm ln iq lf b gy lo lp l lq lr">String greetings = "Valar Morgulis!";</span></pre><p id="97f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，我们已经创建了新的<code class="fe lc ld le lf b">String</code>对象。让我们想象一下，Java内存管理将这个对象放入内存地址<code class="fe lc ld le lf b">ABC123</code>。所以，<code class="fe lc ld le lf b">Heap</code>会有如下状态:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/d1aafb21a53fb1858bca1caacc354d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*GfzqkckxNJXr1Ii5Qva2rg.png"/></div></figure><p id="f126" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您可能看到的，在<code class="fe lc ld le lf b">Heap</code>中没有关于变量名的信息，但是对象值完全存储在那里。</p><p id="c624" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们回到<code class="fe lc ld le lf b">Stack</code>上来。如上所述，<code class="fe lc ld le lf b">Stack</code>存储对复杂数据类型(对象)的引用。</p><p id="b070" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们再看一下上一个代码样本，我们会发现只有一行代码，但是已经执行了三个动作。值为<code class="fe lc ld le lf b">Valar Morgulis!</code>的<code class="fe lc ld le lf b">String</code>对象已创建；<br/> 2。已创建名为<code class="fe lc ld le lf b">greeting</code>且类型为<code class="fe lc ld le lf b">String</code>的变量；<br/> 3。变量<code class="fe lc ld le lf b">greeting</code>现在指的是第一步中的物体。</p><p id="1c63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，堆栈和堆具有以下状态:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nc"><img src="../Images/3b8cea3308147083f00c7582f08cc062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*szPySZAfpmfKwbj61Cejwg.png"/></div></div></figure><p id="5be5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在应该很清楚了。</p><p id="328d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总的来说，这是<code class="fe lc ld le lf b">Stack</code>和<code class="fe lc ld le lf b">Heap</code>背后的主要概念，但是让我们用更复杂的例子更深入一点。</p><p id="67ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑到我们有以下代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="c1ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们一行一行地看Java内存行为(我省略了main方法声明行，以关注主题并保持画面清晰):</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="e206" class="lm ln iq lf b gy lo lp l lq lr">List&lt;String&gt; aryaStarkNameList = new ArrayList&lt;&gt;();</span></pre><p id="9941" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您从前面带有<code class="fe lc ld le lf b">String greeting</code>变量的代码示例中可能知道的那样，这一行代码执行3个动作:<br/> 1。创建<code class="fe lc ld le lf b">ArrayList</code>对象；<br/> 2。创建名为<code class="fe lc ld le lf b">aryaStarkNameList</code>且类型为<code class="fe lc ld le lf b">List&lt;String&gt;</code>的变量；<br/> 3。将变量<code class="fe lc ld le lf b">aryaStarkNameList</code>引用到第一步中的对象。</p><p id="cb22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我敢肯定，你一定知道<code class="fe lc ld le lf b">Stack</code>和<code class="fe lc ld le lf b">Heap</code>现在是什么样子(从现在开始，我将省略把内存地址放到堆中，以使图像更清晰，因为它们将包含越来越多的数据):</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nc"><img src="../Images/8ca5f148c771d9815218782bd1810706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GNC-uw3SY7k8sC_27Zlvgg.png"/></div></div></figure><p id="16a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们转到下一行代码:</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="c5f2" class="lm ln iq lf b gy lo lp l lq lr">aryaStarkNameList.add("Cersei");</span></pre><p id="693f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在那里进行了哪些行动？<br/> 1。<code class="fe lc ld le lf b">String</code>已创建值为<code class="fe lc ld le lf b">Cersei</code>的对象；<br/> 2。<code class="fe lc ld le lf b">ArrayList</code>的第一个元素引用了这个<code class="fe lc ld le lf b">String</code>对象。</p><p id="e352" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您看到这行代码和<code class="fe lc ld le lf b">String greeting</code>示例之间的主要区别了吗？当前代码没有创建局部变量，所以不会有任何东西被放入<code class="fe lc ld le lf b">Stack</code>。</p><p id="46df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这听起来很复杂，让我们试着从另一个角度来看:创建局部变量-&gt;将它放入列表之间的主要原因是什么:</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="0349" class="lm ln iq lf b gy lo lp l lq lr">String cersei = "Cersei";<br/>aryaStarkNameList.add(cersei);</span></pre><p id="0f58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并将数据直接放入列表中:</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="c94c" class="lm ln iq lf b gy lo lp l lq lr">aryaStarkNameList.add("Cersei");</span></pre><p id="58af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">?</p><p id="e1ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主要原因是在第二个例子中没有办法直接调用带有值<code class="fe lc ld le lf b">Cersei</code>的<code class="fe lc ld le lf b">String</code>对象，但是第一个例子通过局部变量<code class="fe lc ld le lf b">cersei</code>提供了这样一种可能性。这就是为什么在第一个示例中，<code class="fe lc ld le lf b">cersei</code>变量将被放入<code class="fe lc ld le lf b">Stack</code>，但在第二个示例中——变量<code class="fe lc ld le lf b">Stack</code>将保持不变。</p><p id="7065" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，让我们进一步看第二个例子:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nc"><img src="../Images/2fad521f43104c8eaf4d6477e8000138.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BkflV-25u8a0u_xTxrTQ_g.png"/></div></div></figure><p id="971d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来的几行代码将元素添加到列表中，它们的行为与前面的代码相同，所以让我们继续:</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="fd96" class="lm ln iq lf b gy lo lp l lq lr">aryaStarkNameList.add("Ilyn Payne");<br/>aryaStarkNameList.add("Joffrey");<br/>aryaStarkNameList.add("The Mountain");<br/>aryaStarkNameList.add("The Hound");</span></pre><p id="ccd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据<code class="fe lc ld le lf b">Stack</code>和<code class="fe lc ld le lf b">Heap</code>状态也没有什么意外:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nc"><img src="../Images/66c71a26e949805c0b187ba694d49554.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ErxGSXV3HH3w_4dQCaF4Q.png"/></div></div></figure><p id="edaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们继续下一行:</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="0a8d" class="lm ln iq lf b gy lo lp l lq lr">printList(aryaStarkNameList);</span></pre><p id="bab4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，现在我们进入新方法<code class="fe lc ld le lf b">void printList(List&lt;String&gt; listToPrint)</code>。正如您从方法签名中看到的，它接收了一个<code class="fe lc ld le lf b">String</code>的<code class="fe lc ld le lf b">List</code>。从Java内存的角度来看，创建了新的局部变量，该变量引用了<code class="fe lc ld le lf b">Heap</code>中与该方法调用中提供的变量相同的对象。这意味着<code class="fe lc ld le lf b">Stack</code>将要被修改:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nc"><img src="../Images/beb68a3da26f5335421091c5e6087afc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZcA-8zVpHajummW18t1aWg.png"/></div></div></figure><p id="664c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，列表内容会打印到控制台:</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="be75" class="lm ln iq lf b gy lo lp l lq lr">[Cersei, Ilyn Payne, Joffrey, The Mountain, The Hound]</span></pre><p id="f586" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经完成了<code class="fe lc ld le lf b">printList()</code>方法，因此<code class="fe lc ld le lf b">Stack</code>将从此方法变量中释放:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nc"><img src="../Images/0ebbfa14662bff20a72c2c0c253a98d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TTlIJDtJXJJ_E-8pKx0Qtg.png"/></div></div></figure><p id="af20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一行代码是:</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="fda6" class="lm ln iq lf b gy lo lp l lq lr">addNewNameToList(aryaStarkNameList, "Walder Frey");</span></pre><p id="fab4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，我们要进入一个新的方法，所以，现在，你应该能够解释，现在<code class="fe lc ld le lf b">Stack</code>和<code class="fe lc ld le lf b">Heap</code>会发生什么:当然，新的变量会被添加到<code class="fe lc ld le lf b">Stack</code>中，新的<code class="fe lc ld le lf b">String</code>对象值<code class="fe lc ld le lf b">Walder Frey</code>会出现在<code class="fe lc ld le lf b">Heap</code>中:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nc"><img src="../Images/b721310aa5ae1c4a238c639ccdfc29c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t90Wv15wMLTH882JktXRmw.png"/></div></div></figure><p id="10f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们在<code class="fe lc ld le lf b">addNewNameToList()</code>方法里面:</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="9994" class="lm ln iq lf b gy lo lp l lq lr">listToModify.add(nameToAdd);</span></pre><p id="6a5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所看到的，列表将通过添加新元素进行修改。这是什么意思？会改变<code class="fe lc ld le lf b">listToModify</code>而不改变<code class="fe lc ld le lf b">aryaStarkNameList</code>吗？号码</p><p id="c74a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理解这一点很重要，在Java中，当我们传递一个对象的值时，我们传递的是对它的引用。所以，当我们修改对象时，意味着我们修改了它在<code class="fe lc ld le lf b">Heap</code>中的值，但是引用将保持不变。这就是为什么物体的状态会被所谓的副作用改变。</p><p id="dbe1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看一下Java内存，对所有这些有一个直观的理解:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nc"><img src="../Images/f12dadc748d3bfa83f0688c59a1abb82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YlkcNxfUzIFmRw9wHr98wg.png"/></div></div></figure><p id="8f42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你会看到<code class="fe lc ld le lf b">Heap</code>中的<code class="fe lc ld le lf b">List</code>对象现在包含了一个元素，而<code class="fe lc ld le lf b">aryaStarkNameList</code>仍然引用它。</p><p id="3a8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们完成了<code class="fe lc ld le lf b">addNewNameToList()</code>方法之后，<code class="fe lc ld le lf b">Stack</code>从方法数据中被释放:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nc"><img src="../Images/beaf5b2fb0531b4e518c17e3430cd0e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YAvtJCu_IVvrYENpzPU3QA.png"/></div></div></figure><p id="3923" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经完成了当前的类(除了发布了<code class="fe lc ld le lf b">Stack</code>和<code class="fe lc ld le lf b">Heap</code>)，但是让我稍微扩展一下，让您思考并检查一下，您是否理解Java内存概念和通过引用传递对象。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="3228" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能已经注意到，已经创建了一个新方法<code class="fe lc ld le lf b">reinitializeList()</code>，并从<code class="fe lc ld le lf b">main()</code>方法中调用。问题是:控制台将打印什么，为什么？现在，你知道的比找到正确答案所需的更多。</p><p id="e4ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们和哈巴狗一起思考一下=)</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nd"><img src="../Images/1c397b0edaacc6c7cae947a8c6c5c87d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q-BWXm_Yr0hQrPM7"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">查尔斯·🇵🇭在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="5d60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，希望你已经顺利完成任务了，来看看正确答案:</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="59c3" class="lm ln iq lf b gy lo lp l lq lr">reinitializeList(aryaStarkNameList);</span></pre><p id="19a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们正在进入一个新的方法，就像我们以前已经做过几次的那样，所以存储器有如下状态:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nc"><img src="../Images/197dcee789b20a11c21bc76c65b19462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-Sae-yNa78rY3X4tLk0og.png"/></div></div></figure><p id="4b9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们在方法内部，所以让我们一行一行地来:</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="b21b" class="lm ln iq lf b gy lo lp l lq lr">List&lt;String&gt; newNames = new ArrayList&lt;&gt;();</span></pre><p id="7c09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对我们来说小菜一碟，不是吗？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/b45e4db58563e5b45181f5970d6809aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dj4rW3zn_IRX20tOZR9DGg.png"/></div></div></figure><p id="5a47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一行代码也很简单:</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="d707" class="lm ln iq lf b gy lo lp l lq lr">newNames.add("John Snow");</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/e79d2cc18d8823e7b29eee9ef4f80a94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MpkxE7-F3H_SYOfT1r6lPg.png"/></div></div></figure><p id="fa98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是这个方法的最后一行可能有点棘手:</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="3c9c" class="lm ln iq lf b gy lo lp l lq lr">listToReinitialize = newNames;</span></pre><p id="ced3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那里发生了什么事？嗯，变量<code class="fe lc ld le lf b">listToReinitialize</code>不是指那庞大的<code class="fe lc ld le lf b">List</code>名字，而是开始指新创建的<code class="fe lc ld le lf b">List</code>。但是主要的问题是:它会以某种方式影响<code class="fe lc ld le lf b">aryaStarkNameList</code>吗？让我们在图片上看看:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/69b949c7dd2c8fbe606d6300dc859089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3272uH54ByWgZO9Lkhf6qw.png"/></div></div></figure><p id="706e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，<code class="fe lc ld le lf b">aryaStarkNameList</code>不受任何影响，因为它在<code class="fe lc ld le lf b">Heap</code>中保留了对巨大的<code class="fe lc ld le lf b">List</code>的引用。</p><p id="8897" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们将在控制台中看到以下内容:</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="b394" class="lm ln iq lf b gy lo lp l lq lr">[Cersei, Ilyn Payne, Joffrey, The Mountain, The Hound, Walder Frey]</span></pre><p id="ed3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望，这是明确的。</p><p id="bee0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们以展示未来会发生什么来结束这节课。</p><p id="d7da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们离开<code class="fe lc ld le lf b">reinitializeList()</code>方法时，<code class="fe lc ld le lf b">Stack</code>从其数据中释放:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/62b4ddb94c9b9cc0e05b35434fe7edc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AljLq6VmOiVKTmht03wk9w.png"/></div></div></figure><p id="e2d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以看到一个有趣的画面:在<code class="fe lc ld le lf b">Heap</code>(只有一个元素的<code class="fe lc ld le lf b">List</code>)中有一个物体，没有人从<code class="fe lc ld le lf b">Stack</code>中提到它。这是什么意思？嗯，这意味着，这个对象有资格被<code class="fe lc ld le lf b">Garbage Collector</code>收集。</p><p id="5686" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">什么是<code class="fe lc ld le lf b">Garbage Collector</code>？简单地说，它是一个从垃圾中清理Java内存的人，垃圾是应用程序不再需要的对象。<code class="fe lc ld le lf b">Not needed anymore</code>的意思是，根本没有对这个对象的引用。</p><p id="fdd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">说到我们的例子，我们可能期望，迟早，<code class="fe lc ld le lf b">Garbage Collector</code>会被调用，并从内存中移除<code class="fe lc ld le lf b">List</code>对象。之后，值为<code class="fe lc ld le lf b">John Snow</code>的<code class="fe lc ld le lf b">String</code>对象将是下一个被垃圾收集的候选对象。</p><p id="afd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我们不确定什么时候会调用<code class="fe lc ld le lf b">Garbage Collector</code>:现在，几秒/几分钟或者更晚。并且没有办法手动调用它。这取决于已经配置(或默认使用)的策略，但这超出了本文的范围。</p><p id="609e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无论如何，让我们想象一下，我们已经足够幸运，已经立即调用了<code class="fe lc ld le lf b">Garbage Collector</code>，所以现在一个元素的<code class="fe lc ld le lf b">List</code>已经不存在了，还有<code class="fe lc ld le lf b">John Snow</code> <code class="fe lc ld le lf b">String</code>对象:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/c2eaecef328e7c1a68c4657e06c52dcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DwBd9oLRDhMXJJRuaoJKWw.png"/></div></div></figure><p id="13d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们正在传递一个打印语句，我们已经完成了<code class="fe lc ld le lf b">main()</code>方法，所以<code class="fe lc ld le lf b">Stack</code>从它的数据中释放出来:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/c6c8fee31490b1a0622dcd2743e34748.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-TMcZSC1wHTNOK8hhDoc0g.png"/></div></div></figure><p id="dbdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而且，您可能已经注意到，新对象(<code class="fe lc ld le lf b">List</code>)符合<code class="fe lc ld le lf b">Garbage Collector</code>的条件。</p><p id="a248" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">课程结束了，干得好！</p><p id="b0e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，还有两件事，我要和你讨论。第一个是类在内存中的样子。</p><p id="cbdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑到我们有课<code class="fe lc ld le lf b">Dwarf</code>:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="e14c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和示例类:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="1be2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们一行一行地来看看，Java内存中发生了什么。</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="2712" class="lm ln iq lf b gy lo lp l lq lr">Dwarf dwarf = new Dwarf("Gimli", 40);</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/59411f9a5fef1059fd6ccade9374ce1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a0q7mxIxq_JgcclSRy0SWQ.png"/></div></div></figure><p id="35df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图像中有一个激动人心的时刻:变量<code class="fe lc ld le lf b">beardLength</code>存储在对象<code class="fe lc ld le lf b">Dwarf</code>中。怎么会这样嗯，没有别的办法了。是的，我告诉过你，原始类型存储在<code class="fe lc ld le lf b">Stack</code>中，但这会使<code class="fe lc ld le lf b">Heap</code>依赖于<code class="fe lc ld le lf b">Stack</code>，更有甚者，如果<code class="fe lc ld le lf b">Stack</code>不在了，<code class="fe lc ld le lf b">Heap</code>也会丢失数据。这就是为什么数据存储在<code class="fe lc ld le lf b">Heap</code>的对象中。</p><p id="7285" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们继续:</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="db4f" class="lm ln iq lf b gy lo lp l lq lr">dwarf.setName("Thorin");<br/>dwarf.setBeardLength(20);</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/28e7f2ef2d94c486903fc43a934dc5c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1juP5ceiVZL1ZcH_9Jgc4A.png"/></div></div></figure><p id="ee06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一点应该是清楚的。而且，正如我们看到的，<code class="fe lc ld le lf b">String</code> <code class="fe lc ld le lf b">Gimli</code>现在有资格进入<code class="fe lc ld le lf b">Garbage Collector</code>。</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="6b6d" class="lm ln iq lf b gy lo lp l lq lr">dwarf = new Dwarf("Thrain", 50);</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/ee0bb4dace67d642700b56f0b35b8646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7s3LuAHVdwKcbcVZLMOnmg.png"/></div></div></figure><p id="c575" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">名为<code class="fe lc ld le lf b">Thorin</code>的<code class="fe lc ld le lf b">Dwarf</code>对象现在可以进行垃圾收集了。让我们想象一下，当我们继续下一行代码时，已经调用了<code class="fe lc ld le lf b">Garbage Collector</code>:</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="1301" class="lm ln iq lf b gy lo lp l lq lr">Dwarf thrain = dwarf;</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/e3544d78c31179805186ff92ae9e7d30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CC6NfWgzBJLPjXRAguK5Jw.png"/></div></div></figure><p id="4129" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们将<code class="fe lc ld le lf b">dwarf</code>赋给<code class="fe lc ld le lf b">thrain</code>时，意味着我们共享了对<code class="fe lc ld le lf b">Heap</code>中<code class="fe lc ld le lf b">Dwarf</code>对象的值的引用。所以，从现在开始，<code class="fe lc ld le lf b">thrain</code>和<code class="fe lc ld le lf b">dwarf</code>都指代<code class="fe lc ld le lf b">Heap</code>中的同一个对象。</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="a6e3" class="lm ln iq lf b gy lo lp l lq lr">thrain.setName("Thrain II");<br/>thrain.setBeardLength(70);</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/bd26528bac5ee2fd4876568284743fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pI1eRJPJIRZAwX2_KnxIXA.png"/></div></div></figure><p id="0087" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为两个变量指向同一个对象，而对象被修改了，这意味着引用保持不变，所以我们又面临副作用了。</p><p id="d908" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以预见，我们将在控制台中看到以下输出:</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="b0e5" class="lm ln iq lf b gy lo lp l lq lr">Dwarf: Dwarf [name='Thrain II', beardLength=70]<br/>Thrain: Dwarf [name='Thrain II', beardLength=70]</span></pre><p id="3e36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望，现在很清楚了。</p><p id="abdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有一件事，我想和你讨论一下。</p><p id="6400" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你可能已经理解的那样，<code class="fe lc ld le lf b">Heap</code>是内存的一个巨大部分，它可以包含超过几千兆字节的内存。它通过引用<code class="fe lc ld le lf b">Stack</code>中对象的值在应用程序间共享。每个应用程序只有一个<code class="fe lc ld le lf b">Heap</code>。但是有几个<code class="fe lc ld le lf b">Stack</code>:每个线程一个。</p><p id="05a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，一个复杂的企业Java应用程序包含许多线程，因此<code class="fe lc ld le lf b">Heap</code>在它们之间共享。重要的是要记住，作为工程师，我们应该注意多线程应用程序中的数据一致性，因为两个或更多线程同时修改同一个对象的风险很高，因此一些数据可能会在更新过程中丢失。这种情况被称为<a class="ae lb" href="https://docs.oracle.com/cd/E19205-01/820-0619/geojs/index.html" rel="noopener ugc nofollow" target="_blank">数据竞争</a>，但是我们不打算在这篇文章中深入探讨。如果你想让我单独写一篇关于Java中数据竞争的文章，请在评论区告诉我。</p><p id="161f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，现在你知道了我想在这篇文章中与你分享的所有东西——干得好，伙计们！</p><p id="afa7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是你难道没有忘记冲锋队克隆人军队的神秘吗？在我们的帖子开始时，他们已经在与叛军的战斗中失败了。您拥有发现问题并解决问题的所有知识和技能——只管去做！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/8c24fedda388dc938ede6b6c31edcbd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0EXkVFFXawZoc5sv"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://unsplash.com/@mariana42?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">玛丽安娜B. </a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="b410" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我给你一个提示:问题在<code class="fe lc ld le lf b">CloneBuilderService</code>类内部。</p><p id="61cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，我们一起来，再来看一看这个类:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="c7d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们试着一行一行地通过它的<code class="fe lc ld le lf b">buildClones()</code>方法来捕捉问题:</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="d5e1" class="lm ln iq lf b gy lo lp l lq lr">List&lt;StormTrooper&gt; clones = new ArrayList&lt;&gt;();</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/c4b764443ebe4e7429aff9d5ca1bec20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H9jJFRQ8SxkeZ_qZ7uRobg.png"/></div></div></figure><p id="5404" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里没什么好讨论的。但是接下来的几行(<code class="fe lc ld le lf b">for</code>循环及其内部)就有趣多了:</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="02b8" class="lm ln iq lf b gy lo lp l lq lr">for (int i = 0; i &lt; numberOfClonesToBuild; i++) {<br/>        StormTrooper clone = stormTrooperPrototype;<br/>        clones.add(clone);<br/>}</span></pre><p id="6d7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在那里有<code class="fe lc ld le lf b">numberOfClonesToBuild</code>迭代(让我们想象一下，它是100，因为我们在<code class="fe lc ld le lf b">BattleMain</code>类中操作这个数)。在每次迭代中，创建一个新变量<code class="fe lc ld le lf b">clone</code>，并且<code class="fe lc ld le lf b">stormTrooperPrototype</code>与<code class="fe lc ld le lf b">clone</code>变量共享对<code class="fe lc ld le lf b">StormTrooper</code>对象的引用。之后，将<code class="fe lc ld le lf b">clone</code>变量(因此，引用了<code class="fe lc ld le lf b">StormTrooper</code>)放入<code class="fe lc ld le lf b">List</code>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/e16b056ef8ad833787d2adaa43f9f04b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LAKHhYUfUU1tocOMMIha6Q.png"/></div></div></figure><p id="a3a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，<code class="fe lc ld le lf b">clone</code>变量从<code class="fe lc ld le lf b">Stack</code>中释放。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/a079579229dc55d2e3cb91ba81b7af02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vj0_Uay2EYH2quhUNDidMA.png"/></div></div></figure><p id="881f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同一个故事出现100次，那么<code class="fe lc ld le lf b">for</code>循环完成后的最终画面将如下:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/3cd0663af6f0aaad6a80fc64f69cbd1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1VJA49FabmBZlQcobBezAg.png"/></div></div></figure><p id="cf7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看着这张照片，很容易捕捉到，是什么原因让克隆人小队在叛军的第一枪后节节败退:</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="11df" class="lm ln iq lf b gy lo lp l lq lr">private static void proceedRebelsAttack(List&lt;StormTrooper&gt; stormTroopers) {<br/>        StormTrooper stormTrooper = stormTroopers.stream()<br/>                                     .filter(StormTrooper::isAlive)<br/>                                     .findFirst()<br/>                        .orElseThrow(IllegalArgumentException::new);</span><span id="5603" class="lm ln iq lf b gy ls lp l lq lr">        System.out.printf("%s is killed \n", stormTrooper);</span><span id="2621" class="lm ln iq lf b gy ls lp l lq lr">        stormTrooper.kill();<br/>}</span></pre><p id="1f31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lc ld le lf b">stormTrooper.kill()</code>将<code class="fe lc ld le lf b">StormTrooper</code> <code class="fe lc ld le lf b">alive</code>字段的值更改为<code class="fe lc ld le lf b">false</code>。由于每个冲锋队都提到了<code class="fe lc ld le lf b">Heap</code>中的同一个物体，这意味着，他们都立即死亡。我要说，帝国软件工程师做得不好…</p><p id="7a01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们修理它！</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="b87e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，每次都会在<code class="fe lc ld le lf b">Heap</code>中创建一个新对象，因此每个<code class="fe lc ld le lf b">List</code>变量将引用单独的独立对象。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/e8946cacc098dab2663d9877f4d2ace2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jnn-t4rMtFEkC4B26SWHKw.png"/></div></div></figure><p id="eb43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们运行应用程序:</p><pre class="km kn ko kp gt li lf lj lk aw ll bi"><span id="37c9" class="lm ln iq lf b gy lo lp l lq lr">The squad of clones is built. The size is 100</span><span id="330a" class="lm ln iq lf b gy ls lp l lq lr">Rebel [name='Gregar Typho', weapon='Gun'] is killed <br/>StormTrooper [name='Stormtrooper Prototype', weapon='Blaster'] is killed</span><span id="9269" class="lm ln iq lf b gy ls lp l lq lr">Rebel [name='Han Solo', weapon='Gun'] is killed <br/>StormTrooper [name='Stormtrooper Prototype', weapon='Blaster'] is killed</span><span id="258b" class="lm ln iq lf b gy ls lp l lq lr">Rebel [name='Princess Leia', weapon='Gun'] is killed <br/>StormTrooper [name='Stormtrooper Prototype', weapon='Blaster'] is killed</span><span id="4926" class="lm ln iq lf b gy ls lp l lq lr">Rebel [name='Chewbacca', weapon='Arbalest'] is killed <br/>StormTrooper [name='Stormtrooper Prototype', weapon='Blaster'] is killed</span><span id="aaf6" class="lm ln iq lf b gy ls lp l lq lr">Rebel [name='Luke Skywalker', weapon='Lightsaber'] is killed <br/>StormTrooper [name='Stormtrooper Prototype', weapon='Blaster'] is killed</span><span id="cbcf" class="lm ln iq lf b gy ls lp l lq lr">Rebel [name='R2D2', weapon='Intelligence'] is killed <br/>StormTrooper [name='Stormtrooper Prototype', weapon='Blaster'] is killed</span><span id="6489" class="lm ln iq lf b gy ls lp l lq lr">Stormtroopers win the battle!</span></pre><p id="3f4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用程序是固定的，但是，我不高兴，因为R2D2走了——没有快乐的结局…</p><p id="bf6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗯，你今天做得非常好！我希望，从现在开始，你已经熟悉了<code class="fe lc ld le lf b">Java Memory Model</code>，并准备好去深入探讨这个话题！</p><p id="f805" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们总结一下文章的内容:</p><ol class=""><li id="8992" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated"><em class="mz"> Java内存模型包含两个主要部分:堆栈和堆；</em></li><li id="e06a" class="mq mr iq jp b jq ng ju nh jy ni kc nj kg nk kk mv mw mx my bi translated"><em class="mz">堆栈负责存储原始数据类型(变量名和值)和对复杂对象值的引用；</em></li><li id="e8bf" class="mq mr iq jp b jq ng ju nh jy ni kc nj kg nk kk mv mw mx my bi translated"><em class="mz">堆负责存储复杂的对象值，并通过栈中的引用在整个应用之间共享；</em></li><li id="9d8e" class="mq mr iq jp b jq ng ju nh jy ni kc nj kg nk kk mv mw mx my bi translated"><em class="mz">每个应用程序有一个堆，但是也可以有几个栈:每个线程一个；</em></li><li id="fd1b" class="mq mr iq jp b jq ng ju nh jy ni kc nj kg nk kk mv mw mx my bi translated">在Java中，当我们传递一个对象的值时，我们传递的是对它的引用。所以，当我们修改对象时，意味着我们修改了它在堆中的值，但是引用保持不变。这就是为什么物体的状态会被所谓的副作用改变；</li><li id="7f86" class="mq mr iq jp b jq ng ju nh jy ni kc nj kg nk kk mv mw mx my bi translated"><em class="mz">如果你正在处理创建克隆人冲锋队的任务，不要省略测试阶段(当然，如果你不是叛军间谍)=) </em></li></ol><p id="99ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一段漫长的旅程，但我们一起走过了。我希望你学到了新的东西，并且在阅读过程中没有睡着。无论如何，谢谢，在评论区和以后的帖子里再见！</p><p id="642c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">玩得开心！</p></div></div>    
</body>
</html>