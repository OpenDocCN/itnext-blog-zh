<html>
<head>
<title>Fast and modern front-end setup with webpack, react, redux, router, saga and postcss, part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用webpack、react、redux、router、saga和postcss的快速现代前端设置，第1部分</h1>
<blockquote>原文：<a href="https://itnext.io/fast-and-modern-front-end-setup-with-webpack-react-redux-router-saga-and-postcss-1360e9715d17?source=collection_archive---------2-----------------------#2018-02-01">https://itnext.io/fast-and-modern-front-end-setup-with-webpack-react-redux-router-saga-and-postcss-1360e9715d17?source=collection_archive---------2-----------------------#2018-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b09a23ab61b80f7a0f50c1ebb74d55a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aWWDEqkro7jA8BYwGm9cDA.jpeg"/></div></div></figure><p id="eb3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意:webpack 4已经发布并经过测试，这个设置有点过时，你可以做得更好！！！</p><blockquote class="kw"><p id="3541" class="kx ky iq bd kz la lb lc ld le lf kv dk translated">这是一个系列的第一部分，你可以在以下链接中阅读其他部分:<br/> - <a class="ae lg" rel="noopener ugc nofollow" target="_blank" href="/fast-and-modern-front-end-setup-with-webpack-react-redux-router-saga-and-postcss-part-2-9ae7ad4e7cb2">第二部分</a>-<a class="ae lg" rel="noopener ugc nofollow" target="_blank" href="/fast-and-modern-front-end-setup-with-webpack-react-redux-router-saga-and-postcss-part-3-27ac4bc3f969">第三部分</a></p></blockquote><p id="0752" class="pw-post-body-paragraph jy jz iq ka b kb lh kd ke kf li kh ki kj lj kl km kn lk kp kq kr ll kt ku kv ij bi translated">如果你只是想开始使用设置</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="fb91" class="lv lw iq lr b gy lx ly l lz ma">git clone <a class="ae lg" href="https://github.com/bojanaleksa/react-redux-router-saga-material-postcss-webpack" rel="noopener ugc nofollow" target="_blank">https://github.com/bojanaleksa/react-redux-router-saga-material-postcss-webpack</a></span></pre><p id="0c23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后<code class="fe mb mc md lr b">npm start</code>在src/ folder中编写代码。</p><h1 id="3304" class="me lw iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">现在一步一步来</h1><p id="d8fc" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">首先，您需要安装npm和节点。这不言而喻，但是，我说了。</p><p id="f371" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开你的终端。我用的是ubuntu，所以如果你看到一些你不知道的系统命令，那是ubuntu，无论你用什么都可以查一下。</p><p id="70b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，创建一个新的文件夹，进入并<code class="fe mb mc md lr b">npm init -y</code>。我们势如破竹！！！</p><p id="e8a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好的，首先我们将安装webpack。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="11bd" class="lv lw iq lr b gy lx ly l lz ma">npm i -D webpack</span></pre><p id="f515" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Webpack是一个模块捆绑器。这意味着，它将使用我们在webpack.config.js文件中提供的配置，将一些文件作为输入，并创建其他文件作为输出。让我们继续创建这个文件:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="d784" class="lv lw iq lr b gy lx ly l lz ma">touch webpack.config.js</span></pre><p id="b16d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在这里想要的是有一个文件夹，我们可以在那里写代码，使它可读和组织良好，另一个文件夹，压缩和优化版本的代码将去，为浏览器做好准备。许多优化都是通过webpack完成的，它将使最终用户体验更好(主要是在速度方面)。</p><p id="f829" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们创建一个名为src的文件夹。在其中，创建一个名为index.js的文件。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="2b4a" class="lv lw iq lr b gy lx ly l lz ma">mkdir src<br/>cd src<br/>touch index.js</span></pre><p id="f65c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个文件中，只需放任何JS代码，像一些<code class="fe mb mc md lr b">console.log(‘here we go’);</code></p><h2 id="11d7" class="lv lw iq bd mf ng nh dn mj ni nj dp mn kj nk nl mr kn nm nn mv kr no np mz nq bi translated">WEBPACK基本版</h2><p id="eee8" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">现在，我们将让webpack获取该文件，并在公共文件夹中创建一个新文件(它也将为我们创建该文件夹)。打开webpack.config.js并将其放入:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="f2ed" class="lv lw iq lr b gy lx ly l lz ma">const path = require('path');</span><span id="6ee1" class="lv lw iq lr b gy nr ly l lz ma">module.exports = {<br/>    entry: "./src/index.js",<br/>    output: {<br/>        filename: 'bundle.js',<br/>        path: path.resolve(__dirname, 'public')<br/>    }<br/>}</span></pre><p id="1032" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">module.exports告诉我们什么将被导出用于其他地方，这是我们的配置对象。第一行导入了一些东西(在本例中是路径)。因此，如你所见，我们可以将代码组织成模块，并随意导入和导出内容。</p><p id="a152" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是首先，这个路径模块是从哪里来的？也许你在安装webpack的时候注意到了一个node_modules/文件夹。该文件夹包含其他人构建的您(或您想要的模块)使用的所有模块。Webpack需要path，因此path随它一起安装。你可以随时使用它。</p><p id="b429" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，我们的对象有两个道具，入口和输出。非常简单，entry是我们想要加载的文件(注意。/在位置字符串中)，输出需要文件名和路径。我们使用path模块的原因现在很清楚了:我们不想要一个绝对路径，我们希望它相对于我们在文件系统中的位置。</p><p id="462e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们启动webpack之前，让我们实际上把它做成一个脚本，这样我们就可以使用npm来完成这个任务。进入package.json并找到脚本。让它看起来像这样:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="3713" class="lv lw iq lr b gy lx ly l lz ma">"scripts": {<br/>    "start": "webpack"<br/>  },</span></pre><p id="572e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在回到终端，运行<code class="fe mb mc md lr b">npm start</code>。该命令运行webpack，webpack读取配置文件，创建公共文件夹并填充它。查看bundle.js并找到我们的console.log。这看起来只是添加了更多的代码，但它是值得的。</p><p id="72c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了更好地理解webpack导入，在index.js旁边创建另一个文件，并将其命名为test.js。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="3b50" class="lv lw iq lr b gy lx ly l lz ma">export default 5;</span></pre><p id="2f79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在打开index.js并:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="997e" class="lv lw iq lr b gy lx ly l lz ma">import test from './test';<br/>console.log(test);</span></pre><p id="9223" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行<code class="fe mb mc md lr b">npm start</code>test . js文件被包含在public/bundle.js中，并与index.js内容捆绑在一起，这就是导入/导出的工作方式。您将只有一个主文件index.js，并导入您需要的内容。Webpack将为您优化导入，所有内容都将保存在一个文件中供浏览器使用。</p><p id="9309" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还要注意，webpack实际上并不运行这些文件，所以在捆绑之后，您可能会在浏览器中看到错误。</p><p id="5451" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在删除test.js并运行<code class="fe mb mc md lr b">npm start</code>。检查错误。红色部分告诉您试图导入一个不存在的模块的确切位置。如果你拼错或忘记了，这很方便。</p><p id="ca67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，关于webpack，有很多内容要讲。添加此行</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="2f2f" class="lv lw iq lr b gy lx ly l lz ma">context: path.resolve(__dirname, 'src')</span></pre><p id="dffb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为我们对象中的下一个属性，并从条目字符串中删除<code class="fe mb mc md lr b">/src</code>。现在看起来是这样的:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="16fe" class="lv lw iq lr b gy lx ly l lz ma">const path = require('path');</span><span id="db5b" class="lv lw iq lr b gy nr ly l lz ma">module.exports = {<br/>    entry: "./index.js",<br/>    output: {<br/>        filename: 'bundle.js',<br/>        path: path.resolve(__dirname, 'public')<br/>    },<br/>    context: path.resolve(__dirname, 'src')<br/>}</span></pre><p id="ccdf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这一行添加了包发生的上下文。对我们来说，它是src/文件夹。</p><h2 id="9e7c" class="lv lw iq bd mf ng nh dn mj ni nj dp mn kj nk nl mr kn nm nn mv kr no np mz nq bi translated">超文本标记语言</h2><p id="26c7" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">每个好的前端都需要一个名为index.html的html文件。我们计划在src/文件夹中完成所有工作，让我们在那里创建一个。像这样填充它:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="08b8" class="lv lw iq lr b gy lx ly l lz ma">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>  &lt;title&gt;Basic Setup&lt;/title&gt;</span><span id="cde3" class="lv lw iq lr b gy nr ly l lz ma">  &lt;meta charset="utf-8"&gt;<br/>  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;<br/>  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;</span><span id="7a37" class="lv lw iq lr b gy nr ly l lz ma">&lt;link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"/&gt;</span><span id="fe4d" class="lv lw iq lr b gy nr ly l lz ma">&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;div id="app"&gt;&lt;/div&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="839c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你注意到的，我们不加载js，也不会加载css。Webpack会帮我们做到这一点。现在，webpack还需要将这个文件复制到public/文件夹中。为此，我们将使用webpack的一些插件。Webpack有很多插件，它们扩展了基本功能。让我们安装我们需要的东西</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="7628" class="lv lw iq lr b gy lx ly l lz ma">npm i -D html-webpack-plugin</span></pre><p id="553e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的webpack.config.js中，加载path模块下的插件</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="6276" class="lv lw iq lr b gy lx ly l lz ma">const HtmlWebpackPlugin = require('html-webpack-plugin');</span></pre><p id="eb78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在配置对象中，添加一个插件数组，并在那里使用我们的插件。现在看起来都是这样的</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="060c" class="lv lw iq lr b gy lx ly l lz ma">const path = require('path');</span><span id="d100" class="lv lw iq lr b gy nr ly l lz ma">const HtmlWebpackPlugin = require('html-webpack-plugin');</span><span id="1e57" class="lv lw iq lr b gy nr ly l lz ma">module.exports = {<br/>    entry: "./index.js",<br/>    output: {<br/>        filename: 'bundle.js',<br/>        path: path.resolve(__dirname, 'public')<br/>    },<br/>    context: path.resolve(__dirname, 'src'),<br/>    plugins: [<br/>     new HtmlWebpackPlugin({<br/>            template: 'index.html'<br/>        })<br/>    ]<br/>}</span></pre><p id="a19d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们为index.html定义了模板。现在再次运行<code class="fe mb mc md lr b">npm start</code>，在public/文件夹中查找。注意，我们现在将bundle.js加载到index.html的public/ folder中。如我所说，让webpack做它的工作。</p><p id="d8c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很好，现在我们有了一个可以在浏览器中运行的文件。如果这样做，您会注意到它运行index.js. Console中的代码，以确保这一点。</p><h2 id="1bc9" class="lv lw iq bd mf ng nh dn mj ni nj dp mn kj nk nl mr kn nm nn mv kr no np mz nq bi translated">开发服务器</h2><p id="8d27" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">接下来我们需要一个开发服务器。如果我们每次修改东西都要运行<code class="fe mb mc md lr b">npm start</code>并在浏览器中打开文件，那就糟了。最好让webpack也这么做。Webpack有个东西叫webpack-dev-server，我们来安装一下:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="496d" class="lv lw iq lr b gy lx ly l lz ma">npm i -D webpack-dev-server</span></pre><p id="b0e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在package.json里面，把<code class="fe mb mc md lr b">“start”: “webpack”</code>改成<code class="fe mb mc md lr b">“start”: “webpack-dev-server”</code>。现在再次运行<code class="fe mb mc md lr b">npm start</code>，它会告诉你在URL:<a class="ae lg" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/</a>打开浏览器。你可以在这里看到你的项目。在index.js中更改一些内容，然后返回浏览器。它会立即更新。现在你可以工作并检查你的进度，中间没有任何步骤。那真是太好了。</p><p id="9b38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果要停止服务器，只需在终端中按ctrl-c即可。制作另一个脚本，只构建应用程序而不运行它，我们以后会需要它。现在package.json脚本部分如下所示:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="4496" class="lv lw iq lr b gy lx ly l lz ma">"scripts": {<br/>    "start": "webpack-dev-server",<br/>    "build": "webpack",<br/>    "build-prod": "webpack -p"<br/>  },</span></pre><p id="771b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您运行<code class="fe mb mc md lr b">npm run build</code>，您将看到与之前相同的内容。但是build-prod脚本有-p标志，它告诉webpack为生产进行优化。运行<code class="fe mb mc md lr b">npm run build-prod</code>并检查bundle.js。现在它已经被压缩并为浏览器做了更好的优化。但是，我们将使用开发模式来开发，因为它更容易。</p><p id="2a69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们做得更好，让webpack为我们打开浏览器标签。在webpack.config.js中添加以下属性:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="17ef" class="lv lw iq lr b gy lx ly l lz ma">devServer: {<br/>   contentBase: path.resolve(__dirname, 'public/assets'),<br/>   stats: 'errors-only',<br/>   open: true,<br/>   port: 8080,<br/>   compress: true<br/>},</span></pre><p id="a056" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行<code class="fe mb mc md lr b">npm start</code>，欣赏它如何在你的浏览器中自己打开一个标签。我们在这里所做的是，我们为开发服务器添加了一个配置，告诉它提供来自/public/assets的图像，只显示错误，打开特定的端口，gzip压缩输出。</p><h2 id="8ff1" class="lv lw iq bd mf ng nh dn mj ni nj dp mn kj nk nl mr kn nm nn mv kr no np mz nq bi translated">静态资产(图像……)</h2><p id="8cdf" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">我们希望能够服务静态资产，比如图像。让我们在src/中创建一个资产/文件夹，并在其中放置一张图片。我们应该能够在index.js中得到这样的图像:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="7245" class="lv lw iq lr b gy lx ly l lz ma">import img from './assets/image.png';<br/>console.log(img);</span></pre><p id="f88e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是如果我们运行<code class="fe mb mc md lr b">npm run build</code>我们会得到一个错误。这是因为不知道这是一个静态文件，它会尝试分析它。让我们告诉webpack在这里做什么。我们需要一种叫做装载机的东西。webpack中的加载器是一个用于预处理某些文件(如图像)的工具。让我们安装它:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="fc27" class="lv lw iq lr b gy lx ly l lz ma">npm i -D file-loader</span></pre><p id="e39c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在用靠近底部的行扩展webpack.config.js。粘贴整个文件:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="7b3c" class="lv lw iq lr b gy lx ly l lz ma">const path = require('path');</span><span id="48c4" class="lv lw iq lr b gy nr ly l lz ma">const HtmlWebpackPlugin = require('html-webpack-plugin');</span><span id="2f58" class="lv lw iq lr b gy nr ly l lz ma">module.exports = {<br/>    entry: "./index.js",<br/>    output: {<br/>        filename: 'bundle.js',<br/>        path: path.resolve(__dirname, 'public')<br/>    },<br/>    context: path.resolve(__dirname, 'src'),<br/>    devServer: {<br/>        contentBase: path.resolve(__dirname, 'public/assets'),<br/>        stats: 'errors-only',<br/>        open: true,<br/>        port: 8080,<br/>        compress: true<br/>    },<br/>    plugins: [<br/>        new HtmlWebpackPlugin({<br/>            template: 'index.html'<br/>        })<br/>    ],<br/>    module: {<br/>        rules: [{<br/>            test: /\.(jpg|png|gif|svg)$/,<br/>            use: [<br/>            {<br/>                loader: 'file-loader',<br/>                options: {<br/>                    name: '[name].[ext]',<br/>                    outputPath: './assets/',<br/>                }<br/>            }]<br/>        }]<br/>    }<br/>}</span></pre><p id="064b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以看到，我们在规则道具中添加了一个模块道具。这就是webpack3的组织方式，不用担心。这里的要点是，rules是一个数组，你向它传递加载器。每个加载器都需要一个测试来检查它是否应该在文件上运行，以及一个带有选项的实际加载器模块。我们在这里看到，我们希望文件加载器接管图像文件。运行<code class="fe mb mc md lr b">npm run build</code>并检查公共/文件夹。那里会有一个资产文件夹，里面有我们的图像。如果图像被导入到代码中的某个地方，Webpack将只在这里复制图像。您也可以运行<code class="fe mb mc md lr b">npm start</code>，因为我们为静态文件配置了assets文件夹。</p><h2 id="40a7" class="lv lw iq bd mf ng nh dn mj ni nj dp mn kj nk nl mr kn nm nn mv kr no np mz nq bi translated">清理网络包</h2><p id="ae4e" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">现在，让我们说你改变或删除一个图像，或一些其他文件。Webpack之前已经复制过了。现在你不用了，它还在，占地方。将public/文件夹复制到生产服务器会更容易，而不用担心额外的文件。这有一个插件:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="ff86" class="lv lw iq lr b gy lx ly l lz ma">npm i -D clean-webpack-plugin</span></pre><p id="490f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在webpack.config.js中设置它</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="2fce" class="lv lw iq lr b gy lx ly l lz ma">const CleanWebpackPlugin = require('clean-webpack-plugin');<br/>...<br/>plugins: [<br/>new CleanWebpackPlugin(['public']),<br/>...<br/>]</span></pre><p id="c823" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们告诉这个插件在它重建的时候删除公共文件夹，这样只有我们实际使用的文件夹才能进入。如果你担心开发速度，开发服务器实际上并不创建文件夹，正如你将看到的。运行<code class="fe mb mc md lr b">npm start</code>你会注意到public/ folder不在这里，但是我们可以加载所有的图像和文件。这是为了使开发更快，这样代码中的每一个变化都会立即显示在浏览器中。</p><p id="0ea3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是如果您运行<code class="fe mb mc md lr b">npm run build</code>，您将再次看到public/ folder，这显示了开发和生产之间的区别。</p><h2 id="2fb6" class="lv lw iq bd mf ng nh dn mj ni nj dp mn kj nk nl mr kn nm nn mv kr no np mz nq bi translated">添加CSS文件</h2><p id="9356" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">我们希望能够将样式与代码的其余部分分开。我们将通过一种允许我们在任何需要的地方加载. css文件的方式来实现。</p><p id="f8a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们在src/ folder中做一个名为styles的文件夹，在里面放一个main.css文件。在文件中放一些css，像这样</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="4a78" class="lv lw iq lr b gy lx ly l lz ma">body {<br/> background: red;<br/>}</span></pre><p id="7ea1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也可以在index.js中导入这个文件</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="df6a" class="lv lw iq lr b gy lx ly l lz ma">import './styles/main.css';</span></pre><p id="e1ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意文件的路径。现在运行<code class="fe mb mc md lr b">npm start</code>，你会得到一个错误:“你可能需要一个合适的加载程序来处理这种文件类型。”很好，我们知道该怎么做了，让我们从终端添加css加载器</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="849c" class="lv lw iq lr b gy lx ly l lz ma">npm i -D css-loader</span></pre><p id="b3f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并将加载器规则添加到规则属性内的webpack.config.js中</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="003c" class="lv lw iq lr b gy lx ly l lz ma">const path = require('path');</span><span id="eb6e" class="lv lw iq lr b gy nr ly l lz ma">const CleanWebpackPlugin = require('clean-webpack-plugin');<br/>const HtmlWebpackPlugin = require('html-webpack-plugin');</span><span id="234e" class="lv lw iq lr b gy nr ly l lz ma">module.exports = {<br/>    entry: "./index.js",<br/>    output: {<br/>        filename: 'bundle.js',<br/>        path: path.resolve(__dirname, 'public')<br/>    },<br/>    context: path.resolve(__dirname, 'src'),<br/>    devServer: {<br/>        contentBase: path.resolve(__dirname, 'public/assets'),<br/>        stats: 'errors-only',<br/>        open: true,<br/>        port: 8080,<br/>        compress: true<br/>    },<br/>    plugins: [<br/>     new CleanWebpackPlugin(['public']),<br/>        new HtmlWebpackPlugin({<br/>            template: 'index.html'<br/>        })<br/>    ],<br/>    module: {<br/>        rules: [{<br/>            test: /\.(jpg|png|gif|svg)$/,<br/>            use: [<br/>            {<br/>                loader: 'file-loader',<br/>                options: {<br/>                    name: '[name].[ext]',<br/>                    outputPath: './assets/',<br/>                }<br/>            }]<br/>        }, {//HERE ARE THE NEW LINES<br/>         test: /\.css$/,<br/>         use: "css-loader"<br/>        }]<br/>    }<br/>}</span></pre><p id="fbe7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们运行<code class="fe mb mc md lr b">npm start</code>，我们的代码将运行并打开浏览器。但是背景不是红色的。这是因为我们现在有了一个加载器来处理css代码，但是它不能单独存在于js文件中。我们需要一种方法，以一种普通的方式将它连接到代码上。回到终端:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="a7ea" class="lv lw iq lr b gy lx ly l lz ma">npm i -D style-loader</span></pre><p id="6f9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个加载器实际上将样式加载到系统中。让我们编辑配置:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="9657" class="lv lw iq lr b gy lx ly l lz ma">...{<br/>   test: /\.css$/,<br/>   use: ["style-loader", "css-loader"]<br/>}</span></pre><p id="954d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好的，首先注意我们第一次是如何为use:属性使用一个对象的，然后是一个字符串，现在是一个数组。是不是很好听:d。</p><p id="143a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还要注意。我们在这里传递的css文件将由两个加载器处理，但最后一个加载器先处理，所以我们首先处理css代码，然后用style-loader连接它。如果我们现在运行<code class="fe mb mc md lr b">npm start</code>，我们的背景将是红色的。但是如果我们运行<code class="fe mb mc md lr b">npm run build</code>，你会注意到。css文件无处可寻。这是因为css代码被js插入了一个&lt;样式的&gt;标签。最好能有一个单独的文件供浏览器加载，这就是我们样式设置的第三部分:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="3867" class="lv lw iq lr b gy lx ly l lz ma">npm i -D extract-text-webpack-plugin</span></pre><p id="4541" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顾名思义，插件会将任何文本提取到一个单独的文件中。在webpack.config.js中，我们添加了这个插件</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="1e5f" class="lv lw iq lr b gy lx ly l lz ma">const path = require('path');</span><span id="1e58" class="lv lw iq lr b gy nr ly l lz ma">const CleanWebpackPlugin = require('clean-webpack-plugin');<br/>const HtmlWebpackPlugin = require('html-webpack-plugin');<br/>// NEW LINE<br/>const ExtractTextPlugin = require('extract-text-webpack-plugin');</span><span id="1442" class="lv lw iq lr b gy nr ly l lz ma">module.exports = {<br/>    entry: "./index.js",<br/>    output: {<br/>        filename: 'bundle.js',<br/>        path: path.resolve(__dirname, 'public')<br/>    },<br/>    context: path.resolve(__dirname, 'src'),<br/>    devServer: {<br/>        contentBase: path.resolve(__dirname, 'public/assets'),<br/>        stats: 'errors-only',<br/>        open: true,<br/>        port: 8080,<br/>        compress: true<br/>    },<br/>    plugins: [<br/>     new CleanWebpackPlugin(['public']),<br/>        new HtmlWebpackPlugin({<br/>            template: 'index.html'<br/>        }),<br/>        // NEW LINE<br/>        new ExtractTextPlugin({<br/>         filename: './style.css'<br/>        })<br/>    ],<br/>    module: {<br/>        rules: [{<br/>            test: /\.(jpg|png|gif|svg)$/,<br/>            use: [<br/>            {<br/>                loader: 'file-loader',<br/>                options: {<br/>                    name: '[name].[ext]',<br/>                    outputPath: './assets/',<br/>                }<br/>            }]<br/>        }, {<br/>         test: /\.css$/,<br/>         use: ["style-loader", "css-loader"]<br/>        }]<br/>    }<br/>}</span></pre><p id="1854" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，我们导入了插件，并将其添加到插件数组中，指定了输出文件，然后我们运行<code class="fe mb mc md lr b">npm run build</code>。恐怖的是，public/ folder中没有css文件。我们实际上需要一个加载器来告诉webpack它的文件进入了插件，所以我们将稍微重写一下配置。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="2310" class="lv lw iq lr b gy lx ly l lz ma">const path = require('path');</span><span id="8488" class="lv lw iq lr b gy nr ly l lz ma">const CleanWebpackPlugin = require('clean-webpack-plugin');<br/>const HtmlWebpackPlugin = require('html-webpack-plugin');<br/>const ExtractTextPlugin = require('extract-text-webpack-plugin');<br/>// WE MOVED THE INSTANCE HERE, SO WE CAN USE IT<br/>const extractPlugin = new ExtractTextPlugin({<br/>    filename: './style.css'<br/>});</span><span id="2a9b" class="lv lw iq lr b gy nr ly l lz ma">module.exports = {<br/>    entry: "./index.js",<br/>    output: {<br/>        filename: 'bundle.js',<br/>        path: path.resolve(__dirname, 'public')<br/>    },<br/>    context: path.resolve(__dirname, 'src'),<br/>    devServer: {<br/>        contentBase: path.resolve(__dirname, 'public/assets'),<br/>        stats: 'errors-only',<br/>        open: true,<br/>        port: 8080,<br/>        compress: true<br/>    },<br/>    plugins: [<br/>        new CleanWebpackPlugin(['public']),<br/>        new HtmlWebpackPlugin({<br/>            template: 'index.html'<br/>        }),<br/>        // WE JUST PASS IT HERE<br/>        extractPlugin<br/>    ],<br/>    module: {<br/>        rules: [{<br/>            test: /\.(jpg|png|gif|svg)$/,<br/>            use: [<br/>            {<br/>                loader: 'file-loader',<br/>                options: {<br/>                    name: '[name].[ext]',<br/>                    outputPath: './assets/',<br/>                }<br/>            }]<br/>        }, {<br/>            test: /\.css$/,<br/>            // AND WE USE IT HERE<br/>            use: extractPlugin.extract({<br/>             use: ["css-loader"],<br/>             fallback: 'style-loader'<br/>            })<br/>        }]<br/>    }<br/>}</span></pre><p id="d407" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们首先实例化了插件，这意味着如果需要，我们可以在其他地方使用另一个实例。请注意加载器中的配置:我们只使用css加载器，但是样式加载器只是一个后备，这很好。运行<code class="fe mb mc md lr b">npm run build</code>并检查公共/文件夹。现在我们的style.css文件就在那里，它在index.html文件中为我们链接。全部完成:d。</p><h2 id="9d2d" class="lv lw iq bd mf ng nh dn mj ni nj dp mn kj nk nl mr kn nm nn mv kr no np mz nq bi translated">一些额外的CSS东西</h2><p id="de3b" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">让我们为css添加两个更好的加载器:scss和postcss。您可以了解它们并利用它们的优势，但是让我们快速安装这些东西</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="5232" class="lv lw iq lr b gy lx ly l lz ma">npm i -D postcss-loader sass-loader node-sass autoprefixer cssnano postcss-import postcss-cssnext</span></pre><p id="4c33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用。scss扩展名，因此将main.css重命名为main.scss，并更改index.js中的import命令以匹配更改后的名称。在主文件夹(webpack.config.js所在的位置)中创建一个postcss.config.js文件，并将它放入</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="05e0" class="lv lw iq lr b gy lx ly l lz ma">module.exports = {<br/>  plugins: {<br/>    'autoprefixer': {},<br/>    'cssnano': {},<br/>    'postcss-import': {},<br/>    'postcss-cssnext': {}<br/>  }<br/>}</span></pre><p id="24d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们定义了postcss要使用的插件。这里最重要的是autoprefixer，它会在需要的地方自动添加供应商前缀，比如webkit和moz。</p><p id="910f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在将这两个加载器添加到我们的webpack配置中，与css-loader放在一起:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="a665" class="lv lw iq lr b gy lx ly l lz ma">use: ["css-loader", "sass-loader", "postcss-loader"],</span></pre><p id="31e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而且我们可以随意运行测试:)</p><h2 id="3eef" class="lv lw iq bd mf ng nh dn mj ni nj dp mn kj nk nl mr kn nm nn mv kr no np mz nq bi translated">JS的东西</h2><p id="8834" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">本文的最后一部分太长了，src/ folder的设置将在下一篇文章中介绍。</p><p id="1f1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们想要现代的js语法、react和所有那些花哨的东西。为此我们需要巴贝尔。Babel就像一个加载器(出于webpack的目的，但官方上它是一个transpiler)。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="7aff" class="lv lw iq lr b gy lx ly l lz ma">npm i -D babel-core babel-loader</span></pre><p id="fb5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们添加一个新规则来通过所有。js文件到babel-loader</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="5c65" class="lv lw iq lr b gy lx ly l lz ma">{<br/>    test: /\.js$/,<br/>    use: {<br/>        loader: 'babel-loader',<br/>        options: {<br/>          presets: []<br/>        }<br/>    }<br/>}</span></pre><p id="b476" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在options prop中，我们需要定义我们希望使用的预置。预设是一组“将这个转换为那个”的规则，因此我们可以选择我们需要的规则。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="bda4" class="lv lw iq lr b gy lx ly l lz ma">npm i -D babel-polyfill babel-preset-env babel-preset-react babel-preset-stage-0</span></pre><p id="43f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在某些浏览器中，需要polyfill预置来处理缺失的承诺，我们需要将它导入index.js文件以使其工作。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="f1e7" class="lv lw iq lr b gy lx ly l lz ma">import "babel-polyfill";</span></pre><p id="1861" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其他的我们将作为预置加载到webpack.config.js中</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="4553" class="lv lw iq lr b gy lx ly l lz ma">presets: ['env', 'stage-0', 'react']</span></pre><p id="9c6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下一篇文章中，您将看到我们如何从这些预置中获益。</p><p id="97ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">点击<a class="ae lg" href="https://medium.com/@bojanaleksa/fast-and-modern-front-end-setup-with-webpack-react-redux-router-saga-and-postcss-part-2-9ae7ad4e7cb2" rel="noopener">此处</a>进入第二部分。</p><p id="fc31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望你喜欢你所读的，请留下一些反馈，并为:D·:D·:D鼓掌</p></div></div>    
</body>
</html>