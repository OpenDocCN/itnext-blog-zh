<html>
<head>
<title>Intro to Docker — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker简介—第1部分</h1>
<blockquote>原文：<a href="https://itnext.io/intro-to-docker-part-1-5b1162c81735?source=collection_archive---------1-----------------------#2020-11-10">https://itnext.io/intro-to-docker-part-1-5b1162c81735?source=collection_archive---------1-----------------------#2020-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a9c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">docker容器快速介绍</p><p id="44ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个简短的Docker教程。</p><h1 id="7a3a" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">目标</h1><p id="50b8" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">快速学习Docker概念，而不会迷失在微小的细节中。提供使用Docker创建和运行您的第一个容器化应用程序所需的工具，使您能够在需要时自己寻找更多。</p><h1 id="6d62" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">先决条件</h1><p id="451a" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">不是这样的。只需从<a class="ae lo" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">这里</a>安装Docker</p><h1 id="6f24" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">基本概念</h1><blockquote class="lp lq lr"><p id="e93c" class="jn jo ls jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated">一个<strong class="jp ir"> <em class="iq">容器</em> </strong>是我们最终想要用Docker引擎运行和托管的。</p></blockquote><p id="8865" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从概念的角度来看，<em class="ls">容器</em>运行在<strong class="jp ir"> Docker主机</strong>内部，与其他容器甚至主机操作系统隔离。它看不到其他容器、物理存储或获取传入连接，除非您明确声明它可以。</p><p id="23ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里需要注意的是，Linux内核是与操作系统和所有其他容器共享的。<em class="ls">主机</em>可以看到/操纵容器中的一切；进程、文件系统等。</p><p id="e1de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PS:- Docker与虚拟机有很大不同，一些细节在这里<a class="ae lo" href="http://www.munzandmore.com/2015/cc/docker-container-vs-virtualization" rel="noopener ugc nofollow" target="_blank">相同</a></p><p id="9443" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">典型的Docker服务器看起来像这样——许多容器的主机:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lw"><img src="../Images/2bb2e59699fe83c7749ab1359795dfd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kZS238OktwTXewxs"/></div></div></figure><blockquote class="lp lq lr"><p id="871b" class="jn jo ls jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated">任何运行的容器都是从一个<strong class="jp ir"> <em class="iq">图像</em> </strong>中创建的。图像描述了创建容器所需的一切；它是容器的模板。您可以根据需要从单个图像创建任意多个容器。</p></blockquote><p id="8e7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图像存储在<strong class="jp ir">注册表中；注册表 </strong> <em class="ls">针对图像管理进行了优化。</em></p><blockquote class="lp lq lr"><p id="5589" class="jn jo ls jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated">Dockerfile 是一个文本文档，它包含用户可以在命令行上调用的所有命令来组合一个图像</p></blockquote><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mi"><img src="../Images/7d9bb36784a4b796ea6fc5f070d55925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vb_5008Zbt_pHj7qx44p0Q.png"/></div></div></figure><p id="7ca6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将详细研究所有这些内容——需要抓住三个重要概念，即Dockerfile、Docker image和Docker container。我们继续吧。</p><h1 id="3f36" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">一些容器概念</h1><p id="99c7" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">强烈建议您在命令行终端上尝试这些命令。</p><blockquote class="lp lq lr"><p id="1c9e" class="jn jo ls jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated">问:当我们跑步时会发生什么</p></blockquote><pre class="lx ly lz ma gt mj mk ml mm aw mn bi"><span id="0140" class="mo km iq mk b gy mp mq l mr ms">docker run hello-world</span></pre><ol class=""><li id="2d0b" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">您的命令要求Docker基于<em class="ls"> hello-world </em>映像<strong class="jp ir">创建并运行一个容器</strong>。</li><li id="d884" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">由于<em class="ls"> hello-world </em>镜像还没有出现在你的磁盘上，Docker <strong class="jp ir">从默认注册表</strong>、Docker Hub 下载了它。</li><li id="cbe3" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">Docker <strong class="jp ir">基于<em class="ls"> hello-world </em>映像创建了一个容器</strong>。</li><li id="61b3" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated"><strong class="jp ir"> <em class="ls"> hello-world </em>图像声明</strong>当启动时，它应该向控制台输出一些文本，所以这是您在容器运行时看到的文本。</li><li id="8a74" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated"><strong class="jp ir">容器停止</strong>。</li></ol><p id="c751" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您重新运行相同的命令，您将会看到除了步骤2之外，上述所有步骤都在重复；这是因为映像不需要下载，因为它在您第一次运行该命令时就已经存在于您的计算机上了。自己尝试一下，验证上面的话是否正确。</p><h1 id="521d" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">问:容器管理的一些基本命令？</h1><blockquote class="lp lq lr"><p id="016d" class="jn jo ls jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated">码头运行—帮助</p></blockquote><p id="f944" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用以下命令进行容器管理:</p><blockquote class="lp lq lr"><p id="154f" class="jn jo ls jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq"> docker ps </em> </strong>:列出仍在运行的容器。添加<strong class="jp ir"> -a </strong>开关，以便查看已经停止的集装箱</p><p id="a44e" class="jn jo ls jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq"> docker日志</em> </strong>:即使容器已经停止，也可以检索容器的日志</p><p id="c535" class="jn jo ls jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated"><strong class="jp ir"><em class="iq"/></strong>:获取正在运行或停止的集装箱的详细信息</p><p id="256a" class="jn jo ls jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">停靠站</em> </strong>:删除一个仍在运行的集装箱</p><p id="f42d" class="jn jo ls jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq"> docker rm </em> </strong>:删除一个容器</p></blockquote><h1 id="3594" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">问:验尸检查？</h1><p id="2497" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">让我们研究一下hello-world容器上的一些容器管理命令。</p><p id="a643" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">获取所有正在运行的容器</strong></p><p id="a4cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nh ni nj mk b">docker ps</code></p><p id="a6b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">获取所有容器</strong></p><p id="170e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nh ni nj mk b">docker ps -a</code></p><pre class="lx ly lz ma gt mj mk ml mm aw mn bi"><span id="f4a9" class="mo km iq mk b gy mp mq l mr ms">CONTAINER ID        IMAGE                        COMMAND                  CREATED             STATUS                      PORTS                    NAMES</span><span id="18c1" class="mo km iq mk b gy nk mq l mr ms">33f2ca665467        hello-world                  "/hello"                 14 seconds ago      Exited (0) 12 seconds ago                            dazzling_morse</span></pre><p id="1a0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">获取容器日志</strong></p><pre class="lx ly lz ma gt mj mk ml mm aw mn bi"><span id="486d" class="mo km iq mk b gy mp mq l mr ms">docker logs 33f2ca665467`</span></pre><p id="4477" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">获取集装箱信息</strong></p><pre class="lx ly lz ma gt mj mk ml mm aw mn bi"><span id="21a9" class="mo km iq mk b gy mp mq l mr ms">docker inspect 33f2ca665467</span></pre><p id="1fa0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">移除容器</strong></p><pre class="lx ly lz ma gt mj mk ml mm aw mn bi"><span id="f962" class="mo km iq mk b gy mp mq l mr ms">docker rm 33f2ca665467</span></pre><p id="eed6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">立即尝试日志和检查命令；码头工人不再知道这个集装箱了。</p><h1 id="953d" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">码头运行(短寿命容器)？</h1><p id="3da0" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">你可以把<strong class="jp ir"> <em class="ls"> docker run </em>命令</strong>想象成相当于买了一台新电脑，在上面执行一些命令，然后把它扔掉。每次从一个映像创建一个容器时，您都会得到一个新的隔离的原始环境，可以在该容器中进行操作。</p><p id="24e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您在容器中获得的内容取决于您的容器基于哪个图像。在图像名称之后，您可以在容器内部传递想要执行的命令。</p><pre class="lx ly lz ma gt mj mk ml mm aw mn bi"><span id="73d7" class="mo km iq mk b gy mp mq l mr ms">docker run alpine printenv</span></pre><p id="3ae4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们基本上要求使用<em class="ls"> alpine </em>映像创建一个容器，并要求该容器执行<em class="ls"> printenv </em>命令，这是打包在<em class="ls"> alpine </em>映像中的二进制程序之一。</p><p id="7852" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">毫不奇怪，<em class="ls"> alpine </em>映像被下载来创建容器，因为它还不在我的磁盘上。</p><p id="3f8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PS:-如果能理解Docker是一个让你获得相当于一次性、一次性使用的计算机的工具，那就太好了。一旦清楚了这一点，一个全新的世界就为你打开了。你来自这样一个世界，在那里获得一台新机器并对其进行配置需要足够的努力来证明保留它是正确的，尽管每次后续使用都会带来副作用。在容器世界中，获得一个全新的环境足够便宜，可以获得许多这样的环境。</p><h1 id="f5cc" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">问:如何清理/删除容器？</h1><blockquote class="lp lq lr"><p id="5011" class="jn jo ls jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated"><strong class="jp ir">有多种方式，其中一种方式使用</strong></p></blockquote><pre class="lx ly lz ma gt mj mk ml mm aw mn bi"><span id="2f43" class="mo km iq mk b gy mp mq l mr ms">docker container prune -f</span></pre><p id="4cc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这相当于为每个停止的集装箱运行一个<em class="ls"> docker rm </em>命令。<em class="ls"> -f </em>开关是一个隐含的确认，表示立即继续并删除所有停止的集装箱，而不是要求确认该操作。</p><h1 id="f863" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">码头运行(长寿命容器)？</h1><p id="cec5" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我们刚刚看到了如何运行短命容器。它们通常会进行一些处理并显示一些输出。然而，长期容器有一个广泛的用途:服务器容器。无论您想要托管web应用程序、API还是数据库，您都需要一个监听传入的网络连接并且可能是长寿命的容器。</p><p id="c90f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，服务器容器</p><ul class=""><li id="72c4" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk nl mz na nb bi translated">是长寿的</li><li id="04f4" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nl mz na nb bi translated">侦听传入的网络连接</li></ul><p id="511c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们试着跑同样的路。</p><pre class="lx ly lz ma gt mj mk ml mm aw mn bi"><span id="1cb9" class="mo km iq mk b gy mp mq l mr ms">docker run alpine ping <a class="ae lo" href="http://www.docker.com" rel="noopener ugc nofollow" target="_blank">www.docker.com</a></span></pre><p id="631c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们尝试pinging相同的</p><pre class="lx ly lz ma gt mj mk ml mm aw mn bi"><span id="790f" class="mo km iq mk b gy mp mq l mr ms">docker run -d alpine ping <a class="ae lo" href="http://www.docker.com" rel="noopener ugc nofollow" target="_blank">www.docker.com</a></span></pre><p id="a5c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们列出所有正在运行的容器</p><pre class="lx ly lz ma gt mj mk ml mm aw mn bi"><span id="bdc5" class="mo km iq mk b gy mp mq l mr ms">docker ps -a</span></pre><p id="5e1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们尝试获取日志；这是调试任何容器的最佳方式</p><pre class="lx ly lz ma gt mj mk ml mm aw mn bi"><span id="a541" class="mo km iq mk b gy mp mq l mr ms">docker logs &lt;container_id&gt;</span><span id="5558" class="mo km iq mk b gy nk mq l mr ms">docker logs — since 10s</span></pre><p id="91fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">监听传入的网络连接</strong></p><p id="0e4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，容器是独立运行的，因此，它不会在运行它的机器上监听传入的连接。您必须在主机上显式打开一个端口，并将其映射到容器上的一个端口。</p><h1 id="3262" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">锻炼</h1><blockquote class="lp lq lr"><p id="a92f" class="jn jo ls jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated">假设我们想运行NGINX web服务器，默认情况下，它在端口80监听传入的HTTP请求。如果我们只是运行服务器，我们的机器不会将传入的请求路由到它，除非我们在<em class="iq"> docker run </em>命令上使用<em class="iq"> -p </em>开关。</p></blockquote><p id="9700" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">停在这里，在查看解决方案之前自己尝试一下</strong></p><p id="4601" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解决方案</strong></p><p id="0738" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ls"> -p </em>开关带两个参数；您希望在主机上打开的传入端口，以及它应该在容器内映射到的端口。例如，下面是我如何声明我希望我的机器监听端口8085上的传入连接，并将它们路由到运行NGINX的容器内的端口80:</p><pre class="lx ly lz ma gt mj mk ml mm aw mn bi"><span id="346b" class="mo km iq mk b gy mp mq l mr ms">docker run -d -p 8085:80 nginx</span></pre><p id="26e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用以下方式到达服务</p><pre class="lx ly lz ma gt mj mk ml mm aw mn bi"><span id="b20a" class="mo km iq mk b gy mp mq l mr ms"><em class="ls">http://localhost:8085</em></span></pre><p id="f9db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为该容器在后台运行，所以它的输出不会显示在我的终端上。但是，我们可以使用</p><pre class="lx ly lz ma gt mj mk ml mm aw mn bi"><span id="392e" class="mo km iq mk b gy mp mq l mr ms"><em class="ls">docker logs</em> &lt;container_id&gt;</span></pre><p id="072e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们停下来，把容器拿走。</p><pre class="lx ly lz ma gt mj mk ml mm aw mn bi"><span id="46b9" class="mo km iq mk b gy mp mq l mr ms">docker stop</span><span id="e0ce" class="mo km iq mk b gy nk mq l mr ms">docker rm</span></pre><p id="2474" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您是否注意到我们现在拥有了相当于全新服务器的产品？这意味着我们可以在上面安装任何我们想安装的东西，也可以随时丢弃它。</p><p id="eb30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">容器允许我们在不污染机器的情况下使用任何软件。通常，在你的机器上尝试一个新的软件之前，你会犹豫不决，因为如果你改变主意并卸载主软件，安装的几个依赖项可能会干扰现有的软件。多亏了容器，我们甚至可以在不污染我的机器的情况下尝试大块的服务器软件。</p><h1 id="a0a4" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">问:设置Jenkins需要多长时间？</h1><p id="31ac" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">Jenkins有像java和其他的依赖，这可能很难管理；Docker让它变得非常简单。</p><pre class="lx ly lz ma gt mj mk ml mm aw mn bi"><span id="6345" class="mo km iq mk b gy mp mq l mr ms">docker run -p 8088:8080 jenkins</span><span id="22b6" class="mo km iq mk b gy nk mq l mr ms"><a class="ae lo" href="http://localhost:8088" rel="noopener ugc nofollow" target="_blank">http://localhost:8088</a></span></pre><p id="fb2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将继续这个系列来研究Docker及其相关编排的更多概念。</p></div></div>    
</body>
</html>