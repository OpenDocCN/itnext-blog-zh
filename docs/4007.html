<html>
<head>
<title>Under-the-hood of web bundlers (e.g. Webpack)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">网络捆扎机的内部(例如网络包)</h1>
<blockquote>原文：<a href="https://itnext.io/under-the-hood-of-web-bundlers-e-g-webpack-926e868f7f5e?source=collection_archive---------1-----------------------#2020-04-09">https://itnext.io/under-the-hood-of-web-bundlers-e-g-webpack-926e868f7f5e?source=collection_archive---------1-----------------------#2020-04-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/1354e8830722ece6bb1a6e0c5a8b4d51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*e9EgvrwuUiwH5aj2HgYgcg.png"/></div></figure><p id="3a04" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对于大多数开发人员来说，Webpack有点像一个黑匣子。像“<a class="ae kv" href="https://create-react-app.dev/docs/getting-started/" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>”这样的工具抽象出了大部分的捆绑器功能。我对此做了一些研究，并开始构建我自己的轻量级web bundler，以更多地了解它需要什么。</p><p id="be36" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是我的“引擎盖下”系列的一部分:</p><ul class=""><li id="7252" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated"><a class="ae kv" href="https://craigtaub.dev/under-the-hood-of-type-systems" rel="noopener ugc nofollow" target="_blank">类型系统(如TypeScript) </a></li><li id="bb14" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated"><a class="ae kv" href="https://craigtaub.dev/under-the-hood-of-test-runners" rel="noopener ugc nofollow" target="_blank">试跑者(如摩卡)</a></li><li id="afc0" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated"><a class="ae kv" href="https://craigtaub.dev/under-the-hood-of-vscode-auto-formatters" rel="noopener ugc nofollow" target="_blank"> VSCode自动格式化程序(例如更漂亮)</a></li><li id="c946" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated"><a class="ae kv" href="https://craigtaub.dev/source-maps-from-top-to-bottom" rel="noopener ugc nofollow" target="_blank">来源图</a></li><li id="1fe0" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated"><a class="ae kv" href="https://craigtaub.dev/under-the-hood-of-react-hooks" rel="noopener ugc nofollow" target="_blank">反应钩</a></li><li id="6745" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/under-the-hood-of-apollo-6d8642066b28">阿波罗</a></li></ul><p id="70f7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这篇文章的完整视频可以在<a class="ae kv" href="https://www.youtube.com/watch?v=JAY10_75vFw" rel="noopener ugc nofollow" target="_blank">这里</a>找到。我的“<a class="ae kv" href="https://www.youtube.com/channel/UCYi23MnKBKn0yLZKBrz5Bfw" rel="noopener ugc nofollow" target="_blank"><em class="lk"/></a>”系列视频的一部分。</p><p id="3dba" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">本文分为三个部分:</p><ol class=""><li id="63e7" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku ll lc ld le bi translated">什么是“网络捆绑器”</li><li id="392e" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku ll lc ld le bi translated">为“网络捆绑器”构建编译器</li><li id="3341" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku ll lc ld le bi translated">在应用程序中使用输出</li></ol></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="adb5" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">1.什么是“网络捆绑器”</h1><p id="9d2d" class="pw-post-body-paragraph jx jy it jz b ka mr kc kd ke ms kg kh ki mt kk kl km mu ko kp kq mv ks kt ku im bi translated">我们应该首先问一个问题“现在是2020年，为什么要捆绑销售？”。这个问题有很多答案:</p><ul class=""><li id="481c" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated">性能:第三方代码是昂贵的，我们可以使用静态代码分析来优化它(如樱桃采摘和摇树)。我们还可以通过将100个文件变成1个来简化发货，从而限制用户的数据和资源支出</li><li id="63b5" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">支持:web有如此多不同的环境，您希望您的代码在尽可能多的环境中运行，同时只编写一次(例如，在必要的地方添加Polyfills)</li><li id="775c" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">用户体验:利用单独捆绑包的浏览器缓存(例如，所有库的供应商和应用本身的应用)</li><li id="0cb4" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">单独关注:管理你如何提供字体，css，图像以及JS。</li></ul><p id="57c1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">网络捆绑器的基本架构是:</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mw"><img src="../Images/4793bb4f8213f429ab9886fc4d7de720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CqJSURNM8ou7rWIl-Eb1YQ.png"/></div></div></figure><p id="f476" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">基本上，我们将模块通过编译器生成资产。</p><p id="dc5e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">编译器涉及到很多概念。这是我觉得这是一个如此有趣的话题的原因之一，因为在如此小的空间里却有如此多的东西。</p><p id="8b14" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这些概念是:</p><ul class=""><li id="6489" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated">生活</li><li id="4313" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">通过引用传递</li><li id="aa5a" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">依赖图(当我们遍历应用程序文件时)</li><li id="850a" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">定义自定义导入/导出系统(可以在任何环境下运行)</li><li id="dd49" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">递归函数</li><li id="8746" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">AST解析和生成(将源代码转换成其标记化的形式)</li><li id="2dbd" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">散列法</li><li id="85bf" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">本机ESM(由于其编译时检查，ESM可以很好地管理循环依赖关系)</li></ul><p id="ef64" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们将忽略编译器中的非js资产；所以没有字体，css或图像。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="3605" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">2.为“网络捆绑器”构建编译器</h1><p id="9593" class="pw-post-body-paragraph jx jy it jz b ka mr kc kd ke ms kg kh ki mt kk kl km mu ko kp kq mv ks kt ku im bi translated">这将是对Webpack如何工作的一个巨大的简化，因为有许多不同的方法来解决这个问题，希望这种方法将提供一些有关机制的见解。</p><p id="bc10" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">下面是编译器的概述，我们将分解每个阶段。</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nf"><img src="../Images/809657290468441cc98d4840ad7e4f72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c0lErXnjoERaKBJRdpmLfg.png"/></div></div></figure><p id="fdef" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们的应用:</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi ng"><img src="../Images/4957f4efc48b37236346ba38e28de5df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WqBpreSB-H1N1JRa4MGkzg.png"/></div></div></figure><p id="111f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们的应用程序由4个文件组成。它的工作是获取日期时间，然后将其传递给logDate，后者的工作是向日期添加文本并将其发送给记录器。这很简单。</p><p id="34ff" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们的应用程序树是这样的:</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/bcc15947f21146eceb66bdc8660652fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*JMRtfpUYuocDE-wzzOUMkA.png"/></div></figure><h2 id="b574" class="ni lu it bd lv nj nk dn lz nl nm dp md ki nn no mh km np nq ml kq nr ns mp nt bi translated"><strong class="ak">第一阶段</strong></h2><p id="200a" class="pw-post-body-paragraph jx jy it jz b ka mr kc kd ke ms kg kh ki mt kk kl km mu ko kp kq mv ks kt ku im bi translated">使用第三方工具进行AST解析我们(参见下面的代码):</p><ul class=""><li id="7391" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated">确定文件的完整路径(这非常重要，所以如果我们再次处理同一个文件，就很清楚了)</li><li id="70c1" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">抓取文件内容</li><li id="8371" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">解析成AST</li><li id="e6ce" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">将内容和AST存储到一个“模块”对象上。</li><li id="fff4" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">处理内容内部的依赖关系(使用AST“import declaration”值)，用值递归调用此函数</li><li id="8790" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">最后，将该函数添加到depsArray中，这样我们就可以用最后出现的第一个文件来构建我们的树(这很重要)</li></ul><figure class="mx my mz na gt ju gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/60b880f8d5308ccf05063f7e49a05489.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/0*PbT2RjdtyPH5ABT2"/></div></figure><p id="6125" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">所以我们的树现在看起来像右下方的数组:</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nv"><img src="../Images/b5ebd23ddda0651a94430ad76e11e56a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eirqP1FjgqydqGuY0scr_w.png"/></div></div></figure><h2 id="d887" class="ni lu it bd lv nj nk dn lz nl nm dp md ki nn no mh km np nq ml kq nr ns mp nt bi translated">第二相</h2><p id="7335" class="pw-post-body-paragraph jx jy it jz b ka mr kc kd ke ms kg kh ki mt kk kl km mu ko kp kq mv ks kt ku im bi translated">编译器的工作是“<em class="lk">执行代码，从而产生可执行代码”。</em>这意味着我们将有两级代码，所以我们将一次审查一级。首先我们将回顾编译器构建了什么，然后回顾构建/输出的代码(由浏览器运行)。</p><h2 id="3170" class="ni lu it bd lv nj nk dn lz nl nm dp md ki nn no mh km np nq ml kq nr ns mp nt bi translated">首先是构建的代码</h2><p id="2e78" class="pw-post-body-paragraph jx jy it jz b ka mr kc kd ke ms kg kh ki mt kk kl km mu ko kp kq mv ks kt ku im bi translated"><strong class="jz iu">模板:</strong></p><p id="597b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">模块模板:它的工作是将给定的模块转换成我们的编译器可以使用的模块。</p><p id="0bfa" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们交给它模块代码和一个索引(Webpack也用索引来做这件事)。</p><p id="eebe" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们希望代码在尽可能多的环境中兼容。ES6模块本身支持严格模式，但是ES5模块不支持，所以我们在模块模板中明确定义了严格模式。</p><p id="3840" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在NodeJS中，所有ES模块都在内部封装在一个附加运行时细节的函数中(即导出)，这里我们使用的是相同的。Webpack也是这样做的。</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nw"><img src="../Images/b81e3aedf8fc0ab47a3189989d889503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Wze4oZQ1XsiT0-BS"/></div></div></figure><p id="ea54" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">运行时模板:它的工作是加载我们的模块，并给出启动模块的id。</p><p id="e6d1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一旦我们有了其中的模块代码，我们将在后面对此进行更多的回顾。</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nx"><img src="../Images/3c714e50227725148b53a9484fa4d503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tL3QlvqlwGuW37u-"/></div></div></figure><p id="ad41" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">自定义导入/导出:</strong></p><p id="3c4b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对于我们的import语句，我们将用自己的语句替换“importing”实例。它看起来像中间的注释。</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi ny"><img src="../Images/61227c2feb9232646ed0139862818a2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cidvLoIbuc7wUfPu"/></div></div></figure><p id="5c24" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们的导出将做一些类似于导入的事情，除了用我们自己的替换任何“导出”。参见底部注释。</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nz"><img src="../Images/db1cc8e666d7a536bb5a72cef71a652a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x6f2wex8JX_lsPM9"/></div></div></figure><p id="ebb6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">值得注意的是，Webpack在前面存储了模块的依赖id。它有自己的“依赖模板”，用自定义变量替换导入和导出的用法。我的交换只是进口本身(他们的交换整个系列和它的所有用法)。与真正的Webpack不完全相同的许多东西之一。</p><p id="2aa3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">变换</strong></p><p id="321c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们的转换函数遍历依赖关系。用我们自己的替换它找到的每个导入和导出。然后将AST转换回源代码并构建一个模块字符串。最后，我们将所有的模块字符串连接在一起，并将它们传递给运行时模板，并给出依赖数组中最后一项的索引位置，因为这是我们的“<strong class="jz iu">入口点</strong>”。</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi oa"><img src="../Images/d5750ce978050ad0260aef1bbfcb1b57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fnU49iT-chYebSfN"/></div></div></figure><h2 id="38f4" class="ni lu it bd lv nj nk dn lz nl nm dp md ki nn no mh km np nq ml kq nr ns mp nt bi translated">现在编译器输出的代码是:</h2><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi ob"><img src="../Images/a478b5b127ec4fe94aa28533e91cb250.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q7bEwg2P8DBr-_TQ4TqYcA.png"/></div></div></figure><p id="55da" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">左手边是我们的运行时，右手边显示所有被加载的“模块”。你可以看到它们是我们开始时使用的模块。</p><p id="76ac" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">到底是怎么回事？</strong></p><p id="4126" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">运行时模板IIFE立即运行，将模块数组作为一个参数。我们定义一个缓存(<em class="lk"> installedModules </em>)和我们的导入函数(<em class="lk"> _our_require_ </em>)。它的工作是执行模块运行时，并返回给定模块ID(ID与它在模块数组中的位置相关)的导出。利用传递引用在父模块上设置导出，然后将模块存储在缓存中以便于重用..最后，我们为入口点执行导入功能，这将启动应用程序，因为它不需要调用导出本身。我们模块中的所有导入都将使用我们的自定义方法。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="43b6" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">3.在应用程序中使用输出</h1><p id="dcc3" class="pw-post-body-paragraph jx jy it jz b ka mr kc kd ke ms kg kh ki mt kk kl km mu ko kp kq mv ks kt ku im bi translated">现在我们有了一个更新的“vendorString”我们想用它(上面的代码)。所以我们:</p><ol class=""><li id="cade" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku ll lc ld le bi translated">创建内容的散列，该散列将在包文件名中使用并存储在清单中</li><li id="8496" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku ll lc ld le bi translated">将vendorString写入我们的新包</li></ol><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi oc"><img src="../Images/b66f08495bf78cbe2344f023db828311.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fodDSUdKu16LkOzo"/></div></div></figure><p id="1f82" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最后，我们运行一个小型的express服务器应用程序，它从清单中提取包名，并在/static路径下公开构建的代码(/build)。</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi od"><img src="../Images/72cd7322d35b37262610f55c3aaa2f0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2j_1-nkOymApxzvf"/></div></div></figure><p id="4aa4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果我们现在跑:</p><p id="771f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="lk"> &gt; npm运行编译</em></p><p id="b18d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="lk"> &gt; npm运行开始</em></p><p id="921f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们的应用程序将运行，我们可以在“network”选项卡中看到我们的包及其内容。</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi oe"><img src="../Images/5ca82c26818846b0f0cefa7c99f04482.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Lp7LK1W3hy_bSVAL"/></div></div></figure><p id="4db0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最后，我们可以通过检查“控制台”来确认它是否工作。好运👍</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi of"><img src="../Images/bb27e7010c051712dc7af482b405c614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hjabS5Y9IkUwK7mb"/></div></div></figure></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="f689" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">未覆盖</h1><p id="a438" class="pw-post-body-paragraph jx jy it jz b ka mr kc kd ke ms kg kh ki mt kk kl km mu ko kp kq mv ks kt ku im bi translated">你可能想知道“那么Webpack还有什么是我们没有的呢？”</p><ul class=""><li id="5518" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated">处理非js资产(CSS/图像/字体)</li><li id="2e49" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">戴夫和HMR:这是内置在网络包</li><li id="8ee7" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">Chunks: Webpack可以将不同的模块放入不同的Chunks中，如果需要的话，每个模块可以有稍微不同的运行时和polyfills。即供应商、动态导入</li><li id="9ede" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">多出口:我们的可以做到这一点，但需要对模块类型进行防御检查，所以不值得这么麻烦。</li><li id="9c96" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">进一步优化(例如缩小/代码分割/摘樱桃/摇树/聚合填充)</li><li id="3901" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">源地图:Webpack混合使用预处理器，它们都生成自己的地图。Webpack设法将它们合并在一起。</li><li id="e7e8" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">使其可扩展或可配置(例如加载程序、插件或生命周期)。即使在内部，Webpack也有80%是插件，即编译器在生命周期事件(例如“预处理文件”)上触发钩子，加载器监听该事件并在适当的时候运行。此外，我们可以扩展我们的编译器来支持生命周期事件，也许可以使用<a class="ae kv" href="https://nodejs.org/api/events.html" rel="noopener ugc nofollow" target="_blank"> NodeJS事件发射器</a>，但是同样不值得这么麻烦。</li></ul></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="aa76" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated"><strong class="ak">就是这样</strong></h1><p id="4caf" class="pw-post-body-paragraph jx jy it jz b ka mr kc kd ke ms kg kh ki mt kk kl km mu ko kp kq mv ks kt ku im bi translated">我希望这对你有用，因为我从中学到了很多。有兴趣的人可以在https://github.com/craigtaub/our-own-webpack的<a class="ae kv" href="https://github.com/craigtaub/our-own-webpack" rel="noopener ugc nofollow" target="_blank">找到一个仓库</a></p><p id="43cc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">谢谢，克雷格😃</p></div></div>    
</body>
</html>