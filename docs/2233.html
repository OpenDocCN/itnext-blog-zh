<html>
<head>
<title>Golang: pointers — detailed overview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang:指针—详细概述</h1>
<blockquote>原文：<a href="https://itnext.io/golang-pointers-detailed-overview-1dd595ca14fc?source=collection_archive---------1-----------------------#2019-04-20">https://itnext.io/golang-pointers-detailed-overview-1dd595ca14fc?source=collection_archive---------1-----------------------#2019-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/294b34ba4ac1ac3de5313ac44c79f348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pT5NLaclavnZQKhiQ_zcqA.png"/></div></div></figure><p id="ceeb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">什么是<em class="kw">指针</em>？</p><p id="6d6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简而言之，指针是一个变量，它存储另一个变量的地址，在那里存储一些数据。</p><ul class=""><li id="fd8a" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><a class="ae lg" href="#28d6" rel="noopener ugc nofollow">指针示例</a></li><li id="36ba" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv lc ld le lf bi translated"><a class="ae lg" href="#6cce" rel="noopener ugc nofollow"> *和&amp;操作员</a></li><li id="c0de" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv lc ld le lf bi translated"><a class="ae lg" href="#5e48" rel="noopener ugc nofollow">新的()函数</a></li><li id="f28b" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv lc ld le lf bi translated"><a class="ae lg" href="#4b41" rel="noopener ugc nofollow">改变指针的值</a></li><li id="5109" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv lc ld le lf bi translated"><a class="ae lg" href="#f9b1" rel="noopener ugc nofollow">将指针作为函数的参数传递</a></li><li id="8f88" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv lc ld le lf bi translated"><a class="ae lg" href="#80aa" rel="noopener ugc nofollow">函数:通过值和引用传递参数</a></li></ul><h2 id="28d6" class="lm ln iq bd lo lp lq dn lr ls lt dp lu kj lv lw lx kn ly lz ma kr mb mc md me bi translated">指针示例</h2><p id="b40a" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">让我们举一个使用指针的最简单的例子:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="3a10" class="lm ln iq mp b gy mt mu l mv mw">package main<br/><br/>import "fmt"<br/><br/>func main() {<br/><br/>    a := 1<br/>    b := &amp;a<br/><br/>    fmt.Println("A: ", a)<br/>    fmt.Println("B: ", b)<br/>    fmt.Println("B: ", *b)<br/>}</span></pre><p id="89b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里:</p><ol class=""><li id="eadc" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv mx ld le lf bi translated">用整数类型和值<em class="kw"> 1 </em>创建变量<code class="fe my mz na mp b">a</code></li><li id="d46a" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated">用指向整数类型的<em class="kw">指针创建一个变量<code class="fe my mz na mp b">b</code>(见下文)</em></li><li id="fbb0" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated">和数据输出:</li><li id="58c5" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated">首先只是<code class="fe my mz na mp b">a</code>的价值</li><li id="6d58" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated"><em class="kw">值</em>(!)或<code class="fe my mz na mp b">b</code>变量的<em class="kw">内容</em></li><li id="ea9c" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated">最后，我们正在获取<code class="fe my mz na mp b">b</code>所指向的<code class="fe my mz na mp b">a</code>的值(稍后将查看<code class="fe my mz na mp b">*</code>和<code class="fe my mz na mp b">&amp;</code>操作符)</li></ol><p id="3a25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行代码:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="5cd8" class="lm ln iq mp b gy mt mu l mv mw">$ go run pointers_example.go<br/>A: 1<br/>B: 0xc0000140e8<br/>B: 1</span></pre><p id="5ce0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第二行，我们看到了内存地址，这里是<code class="fe my mz na mp b">b</code>指针指向的地方。</p><p id="1c0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第三行——我们从这个内存地址得到了值。</p><p id="7d1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">指针可以用更充分的方式用类型规范初始化，而不是使用<code class="fe my mz na mp b">:=</code>，所以代码看起来像这样:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="f26f" class="lm ln iq mp b gy mt mu l mv mw">...<br/>func main() {<br/><br/>    var a int = 1<br/>    var b *int = &amp;a<br/><br/>    fmt.Println("A: ", a)<br/>    fmt.Println("B: ", b)<br/>    fmt.Println("B: ", *b)<br/><br/>}<br/>...</span></pre><p id="2c16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe my mz na mp b">var b *int = &amp;a</code>行中，我们设置<code class="fe my mz na mp b">b</code>变量是一个指向整数数据的指针。</p><p id="43b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，指向字符串数据的指针可以仅使用数据类型中的<code class="fe my mz na mp b">*string</code>而不是<code class="fe my mz na mp b">*int</code>来创建:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="be8b" class="lm ln iq mp b gy mt mu l mv mw">...<br/>    var c *string  <br/>    fmt.Printf("The C var type: %T, default value: %v\n", c, c)<br/>    var d string = "This is a string"<br/>    c = &amp;d<br/>    fmt.Printf("The C var type: %T, default value: %v, string value: %s\n", c, c, *c) <br/>...</span></pre><p id="930e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里:</p><ol class=""><li id="b44c" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv mx ld le lf bi translated"><code class="fe my mz na mp b">c</code>变量被创建为指向字符串数据的指针</li><li id="1c9d" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated">使用<code class="fe my mz na mp b">Printf()</code>的修饰符，显示<code class="fe my mz na mp b">c</code>变量的数据类型(<code class="fe my mz na mp b">%T</code>)及其值(<code class="fe my mz na mp b">%v</code>)</li><li id="16d1" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated"><code class="fe my mz na mp b">d</code>变量是用字符串数据类型和“<em class="kw">这是一个字符串</em>值创建的</li><li id="1049" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated">对于<code class="fe my mz na mp b">c</code>变量，<code class="fe my mz na mp b">d</code>变量的存储地址被设置</li><li id="dcfa" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated">使用<code class="fe my mz na mp b">Printf()</code>的修饰符<code class="fe my mz na mp b">c</code>变量的数据类型(<code class="fe my mz na mp b">%T</code>)、其值(<code class="fe my mz na mp b">%v</code>)以及来自存储在<code class="fe my mz na mp b">c</code>中的内存地址的值</li></ol><p id="c8d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="8ac3" class="lm ln iq mp b gy mt mu l mv mw">$ go run pointers_example.go<br/>The C var type: *string, default value: &lt;nil&gt;<br/>The C var type: *string, default value: 0xc0000101e0, string value: This is a string</span></pre><h2 id="6cce" class="lm ln iq bd lo lp lq dn lr ls lt dp lu kj lv lw lx kn ly lz ma kr mb mc md me bi translated"><code class="fe my mz na mp b">*</code>和<code class="fe my mz na mp b">&amp; operators</code></h2><p id="cc25" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">我们已经在上面的例子中使用了它们，但是让我们仔细看看。</p><p id="ad5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe my mz na mp b">*</code>运算符是一个<em class="kw">解引用运算符</em>。</p><p id="a6e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的<em class="kw">解引用</em>意味着我们得到的不是一个指针的值(它存储一个地址),而是来自这个指针所在的内存地址</p><p id="4df9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们回到之前的例子:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="0536" class="lm ln iq mp b gy mt mu l mv mw">...<br/>fmt.Printf("The C var type: %T, default value: %v, string value: %s\n", c, c, *c)<br/>...</span></pre><p id="a54c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里:</p><ul class=""><li id="ad6f" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><code class="fe my mz na mp b">default value: %v</code>与<code class="fe my mz na mp b">с</code> -显示存储在c变量中的值-一个内存地址，c指向该地址</li><li id="f942" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv lc ld le lf bi translated"><code class="fe my mz na mp b">string value: %s</code>带<code class="fe my mz na mp b">*с</code> -显示从<code class="fe my mz na mp b">c</code>变量调用内存后得到的值</li></ul><p id="ecfd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe my mz na mp b">&amp;</code>运算符返回一个变量的内存地址。</p><p id="d8d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，让我们在前面的示例中再添加一行，并让使用带有<code class="fe my mz na mp b">%p</code>修饰符的<code class="fe my mz na mp b">Printf()</code>来显示地址:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="29b4" class="lm ln iq mp b gy mt mu l mv mw">...<br/>    var c *string  <br/>    fmt.Printf("The C var type: %T, default value: %v\n", c, c)<br/>    var d string = "This is a string"<br/>    c = &amp;d<br/>    fmt.Printf("The C var type: %T, default value: %v, string value: %s\n", c, c, *c)<br/>    fmt.Printf("The D adress: %p\nThe C address: %p\nThe C value: %v\n", &amp;d, &amp;c, c)<br/>...</span></pre><p id="e661" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="8408" class="lm ln iq mp b gy mt mu l mv mw">$ go run pointers_example.go<br/>The C var type: *string, default value: &lt;nil&gt;<br/>The C var type: *string, default value: 0xc0000101e0, string value: This is a string<br/>The D adress: 0xc0000101e0<br/>The C address: 0xc00000e028<br/>The C value: 0xc0000101e0</span></pre><p id="edda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们得到了<em class="kw"> 0xc0000101e0 </em>值作为<code class="fe my mz na mp b">d</code>变量的地址，<em class="kw"> 0xc00000e028 </em>作为<code class="fe my mz na mp b">c</code>变量的地址，但是<code class="fe my mz na mp b">c</code>本身存储了<code class="fe my mz na mp b">d</code>变量的地址- <em class="kw"> 0xc0000101e0 </em>。</p><p id="c8ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际上，<code class="fe my mz na mp b">c</code>指针变量中的数据初始化是通过获取<code class="fe my mz na mp b">d</code>变量的地址来完成的:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="f3ca" class="lm ln iq mp b gy mt mu l mv mw">...<br/>c = &amp;d<br/>...</span></pre><h2 id="5e48" class="lm ln iq bd lo lp lq dn lr ls lt dp lu kj lv lw lx kn ly lz ma kr mb mc md me bi translated"><code class="fe my mz na mp b">new()</code>功能</h2><p id="25ca" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">使用<code class="fe my mz na mp b">var pointername *type</code>符号定义和初始化一个指针——你可以使用内置的<code class="fe my mz na mp b"><a class="ae lg" href="https://golang.org/pkg/builtin/#new" rel="noopener ugc nofollow" target="_blank">new()</a></code> Go函数，它接受一个数据类型作为第一个参数，并返回一个指向为变量数据分配的内存的指针:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="f419" class="lm ln iq mp b gy mt mu l mv mw">...<br/>    a := 1<br/>    b := new(int)<br/>    fmt.Printf("A: %d, B: %v, %v\n", a, b, *b)<br/>    b = &amp;a<br/>    fmt.Printf("A: %d, B: %v, %v\n", a, b, *b) <br/>...</span></pre><p id="56d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里:</p><ol class=""><li id="a3b3" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv mx ld le lf bi translated">用值<em class="kw"> 1 </em>创建<code class="fe my mz na mp b">a</code>变量</li><li id="f1f5" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated">创建了<code class="fe my mz na mp b">b</code>变量，它将保存一个指针，指向new()函数返回的内存，它现在保持0，因为已经分配的内存不能保存<code class="fe my mz na mp b">nil</code></li><li id="5b5b" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated">用<code class="fe my mz na mp b">a</code>的地址更新<code class="fe my mz na mp b">b</code>的值</li></ol><p id="73a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="0fff" class="lm ln iq mp b gy mt mu l mv mw">$ go run pointers_example.go<br/>A: 1, B: 0xc000014100, 0<br/>A: 1, B: 0xc0000140e8, 1</span></pre><h2 id="4b41" class="lm ln iq bd lo lp lq dn lr ls lt dp lu kj lv lw lx kn ly lz ma kr mb mc md me bi translated">更改指针的值</h2><p id="03da" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">嗯，说“改变指针的值”是不正确的，因为指针变量存储的是内存地址，而不是值本身。</p><p id="09d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是使用一个指针，我们可以在这个指针指向的内存位置改变这个值。</p><p id="550a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="4ee1" class="lm ln iq mp b gy mt mu l mv mw">...<br/>    a := 1<br/>    b := &amp;a<br/><br/>    fmt.Println("A: ", a)<br/>    fmt.Println("B: ", *b)<br/><br/>    *b = 2<br/>    fmt.Println("B: ", *b)<br/>...</span></pre><p id="42c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里:</p><ol class=""><li id="0fb7" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv mx ld le lf bi translated"><code class="fe my mz na mp b">a</code>变量的值为<em class="kw"> 1 </em></li><li id="a122" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated"><code class="fe my mz na mp b">b</code>变量有<code class="fe my mz na mp b">a</code>的地址</li><li id="7231" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated">显示的<code class="fe my mz na mp b">a</code>变量值</li><li id="2800" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated">显示的值取自<code class="fe my mz na mp b">b</code>所指向的地址</li><li id="3cd9" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated">我们正在将该存储器中的值更改为<em class="kw"> 2 </em></li><li id="204f" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated">并显示新值</li></ol><p id="9f4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行代码:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="cc37" class="lm ln iq mp b gy mt mu l mv mw">$ go run pointers_example.go<br/>A: 1<br/>B: 1<br/>B: 2</span></pre><h2 id="f9b1" class="lm ln iq bd lo lp lq dn lr ls lt dp lu kj lv lw lx kn ly lz ma kr mb mc md me bi translated">将指针作为函数的参数传递</h2><p id="7222" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">你可以传递一个指向函数的指针作为它的参数。</p><p id="652c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="5297" class="lm ln iq mp b gy mt mu l mv mw">package main<br/><br/>import "fmt"<br/><br/>func setVal(b *int) {<br/>    *b = 2<br/>}<br/><br/>func main() {<br/><br/>    a := 1<br/>    b := &amp;a<br/><br/>    fmt.Println("Init values")<br/>    fmt.Println("A: ", a)<br/>    fmt.Println("B: ", *b)<br/><br/>    setVal(b)<br/><br/>    fmt.Println("Changed values")<br/>    fmt.Println("A: ", a)<br/>    fmt.Println("B: ", *b)<br/>}</span></pre><p id="cd53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们创建了一个<code class="fe my mz na mp b">setVal()</code>函数，它接受一个整数指针作为参数，并将改变用这个指针传递的地址中的一个值。</p><p id="478b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查一下:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="c8d4" class="lm ln iq mp b gy mt mu l mv mw">$ go run pointers_example.go<br/>Init values<br/>A: 1<br/>B: 1<br/>Changed values<br/>A: 2<br/>B: 2</span></pre><p id="8d92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">调用<code class="fe my mz na mp b">setVal()</code>后，<code class="fe my mz na mp b">a</code>和<code class="fe my mz na mp b">b</code>将显示一个新值。</p><p id="6305" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">甚至更多——我们可以只传递一个<code class="fe my mz na mp b">a</code>变量的地址给<code class="fe my mz na mp b">setVal()</code>:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="2dfa" class="lm ln iq mp b gy mt mu l mv mw">...<br/>func setVal(b *int) {<br/>    *b = 2<br/>}<br/><br/>func main() {<br/><br/>    a := 1<br/><br/>    fmt.Println("Init values")<br/>    fmt.Println("A: ", a)<br/><br/>    setVal(&amp;a)<br/><br/>    fmt.Println("Changed values")<br/>    fmt.Println("A: ", a)<br/>}</span></pre><p id="680e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果是:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="0c54" class="lm ln iq mp b gy mt mu l mv mw">$ go run pointers_example.go<br/>Init values<br/>A: 1<br/>Changed values<br/>A: 2</span></pre><h2 id="80aa" class="lm ln iq bd lo lp lq dn lr ls lt dp lu kj lv lw lx kn ly lz ma kr mb mc md me bi translated">函数:通过值和引用传递参数</h2><p id="dd47" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">这里有点跑题，但是使用上面的例子，通过值传递参数<em class="kw">和通过引用传递参数<em class="kw">之间的区别也可以显示出来。</em></em></p><p id="047f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们更新这个例子:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="f914" class="lm ln iq mp b gy mt mu l mv mw">...<br/>func setVal(b *int, c int) {<br/>    *b = 2<br/>    c = 4<br/>    fmt.Printf("B from setVal(). Poiner to: %p, val: %v\n", b, *b)<br/>    fmt.Printf("C from setVal(). Addr: %p, val: %v\n", &amp;c, c)<br/>}<br/><br/>func main() {<br/><br/>    a := 1<br/>    b := &amp;a<br/>    c := 3<br/><br/>    fmt.Println("Init values")<br/>    fmt.Printf("A from main(). Addr: %p, val: %v\n", &amp;a, a)<br/>    fmt.Printf("B from main(). Poiner to: %p, val: %v\n", b, *b)<br/>    fmt.Printf("C from main(). Addr: %p, val: %v\n", &amp;c, c)<br/><br/>    fmt.Println("Changed values")<br/>    setVal(b, c)<br/>    <br/>    fmt.Printf("A from main(). Addr: %p, val: %v\n", &amp;a, a)<br/>    fmt.Printf("B from main(). Poiner to: %p, val: %v\n", b, *b)<br/>    fmt.Printf("C from main(). Addr: %p, val: %v\n", &amp;c, c)<br/>}</span></pre><p id="e4d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里:</p><ol class=""><li id="829c" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv mx ld le lf bi translated">获取<code class="fe my mz na mp b">a</code>变量地址及其值</li><li id="c9c8" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated">获取存储在<code class="fe my mz na mp b">b</code>变量中的地址，然后获取存储在该地址上的数据</li><li id="d06e" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated">获取<code class="fe my mz na mp b">c</code>变量地址及其值</li><li id="50f6" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated">调用<code class="fe my mz na mp b">setVal()</code>函数，通过<code class="fe my mz na mp b">b</code>和<code class="fe my mz na mp b">c</code>中的引用将<code class="fe my mz na mp b">a</code>的值作为一个值传递</li><li id="0c4f" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated">在<code class="fe my mz na mp b">setVal()</code>中，获取存储在<code class="fe my mz na mp b">b</code>变量中的地址和存储在那里的值</li><li id="1526" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated">在<code class="fe my mz na mp b">setVal()</code>中获取<code class="fe my mz na mp b">c</code>变量地址和存储在该存储区中的值</li><li id="2a26" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated">在<code class="fe my mz na mp b">main()</code>中获取<code class="fe my mz na mp b">a</code>的地址和存储在那里的值</li><li id="e98f" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated">在<code class="fe my mz na mp b">main()</code>中获取存储在<code class="fe my mz na mp b">b</code>变量中的地址和值</li><li id="4835" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated">在<code class="fe my mz na mp b">main()</code>中获取<code class="fe my mz na mp b">c</code>变量地址和存储在那里的值</li></ol><p id="3113" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行它:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="086b" class="lm ln iq mp b gy mt mu l mv mw">$ go run pointers_example.go<br/>Init values<br/>A from main(). Addr: 0xc0000140e8, val: 1<br/>B from main(). Poiner to: 0xc0000140e8, val: 1<br/>C from main(). Addr: 0xc000014100, val: 3<br/>Changed values<br/>B from setVal(). Poiner to: 0xc0000140e8, val: 2<br/>C from setVal(). Addr: 0xc000014130, val: 4<br/>A from main(). Addr: 0xc0000140e8, val: 2<br/>B from main(). Poiner to: 0xc0000140e8, val: 2<br/>C from main(). Addr: 0xc000014100, val: 3</span></pre><p id="8db4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里:</p><ol class=""><li id="794c" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv mx ld le lf bi translated"><code class="fe my mz na mp b">a</code>存储在<em class="kw"> 0xc0000140e8 </em>位置，其值为<em class="kw"> 1 </em></li><li id="0aa2" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated"><code class="fe my mz na mp b">b</code>指向相同的位置<em class="kw"> 0xc0000140e8 </em>并返回相同的<em class="kw"> 1 </em>值</li><li id="c048" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated"><code class="fe my mz na mp b">c</code>存储在<em class="kw"> 0xc000014100 </em>位置，值为<em class="kw"> 3 </em></li><li id="3c8b" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated"><code class="fe my mz na mp b">setVal()</code>被称为</li><li id="9f72" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated"><code class="fe my mz na mp b">setVal()</code>中的<code class="fe my mz na mp b">b</code>仍然指向<em class="kw"> 0xc0000140e8 </em>位置，其值为<em class="kw"> 2 </em></li><li id="326f" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated"><code class="fe my mz na mp b">setVal()</code>中的<code class="fe my mz na mp b">c</code>获得了其新地址<em class="kw"> 0xc000014130 </em>，其中存储了<em class="kw"> 4 </em></li><li id="33f2" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated"><code class="fe my mz na mp b">main()</code>中的<code class="fe my mz na mp b">a</code>现在保持来自同一<em class="kw"> 0xc0000140e8 </em>位置的<em class="kw"> 2 </em>值</li><li id="33c8" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated"><code class="fe my mz na mp b">main()</code>中的<code class="fe my mz na mp b">the b</code>仍然和<code class="fe my mz na mp b">setVal()</code>中的一样——指向相同的位置并返回相同的值</li><li id="f614" class="kx ky iq ka b kb lh kf li kj lj kn lk kr ll kv mx ld le lf bi translated">在<code class="fe my mz na mp b">c</code>变量的<code class="fe my mz na mp b">main()</code>中没有任何改变，因为<code class="fe my mz na mp b">setVal()</code>中的<code class="fe my mz na mp b">c</code>有自己的地址<em class="kw"> 0xc000014130 </em>，但是<code class="fe my mz na mp b">main()</code>中的<code class="fe my mz na mp b">c</code>使用<em class="kw">0xc 00014100</em>位置</li></ol><p id="f075" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际上，为了更好地理解什么是指针以及如何使用它们，这些都是需要知道的。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="dbe6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">最初发布于</em> <a class="ae lg" href="https://rtfm.co.ua/en/golang-ukazateli-podrobnyj-razbor-2/" rel="noopener ugc nofollow" target="_blank"> <em class="kw"> RTFM: Linux、DevOps和系统管理</em> </a> <em class="kw">。</em></p></div></div>    
</body>
</html>