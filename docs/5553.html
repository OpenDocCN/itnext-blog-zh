<html>
<head>
<title>Building Git in Elixir — Part 5 (Build Index)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Elixir中构建Git第5部分(构建索引)</h1>
<blockquote>原文：<a href="https://itnext.io/building-git-in-elixir-part-5-build-index-e10098836a83?source=collection_archive---------4-----------------------#2021-04-01">https://itnext.io/building-git-in-elixir-part-5-build-index-e10098836a83?source=collection_archive---------4-----------------------#2021-04-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="77c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/building-git-in-elixir-part-4-store-nested-trees-as-merkle-tree-1a236882215a">的前一篇文章</a>中，我着重于将嵌套树存储为Merkle树，以便<strong class="js iu"> egit </strong>可以存储嵌套目录。在本文中，我将着重于编写构建索引，以便在后续文章中，我们可以在存储库中增量存储更改。</p><h1 id="fe64" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">一点理论</h1><p id="b296" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">Git索引用于提供表示项目当前状态的所有blobs的缓存。Git <strong class="js iu"> add </strong>命令使用这些信息在存储库中增量保存变更。索引文件缓存来自文件系统的大量信息，例如文件大小、最后修改时间、文件模式等，Git <strong class="js iu"> add </strong>命令可以使用这些信息来加速操作。</p><p id="b624" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个阶段，检查位于。<strong class="js iu"> git </strong>文件夹。我们的目录结构如下—</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/1f08374932d78572f1be80941b152dd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8SAGrtQqRJMSIazvV-BTJA.png"/></div></div></figure><p id="200c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们使用<strong class="js iu"> git add </strong>并使用<strong class="js iu"> hexdump </strong>命令检查索引，我们可以看到—</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi me"><img src="../Images/062925a75757003e4569a463d9e7b8e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hg3CrJ6xqZqT9N9Haw69rg.png"/></div></div></figure><p id="03ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了理解这种数据格式，你可以看看[5]。但简而言之，它已经—</p><p id="5ca9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">— 12字节报头，包含—</p><ul class=""><li id="f262" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated">4字节签名(“D”、“I”、“R”、“C”)</li><li id="f59b" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated">4字节版本号—在这种情况下，版本是2</li><li id="4c4f" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated">索引中32位的条目数—在本例中为4</li></ul><p id="0017" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于每个条目，它存储通过调用<strong class="js iu"> stat() </strong>函数获得的10个4字节数字、出现的blob的20字节SHA-1、2字节标志集(包括文件名的长度)，文件名用零填充，因此总长度是8的倍数。</p><p id="38af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Stat() </strong>存储在十个4字节数字中的信息是—</p><p id="f6d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">32位ctime秒</p><p id="3759" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">32位ctime纳秒</p><p id="05e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">32位mtime秒</p><p id="bc2f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">32位mtime纳秒</p><p id="681c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">32位开发</p><p id="3d7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">32位ino</p><p id="a129" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">32位模式</p><p id="3c1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">32位uid</p><p id="530e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">32位gid</p><p id="1ca4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">32位文件大小</p><p id="a36e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">索引以另一个20字节的SHA-1散列结束——这是整个索引内容本身的散列，以便Git可以检查索引本身的完整性。</p><p id="5668" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<strong class="js iu"> git ls-files </strong>我们可以看到索引中的所有文件</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/f7de0f73e8d5e5ba612ec8f4dc47f309.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hmgYlxUa_LsHATfIgkp6zA.png"/></div></div></figure><p id="ec18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于下面的单个条目—</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mt"><img src="../Images/d26e67c9cc98097e5c8087fd023174b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eK8nDPrC1muOd6aCvKW-fg.png"/></div></div></figure><p id="f5fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很容易看到第一个12字节的头(带下划线的黄色)，和最后一个20字节的SHA-1(带下划线的红色)。其余属于<strong class="js iu"> hello.txt </strong>的词条。</p><h1 id="668e" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">本文的重点</h1><p id="1429" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在这篇文章中，重点是复制这种行为—</p><ul class=""><li id="c3dd" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated">添加新的<strong class="js iu"> egit添加</strong>命令</li><li id="0155" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated">该命令将建立<strong class="js iu">索引</strong></li></ul><h1 id="9e17" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">仙丹代码演练</h1><p id="d783" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">这篇文章的最终代码可以在这里找到——<a class="ae ko" href="https://github.com/imeraj/elixir_git" rel="noopener ugc nofollow" target="_blank">https://github.com/imeraj/elixir_git</a></p><p id="1f29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">存储库中的<strong class="js iu"> README </strong>文件包含构建<strong class="js iu"> egit </strong>以及如何使用<strong class="js iu"> egit add </strong>命令的说明。</p><h2 id="db24" class="mu kq it bd kr mv mw dn kv mx my dp kz kb mz na ld kf nb nc lh kj nd ne ll nf bi translated"><strong class="ak">构建索引&amp; egit添加实现</strong></h2><p id="a609" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">cli.ex 现在包含一个新子句来处理<strong class="js iu"> egit add </strong>命令——</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ng"><img src="../Images/f6ac9d26dfd48451a651eb87639dd99b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fECUlfFNAyONe93NSmyOug.png"/></div></div></figure><p id="534a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们需要存储文件和嵌套目录的能力，所以所有的路径都作为一个列表发送给处理逻辑</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nh"><img src="../Images/0636f6c68957ccaee217862e5a16a231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XiTU1oJmVezxgvO-uB6ZYQ.png"/></div></div></figure><p id="c975" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了处理新的<strong class="js iu"> egit add </strong>命令，有一个新的模块，看起来像</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ni"><img src="../Images/16ff669f8fdc3d3295a9ad32abec3cb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zkP8lhMqaDeL8rBwntSpmA.png"/></div></div></figure><p id="ae3d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><ul class=""><li id="2c48" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated"><strong class="js iu">第11–26行</strong> —处理路径，并为每个路径调用<strong class="js iu"> Workspace.list_files() </strong>列出文件，将它们归入索引。所以一旦这段代码执行，我们就有了所有给定路径的索引列表</li><li id="bef0" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated"><strong class="js iu">第28–32行</strong> —组合这些索引，并获得索引内所有条目的平面列表</li><li id="a50e" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated"><strong class="js iu">第34–35行</strong> —将这份单一的最终索引最终写入文件</li></ul><p id="f267" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">新增加的类型<strong class="js iu">索引</strong>完成了大部分繁重的工作——</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="21c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><ul class=""><li id="0223" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated"><strong class="js iu">第10–13行</strong> —为索引创建一个条目(属于新类型<strong class="js iu"> Egit。Types.Index.Entry </strong>并通过添加新条目来更新索引</li><li id="95f6" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated"><strong class="js iu">第107–123行</strong> —定义了<strong class="js iu"> to_s() </strong>函数，该函数按照上面理论部分的描述构建条目</li><li id="4b98" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated"><strong class="js iu">第15–45行</strong> —定义<strong class="js iu"> write_updates() </strong>函数，该函数通过首先创建一个<strong class="js iu"> index.lock </strong>文件来获取最终索引并写入文件。写入过程分为三个函数，因此在写入每个条目后，可以更新SHA-1值</li></ul><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nl"><img src="../Images/fbcdf1f99d1b25c8f022a67f8544657d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tUt2OHeZkcVvkapYWbuD5Q.png"/></div></div></figure><p id="390c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> finish_write() </strong>写入整个索引的最终散列。</p><p id="9989" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦这些写操作完成，它会将<strong class="js iu"> index.lock </strong>重命名为<strong class="js iu"> index </strong>，这样我们就可以得到最终的索引。</p><h1 id="4e1f" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">带埃吉特去兜一圈</h1><p id="8ded" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">最后，是时候带egit兜一圈了。我在上面理论部分提到的相同目录结构上运行了我们新添加的<strong class="js iu"> egit add </strong>命令，它给出了相同的结果</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nm"><img src="../Images/aa17a7ed3de9f17a447e868bc3e1b822.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kxdIHPx5jbS2i9lsQDxORQ.png"/></div></div></figure><h1 id="28ec" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">结论</h1><p id="7359" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在本系列文章的第5部分中，我添加了<strong class="js iu"> egit add </strong>命令来构建<strong class="js iu">索引</strong>，以便在后续文章中我可以在此基础上构建并支持文件的增量更新，而不是每次都使用<strong class="js iu"> egit commit </strong>来存储全部内容。</p><p id="ea09" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="nn">更多详细和深入的未来技术帖子，请关注我这里或</em><a class="ae ko" href="https://twitter.com/meraj_enigma" rel="noopener ugc nofollow" target="_blank"><em class="nn">Twitter</em></a><em class="nn">。</em></p><h1 id="c4db" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">参考</h1><ol class=""><li id="4ce3" class="mf mg it js b jt ln jx lo kb no kf np kj nq kn nr ml mm mn bi translated"><a class="ae ko" href="https://elixir-lang.org/getting-started/introduction.html" rel="noopener ugc nofollow" target="_blank">https://elixir-lang.org/getting-started/introduction.html</a></li><li id="8f55" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn nr ml mm mn bi translated">https://elixir-lang.org/docs.html<a class="ae ko" href="https://elixir-lang.org/docs.html" rel="noopener ugc nofollow" target="_blank"/></li><li id="a6dd" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn nr ml mm mn bi translated">【https://git-scm.com/docs T4】</li><li id="ad8c" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn nr ml mm mn bi translated"><a class="ae ko" href="https://github.com/imeraj/elixir_git" rel="noopener ugc nofollow" target="_blank">https://github.com/imeraj/elixir_git</a></li><li id="0cb8" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn nr ml mm mn bi translated"><a class="ae ko" href="https://mincong.io/2018/04/28/git-index/" rel="noopener ugc nofollow" target="_blank">https://mincong.io/2018/04/28/git-index</a></li></ol></div></div>    
</body>
</html>