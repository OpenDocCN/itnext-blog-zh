<html>
<head>
<title>PWA from scratch guide (yet another one)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PWA从头开始指南(又一个)</h1>
<blockquote>原文：<a href="https://itnext.io/pwa-from-scratch-guide-yet-another-one-bdfa438b50aa?source=collection_archive---------1-----------------------#2018-04-08">https://itnext.io/pwa-from-scratch-guide-yet-another-one-bdfa438b50aa?source=collection_archive---------1-----------------------#2018-04-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/6f1e30ce1c00f66533a82645467eba43.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*BSNDashSJZks1euWcyMj1w.png"/></div></figure><p id="5dd5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">欢迎阅读我的指南，从头开始创建PWA(渐进式网络应用)。我希望它能帮助你了解更多的服务人员、Web应用程序清单和缓存。享受🎓。</p><h1 id="aa24" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">介绍</h1><p id="5104" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">在接下来的部分中，我们将从零开始构建一个非常简单的PWA。目标是熟悉最重要的PWA概念；清单和服务人员。我们不会使用任何特定的框架，将保持代码非常简洁。为了简单起见，我们将在javascript中使用一些ES6特性。</p><p id="3921" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以下是本指南的主要步骤。每一个都将在不同的章节中讨论:</p><ul class=""><li id="e54d" class="lv lw iq jw b jx jy kb kc kf lx kj ly kn lz kr ma mb mc md bi translated">准备应用程序外壳</li><li id="224c" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">添加清单</li><li id="f1ee" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">实施服务人员</li><li id="6997" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">贮藏</li></ul><p id="d3b0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我希望这份指南能让你一瞥采纳PWA想法的好处。但是在进入代码之前，让我们用必要的元素准备我们的工作站。</p><h1 id="b1bf" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">要求</h1><p id="0198" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">我们将使用Visual Studio Code IDE以及这些语言:HTML 5、CSS3和EcmaScript 6。以下是我为本教程推荐的设置:</p><ul class=""><li id="f476" class="lv lw iq jw b jx jy kb kc kf lx kj ly kn lz kr ma mb mc md bi translated"><a class="ae mj" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> Visual studio代码或VS代码</a></li><li id="81b9" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated"><a class="ae mj" href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer" rel="noopener ugc nofollow" target="_blank"> Live server </a>:点击一个按钮就可以在本地服务器上运行当前的工作空间。</li><li id="a492" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">可选地，<a class="ae mj" href="https://marketplace.visualstudio.com/items?itemName=akamud.vscode-javascript-snippet-pack" rel="noopener ugc nofollow" target="_blank"> JavaScript Snippet Pack </a>或任何其他您更喜欢用于web项目的扩展。</li><li id="0d70" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">一个随时可用的JSON API。希望有一个GitHub存储库对一些公共API进行分类。在本指南中，我们将使用<a class="ae mj" href="https://jikan.docs.apiary.io/#reference" rel="noopener ugc nofollow" target="_blank"> Jikan API </a></li><li id="3c5c" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">Chrome的最新版本，因为我们将使用它强大的PWA开发工具</li></ul><p id="6d54" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一旦一切就绪，我们就可以初始化第一行代码了。</p><h1 id="c8c3" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">项目描述和初始化</h1><p id="3234" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">我们要建立的PWA是一个简单的动漫搜索应用程序。它允许显示一个给定了id<strong class="jw ir">的动画。UI提供了一个输入域和一个按钮，用于输入动画id并进行验证。除此之外，还会显示搜索结果的历史记录。</strong></p><p id="310d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该指南分为不同的步骤。第一步是构建应用程序外壳。接下来，我们将添加一个允许将PWA添加到主屏幕的清单。之后，将添加一个服务工作者来缓存之前的搜索响应。这将允许显示一些结果，即使在离线模式。第四步是缓存历史记录，而不依赖于服务人员。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/32edc78865e7d59196d5e1ab9f990ad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*bEB89SWJ2cL1LZ_ic-zjAg.jpeg"/></div></figure><p id="01f2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将创建项目的第一批文件和第一行代码。这允许有一些代码运行，也可以在进入主菜之前验证我们的设置🍕。</p><p id="94cc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请按照以下步骤获得一个最小网站:</p><ul class=""><li id="a4b4" class="lv lw iq jw b jx jy kb kc kf lx kj ly kn lz kr ma mb mc md bi translated">创建一个包含我们项目的空文件夹</li><li id="752b" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">启动VSCode并打开该文件夹</li><li id="2a83" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">创建新的HTML文件</li><li id="c17e" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">用html代码段初始化文件(CTRL+SHIFT+P -&gt;键入代码段-&gt;选择HTML)</li><li id="5683" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">添加一个<strong class="jw ir"> main.js </strong>文件和<strong class="jw ir"> main.css文件</strong>，我们稍后会用到</li></ul><p id="7d13" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">html文件应该类似于以下内容:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="061d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们在使用<a class="ae mj" href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer" rel="noopener ugc nofollow" target="_blank">实时服务器</a>创建的本地服务器上运行这个网站。只需点击工具栏上的<strong class="jw ir">上线</strong>按钮。你的默认浏览器应该将你的<strong class="jw ir">index.html</strong>呈现为一个空白页。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/512c11abefa85d7b77103b0b66ec9599.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*Zw7j9W8_r2kwNs7B0B-CGQ.png"/></div></figure><p id="cce1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">严重的事情现在开始✌️与应用外壳善良。</p><h1 id="dedf" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">应用程序外壳</h1><p id="af20" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">app shell由<a class="ae mj" href="https://developers.google.com/web/fundamentals/architecture/app-shell" rel="noopener ugc nofollow" target="_blank"> Addy Osmani </a>定义为:</p><blockquote class="ms mt mu"><p id="8693" class="ju jv mv jw b jx jy jz ka kb kc kd ke mw kg kh ki mx kk kl km my ko kp kq kr ij bi translated"><em class="iq">支持用户界面和离线缓存所需的最少HTML、CSS和JavaScript可确保用户在重复访问时获得即时、可靠的良好性能</em></p></blockquote><p id="33b3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这里，我试图给出一个综合的定义(如果我错了，请原谅😃):</p><p id="2be3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="mv">应用程序“外壳”是一个PWA的HTML、CSS和JS以及媒体内容:</em></p><ul class=""><li id="cc6b" class="lv lw iq jw b jx jy kb kc kf lx kj ly kn lz kr ma mb mc md bi translated">足以在线或离线浏览</li><li id="970f" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">最小的</li><li id="c935" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">常数</li></ul><p id="22f4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我解释一下这几点:</p><ul class=""><li id="248c" class="lv lw iq jw b jx jy kb kc kf lx kj ly kn lz kr ma mb mc md bi translated">足以在线或离线浏览:应用程序外壳应该设计成这样，用户可以在线或离线浏览网站的所有内容。对我来说，这是一个app shell最重要的特性。</li><li id="7076" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">最小:应用程序外壳是我们打开PWA时首先加载的内容。拥有一个小而优化的应用程序外壳意味着更快的加载时间和更小的缓存。</li><li id="541e" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">常量:由于我们要离线使用PWA，我们需要缓存一些html、css、js和媒体文件来加载应用程序。拥有随时间变化的基本内容使得管理离线模式变得非常复杂。因此，我认为一个好的应用程序外壳应该是不变的。</li></ul><p id="a8c4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">根据这种解释，应用程序外壳将有一个单一的HTML页面，没有任何硬编码的动画内容。后者将从互联网或缓存中加载。外壳还将包含javascript代码，允许从网络上加载动画信息并维护搜索历史。我们的小应用程序外壳的最后一部分是css文件和静态资产。</p><p id="477b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的应用程序外壳将非常小，恒定(或静态)并允许我们利用我们的PWA的所有功能，无论是离线还是在线。</p><p id="bbb9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们回到VS代码，将这些内容添加到html页面:</p><ul class=""><li id="3783" class="lv lw iq jw b jx jy kb kc kf lx kj ly kn lz kr ma mb mc md bi translated">一个按钮和一个输入框。</li><li id="46d5" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">两个空位。一个用于显示搜索动漫的结果(用<code class="fe mz na nb nc b">id="main_anime"</code>)，另一个用于显示历史(用<code class="fe mz na nb nc b">id="history"</code>)。</li></ul><p id="c2d5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">html文件应该是这样的。我们不应该很快改变，这使它成为一个很好的应用程序外壳组件。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="d31a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">很好，让我们也用一些css来得到一些<strong class="jw ir">响应</strong> UI，感谢<code class="fe mz na nb nc b">flex-wrap: wrap;</code>属性。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="1f8a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的应用程序外壳的JavaScript部分将在整个教程中不断发展。但是现在让我们做最基本的事情。</p><p id="f8cf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，定义将从单个动画对象生成html标签的常量和函数。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="5139" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mz na nb nc b">animeHistory</code>数组允许存储搜索到的动漫的历史。</p><p id="a989" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可以在这里看到一个由Jikan API<a class="ae mj" href="https://api.jikan.me/anime/1000" rel="noopener ugc nofollow" target="_blank">https://api.jikan.me/anime/1000</a>提供的动画对象示例。你可以改变网址末尾的数字来获得不同的动漫。当心一些id可能返回404。下面是一些成功的动漫id:4524，5672，1，1000。</p><p id="dd8d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下面是当用户点击按钮时从网络获取动画的代码。当成功检索到响应时，会更新历史记录和DOM。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="29e7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在上面的代码片段中，我们使用<code class="fe mz na nb nc b">fetch</code> API从服务器加载内容，然后显示在主div和历史div上。<code class="fe mz na nb nc b">fetch</code> API是处理Ajax请求的一种简单方式。</p><p id="4a2a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如您所见，这里没有清单、服务人员和缓存。这是可以的，因为应用程序外壳还没有最终确定。</p><p id="dc64" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你现在就可以测试这个应用。它还不符合PWA，但我们将在接下来的步骤中解决它😏。</p><h1 id="a979" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">PWA清单</h1><p id="d6b4" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">我们在PWA世界中的第一步是添加一个清单文件。下面是它来自<a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Web/Manifest" rel="noopener ugc nofollow" target="_blank"> MDN </a>的定义:</p><blockquote class="ms mt mu"><p id="28f9" class="ju jv mv jw b jx jy jz ka kb kc kd ke mw kg kh ki mx kk kl km my ko kp kq kr ij bi translated"><em class="iq">web应用程序清单在JSON文本文件中提供了关于应用程序的信息(如名称、作者、图标和描述)。</em></p></blockquote><p id="6da9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">添加web清单还有其他好处。以下是其中的一些:</p><ul class=""><li id="d488" class="lv lw iq jw b jx jy kb kc kf lx kj ly kn lz kr ma mb mc md bi translated">它们允许用户在你的主屏幕或桌面上添加书签</li><li id="28e9" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">它允许在应用程序加载时显示一个简单的闪屏</li></ul><p id="e2c2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由于web清单是一个普通的JSON文件，我们可以手动编写它，也可以使用工具来生成它。我们将使用这个<a class="ae mj" href="https://tomitm.github.io/appmanifest/" rel="noopener ugc nofollow" target="_blank"> Web应用清单生成器</a>。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nd"><img src="../Images/77d4a1e835fa63906db11a6854dc5749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*60Dlr61UOu3GKs2YjQIsAw.png"/></div></div></figure><p id="53ca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用该工具，尝试生成下面的<code class="fe mz na nb nc b">JSON</code>文件或类似的文件。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="926d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将JSON放在一个名为<code class="fe mz na nb nc b">manifest.json</code>的文件中，并将其放在你的网站的根目录下，与不同的图标放在一起。也许你可以在<a class="ae mj" href="https://www.flaticon.com/" rel="noopener ugc nofollow" target="_blank"> FLATICON </a>中找到你的图标。</p><p id="2821" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们还将使用该工具生成的html来更新HTML头。当然最重要的标签是<code class="fe mz na nb nc b">&lt;link rel="manifest" href="manifest.json"&gt;</code>。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="1e27" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们试试在手机浏览器上打开app。输入url <code class="fe mz na nb nc b">MACHINE_IP:PORT</code>，点击浏览器的菜单按钮，并查找选项<strong class="jw ir">添加到主屏幕。</strong></p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/9848e1d53e3763f4493ba7837c4ef407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*sZTgwVCaO2JVGhJnDe_mdQ.jpeg"/></div></figure><p id="7d57" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">通过选择此选项，您将在主屏幕上显示您的PWA链接。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/9975df2886a0d00ba926b3050f7b9800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*oSB3f2FjXlKF6nFp_dq-kw.jpeg"/></div></figure><p id="27ca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，点击快捷方式。您将看到一个小的加载屏幕。可以使用<code class="fe mz na nb nc b">theme_color</code>和<code class="fe mz na nb nc b">icons</code>属性对其进行定制。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/a832e112f5e9e4ca9d804a4d19d10a9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*EjkPGK48nktkybtIFwoKww.jpeg"/></div></figure><p id="4b75" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在那之后，由于清单中的<code class="fe mz na nb nc b">"display": "fullscreen"</code>选项，全屏PWA显示出它所有的荣耀。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/67db5a3e97a8b0dd7446bdb587cda792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*AkTRt_ZbXxymm47t2EgTQw.jpeg"/></div></figure><p id="61f2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">啊啊。PWA现在添加到了我的主屏幕上😍。但是，目前还没有缓存😒(尽量在平面模式下打开app)。让我们在下一步处理这个问题🚀。</p><h1 id="d83f" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">添加服务人员</h1><p id="505e" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">在这一节中，我们将缓存静态文件以及用户先前获取的动画的响应。请注意，我们将在这一部分保留历史记录。</p><p id="4a41" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了缓存浏览器请求的响应，我们需要实现一个代理来拦截它们。换句话说，我们将通过缓存响应并呈现缓存的内容而不是网络内容来定制<code class="fe mz na nb nc b">fetch</code>调用的行为。允许我们这样做的<strong class="jw ir">代理</strong>被称为<strong class="jw ir">服务工作者</strong>。它附带了一个允许缓存网络响应的API，即<a class="ae mj" href="https://developer.mozilla.org/fr/docs/Web/API/Cache" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">缓存API </strong> </a>。</p><p id="1c76" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">服务工作器基本上是一些浏览器事件的一组事件处理程序，必须在一个单独的文件中实现，通常称为<strong class="jw ir"> sw.js </strong>。为了使用它，我们需要首先将它注册到浏览器。通过调用<code class="fe mz na nb nc b">navigator.serviceWorker.register</code>完成注册。</p><p id="ffae" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将以下函数添加到<strong class="jw ir"> main.js </strong>文件中，并将其添加到您的<strong class="jw ir">index.html</strong>页面的<code class="fe mz na nb nc b">onload</code>事件处理程序中。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ab8d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当页面重新加载时，您应该在浏览器的控制台中看到以下日志行。</p><blockquote class="ms mt mu"><p id="4cf9" class="ju jv mv jw b jx jy jz ka kb kc kd ke mw kg kh ki mx kk kl km my ko kp kq kr ij bi translated"><em class="iq">服务工作者已注册【对象服务工作者注册】</em></p></blockquote><p id="7a93" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这意味着<code class="fe mz na nb nc b">let serviceWorker = await navigator.serviceWorker.register('/sw.js')</code>中指定的文件<strong class="jw ir"> sw.js </strong>已经成功注册为服务人员。你可以通过检查Chrome开发者工具的<strong class="jw ir">应用</strong>标签来确认。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nk"><img src="../Images/dabbb3bb4922018a08060e34361a17a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UTbDUwrS3IgY2qa-iFdzXw.png"/></div></div></figure><p id="1a20" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="mv">应用选项卡是调试PWA的一个非常有用的工具。我邀请你玩不同的菜单。</em></p><p id="cbbb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">开发维修工人时，建议勾选<strong class="jw ir">重新加载时更新</strong>复选框。它让chrome在每次注册后重新安装服务人员。否则，当您注册一个新的服务人员时，w将不得不手动取消注册之前的服务人员。所以，请继续检查。</p><p id="1334" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，在根文件夹中创建一个名为<strong class="jw ir"> sw.js </strong>的javascript文件(或者您为register方法指定的任何名称)。如上所述，服务工作器是一组事件处理程序，允许我们主要提供缓存行为。关于这一点，我们将实现两个事件处理程序:<strong class="jw ir"> install </strong>和<strong class="jw ir"> fetch </strong>。</p><p id="078e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第一个事件是<code class="fe mz na nb nc b">install</code>。在成功的服务人员<strong class="jw ir">注册</strong>后调用一次。这是缓存应用程序外壳和所有静态内容的最佳位置。我们将使用服务工作者的缓存API来添加这些文件，如下所示。将以下代码添加到sw.js中。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6fe1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用缓存非常简单；我们先<code class="fe mz na nb nc b">open</code>它，然后<code class="fe mz na nb nc b">addAll</code>静态文件。</p><p id="d583" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可以点击左侧菜单上的<strong class="jw ir">缓存</strong>来检查文件是否已成功添加。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nl"><img src="../Images/b04836993961aed61b23ab8984b1177f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*idOv7SY7yqYASHVSA150wg.png"/></div></div></figure><p id="d83e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">太好了，我之前添加的文件都在缓存中。然而，我们只完成了一半的工作，因为缓存没有被加载。为了确认这一点，点击维修工人菜单中的<strong class="jw ir">离线</strong>复选框。刷新页面并…😱web应用程序无法加载。</p><p id="bddc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">总而言之，我们将文件添加到了缓存中，但是它们不是在离线模式下加载的。问题是我们没有通知浏览器在网络调用失败时使用它们。</p><p id="00e9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">剩下的难题是服务人员的<code class="fe mz na nb nc b">fetch</code>事件。另外，我们将要实现的<code class="fe mz na nb nc b">fetch</code>事件处理程序也将缓存API调用。这是可能的，因为事件是在浏览器发出任何网络请求之前调用的。当我们处理这个事件时，我们可以选择加载缓存的内容，伪造我们的响应对象或者只是获得网络响应。</p><p id="38a1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请向服务人员添加以下内容。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="5c89" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请注意，代码的关键行是这一行<code class="fe mz na nb nc b">event.respondWith(getCustomResponsePromise())</code>。它允许我们用解析为<code class="fe mz na nb nc b">Response</code>实例的<code class="fe mz na nb nc b">Promise</code>或<code class="fe mz na nb nc b">async</code>函数来覆盖<strong class="jw ir">浏览器响应。如果没有那个电话，服务人员将几乎毫无用处。</strong></p><p id="1d5a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">基本上，这个事件处理程序从缓存中加载内容。如果内容不可用，我们从互联网上获取。这种行为被称为<strong class="jw ir">缓存优先策略</strong>。其他策略也是可行的，你甚至可以自己去抓猫😺策略。</p><p id="a3c5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">重新加载页面，做一些动漫搜索，验证缓存存储。新元素应该会出现在那里。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/231d7b260897479f4f4995e4adbdccd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*BOZdIE3K3aPHxNzB5GXyPw.png"/></div></figure><p id="a568" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，勾选<strong class="jw ir">离线</strong>复选框，再次尝试打开页面。宏伟！页面被加载，我们甚至可以搜索以前搜索过的动漫。它的事件在我的手机上使用平面模式。这是魔法😍。</p><p id="3d91" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">还有最后一件事要做，那就是缓存历史。因为它是一个数组，并且不是从网络响应中构建的，所以我们不能使用缓存API和服务工作器。本指南的下一部分将展示在服务人员之外进行缓存的方法。</p><h1 id="54ac" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">缓存历史记录</h1><p id="06ef" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">本节将展示一种使用<code class="fe mz na nb nc b">localStorage</code>对象持久化<code class="fe mz na nb nc b">animeHhistory</code>数组的技术。这个对象提供函数来存储数据，并在关闭浏览窗口后页面重新加载<strong class="jw ir">时进行检索。使用<code class="fe mz na nb nc b">localStorage.setItem(key, entry)</code>存储条目，使用<code class="fe mz na nb nc b">localStorage.getItem(key)</code>检索条目。</strong></p><p id="55ae" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里需要注意的是，这种持久存储只能处理字符串值。因此，当分别存储/加载时，我们需要将数组序列化/反序列化为JSON字符串。这要归功于<code class="fe mz na nb nc b">JSON.stringify(array)</code>和<code class="fe mz na nb nc b">JSON.parse(string)</code>功能。</p><p id="92c0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在<strong class="jw ir"> main.js </strong>中，修改<code class="fe mz na nb nc b">updateHistory</code>功能如下。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="afe0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">进行最后的接触。当DOM准备好时，让<code class="fe mz na nb nc b">onLoadAsync</code>函数加载持久化的历史。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="723d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">不要惊慌，我们只是添加了一个从本地存储加载动漫历史的函数，并在<code class="fe mz na nb nc b">onLoadAsync</code>事件处理程序中调用它。建议在那里做，因为我们想在前者准备好的时候用历史更新DOM。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nn"><img src="../Images/10a69c8b07fea8b2c63f8293143bc012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*24lwUTlnlnyLcBmaPK_x0Q.jpeg"/></div></div></figure><p id="813e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">瞧，我们的小PWA显示了页面加载和更新的历史🎆。</p><h1 id="2fce" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">结论和下一步</h1><p id="8f05" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">本指南是对大多数PWA概念的实用介绍。他们是:服务人员和货单。我们还学习了如何使用Crome dev工具来调试服务人员。我们只是触及了这些特性的表面，还有很多事情可以做。一些改进包括:</p><ul class=""><li id="78f0" class="lv lw iq jw b jx jy kb kc kf lx kj ly kn lz kr ma mb mc md bi translated">添加HTTPS，这是PWA的必备项</li><li id="394c" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">实现不同的缓存策略。</li><li id="0404" class="lv lw iq jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">添加服务器端渲染。</li></ul><p id="ad9d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你想构建一个生产PWA，我建议你使用支持PWA的框架或者PWA的插件，如果你使用CMS的话。一般来说，你不需要实现一个服务工作者，但是知道它是如何工作的是很有趣的。</p><p id="491a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">GitHub库可从<a class="ae mj" href="https://github.com/yostane/pwa_from_scratch" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="a211" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">快乐编码:)</p><h1 id="ad1f" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">链接</h1><p id="ca46" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated"><a class="ae mj" href="https://developers.google.com/web/fundamentals/codelabs/offline/" rel="noopener ugc nofollow" target="_blank">在您的Web应用程序中添加服务人员并离线</a></p><p id="69d4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae mj" href="https://developers.google.com/web/fundamentals/architecture/app-shell" rel="noopener ugc nofollow" target="_blank">应用外壳模型</a></p><p id="23bd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae mj" href="https://www.youtube.com/watch?v=gcx-3qi7t7c" rel="noopener ugc nofollow" target="_blank">渐进式Web应用程序教程—学习从零开始构建PWA</a></p><p id="7420" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae mj" href="https://developer.mozilla.org/fr/docs/Web/Manifest" rel="noopener ugc nofollow" target="_blank">应用程序清单网站</a></p><p id="b589" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae mj" href="https://developers.google.com/web/fundamentals/web-app-manifest/" rel="noopener ugc nofollow" target="_blank">网络应用清单</a></p><p id="b8b0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae mj" href="https://www.w3schools.com/html/html5_webstorage.asp" rel="noopener ugc nofollow" target="_blank"> HTML5网络存储</a></p><p id="8203" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如何在localStorage中存储数组？</p></div></div>    
</body>
</html>