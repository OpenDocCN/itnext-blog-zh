<html>
<head>
<title>Incremental Static Regeneration for Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度的增量静态再生</h1>
<blockquote>原文：<a href="https://itnext.io/incremental-static-regeneration-for-angular-42b0a8440e53?source=collection_archive---------0-----------------------#2022-04-09">https://itnext.io/incremental-static-regeneration-for-angular-42b0a8440e53?source=collection_archive---------0-----------------------#2022-04-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/83b1023e9b2bd5000fceedafe51ef782.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dyMkS4QZgJLPGViPfIfRWQ.png"/></div></div></figure><p id="b5dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你正在阅读这篇文章，你可能听说过<strong class="ka ir"> SSR </strong>(服务器端渲染)<strong class="ka ir"/>(静态站点生成)和<strong class="ka ir"> CSR </strong>(客户端渲染)。</p><p id="038a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它们的简要概述如下:</p><ul class=""><li id="e77d" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka ir"> SSR </strong>:使用服务器端呈现，每次页面被请求时都会被服务器呈现(可能会进行api调用)，然后提供给客户端。</li><li id="6e6d" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir"> SSG </strong>:使用静态站点生成，页面的呈现将在构建时完成，当页面被请求时，客户端将得到为该路径生成的静态文件。</li><li id="0d59" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir"> CSR </strong>:使用客户端呈现，页面的呈现(以及该页面所需的api调用)将在运行时发生(在客户端设备上)。</li></ul><h1 id="9f35" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">什么是<strong class="ak"> ISR </strong>，它能解决什么问题？</h1><p id="0b58" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">我们以一个电子商务网站为例。这个电子商务网站有数以千计的客户和数以千计的产品，每个产品都有一个详细信息页面。</p><p id="0d96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为这是一个电子商务网站，它应该是服务器端呈现的(可能使用Angular Universal ),以便爬虫读取SEO所需的内容。</p><p id="1e5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，每次对产品详细信息页面发出直接请求时，服务器都必须进行api调用以从后端获取数据，然后呈现HTML，然后将页面提供给客户端。</p><p id="786a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当客户端打开该页面时，都会发生这一过程。</p><p id="ef28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在想象成千上万的用户同时打开产品页面。服务器可能会崩溃，我们需要增加服务器资源(也包括后端服务器资源)。</p><p id="5094" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">服务器需要为所有客户机做同样的工作，以便为它们提供相同的页面。</p><h2 id="d6e3" class="mn ll iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">迄今为止，SSG提供了哪些帮助？</h2><p id="fca2" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">使用静态站点生成，我们在构建时生成每个产品详细信息页面，只提取一次数据，并向用户提供静态文件。</p><p id="5fa8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设这在运行时对服务器资源帮助很大，因为我们只提供静态文件，仅此而已。</p><p id="61e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很好，直到我们需要改变产品的细节，并从头开始做所有的工作。构建站点，生成所有页面，然后再次部署。这一切只是为了改变一个产品的价格。想象一下，每1小时改变100个产品价格。我们需要进行多少次构建、生成和部署？</p><h2 id="8d94" class="mn ll iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">这就是ISR发挥作用的地方！</h2><p id="be76" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">ISR将SSR和SSG的意识形态合二为一。</p><p id="21be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过ISR，我们可以在页面第一次被请求时在服务器上呈现页面，将其保存在缓存中，并将缓存的页面提供给请求该页面的所有其他用户。</p><p id="6889" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于缓存刷新，我们使用时间间隔或按需再生。</p><blockquote class="mz na nb"><p id="1407" class="jy jz nc ka b kb kc kd ke kf kg kh ki nd kk kl km ne ko kp kq nf ks kt ku kv ij bi translated">ISR就像SSG，但在运行时！</p></blockquote><h1 id="6042" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">一切都好吗？让我们按角度来做！</h1><p id="59d8" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">首先，我们需要一个应用程序来安装和配置Angular Universal。</p><p id="8585" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们安装<a class="ae ng" href="https://www.npmjs.com/package/ngx-isr" rel="noopener ugc nofollow" target="_blank"> ngx-isr </a>包。</p><p id="acc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> ngx-isr </strong>通过一个易于使用且可扩展的API(受Next.js启发)帮助您管理所有isr事务。</p><p id="c913" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nh ni nj nk b">npm install ngx-isr</code></p><p id="de78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们安装好之后，需要做一些小的配置。</p><ul class=""><li id="e065" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">在<code class="fe nh ni nj nk b">server.ts</code>中创建一个<strong class="ka ir"> ISRHandler </strong>实例。</li></ul><pre class="nl nm nn no gt np nk nq nr aw ns bi"><span id="2e71" class="mn ll iq nk b gy nt nu l nv nw"><em class="nc">import </em>{ ISRHandler } <em class="nc">from </em>'ngx-isr';</span><span id="1801" class="mn ll iq nk b gy nx nu l nv nw">const isr = new ISRHandler({<br/>  indexHtml, // &lt;-- Is the path to the index.html<br/>  invalidateSecretToken: 'MY_TOKEN', // replace with env secret key<br/>  enableLogging: !environment.production<br/>});</span></pre><ul class=""><li id="1b29" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">用ISR渲染替换角度默认服务器端渲染。</li></ul><p id="f683" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">替换这个:</p><pre class="nl nm nn no gt np nk nq nr aw ns bi"><span id="eedb" class="mn ll iq nk b gy nt nu l nv nw">server.get('*',<br/>  (req, res) =&gt; {<br/>    res.render(indexHtml, { req, providers: [{ provide: APP_BASE_HREF, useValue: req.baseUrl }] });<br/>  }<br/>);</span></pre><p id="4d25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这段代码:</p><pre class="nl nm nn no gt np nk nq nr aw ns bi"><span id="14fe" class="mn ll iq nk b gy nt nu l nv nw">server.get('*',<br/>  // Serve page if it exists in cache<br/>  async (req, res, next) =&gt; await isr.serveFromCache(req, res, next),<br/>  // Server side render the page and add to cache if needed<br/>  async (req, res, next) =&gt; await isr.render(req, res, next),<br/>);</span></pre><blockquote class="mz na nb"><p id="66ea" class="jy jz nc ka b kb kc kd ke kf kg kh ki nd kk kl km ne ko kp kq nf ks kt ku kv ij bi translated">注意:默认情况下，ISRHandler提供了<code class="fe nh ni nj nk b">APP_BASE_HREF</code>。如果您想将<code class="fe nh ni nj nk b">providers</code>传递给ISRHandler的方法，您还必须提供<code class="fe nh ni nj nk b">APP_BASE_HREF</code>令牌。</p></blockquote><ul class=""><li id="c157" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">添加无效URL处理程序</li></ul><pre class="nl nm nn no gt np nk nq nr aw ns bi"><span id="a449" class="mn ll iq nk b gy nt nu l nv nw">server.get(<br/>  "/api/invalidate", <br/>  async (req, res) =&gt; await isr.invalidate(req, res)<br/>);</span></pre><ul class=""><li id="b7db" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">在AppServerModule导入中添加<code class="fe nh ni nj nk b">NgxIsrModule</code></li></ul><pre class="nl nm nn no gt np nk nq nr aw ns bi"><span id="43ee" class="mn ll iq nk b gy nt nu l nv nw">import { NgxIsrModule } from 'ngx-isr'; // &lt;-- Import module<br/><br/>@NgModule({<br/>  imports: [<br/>    ...<br/>    NgxIsrModule  // &lt;-- Use it in module imports<br/>  ]<br/>})<br/>export class AppServerModule {}</span></pre><blockquote class="mz na nb"><p id="adc2" class="jy jz nc ka b kb kc kd ke kf kg kh ki nd kk kl km ne ko kp kq nf ks kt ku kv ij bi translated">当导入模块时，<code class="fe nh ni nj nk b">NgxIsrService</code>将被初始化并开始监听路由变化，只在服务器端，所以浏览器包不会包含任何额外的代码。</p></blockquote><p id="8b56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">原来如此！</strong></p><h2 id="51ec" class="mn ll iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">怎么用？</h2><p id="f249" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">在路线数据中添加<code class="fe nh ni nj nk b">revalidate</code>键即可。</p><pre class="nl nm nn no gt np nk nq nr aw ns bi"><span id="d624" class="mn ll iq nk b gy nt nu l nv nw">{<br/>  path: "example",<br/>  component: ExampleComponent,<br/>  data: { revalidate: 5 }<br/>}</span></pre><blockquote class="mz na nb"><p id="67b1" class="jy jz nc ka b kb kc kd ke kf kg kh ki nd kk kl km ne ko kp kq nf ks kt ku kv ij bi translated">注意:ISR不会处理数据中没有<strong class="ka ir">重新验证键</strong>的路线。它们将退回到角度默认的服务器端渲染管道。</p></blockquote><p id="8149" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要重新生成页面，我们需要向/revalidate发出get请求。像这样:</p><pre class="nl nm nn no gt np nk nq nr aw ns bi"><span id="99dd" class="mn ll iq nk b gy nt nu l nv nw">GET /api/invalidate?secret=MY_TOKEN&amp;urlToInvalidate=/example</span></pre><h2 id="d372" class="mn ll iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">它是如何工作的？</h2><p id="2c72" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">通过使用路线数据中的“重新验证”键，我们定义了ISR处理器将使用的时间间隔<br/>，以了解何时重新生成特定路线。<br/> <br/>选项:</p><ul class=""><li id="bb81" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka ir">不要指定任何东西</strong>:路线不会被缓存，总是由服务器渲染。(比如SSR)</li><li id="f22c" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">第一次发球将由服务器提供，其他所有发球将由缓存提供。(比如SSG)。</li><li id="0bc3" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir">大于0 </strong>(例如:5):第一次服务将由服务器提供，并且每5秒重新生成一次缓存(在最后一次请求之后)。</li></ul><p id="ded0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">高级例子</strong></p><pre class="nl nm nn no gt np nk nq nr aw ns bi"><span id="89b1" class="mn ll iq nk b gy nt nu l nv nw"><em class="nc">const </em>routes: <em class="nc">Routes </em>= [<br/>  {<br/>    path: "one",<br/>    component: PageOneComponent,<br/>  },<br/>  {<br/>    path: "two",<br/>    component: PageTwoComponent,<br/>    data: { revalidate: 5 },<br/>  },<br/>  {<br/>    path: "three",<br/>    component: PageThreeComponent,<br/>    data: { revalidate: 0 },<br/>  }<br/>];</span></pre><ul class=""><li id="b2d2" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">路径“one ”:它不会被缓存，在提供给用户之前将始终由服务器呈现。</li><li id="028b" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">路径“two ”:第一个请求将由服务器呈现，然后将被缓存。在第二次请求时，将从第一次请求时保存的缓存中提供服务。该URL将被添加到重新生成队列中，以便在“5”秒后重新生成缓存。在第三次请求时，如果重新生成成功完成，将向用户提供重新生成的页面，否则，将向他们提供旧的缓存页面。</li><li id="8c3d" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">路径“三”:第一个请求将由服务器呈现，然后将被缓存。在第一个请求之后，所有其他请求都将从缓存中得到服务。因此，缓存永远不会自动刷新。刷新缓存的唯一方法是请求API路由/使其无效。</li></ul><h2 id="eefa" class="mn ll iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">结果</h2><p id="6b9d" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">服务页面:<code class="fe nh ni nj nk b">npm run dev:ssr</code>。</p><p id="1f66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开检查元件。</p><p id="414b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并根据您提供的重新验证密钥检查<strong class="ka ir">最后更新的</strong>时间和日期的变化。</p><figure class="nl nm nn no gt jr gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/9bb3d7889f91180b22a115abf6fec7b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*4X4pe4vAUh_dBCxzB_kYrg.png"/></div></figure><p id="4eda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> ISR问题？</strong></p><p id="bca3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每次我们更改源代码，我们都必须再次进行构建和部署。ISR只在来自后端的数据发生变化时提供帮助(这没关系)。</p><p id="ed18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">原来如此！感谢阅读这篇长文！</strong></p><p id="32c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢它，请竖起大拇指，给Github库<a class="ae ng" href="https://github.com/eneajaho/ngx-isr" rel="noopener ugc nofollow" target="_blank">一个⭐。</a></p></div></div>    
</body>
</html>