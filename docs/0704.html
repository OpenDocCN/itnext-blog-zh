<html>
<head>
<title>V8 wrapped objects lifecycle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">V8包装对象生命周期</h1>
<blockquote>原文：<a href="https://itnext.io/v8-wrapped-objects-lifecycle-42272de712e0?source=collection_archive---------5-----------------------#2018-05-10">https://itnext.io/v8-wrapped-objects-lifecycle-42272de712e0?source=collection_archive---------5-----------------------#2018-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/0fa2f8db7a105eda69ab4da8275afe62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eD3UN8frZoPDwJDfZNPtCA.png"/></div></div></figure><div class=""/><p id="92f9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">V8中的对象，对于可以持有它们的句柄类型可以主要是:<code class="fe kw kx ky kz b">Local </code>或者<code class="fe kw kx ky kz b">Persistent</code>。虽然还有另外一种句柄类型:<code class="fe kw kx ky kz b">Eternal</code>，它的寿命与<code class="fe kw kx ky kz b">Isolate</code>相同，因此永远不会被垃圾回收。</p><p id="e9d8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">Local</code>代表一个短暂的对象，来自v8头文件本身:<em class="la">轻量级和短暂的，通常用于本地操作</em>。一旦管理这个<code class="fe kw kx ky kz b">Local</code>处理程序的<code class="fe kw kx ky kz b">HandleScope</code>被销毁，被包装的对象就无效，最终被垃圾回收。</p><p id="9eaf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">Persistent</code>句柄，可用于跨几个执行单元存储对象。这些对象最终将被垃圾回收。</p><p id="4fe6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在嵌入v8时，我总是需要在javascript中暴露一个本机对象，这是通过将一个<code class="fe kw kx ky kz b">Persistent</code>处理程序与一个本机对象配对来完成的。平均而言，这些本机对象是随着我的javascript代码流创建/销毁的，其对应的本机对象也需要相应地销毁和释放。为此，我设定了一个<code class="fe kw kx ky kz b">weak handle callback</code>像:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="da65" class="lj lk jb kz b gy ll lm l ln lo">class JavascriptWrapper {</span><span id="95a4" class="lj lk jb kz b gy lp lm l ln lo">private:<br/>    v8::Persistent&lt;v8::Object&gt; wrapper_;</span><span id="858d" class="lj lk jb kz b gy lp lm l ln lo">public:<br/>    public void Wrap( v8::Isolate*, ... ) {<br/>        ...<br/>        // set weak handler<br/>        wrapper_.SetWeak( this, <br/>                          weakCallbackForObjectHolder,     <br/>                          v8::WeakCallbackType::kParameter);<br/>    }</span><span id="bbcd" class="lj lk jb kz b gy lp lm l ln lo">    // the <strong class="kz jc">weak handler function</strong> is as follows:</span><span id="772b" class="lj lk jb kz b gy lp lm l ln lo">    static<strong class="kz jc"> </strong>void<strong class="kz jc"> </strong>weakCallbackForObjectHolder(<br/>        const<strong class="kz jc"> </strong>v8::WeakCallbackInfo&lt;HC::Wrapper&gt;&amp; data) {<br/>        delete<strong class="kz jc"> </strong>data.GetParameter();<br/>    }<br/>}</span></pre><p id="18b2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦javascript对象被垃圾收集，这个函数就会被调用，允许我回收这个对象持有的所有本机资源。</p><p id="5d48" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有时，我需要保留一个对象，直到某些操作完成。例如，Image对象应该一直存在，直到它的异步下载过程结束，并有机会通知它的回调，从而避免在该过程中进行垃圾收集。这是通过调用以下命令将<code class="fe kw kx ky kz b">Persistent</code>句柄标记为不弱来实现的:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="bf99" class="lj lk jb kz b gy ll lm l ln lo">wrapper_-&gt;ClearWeak();</span></pre><p id="75a7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这阻止了GC回收我的对象。想象这样一个javascript对象:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="c35c" class="lj lk jb kz b gy ll lm l ln lo">const image = new Image();<br/>image.addEventListener(“load”, (e)=&gt; {...});<br/>image.addEventListener(“error”, (e)=&gt; {...});<br/>image.src= 'http://...';</span></pre><p id="66ff" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这段代码可能会在通知回调之前破坏<code class="fe kw kx ky kz b">image</code>对象。(注意<code class="fe kw kx ky kz b">image</code>根本没有引用，只是在javascript中定义并遗忘了)。由于我希望通知<code class="fe kw kx ky kz b">load</code>或<code class="fe kw kx ky kz b">error</code>回调，所以我必须阻止GC介入，而<code class="fe kw kx ky kz b">ClearWeak</code>正是这么做的。稍后，当回调被通知时，我可以像上面的例子一样通过调用<code class="fe kw kx ky kz b">SetWeak(...)</code>来标记可用于垃圾收集的<code class="fe kw kx ky kz b">Persistent</code>处理程序。这个<code class="fe kw kx ky kz b">ClearWeak</code> / <code class="fe kw kx ky kz b">SetWeak</code>组合让我可以完全控制包装对象的生命周期。</p><h1 id="a3d9" class="lq lk jb bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">私人参考</h1><p id="462f" class="pw-post-body-paragraph jy jz jb ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">有些时候，我只需要将一个对象的生命周期绑定到另一个对象。比如一个<code class="fe kw kx ky kz b">TouchEvent</code>包含一个<code class="fe kw kx ky kz b">TouchList</code>对象，我想把它们的生命周期绑定在一起。</p><p id="3ec7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，v8还提供了私有属性实用程序。可以想象，这些属性将无法从javascript访问。要创建私有属性，只需调用</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="b94c" class="lj lk jb kz b gy ll lm l ln lo">v8::Local&lt;v8::Value&gt; v8Value= obj-&gt;Wrap(info.GetIsolate(), ...);</span><span id="5a4f" class="lj lk jb kz b gy lp lm l ln lo">// create a private property<br/>v8::Local&lt;v8::Private&gt; priv= v8::Private::ForApi(<br/>        info.GetIsolate(),<br/>        v8::String::NewFromUtf8(<br/>           info.GetIsolate(), <br/>           "KeepAlive#TouchEvent#ChangedTouches"));</span><span id="3453" class="lj lk jb kz b gy lp lm l ln lo">// assign this property to the object:<br/>info.Holder()-&gt;SetPrivate(<br/>        info.GetIsolate()-&gt;GetCurrentContext(),<br/>        priv,<br/>        v8Value);</span></pre><p id="65c9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样我就得到一个有趣的效果，当TouchEvent存在时，TouchList对象保持活动状态，没有人可以修改或破坏javascript的这种联系。</p><p id="3d88" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管如此，还有另一个阶段，我的被包装的本机对象值得特别注意，这是在<code class="fe kw kx ky kz b">Isolate</code>销毁时间。</p><h1 id="d2be" class="lq lk jb bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">孤立破坏</h1><p id="8026" class="pw-post-body-paragraph jy jz jb ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">不能依靠垃圾收集来回收任何对象。事实上，它可能不会在javascript程序生命周期中触发。</p><p id="e003" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个前提下，所有本机包装的对象都需要有机会在隔离销毁时被释放。特别是如果您希望创建另一个隔离并避免昂贵的内存泄漏。我们如何识别我们的<code class="fe kw kx ky kz b">Persistent</code>句柄以进行特殊处理呢</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="3fbd" class="lj lk jb kz b gy ll lm l ln lo">wrapper_.SetWrapperClassId( int16_t_tag );</span></pre><p id="b36c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">稍后，当隔离被销毁时，我必须显式调用</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="a510" class="lj lk jb kz b gy ll lm l ln lo">isolate_-&gt;VisitHandlesWithClassIds( &amp;phv );</span></pre><p id="a758" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">phv是这样一个类的实例:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="70fd" class="lj lk jb kz b gy ll lm l ln lo"><strong class="kz jc">class </strong>PHV : <strong class="kz jc">public </strong>v8::PersistentHandleVisitor {<br/><strong class="kz jc">public</strong>:<br/><br/>    v8::Isolate* isolate_;<br/><br/>    PHV(v8::Isolate* isolate) : isolate_(isolate) {}<br/>    <strong class="kz jc">virtual </strong>~PHV() {}<br/><br/>    <strong class="kz jc">virtual void </strong>VisitPersistentHandle(<br/>        v8::Persistent&lt;v8::Value&gt;* value,<br/>        uint16_t class_id) {<br/><br/>        // delete persistent handles on isolate disposal.<br/>        <strong class="kz jc">if </strong>( class_id==HC_GARBAGE_COLLECTED_CLASS_ID ) {<br/>            v8::HandleScope hs(isolate_);<br/>            Wrapper* w = // extract your wrapped object from<br/>                         // the passed-in value object.</span><span id="3d76" class="lj lk jb kz b gy lp lm l ln lo">            <strong class="kz jc">delete </strong>w;<br/>        }<br/>    }<br/>};</span></pre><p id="3ea7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，处理本机对象实际上非常简单。使用嵌入式v8是多么令人愉快的另一个例子。</p></div></div>    
</body>
</html>