<html>
<head>
<title>Application Configuration Management with Kapitan</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kapitan进行应用配置管理</h1>
<blockquote>原文：<a href="https://itnext.io/application-configuration-management-with-kapitan-40cb44dc4bf8?source=collection_archive---------4-----------------------#2020-09-21">https://itnext.io/application-configuration-management-with-kapitan-40cb44dc4bf8?source=collection_archive---------4-----------------------#2020-09-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><a href="http://www.giantswarm.io"><div class="gh gi jn"><img src="../Images/986b9a0f3e28aef27e3b16af4609089a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nz1I2HWkhLFtg7i-qt96NA.jpeg"/></div></a></figure><p id="32c0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果您一直在关注Kubernetes中关于应用程序配置管理的这个<a class="ae ks" href="https://blog.giantswarm.io/application-configuration-management-in-kubernetes/" rel="noopener ugc nofollow" target="_blank">系列</a>，那么您应该已经对其中的一些挑战有所了解。我们已经报道了<a class="ae ks" href="https://www.giantswarm.io/blog/application-configuration-management-helm" rel="noopener ugc nofollow" target="_blank">掌舵人</a>和<a class="ae ks" href="https://www.giantswarm.io/blog/application-configuration-management-with-kustomize" rel="noopener ugc nofollow" target="_blank">草见</a>如何寻求应对这些挑战。在本文中，我们将了解另一个社区解决方案，<a class="ae ks" href="https://kapitan.dev/" rel="noopener ugc nofollow" target="_blank"> Kapitan </a>。</p><h1 id="6172" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">卡皮坦是什么？</h1><p id="2e35" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">Kapitan于2017年开源，源于DeepMind Health公司(在被谷歌收购之前)，随后获得了相当大的追随者。GitHub星级可能不是开源软件项目受欢迎程度的最可靠衡量标准，但Kapitan的1150+星级表明该项目有一些切实的可信度。它可能没有Helm和Kustomize那么多的明星或贡献者，但也没有这些项目与Kubernetes项目的密切联系。</p><p id="92fd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Kapitan最初是作为一个技术无关的配置管理工具而设计的，但后来作为对Helm的明显缺点的一种补救，它开始关注Kubernetes。虽然主要焦点是呈现Kubernetes资源的YAML配置，但它也可以呈现模板化的脚本、文档(即READMEs)或任何其他可以表示为模板的人工制品。这种灵活性允许它同时应用于许多不同的领域。</p><h1 id="3672" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">卡皮坦是如何工作的</h1><p id="2465" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">最初，Kapitan很难让人理解，所以让我们用一个图表来帮助解释它是如何工作的。</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi lw"><img src="../Images/0199f407781c484fa85d841a116443ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9ANCtMUrfCD3xfVU.png"/></div></div></figure><p id="a2e7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Kapitan是一个基于Python的工具，它将库存配置项与一组模板和代码融合在一起，以所需的输出来呈现工件。清单只是一组用YAML表示的值，可以按层次划分成类，能够引用<a class="ae ks" href="https://palletsprojects.com/p/jinja/" rel="noopener ugc nofollow" target="_blank"> Jinja </a>模板和/或<a class="ae ks" href="https://jsonnet.org/" rel="noopener ugc nofollow" target="_blank"> Jsonnet </a>代码。除了类之外，库存目标是为许多不同的配置元素提供关联的抽象实体。对于Kubernetes环境，目标是Kubernetes名称空间的同义词。类定义配置值，目标将这些值组合在一起。</p><p id="1a55" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">创建Kapitan的动机之一是希望将所有配置保存在一个中心位置。不只是针对单个项目，而是针对所有项目。这与Helm形成对比，例如，在Helm中，所有值都倾向于特定于图表，并且不容易在不同的应用程序之间共享。因此，Kapitan的清单可以配置为包含多个应用程序和许多不同的目标环境(例如开发、测试、生产)。不同的目标决定了在Kapitan编译渲染输出的过程中哪些组件会发挥作用。</p><p id="eee4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用Jsonnet作为模板机制也是Kapitan与Kubernetes中的应用程序配置管理相关的一个关键因素。虽然Kapitan最初是为了使用Jinja模板而开发的(并且今天仍然支持它们的使用)，但是Jsonnet为模板提供了一个更具表现力的环境。Jsonnet是一种数据模板语言，它实际上是JSON的扩展，提供了开发人员熟悉的编程结构；库导入、函数、条件分支、变量等等。Jsonnet语言一直被视为解决Kubernetes中应用程序配置管理问题的潜在因素。</p><p id="9d67" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们揭开Kapitan的一些关键属性。</p><h1 id="4e57" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">可组合性</h1><p id="d5ab" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">Kapitan的一大优势是它使用了配置定义的可组合单元。通过减少为不同环境或场景复制配置的需求，这极大地有助于提高效率。可以定义不同的目标来使用与其目的相关的配置，并且可以快速配置新的应用程序或环境目标，而不必重新发明轮子。以这种方式将配置组件化有利于组合和重用。YAML的这个片段详细描述了一个在目标中定义的假设层次结构:</p><pre class="lx ly lz ma gt mf mg mh mi aw mj bi"><span id="f930" class="mk ku iq mg b gy ml mm l mn mo">classes: - common - component.env.qa-common - component.payment-common - component.payment-jsonnet parameters: target_name: payment-qa</span></pre><p id="2cf7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">classes键下的每个定义都引用一个包含参数定义的单独的YAML文件。在呈现其输出之前，Kapitan将库存参数组装到单个实体中进行处理(‘kapi tan inventory’命令可以在不呈现输出的情况下提供此输出)。子类定义或目标可以覆盖类中定义的参数。</p><p id="a9a6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">显然，参数值的层次结构比等效的平面结构要好得多。此外，它可以确保在定义配置项时遵守组织策略和约定。这对团队和组织来说是一个巨大的好处，但是它需要一定程度的初始规划和持续维护。</p><h1 id="f113" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">模板</h1><p id="3f93" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">Kapitan允许您编写和组织配置，这很好，但是模板是如何工作的呢？模板化是Kapitan的一个关键特性，也是应用程序配置管理解决方案的一个普遍接受的需求。</p><pre class="lx ly lz ma gt mf mg mh mi aw mj bi"><span id="5382" class="mk ku iq mg b gy ml mm l mn mo">parameters: namespace: payment-qa kapitan: compile: - output_path: manifests input_type: jsonnet output_type: yaml input_paths: - components/namespace/namespace.jsonnet</span></pre><p id="967c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这个inventory类组件中，在所示的输入路径中引用了一些Jsonnet代码。该语法通知Kapitan期待Jsonnet类型的输入，并且它需要生成YAML作为输出，该输出将放在一个名为“manifests”的目录中(该目录位于一个以目标命名的目录下)。</p><pre class="lx ly lz ma gt mf mg mh mi aw mj bi"><span id="155e" class="mk ku iq mg b gy ml mm l mn mo">local kube = import "lib/kube.libjsonnet"; local kap = import "lib/kapitan.libjsonnet"; local inventory = kap.inventory(); local p = inventory.parameters; { "namespace": kube.Namespace(p.namespace), }</span></pre><p id="2eb7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">相应的Jsonnet代码片段从两个库中导入一些代码；一个与Kapitan有关，另一个与模板化Kubernetes资源有关。在名称空间参数(' payment-qa ')被传递给' kube '之前，库存参数被分配给一个变量。“Namespace”函数，它呈现资源的YAML。密钥“namespace”是Kapitan为YAML定义创建的文件的基本名称。假设目标名为“payment_service”，呈现的名称空间资源位于以下路径:</p><p id="ddec" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mp mq mr mg b">./compiled/payment_service/manifests/namespace.yml</code></p><h1 id="c7f4" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">输入类型</h1><p id="0133" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">Jsonnet是Kapitan的输入类型之一，让我们看看其他一些输入类型。</p><h1 id="308b" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">文档和脚本</h1><p id="086d" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">除了使用Jsonnet代码创建YAML或JSON输出，Kapitan还可以使用Jinja模板呈现工件。考虑到一个项目也可能由脚本、文档、docker文件以及更多的东西组成。能够使用模板基于单个源产生多种细微差别的输出是非常引人注目的。</p><h1 id="7c83" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">舵图</h1><p id="5de6" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">Kapitan还在2019年下半年发布的v0.24中添加了对使用<a class="ae ks" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank">舵图</a>的支持，作为输入。输入类型需要指定为“helm ”,并且可以附带一个“helm _ values”YAML对象和一个“helm _ params”YAML对象。前者允许覆盖Helm图表的默认值，后者允许设置名称空间、版本名称等等。Kapitan的舵图渲染相当于运行“舵模板”命令，但没有舵二进制本身。</p><p id="837a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">定制的舵图可以存储在指定的输入路径之一，但第三方提供的现成舵图呢？这些通常位于远程仓库或<a class="ae ks" href="https://hub.helm.sh/" rel="noopener ugc nofollow" target="_blank">舵毂</a>上。Kapitan如何处理这种情况？嗯，Kapitan有一个内置的依赖管理器，它处理远程内容的<a class="ae ks" href="https://kapitan.dev/external_dependencies/" rel="noopener ugc nofollow" target="_blank">检索</a>。如果库存参数指定了远程图表依赖项的位置，则在“kapitan compile”命令中使用“— fetch”标志将导致kapitan下载图表，以供以后在呈现输出时使用。</p><p id="cb1d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">增加掌舵人的投入是很重要的，这在成熟度方面目前被认为是alpha。Kubernetes的云原生应用程序提供商通常使用Helm作为打包他们的应用程序进行分发的首选方式。在创建消费和定制这些现成应用程序的能力时，Kapitan为Kubernetes提供了消费打包应用程序的当前标准。没有它，卡皮坦将是一个远没有吸引力的提议。</p><h1 id="bb73" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="a450" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">Kapitan是应用程序配置管理领域真正的竞争对手，它提供了可靠的技术来解决围绕这个问题的各种问题。它还有其他有趣的特性，本文没有涉及到；例如，清单验证和机密管理。然而，尽管它有功能上的优势，还是有一些采用的障碍。</p><p id="bb3e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，有一个相对陡峭的学习曲线需要克服。Kapitan使用一个目录结构，其中包含分布在许多类和目标中的配置值片段。对于门外汉来说，当你在不同的目录中添加不同的输入(Jsonnet代码、Jinja模板、Helm charts)时，很难看出所有不同的组件是如何联系和组合在一起的。然而，如果你能克服这个感知问题，卡皮坦对构图的运用就能带来巨大的收益。如果您希望从一个位置管理不同应用程序和环境的所有配置，这一点尤其正确。</p><p id="ae06" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">其次，需要学习如何用Jsonnet编程。他们说，没有痛苦就没有收获。毕竟，如果您正在寻找应用程序配置管理的高级体验，那么有必要进行技能投资来实现它。值得指出的是，Jsonnet作为一种语言相对简单，不应该对现有的开发人员提出太多挑战。这也是试图解决同样问题的一些其他解决方案的一个特征。</p><p id="935c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，值得指出的是，Kapitan不像其他同行项目那样享有同等水平的采用和贡献。我们已经提到过，它没有通过特殊兴趣小组(SIG)或其他渠道与Kubernetes项目结合，它不是云原生计算基金会(CNCF)项目，似乎也没有任何大型云原生公司的贡献支持。这与其他解决方案形成了鲜明的对比，并最终可能决定其采用的程度。我们很想听听你在Kapitan的经历— <a class="ae ks" href="https://twitter.com/giantswarm" rel="noopener ugc nofollow" target="_blank">请保持联系</a>！</p><p id="7a0f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">ICYMI: <a class="ae ks" href="https://www.giantswarm.io/blog/application-configuration-management-in-kubernetes/" rel="noopener ugc nofollow" target="_blank">第一部分——库伯尼特斯</a>、<a class="ae ks" href="https://www.giantswarm.io/blog/application-configuration-management-helm" rel="noopener ugc nofollow" target="_blank">第二部分——赫尔姆</a>，以及<a class="ae ks" href="https://www.giantswarm.io/blog/application-configuration-management-with-kustomize" rel="noopener ugc nofollow" target="_blank">第三部分——库斯托米泽。</a></p><p id="5617" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由<a class="ae ks" href="https://twitter.com/puja108" rel="noopener ugc nofollow" target="_blank"> Puja Abbassi </a>撰写:开发者拥护者@ <a class="ae ks" href="https://twitter.com/giantswarm" rel="noopener ugc nofollow" target="_blank">巨型群体</a></p></div></div>    
</body>
</html>