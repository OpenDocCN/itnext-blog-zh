<html>
<head>
<title>Decouple Vuex modules with the Mediator pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用中介模式解耦Vuex模块</h1>
<blockquote>原文：<a href="https://itnext.io/decouple-vuex-actions-with-the-mediator-pattern-58a8879de1b4?source=collection_archive---------1-----------------------#2018-05-04">https://itnext.io/decouple-vuex-actions-with-the-mediator-pattern-58a8879de1b4?source=collection_archive---------1-----------------------#2018-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/4b5ca2c4594dd412d17f0f07b8e6af18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*q7IZCxZnWJ4GOe7YxOJnrw.jpeg"/></div></figure><p id="3d09" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我更愿意称之为“导体”模式。我觉得更有说服力，更准确。指挥聆听管弦乐队的各个部分，并在适当的时候触发其他部分。调解人通过推回对立的力量来达成妥协。调解人的定义本身就包含冲突。我们的准则是和谐的，不冲突的☮.但是这种模式被称为<a class="ae ks" href="https://en.wikipedia.org/wiki/Mediator_pattern" rel="noopener ugc nofollow" target="_blank">中介模式</a>。为了避免混淆，让我们坚持这一点。</p><p id="1626" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一旦应用程序包含足够多的特性，Vuex模块将不可避免地进行交互。Vuex模块有3种交互方式:</p><ol class=""><li id="898a" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated">一个动作从另一个模块调度一个动作。</li><li id="1648" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">一个动作引发一个事件。另一个模块订阅该事件并调度一个动作。</li><li id="d560" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">一个动作引发一个事件。中介订阅该事件。中介从另一个模块调度一个动作。</li></ol><p id="555f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">选项1 —“行动A”派遣“行动B”</strong></p><p id="3e40" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用这个选项看起来像下面的例子。认证之后，我们需要获取一些数据。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="066c" class="lq lr iq lm b gy ls lt l lu lv">...<br/>authenticate ({ dispatch }, credentials) {<br/>  return callAuthenticationEndpoint(credentials)<br/>    .then(result =&gt; {<br/>      commit('setToken', result.token)       <br/>      return dispatch('service/fetchData')<br/>        .then(() =&gt; result)<br/>    })<br/>}</span></pre><p id="f896" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这三个选项中，我认为选项1是最常见的。这是最直接的方法，也是唯一不需要事件总线的方法。它最符合我们通常思考代码的方式，从其他函数调用函数。问题是“验证”操作并不关心您的数据需求。authenticate动作没有做好一件事，而是在动作中产生了副作用。现在你对这个动作的测试也必须考虑到副作用。注意，我们还需要额外的代码来返回认证的结果，而不是获取的数据。错误处理呢？我们必须假设错误是在“fetchData”操作中捕获的，否则就在这里捕获它。</p><p id="d67f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">选项2 —模块监听模块</strong></p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="0013" class="lq lr iq lm b gy ls lt l lu lv">// auth module</span><span id="8b85" class="lq lr iq lm b gy lw lt l lu lv">authenticate ({ dispatch }, credentials) {<br/>  return callAuthenticationEndpoint(credentials)<br/>    .then(result =&gt; {<br/>      commit('setToken', result.token)       <br/>      eventBus.emit('authenticated', result)<br/>      return result<br/>    })<br/>}</span><span id="189a" class="lq lr iq lm b gy lw lt l lu lv">// service module</span><span id="e94a" class="lq lr iq lm b gy lw lt l lu lv">initialize ({ dispatch }) {<br/>  eventBus.on('authenticated', () =&gt; dispatch('fetchData'))<br/>}<br/>fetchData () {<br/>}</span></pre><p id="ca66" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">选项2稍微好一点，但是涉及到很多开销。您必须将事件总线导入每个模块，并从动作中发出一个事件。它还需要某种初始化动作，因为一旦我们在一个模块文件中，我们就不能访问dispatch方法，除非从另一个动作中。所以在代码的其他地方，需要调度这个初始化操作。</p><p id="32a4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果此时您在问，“如果我将事件监听器注册移动到另一个文件会怎么样”，那么您已经发现了中介模式，或者您已经知道了中介模式。</p><p id="d200" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">选项3 —中介模式</strong></p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="03eb" class="lq lr iq lm b gy ls lt l lu lv">// auth module</span><span id="2478" class="lq lr iq lm b gy lw lt l lu lv">authenticate ({ dispatch }, credentials) {<br/>  return callAuthenticationEndpoint(credentials)<br/>    .then(result =&gt; {<br/>      commit('setToken', result.token)       <br/>      eventBus.emit('authenticated', result)<br/>      return result<br/>    })<br/>}</span><span id="e99c" class="lq lr iq lm b gy lw lt l lu lv">// service module</span><span id="f507" class="lq lr iq lm b gy lw lt l lu lv">fetchData () {<br/>}</span><span id="5893" class="lq lr iq lm b gy lw lt l lu lv">// mediator file</span><span id="051e" class="lq lr iq lm b gy lw lt l lu lv">eventBus.on(<br/>  'authenticated',<br/>  () =&gt; store.dispatch('anotherModule/fetchData')<br/>)</span></pre><p id="03b7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在有了中介，模块不再需要初始化动作来注册事件监听器。从这个小例子中很难看出效果，但是我们已经分离了这些模块。服务模块仍将耦合到auth模块，因为它需要令牌来认证请求，但这是偶然的。通常，通过使用中介模式，您可以完全解耦您的模块。</p><p id="f8d3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">仍然有额外的开销。模块之间是解耦的，但是每个模块都耦合到事件总线，所以如果你能够在另一个应用中重用一个模块，你也需要事件总线。我会说这没问题，因为它强制执行了一个有用的模式，但是在Vuex中，我们可以通过使用Vuex作为事件总线来拥有我们的蛋糕并吃掉它。</p><p id="0e86" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">使用Vuex作为事件总线</strong></p><p id="64a2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Vuex的API包括:</p><ol class=""><li id="6215" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated">store.subscribeAction监听操作</li><li id="36c0" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">store.subscribe —倾听突变</li></ol><p id="2e4c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这些API不允许您指定想要监听哪个动作。相反，您需要在处理程序中设置一个switch语句，根据动作类型进行分支。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="1e94" class="lq lr iq lm b gy ls lt l lu lv">// store-moderator.js</span><span id="ceb9" class="lq lr iq lm b gy lw lt l lu lv">export default function configureModerator (store, router) {<br/>  // listen to mutations<br/>  store.subscribe(({ type, payload }, state) =&gt; {<br/>    switch (type) {<br/>      case 'auth/setToken':<br/>        return store.dispatch('service/fetchData')<br/>    }<br/>  })</span><span id="d876" class="lq lr iq lm b gy lw lt l lu lv">  // listen to actions<br/>  // note: doesn't not wait for the result of async actions<br/>  store.subscribeAction(({ type, payload }, state) =&gt; {<br/>    switch (type) {<br/>      case 'auth/signOut': return router.push('/auth/signin')<br/>    }<br/>  })<br/>}</span></pre><p id="a8da" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当我可以的时候，我试着去听突变而不是行动。通常，一个动作会导致一个突变。通过听突变，你可以知道这个动作什么时候结束。如果你监听这个动作，在这个动作被调用之后，在它有机会完成之前，这个处理程序会被调用。</p><p id="b01a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在模块内部不需要事件总线，因为Vuex是事件总线。如果我们看看我们的模块，它们彼此完全解耦，也从外部事件总线解耦。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="22ea" class="lq lr iq lm b gy ls lt l lu lv">// auth module</span><span id="8337" class="lq lr iq lm b gy lw lt l lu lv">authenticate ({ dispatch }, credentials) {<br/>  return callAuthenticationEndpoint(credentials)<br/>    .then(result =&gt; {<br/>      commit('setToken', result.token)<br/>      return result<br/>    })<br/>}</span><span id="d8bf" class="lq lr iq lm b gy lw lt l lu lv">// service module</span><span id="4af0" class="lq lr iq lm b gy lw lt l lu lv">fetchData () {<br/>}</span></pre></div></div>    
</body>
</html>