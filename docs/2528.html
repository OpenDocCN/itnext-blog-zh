<html>
<head>
<title>Docker Tips: about <none> images</none></title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker提示:关于<none>图片</none></h1>
<blockquote>原文：<a href="https://itnext.io/docker-tips-about-none-images-39fb34b20bc5?source=collection_archive---------0-----------------------#2019-06-09">https://itnext.io/docker-tips-about-none-images-39fb34b20bc5?source=collection_archive---------0-----------------------#2019-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8328" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解它们是什么以及如何摆脱它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b4a6f06958cf63dc6f76fb78f2ac642a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hVF-hJgkSLQddmd8JV0nYA.png"/></div></div></figure><p id="c9b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你是否已经想知道，当你列出你系统上的所有图片时，你能看到的带有<em class="lq"> &lt;无&gt; </em>标签的图片是什么？此外，那些被称为悬空图像的呢？在本帖中，我们将仔细观察这些图像，并展示它们是如何创建的。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="113f" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated"><strong class="ak">设置Docker主机</strong></h2><p id="d3fd" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">让我们从一个全新的虚拟机(本例中使用的虚拟机是在<a class="ae mw" href="https://digitalocean.com" rel="noopener ugc nofollow" target="_blank"> DigitalOcean </a>上提供的)开始，使用以下命令以最简单快捷的方式安装Docker:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="2e91" class="ly lz it my b gy nc nd l ne nf">$ curl <a class="ae mw" href="https://get.docker.com" rel="noopener ugc nofollow" target="_blank">https://get.docker.com</a> | sh</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="ad78" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated"><strong class="ak">从Docker Hub获取我们的第一批图像</strong></h2><p id="8d0e" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">因为这个Docker主机是全新的，所以上面还没有图像:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="76fb" class="ly lz it my b gy nc nd l ne nf"><strong class="my iu">$ docker image ls</strong><br/>REPOSITORY   TAG   IMAGE   ID   CREATED   SIZE</span></pre><p id="f211" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看几张图片:</p><ul class=""><li id="2021" class="ng nh it kw b kx ky la lb ld ni lh nj ll nk lp nl nm nn no bi translated">nginx 1.16版本中的阿尔卑斯风味:<em class="lq">nginx:1.16-阿尔卑斯</em></li><li id="748f" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp nl nm nn no bi translated">mongo版本4.0: <em class="lq"> mongo:4.0 </em></li></ul><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="4446" class="ly lz it my b gy nc nd l ne nf">$ <strong class="my iu">docker image pull nginx:1.16-alpine</strong><br/>1.16-alpine: Pulling from library/nginx<br/>e7c96db7181b: Pull complete<br/>8985e402e050: Pull complete<br/>Digest: sha256:04f8a19fce...8a6e7109e0<br/>Status: Downloaded newer image for nginx:1.16-alpine</span><span id="754e" class="ly lz it my b gy nu nd l ne nf">$ <strong class="my iu">docker image pull mongo:4.0</strong><br/>4.0: Pulling from library/mongo<br/>9ff7e2e5f967: Pull complete<br/>59856638ac9f: Pull complete<br/>6f317d6d954b: Pull complete<br/>a9dde5e2a643: Pull complete<br/>815c6aedc001: Pull complete<br/>8566b2594855: Pull complete<br/>01c9fe451980: Pull complete<br/>5c9e7bc12cea: Pull complete<br/>c64dd2c4159a: Pull complete<br/>c283cca25ace: Pull complete<br/>051b3304da4a: Pull complete<br/>ab4327c34933: Pull complete<br/>80003bc32b79: Pull complete<br/>Digest: sha256:93bd5412f1...080c203990<br/>Status: Downloaded newer image for mongo:4.0</span></pre><p id="5413" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">列出主机上呈现的图像，我们显然只得到我们刚刚提取的两个图像:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="7179" class="ly lz it my b gy nc nd l ne nf"><strong class="my iu">$ docker image ls</strong><br/>REPOSITORY  TAG          IMAGE ID      CREATED      SIZE<br/>mongo       4.0          0fb47b43df19  10 days ago  411MB<br/>nginx       1.16-alpine  ef04b00b089d  4 weeks ago  20.4MB</span></pre><p id="1ffb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">没有中间图像，因为我们还没有建立任何东西。如果有一些中间图像，它们将与<em class="lq"> ls </em>命令的<em class="lq"> -a </em>标志一起列出:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="f435" class="ly lz it my b gy nc nd l ne nf"><strong class="my iu">$ docker image ls -a</strong><br/>REPOSITORY  TAG          IMAGE ID      CREATED      SIZE<br/>mongo       4.0          0fb47b43df19  10 days ago  411MB<br/>nginx       1.16-alpine  ef04b00b089d  4 weeks ago  20.4MB</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="f356" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated"><strong class="ak">构建我们应用程序的映像</strong></h2><p id="0bc7" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">让我们为一个简单的<a class="ae mw" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">节点</a>构建一个图像。js应用程序由以下文件组成:</p><ul class=""><li id="3864" class="ng nh it kw b kx ky la lb ld ni lh nj ll nk lp nl nm nn no bi translated"><em class="lq"> index.js </em>:基于<a class="ae mw" href="https://expressjs.com/fr/" rel="noopener ugc nofollow" target="_blank"> expressjs </a>定义一个web服务器，它等待/ endpoint上传入的HTTP Get请求，并用一个简单的字符串进行回复</li></ul><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="27a0" class="ly lz it my b gy nc nd l ne nf">// index.js</span><span id="0485" class="ly lz it my b gy nu nd l ne nf">var express = require('express');<br/>var util    = require('util');<br/>var app = express();<br/>app.get('/', function(req, res) {<br/>  res.setHeader('Content-Type', 'text/plain');<br/>  res.end(util.format("%s - %s", new Date(), 'Got Request'));<br/>});<br/>app.listen(process.env.PORT || 80);</span></pre><ul class=""><li id="2b2b" class="ng nh it kw b kx ky la lb ld ni lh nj ll nk lp nl nm nn no bi translated"><em class="lq"> package.json </em>:定义应用程序的依赖关系，本例中只有<em class="lq">表示</em>模块</li></ul><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="1afa" class="ly lz it my b gy nc nd l ne nf">// package.json</span><span id="6291" class="ly lz it my b gy nu nd l ne nf">{<br/>  "name": "testnode",<br/>  "version": "0.0.1",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    "start": "node index.js"<br/>  },<br/>  "dependencies": {<br/>    "express": "^4.14.0"<br/>  }<br/>}</span></pre><p id="2e50" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用下面的<em class="lq"> Dockerfile </em>来打包应用程序:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="78e4" class="ly lz it my b gy nc nd l ne nf"># Base image<br/><strong class="my iu">FROM</strong> node:8.11-alpine</span><span id="42fe" class="ly lz it my b gy nu nd l ne nf"># Copy list of dependencies<br/><strong class="my iu">COPY</strong> package.json /app/package.json</span><span id="610d" class="ly lz it my b gy nu nd l ne nf"># Installation of the dependencies<br/><strong class="my iu">RUN</strong> cd /app &amp;&amp; npm install</span><span id="9a77" class="ly lz it my b gy nu nd l ne nf"># Copy application code into the image filesystem<br/><strong class="my iu">COPY</strong> . /app/</span><span id="6764" class="ly lz it my b gy nu nd l ne nf"># Define a working directory<strong class="my iu"><br/>WORKDIR</strong> /app</span><span id="0d2f" class="ly lz it my b gy nu nd l ne nf"># Port use by the web server<br/><strong class="my iu">EXPOSE</strong> 80</span><span id="e11b" class="ly lz it my b gy nu nd l ne nf"># Command run when a container is created<br/><strong class="my iu">CMD</strong> ["npm", "start"]</span></pre><p id="b0d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">标记为<em class="lq"> myapp:1.0 </em>的映像可以使用以下命令创建:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="b48a" class="ly lz it my b gy nc nd l ne nf">$ <strong class="my iu">docker image build -t myapp:1.0 .</strong><br/>Sending build context to Docker daemon  4.096kB<br/>Step 1/7 : FROM node:8.11-alpine<br/>8.11-alpine: Pulling from library/node<br/>a073c86ecf9e: Pull complete<br/>db7179d8c6cd: Pull complete<br/>66b9cfaecc8c: Pull complete<br/>Digest: sha256:1c38d992f8...8e6449e8e4<br/>Status: Downloaded newer image for node:8.11-alpine<br/> ---&gt; <strong class="my iu">8adf3c3eb26c</strong><br/>Step 2/7 : COPY package.json /app/package.json<br/> ---&gt; <strong class="my iu">0756fe390df0</strong><br/>Step 3/7 : RUN cd /app &amp;&amp; npm install<br/> ---&gt; Running in e6eaedea242c<br/>npm notice created a lockfile as package-lock.json. You should commit this file.<br/>npm WARN testnode@0.0.1 No description<br/>npm WARN testnode@0.0.1 No repository field.<br/>npm WARN testnode@0.0.1 No license field.</span><span id="8467" class="ly lz it my b gy nu nd l ne nf">added 50 packages in 2.601s<br/>Removing intermediate container e6eaedea242c<br/> ---&gt; <strong class="my iu">06401be52a71</strong><br/>Step 4/7 : COPY . /app/<br/> ---&gt; <strong class="my iu">309f1acba82d</strong><br/>Step 5/7 : WORKDIR /app<br/> ---&gt; Running in 50137f182ee6<br/>Removing intermediate container 50137f182ee6<br/> ---&gt; <strong class="my iu">4795b30cda26</strong><br/>Step 6/7 : EXPOSE 80<br/> ---&gt; Running in 5b3009be6e2f<br/>Removing intermediate container 5b3009be6e2f<br/> ---&gt; <strong class="my iu">59082c944c68</strong><br/>Step 7/7 : CMD ["npm", "start"]<br/> ---&gt; Running in bd89f7d79a23<br/>Removing intermediate container bd89f7d79a23<br/> ---&gt; <strong class="my iu">47c736deb8d1</strong><br/>Successfully built 47c736deb8d1<br/>Successfully tagged myapp:1.0</span></pre><p id="789c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面输出中以粗体突出显示的值是构建过程中生成的中间映像的id。事实上，在构建的每一步:</p><ul class=""><li id="1274" class="ng nh it kw b kx ky la lb ld ni lh nj ll nk lp nl nm nn no bi translated">容器正在运行</li><li id="5b4e" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp nl nm nn no bi translated">与步骤中定义的指令相对应的更改在该容器内部完成</li><li id="53d9" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp nl nm nn no bi translated">容器被提交到一个映像(即中间映像)中，该映像将用作下一步的基础映像</li></ul><p id="92fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里需要注意几件事:</p><ul class=""><li id="518d" class="ng nh it kw b kx ky la lb ld ni lh nj ll nk lp nl nm nn no bi translated">生成的第一个图像(Dockerfile中的指令)标记有基础图像的值，<em class="lq">节点:8.11-alpine </em></li><li id="99d1" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp nl nm nn no bi translated">生成的最后一个映像(Dockerfile的指令CMD)标记有正在构建的映像的名称，<em class="lq"> myapp:1.0 </em></li><li id="b642" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp nl nm nn no bi translated">在构建过程中，生成的7个中间图像中有5个图像没有任何标签</li></ul><p id="520b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们再次检查主机上显示的图像:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="3613" class="ly lz it my b gy nc nd l ne nf"><strong class="my iu">$ docker image ls<br/></strong>REPOSITORY  TAG          IMAGE ID       CREATED         SIZE<br/>myapp       1.0          47c736deb8d1   3 seconds ago   71.2MB<br/>mongo       4.0          0fb47b43df19   10 days ago     411MB<br/>nginx       1.16-alpine  ef04b00b089d   4 weeks ago     20.4MB<br/>node        8.11-alpine  8adf3c3eb26c   9 months ago    68.1MB</span></pre><p id="429f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与之前的列表相比，增加了2个图像:</p><ul class=""><li id="8cbc" class="ng nh it kw b kx ky la lb ld ni lh nj ll nk lp nl nm nn no bi translated">myapp:1.0 :我们刚刚创建的图像</li><li id="830d" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp nl nm nn no bi translated"><em class="lq">节点:8.11-阿尔卑斯</em>:构建<em class="lq"> myapp:1.0 </em>时使用的基础镜像</li></ul><p id="cb39" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用-a标志，我们可以看到现在列出的几个中间图像(其中5个),这些是为存储库和标签设置了<em class="lq"> &lt; none &gt; </em>值的图像，它们对应于我们讨论过的中间图像。</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="a926" class="ly lz it my b gy nc nd l ne nf"><strong class="my iu">$ docker image ls -a</strong><br/>REPOSITORY   TAG         IMAGE ID       CREATED             SIZE<br/>&lt;none&gt;       &lt;none&gt;      309f1acba82d   8 seconds ago       71.2MB<br/>&lt;none&gt;       &lt;none&gt;      59082c944c68   8 seconds ago       71.2MB<br/>myapp        1.0         <strong class="my iu">47c736deb8d1</strong>   8 seconds ago       71.2MB<br/>&lt;none&gt;       &lt;none&gt;      4795b30cda26   8 seconds ago       71.2MB<br/>&lt;none&gt;       &lt;none&gt;      06401be52a71   9 seconds ago       71.2MB<br/>&lt;none&gt;       &lt;none&gt;      0756fe390df0   14 seconds ago      68.1MB<br/>mongo        4.0         0fb47b43df19   10 days ago         411MB<br/>nginx        1.16-alpine ef04b00b089d   4 weeks ago         20.4MB<br/>node         8.11-alpine 8adf3c3eb26c   9 months ago        68.1MB</span></pre><p id="1a33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还可以使用<em class="lq"> dangling=true </em>过滤器列出悬空图像，即存在但不再被任何标签引用的图像:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="e856" class="ly lz it my b gy nc nd l ne nf"><strong class="my iu">$ docker image ls --filter dangling=true<br/></strong>REPOSITORY   TAG      IMAGE ID      CREATED           SIZE</span></pre><p id="c038" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个阶段，没有发现悬挂图像，我们将在下面看到这种图像是如何创建的。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="ec8a" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated"><strong class="ak">图像的新构建</strong></h2><p id="2811" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">让我们稍微修改一下<em class="lq"> index.js </em>文件，使其具有以下内容:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="c528" class="ly lz it my b gy nc nd l ne nf">var express = require(‘express’);<br/>var util    = require(‘util’);<br/>var app = express();<br/>app.get(‘/’, function(req, res) {<br/>    res.setHeader(‘Content-Type’, ‘text/plain’);<br/>    <strong class="my iu">res.end(util.format("Got Request at %s", new Date());</strong><br/>});<br/>app.listen(process.env.PORT || 80);</span></pre><p id="cbe2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用我们在第一次构建中使用的同一个标记，<em class="lq"> myapp:1.0，</em>再次构建图像:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="4dc4" class="ly lz it my b gy nc nd l ne nf">$ docker image build -t myapp:1.0 .</span></pre><p id="d8cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以看到新的中间图像被创建，就像第一次构建的情况一样。但是我们也可以看到一个悬空的图像已经生成:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="7886" class="ly lz it my b gy nc nd l ne nf"><strong class="my iu">$ docker image ls --filter dangling=true<br/></strong>REPOSITORY   TAG      IMAGE ID      CREATED           SIZE<br/>&lt;none&gt;       &lt;none&gt;   47c736deb8d1  10 minutes ago    71.2MB</span></pre><p id="21ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与中间的图像一样，这个图像的存储库和标签的值为<em class="lq"> &lt; none &gt; </em>。正如我们在这里看到的，这个悬空图像的id，<strong class="kw iu"> 47c736deb8d1 </strong>，就是之前链接到标签<em class="lq"> myapp:1.0 </em>的那个。</p><p id="750f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为一个记住，下面是第一次建立的形象结束:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="86bf" class="ly lz it my b gy nc nd l ne nf">...<br/>Step 7/7 : CMD ["npm", "start"]<br/> ---&gt; Running in bd89f7d79a23<br/>Removing intermediate container bd89f7d79a23<br/> ---&gt; <strong class="my iu">47c736deb8d1</strong><br/>Successfully built 47c736deb8d1<br/>Successfully tagged myapp:1.0</span></pre><p id="381a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，这个id不再链接到<em class="lq"> myapp:1.0 </em>标签，因为第二次构建已经在新创建的图像(包含我们在index.js文件中所做的更改的图像)上设置了这个标签。</p><p id="6559" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以前的图像现在被认为是悬空的，不再被引用。我们可以删除它，但我们可能首先需要确保我们没有在第二次构建中错误地使用相同的标签(这种情况会发生:)</p><p id="eec0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果错误地重用了标签，仍然可以使用类似于下面的命令向悬挂图像添加标签:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="b498" class="ly lz it my b gy nc nd l ne nf">$ docker image tag 47c736deb8d1 myapp:1.0-recovered</span></pre><p id="1e4c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个图像将不再是一个悬空的图像。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="4542" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated"><strong class="ak">清理</strong></h2><p id="c55e" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">如果我们想去掉所有悬挂的图像(有时甚至不知道我们已经生成了那么多)，我们可以使用prune子命令:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="197e" class="ly lz it my b gy nc nd l ne nf"><strong class="my iu">$ docker image prune<br/></strong>WARNING! This will remove all dangling images.<br/>Are you sure you want to continue? [y/N] y<br/>Deleted Images:<br/>deleted: sha256:aea2f67f5f...72e221afe0<br/>deleted: sha256:eef519a8cc...f50f2f8140<br/>... <br/>deleted: sha256:a26154cc03...8716f933ca<br/>deleted: sha256:d1e43f42db...b912ad9792</span><span id="c7fe" class="ly lz it my b gy nu nd l ne nf">Total reclaimed space: 829.6MB</span></pre><p id="0f5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有时我们可以恢复有用的磁盘空间。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="dff8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">希望中间和悬空的图像对你来说不再有秘密:)</p></div></div>    
</body>
</html>