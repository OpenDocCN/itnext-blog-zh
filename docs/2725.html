<html>
<head>
<title>Understanding Angular Life Cycle Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解角度生命周期挂钩</h1>
<blockquote>原文：<a href="https://itnext.io/understanding-angular-life-cycle-hooks-91616f8946e3?source=collection_archive---------1-----------------------#2019-07-22">https://itnext.io/understanding-angular-life-cycle-hooks-91616f8946e3?source=collection_archive---------1-----------------------#2019-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2b34" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">配有用的例子！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f50cba41212fd09826138a28edb37df9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8NOCjifxWN7tAPEu2p4Hng.png"/></div></div></figure><p id="f2aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Angular应用程序中，组件从创建到销毁的整个<em class="lq">生命周期</em>都由Angular管理。它为我们提供了对<em class="lq">生命周期钩子</em>的访问，这允许我们在组件的<em class="lq">生命周期</em>的关键时刻采取行动。</p><p id="2a8c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了使用这些<em class="lq">钩子，</em>我们必须告诉Angular我们想要实现期望的<em class="lq">钩子接口</em>。Angular检查组件类，<strong class="kw iu"> <em class="lq">调用</em> <em class="lq">钩子</em> <em class="lq">方法，如果它们被定义</em> </strong>。下面是这个语法是如何进行的<em class="lq">(对于OnInit) </em>:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="56c3" class="lw lx it ls b gy ly lz l ma mb">export class MyComponent <strong class="ls iu">implements OnInit</strong> {</span><span id="fffc" class="lw lx it ls b gy mc lz l ma mb">    constructor() { }</span><span id="e9a0" class="lw lx it ls b gy mc lz l ma mb">    <strong class="ls iu">ngOnInit() {<br/>        </strong>// Insert Logic Here!<strong class="ls iu"><br/>    }</strong></span><span id="f443" class="lw lx it ls b gy mc lz l ma mb">}</span></pre><p id="a2c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是Angular提供的钩子列表，这些钩子是按照这个顺序调用的，我们将在下面逐一深入研究:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="cea7" class="lw lx it ls b gy ly lz l ma mb">╔════════════════════════════╗<br/>║   <strong class="ls iu"><em class="lq">lifecycle hooks</em>  </strong>        ║<br/>╠════════════════════════════╣<br/>║   ngOnChanges()            ║<br/>╠════════════════════════════╣<br/>║   ngOnInit()               ║<br/>╠════════════════════════════╣<br/>║   ngDoCheck()              ║<br/>╠════════════════════════════╣<br/>║   ngAfterContentInit()     ║ <br/>╠════════════════════════════╣<br/>║   ngAfterContentChecked()  ║  <br/>╠════════════════════════════╣<br/>║   ngAfterViewInit()        ║<br/>╠════════════════════════════╣<br/>║   ngAfterViewChecked()     ║<br/>╠════════════════════════════╣<br/>║   ngOnDestroy()            ║<br/>╚════════════════════════════╝</span></pre></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h2 id="3b7d" class="lw lx it bd mk ml mm dn mn mo mp dp mq ld mr ms mt lh mu mv mw ll mx my mz na bi translated">恩贡昌斯</h2><p id="54cf" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">该方法在组件创建时被调用一次，然后在组件的<em class="lq">输入</em>属性之一检测到变化时被调用<strong class="kw iu">。它接收一个<a class="ae ng" href="https://angular.io/api/core/SimpleChanges" rel="noopener ugc nofollow" target="_blank"><em class="lq">simple changes</em></a>对象作为参数，该对象包含关于哪个<em class="lq">输入</em>属性已经更改的信息——如果我们有多个属性——以及它的当前值和先前值。</strong></p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="182e" class="lw lx it ls b gy ly lz l ma mb">export class MyComponent implements <strong class="ls iu">OnChanges </strong>{</span><span id="d191" class="lw lx it ls b gy mc lz l ma mb">    <strong class="ls iu">ngOnChanges(changes: SimpleChanges) {</strong><br/>        // Insert Logic Here!<br/>    <strong class="ls iu">}</strong></span><span id="31f1" class="lw lx it ls b gy mc lz l ma mb">}</span></pre><p id="9613" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq"> Obs:当输入属性没有设置值时，其值默认设置为字符串“CD_INIT_VALUE”。</em></p><p id="4707" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是<em class="lq">生命周期挂钩</em>中的一个，可以在多种用例中派上用场。如果您需要根据接收到的<em class="lq">输入</em>属性处理组件中的任何特定逻辑，这将非常有用。</p><p id="b148" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设您有一个显示用户信息的组件，它接收UserInfo对象作为输入参数。下面是一个关于如何在组件中使用<em class="lq"> ngOnChanges </em>来添加逻辑以处理<em class="lq"> UserInfo属性</em>的变化的例子。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="cff1" class="lw lx it ls b gy ly lz l ma mb">export class UserInfoComponent implements OnChanges {</span><span id="0b88" class="lw lx it ls b gy mc lz l ma mb">  @Input userInfo: UserInfo;</span><span id="7cc3" class="lw lx it ls b gy mc lz l ma mb">  ngOnChanges(changes: SimpleChanges) {<br/>    const previousValue = <!-- -->changes[<!-- -->'userInfo']<!-- -->.previousValue;<br/>    <!-- -->const currentValue = <!-- -->changes[<!-- -->'userInfo']<!-- -->.currentValue;<br/>    // Your Logic!<br/>  <!-- -->}</span><span id="28f6" class="lw lx it ls b gy mc lz l ma mb">}</span></pre></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h2 id="8ec6" class="lw lx it bd mk ml mm dn mn mo mp dp mq ld mr ms mt lh mu mv mw ll mx my mz na bi translated">恩戈尼特</h2><p id="3405" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">在组件生命周期中，在第一个<em class="lq"> ngOnChanges </em>调用<em class="lq">之后，这个方法只被调用<strong class="kw iu">一次</strong>。</em>此时，在<em class="lq"> </em>该方法中，您不仅可以访问<em class="lq">数据绑定属性</em>，还可以访问<em class="lq">组件的输入属性</em>。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="178d" class="lw lx it ls b gy ly lz l ma mb">export class MyComponent implements <strong class="ls iu">OnInit </strong>{</span><span id="53a7" class="lw lx it ls b gy mc lz l ma mb">  <strong class="ls iu">ngOnInit() {</strong><br/>      // Insert Logic Here!<br/>  <strong class="ls iu">}</strong></span><span id="5022" class="lw lx it ls b gy mc lz l ma mb">}</span></pre><p id="d865" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是Angular中最常用的<em class="lq">生命周期挂钩</em>之一。在这里，您可以设置对服务器的请求以加载内容，可以为该组件处理的表单创建一个<em class="lq">表单组</em>，设置订阅等等。基本上，<strong class="kw iu"> <em class="lq">在组件构建完成后不久，您就可以在这里执行任何初始化。</em></strong></p><p id="5b4c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设您有一个注册表单组件，您希望基于从服务器接收的字段创建表单，这些字段是根据用户类型获取的。下面是一个如何使用<em class="lq"> ngOnInit </em>来实现这一点的例子。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="186e" class="lw lx it ls b gy ly lz l ma mb">export class RegisterFormComponent implements OnInit {</span><span id="958a" class="lw lx it ls b gy mc lz l ma mb">  public formGroup: FormGroup;<br/>  private _userType: UserTypeEnum;</span><span id="187e" class="lw lx it ls b gy mc lz l ma mb">  constructor(<br/>    private _activatedRoute: ActivatedRoute,<br/>    private _myService: MyService<br/>  ) {<br/>    this._userType =<br/>      this._activatedRoute.snapshot.paramMap.get('userType');<br/>  }</span><span id="02fa" class="lw lx it ls b gy mc lz l ma mb">  ngOnInit() {<br/>    this._myService.getFormFieldsByType(<br/>      this._userType<br/>    ).subscribe((response) =&gt; {<br/>      this.formGroup = this._createForm(<br/>        response.data<br/>      );<br/>    }, (error) =&gt; console.error( error ) );<br/>  <!-- -->}</span><span id="8928" class="lw lx it ls b gy mc lz l ma mb">  private _createForm(formFields: Array&lt;FormFields&gt;): FormGroup {<br/>    // FormGroup Creation Logic!<br/>  }</span><span id="1e6c" class="lw lx it ls b gy mc lz l ma mb">}</span></pre></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h2 id="c215" class="lw lx it bd mk ml mm dn mn mo mp dp mq ld mr ms mt lh mu mv mw ll mx my mz na bi translated">Obs:建造师vs <em class="nh">恩戈尼特</em>？</h2><p id="55b5" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">也许你想知道为什么把你的初始化逻辑放在<em class="lq"> ngOnInit </em>里面，当你可以在类<em class="lq">构造函数中做的时候。嗯，基本上构造函数最好留给依赖注入使用，我们的初始化逻辑应该放在<em class="lq"> ngOnInit </em>上。</em></p><p id="7d8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">这是因为<em class="lq"> Javascript </em>引擎处理的是<em class="lq">构造器</em>，而不是<em class="lq"> Angular </em>。这也是为什么<em class="lq"> ngOnInit </em>钩子被创建的原因之一，它被Angular调用，并成为由其管理的组件的<em class="lq">生命周期</em>的一部分。当然，这也是因为你还不能在构造函数上访问组件的输入属性。</strong></p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h2 id="9b3d" class="lw lx it bd mk ml mm dn mn mo mp dp mq ld mr ms mt lh mu mv mw ll mx my mz na bi translated">ngDoCheck</h2><p id="60cd" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">这个钩子可以解释为<em class="lq"> ngOnChanges的<em class="lq">【扩展】</em>。</em>你可以用这个方法<strong class="kw iu">检测出Angular</strong>检测不到或者不会检测到的变化。在<em class="lq"> ngOnChanges </em>和<em class="lq"> ngOnInit </em>钩子之后，每次变化检测时，它都被调用。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="c88a" class="lw lx it ls b gy ly lz l ma mb">export class MyComponent implements DoCheck {</span><span id="88dd" class="lw lx it ls b gy mc lz l ma mb">  ...<br/>  private _currentValue;<br/>  private _previousValue;<br/>  public changeDetected: boolean = false;<br/>  ...</span><span id="b7dc" class="lw lx it ls b gy mc lz l ma mb">  ngDoCheck() {<br/>    if (this._previousValue !== this._currentValue) {<br/>      this.changeDetected = true;<br/>      // Insert Logic Here<br/>    }<br/>  }</span><span id="d8f3" class="lw lx it ls b gy mc lz l ma mb">}</span></pre><p id="49ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Obs:这个钩子真的很昂贵，因为它被调用的频率非常高；在每个变化检测周期之后，不管变化发生在哪里。因此，为了不影响用户体验，其使用应谨慎。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h2 id="3650" class="lw lx it bd mk ml mm dn mn mo mp dp mq ld mr ms mt lh mu mv mw ll mx my mz na bi translated">后续内容和后续视图</h2><p id="10b9" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">在我们讨论这些挂钩之前，首先我们需要了解它们与什么相关:</p><blockquote class="ni nj nk"><p id="f09a" class="ku kv lq kw b kx ky ju kz la lb jx lc nl le lf lg nm li lj lk nn lm ln lo lp im bi translated">AfterContent挂钩关注的是<code class="fe no np nq ls b"><a class="ae ng" href="https://angular.io/api/core/ContentChildren" rel="noopener ugc nofollow" target="_blank"><em class="it">ContentChildren</em></a></code>，投射到组件中的子组件。</p><p id="ca7b" class="ku kv lq kw b kx ky ju kz la lb jx lc nl le lf lg nm li lj lk nn lm ln lo lp im bi translated">AfterView挂钩关注的是<code class="fe no np nq ls b"><a class="ae ng" href="https://angular.io/api/core/ViewChildren" rel="noopener ugc nofollow" target="_blank">ViewChildren</a></code>，其元素标签出现在组件模板中的<em class="it">子组件。"</em></p></blockquote><p id="028a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了说明我们正在讨论的内容，假设我们有下面的组件，它既有<em class="lq"> ContentChild </em>又有<em class="lq"> ViewChild。</em>我们将有一个<em class="lq"> ng-content </em>标签，它将呈现从父节点传递过来的<em class="lq">内容</em>，以及一个对<em class="lq"> div ViewChild ( </em>，我们称之为<em class="lq">包装器)</em>的引用。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="2091" class="lw lx it ls b gy ly lz l ma mb">@Component({<br/>  selector: 'my-component',<br/>  template: `<br/>    &lt;div <strong class="ls iu">#wrapper</strong> &gt;<br/>      <strong class="ls iu">&lt;ng-content&gt;&lt;/ng-content&gt;</strong><br/>    &lt;/div&gt;`<br/>})<br/>export class MyComponent implements {</span><span id="7202" class="lw lx it ls b gy mc lz l ma mb"> <strong class="ls iu"> @ViewChild('wrapper')</strong> wrapper: ElementRef;<br/>  <strong class="ls iu">@ContentChild('content')</strong> content: ElementRef;<br/><br/>}</span></pre></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h2 id="9b86" class="lw lx it bd mk ml mm dn mn mo mp dp mq ld mr ms mt lh mu mv mw ll mx my mz na bi translated">ngAfterContentInit</h2><p id="f0b8" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">在组件的生命周期中，在第一次<em class="lq"> ngDoCheck之后，这个方法只被调用一次。</em>在这个钩子中，我们在组件创建后第一次访问了<em class="lq"> ContentChild </em>的<em class="lq">element ref</em>；在Angular已经将外部内容投影到组件视图中之后。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="1e65" class="lw lx it ls b gy ly lz l ma mb">@Component({<br/>  selector: 'my-component',<br/>  template: `<br/>    &lt;div&gt;<br/>      &lt;ng-content&gt;&lt;/ng-content&gt;<br/>    &lt;/div&gt;`<br/>})<br/>export class MyComponent implements <strong class="ls iu">AfterContentInit </strong>{</span><span id="dd56" class="lw lx it ls b gy mc lz l ma mb">  @ContentChild('content') content: ElementRef;<br/><br/>  <strong class="ls iu">ngAfterContentInit() {</strong><br/>    // Now we have access to 'this.content'!<br/>    // Insert Logic Here!<br/>  <strong class="ls iu">}</strong><br/>}</span></pre><h2 id="482e" class="lw lx it bd mk ml mm dn mn mo mp dp mq ld mr ms mt lh mu mv mw ll mx my mz na bi translated">ngAfterContentChecked</h2><p id="0c71" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">在组件的生命周期中，在<em class="lq"> ngAfterContentInit </em>之后调用<strong class="kw iu">一次</strong>，然后在<strong class="kw iu">之后每</strong>次<em class="lq"> ngDoCheck调用一次。</em>在Angular已经<em class="lq">检查过</em>投射到<em class="lq">当前摘要循环</em>中组件的内容后调用。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="155c" class="lw lx it ls b gy ly lz l ma mb">@Component({<br/>  selector: 'my-component',<br/>  template: `<br/>    &lt;div&gt;<br/>      &lt;ng-content&gt;&lt;/ng-content&gt;<br/>    &lt;/div&gt;`<br/>})<br/>export class MyComponent implements <strong class="ls iu">AfterContentChecked </strong>{</span><span id="bd1c" class="lw lx it ls b gy mc lz l ma mb">  @ContentChild('content') content: ElementRef;<br/><br/>  <strong class="ls iu">ngAfterContentChecked() {</strong><br/>    // We have access to 'this.content'!<br/>    // Content has already been checked!<br/>    // Insert Logic Here!<br/>  <strong class="ls iu">}</strong><br/>}</span></pre></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h2 id="feec" class="lw lx it bd mk ml mm dn mn mo mp dp mq ld mr ms mt lh mu mv mw ll mx my mz na bi translated">ngAfterViewInit</h2><p id="52ba" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">在组件的生命周期中，在<em class="lq"> ngAfterContentChecked之后，这个方法只被调用<strong class="kw iu">一次</strong>。</em>在这个钩子中，我们在组件创建后第一次访问了<em class="lq"> ViewChildren </em>的<em class="lq">element refs</em>；在Angular已经组合了组件的视图及其子视图之后。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="818f" class="lw lx it ls b gy ly lz l ma mb">@Component({<br/>  selector: 'my-component',<br/>  template: `<br/>    &lt;div #wrapper &gt;<br/>      ...<br/>    &lt;/div&gt;`<br/>})<br/>export class MyComponent implements <strong class="ls iu">AfterViewInit </strong>{</span><span id="c3a0" class="lw lx it ls b gy mc lz l ma mb">  @ViewChild('wrapper') wrapper: ElementRef;<br/><br/>  <strong class="ls iu">ngAfterViewInit() {</strong><br/>    // Now we have access to 'this.wrapper'<br/>    // Insert Logic Here!<br/>  <strong class="ls iu">}</strong><br/><br/>}</span></pre><p id="f927" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您需要在依赖于视图组件的视图上加载内容时，这个钩子非常有用；例如当你需要设置一个<em class="lq">视频播放器</em>或者从一个画布元素创建一个<em class="lq">图表</em>的时候。下面是一个如何使用<em class="lq">ngafterview it</em>钩子设置<em class="lq">图表</em>的例子。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="c44c" class="lw lx it ls b gy ly lz l ma mb">@Component({<br/>  selector: 'my-component',<br/>  template: `<br/>    &lt;div&gt;<br/>      &lt;canvas <!-- -->id="myCanvas" <!-- -->&gt;&lt;/canvas&gt;<br/>    &lt;/div&gt;`<br/>})<br/>export class MyComponent implements <strong class="ls iu">AfterViewInit </strong>{</span><span id="437a" class="lw lx it ls b gy mc lz l ma mb">  <strong class="ls iu">ngAfterViewInit() {</strong><br/>    // Now we can get the <em class="lq">canvas </em>element by its <em class="lq">id<br/>    </em>// in order to create the chart</span><span id="aa30" class="lw lx it ls b gy mc lz l ma mb">    <!-- -->this.chart = new Chart('radarCanvas', {<br/>      ...<br/>    });<br/>  <strong class="ls iu">}</strong><br/>}</span></pre><h2 id="629e" class="lw lx it bd mk ml mm dn mn mo mp dp mq ld mr ms mt lh mu mv mw ll mx my mz na bi translated">ngAfterViewChecked</h2><p id="cb8f" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">该方法在<em class="lq">ngafterview</em>之后调用一次<strong class="kw iu">，然后在<strong class="kw iu">之后每</strong>次<em class="lq"> ngAfterContentChecked </em>调用一次。在Angular已经在<em class="lq">当前摘要循环</em>中<em class="lq">检查了</em>组件的视图及其子视图后，调用该函数。</strong></p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="6fc4" class="lw lx it ls b gy ly lz l ma mb">@Component({<br/>  selector: 'my-component',<br/>  template: `<br/>    &lt;div #wrapper &gt;<br/>      ...<br/>    &lt;/div&gt;`<br/>})<br/>export class MyComponent implements <strong class="ls iu">AfterViewChecked </strong>{</span><span id="70a1" class="lw lx it ls b gy mc lz l ma mb">  @ViewChild('wrapper') wrapper: ElementRef;<br/><br/>  <strong class="ls iu">ngAfterViewChecked() {</strong><br/>    // Now we have access to 'this.wrapper'!<br/>    // View has already been checked!<br/>    // Insert Logic Here!<br/>  <strong class="ls iu">}</strong><br/>}</span></pre></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h2 id="0040" class="lw lx it bd mk ml mm dn mn mo mp dp mq ld mr ms mt lh mu mv mw ll mx my mz na bi translated">OBS:<em class="nh">ExpressionChangedAfterItHasBeenCheckedError</em></h2><blockquote class="ni nj nk"><p id="0d71" class="ku kv lq kw b kx ky ju kz la lb jx lc nl le lf lg nm li lj lk nn lm ln lo lp im bi translated">Angular的单向数据流规则禁止在视图合成后对其进行更新。这两个钩子(AfterViewInit和AfterViewChecked)在组件的视图组成后触发<em class="it">。</em></p></blockquote><p id="0949" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面引用自Angular Docs的<em class="lq"> obs </em>触发了著名的<em class="lq">ExpressionChangedAfterItHasBeenCheckedError。</em>了解何时使用这些<em class="lq">生命周期挂钩</em>有助于避免这种情况。如果你想了解更多，以及Angular的变化检测是如何工作的，你可以查看这篇文章。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h2 id="c35c" class="lw lx it bd mk ml mm dn mn mo mp dp mq ld mr ms mt lh mu mv mw ll mx my mz na bi translated">恩贡德斯特罗伊</h2><p id="89a3" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">最后，这个方法在组件的生命周期中只被调用一次，就在角度销毁它<em class="lq">之前。</em>您应该在这里通知应用程序的其余部分，组件正在被销毁，以防需要对该信息执行任何操作。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="0775" class="lw lx it ls b gy ly lz l ma mb">export class MyComponent implements <strong class="ls iu">OnDestroy </strong>{</span><span id="7c1e" class="lw lx it ls b gy mc lz l ma mb">  <strong class="ls iu">ngOnDestroy() {</strong><br/>      // Insert Logic Here!<br/>  <strong class="ls iu">}</strong></span><span id="bcd7" class="lw lx it ls b gy mc lz l ma mb">}</span></pre><p id="fa74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这也是你应该为组件放置所有的<strong class="kw iu">清理逻辑</strong>的地方。例如，在这里您可以删除任何<em class="lq"> localstorage </em>信息，最重要的是，取消订阅<em class="lq">observables/</em>detach<em class="lq">event handlers/</em>stop<em class="lq">timers，等等。</em> <strong class="kw iu">避免内存泄露</strong>。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="afff" class="lw lx it ls b gy ly lz l ma mb">export class MyComponent implements OnDestroy {</span><span id="be86" class="lw lx it ls b gy mc lz l ma mb">  private _mySubject: Subject&lt;string&gt; = new Subject();</span><span id="f56f" class="lw lx it ls b gy mc lz l ma mb">  ...</span><span id="82e9" class="lw lx it ls b gy mc lz l ma mb">  ngOnDestroy() {<br/>    localStorage.removeItem('storageKey');<br/>    this._searchSubject.unsubscribe();<br/>  }</span><span id="0798" class="lw lx it ls b gy mc lz l ma mb">}</span></pre><p id="bdf6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq"> Obs:当用户刷新页面或关闭浏览器时，不调用ngOnDestroy。因此，如果您需要在这些情况下处理一些清理逻辑，您可以使用HostListener描述符，如下所示:</em></p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="a2a7" class="lw lx it ls b gy ly lz l ma mb">  @HostListener(‘window:beforeunload’)<br/>  ngOnDestroy() {<br/>     // Insert Logic Here!<br/>  }</span></pre></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><p id="dc47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">理解<em class="lq">Angular life cycle钩子、</em>它们的<em class="lq"> </em>目标以及它们何时被调用，在创建Angular应用程序时会非常有用。因此，重要的是要知道它们是如何工作的，以及你可以用它们实现什么，以便能够在你可能需要的时候应用它们。</p><p id="d0a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">希望有帮助！😉</p><h1 id="8a12" class="nr lx it bd mk ns nt nu mn nv nw nx mq jz ny ka mt kc nz kd mw kf oa kg mz ob bi translated">参考资料:</h1><p id="a222" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated"><a class="ae ng" href="https://angular.io/guide/lifecycle-hooks" rel="noopener ugc nofollow" target="_blank">https://angular.io/guide/lifecycle-hooks</a></p><p id="8643" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae ng" href="https://hackernoon.com/everything-you-need-to-know-about-the-expressionchangedafterithasbeencheckederror-error-e3fd9ce7dbb4" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/everything-you-need-know-on-the-expression changedafterithasbeencheckederror-error-E3 FD 9 ce 7 db 4</a></p></div></div>    
</body>
</html>