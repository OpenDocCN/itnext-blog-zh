<html>
<head>
<title>BEM Grandchildren: How To Handle Deeply Nested Elements</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BEM孙代:如何处理深度嵌套元素</h1>
<blockquote>原文：<a href="https://itnext.io/bem-grandchildren-how-to-handle-deeply-nested-elements-da2e5dc18a4b?source=collection_archive---------7-----------------------#2020-01-21">https://itnext.io/bem-grandchildren-how-to-handle-deeply-nested-elements-da2e5dc18a4b?source=collection_archive---------7-----------------------#2020-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1000" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">理解BEM  【块、元素和修改器】的<a class="ae ko" href="https://scalablecss.com/bem-quickstart-guide/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">基本概念是一个相当容易掌握的概念。</strong></a></p><p id="b670" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，当元素开始在一个块中嵌套3或4层时，事情很容易失控。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/f37dd74f2c50bf73b6719eff3dd8b8cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n6tL1ndPlPYpjS3wNtC7Rw.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">在BEM筑巢没有这些俄罗斯娃娃恐怖</figcaption></figure><p id="23a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些嵌套元素通常被称为“孙”元素(因为它们嵌套了两层)。</p><p id="d65a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我将讨论如何解决这些常见问题，并遵循BEM最佳实践。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="c4e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">奖励:</strong> <a class="ae ko" href="https://scalablecss.com/resource/bem-cheat-sheet/" rel="noopener ugc nofollow" target="_blank">下载一份免费的备忘单</a>，它将向您展示如何快速入门BEM。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="01df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">准备好了吗？让我们开始吧。</p><h1 id="baa0" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">将元素链接在一起——典型的孙辈错误</h1><p id="3e60" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">下面是有多少人用边界元法解决了元素内嵌套元素的问题:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ac7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">遵循这种链接元素的方法(比如:<code class="fe mr ms mt mu b">.nav__menu__item__link</code>)很快就会失控。</p><p id="789e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这使得你的类名难以阅读，更不用说它会不必要地增加你的HTML和CSS文件。</p><p id="40c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方法也遵循DOM的结构，如果HTML的结构发生变化，这将限制您的灵活性。</p><p id="ee5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不要只相信我的话。Yandex团队的Vladimir Grinenko(BEM方法的创建者)说:</p><blockquote class="mv mw mx"><p id="e628" class="jq jr my js b jt ju jv jw jx jy jz ka mz kc kd ke na kg kh ki nb kk kl km kn im bi translated">BEM方法不建议在类名中的元素内使用元素。在命名上不需要类似DOM结构。拥有一个层级结构会让重构变得容易得多。”<br/> —弗拉基米尔·格里年科，Yandex</p></blockquote><p id="eb90" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，假设您意识到需要在<code class="fe mr ms mt mu b">&lt;nav&gt;</code>中添加一个<code class="fe mr ms mt mu b">&lt;div&gt;</code>:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="0e60" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">需要更新<code class="fe mr ms mt mu b">&lt;div&gt;</code>中的所有类，以及更新CSS文件中的类名。</p><p id="b0ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以你可以看到，采取<code class="fe mr ms mt mu b">Block__Element__Element__Element</code>不是一个长期的、可持续的选择。</p><p id="f983" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是更好的解决方法:</p><h1 id="b7b5" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">孙子解决方案</h1><p id="9f87" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">不要像<code class="fe mr ms mt mu b">nav__menu__item__link</code>那样链接元素，只需关注块名本身，并使用它作为主锚:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="0d38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">采用这种方法还会使您的代码对其他开发人员来说更具可读性，因为他们可以很容易地看到与该块有关系的所有元素(在本例中是:<code class="fe mr ms mt mu b">.nav</code>)。</p><p id="fa2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果将来需要添加或删除HTML元素，不需要重构:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="eeda" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您发现自己进入了元素深度超过3层的领域，您可能需要重新考虑块的结构，甚至可能将块分成更小的块。</p><p id="8195" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样！</p><p id="edfb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望这篇文章已经帮助您解决了“孙子”的问题。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="6f6d" class="lm ln it bd lo lp nc lr ls lt nd lv lw lx ne lz ma mb nf md me mf ng mh mi mj bi translated">下载免费的BEM备忘单</h1><p id="1b15" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">想开始练习BEM并寻找一本实用的快速行动指南吗？</p><p id="9316" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://scalablecss.com/resource/bem-cheat-sheet" rel="noopener ugc nofollow" target="_blank">下载一份涵盖BEM基础知识的免费备忘单</a>,以便您今天就可以开始练习。</p></div></div>    
</body>
</html>