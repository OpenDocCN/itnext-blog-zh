<html>
<head>
<title>A “Kiss architecture”: Spring boot + Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个“吻建筑”:弹簧靴+棱角分明</h1>
<blockquote>原文：<a href="https://itnext.io/a-kiss-architecture-springboot-angular-2ca6adf48271?source=collection_archive---------1-----------------------#2018-11-13">https://itnext.io/a-kiss-architecture-springboot-angular-2ca6adf48271?source=collection_archive---------1-----------------------#2018-11-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/88e1522738057e740b8e2887c556125c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eEW8D1X4qw7LPv6m"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">《树枝上的两只鸟》由<a class="ae jd" href="https://unsplash.com/@jonah_jpg?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔纳·佩特里奇</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上演</figcaption></figure><div class=""/><p id="c213" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就像维基百科建议的那样，<strong class="kf jh"> KISS </strong>是</p><blockquote class="lb lc ld"><p id="9fe7" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">简单点，笨蛋</p></blockquote><p id="f04d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为美国海军在1960年提出的设计原则。KISS原则指出，如果系统保持简单而不是变得复杂，大多数系统会工作得最好；因此，简单应该是设计中的一个关键目标，应该避免不必要的复杂性。这个短语与飞机工程师凯利·约翰逊联系在一起。</p><p id="98ce" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据我的经验，我从事过许多类型的技术，有机会从客户端(可以是SPA或本地应用程序)和服务器端检查源代码和应用程序的开发。依靠这样的经验，我试图开发一个简单的架构，它在一个<strong class="kf jh"> CRUD </strong>环境中包含了对基本<strong class="kf jh">模式</strong>的尊重。我将阐述这个架构的基础，作为我所有项目的起点。</p><p id="7911" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在设计中，我牢记KISS的概念，从这个角度来看，我将提供5层，即众所周知的层，并有一个特定的完成任务:</p><ul class=""><li id="013b" class="li lj jg kf b kg kh kk kl ko lk ks ll kw lm la ln lo lp lq bi translated">前端</li><li id="9a2e" class="li lj jg kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">应用程序接口</li><li id="1a44" class="li lj jg kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">业务逻辑</li><li id="8397" class="li lj jg kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">综合</li><li id="74c4" class="li lj jg kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">数据访问对象(Data Access Object)</li></ul><p id="b422" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我使用一个<em class="le">多层</em>架构模型。列表中的层顺序与信息流严格相关，所以从前端到DAO</p><figure class="lx ly lz ma gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lw"><img src="../Images/02629cc13f04c4db39fde3774a542333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FQRODMcECQGFv_r8ghe7nQ.png"/></div></div></figure><p id="75f0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">文章引用了可在链接<a class="ae jd" href="https://github.com/paspao/springboot-kiss-architecture" rel="noopener ugc nofollow" target="_blank">https://github.com/paspao/springboot-kiss-architecture</a>下载的项目</p><p id="982a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mb mc md me b">git clone <a class="ae jd" href="https://github.com/paspao/springboot-kiss-architecture" rel="noopener ugc nofollow" target="_blank">https://github.com/paspao/springboot-kiss-architecture</a></code></p><p id="2a0f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<em class="le"> maven </em>管理项目(即父类型和子类型)；即使在Angular中开发的前端被包括在<em class="le"> maven </em>构建阶段，以便创建单个工件(进一步的细节可在下面的<strong class="kf jh">前端</strong>段落中获得)。</p><p id="38a2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要深入每一层，我更喜欢使用<em class="le">自下而上</em>的方法，所以让我们从数据开始。</p><h1 id="1363" class="mf mg jg bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">数据访问对象(Data Access Object)</h1><p id="1564" class="pw-post-body-paragraph kd ke jg kf b kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated">数据访问对象。我说的是CRUD应用程序，即需要收集和处理的数据。这个模块代表了最深的一点。这一层执行数据，它描述实体和访问逻辑。注意:插入、修改、删除和显示数据的简单数据访问逻辑，与其他层没有任何绑定；它是最深的一层，也不依赖于它的任何兄弟，它不处理应用程序的特定方面，如授权、交易或其他:也只是以独占方式访问数据。在Springboot上下文中，我正在执行<strong class="kf jh">实体</strong>和<strong class="kf jh">存储库范例。</strong></p><figure class="lx ly lz ma gt is"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="eaaa" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我定义了<em class="le">组件、实体和存储库</em>的位置。此外，我启用了事务，所以任何使用DAO模块的人都不必担心配置DAO模块的问题。</p><h1 id="38ff" class="mf mg jg bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">综合</h1><p id="1335" class="pw-post-body-paragraph kd ke jg kf b kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated">简单的CRUD数据管理是不够的:我们可能需要与不依赖于我们的数据的其他系统进行互操作，例如JAX-WS或JAX-RS服务，或者使用不同协议的特定打印系统，等等。该组件包括所有这些交互/集成，而没有特定绑定到应用程序的上下文，以保证您具有非常高的可重用性(像DAO模块一样，这一层也是叶子类型)。</p><figure class="lx ly lz ma gt is"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="b8ac" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我展示了模块配置的中心点:只有一个对<strong class="kf jh">服务</strong>定义的引用和一个<em class="le">第三方</em>服务的实例(GeoApiContext)。</p><h1 id="4752" class="mf mg jg bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">业务逻辑</h1><p id="1f4a" class="pw-post-body-paragraph kd ke jg kf b kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated">在确定要处理的数据之后，每个应用程序都必须处理定义在DAO层中的实体之间的交互逻辑。您必须将用户需求与应用程序逻辑结合起来，将它们分解，然后向上层展示简单易读的<em class="le">签名</em>。因此，这一层允许开发人员进行一些处理，而无需进入数据库如何构造的细节或底层的集成是什么。</p><p id="4a60" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在这里发现<strong class="kf jh"> DTO </strong>的定义和用法有助于屏蔽存储在数据库系统或各种集成beans中的数据:为什么？<br/>有一些原因:首先，它是一种对敏感数据的信息隐藏形式(例如密码、时间戳或其他数据一致性所需的信息，但对最终用户没有)。相反，如果返回的数据需要详细说明(比如从多个来源组合的数据)，DTO会帮助以合适的方式组织这些数据。<br/>另一个方面是数据的序列化:在某些情况下，您必须转换数据库中的信息，使其可供人类使用。因此，开发人员必须用序列化逻辑“玷污”这些<em class="le">实体</em>，序列化逻辑的目的应该只是表示数据，例如:数据库系统上的日期字段可能是一个数字，但我们以可打印的方式表示它，所以我们可能会使用格式化注释；这是一个解决方案！但是在这种情况下，我们将把序列化的各个方面链接到一个实体，从长远来看，这种解决方案将导致不可用的代码。哈罗德·艾贝尔森说:</p><blockquote class="lb lc ld"><p id="fd92" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">程序必须写给人们阅读，并且只是附带地给机器执行。</p></blockquote><p id="f42f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">dto允许面对列出的问题，创建一个类似“缓冲区”的东西，因此有更多的松散耦合和更多的可重用性。</p><p id="fe61" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总之，业务逻辑与DAO层和集成层进行通信，在它们之间创建协同和交互。此外，它将逻辑和数据转换引入DTO，可供其他层使用。警告:业务逻辑层使用内部定义的DTO，这同样适用于返回的数据。它们<em class="le">从不</em>是在其他层中定义的对象，所以为了确保我们上面所说的，并提供处理返回数据的能力。</p><p id="109a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该层的另一个特性是事务管理:由于它实现了业务逻辑，所以它能够确定对数据的操作是否成功，因此定义了操作的“<strong class="kf jh">事务性</strong>”。</p><p id="19be" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是业务逻辑层的<strong class="kf jh">@配置</strong>:</p><figure class="lx ly lz ma gt is"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="8586" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它是唯一一个直接链接到DAO和集成层的模块，因此它必须导入配置才能使用它们。此外，为了加速实体和DTO之间的映射，使用为此而生的框架是一个很好的实践，避免长而不可读的<em class="le"> setter </em>和<em class="le"> getter </em>的代码块；在我的例子中，我使用了一个名为<strong class="kf jh"> Dozer </strong>的映射框架。</p><h1 id="634b" class="mf mg jg bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">应用程序接口</h1><p id="3d0c" class="pw-post-body-paragraph kd ke jg kf b kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated">在这一层是表示的逻辑，它代表了我们的应用程序的入口点，至少从服务器的角度来看是这样的。像JAX-RS或JAX-WS这样的服务被定义为主要任务是以XML、JSON或其他格式呈现数据。它只与业务逻辑层对话:一个服务将只调用业务层提供的一个或多个服务，它永远不会直接使用集成或DAO层，也不会使用它们内部定义的对象，以避免<em class="le">紧密耦合的</em>和<em class="le">意大利面代码</em>。</p><p id="f76b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它处理认证和授权的管理:在这里可以确定谁可以执行操作或不执行操作:在下面的层中要复杂得多，或者确定什么角色是必需的信息还不知道。</p><p id="671e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">API总是需要一些文档:REST世界缺乏的一点是缺少这些服务的通用描述符。保证这一点的技术是<strong class="kf jh"> Swagger </strong>(现在的OpenAPI):它允许记录API，但是生成的文档也可以重用来生成客户端部分，因此不仅仅是描述性的。例如，在我的例子中，与REST服务的通信层完全是由服务的Swagger描述生成的:在<strong class="kf jh">前端</strong>模块中有一个<em class="le">远程服务</em>文件夹，其中包含由工具<a class="ae jd" href="https://editor.swagger.io" rel="noopener ugc nofollow" target="_blank">https://editor . Swagger . io</a>生成的结果。</p><p id="e150" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在api层的配置类中，我导入了业务层的配置类，并设置了Swagger文档的生成。</p><figure class="lx ly lz ma gt is"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="3dbe" class="mf mg jg bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">前端</h1><p id="f3e0" class="pw-post-body-paragraph kd ke jg kf b kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated">它代表单页面应用程序:这种类型的应用程序必须与应用程序完全分离，Rest技术的使用已经保证了这一点，但是有必要注意与远程服务的通信是如何实现的。我经常陷入对用于调用远程服务的各种HTTP客户端的糟糕组织和管理中，我指的是在整个应用程序中找到的引用。为了解决这个问题，并使SPA与表示与远程服务通信的所有内容严格分离，正如已经提到的，我使用Swagger技术来生成一个允许与Rest API通信的存根。所以开发人员将使用Swagger产生的东西，主要是因为它提供了许多现成的代码，具有不同的使用选项，并且您不再需要重写它。此外，逻辑将在其他地方实现，因为远程通信部分(存根)将不断重新生成，没有开发人员会梦想在可能被覆盖的源代码中实现自己的逻辑(我希望如此)。</p><p id="6a6c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了确保用Angular编写的应用程序可以包含在Maven项目的构建周期中，我通过添加一个<em class="le"> pom.xml </em>文件来确保即使是<strong class="kf jh">前端</strong>也成为一个Maven模块。这个模块不会产生任何工件，所以打包将是<em class="le"> pom类型</em>，但是这样我可以将它插入到maven构建中，并与其兄弟创建依赖关系。为了能够在Maven环境中集成Angular构建，我使用了一个名为<em class="le"> frontend-maven-plugin </em>的插件:它允许安装一个<em class="le">节点</em>和<em class="le"> Npm </em>实例</p><figure class="lx ly lz ma gt is"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="6354" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以及随后调用Angular <em class="le"> CLI </em>来管理依赖关系和构建angular side。</p><figure class="lx ly lz ma gt is"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="55e2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当调用Npm构建任务时，将从Angular CLI获取控制权，如<em class="le"> package.json </em>中所述:</p><figure class="lx ly lz ma gt is"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="d89c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出路径设置为<em class="le">dist/resources/static/ui</em>，路径<em class="le"> dist/resources </em>也被配置为前端模块的<em class="le"> resource </em>。结合下面的层API配置，它允许在Springboot应用程序中注入Angular build的结果。在(package.json中的<em class="le"> build </em>命令的)输出路径中，有一个特殊的目录<strong class="kf jh"> …/static/… </strong>，Springboot允许在其中定义静态内容。</p><figure class="lx ly lz ma gt is"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="73f2" class="mf mg jg bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">建设</h1><p id="8913" class="pw-post-body-paragraph kd ke jg kf b kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated"><code class="fe mb mc md me b">mvn clean install</code></p><h1 id="d3ef" class="mf mg jg bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">奔跑</h1><p id="7aa5" class="pw-post-body-paragraph kd ke jg kf b kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated"><code class="fe mb mc md me b">java -jar api/target/api-0.0.1-SNAPSHOT.jar</code></p><p id="92d5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">转到网址<a class="ae jd" href="http://localhost:8080/kiss/" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/kiss/</a></p></div></div>    
</body>
</html>