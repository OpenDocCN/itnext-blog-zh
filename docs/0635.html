<html>
<head>
<title>Mastering Types In JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握JavaScript中的类型</h1>
<blockquote>原文：<a href="https://itnext.io/mastering-types-in-javascript-66c43338a274?source=collection_archive---------0-----------------------#2018-04-24">https://itnext.io/mastering-types-in-javascript-66c43338a274?source=collection_archive---------0-----------------------#2018-04-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7f988dfbadba6bfa2353113911312e21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OSnvi-i2FiwE7gXfNusHWA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">讨厌别人用与主体无关的图像，smh-)</figcaption></figure><p id="72da" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">读完这篇文章后，你会:</em></p><ul class=""><li id="acec" class="lb lc iq ke b kf kg kj kk kn ld kr le kv lf kz lg lh li lj bi translated"><em class="la">懂得如何用复杂的JavaScript来管理类型</em>  <em class="la">。</em></li><li id="5124" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><em class="la">不再向用户显示</em><strong class="ke ir"><em class="la"/></strong><em class="la"/><strong class="ke ir"><em class="la">Null</em></strong><em class="la">或</em><strong class="ke ir"><em class="la">undefined</em></strong><em class="la">。</em></li><li id="5bff" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><em class="la">学习如何</em> <strong class="ke ir"> <em class="la">类型检查</em> </strong> <em class="la">各种数据类型包括</em> <strong class="ke ir"> <em class="la">整数</em> </strong> <em class="la">和</em> <strong class="ke ir"> <em class="la">浮点数</em> </strong> <em class="la">。</em></li></ul><p id="860f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">除了基础知识之外，这里还有你在现实世界中构建可靠的关键业务应用程序所需要知道的关于JavaScript类型的一切。</p><blockquote class="lp"><p id="3e2d" class="lq lr iq bd ls lt lu lv lw lx ly kz dk translated">如果和平，就在战时</p></blockquote><h1 id="6a45" class="lz ma iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">**本文的先决条件**</h1><p id="d0d5" class="pw-post-body-paragraph kc kd iq ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz ij bi translated">可选地<a class="ae nc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring" rel="noopener ugc nofollow" target="_blank">析构</a>以使类型检查更具可读性。即</p><p id="237e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la"> is("yo "，" yo") === Object.is("yo "，" yo") </em></p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在你玩之前，复制并粘贴到你的开发工具中:</figcaption></figure><h1 id="c63f" class="lz ma iq bd mb mc md me mf mg mh mi mj mk nj mm mn mo nk mq mr ms nl mu mv mw bi translated">类型错误最常见的原因</h1><blockquote class="nm nn no"><p id="f0bc" class="kc kd la ke b kf kg kh ki kj kk kl km np ko kp kq nq ks kt ku nr kw kx ky kz ij bi translated"><strong class="ke ir">TL；避免对</strong>博士的<strong class="ke ir"> if </strong>和<strong class="ke ir">三元</strong>语句进行隐式强制；总是比较。</p></blockquote><p id="abbe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">依赖<strong class="ke ir">隐式强制</strong>获取条件会导致耗时的后果。因为它在大多数情况下都有效，所以需要训练来重新连接你的大脑以避免它。这样做可以避免将来浪费大量的调试时间。</p><h2 id="0ddc" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">千万不要这样</h2><ul class=""><li id="ef6e" class="lb lc iq ke b kf mx kj my kn oe kr of kv og kz lg lh li lj bi translated"><strong class="ke ir"> <em class="la"> if(值)</em> </strong> <em class="la"> </em> | <em class="la">问题:0，null，“”，未定义，强制值，NaN === false。可以看出，对于非布尔型来说，这是一条危险的捷径。</em></li><li id="d079" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><strong class="ke ir"><em class="la">if(type of value = = = " object ")</em></strong>|<em class="la">Null是对象，数组是对象</em></li><li id="bebb" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><strong class="ke ir">如果(expectedNumberValue) </strong> | <em class="la">再次0，NaN将要挟为假</em></li><li id="bfc8" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><strong class="ke ir">if(type of expected number = = = " number ")</strong>|<em class="la">NaN是一个数字</em></li><li id="f8a8" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><strong class="ke ir"> if(isNaN(value)) </strong> | <em class="la">避免因isNaN执行不熟悉的胁迫</em></li></ul><h2 id="0015" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">总是这样做</h2><ul class=""><li id="563e" class="lb lc iq ke b kf mx kj my kn oe kr of kv og kz lg lh li lj bi translated"><em class="la">显式布尔条件</em> <strong class="ke ir"> <em class="la"> if(值===真)</em></strong><em class="la">|</em><strong class="ke ir"><em class="la">if(值===假)</em> </strong></li><li id="a37b" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><em class="la">显式函数条件</em><strong class="ke ir"><em class="la">if(type of value = = = " function ")</em></strong></li><li id="9ecb" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><em class="la">显式空条件</em><strong class="ke ir"><em class="la">if(value = = = " ")</em></strong></li><li id="34e2" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><em class="la">显式零条件</em><strong class="ke ir"><em class="la">if(value = = = 0)</em></strong></li><li id="d169" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><em class="la">显式空条件</em><strong class="ke ir"><em class="la">if(value = = = null)</em></strong></li><li id="8d9d" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><em class="la">显式未定义条件</em><strong class="ke ir"><em class="la">if(value = = = undefined)</em></strong></li><li id="41ca" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><em class="la">显式NaN条件</em><strong class="ke ir"><em class="la">if(is(parse float(value)，NaN)) </em> </strong></li><li id="e801" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><em class="la">是安全的，建议使用</em><strong class="ke ir"><em class="la">null</em></strong><em class="la">，</em> <strong class="ke ir"> <em class="la">未定义</em> </strong> <em class="la">和</em> <strong class="ke ir"> <em class="la"> NAN </em> </strong></li><li id="5487" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated">使用=== over ==。<strong class="ke ir"> <em class="la"> </em> ==不是更快</strong>，===是显式，==是隐式</li></ul><h2 id="a22f" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">一个例外</h2><p id="5f28" class="pw-post-body-paragraph kc kd iq ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz ij bi translated">对于与条件相同范围内的<strong class="ke ir">无限布尔值</strong>和<strong class="ke ir">的表达式，下面的yes仍然是显式类型检查。</strong></p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="5cdf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">结论:<strong class="ke ir">用你所有的条件逻辑明确</strong>。</p><h1 id="bb34" class="lz ma iq bd mb mc md me mf mg mh mi mj mk nj mm mn mo nk mq mr ms nl mu mv mw bi translated">预防+治疗:何时“必须”执行检查？</h1><h2 id="e097" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">预防</h2><p id="be85" class="pw-post-body-paragraph kc kd iq ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz ij bi oh translated"><span class="l oi oj ok bm ol om on oo op di"> N </span> e <em class="la"> ar你认为是一个</em> <strong class="ke ir"> <em class="la">抽象层</em> </strong> <em class="la">或者</em> <strong class="ke ir"> <em class="la">关注</em> </strong> <em class="la">的开始那就是接收数据。您不必对抽象中的每个函数进行类型检查，但至少要检查入口点。</em></p><h2 id="3ec3" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">疗法</h2><p id="2a4f" class="pw-post-body-paragraph kc kd iq ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz ij bi translated"><em class="la">在</em> <strong class="ke ir"> <em class="la"> return语句</em> </strong> <em class="la">的最后一个阶段</em> <strong class="ke ir"> <em class="la">抽象层</em> </strong> <em class="la">或</em> <strong class="ke ir"> <em class="la">关注点</em> </strong> <em class="la">即专门向另一层、服务器或用户等提供数据。不需要对抽象中的每个return语句进行类型检查。</em></p><h2 id="62a1" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">在中间</h2><p id="86e0" class="pw-post-body-paragraph kc kd iq ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz ij bi translated">使用你的判断力来决定什么时候需要特定的类型检查，但是如果你发现你自己对每件事都进行类型检查，这很明显是因为你没有完全理解你的应用程序的整体情况。了解常见的 <a class="ae nc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures" rel="noopener ugc nofollow" target="_blank"> <em class="la">数据类型</em> </a> <em class="la">并熟悉</em> <a class="ae nc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness" rel="noopener ugc nofollow" target="_blank"> <em class="la">强制</em> </a> <em class="la">会有所帮助。</em></p><h2 id="e999" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">纯函数</h2><p id="2035" class="pw-post-body-paragraph kc kd iq ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz ij bi translated">不惜一切代价避免副作用。在可行的情况下使用<em class="la"> Object.freeze </em>、<em class="la"> Object.seal </em>和<em class="la"> const </em>。</p><p id="d62a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">是的，预防比治疗更可取。但是cure给了你保护和选择其他结局的选择。两者兼得。</p><h1 id="d5fb" class="lz ma iq bd mb mc md me mf mg mh mi mj mk nj mm mn mo nk mq mr ms nl mu mv mw bi translated">类型检查器</h1><p id="b975" class="pw-post-body-paragraph kc kd iq ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz ij bi translated">您很少需要下面列出的大多数“自定义助手”。管理JS动态类型最重要的方面是有条件地<strong class="ke ir">显式</strong>，正如反复提到的。</p><h2 id="1068" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">排列</h2><ul class=""><li id="5ab3" class="lb lc iq ke b kf mx kj my kn oe kr of kv og kz lg lh li lj bi translated"><em class="la"> isArray(值)</em></li></ul><h2 id="6588" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">布尔代数学体系的</h2><ul class=""><li id="f1be" class="lb lc iq ke b kf mx kj my kn oe kr of kv og kz lg lh li lj bi translated"><em class="la">值类型</em></li></ul><h2 id="b1d1" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">日期</h2><ul class=""><li id="301c" class="lb lc iq ke b kf mx kj my kn oe kr of kv og kz lg lh li lj bi translated"><em class="la">` $ { value } ` = = = ` $ { new Date(value . value of())} `</em></li></ul><h2 id="b0d1" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">错误</h2><ol class=""><li id="4a0f" class="lb lc iq ke b kf mx kj my kn oe kr of kv og kz oq lh li lj bi translated"><em class="la"> value.toString()。包含("错误")</em></li><li id="549b" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz oq lh li lj bi translated"><em class="la">` $ { value } ` . includes(" Error ")</em></li></ol><blockquote class="nm nn no"><p id="3539" class="kc kd la ke b kf kg kh ki kj kk kl km np ko kp kq nq ks kt ku nr kw kx ky kz ij bi translated">#2没有调用内部Object.prototype.toString方法，而是调用值的。如果值恰好是错误的，则引发toString方法。</p></blockquote><h2 id="85ba" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">功能</h2><ul class=""><li id="67f6" class="lb lc iq ke b kf mx kj my kn oe kr of kv og kz lg lh li lj bi translated"><em class="la">值类型</em></li></ul><h2 id="0cab" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">空</h2><ol class=""><li id="2928" class="lb lc iq ke b kf mx kj my kn oe kr of kv og kz oq lh li lj bi translated"><em class="la">值===空</em></li><li id="c727" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz oq lh li lj bi translated"><em class="la">是(值，空)</em></li></ol><blockquote class="nm nn no"><p id="4cfb" class="kc kd la ke b kf kg kh ki kj kk kl km np ko kp kq nq ks kt ku nr kw kx ky kz ij bi translated">众所周知，typeof null === "object "</p></blockquote><h2 id="3d34" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">数量:包括南</h2><ul class=""><li id="32d0" class="lb lc iq ke b kf mx kj my kn oe kr of kv og kz lg lh li lj bi translated"><em class="la">值类型</em></li></ul><h2 id="d220" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">编号:隐楠</h2><ul class=""><li id="6b36" class="lb lc iq ke b kf mx kj my kn oe kr of kv og kz lg lh li lj bi translated"><em class="la">！is(parseFloat(value)，NaN) </em></li></ul><blockquote class="nm nn no"><p id="0c81" class="kc kd la ke b kf kg kh ki kj kk kl km np ko kp kq nq ks kt ku nr kw kx ky kz ij bi translated">该值将被强制为浮点数或NaN。这通常比显式NaN类型检查更实用。以“0x”开头的字符串值。？？?"将被强制为预期的数字。</p></blockquote><h2 id="7eec" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">数字:显式NaN</h2><ul class=""><li id="2def" class="lb lc iq ke b kf mx kj my kn oe kr of kv og kz lg lh li lj bi translated"><em class="la">是(值，楠)</em></li></ul><blockquote class="nm nn no"><p id="8851" class="kc kd la ke b kf kg kh ki kj kk kl km np ko kp kq nq ks kt ku nr kw kx ky kz ij bi translated">没有强制，是直接检查值是否等于NaN。这比伊斯南更符合。例如<strong class="ke ir">是南({}) </strong> //真，<strong class="ke ir">是({}，南)</strong> //假。isNaN执行不一致的强制，并且NaN不使用比较运算符(===)，因此始终使用Object.is进行直接的no BS NaN比较。</p></blockquote><h2 id="b8e7" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">数量:整数</h2><ul class=""><li id="fdbc" class="lb lc iq ke b kf mx kj my kn oe kr of kv og kz lg lh li lj bi translated"><em class="la"> isInteger(值)</em></li></ul><blockquote class="nm nn no"><p id="0e48" class="kc kd la ke b kf kg kh ki kj kk kl km np ko kp kq nq ks kt ku nr kw kx ky kz ij bi translated">在运行时，以非10为基数表示的值在算术上被视为以10为基数，并且由于整数本质上是浮点型的，因此会进行有意义的处理。</p></blockquote><h2 id="64d1" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">数字:小数</h2><ul class=""><li id="4ab7" class="lb lc iq ke b kf mx kj my kn oe kr of kv og kz lg lh li lj bi translated"><em class="la">(数字(值)+" ")。包括(".")</em></li></ul><blockquote class="nm nn no"><p id="675d" class="kc kd la ke b kf kg kh ki kj kk kl km np ko kp kq nq ks kt ku nr kw kx ky kz ij bi translated">这并不是检查一个数字是否是浮点数，因为所有的JavaScript数字都是浮点数(因此isFloat()解析所有数字)。所以我们检查一个数是否是小数，因为它在真实世界的应用中更有用。</p><p id="2ff5" class="kc kd la ke b kf kg kh ki kj kk kl km np ko kp kq nq ks kt ku nr kw kx ky kz ij bi translated">该值被强制转换为数字，然后被强制转换为字符串。这确保了小数来自最终数值。</p></blockquote><h2 id="6e43" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">目标</h2><ul class=""><li id="f8ea" class="lb lc iq ke b kf mx kj my kn oe kr of kv og kz lg lh li lj bi translated">typeof value === "object" &amp;&amp;！isArray(value) &amp;&amp;！为(值，null)</li></ul><blockquote class="nm nn no"><p id="fe02" class="kc kd la ke b kf kg kh ki kj kk kl km np ko kp kq nq ks kt ku nr kw kx ky kz ij bi translated">有经验的开发人员“通常”避免使用原型链或。用于检查对象类型的构造函数，因为它们很容易被重新赋值。</p></blockquote><h2 id="052a" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">正则表达式</h2><ul class=""><li id="7641" class="lb lc iq ke b kf mx kj my kn oe kr of kv og kz lg lh li lj bi translated">is(正则表达式(值)，值)</li></ul><h2 id="be54" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">线</h2><ul class=""><li id="d020" class="lb lc iq ke b kf mx kj my kn oe kr of kv og kz lg lh li lj bi translated">值的类型</li></ul><h2 id="1cba" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">标志</h2><ul class=""><li id="32b0" class="lb lc iq ke b kf mx kj my kn oe kr of kv og kz lg lh li lj bi translated">值的类型</li></ul><h2 id="f6e8" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">不明确的</h2><ol class=""><li id="242c" class="lb lc iq ke b kf mx kj my kn oe kr of kv og kz oq lh li lj bi translated"><em class="la">未定义===未定义</em></li><li id="39f4" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz oq lh li lj bi translated"><em class="la">是(值，未定义)</em></li></ol><blockquote class="nm nn no"><p id="b1a9" class="kc kd la ke b kf kg kh ki kj kk kl km np ko kp kq nq ks kt ku nr kw kx ky kz ij bi translated">在ES6中，Undefined是不可变的，而在ES5中，使用“use strict”是安全的。</p></blockquote><p id="8e56" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面是上面列出的所有非内置助手:</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="3ffd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">看着不太吓人吧，而且太容易解剖了<em class="la">(上房)</em></p><p id="1691" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="la"> isObject </em> </strong>和<strong class="ke ir"> <em class="la"> isANaN </em> </strong> <em class="la">可能是典型应用中最常用的。使用原始类型的</em> <strong class="ke ir"> <em class="la">显式</em> </strong> <em class="la">将极大地减少对这些函数的需求。</em></p></div><div class="ab cl or os hu ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="ij ik il im in"><blockquote class="nm nn no"><p id="44f8" class="kc kd la ke b kf kg kh ki kj kk kl km np ko kp kq nq ks kt ku nr kw kx ky kz ij bi translated">事实:我的名字来源于朱利叶斯·凯撒(他显然是个混蛋)。本文的主题是“入乡随俗”，因为这是JavaScript而不是Java，所以不要偷懒，让我们继续一些动态类型的解决方案；)</p></blockquote></div><div class="ab cl or os hu ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="ij ik il im in"><h1 id="f030" class="lz ma iq bd mb mc oy me mf mg oz mi mj mk pa mm mn mo pb mq mr ms pc mu mv mw bi translated">重新分类对象</h1><p id="2c8a" class="pw-post-body-paragraph kc kd iq ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz ij bi translated">您可以使用<strong class="ke ir"><em class="la">symbol . tostring tag</em></strong>对可重写对象进行重新分类。把它想象成复杂的鸭子打字。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="44ff" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里显然没有真正的“类型检查”本身，但这是一种标记对象而不污染其属性集合(如果有的话)的方法。</p><h1 id="97b0" class="lz ma iq bd mb mc md me mf mg mh mi mj mk nj mm mn mo nk mq mr ms nl mu mv mw bi translated">原始包装对象</h1><p id="0bd3" class="pw-post-body-paragraph kc kd iq ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz ij bi translated"><em class="la">以下是有用的数据类型:</em></p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7702" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一些开发人员认为他们的存在是一个错误，但这实际上是ECMAScript规范的一部分。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="f520" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">出于可移植性的原因，您可以自由地向这些类型添加属性:</em></p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="f564" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">并且在不改变内部值的情况下随意使用它们:</em></p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="a011" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">之后你仍然可以像普通的原始变量一样使用这个对象:</em></p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="63e3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当你玩够了，你可以强迫包装者变成它的内在自我。无附带条件(眨眨眼):</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="4a83" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">没人告诉你的是，你可以很容易地检查他们的内在灵魂:</strong></p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/5ed054d978e813d77e40ff85de4da999.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/1*Ysx2Xwlft30obcLwbCLC4g.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae nc" href="https://www.youtube.com/watch?v=SFHi-Ik8-Wg" rel="noopener ugc nofollow" target="_blank">“你不知道，矮子就是一串！”</a> —桁条铃</figcaption></figure><p id="264c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我撒谎了吗？即使是20多年的JS开发者也能从这篇文章中学到一些新东西。</p><p id="a2d3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">原始对象包装上的最终势利眼。</p><blockquote class="lp"><p id="4413" class="lq lr iq bd ls lt lu lv lw lx ly kz dk translated">它们的存在并不意味着你需要过度使用它们。规矩点，有点礼貌。</p></blockquote><h1 id="5aad" class="lz ma iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">toString型跳棋</h1><p id="2cd0" class="pw-post-body-paragraph kc kd iq ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz ij bi translated">这是ECMAScript规范的一部分，它允许您检查对象的类的标记，如前面的示例所示。我编造了第二个例子，但它通常做同样的事情，但有重要的优点和缺点:</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="1cca" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la"> toString类型检查对于以下数据类型是可靠的:</em> <strong class="ke ir"> <em class="la">数组、布尔、日期、错误、函数、Null、数字、对象、正则表达式、字符串、</em> </strong> <em class="la">和</em> <strong class="ke ir"> <em class="la">未定义的</em> </strong> <em class="la">。其他数据类型可能在不同的浏览器和JS实现中不一致。</em></p><p id="eaa5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">尽管这种方法看起来像是一种捷径，但并不完全如此，因为它不能区分NaN、整数或小数。没有放之四海而皆准的解决方案，所有解决方案都一样有用。</p><h1 id="f1a2" class="lz ma iq bd mb mc md me mf mg mh mi mj mk nj mm mn mo nk mq mr ms nl mu mv mw bi translated">安全措施</h1><h2 id="14af" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">TL；博士；医生</h2><blockquote class="nm nn no"><p id="c84c" class="kc kd la ke b kf kg kh ki kj kk kl km np ko kp kq nq ks kt ku nr kw kx ky kz ij bi translated"><strong class="ke ir">没有回退值，不向用户输出任何内容。</strong></p></blockquote><p id="8e08" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">看到<strong class="ke ir"> <em class="la">空，总:$南</em> </strong> <em class="la">或者</em> <strong class="ke ir"> <em class="la">未定义</em></strong><em class="la">2018年还在网站上显示</em>真是可悲。开发人员通常将这些缺陷归咎于语言，但我可以向你保证这是100%的人为疏忽。</p><h2 id="329c" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">保护是最佳实践</h2><p id="0e44" class="pw-post-body-paragraph kc kd iq ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz ij bi translated">这会让你在最不经意的时候免于尴尬。</p><blockquote class="lp"><p id="7167" class="lq lr iq bd ls lt lu lv lw lx ly kz dk translated">始终为用户可能看到的所有动态内容提供一个/多个回退值。</p></blockquote><p id="9f45" class="pw-post-body-paragraph kc kd iq ke b kf pe kh ki kj pf kl km kn pg kp kq kr ph kt ku kv pi kx ky kz ij bi translated">在内容被呈现给<em class="la">(例如)</em>DOM之前立即这么做是很重要的。你不应该在保护之后操纵一个值。</p><h2 id="0800" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">保护字符串值</h2><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="2eed" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">保护数字值</h2><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="ab64" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">保护图像路径</h2><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="bc1f" class="lz ma iq bd mb mc md me mf mg mh mi mj mk nj mm mn mo nk mq mr ms nl mu mv mw bi translated">打破神话:</h1><p id="dcc8" class="pw-post-body-paragraph kc kd iq ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz ij bi translated">尽管有些人声称，没有类型系统可以让JavaScript执行得更快。所有类型系统<em class="la"> (TypeScript，PureScript，Flow)在运行时都使用动态类型</em>。</p><p id="022f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在大型代码库中，对类型的过度检查实际上会对性能产生负面影响(可能可以忽略不计)。</p><p id="a08f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">动态类型在JavaScript中一点也不慢。V8引擎有许多优化，你可以在上阅读<a class="ae nc" href="https://blog.ghaiklor.com/optimizations-tricks-in-v8-d284b6c8b183" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="0e1f" class="lz ma iq bd mb mc md me mf mg mh mi mj mk nj mm mn mo nk mq mr ms nl mu mv mw bi translated">结论</h1><p id="5430" class="pw-post-body-paragraph kc kd iq ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz ij bi translated">让我们回顾一下:</p><ul class=""><li id="4a1d" class="lb lc iq ke b kf kg kj kk kn ld kr le kv lf kz lg lh li lj bi translated"><em class="la">我们解决了JavaScript中</em> <strong class="ke ir"> <em class="la">类型</em> </strong> <em class="la"> </em> <strong class="ke ir"> <em class="la">错误</em> </strong> <em class="la">的最常见原因。</em></li><li id="d6fc" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><em class="la">一头扎进一个简单的</em> <strong class="ke ir"> <em class="la">预防+治疗</em> </strong> <em class="la">策略，在现实世界的代码基础上进行理想的动态类型检查。</em></li><li id="6a26" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><em class="la">查看了</em> <strong class="ke ir"> <em class="la">类型检查器</em> </strong> <em class="la">用于检查包括整数和f̶l̶o̶a̶t̶s小数在内的各种数据类型。(花车被点击-诱饵，我的坏)</em></li><li id="c1a2" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><em class="la">被认为是</em> <strong class="ke ir"> <em class="la">对对象进行重分类</em> </strong> <em class="la">一种对对象进行分类而不污染其键的方法。</em></li><li id="d507" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><em class="la">发现</em> <strong class="ke ir"> <em class="la">原始包装对象</em> </strong> <em class="la">并不是错误，你可以很容易地检查它们的类型。</em></li><li id="c022" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><em class="la">看了看</em> <strong class="ke ir"> <em class="la"> toString类型的Checkers </em> </strong> <em class="la">因为它们是专门为返回对象的内部分类而构建的，但是我们也知道它们对于检查内置对象是不可靠的。</em></li><li id="70bc" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><em class="la">发现</em> <strong class="ke ir"> <em class="la">安全保护</em> </strong> <em class="la">并承诺不再向用户显示null、NaN或undefined。画十字，希望数学。圆周率</em></li></ul><p id="8bf4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">虽然您可能不会在网上找到太多展示本文中提到的实践的例子，但是如果您很聪明，您可能已经得出结论，JavaScript是一种被极度误解的语言，并且许多人鄙视的一些怪癖中有一种美丽的艺术。</p><p id="73ac" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我在本文中创建了助手来解决生产应用程序中常见的问题，但是记住“最好的代码是没有代码”——有人在Twitter上说。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pj"><img src="../Images/61765ee83caa0b7ffc4b2003d316ccb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*Qw59aLJQNrhTq1Tcz54_bA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">当心这些可疑的打字者；-)</figcaption></figure><p id="c41d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我创建了一个JavaScript类型检查器，但是从那以后我的理念已经改变了，你真的不需要一个库来检查JavaScript类型，函数是如此的小和少，创建一个<a class="ae nc" href="https://gist.github.com/" rel="noopener ugc nofollow" target="_blank">要点</a>然后就到此为止。</p><h2 id="448d" class="ns ma iq bd mb nt nu dn mf nv nw dp mj kn nx ny mn kr nz oa mr kv ob oc mv od bi translated">感谢阅读；-)</h2><p id="9392" class="pw-post-body-paragraph kc kd iq ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz ij bi translated"><em class="la">彼此明确——比尔&amp;泰德；——)</em></p></div></div>    
</body>
</html>