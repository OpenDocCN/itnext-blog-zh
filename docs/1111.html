<html>
<head>
<title>React SVG radar chart</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应SVG雷达图</h1>
<blockquote>原文：<a href="https://itnext.io/react-svg-radar-chart-a89d15760e8?source=collection_archive---------6-----------------------#2018-07-23">https://itnext.io/react-svg-radar-chart-a89d15760e8?source=collection_archive---------6-----------------------#2018-07-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cfc9f7a890e4f42b8a6dbecd0d07ff16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YFroPGj9dpPx7nqf045AUQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">用React制作的漂亮SVG雷达图</figcaption></figure><p id="313b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">周围有很多库，用来创建图表，但是很多都很重。让我们看看如何用<em class="la"> React </em>构建<strong class="ke ir">雷达图</strong>。</p><p id="ed5a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我选择的图像格式是SVG，主要原因是:</p><ol class=""><li id="8d8d" class="lb lc iq ke b kf kg kj kk kn ld kr le kv lf kz lg lh li lj bi translated"><strong class="ke ir">分辨率</strong> : SVG图像是<em class="la">矢量</em>，由形状和填充组成，可以任意缩放，高分辨率打印。</li><li id="3853" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><strong class="ke ir">速度</strong> : SVG比其他图像格式重量轻，浏览器下载速度更快。(在我们的例子中，它们不是下载的，而是生成的)</li><li id="c935" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><strong class="ke ir">动画</strong>:我们可以添加任何种类的动画和CSS样式。</li><li id="50fb" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><strong class="ke ir">可访问性和SEO </strong>:谷歌索引SVG图片。</li></ol><h1 id="b1ae" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">让我们编码</h1><p id="ca47" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">让我们开始用React编码。</p><p id="d15b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了生成<strong class="ke ir"> SVG雷达图</strong>，我们将开始创建一个<em class="la"> React组件</em>，它将呈现一个空的(到目前为止)SVG。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="b317" class="nb lq iq mx b gy nc nd l ne nf">import React from 'react';</span><span id="9c0f" class="nb lq iq mx b gy ng nd l ne nf">const RadarChart = props =&gt; {<br/>  return (&lt;svg version="1"  width="450" height="450"&gt;&lt;/svg&gt;);<br/>};</span><span id="0ae9" class="nb lq iq mx b gy ng nd l ne nf">export default RadarChart;</span></pre><p id="628d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们要用雷达图填充空的SVG。</p><p id="f68e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在向图表添加任何对象之前，我们必须定义要显示的数据的数据结构。这些数据将是一个对象数组，其形状如下:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="6917" class="nb lq iq mx b gy nc nd l ne nf">const data = [<br/> {battery: 0.7, design: 1, useful: 0.9, speed: 0.67, weight: 0.8 },<br/> {battery: 0.6, design: 0.9, useful: 0.8, speed: 0.7, weight: 0.6 }<br/>];</span></pre><p id="443e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">数组的每个对象都由固定的属性组成，这些属性的值是0到1之间的一个数字。在上面的例子中，我们有两个数据系列，但我们可以添加一些其他的，或者只保留一个。我可能给你的建议是最多用3/4系列，不然数据可视化会太混乱。</p><h2 id="874e" class="nb lq iq bd lr nh ni dn lv nj nk dp lz kn nl nm md kr nn no mh kv np nq ml nr bi translated">画出刻度</h2><p id="5342" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">让我们继续看图表，画出刻度，经典的雷达同心圆。我们将创建<code class="fe ns nt nu mx b">scale</code>函数，为此我们需要知道:</p><ul class=""><li id="3a99" class="lb lc iq ke b kf kg kj kk kn ld kr le kv lf kz nv lh li lj bi translated">图表的大小，来计算圆的半径。</li><li id="5eda" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz nv lh li lj bi translated">圈数，我们想要多少圈。</li></ul><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="1d0c" class="nb lq iq mx b gy nc nd l ne nf">const chartSize = 450;<br/>const numberOfScales = 4;</span></pre><p id="4fd5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是函数。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="bee1" class="nb lq iq mx b gy nc nd l ne nf">const scale = value =&gt; (<br/>  &lt;circle <br/>    key={`scale-${value}`}<br/>    cx={0}<br/>    cy={0}<br/>    r={(value / numberOfScales * chartSize) / 2}<br/>    fill="#FAFAFA"<br/>    stroke="#999"<br/>    strokeWidth="0.2"<br/>  /&gt;<br/>);</span></pre><p id="1feb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了计算圆的半径(<code class="fe ns nt nu mx b">r</code>属性)，我们使用<code class="fe ns nt nu mx b">value</code>参数，其值为:<code class="fe ns nt nu mx b">(value / numberOfScales * chartSize) / 2</code>。值得注意的是，我们把圆心放在位置x = 0，y = 0。</p><p id="84a8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将根据需要多次调用<code class="fe ns nt nu mx b">scale</code>函数:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="5f98" class="nb lq iq mx b gy nc nd l ne nf">for (let i = numberOfScales; i &gt; 0; i--) {<br/>  scales.push(scale(i));<br/>}</span></pre><p id="cf70" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将<em class="la">组件</em>组装在一起将会是:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="95dd" class="nb lq iq mx b gy nc nd l ne nf">import React from 'react';</span><span id="55e4" class="nb lq iq mx b gy ng nd l ne nf">const data = [<br/>  { battery: 0.7, design: 1, useful: 0.9, speed: 0.67, weight: 0.8 },<br/>  { battery: 0.6, design: 0.9, useful: 0.8, speed: 0.7, weight: 0.6 }<br/>];</span><span id="fa56" class="nb lq iq mx b gy ng nd l ne nf">const chartSize = 450;<br/>const numberOfScales = 4;</span><span id="6451" class="nb lq iq mx b gy ng nd l ne nf">const scale = value =&gt; (<br/>  &lt;circle<br/>    key={`scale-${value}`}<br/>    cx={0}<br/>    cy={0}<br/>    r={((value / numberOfScales) * chartSize) / 2}<br/>    fill="#FAFAFA"<br/>    stroke="#999"<br/>    strokeWidth="0.2"<br/>  /&gt;<br/>);</span><span id="b63f" class="nb lq iq mx b gy ng nd l ne nf">const RadarChart = props =&gt; {<br/>  const groups = [];<br/>  const scales = [];<br/>  for (let i = numberOfScales; i &gt; 0; i--) {<br/>    scales.push(scale(i));<br/>  }<br/>  groups.push(&lt;g key={`scales`}&gt;{scales}&lt;/g&gt;);</span><span id="edef" class="nb lq iq mx b gy ng nd l ne nf">return (<br/>    &lt;svg<br/>      version="1"<br/>      ae nw" href="http://www.w3.org/2000/svg" rel="noopener ugc nofollow" target="_blank"&gt;http://www.w3.org/2000/svg"<br/>      width={chartSize}<br/>      height={chartSize}<br/>      viewBox={`0 0 ${chartSize} ${chartSize}`}<br/>    &gt;<br/>      &lt;g&gt;{groups}&lt;/g&gt;<br/>    &lt;/svg&gt;<br/>  );<br/>};<br/>export default RadarChart;</span></pre><p id="1164" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将中心设置在<code class="fe ns nt nu mx b">0,0</code>位置，因此结果将是:</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/4882b6df358723e242d5f805d4990e84.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*Yh9H24gVw53XaP1VB-2nyA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">雷达图的比例尺，在0，0位置</figcaption></figure><p id="15cc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们必须对组应用一个转换，在SVG的中间翻译它们，属性为<code class="fe ns nt nu mx b">transform</code>:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="f03f" class="nb lq iq mx b gy nc nd l ne nf">const middleOfChart = (chartSize / 2).toFixed(4);<br/>...<br/>&lt;g transform={`translate(${middleOfChart},${middleOfChart})`}&gt;{groups}&lt;/g&gt;</span></pre><p id="64d8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是结果:</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/bf4921f8cf5ff86f457061cb2d46da42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*RAPNVM7dJBwVFap_G970xw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">雷达图上的圆圈现在处于正确的位置。</figcaption></figure><h2 id="e597" class="nb lq iq bd lr nh ni dn lv nj nk dp lz kn nl nm md kr nn no mh kv np nq ml nr bi translated">形状</h2><p id="4273" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">让我们继续，画出图表的实际形状。</p><p id="e40b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们需要为每一个数据设定一个角度，知道在哪里划线。接下来，我们将添加一个组<code class="fe ns nt nu mx b">g</code>来放置形状。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="34a3" class="nb lq iq mx b gy nc nd l ne nf">const captions = Object.keys(data[0]);<br/>  const columns = captions.map((key, i, all) =&gt; {<br/>    return {<br/>      key,<br/>      angle: (Math.PI * 2 * i) / all.length<br/>    };<br/>  });<br/>  groups.push(&lt;g key={`groups}`}&gt;{data.map(shape(columns))}&lt;/g&gt;);</span></pre><p id="407d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们创建了<code class="fe ns nt nu mx b">shape</code>函数来绘制形状。这有点复杂，但是基本的概念是:对于数据中的每个序列，我们添加一个组<code class="fe ns nt nu mx b">g</code>，在那里我们会放一个<code class="fe ns nt nu mx b">path</code>。</p><p id="8e5c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe ns nt nu mx b">path</code>的<code class="fe ns nt nu mx b">d</code>属性是<em class="la">路径定义</em>，在这里面，我们可以使用一些<em class="la">函数</em>，我们将要使用:</p><ul class=""><li id="6387" class="lb lc iq ke b kf kg kj kk kn ld kr le kv lf kz nv lh li lj bi translated"><em class="la">移动到</em> ( <code class="fe ns nt nu mx b">M</code>):将光标移动到这个位置。</li><li id="a431" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz nv lh li lj bi translated"><em class="la">直线到</em> ( <code class="fe ns nt nu mx b">L</code> ): <em class="la"> </em>从这里的<em class="la">到那里的</em>画一条直线。</li><li id="7c81" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz nv lh li lj bi translated"><em class="la">关闭路径</em> ( <code class="fe ns nt nu mx b">z</code>):关闭路径。</li></ul><p id="f334" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了知道在哪里画线，我们需要使用一些三角学，所以我创建了函数<code class="fe ns nt nu mx b">polarToX</code>和<code class="fe ns nt nu mx b">polarToY</code>，它们使用余弦和我们之前计算的角度。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="cb66" class="nb lq iq mx b gy nc nd l ne nf">const polarToX = (angle, distance) =&gt; Math.cos(angle - Math.PI / 2) * distance * chartSize;<br/>const polarToY = (angle, distance) =&gt; Math.sin(angle - Math.PI / 2) * distance * chartSize;</span><span id="8f17" class="nb lq iq mx b gy ng nd l ne nf">const pathDefinition = points =&gt; {<br/>  let d = 'M' + points[0][0].toFixed(4) + ',' + points[0][1].toFixed(4);<br/>  for (let i = 1; i &lt; points.length; i++) {<br/>    d += 'L' + points[i][0].toFixed(4) + ',' + points[i][1].toFixed(4);<br/>  }<br/>  return d + 'z';<br/>};</span><span id="1fad" class="nb lq iq mx b gy ng nd l ne nf">const shape = (columns) =&gt; (chartData, i) =&gt; {<br/>  const data = chartData;<br/>  return (<br/>    &lt;path<br/>      key={`shape-${i}`}<br/>      d={pathDefinition(<br/>        columns.map(col =&gt; {<br/>          const value = data[col.key];<br/>          return [<br/>            polarToX(col.angle, (value) / 2),<br/>            polarToY(col.angle, (value) / 2)<br/>          ];<br/>        })<br/>      )}<br/>      stroke={`#edc951`}<br/>      fill={`#edc951`}<br/>      fillOpacity=".5"<br/>    /&gt;<br/>  );<br/>};</span></pre><p id="08d9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">同样，将所有代码放在一起，我们的代码将是:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="e8d1" class="nb lq iq mx b gy nc nd l ne nf">import React from 'react';</span><span id="6435" class="nb lq iq mx b gy ng nd l ne nf">const data = [<br/>  { battery: 0.7, design: 1, useful: 0.9, speed: 0.67, weight: 0.8 },<br/>  { battery: 0.6, design: 0.9, useful: 0.8, speed: 0.7, weight: 0.6 }<br/>];</span><span id="a6cb" class="nb lq iq mx b gy ng nd l ne nf">const chartSize = 450;<br/>const numberOfScales = 4;</span><span id="a032" class="nb lq iq mx b gy ng nd l ne nf">const scale = value =&gt; (<br/>  &lt;circle<br/>    key={`scale-${value}`}<br/>    cx={0}<br/>    cy={0}<br/>    r={((value / numberOfScales) * chartSize) / 2}<br/>    fill="#FAFAFA"<br/>    stroke="#999"<br/>    strokeWidth="0.2"<br/>  /&gt;<br/>);</span><span id="db40" class="nb lq iq mx b gy ng nd l ne nf">const polarToX = (angle, distance) =&gt; Math.cos(angle - Math.PI / 2) * distance;<br/>const polarToY = (angle, distance) =&gt; Math.sin(angle - Math.PI / 2) * distance;</span><span id="1912" class="nb lq iq mx b gy ng nd l ne nf">const pathDefinition = points =&gt; {<br/>  let d = 'M' + points[0][0].toFixed(4) + ',' + points[0][1].toFixed(4);<br/>  for (let i = 1; i &lt; points.length; i++) {<br/>    d += 'L' + points[i][0].toFixed(4) + ',' + points[i][1].toFixed(4);<br/>  }<br/>  return d + 'z';<br/>};</span><span id="07fd" class="nb lq iq mx b gy ng nd l ne nf">const shape = columns =&gt; (chartData, i) =&gt; {<br/>  const data = chartData;<br/>  return (<br/>    &lt;path<br/>      key={`shape-${i}`}<br/>      d={pathDefinition(<br/>        columns.map(col =&gt; {<br/>          const value = data[col.key];<br/>          return [<br/>            polarToX(col.angle, (value * chartSize) / 2),<br/>            polarToY(col.angle, (value * chartSize) / 2)<br/>          ];<br/>        })<br/>      )}<br/>      stroke={`#edc951`}<br/>      fill={`#edc951`}<br/>      fillOpacity=".5"<br/>    /&gt;<br/>  );<br/>};</span><span id="b5bd" class="nb lq iq mx b gy ng nd l ne nf">const RadarChart = props =&gt; {<br/>  const groups = [];<br/>  const scales = [];<br/>  for (let i = numberOfScales; i &gt; 0; i--) {<br/>    scales.push(scale(i));<br/>  }<br/>  groups.push(&lt;g key={`scales`}&gt;{scales}&lt;/g&gt;);</span><span id="2af8" class="nb lq iq mx b gy ng nd l ne nf">const middleOfChart = (chartSize / 2).toFixed(4);</span><span id="cb9a" class="nb lq iq mx b gy ng nd l ne nf">const captions = Object.keys(data[0]);<br/>  const columns = captions.map((key, i, all) =&gt; {<br/>    return {<br/>      key,<br/>      angle: (Math.PI * 2 * i) / all.length<br/>    };<br/>  });<br/>  groups.push(&lt;g key={`groups}`}&gt;{data.map(shape(columns))}&lt;/g&gt;);</span><span id="0ed1" class="nb lq iq mx b gy ng nd l ne nf">return (<br/>    &lt;svg<br/>      version="1"<br/>      ae nw" href="http://www.w3.org/2000/svg" rel="noopener ugc nofollow" target="_blank"&gt;http://www.w3.org/2000/svg"<br/>      width={chartSize}<br/>      height={chartSize}<br/>      viewBox={`0 0 ${chartSize} ${chartSize}`}<br/>    &gt;<br/>      &lt;g transform={`translate(${middleOfChart},${middleOfChart})`}&gt;{groups}&lt;/g&gt;<br/>    &lt;/svg&gt;<br/>  );<br/>};<br/>export default RadarChart;</span></pre><p id="b5c1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">部分结果将变成:</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/d9158af5234bf64fc320b9f25f5688f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*b0xKSsefZF9Zbb7kSS_OEQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">雷达图开始有了最终的形状，我们添加了形状。</figcaption></figure><h2 id="ee64" class="nb lq iq bd lr nh ni dn lv nj nk dp lz kn nl nm md kr nn no mh kv np nq ml nr bi translated">轴心</h2><p id="0487" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">让我们继续在形状的顶点添加轴。</p><p id="3713" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将创建一个函数来绘制轴，轴的数量将根据我们拥有的数据量而变化。在这种情况下，我们也使用功能<code class="fe ns nt nu mx b">polarToX</code>和<code class="fe ns nt nu mx b">polarToY</code>来定位它们。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="2334" class="nb lq iq mx b gy nc nd l ne nf">const points = points =&gt; {<br/>  return points<br/>    .map(point =&gt; point[0].toFixed(4) + ',' + point[1].toFixed(4))<br/>    .join(' ');<br/>};</span><span id="6d1a" class="nb lq iq mx b gy ng nd l ne nf">const axis = () =&gt; (col, i) =&gt; (<br/>  &lt;polyline<br/>    key={`poly-axis-${i}`}<br/>    points={points([<br/>      [0, 0],<br/>      [polarToX(col.angle, chartSize / 2), polarToY(col.angle, chartSize / 2)]<br/>    ])}<br/>    stroke="#555"<br/>    strokeWidth=".2"<br/>  /&gt;<br/>);</span></pre><p id="833a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将添加另一组，并将其放在<em class="la">形状组</em>之前，以便有更好的美学效果。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="b0ab" class="nb lq iq mx b gy nc nd l ne nf">groups.push(&lt;g key={`group-axes`}&gt;{columns.map(axis())}&lt;/g&gt;);</span></pre><p id="05bb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的雷达图差不多完成了，这是目前为止的代码:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="bc63" class="nb lq iq mx b gy nc nd l ne nf">import React from 'react';</span><span id="422d" class="nb lq iq mx b gy ng nd l ne nf">const data = [<br/>  { battery: 0.7, design: 1, useful: 0.9, speed: 0.67, weight: 0.8 },<br/>  { battery: 0.6, design: 0.9, useful: 0.8, speed: 0.7, weight: 0.6 }<br/>];</span><span id="7288" class="nb lq iq mx b gy ng nd l ne nf">const chartSize = 450;<br/>const numberOfScales = 4;</span><span id="6130" class="nb lq iq mx b gy ng nd l ne nf">const scale = value =&gt; (<br/>  &lt;circle<br/>    key={`scale-${value}`}<br/>    cx={0}<br/>    cy={0}<br/>    r={((value / numberOfScales) * chartSize) / 2}<br/>    fill="#FAFAFA"<br/>    stroke="#999"<br/>    strokeWidth="0.2"<br/>  /&gt;<br/>);</span><span id="aecf" class="nb lq iq mx b gy ng nd l ne nf">const polarToX = (angle, distance) =&gt; Math.cos(angle - Math.PI / 2) * distance;<br/>const polarToY = (angle, distance) =&gt; Math.sin(angle - Math.PI / 2) * distance;</span><span id="e527" class="nb lq iq mx b gy ng nd l ne nf">const pathDefinition = points =&gt; {<br/>  let d = 'M' + points[0][0].toFixed(4) + ',' + points[0][1].toFixed(4);<br/>  for (let i = 1; i &lt; points.length; i++) {<br/>    d += 'L' + points[i][0].toFixed(4) + ',' + points[i][1].toFixed(4);<br/>  }<br/>  return d + 'z';<br/>};</span><span id="97f8" class="nb lq iq mx b gy ng nd l ne nf">const shape = columns =&gt; (chartData, i) =&gt; {<br/>  const data = chartData;<br/>  return (<br/>    &lt;path<br/>      key={`shape-${i}`}<br/>      d={pathDefinition(<br/>        columns.map(col =&gt; {<br/>          const value = data[col.key];<br/>          return [<br/>            polarToX(col.angle, (value * chartSize) / 2),<br/>            polarToY(col.angle, (value * chartSize) / 2)<br/>          ];<br/>        })<br/>      )}<br/>      stroke={`#edc951`}<br/>      fill={`#edc951`}<br/>      fillOpacity=".5"<br/>    /&gt;<br/>  );<br/>};</span><span id="d51b" class="nb lq iq mx b gy ng nd l ne nf">const points = points =&gt; {<br/>  return points<br/>    .map(point =&gt; point[0].toFixed(4) + ',' + point[1].toFixed(4))<br/>    .join(' ');<br/>};</span><span id="a6c9" class="nb lq iq mx b gy ng nd l ne nf">const axis = () =&gt; (col, i) =&gt; (<br/>  &lt;polyline<br/>    key={`poly-axis-${i}`}<br/>    points={points([<br/>      [0, 0],<br/>      [polarToX(col.angle, chartSize / 2), polarToY(col.angle, chartSize / 2)]<br/>    ])}<br/>    stroke="#555"<br/>    strokeWidth=".2"<br/>  /&gt;<br/>);</span><span id="eada" class="nb lq iq mx b gy ng nd l ne nf">const RadarChart = props =&gt; {<br/>  const groups = [];<br/>  const scales = [];<br/>  for (let i = numberOfScales; i &gt; 0; i--) {<br/>    scales.push(scale(i));<br/>  }<br/>  groups.push(&lt;g key={`scales`}&gt;{scales}&lt;/g&gt;);</span><span id="36a4" class="nb lq iq mx b gy ng nd l ne nf">const middleOfChart = (chartSize / 2).toFixed(4);</span><span id="93f6" class="nb lq iq mx b gy ng nd l ne nf">const captions = Object.keys(data[0]);<br/>  const columns = captions.map((key, i, all) =&gt; {<br/>    return {<br/>      key,<br/>      angle: (Math.PI * 2 * i) / all.length<br/>    };<br/>  });<br/>  groups.push(&lt;g key={`group-axes`}&gt;{columns.map(axis())}&lt;/g&gt;);<br/>  groups.push(&lt;g key={`groups}`}&gt;{data.map(shape(columns))}&lt;/g&gt;);</span><span id="1d00" class="nb lq iq mx b gy ng nd l ne nf">return (<br/>    &lt;svg<br/>      version="1"<br/>      ae nw" href="http://www.w3.org/2000/svg" rel="noopener ugc nofollow" target="_blank"&gt;http://www.w3.org/2000/svg"<br/>      width={chartSize}<br/>      height={chartSize}<br/>      viewBox={`0 0 ${chartSize} ${chartSize}`}<br/>    &gt;<br/>      &lt;g transform={`translate(${middleOfChart},${middleOfChart})`}&gt;{groups}&lt;/g&gt;<br/>    &lt;/svg&gt;<br/>  );<br/>};<br/>export default RadarChart;</span></pre><p id="6120" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是结果:</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/87397ec845924ea7708ce05a86d944f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*3m883TsxABg6ZFkJJMfJ8Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">雷达图快完成了。</figcaption></figure><h2 id="e077" class="nb lq iq bd lr nh ni dn lv nj nk dp lz kn nl nm md kr nn no mh kv np nq ml nr bi translated">字幕</h2><p id="feb0" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">任何自尊的图表都有它的标题。让我们创建函数<code class="fe ns nt nu mx b">caption</code>。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="34f2" class="nb lq iq mx b gy nc nd l ne nf">const caption = () =&gt; col =&gt; (<br/>  &lt;text<br/>    key={`caption-of-${col.key}`}<br/>    x={polarToX(col.angle, (chartSize / 2) * 0.95).toFixed(4)}<br/>    y={polarToY(col.angle, (chartSize / 2) * 0.95).toFixed(4)}<br/>    dy={10 / 2}<br/>    fill="#444"<br/>    fontWeight="400"<br/>    textShadow="1px 1px 0 #fff"<br/>  &gt;<br/>    {col.key}<br/>  &lt;/text&gt;<br/>);</span></pre><p id="59fb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">和相对组:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="29ca" class="nb lq iq mx b gy nc nd l ne nf">groups.push(&lt;g key={`group-captions`}&gt;{columns.map(caption())}&lt;/g&gt;);</span></pre><p id="20eb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是结果:</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/fd2ea901c8dbdb0b142da8c7db2b6faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wWyAvxzyRaiaBbuAR239MA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我们几乎完成了，我们只需要添加一些风格。</figcaption></figure><h2 id="fcac" class="nb lq iq bd lr nh ni dn lv nj nk dp lz kn nl nm md kr nn no mh kv np nq ml nr bi translated">以风格收尾</h2><p id="3b76" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">我们可以感到满意，但是缺少了一些东西:</p><ul class=""><li id="cf53" class="lb lc iq ke b kf kg kj kk kn ld kr le kv lf kz nv lh li lj bi translated">每个形状都有相同的颜色，这是不好的。</li><li id="b1a8" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz nv lh li lj bi translated">我们可以在形状上添加一个<code class="fe ns nt nu mx b">:hover</code>效果。</li><li id="7315" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz nv lh li lj bi translated">标题不是真正的文本，而只是数据对象关键字<em class="la">。</em></li><li id="3c5b" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz nv lh li lj bi translated">在某些情况下，标题不适合SVG。</li><li id="2421" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz nv lh li lj bi translated">对数据没有正式或运行时验证</li></ul><p id="3175" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我可以编写代码在这个故事中添加所有这些改进，但我更喜欢创建并发布一个<a class="ae nw" href="https://spyna.github.io/react-svg-radar-chart/" rel="noopener ugc nofollow" target="_blank"> <em class="la"> npm库</em> </a>，其中所有这些事情都已经完成了。这是最后的结果。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/3c2033464a21501afa59128002f9b2cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*sTaONzrZnu7k-NOcUJH0UQ.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">这是SVG React雷达图的最终结果</figcaption></figure><p id="8837" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，我给你留下了使用它的所有信息:</p><p id="51af" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">演示应用:<a class="ae nw" href="https://spyna.github.io/react-svg-radar-chart/" rel="noopener ugc nofollow" target="_blank">https://spyna.github.io/react-svg-radar-chart/</a></p><p id="719f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Npm页面:【https://www.npmjs.com/package/react-svg-radar-chart T2】</p><p id="56df" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">GitHub页面:【https://github.com/Spyna/react-svg-radar-chart T4】</p><div class="od oe gp gr of og"><a rel="noopener  ugc nofollow" target="_blank" href="/manage-react-state-without-redux-a1d03403d360"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">管理无冗余的反应状态</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">如何以一种简单漂亮的方式使用React上下文API？</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">itnext.io</p></div></div><div class="op l"><div class="oq l or os ot op ou jw og"/></div></div></a></div></div></div>    
</body>
</html>