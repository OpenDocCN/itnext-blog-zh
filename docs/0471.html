<html>
<head>
<title>Typescript function (almost) variadic arguments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Typescript函数(几乎)可变参数</h1>
<blockquote>原文：<a href="https://itnext.io/typescript-function-almost-variadic-arguments-b4f4290cf69c?source=collection_archive---------6-----------------------#2018-03-14">https://itnext.io/typescript-function-almost-variadic-arguments-b4f4290cf69c?source=collection_archive---------6-----------------------#2018-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1555995cadf0139096c10de60e0c2ff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QmTYH9yr1Tq9U1SX."/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">安德烈斯·梅迪纳在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1951" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Ftypescript-function-almost-variadic-arguments-b4f4290cf69c" rel="noopener ugc nofollow" target="_blank"> <em class="lb">点击这里在LinkedIn上分享这篇文章</em> </a></p><p id="b352" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我最近遇到的一个小问题，如何为following函数编写typescript泛型？</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="ce7d" class="ll lm iq lh b gy ln lo l lp lq"><strong class="lh ir">function </strong>createAction(type,payloadCreator,metaCreator){<br/>  <strong class="lh ir">return </strong>(...args) =&gt; {<br/>    <strong class="lh ir">return </strong>({<br/>      type,<br/>      ...(payloadCreator &amp;&amp; {payload: payloadCreator(...args)}),<br/>      ...(metaCreator &amp;&amp; {meta: metaCreator(...args)}),<br/>    })<br/>  }<br/>}</span></pre><p id="545b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个函数的灵感来自于一个类似的名为redux-actions的库。对于创建返回redux动作的动作创建器来说，这是一个非常有用的函数。可以按如下方式使用:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="d8bb" class="ll lm iq lh b gy ln lo l lp lq">const incr = createAction('INCREMENT')<br/>incr() // {type: "INCREMENT"}<br/>incr(1) // {type: "INCREMENT"}</span><span id="2fa4" class="ll lm iq lh b gy lr lo l lp lq">const incr = createAction('INCREMENT', arg =&gt; arg)<br/>incr(1) //{type: "INCREMENT", payload: 1}</span><span id="d9d4" class="ll lm iq lh b gy lr lo l lp lq">const incr = createAction('INCREMENT',arg=&gt;arg,()=&gt;({user:'admin'}))<br/>incr(1) // {type: "INCREMENT", payload: 1, meta: {user:'admin'}}</span></pre><p id="5f53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的代码中，该函数将enum作为第一个类型参数，这就是为什么我希望允许typescript使用该类型创建action，而不是像redux-actions那样使用string。</p><p id="efc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先你需要声明一些带多个参数的通用函数，你可以声明任意多个，这里我只有4个，从一个带0个参数的开始，到一个带3个参数的结束。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="d837" class="ll lm iq lh b gy ln lo l lp lq"><strong class="lh ir">type </strong>ActionFunction0&lt;R&gt; = () =&gt; R<br/><strong class="lh ir">type </strong>ActionFunction1&lt;T1, R&gt; = (t1: T1) =&gt; R<br/><strong class="lh ir">type </strong>ActionFunction2&lt;T1, T2, R&gt; = (t1: T1, t2: T2) =&gt; R<br/><strong class="lh ir">type </strong>ActionFunction3&lt;T1, T2, T3, R&gt; = (t1: T1, t2: T2, t3: T3) =&gt; R</span></pre><p id="d700" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你需要4个或更多参数的函数呢？你可以继续声明更多的类型，但是最终你必须在某个地方停下来，也许9是个好数字。如果有人用10个或更多参数调用你的函数呢？在这种情况下，我们可以退回到这个版本:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="43d3" class="ll lm iq lh b gy ln lo l lp lq"><strong class="lh ir">export type </strong>ActionFunctionAny&lt;R&gt; = (...args: <strong class="lh ir">any</strong>[]) =&gt; R</span></pre><p id="7427" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将无法正确处理类型，但将允许用户输入更多类型。</p><p id="6666" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，接下来要做的是像这样添加多个重载函数声明:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="3197" class="ll lm iq lh b gy ln lo l lp lq"><strong class="lh ir">export function </strong>createAction&lt;T, P, M&gt;(<br/>  type: T,<br/>  payloadCreator: ActionFunction0&lt;P&gt;,<br/>  metaCreator: ActionFunction0&lt;M&gt;,<br/>): ActionFunction0&lt;Action&lt;T,P&gt;&gt;<br/><br/><strong class="lh ir">export function </strong>createAction&lt;T, P, M, A1&gt;(<br/>  type: T,<br/>  payloadCreator: ActionFunction1&lt;A1,P&gt;,<br/>  metaCreator: ActionFunction1&lt;A1,M&gt;,<br/>): ActionFunction1&lt;A1, Action&lt;T,P&gt;&gt;<br/><br/><strong class="lh ir">export function </strong>createAction&lt;T, P, M, A1, A2&gt;(<br/>  type: T,<br/>  payloadCreator: ActionFunction2&lt;A1,A2,P&gt;,<br/>  metaCreator: ActionFunction2&lt;A1,A2,M&gt;,<br/>): ActionFunction2&lt;A1,A2,Action&lt;T,P&gt;&gt;<br/><br/><strong class="lh ir">export function </strong>createAction&lt;T, P, M, A1, A2, A3&gt;(<br/>  type: T,<br/>  payloadCreator: ActionFunction3&lt;A1,A2,A3,P&gt;,<br/>  metaCreator: ActionFunction3&lt;A1,A2,A3,M&gt;,<br/>): ActionFunction3&lt;A1,A2,A3,Action&lt;T,P&gt;&gt;</span></pre><p id="f2c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们添加我们的实现。以下是参数最多的版本:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="b42d" class="ll lm iq lh b gy ln lo l lp lq"><strong class="lh ir">export function </strong>createAction&lt;T, P, M, A1, A2, A3&gt;(<br/>  type: T,<br/>  payloadCreator: ActionFunction3&lt;A1,A2,A3,P&gt;,<br/>  metaCreator: ActionFunction3&lt;A1,A2,A3,M&gt;,<br/>): ActionFunction3&lt;A1,A2,A3, Action&lt;T,P&gt;&gt; {<br/>  <strong class="lh ir">return </strong>(a1:A1,a2:A2,a3:A3) =&gt; {<br/>    <strong class="lh ir">return </strong>({<br/>      type,<br/>      ...(payloadCreator &amp;&amp; { payload: payloadCreator(a1,a2,a3) }),<br/>      ...(metaCreator &amp;&amp; { meta: metaCreator(a1, a2, a3) }),<br/>    })<br/>  }<br/>}</span></pre><p id="1dc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，typescript可以正确识别所有类型。</p></div></div>    
</body>
</html>