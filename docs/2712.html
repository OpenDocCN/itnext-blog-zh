<html>
<head>
<title>Build an Enterprise Scalable Dashboard using Angular — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Angular构建企业级可扩展仪表板—第1部分</h1>
<blockquote>原文：<a href="https://itnext.io/build-an-enterprise-scalable-dashboard-using-angular-155aa4280a74?source=collection_archive---------1-----------------------#2019-07-17">https://itnext.io/build-an-enterprise-scalable-dashboard-using-angular-155aa4280a74?source=collection_archive---------1-----------------------#2019-07-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="63ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">许多专业开发人员已经或将要承担为他们的公司网站构建仪表板的任务。本文将介绍一种保持内容独立于仪表板的特殊方法。</p><p id="7255" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是两部分系列文章的第一部分。你可以在这里找到第二部。</p><p id="19bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你是Angular的新手，我建议你阅读<a class="ae ko" href="https://blog.angular-university.io/angular-2-smart-components-vs-presentation-components-whats-the-difference-when-to-use-each-and-why/" rel="noopener ugc nofollow" target="_blank">这篇关于表示/哑组件vs容器/智能组件的文章</a>。</p><p id="b6de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在参加ng-conf 2019时，我遇到了一位在一家非常大的银行公司工作的人，他试图以一种让仪表板完全不知道组件的方式来构建仪表板。仪表板上的每个卡片都有潜在的动态组件，这些组件需要在仪表板模板中没有任何直接引用的情况下存在。后来我发现<a class="ae ko" href="https://angular.io/guide/dynamic-component-loader" rel="noopener ugc nofollow" target="_blank">这是Angular团队的官方教程</a>，我建议你在继续之前读一读。但是，本教程并没有展示如何加载多个组件，并且还需要仪表板将数据绑定到动态组件，这在现实应用程序中变得非常复杂。这篇文章解决了缺失的部分，所以让我们开始吧。</p></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h1 id="f374" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">入门指南</h1><p id="a572" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">我总是做的第一件事是生成一个功能模块来托管我们所有的仪表板相关的优点。我还生成了仪表板组件，所有的操作都将在这里发生。</p><p id="18c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在仪表板中，我将声明一个名为<em class="lz"> tracks的变量。</em>可变轨道保存相关信息以及属于每个轨道的项目。</p><blockquote class="ma mb mc"><p id="c4ee" class="jq jr lz js b jt ju jv jw jx jy jz ka md kc kd ke me kg kh ki mf kk kl km kn im bi translated">仪表板.组件. ts</p></blockquote><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/c284032e0adb7177d47b63fd2e17040b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OoBAujaYKELknLkxafXKig.png"/></div></div></figure><blockquote class="ma mb mc"><p id="b64b" class="jq jr lz js b jt ju jv jw jx jy jz ka md kc kd ke me kg kh ki mf kk kl km kn im bi translated">item.ts</p></blockquote><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ms"><img src="../Images/45fb43ffcf475786cb394123b1033e17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TcFXwbQ9lm5UAsZ37Ex3Ow.png"/></div></div></figure><blockquote class="ma mb mc"><p id="eb7f" class="jq jr lz js b jt ju jv jw jx jy jz ka md kc kd ke me kg kh ki mf kk kl km kn im bi translated">track.ts</p></blockquote><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ms"><img src="../Images/768e4f475597bd10c343389f62d1281f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5PGiQrJ6U8lDLOVsJbaAqA.png"/></div></div></figure><p id="7be4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意Item上的component属性是一个字符串。这是有意的，将在后面的部分解释。</p><p id="1b5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我还呈现了仪表板模板中的项目。</p><blockquote class="ma mb mc"><p id="d01f" class="jq jr lz js b jt ju jv jw jx jy jz ka md kc kd ke me kg kh ki mf kk kl km kn im bi translated">dashboard.component.html</p></blockquote><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ms"><img src="../Images/9cb46d638616937ac74cbec21ca40ba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j1hRwDcMx6orJFXJEM-Vcw.png"/></div></div></figure></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h1 id="4aee" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">动态加载内容</h1><p id="1f6a" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">本节将介绍如何在不直接引用组件的情况下将组件加载到仪表板上。</p><p id="9b78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了动态加载组件，我们需要一个对每个项目模板的视图容器引用。要访问它，创建一个指令，在我的例子中，我称它为“dashboardOutlet ”,并将ViewContainerRef添加到构造函数中，并为该项添加一个@Input()。</p><p id="5b98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lz">dashboard-outlet . directive . ts</em></p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ms"><img src="../Images/05427670880b359fea9caff89d1806cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jirtz8x2pqX33riDRi2kfg.png"/></div></div></figure><p id="5014" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后用ng-template标记替换dashboard.component.html中的item.id表达式。接下来，将dashboard-outlet指令添加到ng-template，并将项目的数据绑定到item指令。</p><p id="282b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lz">dashboard.component.html</em></p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ms"><img src="../Images/b5454d56b167d57270974f59b354c210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sV4JP2aqVU1Gf37SdA66Rw.png"/></div></div></figure><p id="18ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，在我们将内容组件呈现到仪表板之前，我们必须做一些事情。</p><p id="1c06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我创建了一个dashboardCard组件和dashboardCardContainer组件，每个仪表板卡及其父容器都将扩展这两个组件，这允许我们绑定一组公共的变量和事件。DashboardCardContainer需要一个@Input()项来保存对该项本身的引用。其思想是容器将为表示组件完成所有的服务调用和数据检索。目前，这些只是占位符组件。</p><p id="776c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lz">dashboard-card . container . ts</em></p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mt"><img src="../Images/d00c296373d9b112aff83e3618a45ee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tdW9Ekk4QXovt1qJaI-_Bw.png"/></div></div></figure><p id="6b3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其次，我们必须有一个地方来托管仪表板上不存在的组件。为此，创建一个文件并导出一个名为<em class="lz"> dashboardCards </em>的对象。dashboardCards是一个将字符串映射到仪表板组件的对象。这样，我们可以给它一个字符串，它会返回一个组件供我们渲染。我还喜欢创建一个枚举来保存对每个字符串的引用，这允许我们在track对象上构建项目时使用autocomplete。</p><p id="ce00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lz">仪表板-卡片. ts </em></p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ms"><img src="../Images/2d767a3c3cebbcac53357b30419a1ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*99JnLF3xiQpi8Gq68Pir0g.png"/></div></div></figure><p id="7cfe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lz"> dashboard-cards.enum.ts </em></p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mu"><img src="../Images/e089cc9363943b8f59d230e6468f748b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yc9ddaPuU1E4H5h3fhOfkw.png"/></div></div></figure><p id="14ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用这些引用，我们可以引用内容组件，而不需要仪表板直接引用模板中的组件。</p><p id="9c03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到仪表板组件，我们需要一个从*ngFor循环中创建的所有模板的引用。我们可以通过使用<a class="ae ko" href="https://angular.io/api/core/ViewChildren" rel="noopener ugc nofollow" target="_blank"> @ViewChildren </a>查询DashboardOutlet指令来实现这一点。</p><p id="87ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lz"> dashboard.component.ts </em></p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mt"><img src="../Images/0c298da66dad7e04478d9e7322594601.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ei-DI9vTh4quQ2seLo52lg.png"/></div></div></figure><p id="ecdd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这个引用，我们现在可以将组件加载到仪表板上。我们使用一个名为loadContent的方法来实现这一点。它有两个参数:类型为DashboardOutletDirective的template和名称非常巧妙的类型为item的Item。然后，我们使用loadContent方法中的<a class="ae ko" href="https://angular.io/api/core/ComponentFactoryResolver" rel="noopener ugc nofollow" target="_blank">componentforyresolver</a>来创建内容并将其呈现在模板上。我还创建了另一个方法loadContents(注意“s”)，它遍历@ViewChildren提供的所有模板，并将其传递给loadContent。</p><p id="b85d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lz"> dashboard.component.ts </em></p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mv"><img src="../Images/e1fd7c79ed01deaa72e9db4bec5ea941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hrwQ6n92WtUkzrM8RzNM1w.png"/></div></div></figure><p id="c344" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们已经更新了dom，所以我们告诉changeDetectorRef来检测更改是很重要的。如果没有这个调用，您可能会得到错误或意外的结果。</p><p id="9513" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们所要做的就是将项目添加到轨道中，并在ngAfterViewInit()中调用loadContents。</p><p id="02cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lz"> dashboard.component.ts </em></p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/a1ff7fbf36e11568f775b9fcbbd49fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vGQXRlMgLPhVjL9hvOEYeA.png"/></div></div></figure><p id="4380" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样！您应该拥有一个功能完整的动态仪表板，独立于它所呈现的内容。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/2dd265b57951541a46a05c11f99550ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*lFTHTZI3SFfo3Ks0gpNG4Q.png"/></div></figure><p id="72ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以在这里获得完整的功能示例:<a class="ae ko" href="https://stackblitz.com/github/buttars/enterprise-dynamic-dashboard" rel="noopener ugc nofollow" target="_blank">https://stack blitz . com/github/but tars/enterprise-dynamic-dashboard</a></p><p id="f57c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae ko" href="https://medium.com/@buttars/build-an-enterprise-scalable-dashboard-using-angular-part-2-104acc38bea3" rel="noopener">第2部分</a>中，我将讲述如何在维护状态的同时实现拖放，如何为单个卡片进行服务调用，以及如何在运行时从轨道中添加/删除项目。</p><p id="392a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我写的第一篇文章，如果你喜欢它或者学到了什么，给它几个掌声，这对我意义重大。此外，我将尽可能回答更多的问题，所以如果你有任何问题，请在下面评论。</p></div></div>    
</body>
</html>