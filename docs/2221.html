<html>
<head>
<title>NGXS — Thoughts, Patterns, Architecture and best practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NGXS——思想、模式、架构和最佳实践</h1>
<blockquote>原文：<a href="https://itnext.io/ngxs-thoughts-patterns-architecture-and-best-practices-c991c42618d9?source=collection_archive---------1-----------------------#2019-04-18">https://itnext.io/ngxs-thoughts-patterns-architecture-and-best-practices-c991c42618d9?source=collection_archive---------1-----------------------#2019-04-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/ce47fb596504836ce673255cae4ac5c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SbKpWlZWOaOTzeC_xjvbsQ.png"/></div></div></figure><div class=""/></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="fdeb" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">最近，我将我的整个应用程序从NGRX重构为NGXS，在完成这个费力的160文件重构后，我松了一口气。为什么？不是因为我已经完成的工作，而是因为我在系统内释放的效率——这种可能性变得可行。</p><p id="523e" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我从每个实体开始，将NGRX动作和选择器映射到NGXS动作和选择器。一旦我进入状态，这个任务出奇的简单。</p><p id="dbcd" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这篇文章中，我将解释我喜欢用NGXS实现的一些模式，我对这个库的一些观察，并希望说服你为什么…</p><blockquote class="lh li lj"><p id="60b3" class="ki kj lk kk b kl km kn ko kp kq kr ks ll ku kv kw lm ky kz la ln lc ld le lf im bi translated">您应该使用NGXS进行角度状态管理</p></blockquote><h1 id="6e67" class="lo lp je bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">文件结构和命名</h1><p id="e915" class="pw-post-body-paragraph ki kj je kk b kl mm kn ko kp mn kr ks kt mo kv kw kx mp kz la lb mq ld le lf im bi translated">下面概述的文件结构对我来说工作得很好，它包括将主要的状态问题分离到单独的文件中，例如—</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="9fec" class="na lp je mw b gy nb nc l nd ne">//inside a single state folder pertaining to pelicans</span><span id="847d" class="na lp je mw b gy nf nc l nd ne">/pelican<br/> - index.ts<br/> - pelican.actions.ts<br/> - pelican.selectors.ts<br/> - pelican.state.ts<br/> - pelican-state.model.ts</span></pre><p id="5615" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们现在已经清楚地定义和分离了我们的动作、状态和选择器。这种结构的好处是它的伸缩性很好，允许我们将所有的状态“汇总”成一个单一的常量，然后我们可以将它注入到我们的模型中。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="cea3" class="na lp je mw b gy nb nc l nd ne">// inside the store folder which contains a bunch of folders like the one outlined above </span><span id="65e0" class="na lp je mw b gy nf nc l nd ne">/store<br/> - index.ts<br/> - /pelican<br/> - /salmon<br/> - /migration-route<br/> - /lake</span></pre><p id="b3af" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">下面是“roll-up”模式的一个例子，我们将存储根index.ts文件中的所有状态作为一个常量导入，然后简单地将该常量导入到模块中，如下所示。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="846e" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">经过多次迭代后，我发现这是一种非常好的结构化和模块化应用程序状态的方法。</p><h1 id="6aca" class="lo lp je bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">使用路由器插件</h1><p id="448c" class="pw-post-body-paragraph ki kj je kk b kl mm kn ko kp mn kr ks kt mo kv kw kx mp kz la lb mq ld le lf im bi translated">将Angular路由器连接到商店绝对是一个好主意。主要原因是，您可以在任何需要的时候从商店生命周期中访问路线状态。这是<strong class="kk jf">完全独立于你的组件&amp;服务</strong>。这对于诸如路径数据之类的东西来说是非常好的，我将在下面作为一个例子进行概述。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ee6e" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在，我们可以在状态或组件生命周期中的任何时候选择路由状态的片段。</p><h1 id="2c47" class="lo lp je bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">使用实体管理器</h1><p id="eef0" class="pw-post-body-paragraph ki kj je kk b kl mm kn ko kp mn kr ks kt mo kv kw kx mp kz la lb mq ld le lf im bi translated">我100%支持使用实体适配器来管理状态。在写这篇文章的时候，还没有一个官方的NGXS实体适配器(<a class="ae lg" href="https://www.npmjs.com/package/ngxs-entity" rel="noopener ugc nofollow" target="_blank">我一直使用这个库</a>)。</p><blockquote class="lh li lj"><p id="326d" class="ki kj lk kk b kl km kn ko kp kq kr ks ll ku kv kw lm ky kz la ln lc ld le lf im bi translated">要了解更多关于NG redux实体的主题，这里有一个深入的解释，我建议<a class="ae lg" href="https://medium.com/ngrx/introducing-ngrx-entity-598176456e15" rel="noopener">阅读</a>。</p></blockquote><p id="bafb" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">然而本质上你可以；</p><p id="7230" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">首先，用类型定义定义一个实体适配器。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="ca8e" class="na lp je mw b gy nb nc l nd ne">export const pelicanEntityAdapter = createEntityAdapter&lt;Pelican&gt;({});</span></pre><p id="e5a3" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">然后，在动作处理程序中，我们可以通过实体适配器来调整状态。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="bbca" class="na lp je mw b gy nb nc l nd ne">@Action(GetPelicans)</span><span id="4fb5" class="na lp je mw b gy nf nc l nd ne">postPatterns({ getState, patchState }: stateCtx) {<br/>  return this.patternService.postPatterns(createPatterns).pipe(<br/>    tap(pelicans =&gt; patchState(<br/>      pelicanEntityAdapter.upsertMany(pelicans, getState()))<br/>    )<br/>  );<br/>}</span></pre><p id="9c10" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">酷的是我们可以升级tOne、upsertMany、addOne、deleteMany等等——用更少的样板文件实现出色的抽象。</p><h1 id="7698" class="lo lp je bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">高低阶状态</h1><p id="3ef2" class="pw-post-body-paragraph ki kj je kk b kl mm kn ko kp mn kr ks kt mo kv kw kx mp kz la lb mq ld le lf im bi translated">Redux架构在现代SPA架构中是革命性的，在我看来，MVC看起来像是一个<em class="lk"> php </em>旧时代的古老遗迹。然而，这并不意味着redux不是没有缺陷。</p><p id="ddd7" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">MVC涉及在控制器(组件和服务)之间分配逻辑(也称为复杂性)，而redux涉及在状态定义中尽可能多地本地化逻辑。这意味着redux状态可能会变得令人费解。</p><p id="f03d" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我喜欢把我的状态分为高和低的顺序，这意味着像身份验证、用户和实体状态这样的东西比ui、表单和加载状态这样的东西存储在更高的级别。</p><p id="7281" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在angular的上下文中，高阶状态可以存储在<em class="lk">核心模块</em>中，而较低级状态通常通过<em class="lk">特征模块延迟加载。</em>这个概念在下图中有所表达，其中列表和活动选项卡存储在较低的级别，用户和授权存储在较高的级别，需要注意的是:</p><ul class=""><li id="ec81" class="ni nj je kk b kl km kp kq kt nk kx nl lb nm lf nn no np nq bi translated">这个概念很大程度上是主观的，并且因情况而异，示例中较低阶的实体很容易成为较高阶的实体。</li><li id="9c12" class="ni nj je kk b kl nr kp ns kt nt kx nu lb nv lf nn no np nq bi translated">高阶和低阶状态可以组合在一起。</li></ul><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nw"><img src="../Images/b5f3e73b996d16847e8562111c9c8747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bFSHG4PQN-kgUmB1fDY3dQ.png"/></div></div></figure><h1 id="c1be" class="lo lp je bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">选择器组成</h1><p id="b2bf" class="pw-post-body-paragraph ki kj je kk b kl mm kn ko kp mn kr ks kt mo kv kw kx mp kz la lb mq ld le lf im bi translated">Redux是关于关注点的清晰分离，因此拥有定义良好的选择器是很重要的。为了有一个干净的选择器，我建议在可能的情况下，坚持以下原则。</p><ul class=""><li id="d1ae" class="ni nj je kk b kl km kp kq kt nk kx nl lb nm lf nn no np nq bi translated">尽可能确保逻辑在选择器中处理，而不是在组件中处理(组件应该只选择一个值并在模板中反映该值)</li><li id="20a0" class="ni nj je kk b kl nr kp ns kt nt kx nu lb nv lf nn no np nq bi translated">通过只将较高阶的状态导入较低阶的状态，而不是相反，来干净地构成状态(NG lazy模块不应该从核心模块导入)。</li></ul><p id="25d5" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">到目前为止，组织选择器的一个很好的模式是在选择器类中定义选择器，然后将它们导入到组件中。在这种方式下，选择器的作用类似于db查询，选择状态片段并在需要的地方执行联合。你可以在下面看到一个例子。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="33cf" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">希望我已经能够分享我从使用NGXS中获得的一些模式。在我看来，这是Angular目前可用的最好的状态管理库，因为它周围有很好的社区，以及专注于简单性和最少样板文件的深思熟虑的方法。</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><a href="http://www.velocityapp.io"><div class="gh gi nx"><img src="../Images/b499f4b01415de408840d65158421ab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*faZWtbZKwtq3nzD5uvHPwA.png"/></div></a></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="302a" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated"><em class="lk">封面图片:</em><a class="ae lg" href="https://www.skypixel.com/users/first-tsv" rel="noopener ugc nofollow" target="_blank"><em class="lk">https://www.skypixel.com/users/first-tsv</em></a></p></div></div>    
</body>
</html>