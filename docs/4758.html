<html>
<head>
<title>Building a Game With TypeScript. Drawing Grid 5/5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TypeScript构建游戏。绘制网格5/5</h1>
<blockquote>原文：<a href="https://itnext.io/building-a-game-with-typescript-drawing-grid-5-5-49454917b3af?source=collection_archive---------0-----------------------#2020-09-09">https://itnext.io/building-a-game-with-typescript-drawing-grid-5-5-49454917b3af?source=collection_archive---------0-----------------------#2020-09-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="39ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">教程<a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener">系列</a>的第三章讲述了如何用TypeScript和原生浏览器API从头开始构建游戏</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/20b84b566d81e554164845280c6c5711.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0_GG2exR9aojCf4Yj8Ca5Q.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/free-photos-vectors/people" rel="noopener ugc nofollow" target="_blank">free pik创建的人员向量</a></figcaption></figure><p id="07ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎来到第三章的最后部分“画格子”！前一篇文章是关于实现和测试一个简单而强大的渲染系统<em class="lc">。在这一章的最后一篇文章中，我们将整理所有的细节。</em></p><p id="7a90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">拥有渲染系统固然很棒，但是<code class="fe ld le lf lg b">NodeDrawComponent</code>如何访问呢？我们必须将<code class="fe ld le lf lg b">Canvas</code>的实例传递给<code class="fe ld le lf lg b">Node</code>吗？如果是这样，那么我们就有了和以前一样的问题:我们将<code class="fe ld le lf lg b">Node</code>和一个绘图上下文联系起来。唯一的区别是我们必须传递对<code class="fe ld le lf lg b">Canvas</code>的引用，而不是本地上下文，这并没有减少问题。有些不对劲。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><p id="9dd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第三章“绘制网格”中，我们正在实现回合制游戏的一个基础部分:我们正在绘制节点网格。其他章节可在此处获得:</p><ul class=""><li id="d403" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated"><a class="ae kl" href="/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener ugc nofollow" target="_blank">简介</a></li><li id="0762" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated"><a class="ae kl" href="/@gregsolo/entity-component-system-in-action-with-typescript-f498ca82a08e" rel="noopener ugc nofollow" target="_blank">第一章实体组件系统</a></li><li id="e294" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">第二章。游戏循环(<a class="ae kl" href="/@gregsolo/gamedev-patterns-and-algorithms-with-typescript-game-loop-part-1-2-699919bb9b71" rel="noopener ugc nofollow" target="_blank">第一部分</a>，<a class="ae kl" href="/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-game-loop-2-2-c0d57a8e5ec2" rel="noopener ugc nofollow" target="_blank">第二部分</a>)</li><li id="5b86" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">第三章。绘制网格(<a class="ae kl" href="/@gregsolo/building-a-game-with-typescript-drawing-grid-1-5-aaf68797a0bb" rel="noopener ugc nofollow" target="_blank">第一部分</a>、<a class="ae kl" href="/javascript-in-plain-english/building-a-game-with-typescript-drawing-grid-2-5-206555719490" rel="noopener ugc nofollow" target="_blank">第二部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-3-5-1fb94211c4aa" rel="noopener">第三部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-iii-drawing-grid-4-5-398af1dd638d" rel="noopener">第四部分</a>、第五部分)</li><li id="a1f1" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">第四章。舰船(<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-colors-and-layers-337b0e4d71f" rel="noopener">第一部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-team-and-fleet-f223d39e9248" rel="noopener">第二部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-ship-14e6c19caa38" rel="noopener">第三部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-ship-and-locomotion-4f5969675993" rel="noopener">第四部分</a>)</li><li id="9777" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">第五章输入系统(<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-1-3-46d0b3dd7662" rel="noopener">第一部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-2-3-cd419e36027c" rel="noopener">第二部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-3-3-8492552579f1" rel="noopener">第三部分</a>)</li><li id="39cc" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">第六章。寻路和移动(<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-17-introduction" rel="noopener ugc nofollow" target="_blank">第一部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-27-highlighting-locomotion-range" rel="noopener ugc nofollow" target="_blank">第二部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-37-graph-and-priority-queue" rel="noopener ugc nofollow" target="_blank">第三部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-47-pathfinder" rel="noopener ugc nofollow" target="_blank">第四部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-57-finding-the-path" rel="noopener ugc nofollow" target="_blank">第五部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-6-instant-locomotion" rel="noopener ugc nofollow" target="_blank">第六部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/pathfinding-and-movement-7-animated-locomotion" rel="noopener ugc nofollow" target="_blank">第七部分</a>)</li><li id="dd68" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">第七章。玛奇纳州</li><li id="0682" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">第八章。攻击系统:生命和伤害</li><li id="6aa5" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">第九章。比赛的输赢</li><li id="f548" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">第十章敌人AI</li></ul><blockquote class="mc md me"><p id="5d1a" class="jn jo lc jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated">随意切换到<a class="ae kl" href="https://github.com/soloschenko-grigoriy/gamedev-patterns-ts" rel="noopener ugc nofollow" target="_blank">库</a>的<code class="fe ld le lf lg b">drawing-grid-4</code>分支。它包含了前几篇文章的工作成果，是这篇文章的一个很好的起点。</p></blockquote></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="2010" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">目录</h1><ol class=""><li id="31aa" class="lo lp iq jp b jq ng ju nh jy ni kc nj kg nk kk nl lu lv lw bi translated">介绍</li><li id="9e85" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk nl lu lv lw bi translated">画布层</li><li id="15f8" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk nl lu lv lw bi translated">测试CanvasLayer</li><li id="87a4" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk nl lu lv lw bi translated">用图层绘图</li><li id="fc5d" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk nl lu lv lw bi translated">重新绘制</li><li id="6e49" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk nl lu lv lw bi translated">结论</li></ol></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="f0f9" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">画布层</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nm"><img src="../Images/b2c0148df025355da818d0b159d058d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uh5tI0pQB08aTb2AU7ASiw.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/free-photos-vectors/background" rel="noopener ugc nofollow" target="_blank">free pik制作的背景照片</a></figcaption></figure><p id="75bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有一个问题我们必须回答。我们同意在同一块画布上绘制所有节点。但是其他元素呢，比如船？看看这张gif:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/51c91fcc5688359637ee64565ce3d316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*twb3OLuV9kKGUE9umFWhsw.gif"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">这是我们希望实现的游戏演示</figcaption></figure><p id="fd57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们试图实现的游戏。这些圈是“船”，我们将在下一章谈到它们。但现在，我们应该记住，这些“船”必须在网格的顶部。一直都是。</p><p id="13b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解决这个问题，我们可以引入画布的<strong class="jp ir">层的概念，类似于你在Gimp等图像编辑器中看到的层系统。有了层，我们可以把一块画布放在另一块之上。例如，我们可以将<code class="fe ld le lf lg b">Grid</code>和任何装饰品放在一个层上，即“底部”(“背景”)层。然后将船只放在另一个“顶部”(“前景”)层。这种方法可以保证船只总是被绘制在网格的顶部。</strong></p><blockquote class="mc md me"><p id="b913" class="jn jo lc jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated"><em class="iq">此时此刻，原生Canvas API还没有简单的方法来管理“层”。当然还有</em> <code class="fe ld le lf lg b"><em class="iq">globalCompositeOperation</em></code> <em class="iq">，但顾名思义，那是一个</em><strong class="jp ir"><em class="iq"/></strong><em class="iq">的全局设置。使用它有太多的限制。为了给自己留有回旋的余地，我们将定义我们的分层系统。</em></p></blockquote><p id="5e8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我从定义<code class="fe ld le lf lg b">CanvasLayer</code>类开始。它将管理对我们决定添加到游戏中的每一层的访问:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="09c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们不要忘记桶文件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0ed8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个类将确保游戏总是只有一个特定类型的画布。虽然<code class="fe ld le lf lg b">Canvas</code>和<code class="fe ld le lf lg b">CanvasLayer</code>都不是<strong class="jp ir">单例</strong>，但是静态<code class="fe ld le lf lg b">CanvasLayer</code>确保<code class="fe ld le lf lg b">Canvas</code>只被实例化:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="fd91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我为<em class="lc">背景</em> <code class="fe ld le lf lg b">Canvas</code>定义了一个静态字段和一个标准的公共getter，但有一点需要注意。这个getter首先检查字段是否为空。如果是，说明后台canvas还没有实例化，getter要先构造。</p><p id="3df0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将只在静态上下文中使用<code class="fe ld le lf lg b">CanvasLayer</code>，所以我将<code class="fe ld le lf lg b">constructor</code>设为私有，以防止任何人意外实例化。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="c3e2" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">测试CanvasLayer</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/049f0693943a753485ddb88277a913b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z4ODrW-z6zqEOJQMlkzx1g.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/free-photos-vectors/background" rel="noopener ugc nofollow" target="_blank">freepik创建的背景矢量</a></figcaption></figure><p id="dbb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们继续之前，让我们花点时间来介绍一下测试<code class="fe ld le lf lg b">CanvasLayer</code>。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="5cad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们应该验证<code class="fe ld le lf lg b">Background</code>总是相同的，不管我们访问它多少次:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b74d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我从导入和嘲讽<code class="fe ld le lf lg b">Canvas</code>开始。我还确保它以前从未被调用过:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e413" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我几次请求<code class="fe ld le lf lg b">Background</code>层，并检查<code class="fe ld le lf lg b">Canvas</code>被实例化了多少次:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e852" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！此时，您的代码应该可以通过<code class="fe ld le lf lg b">npm start,</code>成功编译，并且所有的测试应该可以通过<code class="fe ld le lf lg b">npm t</code>:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nq"><img src="../Images/ef083cbda1e4e5a87dac1854d6c6059c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mkUqBsz2qpw8zq3dkTR19w.png"/></div></div></figure></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="569c" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">用图层绘图</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nr"><img src="../Images/f16794778877dedff9482506aa713818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XknquTa1qb3Q7Jr4dEOWwg.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/free-photos-vectors/watercolor" rel="noopener ugc nofollow" target="_blank">由宏矢量创建的水彩矢量</a></figcaption></figure><p id="9bab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，最后，我们可以清理<code class="fe ld le lf lg b">NodeDrawComponent</code>并利用我们的真棒层系统:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="615e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您的代码应该用<code class="fe ld le lf lg b">npm start</code>编译并呈现:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ns"><img src="../Images/8539c87f28a38006fb0f2ed3aa18ac7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jtpWS085xvO9oxDFC3dCZg.png"/></div></div></figure><p id="dc96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，如果您检查开发工具，您现在应该只看到一个画布:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/18111864351b3f753da40ede3bb54e8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*3oMqTOAgYQCGVnrRHKHnFw.png"/></div></figure><p id="9b8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了，这正是我们想要的！然而，还有一件事要讲。此时，我们只画一次节点:当<code class="fe ld le lf lg b">NodeDrawComponent</code>醒来时。这很有效，而且非常高效，但不幸的是，不是很灵活。</p><p id="4b1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很容易掉入陷阱，并假设网格是静态的，并且一生只绘制一次。毕竟只是游戏的一个<em class="lc">背景</em>对吧？嗯，是也不是。</p><p id="fad5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就<em class="lc">在屏幕上定位</em>而言，它确实是一个背景。但这并不意味着它是静态的<em class="lc"/>。我们要<em class="lc">与这一层</em>进行交互；点击这个节点应该是信号；玩家的船要移动到这个节点；</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/51c91fcc5688359637ee64565ce3d316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*twb3OLuV9kKGUE9umFWhsw.gif"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">这是我们希望实现的游戏演示</figcaption></figure><p id="c770" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是为什么我们要创建<code class="fe ld le lf lg b">Grid</code>和<code class="fe ld le lf lg b">Node</code>实体，而不是简单地在画布上绘制它们。但是如果你仔细看看上面的gif，你可能会注意到其他有趣的事情。<code class="fe ld le lf lg b">Node</code>的颜色应该能够改变，以帮助玩家了解他们<em class="lc">可以</em>点击的位置。</p><p id="e2be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何才能实现这种行为？浏览器画布的工作方式是，在绘制形状后，您将失去对它的所有控制。没有参考<em class="lc">颜色</em>属性什么的。要改变一个矩形的颜色，<code class="fe ld le lf lg b">NodeDrawComponent</code>必须<em class="lc">重绘</em>:清理并重新绘制，但使用新的颜色。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="caeb" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">重新绘制</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nu"><img src="../Images/fa1758e3c3437fe33a4d4c615892321f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MOwe4nl7idZ3RDl377HFcg.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/free-photos-vectors/icon" rel="noopener ugc nofollow" target="_blank">rawpixel.com创建的图标向量</a></figcaption></figure><p id="beec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有几种方法可以做到这一点。其中之一是利用<code class="fe ld le lf lg b">Update</code>方法。如果你回忆一下，每个<code class="fe ld le lf lg b">Component</code>都有<code class="fe ld le lf lg b">Update</code>，这个<code class="fe ld le lf lg b">Component</code>属于<code class="fe ld le lf lg b">Entity</code>所调用的一个方法。</p><p id="166c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ld le lf lg b">NodeDrawComponent</code>也不例外，有它自己的<code class="fe ld le lf lg b">Update</code>方法，我们暂时空着:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2dd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在每一次<code class="fe ld le lf lg b">Update</code>醒来时绘制，而不是在一次<code class="fe ld le lf lg b">NodeDrawComponent</code>醒来时绘制。这样我们就可以确定，如果有什么变化，<code class="fe ld le lf lg b">Node</code>会有最相关的表示。</p><p id="d319" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们可以将<code class="fe ld le lf lg b">Draw</code>方法调用从<code class="fe ld le lf lg b">Awake</code>移到<code class="fe ld le lf lg b">Update</code>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="6846" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，我们应该首先清理各自的区域。幸运的是，我们已经在我们的小渲染引擎中准备了适当的API，即<code class="fe ld le lf lg b">ClearRect</code>方法:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b8bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们设置一个私有的<code class="fe ld le lf lg b">Clear</code>方法。它的职责是清理在画布特定区域上绘制的任何东西，准确地说就是我们曾经绘制矩形的地方。然后，在每一帧上，我们清理并重新绘制。</p><blockquote class="mc md me"><p id="6926" class="jn jo lc jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated"><em class="iq">“我们再画一遍</em> <strong class="jp ir"> <em class="iq">每一个</em> </strong> <em class="iq">帧？？？这算表演吗？!"，你可能会问。我们确实可以实现一些智能系统来检查是否有任何变化。并且，如果是，则仅触发重绘。当然，这将更具表演性。</em></p><p id="6153" class="jn jo lc jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated">但是，正如你可能已经注意到的，我在本教程中一直使用增量方法。我们从简单开始，逐渐增加复杂性。目前的解决方案对我们来说已经足够好了:节点的数量是有限的，而且每个节点的绘图都很便宜。我们的架构允许我们在将来遇到性能瓶颈时重新审视和改进。</p></blockquote><p id="2165" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，您的代码应该通过<code class="fe ld le lf lg b">npm start</code>成功编译，并且所有测试应该通过<code class="fe ld le lf lg b">npm t</code>:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nq"><img src="../Images/ef083cbda1e4e5a87dac1854d6c6059c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mkUqBsz2qpw8zq3dkTR19w.png"/></div></div></figure><p id="e45c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们告别这一章之前，让我们在这个美丽的蛋糕上加一颗樱桃。让我们用一些测试来覆盖<code class="fe ld le lf lg b">NodeDrawComponent</code>！</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="e4b2" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">测试NodeDrawComponent</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/06931007ab607276e630b2578592409e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j97HQTOdR_og13vN1k7YfQ.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/free-photos-vectors/school" rel="noopener ugc nofollow" target="_blank">freepik创建的学校向量</a></figcaption></figure><p id="7e4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">初始设置看起来应该很熟悉:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="dbc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，我们会有很多其他的<code class="fe ld le lf lg b">Node</code>组件。对于其中的每一个，我们都必须进行相同的设置。让我们节省一些时间和精力，为<code class="fe ld le lf lg b">Node</code>创建一个<strong class="jp ir">模拟工厂</strong>，我们可以反复使用它。</p><p id="b917" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模拟工厂只是一个用指定的参数为我们构建一个<code class="fe ld le lf lg b">Node</code>的函数:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f99e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了稍微方便一点，我们可以设置一个默认参数:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8ea5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要忘记更新桶文件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="923e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，回到<code class="fe ld le lf lg b">NodeDrawComponent</code>测试中，我将使用模拟工厂，而不是直接调用Node的构造函数:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="954f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不错！剩下的就是检查<code class="fe ld le lf lg b">NodeDrawComponent</code>是否执行了<code class="fe ld le lf lg b">CanvasLayer</code>的正确方法。例如，一旦<code class="fe ld le lf lg b">NodeDrawComponent</code>醒来，它应该清理画布:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8b0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似地，<code class="fe ld le lf lg b">NodeDrawComponent</code>应该在每次更新时清理和重绘:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="cb0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，您的代码应该可以用<code class="fe ld le lf lg b">npm start</code>成功编译，所有的测试应该可以用<code class="fe ld le lf lg b">npm t</code>通过:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/6cfd855e09dbea9b505928e735b2758d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*X_7ArbUQsMwnzuV2SwM7Bw.png"/></div></figure><blockquote class="mc md me"><p id="d4fa" class="jn jo lc jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated">你可以在<a class="ae kl" href="https://github.com/soloschenko-grigoriy/gamedev-patterns-ts" rel="noopener ugc nofollow" target="_blank">库</a>的<code class="fe ld le lf lg b">drawing-grid-5</code>分支中找到这篇文章的完整源代码。</p></blockquote></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="3c0b" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">结论</h1><p id="9c99" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy nw ka kb kc nx ke kf kg ny ki kj kk ij bi translated">厉害！第三章“绘制网格”到此结束。我们在这一章的最后部分完成了很多！我们讨论了游戏中画布的<code class="fe ld le lf lg b">layers</code>概念，并设置了<code class="fe ld le lf lg b">Background</code>层的提供者。我们在<code class="fe ld le lf lg b">NodeDrawComponent,</code>中使用了它，它现在不断地重画每一帧的<code class="fe ld le lf lg b">Node</code>，准备对任何变化做出反应。</p><p id="2ae8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一章致力于绘制<code class="fe ld le lf lg b">Grid</code>:我们游戏的基础部分。让我们停下来，欣赏一下我们走过的路。</p><p id="b026" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们开始了第一个不确定的步骤，直接用浏览器的canvas API绘制网格。然后我们通过定义<code class="fe ld le lf lg b">Grid</code>和<code class="fe ld le lf lg b">Node</code>实体建立了游戏的结构层次。我们发现将绘图逻辑作为<code class="fe ld le lf lg b">Node</code> : <code class="fe ld le lf lg b">NodeDrawComponent</code>的特定组件是合理的。多亏了<code class="fe ld le lf lg b">Vector2d</code>结构，我们可以轻松传递元组数据，比如坐标和大小。最后，我们创建了一个小的渲染引擎和图层系统。这的确是一次漫长的旅行，但我希望你能安排好！</p><p id="ad7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下次我们开始新的篇章。我们将看看核心的<em class="lc">游戏机制</em>并引入更多的实体和组件。我迫不及待地想在那里见到你！</p><p id="58f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你有任何<strong class="jp ir">的评论</strong>、<strong class="jp ir">的建议</strong>、<strong class="jp ir">的问题</strong>，或者任何其他<strong class="jp ir">的反馈</strong>，不要犹豫给我发私信<strong class="jp ir">留言</strong>或者在下面留下<strong class="jp ir">评论</strong>！如果你喜欢这个系列，<strong class="jp ir">请与他人分享</strong>。它真的帮助我继续努力。感谢您的阅读，我们下次再见！</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><p id="e04c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是“使用TypeScript的Gamedev模式和算法”系列教程的第三章。其他章节可在这里:</p><ul class=""><li id="0ccd" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated"><a class="ae kl" href="/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener ugc nofollow" target="_blank">简介</a></li><li id="e523" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated"><a class="ae kl" href="/@gregsolo/entity-component-system-in-action-with-typescript-f498ca82a08e" rel="noopener ugc nofollow" target="_blank">第一章实体组件系统</a></li><li id="20d7" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">第二章。游戏循环(<a class="ae kl" href="/@gregsolo/gamedev-patterns-and-algorithms-with-typescript-game-loop-part-1-2-699919bb9b71" rel="noopener ugc nofollow" target="_blank">第一部分</a>，<a class="ae kl" href="/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-game-loop-2-2-c0d57a8e5ec2" rel="noopener ugc nofollow" target="_blank">第二部分</a>)</li><li id="a000" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">第三章。绘制网格(<a class="ae kl" href="/@gregsolo/building-a-game-with-typescript-drawing-grid-1-5-aaf68797a0bb" rel="noopener ugc nofollow" target="_blank">第1部分</a>、<a class="ae kl" href="/javascript-in-plain-english/building-a-game-with-typescript-drawing-grid-2-5-206555719490" rel="noopener ugc nofollow" target="_blank">第2部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-3-5-1fb94211c4aa" rel="noopener">第3部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-iii-drawing-grid-4-5-398af1dd638d" rel="noopener">第4部分</a>，第5部分)</li><li id="0abd" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">第四章。舰船(<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-colors-and-layers-337b0e4d71f" rel="noopener">第一部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-team-and-fleet-f223d39e9248" rel="noopener">第二部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-ship-14e6c19caa38" rel="noopener">第三部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-ship-and-locomotion-4f5969675993" rel="noopener">第四部分</a>)</li><li id="ce8c" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">第五章输入系统(<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-1-3-46d0b3dd7662" rel="noopener">第一部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-2-3-cd419e36027c" rel="noopener">第二部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-3-3-8492552579f1" rel="noopener">第三部分</a>)</li><li id="a8df" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">第六章。寻路和移动(<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-17-introduction" rel="noopener ugc nofollow" target="_blank">部分1 </a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-27-highlighting-locomotion-range" rel="noopener ugc nofollow" target="_blank">部分2 </a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-37-graph-and-priority-queue" rel="noopener ugc nofollow" target="_blank">部分3 </a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-47-pathfinder" rel="noopener ugc nofollow" target="_blank">部分4 </a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-57-finding-the-path" rel="noopener ugc nofollow" target="_blank">部分5 </a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-6-instant-locomotion" rel="noopener ugc nofollow" target="_blank">部分6 </a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/pathfinding-and-movement-7-animated-locomotion" rel="noopener ugc nofollow" target="_blank">部分7 </a>)</li><li id="68ae" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">第七章。玛奇纳州</li><li id="cf0c" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">第八章。攻击系统:生命和伤害</li><li id="3b78" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">第九章。比赛的输赢</li><li id="6146" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">第十章敌人AI</li></ul></div></div>    
</body>
</html>