<html>
<head>
<title>Introduction to Azure Functions using Terraform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Terraform的Azure函数简介</h1>
<blockquote>原文：<a href="https://itnext.io/introduction-to-azure-functions-using-terraform-eca009ddf437?source=collection_archive---------1-----------------------#2021-03-16">https://itnext.io/introduction-to-azure-functions-using-terraform-eca009ddf437?source=collection_archive---------1-----------------------#2021-03-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b937c7ea97be722df36c8ed8dd3f480d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zgg4qWVYDWD5Fyje"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">伊万·班杜拉在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="e6fd" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">介绍</h1><p id="da70" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在这篇文章中，我将提供一个快速的<strong class="lg iu">介绍</strong>到<a class="ae kf" href="https://azure.microsoft.com/en-us/services/functions/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Azure函数</strong> </a>和<a class="ae kf" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Terraform </strong> </a>以及一个<strong class="lg iu">动手</strong>的例子，这个例子很容易理解。</p><p id="ae1b" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">有很多关于Azure函数的文章，但是大多数都没有解释如何使用<strong class="lg iu"> CI/CD </strong>管道自动化<strong class="lg iu">真实世界场景</strong>的部署。</p><p id="e48d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">本文不会深入讨论创建特定CI/CD管道的细节，而是通过一个简单的例子来关注自动化在Azure中部署<strong class="lg iu"> Function App </strong>所需的<strong class="lg iu">基础设施和代码</strong>。将提供命令，以便您可以使用此代码轻松地与任何CI/CD工具集成，如<a class="ae kf" href="https://azure.microsoft.com/en-us/services/devops/?nav=min" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Azure DevOps </strong> </a>或<strong class="lg iu"> Jenkins </strong>。</p><p id="d2f6" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们将首先快速介绍一下<strong class="lg iu"> Azure Functions </strong>和Terraform，然后进行动手练习。注意，我们没有时间涵盖所有关于<strong class="lg iu">地形</strong>的概念，但我会提供一些链接作为参考。</p><h1 id="0634" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">Azure函数</h1><p id="fa19" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">Azure功能是Azure中的<strong class="lg iu">无服务器</strong> <strong class="lg iu">事件驱动</strong>计算服务，类似于<a class="ae kf" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>。这也被称为功能即服务或<a class="ae kf" href="https://en.wikipedia.org/wiki/Function_as_a_service" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Faas </strong> </a>。简言之，<a class="ae kf" href="https://martinfowler.com/articles/serverless.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">无服务器</strong> </a> <strong class="lg iu">就是执行不需要任何服务器</strong>的业务逻辑的任何东西。这个<strong class="lg iu">去掉了DevOp </strong> s的操作方面。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/5f99b8ef2b3a338bd82d7b9d5524957b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rwUQZxNc-kg0-xeH"/></div></div></figure><p id="cf81" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">无服务器意味着你不需要管理任何服务器、操作系统或基础设施，你只需要专注于代码。Azure Functions处理部署、可用性、伸缩性等等；这对开发者来说是非常好的。</p><p id="d684" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">第二个方面，是<strong class="lg iu">事件驱动的</strong>。相比其他无服务器产品，如<a class="ae kf" href="https://azure.microsoft.com/en-us/services/app-service/" rel="noopener ugc nofollow" target="_blank"> Azure应用服务</a>；有了Azure Functions，你只需编写对事件做出反应的小函数，而不用编写一个完整的应用程序。每个函数都将有一个您在函数旁边定义的特定触发器，这可能是一个<a class="ae kf" href="https://azure.microsoft.com/en-us/services/event-grid/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Azure事件网格</strong> </a>主题或者是许多其他<a class="ae kf" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings?tabs=csharp#supported-bindings" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">触发器</strong> </a>中的一个HTTP端点。这意味着您只关心编写函数的逻辑。你可以用语言的选择来编写这个逻辑:JavaScript，C#，F#或者Java。</p><p id="9018" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">FaaS的另一个重要特点是它采用现收现付的模式。你只为你使用的东西付费，如果一个函数没有被调用，你不需要支付任何东西。这使得Azure功能非常划算，特别是对于有大量峰值的工作负载。</p><p id="704f" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在这篇<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/scaling-my-app-serverless-vs-kubernetes-cdb8adf446e1"> <strong class="lg iu">文章</strong> </a>里我讲了很多关于<strong class="lg iu">无服务器</strong>的内容，所以多看看了解一下吧。</p><h1 id="b36a" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">将（行星）地球化（以适合人类居住）</h1><p id="f83a" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><a class="ae kf" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Terraform </strong> </a>是一个众所周知的开源<strong class="lg iu">基础设施作为Code</strong>(<a class="ae kf" href="https://en.wikipedia.org/wiki/Infrastructure_as_code" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">IaC</strong></a>)工具。IaC是使用机器可读的定义文件管理和配置整个IT基础架构(包括物理机和虚拟机)的过程。</p><p id="ef61" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu"> Terraform </strong>使用易于阅读的<strong class="lg iu">声明性</strong>文件，以直观、人类可读的格式描述您的基础设施。您可以描述您需要哪些云服务，Terraform将为您提供这些服务。它与公共云提供商紧密结合，但也可以在内部使用。它与AWS<strong class="lg iu">中的<a class="ae kf" href="https://aws.amazon.com/cloudformation/" rel="noopener ugc nofollow" target="_blank"> CloudFormation </a>等工具非常相似，但Terraform可以在许多云提供商之间工作。声明性的优点在于它保持了基础设施的状态，所以当你运行它时，它会检查你想要的和已经存在的，并且只修改需要的。这不仅仅是简单的自动化脚本或配置管理；<strong class="lg iu"> Terraform可以安全可靠地协调您的整个基础设施</strong>。例如，如果您想减少应用程序的虚拟机数量，只需减少Terraform定义文件中的数量，Terraform就会检测到数量减少并删除其中一个虚拟机。</strong></p><p id="50d3" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">Terraform遵循<a class="ae kf" href="https://www.gitops.tech/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> GitOps </strong> </a>原则，所有代码都保存在源代码控制中，因此每个变更都需要得到团队的批准，并且所有变更历史都被保存下来以供审计。忘记复杂的变更管理流程，使用Terraform，如果您需要更改您的基础架构，您可以像更改代码一样提出拉式请求；并遵循标准实践，如PR评审、代码质量、CI/CD等。</p><p id="dcd9" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">要了解更多关于Terraform的内容，可以查看<a class="ae kf" href="https://www.terraform.io/intro/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">官方文档</strong> </a>或者这篇<a class="ae kf" href="https://geekflare.com/terraform-for-beginners/" rel="noopener ugc nofollow" target="_blank">大文章</a>了解<strong class="lg iu">模块、变量、状态、计划</strong>等核心概念；以及<strong class="lg iu"> Terraform生命周期</strong>。</p><h1 id="8431" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">动手示例</h1><p id="83c9" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在我们开始之前，确保你对地形有所了解。你可以在这里 获得本练习<a class="ae kf" href="https://github.com/javiramos1/azure_functions_terraform_demo" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">的<strong class="lg iu">源代码。</strong></strong></a></p><p id="a18e" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们将使用Terraform提供应用程序和存储帐户来存储功能；并且我们将使用<a class="ae kf" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=linux%2Ccsharp%2Cbash#v2" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Azure功能核心</strong> </a>来部署功能本身。我们将创建一个<strong class="lg iu"> Makefile </strong>来自动化这个过程。这样，Jenkins或Azure DevOps就可以调用<strong class="lg iu"> make </strong>命令。</p><h2 id="e515" class="mm kh it bd ki mn mo dn km mp mq dp kq lp mr ms ku lt mt mu ky lx mv mw lc mx bi translated">设置</h2><p id="137f" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在开始之前，请确保您具备以下要求:</p><ul class=""><li id="977f" class="my mz it lg b lh mc ll md lp na lt nb lx nc mb nd ne nf ng bi translated">具有有效订阅的Azure帐户。<a class="ae kf" href="https://azure.microsoft.com/free/?ref=microsoft.com&amp;utm_source=microsoft.com&amp;utm_medium=docs&amp;utm_campaign=visualstudio" rel="noopener ugc nofollow" target="_blank">免费创建账户</a>。</li><li id="7770" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated"><a class="ae kf" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>，主动LTS和维护LTS版本(推荐10.14.1)。使用<code class="fe nm nn no np b">node --version</code>命令检查您的版本。请注意，目前还不支持最新的NodeJS版本。</li><li id="d077" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated"><a class="ae kf" href="https://docs.microsoft.com/en-us/cli/azure/install-azure-cli" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">Azure CLI</strong></a><strong class="lg iu"/>管理Azure资源。</li><li id="7858" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated"><a class="ae kf" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Visual Studio代码</strong> </a>在<a class="ae kf" href="https://code.visualstudio.com/docs/supporting/requirements#_platforms" rel="noopener ugc nofollow" target="_blank">支持的平台</a>之一上。</li><li id="717a" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated"><a class="ae kf" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=linux%2Ccsharp%2Cbash#v2" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">Azure Functions Core</strong></a>对功能进行管理。</li><li id="d41b" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated">将<a class="ae kf" href="https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurefunctions" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Azure函数扩展</strong> </a> <strong class="lg iu"> </strong>为Visual Studio代码。</li><li id="5ec4" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated">地形<strong class="lg iu"> CLI </strong>。从<a class="ae kf" href="https://www.terraform.io/downloads.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">这里</strong> </a>下载，解压后放入你的系统<code class="fe nm nn no np b">PATH.</code></li></ul><p id="6694" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">确保您可以登录到<a class="ae kf" href="https://login.microsoftonline.com/organizations/oauth2/v2.0/authorize?client_id=c44b4083-3bb0-49c1-b47d-974e53cbdf3c&amp;response_type=code%20id_token&amp;scope=https%3A%2F%2Fmanagement.core.windows.net%2F%2Fuser_impersonation%20openid%20email%20profile&amp;state=OpenIdConnect.AuthenticationProperties%3DLzR9qCiyV4prT5hzJcG3le4KyQk9yA2npK1RkE_mrRoPgRoS21WUGXSPOsRgMNxZuMzr6AYrbiWxLDfeGihv7ImYTltO1mscPPieYji3_O5EfYY2YYHB2bFnvxXsgCrE&amp;response_mode=form_post&amp;nonce=637507338749166161.ZWM0YWViYTItMmIwNS00NzliLWJkOGQtOTY4YmFmZDk1Y2ZhYjEyYjNiYjItMDU5Ni00ODBkLWI2MWItYWM3ZTJjMmQwMzQ3&amp;redirect_uri=https%3A%2F%2Fportal.azure.com%2Fsignin%2Findex%2F&amp;site_id=501430&amp;client-request-id=503988f0-04fc-4ea1-83b5-4ac379b30e5b&amp;x-client-SKU=ID_NET45&amp;x-client-ver=5.3.0.0" rel="noopener ugc nofollow" target="_blank"> Azure门户</a>。然后，使用命令行登录:</p><p id="ac10" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe nm nn no np b">az login</code></p><p id="0bd4" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这将打开浏览器，您可以在其中输入详细信息。</p><h2 id="c862" class="mm kh it bd ki mn mo dn km mp mq dp kq lp mr ms ku lt mt mu ky lx mv mw lc mx bi translated">创建项目</h2><p id="fb9d" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们开始吧！</p><p id="258a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们将该项目分为两个文件夹:</p><ul class=""><li id="9997" class="my mz it lg b lh mc ll md lp na lt nb lx nc mb nd ne nf ng bi translated"><code class="fe nm nn no np b">infra</code>:部署功能app的Terraform文件。</li><li id="905e" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated"><code class="fe nm nn no np b">functions</code>:包含Azure函数。包含执行业务逻辑的<strong class="lg iu"> <em class="nq"> NodeJS </em> </strong>函数的主应用程序。</li></ul><p id="5078" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">创建这些到项目，并光盘到<em class="nq">功能</em>文件夹。</p><p id="7795" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">现在，让我们使用<a class="ae kf" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Visual Studio代码</strong> </a>创建一个使用<strong class="lg iu"> HTTP </strong>触发器的示例函数，也就是说，当我们点击一个HTTP端点时，该函数将被调用，该端点将在我们部署该函数时生成。</p><ul class=""><li id="1507" class="my mz it lg b lh mc ll md lp na lt nb lx nc mb nd ne nf ng bi translated">在活动栏中选择Azure图标，然后在Azure: Functions区域中，选择Create new project…图标。</li></ul><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/0e53feb3c0cfa8ad904b124b50e4c92a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*JosM5jwN4oD96z2R.png"/></div></figure><ul class=""><li id="db82" class="my mz it lg b lh mc ll md lp na lt nb lx nc mb nd ne nf ng bi translated">为项目工作环境选择一个目录位置，然后选择“选择”。</li><li id="9444" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated">根据提示提供以下信息:</li><li id="331d" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated">为您的功能项目选择语言:选择<code class="fe nm nn no np b">TypeScript</code>。</li><li id="0739" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated">为项目的第一个功能选择一个模板:选择<code class="fe nm nn no np b">HTTP trigger</code>。</li><li id="4192" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated">提供一个函数名:Type <code class="fe nm nn no np b">RestEndpoint</code>。</li><li id="5ca7" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated">授权级别:选择<code class="fe nm nn no np b">Anonymous</code>，这使得任何人都可以调用你的函数端点。要了解授权级别，请参见<a class="ae kf" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-http-webhook-trigger#authorization-keys" rel="noopener ugc nofollow" target="_blank">授权密钥</a>。</li><li id="ca05" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated">选择您希望打开项目的方式:选择<code class="fe nm nn no np b">Add to workspace</code>。</li><li id="824f" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated">使用这些信息，Visual Studio代码生成一个带有HTTP触发器的Azure Functions项目。您可以在浏览器中查看本地项目文件。要了解更多关于创建的文件，请参见<a class="ae kf" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-develop-vs-code#generated-project-files" rel="noopener ugc nofollow" target="_blank">生成的项目文件</a>。</li></ul><p id="3c27" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">此外，单击“登录Azure”按钮将Visual Studio代码与您的帐户连接起来。</p><p id="453f" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">现在你可以通过点击<strong class="lg iu"> <em class="nq"> F5 </em> </strong>从Visual Studio代码中<strong class="lg iu">运行</strong>该函数。您也可以运行:</p><p id="34fa" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe nm nn no np b">func run</code></p><p id="ac75" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">您可以看到本地运行的HTTP触发函数的URL端点。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/b2d215e60f79d839db7ea1fa037dca7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GhXrP6s2xwuS4qkp.png"/></div></div></figure><p id="eb82" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们现在有了一个Azure Functions <strong class="lg iu"> NodeJS </strong>应用程序，可以运行并部署到<strong class="lg iu"> Azure </strong>中。</p><p id="5950" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如果你想学习如何使用Visual Studio代码扩展来部署它，你可以继续遵循官方指南。</p><h2 id="397b" class="mm kh it bd ki mn mo dn km mp mq dp kq lp mr ms ku lt mt mu ky lx mv mw lc mx bi translated">添加Terraform文件</h2><p id="7276" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">让我们添加Terraform文件，它将提供以下内容:</p><ul class=""><li id="a939" class="my mz it lg b lh mc ll md lp na lt nb lx nc mb nd ne nf ng bi translated"><strong class="lg iu">资源组。</strong></li><li id="05d8" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated"><strong class="lg iu">存储账户</strong>。存储功能代码。</li><li id="8520" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated"><a class="ae kf" href="https://docs.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">应用洞察</strong> </a>进行监控。</li><li id="b00c" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated"><a class="ae kf" href="https://docs.microsoft.com/en-us/azure/app-service/overview-hosting-plans" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">服务计划</strong> </a>用于运行该功能。</li><li id="91ad" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated">包含不同函数的函数应用程序。</li></ul><p id="5467" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">Terraform是模块化，建议您创建模块来处理特定类型的基础设施。为了管理Azure函数，我们将创建一个<strong class="lg iu">模块</strong>来执行上面列表的最后3点。</p><p id="6c64" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">进入之前创建的<em class="nq"> infra/ </em>文件夹，创建一个文件夹模块来存储我们自己的模块。在此为功能模块创建一个新文件夹<em class="nq"> func/ </em>。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/5cb80892cb48e9cef8f6bea6ffb20491.png" data-original-src="https://miro.medium.com/v2/resize:fit:270/format:webp/1*SLZ8ppBcly2WujgD1A_X5w.png"/></div></figure><p id="dac9" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">创建一个<strong class="lg iu"> <em class="nq"> main.tf </em> </strong>文件，该文件将包含创建Azure函数资源的代码。输入以下内容:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="f8bf" class="my mz it lg b lh mc ll md lp na lt nb lx nc mb nd ne nf ng bi translated">第8–13行:创建用于监控的应用洞察资源。</li><li id="c376" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated">第15–26行:创建一个服务计划来运行这些功能。如果需要，您可以重复使用现有的服务计划。</li><li id="9975" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated">第28–57行:创建函数应用程序。我们使用<em class="nq"> app_settings </em>传递运行时或应用洞察参考等属性。我们还选择Linux运行时并指定存储帐户，以便函数应用程序资源知道它可以在哪里存储源代码。</li></ul><p id="6e02" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在顶部，您可以看到需要传递给该模块的<strong class="lg iu">输入变量</strong>。我们希望之前已经创建了资源组和存储帐户。这是<em class="nq"> main </em> Terraform文件的工作，它将创建这两个资源，然后使用我们刚刚创建的模块。</p><p id="d5f3" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">接下来，让我们在主文件夹中名为<strong class="lg iu"> <em class="nq"> vars.tf </em> </strong>的单独文件中定义一些我们需要的变量:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="7dbc" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们需要Azure <strong class="lg iu"> <em class="nq">订阅ID </em> </strong>和<strong class="lg iu"> <em class="nq">租户ID </em> </strong>来访问<strong class="lg iu"> Azure </strong>。我们还有资源组名称和资源位置的变量。如果使用命令行选择或传递它们，您可以看到不同的值。请注意我们如何为资源组和位置设置默认值，因为我们不需要经常更改它们，但是我们仍然希望能够在不更改许多文件的情况下更新它们。</p><p id="0781" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">接下来，我们需要为Terraform添加一个负责与Azure对话的<a class="ae kf" href="https://www.terraform.io/docs/providers/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">提供者</strong> </a>。创建一个名为<strong class="lg iu"> <em class="nq"> provider.tf </em> </strong>的文件:</p><pre class="mi mj mk ml gt nw np nx ny aw nz bi"><span id="24f9" class="mm kh it np b gy oa ob l oc od">provider "azurerm" {</span><span id="24b3" class="mm kh it np b gy oe ob l oc od">subscription_id = var.SUBSCRIPTION_ID</span><span id="1a7a" class="mm kh it np b gy oe ob l oc od">tenant_id = var.TENANT_ID</span><span id="af67" class="mm kh it np b gy oe ob l oc od">features {}</span><span id="fdff" class="mm kh it np b gy oe ob l oc od">}</span></pre><p id="73c8" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们使用我们之前为您的订阅和租户id定义的变量，这些变量是<strong class="lg iu">机密</strong>；但是我们如何传递这两个秘密呢？首先，你不应该把它们放在你的源代码中，Jenkins应该在运行Terraform时管理并注入这些变量。这可以在运行时使用以下方法完成:</p><p id="2780" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe nm nn no np b">--var </code> SUBSCRIPTION_ID="…"</p><p id="fc10" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">通常，你会有几个变量，所以更好的方法是创建一个<strong class="lg iu">变量文件</strong>。但是首先，我们如何获得订阅ID和租户ID？只需运行<strong class="lg iu"> <em class="nq"> az登录</em> </strong>即可得到输出。订阅id是“<em class="nq"> id </em>”字段，租户ID是“<em class="nq"> tenantId </em>”字段。</p><p id="4b91" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">创建一个变量<strong class="lg iu"> <em class="nq"> func.tfvars </em> </strong>来保存这两个秘密:</p><pre class="mi mj mk ml gt nw np nx ny aw nz bi"><span id="bd37" class="mm kh it np b gy oa ob l oc od">SUBSCRIPTION_ID = “02d6b8fc-….”<br/>TENANT_ID = “77b59865–….”</span></pre><p id="ce8a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">一定要加上<em class="nq"> **/*。将</em>转换为<em class="nq">。gitignore </em>文件，这样就不会将这些秘密提交给源代码库。</p><p id="6cf1" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">好了，现在我们有了管理函数、提供者和定义的变量的模块。让我们创建Terraform <strong class="lg iu">主</strong>文件。在<em class="nq">下</em>文件夹中创建一个<strong class="lg iu"> <em class="nq"> func.tf </em> </strong>文件:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="877c" class="my mz it lg b lh mc ll md lp na lt nb lx nc mb nd ne nf ng bi translated">第1–4行:创建资源组来保存我们所有的资源。我们引用在<strong class="lg iu"> <em class="nq"> vars.tf </em> </strong>文件中创建的变量。</li><li id="0b36" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated">第6–11行:我们使用<em class="nq">random _ string</em>terra form util为存储帐户创建一个随机数，因为它们需要是全局唯一的。</li><li id="3482" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated">第13–21行:创建存储帐户。请注意我们是如何在资源组上设置依赖关系的，您也可以引用以前的资源，Terraform会检测到这种依赖关系。</li><li id="432b" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated">第23–29行:在存储帐户中创建容器。</li><li id="dff3" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated">第32–41行:我们调用了之前创建的模块。我们传递在模块文件顶部定义的所有必需的输入变量。</li></ul><p id="5d54" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">就这样，现在我们准备好部署基础架构了。首先，让我们初始化Terraform，运行:</p><p id="738a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe nm nn no np b">terraform init</code></p><p id="4fb6" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">然后运行:</p><pre class="mi mj mk ml gt nw np nx ny aw nz bi"><span id="e6d6" class="mm kh it np b gy oa ob l oc od">terraform apply -var-file=func.tfvars</span></pre><p id="7094" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">注意我们是如何传递我们的秘密<em class="nq"> func.tfvars </em>文件的。这应该会将您的基础设施部署到Azure。进入<strong class="lg iu">门户</strong>查看结果。您应该会看到存储帐户和功能应用程序。如果您单击左侧的功能菜单，您将看不到任何功能。这是因为我们使用<strong class="lg iu"> Azure核心工具</strong>来部署功能本身。我们将基础设施与代码分开。<strong class="lg iu">功能是开发者的责任</strong>，不应由Terraform处理。</p><p id="6cf7" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">要部署功能，转到<em class="nq">功能</em>文件夹并运行:</p><pre class="mi mj mk ml gt nw np nx ny aw nz bi"><span id="c27f" class="mm kh it np b gy oa ob l oc od">func azure functionapp publish func-function-app</span></pre><p id="f89e" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">注意那个<strong class="lg iu"><em class="nq">func-Function-app</em></strong>是Terraform之前创建的函数App的名字，这是Azure Functions CLI(针对<em class="nq">开发者</em>)和Terraform(针对<em class="nq"> DevOps </em>)之间的链接。</p><p id="fe5d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">现在，您应该能够看到门户中的功能了。该命令还将打印URL，您可以点击该URL来测试该功能。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi of"><img src="../Images/3c0bd5ddedf2fb07eb88e760b894b142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*34yMKH6rYLQ9VvRQeNSqKw.png"/></div></div></figure><p id="2135" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如果你有一个小团队，你可能想把Terraform文件和代码放在同一个代码库中，这就是我们的情况。在这种情况下你可以使用<strong class="lg iu"> <em class="nq"> Makefile </em> </strong>来自动化一切。在根目录下创建一个<strong class="lg iu"> <em class="nq"> Makefile </em> </strong>:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="d551" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">现在你可以简单地运行<strong class="lg iu"> <em class="nq"> make </em> </strong>来使用Terraform部署基础设施，然后使用<em class="nq"> Azure Functions Core </em>工具部署功能。</p><p id="3635" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这些是命令:</p><ul class=""><li id="f024" class="my mz it lg b lh mc ll md lp na lt nb lx nc mb nd ne nf ng bi translated"><strong class="lg iu"> make </strong>:使用服务计划创建一个基于Linux的功能应用程序，它还安装了用于监控的应用程序洞察。之后，它部署功能。总共有2个主要目标可以单独运行，请查看Make文件了解详细信息。使用<em class="nq"> make setup </em>创建功能app，<em class="nq"> make deploy </em>部署功能。</li><li id="bcd3" class="my mz it lg b lh nh ll ni lp nj lt nk lx nl mb nd ne nf ng bi translated"><strong class="lg iu">制作销毁</strong>:销毁功能app。</li></ul><p id="330a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如果您在运行这些应用程序时遇到问题，请在这里查看<a class="ae kf" href="https://github.com/javiramos1/azure_functions_terraform_demo" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">我的源代码</strong> </a>以获得帮助。</p><h1 id="2802" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">结论</h1><p id="61e2" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在这篇文章中，我简单介绍了一下<strong class="lg iu"> Terraform </strong>和<strong class="lg iu"> Azure函数</strong>。然后，我们进入了一个实践示例，展示了如何从实际代码中分离出与基础设施相关的资源。使用<strong class="lg iu"> IaC +无服务器</strong>时，这些界限变得<strong class="lg iu">模糊</strong>。基础设施也是代码，功能也是基础设施。</p><p id="9ad0" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我建议总是<strong class="lg iu">将云资源与代码</strong>分开。如果服务很小，你可以像我们一样把它们放在同一个存储库中，但是最好把它们放在相关但独立的存储库中。Terraform存储库将接受更多审核，因为它处理更敏感的资源。但是我们如何在DevOps团队和开发人员之间共享资源呢？例如，开发人员如何知道Terraform创建的功能应用程序资源的名称是什么？这可以随时更改。在我的<a class="ae kf" href="https://github.com/javiramos1/azure_functions_terraform_demo" rel="noopener ugc nofollow" target="_blank"> repositor </a> y中，我创建了一个临时文件，然后在Makefile中使用它从Terraform输出中读取函数名。如果这些库是分离的，我推荐使用一个类似<a class="ae kf" href="https://docs.microsoft.com/en-us/azure/key-vault/general/overview" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">Azure Key Vault</strong></a>的秘密库，将包含敏感数据的<em class="nq">JSON</em><strong class="lg iu">terra form</strong>输出作为秘密存储在秘密库中，这种方式非常容易保护开发者对资源的访问。</p><p id="4438" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如果你喜欢这篇文章，记得鼓掌，并关注我的更多更新！</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><p id="0026" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我希望你喜欢这篇文章。欢迎发表评论或分享这篇文章。跟随<a class="ae kf" href="https://twitter.com/JavierRamosRod" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu"><em class="nq">me</em></strong></a><strong class="lg iu"><em class="nq"/></strong><em class="nq">进行未来岗位。</em></p></div></div>    
</body>
</html>