<html>
<head>
<title>Module Oriented Architecture — Part 2: Routing and Modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向模块的体系结构第2部分:路由和模块</h1>
<blockquote>原文：<a href="https://itnext.io/module-oriented-architecture-part-2-routing-and-modules-2437e6a292e7?source=collection_archive---------5-----------------------#2018-05-15">https://itnext.io/module-oriented-architecture-part-2-routing-and-modules-2437e6a292e7?source=collection_archive---------5-----------------------#2018-05-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="43f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">刷新你的记忆:</p><div class="kl km gp gr kn ko"><a href="https://medium.com/@poksi/module-oriented-architecture-part-1-coupling-and-decoupling-4443dd7f598a" rel="noopener follow" target="_blank"><div class="kp ab fo"><div class="kq ab kr cl cj ks"><h2 class="bd ir gy z fp kt fr fs ku fu fw ip bi translated">面向模块的体系结构第1部分:耦合与解耦</h2><div class="kv l"><h3 class="bd b gy z fp kt fr fs ku fu fw dk translated">我们的应用程序通常被分成更多的功能单元。我们努力遵循良好的软件工程实践来…</h3></div><div class="kw l"><p class="bd b dl z fp kt fr fs ku fu fw dk translated">medium.com</p></div></div></div></a></div><h1 id="ec99" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">在你的应用中分离关注点</h1><p id="24cb" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我想在不同的层次上有很多方法，但是我想开始分离特性流、特性集群或者简称为<strong class="jp ir">模块</strong>的关注点是有意义的。</p><p id="fd57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以很容易地想象一个简单的银行应用程序，它会有如下模块:</p><ul class=""><li id="9135" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated"><strong class="jp ir">登录</strong></li><li id="b595" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir">交易清单</strong></li><li id="df5a" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir">支付</strong></li><li id="effc" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi">…</li></ul><p id="2e31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，假设我们有如下接受标准</p><ul class=""><li id="181d" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">你想要通过深层链接独立地访问这些特性/模块。</li><li id="1379" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">这些模块/服务中的一些可能在彼此之间具有功能依赖性</li><li id="137a" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">您可能会为同一目的使用不同的模块(例如，使用基于密码的登录模块或基于TouchID/FaceID/PIN的模块)</li><li id="ae99" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">您希望完全<strong class="jp ir"> <em class="mo">封装每个模块中的所有功能，从而使app完全模块化，并将模块变成具有自己的通信约定/协议</em> </strong>的构建块。</li></ul><p id="2380" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，这是一个长长的愿望清单！</p><h1 id="de35" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">应用路由器拯救世界</h1><p id="3600" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这可能是我们将开始实现所有先前发现和愿望的地方。<br/>什么是应用路由器？是一门课。甚至可能是一胎！！！<br/>很矮很瘦。它存储的是“已注册”的类，这意味着它知道的类符合某些协议，这使得它们至少能够识别自己。应用路由器所做的只是:</p><ul class=""><li id="738c" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">正在接收有效的URL请求</li><li id="869c" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">查找模块，它将从URL响应主机</li><li id="e455" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">用代表函数/方法和潜在参数的路径调用这个模块</li><li id="68a4" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">返回带有URLResponse、最终响应字典和最终错误的回调</li></ul><p id="ae59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">听起来几乎像RESTful API路由器，不是吗？嗯，差不多是了。但它更通用，更像一个URL路由器。所有这些现在甚至开始类似于微服务…</p><p id="a45e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，我们这里有一些Swift语言的简单代码。请记住，还没有在语言语义上花太多心思来使代码尽可能的聪明。它只是用来表示概念，您的实际实现可以根据您的喜好而有所不同。</p><p id="959c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码非常简单:我们有一个属性作为注册的ModuleTypes和函数的集合来打开模块，两者都在<code class="fe mp mq mr ms b">ApplicationRouterType</code>中定义。</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="fcc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们查看代码，特别是<code class="fe mp mq mr ms b">func open(url: URL, callback: ModuleCallback?)</code>，我们可以看到，它主要做的是寻找匹配路由的注册模块，这应该是唯一的(我们显然没有实现这里的检查和潜在断言),并反映模块名称/函数和路径，这反映了模块内的方法/功能。好的，现在让我们做模块。</p><h1 id="cf34" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">模块怎么样？</h1><p id="aa46" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated"><strong class="jp ir"> <em class="mo">到底是什么模块？</em> </strong></p><p id="3acc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Module是一个简单的类，它代表一组类型之间的网关，这些类型执行一组任务，这些任务定义了应用程序级别的通用全局功能(我们可以称之为:服务)和:</p><ul class=""><li id="e340" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">应用程序的其余部分(像其他模块一样)</li><li id="4bc4" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">外部世界(如深层链接)</li><li id="e231" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">甚至应用中捆绑的其他技术(比如React Native)。</li></ul><p id="06d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">听起来很吸引人。听起来就像一把瑞士刀……<br/>协议<code class="fe mp mq mr ms b">ModuleType</code>几乎定义了需要在其上工作的一切:</p><ul class=""><li id="6fdb" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">路由字符串，唯一标识模块并从URL映射到主机</li><li id="28aa" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">路径的集合，它唯一地标识模块的所有函数，并从URL映射到路径</li><li id="c570" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">open函数是模块的简单网关，提供路由、路径、参数，并以标准URL会话的形式返回响应。</li></ul><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="1b76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到，模块本身是由其路由和路径定义的。</p><h1 id="73b2" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">LoginModule和PaymentModule类</h1><p id="76f1" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">如果我们看一下这两个类应该符合的ModuleType，那么我们应该期待非常简单的实现，而且确实如此！</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="4adc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到变量<code class="fe mp mq mr ms b">route</code>和<code class="fe mp mq mr ms b">paths</code>，它们被<code class="fe mp mq mr ms b">ApplicationRouter</code>使用，如前所述，路径反映了模块的能力。您还可以找到<code class="fe mp mq mr ms b">moduleRouter</code>，稍后它将被用作根据路径在模块内进行路由的手段，当通过<code class="fe mp mq mr ms b">open</code>函数访问模块时，路径作为参数被传递。</p><h1 id="2bcc" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">…还有一件事？</h1><p id="2c7c" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">是的。我们的应用程序只包含模块吗？它可能主要只包含相互调用的模块。但是如果我们回顾一下我们描述它们的角色，模块看起来更像是服务，提供特定的功能。它们可以相互依赖，但更多的是作为一种功能，而不是一个特定的模块。毕竟，我们在<em class="mo">第1部分</em>中解释过，我们想要去耦架构。在上面的实际例子中，我们可以说，如果我们想要执行支付，我们需要让用户登录，但不一定要使用<code class="fe mp mq mr ms b">LoginModule</code>，它可以是任何其他模块，它将为我们提供必要的令牌/凭证。有时可能还需要编排模块，甚至将它们排队。同样，我们可以发现与微服务的相似之处，但在我们的应用程序中，这将以非常简单的方式实现。</p><p id="7636" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是为什么我们引入了一个名为<code class="fe mp mq mr ms b">ApplicationServices</code>的类，它向我们应用程序的任何部分公开完整的服务。在我们的例子中，我们简单地从应用程序委托中调用<code class="fe mp mq mr ms b">pay</code>服务，但是你可以得到一个想法，当然，这在许多其他场景中是如何工作的。</p><p id="52e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的代码示例是一个典型的表示，我们如何创建一个服务(在我们的例子中是<code class="fe mp mq mr ms b">pay</code>，它使用一个<code class="fe mp mq mr ms b">ApplicationRouter</code>来编排可用的需要的模块来交付它。</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="c0a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以看到模块不是直接通过它们的类型名称表示来调用的，而是简单而通用地通过它们的<code class="fe mp mq mr ms b">route</code>来调用，在<code class="fe mp mq mr ms b">URL</code>参数中指定为<code class="fe mp mq mr ms b">host</code>。通过<code class="fe mp mq mr ms b">path</code>可以访问特定的模块功能，如果需要参数，那么它们将作为简单的<code class="fe mp mq mr ms b">[String: String]</code>字典在<code class="fe mp mq mr ms b">parameters</code>参数中传递，就像其他URL一样。</p><p id="bb44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就功能而言，上面的例子代表付费服务，我们需要为其提供一个<code class="fe mp mq mr ms b">amount</code>、一个<code class="fe mp mq mr ms b">username</code>和一个<code class="fe mp mq mr ms b">password</code>。最后2个首先用于获得一个<code class="fe mp mq mr ms b">paymentToken</code>，然后我们用令牌和<code class="fe mp mq mr ms b">amount</code>调用<code class="fe mp mq mr ms b">payments</code>主机/模块中的<code class="fe mp mq mr ms b">/pay</code>路径。</p><p id="f12b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还应该在这里补充一下，我们在这里使用内部模式(<code class="fe mp mq mr ms b">tandem</code>)，这有助于我们区分内部和外部URL位置。对于那些忘记如何设置它的人，它在Info.plist中的这些属性下:</p><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/bbeb279bd2fa5793663bad6d51a743db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SRfo2MICEYJ0RPrM87GXew.jpeg"/></div></div></figure><h1 id="8236" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">目标实现了吗？</h1><p id="5d70" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">看到这个代码示例，我想说我们的接受标准或多或少得到了满足。但是像往常一样，我们可能会得到一些额外的东西。我最喜欢的事实是，我们已经简化并大大减少了函数签名的数量，并使添加、扩展和替换函数及其参数更加灵活。我们使用的唯一函数实际上是<code class="fe mp mq mr ms b">open</code>，其他的都是<code class="fe mp mq mr ms b">String</code>，你只能想象重构的工作量是如何减少的。此外，想象一下单元测试的简化，它现在可以受益于更多的助手代码，并且实际测试代码的复杂性也将大大降低。</p><p id="5a03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我最喜欢的extra肯定是<strong class="jp ir"> <em class="mo">【无类型依赖】</em> </strong>。想象一下这种情况，你想把不同的模块存放在不同的仓库中。一个模块可能会有许多依赖的模块，而不是将相同的模块一次又一次地存放在不同的存储库/项目中，你只需要简单地:嗯，什么都不做！！:)当然，<strong class="jp ir">项目会编译，因为模块是松散耦合的，没有引用具体的类型或者协议。想象一下测试是多么容易！不需要编写成千上万的mock、子类化实际类型或实现实际协议，您只需创建一个通用模块mock并在模块回调中返回存根字典！</strong></p><p id="74e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">胡萝卜加大棒。这种方法的缺点是我们在编译时失去了对模块名及其方法的类型检查。然而，我们已经在<code class="fe mp mq mr ms b">ApplicationRouter</code>中实现了简单的<code class="fe mp mq mr ms b">host</code>和<code class="fe mp mq mr ms b">path</code>检查，所以我们在运行时<code class="fe mp mq mr ms b">assert</code>。在我看来，这不是一个太大的权衡。</p><p id="816f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在下一章看看这些模块是如何实现的。</p><div class="kl km gp gr kn ko"><a href="https://medium.com/@poksi/module-oriented-architecture-part-3-modules-and-routing-241b06439a9f" rel="noopener follow" target="_blank"><div class="kp ab fo"><div class="kq ab kr cl cj ks"><h2 class="bd ir gy z fp kt fr fs ku fu fw ip bi translated">面向模块的体系结构第3部分:模块和路由</h2><div class="kv l"><h3 class="bd b gy z fp kt fr fs ku fu fw dk translated">刷新你的记忆:</h3></div><div class="kw l"><p class="bd b dl z fp kt fr fs ku fu fw dk translated">medium.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm nf ko"/></div></div></a></div></div></div>    
</body>
</html>