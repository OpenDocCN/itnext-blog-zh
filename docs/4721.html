<html>
<head>
<title>How To Extend A Native HTML Element</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何扩展原生HTML元素</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-extend-a-native-html-element-1d4674e09c22?source=collection_archive---------1-----------------------#2020-09-01">https://itnext.io/how-to-extend-a-native-html-element-1d4674e09c22?source=collection_archive---------1-----------------------#2020-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1869" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当标准HTML不够用时</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/103c7c29d9be5afc11026392553ac72b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UZtzcmnoV1FcL_gM"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">瑞安·昆塔尔在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="e958" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从XML时代开始，我们就试图用我们自己的标签来扩展HTML。</p><p id="30b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">HTML标签的标准库是相当有限的，并且有意由低级构建块组成，这意味着由开发人员组成更高级的功能。</p><p id="0632" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在所有的现代浏览器都支持<a class="ae le" href="https://blog.usejournal.com/web-components-will-replace-your-frontend-framework-3b17a580831c" rel="noopener ugc nofollow" target="_blank"> Web组件</a>(或者更具体地说<a class="ae le" href="https://caniuse.com/#feat=custom-elementsv1" rel="noopener ugc nofollow" target="_blank">自定义元素</a>)你可以创建你自己的HTML元素，你可以在任何地方使用它们，只需加载一个脚本，然后将标签添加到文档中。</p><p id="a5b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">真的就这么简单。</p><p id="12b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您已经创建了自己的图像库，您只需加载脚本并将<code class="fe lf lg lh li b">&lt;image-gallery&gt;&lt;/image-gallery&gt;</code>添加到文档中即可使用它:</p><pre class="kp kq kr ks gt lj li lk ll aw lm bi"><span id="05d7" class="ln lo it li b gy lp lq l lr ls">class ImageGallery extends HTMLElement {<br/>  constructor() {<br/>    super();<br/>  }</span><span id="6805" class="ln lo it li b gy lt lq l lr ls">  ...</span><span id="47e8" class="ln lo it li b gy lt lq l lr ls">}</span><span id="7e80" class="ln lo it li b gy lt lq l lr ls">customElements.define('image-gallery', ImageGallery);</span><span id="ff81" class="ln lo it li b gy lt lq l lr ls">&lt;image-gallery&gt;&lt;/image-gallery&gt;  // presto!</span></pre><p id="ae01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的<code class="fe lf lg lh li b">ImageGallery</code>类包含了<code class="fe lf lg lh li b">&lt;image-gallery&gt;</code> HTML元素的所有功能，我们通过<code class="fe lf lg lh li b">customElements.define</code>用<code class="fe lf lg lh li b">'image-gallery'</code>标签名注册它。</p><p id="e52c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在像React、Angular和Vue.js这样的框架也允许你创建自己的HTML标签，但是与框架组件相反，自定义元素是<em class="lu">真正的</em>一级HTML元素。</p><p id="129d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，<code class="fe lf lg lh li b">ImageGallery</code>类扩展了<code class="fe lf lg lh li b">HTMLElement</code>，这是所有HTML元素的基本接口。这意味着它将继承所有HTML元素共有的功能。</p><p id="9eb2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，您可以通过<code class="fe lf lg lh li b">addEventListener</code>将事件侦听器附加到它，使用CSS通过它的<code class="fe lf lg lh li b">style</code>属性对它进行样式化，或者像任何其他HTML元素一样在浏览器devtools中与它进行交互。</p><p id="0345" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">而且不止于此。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4f63" class="mc lo it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">站在巨人的肩膀上</h1><p id="8884" class="pw-post-body-paragraph jq jr it js b jt mz jv jw jx na jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">除了扩展<code class="fe lf lg lh li b">HTMLElement</code>，定制元素还可以扩展其他内置的HTML元素，例如<code class="fe lf lg lh li b">&lt;button&gt;</code>、<code class="fe lf lg lh li b">&lt;img&gt;</code>和<code class="fe lf lg lh li b">&lt;a&gt;</code>。</p><p id="ce0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们想要创建一个延迟加载的图像，直到它被滚动到视窗中才会被加载。我们可以通过搜索页面中的所有图像并给每个图像附加一个<code class="fe lf lg lh li b">IntersectionObserver</code>来确保图像只有在可见时才会被加载。</p><p id="95ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是我们也可以<em class="lu">扩展内置的图像元素本身</em>并使用增强的图像元素代替常规的<code class="fe lf lg lh li b">&lt;img&gt;</code> HTML元素。</p><p id="b08b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以通过创建一个定制元素来实现这一点，这个定制元素不扩展<code class="fe lf lg lh li b">HTMLElement</code>，而是扩展<code class="fe lf lg lh li b">&lt;img&gt;</code>元素的接口，也就是<code class="fe lf lg lh li b">HTMLImageElement</code>:</p><pre class="kp kq kr ks gt lj li lk ll aw lm bi"><span id="6732" class="ln lo it li b gy lp lq l lr ls">class LazyImg extends HTMLImageElement {<br/>  constructor() {<br/>    super();<br/>  }</span><span id="cec3" class="ln lo it li b gy lt lq l lr ls">...</span><span id="935a" class="ln lo it li b gy lt lq l lr ls">}</span><span id="1594" class="ln lo it li b gy lt lq l lr ls">customElements.define('lazy-img', LazyImg, {extends: 'img'});</span></pre><p id="42f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">定制元素是通过对<code class="fe lf lg lh li b">customElement.define</code>的调用注册的，但是现在它需要第三个参数<code class="fe lf lg lh li b">{extends: 'img'}</code>，指定哪个HTML元素将被扩展。</p><p id="48c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们不再使用新的HTML标签，而是使用带有常规<code class="fe lf lg lh li b">&lt;img&gt;</code>标签的增强型图像元素，但是我们通过<code class="fe lf lg lh li b">is</code>属性为其添加了新的功能:</p><pre class="kp kq kr ks gt lj li lk ll aw lm bi"><span id="8773" class="ln lo it li b gy lp lq l lr ls">&lt;img <strong class="li iu">is="lazy-img"</strong> src="/path/to/image.png"&gt;</span></pre><p id="3adb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个图像现在是一个增强的图像，获得了我们在<code class="fe lf lg lh li b">LazyImg</code>类中定义的所有功能。</p><p id="a269" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lu"/><code class="fe lf lg lh li b"><em class="lu">LazyImg</em></code><em class="lu">的完整实现对于本文来说太大了，但是您可以在我的Github </em>  <em class="lu">上找到源代码。</em></p><p id="4c0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方法的美妙之处在于，任何不支持扩展内置HTML元素的浏览器都会简单地忽略<code class="fe lf lg lh li b">is</code>属性，只呈现常规图像。</p><p id="9fa4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">渐进增强的最佳表现。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cf4b" class="mc lo it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">示例:客户端路由</h1><p id="9975" class="pw-post-body-paragraph jq jr it js b jt mz jv jw jx na jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">这样，我们也可以轻松地增强普通链接，使之成为与客户端路由器一起工作的链接。</p><p id="9449" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通常，我们需要遍历所有这些链接，并编写一些代码来防止我们在单击链接时导航到另一个页面，因为我们希望在客户端处理路由。</p><p id="2212" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过扩展原生的<code class="fe lf lg lh li b">&lt;a&gt;</code>标签，我们可以简单地添加一个<code class="fe lf lg lh li b">is</code>属性来表明它是一个客户端链接，所以它不会使浏览器在被点击时转到其<code class="fe lf lg lh li b">href</code>属性中指定的页面。</p><p id="fd1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们通过扩展作为<code class="fe lf lg lh li b">&lt;a&gt;</code>标签接口的<code class="fe lf lg lh li b">HTMLAnchorElement</code>来做到这一点:</p><pre class="kp kq kr ks gt lj li lk ll aw lm bi"><span id="e0e9" class="ln lo it li b gy lp lq l lr ls">class RouterLink extends HTMLAnchorElement<strong class="li iu"><em class="lu"> </em></strong>{<br/>  constructor() {<br/>    super();<br/>  }<br/><br/>  connectedCallback() {<br/>    this.addEventListener('click', e =&gt; {<br/>      e.preventDefault();<br/>      <br/>      this.dispatchEvent(new CustomEvent('route-change', {<br/>        composed: true,<br/>        detail: {link: this}<br/>      }));<br/>    })<br/>  }<br/>}</span></pre><p id="df01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe lf lg lh li b">connectedCallback</code>中，我们设置了一个事件处理程序来拦截<code class="fe lf lg lh li b">click</code>事件。通过调用<code class="fe lf lg lh li b">e.preventDefault</code>，我们阻止了浏览器跟随链接，所以当用户点击链接时什么都不会发生。</p><p id="3234" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们抛出一个新的<code class="fe lf lg lh li b">route-change</code>事件，在<code class="fe lf lg lh li b">link</code>属性中使用链接作为有效负载。父元素可以监听该事件并执行客户端路由，例如一个已经扩展的<code class="fe lf lg lh li b">nav</code>标记:</p><pre class="kp kq kr ks gt lj li lk ll aw lm bi"><span id="e2c8" class="ln lo it li b gy lp lq l lr ls">&lt;nav <strong class="li iu">is="client-side-router</strong>"&gt;<br/>  &lt;a href="/path/to/page1" <strong class="li iu">is="router-link"</strong>&gt;Page 1&lt;/a&gt;<br/>  &lt;a href="/path/to/page2" <strong class="li iu">is="router-link"</strong>&gt;Page 2&lt;/a&gt;<br/>  &lt;a href="/path/to/page3" <strong class="li iu">is="router-link"</strong>&gt;Page 3&lt;/a&gt;<br/>&lt;/nav&gt;</span></pre><p id="680c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过这种方式，我们可以构建一个导航组件，它可以在不支持浏览器的旧版本中工作得非常好，并且可以在现代浏览器中被增强为客户端路由器(T21)。</p><p id="bff6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看如何通过扩展<code class="fe lf lg lh li b">&lt;nav&gt;</code>标签来实现路由器本身。</p><p id="7e77" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lf lg lh li b">&lt;nav&gt;</code>标签没有自己的接口，所以它只是扩展了<code class="fe lf lg lh li b">HTMLElement</code>。尽管它是一个内置元素，我们仍然可以向它添加Shadow DOM，这将使与子元素(链接)的交互变得更加容易和健壮:</p><pre class="kp kq kr ks gt lj li lk ll aw lm bi"><span id="5b41" class="ln lo it li b gy lp lq l lr ls">class ClientSideRouter extends HTMLElement<strong class="li iu"><em class="lu"> </em></strong>{<br/>  constructor() {<br/>    super();<br/><br/>    const shadowRoot = this.attachShadow({mode: 'open'});<br/><br/>    shadowRoot.innerHTML = `<br/>      &lt;slot name="link"&gt;&lt;/slot&gt;<br/>    `;<br/>  }<br/><br/>  connectedCallback() {<br/>    const slot = this.shadowRoot.querySelector('slot');<br/>    const links = slot.assignedNodes();<br/><br/>    links.forEach(link =&gt; {<br/>      link.addEventListener('route-change', e =&gt; {<br/>        this.handleRouteChange(e.detail.link);<br/>      });<br/>    });<br/>  }<br/>}</span></pre><p id="c1bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">路由器的影子DOM将只包含一个命名的<code class="fe lf lg lh li b">&lt;slot&gt;</code>元素，它将作为链接的插入点。然后，我们可以通过<code class="fe lf lg lh li b">&lt;slot&gt;</code>的<code class="fe lf lg lh li b">assignedNodes</code>方法获取所有链接，并为每个链接添加一个事件监听器，这样我们就可以在单击链接时处理路由更改。</p><p id="64d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要在链接上添加的唯一东西是一个<code class="fe lf lg lh li b">slot</code>属性，以确保它们被插入到正确的插槽中:</p><pre class="kp kq kr ks gt lj li lk ll aw lm bi"><span id="a10c" class="ln lo it li b gy lp lq l lr ls">&lt;a href="/path/to/page1" is="router-link" <strong class="li iu">slot="link"</strong>&gt;Page 1&lt;/a&gt;</span></pre><p id="7c36" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lu">我们可以省略插槽上的</em> <code class="fe lf lg lh li b"><em class="lu">name</em></code> <em class="lu">属性和链接上的</em> <code class="fe lf lg lh li b"><em class="lu">slot</em></code> <em class="lu">属性。这也可以，但是</em> <code class="fe lf lg lh li b"><em class="lu">nav</em></code> <em class="lu">组件中的任何换行符也会被</em> <code class="fe lf lg lh li b"><em class="lu">assignedNodes()</em></code> <em class="lu">作为空文本节点返回，我们需要过滤掉它们。</em></p><p id="7c18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这很好，但我们需要为每个链接添加一个单独的事件处理程序，这有点不幸且效率低下。如果我们能给路由器本身添加一个事件处理器，那就更好了。</p><p id="68c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以通过将<code class="fe lf lg lh li b">bubbles: true</code>添加到由<code class="fe lf lg lh li b">RouterLink</code>抛出的<code class="fe lf lg lh li b">route-change</code>事件的配置对象中来做到这一点:</p><pre class="kp kq kr ks gt lj li lk ll aw lm bi"><span id="007e" class="ln lo it li b gy lp lq l lr ls">this.dispatchEvent(new CustomEvent('route-change', {<br/>  composed: true,<br/>  <strong class="li iu">bubbles: true, </strong>// &lt;-- add this to make the event bubble up<br/>  detail: {url}<br/>}));</span></pre><p id="b536" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该事件现在将冒泡，我们可以在路由器上收听它:</p><pre class="kp kq kr ks gt lj li lk ll aw lm bi"><span id="3c7f" class="ln lo it li b gy lp lq l lr ls">class ClientSideRouter extends HTMLElement<strong class="li iu"><em class="lu"> </em></strong>{<br/>  constructor() {<br/>    super();<br/><br/>    const shadowRoot = this.attachShadow({mode: 'open'});<br/><br/>    shadowRoot.innerHTML = `<br/>      &lt;slot name="link"&gt;&lt;/slot&gt;<br/>    `;<br/>  }<br/><br/>  connectedCallback() {<br/>    this.outlet = document.querySelector(this.dataset.outlet);<br/><br/>    <strong class="li iu">this.addEventListener('route-change', e =&gt; {<br/>      this.handleRouteChange(e.detail.link)<br/>    });</strong><br/>  }<br/><br/>  handleRouteChange(link) {<br/>    // handle route change<br/>  }<br/>}<br/><br/>customElements.define('client-side-router', ClientSideRouter, {extends: 'nav'});</span></pre><p id="b2f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在还可以制作一个简单的<code class="fe lf lg lh li b">handleRouteChange</code>方法实现。我们可以给路由器添加一个<code class="fe lf lg lh li b">data-</code>属性，包含一个CSS选择器来指定模板应该呈现在哪里，给每个路由器链接添加一个<code class="fe lf lg lh li b">data-</code>属性来指定应该呈现哪个模板:</p><pre class="kp kq kr ks gt lj li lk ll aw lm bi"><span id="721c" class="ln lo it li b gy lp lq l lr ls">&lt;nav is="client-side-router" <strong class="li iu">data-outlet="#main"</strong>&gt;<br/>  &lt;a href="/path/to/page1" is="router-link" slot="link"<br/>     <strong class="li iu">data-template="./page1.html"</strong>&gt;Page 1&lt;/a&gt;<br/>  <br/>  ...</span><span id="4eb4" class="ln lo it li b gy lt lq l lr ls">&lt;/nav&gt;</span><span id="7832" class="ln lo it li b gy lt lq l lr ls">&lt;!-- templates are rendered here --&gt;<br/>&lt;div <strong class="li iu">id="main"</strong>&gt;&lt;/div&gt;</span></pre><p id="4590" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe lf lg lh li b">handleRouteChange</code>方法中，我们获取模板，在outlet中渲染，并向浏览器的历史记录中添加条目，因此url将会改变以反映路由的变化:</p><pre class="kp kq kr ks gt lj li lk ll aw lm bi"><span id="349a" class="ln lo it li b gy lp lq l lr ls">async handleRouteChange(link) {<br/>  const template = link.dataset.template;<br/>  const url = link.getAttribute('href');<br/>  const state = {template, url};<br/><br/>  const html = await (await fetch(template)).text();<br/><br/>  history.pushState(state, null, url);<br/><br/>  this.outlet.innerHTML = html;<br/>}</span></pre><p id="5810" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这显然是一个幼稚且非常基础的实现，但我希望您已经了解了扩展内置HTML元素的可能性。</p><p id="f9ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以在<a class="ae le" href="https://github.com/DannyMoerkerke/client-side-router" rel="noopener ugc nofollow" target="_blank">我的Github </a>上找到包含演示页面的源代码。</p><p id="bef3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以在Twitter上关注我，我经常在那里写关于PWAs、网络组件和现代网络功能的文章。</p></div></div>    
</body>
</html>