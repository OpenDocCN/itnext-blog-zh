<html>
<head>
<title>Handling Asynchronous Operations in Parallel in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Node.js中并行处理异步操作</h1>
<blockquote>原文：<a href="https://itnext.io/node-js-handling-asynchronous-operations-in-parallel-69679dfae3fc?source=collection_archive---------1-----------------------#2019-02-05">https://itnext.io/node-js-handling-asynchronous-operations-in-parallel-69679dfae3fc?source=collection_archive---------1-----------------------#2019-02-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/ef79f8d407aeab52f04486fcc761832f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7bay7jIDxCknwGxsCiSBAw.jpeg"/></div></figure><p id="9653" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">Node.js，<em class="kv">简而言之</em>，是服务器端JavaScript执行的单线程环境。你写的JavaScript在一个线程上执行。那么Node.js如何处理负载并保持性能呢？关键是<em class="kv">非阻塞异步I/O </em>。说实话，根本没那么简单。还有libuv的线程池，让某些阻塞的东西表现得像非阻塞。这样或那样，在Node.js中，我们异步地做事情，这让成千上万的客户端同时得到服务。有很多不错的文章详细描述了这些方面，因此我不打算深入阐述。</p><p id="29bf" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最后，您要处理承诺，它代表一些异步动作。由于回访很容易转化为承诺，所以我不打算考虑它们。我想重点介绍一件事:<strong class="jz iu"> <em class="kv">在Node.js中并行处理异步操作和正确处理</em> </strong> <em class="kv">。</em></p><p id="3c4c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">自从Node.js 4(最初带有<code class="fe kw kx ky kz b">--harmony</code>标志)以来，我们被赋予了原生承诺。MDN对承诺的描述如下:</p><blockquote class="la lb lc"><p id="01ec" class="jx jy kv jz b ka kb kc kd ke kf kg kh ld kj kk kl le kn ko kp lf kr ks kt ku im bi translated"><code class="fe kw kx ky kz b"><strong class="jz iu">Promise</strong></code>对象表示异步操作的最终完成(或失败)及其结果值。</p></blockquote><p id="388e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">有一点应该牢记在心:一旦承诺产生，它的执行就已经开始了，不管你是否<code class="fe kw kx ky kz b">.then</code>它。一旦调用<code class="fe kw kx ky kz b">fetch('https://example.com/')</code>，请求就会被激发；需要<code class="fe kw kx ky kz b">.then</code>或<code class="fe kw kx ky kz b">.catch</code>以便仅处理响应。这样，如果创建了几个承诺(例如，我们已经一个接一个地同步调用了几次<code class="fe kw kx ky kz b">fetch</code>)，请求将被并行触发。</p><p id="b54b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">出于演示目的，让我们介绍一个助手函数和一些实用程序:</p><ul class=""><li id="c15f" class="lg lh it jz b ka kb ke kf ki li km lj kq lk ku ll lm ln lo bi translated"><code class="fe kw kx ky kz b">numberOfOperations</code>:要执行的异步操作的数量。</li><li id="3fe8" class="lg lh it jz b ka lp ke lq ki lr km ls kq lt ku ll lm ln lo bi translated"><code class="fe kw kx ky kz b">listOfArguments</code>:包含每次执行传递给<code class="fe kw kx ky kz b">asyncOperation</code>的参数。为简单起见而介绍。</li><li id="3363" class="lg lh it jz b ka lp ke lq ki lr km ls kq lt ku ll lm ln lo bi translated"><code class="fe kw kx ky kz b">asyncOperation</code>:伪造异步操作的函数:返回一个承诺，这个承诺会在1到10秒内解决。</li><li id="059f" class="lg lh it jz b ka lp ke lq ki lr km ls kq lt ku ll lm ln lo bi translated"><code class="fe kw kx ky kz b">listOfDelays</code>:数组，包含对应每个<code class="fe kw kx ky kz b">asyncOperation</code>的解析秒数。<code class="fe kw kx ky kz b">listOfDelays</code>在开始时填充一次，以后用于所有的镜头和子镜头。<em class="kv">请记住，下面给出的所有时间测量值都与特定的</em> <code class="fe kw kx ky kz b"><em class="kv">listOfDelays</em></code> <em class="kv">相关，并且可能会因执行而异。无论如何，最终的结果平均起来是一样的</em>。</li><li id="31f0" class="lg lh it jz b ka lp ke lq ki lr km ls kq lt ku ll lm ln lo bi translated"><code class="fe kw kx ky kz b">watchCounter</code>:查看当前执行承诺量的功能。每秒将其数据写入控制台。</li></ul><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div></figure><h1 id="2c8a" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">并行执行—取0</h1><p id="4db4" class="pw-post-body-paragraph jx jy it jz b ka my kc kd ke mz kg kh ki na kk kl km nb ko kp kq nc ks kt ku im bi translated">让我们看看下面的代码。我们执行<code class="fe kw kx ky kz b">asyncOperation</code>并返回结果列表。</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="88fe" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">说实话，一点都不平行。我们依次等待每个<code class="fe kw kx ky kz b">asyncOperation</code>完成，因此结果列表按正确的顺序给出。我们在每次迭代中创建一个承诺，并等待它的完成。在任何时候，我们只有一个承诺在执行:</p><figure class="lu lv lw lx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nd"><img src="../Images/ab80abec5fd34440fa97156387dbabb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qbgd2xNI9cbS4W-9hTqMWA.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">承诺在每一刻都在执行</figcaption></figure><p id="7e47" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这种类型的执行需要142秒才能完成。执行时间是所有操作执行时间的总和。这种做法，即使我们不屏蔽，似乎也不是一个好的解决办法。</p><h1 id="ca7c" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">并行执行—第一次</h1><p id="3355" class="pw-post-body-paragraph jx jy it jz b ka my kc kd ke mz kg kh ki na kk kl km nb ko kp kq nc ks kt ku im bi translated">这次是平行的，我发誓。让我们稍微改变一下前面的例子。不要在每次迭代中调用并等待<code class="fe kw kx ky kz b">asyncOperation</code>，让我们预先调用所有的函数。它将为我们提供一份有待兑现的承诺清单:</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="72ff" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在我们所有的承诺都开始并行执行。我们收集等待每个承诺的数据，最终给出正确的结果顺序。</p><p id="ed2d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">履行承诺的数量随着时间的推移而减少:</p><figure class="lu lv lw lx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nd"><img src="../Images/885f70c05c058557840639d1b4faad70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*krHJUkUPYkpmYviRpcZ2Kg.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">并行开始所有的承诺，最后收获</figcaption></figure><p id="95b8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这种执行只花了9秒钟。好多了！现在，总时间被绑定到最慢操作的执行时间。</p><h1 id="e3d0" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">并行执行—第二次</h1><p id="786c" class="pw-post-body-paragraph jx jy it jz b ka my kc kd ke mz kg kh ki na kk kl km nb ko kp kq nc ks kt ku im bi translated">我们可以用<code class="fe kw kx ky kz b">Promise.all</code>缩短前面的代码。它接受一组承诺，并在所有承诺都得到解决时进行解决，或者如果任何承诺被拒绝，则进行拒绝。</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="84e2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">执行时间和图表几乎相同，所以我将跳过它。检查之前的拍摄。</p><p id="0c07" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">虽然我们做得很好，但我们必须牢记一个威胁。</p><h1 id="78be" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">并行执行—第三步</h1><p id="079f" class="pw-post-body-paragraph jx jy it jz b ka my kc kd ke mz kg kh ki na kk kl km nb ko kp kq nc ks kt ku im bi translated">前面的两个例子做了我们想要的事情:处理并行承诺的执行。但是它会并行执行<em class="kv">您提供的所有承诺</em>，这可能会导致一些问题。</p><p id="7f5b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果<code class="fe kw kx ky kz b">asyncOperation</code>请求有速率限制的第三方API怎么办？它可以是请求量或传递的数据量。根据承诺的数量，你可能会碰到这种情况。</p><p id="3c8a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">重点是:<em class="kv">并行做事情是好的，但你应该考虑实际操作，并防止并行做可能带来的负面后果</em>。如果能够限制并行执行的请求数量，那就太好了。它将允许更好地控制应用程序的流程。</p><h2 id="5279" class="nm mb it bd mc nn no dn mg np nq dp mk ki nr ns mo km nt nu ms kq nv nw mw nx bi translated">子标签— 0</h2><p id="cd17" class="pw-post-body-paragraph jx jy it jz b ka my kc kd ke mz kg kh ki na kk kl km nb ko kp kq nc ks kt ku im bi translated">我们可以很容易地做的是在最开始的时候分割调用的数量。让我们设置一个阈值，在任何给定的时刻，最多并行执行5个承诺。这样，让我们将参数列表分散到批列表中，每批5个。接下来，我们为每个参数调用<code class="fe kw kx ky kz b">fn</code>来获得一个承诺列表。最后，我们等待这个列表完成，然后再获取下一个。</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="f080" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">嗯，不可否认，我们已经完成了我们需要的。在任何给定时刻，并行执行的承诺的数量被限制为小于或等于5。我们逐批处理数据并得到结果。整个执行用了40秒，比9秒差，但比142秒好多了。然而，让我们来看看图表。</p><figure class="lu lv lw lx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nd"><img src="../Images/a7fd3a265bf37cf6e328c41f244f5107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f8ilNzozt727klGDflzt_Q.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">开始时按批次传播参数，并等待每个批次完成</figcaption></figure><p id="52db" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">履行承诺的数量是有峰值的。这意味着负载没有分散，我们可能在峰值之间有一些资源处于空闲状态。问题在于，单个批处理的完成时间与批处理中最慢的操作的完成时间一样长。批处理可能包含5个操作，其中4个需要1秒钟完成，最后一个需要10秒钟。由于我们使用的是<code class="fe kw kx ky kz b">Promise.all</code>，整批也需要10秒钟完成。</p><h2 id="4b44" class="nm mb it bd mc nn no dn mg np nq dp mk ki nr ns mo km nt nu ms kq nv nw mw nx bi translated">子标签— 1</h2><p id="357b" class="pw-post-body-paragraph jx jy it jz b ka my kc kd ke mz kg kh ki na kk kl km nb ko kp kq nc ks kt ku im bi translated">为了纠正这一点，应该采取另一种方法。让我们逐个承诺地处理数据，而不是将最初的参数数组分散到批中。在前面的子任务中，逻辑是:</p><ul class=""><li id="caec" class="lg lh it jz b ka kb ke kf ki li km lj kq lk ku ll lm ln lo bi translated">将参数分散到批次列表中，并对每个批次依次执行以下步骤；</li><li id="2103" class="lg lh it jz b ka lp ke lq ki lr km ls kq lt ku ll lm ln lo bi translated">为单个批处理中的每个参数调用<code class="fe kw kx ky kz b">fn</code>以获得承诺列表；</li><li id="58a1" class="lg lh it jz b ka lp ke lq ki lr km ls kq lt ku ll lm ln lo bi translated">等待完成一系列承诺；</li></ul><p id="ba16" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在我们将改变逻辑。我们将创建第一批已解决的承诺，并将以下活动与批中的每个承诺相关联:</p><ul class=""><li id="ba7b" class="lg lh it jz b ka kb ke kf ki li km lj kq lk ku ll lm ln lo bi translated">从参数列表中获取下一个参数；</li><li id="0a9d" class="lg lh it jz b ka lp ke lq ki lr km ls kq lt ku ll lm ln lo bi translated">叫<code class="fe kw kx ky kz b">fn</code>；</li><li id="e105" class="lg lh it jz b ka lp ke lq ki lr km ls kq lt ku ll lm ln lo bi translated">将相同的步骤链接到返回的承诺(如果我们有要处理的参数)。</li></ul><p id="2384" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这样，一旦当前执行的承诺之一被解决，我们就接受下一个参数，调用<code class="fe kw kx ky kz b">fn</code>并链接承诺。由于初始批处理的大小等于我们的并发限制，我们不会在一个时刻运行超过5个承诺。</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="4501" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，我们在任何给定时间最多执行5个承诺，但现在我们更好地分配了负载，没有出现峰值:</p><figure class="lu lv lw lx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nd"><img src="../Images/2b8d330f4599eaa00098a5502e3a3e9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ALZyVsGbX53c_JOrhZ10g.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">正确地将执行的承诺数量限制为5</figcaption></figure><p id="bce7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">整个执行过程耗时33秒。我们赢了7秒，并且更好地分配了负载。</p><p id="f9cd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">很好，我们现在有了并行执行，并最终获得了对流程的控制。不幸的是，现在喝香槟还为时过早。希望你已经注意到我们遗漏了一件重要的事情:<em class="kv">执行时没有收集到任何结果！让我们来解决这个问题。有几种不同的方法可以做到这一点，我想用一个事实，那就是我们确切地知道在结果数组中应该有多少个元素。因此，我将分配一个空数组，并最终用与最初传递的参数相对应的值填充它。</em></p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="697b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">每个Promise在完成时都会在特定的位置添加一个条目，因此顺序与最初传递的参数相对应。</p><p id="a570" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">到目前为止，我们已经完成了所需要的:异步操作被并行执行，我们能够控制这些操作的运行数量。该代码可能在许多地方被缩短，但出于教育目仍保持原样。除此之外，还有很多其他需要改进的地方:</p><ul class=""><li id="46dc" class="lg lh it jz b ka kb ke kf ki li km lj kq lk ku ll lm ln lo bi translated">只有一个参数被调用，我们将来可能想要传递几个参数；</li><li id="09a4" class="lg lh it jz b ka lp ke lq ki lr km ls kq lt ku ll lm ln lo bi translated">根本没有错误处理，这显然是强制性的，称之为生产就绪的解决方案；</li><li id="c544" class="lg lh it jz b ka lp ke lq ki lr km ls kq lt ku ll lm ln lo bi translated">在<code class="fe kw kx ky kz b">take3subtake1part0</code>和<code class="fe kw kx ky kz b">take3subtake1part1</code>中可以采用另一种方法:我们可以使用索引，而不是增强和复制一系列的参数并耗尽它们；</li><li id="d918" class="lg lh it jz b ka lp ke lq ki lr km ls kq lt ku ll lm ln lo bi translated">我们可以省略<code class="fe kw kx ky kz b">Promise.resolve</code>的用法，从真正的操作开始。提示:<em class="kv">我们需要观察最初的参数数量</em>；</li></ul><p id="201b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果有人觉得这篇文章很有趣，我会建议他自己应用这个增强功能来热身。</p></div></div>    
</body>
</html>