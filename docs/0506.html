<html>
<head>
<title>Why I don’t like ImmutableJS in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我不喜欢反应中的不变量</h1>
<blockquote>原文：<a href="https://itnext.io/why-i-dont-like-immutablejs-in-react-f1d2fd03230e?source=collection_archive---------1-----------------------#2018-03-21">https://itnext.io/why-i-dont-like-immutablejs-in-react-f1d2fd03230e?source=collection_archive---------1-----------------------#2018-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8257f284815a45220fab12f0c7b50a78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M0BZyGsojKAyQHIx481xNA.png"/></div></div></figure><p id="2d61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不认为我需要向唱诗班宣讲javascript应用程序中的<strong class="ka ir">突变</strong>有多邪恶，以及ImmutableJS如何通过将数据封装到具有私有属性的对象中来帮助消除它。</p><p id="941d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这的确是一个非常好的主意。它迫使你不能变异任何东西，<strong class="ka ir">在整个应用</strong>！</p><p id="d5d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我个人喜欢。但是，说到反应，我发现有点(或者非常)没必要。为什么让我们从不变量试图解决什么问题开始。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="b3f8" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">不变的</h1><p id="6107" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">因为真理的唯一来源是JS中的圣经，允许改变价值观可能是灾难性的。例如，我有一个从服务器请求的客户机数据列表，我将它传递给两个组件。组件A改变它，但是组件B不知道它。更糟糕的是，原始的客户端列表永远消失了，直到您用另一个远程请求重新设置它。</p><p id="4032" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ImmutableJS是如何将所有东西包装(或封装)到它自己的映射或对象中的，就像Java一样。另外，它使所有属性都是私有的，并且只提供getters和setters。好就好在，setters不设置，他们用你想要的新值返回一个全新的对象！所以基本上你不能改变原始对象的任何值，一旦它被ImmutableJS包装。</p><h2 id="358b" class="mg le iq bd lf mh mi dn lj mj mk dp ln kj ml mm lr kn mn mo lv kr mp mq lz mr bi translated">React是如何关联的？</h2><p id="ab22" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">在React中你要处理的只是<strong class="ka ir">道具</strong>和<strong class="ka ir">状态</strong>。让我们快速回顾一下。</p><p id="aef6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> props </strong>:只读，从父节点传递。即使你可以给一个道具赋予不同的值，它也不会改变视图，它不会<strong class="ka ir"><em class="ms"/></strong>。这一点非常重要。</p><p id="0d3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">状态</strong>:局部变量，或者我应该称之为常量。原因是，给<strong class="ka ir">状态</strong>赋值也没有任何意义。它不更新视图，并且值只在您的作用域内局部改变(在您更新它的函数内)。</p><p id="7819" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，如果你还在猜测我想说什么，那么你可能会继续读下去。</p><p id="b63b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为一名经验丰富的React开发人员，除了一些实验之外，我从未使用过，也没见过给<strong class="ka ir">道具</strong>或<strong class="ka ir">状态</strong>赋值。如果你正在做，在你被抓住之前，停止！虽然，我真的相信，每个React开发人员在他们的React旅程中，或者旅程本身，会很快停止这样做。</p><p id="e86b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是我的观点:在React中，你永远不要给<strong class="ka ir">道具</strong>或<strong class="ka ir">状态</strong>赋值，只有它们才是重要的。</p><blockquote class="mt mu mv"><p id="afd9" class="jy jz ms ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated">你在生命周期之外创建的其他变量呢？</p></blockquote><p id="889b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的问题是:它们重要吗？</p><p id="23dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">恐怕不行。如果你试图用一个变量来更新视图，而不是那两种情况，你会很纠结，最终会很沮丧。否则，您就没有使用React的功能。</p><p id="3855" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管React对道具或状态赋值没有限制，但你不会喜欢做，不会想做，也不会做。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="2514" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">功能的</h1><p id="741b" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">React本身是功能性的。为什么</p><p id="fbcf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个React组件实际上都是一个函数。道具和状态都包在里面。如果你想从一个孩子身上改变一个父母的状态，他们唯一的办法就是使用一个函数(当然，你是在设置一个新的状态)。</p><blockquote class="mt mu mv"><p id="13c0" class="jy jz ms ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated">但是ImmutableJS提供了全功能的API。</p></blockquote><p id="c847" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我完全同意，这也是你应该做的。有很多图书馆可以帮助你。我会推荐<a class="ae mz" href="http://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> RamdaJS </a>。</p><p id="0d22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它提供的功能比你想象的要多，而且都是纯功能性的。你可以做currying，组成，函子和许多许多令人兴奋的功能。如果你想了解更多细节，请观看下面的视频。</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="421c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是的，你必须在你的代码中使用另一个库，就像你正在使用的库太多了。但这是唯一的缺点，我的朋友。老实说，我不认为这是骗局。</p><h1 id="c952" class="ld le iq bd lf lg ng li lj lk nh lm ln lo ni lq lr ls nj lu lv lw nk ly lz ma bi translated">与Redux一起使用</h1><p id="4bc2" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">我读过一些关于ImmutableJS与Redux配合得有多好的文章。</p><p id="8d1b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不是说它不是，但是真的，你需要吗？</p><p id="f084" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Redux中的减速器也完全可用。Reducers总是返回一个新状态。您可能希望只在reducers中使用不变量，以避免传入的<strong class="ka ir">状态</strong>发生变异。但是对于它返回的状态，真的需要让它成为不可变的对象吗？答案上面提到了。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="97be" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">没有永恒</h1><h2 id="160a" class="mg le iq bd lf mh mi dn lj mj mk dp ln kj ml mm lr kn mn mo lv kr mp mq lz mr bi translated">首先，调试愉快！</h2><p id="7741" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">对于ImmutableJS，我必须一次又一次地点击，才能在控制台中展开包装好的数据。如果只是一个简单的对象嵌套列表，我无法简单的找出里面是什么。</p><p id="e45d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有一些devtools可以帮助你将数据恢复到正常的<em class="ms">状态，尽管如此，我还是不喜欢那种无法获得数据的感觉。</em></p><h2 id="6006" class="mg le iq bd lf mh mi dn lj mj mk dp ln kj ml mm lr kn mn mo lv kr mp mq lz mr bi translated">ES6特性和更多功能</h2><p id="c4dc" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">我喜欢ES6的功能。使用ImmutableJS有点糟糕。而不是使用部分赋值，你需要一直调用<em class="ms"> get </em>。</p><pre class="na nb nc nd gt nl nm nn no aw np bi"><span id="e224" class="mg le iq nm b gy nq nr l ns nt">// ES6<br/>const {profile, image, age, gender} = this.props.client;</span><span id="ec11" class="mg le iq nm b gy nu nr l ns nt">// ImmutableJS<br/>const profile = Immutable.get(this.props.client, 'profile');<br/>const image = Immutable.get(this.props.client, 'image');<br/>const age = Immutable.get(this.props.client, 'age');<br/>const gender = Immutable.get(this.props.client, 'gender');</span></pre><p id="56b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和扩展运算符:</p><pre class="na nb nc nd gt nl nm nn no aw np bi"><span id="d798" class="mg le iq nm b gy nq nr l ns nt">// Spread operator<br/>return {<br/>  ...state,<br/>  profile: R.map(mapClientToProfile, state.client),<br/>  updated: true,<br/>  someOtherValue: value<br/>}</span><span id="86c6" class="mg le iq nm b gy nu nr l ns nt">// ImmutableJS<br/>return merge(state, {<br/>  profile: ImmutableJS.get(state, 'client').map(mapClientToProfile),<br/>  updated: true,<br/>  someOtherValue: value<br/>})</span></pre><p id="ae3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有人认为使用spread运算符的性能不如<em class="ms"> merge </em>函数有效(在这里运行一些测试<a class="ae mz" href="https://www.measurethat.net/Benchmarks/Show/579/1/arrayprototypeconcat-vs-spread-operator" rel="noopener ugc nofollow" target="_blank">)。而语法方面，spread运算符和调用函数没有太大区别，所以function赢在这一点上。正如你所看到的，ImmutableJS正试图转移到functional，然而，它仍然不太正确。(看上面的视频，真的很说明问题！)</a></p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="081e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总而言之，在React中，更新视图的机制设计得很好，可以让你开始学习如何避免直接变异，并做更具功能性的事情，ES6也提供了非常好的功能来帮助你忘记变异。</p><p id="9751" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">改为纯函数是避免代码突变的另一种方法，RamdaJS就是一个很好的工具。ImmutableJS还提供了一些功能，如<em class="ms">映射</em>、<em class="ms">过滤</em>和<em class="ms">查找</em>，但很常见的是，人们解开一个不可变的对象，进行复杂的映射，然后再包装回去。为什么一开始就要包装它们呢？它增加了数据的复杂性，而不是简化数据。</p><p id="6644" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对我来说，如果你真的理解突变有多糟糕，并愿意使用库来避免它，ImmutableJS只是选项之一，而且肯定不是最好的。有些人用它来防止其他开发人员做错误的事情，这是可以理解的，但你知道，总有更友好的方式。</p></div></div>    
</body>
</html>