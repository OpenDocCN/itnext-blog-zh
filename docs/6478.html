<html>
<head>
<title>Deploying Next Gen Serverless Functions with WebAssembly and Module Federation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用WebAssembly和模块联合部署下一代无服务器功能</h1>
<blockquote>原文：<a href="https://itnext.io/deploying-next-gen-serverless-functions-with-webassembly-and-module-federation-1471b94e425c?source=collection_archive---------1-----------------------#2021-11-29">https://itnext.io/deploying-next-gen-serverless-functions-with-webassembly-and-module-federation-1471b94e425c?source=collection_archive---------1-----------------------#2021-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a771" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不需要部署自动化。第二部分，共三部分。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/447b41b83c24db7d9a62addfbb9b121f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fzSv-6566h4QadNMfgFo1g.jpeg"/></div></div></figure><p id="1eed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文的第1部分中，我们讨论了Wasm作为无服务器运行时的优势以及它所解决的一些问题，比如消除冷启动性能问题。但是我们不得不考虑如何部署Wasm无服务器功能。</p><p id="ef53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没有码头集装箱，对吗？没错。Wasm是容器的替代品。把它想象成一个纳米容器。它已经提供了保护主机和其他容器所需的隔离。</p><p id="a5f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们不部署Docker容器，我们具体部署什么，如何部署？在这一点上，您会记得建议是避免在服务器上安装软件，而是在运行时通过网络传输软件。我们将把程序直接加载到内存中，而不是花费时间和资源将其复制到(短暂的)磁盘或远程存储(例如S3)中。</p><p id="d01a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑到我们可以从任何地方流式传输，源回购甚至CDN，我们的后端架构可能看起来很像我们的前端——如果我们使用JamStack的话。只需添加一个额外的箭头，从无服务器指向CDN。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/70a99ccce6b555e42f23e01f5f72f807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QlFL5jRIfhSt2qis9Mc2-w.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">Jamstack架构，支持来自cdn的微服务流</figcaption></figure><h2 id="5ea5" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">联合无服务器平台</h2><p id="a5ed" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">建立这样一个平台需要什么？K8s，Istio，Casandra，Etherium，Beat-complex-into-submission-ly？我们需要的是一个联邦运行时，它可以被告知哪些模块需要流式传输和执行。回想在前一篇文章中，我们考虑了这样一个<a class="ae kx" href="https://github.com/module-federation/aegis" rel="noopener ugc nofollow" target="_blank">运行时</a>，以及如何将它嵌入或移植到Wasm中。因此，联合无服务器平台的构建块是基于Wasm的模块联合运行时。这就是所需的一切:无需额外的软件来协调或执行部署。</p><p id="f67b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第三篇也是最后一篇文章中，我们将详细研究联邦无服务器平台。</p></div></div>    
</body>
</html>