<html>
<head>
<title>Protecting your NestJS API with Keycloak</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Keycloak保护您的NestJS API</h1>
<blockquote>原文：<a href="https://itnext.io/protecting-your-nestjs-api-with-keycloak-8236e0998233?source=collection_archive---------0-----------------------#2020-08-23">https://itnext.io/protecting-your-nestjs-api-with-keycloak-8236e0998233?source=collection_archive---------0-----------------------#2020-08-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ff22f63d0a45a3477bbb3bfd8d2406d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hsljLzoyooynUHHNWZGY0g.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">“在古代，猫被当作神来崇拜；他们没有忘记这一点。”—特里·普拉切特</figcaption></figure><p id="4612" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">从Keycloak网站来看，“<strong class="kh iu"> Keycloak </strong>是一个开源的身份和访问管理解决方案”。今天我们来看看如何用Keycloak保护你的HTTP API。</p><p id="be67" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如今，保护HTTP API的现代方法之一是通过“授权:载体<token>”HTTP头，令牌是携带身份和声明(角色等)的JWT。)的API的消费者。</token></p><p id="da90" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们假设您已经有一个JS前端应用程序，或者至少有一个HTTP客户端执行了针对Keycloak的身份验证，并且拥有一个JWT，可以将它作为HTTP“Authorization:Bearer<token>”头传递到您的NestJS后端。</token></p><p id="5c14" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">JWT可以是对称签名的(签名和验证JWT的秘密相同)，也可以是非对称签名的(用私钥签名的令牌，可以用相应的公钥验证)。Keycloak使用后者，这很好，因为它允许多个后端能够验证jwt，而不需要跨多个服务传播秘密。这意味着，如果您的一个服务受到威胁，至少攻击者无法自己伪造jwt来攻击其他服务。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h1 id="1330" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">履行</h1><p id="18ee" class="pw-post-body-paragraph kf kg it kh b ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc im bi translated">我们需要编写一个保护程序来修饰我们想要保护的控制器或单独的处理程序。</p><p id="94ab" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个防护将使用一个<strong class="kh iu">认证服务</strong>，它将执行(以各种方式，如下所示)JWT 的<strong class="kh iu">验证。</strong></p><p id="6c43" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所有需要的服务都将是AuthenticationModule的一部分，该模块将导出应用程序其余部分可能需要的一些服务。</p><p id="2381" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将提供一个可行的实现，并在以后对其进行改进，使其在生产、E2E测试等方面更加实用。</p><p id="d561" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们走吧:</p><figure class="mn mo mp mq gt ju"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="6f40" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您想要该状态下应用程序的完整代码。这里是提交:<a class="ae mt" href="https://github.com/paztek/nestjs-authentication-example/tree/7376afb2691fdd6972eceb70ceda86e1103b716d" rel="noopener ugc nofollow" target="_blank">https://github . com/Paz tek/nestjs-authentic ation-example/tree/7376 AFB 2691 FDD 6972 eceb 70 ceda 86 e 1103 b 716d</a></p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h1 id="8225" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">丰富</h1><p id="d8b7" class="pw-post-body-paragraph kf kg it kh b ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc im bi translated">我们可以改进的事情之一是提供一种方法，在您的E2E测试期间不运行Keycloak。在您的E2E测试中使用真实的Keycloak实例，虽然更现实，但是由于需要额外的HTTP调用、等待Keycloak启动并预加载具有不同角色集的用户列表，因此会使您的测试变慢。</p><p id="9b58" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">目前，在E2E测试中绕过Keycloak的一个合理方法是用一个<strong class="kh iu">FakeAuthenticationService</strong>替换AuthenticationService。但随着您的AuthenticationService封装越来越多的逻辑(在您的本地数据库中创建用户、计算会话或分析等)，这将变得越来越不可接受。).</p><p id="05c0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">另一种方法是<strong class="kh iu"> stub使用HttpService </strong>进行的HTTP调用，但是一旦您的HttpService也用于执行对其他服务的HTTP调用，这将变得越来越复杂。</p><p id="ec3a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">下面，我提出一个解决方案，<strong class="kh iu">保持你的测试足够真实，同时消除了运行Keycloak实例</strong>的需要。</p><figure class="mn mo mp mq gt ju"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="2097" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">通过将JWT的验证委托给另一个服务，我们可以保留AuthenticationService，并在测试期间使用不同的策略来验证JWT。不要忘记添加NODE_ENV=test环境变量。</p><p id="f0f3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您对实际源代码中与测试相关的代码过敏，并且您对AuthenticationModule感到惊讶，您可以执行以下操作:</p><figure class="mn mo mp mq gt ju"><div class="bz fp l di"><div class="mr ms l"/></div></figure></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h1 id="f1fa" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">遗留问题</h1><p id="a916" class="pw-post-body-paragraph kf kg it kh b ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc im bi translated">当JWT的发行者不同于用于获取用户信息的URL时，Keycloak会发出抱怨。当你的前端根据Keycloak的公共URL(例如https://your-domain.com/auth的<a class="ae mt" href="https://your-domain.com/auth" rel="noopener ugc nofollow" target="_blank"/>)协商它的令牌，但是你的后端使用你的Keycloak实例的内部地址(例如http://10.0.1.23/auth的<a class="ae mt" href="http://10.0.1.23/auth)." rel="noopener ugc nofollow" target="_blank">)时，就会发生这种情况。奇克洛的团队不认为这是一个错误:</a><a class="ae mt" href="https://issues.redhat.com/browse/KEYCLOAK-5045?_sscc=t" rel="noopener ugc nofollow" target="_blank">https://issues.redhat.com/browse/KEYCLOAK-5045?_sscc=t</a>所以我们必须解决它。</p><p id="a553" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您不能轻松地实现所描述的解决方法(更新后端的/etc/hosts，以便your-domain.com解析到10.0.1.23 ),如果您没有使用Keycloak的令牌撤销功能，并且您的访问令牌寿命很短(例如，5分钟),您可能会发现以下解决方案是可以接受的。</p><figure class="mn mo mp mq gt ju"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="688b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">我们正在手动验证JWT</strong>，而不是向Keycloak请求。但是为了做到这一点，我们必须拥有与用于签名令牌的私钥相对应的公钥。<br/>我们不能在NestJS应用程序上硬编码密钥，因为Keycloak会定期更改签名密钥。这意味着我们必须调用奇克洛来取回它们。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h1 id="92d3" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">结论</h1><p id="f2e8" class="pw-post-body-paragraph kf kg it kh b ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc im bi translated">建议对初始实现进行重构有几个好处:</p><ul class=""><li id="a1f4" class="mu mv it kh b ki kj km kn kq mw ku mx ky my lc mz na nb nc bi translated">这使得E2E测试更容易编写和运行</li><li id="0bc4" class="mu mv it kh b ki nd km ne kq nf ku ng ky nh lc mz na nb nc bi translated">当我们在生产中遇到Keycloak的限制时，它允许我们快速编写一个解决方法。</li></ul><p id="f6cd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">下一次，我们将在这个实现的基础上，通过验证经过身份验证的用户的角色来研究授权。</p><p id="01aa" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一如既往，这里是Github库的链接:<a class="ae mt" href="https://github.com/paztek/nestjs-authentication-example" rel="noopener ugc nofollow" target="_blank">https://github.com/paztek/nestjs-authentication-example</a></p></div></div>    
</body>
</html>