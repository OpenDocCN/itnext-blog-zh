<html>
<head>
<title>How to structure your React app 2.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建你的React应用2？</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-structure-your-react-app-2-2cf3b8040634?source=collection_archive---------0-----------------------#2018-09-26">https://itnext.io/how-to-structure-your-react-app-2-2cf3b8040634?source=collection_archive---------0-----------------------#2018-09-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="cfc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在之前的<a class="ae kl" href="https://hackernoon.com/how-to-structure-your-react-app-98c48e102aad" rel="noopener ugc nofollow" target="_blank">如何构建你的react应用</a>的故事中，我写了关于使用捆绑包作为你的应用的顶级入口点，这可能对一些人有效，对另一些人可能无效。今天我要告诉你另一种构建react应用的方法，我们在<a class="ae kl" href="http://unicorndev.io" rel="noopener ugc nofollow" target="_blank"> unicorndev </a>使用的是这个方法——域。我建议您在继续之前阅读本主题的<a class="ae kl" href="https://hackernoon.com/how-to-structure-your-react-app-98c48e102aad" rel="noopener ugc nofollow" target="_blank">第一版。</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/95d0f71ad2da66273d4ae8e409c87981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RgksJMWeuF0c6SD-W7CAPQ.jpeg"/></div></div></figure></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="a2ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">在我们开始之前</strong></p><p id="1b87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们开始讨论域之前，让我们先来看看它:</p><p id="5c93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们定义了一个名为<code class="fe lf lg lh li b">alert</code>的域，它有组件和redux文件夹，但也有只与这个域相关的常量文件。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/614256b36dee8eb67c87d700d2e614d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:326/format:webp/1*0m82evR2Tm2bsZVx_E4ybw.png"/></div></figure><p id="e09f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，它非常小。</p><p id="b73e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们定义了一个域和其中的两个文件夹:components &amp; redux。这取决于你在域文件夹里放什么。不管你用的是redux还是relay。这个想法是将与域相关的所有东西都保存在它自己的文件夹中。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="d6ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">想法</strong></p><p id="1938" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将域作为应用程序的顶级是有益的，原因如下:</p><ol class=""><li id="7d1b" class="lk ll iq jp b jq jr ju jv jy lm kc ln kg lo kk lp lq lr ls bi translated">域名很小。使用它时很容易记住它，因为您处理的所有内容都在同一个文件夹中。万一你不喜欢，也很容易重组。</li><li id="89cf" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">主应用程序的结构保持扁平。因为域是独立的，所以在初始阶段更容易规划应用程序。</li><li id="ff15" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">没有深层文件夹结构—平均3层。不需要写很长的导入，这就是为什么更容易记住需要导入什么以及从哪个域导入。</li><li id="2ca7" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">每个域都有相似的结构，通常有一些实体子集，如<code class="fe lf lg lh li b">components</code> <code class="fe lf lg lh li b">redux actions</code> <code class="fe lf lg lh li b">reducers</code> <code class="fe lf lg lh li b">sagas</code>。只要你保持所有领域看起来相似，就很容易记住并习惯它。</li><li id="7904" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">领域很容易指定，因为总是很清楚你要写什么组件，指定领域也很容易。如果你需要创建一个普通的文本输入或按钮，那么你可能要创建一个名为<code class="fe lf lg lh li b">input</code>的域。</li><li id="3093" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">这种方法消除了像<code class="fe lf lg lh li b">shared</code>或<code class="fe lf lg lh li b">common</code>这样的东西，通常所有没有共同点的东西都在这里。你通常会把一个你不能确定的东西放在其中一个文件夹里。</li></ol></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="5c22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">人类</strong></p><p id="41f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们是人类，我们的大脑以特定的方式工作。这意味着对我们的大脑来说，有些事情比其他事情更容易记忆和处理。我们倾向于更快地记住小而简单的事情。这就是这种方法与人脑兼容的原因:</p><ol class=""><li id="af99" class="lk ll iq jp b jq jr ju jv jy lm kc ln kg lo kk lp lq lr ls bi translated">清楚明白什么是什么。域名代表了它的主要功能。</li><li id="c950" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">通过功能的名称/描述很容易找到域。</li><li id="c596" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">保持它们很小很容易，因为域是专门为某个目的而创建的，它们通常只保存与它们的域逻辑相关的东西。</li></ol></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="18f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如何指定</strong></p><p id="2c40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在你开始考虑什么是你正在工作或将要工作的领域之前，你可能要考虑你的应用程序中是否已经有了这个领域。如果您没有域，因此需要创建一个:</p><ol class=""><li id="f22c" class="lk ll iq jp b jq jr ju jv jy lm kc ln kg lo kk lp lq lr ls bi translated">选择名称。名称应该反映一个域名的主要功能。只要想想你创建它的主要目的或原因是什么。通常名称应该是单数，并且以小写字母开头。比如:<code class="fe lf lg lh li b">user</code> <code class="fe lf lg lh li b">auth</code>，<code class="fe lf lg lh li b">navigation</code>。</li><li id="0940" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">尽量保持所有的域结构相似。为了能够快速地写/找东西，你必须为所有的领域保持一个相似的结构。例如:</li></ol><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/aa51a7f592885105800881473a64c9d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:268/format:webp/1*M7sSVBrTlQ8C3cZrttiWjA.png"/></div></figure></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="f869" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">差异</strong></p><p id="ef3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">包是比域更高层次的抽象，用于保存组件。定义一个捆绑包总是很难，因为你需要考虑那里会有什么类型的组件，而且因为它是一个高层次的抽象，所以总是很难确定，几个捆绑包可能有逻辑交集，导致提取一个新的捆绑包或将其作为技术债务。一个域名很容易。简单而准确。</p><p id="9a5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">什么比较好</strong></p><p id="8300" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何构建react应用程序完全取决于您。想一想和你一起工作或者可能和你一起工作的其他人。</p><p id="69e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">喜欢&amp;分享。一块。</p><p id="1e05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">附注:感谢所有来自<a class="ae kl" href="http://unicorndev.io" rel="noopener ugc nofollow" target="_blank"> unicorndev </a>团队的人审阅&amp;这篇文章。</p></div></div>    
</body>
</html>