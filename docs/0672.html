<html>
<head>
<title>How to Cancel HTTP Requests in AngularJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在AngularJS中取消HTTP请求</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-cancel-http-requests-in-angularjs-4ccf351319e0?source=collection_archive---------1-----------------------#2018-05-03">https://itnext.io/how-to-cancel-http-requests-in-angularjs-4ccf351319e0?source=collection_archive---------1-----------------------#2018-05-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9286" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近，我们需要开发一个新功能，允许用户取消正在进行的HTTP请求。这是一个相当合理的要求，在技术上实现起来并不困难，但是，我们由AngularJS和ngRedux组成的架构使它更具挑战性。</p><p id="f7b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将提出一种取消HTTP请求的方法。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/b5e34d0888b0be3affeb7b9a9648a224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NUZCLQfkiyyZtduHTC_6fA.jpeg"/></div></div></figure><h1 id="9c56" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">承诺链中的问题</h1><p id="f627" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">AngularJS提供了一种取消HTTP请求的简单方法。<code class="fe ma mb mc md b">$http</code>接受可以是承诺的<code class="fe ma mb mc md b">timeout</code>选项。当<code class="fe ma mb mc md b">timeout</code>承诺被解决时，HTTP请求将被取消。这里有一个例子:</p><pre class="km kn ko kp gt me md mf mg aw mh bi"><span id="6e12" class="mi ky iq md b gy mj mk l ml mm">function fetchBooks() {<br/>    const canceller = $q.defer();<br/>    return $http.get('/api/books/', { timeout: canceller.promise });<br/>}</span></pre><p id="4af7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码片段中，我们可以通过调用<code class="fe ma mb mc md b">canceller.promise.resolve()</code>轻松取消HTTP请求。然而问题很明显:<code class="fe ma mb mc md b">fetchBooks()</code>中没有返回<code class="fe ma mb mc md b">canceller</code>。换句话说，<code class="fe ma mb mc md b">fetchBooks()</code>的调用者没有取消请求的控制权。</p><p id="1616" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，我们可以将<code class="fe ma mb mc md b">canceller</code>赋值给结果承诺，就像这样:</p><pre class="km kn ko kp gt me md mf mg aw mh bi"><span id="e7cf" class="mi ky iq md b gy mj mk l ml mm">function fetchBooks() {<br/>    const canceller = $q.defer();<br/>    let promise = $http.get('/api/books/', {<br/>        timeout: canceller.promise<br/>    });<br/>    promise.cancel = () =&gt; {<br/>        canceller.resolve();<br/>    }<br/>    return promise;<br/>}</span><span id="8047" class="mi ky iq md b gy mn mk l ml mm">// Caller<br/>const books = fetchBooks();</span><span id="ea69" class="mi ky iq md b gy mn mk l ml mm">// Later..<br/>books.cancel();</span></pre><p id="0a23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这看起来不错，但是只有一个问题。如果<code class="fe ma mb mc md b">fetchBooks()</code>返回的承诺在承诺链中被进一步使用，这种方法将会失败。例如，以下代码在redux操作中非常常用:</p><pre class="km kn ko kp gt me md mf mg aw mh bi"><span id="ebc5" class="mi ky iq md b gy mj mk l ml mm">const action = () =&gt; dispatch =&gt; {<br/>    return fetchBooks()<br/>        .then(response =&gt; response.results)<br/>        .then(books =&gt; {<br/>            dispatch(updateBooks(books));<br/>            return books;<br/>        });</span><span id="79c3" class="mi ky iq md b gy mn mk l ml mm">// Caller<br/>const books = action();<br/>books.cancel();    // ERROR: books.cancel === undefined</span></pre><p id="b510" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ma mb mc md b">.then()</code>会生成新的承诺，因此<code class="fe ma mb mc md b">action()</code>返回的<code class="fe ma mb mc md b">books</code>不再是<code class="fe ma mb mc md b">$http.get()</code>返回的原承诺。</p><p id="b286" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看到问题了吗？简而言之，我们无法访问<code class="fe ma mb mc md b">cancel()</code>方法，因为:</p><ul class=""><li id="7b62" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated"><code class="fe ma mb mc md b">cancel()</code>能够被暴露的唯一方式是附在结果承诺上；</li><li id="4be1" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">结果承诺在通过承诺链时丢失。</li></ul><h1 id="637d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">在后台</h1><p id="0b86" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">如果我们仔细看看AngularJS中的<code class="fe ma mb mc md b">.then()</code>方法的实现，我们会发现类似这样的内容:</p><pre class="km kn ko kp gt me md mf mg aw mh bi"><span id="d174" class="mi ky iq md b gy mj mk l ml mm">extend(Promise.prototype, {                                                                        <br/>    then: function(onFulfilled, onRejected, progressBack) {                                          <br/>      if (isUndefined(onFulfilled) &amp;&amp; isUndefined(onRejected) &amp;&amp; isUndefined(progressBack)) {        <br/>        return this;                                                                                 <br/>      }                                                                                              <br/>      var result = new Deferred();                                                                   <br/>                                                                                                     <br/>      this.$$state.pending = this.$$state.pending || [];                                             <br/>      this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);                    <br/>      if (this.$$state.status &gt; 0) scheduleProcessQueue(this.$$state);                               <br/>                                                                                                     <br/>      return result.promise;                                                                         <br/>    },<br/>...</span></pre><p id="a6b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到旧的承诺对新的承诺有一个引用(<code class="fe ma mb mc md b">this.$$state.pending[0][0]</code>)。为了说明这一点，请考虑以下设置:</p><pre class="km kn ko kp gt me md mf mg aw mh bi"><span id="4ed0" class="mi ky iq md b gy mj mk l ml mm">let promiseA = $http.get('/');<br/>promiseB = promiseA.then(response =&gt; response);<br/>promiseC = promiseB.then(repsonse =&gt; response);</span></pre><p id="8b72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后:</p><pre class="km kn ko kp gt me md mf mg aw mh bi"><span id="f7ef" class="mi ky iq md b gy mj mk l ml mm">promiseA.$$state.pending[0][0].promise === promiseB<br/>promiseB.$$state.pending[0][0].promise === promiseC</span></pre><p id="23ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的关键是引用是从最早的到最新的。我们不能从最近的承诺<code class="fe ma mb mc md b">promiseC</code>返回到根承诺<code class="fe ma mb mc md b">promiseA</code>。然而，我们可以为正在进行的HTTP请求创建一个列表，并提供一个方法<code class="fe ma mb mc md b">cancelPromise(promise)</code>，该方法接受承诺链中的任何承诺。当<code class="fe ma mb mc md b">cancelPromise(promise)</code>被调用时，我们将遍历HTTP请求列表并找到相应的承诺链，然后调用根承诺的<code class="fe ma mb mc md b">.cancel()</code>方法。</p><h1 id="f401" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">履行</h1><p id="a34f" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们定义了一个服务来保存HTTP请求:</p><pre class="km kn ko kp gt me md mf mg aw mh bi"><span id="67dc" class="mi ky iq md b gy mj mk l ml mm">class PromiseService {</span><span id="11e8" class="mi ky iq md b gy mn mk l ml mm">    constructor() {<br/>        this._requests = [];<br/>    }</span><span id="ccbc" class="mi ky iq md b gy mn mk l ml mm">    register(promise) {<br/>        this._requests.push(promise);<br/>    }</span><span id="26ea" class="mi ky iq md b gy mn mk l ml mm">    unregister(promise) {<br/>        const idx = this._requests.indexOf(promise);<br/>        if (idx &gt;= 0) {<br/>            this._requests.splice(idx, 1);<br/>        }<br/>    }</span><span id="56ec" class="mi ky iq md b gy mn mk l ml mm">    cancelPromise(promise) {<br/>        for (let i = 0; i &lt; this._requests.length; i++) {<br/>            const rootPromise = this._requests[i];<br/>            let p = rootPromise;</span><span id="9b8d" class="mi ky iq md b gy mn mk l ml mm">            // Traverse the promise chain to see <br/>            // if given promise exists in the chain<br/>            while (p !== promise &amp;&amp; p.$$state.pending &amp;&amp;<br/>                p.$$state.pending.length &gt; 0) {<br/>                p = p.$$state.pending[0][0].promise;<br/>            }</span><span id="0c5d" class="mi ky iq md b gy mn mk l ml mm">            // If this chain contains given promise, then call the<br/>            // cancel method to cancel the http request<br/>            if (p === promise &amp;&amp; typeof r.cancel === 'function') {<br/>                r.cancel();<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="e253" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并且在API调用中:</p><pre class="km kn ko kp gt me md mf mg aw mh bi"><span id="436d" class="mi ky iq md b gy mj mk l ml mm">function fetchBooks() {<br/>    const canceller = $q.defer();<br/>    let promise = $http.get('/api/books/', {<br/>        timeout: canceller.promise,<br/>    });</span><span id="325c" class="mi ky iq md b gy mn mk l ml mm">    promise.cancel = () =&gt; {<br/>        canceller.resolve();<br/>    }</span><span id="3971" class="mi ky iq md b gy mn mk l ml mm">    promiseService.register(promise);</span><span id="8b13" class="mi ky iq md b gy mn mk l ml mm">    // If HTTP requests complete before cancel,<br/>    // then remove the entry from PromiseService<br/>    return promise.then((response) =&gt; {<br/>       promiseService.unregister(promise);<br/>       return response;<br/>    });<br/>}</span></pre><p id="6f2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成后，我们可以简单地调用<code class="fe ma mb mc md b">promiseService.cancel()</code>:</p><pre class="km kn ko kp gt me md mf mg aw mh bi"><span id="15f4" class="mi ky iq md b gy mj mk l ml mm">// Caller<br/>let books = action();</span><span id="89cb" class="mi ky iq md b gy mn mk l ml mm">// Cancel the HTTP request<br/>promiseService.cancel(books);</span></pre></div></div>    
</body>
</html>