<html>
<head>
<title>C++20 Coroutines — Complete* Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++20协同程序—完整*指南</h1>
<blockquote>原文：<a href="https://itnext.io/c-20-coroutines-complete-guide-7c3fc08db89d?source=collection_archive---------0-----------------------#2021-09-26">https://itnext.io/c-20-coroutines-complete-guide-7c3fc08db89d?source=collection_archive---------0-----------------------#2021-09-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="28f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">C++20给我们带来了对协程的最初支持。在本文中，我们将查看几个相互构建的协程示例。不过，警告一下，C++20中的支持主要是针对库实现者的。C++23应该带来额外的支持，至少应该覆盖最常见的用例。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/31080f05932f7c17c59166300bfa2246.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ixZS1N0-nMdRT7q_GxISdQ.png"/></div></div></figure><p id="bc98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，什么是协程呢？协程是任何包含<code class="fe kx ky kz la b">co_return</code>、<code class="fe kx ky kz la b">co_yield</code>或<code class="fe kx ky kz la b">co_await</code>的函数。</p><p id="fc7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从根本上说，C++20协同程序是位于函数对象之上的语法糖。编译器将围绕你的协程生成一个代码框架。该代码依赖于用户定义的退货和承诺类型。在我们用C++23得到一些标准类型之前，你需要自己写这些。</p><h1 id="02b8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">无所事事的协程程序</h1><p id="17c7" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">让我们看看您目前可以编写的最简单的协程:</p><pre class="km kn ko kp gt me la mf mg aw mh bi"><span id="e16b" class="mi lc iq la b gy mj mk l ml mm">#include &lt;coroutine&gt;</span><span id="936d" class="mi lc iq la b gy mn mk l ml mm">// The caller-level type<br/>struct Task {<br/>    // The coroutine level type<br/>    struct promise_type {<br/>        Task get_return_object() { return {}; }<br/>        std::suspend_never initial_suspend() { return {}; }<br/>        std::suspend_never final_suspend() noexcept { return {}; }<br/>        void return_void() {}<br/>        void unhandled_exception() {}<br/>    };<br/>};</span><span id="0295" class="mi lc iq la b gy mn mk l ml mm">Task myCoroutine() {<br/>    co_return; // make it a coroutine<br/>}</span><span id="8050" class="mi lc iq la b gy mn mk l ml mm">int main() {<br/>    Task x = myCoroutine();<br/>}</span></pre><p id="5b57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，这看起来像是一堆样板文件，只调用一个协程，它立即返回，什么也不做。但是这是一个很好的地方，可以开始研究编译器生成的框架代码。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mo"><img src="../Images/76c24858291b986fda0315705c05fcd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A9IGYylDx4OYV3u_VWb5GQ.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">展示编译器围绕协程生成的代码框架的图表。</figcaption></figure><p id="1ca1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们稍后将讨论<code class="fe kx ky kz la b">co_await</code>，但是我在这个图中特意将它们标记为虚线，因为在<code class="fe kx ky kz la b">std::suspend_never</code>的实例上调用<code class="fe kx ky kz la b">co_await</code>将立即返回。如果您运行将在链接库(在本文末尾)中找到的示例的测试版本，就可以看到这种情况。</p><p id="3bdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们继续之前，让我们更深入地研究一下这个例子。如果我们将<code class="fe kx ky kz la b">initial_suspend()</code>返回类型改为<code class="fe kx ky kz la b">std::suspend_always</code>会发生什么？</p><pre class="km kn ko kp gt me la mf mg aw mh bi"><span id="a5ee" class="mi lc iq la b gy mj mk l ml mm">//...<br/>std::suspend_always initial_suspend() { return {}; }<br/>//...</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mo"><img src="../Images/874e5c48446b0fc9ad35cbc3f2456aa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SzRv6X92S9bmVWuTMi4NzQ.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">演示使用suspend_always时会发生什么的图表。</figcaption></figure><p id="5f57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种变化给我们带来了一个问题。协程现在搁浅(泄露)。</p><p id="3d8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe kx ky kz la b">std::suspend_always{}</code>的实例上调用<code class="fe kx ky kz la b">co_await</code>会导致协程挂起。这又将控制返回给调用者。然而，调用者(函数main)没有办法恢复协程。所以让我们解决这个问题。</p><pre class="km kn ko kp gt me la mf mg aw mh bi"><span id="4189" class="mi lc iq la b gy mj mk l ml mm">#include &lt;coroutine&gt;</span><span id="ef1f" class="mi lc iq la b gy mn mk l ml mm">// The caller-level type<br/>struct Task {<br/>    // The coroutine level type<br/>    struct promise_type {<br/><strong class="la ir">        using Handle = std::coroutine_handle&lt;promise_type&gt;;</strong></span><span id="b2a1" class="mi lc iq la b gy mn mk l ml mm"><strong class="la ir">        Task get_return_object() {<br/>            return Task{Handle::from_promise(*this)};<br/>        }</strong><br/>        std::suspend_always initial_suspend() { return {}; }<br/>        std::suspend_never final_suspend() noexcept { return {}; }<br/>        void return_void() { }<br/>        void unhandled_exception() { }<br/>    };</span><span id="b778" class="mi lc iq la b gy mn mk l ml mm"><strong class="la ir">    explicit Task(promise_type::Handle coro) : coro_(coro) {}</strong></span><span id="1fe7" class="mi lc iq la b gy mn mk l ml mm"><strong class="la ir">    void destroy() { coro_.destroy(); }<br/>    void resume() { coro_.resume(); }</strong></span><span id="9c00" class="mi lc iq la b gy mn mk l ml mm"><strong class="la ir">private:<br/>    promise_type::Handle coro_;</strong><br/>};</span><span id="d1e1" class="mi lc iq la b gy mn mk l ml mm">Task myCoroutine() {<br/>    co_return; // make it a coroutine<br/>}</span><span id="76dc" class="mi lc iq la b gy mn mk l ml mm">int main() {<br/>    auto c = myCoroutine();<br/>    c.resume();<br/>    // c.destroy();<br/>}</span></pre><p id="df48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要让呼叫者可以使用<code class="fe kx ky kz la b">coroutine_handle</code>。为此，我们通过从promise实例创建它的<code class="fe kx ky kz la b">get_return_object()</code>调用来传递它。然后调用者可以在挂起的协程上调用<code class="fe kx ky kz la b">resume()</code>或<code class="fe kx ky kz la b">destroy()</code>。注意，在没有挂起的协程上调用这些方法是未定义的行为。让调用方级别的类型移动也是有意义的——只是为了避免对句柄所有权的混淆。</p><pre class="km kn ko kp gt me la mf mg aw mh bi"><span id="2f9c" class="mi lc iq la b gy mj mk l ml mm">// Making Task move-only:<br/>Task(const Task&amp;) = delete;<br/>Task&amp; operator=(const Task&amp;) = delete;</span><span id="30ae" class="mi lc iq la b gy mn mk l ml mm">Task(Task&amp;&amp; t) noexcept : coro_(t.coro_) { t.coro_ = {} }<br/>Task&amp; operator=(Task&amp;&amp; t) noexcept {<br/>    if (this == &amp;t) return *this;<br/>    if (coro_) coro_.destroy();<br/>    coro_ = t.coro_;<br/>    t.coro_ = {};<br/>    return *this;<br/>}</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mo"><img src="../Images/080af3126e1e7eaaca39fb363f65c9c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LgUCJB6WXSxude4FzNyT1w.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">演示带有resume()调用的普通协程的图表。</figcaption></figure><p id="4202" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">挂起的协程作为纯数据存在。因此，我们可以这样处理它，例如，在线程之间传递它。我们将在以后使用<code class="fe kx ky kz la b">co_await</code>时依赖这个属性。</p><p id="6722" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，我们的演示协程没有做任何事情。让我们继续看第一个有用的例子，它是一个发电机。</p><h1 id="fb20" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">一个生成器协程</h1><p id="5cd8" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">生成器依赖于关键字<code class="fe kx ky kz la b">co_yield</code>。<code class="fe kx ky kz la b">co_yield expr;</code>这个表达是<code class="fe kx ky kz la b">co_await promise.yield_value(expr);</code>的简写。promise类型控制产生一个值意味着什么，以及协程是否/如何挂起。这里我们使用了<code class="fe kx ky kz la b">std::suspend_always</code>，因为我们想要停止协程，直到下一个<code class="fe kx ky kz la b">get_next()</code>调用。</p><pre class="km kn ko kp gt me la mf mg aw mh bi"><span id="375f" class="mi lc iq la b gy mj mk l ml mm">#include &lt;coroutine&gt;<br/>#include &lt;iostream&gt;</span><span id="bb50" class="mi lc iq la b gy mn mk l ml mm">// The caller-level type<br/>struct Generator {<br/>    // The coroutine level type<br/>    struct promise_type {<br/>        using Handle = std::coroutine_handle&lt;promise_type&gt;;</span><span id="74b2" class="mi lc iq la b gy mn mk l ml mm">        Generator get_return_object() {<br/>            return Generator{Handle::from_promise(*this)};<br/>        }<br/>        std::suspend_always initial_suspend() { return {}; }<br/>        std::suspend_always final_suspend() noexcept { return {}; }<br/><strong class="la ir">        std::suspend_always yield_value(int value) {<br/>            current_value = value;<br/>            return {};<br/>        }</strong><br/>        void unhandled_exception() { }<br/><strong class="la ir">        int current_value;</strong><br/>    };</span><span id="432f" class="mi lc iq la b gy mn mk l ml mm">    explicit Generator(promise_type::Handle coro) : coro_(coro) {}<br/><strong class="la ir">    ~Generator() {<br/>        if (coro_) coro_.destroy();<br/>    }</strong><br/>    // Make move-only<br/>    Generator(const Generator&amp;) = delete;<br/>    Generator&amp; operator=(const Generator&amp;) = delete;<br/>    Generator(Generator&amp;&amp; t) noexcept : coro_(t.coro_) { <br/>        t.coro_ = {};<br/>    }<br/>    Generator&amp; operator=(Generator&amp;&amp; t) noexcept {<br/>        if (this == &amp;t) return *this;<br/>        if (coro_) coro_.destroy();<br/>        coro_ = t.coro_;<br/>        t.coro_ = {};<br/>        return *this;<br/>    }</span><span id="a619" class="mi lc iq la b gy mn mk l ml mm"><strong class="la ir">    int get_next() {<br/>        coro_.resume();<br/>        return coro_.promise().current_value;<br/>    }</strong></span><span id="8484" class="mi lc iq la b gy mn mk l ml mm">private:<br/>    promise_type::Handle coro_;<br/>};</span><span id="93b3" class="mi lc iq la b gy mn mk l ml mm"><strong class="la ir">Generator myCoroutine() {<br/>    int x = 0;<br/>    while (true) {<br/>        co_yield x++;<br/>    }<br/>}</strong></span><span id="fbc8" class="mi lc iq la b gy mn mk l ml mm">int main() {<br/>    auto c = myCoroutine();<br/>    int x = 0;<br/>    while ((x = c.get_next()) &lt; 10) {<br/>        std::cout &lt;&lt; x &lt;&lt; "\n";<br/>    }<br/>}</span></pre><p id="66ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为这个协程包含一个死循环，所以永远不会被自然清理。然而，由于协程只在<code class="fe kx ky kz la b">get_next()</code>调用中运行，我们可以安全地调用<code class="fe kx ky kz la b">destroy()</code>在生成器析构函数中清理它。</p><p id="2626" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，由于<code class="fe kx ky kz la b">get_next()</code>函数，这个协程的可用性有点尴尬。但是我们可以很容易地添加更多的样板文件，并将其转换成一个范围，就像cppreference上的这个例子:<a class="ae mt" href="https://en.cppreference.com/w/cpp/coroutine/coroutine_handle#Example" rel="noopener ugc nofollow" target="_blank">https://en . CP preference . com/w/CPP/coroutine/coroutine _ handle # Example</a></p><h1 id="4920" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">值得称赞的</h1><p id="51a0" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我们已经使用了两个awaitables，<code class="fe kx ky kz la b">std::suspend_never</code>和<code class="fe kx ky kz la b">std::suspend_always</code>。让我们看看awaitables是如何工作的，以及如何编写自己的程序来与异步库接口。</p><p id="20c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与promise类型类似，编译器将围绕awaitable类型生成代码。如果承诺类型提供了一个<code class="fe kx ky kz la b">await_transform(expr);</code>方法，那么<code class="fe kx ky kz la b">co_await expr;</code>调用将被转换为<code class="fe kx ky kz la b">co_await promise.await_transform(expr);</code>。因此，promise类型可以控制允许哪些away able类型出现在协程主体中，并可能根据表达式返回不同的away able(注意这里的<code class="fe kx ky kz la b">expr</code>不一定是away able)。</p><pre class="km kn ko kp gt me la mf mg aw mh bi"><span id="9680" class="mi lc iq la b gy mj mk l ml mm">struct promise_type {<br/>    // only allow std::suspend_always inside of the coroutine<br/>    std::suspend_always await_transform(std::suspend_always s) {<br/>        return std::suspend_always{};<br/>    }<br/>};</span></pre><p id="08d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可调整类型需要提供三种方法:</p><pre class="km kn ko kp gt me la mf mg aw mh bi"><span id="fff2" class="mi lc iq la b gy mj mk l ml mm">struct awaitable {<br/>    bool await_ready();</span><span id="d7a4" class="mi lc iq la b gy mn mk l ml mm">    // one of:<br/>    void await_suspend(std::coroutine_handle&lt;&gt;) {}<br/>    bool await_suspend(std::coroutine_handle&lt;&gt;) {}<br/>    std::coroutine_handle&lt;&gt;<br/>        await_suspend(std::coroutine_handle&lt;&gt;) {}</span><span id="3cbc" class="mi lc iq la b gy mn mk l ml mm">    void await_resume() {}<br/>};</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mu"><img src="../Images/7aa9ec66f7184807266d2e95efe4624f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pp_9cevQLoY0n1mWgHLF1g.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">描述由于co_await调用而生成的代码框架的图表。</figcaption></figure><p id="9af1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看一个简单(尽管毫无意义)的例子。</p><pre class="km kn ko kp gt me la mf mg aw mh bi"><span id="a0c3" class="mi lc iq la b gy mj mk l ml mm">struct Sleeper {<br/>    constexpr bool await_ready() const noexcept { return false; }</span><span id="7781" class="mi lc iq la b gy mn mk l ml mm">    void await_suspend(std::coroutine_handle&lt;&gt; h) const {<br/>        auto t = std::jthread([h,l = length] {<br/>            std::this_thread::sleep_for(l);<br/>            h.resume();<br/>        });<br/>    }</span><span id="729a" class="mi lc iq la b gy mn mk l ml mm">    constexpr void await_resume() const noexcept {}<br/>    const std::chrono::duration&lt;int, std::milli&gt; length;<br/>};</span></pre><p id="a9cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">协程在进入<code class="fe kx ky kz la b">await_suspend</code>方法之前挂起。因为我们在这个方法中创建了一个新线程(在暂停点之后)，所以没有数据竞争。还要注意，虽然我们遵循上图中的“控制返回给调用者”分支，但是我们在新产生的线程中(而不是在调用者中)恢复协程。</p><p id="0a07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们可以在协程中使用它:</p><pre class="km kn ko kp gt me la mf mg aw mh bi"><span id="2fb6" class="mi lc iq la b gy mj mk l ml mm">Task myCoroutine() {<br/>    using namespace std::chrono_literals;<br/>    auto before = std::chrono::steady_clock::now();<br/>    co_await Sleeper{200ms};<br/>    auto after = std::chrono::steady_clock::now();<br/>    std::cout &lt;&lt; "Slept for " &lt;&lt; (after-before) / 1ms &lt;&lt; " ms\n";<br/>}</span></pre><h1 id="5140" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">何时(不)使用协程</h1><p id="b65e" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">最后，我想谈一谈什么时候可能需要使用协程，以及它们的优缺点。首先，生成器是有用的，即使你有好的用例，你现在也应该使用它们。</p><h2 id="4eb0" class="mi lc iq bd ld mv mw dn lh mx my dp ll jy mz na lp kc nb nc lt kg nd ne lx nf bi translated">单线程环境</h2><p id="af6b" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">如果您受限于单个线程，那么协程是一种异步处理的解决方案，否则您将无法使用它。使用当前的协程支持应该可以实现Javascript风格的事件循环。</p><h2 id="71ad" class="mi lc iq bd ld mv mw dn lh mx my dp ll jy mz na lp kc nb nc lt kg nd ne lx nf bi translated">极度线程化的环境</h2><p id="5ac3" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">另一个用例位于光谱的另一端。如果您的产品需要大量的轻量级线程，协程可能会节省内存和文件描述符。</p><h2 id="3837" class="mi lc iq bd ld mv mw dn lh mx my dp ll jy mz na lp kc nb nc lt kg nd ne lx nf bi translated">使用具有适当支持的异步库</h2><p id="97ff" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">这个有点明显。如果您编写用户代码，并且您的库为您提供了预构建的awaitables和协程支持类型，那么编写协程可能是更干净的方法。你将避免互斥体使你的代码混乱，因为所有与协程的同步都发生在<code class="fe kx ky kz la b">co_await</code>调用之后。</p><h2 id="a75e" class="mi lc iq bd ld mv mw dn lh mx my dp ll jy mz na lp kc nb nc lt kg nd ne lx nf bi translated">容量受控的环境</h2><p id="c6b7" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">那么剩下的呢？我发现协程问题的一个例子是容量控制的环境。使用同步处理，您可以通过控制线程的数量来控制服务的容量。当达到重载时，您可以在请求到达时拒绝它们。不幸的是，使用协程防止过载变得更加复杂，在处理请求的过程中很快就会出现过载的情况。</p><h2 id="f1fd" class="mi lc iq bd ld mv mw dn lh mx my dp ll jy mz na lp kc nb nc lt kg nd ne lx nf bi translated">超时设定</h2><p id="032e" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">另一个我还没有弄清楚如何使用协程的棘手特性是处理超时。例如，下面的代码片段出现在我过去工作过的大多数系统中:</p><pre class="km kn ko kp gt me la mf mg aw mh bi"><span id="66e0" class="mi lc iq la b gy mj mk l ml mm">Throttler tr;<br/>// mu is absl::Mutex (std::mutex+std:condition_variable combination)<br/>auto has_slot = [&amp;tr]() { return !tr.Full(); }<br/>if (mu.LockWhenWithTimeout(Condition(&amp;has_slot), 200 /*ms*/)) {<br/>  // sucesfull slot grab<br/>  do_work();<br/>} else { <br/>  // timeout branch<br/>  bail_out();<br/>}<br/>mu.Unlock();</span></pre><p id="0a45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我很难找到一个等价的协程，特别是安全地实现超时分支。</p><h1 id="25ce" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">链接和技术说明</h1><p id="94ca" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">所有示例都使用GCC的主干版本(2021年9月)进行了演示。</p><p id="bd32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有代码示例和脚本都可以在https://github.com/HappyCerberus/article-cpp20-coroutines<a class="ae mt" href="https://github.com/HappyCerberus/article-cpp20-coroutines" rel="noopener ugc nofollow" target="_blank">获得</a></p><h1 id="c3eb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">感谢您的阅读</h1><p id="14a7" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">感谢您阅读这篇文章。你喜欢吗？</p><p id="3345" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也在YouTube上发布视频。你有问题吗？在<a class="ae mt" href="https://twitter.com/SimonToth83" rel="noopener ugc nofollow" target="_blank">推特</a>或<a class="ae mt" href="https://www.linkedin.com/in/simontoth" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我。</p></div></div>    
</body>
</html>