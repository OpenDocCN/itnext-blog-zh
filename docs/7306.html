<html>
<head>
<title>Rust Ownership: 50 Code Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust所有权:50个代码示例</h1>
<blockquote>原文：<a href="https://itnext.io/rust-ownership-50-code-examples-96203fcf79ea?source=collection_archive---------1-----------------------#2022-08-17">https://itnext.io/rust-ownership-50-code-examples-96203fcf79ea?source=collection_archive---------1-----------------------#2022-08-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/13edb20e7be030bd18951dea2877892b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*QHtxTqvvJOwclrH0KtJkxA.png"/></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk translated">图片来自<a class="ae jc" href="https://www.rust-lang.org/logos/error.png" rel="noopener ugc nofollow" target="_blank">https://www.rust-lang.org/logos/error.png</a></figcaption></figure><div class=""/><div class=""><h2 id="ed56" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">在铁锈操场上试试吧</h2></div><p id="24b0" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">变更日志:<br/>2023年1月2日—使用Medium的新代码块进行语法突出显示</em></p><p id="0c13" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lr translated">遇到所有权问题，比如借用一个已经被转移的价值？如果你是，那么我有50个代码片段(好吧，有53个)让我们在Rust Playground一起练习。</p><p id="7cd4" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文假设您大致了解基本类型，如<code class="fe ma mb mc md b">String</code>，整数类型，如<code class="fe ma mb mc md b">i32</code>、<code class="fe ma mb mc md b">Vec</code>，迭代器、片和结构。我假设你已经读过Rust编程语言。第四章:理解所有权)和<a class="ae jc" href="https://doc.rust-lang.org/rust-by-example/" rel="noopener ugc nofollow" target="_blank">锈例</a>书籍。</p><p id="cfd3" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些例子从简单的类型(从<code class="fe ma mb mc md b">String</code>开始)开始，到稍微复杂一点的类型。✅的意思是代码可以编译，❌的意思是不能。虽然一些例子为无法编译的代码提供了替代方案，但是请注意，这些选项并不详尽，只是针对初学者的。这些例子不包括可变性(因为我觉得它们更容易掌握)，也不涉及所有权异步编程。</p><h1 id="4474" class="me mf jf bd mg mh mi mj mk ml mm mn mo kl mp km mq ko mr kp ms kr mt ks mu mv bi translated">内容</h1><ol class=""><li id="e511" class="mw mx jf kw b kx my la mz ld na lh nb ll nc lp nd ne nf ng bi translated"><code class="fe ma mb mc md b"><a class="ae jc" href="#f4fc" rel="noopener ugc nofollow">String</a></code></li><li id="6af2" class="mw mx jf kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><code class="fe ma mb mc md b"><a class="ae jc" href="#ed8d" rel="noopener ugc nofollow">i32</a></code></li><li id="8aee" class="mw mx jf kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae jc" href="#e17b" rel="noopener ugc nofollow"> Struct带</a> <code class="fe ma mb mc md b"><a class="ae jc" href="#e17b" rel="noopener ugc nofollow">String</a></code> <a class="ae jc" href="#e17b" rel="noopener ugc nofollow">字段</a></li><li id="5941" class="mw mx jf kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae jc" href="#6b61" rel="noopener ugc nofollow">结构带</a> <code class="fe ma mb mc md b"><a class="ae jc" href="#6b61" rel="noopener ugc nofollow">u8</a></code> <a class="ae jc" href="#6b61" rel="noopener ugc nofollow">字段</a></li><li id="1677" class="mw mx jf kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae jc" href="#39d6" rel="noopener ugc nofollow">具有两个</a> <code class="fe ma mb mc md b"><a class="ae jc" href="#39d6" rel="noopener ugc nofollow">String</a></code> <a class="ae jc" href="#39d6" rel="noopener ugc nofollow">字段的结构</a></li><li id="dc70" class="mw mx jf kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><code class="fe ma mb mc md b"><a class="ae jc" href="#e657" rel="noopener ugc nofollow">Vec&lt;String&gt;</a></code></li><li id="c680" class="mw mx jf kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><code class="fe ma mb mc md b"><a class="ae jc" href="#3c86" rel="noopener ugc nofollow">Iterator</a></code></li><li id="3ada" class="mw mx jf kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><code class="fe ma mb mc md b"><a class="ae jc" href="#e5f2" rel="noopener ugc nofollow">&amp;str</a></code></li></ol></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="f4fc" class="me mf jf bd mg mh nt mj mk ml nu mn mo kl nv km mq ko nw kp ms kr nx ks mu mv bi translated">1.线</h1><p id="a5ce" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">一个<code class="fe ma mb mc md b"><a class="ae jc" href="https://doc.rust-lang.org/std/string/struct.String.html" rel="noopener ugc nofollow" target="_blank">String</a></code>是一个没有实现<code class="fe ma mb mc md b">Copy</code>特征的类型。</p><h2 id="06f8" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated">✅ <strong class="ak">清单1–1</strong></h2><p id="6536" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">让我们创建一个<code class="fe ma mb mc md b">String</code>，然后用它调用<code class="fe ma mb mc md b">do_something</code>。</p><p id="e5d8" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一切看起来正常…</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="480d" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let name = String::from("Rust");<br/>    do_something(name);<br/>}<br/><br/>fn do_something(name: String) {<br/>    println!("Hello, {}!", name);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="3ae4" class="ov mf jf md b be ow ox l pb oz">Hello, Rust!</span></pre><p id="4826" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=faac85d612a7017d6b1193aff6df0dcb" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="8d07" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated">❌ <strong class="ak">清单1–2</strong></h2><p id="a33b" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">让我们在第4行添加一个<code class="fe ma mb mc md b">println!</code>语句…</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="8f9e" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let name = String::from("Rust");<br/>    do_something(name);<br/>    println!("{}", name);<br/>}<br/><br/>fn do_something(name: String) {<br/>    println!("Hello, {}!", name);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="9ea2" class="ov mf jf md b be ow ox l pb oz">error[E0382]: borrow of moved value: `name`<br/> --&gt; src/main.rs:4:20</span></pre><p id="714f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=d2ce6f6d4f6f83e941636914c0f66f03" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><p id="d447" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是违法的！这是因为我们试图使用(借用，在<code class="fe ma mb mc md b">println!</code>的情况下)已经移动到第3行<code class="fe ma mb mc md b">do_something</code>中的值<code class="fe ma mb mc md b">name</code>。</p><p id="fd11" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不能使用已移动的值。在<code class="fe ma mb mc md b">name</code>到达<code class="fe ma mb mc md b">println!</code>之前，它被移入<code class="fe ma mb mc md b">do_something</code>并在函数结束时<em class="lq">移出</em>范围。</p><p id="a513" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们能做什么？</p><h2 id="b188" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated">✅ <strong class="ak">清单1–3</strong></h2><p id="b084" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">我们可以做的是将name克隆为<code class="fe ma mb mc md b">name_clone</code>，这样我们将name用于第5行，将<code class="fe ma mb mc md b">name_clone</code>用于第6行。注意克隆是有成本的。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="8719" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let name = String::from("Rust");<br/>    let name_clone = name.clone();<br/><br/>    do_something(name);<br/>    println!("{}", name_clone);<br/>}<br/><br/>fn do_something(name: String) {<br/>    println!("Name: {}!", name);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="dda6" class="ov mf jf md b be ow ox l pb oz">Name: Rust!<br/>Rust</span></pre><p id="7242" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=1b034f361507f04bdf6cbeedc7e1caca" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="1b31" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated">✅ <strong class="ak">清单1–4</strong></h2><p id="0f76" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">或者我们可以通过第3行中的引用将<code class="fe ma mb mc md b">name</code>传递给<code class="fe ma mb mc md b">do_something</code>，并且仍然能够将其用于第4行中的<code class="fe ma mb mc md b">println!</code>。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="15af" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let name = String::from("Rust");<br/>    do_something(&amp;name);<br/>    println!("{}", name);<br/>}<br/><br/>fn do_something(name: &amp;str) {<br/>    println!("Hello, {}!", name);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="c726" class="ov mf jf md b be ow ox l pb oz">Hello, Rust!<br/>Rust</span></pre><p id="c847" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=6e98c5b6a5164b1d2a046331e5794ebb" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="3730" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated">✅清单1–5</h2><p id="cd6d" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">或者，如果你的程序允许的话，我们可以简单地改变一下代码。</p><p id="7827" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，我们先借用<code class="fe ma mb mc md b">name</code>，然后再把它移入<code class="fe ma mb mc md b">do_something</code>。这个程序编译是因为在<code class="fe ma mb mc md b">do_something</code>行之后，在<code class="fe ma mb mc md b">main</code>范围内没有其他人会使用<code class="fe ma mb mc md b">name</code>。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="6cb7" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let name = String::from("Rust");<br/>    println!("{}", name);<br/>    do_something(name);<br/>}<br/><br/>fn do_something(name: String) {<br/>    println!("Hello, {}!", name);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="c078" class="ov mf jf md b be ow ox l pb oz">Rust<br/>Hello, Rust!</span></pre><p id="eed5" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=1aadec2aaa62a7de28521b79a6e5c779" rel="noopener ugc nofollow" target="_blank">游乐场</a></p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="ed8d" class="me mf jf bd mg mh nt mj mk ml nu mn mo kl nv km mq ko nw kp ms kr nx ks mu mv bi translated">2.i32</h1><p id="939a" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">对于拥有<code class="fe ma mb mc md b">Copy</code>特质的人来说，生活要容易得多，比如<code class="fe ma mb mc md b"><a class="ae jc" href="https://doc.rust-lang.org/std/primitive.i32.html" rel="noopener ugc nofollow" target="_blank">i32</a></code>。</p><h2 id="2e1b" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated">✅ <strong class="ak">清单2–1</strong></h2><p id="c34e" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">还是那句话，先从简单的开始。我们创建<code class="fe ma mb mc md b">age</code>并用它来调用<code class="fe ma mb mc md b">do_something</code>。这里复制了<code class="fe ma mb mc md b">age</code>的值，因为<code class="fe ma mb mc md b">i32</code>类型实现了<code class="fe ma mb mc md b">Copy</code>特征。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="eaa5" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let age: i32 = 25;<br/>    do_something(age);<br/>}<br/><br/>fn do_something(age: i32) {<br/>    println!("Hello, {}!", age);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="e3d4" class="ov mf jf md b be ow ox l pb oz">Hello, 25!</span></pre><p id="5317" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=feb04c5816c7ddecb806881e39c0e18c" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="5de2" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated">✅ <strong class="ak">清单2–2</strong></h2><p id="a282" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">第4行再次复制了<code class="fe ma mb mc md b">age</code>的值。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="667e" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let age: i32 = 25;<br/>    do_something(age);<br/> println!("{}", age);<br/>}<br/><br/>fn do_something(age: i32) {<br/>    println!("Hello, {}!", age);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="97e9" class="ov mf jf md b be ow ox l pb oz">Hello, 25!<br/>25</span></pre><p id="5f0f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=3cd8c1be29e0692e1a596178d9174379" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="688e" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated">✅ <strong class="ak">清单2–3</strong></h2><p id="268b" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">我们也可以通过引用来传递值，虽然<em class="lq">我觉得</em>不太习惯。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="3904" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let age: i32 = 25;<br/>    do_something(&amp;age);<br/>    println!("{}", age);<br/>}<br/><br/>fn do_something(age: &amp;i32) {<br/>    println!("Hello, {}!", age);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="022a" class="ov mf jf md b be ow ox l pb oz">Hello, 25!<br/>25</span></pre><p id="1e9b" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=26eb7144eee0887ac8f9d04cde0cb3e9" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="f6a5" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated">✅ ⚠️ <strong class="ak">清单2–4</strong></h2><p id="7397" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">在第3行中，我们首先克隆了<code class="fe ma mb mc md b">age</code>，然后将其传递给<code class="fe ma mb mc md b">do_something</code>。程序编译，但是注意复制会进行两次——一次是在<code class="fe ma mb mc md b">.clone()</code>中，另一次是在<code class="fe ma mb mc md b">age</code>进入<code class="fe ma mb mc md b">do_something</code>范围时复制。</p><p id="3ddd" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，应该避免这种习语。参见<strong class="kw jg">上的Clippy lint clone _ on _ copy</strong>这里的。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="2f3d" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let age: i32 = 25;<br/>    do_something(age.clone());<br/>    println!("{}", age);<br/>}<br/><br/>fn do_something(age: i32) {<br/>    println!("Hello, {}!", age);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="7859" class="ov mf jf md b be ow ox l pb oz">Hello, 25!<br/>25</span></pre><p id="dd31" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=e550a2a06f881d03d71e3178d800df28" rel="noopener ugc nofollow" target="_blank">游乐场</a></p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="e17b" class="me mf jf bd mg mh nt mj mk ml nu mn mo kl nv km mq ko nw kp ms kr nx ks mu mv bi translated">3.具有<code class="fe ma mb mc md b">String</code>字段的结构</h1><p id="fda3" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">如果一个类型的所有组件都实现了<code class="fe ma mb mc md b">Copy</code>，那么这个类型就可以实现<code class="fe ma mb mc md b">Copy</code>(参见<a class="ae jc" href="https://doc.rust-lang.org/std/marker/trait.Copy.html#when-can-my-type-be-copy" rel="noopener ugc nofollow" target="_blank">我的类型什么时候可以成为</a> <code class="fe ma mb mc md b"><a class="ae jc" href="https://doc.rust-lang.org/std/marker/trait.Copy.html#when-can-my-type-be-copy" rel="noopener ugc nofollow" target="_blank">Copy</a></code> <a class="ae jc" href="https://doc.rust-lang.org/std/marker/trait.Copy.html#when-can-my-type-be-copy" rel="noopener ugc nofollow" target="_blank">？</a>)。</p><p id="5cb1" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这些清单中，我们关注的是由一个<code class="fe ma mb mc md b">String</code>字段组成的<code class="fe ma mb mc md b">Movie</code>结构，其中<em class="lq">没有</em>实现<code class="fe ma mb mc md b">Copy</code>。因此，<code class="fe ma mb mc md b">Movie</code> <em class="lq">无法</em>实现<code class="fe ma mb mc md b">Copy</code>。</p><h2 id="db3b" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated">✅清单3–1</h2><p id="7c0d" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">目前看来还不错，不是吗？程序编译(忽略未使用的字段警告)，我们都很高兴。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="11fc" class="ov mf jf md b be ow ox l oy oz">#[derive(Debug)]<br/>struct Movie {<br/>    title: String,<br/>}<br/><br/>fn main() {<br/>    let movie = Movie { <br/>        title: String::from("Rust")<br/>    };<br/>    do_something(movie);<br/>}<br/><br/>fn do_something(movie: Movie) {<br/>    println!("Movie: {:?}!", movie);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="97df" class="ov mf jf md b be ow ox l pb oz">Movie: Movie { title: "Rust" }!</span></pre><p id="c1c2" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=beb3e965a56641ad97632f7919e6473e" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="6c3a" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated">❌ 清单3–2</h2><p id="754a" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">但是在添加了<code class="fe ma mb mc md b">println!</code>之后，编译器抱怨我们试图借用一个已经移入<code class="fe ma mb mc md b">do_something</code>的值<code class="fe ma mb mc md b">movie</code>。</p><p id="766a" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在前面的清单中，我们已经看到过这种针对<code class="fe ma mb mc md b">String</code>的移动语义。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="bafb" class="ov mf jf md b be ow ox l oy oz">#[derive(Debug)]<br/>struct Movie {<br/>    title: String,<br/>}<br/><br/>fn main() {<br/>    let movie = Movie { <br/>        title: String::from("Rust")<br/>    };<br/>    do_something(movie);<br/>    println!("Movie: {:?}", movie);<br/>}<br/><br/>fn do_something(movie: Movie) {<br/>    println!("Movie: {:?}!", movie);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="aca7" class="ov mf jf md b be ow ox l pb oz">error[E0382]: borrow of moved value: `movie`<br/>  --&gt; src/main.rs:10:29</span></pre><p id="9a56" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=57898774f167fad6dad057040e6c6bb4" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><p id="81aa" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们该怎么办？</p><h2 id="2db9" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单3–3</strong></h2><p id="d845" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">我们可以借用<code class="fe ma mb mc md b">movie</code>而不是移动它。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="bf3c" class="ov mf jf md b be ow ox l oy oz">#[derive(Debug)]<br/>struct Movie {<br/>    title: String,<br/>}<br/><br/>fn main() {<br/>    let movie = Movie { <br/>        title: String::from("Rust")<br/>    };<br/>    do_something(&amp;movie);<br/>    println!("Movie: {:?}", movie);<br/>}<br/><br/>fn do_something(movie: &amp;Movie) {<br/>    println!("Movie: {:?}!", movie);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="0f0d" class="ov mf jf md b be ow ox l pb oz">Movie: Movie { title: "Rust" }!<br/>Movie: Movie { title: "Rust" }</span></pre><p id="0943" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=e6e55488d4ce718c6ff7e20bcf8e7393" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="3570" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单3–4</strong></h2><p id="4e4a" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">或者我们可以为<code class="fe ma mb mc md b">do_something</code>克隆<code class="fe ma mb mc md b">movie</code>。这就需要<code class="fe ma mb mc md b">Movie</code>来实现<code class="fe ma mb mc md b">Clone</code>。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="9de0" class="ov mf jf md b be ow ox l oy oz">#[derive(Debug, Clone)]<br/>struct Movie {<br/>    title: String,<br/>}<br/><br/>fn main() {<br/>    let movie = Movie { <br/>        title: String::from("Rust")<br/>    };<br/>    do_something(movie.clone());<br/>    println!("Movie: {:?}", movie);<br/>}<br/><br/>fn do_something(movie: Movie) {<br/>    println!("Movie: {:?}!", movie);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="f630" class="ov mf jf md b be ow ox l pb oz">Movie: Movie { title: "Rust" }!<br/>Movie: Movie { title: "Rust" }</span></pre><p id="80ed" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=8f4db43211110c0c1903f815c2584e97" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="6562" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单3–5</strong></h2><p id="6f5a" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">或者，如果你的程序允许的话，我们可以在不克隆的情况下稍微改变一下代码。在这里，将<code class="fe ma mb mc md b">println!</code>借用为<code class="fe ma mb mc md b">movie</code>，然后将<code class="fe ma mb mc md b">movie</code>移入<code class="fe ma mb mc md b">do_something</code>。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="da4e" class="ov mf jf md b be ow ox l oy oz">#[derive(Debug)]<br/>struct Movie {<br/>    title: String,<br/>}<br/><br/>fn main() {<br/>    let movie = Movie { <br/>        title: String::from("Rust")<br/>    };<br/>    println!("Movie: {:?}", movie);<br/>    do_something(movie);<br/>}<br/><br/>fn do_something(movie: Movie) {<br/>    println!("Movie: {:?}!", movie);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="6c0d" class="ov mf jf md b be ow ox l pb oz">Movie: Movie { title: "Rust" }<br/>Movie: Movie { title: "Rust" }!</span></pre><p id="10f2" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=52e772eafc2d0a33bb7a4e3cfd95ba7f" rel="noopener ugc nofollow" target="_blank">游乐场</a></p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="6b61" class="me mf jf bd mg mh nt mj mk ml nu mn mo kl nv km mq ko nw kp ms kr nx ks mu mv bi translated">4.带有u8字段的结构</h1><p id="9d5a" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">如前所述，如果一个类型的所有组件都实现了<code class="fe ma mb mc md b">Copy</code>，那么这个类型就可以实现<code class="fe ma mb mc md b">Copy</code>。</p><p id="766d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这些清单中，我们关注的是由一个实现<code class="fe ma mb mc md b">Copy</code>特征的<code class="fe ma mb mc md b">u8</code>字段组成的<code class="fe ma mb mc md b">Book</code>结构。这样一来，<code class="fe ma mb mc md b">Movie</code> <em class="lq">就可以</em>实现<code class="fe ma mb mc md b">Copy</code>。</p><h2 id="01bf" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated">✅ <strong class="ak">清单4–1</strong></h2><p id="381d" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">在这个清单中，一切看起来都很正常，对吗？</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="4e54" class="ov mf jf md b be ow ox l oy oz">#[derive(Debug)]<br/>struct Book {<br/>    id: u8,<br/>}<br/><br/>fn main() {<br/>    let book = Book { id: 1 };<br/>    do_something(book);<br/>}<br/><br/>fn do_something(book: Book) {<br/>    println!("Book: {:?}!", book);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="6281" class="ov mf jf md b be ow ox l pb oz">Book: Book { id: 1 }!</span></pre><p id="9a3f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=8f03cf76c09fd56dbe37299b03eac55d" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="2b98" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated">❌ <strong class="ak">清单4–2</strong></h2><p id="a13e" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">直到我们在<code class="fe ma mb mc md b">do_something</code>下面加一个<code class="fe ma mb mc md b">println!</code>语句。发生了什么事？</p><p id="ffac" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为<code class="fe ma mb mc md b">book</code>没有实现<code class="fe ma mb mc md b">Copy</code>特征(或者还没有实现)，Rust <em class="lq">将</em> <code class="fe ma mb mc md b">book</code>移入<code class="fe ma mb mc md b">do_something</code>。但是…因为<code class="fe ma mb mc md b">book</code>被移动，<code class="fe ma mb mc md b">println!</code>不能再使用该值。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="d70f" class="ov mf jf md b be ow ox l oy oz">#[derive(Debug)]<br/>struct Book {<br/>    id: u8,<br/>}<br/><br/>fn main() {<br/>    let book = Book { id: 1 };<br/>    do_something(book);<br/>    println!("Book: {:?}", book);<br/>}<br/><br/>fn do_something(book: Book) {<br/>    println!("Book: {:?}!", book);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="b4e1" class="ov mf jf md b be ow ox l pb oz">error[E0382]: borrow of moved value: `book`<br/> --&gt; src/main.rs:8:28</span></pre><p id="95e0" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们能做什么？</p><p id="c310" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=0d7204cf6da7b709ea3cdc6f573f9c5c" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="2089" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated">❌ <strong class="ak">清单4–3</strong></h2><p id="d3da" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">一种方法是通过派生<code class="fe ma mb mc md b">Copy</code>来实现Book的<code class="fe ma mb mc md b">Copy</code>特征。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="3bce" class="ov mf jf md b be ow ox l oy oz">#[derive(Debug, Copy)]<br/>struct Book {<br/>    id: u8,<br/>}<br/><br/>fn main() {<br/>    let book = Book { id: 1 };<br/>    do_something(book);<br/>    println!("Book: {:?}", book);<br/>}<br/><br/>fn do_something(book: Book) {<br/>    println!("Book: {:?}!", book);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="af57" class="ov mf jf md b be ow ox l pb oz">error[E0277]: the trait bound `Book: Clone` is not satisfied<br/> --&gt; src/main.rs:1:17</span></pre><p id="d52c" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=ad90ab72c41ee22806c3a3ab67e3b375" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><p id="ba8e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是……我们仍然得到一个错误——特征边界<code class="fe ma mb mc md b">Book: Clone</code>不满足。</p><h2 id="950d" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated">✅ <strong class="ak">清单4–4</strong></h2><p id="7966" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">如果我们看一下<a class="ae jc" href="https://doc.rust-lang.org/std/marker/trait.Copy.html#whats-the-difference-between-copy-and-clone" rel="noopener ugc nofollow" target="_blank">文档</a>，它说所有为<code class="fe ma mb mc md b">Copy</code>的东西也必须实现<code class="fe ma mb mc md b">Clone</code>，因为<code class="fe ma mb mc md b">Clone</code>是一个父类。</p><p id="2b11" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，让我们在现有的<code class="fe ma mb mc md b">Copy</code>特征之上为<code class="fe ma mb mc md b">Book</code>实现<code class="fe ma mb mc md b">Clone</code>特征。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="bd2e" class="ov mf jf md b be ow ox l oy oz">#[derive(Debug, Copy, Clone)]<br/>struct Book {<br/>    id: u8,<br/>}<br/><br/>fn main() {<br/>    let book = Book { id: 1 };<br/>    do_something(book);<br/>    println!("Book: {:?}", book);<br/>}<br/><br/>fn do_something(book: Book) {<br/>    println!("Book: {:?}!", book);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="dbcf" class="ov mf jf md b be ow ox l pb oz">Book: Book { id: 1 }!<br/>Book: Book { id: 1 }</span></pre><p id="43c9" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=5ad07c8da8842c55178df24c3ab7e1c7" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="114a" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated">✅ <strong class="ak">清单4–5</strong></h2><p id="3375" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">太棒了。我们也可以重新设计我们的程序，让<code class="fe ma mb mc md b">do_something</code>借用<code class="fe ma mb mc md b">book</code>来代替。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="123b" class="ov mf jf md b be ow ox l oy oz">#[derive(Debug)]<br/>struct Book {<br/>    id: u8,<br/>}<br/><br/>fn main() {<br/>    let book = Book { id: 1 };<br/>    do_something(&amp;book);<br/>    println!("Book: {:?}", book);<br/>}<br/><br/>fn do_something(book: &amp;Book) {<br/>    println!("Book: {:?}!", book);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="b851" class="ov mf jf md b be ow ox l pb oz">Book: Book { id: 1 }!<br/>Book: Book { id: 1 }</span></pre><p id="72c1" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=a22b2118f4fb1529e9f942f913d8d378" rel="noopener ugc nofollow" target="_blank">游乐场</a></p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="39d6" class="me mf jf bd mg mh nt mj mk ml nu mn mo kl nv km mq ko nw kp ms kr nx ks mu mv bi translated"><strong class="ak"> 5。具有两个字符串字段的结构</strong></h1><p id="3b0d" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">值可以从结构中移出吗？🤔</p><p id="5650" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本节中，我们将讨论<em class="lq">部分移动</em>。</p><h2 id="234b" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单5–1</strong></h2><p id="8ee7" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">目前看来一切正常…</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="6df2" class="ov mf jf md b be ow ox l oy oz">#[derive(Debug)]<br/>struct Person {<br/>    name: String,<br/>    alias: String,<br/>}<br/><br/>fn main() {<br/>    let person = Person { <br/>        name: "John".to_string(),<br/>        alias: "Johan".to_string(),<br/>    };<br/>    print_alias(person.alias);<br/>}<br/><br/>fn print_alias(alias: String) {<br/>    println!("Person: {:?}!", alias);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="c047" class="ov mf jf md b be ow ox l pb oz">Person: "Johan"!</span></pre><p id="91c4" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=13b421d6a489dc624c36a89991007f11" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="2b12" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ❌清单5–2</strong></h2><p id="4123" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">然而，在这个清单中，我们在<code class="fe ma mb mc md b">print_alias</code>之后添加了一个print语句。</p><p id="7544" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">程序没有编译，因为<code class="fe ma mb mc md b">person.alias</code>已经将<em class="lq">部分移动到<code class="fe ma mb mc md b">print_alias</code>中，但是我们尝试在<code class="fe ma mb mc md b">println!</code>行中整体借用<code class="fe ma mb mc md b">person</code>。</em></p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="7b74" class="ov mf jf md b be ow ox l oy oz">#[derive(Debug)]<br/>struct Person {<br/>    name: String,<br/>    alias: String,<br/>}<br/><br/>fn main() {<br/>    let person = Person { <br/>        name: "John".to_string(),<br/>        alias: "Johan".to_string(),<br/>    };<br/>    print_alias(person.alias);<br/>    println!("{:?}", person);<br/>}<br/><br/>fn print_alias(alias: String) {<br/>    println!("Person: {:?}!", alias);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="be6c" class="ov mf jf md b be ow ox l pb oz">error[E0382]: borrow of partially moved value: `person`<br/>  --&gt; src/main.rs:12:22</span></pre><p id="01d9" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=0611ce83e9af1663cd1027aa4f73ec38" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><p id="5656" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们能做什么？有哪些合法的举动？</p><h2 id="ad32" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单5–3</strong></h2><p id="c820" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">原来我们<em class="lq">可以</em>部分移动字段——只要确保我们以后不再尝试使用这个结构本身。</p><p id="29f9" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，我们将这两个字段移动到两个不同的函数中。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="f8f4" class="ov mf jf md b be ow ox l oy oz">#[derive(Debug)]<br/>struct Person {<br/>    name: String,<br/>    alias: String,<br/>}<br/><br/>fn main() {<br/>    let person = Person { <br/>        name: "John".to_string(),<br/>        alias: "Johan".to_string(),<br/>    };<br/>    print_alias(person.alias);<br/>    print_name(person.name);<br/>}<br/><br/>fn print_alias(alias: String) {<br/>    println!("Alias: {:?}!", alias);<br/>}<br/><br/>fn print_name(name: String) {<br/>    println!("Name: {:?}!", name);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="620a" class="ov mf jf md b be ow ox l pb oz">Alias: "Johan"!<br/>Name: "John"!</span></pre><p id="47fa" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=fd51d900044e94a589332c6c8485dace" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="714a" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单5–4</strong></h2><p id="6612" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">我们可以通过引用来传递这些字段。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="15c7" class="ov mf jf md b be ow ox l oy oz">#[derive(Debug)]<br/>struct Person {<br/>    name: String,<br/>    alias: String,<br/>}<br/><br/>fn main() {<br/>    let person = Person { <br/>        name: "John".to_string(),<br/>        alias: "Johan".to_string(),<br/>    };<br/>    print_alias(&amp;person.alias);<br/>    print_name(&amp;person.name);<br/>}<br/><br/>fn print_alias(alias: &amp;str) {<br/>    println!("Alias: {:?}!", alias);<br/>}<br/><br/>fn print_name(name: &amp;str) {<br/>    println!("Name: {:?}!", name);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="43c7" class="ov mf jf md b be ow ox l pb oz">Alias: "Johan"!<br/>Name: "John"!</span></pre><p id="53a3" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=d7c5c74fe3cea73da8ef411bafe5a8ed" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="70b5" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单5–5</strong></h2><p id="1448" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">或者如果我们以后想再次使用<code class="fe ma mb mc md b">person</code>，我们可以克隆这些值。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="e780" class="ov mf jf md b be ow ox l oy oz">#[derive(Debug)]<br/>struct Person {<br/>    name: String,<br/>    alias: String,<br/>}<br/><br/>fn main() {<br/>    let person = Person { <br/>        name: "John".to_string(),<br/>        alias: "Johan".to_string(),<br/>    };<br/>    print_alias(person.alias.clone());<br/>    print_name(person.name.clone());<br/>    println!("{:?}", person);<br/>}<br/><br/>fn print_alias(alias: String) {<br/>    println!("Alias: {:?}!", alias);<br/>}<br/><br/>fn print_name(name: String) {<br/>    println!("Name: {:?}!", name);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="c301" class="ov mf jf md b be ow ox l pb oz">Alias: "Johan"!<br/>Name: "John"!<br/>Person { name: "John", alias: "Johan" }</span></pre><p id="a7af" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=43ff48bc0215e4a341a08a02aab68b78" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="1310" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单5–6</strong></h2><p id="2ea0" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">或者你可以移动东西而不需要克隆。这里我们先借用了<code class="fe ma mb mc md b">person</code>，然后部分移动了字段。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="4fd2" class="ov mf jf md b be ow ox l oy oz">#[derive(Debug)]<br/>struct Person {<br/>    name: String,<br/>    alias: String,<br/>}<br/><br/>fn main() {<br/>    let person = Person { <br/>        name: "John".to_string(),<br/>        alias: "Johan".to_string(),<br/>    };<br/>    println!("{:?}", person);<br/>    print_alias(person.alias);<br/>    print_name(person.name);<br/>}<br/><br/>fn print_alias(alias: String) {<br/>    println!("Alias: {:?}!", alias);<br/>}<br/><br/>fn print_name(name: String) {<br/>    println!("Name: {:?}!", name);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="af3d" class="ov mf jf md b be ow ox l pb oz">Person { name: "John", alias: "Johan" }<br/>Alias: "Johan"!<br/>Name: "John"!</span></pre><p id="b521" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=f4dcc6f3684bad24294ef8d4196b1aa6" rel="noopener ugc nofollow" target="_blank">游乐场</a></p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="e657" class="me mf jf bd mg mh nt mj mk ml nu mn mo kl nv km mq ko nw kp ms kr nx ks mu mv bi translated">6.Vec <string/></h1><p id="e279" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">像<code class="fe ma mb mc md b">String</code>，<code class="fe ma mb mc md b"><a class="ae jc" href="https://doc.rust-lang.org/std/vec/struct.Vec.html#" rel="noopener ugc nofollow" target="_blank">Vec</a></code>一样被移动，因为它们没有实现<code class="fe ma mb mc md b">Copy</code>特性(见<a class="ae jc" href="https://doc.rust-lang.org/std/vec/struct.Vec.html#trait-implementations" rel="noopener ugc nofollow" target="_blank">此处</a>)。同样的移动语义也适用。</p><p id="2f9b" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">向量(以及其他相关的集合)值得一谈，因为涉及到太多的语义——容器本身、元素和迭代器。</p><p id="28a5" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在这里使用<code class="fe ma mb mc md b">Vec</code>作为例子，因为它是集合中非常常见的数据结构。其他没有实现<code class="fe ma mb mc md b">Copy</code>特征的集合包括<code class="fe ma mb mc md b">HashMap</code>和<code class="fe ma mb mc md b">HashSet</code>。另一方面，数组的移动语义与结构的工作方式相似，因为它们依赖于项的类型——但那是另一天的事情了。</p><h2 id="faa9" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单6–1</strong></h2><p id="7d1c" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">像往常一样，我们从开心的事情开始:</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="50f1" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let names = vec![<br/>       String::from("John"),<br/>       String::from("Jane"),<br/>   ];<br/>    do_something(names);<br/>}<br/><br/>fn do_something(names: Vec&lt;String&gt;) {<br/>    println!("{:?}", names);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="d562" class="ov mf jf md b be ow ox l pb oz">["John", "Jane"]</span></pre><p id="9298" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=307eea01cd9ed0e81f72547968c94700" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="b137" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ❌清单6–2</strong></h2><p id="154b" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">直到我们在<code class="fe ma mb mc md b">do_something</code>后面加上一个<code class="fe ma mb mc md b">println!</code>语句。</p><p id="5e8b" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于<code class="fe ma mb mc md b">String</code>类型，我们之前已经看到过这种编译器错误，在这种情况下，我们试图借用/使用一个已经被移动的值。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="9b37" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let names = vec![<br/>        String::from("John"),<br/>        String::from("Jane"),<br/>   ];<br/>    do_something(names);<br/>    println!("{:?}", names);<br/>}<br/><br/>fn do_something(names: Vec&lt;String&gt;) {<br/>    println!("{:?}", names);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="a0fb" class="ov mf jf md b be ow ox l pb oz">error[E0382]: borrow of moved value: `names`<br/> --&gt; src/main.rs:7:22</span></pre><p id="16ff" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=949805ae8472f9fb4fe3edb57d7f9067" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><p id="8268" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们能做什么？</p><h2 id="7ee2" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单6–3</strong></h2><p id="332a" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">我们可以先借用<code class="fe ma mb mc md b">names</code>，这样之后就可以把它移入<code class="fe ma mb mc md b">do_something</code>了。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="3937" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let names = vec![<br/>       String::from("John"),<br/>       String::from("Jane"),<br/>   ];<br/>    println!("{:?}", names);<br/>    do_something(names);<br/>}<br/><br/>fn do_something(names: Vec&lt;String&gt;) {<br/>    println!("{:?}", names);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="052d" class="ov mf jf md b be ow ox l pb oz">["John", "Jane"]<br/>["John", "Jane"]</span></pre><p id="fd68" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=3fd48e7cd13a70efaa4faab673a7fd5a" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="4f69" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单6–4</strong></h2><p id="ccf1" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">我们可以重新设计<code class="fe ma mb mc md b">do_something</code>来借用<code class="fe ma mb mc md b">names</code>，这样我们就可以在<code class="fe ma mb mc md b">println!</code>再次借用。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="c220" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let names = vec![<br/>       String::from("John"),<br/>       String::from("Jane"),<br/>   ];<br/>    do_something(&amp;names);<br/>    println!("{:?}", names);<br/>}<br/><br/>fn do_something(names: &amp;[String]) {<br/>    println!("{:?}", names);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="5ed3" class="ov mf jf md b be ow ox l pb oz">["John", "Jane"]<br/>["John", "Jane"]</span></pre><p id="b878" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=faaf4eb528f522351b79c5121c811217" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="a3cb" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单6–5</strong></h2><p id="1791" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">最后，我们可以克隆载体用于<code class="fe ma mb mc md b">do_something</code>。注意，如果一个向量的底层类型实现了<code class="fe ma mb mc md b">Clone</code>特征，那么这个向量就可以被克隆。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="62d6" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let names = vec![<br/>       String::from("John"),<br/>       String::from("Jane"),<br/>  ];<br/>    do_something(names.clone());<br/>    println!("{:?}", names);<br/>}<br/><br/>fn do_something(names: Vec&lt;String&gt;) {<br/>    println!("{:?}", names);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="cc97" class="ov mf jf md b be ow ox l pb oz">["John", "Jane"]<br/>["John", "Jane"]</span></pre><p id="b4be" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=eb0be758f7629102ba954cbb79aab1fc" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><p id="f90e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过获取索引来读取向量中的元素是很复杂的。这和我们所知的编程语言不一样。</p><h2 id="5cd6" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ❌清单6–6</strong></h2><p id="0776" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">我是说你能看看这个吗！下面的代码在我所知道的编程语言中非常好，但是在这里，我们得到一个编译器错误，说我不能移出索引<code class="fe ma mb mc md b">Vec&lt;String&gt;</code>。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="4e72" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let names = vec![<br/>       String::from("John"),<br/>       String::from("Jane"),<br/>   ];<br/>    let name: String = names[0];<br/>    println!("Hello, {}", name);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="33e9" class="ov mf jf md b be ow ox l pb oz">error[E0507]: cannot move out of index of `Vec&lt;String&gt;`<br/> --&gt; src/main.rs:6:24</span></pre><p id="e080" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=b0b6114f17c06ed0a42fcd6e1325e824" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><p id="b468" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是为什么呢？</p><p id="e847" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看，如果你只从一个<code class="fe ma mb mc md b">Vec</code>中移出一个元素，你会让向量处于一个<strong class="kw jg">无效状态</strong>——向量不再是同质元素的集合</p><p id="d4dc" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不允许隐式移出<code class="fe ma mb mc md b">Vec</code>，因为这会<strong class="kw jg">使向量处于无效状态</strong>——一个元素被移出，其他元素不被移出(参见<a class="ae jc" href="https://stackoverflow.com/questions/27904864/what-does-cannot-move-out-of-index-of-mean" rel="noopener ugc nofollow" target="_blank">这个</a> StackOverflow post)。如果我要迭代这个向量，我可能会访问一个无效的内存(被移出的元素)😱。谢谢你保护我们，拉斯特。</p><p id="a840" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那我们该怎么办？</p><h2 id="f247" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单6–7</strong></h2><p id="dbfc" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">我们可以通过使用索引操作符来借用我们想要的值。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="57dc" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let names = vec![<br/>       String::from("John"),<br/>       String::from("Jane"),<br/>   ];<br/>    let name: &amp;str = &amp;names[0];<br/>    println!("Hello, {}", name);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="43a3" class="ov mf jf md b be ow ox l pb oz">Hello, John</span></pre><p id="944d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=3a2b3b74fa9fac331e805a86158e9c2b" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="0a7e" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单6–8</strong></h2><p id="368d" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">我们也可以使用<code class="fe ma mb mc md b">.get</code>方法来借用这个值。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="15cc" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let names = vec![<br/>       String::from("John"),<br/>       String::from("Jane"),<br/>   ];<br/>    let name: &amp;str = <br/>    names.get(0).unwrap();<br/>    println!("Hello, {}", name);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="3577" class="ov mf jf md b be ow ox l pb oz">Hello, John</span></pre><p id="3dd2" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=1dd433f1795e97c7131b165ef195f70f" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="d032" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单6–9</strong></h2><p id="bc49" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">我们可以使用<code class="fe ma mb mc md b">.first()</code>或<code class="fe ma mb mc md b">.last()</code>方法来借用这个值(当然，如果你想要第一个和最后一个项目的话)。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="f33a" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let names = vec![<br/>       String::from("John"),<br/>       String::from("Jane"),<br/>   ];<br/>    let name: &amp;str = <br/>    names.first().unwrap();<br/>    println!("Hello, {}", name);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="0d0f" class="ov mf jf md b be ow ox l pb oz">Hello, John</span></pre><p id="21f9" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=8dd83ef7fc141dcde84c39e881e90761" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><p id="d926" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是……如果我想<em class="lq">拥有</em>一个元素呢？</p><h2 id="867c" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单6–10</strong></h2><p id="e2e8" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">我们使用<code class="fe ma mb mc md b">.into_iter()</code>方法来拥有单个元素。下一章将详细介绍迭代器。在这里，我们设法拥有调用<code class="fe ma mb mc md b">.next()</code>后的第一个元素:</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="d2b9" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let names = vec![<br/>       String::from("John"),<br/>       String::from("Jane"),<br/>   ];<br/>    let mut names_iter = <br/>    names.into_iter();<br/>    let name: String = <br/>    names_iter.next().unwrap();<br/>    println!("Hello, {}", name);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="4066" class="ov mf jf md b be ow ox l pb oz">Hello, John</span></pre><p id="a441" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=166c5d7162d09dbf206b1161f4c9a8bd" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><p id="55a1" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您想拥有第一个元素，这个例子就可以了。Afaik，如果你想拥有索引为<em class="lq"> n </em>的元素(出于某种原因)，你应该调用<code class="fe ma mb mc md b">.skip(n)</code>然后调用<code class="fe ma mb mc md b">.next()</code>。</p><h2 id="de0b" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单6–11</strong></h2><p id="b65b" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">对于<code class="fe ma mb mc md b">Vec</code>，我们可以<code class="fe ma mb mc md b">.pop()</code>最后一个元素并拥有数据(当然，只有当你想要一个向量的最后一个元素时)。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="b608" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let mut names = vec![<br/>       String::from("John"),<br/>       String::from("Jane"),<br/>   ];<br/>    let name: String = names.pop()<br/>    .unwrap();<br/>    println!("Hello, {}", name);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="8078" class="ov mf jf md b be ow ox l pb oz">Hello, Jane</span></pre><p id="07b8" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=b13290b5c7dd64754afe127e687dfb23" rel="noopener ugc nofollow" target="_blank">游乐场</a></p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="3c86" class="me mf jf bd mg mh nt mj mk ml nu mn mo kl nv km mq ko nw kp ms kr nx ks mu mv bi translated">7.迭代程序</h1><p id="2621" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">当涉及到集合中元素的所有权时，迭代器扮演着极其重要的角色。</p><p id="2fea" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这些例子中，我们将使用<code class="fe ma mb mc md b">Vec&lt;String&gt;</code>，有意地使用<code class="fe ma mb mc md b">String</code>作为元素(它没有实现<code class="fe ma mb mc md b">Copy</code>特征),这样我们可以在一个向量中演示它的移动语义。</p><h2 id="b3c8" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> for循环</strong></h2><h2 id="b6b9" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单7–1</strong></h2><p id="55be" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">让我们从遍历<code class="fe ma mb mc md b">names</code>的for循环开始。为什么是for-loop？我们会谈到这一点。</p><p id="5a3f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但现在，生活是一床玫瑰:</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="3499" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let names = vec![<br/>        String::from("John"),<br/>        String::from("Jane"),<br/>    ];<br/>    for name in names {<br/>        println!("{}", name);<br/>    }<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="e01c" class="ov mf jf md b be ow ox l pb oz">John<br/>Jane</span></pre><p id="a8eb" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=a3904f4e4f35218c5deb07f2a3f83405" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="a7fb" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ❌清单7–2</strong></h2><p id="1601" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">直到我们在for循环下面添加一个print语句…编译器开始抱怨。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="1178" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let names = vec![<br/>        String::from("John"),<br/>        String::from("Jane"),<br/>    ];<br/>  <br/>    for name in names {<br/>        println!("{}", name);<br/>    }<br/>  <br/>    println!("Names: {:?}", names);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="c758" class="ov mf jf md b be ow ox l pb oz">error[E0382]: borrow of moved value: `names`<br/> --&gt; src/main.rs:11:29</span></pre><p id="e17d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=61bffd8a9200a2f36531a59a1c797600" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><p id="5e62" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">显然，在循环之前有一个“隐式的<code class="fe ma mb mc md b">.into_iter</code>调用”</p><p id="6ad5" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">等等，<em class="lq">隐</em>？为什么？！但是好吧，让我们添加那个隐含的<code class="fe ma mb mc md b">.into_iter</code>:</p><h2 id="fcfe" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ❌清单7–3</strong></h2><p id="5e52" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">添加<code class="fe ma mb mc md b">into_iter()</code>后，我们预计程序仍然无法编译。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="ef1a" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let names = vec![<br/>        String::from("John"),<br/>        String::from("Jane"),<br/>    ];<br/><br/>    for name in names.into_iter() {<br/>        println!("{}", name);<br/>    }<br/><br/>    println!("Names: {:?}", names);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="f3b4" class="ov mf jf md b be ow ox l pb oz">error[E0382]: borrow of moved value: `names`<br/> --&gt; src/main.rs:11:29</span></pre><p id="0478" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=81dd26cd3f2d47a9a163e39fa953d2dc" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="cfb3" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ❌清单7–4</strong></h2><p id="2348" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">Hmmmmm我们给<code class="fe ma mb mc md b">names.into_iter()</code>赋个变量吧。所以我们可以想象这个动作。注意，我们仍然认为程序不会编译。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="6283" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let names = vec![<br/>        String::from("John"),<br/>        String::from("Jane"),<br/>    ];<br/>  <br/>    let names_iter = names.into_iter();<br/>    for name in names_iter {<br/>        println!("{}", name);<br/>    }<br/>    println!("Names: {:?}", names);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="34fa" class="ov mf jf md b be ow ox l pb oz">error[E0382]: borrow of moved value: `names`<br/> --&gt; src/main.rs:11:29</span></pre><p id="87c0" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=df4b0449605a42f4e902e4fa79ddd8b3" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><p id="d3ec" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正在发生的是，使用<code class="fe ma mb mc md b">into_iter</code>，我们正在<em class="lq">移动</em>元素从<code class="fe ma mb mc md b">names</code>到<code class="fe ma mb mc md b">names_iter</code>。因此，我们不能再使用<code class="fe ma mb mc md b">names</code>了！</p><p id="c37e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们该怎么办？</p><h2 id="06a8" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单7–5</strong></h2><p id="d070" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">我们可以使用<code class="fe ma mb mc md b">.iter()</code>从<code class="fe ma mb mc md b">names</code>借用元素:</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="88c5" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let names = vec![<br/>        String::from("John"),<br/>        String::from("Jane"),<br/>    ];<br/><br/>    for name in names.iter() {<br/>        println!("{}", name);<br/>    }<br/><br/>    println!("Names: {:?}", names);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="8612" class="ov mf jf md b be ow ox l pb oz">John<br/>Jane<br/>Names: ["John", "Jane"]</span></pre><p id="ba84" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=915863eb52ba9dddb5c498cbb1ab8a25" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="e078" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单7–6</strong></h2><p id="a556" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">我们可以使用一个切片(它实现了<code class="fe ma mb mc md b">IntoIterator</code>)。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="5b01" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let names = vec![<br/>        String::from("John"),<br/>        String::from("Jane"),<br/>    ];<br/><br/>    for name in &amp;names {<br/>        println!("{}", name);<br/>    }<br/><br/>    println!("Names: {:?}", names);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="a4bd" class="ov mf jf md b be ow ox l pb oz">John<br/>Jane<br/>Names: ["John", "Jane"]</span></pre><p id="f779" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=0d332a54632258fbad2cca0dd2039240" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="fea7" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单7–7</strong></h2><p id="8116" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">如果你的程序允许的话，我们可以稍微改变一下代码，先借用<code class="fe ma mb mc md b">names</code>，然后移动它:</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="1cef" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let names = vec![<br/>        String::from("John"),<br/>        String::from("Jane"),<br/>    ];<br/><br/>    println!("Names: {:?}", names);<br/><br/>    for name in names {<br/>        println!("{}", name);<br/>    }<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="733b" class="ov mf jf md b be ow ox l pb oz">Names: ["John", "Jane"]<br/>John<br/>Jane</span></pre><p id="7be1" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=36f20472e004e42b74c7db6463506d84" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="7491" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单7–8</strong></h2><p id="d069" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">我们也可以克隆载体。注意克隆是有成本的。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="3c02" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let names = vec![<br/>        String::from("John"),<br/>        String::from("Jane"),<br/>    ];<br/><br/>    for name in names.clone() {<br/>        println!("{}", name);<br/>    }<br/><br/>    println!("Names: {:?}", names);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="26d7" class="ov mf jf md b be ow ox l pb oz">John<br/>Jane<br/>Names: ["John", "Jane"]</span></pre><p id="8f2b" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=e748cbe0f4c52f20d8bf5839369179c4" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="b2eb" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak">功能编程</strong></h2><p id="86cc" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">使用函数式编程习惯用法使得当您想要迭代元素时，迭代器的参与变得更加明显(特别是如果您来自不必直接处理迭代器的编程语言)。</p><p id="a6b0" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与for循环不同，这里没有隐式的<code class="fe ma mb mc md b">.into_iter()</code>调用。同样，对于向量，我们总是需要调用<code class="fe ma mb mc md b">.iter()</code>、<code class="fe ma mb mc md b">.into_iter()</code>等。得到一个迭代器。</p><h2 id="6657" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ❌清单7–9</strong></h2><p id="3e51" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">这里它没有编译，因为我们需要迭代元素，这意味着我们需要一个迭代器，比如说，<code class="fe ma mb mc md b">.iter()</code>。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="b625" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let names = vec![<br/>        String::from("John"),<br/>        String::from("Jane"),<br/>    ];<br/>    <br/>    names.for_each(|name|<br/>       println!("{}", name));<br/>    <br/>    println!("{:?}", names);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="df81" class="ov mf jf md b be ow ox l pb oz">error[E0599]: `Vec&lt;String&gt;` is not an iterator<br/> --&gt; src/main.rs:7:11</span></pre><p id="db5f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=578112b4e95e4655baf89f35e87fe197" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="d7ce" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单7–10</strong></h2><p id="9a52" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">这里，我们使用了<code class="fe ma mb mc md b">.iter()</code>和<code class="fe ma mb mc md b">.for_each()</code>的组合。</p><p id="1d33" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">迭代器返回对元素的引用。之后我们仍然可以使用<code class="fe ma mb mc md b">names</code>对象:</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="6129" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let names = vec![<br/>        String::from("John"),<br/>        String::from("Jane"),<br/>    ];<br/>    <br/>    names<br/>        .iter()<br/>        .for_each(|name|<br/>           println!("{}", name));<br/>    <br/>    println!("{:?}", names);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="56c9" class="ov mf jf md b be ow ox l pb oz">John<br/>Jane<br/>["John", "Jane"]</span></pre><p id="875e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=9aef2992265c97429f9881595ad86f41" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="1866" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ❌清单7–11</strong></h2><p id="6a50" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">如果你想移动元素，使用<code class="fe ma mb mc md b">.into_iter()</code>。但是，请注意，我们不能在之后使用向量:</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="feb6" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let names = vec![<br/>        String::from("John"),<br/>        String::from("Jane"),<br/>    ];<br/>  <br/>    names<br/>        .into_iter()<br/>        .for_each(|name|<br/>           println!("{}", name));<br/>  <br/>    println!("{:?}", names); <br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="237c" class="ov mf jf md b be ow ox l pb oz">error[E0382]: borrow of moved value: `names`<br/> --&gt; src/main.rs:12:22</span></pre><p id="03bb" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=35ec96f6bb1cd1b658064098aeed5fb3" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="af56" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单7–12</strong></h2><p id="d952" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">你需要重新设计你的程序，这样你就不会使用被移动的元素。这里，我们将打印声明移到了前面:</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="2e00" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let names = vec![<br/>        String::from("John"),<br/>        String::from("Jane"),<br/>    ];<br/>    <br/>    println!("{:?}", names); <br/><br/>    names<br/>        .into_iter()<br/>        .for_each(|name|<br/>           println!("{}", name));<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="0ed6" class="ov mf jf md b be ow ox l pb oz">["John", "Jane"]<br/>John<br/>Jane</span></pre><p id="c085" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=ffc3752256b543ad20c32f097d21aed0" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="4d58" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated"><strong class="ak"> ✅清单7–13</strong></h2><p id="2eea" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">我们也可以在调用<code class="fe ma mb mc md b">.into_iter()</code>之前克隆这个向量。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="196d" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let names = vec![<br/>        String::from("John"),<br/>        String::from("Jane"),<br/>    ];<br/><br/>    names.clone()<br/>        .into_iter()<br/>        .for_each(|name|<br/>           println!("{}", name));<br/>    <br/>    println!("{:?}", names); <br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="1d49" class="ov mf jf md b be ow ox l pb oz">John<br/>Jane<br/>["John", "Jane"]</span></pre><p id="67f1" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=f5ebced734aec3011fd60aa6d0a960da" rel="noopener ugc nofollow" target="_blank">游乐场</a></p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="e5f2" class="me mf jf bd mg mh nt mj mk ml nu mn mo kl nv km mq ko nw kp ms kr nx ks mu mv bi translated">8.&amp;str</h1><p id="d9ef" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">共享引用(<code class="fe ma mb mc md b">&amp;T</code>)也是<code class="fe ma mb mc md b">Copy</code>(此处见<a class="ae jc" href="https://doc.rust-lang.org/std/marker/trait.Copy.html#when-can-my-type-be-copy" rel="noopener ugc nofollow" target="_blank"/>)。下面是一个常用类型的例子，字符串切片<code class="fe ma mb mc md b">&amp;str</code>。</p><h2 id="8053" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated">✅ <strong class="ak">清单8–1</strong>:</h2><p id="83ec" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">我们可以在第3行和第4行传递<code class="fe ma mb mc md b">name</code>到<code class="fe ma mb mc md b">do_something</code>。请注意，我们正在复制<em class="lq">引用。</em></p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="02ad" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let name: &amp;'static str = "Rust";<br/>    do_something(name);<br/>    do_something(name);<br/>}<br/><br/>fn do_something(name: &amp;str) {<br/>    println!("Hello, {:?}!", name);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="03cf" class="ov mf jf md b be ow ox l pb oz">Hello, Rust!<br/>Hello, Rust!</span></pre><p id="969f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=d887f4a40dd3a6ccea5f7ae06610a1e7" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="6fc7" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated">✅ ⚠️ <strong class="ak">清单8–2</strong>:</h2><p id="767a" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">类似于清单2–4，在将<code class="fe ma mb mc md b">name</code>传递给<code class="fe ma mb mc md b">do_something</code>之前调用<code class="fe ma mb mc md b">.clone()</code>是多余的。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="ef4c" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let name: &amp;'static str = "Rust";<br/>    do_something(name.clone());<br/>    do_something(name.clone());<br/>}<br/><br/>fn do_something(name: &amp;str) {<br/>    println!("Hello, {:?}!", name);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="990d" class="ov mf jf md b be ow ox l pb oz">Hello, Rust!<br/>Hello, Rust!</span></pre><p id="6e54" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=2fbea3e861cd47929ca233542d881bc3" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><h2 id="e76e" class="ob mf jf bd mg oc od dn mk oe of dp mo ld og oh mq lh oi oj ms ll ok ol mu om bi translated">✅ ⚠️ <strong class="ak">清单8–3</strong>:</h2><p id="9df2" class="pw-post-body-paragraph ku kv jf kw b kx my kg kz la mz kj lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">在Clippy的建议下，<code class="fe ma mb mc md b">&lt;&amp;str&gt;::clone(&amp;name)</code>习语克隆了这个参考。程序可以编译，但我不确定这是否是惯用的。</p><pre class="on oo op oq gt or md os bn ot ou bi"><span id="d896" class="ov mf jf md b be ow ox l oy oz">fn main() {<br/>    let name: &amp;'static str = "Rust";<br/>    do_something(&lt;&amp;str&gt;::clone(&amp;name));<br/>    do_something(&lt;&amp;str&gt;::clone(&amp;name));<br/>}<br/><br/>fn do_something(name: &amp;str) {<br/>    println!("Hello, {:?}!", name);<br/>}</span></pre><pre class="pa or md os bn ot ou bi"><span id="7216" class="ov mf jf md b be ow ox l pb oz">Hello, Rust!<br/>Hello, Rust!</span></pre><p id="070a" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae jc" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=6b073e2f6039ef91fc640b0bb43168e7" rel="noopener ugc nofollow" target="_blank">游乐场</a></p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="ee0a" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就这些了，伙计们！</p><p id="4039" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我发表关于人工智能、机器学习、编程语言、Web框架、生产力和学习的文章。</p><p id="216b" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">如果你喜欢阅读更多关于web框架的内容，你可以通过我的推荐链接</em> <a class="ae jc" href="https://remykarem.medium.com/subscribe" rel="noopener"> <em class="lq">订阅</em> </a> <em class="lq">随时接收更新或者</em> <a class="ae jc" href="https://remykarem.medium.com/membership" rel="noopener"> <em class="lq">注册</em> </a> <em class="lq">！请注意，您的会员费的一部分将作为介绍费分摊给我。</em></p></div></div>    
</body>
</html>