<html>
<head>
<title>HTTP: redirects, POST and GET requests, and “lost” data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTTP:重定向、POST和GET请求，以及“丢失”的数据</h1>
<blockquote>原文：<a href="https://itnext.io/http-redirects-post-and-get-requests-and-lost-data-e432e7260cbb?source=collection_archive---------2-----------------------#2019-11-23">https://itnext.io/http-redirects-post-and-get-requests-and-lost-data-e432e7260cbb?source=collection_archive---------2-----------------------#2019-11-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/2352808691910b04249f513cee469755.png" data-original-src="https://miro.medium.com/v2/resize:fit:260/format:webp/0*dbrrKbZxzFHkARY3.png"/></div></figure><p id="d703" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们有一个web应用程序，它必须接受来自客户端的POST请求。</p><p id="a2c2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这个应用程序的前面，有一些代理服务，不管是哪一种——最初，我们在AWS的应用程序负载平衡器上遇到了问题，然后我用NGINX重现了这些问题，它将“适用于”任何其他代理系统。</p><p id="3018" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">除了代理之外，该服务还执行HTTP (80)到HTTPS (443)的重定向。</p><p id="282f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这种重定向过程中，问题会准确地出现:</p><ol class=""><li id="0558" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">客户端通过HTTP发送一个<code class="fe le lf lg lh b">POST</code>请求</li><li id="5404" class="kv kw it jz b ka li ke lj ki lk km ll kq lm ku la lb lc ld bi translated">代理返回<strong class="jz iu"> 301 </strong>或<strong class="jz iu"> 302 </strong>重定向到HTTPS</li><li id="0e87" class="kv kw it jz b ka li ke lj ki lk km ll kq lm ku la lb lc ld bi translated">然后，客户端通过HTTPS发送请求，但是:</li><li id="bbea" class="kv kw it jz b ka li ke lj ki lk km ll kq lm ku la lb lc ld bi translated">在某些情况下，这个<code class="fe le lf lg lh b">POST</code>变成了<code class="fe le lf lg lh b">GET</code></li><li id="bf0d" class="kv kw it jz b ka li ke lj ki lk km ll kq lm ku la lb lc ld bi translated">或者它仍然是<code class="fe le lf lg lh b">POST</code>，但是它的所有数据都将“丢失”</li></ol><h2 id="16ef" class="ln lo it bd lp lq lr dn ls lt lu dp lv ki lw lx ly km lz ma mb kq mc md me mf bi translated">测试环境设置</h2><p id="c8d8" class="pw-post-body-paragraph jx jy it jz b ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku im bi translated">出于测试目的，让我们使用下面的配置:</p><ol class=""><li id="9555" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">NINGX接受API请求</li><li id="267f" class="kv kw it jz b ka li ke lj ki lk km ll kq lm ku la lb lc ld bi translated">NGINX通过HTTP将via <code class="fe le lf lg lh b">proxy_pass</code>传递给后端服务</li></ol><ul class=""><li id="5a72" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku ml lb lc ld bi translated">为了重现<code class="fe le lf lg lh b">POST</code>到<code class="fe le lf lg lh b">GET</code>的问题——将使用Docker容器中带有Go应用程序的后端</li><li id="2dcf" class="kv kw it jz b ka li ke lj ki lk km ll kq lm ku ml lb lc ld bi translated">为了重现“丢失的”数据和空的<code class="fe le lf lg lh b">Сontent-length</code>-Python脚本将被用来作为网络服务器运行</li></ul><h2 id="077b" class="ln lo it bd lp lq lr dn ls lt lu dp lv ki lw lx ly km lz ma mb kq mc md me mf bi translated">NGINX</h2><p id="6567" class="pw-post-body-paragraph jx jy it jz b ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku im bi translated">只是一个普通的配置——NGINX，监听80，重定向到HTTPS:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="ab02" class="ln lo it lh b gy mu mv l mw mx">server {<br/><br/>    listen 80;<br/><br/>    server_name dev.poc.example.com;<br/><br/>    location / {<br/><br/>        return 302 <a class="ae my" href="https://dev.poc.example.com$request_uri;" rel="noopener ugc nofollow" target="_blank">https://dev.poc.example.com$request_uri;</a><br/>    }<br/>}<br/>...</span></pre><p id="543a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">和一个<code class="fe le lf lg lh b">server 443 {}</code> -也是常见配置，在8081端口上有一个到后端的<code class="fe le lf lg lh b">proxy_pass</code>:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="0c3d" class="ln lo it lh b gy mu mv l mw mx">...<br/>server {<br/><br/>    listen       443 ssl;<br/>    server_name  dev.poc.example.com;<br/><br/>    ...<br/><br/>    location / {<br/><br/>        proxy_pass <a class="ae my" href="http://localhost:8081;" rel="noopener ugc nofollow" target="_blank">http://localhost:8081;</a><br/><br/>        proxy_set_header Host $host;<br/>        proxy_set_header X-Real-IP $remote_addr;<br/>        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br/>        proxy_set_header X-Forwarded-Proto $scheme;<br/><br/>    }<br/>}</span></pre><h2 id="602c" class="ln lo it bd lp lq lr dn ls lt lu dp lv ki lw lx ly km lz ma mb kq mc md me mf bi translated">Docker中的Go-app</h2><p id="6786" class="pw-post-body-paragraph jx jy it jz b ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku im bi translated">我们在堆栈中有多个容器，但目前，我们感兴趣的是一个带有本地NGINX的<em class="mz">队列消费者</em>(整个初始系统现在仍处于概念验证状态，所以不要担心这里有太多的NGINX)。</p><p id="8357" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们只是对使用<code class="fe le lf lg lh b">POST</code>或<code class="fe le lf lg lh b">GET</code>方法的日志感兴趣。</p><h2 id="bab2" class="ln lo it bd lp lq lr dn ls lt lu dp lv ki lw lx ly km lz ma mb kq mc md me mf bi translated">Python网络服务器</h2><p id="c810" class="pw-post-body-paragraph jx jy it jz b ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku im bi translated">另一个web服务器扮演后端角色来查看数据长度问题——快速搜索Python脚本:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="29f9" class="ln lo it lh b gy mu mv l mw mx">#!/usr/bin/env python3<br/>"""<br/>Very simple HTTP server in python for logging requests<br/>Usage::<br/>    ./server.py [&lt;port&gt;]<br/>"""<br/>from http.server import BaseHTTPRequestHandler, HTTPServer<br/>import logging<br/><br/>class S(BaseHTTPRequestHandler):<br/>    def _set_response(self):<br/>        self.send_response(200)<br/>        self.send_header('Content-type', 'text/html')<br/>        self.end_headers()<br/><br/>    def do_GET(self):<br/>        logging.info("GET request,\nPath: %s\nHeaders:\n%s\n", str(self.path), str(self.headers))<br/>        self._set_response()<br/>        self.wfile.write("GET request for {}".format(self.path).encode('utf-8'))<br/><br/>    def do_POST(self):<br/>        content_length = int(self.headers['Content-Length']) # &lt;--- Gets the size of data<br/>        post_data = self.rfile.read(content_length) # &lt;--- Gets the data itself<br/>        logging.info("POST request,\nPath: %s\nHeaders:\n%s\n\nBody:\n%s\n",<br/>                str(self.path), str(self.headers), post_data.decode('utf-8'))<br/><br/>        self._set_response()<br/>        self.wfile.write("POST request for {}".format(self.path).encode('utf-8'))<br/><br/>def run(server_class=HTTPServer, handler_class=S, port=8081):<br/>    logging.basicConfig(level=logging.INFO)<br/>    server_address = ('', port)<br/>    httpd = server_class(server_address, handler_class)<br/>    logging.info('Starting httpd...\n')<br/>    try:<br/>        httpd.serve_forever()<br/>    except KeyboardInterrupt:<br/>        pass<br/>    httpd.server_close()<br/>    logging.info('Stopping httpd...\n')<br/><br/>if __name__ == '__main__':<br/>    from sys import argv<br/><br/>    if len(argv) == 2:<br/>        run(port=int(argv[1]))<br/>    else:<br/>        run()</span></pre><h2 id="9c84" class="ln lo it bd lp lq lr dn ls lt lu dp lv ki lw lx ly km lz ma mb kq mc md me mf bi translated">示例:重现问题</h2><h2 id="f578" class="ln lo it bd lp lq lr dn ls lt lu dp lv ki lw lx ly km lz ma mb kq mc md me mf bi translated">重定向后<code class="fe le lf lg lh b">POST</code>的数据丢失</h2><p id="312b" class="pw-post-body-paragraph jx jy it jz b ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku im bi translated">我们面临的第一件事是，在HTTP到HTTPS重定向之后，我们的POST请求丢失了数据。</p><p id="3b89" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了重现它，让我们使用上面提到的Python脚本。</p><p id="059e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在8081端口上运行它:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="60b1" class="ln lo it lh b gy mu mv l mw mx">root@ip-10–0–15–118:/home/admin# ./test_post.py 8081<br/>INFO:root:Starting httpd…</span></pre><p id="4f73" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">用<code class="fe le lf lg lh b">POST</code>和<code class="fe le lf lg lh b">--data</code>中的一些数据运行<code class="fe le lf lg lh b">curl</code>:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="860b" class="ln lo it lh b gy mu mv l mw mx">curl -vL -X POST <a class="ae my" href="http://dev.poc.example.com/" rel="noopener ugc nofollow" target="_blank">http://dev.poc.example.com/</a> -d “param1=value1&amp;param2=value2”<br/>…<br/>* Trying 52.***.***.224:80…<br/>…<br/>&gt; Content-Length: 27<br/>…<br/>&lt; HTTP/1.1 302 Moved Temporarily<br/>…<br/>&lt; Content-Length: 161<br/>&lt; Connection: keep-alive<br/>&lt; Location: <a class="ae my" href="https://dev.poc.example.com/" rel="noopener ugc nofollow" target="_blank">https://dev.poc.example.com/</a><br/>…<br/>&gt; POST / HTTP/1.1<br/>&gt; Host: dev.poc.example.com<br/>&gt; User-Agent: curl/7.67.0<br/>&gt; Accept: */*<br/>&gt;<br/>* Mark bundle as not supporting multiuse<br/>&lt; HTTP/1.1 502 Bad Gateway<br/>&lt; Server: nginx/1.10.3<br/>…<br/>&lt; Content-Type: text/html<br/>&lt; Content-Length: 173</span></pre><p id="05a7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们看看这里发生了什么:</p><ol class=""><li id="d09f" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">通过HTTP发送一个<code class="fe le lf lg lh b">POST</code>请求，<em class="mz"> Content-Length: 27 </em></li><li id="8bc9" class="kv kw it jz b ka li ke lj ki lk km ll kq lm ku la lb lc ld bi translated">一个<strong class="jz iu"> 302重定向</strong>发给HTTPS</li><li id="a814" class="kv kw it jz b ka li ke lj ki lk km ll kq lm ku la lb lc ld bi translated">并且经由HTTPS发送<code class="fe le lf lg lh b">POST</code>请求，<em class="mz">内容长度:173 </em></li></ol><p id="7ff1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在NGINX日志中，我们可以看到一个标准的HTTP <code class="fe le lf lg lh b">POST</code>:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="aee4" class="ln lo it lh b gy mu mv l mw mx">…<br/>==&gt; /var/log/nginx/dev.poc.example.com-error.log &lt;==<br/>2019/11/23 09:52:41 [error] 19793#19793: *51100 upstream prematurely closed connection while reading response header from upstream, client: 194.***.***.26, server: dev.poc.example.com, request: “POST / HTTP/1.1”, upstream: “http://127.0.0.1:8081/", host: “dev.poc.example.com”<br/>==&gt; /var/log/nginx/dev.poc.example.com-access.log &lt;==<br/>194.***.***.26 — — [23/Nov/2019:09:52:41 +0000] “POST / HTTP/1.1” 502 173 “-” “curl/7.67.0”<br/>…</span></pre><p id="c558" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但是让我们看看Python服务器运行的stderr:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="7bd1" class="ln lo it lh b gy mu mv l mw mx">…<br/>Exception happened during processing of request from (‘127.0.0.1’, 38224)<br/>Traceback (most recent call last):<br/>File “/usr/lib/python3.5/socketserver.py”, line 313, in _handle_request_noblock<br/>self.process_request(request, client_address)<br/>File “/usr/lib/python3.5/socketserver.py”, line 341, in process_request<br/>self.finish_request(request, client_address)<br/>File “/usr/lib/python3.5/socketserver.py”, line 354, in finish_request<br/>self.RequestHandlerClass(request, client_address, self)<br/>File “/usr/lib/python3.5/socketserver.py”, line 681, in __init__<br/>self.handle()<br/>File “/usr/lib/python3.5/http/server.py”, line 422, in handle<br/>self.handle_one_request()<br/>File “/usr/lib/python3.5/http/server.py”, line 410, in handle_one_request<br/>method()<br/>File “./test_post.py”, line 22, in do_POST<br/>content_length = int(self.headers[‘Content-Length’]) # ←- Gets the size of data<br/>TypeError: int() argument must be a string, a bytes-like object or a number, not ‘NoneType’<br/>…</span></pre><p id="d142" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注意这几行:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="f501" class="ln lo it lh b gy mu mv l mw mx">…<br/>content_length = int(self.headers[‘Content-Length’])<br/>TypeError: int() argument must be a string, a bytes-like object or a number, not ‘NoneType’</span></pre><p id="3faa" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">例如，应用程序得到一个空的/缺失的<em class="mz">内容长度</em>字段。</p><p id="fc29" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">尽管如此，如果直接通过HTTP(NGINX禁用了重定向)或通过HTTPS发出一个新请求，一切都会正常工作，正如预期的那样:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="8b1f" class="ln lo it lh b gy mu mv l mw mx">$ curl -vL -X POST <a class="ae my" href="https://dev.poc.example.com/" rel="noopener ugc nofollow" target="_blank">https://dev.poc.example.com/</a> -d “param1=value1&amp;param2=value2”<br/>…<br/>&gt; POST / HTTP/1.1<br/>&gt; Host: dev.poc.example.com<br/>&gt; User-Agent: curl/7.67.0<br/>&gt; Accept: */*<br/>&gt; Content-Length: 27<br/>&gt; Content-Type: application/x-www-form-urlencoded<br/>&gt;<br/>* upload completely sent off: 27 out of 27 bytes<br/>* Mark bundle as not supporting multiuse<br/>&lt; HTTP/1.1 200 OK&lt; Server: nginx/1.10.3<br/>&lt; Date: Sat, 23 Nov 2019 09:55:07 GMT<br/>&lt; Content-Type: text/html<br/>&lt; Transfer-Encoding: chunked<br/>&lt; Connection: keep-alive<br/>&lt;<br/>* Connection #0 to host dev.poc.example.com left intact<br/>POST request for /</span></pre><p id="63aa" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">Python的应用程序stdout:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="7dda" class="ln lo it lh b gy mu mv l mw mx">…<br/>INFO:root:POST request,<br/>Path: /<br/>Headers:<br/>Host: dev.poc.example.com<br/>X-Real-IP: 194.***.***.26<br/>X-Forwarded-For: 194.***.***.26<br/>X-Forwarded-Proto: https<br/>Connection: close<br/>Content-Length: 27<br/>User-Agent: curl/7.67.0<br/>Accept: */*<br/>Content-Type: application/x-www-form-urlencoded<br/>Body:<br/>param1=value1&amp;param2=value2<br/>127.0.0.1 — — [23/Nov/2019 09:55:07] “POST / HTTP/1.0” 200 -</span></pre><p id="3947" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，我们来看下一个第二题。</p><h2 id="e926" class="ln lo it bd lp lq lr dn ls lt lu dp lv ki lw lx ly km lz ma mb kq mc md me mf bi translated">一个<code class="fe le lf lg lh b">POST</code>变成了<code class="fe le lf lg lh b">GET</code></h2><p id="e8a7" class="pw-post-body-paragraph jx jy it jz b ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku im bi translated">在调试上面讨论的问题期间，当后端在<code class="fe le lf lg lh b">POST</code>期间没有接收到数据时，我发现在HTTP-redirects期间请求的另一个“令人兴奋”的行为。</p><p id="12b5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们看看我们的<code class="fe le lf lg lh b">POST</code>请求会变成什么样...一个<code class="fe le lf lg lh b">GET</code>请求！</p><p id="37f2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">细节和根本原因将在本文后面讨论，现在让我们使用两个HTTP客户端— <code class="fe le lf lg lh b">curl</code>和Postman来重现这个问题。</p><p id="74fa" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe le lf lg lh b"><strong class="jz iu">curl</strong></code></p><p id="aa9f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">通过带有<code class="fe le lf lg lh b">-L</code>的HTTP运行一个带有<code class="fe le lf lg lh b">POST</code>类型的请求，然后重定向到HTTPS。</p><p id="94e3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这种情况下，我们使用的不是上面使用的Python脚本，而是我们真正的后端Docker容器来演示它的工作并检查它的日志。</p><p id="991b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">数据本身以及任何错误在这里都没有价值——我们只对使用的请求方法— <code class="fe le lf lg lh b">POST</code>和<code class="fe le lf lg lh b">GET</code>感兴趣。</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="1ccd" class="ln lo it lh b gy mu mv l mw mx">$ curl -vL -X POST <a class="ae my" href="http://dev.poc.example.com/skin/api/v1/receipt" rel="noopener ugc nofollow" target="_blank">http://dev.poc.example.com/skin/api/v1/receipt</a> -d “{}”<br/>…<br/>&gt; POST /skin/api/v1/receipt HTTP/1.1<br/>&gt; Host: dev.poc.example.com<br/>&gt; User-Agent: curl/7.67.0<br/>&gt; Accept: */*<br/>&gt;<br/>* Mark bundle as not supporting multiuse<br/>&lt; HTTP/1.1 400 Bad Request<br/>&lt; Server: nginx/1.10.3<br/>&lt; Date: Sat, 23 Nov 2019 10:07:37 GMT<br/>&lt; Content-Type: application/json; charset=utf-8<br/>&lt; Content-Length: 58<br/>&lt; Connection: keep-alive<br/>&lt;<br/>* Connection #1 to host dev.poc.example.com left intact<br/>{“message”:”Validation failed: unable to parse json body”</span></pre><p id="f45f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">同样，不要在这里查看错误，而是让我们查看NGINX的日志:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="19f4" class="ln lo it lh b gy mu mv l mw mx">==&gt; /var/log/nginx/dev.poc.example.com-access.log &lt;==<br/>194.***.***.26 — — [23/Nov/2019:10:07:37 +0000] “POST /skin/api/v1/receipt HTTP/1.1” 400 58 “-” “curl/7.67.0”</span></pre><p id="5092" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里一切都好吗？发送了一个<code class="fe le lf lg lh b">POST</code>-收到了一个<code class="fe le lf lg lh b">POST</code>。</p><p id="0998" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">只是为了检查一下——让我们用显式指定的<code class="fe le lf lg lh b">GET</code>类型运行<code class="fe le lf lg lh b">curl</code>,看看后端的响应和NGINX日志，在这种情况下:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="f3ea" class="ln lo it lh b gy mu mv l mw mx">curl -L -X GET <a class="ae my" href="http://dev.poc.example.com/skin/api/v1/receipt" rel="noopener ugc nofollow" target="_blank">http://dev.poc.example.com/skin/api/v1/receipt</a> -d “{}”<br/>404 page not found</span></pre><p id="11ca" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">和NGINX日志与此<code class="fe le lf lg lh b">GET</code>:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="4d86" class="ln lo it lh b gy mu mv l mw mx">==&gt; /var/log/nginx/dev.poc.example.com-access.log &lt;==<br/>194.***.***.26 — — [23/Nov/2019:10:07:37 +0000] “POST /skin/api/v1/receipt HTTP/1.1” 400 58 “-” “curl/7.67.0”<br/>194.***.***.26 — — [23/Nov/2019:10:09:57 +0000] “GET /skin/api/v1/receipt HTTP/1.1” 404 18 “-” “curl/7.67.0”</span></pre><p id="6c0d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一切都很好，一切似乎都是正确的——一点问题都没有，嗯？</p><p id="85e4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">邮递员</strong></p><p id="b97b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但是现在，让我们使用Postman向同一个端点发送相同的请求:a <code class="fe le lf lg lh b">POST</code>通过HTTP触发并跟随重定向到HTTPS:</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/8a1d38290b9be905e779b53ab4b54ec8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UnP9wi59jJ5jNLNC.png"/></div></div></figure><p id="5711" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后呢。…</p><p id="b165" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在让我们来看看NGINX日志:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="5ae5" class="ln lo it lh b gy mu mv l mw mx">==&gt; /var/log/nginx/dev.poc.example.com-access.log &lt;==<br/>194.***.***.26 — — [23/Nov/2019:10:07:37 +0000] “POST /skin/api/v1/receipt HTTP/1.1” 400 58 “-” “curl/7.67.0”<br/>194.***.***.26 — — [23/Nov/2019:10:09:57 +0000] “GET /skin/api/v1/receipt HTTP/1.1” 404 18 “-” “curl/7.67.0”<br/>194.***.***.26 — — [23/Nov/2019:10:11:44 +0000] “GET /skin/api/v1/receipt HTTP/1.1” 404 18 “http://dev.poc.example.com/skin/api/v1/receipt" “PostmanRuntime/7.19.0”</span></pre><p id="f4c0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">呃…</p><p id="796e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">什么？！？</p><p id="a63e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但是我发送了一个明确指定的<code class="fe le lf lg lh b">POST</code>请求？</p><p id="487a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">再一次:</p><ol class=""><li id="2503" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">用<code class="fe le lf lg lh b">curl</code>做个请求，HTTP = &gt; HTTPS重定向发出，<code class="fe le lf lg lh b">POST</code>日志——都好</li><li id="d526" class="kv kw it jz b ka li ke lj ki lk km ll kq lm ku la lb lc ld bi translated">向邮递员发出请求，HTTP =&gt; HTTPS重定向已发出，但日志中的<code class="fe le lf lg lh b">GET</code>-<strong class="jz iu">WTF</strong>？？？</li></ol><h2 id="a1f2" class="ln lo it bd lp lq lr dn ls lt lu dp lv ki lw lx ly km lz ma mb kq mc md me mf bi translated">POST、GET和一个“丢失”的数据</h2><p id="9d3f" class="pw-post-body-paragraph jx jy it jz b ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku im bi translated">好了，现在我们可以知道我们的数据去了哪里——因为我们的<code class="fe le lf lg lh b">POST</code>变成了<code class="fe le lf lg lh b">GET</code>。</p><h2 id="c0f5" class="ln lo it bd lp lq lr dn ls lt lu dp lv ki lw lx ly km lz ma mb kq mc md me mf bi translated">根本原因、3xx重定向和HTTP RFC</h2><p id="f436" class="pw-post-body-paragraph jx jy it jz b ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku im bi translated">其实这两个问题都是同一个原因造成的。</p><p id="d622" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们通过阅读RFC 2616—<a class="ae my" href="https://tools.ietf.org/html/rfc2616#section-10.3.2" rel="noopener ugc nofollow" target="_blank">https://tools.ietf.org/html/rfc2616#section-10.3.2</a>中的<strong class="jz iu"> 301 </strong>代码描述开始我们的调查，尤其是它的<strong class="jz iu"> <em class="mz">注释</em> </strong>:</p><blockquote class="nf ng nh"><p id="aae8" class="jx jy mz jz b ka kb kc kd ke kf kg kh ni kj kk kl nj kn ko kp nk kr ks kt ku im bi translated">注意:当<br/>收到301状态码后自动重定向POST请求时，<strong class="jz iu">一些</strong>已有的HTTP/1.0 <strong class="jz iu">用户代理</strong> <br/> <strong class="jz iu">会错误地将其更改为GET请求</strong>。</p></blockquote><p id="760e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">即，一些客户端在发送<code class="fe le lf lg lh b">POST</code>和接收<em class="mz"> 301 </em>之后，会将请求的类型更改为<code class="fe le lf lg lh b">GET</code>。</p><p id="eb20" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但这仅仅是开始！</p><p id="37e0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在进一步阅读过程中，在同一个RFC 2016—<a class="ae my" href="https://tools.ietf.org/html/rfc2616#section-10.3.3" rel="noopener ugc nofollow" target="_blank">https://tools.ietf.org/html/rfc2616#section-10.3.3</a>中的<strong class="jz iu"> 302 </strong>代码描述处，我们会看到另一个<strong class="jz iu"> <em class="mz">注释</em> </strong>:</p><blockquote class="nf ng nh"><p id="f3f5" class="jx jy mz jz b ka kb kc kd ke kf kg kh ni kj kk kl nj kn ko kp nk kr ks kt ku im bi translated">注意:RFC 1945和RFC 2068规定<strong class="jz iu">客户端不允许</strong> <br/> <strong class="jz iu">改变重定向请求上的方法</strong>。然而，<strong class="jz iu">大多数</strong> <br/> <strong class="jz iu">现有用户代理</strong>实现<strong class="jz iu">将302视为303 </strong> <br/>响应，<strong class="jz iu">对位置字段值执行GET，而不管原始请求方法</strong>的 <br/> <strong class="jz iu">。添加了状态代码303和307<br/>,用于希望明确表明客户端期望哪种<br/>反应的服务器。</strong></p></blockquote><p id="1819" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu"> RFC 1945 </strong>关于<strong class="jz iu"> 3хх </strong>重定向—<a class="ae my" href="https://tools.ietf.org/html/rfc1945#section-9.3" rel="noopener ugc nofollow" target="_blank">https://tools.ietf.org/html/rfc1945#section-9.3</a></p><p id="617b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu"> RFC 2068 </strong>关于<strong class="jz iu"> 3хх </strong>重定向—<a class="ae my" href="https://tools.ietf.org/html/rfc2068#section-10.3.2" rel="noopener ugc nofollow" target="_blank">https://tools.ietf.org/html/rfc2068#section-10.3.2</a></p><p id="d8d7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">即RFC 1945和RFC 2068声明客户端没有重定向请求的变更类型，但它们中的大多数会将<strong class="jz iu"> 302 </strong>代码视为… <strong class="jz iu"> 303 </strong>！</p><p id="9033" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们进入下一部分，阅读关于<strong class="jz iu"> 303 </strong>代码—<a class="ae my" href="https://tools.ietf.org/html/rfc2616#section-10.3.4" rel="noopener ugc nofollow" target="_blank">https://tools.ietf.org/html/rfc2616#section-10.3.4</a>:</p><blockquote class="nf ng nh"><p id="5481" class="jx jy mz jz b ka kb kc kd ke kf kg kh ni kj kk kl nj kn ko kp nk kr ks kt ku im bi translated">对请求的响应可以在不同的URI和<br/> <strong class="jz iu">下找到，应该使用该资源上的<strong class="jz iu"> GET </strong>方法检索</strong>。</p></blockquote><p id="75a7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">即当客户端认为它收到了<strong class="jz iu"> 303 </strong>代码时，它<strong class="jz iu">总是</strong>会执行<strong class="jz iu"> GET </strong>。</p><p id="e7f1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，我们从Postman案例中看到了什么(以及我们最初遇到这个问题的移动应用程序客户端):</p><ol class=""><li id="6b62" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">客户端通过HTTP执行<code class="fe le lf lg lh b">POST</code></li><li id="2d61" class="kv kw it jz b ka li ke lj ki lk km ll kq lm ku la lb lc ld bi translated">用<em class="mz"> 301 </em>或<em class="mz"> 302 </em>获得到HTTPS的重定向</li><li id="7419" class="kv kw it jz b ka li ke lj ki lk km ll kq lm ku la lb lc ld bi translated">认为是<em class="mz"> 303 </em></li><li id="3847" class="kv kw it jz b ka li ke lj ki lk km ll kq lm ku la lb lc ld bi translated">并将自己通过HTTPS发送的请求类型从更改为<code class="fe le lf lg lh b">GET</code>，从而“丢失”所有原始数据</li></ol><h2 id="04ac" class="ln lo it bd lp lq lr dn ls lt lu dp lv ki lw lx ly km lz ma mb kq mc md me mf bi translated">解决方案</h2><p id="f2db" class="pw-post-body-paragraph jx jy it jz b ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku im bi translated">我在阅读了Mozilla的文档后找到了解决方案(尽管在针对302 的<a class="ae my" href="https://tools.ietf.org/html/rfc2616#section-10.3.3" rel="noopener ugc nofollow" target="_blank"> RFC 2016注释中有一个提示)，其中提到了关于<strong class="jz iu"> 301 </strong>和<strong class="jz iu"> 302 </strong>重定向:</a></p><blockquote class="nf ng nh"><p id="7d7d" class="jx jy mz jz b ka kb kc kd ke kf kg kh ni kj kk kl nj kn ko kp nk kr ks kt ku im bi translated">因此，建议仅将<strong class="jz iu"> 302代码设置为GET或HEAD </strong>方法的响应，并建议<strong class="jz iu">使用307临时重定向代替</strong>，因为在这种情况下，方法更改是明确禁止的。</p></blockquote><p id="44a2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">好的——让我们更新我们的NGINX并将代码<em class="mz"> 302 </em>改为<em class="mz"> 307 </em>:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="8bb4" class="ln lo it lh b gy mu mv l mw mx">server {<br/><br/>    listen 80;<br/>...<br/>    location / {<br/><br/>        # return 302 <a class="ae my" href="https://dev.poc.example.com$request_uri;" rel="noopener ugc nofollow" target="_blank">https://dev.poc.example.com$request_uri;</a><br/>        return 307 <a class="ae my" href="https://dev.poc.example.com$request_uri;" rel="noopener ugc nofollow" target="_blank">https://dev.poc.example.com$request_uri;</a> <br/>    }<br/>}<br/>...</span></pre><p id="fe4c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">重新加载配置，并重复来自<code class="fe le lf lg lh b">curl</code>的请求:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="4027" class="ln lo it lh b gy mu mv l mw mx">$ curl -L -X POST <a class="ae my" href="http://dev.poc.example.com/skin/api/v1/receipt" rel="noopener ugc nofollow" target="_blank">http://dev.poc.example.com/skin/api/v1/receipt</a> -d “{}”<br/>{“message”:”Validation failed: fields ‘hardware_id’ and ‘receipt’ are mandatory”}</span></pre><p id="9f58" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们从后端得到了一个有效的响应，现在只需要一个正常的数据。</p><p id="46e6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">重定向成功，收到了一个<code class="fe le lf lg lh b">POST</code>请求。</p><p id="a94c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">NGINX日志:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="13f9" class="ln lo it lh b gy mu mv l mw mx">==&gt; /var/log/nginx/dev.poc.example.com-access.log &lt;==<br/>194.***.***.26 — — [23/Nov/2019:10:07:37 +0000] “POST /skin/api/v1/receipt HTTP/1.1” 400 58 “-” “curl/7.67.0”<br/>194.***.***.26 — — [23/Nov/2019:10:09:57 +0000] “GET /skin/api/v1/receipt HTTP/1.1” 404 18 “-” “curl/7.67.0”<br/>194.***.***.26 — — [23/Nov/2019:10:11:44 +0000] “GET /skin/api/v1/receipt HTTP/1.1” 404 18 “http://dev.poc.example.com/skin/api/v1/receipt" “PostmanRuntime/7.19.0”<br/>194.***.***.26 — — [23/Nov/2019:10:35:51 +0000] “POST /skin/api/v1/receipt HTTP/1.1” 422 81 “-” “curl/7.67.0”<br/>194.***.***.26 — — [23/Nov/2019:10:36:00 +0000] “POST /skin/api/v1/receipt HTTP/1.1” 422 81 “-” “curl/7.67.0”</span></pre><p id="6e8b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">重复邮递员的请求:</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/2a7450ea31a5f1ffc9b8a03f0593355a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IfGTK1s48G2mukr4.png"/></div></div></figure><p id="628c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">NGINX日志:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="6817" class="ln lo it lh b gy mu mv l mw mx">==&gt; /var/log/nginx/dev.poc.example.com-access.log &lt;==<br/>194.***.***.26 — — [23/Nov/2019:10:07:37 +0000] “POST /skin/api/v1/receipt HTTP/1.1” 400 58 “-” “curl/7.67.0”<br/>194.***.***.26 — — [23/Nov/2019:10:09:57 +0000] “GET /skin/api/v1/receipt HTTP/1.1” 404 18 “-” “curl/7.67.0”<br/>194.***.***.26 — — [23/Nov/2019:10:11:44 +0000] “GET /skin/api/v1/receipt HTTP/1.1” 404 18 “http://dev.poc.example.com/skin/api/v1/receipt" “PostmanRuntime/7.19.0”<br/>194.***.***.26 — — [23/Nov/2019:10:35:51 +0000] “POST /skin/api/v1/receipt HTTP/1.1” 422 81 “-” “curl/7.67.0”<br/>194.***.***.26 — — [23/Nov/2019:10:36:00 +0000] “POST /skin/api/v1/receipt HTTP/1.1” 422 81 “-” “curl/7.67.0”<br/>194.***.***.26 — — [23/Nov/2019:10:37:57 +0000] “POST /skin/api/v1/receipt HTTP/1.1” 422 81 “http://dev.poc.example.com/skin/api/v1/receipt" “PostmanRuntime/7.19.0”</span></pre><p id="0aca" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一切正常，不出所料。</p><h2 id="2a55" class="ln lo it bd lp lq lr dn ls lt lu dp lv ki lw lx ly km lz ma mb kq mc md me mf bi translated">AWS应用程序负载平衡器重定向</h2><p id="2ff8" class="pw-post-body-paragraph jx jy it jz b ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku im bi translated">不幸的是，在使用AWS ALB时，我无法找到如何设置307:</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nl"><img src="../Images/4021e8362e2101eeffad29c7c1464083.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*R4a3SjCCN-fiw7uD.png"/></div></div></figure><p id="b81a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">就这些了，伙计们！</p><h2 id="f4ae" class="ln lo it bd lp lq lr dn ls lt lu dp lv ki lw lx ly km lz ma mb kq mc md me mf bi translated">有用的链接</h2><h2 id="273a" class="ln lo it bd lp lq lr dn ls lt lu dp lv ki lw lx ly km lz ma mb kq mc md me mf bi translated">其他网站上的问题</h2><ul class=""><li id="0a4b" class="kv kw it jz b ka mg ke mh ki nm km nn kq no ku ml lb lc ld bi translated"><a class="ae my" href="https://www.digitalocean.com/community/questions/post-request-redirects-to-get-in-nginx-proxy-and-nodejs" rel="noopener ugc nofollow" target="_blank"> POST请求重定向到Nginx代理和NodeJS </a></li><li id="7e85" class="kv kw it jz b ka li ke lj ki lk km ll kq lm ku ml lb lc ld bi translated"><a class="ae my" href="https://trac.nginx.org/nginx/ticket/248#comment:1" rel="noopener ugc nofollow" target="_blank">通过proxy_pass传递POST请求时出现问题</a></li><li id="348e" class="kv kw it jz b ka li ke lj ki lk km ll kq lm ku ml lb lc ld bi translated"><a class="ae my" href="https://www.ruby-forum.com/t/how-to-proxy-pass-post-with-headers/216170" rel="noopener ugc nofollow" target="_blank">如何代理_传递带标题的帖子</a></li><li id="586b" class="kv kw it jz b ka li ke lj ki lk km ll kq lm ku ml lb lc ld bi translated"><a class="ae my" href="https://serverfault.com/questions/482875/nginx-removes-content-length-header-for-chunked-content" rel="noopener ugc nofollow" target="_blank"> Nginx删除分块内容的内容长度头</a></li><li id="91fd" class="kv kw it jz b ka li ke lj ki lk km ll kq lm ku ml lb lc ld bi translated"><a class="ae my" href="https://trac.nginx.org/nginx/ticket/588" rel="noopener ugc nofollow" target="_blank">响应为302且内容长度为0的POST请求导致nginx崩溃</a></li><li id="4e8c" class="kv kw it jz b ka li ke lj ki lk km ll kq lm ku ml lb lc ld bi translated"><a class="ae my" href="https://www.hiawatha-webserver.org/forum/topic/1537" rel="noopener ugc nofollow" target="_blank">反向代理发布问题</a></li><li id="d79d" class="kv kw it jz b ka li ke lj ki lk km ll kq lm ku ml lb lc ld bi translated"><a class="ae my" href="https://stackoverflow.com/questions/58938233/http-post-redirect-no-content-length" rel="noopener ugc nofollow" target="_blank"> HTTP POST重定向—无内容长度</a></li></ul><h2 id="aeb3" class="ln lo it bd lp lq lr dn ls lt lu dp lv ki lw lx ly km lz ma mb kq mc md me mf bi translated">帮助找到了解决方案</h2><ul class=""><li id="6a84" class="kv kw it jz b ka mg ke mh ki nm km nn kq no ku ml lb lc ld bi translated"><a class="ae my" href="https://github.com/sindresorhus/got/issues/568" rel="noopener ugc nofollow" target="_blank"> POST请求不遵循301/ 302重定向</a></li><li id="fe75" class="kv kw it jz b ka li ke lj ki lk km ll kq lm ku ml lb lc ld bi translated"><a class="ae my" href="https://softwareengineering.stackexchange.com/questions/99894/why-doesnt-http-have-post-redirect#99966" rel="noopener ugc nofollow" target="_blank">HTTP为什么没有POST重定向？</a></li></ul></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="1651" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="mz">最初发布于</em> <a class="ae my" href="https://rtfm.co.ua/en/http-redirects-post-and-get-requests-and-lost-data/" rel="noopener ugc nofollow" target="_blank"> <em class="mz"> RTFM: Linux、DevOps和系统管理</em> </a> <em class="mz">。</em></p></div></div>    
</body>
</html>