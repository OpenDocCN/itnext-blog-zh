<html>
<head>
<title>Testing real world VueJs apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试真实世界VueJs应用</h1>
<blockquote>原文：<a href="https://itnext.io/testing-real-world-vuejs-apps-d3e44118f8ce?source=collection_archive---------0-----------------------#2018-10-07">https://itnext.io/testing-real-world-vuejs-apps-d3e44118f8ce?source=collection_archive---------0-----------------------#2018-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="49d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">演示如何对vue-hacken news-2.0进行单元测试(使用Jest和vue-test-utils)</p><p id="9b35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如今，像<a class="ae kl" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>或<a class="ae kl" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> VueJs </a>这样的现代库和像<a class="ae kl" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>或<a class="ae kl" href="https://www.cypress.io/" rel="noopener ugc nofollow" target="_blank"> Cypress.io </a>这样的测试工具允许我们以几年前不可能的方式测试我们的网络应用。然而，我们通常在网上找到的例子都太简单了，对于没有强大测试背景的前端开发人员来说，测试一个相对复杂的应用<strong class="jp ir">可能具有挑战性。</strong></p><p id="b884" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇<a class="ae kl" href="https://medium.com/js-dojo/end-to-end-testing-a-vuejs-hackernews-clone-23b9415fd5c5" rel="noopener">令人难以置信的帖子</a>中，<a class="km kn ep" href="https://medium.com/u/38e920770219?source=post_page-----d3e44118f8ce--------------------------------" rel="noopener" target="_blank">Gleb Bahmutov</a>(Cypress的开发人员之一)展示了用端到端测试覆盖一个最流行的VueJS示例(<a class="ae kl" href="https://github.com/vuejs/vue-hackernews-2.0" rel="noopener ugc nofollow" target="_blank"> VueJs HackerNews克隆</a>)是多么容易，他提出了这个问题:</p><blockquote class="ko"><p id="1c6b" class="kp kq iq bd kr ks kt ku kv kw kx kk dk translated">对这个应用进行单元测试的整个过程会充满痛苦和不幸吗？</p></blockquote><p id="6704" class="pw-post-body-paragraph jn jo iq jp b jq ky js jt ju kz jw jx jy la ka kb kc lb ke kf kg lc ki kj kk ij bi translated">我❤️了Cypress.io，并在我的项目中使用它来覆盖我的<strong class="jp ir">关键快乐路径</strong>和<strong class="jp ir">端到端测试</strong>，然而，我相信<strong class="jp ir">单元测试</strong>对于Real World前端应用程序也是必不可少的，因为它们帮助我们更好地理解和设计我们的应用程序，具有更快的<strong class="jp ir">反馈循环</strong>。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/e844aff9467f9fb658ba69a4d8d8937b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*DsqJmg0DSMSRCrAeru1_1A.gif"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">快速反馈循环对于无所畏惧地编码和重构至关重要</figcaption></figure><p id="cc55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想展示单元测试一个不平凡的VueJs应用程序并不是一件容易的事情，但是它给我们带来了很多好处，也很有趣😉</p><h1 id="0f95" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="4731" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">在这篇文章中，你将看到如何单元测试由<a class="km kn ep" href="https://medium.com/u/4f198f5f1f12?source=post_page-----d3e44118f8ce--------------------------------" rel="noopener" target="_blank">尤雨溪</a>制作的Vue.js <a class="ae kl" href="https://github.com/vuejs/vue-hackernews-2.0" rel="noopener ugc nofollow" target="_blank"> HackerNews </a>克隆，它使用vue-router &amp; vuex、<a class="ae kl" href="https://nuxtjs.org/" rel="noopener ugc nofollow" target="_blank"> nuxt </a>服务器端渲染和firebase后端。</p><p id="ef72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些是我们将在本帖中涉及的主要话题:</p><ul class=""><li id="0f68" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated">测试页面组件</li><li id="a4f5" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">使用假数据存根后端API</li><li id="714d" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">存根Vue路由器</li><li id="7079" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">测试与Vuex动作的交互</li><li id="4383" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">模拟nuxt asyncData挂钩</li></ul><p id="359c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里找到测试<a class="ae kl" href="https://github.com/agualis/vue-hackernews-2.0" rel="noopener ugc nofollow" target="_blank">的分叉回购。</a></p><h1 id="bd71" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">了解组件的输入和输出</h1><p id="57aa" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">如果我们把一个组件想象成一个有一些输入和一些输出的黑盒函数，我们可以<strong class="jp ir">试着从外部测试它而不访问它的内部</strong>，但是，哪一个是组件的<em class="nk">输入</em>？</p><ul class=""><li id="3f6c" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated">道具:我们可以传递参数作为道具</li><li id="e855" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated"><strong class="jp ir">路线</strong>:我们可以传递路线参数</li><li id="9f81" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated"><strong class="jp ir"> DOM </strong>:我们可以通过点击链接、填充输入或滚动页面来与UI交互</li><li id="ff61" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated"><strong class="jp ir"> VUEX存储</strong>:作为单点真值，组件可以访问该存储以获得它的一些<em class="nk">输入</em></li></ul><p id="205c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哪个是组件的<em class="nk">输出</em>？</p><ul class=""><li id="0cde" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated"><strong class="jp ir"> DOM: </strong>组件可以重新呈现它的UI，产生新的输出。</li><li id="a004" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated"><strong class="jp ir"> VUEX存储</strong>:组件可以调度带有突变的动作，这些动作将修改存储的状态(可见<em class="nk">输出</em>)。</li><li id="d944" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated"><strong class="jp ir"> Route </strong>:组件可以与路由器交互，生成一条新的路由，由新的页面组件呈现。</li></ul><p id="60c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理想情况下，我总是试图通过修改先前的<em class="nk">输入</em>并断言<em class="nk">输出的变化来测试我的组件。这样，我们的测试将更加独立于它的实现，因此，不那么脆弱。然而，在这篇文章中我们会看到，为了测试某些特性，我们无法避免访问被测组件的实现。</em></p><h1 id="f2cd" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">设置</h1><p id="dc0e" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">我假设你已经知道如何安装和设置<a class="ae kl" href="https://jestjs.io/docs/en/configuration.html" rel="noopener ugc nofollow" target="_blank"> jest </a>和<a class="ae kl" href="https://vue-test-utils.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> vue-test-utils </a>。</p><p id="3efe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我把这一行加到了<a class="ae kl" href="https://github.com/agualis/vue-hackernews-2.0/blob/master/package.json" rel="noopener ugc nofollow" target="_blank"> package.json </a>:</p><pre class="le lf lg lh gt nl nm nn no aw np bi"><span id="588a" class="nq lu iq nm b gy nr ns l nt nu">"test": "jest -c <strong class="nm ir">jest.config.js</strong>"</span></pre><p id="24db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">，这样我就可以用<strong class="jp ir"> npm test </strong>运行测试(你可以在<a class="ae kl" href="https://github.com/agualis/vue-hackernews-2.0/blob/master/jest.config.js" rel="noopener ugc nofollow" target="_blank"> jest.config.js </a>中检查jest设置)。</p><h1 id="1f63" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">制造假数据</h1><p id="76e9" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">HackerNews克隆定义了<a class="ae kl" href="https://github.com/vuejs/vue-hackernews-2.0/blob/master/src/api/index.js" rel="noopener ugc nofollow" target="_blank">一个API </a>，它从firebase数据库获取数据，但是<strong class="jp ir">我们不打算在组件的单元测试中测试这个API的内部。</strong> <strong class="jp ir">取而代之，我们要存根那个API </strong>。</p><h2 id="a6fb" class="nq lu iq bd lv nv nw dn lz nx ny dp md jy nz oa mh kc ob oc ml kg od oe mp of bi translated">我们如何得到存根的假数据？</h2><p id="a076" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">我只是执行了应用程序并保存了真实的响应，将它们存储为一个<a class="ae kl" href="https://github.com/agualis/vue-hackernews-2.0/blob/master/test/fake-news.json" rel="noopener ugc nofollow" target="_blank"> JSON文件</a>。这样我就可以创建这个<a class="ae kl" href="https://github.com/agualis/vue-hackernews-2.0/blob/master/test/fake-data.js" rel="noopener ugc nofollow" target="_blank">假数据文件</a>，导出我们将在测试中使用的常量，比如:</p><ul class=""><li id="1230" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated">60条黑客新闻列表</li><li id="e541" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">所有新闻的身份列表</li><li id="120e" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">赝品</li><li id="0219" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">假冒用户</li></ul><h1 id="47b5" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">清除后端API</h1><p id="5f7f" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">一旦我们有了合适的假数据，我们需要知道如何在测试中创建和使用API <strong class="jp ir">存根来替换真实的实现</strong>。</p><p id="d2b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">真正的<a class="ae kl" href="https://github.com/vuejs/vue-hackernews-2.0/blob/master/src/api/index.js" rel="noopener ugc nofollow" target="_blank"> api </a>使用firebase客户端/服务器和底层缓存，但我们对组件单元测试范围内的那些细节不感兴趣。我们需要做的就是理解api的公共契约，然后<strong class="jp ir">创建一个假的API来履行契约</strong>。</p><p id="f093" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，真正的api有一个<em class="nk"> fetchItem </em>函数，它接收一个id并查询数据库/缓存，<strong class="jp ir">返回一个带有项目的承诺。</strong>我们可以简单地用我们的假实现替换那个复杂的函数，该实现返回一个带有假用户的承诺:</p><pre class="le lf lg lh gt nl nm nn no aw np bi"><span id="7b47" class="nq lu iq nm b gy nr ns l nt nu">export function <strong class="nm ir">fetchItem</strong> (id) {<br/>  return Promise.resolve(fakeItemList[id])<br/>}</span></pre><h2 id="41c6" class="nq lu iq bd lv nv nw dn lz nx ny dp md jy nz oa mh kc ob oc ml kg od oe mp of bi translated">在我们的测试中注入假的api</h2><p id="149d" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">一旦我们<a class="ae kl" href="https://github.com/agualis/vue-hackernews-2.0/blob/master/src/api/__mocks__/fake-api.js" rel="noopener ugc nofollow" target="_blank">伪造了每一个API方法，</a>我们需要决定如何在测试中用伪造的方法替换真实的实现。</p><p id="cafe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以尝试改变现有应用的设计，以便能够显式地注入依赖关系，但我们希望保留原始的生产代码，因此我们需要使用一些<em class="nk">黑魔法</em>来替换我们测试中的整个API模块。</p><p id="29f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个常见的方法是使用<a class="ae kl" href="https://jestjs.io/docs/en/manual-mocks" rel="noopener ugc nofollow" target="_blank"> Jest manual mock </a> s，但是为了简化解释，我将例外地使用一个<em class="nk">更肮脏的伎俩</em>😅：</p><pre class="le lf lg lh gt nl nm nn no aw np bi"><span id="df0f" class="nq lu iq nm b gy nr ns l nt nu">//jest.config.js</span><span id="1fc0" class="nq lu iq nm b gy og ns l nt nu">...</span><span id="04db" class="nq lu iq nm b gy og ns l nt nu">"moduleNameMapper": {<br/>  "^@/(.*)$": "&lt;rootDir&gt;/src/$1",<br/><strong class="nm ir">  '../api': '&lt;rootDir&gt;/src/api/__mocks__/fake-api.js'<br/></strong>},</span><span id="f9f7" class="nq lu iq nm b gy og ns l nt nu">...</span></pre><p id="d7e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在前面的设置中，每个单元测试都将使用<a class="ae kl" href="https://github.com/agualis/vue-hackernews-2.0/blob/master/src/api/__mocks__/fake-api.js" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> fake-api.js </strong> </a>作为默认api，而不是使用生产🧙‍✨</p><h1 id="622d" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">我从哪里开始测试我的应用程序？</h1><p id="3312" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">作为一名TDD实践者，我更喜欢在实现之前编写我的测试，但是在这种情况下，我们想要测试一个<a class="ae kl" href="https://github.com/vuejs/vue-hackernews-2.0" rel="noopener ugc nofollow" target="_blank">现有的“遗留代码”</a>，所以第一步是理解它的主要部分。Vue HackerNews clone有3个主页:</p><ul class=""><li id="073e" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated"><strong class="jp ir"> ListView </strong>:有5个列表路径(top、new、show、ask、job)具有完全相同的结构</li><li id="3295" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated"><strong class="jp ir">项目视图</strong>:点击列表中的一个项目，打开该页面</li><li id="a2f5" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">当你点击一个作者链接时，这个页面被打开</li></ul><p id="4f56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前面的每一个页面都是一个<strong class="jp ir">根组件，当我们访问它的路径</strong>时，它会呈现页面。我称它们为<strong class="jp ir">页面组件</strong>，但是你也可以称它们为根、容器或视图组件。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi oh"><img src="../Images/0d56b0c12faffa6ef6709ad2dd9b52c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NISaA8JCzFS4-6tgaQLL8w.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">显示头条新闻的ListView页面组件示例</figcaption></figure><p id="d9d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我总是喜欢从上层(<em class="nk">页面组件</em>)测试我的应用程序的行为，并且我总是尽量避免嘲笑子组件。好处是:</p><ul class=""><li id="0e82" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated">您的测试的意图将更容易理解</li><li id="576a" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">当内部结构/实现改变时，你不需要改变你的测试，但是你的行为没有改变</li><li id="8150" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">它将引导你更好地理解你的内在组件之间的关系以及它们与外部世界的相互作用</li></ul><p id="4a4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们测试我们的第一个页面组件来理解我的意思。</p><h1 id="d5d9" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">我们的第一个测试</h1><p id="17f5" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">我们将从一个非常简单的页面组件开始，<a class="ae kl" href="https://github.com/vuejs/vue-hackernews-2.0/blob/master/src/views/UserView.vue" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">user view . vue</strong></a><strong class="jp ir">，</strong>就是通过这个途径打开的:</p><pre class="le lf lg lh gt nl nm nn no aw np bi"><span id="55a4" class="nq lu iq nm b gy nr ns l nt nu">{ path: '/user/<strong class="nm ir">:id</strong>', component: <strong class="nm ir">UserView</strong> }</span></pre><p id="2df8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该组件通过路由器参数接收用户的:id，并使用从Vuex存储中获取用户的计算属性对其进行呈现:</p><pre class="le lf lg lh gt nl nm nn no aw np bi"><span id="1cdf" class="nq lu iq nm b gy nr ns l nt nu">computed: {<br/>  <strong class="nm ir">user</strong> () {<br/>    return this.$store.state.<strong class="nm ir">users</strong>[this.$route.params.<strong class="nm ir">id</strong>]<br/>  }<br/>},</span></pre><p id="f6e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个呈现用户视图的示例:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi oi"><img src="../Images/6ef31ae0c7eb4652c616e068b2871801.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CLApslWpsLU4pNCNtu9XnQ.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">呈现的UserView.vue页面示例</figcaption></figure><h2 id="0594" class="nq lu iq bd lv nv nw dn lz nx ny dp md jy nz oa mh kc ob oc ml kg od oe mp of bi translated">识别用户视图组件的输入和输出</h2><p id="d593" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">正如我们所见，识别输入和输出对于理解我们想要测试的组件的“契约”是非常重要的。</p><p id="887d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">UserView.vue组件的输入？</p><ul class=""><li id="3793" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated"><strong class="jp ir">道具</strong>:该组件没有道具</li><li id="9494" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated"><strong class="jp ir">路由</strong>:我们将<strong class="jp ir">用户id </strong>作为路由参数传递</li><li id="5eb8" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">DOM  : UserView是一个简单的组件，我们不会在测试中与DOM交互。</li><li id="d40f" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated"><strong class="jp ir"> VUEX store </strong>:组件需要一个来自<strong class="jp ir"><em class="nk">store . state . users</em></strong><em class="nk">的用户。</em></li></ul><p id="923f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">UserView.vue组件的输出？</p><ul class=""><li id="43ff" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated"><strong class="jp ir"> DOM: </strong>显然，我们的组件会渲染它的UI。</li><li id="26bd" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated"><strong class="jp ir"> VUEX store </strong>:组件加载时调度FETCH_USER动作。</li><li id="89d1" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated"><strong class="jp ir">路线</strong>:我们的组件不生成新路线。</li></ul><h2 id="721d" class="nq lu iq bd lv nv nw dn lz nx ny dp md jy nz oa mh kc ob oc ml kg od oe mp of bi translated">设置Vuex商店:</h2><p id="aa17" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">我们需要一个干净的Vuex商店实例来测试我们的组件。我们可以用一个新的Vuex对象创建<a class="ae kl" href="https://vue-test-utils.vuejs.org/api/options.html#localvue" rel="noopener ugc nofollow" target="_blank">一个localVue实例</a>，但是我们的项目已经使用了<a class="ae kl" href="https://github.com/vuejs/vue-hackernews-2.0/blob/master/src/store/index.js" rel="noopener ugc nofollow" target="_blank"> createStore() </a>函数来初始化存储，我们将简单地从每个测试中调用它来拥有一个新的干净的存储。</p><h2 id="2471" class="nq lu iq bd lv nv nw dn lz nx ny dp md jy nz oa mh kc ob oc ml kg od oe mp of bi translated">嘲讽路线:</h2><p id="4549" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">我们的<em class="nk"> UserView.vue </em>组件需要一个带有<em class="nk"> :id </em>参数的路由。这就是为什么我们创建了一个构建器函数来从一个id创建一个假路径:</p><pre class="le lf lg lh gt nl nm nn no aw np bi"><span id="cee8" class="nq lu iq nm b gy nr ns l nt nu">const<strong class="nm ir"> userRoute</strong> = (id) =&gt; ({<br/> path: '/user',<br/> params: { id }<br/>})</span></pre><p id="d399" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用<a class="ae kl" href="https://vue-test-utils.vuejs.org/guides/using-with-vue-router.html" rel="noopener ugc nofollow" target="_blank"> vue-test-utils mock </a> s将该路径传递给被测组件:</p><pre class="le lf lg lh gt nl nm nn no aw np bi"><span id="c8a2" class="nq lu iq nm b gy nr ns l nt nu">// route will contain a route created with <strong class="nm ir">userRoute() </strong>builder<br/>const<strong class="nm ir"> </strong>wrapper = mount(UserView, { store, router,<br/>  mocks: {<br/>    <strong class="nm ir">$route: route</strong><br/>  }<br/>})</span></pre><h2 id="ed4c" class="nq lu iq bd lv nv nw dn lz nx ny dp md jy nz oa mh kc ob oc ml kg od oe mp of bi translated">我们的第一个断言</h2><p id="dc7d" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">我们终于拥有了编写第一个用户视图测试所需的一切:</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="9751" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们<strong class="jp ir">测试了我们的组件呈现包含h1标题的</strong> HTML，标题中有我们的假用户✅的id</p><h2 id="98db" class="nq lu iq bd lv nv nw dn lz nx ny dp md jy nz oa mh kc ob oc ml kg od oe mp of bi translated">测试Nuxt异步负载</h2><p id="d8a1" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">在我们之前的测试中，我们用一个假用户初始化了我们的<em class="nk"> store.state.users </em>，但是在现实世界中，这个用户将通过执行异步请求从API中获取，因此，如果我们希望它尽可能真实，我们需要改进我们的测试。</p><p id="33f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该项目使用<a class="ae kl" href="https://nuxtjs.org/guide/" rel="noopener ugc nofollow" target="_blank"> Nuxt </a>进行服务器端渲染，并使用一种特殊的钩子方法，称为<a class="ae kl" href="https://nuxtjs.org/api/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">【async data()</strong></a><strong class="jp ir">:</strong></p><pre class="le lf lg lh gt nl nm nn no aw np bi"><span id="9d8a" class="nq lu iq nm b gy nr ns l nt nu"><strong class="nm ir">asyncData</strong> ({ store, route: { params: { id }}}) {<br/>  return<strong class="nm ir"> </strong>store.dispatch('FETCH_USER', { id })<br/>},</span></pre><p id="c4d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们如何测试它？</p><p id="d5f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理想情况下，<strong class="jp ir">我们总是试图避免访问组件的内部，以避免将我们的测试耦合到实现上</strong>，但是，在这种情况下，这是我们唯一的选择，所以我们将使用<a class="ae kl" href="https://vue-test-utils.vuejs.org/api/wrapper/#properties" rel="noopener ugc nofollow" target="_blank"> vm属性</a>来调用我们的asyncData方法，并执行我们的测试的改进版本💪</p><p id="8a27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要等待Vue异步重新呈现DOM，因此我们将使用一个<strong class="jp ir">resolve promes</strong>函数来帮助我们。如果你对细节感兴趣，可以看看这篇<a class="ae kl" href="https://kentor.me/posts/testing-promise-all-side-effects-with-async-await/" rel="noopener ugc nofollow" target="_blank">精彩的文章</a>。</p><pre class="le lf lg lh gt nl nm nn no aw np bi"><span id="d189" class="nq lu iq nm b gy nr ns l nt nu">wrapper.vm.$options.<strong class="nm ir">asyncData</strong>({ store, route })<br/>await<strong class="nm ir"> </strong>resolvePromises()</span></pre><p id="2f9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们有了新的异步测试🚀：</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="oj ok l"/></div></figure><h2 id="68d7" class="nq lu iq bd lv nv nw dn lz nx ny dp md jy nz oa mh kc ob oc ml kg od oe mp of bi translated">测试过滤器</h2><p id="23e3" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">既然我们已经编写了第一个测试，我们还需要更多。例如，检查组件是否呈现自用户创建以来的天数、小时数或分钟数。该应用程序使用一个<em class="nk">时间前</em> <a class="ae kl" href="https://vuejs.org/v2/guide/filters.html" rel="noopener ugc nofollow" target="_blank"> Vue过滤器</a>来实现:</p><pre class="le lf lg lh gt nl nm nn no aw np bi"><span id="a318" class="nq lu iq nm b gy nr ns l nt nu">{{ user.created | <strong class="nm ir">timeAgo</strong> }} ago</span></pre><p id="55aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有的Vue过滤器都在<a class="ae kl" href="https://github.com/vuejs/vue-hackernews-2.0/blob/master/src/app.js" rel="noopener ugc nofollow" target="_blank"> app.js </a>中注册，代码如下:</p><pre class="le lf lg lh gt nl nm nn no aw np bi"><span id="ece7" class="nq lu iq nm b gy nr ns l nt nu">Object.keys(filters).forEach(key =&gt; {<br/>  <strong class="nm ir">Vue.filter</strong>(key, filters[key])<br/>})</span></pre><p id="85be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们如何测试这些全局注册的过滤器？</p><p id="d554" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在测试中没有调用app.js，但是，<strong class="jp ir"> jest允许我们创建一个设置文件</strong>(查看我们的<a class="ae kl" href="https://github.com/agualis/vue-hackernews-2.0/blob/master/src/jest-setup.js" rel="noopener ugc nofollow" target="_blank"> jest-setup.js </a>)，在这里我们可以初始化全局的东西，比如过滤器，这样我们就能够在我们的测试范围内使用它们。</p><p id="e16e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的过滤器测试将如下所示:</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="13c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中，知道我们的假用户是在9月7日创建的，我们将使用<strong class="jp ir"> Jest来删除Date.now并使测试独立于实时</strong>:</p><pre class="le lf lg lh gt nl nm nn no aw np bi"><span id="e2a5" class="nq lu iq nm b gy nr ns l nt nu">Date.now = <strong class="nm ir">jest.fn</strong>(() =&gt; nineOfSeptember)</span></pre><h2 id="09a5" class="nq lu iq bd lv nv nw dn lz nx ny dp md jy nz oa mh kc ob oc ml kg od oe mp of bi translated">测试调度的操作</h2><p id="0ccf" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">我们将Vuex动作确定为组件的可能输出(或副作用)之一，有时我们会隐式测试它们。</p><p id="4636" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，当我们在用户视图测试中调用<strong class="jp ir"> asyncData </strong> hook时，我们在那里执行这段代码:</p><pre class="le lf lg lh gt nl nm nn no aw np bi"><span id="7507" class="nq lu iq nm b gy nr ns l nt nu">asyncData ({ store, route: { params: { id }}}) {<br/>  return <strong class="nm ir">store.dispatch</strong>('FETCH_USER', { id })<br/>},</span></pre><p id="f2b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们正在隐式测试FETCH_USER操作是否被正确调度。</p><p id="5d24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要显式地测试它吗？这要视情况而定，但是随着我们的应用程序的增长，我们将倾向于依赖于更多外部服务的更复杂的操作，接收更难理解的更复杂的有效负载，所以<strong class="jp ir">我发现一个好主意来测试我们的组件与Vuex store的交互</strong>，或者甚至在我们的组件的单元测试范围内取消dispatch方法，并在另一种集成测试中测试操作的实现。</p><p id="8324" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个例子，说明检查我们的<em class="nk"> UserView.vue </em>分派一个动作(<strong class="jp ir">使用jest.spyOn来验证交互</strong>)是多么容易:</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="oj ok l"/></div></figure><h1 id="0679" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">测试更多组件</h1><p id="51ed" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">按照前面的提示，我们准备测试页面组件的其余部分。例如，这里有对ItemView.vue组件的测试:</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="9662" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者我们甚至可以测试更复杂的东西。例如，当某个项目被实时添加到列表中时会发生什么:</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="e64c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里是回购协议，你可以在这里查看演示测试的所有细节。</p><h1 id="4f8f" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">未来的步骤</h1><p id="f6d9" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">我们已经在<a class="ae kl" href="https://martinfowler.com/articles/practical-test-pyramid.html" rel="noopener ugc nofollow" target="_blank">测试金字塔</a>中看到了一些最重要的测试示例，但我不会在此结束。</p><h2 id="04cc" class="nq lu iq bd lv nv nw dn lz nx ny dp md jy nz oa mh kc ob oc ml kg od oe mp of bi translated">内部组件</h2><p id="aafe" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">正如我们看到的，我喜欢从上层测试我的应用程序，我试图覆盖最相关的情况，我需要检查我的功能。但是我并不试图从外部覆盖所有可能的情况，因此，测试内部组件也很重要，因为您可以很容易地测试所有的边缘情况。例如，getters、filters或presentational组件很容易用真正简单的隔离测试来测试。</p><h2 id="d09f" class="nq lu iq bd lv nv nw dn lz nx ny dp md jy nz oa mh kc ob oc ml kg od oe mp of bi translated">复杂的DOM交互</h2><p id="381c" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">随着我们真正的应用程序的增长，我们会发现更多的挑战，我们需要改进我们目前的测试。例如，HackerNews应用程序是一个只读应用程序，用户不能在其中创建内容，但在更大的应用程序中，通常会有复杂的表单，用户可以与DOM交互，以许多复杂的方式生成状态更改和副作用。在那种情况下，<strong class="jp ir">我总是使用</strong> <a class="ae kl" href="https://martinfowler.com/bliki/PageObject.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">页面对象模式</strong> </a> <strong class="jp ir">来减少我们的单元测试与html/css实现的耦合。</strong></p><h2 id="f07c" class="nq lu iq bd lv nv nw dn lz nx ny dp md jy nz oa mh kc ob oc ml kg od oe mp of bi translated">测试后端API的实现</h2><p id="ccbc" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">在这篇文章中，我们看到了如何模拟后端API，忘记了它在组件的单元测试中的实现，但是，我也会对该实现进行单元测试(主要是缓存)，例如，通过使用firebase存根(我们可以手动存根，或者使用类似于<a class="ae kl" href="https://github.com/soumak77/firebase-mock" rel="noopener ugc nofollow" target="_blank"> firebase-mock </a>的工具)。</p><p id="19a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还会添加一些<a class="ae kl" href="https://martinfowler.com/bliki/ContractTest.html" rel="noopener ugc nofollow" target="_blank">契约测试</a>来测试与真实firebase实例的集成是否有效。</p><h1 id="e413" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">结论</h1><p id="c66d" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">对真正的VueJs应用进行单元测试可能具有挑战性，因为我们需要了解良好的设计和测试实践，我们需要控制我们的工具(jest、vue-test-utils……)，我们还需要发挥创造力来克服某些障碍。</p><p id="3dfb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">拥有像Cypress这样的工具来进行端到端测试是一件幸事，但我认为我们永远不能忘记单元测试，因为它们对于改进我们的应用程序设计、我们的库/框架知识以及编码的乐趣是必不可少的。单元测试万岁！</p></div><div class="ab cl ol om hu on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ij ik il im in"><p id="c548" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我目前在<a class="ae kl" href="https://www.sennder.com/" rel="noopener ugc nofollow" target="_blank">sender</a>工作，我们正在寻找一名有才华的VueJs开发人员！(远程可能！)如果你有兴趣，就发邮件到konstantin.schubert@sennder.com的<a class="ae kl" href="mailto:konstantin.Schubert@sennder.com" rel="noopener ugc nofollow" target="_blank"> <br/>或者查看我们的职位描述</a><a class="ae kl" href="https://sennder.heavenhr.com/jobs/_IhTF1F63_D5JV7aBlW4XZg_/apply?language=en" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>