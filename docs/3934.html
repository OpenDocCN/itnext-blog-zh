<html>
<head>
<title>Cross-compile Rust programs to run on Turris Omnia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">交叉编译Rust程序以在Turris Omnia上运行</h1>
<blockquote>原文：<a href="https://itnext.io/cross-compile-rust-programs-to-run-on-turris-omnia-e592b555e2aa?source=collection_archive---------5-----------------------#2020-03-27">https://itnext.io/cross-compile-rust-programs-to-run-on-turris-omnia-e592b555e2aa?source=collection_archive---------5-----------------------#2020-03-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0040febddbdaf4e10041a24e02adcfb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LmXJNEKzvFU1hH9B6KH3EQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Rust遇到Omnia。Rust徽标归Mozilla所有，并在4.0版的CC下获得许可。</figcaption></figure><p id="30bb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在我之前的<a class="ae ld" href="https://medium.com/@bajtos/how-to-run-unifi-controller-on-turris-omnia-f9c178594bff" rel="noopener">博客文章</a>中，我描述了如何使用LXC容器在Turris Omnia上运行任意的Ubuntu包。虽然易于配置，但我发现这样的设置相当浪费。我不想在我的路由器上运行另一个完整的Linux发行版来运行小型(家庭)自动化程序。</p><p id="866b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们还有其他选择吗？</p><ul class=""><li id="eb36" class="le lf it kh b ki kj km kn kq lg ku lh ky li lc lj lk ll lm bi translated">用Python写程序。Turris OS附带了Python 2.7版本，许多管理工具也是用Python编写的。然而，我从未爱上Python，而且它是一种带有垃圾收集器的高级解释语言——也不是最有效的选择🤷‍♂️</li><li id="0c92" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated">使用C或C++等低级语言，并为Turris交叉编译程序。事实证明，交叉编译很容易设置，我们可以用最低的内存使用获得最佳性能。但是，只要我们不引入内存泄漏，或者在访问已经释放回来的内存时使进程崩溃🙈(更不用说安装第三方依赖项的复杂性了，因为C/C++没有包管理器。)</li><li id="6170" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated">使用<a class="ae ld" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank"> Rust </a>来获得两个世界的最佳效果:像Python这样的高级语言的生产力和可靠性以及像C这样的低级语言的性能💪</li></ul><p id="6407" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们来看看锈道。要在Turris上运行Rust程序，我们需要:</p><ol class=""><li id="dea0" class="le lf it kh b ki kj km kn kq lg ku lh ky li lc ls lk ll lm bi translated">找到路由器硬件使用的平台，这将是交叉编译的目标。</li><li id="337b" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc ls lk ll lm bi translated">安装交叉编译构建工具，验证我们可以交叉编译一个简单的C程序，并在路由器上运行。</li><li id="4211" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc ls lk ll lm bi translated">安装Rust并设置交叉编译，验证我们可以交叉编译一个简单的Rust程序并在路由器上运行它。</li></ol><p id="b0c3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="lt">注意:以下说明适用于Ubuntu 18.04 LTS版。我正在使用</em><a class="ae ld" href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" rel="noopener ugc nofollow" target="_blank"><em class="lt">Linux的Windows子系统</em> </a> <em class="lt">在我的Windows机器上运行Ubuntu。</em></p><h1 id="371f" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">找到目标平台🕵️‍♂️</h1><p id="4054" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">交叉编译目标通常表示为以下格式的三元组:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="7af4" class="ng lv it nc b gy nh ni l nj nk">{architecture}-{vendor}-{system}-{abi}</span></pre><p id="1cad" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们已经知道Turris Omnia的处理器有ARMv7架构。对于Linux系统，供应商通常是<code class="fe nl nm nn nc b">unknown</code>,因为哪个供应商创建了发行版并不重要。最后缺失的部分是什么ABI(应用二进制接口)是Turris操作系统使用？在Linux上，这指的是libc实现，您可以通过<code class="fe nl nm nn nc b">ldd --version.</code>找到它</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="4b20" class="ng lv it nc b gy nh ni l nj nk">$ ssh root@192.168.1.1 "ldd --version"<br/>musl libc (armhf)<br/>Version 1.1.19<br/>Dynamic Program Loader<br/>Usage: ldd [options] [--] pathname</span></pre><p id="4263" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Turris Omnia的三重目标是<code class="fe nl nm nn nc b">armv7-unknown-linux-musleabihf</code>，对我们来说幸运的是，这个目标得到了Rust作为<a class="ae ld" href="https://forge.rust-lang.org/release/platform-support.html#tier-2" rel="noopener ugc nofollow" target="_blank">二级平台</a>的支持:</p><blockquote class="no np nq"><p id="4c11" class="kf kg lt kh b ki kj kk kl km kn ko kp nr kr ks kt ns kv kw kx nt kz la lb lc im bi translated">第二层平台可以被认为是“保证要建造的”。自动化测试没有运行，所以不能保证产生一个工作的构建，但是平台通常工作得很好，补丁总是受欢迎的！</p></blockquote><h1 id="0bd2" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">设置c交叉编译器⚙</h1><p id="1582" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">在开始之前，让我们确保安装了常规的构建工具。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="3026" class="ng lv it nc b gy nh ni l nj nk">$ sudo apt-get install build-essential</span></pre><p id="1a99" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，如果我们的目标是<code class="fe nl nm nn nc b">gnueabihf</code>而不是<code class="fe nl nm nn nc b">musleabihf</code>，我们的任务会简单得多，因为Ubuntu为<code class="fe nl nm nn nc b">gnueabihf</code>目标提供了带有交叉编译工具链的包。<a class="ae ld" href="https://www.musl-libc.org/" rel="noopener ugc nofollow" target="_blank"> MUSL </a>对我来说有点神秘，我对这种风格的标准C库几乎一无所知。</p><p id="7dd9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">幸运的是，有一个名为<a class="ae ld" href="https://github.com/richfelker/musl-cross-make" rel="noopener ugc nofollow" target="_blank"> musl-cross-make </a>的项目提供了一个<em class="lt">“基于makefile的musl cross compiler的简单构建”</em>,并且它非常有效！首先从GitHub下载源代码:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="4a74" class="ng lv it nc b gy nh ni l nj nk">$ wget https://github.com/richfelker/musl-cross-make/archive/master.tar.gz<br/>$ tar xzf master.tar.gz<br/>$ cd musl-cross-make-master</span></pre><p id="22d6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在开始构建之前，让我们调整一些配置选项。将配置模板文件<code class="fe nl nm nn nc b">config.mak.dist</code>复制到<code class="fe nl nm nn nc b">config.mak</code>，设置以下选项(可以取消模板提供的相关行的注释):</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="5200" class="ng lv it nc b gy nh ni l nj nk">TARGET=arm-linux-musleabihf<br/>OUTPUT=/usr/local<br/>MUSL_VER = 1.1.19</span></pre><p id="c457" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">(最好在你的Turris上使用与<code class="fe nl nm nn nc b">ldd --version</code>报道的相同的MUSL版本。我的是<code class="fe nl nm nn nc b">1.1.19</code>写的时候。)</p><p id="6d37" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">建造时间！</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="572c" class="ng lv it nc b gy nh ni l nj nk">$ make<br/>$ make install</span></pre><p id="da69" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，我们应该在<code class="fe nl nm nn nc b">/usr/local</code>中安装好所有工具，因此在<code class="fe nl nm nn nc b">PATH</code>中也可以使用。让我们运行gcc来验证:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="4fe7" class="ng lv it nc b gy nh ni l nj nk">$ arm-linux-musleabihf-gcc --version<br/>arm-linux-musleabihf-gcc (GCC) 9.2.0<br/>Copyright (C) 2019 Free Software Foundation, Inc.<br/>(...)</span></pre><h1 id="ddd4" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">交叉编译C程序🌍</h1><p id="69ae" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">到目前为止，我们有一个与Turris平台匹配的目标三联体的假设。现在是时候在实践中验证我们的假设了。</p><p id="a7d7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">用C编写一个简单的“Hello world”程序——将下面的代码保存到一个名为<code class="fe nl nm nn nc b">hello.c</code>的文件中:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="f5fe" class="ng lv it nc b gy nh ni l nj nk">#include &lt;stdio.h&gt;<br/>int main() {<br/>   printf("Hello, World!\n");<br/>   return 0;<br/>}</span></pre><p id="23e4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为Turris交叉编译这个程序:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="b9dd" class="ng lv it nc b gy nh ni l nj nk">arm-linux-musleabihf-gcc hello.c -o hello</span></pre><p id="e40c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">将程序上传到路由器并在那里执行。我将文件存储在<code class="fe nl nm nn nc b">/srv</code>中，它由mSATA SSD驱动器支持，以避免对内部闪存进行不必要的写入。如果一切顺利，你会得到熟悉的问候。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="aa6a" class="ng lv it nc b gy nh ni l nj nk">$ scp hello root@192.168.1.1:/srv<br/>hello                                 100% 7292     1.6MB/s   00:00<br/>$ ssh root@192.168.1.1 /srv/hello<br/>Hello, World!</span></pre><h1 id="f3f6" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">安装Rust并设置交叉编译🏎</h1><p id="314d" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">安装Rust有不同的方法，我决定使用基于<code class="fe nl nm nn nc b">rustup</code>的推荐方法。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="1e51" class="ng lv it nc b gy nh ni l nj nk">$ curl https://sh.rustup.rs -sSf | sh</span></pre><p id="5b19" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们还需要为我们的目标平台安装交叉编译的标准板条箱(Rust core模块)。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="489c" class="ng lv it nc b gy nh ni l nj nk">$ rustup target add armv7-unknown-linux-musleabihf</span></pre><p id="b718" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后一步，我们告诉Rust编译器在为我们的目标平台编译时使用哪个链接器。将以下部分添加到<code class="fe nl nm nn nc b">~/.cargo/config</code>:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="b126" class="ng lv it nc b gy nh ni l nj nk">[target.armv7-unknown-linux-musleabihf]<br/>linker = "arm-linux-musleabihf-gcc"</span></pre><h1 id="409d" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">交叉编译Rust程序🎉</h1><p id="17f3" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">在Rust中创建一个“Hello world”程序并编译它:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="c80d" class="ng lv it nc b gy nh ni l nj nk">$ cargo new --bin hello<br/>$ cd hello<br/>$ cargo build --target=armv7-unknown-linux-musleabihf<br/>   Compiling hello v0.1.0 (/home/bajtos/src/hello)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 2.53s</span></pre><p id="f328" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">将程序上传到路由器并在那里执行。如果一切顺利，你应该会再次收到同样的问候。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="f3c7" class="ng lv it nc b gy nh ni l nj nk">$ scp target/armv7-unknown-linux-musleabihf/debug/hello root@192.168.1.1:/srv<br/>hello                                  100% 2903KB  10.8MB/s   00:00 $ ssh root@129.168.1.1 /srv/hello<br/>Hello, World!</span></pre><p id="e563" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">恭喜你，现在你可以在你的Turris Omnia路由器上运行任何Rust程序了。例如，如果您使用的是乳齿象和Twitter，您可以使用乳齿象-twitter-sync在这两个网络之间同步您的帖子:</p><div class="nu nv gp gr nw nx"><a href="https://github.com/klausi/mastodon-twitter-sync/" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">克劳斯/乳齿象-推特-同步</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">这个工具可以同步乳齿象和Twitter之间的帖子。不管你把你的东西贴在哪里，它都会…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">github.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol jz nx"/></div></div></a></div><h1 id="f93c" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">学分和参考🙇‍♂️</h1><p id="99ee" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">这篇博文中的很多信息都是基于下面这篇关于交叉编译Rust程序的很棒的指南。谢谢，<a class="ae ld" href="https://github.com/japaric" rel="noopener ugc nofollow" target="_blank">豪尔赫·阿帕里西奥</a>！</p><div class="nu nv gp gr nw nx"><a href="https://github.com/japaric/rust-cross/blob/master/README.md" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">日本/锈十字</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">关于交叉编译Rust程序你需要知道的一切！如果你想把你的生锈工具链设置成十字…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">github.com</p></div></div><div class="og l"><div class="om l oi oj ok og ol jz nx"/></div></div></a></div><p id="d037" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Rust支持的平台列表可以在以下官方项目文档中找到:</p><div class="nu nv gp gr nw nx"><a href="https://forge.rust-lang.org/release/platform-support.html" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">防锈平台支架</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">Rust编译器可以在很多平台上运行并编译，尽管不是所有的平台都一样…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">forge.rust-lang.org</p></div></div></div></a></div><p id="e466" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后，如果没有里奇·费尔克出色的musl-cross-make项目，我要花很长时间才能弄清楚如何为MUSL·ABI进行交叉编译。</p><div class="nu nv gp gr nw nx"><a href="https://github.com/richfelker/musl-cross-make" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">richfelker/musl-cross-make</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">这是第二代musl-cross-make，一种快速、简单但先进的基于makefile的制作方法…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">github.com</p></div></div><div class="og l"><div class="on l oi oj ok og ol jz nx"/></div></div></a></div><h1 id="0a9f" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">附言</h1><p id="8dea" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">你有没有注意到我们的C程序有7kB，而Rust版本有2903kB？有几个窍门可以减少Rust程序的可执行大小。通过启用链接时间优化，我能够将发布版本的大小快速减少到1408kB。您可以在<em class="lt">“最小化Rust二进制大小”</em>中了解更多高级技术:</p><div class="nu nv gp gr nw nx"><a href="https://github.com/johnthagen/min-sized-rust" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">约翰哈根/最小尺寸-铁锈</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">这个库演示了如何最小化Rust二进制文件的大小。默认情况下，Rust会优化…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">github.com</p></div></div></div></a></div></div></div>    
</body>
</html>