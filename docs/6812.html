<html>
<head>
<title>Node.js is terrible for data processing pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js对于数据处理管道来说很糟糕</h1>
<blockquote>原文：<a href="https://itnext.io/node-js-is-terrible-for-data-processing-pipelines-fe74ee2fd258?source=collection_archive---------1-----------------------#2022-03-08">https://itnext.io/node-js-is-terrible-for-data-processing-pipelines-fe74ee2fd258?source=collection_archive---------1-----------------------#2022-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8687d1cc0bd94c3a5cf32c334d3efecf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zCcsEzqadYTbrewbRtHvbA.png"/></div></div></figure><p id="ce1b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">说到数据处理，就像我们在<a class="ae kz" href="https://blockpulsar.com" rel="noopener ugc nofollow" target="_blank">blockpulsar.com</a>所做的那样，它通常被称为一个以特定格式加载数据，将数据转换成不同的结构，然后返回的函数。这里的逻辑非常简单。有时它如此简单，以至于你认为它会执行得很快，因为它所做的只是改变一个字段的名称或删除一些字段。实际上，所有这些操作都是同步的，如果您同时进行数据转换操作，这将会占用大量CPU资源。</p><p id="a367" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Node.js非常擅长处理异步任务，因为JavaScript的事件循环可以执行一些同步操作，同时等待异步函数返回结果。例如，当您有一个与Node.js服务器的数据库连接，并且您进行一个异步查询以从中获取一些数据时，您的Node.js应用程序有可能执行代码的其他部分。同时，它等待数据库的响应。这使得处理太多的同步操作非常具有挑战性，因为每个同步操作都会阻塞整个过程。甚至异步功能也会被阻塞，直到同步操作完成。</p><p id="d3cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个问题在使用Node.js的相对简单的Web服务中经常出现，这些服务提供简单的JSON响应。最终，当请求越来越多时，Node.js开始变得越来越慢，因为JSON编码和解码对于JavaScript来说是相当繁重的同步操作。</p><h1 id="18a7" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">JSON解析/字符串性能(慢！)</h1><p id="2df5" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">这是JavaScript引擎最常见的性能问题，因为它是一个同步操作，我们在Node.js执行期间经常使用它。因此，如果您还没有处理Node.js中的JSON解析/字符串性能问题，那么您还没有一个高性能的应用程序😃</p><p id="41a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这并不是说它超级慢，它只是阻塞了整个过程，如果您有许多对象要解析或字符串化，最终会延迟您的异步方法，如从DB获取数据或响应HTTP请求。</p><p id="b9cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有一些使用工作线程使JSON解析和字符串化的方法，但是代码感觉非常Node。我承认这仍然是可行的，我曾经这样做过，但是它使生产和当地发展变得复杂。</p><h1 id="f30b" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">在JS中滥用对象复制/传播。</h1><p id="e233" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">假设你已经用C++、Rust、甚至Go等其他低级编程语言做过一些编码(不是低级，而是……)。在这种情况下，您会记得从一个函数到另一个函数复制内存会导致性能下降。这就是为什么大多数开发人员在这些语言中使用指针，他们直接使用引用来改变变量。</p><p id="6afd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我承认，有一条严格的规则，即不改变函数内部的函数参数，适合于代码维护。尽管如此，每次您将一个对象作为给定对象的扩展返回时，JS引擎都会复制内存，然后删除旧的内存，这当然会导致更多的同步操作。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="afe9" class="mm lb it mi b gy mn mo l mp mq">// Not that performant, but good for code readability<br/>function processData(data: Object) {<br/>  return { ...data, changedField: 100};<br/>}</span><span id="95f6" class="mm lb it mi b gy mr mo l mp mq">// Terrible for code maintanence, but works faster<br/>function processData(data: Object) {<br/>  data.changedField = 100;<br/>  return data;<br/>}</span></pre><p id="fc13" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们一直遵循Eslint的规则，最终，随着时间的推移，对象扩散/复制成为了真正的性能瓶颈。</p><h1 id="2274" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Docker图像大小(1GB+)</h1><p id="5ef5" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">你可能会想，为什么我们甚至在谈论Docker图像大小，它与数据处理无关，但它实际上是！拥有ETL数据处理系统的关键是根据数据量尽可能快地伸缩，尤其是在第一次数据接收期间，这里有一个对时间敏感的首次同步。但是有一个真正的应用程序太重了，它装满了一个容器。</p><p id="b3ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一些node-exec库试图将Node.js转换成一个二进制文件，并多次使用。很难管理和跟上其他模块，因为不是所有的支持都与node _ moduels文件夹本身分开。如果您正在构建一些简单的Web API，这是可以的。在数据处理管道中，你通常会尝试使用带有二进制依赖的数据库驱动程序，这样会很容易出错。</p><h1 id="c175" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">那么，解决办法是什么？</h1><p id="839f" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在<a class="ae kz" href="https://blockpulsar.com" rel="noopener ugc nofollow" target="_blank">blockpulsar.com</a>，我们切换到Golang和C++，因为编写合适的JS代码同步操作优化太难了。我们仍然将Node.js作为我们领先的Web应用程序API服务，因为有这么多优秀的库来处理Web集成，如果用其他后端技术来做，将会非常耗时。</p><p id="1b48" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">并行处理是我们为数据处理管道系统改用另一种语言的主要原因。带有工作线程的Node.js比单个常规进程多消耗大约10倍的内存，这使我认为我们没有按照设计的方式使用Node.js。</p><p id="3ce8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们得到了令人震惊的好性能结果和小于20MB的容器映像，其中我们只保存一个静态编译的二进制文件。当然，编码需要更多的时间，尤其是在最初，但是如果你打算将数据处理时间从10秒降低到500毫秒，这就是优化的方法。</p><h1 id="917c" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="1077" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">Node.js非常适合作为Web API运行，但是当您面临繁重的数据处理负载时，它将会非常吃力。一般来说，Node.js和JavaScript有很多库和社区项目，所以用Node.js编写项目更令人愉快，但根据项目类型的不同，它可能不太适合</p><p id="703c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您喜欢这篇文章，请让我知道您在生产中是如何与Node抗争的😃</p></div></div>    
</body>
</html>