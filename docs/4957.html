<html>
<head>
<title>Bonjour: How to Stream Data in 2 Easy Steps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Bonjour:如何通过两个简单的步骤传输数据</h1>
<blockquote>原文：<a href="https://itnext.io/bonjour-how-to-stream-data-in-2-easy-steps-f335bded87?source=collection_archive---------6-----------------------#2020-11-02">https://itnext.io/bonjour-how-to-stream-data-in-2-easy-steps-f335bded87?source=collection_archive---------6-----------------------#2020-11-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3c24" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用流从一台设备向下一台设备发送数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4184fc9ec37a7d44a058bc77416b3605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MYmjWO6XrIFvrDbDHorziQ.png"/></div></div></figure><p id="65e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最近在另一篇文章中，我开始讲述我进入一个不是每个人都会去的世界的旅程。网络和数据流的世界。在第一篇文章中，我们介绍了如何利用一个简单易用的工具Bonjour来处理这种情况。</p><p id="41c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们必须认真对待将数据从一个设备转移到另一个设备的严肃事务。<strong class="kw iu">我不想撒谎，这并没有你想象的那么难。</strong></p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="da60" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有那篇文章的链接，所以你可以在开始阅读这篇文章之前先读一读:<a class="ae lx" href="http://Figure out the IP of the device receiving the data. Establish a connection with it. Send data." rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">【你好:网络发现简单易行】</strong> </a> <strong class="kw iu">。</strong></p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="cbc3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简单回顾一下。<strong class="kw iu">为了实现这一目标，我们之前定义了需要遵循的3个步骤。</strong>这些步骤如下:</p><ol class=""><li id="3e76" class="ly lz it kw b kx ky la lb ld ma lh mb ll mc lp md me mf mg bi translated"><em class="mh">算出接收数据的设备的IP。</em></li><li id="366b" class="ly lz it kw b kx mi la mj ld mk lh ml ll mm lp md me mf mg bi translated"><strong class="kw iu">与其建立联系。</strong></li><li id="5a80" class="ly lz it kw b kx mi la mj ld mk lh ml ll mm lp md me mf mg bi translated"><strong class="kw iu">发送数据。</strong></li></ol><p id="2d9e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">我们已经完成了第一步，使用</strong> <a class="ae lx" href="https://developer.apple.com/documentation/foundation/netservice" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">网络服务</strong> </a> <strong class="kw iu">和</strong> <a class="ae lx" href="https://developer.apple.com/documentation/foundation/netservicebrowser" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">网络服务浏览器</strong> </a> <strong class="kw iu">发布并查找同一网络内的设备</strong>。我们可以连接的设备，并希望在它们之间传递数据。这使得第二步和第三步悬而未决。我会尽我所能展示我是如何完成这些部分的。</p><p id="107e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在对实现这些步骤的不同方法进行了数小时的研究并在网上看到了许多不同的资源后，我发现很少有利用第三方解决方案的。而是依靠第三方框架来完成繁重的工作。我有意识地选择只使用苹果公司提供的工具和框架。记住这一点，让我们来解决第2步。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="287a" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated"><strong class="ak"> 2。与其建立连接</strong></h1><p id="0212" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated"><strong class="kw iu">我要用来解决这个问题的是</strong><a class="ae lx" href="https://developer.apple.com/documentation/foundation/urlsession" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">URLSession</strong></a><strong class="kw iu">。</strong>惊讶？我敢打赌你是。在很大程度上，我可以有把握地假设，正如我直到最近也一直这样做的那样，你们中的许多人只是使用URLSession与后端进行日常交互。这意味着您知道通过使用URLSession，您必须创建一个<a class="ae lx" href="https://developer.apple.com/documentation/foundation/urlsessiontask" rel="noopener ugc nofollow" target="_blank"> URLSessionTask </a>。有许多类型的任务:数据，下载，上传等。<strong class="kw iu">我们有兴趣使用</strong><a class="ae lx" href="https://developer.apple.com/documentation/foundation/urlsessionstreamtask" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">URLSessionStreamTask</strong></a><strong class="kw iu">。</strong></p><p id="d748" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">流任务为我们提供了一个进行TCP/IP连接的接口。<strong class="kw iu">要创建这个任务，我们有两个选择:使用主机名和端口来连接，或者我们可以直接使用网络服务。</strong>记住，当我们使用网络服务浏览器时，我们寻找网络服务。所以我们手头有所有这些值，可以使用其中任何一个。</p><p id="6e40" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们来做个区分。我们将拥有一台主机设备和一台客户机。主机是发布服务的一方，客户机是寻找服务并随后请求连接服务的一方。这是一张示意图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/18dc5c20da2aba07e6d8738cb75a70cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VnNqzg41mn-ttFOJ6pOvIA.png"/></div></div></figure><p id="3ae4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们在第一步结束时给自己定位。我们在客户端设备上的服务浏览器已经找到了由主机发布的服务。</p><p id="9454" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着我们已经找到了要连接的东西，并且拥有了请求它所需的所有信息。为此，我们使用该信息创建流任务，并发送它来请求连接。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="6c1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">到目前为止，一切都不言自明。我们用默认配置创建了一个URLSession的实例。我们通过遵循URLSessionStreamDelegate将自己指定为该会话的代表，因为这些是我们感兴趣的。然后，我们通过使用搜索时获得的网络服务来创建流任务。</p><p id="16b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">完成后，我们“恢复”任务。我们就是这样开始的。然后我们继续<strong class="kw iu">调用“</strong><a class="ae lx" href="https://developer.apple.com/documentation/foundation/urlsessionstreamtask/1410132-capturestreams" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">captureStreams()</strong></a><strong class="kw iu">”这将触发对委托的调用，传入一个</strong><a class="ae lx" href="https://developer.apple.com/documentation/foundation/inputstream" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">InputStream</strong></a><strong class="kw iu">和一个</strong><a class="ae lx" href="https://developer.apple.com/documentation/foundation/outputstream" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">OutputStream</strong></a>。我们将保留对这些流的引用，并告诉这两个流都打开。这个动作允许我们从InputStream中读取并写入OutputStream。</p><p id="3de9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能注意到的另外两件事是，我们也希望成为两个流的代表，我们将流插入到<a class="ae lx" href="https://developer.apple.com/documentation/foundation/runloop" rel="noopener ugc nofollow" target="_blank"> RunLoop </a>中。<strong class="kw iu">delegate方法会让我们知道流的状态</strong>，但是更重要的是，<strong class="kw iu">当InputStream上有可用的信息要读取时，它会通知我们。关于RunLoop，它可以让我们避免对流进行轮询。我推荐阅读关于RunLoop的文档和这篇来自苹果的关于<a class="ae lx" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Streams/Articles/PollingVersusRunloop.html" rel="noopener ugc nofollow" target="_blank">“轮询与运行循环调度”</a>的简短文章</strong></p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="109c" class="nn mo it bd mp no np dn mt nq nr dp mx ld ns nt mz lh nu nv nb ll nw nx nd ny bi translated">什么是InputStream和OutputStream？</h2><p id="ff1d" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">让我们解释一下它们是什么，以及为什么我们需要这些流。</p><blockquote class="nz oa ob"><p id="958e" class="ku kv mh kw b kx ky ju kz la lb jx lc oc le lf lg od li lj lk oe lm ln lo lp im bi translated">流是一段时间内可用的数据元素序列。<strong class="kw iu">一个流可以被认为是传送带上的物品，一次处理一个，而不是成批处理。<a class="ae lx" href="https://en.wikipedia.org/wiki/Stream_(computing)" rel="noopener ugc nofollow" target="_blank">维基百科</a></strong></p></blockquote><p id="4d7e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我觉得这解释得很好。<strong class="kw iu">它代表我们将用来将数据从一个设备转移到下一个</strong>的装配线。但是为什么会有两种类型的流呢？</p><p id="2a0c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">嗯，<strong class="kw iu">顾名思义，InputStream </strong>处理所有传入的数据。它的目的是接收数据并传递给我们。如果没有这个输入流，我们将无法获得从其他设备发送的信息。</p><p id="6e19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">另一方面，</strong>输出流<strong class="kw iu">处理将消息写入另一个设备</strong>上的输入流。我们需要它通过已建立的链路发送数据。</p><p id="2306" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着客户端的输入流从主机的输出流获取信息，同样，客户端的输出流将数据传递给主机的输入流。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/144a230421f0e0c26211c78e8ce46651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFg6azOT54zzoTOJq9nvCg.png"/></div></div></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="6f06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们来看看等式的主机端。客户端请求连接，如果一切顺利<strong class="kw iu">，我们将通过</strong><a class="ae lx" href="https://developer.apple.com/documentation/foundation/netservicedelegate" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">net servicedelegate</strong></a><strong class="kw iu">得到一个委托调用，告诉我们一个连接已经被接受</strong>，它将为我们提供主机相应的流。我们将不得不做和以前一样的事情:捕获溪流并打开它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="c151" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这与我们之前在启动URLSessionStreamTask之后所做的完全相同。<strong class="kw iu">至此，我们完成了第2步，并准备开始第3步。</strong></p><h1 id="fe8b" class="mn mo it bd mp mq og ms mt mu oh mw mx jz oi ka mz kc oj kd nb kf ok kg nd ne bi translated">3.<strong class="ak">发送数据</strong></h1><p id="6b73" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">现在我们已经完成了我们的连接，并且我们有了对我们打开的和等待使用的流的引用。我们现在需要做的就是使用它们。<strong class="kw iu">让我们从输出流方面开始:</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a48e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">要沿着溪流移动对象，它们需要一个</strong> <a class="ae lx" href="https://developer.apple.com/documentation/foundation/data" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">数据</strong> </a> <strong class="kw iu">对象</strong>。这就是为什么我们把字符串转换成数据，然后我们可以把它交给OutputStream来传递。您可能还注意到，我在OutputStream上利用了一个扩展。我不打算详细讨论那里发生了什么，因为这超出了本文的范围。</p><p id="5cdb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">知道我们传递的是数据对象，它就为通过它发送更复杂的结构打开了大门。通过定义一个符合Codable的对象，我们可以利用它来发送更多有趣的东西。绳子很酷，但我们可以做得更多。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9bf0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我知道，这个例子只是在本质上是一个消息字符串的地方添加了一个用户字段。但是你明白了。使用codable可以让你更灵活地发送结构更好的数据。</p><p id="9fc3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是InputStream呢？我们如何在主机端接收数据呢？<strong class="kw iu">我们这样做是因为符合StreamDelegate </strong>。每次事件发生时，我们都会通过代理人得到通知。我们只需要监听正确的事件并等待它。<strong class="kw iu">我们期望的事件是:。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="843b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当大事”。当我们知道有数据等待读取时，就会触发“hasBytesAvailable”。我们继续<strong class="kw iu">告诉InputStream去读它</strong>。这样做之后，我们将那些<strong class="kw iu">字节插入到我们的数据对象中，然后我们将它们转换回字符串，以成功地获得我们的“Hello World”。</strong>正如我对OutputStream所做的一样，我也在这里利用一个扩展来读取数据。然而，解释将花费很长时间，这超出了本文的范围。</p><p id="05a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从这一点来看，我们需要做的就是将消息传递给任何期望它的对象。我们可以通过实现我们自己的委托来实现，或者如果项目已经使用了combine，那么将它传递给发布者，以分发给它的听众。</p><p id="ea13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了完整起见，如果您通过传递一个可编码的对象，就像我们之前定义的Package一样。那么您阅读部分可能看起来有点像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="43b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们完了。<strong class="kw iu">消息已从一台设备发送到另一台设备。这就完成了步骤3 </strong>。现在就看你自己了，用这些知识向前迈进，做一些很酷的事情。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="d95b" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">最终想法</h1><p id="311a" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">经过一段时间的努力和艰辛之后，<strong class="kw iu">我可以有把握地说，有了这些知识，任何人都可以开始尝试创建点对点连接</strong>。</p><p id="6c69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些信息不仅适用于iOS设备之间，<strong class="kw iu">同样的原则也适用，即使你想用它与Mac、Android或打印机进行通信</strong>。发送的是字节信息，唯一的条件是无论另一端的设备是什么，它都必须能够读取和使用它。</p><p id="2e34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，关于这个主题还有更多，这只是冰山一角。这取决于你继续做更多的研究，弄清楚这是否是你正在寻找的解决方案，以及如何在你的项目中最好地使用它。</p><p id="be30" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为你一路走到了最后。这是这段代码在演示中的一个片段:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/f74fd2031196b8f7a145523d0eea8bc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*l2T24V0a55ymQiPjNJY5Ug.gif"/></div></figure><h2 id="beab" class="nn mo it bd mp no np dn mt nq nr dp mx ld ns nt mz lh nu nv nb ll nw nx nd ny bi translated">小免责声明</h2><p id="f45c" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">这里提供的代码代表了实现预期目标所需的最低限度。这就缺少了将代码投入生产所需的部分代码和错误处理。所提供的信息旨在用作就此问题开展工作的指南。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="2215" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你喜欢这篇文章，请为它鼓掌(喜欢它),并在下面留下你的问题、评论或建议。我会尽力回答他们。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="7d7a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">更多内容由我:</strong></p><ul class=""><li id="c997" class="ly lz it kw b kx ky la lb ld ma lh mb ll mc lp om me mf mg bi translated"><a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/bonjour-share-data-across-devices-without-a-backend-36faee520e14">你好:网络易发现</a></li><li id="42e2" class="ly lz it kw b kx mi la mj ld mk lh ml ll mm lp om me mf mg bi translated"><a class="ae lx" href="https://blog.usejournal.com/taking-advantage-of-generics-and-codable-in-swift-b5e28cdeb6fa" rel="noopener ugc nofollow" target="_blank">利用Swift中的泛型和可编码性</a></li><li id="9f03" class="ly lz it kw b kx mi la mj ld mk lh ml ll mm lp om me mf mg bi translated"><a class="ae lx" href="https://medium.com/@mpesate/a-few-swift-tricks-that-you-might-not-know-7d14afbd5f71" rel="noopener">一些你可能不知道的快速技巧</a></li></ul></div></div>    
</body>
</html>