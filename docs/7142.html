<html>
<head>
<title>Solving a Graph Problem with Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Go解决一个图形问题</h1>
<blockquote>原文：<a href="https://itnext.io/solving-a-graph-problem-with-go-f1049de33856?source=collection_archive---------0-----------------------#2022-06-24">https://itnext.io/solving-a-graph-problem-with-go-f1049de33856?source=collection_archive---------0-----------------------#2022-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/f8b958f8b8af2ddca2f7f66f0665c371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_d9gcSUPHjrdJOmiEcRpEQ.jpeg"/></div></div></figure><div class=""/><p id="bfd1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在过去的几天里，我一直在看现场模拟面试，尽管我并不想找新工作(我在谷歌很开心)，但我觉得有趣的是，这么多人都在为隐藏在一些复杂装饰背后的同一个问题而挣扎。</p><p id="f71c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中一个模拟问题是这样说的:</p><blockquote class="kw kx ky"><p id="0fe7" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">想象你有图像，你可以复制任何你想要的图像，创造另一个图像。新的图像(复制品)也可以被复制，等等。虽然新图像看起来一样，但名称不同，您还可以追溯到父图像。</p><p id="2337" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">现在，我们想要删除所有的图像，但是如果图像有重复，我们就不能删除它。您必须实现一个返回图像删除顺序的函数。</p><p id="d76b" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">要实现的功能如下(在这篇文章中，我们对所有代码都使用Go):</p></blockquote><p id="a3e7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ld le lf lg b">func deleteOrder(imgs []*Image, cps []*CPOps) []*Image {...}</code></p><pre class="lh li lj lk gt ll lg lm ln aw lo bi"><span id="3b4d" class="lp lq jb lg b gy lr ls l lt lu">type Image struct {<br/>  Name string<br/>}</span><span id="1f07" class="lp lq jb lg b gy lv ls l lt lu">// CPOps represent a copy operation. <br/>type CPOps struct {<br/>  ParentImage *Image //Original images being copied. <br/>  CpImages []*Image  //Copies of the original image.<br/>}</span></pre><blockquote class="kw kx ky"><p id="6ac4" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">该函数接收图像列表，以及它们之间的复制操作，然后它必须返回根据上述规则删除所有图像时必须遵循的顺序。</p></blockquote><p id="af6f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看一个例子:</p><pre class="lh li lj lk gt ll lg lm ln aw lo bi"><span id="927f" class="lp lq jb lg b gy lr ls l lt lu">Images = [A, B, C, D]<br/>CPOps = [<br/>  {ParentImage:A, CPImages:[B, C]},<br/>  {ParentImage:B, CPImages:[D]},<br/>]</span></pre><p id="6213" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是说，A是原始图像，我们制作了两个副本，B和C，然后我们将B的副本制作成D，我们函数<code class="fe ld le lf lg b">deleteOrder</code>的out应该是[D，B，C，A]或[D，C，B，A]或[C，D，B，A]。请注意，多种解决方案是可能的，但所有这些解决方案都是这样的，即只有在删除其副本后，才会删除每个图像。</p><h1 id="920d" class="lw lq jb bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">解决问题。</h1><p id="7e45" class="pw-post-body-paragraph jy jz jb ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">这个问题是一个经典的拓扑排序算法，其中建立了对象之间的某种依赖关系。同样的问题以不同的措辞呈现给模拟面试的候选人，但在所有情况下，问题都可以归结为拓扑排序。</p><p id="b3d1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在这篇文章中提出的解决方案是这样写的，每一部分都可以独立解释。然而，为了节省时间，在面试中写一段可读性较差的代码是可以接受的。</p><h2 id="1f7b" class="lp lq jb bd lx my mz dn mb na nb dp mf kj nc nd mj kn ne nf mn kr ng nh mr ni bi translated">构建图表</h2><p id="6b13" class="pw-post-body-paragraph jy jz jb ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">我希望到现在为止，读者可以意识到这是一个图表问题，这反过来应该是给面试官的第一个信号，表明候选人了解正在发生的事情。</p><p id="08c1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们使用上面的示例来构建图表，我们应该会得到如下结果:</p><pre class="lh li lj lk gt ll lg lm ln aw lo bi"><span id="4d16" class="lp lq jb lg b gy lr ls l lt lu">A --&gt; B --&gt; D<br/> \  <br/>  --&gt; C</span></pre><p id="479a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们创建一个函数，给定输入，我们可以建立一个图形，可以用来解决这个问题。</p><figure class="lh li lj lk gt is"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">构建图表</figcaption></figure><p id="4bee" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，我们首先将所有节点(图像)添加到图中，这很重要，因为可能有从未被复制的图像，因此它们将永远不会出现在给定的关系中。然后，我们建立节点之间的依赖关系。</p><p id="3f86" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以实现算法的主要部分，拓扑排序。</p><h2 id="48d8" class="lp lq jb bd lx my mz dn mb na nb dp mf kj nc nd mj kn ne nf mn kr ng nh mr ni bi translated">拓扑排序</h2><p id="95bd" class="pw-post-body-paragraph jy jz jb ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">拓扑排序是一个简单的DFS，它使用依赖关系作为有向边来遍历图，并返回相反的顺序。在我们的例子中，我们对依赖关系的逆序感兴趣，因为A — &gt; B，我们需要先删除B，然后删除A。</p><figure class="lh li lj lk gt is"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">DFS遍历给定初始节点的图。</figcaption></figure><p id="1500" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">DFS遍历给定初始节点的图，并以相反的顺序返回依赖关系。<code class="fe ld le lf lg b">visited</code>变量跟踪我们已经在图中访问过的节点(为了不重复它们)，变量<code class="fe ld le lf lg b">path</code>跟踪反转的依赖关系。</p><p id="a594" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们已经有了一种构建图并遍历它的方法，我们必须马上把所有的东西放在一起。</p><figure class="lh li lj lk gt is"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9339" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ld le lf lg b">DeletionOrder</code>函数用给定的输入构建图形，对于每个没有被访问过的节点，执行<code class="fe ld le lf lg b">dfs</code>。<code class="fe ld le lf lg b">result</code>变量将包含正确删除顺序的图像名称。</p><p id="64a6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其余的<code class="fe ld le lf lg b">DeleteOrder</code>函数(第14行等等)只是确保我们从图像名称中选择图像(在图形算法之外)。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="662b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大部分算法看起来并不复杂，但是很多人都没有解决这个问题，在我看来，在45分钟的采访中这是可行的。我观察到大多数人不能足够快地识别图形问题，以便有时间实现一个工作解决方案。</p><h1 id="9a72" class="lw lq jb bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">其他考虑</h1><p id="67b1" class="pw-post-body-paragraph jy jz jb ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">同一个问题可以有不同的方向，取决于面试官想怎么看。</p><p id="d294" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，当图有数千个节点时，放大算法的问题是一个有趣的问题。尽管它们看起来很简单，但仍有一些棘手的情况需要考虑。</p><p id="ac78" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检测给定输入是否正确的问题也可能是一个有趣的问题。为了使图可排序，从而拓扑排序正确工作，图不能有圈。检测周期并不是一个特别复杂的问题，但是大规模的检测可能会有一些问题。</p><p id="33f8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些都是有趣的问题，读者应该花点时间思考一下它们以及每个问题的含义。</p><p id="0efb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，在45分钟的面试中，只有在主要问题被正确编码后，才有时间解决其中的几个问题。然而，我们希望在这篇文章之后，读者可以看到一些问题，并很容易地将它们简化为可以使用拓扑排序解决的问题的图形类别。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="15b2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">祝你面试好运。</p></div></div>    
</body>
</html>