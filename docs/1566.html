<html>
<head>
<title>Don’t Just Refactor, Make it Maintainable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要只是重构，要让它可维护</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-safely-refactor-old-code-part-2-2d09451b4e8f?source=collection_archive---------4-----------------------#2018-11-24">https://itnext.io/how-to-safely-refactor-old-code-part-2-2d09451b4e8f?source=collection_archive---------4-----------------------#2018-11-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/2b838eaa995688f95f6baf91de97914f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ctO3MYJgR0FTkauk"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">拉·罗宾逊公司在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><div class=""><h2 id="1bf0" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">安全重构旧代码:第2部分</h2></div><p id="380c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">在这个系列中，我们一步一步地回顾安全重构旧代码的概念设计模式。我编写本指南是为了适应任何类型的重构场景，示例项目是Node.js with RxJS。</em></p><p id="9e82" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">这是关于安全重构代码的3部分系列文章中的第二篇文章</em><em class="lr">:</em></p><ul class=""><li id="cbba" class="ls lt jg kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated"><a class="ae jd" href="https://medium.com/@Sawtaytoes/how-to-safely-refactor-old-code-part-1-a1a853263fec" rel="noopener"> <em class="lr">第1部分:防止现有系统的突破性变化</em> </a></li><li id="26b2" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><a class="ae jd" href="https://medium.com/@Sawtaytoes/how-to-safely-refactor-old-code-part-2-2d09451b4e8f" rel="noopener"> <em class="lr">第二部分:不要只是重构，要让它可维护</em> </a></li><li id="c705" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><a class="ae jd" href="https://medium.com/@Sawtaytoes/how-to-safely-refactor-old-code-part-3-f285a6200988" rel="noopener"> <em class="lr">第3部分:重构AJAX调用和观察对象</em> </a></li></ul><h1 id="642b" class="mg mh jg bd mi mj mk ml mm mn mo mp mq km mr kn ms kp mt kq mu ks mv kt mw mx bi translated">我们的故事到此为止</h1><p id="1a49" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">在编写测试时，我们完全无法在不修改主要代码的情况下完成单元、集成甚至端到端(E2E)测试。相反，我们最终创建了E2E测试，在这个过程中需要人来验证功能。现在我们已经有了一些东西来确保我们的应用程序不被破坏，我们可以开始重构代码，这样它对于npm包来说实际上是可测试的和可展示的。</p><h1 id="42c9" class="mg mh jg bd mi mj mk ml mm mn mo mp mq km mr kn ms kp mt kq mu ks mv kt mw mx bi translated">从哪里开始重构？</h1><p id="3db6" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">现在我们终于找到了检验破损的方法，我们从哪里开始呢？我们是重构还是重写？这篇文章是关于安全重构的，所以我们要避免重写。这意味着我们必须确保每一个微小的变化都让应用程序处于工作状态，但这也意味着我们可以逐个模块地重构。</p><p id="9691" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">免责声明:虽然我提到我们编写测试是为了确保我们不会破坏功能，但在某个时候，我们将不得不升级RxJS版本，其中包括重大更改。除非我们更新导入，否则我们的单元测试将无法正常运行，所以到时候我们将不得不再次测试测试。</em></p><p id="d0d6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上一篇文章中，我们做了一点返工，只是为了确保我们可以完成一些可重复的测试。我们今天将继续这样做，但我想聪明地开始。</p><h1 id="4ac0" class="mg mh jg bd mi mj mk ml mm mn mo mp mq km mr kn ms kp mt kq mu ks mv kt mw mx bi translated">从图书馆开始</h1><h2 id="0d65" class="nd mh jg bd mi ne nf dn mm ng nh dp mq le ni nj ms li nk nl mu lm nm nn mw no bi translated">升级RxJS</h2><p id="62df" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">因为对我们代码库最大的改变将是RxJS升级，所以让我们完成它。你不会想到先处理大鱼，但这次升级将改变我们设计的一些基本原则。重构后不升级RxJS，意味着我们有更多的地方需要更新，包括单元测试。</p><p id="203a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将利用rxjs-compat库来保留现有的RxJS v5代码以及新的RxJS v6代码。这样，我们不必一次改变所有的东西，我们可以分块来做。完成重构后，删除rxjs-compat非常重要。我可以预见更大的项目会安装这样的拐杖，然后在产品的整个生命周期中继续有两种不同的使用RxJS的方法。</p><p id="864a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最安全的方法是让我们一次做一个小的改变，而不是在最后一刻做大规模的架构改变。从经验来看，最后升级RxJS意味着它永远不会更新，因为你会有太多根深蒂固的旧方式要移动。当RxJS升级时，我们已经不得不更新我们的一个单元测试，那么为什么还要在那些都需要潜在突破性改变的基础上写一堆额外的单元测试呢？</p><p id="39d6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一方面，如果你的代码是以一种重写比重构更容易的方式编写的，你就不应该首先升级RxJS。在我们的例子中，我们将获取一点代码，并将其移动到单独的单元可测试模块中。这极大地改变了它的结构，因此越早升级越重要。</p><p id="16b4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">简单地更新rxjs并添加rxjs-compat就足以让代码像以前一样工作:</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="317c" class="nd mh jg nu b gy ny nz l oa ob">yarn add rxjs rxjs-compat</span></pre><p id="ea89" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个小小的升级是迄今为止超级安全的改变。我们不知道性能、内存使用等；但是我要假设，如果你还没有这些东西的测试，那么它对你的项目来说是不值得的。</p><h2 id="bb06" class="nd mh jg bd mi ne nf dn mm ng nh dp mq le ni nj ms li nk nl mu lm nm nn mw no bi translated">其他图书馆</h2><p id="61a3" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">我知道我的其他库有更新的版本，但我只打算更新那些没有重大变化的库。想继续用RxJS所以升级了。另一方面，我不想继续使用moment.js，所以我会保持原样，直到我准备好。</p><p id="f122" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个项目中，一些安全的升级是nodemon、node-fetch和我们已经看到的rxjs。升级app-module-path和moment.js是不安全的，因为现有API可能会出现破损。如果项目维护得很好，我至少可以更新补丁版本(语义版本的最后一个小数:2.19。尤其是如果我目前的版本有已知的安全缺陷。你应该也能够升级次要版本(2。<strong class="kx jh">19【T3 . 1】与大多数npm包，但如果你还没有单元测试，这是不安全的。</strong></p><h2 id="4fbc" class="nd mh jg bd mi ne nf dn mm ng nh dp mq le ni nj ms li nk nl mu lm nm nn mw no bi translated">避免更换库</h2><p id="b45b" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">在最初的重构中，您会希望避免更改库。这样，在用新代码替换旧代码之前，您可以确保旧代码仍然有效。</p><p id="7c76" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，我真的很想使用date-fns而不是moment.js，但不是去所有使用moment.js的地方并交换它们，我应该首先重构那些点以允许针对moment.js的单元测试，然后在我得到工作单元测试之后交换到date-fns。</p><h1 id="5e74" class="mg mh jg bd mi mj mk ml mm mn mo mp mq km mr kn ms kp mt kq mu ks mv kt mw mx bi translated">是万圣节吗？</h1><p id="6329" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">让我们看看之前的<code class="fe oc od oe nu b">isHalloween</code>例子:</p><figure class="np nq nr ns gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="bd73" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们需要给它一个日期，而不是硬编码<code class="fe oc od oe nu b">moment()</code>,这样我们就可以在任何一天对它进行单元测试。我们还需要把<code class="fe oc od oe nu b">currentYear</code>作为一个参数传入，或者把它改成一个函数，并给它传递一个日期。这两项更改都可以很容易地进行单元测试，以确保没有任何问题。</p><h2 id="5ada" class="nd mh jg bd mi ne nf dn mm ng nh dp mq le ni nj ms li nk nl mu lm nm nn mw no bi translated">超级安全重构</h2><p id="6b20" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">一个简单的重构如下所示:</p><figure class="np nq nr ns gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="d627" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意我们所做的一切是如何让<code class="fe oc od oe nu b">moment()</code>接受一个传入的日期的。这正是我们想要的。最小的变化，但我们可以进行单元测试。</p><p id="c0f8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的<code class="fe oc od oe nu b">isHalloween</code>函数以前没有参数，所以我们保留了这个功能，并且只在没有传递日期时默认为<code class="fe oc od oe nu b">new Date()</code>(没有参数调用<code class="fe oc od oe nu b">moment()</code>的老方法)。</p><h2 id="52b2" class="nd mh jg bd mi ne nf dn mm ng nh dp mq le ni nj ms li nk nl mu lm nm nn mw no bi translated">重命名函数</h2><p id="c8e6" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">作为最后一项更改，我想将这个函数从<code class="fe oc od oe nu b">isHalloween</code>重命名为<code class="fe oc od oe nu b">isDuringHalloweenNight</code>，因为这在语义上是正确的:</p><figure class="np nq nr ns gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="5ea4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本着安全重构的思想，我用重命名的函数创建了新文件，并弃用了旧函数。这样，旧的功能仍然有效，但是现在我们可以通知用户新的文件，这样他们就可以知道不赞成使用的更改。</p><p id="e4fe" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我建议使用弃用库，而不是在整个代码库中编写自定义的弃用代码。对于这个例子，我想保持简单，但实际上我已经编写了自己的弃用库来处理这些情况。</p><h2 id="d8e1" class="nd mh jg bd mi ne nf dn mm ng nh dp mq le ni nj ms li nk nl mu lm nm nn mw no bi translated">编写单元测试</h2><p id="ad06" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">我继续前进，引入了<a class="ae jd" href="https://github.com/avajs/ava" rel="noopener ugc nofollow" target="_blank"> AVA </a>作为我们的单元测试库，并更新了我们导入文件的方式。</p><p id="a8de" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是我们的单元测试的样子:</p><figure class="np nq nr ns gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="a525" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我也可以对旧的<code class="fe oc od oe nu b">isHalloween</code>进行单元测试，但是最初的<code class="fe oc od oe nu b">isHalloween</code>是不可测试的，因为它没有参数。因为它仍然不接受参数，所以仍然无法测试。</p><h2 id="471f" class="nd mh jg bd mi ne nf dn mm ng nh dp mq le ni nj ms li nk nl mu lm nm nn mw no bi translated">更新库</h2><p id="4eba" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">现在我们的单元测试已经就绪，我升级到了date-fns并重写了<code class="fe oc od oe nu b">isDuringHalloweenNight</code>。由于功能没有改变，我们的单元测试也没有改变。这是结果:</p><figure class="np nq nr ns gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="ea7c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">基本的日期库完全是个人偏好，但是date-fns有一个函数编程文件夹，它允许你从它们的基本函数组合新的函数。在新的<code class="fe oc od oe nu b">isDuringHalloweenNight</code>中，我们正在编写一个新的日期函数。</p><p id="6ee2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们不需要将<code class="fe oc od oe nu b">date</code>传递给<code class="fe oc od oe nu b">getYear</code>，它会看起来更清晰，但是这种重构并不意味着完全重写。</p><h1 id="246a" class="mg mh jg bd mi mj mk ml mm mn mo mp mq km mr kn ms kp mt kq mu ks mv kt mw mx bi translated">颜色索引</h1><p id="f3a8" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">在<code class="fe oc od oe nu b">flashRandomLight</code>中，我们有很多不可测试的功能。为了使它们可测试，我们将做和<code class="fe oc od oe nu b">isDuringHalloweenNight</code>一样的事情；我们希望编写可以组合的基本函数，并使用我们在<code class="fe oc od oe nu b">flashRandomLight</code>中的函数在语义上组合这些通用基本函数。</p><p id="1fdf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们来看看<code class="fe oc od oe nu b">getRandomColorSetIndex</code>:</p><figure class="np nq nr ns gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="13aa" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这次重构与上一次不同。我们正在创建基本函数(就像我们对date-fns所做的那样),并在我们的旧函数中组合它。当进行单元测试时，对一般的基本函数进行单元测试是有意义的，因为组合函数不一定需要进行单元测试。</p><p id="99b3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于<code class="fe oc od oe nu b">getRandomColorSetIndex</code>仍然不接受任何参数，我们无法对其进行单元测试。这就是为什么我们最好创建一个新的通用函数来进行单元测试:<code class="fe oc od oe nu b">pluckRandomNumberFromRange</code>。</p><p id="6add" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除了将<code class="fe oc od oe nu b">dependencies</code>作为第二个参数传递——将它暴露给任何人传入——我们还可以将它分离到一个单独的函数中，并将其组合成我们的随机数提取函数:</p><figure class="np nq nr ns gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="3855" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种重构更加简洁，并且真正简化了我们正在做的事情。在这一点上，将来有人可以重构<code class="fe oc od oe nu b">pluckRandomNumberFromRange</code>来使用lodash-fp或Ramda中的通用范围函数；尽管这是StackOverflow 上的一个<a class="ae jd" href="https://stackoverflow.com/questions/4959975/generate-random-number-between-two-numbers-in-javascript" rel="noopener ugc nofollow" target="_blank">常见问题，但这些库中并不存在这种特定的功能。</a></p><p id="f498" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们仍然可以将它进一步重构为最流行的StackOverflow答案:</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="d082" class="nd mh jg nu b gy ny nz l oa ob">Math.floor(Math.random() * upperBound) + lowerBound</span></pre><p id="8f58" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我不会为这个项目做那样的改变，但这绝对是可能的。只需通过<code class="fe oc od oe nu b">0</code>中的一个<code class="fe oc od oe nu b">lowerBound</code>，您现有的功能不会改变。</p><p id="13b3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我编写了单元测试，并在更改API后对它们进行了调整。当我进行这些重构时，我会定期检查应用程序以确保它能运行，并检查原始的E2E测试规范以确保应用程序仍能正常运行。</p><p id="766b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我做了最后一个改变。我们需要一些方法来抛出一个错误，如果有人没有传入项目的数量或者他们的项目计数是<code class="fe oc od oe nu b">0</code>。在这种情况下返回<code class="fe oc od oe nu b">0</code>是没有意义的，因为它不是大小为<code class="fe oc od oe nu b">0</code>的列表中的有效索引。</p><p id="0bcd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要么我们返回<code class="fe oc od oe nu b">null</code>或者错误。我想在这次重构中尝试一些新的东西，所以我们返回一个错误:</p><figure class="np nq nr ns gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="5e08" class="nd mh jg bd mi ne nf dn mm ng nh dp mq le ni nj ms li nk nl mu lm nm nn mw no bi translated">排版错误</h2><p id="b784" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">因为我修改了<code class="fe oc od oe nu b">createRangePicker</code>来抛出一个错误，所以我使用函数组合创建了一个抛出错误的机制。该API类似于AVA抛出错误的方式。这样，如果在我们的函数执行之前满足了某些错误标准，我们可以简单地抛出一个错误，而不必使函数的逻辑变得复杂。</p><figure class="np nq nr ns gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="3375" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为<code class="fe oc od oe nu b">errorWrapper</code>是可组合的，你可以把一个放在另一个里，另一个放在另一个里。在ECMAScript的更高版本中，您甚至可以使用pipeline操作符在一次跳转中垂直读取它们。这将大大提高可读性。</p><h1 id="4c6a" class="mg mh jg bd mi mj mk ml mm mn mo mp mq km mr kn ms kp mt kq mu ks mv kt mw mx bi translated">最终产品</h1><p id="998a" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">在一大堆工作重构和编写单元测试之后，我能够使这个项目变得可维护、可测试和可靠。我不担心它在万圣节突然不工作了，并且可以继续添加E2E测试来验证它做了我期望的事情，只是为了增加一点点安全性。</p><p id="0ceb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你想看AJAX refactor和其他，请查看第3部分 ！</p><h1 id="3ec4" class="mg mh jg bd mi mj mk ml mm mn mo mp mq km mr kn ms kp mt kq mu ks mv kt mw mx bi translated">更多阅读</h1><p id="94c3" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">如果你喜欢你所读的，你也应该看看我关于智能家居和函数式编程的其他文章:</p><ul class=""><li id="d972" class="ls lt jg kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated"><a class="ae jd" href="https://medium.com/flicblog/flic-buttons-and-the-observable-customization-using-rxjs-2214bc53d407" rel="noopener"> RxJS和可观察的Flic按钮</a></li><li id="2eb2" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><a class="ae jd" href="https://medium.com/flicblog/controlling-iot-devices-with-the-flic-of-a-button-1349c81bddef" rel="noopener">通过轻触按钮控制物联网设备</a></li><li id="e22a" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">函数式编程的表情爱好者指南:第一部分</li></ul></div></div>    
</body>
</html>