<html>
<head>
<title>How NebulaGraph Database Automatically Cleans Stale Data with TTL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NebulaGraph数据库如何用TTL自动清除陈旧数据</h1>
<blockquote>原文：<a href="https://itnext.io/how-nebulagraph-database-automatically-cleans-stale-data-with-ttl-cbe840277fc7?source=collection_archive---------4-----------------------#2022-12-12">https://itnext.io/how-nebulagraph-database-automatically-cleans-stale-data-with-ttl-cbe840277fc7?source=collection_archive---------4-----------------------#2022-12-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/13eb86ae83d15d145090f7825c01c50a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*i93AS4L8RpcEMpRC.png"/></div></div></figure><h1 id="b822" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="641d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">大数据时代，我们处理的是TB、PB，甚至EB的数据。如何处理庞大的数据集是数据库领域工作人员面临的一个普遍问题。</p><p id="3d48" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这个问题的核心是存储在数据库中的数据是否仍然有效和有用。因此，提高有效数据的利用率、过滤无效/过期数据等问题已经引起了全球的广泛关注。</p><p id="a68e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这篇文章中，我们将关注如何处理数据库中的过时数据。</p><p id="afd5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">清理数据库中过时数据的方法有很多种，比如存储过程、事件等等。这里我们举一个例子来简单解释一下数据过滤中常用的存储过程事件以及TTL。</p><h1 id="3475" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">存储过程和事件</h1><h1 id="372d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">存储过程</h1><p id="986d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">存储过程是一个或多个SQL语句的集合。这种技术将复杂的操作封装到一个代码块中，以便在对数据库执行一系列读或写操作时重用代码，从而大大节省了数据库开发人员的时间和精力。</p><p id="2e73" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">通常，存储过程一旦编译，就可以多次执行，从而大大提高效率。</p><p id="fa96" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">存储过程的优点:</p><ul class=""><li id="b7e4" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated"><strong class="ky ir">简化操作。</strong>将重复的操作封装到一个存储过程中，这简化了对这些SQL查询的调用。</li><li id="6522" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated"><strong class="ky ir">批量加工。</strong>SQL作业的组合可以减少服务器端和客户端之间的流量。</li><li id="2745" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated"><strong class="ky ir">统一接口</strong>确保数据安全。</li><li id="9c3b" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated"><strong class="ky ir">编译后，随处运行</strong>提高效率。</li></ul><p id="102e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">以MySQL为例，假设我们要删除如下表:</p><pre class="mn mo mp mq gt mr ms mt bn mu mv bi"><span id="2eb6" class="mw jz iq ms b be mx my l mz na">mysql&gt; SHOW CREATE TABLE person;<br/>+--------+---------------------------------------------------------------------------------------------------------------------------------+<br/>| Table  | Create Table                                                                                                                    |<br/>+--------+---------------------------------------------------------------------------------------------------------------------------------+<br/>| person | CREATE TABLE `person` (<br/>  `age` int(11) DEFAULT NULL,<br/>  `inserttime` datetime DEFAULT NULL<br/>) ENGINE=InnoDB DEFAULT CHARSET=utf8 |<br/>+--------+---------------------------------------------------------------------------------------------------------------------------------+<br/>1 row in set (0.00 sec)</span></pre><p id="918b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这是一个名为person的表，其中_inserttime_ column是日期时间类型。我们使用_inserttime_ column来存储数据的生成时间。</p><p id="10f1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">接下来，我们创建一个删除该表的存储过程:</p><pre class="mn mo mp mq gt mr ms mt bn mu mv bi"><span id="d643" class="mw jz iq ms b be mx my l mz na">mysql&gt; delimiter //<br/><br/>mysql&gt; CREATE PROCEDURE del_data(IN `date_inter` int)<br/>    -&gt; BEGIN<br/>    -&gt;   DELETE FROM person WHERE inserttime &lt; date_sub(curdate(), interval date_inter day);<br/>    -&gt; END //<br/><br/>mysql&gt; delimiter ;</span></pre><p id="72eb" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">该示例创建了一个名为_del_data_的存储过程，其中参数_date_inter_指定删除时间和当前时间之间的间隔，即如果inserttime列(日期时间类型)和date_inter之和小于当前时间，则数据过期，然后被删除。</p><h1 id="f572" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">事件</h1><p id="23ee" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">事件是根据计划运行的任务。一个事件可以被调用一次或重复调用。一个称为事件调度程序的特殊线程执行所有调度的事件。</p><p id="3e23" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">事件类似于触发器，因为它们都在满足特定条件时运行。当数据库中的语句在事件监听其调度程序时执行时，触发器运行。由于相似性，事件也被称为临时触发器。每秒钟都可以安排一个事件。</p><p id="5159" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">以下示例创建一个重复事件，该事件在每天12:00:00调用_del_data_ stored过程，以清除自2020年3月20日以来的数据。</p><pre class="mn mo mp mq gt mr ms mt bn mu mv bi"><span id="b8b3" class="mw jz iq ms b be mx my l mz na">mysql&gt; CREATE EVENT del_event  <br/>    -&gt;     ON SCHEDULE<br/>    -&gt;     EVERY 1 DAY<br/>    -&gt;     STARTS '2020-03-20 12:00:00'<br/>    -&gt;     ON COMPLETION PRESERVE ENABLE<br/>    -&gt;     DO CALL del_data(1);</span></pre><p id="cb35" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后运行:</p><pre class="mn mo mp mq gt mr ms mt bn mu mv bi"><span id="9e97" class="mw jz iq ms b be mx my l mz na">mysql&gt; SET global event_scheduler = 1;</span></pre><p id="01ec" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">打开事件del_event，使其在指定时间自动在后台执行。过期数据通过存储过程del_data和事件del_event自动清除。</p><h1 id="4cc8" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">通过TTL清除数据</h1><p id="3a75" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">上一节介绍了通过存储过程和事件的组合定期清理数据。然而NebulaGraph提供了一种<strong class="ky ir">简单有效的方式</strong>来自动清理过期数据，即TTL方法。</p><p id="d2dc" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">使用TTL清除过期数据的好处如下:</p><ol class=""><li id="259d" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt nb mf mg mh bi translated">简单方便。</li><li id="a021" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt nb mf mg mh bi translated">通过数据库系统的内部逻辑进行处理，确保了安全性和可靠性。</li><li id="5940" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt nb mf mg mh bi translated">高度自动化。数据库根据自身状态自动判断并执行何时处理。不需要人工干预。</li></ol><h1 id="de6a" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">TTL简介</h1><p id="1bde" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><a class="ae nc" href="https://en.wikipedia.org/wiki/Time_to_live" rel="noopener ugc nofollow" target="_blank">生存时间</a>(简称TTL)是一种允许你自动删除过期数据的机制。TTL决定了数据库中数据的生命周期。</p><p id="7a5e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在NebulaGraph中，过期的数据将不再被检索，并将在未来被删除。</p><p id="267a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在称为压缩的后台垃圾收集操作期间，系统将自动从磁盘中删除过期数据。在从磁盘中删除之前，所有过期数据对用户都是不可见的。</p><p id="0d9d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">TTL需要两个参数，<code class="fe nd ne nf ms b">ttl_col</code>和<code class="fe nd ne nf ms b">ttl_duration</code>。<code class="fe nd ne nf ms b">ttl_col</code>表示TTL列，<code class="fe nd ne nf ms b">ttl_duration</code>表示TTL的持续时间。当TTL列和ttl_duration之和小于当前时间时，数据过期。<code class="fe nd ne nf ms b">ttl_col</code>类型必须是整数或时间戳，以秒为单位。<code class="fe nd ne nf ms b">ttl_duration</code> <strong class="ky ir">必须</strong>也以秒为单位设定。</p><h1 id="f3fb" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">TTL读取过滤</h1><p id="e135" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如前所述，TTLed记录对用户是不可见的。因此，通过网络将这些记录从存储服务器传输到图形服务是一种浪费。在NebulaGraph存储服务中，首先从meta服务获得ttl信息，然后在图形遍历时检查每个顶点或边的ttl_col值，即系统将TTL列和ttl_duration的总和与当前时间进行比较，找到过期的数据，然后过滤它们。</p><h1 id="1855" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">TTL压缩详细信息</h1><h1 id="997b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">背景:RocksDB文件组织</h1><p id="8044" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">NebulaGraph使用RocksDB作为其存储引擎。磁盘上的RocksDB文件分为多个级别。默认情况下，有七个级别。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/9fc82f0c892d5893b9f3ed9a4f6b459a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nLevBP8rLAh-06AA.png"/></div></div></figure><p id="f196" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这些文件称为SST文件。对于SST文件中的所有键，它们都按照键进行了很好的排序、结构化和索引。对于级别1到级别6，在每个级别中，SST文件也是排序排列的。但是不同级别的两个文件可能会重叠。级别0中的文件也是如此，这些文件是从内存(MemTable)中刷新和生成的，即l 0中的文件将彼此重叠。如下图所示:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/be255b2de07a4259961cba5e70622c06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fz8ElUh0N9apxFMJ.png"/></div></div></figure><h1 id="5ab7" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">RocksDB压实</h1><p id="ee7f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">RocksDB基于日志结构的合并树(LSM树)。但是LSM是一个数据结构的概念和设计思想。详情请参考<a class="ae nc" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.44.2782&amp;rep=rep1&amp;type=pdf" rel="noopener ugc nofollow" target="_blank"> LSM论文</a>。LSM最重要的部分是压实。因为数据文件是以仅附加模式写入的，所以过期、重复和删除的数据需要通过后台压缩操作来清除。</p><h1 id="9df7" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">RocksDB压缩逻辑</h1><p id="0aeb" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这里使用的压缩策略是分级压缩(受Google著名的LevelDB启发)。当数据被写入RocksDB时，它首先被写入MemTable。当MemTable已满时，它将成为不可变的MemTable。RocksDB通过后台的flush线程将这个不可变的MemTable刷新到磁盘，生成一个排序字符串表(SST)文件，放在0级。当级别0中的SST文件的数量超过某个阈值时，执行压缩。它从第0层读取所有密钥，并将一些新的SST文件写入第1层。通常，L0的所有文件都必须合并到L1中以提高读取性能，因为L0文件通常是重叠的。</p><p id="4e40" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">0级和1级压实如下:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/282c589219980540a568c92af88d61ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l5lrGk1-_Y9VPFYw.png"/></div></div></figure><p id="7f48" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">其他级别的压缩规则相同，以1级和2级压缩为例:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/98bb134b2db0c6d60f4c0444c3350e56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XVpMIiaJcz1mibCM.png"/></div></div></figure><p id="8915" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当0级压缩完成时，1级中的总文件大小或文件数量可能会超过阈值，从而触发1级和2级之间的另一次压缩。将至少选择一个来自L1的文件，并且还会选择L2的一些文件(这些文件与所选的L1文件有重叠)。在这一新的压缩之后，在L1和L2的选定文件被直接从磁盘中删除，并且一些新文件将被写入L3，这可能再次触发L2和L3之间的另一新的压缩，等等。</p><p id="b39e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">从用户的角度来看，如果没有压缩，写操作会非常快(仅追加)，但读操作会非常慢(系统必须从一堆文件中找到一个键)。为了在写入、读取和磁盘使用之间取得平衡，RocksDB在后台执行压缩，以合并不同级别的SST。</p><h1 id="9081" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">星云图TTL压缩原理</h1><p id="5165" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">除了上面提到的默认压缩操作(分级SST文件合并)，RocksDB还提供了一种在后台基于自定义逻辑删除或修改键/值对的方法，即CompactionFilter。</p><p id="3c88" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">NebulaGraph使用CompactionFilter定制自己的TTL函数，在这篇文章中讨论了这个函数。每次在压缩过程中读取数据时，CompactionFilter都会调用一个自定义的筛选函数。TTL压缩基于方法在筛选器函数中实现TTLed数据删除逻辑。</p><p id="3a51" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">下面是详细的实现:</p><ol class=""><li id="b290" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt nb mf mg mh bi translated">首先从元服务获取标签/边缘的TTL信息。</li><li id="95c6" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt nb mf mg mh bi translated">在图形遍历期间，读取一个顶点或边并取值。</li><li id="106b" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt nb mf mg mh bi translated">得到ttl_duration和ttl_col之和，然后与当前时间进行比较。这决定了数据是否过期。过期的数据将被删除。</li></ol><h1 id="5c14" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">实践中的TTL</h1><p id="7ebf" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在NebulaGraph中，将TTL添加到边几乎与添加到标签一样。我们以tag为例介绍TTL的用法。</p><h1 id="eb06" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">设置TTL值</h1><p id="c01f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在NebulaGraph中设置TTL值有两种方法。</p><p id="9c1a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">创建新标签时设置TTL属性。用ttl_col表示ttl列，而ttl_duration表示这个标签的寿命。</p><pre class="mn mo mp mq gt mr ms mt bn mu mv bi"><span id="bf4e" class="mw jz iq ms b be mx my l mz na">nebula&gt; CREATE TAG t (id int, ts timestamp ) ttl_duration = 3600, ttl_col = "ts";</span></pre><p id="337e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当TTL column和ttl_duration之和小于当前时间时，我们认为数据过期。ttl_col数据类型必须是整数或时间戳，并且以秒为单位设置。ttl_duration也是以秒为单位设置的。</p><ul class=""><li id="87a0" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">当ttl_duration设置为-1或0时，此标签的顶点属性不会过期。</li><li id="ae06" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">ttl_col数据类型必须是整数或时间戳。</li></ul><p id="9d22" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">或者，您可以通过ALTER语法为现有标签设置TTL值。</p><pre class="mn mo mp mq gt mr ms mt bn mu mv bi"><span id="0e86" class="mw jz iq ms b be mx my l mz na">nebula&gt; CREATE TAG t (id int, ts timestamp );<br/>nebula&gt; ALTER TAG t ttl_duration = 3600, ttl_col = "ts";</span></pre><h1 id="8d1e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">显示TTL</h1><p id="e53f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">您可以使用以下语法来显示TTL值:</p><pre class="mn mo mp mq gt mr ms mt bn mu mv bi"><span id="3dc4" class="mw jz iq ms b be mx my l mz na">nebula&gt; SHOW CREATE TAG t;<br/>=====================================<br/>| Tag | Create Tag                  |<br/>=====================================<br/>| t   | CREATE TAG t (<br/>  id int,<br/>  ts timestamp<br/>) ttl_duration = 3600, ttl_col = id |<br/>-------------------------------------</span></pre><h2 id="2c7d" class="nj jz iq bd ka nk nl dn ke nm nn dp ki lh no np km ll nq nr kq lp ns nt ku nu bi translated">改变TTL</h2><p id="b077" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">用<code class="fe nd ne nf ms b">ALTER TAG</code>语句改变TTL值。</p><pre class="mn mo mp mq gt mr ms mt bn mu mv bi"><span id="80a8" class="mw jz iq ms b be mx my l mz na">nebula&gt; ALTER TAG t ttl_duration = 100, ttl_col = "id";</span></pre><h1 id="d266" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">丢弃TTL</h1><p id="7216" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果您已经为字段设置了TTL值，但后来决定不希望它自动过期，则可以删除TTL值，将其设置为空字符串，或者通过将其设置为0或-1来使其无效。</p><pre class="mn mo mp mq gt mr ms mt bn mu mv bi"><span id="225e" class="mw jz iq ms b be mx my l mz na">nebula&gt; ALTER TAG t1 ttl_col = ""; -- drop ttl attribute</span></pre><p id="7f9e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">删除<code class="fe nd ne nf ms b">ttl_col</code>字段:</p><pre class="mn mo mp mq gt mr ms mt bn mu mv bi"><span id="adb0" class="mw jz iq ms b be mx my l mz na">nebula&gt; ALTER TAG t1 DROP (a); -- drop ttl_col</span></pre><p id="3636" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">将ttl_duration设置为0或-1:</p><pre class="mn mo mp mq gt mr ms mt bn mu mv bi"><span id="6db9" class="mw jz iq ms b be mx my l mz na">nebula&gt; ALTER TAG t1 ttl_duration = 0; -- keep the ttl but the data never expires</span></pre><h1 id="757e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">例子</h1><p id="6345" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">以下示例显示，当设置了TTL值且数据过期时，系统会忽略过期数据。</p><pre class="mn mo mp mq gt mr ms mt bn mu mv bi"><span id="a82c" class="mw jz iq ms b be mx my l mz na">nebula&gt; CREATE TAG t(id int) ttl_duration = 100, ttl_col = "id";<br/>nebula&gt; INSERT VERTEX t(id) values 102:(1584441231);</span></pre><pre class="nv mr ms nw nx aw ny bi"><span id="b195" class="nj jz iq ms b gy nz oa l ob na">nebula&gt; FETCH prop on t 102;<br/>Execution succeeded (Time spent: 5.945/7.492 ms)</span></pre><p id="862b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">注意:</p><ol class=""><li id="3413" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt nb mf mg mh bi translated">如果字段包含ttl_col值，则不能对该字段进行任何更改。您必须先删除TTL值，然后更改该字段。</li><li id="e16c" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt nb mf mg mh bi translated">请注意，标记或边不能同时具有TTL属性和索引，即使ttl_col列不同于索引列。</li></ol><p id="a0c0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">TTL介绍到此结束。通过向我们提出一个<a class="ae nc" href="https://github.com/vesoft-inc/nebula" rel="noopener ugc nofollow" target="_blank">问题</a>或在我们的官方<a class="ae nc" href="https://discuss.nebula-graph.io/" rel="noopener ugc nofollow" target="_blank">论坛</a>上发布您的反馈来分享您对TTL的想法。</p><h1 id="c1ed" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">你可能也会喜欢</h1><ol class=""><li id="f616" class="lz ma iq ky b kz la ld le lh oc ll od lp oe lt nb mf mg mh bi translated"><a class="ae nc" href="https://nebula-graph.io/posts/how-indexing-works-in-nebula-graph/" rel="noopener ugc nofollow" target="_blank">索引如何在NebulaGraph中工作</a></li><li id="e28d" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt nb mf mg mh bi translated"><a class="ae nc" href="https://nebula-graph.io/posts/nebula-graph-storage-banlancing-data-migration/" rel="noopener ugc nofollow" target="_blank">存储平衡和数据迁移</a></li><li id="5215" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt nb mf mg mh bi translated"><a class="ae nc" href="https://nebula-graph.io/posts/nebula-graph-snapshot-introduction/" rel="noopener ugc nofollow" target="_blank">星云图中的快照介绍</a></li></ol></div></div>    
</body>
</html>