<html>
<head>
<title>Functional Reactive Programming explained in a simple way, in JavaScript…yes, in a simple way.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式反应式编程用简单的方式解释，用JavaScript…是的，用简单的方式。</h1>
<blockquote>原文：<a href="https://itnext.io/functional-reactive-programming-explained-in-a-simple-way-in-javascript-yes-in-a-simple-way-925b14cddf75?source=collection_archive---------1-----------------------#2018-06-20">https://itnext.io/functional-reactive-programming-explained-in-a-simple-way-in-javascript-yes-in-a-simple-way-925b14cddf75?source=collection_archive---------1-----------------------#2018-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cb17a28e2c5098f998abc4838441eb32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A23h1nFMOm2Cf2ERexOWWw.jpeg"/></div></div></figure><p id="6b86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你读过这篇文章，为了理解它，你应该熟悉JavaScript，应该了解什么是反应式编程(RP)，以及什么是函数式编程(FP)；虽然你不一定要精通它们中的任何一个，但是希望你离开时能够对函数式反应式编程(FRP)有一个更清晰的理解。</p><p id="1506" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想写这篇文章的原因是，在网上看了关于FRP的文章后，我找到的几乎都是RP的文章和声称是FRP但在“功能方式”上却什么都没做的例子。似乎有很多困惑；写FRP的开发人员，很多时候只是用点符号链接操作符到转换流，而不是通过使用<strong class="ka ir">管道</strong>链接<em class="kw">纯函数</em>，这是FP的核心。如果你不明白最后一句话，不要担心，解释它是这篇文章的重点。</p><p id="4de0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们暂时忘记FRP和RP，让我们看看传统的命令式和声明式编程方式之间的区别。为此，我将首先用我们大多数人用JavaScript编写代码的方式编写代码，然后我将使用FP。这将刷新你的思维，如果你以前见过FP，但有点生疏，它将帮助你理解从RP到FRP的过渡，以及为什么这两个术语不是一个意思。我将尽量保持例子的简单，这样它们就容易推理，但是，要完全理解这篇文章，你需要熟悉RP和FP。</p><p id="d692" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题是:</p><p id="5711" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">你有一个保存字符串数组的变量，你的任务是获取每个字符串，修剪它，将其转换为大写字母，然后将新的结果数组打印到浏览器控制台。</em></p><p id="7b11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们永远不会修改原始数组，我们将在整篇文章中使用以下两个变量。除此之外，我将重复我们在每个示例中需要的代码，这样您就有了完整的代码片段，即使您正在使用手机，并且手边没有IDE或代码编辑器，也可以跟着做。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kx"><img src="../Images/b662fc5b544d46054eed9b5b7729424c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oOuDfdmSSc_5CsHSkuKPhw.png"/></div></div></figure><p id="4c80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">传统命令式方式:</strong></p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lc"><img src="../Images/9854fc4fa68f211cd560d41ef1a34499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zumvOvf04bhmu3WJtGTPAg.png"/></div></div></figure><p id="e9e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们对循环使用了一个<strong class="ka ir">，并且我们将方法<strong class="ka ir"> trim </strong>和<strong class="ka ir"> toUpperCase </strong>链接在一起，没有什么新奇的东西，类似于我们可能每天都会看到的代码。</strong></p><p id="d5e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">一种陈述方式:</strong></p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ld"><img src="../Images/88e8aa5cc15b00af711288bafad14c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rjUBXjZ-nyj9jORbigrWHg.png"/></div></div></figure><p id="83ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们以一种可以重用的方式创建了两个变量，并使用了<strong class="ka ir"> Array.prototype.map </strong>方法来实现我们的目标。您可能已经注意到，通过这种方式解决问题，我们的效率很低，因为我们已经遍历了数组两次，首先是修剪值，然后将它们转换为大写。我知道如果我们就这样不管，你今晚会睡不好，我也是；所以让我们做点什么吧。</p><p id="1960" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">改善效率低下:</strong></p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi le"><img src="../Images/e3e2410e2130709e02a19145ae554944.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQdvTnQI__Z-EJSa72M5YQ.png"/></div></div></figure><p id="43d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以感觉更好，现在没有低效率。如果你认为第一个例子中的循环的<strong class="ka ir">比<strong class="ka ir">映射</strong>函数执行得更好更快，我建议你看看这个伟大的演示<a class="ae lf" href="https://www.youtube.com/watch?v=g0ek4vV7nEA" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=g0ek4vV7nEA</a>，我保证，它会改变你的想法。</strong></p><p id="0624" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你是FP的拥护者，或者至少你喜欢它所提倡的东西，你会觉得有些事情看起来不对劲，你会认为有办法做得更好。无论如何，如果我们倾向于一种更实用的方法，我们确实可以做些别的事情。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lg"><img src="../Images/b5c2b60d4262104bdd186b3a3afc100e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tq-4udXR0SIvNKNvZm7PjQ.png"/></div></div></figure><p id="2de4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然你熟悉FP，你至少知道<strong class="ka ir"> pipeAll </strong>变量背后的思想，但我还是会稍微讲一下。<strong class="ka ir"> Array.prototype.reduce </strong></p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lg"><img src="../Images/59f0420bf530fb116cb1c5f40db29fc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GNxdSS71GLSKBTjHwiTerw.png"/></div></div></figure><p id="acb9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的例子中，数组中包含的元素不是数字，而是函数，比如<strong class="ka ir"> trim </strong>和<strong class="ka ir"> toUpperCase </strong>，所有这些函数都是通过将前一个函数返回的结果传递给它们中的每一个来执行的，对于<strong class="ka ir"> words </strong>数组中的每一个值。这就像如果所有这些函数组成一个管道，每个<strong class="ka ir">单词</strong>都要通过它，并且在最后，它已经被修剪并转换成大写字母。如果你仍然不明白，你可能应该看看关于使用<strong class="ka ir"> reduce </strong>的例子，并阅读一篇旨在恰当而全面地解释其工作原理的文章，相信我，这是值得的。</p><p id="bb6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在像兰博达、<a class="ae lf" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"/>这样的库中找到像<strong class="ka ir"> pipeAll </strong>(名字其实是<strong class="ka ir"> pipe </strong>)这样的实现。我想在这段代码中包含实现，而不使用Rambda，这样您就可以看到发生了什么，而不用去任何其他地方，我调用<strong class="ka ir"> pipeAll </strong>而不是<strong class="ka ir"> pipe </strong>的唯一原因是这样它就不会与<strong class="ka ir">pipe</strong><em class="kw">pure</em><strong class="ka ir"><em class="kw"/></strong><em class="kw">函数</em>冲突，您将在<strong class="ka ir">反应式编程</strong>一节中看到。</p><p id="db4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以灵活地“管道化”我们想要的任意多的函数，这给了我们高度的灵活性来组合函数，我们甚至不必创建像<strong class="ka ir"> trimAndUpperCase </strong>这样的变量，我们只需像这样内联<strong class="ka ir"> map </strong>和<strong class="ka ir"> pipeAll </strong>:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lh"><img src="../Images/1d2bab0d011a3c59aed5618ed0b8ce77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mreZR48PrxNoZQo4bwhrog.png"/></div></div></figure><p id="035d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们的代码有了一个声明性的新外观，我们可以通过使用Rambda的<strong class="ka ir"> curry </strong>方法<strong class="ka ir"/><strong class="ka ir"/>来创建我们自己的<strong class="ka ir"> map </strong>版本。然后我们就可以删除前面那行代码中的点符号<em class="kw">了，但是我认为这对本文的目的来说太过分了。还有一点，这并不是真正的纯函数代码，因为我们访问的是<strong class="ka ir">单词</strong>变量，它的作用域并不局限于一个<em class="kw">纯函数</em>和<strong class="ka ir"> </strong>，因为我们是在编写浏览器控制台，但在本文中我们不必如此严格，达到完全纯净并不是我们的目标。</em></p><p id="b42f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我将展示一个简单的RP示例，其中的问题几乎相同，但略有不同(因此我们看到了“反应方式”)。一旦用户点击页面上分配了css类“myButton”的按钮，我们必须将<strong class="ka ir"> words </strong>数组中的值转换成大写字母，并打印到浏览器控制台。我们将使用RxJS库的5.5.11版本，因此可以随意添加一个指向<a class="ae lf" href="https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.5.11/Rx.min.js" rel="noopener ugc nofollow" target="_blank">https://cdnjs . cloud flare . com/Ajax/libs/RxJS/5 . 5 . 11/rx . min . js</a>的脚本标签。</p><p id="188b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">反应式编程:</strong></p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi li"><img src="../Images/c8cc3dc0ed11789f253a3a71c9e7dce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bMESrXUACb5fAORddGoD7Q.png"/></div></div></figure><p id="479f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我知道你已经告诉我你熟悉RP，但是如果你不太记得<strong class="ka ir"> flatMap </strong>是做什么的，你可以看看大卫·威尔森写的这篇很棒的文章:<a class="ae lf" href="https://medium.com/@w.dave.w/becoming-more-reactive-with-rxjs-flatmap-and-switchmap-ccd3fb7b67fa" rel="noopener">https://medium . com/@ w . Dave . w/being-more-reactive-with-rxjs-flat map-and-switch map-CCD 3 FB 7b 67 fa</a>。</p><p id="dced" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是RP，在了解了本文前面的函数式代码之后，我希望最后一个代码示例对您来说一点也不函数式。事实上，RxJS 5引入了几个<em class="kw">纯函数</em>，就是那些允许我们做FRP的函数。</p><p id="589a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">使用<em class="kw">让</em>和新的pure函数更加实用:</strong></p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi le"><img src="../Images/454a5a25337883594622d1890dbc527f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9IZmNYz7-3L3gtDk4XneyQ.png"/></div></div></figure><p id="23b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们使用了<strong class="ka ir"> map </strong>和<strong class="ka ir"> pipe </strong>，它们的RxJS版本，其操作方式与您在本文之前看到的相同。所以，即使你是FRP的新手，这段代码也应该是有意义的，这也是我一开始带你走这条过渡之路的原因，所以把你的心智模型从RP转移到FRP会更容易。</p><p id="c522" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以比这更有功能。让我们看看最后一个代码示例:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lj"><img src="../Images/1ff36920edaddae5769a8e4bf404eb95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yjj9fgwKjZxbHbolfzRLcQ.png"/></div></div></figure><p id="0d23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们以某种方式重构了代码，我们还“管道化”<strong class="ka ir">平面图</strong>，以及<strong class="ka ir"> trim </strong>和<strong class="ka ir"> toUpperCase </strong>，并且我们去掉了<strong class="ka ir"> trimAndUpperCase </strong>变量。希望到现在为止，你能区分RP和FRP，如果你能，我会很高兴，因为这意味着我已经完成了我的目标。</p><p id="855e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你像我一样，当你看到新的技术或方法或范例时，你想知道你能否用它们建立重要的、大的、可维护的、可重用的和可扩展的系统，你想知道你能否用反应式编程做到这一点，总的来说，我建议你观看这个非常有趣的演示:<a class="ae lf" href="https://www.youtube.com/watch?v=XRYN2xt11Ek" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=XRYN2xt11Ek</a>。剧透一下，RP为网飞的大部分开发基础设施提供了动力，包括客户端和服务器端，这应该回答了你的问题。</p><p id="a2b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编码快乐！</p></div></div>    
</body>
</html>