<html>
<head>
<title>Create your first GraphQL app with nodejs and set an auth middleware</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用nodejs创建您的第一个GraphQL应用程序，并设置一个auth中间件</h1>
<blockquote>原文：<a href="https://itnext.io/create-your-first-graphql-app-and-set-an-auth-middleware-2dd841f714c2?source=collection_archive---------1-----------------------#2018-04-02">https://itnext.io/create-your-first-graphql-app-and-set-an-auth-middleware-2dd841f714c2?source=collection_archive---------1-----------------------#2018-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bda4ad7eaf7742703c4a637de0b4f350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z68F4SMRusBjJ7Q8ox4Waw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/photos/Q1p7bh3SHj8?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> NASA </a>在<a class="ae kc" href="https://unsplash.com/search/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><blockquote class="kd ke kf"><p id="a25c" class="kg kh ki kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><a class="ae kc" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fcreate-your-first-graphql-app-and-set-an-auth-middleware-2dd841f714c2%3Futm_source%3Dmedium_sharelink%26utm_medium%3Dsocial%26utm_campaign%3Dbuffer" rel="noopener ugc nofollow" target="_blank">点击这里在LinkedIn上分享这篇文章</a></p></blockquote><p id="2fa2" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我们将使用<a class="ae kc" href="https://github.com/expressjs/express" rel="noopener ugc nofollow" target="_blank"> express </a>和<a class="ae kc" href="https://github.com/brianc/node-postgres" rel="noopener ugc nofollow" target="_blank"> pg </a>创建我们的第一个<a class="ae kc" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>服务器。这个想法是要有一个GraphQL中间件来处理所有的请求，并且在某些情况下，它会使用<a class="ae kc" href="https://github.com/auth0/node-jsonwebtoken" rel="noopener ugc nofollow" target="_blank"> JWT </a>来验证用户是否有效。</p><p id="9852" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">在这种情况下，我们不打算使用<a class="ae kc" href="https://github.com/facebook/dataloader" rel="noopener ugc nofollow" target="_blank">数据加载器</a>，但如果你对它进行研究并尝试在这里实现它会很好……而且在不久的将来，会有一个新帖子使用它。</p><p id="0f34" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><a class="ae kc" href="https://github.com/estrada9166/graphql-basics" rel="noopener ugc nofollow" target="_blank">全额回购</a></p></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><h1 id="2199" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">设置项目:</strong></h1><p id="f27f" class="pw-post-body-paragraph kg kh iq kj b kk mn km kn ko mo kq kr lf mp ku kv lg mq ky kz lh mr lc ld le ij bi translated">首先要做的是设定我们的项目；首先，我们需要做多件事(在终端中):</p><p id="232d" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">为我们的项目创建一个新文件夹。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="8bac" class="nb lq iq mx b gy nc nd l ne nf">mkdir new-graphql-project</span><span id="7307" class="nb lq iq mx b gy ng nd l ne nf">cd new-graphql-project</span><span id="138c" class="nb lq iq mx b gy ng nd l ne nf">npm init -y</span><span id="39bf" class="nb lq iq mx b gy ng nd l ne nf">npm i -s cors dotenv express express-graphql graphql jsonwebtoken pg</span><span id="899e" class="nb lq iq mx b gy ng nd l ne nf">npm i -D nodemon standard</span></pre><h2 id="c85b" class="nb lq iq bd lr nh ni dn lv nj nk dp lz lf nl nm md lg nn no mh lh np nq ml nr bi translated"><strong class="ak">结构:</strong></h2><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="b334" class="nb lq iq mx b gy nc nd l ne nf">|<br/>|—.gitignore<br/>|—node_modules<br/>|—development.env<br/>|—package.json<br/>|—src<br/>   |—App.js<br/>   |—utils<br/>   |—models<br/>   |—schema<br/>       |—mutations<br/>       |—queries<br/>       |—types<br/>       |—index.js</span></pre><p id="f601" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><strong class="kj ir"> src/App.js: </strong></p><p id="2957" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">创建项目后，我们应该做的第一件事是创建服务器:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="dc06" class="nb lq iq mx b gy nc nd l ne nf"><em class="ki">const</em> express = require('express')<br/><em class="ki">const</em> graphqlHTTP = require('express-graphql')<br/><em class="ki">const</em> cors = require('cors')<br/><em class="ki">const</em> pg = require('pg')</span><span id="4890" class="nb lq iq mx b gy ng nd l ne nf"><em class="ki">const</em> pgPool = new pg.Pool({ database: 'mydb' })</span><span id="143d" class="nb lq iq mx b gy ng nd l ne nf"><em class="ki">const</em> app = express()</span><span id="46ac" class="nb lq iq mx b gy ng nd l ne nf"><em class="ki">if</em> (process.env.NODE_ENV === 'development') {<br/>  require('dotenv').config({ path: 'development.env' })<br/>}</span><span id="8b20" class="nb lq iq mx b gy ng nd l ne nf">app.set('port', process.env.PORT || 7000)</span><span id="6a7d" class="nb lq iq mx b gy ng nd l ne nf"><em class="ki">const</em> ncSchema = require('./schema')</span><span id="1469" class="nb lq iq mx b gy ng nd l ne nf">app.use('/graphql', cors(), (req, res) <em class="ki">=&gt;</em> {<br/>  graphqlHTTP({<br/>    schema: ncSchema,<br/>    graphiql: process.env.NODE_ENV === 'development',<br/>    context: { pgPool, req }<br/>  })(req, res)<br/>})</span><span id="41d7" class="nb lq iq mx b gy ng nd l ne nf"><em class="ki">const</em> server = app.listen(app.get('port'), () <em class="ki">=&gt;</em> {<br/>  console.log(`Server running -&gt; PORT ${server.address().port}`)<br/>})</span><span id="0f2f" class="nb lq iq mx b gy ng nd l ne nf">module.exports = app</span></pre><p id="c262" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">有很多信息，所以让我们一步一步来:</p><ol class=""><li id="bd99" class="ns nt iq kj b kk kl ko kp lf nu lg nv lh nw le nx ny nz oa bi translated">需要我们安装的所有外部模块</li></ol><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="9a0e" class="nb lq iq mx b gy nc nd l ne nf"><em class="ki">const</em> express = require('express')<br/><em class="ki">const</em> graphqlHTTP = require('express-graphql')<br/><em class="ki">const</em> cors = require('cors')<br/><em class="ki">const</em> pg = require('pg')</span></pre><p id="39a0" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">2.为数据库创建一个新池。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="dde5" class="nb lq iq mx b gy nc nd l ne nf"><em class="ki">const</em> pgPool = new pg.Pool({ database: 'mydb' })</span></pre><p id="14b4" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">3.启动express，设置环境变量(如果是<code class="fe ob oc od mx b">NODE_ENV === ‘development’</code>并设置端口(如果没有设置，则默认为<code class="fe ob oc od mx b">7000</code>)</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="0061" class="nb lq iq mx b gy nc nd l ne nf"><em class="ki">const</em> app = express()</span><span id="d87c" class="nb lq iq mx b gy ng nd l ne nf"><em class="ki">if</em> (process.env.NODE_ENV === 'development') {<br/>  require('dotenv').config({ path: 'development.env' })<br/>}</span><span id="adab" class="nb lq iq mx b gy ng nd l ne nf">app.set('port', process.env.PORT || 7000)</span></pre><p id="baff" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">4.导入<code class="fe ob oc od mx b">schema</code>，设置<code class="fe ob oc od mx b">GraphQL</code>为中间件:</p><p id="9da9" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">如果这是第一次使用GraphQL，那么如何在一个中间件中处理所有的路由可能会令人困惑；所以，有很多事情你必须首先知道:</p><ul class=""><li id="b3e0" class="ns nt iq kj b kk kl ko kp lf nu lg nv lh nw le oe ny nz oa bi translated">有质疑，有突变。</li><li id="ee89" class="ns nt iq kj b kk of ko og lf oh lg oi lh oj le oe ny nz oa bi translated">当你发出一个请求时，你设置它是一个查询还是一个变异，然后GraphQL会处理它。</li><li id="3468" class="ns nt iq kj b kk of ko og lf oh lg oi lh oj le oe ny nz oa bi translated">可以在查询或突变时调用上下文，我们将使用上下文连接到数据库并获取请求数据。</li><li id="8473" class="ns nt iq kj b kk of ko og lf oh lg oi lh oj le oe ny nz oa bi translated">每个查询或变异都有一个类型，即响应请求的类型。</li><li id="d6fa" class="ns nt iq kj b kk of ko og lf oh lg oi lh oj le oe ny nz oa bi translated">graphiql是一个客户端进行查询和突变，建议只在开发时设置。</li></ul><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="1e45" class="nb lq iq mx b gy nc nd l ne nf"><em class="ki">const</em> ncSchema = require('./schema')</span><span id="6df9" class="nb lq iq mx b gy ng nd l ne nf">app.use('/graphql', cors(), (req, res) <em class="ki">=&gt;</em> {<br/>  graphqlHTTP({<br/>    schema: ncSchema,<br/>    graphiql: process.env.NODE_ENV === 'development',<br/>    context: { pgPool, req }<br/>  })(req, res)<br/>})</span></pre><p id="2051" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">5.启动服务器:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="56a2" class="nb lq iq mx b gy nc nd l ne nf"><em class="ki">const</em> server = app.listen(app.get('port'), () <em class="ki">=&gt;</em> {<br/>  console.log(`Server running -&gt; PORT ${server.address().port}`)<br/>})</span></pre><p id="b75e" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><strong class="kj ir"> development.env: </strong></p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="e5ad" class="nb lq iq mx b gy nc nd l ne nf">PORT="YOUR_FAVORITE_PORT"<br/>DATABASE_URL="YOUR_DATABASE_URL"<br/>JWT_KEY="YOUR_JWT_KEY"</span></pre><p id="9fdc" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><strong class="kj ir"> package.json: </strong></p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="6a3c" class="nb lq iq mx b gy nc nd l ne nf">"scripts": {<br/>  "dev": "NODE_ENV=development nodemon src/App.js",<br/>  "standard": "standard",<br/>  "standard-fix": "standard --fix"<br/>}</span></pre><h2 id="6d61" class="nb lq iq bd lr nh ni dn lv nj nk dp lz lf nl nm md lg nn no mh lh np nq ml nr bi translated">models/pgdb.js:</h2><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/4ab4fb712afd6ad67b59e2dea5bb0fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gzCEy98pmhxBkwCujcqB3A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">数据库模型</figcaption></figure><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="0673" class="nb lq iq mx b gy nc nd l ne nf"><em class="ki">const</em> { signToken } = require('../utils')</span><span id="4088" class="nb lq iq mx b gy ng nd l ne nf">module.exports = pgPool <em class="ki">=&gt;</em> {<br/>  <em class="ki">return</em> {<br/>    addNewUser ({ username, email }) {<br/>      <em class="ki">return</em> pgPool.query(`<br/>        insert into users (username, email)<br/>        values ($1, $2) returning *<br/>      `, [username, email])<br/>      .then(res <em class="ki">=&gt;</em> {<br/>        <em class="ki">const</em> user = res.rows[0]<br/>        user.apiKey = signToken(user)<br/>        <em class="ki">return</em> user<br/>      })<br/>    },</span><span id="3fbf" class="nb lq iq mx b gy ng nd l ne nf">    addNewVisitedPlace ({ userId, place }) {<br/>      <em class="ki">return</em> pgPool.query(`<br/>        insert into visitedplaces (user_id, place)<br/>        values ($1, $2) returning *<br/>      `, [userId, place])<br/>      .then(res <em class="ki">=&gt;</em> {<br/>        <em class="ki">return</em> res.rows[0]<br/>      })<br/>    },</span><span id="7b84" class="nb lq iq mx b gy ng nd l ne nf">    getUserById (userId) {<br/>      <em class="ki">return</em> pgPool.query(`<br/>        select * from users where id = $1<br/>      `, [userId])<br/>      .then(res <em class="ki">=&gt;</em> {<br/>        <em class="ki">return</em> res.rows[0]<br/>      })<br/>    },</span><span id="8f3e" class="nb lq iq mx b gy ng nd l ne nf">    getVisitedPlaces (userId) {<br/>      <em class="ki">return</em> pgPool.query(`<br/>        select place from visitedplaces where user_id = $1<br/>      `, [userId])<br/>      .then(res <em class="ki">=&gt;</em> {<br/>        <em class="ki">return</em> res.rows<br/>      })<br/>    }<br/>  }<br/>}</span></pre><p id="72ec" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我们需要创建4个查询，其中2个用于插入，另外2个用于选择。如你所见，这些是一些基本的查询，有些返回一个数组，有些只返回一行。此外，当我们创建一个新用户时，我们需要返回apiKey，也就是我们需要使用<code class="fe ob oc od mx b">Bearer</code>作为头或者使用<code class="fe ob oc od mx b">access_token</code>作为查询传递的API key。</p><h2 id="233c" class="nb lq iq bd lr nh ni dn lv nj nk dp lz lf nl nm md lg nn no mh lh np nq ml nr bi translated">utils/index.js:</h2><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="6e79" class="nb lq iq mx b gy nc nd l ne nf"><em class="ki">const</em> jwt = require('jsonwebtoken')</span><span id="7b6d" class="nb lq iq mx b gy ng nd l ne nf"><em class="ki">const</em> signToken = str <em class="ki">=&gt;</em> {<br/>  <em class="ki">return</em> new Promise(resolve <em class="ki">=&gt;</em> {<br/>    resolve(jwt.sign({ apiKey: str }, process.env.JWT_KEY))<br/>  })<br/>}</span><span id="3ac5" class="nb lq iq mx b gy ng nd l ne nf"><em class="ki">const</em> verifyJwt = req <em class="ki">=&gt;</em> {<br/>  <em class="ki">let</em> token<br/>  <em class="ki">if</em> (req.query &amp;&amp; req.query.hasOwnProperty('access_token')) {<br/>    token = req.query.access_token<br/>  } <em class="ki">else</em> <em class="ki">if</em> (req.headers.authorization &amp;&amp; req.headers.authorization.includes('Bearer')) {<br/>    token = req.headers.authorization.split(' ')[1]<br/>  }<br/>  <br/>  <em class="ki">return</em> new Promise((resolve, reject) <em class="ki">=&gt;</em> {<br/>    jwt.verify(token, process.env.JWT_KEY, (error, decoded) <em class="ki">=&gt;</em> {<br/>      <em class="ki">if</em> (error) reject('401: User is not authenticated')<br/>   <br/>      resolve(decoded)<br/>    })<br/>  })<br/>}</span><span id="d8a6" class="nb lq iq mx b gy ng nd l ne nf">module.exports = { signToken, verifyJwt }</span></pre><p id="d3fc" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我们需要创建两个方法；一个是对我们创建用户时要返回的令牌进行签名，另一个是验证令牌是否得到了查询或授权头。</p><p id="57a8" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">查询:<code class="fe ob oc od mx b">&amp;access_token=&lt;YOUR_TOKEN&gt;</code></p><p id="06ca" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">授权:<code class="fe ob oc od mx b">Bearer &lt;YOUR_TOKEN&gt;</code></p></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><h1 id="1ab2" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">GraphQL魔法</h1><p id="b50a" class="pw-post-body-paragraph kg kh iq kj b kk mn km kn ko mo kq kr lf mp ku kv lg mq ky kz lh mr lc ld le ij bi translated">既然我们已经完成了需要继续的不同文件的设置，我们将从GraphQL的所有神奇之处开始。</p><h2 id="bbf0" class="nb lq iq bd lr nh ni dn lv nj nk dp lz lf nl nm md lg nn no mh lh np nq ml nr bi translated">类型:</h2><p id="996a" class="pw-post-body-paragraph kg kh iq kj b kk mn km kn ko mo kq kr lf mp ku kv lg mq ky kz lh mr lc ld le ij bi translated">在这里，我们定义我们希望对发出请求的用户做出什么样的响应，我们可以在这里添加一些验证，还可以定义我们要返回什么类型的数据。\</p><ul class=""><li id="f3f5" class="ns nt iq kj b kk kl ko kp lf nu lg nv lh nw le oe ny nz oa bi translated">有不同类型的类型，我们应该从<code class="fe ob oc od mx b">graphql</code>导入，并设置什么样的数据是我们正在返回的。</li><li id="6f60" class="ns nt iq kj b kk of ko og lf oh lg oi lh oj le oe ny nz oa bi translated">每种类型必须是一个<code class="fe ob oc od mx b">GraphQLObjectType</code>，它将有多个属性，如名称和字段(返回时用户将获得的值)。</li><li id="b4b3" class="ns nt iq kj b kk of ko og lf oh lg oi lh oj le oe ny nz oa bi translated">每个字段都必须有一个类型(在这里我们设置了之前导入的类型),并且它还可以有一个解析。</li><li id="145b" class="ns nt iq kj b kk of ko og lf oh lg oi lh oj le oe ny nz oa bi translated">Resolve:这是一个接收3个参数的函数，实际的对象、参数和上下文，在resolve中我们可以处理不同的逻辑，比如检查令牌是否有效的auth中间件；同样，当我们返回一个值时，我们可以返回一个承诺而不解析它，GraphQL会处理它。</li></ul><h2 id="ca26" class="nb lq iq bd lr nh ni dn lv nj nk dp lz lf nl nm md lg nn no mh lh np nq ml nr bi translated">架构/类型/me.js:</h2><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="178e" class="nb lq iq mx b gy nc nd l ne nf"><em class="ki">const</em> { <br/>  GraphQLID,<br/>  GraphQLObjectType,<br/>  GraphQLString,<br/>  GraphQLNonNull<br/>} = require('graphql')</span><span id="7c65" class="nb lq iq mx b gy ng nd l ne nf"><em class="ki">const</em> MeType = new GraphQLObjectType({<br/>  name: 'Me',<br/>  fields: () <em class="ki">=&gt;</em> {<br/>    <em class="ki">return</em> {<br/>      id: { type: GraphQLNonNull(GraphQLID) },<br/>      email: { type: GraphQLNonNull(GraphQLString) },<br/>      username: { type: GraphQLNonNull(GraphQLString) },<br/>      apiKey: { type: GraphQLNonNull(GraphQLString) }<br/>    }<br/>  }<br/>})</span><span id="9c8e" class="nb lq iq mx b gy ng nd l ne nf">module.exports = MeType</span></pre><p id="c467" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">当我们要使用meType时；我们可以要求查询返回:</p><ul class=""><li id="3ba5" class="ns nt iq kj b kk kl ko kp lf nu lg nv lh nw le oe ny nz oa bi translated">email:是一个不能为空的字符串。</li><li id="f7a8" class="ns nt iq kj b kk of ko og lf oh lg oi lh oj le oe ny nz oa bi translated">用户名:它是一个不能为空的字符串。</li><li id="9693" class="ns nt iq kj b kk of ko og lf oh lg oi lh oj le oe ny nz oa bi translated">apiKey:是一个不能为空的字符串。</li></ul><h2 id="9656" class="nb lq iq bd lr nh ni dn lv nj nk dp lz lf nl nm md lg nn no mh lh np nq ml nr bi translated">schema/types/places.js:</h2><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="ea10" class="nb lq iq mx b gy nc nd l ne nf"><em class="ki">const</em> {<br/>  GraphQLObjectType,<br/>  GraphQLString,<br/>  GraphQLNonNull,<br/>} = require('graphql')</span><span id="23bb" class="nb lq iq mx b gy ng nd l ne nf"><em class="ki">const</em> PlacesType = new GraphQLObjectType({<br/>  name: 'Place',<br/>  fields: () <em class="ki">=&gt;</em> {<br/>    <em class="ki">return</em> {<br/>      place: { type: GraphQLNonNull(GraphQLString) },<br/>    }<br/>  }<br/>})</span><span id="ea9d" class="nb lq iq mx b gy ng nd l ne nf">module.exports = PlacesType</span></pre><p id="9677" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">当我们要使用PlacesType时；我们可以要求查询返回:</p><ul class=""><li id="cc00" class="ns nt iq kj b kk kl ko kp lf nu lg nv lh nw le oe ny nz oa bi translated">place:是一个不能为空的字符串。</li></ul><h2 id="3f58" class="nb lq iq bd lr nh ni dn lv nj nk dp lz lf nl nm md lg nn no mh lh np nq ml nr bi translated">模式/类型/用户. js:</h2><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="cae1" class="nb lq iq mx b gy nc nd l ne nf"><em class="ki">const</em> {<br/>  GraphQLObjectType,<br/>  GraphQLString,<br/>  GraphQLNonNull,<br/>  GraphQLList<br/>} = require('graphql')</span><span id="7513" class="nb lq iq mx b gy ng nd l ne nf"><em class="ki">const</em> { verifyJwt } = require('../../utils')<br/><em class="ki">const</em> pgdb = require('../../models/pgdb')</span><span id="892f" class="nb lq iq mx b gy ng nd l ne nf"><em class="ki">const</em> UsersType = new GraphQLObjectType({<br/>  name: 'Users',<br/>  fields: () <em class="ki">=&gt;</em> {<br/>    <em class="ki">const</em> PlacesType = require('./places')<br/>    <em class="ki">return</em> {<br/>      email: { type: GraphQLNonNull(GraphQLString) },<br/>      username: { type: GraphQLNonNull(GraphQLString) },<br/>      visitedPlaces: {<br/>        type: new GraphQLList(PlacesType),<br/>        resolve: async (obj, args, { pgPool, req }) <em class="ki">=&gt;</em> {<br/>          <em class="ki">try</em> {<br/>            <em class="ki">await</em> verifyJwt(req)<br/>            <em class="ki">return</em> pgdb(pgPool).getVisitedPlaces(obj.id)<br/>          } <em class="ki">catch</em> (err) {<br/>            <em class="ki">return</em> []<br/>          }<br/>        }<br/>      }<br/>    }<br/>  }<br/>})</span><span id="6387" class="nb lq iq mx b gy ng nd l ne nf">module.exports = UsersType</span></pre><p id="fb28" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">这种型号和其他型号有点不同。</p><p id="a4af" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我们要求<code class="fe ob oc od mx b">verifyJwt</code>；它将用于验证我们传递的令牌是否有效，如果无效，我们将在访问过的地方返回一个空数组。</p><p id="5aa7" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">你可能注意到的另一件新事情是，我们正在使用<code class="fe ob oc od mx b">GraphQLList</code>和<code class="fe ob oc od mx b">resolve</code>。</p><p id="9d50" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">GraphQLList会让GraphQL知道我们要返回placesType的列表(数组)。</p><p id="0391" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">Resolve将是<code class="fe ob oc od mx b">async/await</code>，因为我们想首先检查令牌是否有效，所以我们将<code class="fe ob oc od mx b">(obj, args, { pgPool, req })</code>作为参数传递，其中<code class="fe ob oc od mx b">obj</code>是我们从用户那里得到的完整响应，<code class="fe ob oc od mx b">pgPool</code>是我们在<code class="fe ob oc od mx b">App.js</code>上设置的数据库池，<code class="fe ob oc od mx b">req</code>是来自express的请求。然后我们验证令牌是否有效，如果有效，我们在数据库中搜索用户访问过的所有地方并返回它们。</p><h2 id="43a4" class="nb lq iq bd lr nh ni dn lv nj nk dp lz lf nl nm md lg nn no mh lh np nq ml nr bi translated">查询:</h2><p id="538b" class="pw-post-body-paragraph kg kh iq kj b kk mn km kn ko mo kq kr lf mp ku kv lg mq ky kz lh mr lc ld le ij bi translated">查询是我们想要设置让GraphQL对我们的数据库执行的<code class="fe ob oc od mx b">/GET</code>的地方，我们在查询中设置我们想要给出的响应类型，因此我们可以确定我们想要共享哪些数据。</p><h2 id="a28c" class="nb lq iq bd lr nh ni dn lv nj nk dp lz lf nl nm md lg nn no mh lh np nq ml nr bi translated">模式/查询/getUser.js:</h2><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="8e89" class="nb lq iq mx b gy nc nd l ne nf"><em class="ki">const</em> { GraphQLID, GraphQLNonNull } = require('graphql')</span><span id="ac9f" class="nb lq iq mx b gy ng nd l ne nf"><em class="ki">const</em> UserType = require('../types/users')<br/><em class="ki">const</em> pgdb = require('../../models/pgdb')</span><span id="1d11" class="nb lq iq mx b gy ng nd l ne nf">module.exports = {<br/>  type: UserType,<br/>  description: 'This query will search for a user with userId',<br/>  args: {<br/>    userId: { type: new GraphQLNonNull(GraphQLID) }<br/>  },<br/>  resolve (obj, { userId }, { pgPool, req }) {<br/>    <em class="ki">return</em> pgdb(pgPool).getUserById(userId)<br/>  }<br/>}</span></pre><p id="4b6d" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">该查询将具有我们已经在类型上定义的类型；可选的描述；args是可选的，它是一个带有查询将接收的参数的对象，而且，它必须有一个类型；并解析我们在哪里做所有的逻辑来响应，在这种情况下，查询正在等待获取<code class="fe ob oc od mx b">userId</code>，它将使用它对数据库进行查询。</p><h2 id="e96f" class="nb lq iq bd lr nh ni dn lv nj nk dp lz lf nl nm md lg nn no mh lh np nq ml nr bi translated">突变:</h2><p id="c0a7" class="pw-post-body-paragraph kg kh iq kj b kk mn km kn ko mo kq kr lf mp ku kv lg mq ky kz lh mr lc ld le ij bi translated">突变是让我们将信息保存到数据库的查询。我们在突变中设置我们想要给出的响应类型，这样我们就可以确定我们想要共享哪些数据。</p><h2 id="c73c" class="nb lq iq bd lr nh ni dn lv nj nk dp lz lf nl nm md lg nn no mh lh np nq ml nr bi translated">schema/mutations/addUser.js:</h2><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="1d5a" class="nb lq iq mx b gy nc nd l ne nf"><em class="ki">const</em> {<br/>  GraphQLInputObjectType,<br/>  GraphQLString,<br/>  GraphQLNonNull<br/>} = require('graphql')</span><span id="5303" class="nb lq iq mx b gy ng nd l ne nf"><em class="ki">const</em> pgdb = require('../../models/pgdb')<br/><em class="ki">const</em> MeType = require('../types/me')</span><span id="a575" class="nb lq iq mx b gy ng nd l ne nf"><em class="ki">const</em> UserInputType = new GraphQLInputObjectType({<br/>  name: 'UserInput',<br/>  fields: {<br/>    email: { type: GraphQLNonNull(GraphQLString) },<br/>    username: { type: GraphQLNonNull(GraphQLString) }<br/>  }<br/>})</span><span id="ce00" class="nb lq iq mx b gy ng nd l ne nf">module.exports = {<br/>  type: MeType,<br/>  description: 'This mutation will create a new user and it will<br/>    return a apiKey',<br/>  args: {<br/>    input: { type: new GraphQLNonNull(UserInputType) }<br/>  },<br/>  resolve: async (obj, { input }, { pgPool }) <em class="ki">=&gt;</em> {<br/>    <em class="ki">return</em> pgdb(pgPool).addNewUser(input)<br/>  }<br/>}</span></pre><p id="47db" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我们需要定义<code class="fe ob oc od mx b">GraphQLInputObjectType</code>,这是我们将在args上接收的类型。</p><h2 id="9161" class="nb lq iq bd lr nh ni dn lv nj nk dp lz lf nl nm md lg nn no mh lh np nq ml nr bi translated">schema/mutations/addvisitedplaces . js:</h2><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="13bc" class="nb lq iq mx b gy nc nd l ne nf"><em class="ki">const</em> {<br/>  GraphQLInputObjectType,<br/>  GraphQLID,<br/>  GraphQLString,<br/>  GraphQLNonNull<br/>} = require('graphql')</span><span id="8911" class="nb lq iq mx b gy ng nd l ne nf"><em class="ki">const</em> { verifyJwt } = require('../../utils')<br/><em class="ki">const</em> pgdb = require('../../models/pgdb')<br/><em class="ki">const</em> UsersType = require('../types/users')</span><span id="e532" class="nb lq iq mx b gy ng nd l ne nf"><em class="ki">const</em> VisitedInputType = new GraphQLInputObjectType({<br/>  name: 'VisitedInput',<br/>  fields: {<br/>    userId: { type: GraphQLNonNull(GraphQLID) },<br/>    place: { type: GraphQLNonNull(GraphQLString) }<br/>  }<br/>})</span><span id="4fb8" class="nb lq iq mx b gy ng nd l ne nf">module.exports = {<br/>  type: UsersType,<br/>  description: 'This mutation will add a new visited place',<br/>  args: {<br/>    input: { type: new GraphQLNonNull(VisitedInputType) }<br/>  },<br/>  resolve: async (obj, { input }, { pgPool, req }) <em class="ki">=&gt;</em> {<br/>    <em class="ki">await</em> verifyJwt(req)<br/>    <em class="ki">await</em> pgdb(pgPool).addNewVisitedPlace(input)<br/>    <em class="ki">return</em> pgdb(pgPool).getUserById(input.userId)<br/>  }<br/>}</span></pre><p id="a97e" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">首先，我们要验证令牌是否有效，然后在数据库中保存一个新的访问过的地方。验证之后，我们保存信息，然后用用户和访问过的地方的数据进行响应。如果令牌无效，它将返回一个错误<code class="fe ob oc od mx b">401: User is not authenticated</code>。</p><h2 id="0b4f" class="nb lq iq bd lr nh ni dn lv nj nk dp lz lf nl nm md lg nn no mh lh np nq ml nr bi translated">架构/索引. js:</h2><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="571a" class="nb lq iq mx b gy nc nd l ne nf"><em class="ki">const</em> { GraphQLSchema, GraphQLObjectType } = require('graphql')</span><span id="3b77" class="nb lq iq mx b gy ng nd l ne nf"><em class="ki"><br/>const</em> GetUser = require('./queries/getUser')</span><span id="d22b" class="nb lq iq mx b gy ng nd l ne nf"><em class="ki">const</em> AddNewUserMutation = require('./mutations/addUser')<br/><em class="ki">const</em> AddVisitedPlaceMutation = require('./mutations/addVisitedPlace')</span><span id="0a77" class="nb lq iq mx b gy ng nd l ne nf"><em class="ki">const</em> RootQueryType = new GraphQLObjectType({<br/>  name: 'RootQuery',<br/>  fields: () <em class="ki">=&gt;</em> ({<br/>    user: GetUser<br/>  })<br/>})</span><span id="39f2" class="nb lq iq mx b gy ng nd l ne nf"><em class="ki">const</em> RootMutationType = new GraphQLObjectType({<br/>  name: 'RootMutation',<br/>  fields: () <em class="ki">=&gt;</em> ({<br/>    AddUser: AddNewUserMutation,<br/>    AddVisitedPlace: AddVisitedPlaceMutation<br/>  })<br/>})</span><span id="118d" class="nb lq iq mx b gy ng nd l ne nf"><em class="ki">const</em> ncSchema = new GraphQLSchema({<br/>  query: RootQueryType,<br/>  mutation: RootMutationType<br/>})</span><span id="7839" class="nb lq iq mx b gy ng nd l ne nf">module.exports = ncSchema</span></pre><p id="5be8" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">现在我们想定义如何使用我们的<code class="fe ob oc od mx b">GraphQLSchema</code>，因此，我们为查询创建了一个<code class="fe ob oc od mx b">GraphQLObjectType</code>,并为将在下面使用的突变创建了另一个<code class="fe ob oc od mx b">GraphQLObjectType</code>:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="e320" class="nb lq iq mx b gy nc nd l ne nf"><em class="ki">const</em> ncSchema = new GraphQLSchema({<br/>  query: RootQueryType,<br/>  mutation: RootMutationType<br/>})</span></pre></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><h1 id="5c87" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">如何测试？</strong></h1><p id="9e52" class="pw-post-body-paragraph kg kh iq kj b kk mn km kn ko mo kq kr lf mp ku kv lg mq ky kz lh mr lc ld le ij bi translated">在创建了整个项目之后，我们可以开始测试它，所以请遵循下面的步骤:</p><p id="8eeb" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><code class="fe ob oc od mx b">npm run dev</code></p><p id="a4b5" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">在您的浏览器上，使用您设置的端口和<code class="fe ob oc od mx b">/graphql</code>打开本地主机。它将打开一个很好的客户端来测试GraphQL。</p><h2 id="33fc" class="nb lq iq bd lr nh ni dn lv nj nk dp lz lf nl nm md lg nn no mh lh np nq ml nr bi translated">添加新用户:</h2><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/80614456e00a43502d3a0f54a635d3fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jpHyUbGms7o88N1sQJ2mjg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">打开查询变量来设置变异所需的变量</figcaption></figure><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="3594" class="nb lq iq mx b gy nc nd l ne nf">mutation AddNewUser($input: UserInput!) {<br/>  AddUser(input: $input) { <br/>    id<br/>    email<br/>    username<br/>    apiKey<br/>  }<br/>}</span><span id="4332" class="nb lq iq mx b gy ng nd l ne nf">{<br/>  "input": {<br/>    "email": "<a class="ae kc" href="mailto:test@test.com" rel="noopener ugc nofollow" target="_blank">test@test.com</a>",<br/>    "username": "test"<br/>  }<br/>}</span></pre><h2 id="4d35" class="nb lq iq bd lr nh ni dn lv nj nk dp lz lf nl nm md lg nn no mh lh np nq ml nr bi translated">添加参观过的地方:</h2><p id="b7d4" class="pw-post-body-paragraph kg kh iq kj b kk mn km kn ko mo kq kr lf mp ku kv lg mq ky kz lh mr lc ld le ij bi translated">要添加一个新的访问过的地方，您必须将从前面的变异中获得的apiKey设置为query或header。</p><p id="24b7" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">要设置为查询添加到URL <code class="fe ob oc od mx b">&amp;access_token=&lt;API_KEY&gt;</code>。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/fc23e9ef42b6c064e14bbc4b79614b15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UUU0dqu-6qlF0NBVMcVK_A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">打开查询变量来设置变异所需的变量</figcaption></figure><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="fcd4" class="nb lq iq mx b gy nc nd l ne nf">mutation AddVisitedPlace($input: VisitedInput!) {<br/>  AddVisitedPlace(input: $input) {<br/>    email<br/>    username<br/>    visitedPlaces {<br/>      place<br/>    }<br/>  }<br/>}</span><span id="3e19" class="nb lq iq mx b gy ng nd l ne nf">{<br/>  "input": {<br/>    "userId": 5,<br/>    "place": "MIA"<br/>  }<br/>}</span></pre><h2 id="3a95" class="nb lq iq bd lr nh ni dn lv nj nk dp lz lf nl nm md lg nn no mh lh np nq ml nr bi translated">获取用户访问过的地点:</h2><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi on"><img src="../Images/ff1238486c9d06cb84a17ba4f808d577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pf3SA1arePlAqRGxXTbCCw.png"/></div></div></figure><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="4a8b" class="nb lq iq mx b gy nc nd l ne nf">{<br/>  user(userId: 5) {<br/>    username<br/>    email<br/>    visitedPlaces {<br/>      place<br/>    }<br/>  }<br/>}</span></pre></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><p id="36d2" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">您可以查看完整回购<a class="ae kc" href="https://github.com/estrada9166/graphql-basics" rel="noopener ugc nofollow" target="_blank">这里</a></p><p id="1c33" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">GraphQL的相关帖子:</p><h2 id="08c8" class="nb lq iq bd lr nh ni dn lv nj nk dp lz lf nl nm md lg nn no mh lh np nq ml nr bi translated"><a class="ae kc" href="https://medium.com/@estrada9166/return-custom-errors-with-status-code-on-graphql-45fca360852" rel="noopener">在GraphQL上返回带有状态代码的自定义错误</a></h2></div></div>    
</body>
</html>