<html>
<head>
<title>How to Download Files With JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用JavaScript下载文件</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-download-files-with-javascript-d5a69b749896?source=collection_archive---------0-----------------------#2021-04-26">https://itnext.io/how-to-download-files-with-javascript-d5a69b749896?source=collection_archive---------0-----------------------#2021-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/113717472c6a5d1e307aa1bc0208c4a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fZA3JygQCWiqfOfHwfzrqg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@pankajpatel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">潘卡杰·帕特尔</a>在<a class="ae kf" href="https://unsplash.com/s/photos/loading?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6484" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下载文件是网上冲浪的一个重要方面。每天从互联网上下载大量文件，从二进制文件(如应用程序、图像、视频和音频)到纯文本文件。</p><p id="f6f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你有一个web开发人员，你想把这个特性添加到你的应用程序中，你可以这样做。</p><p id="4d13" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将考察3种不同的方法:</p><ul class=""><li id="a85d" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">仅使用HTML元素的基本模式；</li><li id="9881" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">使用带有<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank"> Fetch API </a>和HTML元素的JavaScript</li><li id="04d3" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">使用XMLHttpRequest和HTML元素，但是在一个更复杂的场景中，我们实现了一个测量进度的系统；</li></ul><h1 id="a8b6" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">方法一</h1><p id="1c52" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">第一种也是最简单的方法意味着创建一个具有<code class="fe mv mw mx my b">download</code>属性的锚HTML元素。</p><p id="d4d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据定义，<code class="fe mv mw mx my b">download</code>属性指定当用户点击超链接时，目标(在<code class="fe mv mw mx my b">href</code>属性中指定的文件)将被下载。</p><p id="e1ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，使用这个<code class="fe mv mw mx my b">download</code>属性，我们可以在下载后指定文件的新名称。因此，如果我们想下载一个特定名称的文件，我们可以使用这个属性来控制它。但是，当本地下载窗口出现时，用户仍然可以更改名称，但是我们提供的名称将是默认名称。</p><p id="a334" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果省略该值，则使用原始文件名。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/2ee31f40c3aaa0c4f71539922cecc530.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pOBDf4nsNZSpG2eWykfR2Q.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://carbon.now.sh/?bg=rgba%28171%2C+184%2C+195%2C+1%29&amp;t=seti&amp;wt=none&amp;l=htmlmixed&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=true&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fl=1&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=%253Ca%2520href%253D%2522https%253A%252F%252Ft-bucket.sfo3.digitaloceanspaces.com%252F100mb.txt%2522%2520download%250A%2520%2520%253EDownload%2520100mb.txt%253C%252Fa%250A%253E" rel="noopener ugc nofollow" target="_blank">原始</a></figcaption></figure><p id="6ad2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们不需要基于这个下载过程做任何动作的时候，这个方法是很棒的。</p><p id="4607" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同时，我们可以使用这个方法，即使我们不能使用JavaScript呈现锚HTML元素。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/a5aa5e6c4350d1d967eedc95ff2e8e34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3jSH62zFcdkyE_HfB01Pxw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://carbon.now.sh/?bg=rgba%28171%2C+184%2C+195%2C+1%29&amp;t=seti&amp;wt=none&amp;l=javascript&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=true&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fl=1&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=function%2520downloadUsingAnchorElement%28%29%2520%257B%250A%2520%2520const%2520anchor%2520%253D%2520document.createElement%28%2522a%2522%29%253B%250A%2520%2520anchor.href%2520%253D%2520IMG_URL%253B%250A%2520%2520anchor.download%2520%253D%2520FILE_NAME%253B%250A%2520%2520%250A%2520%2520document.body.appendChild%28anchor%29%253B%250A%2520%2520anchor.click%28%29%253B%250A%2520%2520document.body.removeChild%28anchor%29%253B%250A%257D" rel="noopener ugc nofollow" target="_blank">生</a></figcaption></figure><p id="cea3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的函数做的是一样的，只是我们创建了锚HTML元素，只是为了这个下载动作，然后我们删除它。</p><ul class=""><li id="0903" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated"><code class="fe mv mw mx my b">IMG_URL</code>是我们要下载的图片的网址；</li><li id="3595" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><code class="fe mv mw mx my b">FILE_NAME</code>是文件下载后的新名称；</li></ul><p id="2ae2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个方法的限制是它必须遵守<em class="nf">同源策略</em>，因此这个属性对于同源URL是正确的。</p><p id="ab95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个常见的情况是，当您想从另一个服务器下载图像，而不是下载它，浏览器会在一个新的标签中打开它。</p><p id="9b67" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种方法的关键在于下载过程会自动开始，并且可以在浏览器中直接查看。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/3228c665a1e8bcc48b730ed4e13e7e80.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*BIsUxlHwgkVTR0hCu6aFRg.png"/></div></figure><p id="8aef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意上图中下载过程是如何被发送到浏览器来管理的，浏览器提供了对它的控制并显示进度。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h2 id="3c6b" class="no lt it bd lu np nq dn ly nr ns dp mc kr nt nu mg kv nv nw mk kz nx ny mo nz bi translated">方法二</h2><p id="7bea" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">第二个方法和第三个方法对anchor元素使用了相同的技术，但是我们没有提供图像URL，而是将文件的内容转换为一个<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" rel="noopener ugc nofollow" target="_blank"> Blob </a>，然后使用<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL" rel="noopener ugc nofollow" target="_blank"> createObjectURL </a>方法从中创建<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/DOMString" rel="noopener ugc nofollow" target="_blank"> DOMString </a>。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/b15b3dd8717ed2642fffb27e05f05229.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eAaG3qS538t1LcD5O_Aykw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://carbon.now.sh/?bg=rgba%28171%2C+184%2C+195%2C+1%29&amp;t=seti&amp;wt=none&amp;l=javascript&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=true&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fl=1&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=async%2520function%2520downloadUsingFetch%28%29%2520%257B%250A%2520%2520const%2520image%2520%253D%2520await%2520fetch%28IMG_URL%29%253B%250A%2520%2520const%2520imageBlog%2520%253D%2520await%2520image.blob%28%29%253B%250A%2520%2520const%2520imageURL%2520%253D%2520URL.createObjectURL%28imageBlog%29%253B%250A%250A%2520%2520const%2520anchor%2520%253D%2520document.createElement%28%2522a%2522%29%253B%250A%2520%2520anchor.href%2520%253D%2520imageURL%253B%250A%2520%2520anchor.download%2520%253D%2520FILE_NAME%253B%250A%250A%2520%2520document.body.appendChild%28anchor%29%253B%250A%2520%2520anchor.click%28%29%253B%250A%2520%2520document.body.removeChild%28anchor%29%253B%250A%250A%2520%2520URL.revokeObjectURL%28imageURL%29%253B%250A%257D" rel="noopener ugc nofollow" target="_blank">生</a></figcaption></figure><p id="4fa3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，在最后我们使用了<code class="fe mv mw mx my b">URL.revokeObjectURL</code>，这在内存管理方面很重要。当使用<code class="fe mv mw mx my b">URL.createObjectURL</code>时，会创建一个新的对象URL，即使它是用同一个blob对象调用的。</p><p id="10a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每当创建一个对象URL时，它会在创建它的文档的生命周期内一直存在。卸载文档时，浏览器将释放所有对象URL。但是，为了提高性能和最小化内存使用，在不再需要对象URL时释放它们是很重要的。</p><p id="f4b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种方法的关键是下载过程会自动开始，但是在我们的应用程序中，并且只有在下载完成时才会传递给浏览器。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/b22ee989e412200227989fb5aa021d8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wf36OgYwZ3LRwIGTnNxQDw.gif"/></div></div></figure><p id="2f6f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，在上面的GIF中，一旦我们单击了Download按钮，似乎什么也没有发生，因为下载在我们的应用程序中作为异步任务发生，一旦完成，它将被传递给浏览器。</p><p id="ad9b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦浏览器窗口出现，我们点击保存，文件会自动保存在我们的计算机上。</p><p id="0655" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过这种方法，我们现在可以下载任何类型的文件，而不用考虑原始服务器。然而，问题是因为下载发生在我们的应用程序内部，用户可能认为当他点击时什么也没发生，因此通过实现进度的测量来管理大文件下载是我们的责任。</p><p id="7c01" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同时，当文件下载完成后，我们需要在应用程序内部执行某些操作时，这种方法非常有用。显示一条消息，向后端发送一个请求，呈现一个新页面，等等…</p><h2 id="225f" class="no lt it bd lu np nq dn ly nr ns dp mc kr nt nu mg kv nv nw mk kz nx ny mo nz bi translated">方法三</h2><p id="0054" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">第三种方法类似于第二种方法，我们仍然要使用Blob和createObjectURL，但是不使用Fetch API，我们将使用<a class="ae kf" href="http://org/en-US/docs/Web/API/XMLHttpRequest" rel="noopener ugc nofollow" target="_blank"> XMLHttpRequest </a>。</p><p id="9f29" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用XMLHttpRequest而不是Fetch，因为目前Fetch API没有提供进度测量的接口，而XMLHttpRequest提供了。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/2866f0ee73893d5a38c6c2d669137304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pwAtFjXh5sxCW8WtVXXcqw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://carbon.now.sh/?bg=rgba%28171%2C+184%2C+195%2C+1%29&amp;t=seti&amp;wt=none&amp;l=javascript&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=true&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fl=1&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=function%2520downloadWithProgress%28%29%2520%257B%250A%2520%2520const%2520startTime%2520%253D%2520new%2520Date%28%29.getTime%28%29%253B%250A%250A%2520%2520request%2520%253D%2520new%2520XMLHttpRequest%28%29%253B%250A%250A%2520%2520request.responseType%2520%253D%2520%2522blob%2522%253B%250A%2520%2520request.open%28%2522get%2522%252C%2520IMG_URL%252C%2520true%29%253B%250A%2520%2520request.send%28%29%253B%250A%250A%2520%2520request.onreadystatechange%2520%253D%2520function%2520%28%29%2520%257B%250A%2520%2520%2520%2520if%2520%28this.readyState%2520%253D%253D%25204%2520%2526%2526%2520this.status%2520%253D%253D%2520200%29%2520%257B%250A%2520%2520%2520%2520%2520%2520const%2520imageURL%2520%253D%2520window.URL.createObjectURL%28this.response%29%253B%250A%250A%2520%2520%2520%2520%2520%2520const%2520anchor%2520%253D%2520document.createElement%28%2522a%2522%29%253B%250A%2520%2520%2520%2520%2520%2520anchor.href%2520%253D%2520imageURL%253B%250A%2520%2520%2520%2520%2520%2520anchor.download%2520%253D%2520FILE_NAME%253B%250A%2520%2520%2520%2520%2520%2520document.body.appendChild%28anchor%29%253B%250A%2520%2520%2520%2520%2520%2520anchor.click%28%29%253B%250A%2520%2520%2520%2520%257D%250A%2520%2520%257D%253B%250A%250A%2520%2520request.onprogress%2520%253D%2520function%2520%28e%29%2520%257B%250A%2520%2520%2520%2520const%2520percent_complete%2520%253D%2520Math.floor%28%28e.loaded%2520%252F%2520e.total%29%2520*%2520100%29%253B%250A%250A%2520%2520%2520%2520const%2520duration%2520%253D%2520%28new%2520Date%28%29.getTime%28%29%2520-%2520startTime%29%2520%252F%25201000%253B%250A%2520%2520%2520%2520const%2520bps%2520%253D%2520e.loaded%2520%252F%2520duration%253B%250A%250A%2520%2520%2520%2520const%2520kbps%2520%253D%2520Math.floor%28bps%2520%252F%25201024%29%253B%250A%250A%2520%2520%2520%2520const%2520time%2520%253D%2520%28e.total%2520-%2520e.loaded%29%2520%252F%2520bps%253B%250A%2520%2520%2520%2520const%2520seconds%2520%253D%2520Math.floor%28time%2520%2525%252060%29%253B%250A%2520%2520%2520%2520const%2520minutes%2520%253D%2520Math.floor%28time%2520%252F%252060%29%253B%250A%250A%2520%2520%2520%2520console.log%28%250A%2520%2520%2520%2520%2520%2520%2560%2524%257Bpercent_complete%257D%2525%2520-%2520%2524%257Bkbps%257D%2520Kbps%2520-%2520%2524%257Bminutes%257D%2520min%2520%2524%257Bseconds%257D%2520sec%2520remaining%2560%250A%2520%2520%2520%2520%29%253B%250A%2520%2520%257D%253B%250A%257D" rel="noopener ugc nofollow" target="_blank">生</a></figcaption></figure><p id="6fd5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">开始和<code class="fe mv mw mx my b">onreadystatechange</code>块类似于第二个功能。将响应作为Blob对象下载，创建一个DOMString，并使用锚元素下载文件。</p><p id="6751" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mv mw mx my b">onprogress</code>中，我们使用<code class="fe mv mw mx my b">e.loaded</code>和<code class="fe mv mw mx my b">e.total</code>值来计算进度百分比和所用时间，以及下载速度和剩余时间。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/4352a7d10db60904db23b6028360641a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0ncaSmASCw9YhZMgErQb9w.gif"/></div></div></figure><p id="3ae4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，在上面的GIF中，我们的行为与第二种方法相同，只是现在我们可以监控进度。文件下载完成后，将被发送到浏览器，然后立即保存到磁盘。</p><h1 id="a452" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">包裹</h1><p id="5c3f" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">上述每种方法都是对以前方法的更新。</p><p id="9c4f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一种方法最简单。在这种情况下，我们只需将下载过程转发到浏览器进行本地管理。当应用程序不必根据加载状态执行某些操作时，此方法是首选方式。</p><p id="a42c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第二种情况下，我们在内部管理下载，只有在下载完成时才将其发送到浏览器。通过这种方式，我们可以控制应用程序内部的下载，并根据其状态做出反应。这种方法适用于下载速度很快的小文件，但是当文件太大时，如果用户界面上没有任何提示用户下载正在进行，用户可能会认为应用程序有问题。</p><p id="5a81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在最后一种方法中，我们实现了我们自己的进度度量，这与浏览器中的度量类似。</p></div></div>    
</body>
</html>