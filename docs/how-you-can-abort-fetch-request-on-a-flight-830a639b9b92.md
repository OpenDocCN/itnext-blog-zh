# 如何在飞行中中止 Fetch()请求…

> 原文：<https://itnext.io/how-you-can-abort-fetch-request-on-a-flight-830a639b9b92?source=collection_archive---------0----------------------->

![](img/a9810507375c0b9187275ca0c695047d.png)

照片由[鞠波·史密斯](https://unsplash.com/@jessysmith?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

每个前端开发者都一直在用 **REST API** 。流程非常清楚——如果你需要来自服务器的一些数据，你只需要用 **XHR 请求**获取它。尽管 Ajax 不是一项新技术，但有些特性我最近才发现，所以我决定分享它们。

我相信如今最流行的从服务器获取数据的方式之一，是更确切的**[**axios**](https://github.com/axios/axios)，承诺基于库获取数据，或者原生浏览器 [**获取**](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) **API** 。**

****Axios** 有内置的 **cancel()** 方法，该方法让您有机会中止尚未解决或拒绝的请求。因此，如果您的项目依赖项中有 Axios，您可以开始使用它。这是[链接](https://github.com/axios/axios/blob/master/README.md#cancellation)到它的文档。**

**但是那些使用本机 **fetch API、**的开发者应该怎么做呢，因为它已经内置于现代浏览器中，不会增加包的大小或任何你使用它的理由。**

**所以我之前不知道的是，你也可以使用新的[**abort controller**](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)**API 来取消请求。**所以让我们来看一些直接从 Mozila MDN 使用它的代码示例。**

**让我们看看这段代码中发生了什么。所以在第一行，我们创建了一个 **AbortController** 的实例。然后在第二行，我们从它那里得到一个**信号**，然后我们使用它将这个控制器绑定到特定的请求，方法是将它添加到第四行的 **fetch()** params。所以现在我们可以调用`controller.abort()`方法来取消我们的请求，见第 13 行。**

****注意:**如果您取消请求，您的承诺将被拒绝，您将进入`catch()`错误处理程序。我们将进一步讨论如何检测取消的请求，以分离错误处理和取消的请求逻辑。**

**尽管这段代码大约有 11 行，但它仍然很长，而且我们确实喜欢将这些低级代码隐藏到一些更具语义和直觉的抽象中，如`getGithubUser()`或`fetchVideo()`。**

**通常我们的`getGithubUser()`函数看起来像这样:**

**所以它已经封装了一些逻辑，你可以看到它有 Github api 的 url，并且预置了参数。所以也许我们也可以把我们的**人工控制器**放在这里？**

**如你所见，我们已经创建了一个 **AbortController** 的实例，提取了它在第 4 行的信号，并将其传递给第 7 行的 fetch。**

**然而，我们不能中止这个请求，因为我们没有任何访问`controller.abort()`方法的权限，因为实例没有返回。我们可以修复它:**

**所以现在我们返回我们的`promise`和`controller.abort()`函数。**

****注意:**要注意的重要事情是用`.bind()`方法绑定上下文，因为否则你将无法在你的客户端代码中使用`abort()`函数。**

**下面是如何在您的客户端代码中使用它，如下所示:**

**这看起来漂亮多了，但我仍然不满意这个解决方案。我们仍然在每个抽象函数中重复 **AbortController** 代码。**

**因此，让我们通过将我们的 **AbortController** 和 **fetch API** 代码提取到一些可以处理它的公共抽象中来改进这一点。**

**哇，看起来变化很大。事实上，这看起来不像我们以前拥有的。我们的`getGithubUser()`功能现在在哪里？别担心，跟着我，我们会找到的。现在让我们讨论一下上面的代码是怎么回事。**

**所以我们创建了一个新的函数来保存所有的 **AbortController** 逻辑。它看起来与我们之前的`getGithubUser()`函数非常相似，但是它与 Github url 或预定义的获取参数无关。我是故意这么做的，这是我们所有其他抽象都会用到的通用函数。**

**我们的`fetchData()`函数接收两个参数:**

*   **全球资源定位器(Uniform Resource Locator)**
*   **参数**

**基本上这两个非常相似，你通常会传递给`fetch()`，事实上我们在第 11 行传递。然而，我们不仅传递收到的`params`参数，还在第 8 行添加了`controller.signal`。然后我们返回 Promise 和我们的`abort()`函数，现在它将工作，因为我们在第 16 行绑定了它的上下文。**

**您可以在客户端代码中使用这个特殊的示例，如下所示:**

**再问一次，我们的`getGithubUser()`函数在客户端代码中如此容易使用，它是怎么回事？正如您在第 5 行看到的，我们将用户名硬编码到 url 中，这也不好。**

**所以现在让我们使用我们常用的`fetchData()`函数来创建我们的`getGithubUser()`，它将获得参数`userName`，能够中止它的请求，并且不需要用户处理任何参数，如果他/她不想的话。**

**所以这里是我们最终版本的`getGithubUser()`函数。首先要注意的是我们在第 1 行导入了`fetchData()`函数。现在我们的`getGithubUser()`变成了高阶函数，它将返回对`fetchData()`的调用，但是带有固定的参数。这意味着我们可以将 Github url 封装在我们的函数中，因此客户端代码甚至不需要考虑它，它所要做的就是通过`userName`。我们也可以在这个函数中隐藏默认的获取参数，如第 4 行所示。更酷的是，如果需要，客户端代码仍然可以扩展 params。**

**现在，在我们的客户端代码中，我们可以像这样轻松地使用我们的函数:**

****注意:**记住我已经答应告诉你如何检测被取消的请求，所以在这里的第 8 行你可以看到如何处理**“abor terror”。****

**在单页应用程序中，我们可以从这种模式中获益并提高性能。例如，每个从服务器获取数据的组件可能会在请求完成之前被卸载。当用户更改路由时，路由器组件重新呈现另一个不再包含我们组件的页面。因此，在 **componentWillUnmount()** 方法中中止请求可能是个好主意，在这个方法中，您保存了所有组件清理登录。**

**原来如此。我将感谢你分享你自己在中止请求时的用例，以及你对此的想法。**

**对于那些不想复制和摆弄代码的人来说。这里是一个带有小演示的[链接](https://codesandbox.io/embed/patient-firefly-wy7qjz6mnl)到 codesandbox，带有 **<用户/ >** 组件，该组件获取 Github 用户，但是如果组件在请求仍在处理时被卸载，则取消请求。**

****附言**我建议您使用网络选项卡将连接限制为慢速 3G，这样您就有时间通过点击“切换”按钮来取消请求。**