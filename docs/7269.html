<html>
<head>
<title>C++ Syntax Sucks and Carbon Fixes It</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++语法很糟糕，Carbon解决了它</h1>
<blockquote>原文：<a href="https://itnext.io/c-syntax-sucks-and-carbon-fixes-it-744efe5cae71?source=collection_archive---------0-----------------------#2022-08-06">https://itnext.io/c-syntax-sucks-and-carbon-fixes-it-744efe5cae71?source=collection_archive---------0-----------------------#2022-08-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dec8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">C++语法不是非常好吗？为什么碳公司的人需要改变它？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2dcc38c31b13fc0b14b09dc6c65aa322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X9fUkuf7-t0Bw6RJ7iw1Zw.jpeg"/></div></div></figure><p id="3fe1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从我读过的许多关于Carbon的twitter评论来看，有相当多的C++开发人员对Carbon编程语言的语法非常不满。我见过的一个反复被问到的问题是:</p><blockquote class="lq lr ls"><p id="5d35" class="ku kv lt kw b kx ky ju kz la lb jx lc lu le lf lg lv li lj lk lw lm ln lo lp im bi translated">如果他们正在为C++开发人员开发一种新的语言，那么他们为什么要让它看起来完全不同呢？C++语法非常好，而且众所周知。</p></blockquote><p id="597d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实际上，不，C++语法一点也不好，但是一旦你在C++领域呆了足够长的时间，就很容易将这一事实内在化并对此视而不见。当Chandler Carruth提出Carbon时，他可能没有很好地解释<em class="lt">为什么</em> C++语法如此有问题。我不能保证我也会成功，但是我会尝试去挖掘为什么C++语法有问题，为什么我们需要升级的细节。让我们从一个简单的比较开始:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/97472408c4c87d20b0038963984b6860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AxkWo8hYVbwpnBNBuwtMFQ.png"/></div></div></figure><p id="fdb2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你会注意到Carbon中的大多数语句都有一个<em class="lt">介绍者</em>关键字，比如<code class="fe ly lz ma mb b">fn</code>、<code class="fe ly lz ma mb b">var</code>、<code class="fe ly lz ma mb b">let</code>和<code class="fe ly lz ma mb b">class</code>。这些关键字允许您通过查看一个关键字来确定您正在处理哪种陈述。那是Carbon刻意设计的。让我引用碳的第一次<a class="ae mc" href="https://youtu.be/omrY53kbVoA?t=745" rel="noopener ugc nofollow" target="_blank">展示:</a></p><blockquote class="md"><p id="ad20" class="me mf it bd mg mh mi mj mk ml mm lp dk translated">我不知道是否有人做过C++解析器，它不能成为一个完整的编译器。这非常困难。我们可以做得更好。</p><p id="e2c3" class="me mf it bd mg mh mi mj mk ml mm lp dk translated">—钱德勒·卡鲁斯</p></blockquote><p id="9905" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">作为一个经常使用各种工具来帮助我进行C++开发的开发人员，我完全可以同意这个观点。编写解析C++的代码非常困难。自从我在1998年开始写C++代码以来，这是我亲眼所见的事情。虽然Java和C#社区被令人惊叹的ide和工具宠坏了，但我们C++开发人员多年来一直使用非常糟糕的工具。命令完成经常会中断，尤其是在较大的项目中。尤其是重构工具，与Java和C#开发人员所拥有的相比，将会非常有限。</p><p id="4b23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">VS代码的C++ highlighter的维护者解释了为什么为C++制作工具如此困难:</p><blockquote class="md"><p id="9db0" class="me mf it bd mg mh mi mj mk ml mm lp dk translated">19，000行的C++语法荧光笔不仅是所有语言中最大的，而且几乎是第二大语法(5000行的打字稿)的四倍。</p><p id="9e1d" class="me mf it bd mg mh mi mj mk ml mm lp dk translated">印象深刻？不能，因为它甚至还不能在变量声明中突出自定义类型！Rust highlighter可以不费吹灰之力做到这一点，因为它与碳非常相似。</p><p id="bba6" class="me mf it bd mg mh mi mj mk ml mm lp dk translated">—杰弗里·海金</p></blockquote><p id="2432" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">然而，即使是Java和C#在解析方面也不理想，因为它们借鉴了C/C++的很多语法。我第一次在Go上使用<em class="lt">介绍者关键字</em>时注意到了语言的好处。Go引入了带有关键字<code class="fe ly lz ma mb b">func</code>的函数。这使得搜索代码毫不费力。我可以更容易地区分用法和定义。这里我正在查找对<code class="fe ly lz ma mb b">MassFlow</code>函数的调用和<code class="fe ly lz ma mb b">MassFlow</code>函数的定义。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ms"><img src="../Images/cc59c85a6b04e29dfeda63b560d93d38.png" data-original-src="https://miro.medium.com/v2/format:webp/1*YLLbHHkiBcgm3cimGIMkeQ.png"/></div></figure><p id="337f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">C/C++语法的问题在于，只有在解析了几个标记之后，才能确定一个语句是什么。虽然对人类读者来说可能没那么重要，但对我们的工具来说却很重要。仅仅编写一个正则表达式来搜索某些东西变得更加困难。</p><h2 id="ce85" class="mt mu it bd mv mw mx dn my mz na dp nb ld nc nd ne lh nf ng nh ll ni nj nk nl bi translated">最令人烦恼的解析</h2><p id="11b4" class="pw-post-body-paragraph ku kv it kw b kx nm ju kz la nn jx lc ld no lf lg lh np lj lk ll nq ln lo lp im bi translated">解析C++代码的困难的一个具体例子被称为<a class="ae mc" href="https://en.wikipedia.org/wiki/Most_vexing_parse" rel="noopener ugc nofollow" target="_blank">“最麻烦的解析”</a>。这个奇特的术语是由斯科特·梅耶斯在他2001年的著作《有效短期债券》中首次提出的。下面的例子将说明这个问题:</p><pre class="kj kk kl km gt nr mb ns nt aw nu bi"><span id="5c6b" class="mt mu it mb b gy nv nw l nx ny">// C++ most vexing parse<br/>void foo(double x) {<br/>  int bar(int(x));<br/>}</span></pre><p id="1bcf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第二行代码不明确。它可以解释为如下编写的函数声明:</p><pre class="kj kk kl km gt nr mb ns nt aw nu bi"><span id="b062" class="mt mu it mb b gy nv nw l nx ny">// A function named bar takes an integer and returns an integer.<br/>int bar(int x);</span></pre><p id="6997" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">C++允许在函数声明中用圆括号将参数<code class="fe ly lz ma mb b">x</code>括起来。因此，C++解析器不容易区分声明一个函数<code class="fe ly lz ma mb b">bar</code>和声明一个用转换成整数的值<code class="fe ly lz ma mb b">x</code>初始化的变量<code class="fe ly lz ma mb b">bar</code>。</p><p id="fc3b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是一个更详细的例子:</p><pre class="kj kk kl km gt nr mb ns nt aw nu bi"><span id="9eb5" class="mt mu it mb b gy nv nw l nx ny">// C++ Unnamed temporary<br/>struct Timer {};<br/><br/>struct TimeKeeper {<br/>  explicit TimeKeeper(Timer t);<br/>  int getTime();<br/>};<br/><br/>int main() {<br/>  TimeKeeper time_keeper(Timer());<br/>  return time_keeper.getTime();<br/>}</span></pre><p id="9aa4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ly lz ma mb b">main</code>函数中的第一行不明确:</p><pre class="kj kk kl km gt nr mb ns nt aw nu bi"><span id="d0b7" class="mt mu it mb b gy nv nw l nx ny">TimeKeeper time_keeper(Timer());</span></pre><p id="8aba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于C++来说，这一行可能看起来像函数<code class="fe ly lz ma mb b">time_keeper</code>的定义，返回<code class="fe ly lz ma mb b"> TimeKeeper</code>对象并接受一个函数对象作为参数。在声明C++函数时，不需要指定参数的名称。<code class="fe ly lz ma mb b">int foo(int);</code>是有效的函数签名。</p><p id="a5f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个问题在Carbon中无法重现，原因如下:</p><ul class=""><li id="e11e" class="nz oa it kw b kx ky la lb ld ob lh oc ll od lp oe of og oh bi translated">Carbon类没有构造函数</li><li id="1e59" class="nz oa it kw b kx oi la oj ld ok lh ol ll om lp oe of og oh bi translated">对象用赋值来初始化</li></ul><p id="1e56" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的代码试图用Carbon复制早期的C++代码。我必须发明一些类函数<code class="fe ly lz ma mb b">Create</code>和<code class="fe ly lz ma mb b">Make</code>来代替C++例子中使用的构造函数。</p><pre class="kj kk kl km gt nr mb ns nt aw nu bi"><span id="2e36" class="mt mu it mb b gy nv nw l nx ny">// Carbon <br/>class Timer {<br/>    fn Create() -&gt; Self;<br/>};<br/><br/>class TimeKeeper {<br/>    fn Make(t: Timer) -&gt; Self;  <br/>    fn getTime[me: Self]() -&gt; int;<br/>};<br/><br/>fn Main() -&gt; i32 {<br/>  let time_keeper: auto = TimeKeeper.Make(Timer.Create());<br/>  return time_keeper.get_time();<br/>}</span></pre><p id="eefb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以注意到Carbon语法中的一些事情，这些事情可能并不完全明显。<code class="fe ly lz ma mb b">Self</code>表示封闭类的类型。方括号内的东西，比如<code class="fe ly lz ma mb b">[me: Self]</code>指的是没有显式传递的任何东西。它是被诱导的东西。在这种情况下，它就是C++开发人员熟知的<code class="fe ly lz ma mb b">this</code>指针。Go也有非常相似的方法。Go中的<code class="fe ly lz ma mb b">getTime</code>方法如下所示:</p><pre class="kj kk kl km gt nr mb ns nt aw nu bi"><span id="4ea7" class="mt mu it mb b gy nv nw l nx ny">// Go method example<br/>func (me TimeKeeper) getTime() int</span></pre><p id="4bf0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">方括号也用于其他隐式数据，如类型参数。其中一个碳代码示例如下:</p><pre class="kj kk kl km gt nr mb ns nt aw nu bi"><span id="8632" class="mt mu it mb b gy nv nw l nx ny">// Carbon code showing function parameters<br/>fn QuickSort[T:! Comparable &amp; Movable](s: Slice(T)) {<br/>  if (s.Size() &lt;= 1) {<br/>    return;<br/>  }<br/>  let p: i64 = Partition(s);<br/>  QuickSort(s[:p - 1]);<br/>  QuickSort(s[p + 1:]);<br/>}</span></pre><p id="a920" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们没有指定<code class="fe ly lz ma mb b">this</code> (me)对象，而是指定了一个类型参数<code class="fe ly lz ma mb b">T</code>，它必须同时满足<code class="fe ly lz ma mb b">Comparable</code>和<code class="fe ly lz ma mb b">Movable</code>接口。Carbon使用一个冒号<code class="fe ly lz ma mb b">:</code>来指定对象的类型，而<code class="fe ly lz ma mb b">:!</code>用来表示我们正在指定类型参数必须遵循的接口。</p><h2 id="652d" class="mt mu it bd mv mw mx dn my mz na dp nb ld nc nd ne lh nf ng nh ll ni nj nk nl bi translated">解析C++中的函数指针</h2><p id="b1c7" class="pw-post-body-paragraph ku kv it kw b kx nm ju kz la nn jx lc ld no lf lg lh np lj lk ll nq ln lo lp im bi translated">当您定义以函数为参数的高阶函数时，将返回类型放在前面而不是最后的问题变得很明显。快速看一下这段代码，告诉我函数指针参数叫什么名字？</p><pre class="kj kk kl km gt nr mb ns nt aw nu bi"><span id="ea8d" class="mt mu it mb b gy nv nw l nx ny">// C++<br/>int FindFirst(int xs[], int n, bool (*condition)(int x)) {<br/>    for(int i = 0; i &lt; n; ++i) {<br/>        if (condition(xs[i])) {<br/>            return i;<br/>        }<br/>    }<br/>    return -1;<br/>}</span></pre><p id="6e4d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">函数指针参数的名字是<code class="fe ly lz ma mb b">conditon</code>。我想大多数人都会同意这不是你可以快速阅读的东西。它显示了C++语法的一个问题。</p><p id="a103" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我本打算大张旗鼓地展示这在Carbon中会有多好，但不幸的是，我在Carbon语言规范中找不到任何关于函数指针的内容。相反，我将展示这在Go中会是什么样子，并推测如何在Carbon中实现它。</p><pre class="kj kk kl km gt nr mb ns nt aw nu bi"><span id="3e42" class="mt mu it mb b gy nv nw l nx ny">// Go<br/>func FindFirst(xs []int, condition func(int) bool) int {<br/>	for i, x := range xs {<br/>		if condition(x) {<br/>			return i<br/>		}<br/>	}<br/>	return -1<br/>}</span></pre><p id="540f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go代码更容易阅读的原因是参数名在前，类型在后。是一致的。对于Carbon，我认为他们可以使这一点更清楚，因为他们使用冒号来分隔类型和参数名:</p><pre class="kj kk kl km gt nr mb ns nt aw nu bi"><span id="d16a" class="mt mu it mb b gy nv nw l nx ny">// Carbon - Assumption (similar to Rust)<br/>fn FindFirst(xs: Slice(int), condition: fn(int) -&gt; bool) -&gt; i32</span></pre><p id="1832" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实际上，这段代码几乎就是你在Rust中编写<code class="fe ly lz ma mb b">FindFirst</code>函数签名的方式。</p><h2 id="807a" class="mt mu it bd mv mw mx dn my mz na dp nb ld nc nd ne lh nf ng nh ll ni nj nk nl bi translated">摆脱常量引用的混乱</h2><p id="2cc4" class="pw-post-body-paragraph ku kv it kw b kx nm ju kz la nn jx lc ld no lf lg lh np lj lk ll nq ln lo lp im bi translated">写C++代码时最烦人的事情之一就是处理常量正确性和引用。考虑下面的几何示例代码。</p><pre class="kj kk kl km gt nr mb ns nt aw nu bi"><span id="54d3" class="mt mu it mb b gy nv nw l nx ny">// C++ class<br/>class Circle {     <br/>public:<br/>    const Point&amp; center() const;<br/>    float radius() const;    <br/>    void  setCenter(const Point&amp; pos);<br/>    void  setRadius(float radius);<br/>            <br/>    bool inside(const Point&amp; p) const;<br/>    bool intersect(const Circle&amp; c) const;<br/>    <br/>private:<br/>    Point center;<br/>    float radius;<br/>};</span></pre><p id="c833" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">偶尔，你想传递一个参数，比如一个圆的中心，作为一个常量引用，<code class="fe ly lz ma mb b">const Point&amp; pos</code>，但是其他时候你不想。我将半径作为一个<code class="fe ly lz ma mb b">float</code>的副本传递。这在机器码级别更有效，因为单个浮点值可以通过微处理器寄存器传递。相反，引用是作为指针实现的，这意味着到达实际所需的值会导致额外的间接引用。</p><p id="51e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Carbon完全解决了这个问题，让编译器来决定什么是最好的。在Carbon中，我们将前面的类实现为:</p><pre class="kj kk kl km gt nr mb ns nt aw nu bi"><span id="5006" class="mt mu it mb b gy nv nw l nx ny">// Carbon class<br/>class Circle {     <br/>    fn center[me: Self]() -&gt; Point;<br/>    fn radius[me: Self]() -&gt; f32;    <br/>    fn setCenter[addr me: Self*](pos: Point);<br/>    fn setRadius[addr me: Self*](radius: f32);<br/>            <br/>    fn inside[me: Self](p: Point);<br/>    fn intersect[me: Self](c: Circle);<br/>    <br/>    var center: Point;<br/>    var radius: float;<br/>}</span></pre><p id="f742" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你会注意到<code class="fe ly lz ma mb b">setCenter</code>和<code class="fe ly lz ma mb b">setRadius</code>看起来很相似。Carbon将会找出最佳方式将参数<code class="fe ly lz ma mb b">pos</code>和<code class="fe ly lz ma mb b">radius</code>传递给它们各自的功能。无需担心引用和常量。在Carbon中，参数默认为<code class="fe ly lz ma mb b">let</code>类型，所以它们本质上类似于const。</p><p id="4d09" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有时，您需要能够修改调用者中的值。Carbon没有引用，所以用指针代替。<code class="fe ly lz ma mb b">Self*</code>表示<code class="fe ly lz ma mb b">me</code>参数是一个指针，允许我们修改<code class="fe ly lz ma mb b">me</code>。使用指针而不是引用的一个问题是，你必须接受一个对象的地址。</p><pre class="kj kk kl km gt nr mb ns nt aw nu bi"><span id="d879" class="mt mu it mb b gy nv nw l nx ny">// Carbon - Calling setRadius if it was defined as <br/>// fn setRadius[me: Self*](radius: f32)<br/><br/>var circle: Circle = MakeRandomCircle();<br/>var ptr: Circle* = &amp;circle;<br/>ptr.setRadius(5);</span></pre><p id="bdb1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每次都获取地址来改变一个圆形对象是很麻烦的。出于这个原因，我们在<code class="fe ly lz ma mb b">me</code>前面添加了<code class="fe ly lz ma mb b">addr</code>关键字，指示Carbon为我们获取地址。这就是为什么我们可以调用<code class="fe ly lz ma mb b">setRadius</code>而不用获取地址:</p><pre class="kj kk kl km gt nr mb ns nt aw nu bi"><span id="54d0" class="mt mu it mb b gy nv nw l nx ny">// Carbon <br/>var circle: Circle = MakeRandomCircle();<br/>circle.setRadius(5);</span></pre><h2 id="9512" class="mt mu it bd mv mw mx dn my mz na dp nb ld nc nd ne lh nf ng nh ll ni nj nk nl bi translated">为代码可读性而设计</h2><p id="cfb6" class="pw-post-body-paragraph ku kv it kw b kx nm ju kz la nn jx lc ld no lf lg lh np lj lk ll nq ln lo lp im bi translated">大多数开发人员从不研究或关心可用性和用户界面设计。他们应该这样做，因为适用于用户界面布局的原则与编写清晰易读的代码有很多共同之处。</p><p id="0734" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">需要注意的一个重要细节是人类阅读文本的方式。你唯一一次阅读单词中的单个字母是在你还是个孩子学习读写的时候。成年人通过<em class="lt">形状</em>来阅读单词。我们通过观察单词的形状来识别它们。</p><p id="9a25" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个事实意味着，为了快速识别不同的选择，单词和句子的形状应该是不同的。让我们举一个例子来说明这个问题。考虑一个带有选项列表的网页:</p><pre class="kj kk kl km gt nr mb ns nt aw nu bi"><span id="f79a" class="mt mu it mb b gy nv nw l nx ny">I want to customize tools...<br/>I want to have custom shows...<br/>I want to do custom animations...</span></pre><p id="983f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个糟糕的设计，因为句子的形状太相似了，使得视觉扫描选项更加困难。我们可以通过剔除重复的内容来改进设计:</p><pre class="kj kk kl km gt nr mb ns nt aw nu bi"><span id="0c2f" class="mt mu it mb b gy nv nw l nx ny">I want to:<br/>  Customize tools...<br/>  Custom shows...<br/>  Custom animations...</span></pre><p id="3a03" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然有所改进，但我们仍然存在每个选项中的第一个单词看起来非常相似的问题。通过对每个选项进行重新措辞，我们可以使选项更容易阅读:</p><pre class="kj kk kl km gt nr mb ns nt aw nu bi"><span id="8ec6" class="mt mu it mb b gy nv nw l nx ny">I want to do:<br/>  Tool Customizing...<br/>  Reset Shows...<br/>  Custom Animations...</span></pre><p id="8b24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些原则如何应用于Carbon编程语言？Carbon使用简短的<em class="lt">介绍者</em>关键字，例如<code class="fe ly lz ma mb b">fn</code>，这更侧重于个别方法或功能的名称:</p><pre class="kj kk kl km gt nr mb ns nt aw nu bi"><span id="ff71" class="mt mu it mb b gy nv nw l nx ny">// Carbon function names line up<br/>fn center[me: Self]() -&gt; Point;<br/>fn radius[me: Self]() -&gt; f32;    <br/>fn setCenter[addr me: Self*](pos: Point);<br/>fn setRadius[addr me: Self*](radius: f32);          <br/>fn inside[me: Self](p: Point);<br/>fn intersect[me: Self](c: Circle);</span></pre><p id="6211" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这使得在Carbon中扫描函数或方法列表的速度更快。尤其是语言，比如Java，在这方面很可怕。你读<code class="fe ly lz ma mb b">public static void</code>，然后你终于到了重要的部分，也就是方法名。C++更好，但是仍然会将注意力从方法名上转移开，因为在方法名之前有返回值的信息:</p><pre class="kj kk kl km gt nr mb ns nt aw nu bi"><span id="7d7a" class="mt mu it mb b gy nv nw l nx ny">// C++ function names don't line up<br/>const Point&amp; center() const;<br/>float radius() const;</span></pre><p id="9bde" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当方法名处于不同的偏移量时，扫描方法名列表变得更加困难，因为返回类型的名称可能不同。这也适用于列出变量。通过使用像<em class="lt"> var </em>这样的<em class="lt">介绍者</em>关键字，我们可以在每一行的相同位置获得变量名的开始，从而允许代码读者更快地浏览。</p><pre class="kj kk kl km gt nr mb ns nt aw nu bi"><span id="116e" class="mt mu it mb b gy nv nw l nx ny">// Carbon variable names line up<br/>var center: Point;<br/>var radius: float;</span></pre><h1 id="5590" class="on mu it bd mv oo op oq my or os ot nb jz ou ka ne kc ov kd nh kf ow kg nk ox bi translated">结论</h1><p id="ec24" class="pw-post-body-paragraph ku kv it kw b kx nm ju kz la nn jx lc ld no lf lg lh np lj lk ll nq ln lo lp im bi translated">Carbon语法不仅对解析器更容易，对开发人员阅读代码和使用工具也更容易。开发人员可以更容易地搜索Carbon代码，也可以更容易地扫描Carbon代码，因为标识符等有效位存在于相同的字符偏移量处。</p></div></div>    
</body>
</html>