<html>
<head>
<title>Building Container Images with Podman and Buildah</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Podman和Buildah构建容器图像</h1>
<blockquote>原文：<a href="https://itnext.io/building-container-images-with-podman-and-buildah-44489560df25?source=collection_archive---------6-----------------------#2019-08-12">https://itnext.io/building-container-images-with-podman-and-buildah-44489560df25?source=collection_archive---------6-----------------------#2019-08-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><a href="https://www.giantswarm.io/on-demand-webinar-kubernetes-hard-lessons-and-how-to-avoid-them?utm_campaign=Medium%20CTA%20Conversion&amp;utm_source=Kubernetes%20hard%20lessons_Medium&amp;utm_medium=Medium%20CTA&amp;utm_term=Kubernetes%20hard%20lessons"><div class="gh gi jn"><img src="../Images/4bf2e48f888ba30cfc7a1858f63698a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MBSmUTGvxDA8zRPR.jpg"/></div></a></figure><p id="4df8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是关于构建容器图像的系列博客文章的第二篇。系列开始于<a class="ae ks" href="https://blog.giantswarm.io/what-is-the-future-of-container-image-building/" rel="noopener ugc nofollow" target="_blank">集装箱形象建设的未来是什么？</a>它着眼于自Docker首次推出以来构建图像的变化，以及如何克服使用Docker文件的一些限制。<a class="ae ks" href="https://www.giantswarm.io/blog/building-container-images-with-podman-and-buildah" rel="noopener ugc nofollow" target="_blank">这篇文章关注的是Podman和Buildah </a>，在以后的文章中，我们将研究这一领域的其他新方法。</p><p id="24c4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://podman.io/" rel="noopener ugc nofollow" target="_blank"> Podman </a>和<a class="ae ks" href="https://buildah.io/" rel="noopener ugc nofollow" target="_blank"> Buildah </a>是最近出现的两种帮助构建容器映像的工具。它们是互补的工具，都是容器工具开放库的组成部分，并且源于Red Hat从容器工作流中删除Docker守护进程的使命。为什么是两个工具，每个工具给容器映像构建体验带来了什么？先说波德曼。</p><h1 id="0860" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">波德曼</h1><p id="8806" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">Podman的目的超出了容器映像构建的目标，但是它经常与Buildah一起讨论，并且在这里被考虑，因为它对容器映像构建有贡献。</p><h1 id="3001" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">无梦构建</h1><p id="fea2" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">Podman试图再现熟悉的Docker CLI的整体，而不需要运行守护程序来服务和处理API请求。Podman实现了一个本地fork/exec模型，而不是客户端/服务器模型，在Red Hat的眼中，这大大简化了容器生命周期的控制和安全性。</p><p id="416d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Podman模仿Docker提供的各种客户端命令，一些倡导者甚至鼓励新用户将命令别名为T1，以便于从一个到另一个的迁移。在波德曼提供的一套类似Docker的命令中，有一个是<code class="fe lw lx ly lz b">podman build</code>命令。它用于构建<a class="ae ks" href="https://github.com/opencontainers/image-spec/blob/master/spec.md#open-container-initiative" rel="noopener ugc nofollow" target="_blank">符合OCI标准的容器映像</a>，使用docker文件作为各个构建步骤的源。在这个意义上，它实际上与<code class="fe lw lx ly lz b">docker build command</code>相同，但是没有Docker守护进程的开销。</p><p id="a1f7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">正如您所料，所有熟悉的<code class="fe lw lx ly lz b">docker build</code>命令行参数都在<code class="fe lw lx ly lz b">podman build</code>中可用(除了仍未实现的一个，如<code class="fe lw lx ly lz b">--cache-from</code>)，需要一些额外的参数来代替Docker守护进程通常提供的一些功能(如注册表通信)。从<code class="fe lw lx ly lz b">docker build</code>切换到<code class="fe lw lx ly lz b">podman build</code>是一种无缝的体验，除了一些奇怪的地方，比如需要<a class="ae ks" href="https://github.com/containers/buildah/blob/master/install.md#man-page-registriesconf5" rel="noopener ugc nofollow" target="_blank">指定</a>在哪里找到没有完全限定的图像名的图像。</p><p id="954b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> <em class="ma">有兴趣看看Giant Swarm如何与OpenShift短兵相接？</em> </strong> <a class="ae ks" href="https://blog.giantswarm.io/giantswarm-vs-openshift/" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> <em class="ma">阅读我们的文章，该文章将使用巨型Swarm的主要优势与open shift</em></strong></a><strong class="jw ir"><em class="ma">进行了对比。</em>T29】</strong></p><h1 id="093c" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">无根建筑</h1><p id="66e5" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">随着一个大目标——无缝构建体验的实现，Podman还提供了另一个受欢迎的特性——无根容器构建。从历史上看，由于Docker守护进程，使用<code class="fe lw lx ly lz b">docker build</code>构建容器映像需要root权限，这种级别的访问权限在有安全意识的组织中通常被认为过于宽松。通过提供执行无根构建的能力，Podman回答了这个严重的问题，但它也有其局限性。</p><p id="04bb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">从Dockerfiles构建映像的过程包括为运行命令临时创建容器，以便安装包、检索远程内容、构建工件等等。创建和运行容器通常需要root权限。那么，波德曼如何满足这种明显的二分法呢？为了避免以根用户身份运行构建，Podman使用了<a class="ae ks" href="http://man7.org/linux/man-pages/man7/user_namespaces.7.html" rel="noopener ugc nofollow" target="_blank">用户名称空间</a>。<a class="ae ks" href="http://man7.org/linux/man-pages/man7/namespaces.7.html" rel="noopener ugc nofollow" target="_blank">名称空间</a>为Linux进程提供了一种隔离机制，并且是容器抽象的主要组成部分。如果创建容器时使用的名称空间集包括用户名称空间，那么调用容器的代理可以是无特权用户——换句话说，使用用户名称空间，Podman可以使用容器来实现无根映像构建。</p><p id="df6b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">用户命名空间提供了一种将主机的默认用户命名空间中的一系列非特权用户和组id(uid/GID)映射到与容器相关联的新用户命名空间中的一组不同的uid/GID的方式。通过这种方式，主机上的非特权UID/GID可以安全地映射到容器内的root用户(UID/GID=0 ),为容器的进程提供作为映像构建的一部分可能需要的提升的特权(例如，安装OS软件包)。但是由于这种映射，容器在主机上只拥有与发出<code class="fe lw lx ly lz b">podman build</code>命令的非特权用户相同的文件访问权限。这意味着主机的文件系统受到保护，不会受到意外或恶意的容器损害。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><a href="https://www.giantswarm.io/on-demand-webinar-kubernetes-hard-lessons-and-how-to-avoid-them?utm_campaign=Medium%20CTA%20Conversion&amp;utm_source=Kubernetes%20hard%20lessons_Medium&amp;utm_medium=Medium%20CTA&amp;utm_term=Kubernetes%20hard%20lessons"><div class="gh gi mb"><img src="../Images/3ef8462f8c5043c2475daa2b6bdff075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rU8OLgxaQhcnaAQ7CBfbXA.jpeg"/></div></a></figure><h1 id="6c03" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">当前无根的限制</h1><p id="1f03" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">但是有一个问题。新映像通常是从基本映像(docker文件中的<code class="fe lw lx ly lz b">FROM</code>指令)构建的，其内容通常由UID/GID=0的用户拥有。当容器作为容器构建的一部分由非特权用户启动时，容器的文件由主机上的UID/GID=0拥有，而容器的进程将只拥有与非特权用户相关联的文件访问权限。这可能意味着容器的进程无法写入其文件系统，这将严重阻碍容器映像的构建。为了使映像中的文件在容器中拥有正确的所有权，UID/GID集需要与用户名称空间映射一起“移位”。目前，没有实现这一点的最佳方法。</p><p id="a03e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当一个无根的<code class="fe lw lx ly lz b">podman build</code>被调用并且一个容器需要所有权“转移”时，文件系统内容被复制并且所有权被改变(chowned)以反映映射。就空间而言，这显然是低效的，并且耗费时间，这会严重影响容器构建所花费的时间长度。容器背后的一个重要想法是，多个容器和图像可以共享一个图像的内容，而不会重复。理想情况下，当一个容器的文件系统是由它的组成层组装而成时，这种转移应该在挂载操作中没有复制的情况下发生。</p><p id="d5fc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">大多数容器运行时使用overlayfs来组装容器的文件系统，这不支持在其挂载上转移UID/GID，但最近Ubuntu成为第一个支持覆盖的内核内机制(shiftfs)的Linux发行版，该机制已在Linux容器<a class="ae ks" href="https://discuss.linuxcontainers.org/t/lxd-3-12-has-been-released/4483" rel="noopener ugc nofollow" target="_blank"> LXD项目</a>中投入使用。</p><p id="d518" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于Podman来说，部分补救措施是在Linux内核版本4.19中为overlayfs引入一个mount选项，该选项只将文件和目录的元数据复制到读/写层，而不是内容本身。然而，最终，社区正在等待主流Linux内核对UID/GID转换的支持，以便实现这个目标。</p><p id="8e8d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们继续讨论Buildah，并解释它与<code class="fe lw lx ly lz b">podman build</code>的关系和区别。</p><h1 id="1479" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Buildah</h1><p id="bd8a" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">到目前为止我们还没有提到的是<code class="fe lw lx ly lz b">podman build</code>在幕后使用Buildah来执行容器映像构建。这意味着无后台和无根构建也是Buildah的一个特性。与Podman不同，Buildah有一个容器映像构建特定的函数，并且有许多特性超出了基于Dockerfiles构建映像的范围。</p><p id="62b9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">外界的大多数容器映像都是使用docker文件作为映像的不可变引用构建的。我们已经讨论了<code class="fe lw lx ly lz b">podman build</code>如何使用order文件来构建映像，Buildah也可以使用<code class="fe lw lx ly lz b">buildah</code> bud命令从order文件构建映像。但是再一次，Buildah受到了寻找一种替代无处不在的Dockerfile的方法来构建容器映像的启发。另一种方法的基本原理是，所需要的只是一个代表符合OCI标准的映像的“捆绑包”,而如何实现最终目标并不需要docker文件。Buildah的维护者坚持认为Dockerfile是一个需要规避的限制。</p><h1 id="a561" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Buildah如何工作</h1><p id="3f6e" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">尽管刻意希望从docker文件中独立出来，但Buildah使用了非常相似的过程来构建容器映像。一个<code class="fe lw lx ly lz b">docker build</code>运行一个新的容器来处理每个Dockerfile指令，这导致在容器作为新的映像提交之前，创建新的或改变的内容或映像元数据。下一条指令在基于先前创建的映像的新容器中处理，然后作为新映像提交，依此类推。Buildah做同样的事情，但是它执行Buildah子命令，而不是使用Dockerfile指令，并且在每个子命令执行后不需要“提交”。</p><p id="31d7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">构建过程可能从一个<code class="fe lw lx ly lz b">buildah from</code>命令开始，这会导致一个基于指定为参数的图像的运行容器。这显然类似于<code class="fe lw lx ly lz b">FROM</code> Dockerfile指令。为了在一个容器中执行命令作为图像构建的一部分(例如，创建一个新用户，或者从其源构建一个工件)，图像作者可以利用<code class="fe lw lx ly lz b">buildah run</code>，它可以在需要时进行交互。除了运行为容器图像创建内容的命令之外，Buildah还提供了使用<code class="fe lw lx ly lz b">buildah config</code>为图像定义元数据的方法。这使得诸如暴露的端口、默认用户、容器入口点等事情的规范成为可能。<code class="fe lw lx ly lz b">buildah copy</code>和<code class="fe lw lx ly lz b">buildah add</code>命令直接类似于<code class="fe lw lx ly lz b">COPY</code>和<code class="fe lw lx ly lz b">ADD</code> Dockerfile指令，用于将外部内容获取到图像中。使用<code class="fe lw lx ly lz b">buildah mount</code>，甚至可以将容器的根文件系统挂载到主机上合适的位置，以便随后使用主机本身自带的工具进行操作。</p><p id="8171" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一旦图像作者确信他们已经完成了图像的制作，<code class="fe lw lx ly lz b">buildah commit</code>命令将容器提交给新图像。</p><h1 id="dd97" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">工作流程</h1><p id="0d23" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">Dockerfile和<code class="fe lw lx ly lz b">docker build</code>以及Buildah的组合有一些明显的相似之处。但是Dockerfile强制依赖指令的顺序执行，那么Buildah如何在容器构建中提供类似的顺序和可重复性呢？代替守护进程的构建引擎为<code class="fe lw lx ly lz b">docker build</code>强加这个顺序，建议使用Buildah的容器构建应该以编程方式定义，例如使用Bash之类的东西。</p><p id="09ee" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上面的简单例子展示了如何在Bash脚本中使用Buildah实现可重复的构建。</p><p id="82de" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在采用它所采用的映像构建方法时，Buildah消除了对长时间运行的守护进程的任何依赖，并且进一步将映像构建器从Dockerfile语法的约束中解放出来。由Buildah创建的映像可以被推送到容器注册中心，然后由Podman或Docker守护进程提取，并将在支持<a class="ae ks" href="https://github.com/opencontainers/runtime-spec/blob/master/spec.md#open-container-initiative-runtime-specification" rel="noopener ugc nofollow" target="_blank"> OCI规范</a>的容器运行时上无缝工作。</p><h1 id="db35" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">构建缓存和并行执行</h1><p id="a48d" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">如果图像是使用Dockerfile和<code class="fe lw lx ly lz b">buildah bud</code>构建的，那么图像层将被缓存，以便在后续构建中重用。对于那些从Docker环境进入Buildah的人来说，这是预期的行为，可以显著提高构建执行的速度。但是，如果您希望在脚本中使用Buildah命令构建图像时可以使用缓存，那么您将会大吃一惊。缓存<a class="ae ks" href="https://github.com/containers/buildah/issues/1292" rel="noopener ugc nofollow" target="_blank">不可用</a>，这意味着所有的构建步骤都需要在每个新的构建迭代中执行，不管内容或命令是否发生了变化。</p><p id="056a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此外，Buildah按顺序执行其构建步骤，即使一个构建步骤完全独立于另一个构建步骤。虽然包含并行构建步骤特性<a class="ae ks" href="https://github.com/containers/buildah/issues/1292" rel="noopener ugc nofollow" target="_blank">已经被考虑过</a>，但它目前在Buildah中不可用，这会进一步延长执行复杂容器映像构建所需的时间。</p><h1 id="315e" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="b1ce" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">虽然Podman和Buildah之间有明显的区别，但有两条路线可以实现相同的目标，这似乎有点令人困惑。如果有疑问，在使用Dockerfiles创作图像时应该使用<code class="fe lw lx ly lz b">podman build</code>,如果Dockerfile语法被认为过于严格，或者倾向于使用类似脚本的方法来实现可重复性，则应该使用Buildah。值得一提的是，容器图像和Dockerfile几乎是同义词，因此Buildah是否会在Red Hat社区之外获得足够的牵引力以最终篡夺docker file还有待观察。</p><p id="561c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Podman和Buildah提供了两个最受欢迎的容器图像构建功能；无梦和无根的构建。然而，这些工具正在一个日益拥挤的空间中竞争，虽然现在还为时尚早，但它们确实缺乏类似工具目前提供的一些功能。</p><p id="d8bc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由<a class="ae ks" href="https://twitter.com/puja108" rel="noopener ugc nofollow" target="_blank">Puja Abbas si</a>——开发者倡议@ <a class="ae ks" href="https://giantswarm.io/" rel="noopener ugc nofollow" target="_blank">巨型虫群</a>撰写</p><div class="mg mh gp gr mi mj"><a href="https://twitter.com/puja108" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd ir gy z fp mo fr fs mp fu fw ip bi translated">Puja Abbassi @ #KubeCon #KubeKhan</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">Puja Abbassi的最新推文@ #KubeCon #KubeKhan (@puja108)。开发者关系和产品@GiantSwarm…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">twitter.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx js mj"/></div></div></a></div></div></div>    
</body>
</html>