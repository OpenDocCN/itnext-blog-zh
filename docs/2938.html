<html>
<head>
<title>Intro to Bash Scripting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Bash脚本简介</h1>
<blockquote>原文：<a href="https://itnext.io/intro-to-bash-scripting-95c5fbc2dcef?source=collection_archive---------2-----------------------#2019-09-03">https://itnext.io/intro-to-bash-scripting-95c5fbc2dcef?source=collection_archive---------2-----------------------#2019-09-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2559" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为Bash中的基本命令行任务构建工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7ef28d325e667c259c1fd8626fa74bce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nlte8CxUQ8S3MpN9aA1KmA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.gnu.org/software/bash/" rel="noopener ugc nofollow" target="_blank"> GNU Bash </a></figcaption></figure><h2 id="623d" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h2><p id="188b" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi mo translated"><span class="l mp mq mr bm ms mt mu mv mw di"> D </span>开发软件通常需要花费大量时间在命令行上。各种任务需要向计算机输入非常详细的指令的能力，如果没有基于文本的界面和键盘(以及咖啡)，这是很难甚至不可能完成的。</p><p id="63c7" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">在本文中，我们将了解在<a class="ae ky" href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)" rel="noopener ugc nofollow" target="_blank"> Bash </a>中创建有用工具的基础知识，Bash 是服务器端架构和DevOps中最常见的shell。</p><p id="4870" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">虽然shell脚本实际上是<em class="nc">脚本，但是</em>会努力将尽可能多的产品级软件工程的概念应用到示例项目中，以建立导致高度成功的最佳实践(并且在出现问题时更容易发现发生了什么)。</p><p id="557c" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">本文的源代码副本可以在GitHub 上的<a class="ae ky" href="https://github.com/kenreilly/bash-tools-example" rel="noopener ugc nofollow" target="_blank">处获得。</a></p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="d20a" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">概观</h2><p id="da09" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">Bash是一种<a class="ae ky" href="https://en.wikipedia.org/wiki/Command_language" rel="noopener ugc nofollow" target="_blank">命令语言</a>，其语法源自自然人类语言，其特性集包括命令执行、条件逻辑、计算、数组/字典、迭代/循环、函数、字符串操作、扩展等等——这使得它对于批处理、作业控制、维护和其他系统管理员任务非常有用。</p><p id="f1b6" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">关于Bash特性及其工作原理的概述，请查看这篇优秀的<a class="ae ky" href="https://devhints.io/bash" rel="noopener ugc nofollow" target="_blank">备忘单</a>。开始使用Bash很容易，只需要访问一个终端。要创建并运行基本脚本:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="6056" class="kz la it nl b gy np nq l nr ns"><strong class="nl iu">$</strong> echo 'echo "hello $1"' &gt; hello.sh <br/><strong class="nl iu">$</strong> chmod +x hello.sh<br/><strong class="nl iu">$</strong> ./hello.sh programmer</span><span id="b2ef" class="kz la it nl b gy nt nq l nr ns">hello programmer</span></pre><p id="49aa" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">第一行<a class="ae ky" href="https://www.gnu.org/software/bash/manual/html_node/Redirections.html" rel="noopener ugc nofollow" target="_blank">将文字字符串<code class="fe nu nv nw nl b">‘echo “hello $1"'</code>重定向</a>到文件<em class="nc"> hello.sh </em>，第二行<a class="ae ky" href="https://en.wikipedia.org/wiki/Chmod" rel="noopener ugc nofollow" target="_blank">启用脚本的执行权限</a>。第三行使用<code class="fe nu nv nw nl b">programmer</code>作为参数运行脚本，通过<code class="fe nu nv nw nl b">$1</code>变量输出回终端。这说明了什么是<code class="fe nu nv nw nl b">.sh</code>文件，以及它们如何接受输入并从中产生输出。接下来，我们将看看将<code class="fe nu nv nw nl b">.sh</code>文件格式化成结构化代码块的概念。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="773d" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">入口点</h2><p id="857d" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">bash脚本是自顶向下逐行解释的，其他bash文件可以使用<code class="fe nu nv nw nl b">source <em class="nc">my-script-name.sh</em></code> <em class="nc"> </em>命令导入，这对于将各种概念组织成可重用的库代码非常有用。</p><p id="1b6f" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">下面是我们的示例项目中的主文件，<strong class="lx iu"> bash-example.sh </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="a2e9" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">第一行包含<code class="fe nu nv nw nl b">#!/bin/bash</code>——一个称为<a class="ae ky" href="https://en.wikipedia.org/wiki/Shebang_(Unix)" rel="noopener ugc nofollow" target="_blank"> shebang </a>的解释器指令方案，它告诉环境使用<code class="fe nu nv nw nl b">bash</code>解释器处理这个文件的其余部分。第<code class="fe nu nv nw nl b">source ./lib/main.sh</code>行将主函数导入到当前会话中，然后用<code class="fe nu nv nw nl b">main $@</code>调用它，后者将当前范围内的所有参数(<code class="fe nu nv nw nl b">@</code>参数)传递给主函数。该文件作为定义/条目文件保持干净。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="1c93" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">主要功能</h2><p id="4395" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">接下来是这个实用程序的主函数，在<strong class="lx iu"> lib/main.sh </strong>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="42be" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">在<a class="ae ky" href="https://en.wikipedia.org/wiki/Shebang_(Unix)" rel="noopener ugc nofollow" target="_blank"> shebang </a>之后，其余的库脚本都是源代码，稍后我们将进一步检查每一个。在入口点调用的<em class="nc"> main() </em>函数(在前一个文件中)首先初始化这个示例实用程序处理的各种数据处理任务的目录。接下来，用Bash命令<code class="fe nu nv nw nl b">declare -A -x command_table</code>创建command_table变量，该命令创建一个关联数组(<code class="fe nu nv nw nl b">-A</code>)，并允许用一个值(<code class="fe nu nv nw nl b">-x</code>)初始化该变量。这创建了一个简单的功能表，以避免使用更大的<code class="fe nu nv nw nl b">if/elif</code>或<code class="fe nu nv nw nl b">switch</code>模块。然后来自<code class="fe nu nv nw nl b">command_table</code>的键被解析成简单的索引数组<code class="fe nu nv nw nl b">commands</code>，当使用不正确的参数调用时，该数组用于显示帮助信息。</p><p id="97d4" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">从命令行获取的第一个参数存储为<code class="fe nu nv nw nl b">command</code>，然后调用<code class="fe nu nv nw nl b">shift</code>，然后将该项从参数堆栈中推出。在命令表中查找该命令，如果存在匹配的键，则通过调用<code class="fe nu nv nw nl b">$fn_name $@</code>使用剩余的参数堆栈调用相应的函数，该函数采用<code class="fe nu nv nw nl b">fn_name</code>的值，并将其作为shell命令执行，同时传入参数。</p><p id="c117" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">这个小型Bash程序支持三个特性:</p><ul class=""><li id="1baa" class="nz oa it lx b ly mx mb my li ob lm oc lq od mn oe of og oh bi translated"><code class="fe nu nv nw nl b">scan-files<strong class="lx iu"> <em class="nc">num</em></strong><em class="nc"> </em>:</code>递归扫描当前目录中<strong class="lx iu"> <em class="nc"> num </em> </strong>最大的文件，并将结果输出到<code class="fe nu nv nw nl b">./data/logs</code>下的日志中</li><li id="dfb2" class="nz oa it lx b ly oi mb oj li ok lm ol lq om mn oe of og oh bi translated"><code class="fe nu nv nw nl b">process-logs :</code>处理日志文件，向<code class="fe nu nv nw nl b">./data/reports</code>写入摘要，在<code class="fe nu nv nw nl b">./data/archives</code>创建一个<code class="fe nu nv nw nl b">tar.gz</code>文件，并删除日志文件</li><li id="e535" class="nz oa it lx b ly oi mb oj li ok lm ol lq om mn oe of og oh bi translated"><code class="fe nu nv nw nl b">get-photo :</code>获取NASA当天的天文照片，并将照片<code class="fe nu nv nw nl b">.jpg</code>和相应的<code class="fe nu nv nw nl b">.json</code>放在<code class="fe nu nv nw nl b">./data/images</code>下</li></ul><p id="754a" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">我们一会儿将讨论每一个函数，但是首先让我们看看在这个示例项目的其余部分中使用的底层配置和实用函数。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="b16f" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">配置</h2><p id="597f" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">没有一些初始设置和配置，任何项目都是不完整的。我们要检查的下一个文件是<strong class="lx iu"> lib/config.sh </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="881b" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">首先，错误处理是通过创建一个处理函数<em class="nc"> on_error()，</em>设置错误跟踪，然后设置一个错误陷阱，在出现<code class="fe nu nv nw nl b">ERR</code>条件时调用<em class="nc"> on_error </em>(这在调试时提供了有用的反馈)。</p><p id="30de" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">接下来，启用别名扩展，以便轻松扩展和重用别名。这个功能在这个项目中用得不多，但是以防万一。</p><p id="e395" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">设置了另一个陷阱，这一次是针对<code class="fe nu nv nw nl b">TERM</code>信号，以便在任何时候从任何点退出脚本。最后，当前的工作目录被发现并存储在<code class="fe nu nv nw nl b">_ROOT</code>中，用于文件系统操作，以确保在代码库的其余部分使用正确的目录。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="d384" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">效用函数</h2><p id="6dd3" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">下一个要检查的文件是<strong class="lx iu"> lib/utility.sh </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="28e6" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">在这个文件中有几个简单的实用函数，使这个项目的工作变得更加容易。函数<em class="nc"> exit_with_help </em>显示作为参数传入的消息，然后退出脚本。<em class="nc"> get_timestamp </em>函数打印出带有格式字符串的<code class="fe nu nv nw nl b">date</code>命令的结果，并且<em class="nc"> init_dir </em>检查一个目录，如果它不存在，就创建它。</p><p id="9ede" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated"><em class="nc"> str_split </em>函数以一个字符串作为输入，通过设置一个全局关联数组<code class="fe nu nv nw nl b">str_split_result</code>来“返回”一个数组，调用脚本在调用<em class="nc"> str_split </em>后访问该数组。通过将内部Bash读取分隔符<code class="fe nu nv nw nl b">IFS</code>设置为所提供的值，然后使用<code class="fe nu nv nw nl b">read</code>读取字符串数据(通过<code class="fe nu nv nw nl b">IFS</code>将字符串分解为一个数组)并将结果存储在<code class="fe nu nv nw nl b">str_split_result</code>中以备后用，从而生成数组。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="c334" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">文件扫描</h2><p id="0254" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">基本的配置和帮助函数已经完成，让我们来看看<strong class="lx iu"> lib/file-io.sh </strong>中的第一个特性(文件扫描):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="d279" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated"><em class="nc"> write_file </em>函数将printf语句的输出重定向到由根url和提供的字符串路径构建的路径。write_log函数只是调用带有<code class="fe nu nv nw nl b">‘logs/’</code>前缀的<em class="nc"> write_log </em>来存储<code class="fe nu nv nw nl b">data/logs</code>下的文件。</p><p id="0464" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">实际扫描功能在<em class="nc"> scan_large_files </em>中实现，它首先检查以验证参数是否已传入(用于记录的最大文件数)，如果未提供，则打印帮助消息并退出。</p><p id="d2bd" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">接下来，运行一个<code class="fe nu nv nw nl b">find</code>命令来搜索当前目录及其下的所有文件。这个命令的结果通过<code class="fe nu nv nw nl b">awk</code>、<code class="fe nu nv nw nl b">sort</code>和<code class="fe nu nv nw nl b">head</code>来过滤、排序和提取列表中的前x个文件(有关I/O重定向的更多信息，<a class="ae ky" href="https://www.tldp.org/LDP/abs/html/io-redirection.html" rel="noopener ugc nofollow" target="_blank">参见本页</a>)。其结果存储在<code class="fe nu nv nw nl b">data</code>中，并产生一个<code class="fe nu nv nw nl b">timestamp</code>。然后将<code class="fe nu nv nw nl b">data</code>的内容保存到一个文件中。</p><p id="1d10" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">这就完成了文件扫描器和日志生成器。这个文件中还有一个函数<code class="fe nu nv nw nl b">create_archive</code>(我们将从下一个文件中调用它)，它实际上只是运行一个<code class="fe nu nv nw nl b">tar</code>来归档和压缩日志文件，并将结果归档保存到<code class="fe nu nv nw nl b">./data/archives</code>。</p><p id="4145" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated"><em class="nc"> create_report </em>函数将<code class="fe nu nv nw nl b">log_data</code>的内容写入一个格式化的<code class="fe nu nv nw nl b">.yaml</code>文件，以便阅读。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="b1fa" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">数据处理</h2><p id="c336" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">接下来是本例中的第二个特性，处理由文件扫描器生成的日志文件，在<strong class="lx iu"> lib/log-processor.sh </strong>中实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="5ac6" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">这个文件是这个程序中大多数复杂工作完成的地方。文件中的第一个函数是<em class="nc"> process_logs，</em>，它从初始化一个全局关联数组<code class="fe nu nv nw nl b">log_data</code>开始，该数组将保存用于创建报告的数据。使用另一个查找命令，结果存储在<code class="fe nu nv nw nl b">logs</code>中。文件和行的总数的计数器也被初始化。接下来，执行检查，如果没有可用的日志文件，脚本将退出。</p><p id="fd9c" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">每个日志文件都作为<code class="fe nu nv nw nl b">record</code>处理，通过使用下划线分隔符(<code class="fe nu nv nw nl b">_</code>)调用<code class="fe nu nv nw nl b">str_split</code>并从数组中检索第二项来提取日期。如果由于某种原因日期为空，则忽略该条目，脚本继续处理列表中的下一项。每个日志文件被读入到<code class="fe nu nv nw nl b">line</code>中，然后被传递到<code class="fe nu nv nw nl b">process_entry</code>函数中进行进一步处理，稍后我们将对此进行研究。</p><p id="f42d" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated"><em class="nc"> process_entry </em>函数设置一些局部变量，打印一些<a class="ae ky" href="https://misc.flogisoft.com/bash/tip_colors_and_formatting" rel="noopener ugc nofollow" target="_blank">彩色的</a>状态信息，然后查看文件是否已经存在于<code class="fe nu nv nw nl b">log_data</code>中。如果是，则比较两个条目的日期，如果当前条目比数组中的条目新，则替换旧的条目。否则，只需将该项添加到数组中。</p><p id="e972" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">处理完每条记录后，会显示一些状态信息，脚本运行<code class="fe nu nv nw nl b">create_report</code>和<code class="fe nu nv nw nl b">create_archive</code>来生成报告，并将日志文件归档到各自的位置。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="4509" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">图像下载器</h2><p id="9b8d" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">最后但同样重要的是，我们在<strong class="lx iu"> lib/net-client.sh </strong>中有图像下载程序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="353f" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">这里我们有一个函数<code class="fe nu nv nw nl b">get_nasa_photo</code>，用于从NASA检索关于他们当前<a class="ae ky" href="https://apod.nasa.gov/apod/astropix.html" rel="noopener ugc nofollow" target="_blank">天文图片</a>的信息。这个函数首先定义这个服务的NASA URL，对它执行一个<a class="ae ky" href="https://en.wikipedia.org/wiki/CURL" rel="noopener ugc nofollow" target="_blank"> cURL </a>操作，并将结果存储在<code class="fe nu nv nw nl b">json</code>中。<code class="fe nu nv nw nl b">filename</code>变量也被初始化为空字符串。接下来，使用字符串扩展范围选择器<code class="fe nu nv nw nl b">${json:1:-1}</code>修剪json的前后括号，该选择器接受<code class="fe nu nv nw nl b">json</code>的值并返回开头的<code class="fe nu nv nw nl b">+1</code>到结尾的<code class="fe nu nv nw nl b">-1</code>。这被传递到<em class="nc"> str_split </em>中，以通过<code class="fe nu nv nw nl b">','</code>字符分割剩余的字符串，这将不允许对整个JSON数据进行正确的解析，但会让我们更接近我们需要的唯一值<code class="fe nu nv nw nl b">url</code>。这是一个纯粹黑客的例子，这样做是为了在pure Bash中实现一个解决方案，但是对于生产场景，建议使用命令行JSON处理工具<a class="ae ky" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank">，比如jt </a>。</p><p id="f5cb" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">分割后的JSON数据的每一部分都作为<code class="fe nu nv nw nl b">field</code>进行处理，当找到以<code class="fe nu nv nw nl b">'"url":'</code>开头的部分时，它会被进一步处理以从字符串中检索实际的URL。一旦获得了URL，就从其中检索文件名并调用<em class="nc"> download_image </em>，后者执行另一个<code class="fe nu nv nw nl b">curl</code>操作来下载文件内容并将它们重定向到目标<code class="fe nu nv nw nl b">.jpg</code>文件。</p><p id="e644" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">一旦下载完成，原始的未修改的JSON数据也被写入，文件名相同，但扩展名为<code class="fe nu nv nw nl b">.json</code>，而不是<code class="fe nu nv nw nl b">.jpg</code>。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="cc2a" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h2><p id="5f2a" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">Bash是一个强大的命令行环境，它为开发人员和系统管理员提供了各种各样的工具来快速自动化许多常见任务，尤其是在部署和维护方面。</p><p id="3ef1" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">这个项目演示了Bash中可以完成的几件事情。如需更详细的信息，请查看本<a class="ae ky" href="https://www.tldp.org/LDP/abs/html/" rel="noopener ugc nofollow" target="_blank">高级脚本指南</a>或参考前面提到的<a class="ae ky" href="https://devhints.io/bash" rel="noopener ugc nofollow" target="_blank">备忘单</a>。</p><p id="8263" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">感谢您的阅读，祝您的下一个DevOps项目好运！</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/4540a371c4b66e95ccf74032bbde14ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Ycl-WVGY_UfDMcT2kc7bnw.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">运行中的<strong class="bd lb"> bash-example.sh </strong>的屏幕截图</figcaption></figure></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><blockquote class="oo"><p id="ed10" class="op oq it bd or os ot ou ov ow ox mn dk translated">肯尼斯·雷利(<a class="ae ky" href="https://twitter.com/8_bit_hacker" rel="noopener ugc nofollow" target="_blank"> 8_bit_hacker </a>)是<a class="ae ky" href="https://lvl-up.tech/" rel="noopener ugc nofollow" target="_blank"> LevelUP </a>的CTO</p></blockquote></div></div>    
</body>
</html>