<html>
<head>
<title>Modern Node Part 2 — Bootstrapping a Node.js Typescript API: Routing, Middleware, and Custom Types and Errors Modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代节点第2部分—引导Node.js Typescript API:路由、中间件和自定义类型和错误模块</h1>
<blockquote>原文：<a href="https://itnext.io/modern-node-part-2-bootstrapping-a-node-js-9be331c3d9ed?source=collection_archive---------1-----------------------#2021-08-21">https://itnext.io/modern-node-part-2-bootstrapping-a-node-js-9be331c3d9ed?source=collection_archive---------1-----------------------#2021-08-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/994b1f297453e4afe80a602c1b0b14ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r9IzniPmGfBx8mMpJOtZ5A.jpeg"/></div></div></figure><h1 id="ecee" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="3c81" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在我的上一篇文章<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/modern-node-part-1-architecting-and-scaffolding-a-typescript-express-api-22e87fee054c">架构&amp;搭建一个Typescript &amp; Express API </a>中，我们讨论了在构建生产级的、基于微服务的API时如何从头开始。我们引导了我们的<code class="fe lv lw lx ly b">users-service</code>和一个<code class="fe lv lw lx ly b">math-service</code>。</p><p id="7578" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">在本文中，我们将为TypeScript项目构建一个可扩展的路由系统、自定义错误、实用程序和类型模块(当某些npm库没有附加ts声明时，这很有帮助)，以及构建一个不使用外部依赖的自定义错误处理模块和结构。</p><p id="3d94" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">注意:如果你在上一篇文章中克隆了我的回购协议，你现在必须重新克隆它，因为它是一个新的回购协议。抱歉，调换了！</p><p id="05e9" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">如果您还没有阅读上面的文章，我建议您浏览一下，了解一下我们正在构建的内容以及我们为此做了些什么。</p><p id="87dd" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated"><strong class="ky ir">我也强烈建议您在第二章</strong> <a class="ae lu" href="https://github.com/ryanoillataguerre/nonprofits-medium/tree/Chapter_2-Bootstrapping" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">这里</strong> </a> <strong class="ky ir">找到回购，并在当地查看。</strong>在分支<code class="fe lv lw lx ly b">Chapter_2-Bootstrapping</code>检查它将帮助你跟上这篇文章的运行示例，以及我将做的所有小的改变，但不在这里详述。</p><pre class="mf mg mh mi gt mj ly mk ml aw mm bi"><span id="0e6f" class="mn jz iq ly b gy mo mp l mq mr">git clone <a class="ae lu" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:ryanoillataguerre/nonprofits-medium.git<br/>git checkout Chapter_2-Bootstrapping</span></pre><h2 id="deaf" class="mn jz iq bd ka ms mt dn ke mu mv dp ki lh mw mx km ll my mz kq lp na nb ku nc bi translated">在这篇文章中，我们将使用哪些技术？</h2><ul class=""><li id="c5b9" class="nd ne iq ky b kz la ld le lh nf ll ng lp nh lt ni nj nk nl bi translated">快递. js</li><li id="29b8" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated">地方国家预防机制模块</li><li id="a116" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated"><a class="ae lu" href="https://github.com/winstonjs/winston" rel="noopener ugc nofollow" target="_blank">温斯顿</a>为我们伐木</li></ul><p id="a439" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated"><em class="me">注意:在本系列中，我不打算对这些工具进行深入探讨。本内容将假设您至少对这些工具有初步的了解！如果没有，我将链接到他们的文档，这样您可以在我们开始使用它们之前获得一些上下文。</em></p><p id="a9d9" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">在这篇文章中，和上一篇文章一样，我将只为<code class="fe lv lw lx ly b">users-service</code>完成这个过程，但是在这个阶段的早期，我们将为两者做同样的事情。</p><p id="1d45" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">这种模式可以应用于任何定制的本地npm模块，我过去曾将这些模块用于不同的目的。</p><p id="46b9" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">说完了，我们开始吧！</p><h2 id="ddb1" class="mn jz iq bd ka ms mt dn ke mu mv dp ki lh mw mx km ll my mz kq lp na nb ku nc bi translated">中间件</h2><p id="8934" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在我们的<code class="fe lv lw lx ly b">users-service/</code>目录中，我们将创建一个<code class="fe lv lw lx ly b">/utils/</code>文件夹。</p><p id="2e8a" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">让我们引导我们的实用程序，我会解释一下每一个。</p><p id="d731" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated"><code class="fe lv lw lx ly b">utils/handleValidationErrors.ts</code></p><pre class="mf mg mh mi gt mj ly mk ml aw mm bi"><span id="0cc8" class="mn jz iq ly b gy mo mp l mq mr">import { Request } from "express";<br/>import { Result, ValidationError, validationResult } from "express-validator";<br/>import { BadRequestError } from "../errors";</span><span id="27ac" class="mn jz iq ly b gy nr mp l mq mr">export default (req: Request) =&gt; {<br/>  const validationErrors: Result&lt;ValidationError&gt; = validationResult(req);<br/>  if (!validationErrors.isEmpty()) {<br/>    throw new BadRequestError(<br/>      "Validation Error",<br/>      400,<br/>      validationErrors.array()<br/>    );<br/>  }<br/>};</span></pre><p id="e1cd" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">这里我们有一个使用<code class="fe lv lw lx ly b">express-validator</code>来处理验证错误的函数。从技术上来说，可以被称为中间件，但它是作为一种功能来使用的。这是我们的快速调用堆栈的一个停止，如果请求中有任何验证错误，我们将在这里抛出它们，以通知前端/API调用者有效负载有问题！</p><p id="e50d" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated"><code class="fe lv lw lx ly b">utils/logger.ts</code></p><pre class="mf mg mh mi gt mj ly mk ml aw mm bi"><span id="7d60" class="mn jz iq ly b gy mo mp l mq mr">import winston from "winston";</span><span id="da40" class="mn jz iq ly b gy nr mp l mq mr">const logger = winston.createLogger({<br/> level: process.env.WINSTON_LOGGER_LEVEL || "info",<br/> format: winston.format.simple(),<br/> transports: [new winston.transports.Console()],<br/>});</span><span id="1beb" class="mn jz iq ly b gy nr mp l mq mr">export default logger;</span></pre><p id="826e" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">不言而喻，我们有一个winston logger，它为我们提供了一个单一的函数/模块来传递我们的中间件、服务器函数等。</p><p id="9e40" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated"><code class="fe lv lw lx ly b">errorHandler.ts</code></p><pre class="mf mg mh mi gt mj ly mk ml aw mm bi"><span id="5cdb" class="mn jz iq ly b gy mo mp l mq mr">import { BadRequestError, UnauthorizedError, NotFoundError } from "<a class="ae lu" href="http://twitter.com/errors" rel="noopener ugc nofollow" target="_blank">@errors</a>";<br/>import { NextFunction, Request, Response } from "express";<br/>import PrettyError from "pretty-error";<br/>import { logger } from "<a class="ae lu" href="http://twitter.com/utils" rel="noopener ugc nofollow" target="_blank">@utils</a>";</span><span id="44b0" class="mn jz iq ly b gy nr mp l mq mr">const pe = new PrettyError();<br/>const errorHandler = (<br/> error: any,<br/> req: Request,<br/> res: Response,<br/> _: NextFunction<br/>) =&gt; {<br/> logger.error(`${req.method} - ${req.path}`);<br/> logger.error(<br/>  process.env.NODE_ENV === "production" ? error : pe.render(error)<br/> );</span><span id="2fde" class="mn jz iq ly b gy nr mp l mq mr">const { name, message, details } = error;</span><span id="dce1" class="mn jz iq ly b gy nr mp l mq mr">if (error instanceof NotFoundError) {<br/>  return res.status(404).send({<br/>   name,<br/>   message,<br/>   details,<br/>  });<br/> }</span><span id="51c4" class="mn jz iq ly b gy nr mp l mq mr">if (error instanceof BadRequestError) {<br/>  return res.status(400).send({<br/>   name,<br/>   message,<br/>   details,<br/>  });<br/> }</span><span id="8389" class="mn jz iq ly b gy nr mp l mq mr">if (error instanceof UnauthorizedError) {<br/>  return res.status(403).send({<br/>   name,<br/>   message,<br/>   details,<br/>  });<br/> }</span><span id="c8d2" class="mn jz iq ly b gy nr mp l mq mr">return res.status(500).send({<br/>  name,<br/>  message,<br/>  details,<br/> });<br/>};</span><span id="ed6d" class="mn jz iq ly b gy nr mp l mq mr">export default errorHandler;</span></pre><p id="afc3" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">这是对我们最有用的一个！这是我们快速调用堆栈的最后一站。所有的请求都将传递到这个中间件，如果上游出现错误，我们将返回正确的错误代码和对客户端的响应。</p><p id="5681" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">然后，当然，一个<code class="fe lv lw lx ly b">index.ts</code>文件将所有这些导出为<code class="fe lv lw lx ly b">@utils</code>:</p><pre class="mf mg mh mi gt mj ly mk ml aw mm bi"><span id="760f" class="mn jz iq ly b gy mo mp l mq mr">import handleValidationErrors from "./handleValidationErrors";<br/>import logger from "./logger";<br/>import errorHandler from "./middleware/errorHandler";<br/>import rateLimiter from "./middleware/rateLimit";</span><span id="54da" class="mn jz iq ly b gy nr mp l mq mr">export {<br/>  handleValidationErrors, logger, errorHandler, rateLimiter<br/>};</span></pre><p id="f167" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">这里是我们的<code class="fe lv lw lx ly b">utils</code>模块。我在应用程序的几个地方添加了这些函数的调用，但不会解释每个函数的位置。如果你克隆回购，你可以看到我如何使用这些模块。</p><h2 id="92b7" class="mn jz iq bd ka ms mt dn ke mu mv dp ki lh mw mx km ll my mz kq lp na nb ku nc bi translated">按指定路线发送</h2><p id="7fe8" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这个路由系统是我见过很多次的一个非常基本的模式，并且一直困扰着我。这是干净的，让你可以分割你的路线，无论你想要多浅/多深。</p><p id="f865" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">对我来说，我喜欢保持一个非常标准化的REST结构，所以我在这里使用模块化的方法，将子路由分割成它们的业务逻辑单元。例如，现在我将创建一条<code class="fe lv lw lx ly b">/auth/login</code>路线:</p><p id="522f" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">首先，让我们制作我们的授权路由器:</p><p id="c6d1" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated"><code class="fe lv lw lx ly b">src/api/authentication.ts</code></p><pre class="mf mg mh mi gt mj ly mk ml aw mm bi"><span id="8de0" class="mn jz iq ly b gy mo mp l mq mr">import { Request, Response, NextFunction, Router } from "express";<br/>import { body } from "express-validator";<br/>import { handleValidationErrors } from "@utils";</span><span id="d8db" class="mn jz iq ly b gy nr mp l mq mr">const router: Router = Router();</span><span id="69e8" class="mn jz iq ly b gy nr mp l mq mr">// API<br/>router.post(<br/> "/signup",<br/> [body("email").exists().isEmail(), body("password").exists()],<br/> async (req: Request, res: Response, next: NextFunction) =&gt; {<br/>  try {<br/>    handleValidationErrors(req);<br/>    res.status(200).send({<br/>      success: true,<br/>    });<br/>  } catch (err) {<br/>   next(err);<br/>  }<br/> }<br/>);</span><span id="b63c" class="mn jz iq ly b gy nr mp l mq mr">router.post("/login", async (_: Request, res: Response, next: NextFunction) =&gt; {<br/> try {<br/>  res.status(200).send({<br/>   success: true,<br/>  });<br/> } catch (err) {<br/>  next(err);<br/> }<br/>});</span><span id="a957" class="mn jz iq ly b gy nr mp l mq mr">export default router;</span></pre><p id="9ad6" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">这里我们有一个基本的express <code class="fe lv lw lx ly b">Router</code>，它本质上只是一个模块，如果你愿意，你可以与其他路由器一起使用。它也可以作为您唯一的路由器，并且是您服务器中的<code class="fe lv lw lx ly b">app.use()</code>所必需的。</p><p id="bfe0" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">您还可以看到我们如何通过传递请求对象来使用中间件<code class="fe lv lw lx ly b">handleValidationErrors</code>。我们用作路由中间件数组的<code class="fe lv lw lx ly b">express-validator</code>函数将触发<code class="fe lv lw lx ly b">handleValidationErrors</code>响应。这将有助于我们保持一个干净的API，并很好地传达后数据形状需求。</p><p id="1a66" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">然而，我们试图在这里构建一个可扩展的模式，所以我们将把它导入到<code class="fe lv lw lx ly b">src/api/index.ts</code>中的<code class="fe lv lw lx ly b">index.ts</code>文件中:</p><pre class="mf mg mh mi gt mj ly mk ml aw mm bi"><span id="8933" class="mn jz iq ly b gy mo mp l mq mr">import { Router } from "express";<br/>import AuthRoutes from "./authentication";</span><span id="f3f4" class="mn jz iq ly b gy nr mp l mq mr">const router: Router = Router();</span><span id="63f3" class="mn jz iq ly b gy nr mp l mq mr">router.use("/auth", AuthRoutes);</span></pre><p id="5aa1" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">这里是我们的根快速路由器模块，我们将在<code class="fe lv lw lx ly b">server.ts</code>中用到它</p><pre class="mf mg mh mi gt mj ly mk ml aw mm bi"><span id="cf93" class="mn jz iq ly b gy mo mp l mq mr">import routes from './api</span><span id="e9e6" class="mn jz iq ly b gy nr mp l mq mr">... // Other server code<br/>app.use("/", routes);<br/>...</span></pre><p id="e37c" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">呜！我们有自己的路线，很容易导入到我们的服务器中，并作为“中间件”添加到express应用程序中。</p><p id="4bf3" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">你可以把express应用程序想象成一个带有停靠点的单一调用，我们在<code class="fe lv lw lx ly b">use()</code>中传递给它的所有东西都按照给定的顺序运行请求。这里，我们将真实路由放在通用路由处理程序之前，使它们优先于通用路由。这也是为什么我们将<code class="fe lv lw lx ly b">app.use(errorHandler)</code>放在服务器函数顺序的较低位置，因为它将返回任何给它的抛出错误的响应。我们不希望这种情况过早发生，所以我们把它放在我们的应用程序“中间件”的最后。</p><h2 id="e56f" class="mn jz iq bd ka ms mt dn ke mu mv dp ki lh mw mx km ll my mz kq lp na nb ku nc bi translated">自定义类型模块</h2><p id="1c23" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我经常遇到没有最新类型定义的模块，或者对我的使用来说定义太严格的模块。如果您想为自定义类型创建一个简洁的类型模块，这非常简单。</p><p id="737b" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">在<code class="fe lv lw lx ly b">src/types/utils.ts</code>,我们将导出一个单独的自定义类型，用于我们的app util函数:</p><pre class="mf mg mh mi gt mj ly mk ml aw mm bi"><span id="be02" class="mn jz iq ly b gy mo mp l mq mr">export interface Logger {<br/>  error: Function;<br/>  info: Function;<br/>}</span></pre><p id="95a6" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">然后用一个<code class="fe lv lw lx ly b">src/types/index.ts</code>文件导出我们的类型:</p><pre class="mf mg mh mi gt mj ly mk ml aw mm bi"><span id="8418" class="mn jz iq ly b gy mo mp l mq mr">export * from "./utils";</span></pre><h2 id="9107" class="mn jz iq bd ka ms mt dn ke mu mv dp ki lh mw mx km ll my mz kq lp na nb ku nc bi translated">自定义错误处理模块</h2><p id="7385" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这是我个人喜欢的处理应用程序错误的方式，因为它是可扩展的，非常容易解释，我们可以添加/删除我们需要的任何类型的错误。同样，对于个人项目来说，这可能没有必要，您可以使用GitHub上的许多错误处理文章中的任何一篇。但是在一个生产应用程序中，我遇到了外部库的灵活性问题，我更喜欢这种方法，因为对于我们获得的灵活性来说，这是相对较低的工作量。</p><p id="63c3" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">让我们建立一个如下的结构(在本章的分支<a class="ae lu" href="https://github.com/ryanoillataguerre/pfapp/tree/Chapter_2-Bootstrapping" rel="noopener ugc nofollow" target="_blank">这里</a>克隆存储库要容易得多):</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/72eb5ae006dad8d18af9f81373d23c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xnWR_y3rb5yfOLoxHiu7dA.png"/></div></div></figure><p id="a162" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">在<code class="fe lv lw lx ly b">src/errors</code>中，我们已经为我们的自定义错误模块创建了所有这些文件。</p><p id="0f85" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">我会把不同错误的所有代码放在下面，然后讨论。</p><p id="2514" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated"><code class="fe lv lw lx ly b">CustomError.ts</code></p><pre class="mf mg mh mi gt mj ly mk ml aw mm bi"><span id="b4e5" class="mn jz iq ly b gy mo mp l mq mr">class CustomError extends Error {<br/> constructor(message: String, code: Number, details: Object) {<br/>  super(message || String(code));<br/>  this.code = code;<br/>  this.name = "CustomError";</span><span id="d26d" class="mn jz iq ly b gy nr mp l mq mr">  if (details) {<br/>   this.details = details;<br/>  }<br/> }</span><span id="09e5" class="mn jz iq ly b gy nr mp l mq mr"> code: Number;<br/> details?: Object;<br/>}</span><span id="be7d" class="mn jz iq ly b gy nr mp l mq mr">export default CustomError;</span></pre><p id="531b" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated"><code class="fe lv lw lx ly b">InternalError.ts</code></p><pre class="mf mg mh mi gt mj ly mk ml aw mm bi"><span id="831a" class="mn jz iq ly b gy mo mp l mq mr">import CustomError from "./CustomError";</span><span id="23ec" class="mn jz iq ly b gy nr mp l mq mr">class InternalError extends CustomError {<br/> constructor(message: String, code: Number = 500, details: Object) {<br/>  super(message, code, details);<br/>  this.name = "InternalError";<br/> }<br/>}</span><span id="ad6e" class="mn jz iq ly b gy nr mp l mq mr">export default InternalError;</span></pre><p id="6e94" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated"><code class="fe lv lw lx ly b">BadRequestError.ts</code></p><pre class="mf mg mh mi gt mj ly mk ml aw mm bi"><span id="71bb" class="mn jz iq ly b gy mo mp l mq mr">import CustomError from "./CustomError";</span><span id="d512" class="mn jz iq ly b gy nr mp l mq mr">class BadRequestError extends CustomError {<br/> constructor(message: String, code: Number = 400, details: Object) {<br/>  super(message, code, details);<br/>  this.name = "BadRequestError";<br/> }<br/>}</span><span id="4af4" class="mn jz iq ly b gy nr mp l mq mr">export default BadRequestError;</span></pre><p id="bd2a" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated"><code class="fe lv lw lx ly b">NotFoundError.ts</code></p><pre class="mf mg mh mi gt mj ly mk ml aw mm bi"><span id="b96a" class="mn jz iq ly b gy mo mp l mq mr">import CustomError from "./CustomError";</span><span id="aba0" class="mn jz iq ly b gy nr mp l mq mr">class NotFoundError extends CustomError {<br/> constructor(message: String, code: Number = 404, details: Object) {<br/>  super(message, code, details);<br/>  this.name = "NotFoundError";<br/> }<br/>}</span><span id="ace5" class="mn jz iq ly b gy nr mp l mq mr">export default NotFoundError;</span></pre><p id="417a" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated"><code class="fe lv lw lx ly b">UnauthorizedError.ts</code></p><pre class="mf mg mh mi gt mj ly mk ml aw mm bi"><span id="1628" class="mn jz iq ly b gy mo mp l mq mr">import CustomError from "./CustomError";</span><span id="ef04" class="mn jz iq ly b gy nr mp l mq mr">class UnauthorizedError extends CustomError {<br/> constructor(message: String, code: Number = 401, details: Object) {<br/>  super(message, code, details);<br/>  this.name = "UnauthorizedError";<br/> }<br/>}</span><span id="6845" class="mn jz iq ly b gy nr mp l mq mr">export default UnauthorizedError;</span></pre><p id="3c90" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">这些是我们的错误类型！</p><ul class=""><li id="9bcf" class="nd ne iq ky b kz lz ld ma lh nt ll nu lp nv lt ni nj nk nl bi translated">CustomError:主要用作基本错误类型，就像JavaScript错误一样，但是有一些额外的字段供我们在我们将创建的所有其他错误中一致使用。</li><li id="e624" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated">内部错误:当它是真的500时，我们抛出这个。要么是我们代码中的一个进程失败了，要么是外部API请求失败了。</li><li id="ba0e" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated">BadRequestError:这是我们常见的400错误，将告诉用户他们的有效负载格式不正确。</li><li id="a57d" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated">NotFoundError:这是我们的标准404，表示没有找到路由或资源。因为如果用户点击了我们没有的路由(在<code class="fe lv lw lx ly b">server.ts</code>中),我们可以回退到404，所以我们将只对未找到的资源使用这个。</li><li id="2c8d" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated">UnauthorizedError:这将是我们的401错误，当我们的授权中间件(我们将在下一篇文章中构建)发现用户的认证丢失或无效时</li></ul><p id="7f4c" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">最后，让我们将<code class="fe lv lw lx ly b">index.ts</code>添加到我们的错误处理库中:</p><pre class="mf mg mh mi gt mj ly mk ml aw mm bi"><span id="899d" class="mn jz iq ly b gy mo mp l mq mr">import BadRequestError from "./BadRequestError";<br/>import CustomError from "./CustomError";<br/>import InternalError from "./InternalError";<br/>import NotFoundError from "./NotFoundError";<br/>import UnauthorizedError from "./UnauthorizedError";</span><span id="f786" class="mn jz iq ly b gy nr mp l mq mr">export {<br/> BadRequestError,<br/> CustomError,<br/> InternalError,<br/> NotFoundError,<br/> UnauthorizedError,<br/>};</span></pre><h2 id="92e4" class="mn jz iq bd ka ms mt dn ke mu mv dp ki lh mw mx km ll my mz kq lp na nb ku nc bi translated">实施我们的定制模块</h2><p id="642d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">要使用TypeScript定制模块，使其在开发中和部署到云中时都能工作，我们需要进行一点设置，使它们按照我们的预期工作。</p><p id="78c2" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">首先，我们将安装两个库:<code class="fe lv lw lx ly b">module-alias</code>和<code class="fe lv lw lx ly b">tsc-alias</code>，分别用于运行和构建:</p><pre class="mf mg mh mi gt mj ly mk ml aw mm bi"><span id="8242" class="mn jz iq ly b gy mo mp l mq mr">yarn add -D tsc-alias<br/>yarn add module-alias</span></pre><p id="684d" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">现在，我们将向我们的<code class="fe lv lw lx ly b">tsconfig.json</code>添加一些配置:</p><pre class="mf mg mh mi gt mj ly mk ml aw mm bi"><span id="0c1b" class="mn jz iq ly b gy mo mp l mq mr">"compilerOptions": {<br/>    ...<br/>    "baseUrl": ".",<br/>    "rootDir": ".",<br/>    "paths": {<br/>      "<a class="ae lu" href="http://twitter.com/utils" rel="noopener ugc nofollow" target="_blank">@utils</a>": ["src/utils/index.ts"],<br/>      "<a class="ae lu" href="http://twitter.com/errors" rel="noopener ugc nofollow" target="_blank">@errors</a>": ["src/errors/index.ts"],<br/>      "<a class="ae lu" href="http://twitter.com/nptypes" rel="noopener ugc nofollow" target="_blank">@nptypes</a>": ["src/nptypes/index.ts"],<br/>    },<br/>    ...<br/>},</span></pre><p id="5c14" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">还有我们的<code class="fe lv lw lx ly b">package.json</code>:</p><pre class="mf mg mh mi gt mj ly mk ml aw mm bi"><span id="d17f" class="mn jz iq ly b gy mo mp l mq mr">"_moduleAliases": {<br/>  "@utils": "src/utils/index.ts",<br/>  "@errors": "src/errors/index.ts",<br/>  "@nptypes": "src/nptypes/index.ts"<br/>}</span></pre><p id="5cda" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">将<code class="fe lv lw lx ly b">import "module-alias/register";</code>放在我们<code class="fe lv lw lx ly b">src/index.ts</code>文件的顶部。</p><p id="594f" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">最后，确保我们已经将<code class="fe lv lw lx ly b">errorHandler</code>作为中间件添加到我们的服务器中:</p><pre class="mf mg mh mi gt mj ly mk ml aw mm bi"><span id="55bb" class="mn jz iq ly b gy mo mp l mq mr">// routes here<br/>app.use(errorHandler);</span></pre><p id="8ecd" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">现在，我们可以使用这个错误处理程序从调用堆栈中的任何一点捕获我们的任何错误，从路由函数或我们的服务，我们通过在下面的路由函数中捕获错误并将其传递给express的<code class="fe lv lw lx ly b">next</code>函数来传递到这一步。为了测试，让我们在下面的<code class="fe lv lw lx ly b">api/authentication.ts</code>文件中添加一个无意义的<code class="fe lv lw lx ly b">NotFoundError</code>:</p><pre class="mf mg mh mi gt mj ly mk ml aw mm bi"><span id="749a" class="mn jz iq ly b gy mo mp l mq mr">import { Request, Response, NextFunction, Router } from "express";<br/>import { body } from "express-validator";<br/>import { handleValidationErrors } from "<a class="ae lu" href="http://twitter.com/nonprofits/shared" rel="noopener ugc nofollow" target="_blank">@</a>utils";<br/>import { NotFoundError } from "<a class="ae lu" href="http://twitter.com/nonprofits/shared" rel="noopener ugc nofollow" target="_blank">@</a>errors";</span><span id="1177" class="mn jz iq ly b gy nr mp l mq mr">const router: Router = Router();</span><span id="fb4d" class="mn jz iq ly b gy nr mp l mq mr">// API<br/>router.post(<br/> "/signup",<br/> [body("email").exists().isEmail(), body("password").exists()],<br/> async (req: Request, res: Response, next: NextFunction) =&gt; {<br/>  try {<br/>   handleValidationErrors(req);<br/>   throw new NotFoundError("Sorry, can't find it!", undefined, { hello: "world"});<br/>   res.status(200).send({<br/>    success: true,<br/>   });<br/>  } catch (err) {<br/>   next(err);<br/>  }<br/> }<br/>);</span><span id="2451" class="mn jz iq ly b gy nr mp l mq mr">router.post("/login", async (_: Request, res: Response, next: NextFunction) =&gt; {<br/> try {<br/>  res.status(200).send({<br/>   success: true,<br/>  });<br/> } catch (err) {<br/>  next(err);<br/> }<br/>});</span><span id="413d" class="mn jz iq ly b gy nr mp l mq mr">export default router;</span></pre><p id="c9e9" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">让我们启动服务器，尝试一些东西吧！</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/b7e86fc4c61f49403978ea45d05d29c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kWKON4Lr2ayTbMzsPBo3Pw.png"/></div></div></figure><p id="9d18" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">现在，让我们点击我们的API，看看我们的处理程序是否在做它们的工作:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/91edf7b489b335230b623aa9a7d7ac84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aCvtktc9xaVyTMS82_x5Xw.png"/></div></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">对于那些感兴趣的人，我正在使用<a class="ae lu" href="https://insomnia.rest/" rel="noopener ugc nofollow" target="_blank">失眠</a>休息客户端</figcaption></figure><p id="c9bb" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">由于我们在这个请求中没有包含密码，并且我们已经将密码标记为必填字段，我们的<code class="fe lv lw lx ly b">express-validator</code>助手将此作为一个错误抛出，然后在我们添加到上面的服务器调用顺序中的<code class="fe lv lw lx ly b">errorHandler.ts</code>实用程序中捕捉到这个错误！</p><p id="1e09" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">现在，让我们看看我们的手动错误是否被抛出:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/333eb75d7191b3ff7fe88fc899f778a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Iqh_E4gaBj3QRrAX-hn_A.png"/></div></div></figure><p id="f0e6" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">呜！我们在做生意。让我们也删除被抛出的手动错误，看看我们是否能在快乐路径中获得一个成功的响应，一个格式正确的有效负载，没有假错误:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/20516467c889481f9512323238c88fa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DwRawhWTn7YDRwUZsy8g4Q.png"/></div></div></figure><p id="f9a7" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">这就是我们的流程。我们已经设置好了路由系统、处理自定义类型的方法、验证系统、从头开始的自定义错误模块，以及正确的中间件，所有这些都设置好了，可以运行稳定的API。</p><p id="9ce0" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">虽然我们在本文中没有关注一个大的特性或成就，但这些都是你可以在自己的应用程序或工作中选择使用或不使用的东西。在我的职业生涯中，我已经看到了这些类型的实用程序的大杂烩，希望我能够挑选出一些最好的用于本文。</p><h1 id="d5f8" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="c546" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">本文只是简单介绍了构建生产就绪的API需要做的几件事情，但是下一篇文章将更深入地探讨一个主题:身份验证！我们将为我们的应用程序添加一个auth层，使用Redis进行令牌存储和快速会话。</p><p id="8c29" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">如果有些地方不适合你，我不会感到惊讶，因为在构建这个结构时，我跳过了一些不值得解决的小变化。前往本章分支的<a class="ae lu" href="https://github.com/ryanoillataguerre/nonprofits-medium/tree/Chapter_2-Bootstrapping" rel="noopener ugc nofollow" target="_blank"> Github repo查看源代码。</a></p><p id="b42c" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">感谢阅读，希望你喜欢这篇文章！如果你有任何具体的需求、建议或批评，欢迎在下面留下评论。</p><p id="aa37" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated"><strong class="ky ir"> <em class="me">另外，我将所有代码修改打包成一章后，需要一些时间来写下一篇文章，所以如果你想在我发布它时保持更新，请在媒体上关注我</em> </strong> <a class="ae lu" href="https://medium.com/@ryanoillataguerre" rel="noopener"> <strong class="ky ir"> <em class="me">这里</em> </strong> </a>，<strong class="ky ir"> <em class="me">或者在Twitter上</em> </strong> <a class="ae lu" href="https://twitter.com/roillataguerre" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="me">这里</em> </strong> </a> <strong class="ky ir"> <em class="me">！</em>T25】</strong></p></div></div>    
</body>
</html>