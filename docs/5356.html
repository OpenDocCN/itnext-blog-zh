<html>
<head>
<title>Advanced Git Features You Didn’t Know You Needed</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您不知道自己需要的高级Git特性</h1>
<blockquote>原文：<a href="https://itnext.io/advanced-git-features-you-didnt-know-you-needed-ed8455c45495?source=collection_archive---------2-----------------------#2021-02-15">https://itnext.io/advanced-git-features-you-didnt-know-you-needed-ed8455c45495?source=collection_archive---------2-----------------------#2021-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c2ef" class="pw-subtitle-paragraph ju is it bd b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dk translated">你错过了一些很棒的<code class="fe jq jr js jt b">git</code>功能，比如单词区分、自动更正、插件或提交签名，是时候改变它了…</h2></div><p id="435b" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><code class="fe jq jr js jt b">git</code>是一个非常强大的工具，几乎每个开发人员每天都需要使用，但是对我们大多数人来说，它的使用减少到只有几个命令，比如<code class="fe jq jr js jt b">pull</code>、<code class="fe jq jr js jt b">commit</code>和<code class="fe jq jr js jt b">push</code>。然而，为了高效、多产并充分发挥<code class="fe jq jr js jt b">git</code>的威力，人们需要知道更多的命令和技巧。因此，在本文中，我们将探索一些易于使用、记忆和配置的<code class="fe jq jr js jt b">git</code>特性，这些特性可能会让您处理版本控制的时间变得更加愉快。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi li"><img src="../Images/ba9a344efe723cce800b3dc1ca866407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XBG3VMPpYkvRy7tbue_TLA.jpeg"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated"><a class="ae ly" href="https://unsplash.com/@davezeidler?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> David Z </a>在<a class="ae ly" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="3267" class="lz ma it bd mb mc md me mf mg mh mi mj kd mk ke ml kg mm kh mn kj mo kk mp mq bi translated">改进基本工作流程</h1><p id="b56b" class="pw-post-body-paragraph km kn it ko b kp mr jy kr ks ms kb ku kv mt kx ky kz mu lb lc ld mv lf lg lh im bi translated">在我们使用最基本的命令如<code class="fe jq jr js jt b">pull</code>、<code class="fe jq jr js jt b">commit</code>和<code class="fe jq jr js jt b">push</code>之前，我们需要了解我们的分支和更改的文件发生了什么。为此，我们将使用<code class="fe jq jr js jt b">git log</code>，这是相当普遍的知识，但不是每个人都知道如何使它的输出<em class="mw">实际上</em>可读和漂亮:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mx my l"/></div></figure><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi mz"><img src="../Images/d7e8c525d7895e6ec434efa597f570ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o46_pHgCCro1tekXgIBp0g.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">git日志图</figcaption></figure><p id="9d16" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">这种图表可以给你一个很好的概述，但通常你可能需要挖掘得更深一点。例如，查看特定文件甚至单个功能的历史/演变，并且<code class="fe jq jr js jt b">git log</code>(带有<code class="fe jq jr js jt b">-L :&lt;funcname&gt;:&lt;file&gt;</code>参数)也可以这样做:</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi na"><img src="../Images/d62d2502ea624d907041443669b9dad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*Cw-Ht8ZhFwQXAqoIoxj_vA.png"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">git日志功能</figcaption></figure><p id="d764" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">既然我们对存储库中发生的事情有了更好的了解，我们可能想要检查我们更新的文件和最近提交的文件之间的差异。为此我们将使用<code class="fe jq jr js jt b">git diff</code>，这里也没有什么新的东西，但是<code class="fe jq jr js jt b">diff</code>有一些你可能不知道的选项和标志。例如，你可以用<code class="fe jq jr js jt b">git diff branch-a..branch-b</code>比较两个分支，或者用<code class="fe jq jr js jt b">git diff &lt;commit-a&gt; &lt;commit-b&gt; -- &lt;path(s)&gt;</code>比较不同分支中的特定文件。</p><p id="83d8" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">有时,<code class="fe jq jr js jt b">git diff</code>的输出可能变得很难阅读。为了帮助解决这个问题，你可以尝试使用<code class="fe jq jr js jt b">-w</code>标志，它会忽略所有的空格，让diff更多地处理单词而不是整行。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi nb"><img src="../Images/f93675a264d5106169aa524e4471679a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x34SR_BTvh9Ks4pfJw67MQ.png"/></div></div></figure><p id="5252" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">如果shell中的基本静态输出对您来说不够好，那么您可以使用<code class="fe jq jr js jt b">git difftool=vimdiff</code>启动<code class="fe jq jr js jt b">difftool</code>，这将在vim编辑器中并排打开diff。Vim显然不是这里唯一的选择，您可以运行<code class="fe jq jr js jt b">git difftool --tool-help</code>来查看您可以使用的所有有效区分工具的列表。</p><p id="0304" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">我们已经看到了如何使用<code class="fe jq jr js jt b">git log</code>查看文件中特定零件/行的历史。类似的事情也很方便——例如——暂存文件的各个部分，对吗？这可以在IDE中很容易地完成，比如IntelliJ，但是使用<code class="fe jq jr js jt b">git</code> CLI就不那么简单了，但是使用<code class="fe jq jr js jt b">git add --patch</code>是可能的:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="b73e" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">这将打开一个编辑器，显示一个<em class="mw">“hunk”</em>，这是一段代码，其中有一些不同的行。你可以对这一大块做很多事情，但最重要的选项是<code class="fe jq jr js jt b">y</code> -接受更改(展示大块)<code class="fe jq jr js jt b">n</code> -不接受(不展示大块)和<code class="fe jq jr js jt b">e</code> -在展示前编辑大块(选项的完整列表<a class="ae ly" href="https://git-scm.com/book/en/v2/Git-Tools-Interactive-Staging#_staging_patches" rel="noopener ugc nofollow" target="_blank">在此</a>)。</p><p id="5f30" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">完成交互式暂存后，您可以运行<code class="fe jq jr js jt b">git status</code>，您将看到部分暂存的文件同时位于<code class="fe jq jr js jt b">Changes to be committed:</code>和<code class="fe jq jr js jt b">Changes not staged for commit:</code>部分。您也可以运行<code class="fe jq jr js jt b">git add -i</code>(交互式暂存)，然后使用<code class="fe jq jr js jt b">s</code>(状态)命令，该命令将显示哪些行已暂存，哪些未暂存。</p><h1 id="1a14" class="lz ma it bd mb mc md me mf mg mh mi mj kd mk ke ml kg mm kh mn kj mo kk mp mq bi translated">纠正常见错误</h1><p id="d992" class="pw-post-body-paragraph km kn it ko b kp mr jy kr ks ms kb ku kv mt kx ky kz mu lb lc ld mv lf lg lh im bi translated">上传文件后，我(也是)经常意识到我添加了一些我不想添加的东西。<code class="fe jq jr js jt b">git</code>没有实际的命令去<em class="mw">卸载</em>一个文件。为了避开这个限制，我们可以使用<code class="fe jq jr js jt b">git reset --soft HEAD somefile.txt</code>重置存储库。您还可以将<code class="fe jq jr js jt b">-p</code>与<code class="fe jq jr js jt b">git reset</code>包含在一起，这将为您提供与<code class="fe jq jr js jt b">git add -p</code>相似的用户界面。此外，不要忘记在这里添加<code class="fe jq jr js jt b">--soft</code>标志，否则您将擦除您的局部更改！</p><h1 id="e0fb" class="lz ma it bd mb mc md me mf mg mh mi mj kd mk ke ml kg mm kh mn kj mo kk mp mq bi translated">使用(少一点)力量</h1><p id="1784" class="pw-post-body-paragraph km kn it ko b kp mr jy kr ks ms kb ku kv mt kx ky kz mu lb lc ld mv lf lg lh im bi translated">现在我们已经准备好了一切，剩下的就是提交和推动了。但是，如果我们忘记添加一些东西或者我们犯了一个错误，我们想修改已经提交的提交，该怎么办呢？使用<code class="fe jq jr js jt b">git commit -a</code>和<code class="fe jq jr js jt b">git push --force</code>有一个简单的解决方案，但是如果我们在像<code class="fe jq jr js jt b">master</code>这样的共享分支上工作，这可能是相当危险的。因此，为了避免用我们的强制推送覆盖其他人的工作，我们可以使用<code class="fe jq jr js jt b">--force-with-lease</code>标志。这个标志——与<code class="fe jq jr js jt b">--force</code>不同——只有在没有其他人同时向分支添加任何变更的情况下才会推送变更。如果分支被更改，我们的推送将被拒绝，这表明我们必须在推送之前获取最新的更改。</p><h1 id="3f8e" class="lz ma it bd mb mc md me mf mg mh mi mj kd mk ke ml kg mm kh mn kj mo kk mp mq bi translated">合并的正确方式</h1><p id="af8b" class="pw-post-body-paragraph km kn it ko b kp mr jy kr ks ms kb ku kv mt kx ky kz mu lb lc ld mv lf lg lh im bi translated">如果您在涉及不止一个开发人员的存储库上工作，假设您在您单独的分支而不是在<code class="fe jq jr js jt b">master</code>上工作是安全的。这也意味着迟早你将不得不把你的代码合并到代码库中(<code class="fe jq jr js jt b">master</code>分支)。很有可能，当你在你的分支上工作的时候，其他人已经把他们的代码添加到了<code class="fe jq jr js jt b">master</code>分支中，使得你的特性分支落后了几个提交。现在，您可以继续使用<code class="fe jq jr js jt b">git merge</code>将您的代码合并到<code class="fe jq jr js jt b">master</code>中，但是这将创建额外的<em class="mw">合并提交</em>，并使历史(不必要的)更加复杂和难以阅读:</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi nc"><img src="../Images/d76cefbfc96a75407301b0d921e6cdb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mubBr9x2YDg2m1-2gTDSFQ.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">分支历史</figcaption></figure><p id="4512" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">更好的方法(尽管和我争论，这是一个我愿意死在上面的象征性的小山)是首先将特征分支重新放在<code class="fe jq jr js jt b">master</code>上，然后执行所谓的<em class="mw">快速</em>合并(<code class="fe jq jr js jt b">git merge --ff</code>)。这维护了易于阅读的线性历史，并且使得以后查找引入了某些特定特性或错误的提交变得更加容易。</p><p id="ef6a" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">但是我们如何做这个<em class="mw">重定基数</em>的事情呢？嗯，您可以用<code class="fe jq jr js jt b">git rebase master feature/branch</code>以最基本的形式执行rebase，这通常就足够了(接着是force-push)。为了最大限度地利用<code class="fe jq jr js jt b">git rebase</code>,你还应该包括<code class="fe jq jr js jt b">-i</code>来开始一个<em class="mw">交互式</em> rebase会话，这是一个方便的工具，例如重新措辞、压缩或通常清理你的提交和整个分支。作为一个小小的演示，我们甚至可以将分支重新定位到其自身上:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="febc" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">上面有效地允许我们重新应用最后4个提交，同时对它们进行修改。例如，压缩一些内容并改写其他内容:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f835" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">上述示例显示了一个重定基础会话的示例。在顶部，我们可以看到该分支在重设基础之前的样子。代码片段的第二部分显示了运行<code class="fe jq jr js jt b">git rebase ...</code>后我们得到的提交列表，每个提交都带有<code class="fe jq jr js jt b">pick</code>动作。我们可以改变每一项的操作，也可以完全重新排序。如示例的第三部分所示，您可以使用的一些操作是- <code class="fe jq jr js jt b">reword</code>指示<code class="fe jq jr js jt b">git</code>为您打开提交消息编辑器，<code class="fe jq jr js jt b">squash</code>将提交合并到它前面的一个中，<code class="fe jq jr js jt b">fixup</code>与<code class="fe jq jr js jt b">squash</code>相同，但它也将丢弃一个提交消息。在我们应用这些更改并改写修改后的提交后，我们将在上面的例子的底部显示历史。</p><p id="3279" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">如果在重设基础的过程中你遇到了一些冲突，那么你可以运行<code class="fe jq jr js jt b">git mergetool --tool=vimdiff</code>来解决它们，然后用<code class="fe jq jr js jt b">git rebase --continue</code>继续重设基础。你可能对<code class="fe jq jr js jt b">git mergetool</code>不熟悉，第一次看它可能会感到害怕。这真的和你在IntelliJ这样的IDE中看到的一样，只是在<em class="mw">“Vim style”</em>中。与任何使用vim的工具一样，如果您不知道至少几个快捷方式，就很难导航和使用它，在这种情况下，甚至很难意识到您实际上在看什么。所以，如果你在这方面需要一些帮助，我推荐阅读这篇全面的文章。</p><p id="3277" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">如果以上感觉太复杂或者你只是害怕使用<code class="fe jq jr js jt b">rebase</code>你可以在GitHub中创建拉请求，使用<em class="mw"> Rebase和merge </em>按钮至少做简单的快进Rebase/merge。</p><h1 id="8194" class="lz ma it bd mb mc md me mf mg mh mi mj kd mk ke ml kg mm kh mn kj mo kk mp mq bi translated">效率是关键</h1><p id="941b" class="pw-post-body-paragraph km kn it ko b kp mr jy kr ks ms kb ku kv mt kx ky kz mu lb lc ld mv lf lg lh im bi translated">我认为上面的例子展示了一些漂亮的技巧和诀窍，但是要记住所有这些可能很难，尤其是当涉及到像<code class="fe jq jr js jt b">git log</code>这样的命令时。幸运的是，我们可以使用<code class="fe jq jr js jt b">git</code>的全局配置和别名来克服这个问题，使事情使用起来更加方便。全局git配置位于<code class="fe jq jr js jt b">~/.gitconfig</code>中，每次运行<code class="fe jq jr js jt b">git config --global ...</code>时都会更新。即使你没有尝试建立这个文件，它可能包含一些基本的东西，如<code class="fe jq jr js jt b">[user]</code>部分，但是你可以放入更多的东西:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="b691" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">上面你可以看到一些可用的配置选项的例子。特别是别名为<code class="fe jq jr js jt b">git graph</code>的looong <code class="fe jq jr js jt b">git log</code>命令。自动更正设置为<code class="fe jq jr js jt b">10</code>，这将启用它，并使它等待1秒钟，然后执行错误键入的正确命令，最后配置GPG提交签名(更多内容见下文)。</p><p id="fee0" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">设置带有一堆别名的<code class="fe jq jr js jt b">.gitconfig</code>将保证一篇独立的文章，并且也有相当多的好资源和例子可以包含在您的<code class="fe jq jr js jt b">.gitconfig</code>中，所以我不会给你所有选项和别名的详尽列表，我将在这里留下这些资源:</p><ul class=""><li id="575a" class="nd ne it ko b kp kq ks kt kv nf kz ng ld nh lh ni nj nk nl bi translated"><a class="ae ly" href="https://github.com/jessfraz/dotfiles/blob/master/.gitconfig" rel="noopener ugc nofollow" target="_blank">https://github.com/jessfraz/dotfiles/blob/master/.gitconfig</a></li><li id="ff0f" class="nd ne it ko b kp nm ks nn kv no kz np ld nq lh ni nj nk nl bi translated"><a class="ae ly" href="https://gist.github.com/pksunkara/988716" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/pksunkara/988716</a></li><li id="ddfa" class="nd ne it ko b kp nm ks nn kv no kz np ld nq lh ni nj nk nl bi translated"><a class="ae ly" href="https://github.com/mgedmin/dotfiles/blob/master/gitconfig" rel="noopener ugc nofollow" target="_blank">https://github.com/mgedmin/dotfiles/blob/master/gitconfig</a></li></ul><p id="a8cf" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">命令自动完成也可以实现与别名类似的生产率提升。您可以使用以下方法简单地安装它:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="8e81" class="lz ma it bd mb mc md me mf mg mh mi mj kd mk ke ml kg mm kh mn kj mo kk mp mq bi translated">临时演员</h1><p id="d733" class="pw-post-body-paragraph km kn it ko b kp mr jy kr ks ms kb ku kv mt kx ky kz mu lb lc ld mv lf lg lh im bi translated">除了建立自己方便的别名，你还可以使用<code class="fe jq jr js jt b">git-extras</code>插件，它引入了很多有用的命令，可以让你的生活变得更简单。我不打算详细介绍这个插件的所有特性——你可以查看它的<a class="ae ly" href="https://github.com/tj/git-extras/blob/master/Commands.md" rel="noopener ugc nofollow" target="_blank">命令列表</a>——只是给你一个内部的快速样本:</p><ul class=""><li id="9399" class="nd ne it ko b kp kq ks kt kv nf kz ng ld nh lh ni nj nk nl bi translated"><code class="fe jq jr js jt b">git delta</code> -列出不同于另一个分支的文件。</li><li id="5ba4" class="nd ne it ko b kp nm ks nn kv no kz np ld nq lh ni nj nk nl bi translated"><code class="fe jq jr js jt b">git show-tree</code> -显示来自所有分支的提交的装饰图视图，类似于前面显示的<code class="fe jq jr js jt b">git log</code>。</li><li id="1fb3" class="nd ne it ko b kp nm ks nn kv no kz np ld nq lh ni nj nk nl bi translated"><code class="fe jq jr js jt b">git pull-request</code> -通过命令行创建拉取请求。</li><li id="fcdb" class="nd ne it ko b kp nm ks nn kv no kz np ld nq lh ni nj nk nl bi translated"><code class="fe jq jr js jt b">git changelog</code> -从标签和提交消息生成变更日志。</li></ul><p id="b998" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">当然，这不是唯一的酷插件。例如，另一个方便的工具是，它允许您直接从CLI在浏览器中打开回购。您可能还想在终端提示符下配置存储库状态，这可以通过<code class="fe jq jr js jt b">zsh</code>或<code class="fe jq jr js jt b">bash-it</code>来完成。</p><h1 id="9fef" class="lz ma it bd mb mc md me mf mg mh mi mj kd mk ke ml kg mm kh mn kj mo kk mp mq bi translated">签名提交</h1><p id="4b69" class="pw-post-body-paragraph km kn it ko b kp mr jy kr ks ms kb ku kv mt kx ky kz mu lb lc ld mv lf lg lh im bi translated">即使你从未参与过任何OSS项目，你也可能浏览过一个这样项目的提交历史。在提交历史中，您很可能已经看到了提交签署和/或签名/验证提交徽章。但是这些是什么，为什么你可能想使用它们？</p><p id="35e1" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">第一个是“提交签署”,一些项目使用它来证明您已经创建了有问题的代码，或者证明就您所知，它是在适当的开源许可下创建的。这是出于与代码版权状态相关的法律原因而使用的。您通常不需要使用它，但是如果您想在某个时候向需要它的项目贡献代码，那么下面是如何使用它:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1382" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">从上面我们可以看到，运行带有<code class="fe jq jr js jt b">--sign-off</code>选项的<code class="fe jq jr js jt b">git commit</code>会根据您在<code class="fe jq jr js jt b">git</code>配置中的用户名自动在提交消息的末尾添加<code class="fe jq jr js jt b">Signed-off-by: ...</code>行。</p><p id="ac85" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">至于你可能在一些存储库中注意到的签名/验证徽章——它是存在的，因为在GitHub上冒充其他用户非常容易。你所需要做的就是在你的配置中更改提交者的名字和电子邮件，并推送你的代码更改。为了防止这种假冒，您可以使用GPG键使用提交歌唱，这验证了提交和推送提交中的代码的人确实是他们所声称的人。这比提交签署更常见，因为知道谁真正贡献了代码是很重要的。</p><p id="26bb" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">如果您想开始使用此功能，或者在您的团队中强制使用，那么您可以执行以下操作:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f3e3" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">您将首先生成GPG密钥对(假设您还没有)，然后使用<code class="fe jq jr js jt b">git config ...</code>设置您的签名密钥，最后在提交代码时添加<code class="fe jq jr js jt b">-S</code>选项。当您在GitHub中查看提交信息时，您会看到如下图所示的徽章。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/b1f09e0cb05a7aa1aca7f295c5b1d593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*NFTUO6vyOX_qZ-hrB2imuQ.png"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">签名的未验证提交</figcaption></figure><p id="f68f" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">正如图片所示，签名未经验证，因为GitHub不知道GPG密钥属于你。为了解决这个问题，我们需要将密钥对中的公钥添加到GitHub中。为此，我们使用<code class="fe jq jr js jt b">gpg --export</code>导出密钥，如您在此处所示:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9429" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">然后你可以把这个密钥粘贴到https://github.com/settings/gpg/new的字段中。添加密钥后，如果您检查之前签名的提交，您会看到它现在已经过验证，假设您添加到GitHub的密钥与您用于签名的密钥相同:</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/709c448559c8f227acbd547309354b13.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*bKfkzZEot4-_ET--JCPIyA.png"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">签名验证提交</figcaption></figure><h1 id="6c01" class="lz ma it bd mb mc md me mf mg mh mi mj kd mk ke ml kg mm kh mn kj mo kk mp mq bi translated">结束语</h1><p id="9d07" class="pw-post-body-paragraph km kn it ko b kp mr jy kr ks ms kb ku kv mt kx ky kz mu lb lc ld mv lf lg lh im bi translated">是一个非常强大的工具，它有太多的子命令和选项，无法在一篇文章中全部涵盖。如果你想深入一些与<code class="fe jq jr js jt b">git</code>相关的话题，我推荐你阅读<a class="ae ly" href="https://blog.bitsrc.io/debugging-with-git-84b3cd53e587" rel="noopener ugc nofollow" target="_blank">用Git </a>调试以获得关于<code class="fe jq jr js jt b">blame</code>和<code class="fe jq jr js jt b">bisect</code>的信息，或者<a class="ae ly" href="https://medium.com/@porteneuve/getting-solid-at-git-rebase-vs-merge-4fa1a48c53aa" rel="noopener">在Git rebase vs. merge </a>中获得关于<code class="fe jq jr js jt b">rebase</code>和<code class="fe jq jr js jt b">merge</code>的更深入的解释。除了互联网上的许多有用的文章，当你寻找关于<code class="fe jq jr js jt b">git</code>的一些复杂信息时，通常最好的办法是使用<code class="fe jq jr js jt b">--help</code>选项浏览<code class="fe jq jr js jt b">man</code>页面，或者在<a class="ae ly" href="https://git-scm.com/doc" rel="noopener ugc nofollow" target="_blank">https://git-scm.com/doc</a>浏览它的在线版本。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><p id="62e4" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><em class="mw">本文原帖</em><a class="ae ly" href="https://martinheinz.dev/blog/43?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=blog_post_43" rel="noopener ugc nofollow" target="_blank"><em class="mw">martinheinz . dev</em>T22】</a></p><div class="oa ob gp gr oc od"><a href="https://towardsdatascience.com/networking-tools-every-developer-needs-to-know-e17c9159b180" rel="noopener follow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">每个开发人员都需要知道的网络工具</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">让我们学习被忽视的网络技能，如检查DNS记录，扫描端口，排除连接故障…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">towardsdatascience.com</p></div></div><div class="om l"><div class="on l oo op oq om or ls od"/></div></div></a></div><div class="oa ob gp gr oc od"><a href="https://towardsdatascience.com/its-time-to-say-goodbye-to-docker-5cfec8eff833" rel="noopener follow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">你不用再用Docker了</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">Docker不是唯一的集装箱工具，可能会有更好的替代工具…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">towardsdatascience.com</p></div></div><div class="om l"><div class="os l oo op oq om or ls od"/></div></div></a></div><div class="oa ob gp gr oc od"><a href="https://medium.com/better-programming/save-your-linux-machine-from-certain-death-24ced335d969" rel="noopener follow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">从死亡中拯救你的Linux机器</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">恢复您的根密码和更多</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">medium.com</p></div></div><div class="om l"><div class="ot l oo op oq om or ls od"/></div></div></a></div></div></div>    
</body>
</html>