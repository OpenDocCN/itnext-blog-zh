# 用 TypeScript 设置 NodeJS API:第 1 部分

> 原文：<https://itnext.io/setting-up-a-nodejs-api-with-typescript-part-1-9f7c152b2af6?source=collection_archive---------3----------------------->

## 实践介绍

![](img/8df46f597f2d1d05d320453caf3340e8.png)

# 介绍

使用 TypeScript 开发 API 时，有许多风格可供选择。像 NestJS、LoopBack 和其他一些框架要么建立在 TypeScript 之上，要么提供对它的支持。但是，如果您想设置一个快速的服务器，并且不使用包含电池的框架，那么该怎么办呢？本文的目的是帮助您快速获得一个简约而完整的服务器并运行。

本文面向至少对 NodeJS 开发有点熟悉的开发人员，它不会详细解释使用的每个概念。这里可以看到完整的代码[。](https://github.com/TudorIoanMarin/nodejs-ts-v1)

# 先决条件

*   NodeJS ≥ v14.15.0
*   你选择的编辑
*   [nvm](https://github.com/nvm-sh/nvm) (可选)

在撰写本文时，我选择使用 Node 的 LTS 版本:v16.13.1

# 入门指南

我们将从创建一个新项目并初始化我们选择的包管理器开始，我将使用 npm。这将提示您一系列的选择，现在使用默认的。

创建初始文件夹结构的命令

创建 app.ts 和 server.ts 文件使我们能够将 API 声明与网络问题分离开来。这将有助于测试，因为我们现在可以模拟 HTTP 调用。

首先，我们需要安装更多的依赖项。为了便于开发，我们将使用 Express 来处理路线。Express 是一个用于 NodeJS 的极简 web 框架。它不支持 TypeScript，但是我们可以找到 Node 和 Express 的声明文件。这将允许我们访问类、接口、类型和基本上大多数的 TypeScript 好东西。然而，请记住这些文件只是类型声明，它们是**而不是实际的源代码**。

目前，我们将创建一个简单的“Hello，World！”在 app.ts 文件中:

然后我们将它导入 server.ts 文件，并使用它来创建一个 HTTP 服务器:

# 添加类型脚本支持和林挺

运行以下命令会将 TypeScript 作为开发依赖项安装，并创建一个 tsconfig.json 文件。

在删除了所有带注释的样板文件后，它看起来会像这样:

为了设置构建过程的输出目录并获得一个 sourcemap，我们将向其中添加以下代码行。sourcemap 将允许我们查看映射到原始代码的对我们构建的任何引用。

要生成 tslint.json 文件，请运行以下命令:

配置文件将扩展推荐的 tslint 规则，但是您可以根据自己的喜好进行混合和匹配。例如，如果您希望跳过林挺错误，直到我们稍后添加日志程序，您可以将无控制台规则的严重性更改为如下警告:

# 发出命令

现在我们有几个命令可以运行来与我们的项目进行交互，我们将会非常频繁地使用这些命令。我们将添加一个 **Makefile** ，而不是仅仅依赖于 **package.json** 脚本。这将导致更短的命令和未来的证明，我们可以编写外壳代码，并在它变得复杂时仍然保持可读。

![](img/d47a9c72ef58ba7eb5263c44757cace7.png)

但是首先，我们需要安装更多的依赖项: **nodemon** 和 **ts-node** 。Nodemon 主要是一个开发工具，它会在检测到源代码中的变化时重启服务器，这是开发的理想选择。 **ts-node** 使我们能够执行类型脚本代码，而不需要构建步骤。同样，这将简化开发过程。

在我们的 **package.json** 中，我们将定义四个命令: **lint、build、start** 和 **start:dev。**

**lint** 命令执行它所说的:lint 在 src 文件夹下找到的代码并输出任何错误和警告。构建命令将生成我们的应用程序的 JavaScript 构建和 dist 文件夹中的源地图。 **start** 和 **start:dev** 的区别在于，dev 命令将直接执行类型脚本代码，而 start 命令将运行已经编译好的代码。

在我们的 makefile 中，我们将在上述脚本的基础上构建一个更全面的服务器生命周期命令集。

现在我们只需为每个进程调用 **make < command >** 。

# 环境变量设置

服务器将在不同的环境中运行，所以让我们轻松地配置可能会改变的属性。例如，我们可能希望服务器在本地 3000 端口上运行，但是当它部署到云上时，它在 8080 端口上运行。

在当地。被 git 忽略的 env 文件将允许我们轻松地配置这些值，这样就不需要修改代码就能以不同的方式运行我们的代码。将 API 键之类的敏感信息保存在。因为它不会被推送到 git。让我们看看我们是如何做到这一点的:

Dotenv 提供了自己的类型定义，所以我们不需要为它安装额外的类型定义。接下来，我们需要在应用程序的根目录下创建一个. env 文件，并将以下几行添加到该文件中:

我们需要在 server.ts 文件中对其进行配置:

服务器启动后，该端口已用于记录消息。换一个。启动服务器时，env 将导致日志发生变化。NODE_ENV 属性用于表示服务器是以开发模式还是生产模式运行。这可以在很多情况下帮助我们，其中一个我们将在接下来讨论日志时看到。

# 记录

调试和监控不再在您的机器上本地运行的服务器带来了挑战。然而，访问它的日志以及适当的错误处理应该是一个好的起点。

![](img/2a78c925ab7fdde805c31695688af711.png)

我们将使用一个名为 Winston 的库来处理日志部分。Winston 是一个流行的日志库，它将自己定义为一个几乎所有事情的日志记录器。这些日志可以由不同的第三方服务获取，以便于访问。

我们将为记录器做一个基本配置，创建 3 个传输。一个只将错误记录到一个文件中，一个将所有内容记录到一个文件中，一个控制台传输也将记录到控制台中。最后一个将依赖于我们的环境，因为我们只在开发时需要它。

colorize 方法为控制台日志添加了一些颜色，以提高可读性。现在，我们可以根据严重性导入记录器和日志，而不是使用 console.log。

# 结论

结果是一个在幕后使用 TypeScript 的服务器，有一组现成的命令，可以在开发和生产中运行。它还被设置为使用环境变量，并且有一个日志记录器。这足够开始了吗？

![](img/2d64a9691c1a17c343656525ebb4998f.png)

算是吧。我们有一个很好的起点，但我们错过了一些东西。本系列的第 2 部分完成了服务器样板文件，并探讨了测试、安全性和容器化等主题。一定要去看看！

本文中介绍的所有主题都可以深入兔子洞，所以如果您对更深入的后续内容感兴趣，请告诉我。

如果你觉得这篇文章有帮助，鼓掌并分享它，这样它会帮助更多的人。有问题吗？在 [LinkedIn](https://www.linkedin.com/in/tudor-ioan-marin-89870848/) 上给我留言。