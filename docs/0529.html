<html>
<head>
<title>Comparable and Comparator in JAVA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JAVA中的比较器和比较器</h1>
<blockquote>原文：<a href="https://itnext.io/comparable-and-comparator-in-java-bbb8e89f1fec?source=collection_archive---------2-----------------------#2018-03-26">https://itnext.io/comparable-and-comparator-in-java-bbb8e89f1fec?source=collection_archive---------2-----------------------#2018-03-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f36e7a9fde82e74e5a882a31246fc0b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*51B1LBLEQyKZy5x8."/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">迭戈·杜阿尔特·塞雷塞达在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的“圣地亚哥的一长排橙色出租自行车”</figcaption></figure><blockquote class="kd ke kf"><p id="251a" class="kg kh ki kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><a class="ae kc" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fcomparable-and-comparator-in-java-bbb8e89f1fec%3Futm_source%3Dmedium_sharelink%26utm_medium%3Dsocial%26utm_campaign%3Dbuffer" rel="noopener ugc nofollow" target="_blank"> <em class="iq">点击这里在LinkedIn上分享这篇文章</em> </a></p></blockquote><p id="22dc" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">当构建程序来解决特定问题时，我们会遇到许多创建自己的类(自定义类)的情况。例如，一个表示新闻文章的类可以在抓取新闻网站时保存信息。</p><p id="194d" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">无论我使用什么编程语言，都有许多有用的内置实用程序来扩展我自己的代码。最有用的内置函数工具之一是对数组或列表进行排序。然而，我们需要付出一点努力来实现适用于自定义类的排序功能。因为内置的排序工具不知道有一个新创建的类，我们应该让它们知道有一个。</p><p id="7acd" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">Comparable和Comparator是为了给JAVA中的自定义类提供排序能力而引入的。在这篇文章中，我想谈谈他们。</p></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><h1 id="2ab2" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">可比较的</h1><p id="7afd" class="pw-post-body-paragraph kg kh iq kj b kk mn km kn ko mo kq kr lf mp ku kv lg mq ky kz lh mr lc ld le ij bi translated">Comparable是java.lang包中包含的接口之一。意思是不需要你自己包含，在JAVA里是很原始的。即使你不知道，JAVA提供的一些基本类已经自带了。</p><p id="346a" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">Comparable interface的目的是让新的类实例能够将其自身与属于同一类类型的其他实例进行比较。你可以在这里找到官方文档(<a class="ae kc" href="https://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/7/docs/API/Java/lang/comparable . html</a>)。如果你仔细研究过，在使用它之前，你应该只记得两件事。</p><ul class=""><li id="9af3" class="ms mt iq kj b kk kl ko kp lf mu lg mv lh mw le mx my mz na bi translated"><strong class="kj ir">类型参数(你想比较哪个类？)</strong></li><li id="d53a" class="ms mt iq kj b kk nb ko nc lf nd lg ne lh nf le mx my mz na bi translated"><strong class="kj ir"> compareTo法(如何比较？)</strong></li></ul><p id="415e" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">类型参数几乎总是与实现Comparable的类的类类型相同，并且类型参数指示我们想要与哪个类进行比较。然后，我们实际上让自定义类知道如何将自己与其他类进行比较，这种能力可以通过实现compareTo方法来提供。</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="aa8a" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">compareTo方法接受一个自定义类希望与之进行比较的参数变量，compareTo方法返回一个整数值，以指示自定义类应该放在对手实例的前面、后面还是相等位置。因此，返回值应该分为三个值域。</p><ul class=""><li id="6e67" class="ms mt iq kj b kk kl ko kp lf mu lg mv lh mw le mx my mz na bi translated"><strong class="kj ir"> 0(相等)</strong></li><li id="bcd8" class="ms mt iq kj b kk nb ko nc lf nd lg ne lh nf le mx my mz na bi translated"><strong class="kj ir"> +(后)</strong></li><li id="037b" class="ms mt iq kj b kk nb ko nc lf nd lg ne lh nf le mx my mz na bi translated"><strong class="kj ir"> -【前】</strong></li></ul><p id="8288" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">上面的示例代码显示了Person类如何通过名为“age”的变量进行自我比较。当当前实例的年龄为10岁而对手的年龄为11岁时，compareTo方法返回-1。这意味着当前实例应该放在对手之前，当我们把它们放在一起的时候。</p><pre class="ng nh ni nj gt nm nn no np aw nq bi"><span id="f697" class="nr lq iq nn b gy ns nt l nu nv">List&lt;Person&gt; people = fetchMembers();<br/>Collections.sort(people);</span></pre><p id="02eb" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">在定义了具有可比接口的自定义类之后，我们可以通过将列表传递给Collections.sort方法(<a class="ae kc" href="https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#sort(java.util.List)" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/7/docs/API/Java/util/collections . html # sort(Java . util . list)</a>作为参数，轻松地对包含该类实例的列表/数组进行排序。如果存储在给定列表中的实例的类没有实现可比较的接口，Collections.sort方法将抛出一个错误。</p><p id="1ee1" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">Collections.sort方法不返回任何内容，但是传递给它的列表将会对其元素进行排序。</p></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><h1 id="273e" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">可比的问题</h1><p id="2b32" class="pw-post-body-paragraph kg kh iq kj b kk mn km kn ko mo kq kr lf mp ku kv lg mq ky kz lh mr lc ld le ij bi translated">对于我们的代码来说，类似的接口带来了多少便利，这看起来很不错。然而，这种方法有一个问题。OOP(面向对象编程)方法也许能够解释这个问题。在OOP范例中，最好尽可能将代码解耦。</p><p id="d11c" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">对于上一节中的例子，我们让Person类实现Comparable接口，将它自己与名为“age”的变量进行比较。如果我们想用不同的变量比如“名字”来比较呢？我们每次都必须修改compareTo方法内部的代码。Person类可以看作是一个模型类，它可以用在很多地方。这意味着Person类也可以被其他开发者的代码引用！</p><p id="79fe" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">这是不好的，因为如果我们在修改代码时犯了语法错误，离开办公室一段时间，许多同事将不得不等待，甚至不知道发生了什么。</p><p id="35e0" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">然后，我们可以对自己说，如果我们能够将人员类别与比较功能分开，那就更好了。</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><h1 id="7961" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">比较仪</h1><p id="0b3b" class="pw-post-body-paragraph kg kh iq kj b kk mn km kn ko mo kq kr lf mp ku kv lg mq ky kz lh mr lc ld le ij bi translated">下面的代码是以非常标准的形式编写的，在下一节中可以找到更实用的代码实现。所以，你不用一直提心吊胆的写这么繁琐的代码。</p><p id="14d8" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">Comparator是java.util包中包含的一个接口，用于解决上一节中讨论的问题。我们可以从自定义类中提取比较功能，并在单独的类中定义该功能。</p><p id="3b77" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">下面的代码示例定义了实现比较器接口的PersonAgeComparator类。如您所见，比较器界面看起来与可比界面非常相似。区别在于方法名(comareTo → compare)和参数数量。正如方法名的变化所表明的，Comparator看起来更像Comparable的通用接口。正如你所猜测的，这个方法采用两个参数的原因是它不知道要比较哪一个。</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><pre class="ng nh ni nj gt nm nn no np aw nq bi"><span id="83e5" class="nr lq iq nn b gy ns nt l nu nv">List&lt;Person&gt; people = fetchMembers();<br/>Collections.sort(people, new PersonAgeComparator());</span></pre><p id="ea79" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">存在覆盖的collections . sort(<a class="ae kc" href="https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#sort(java.util.List,%20java.util.Comparator)" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/7/docs/API/Java/util/collections . html # sort(Java . util . list，%20java.util.Comparator) </a>方法，该方法采用实现比较器接口的类实例的附加第二个参数。其他一切都和前面的例子一样。</p></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><h1 id="2bac" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">匿名比较器</h1><p id="703a" class="pw-post-body-paragraph kg kh iq kj b kk mn km kn ko mo kq kr lf mp ku kv lg mq ky kz lh mr lc ld le ij bi translated">如果比较标准在整个项目中非常流行，那么用比较器编写类的标准方法会很有用。然而，一些开发人员希望为临时目的定义这样的功能。然后，为了提高他们的工作效率，一直定义单独的类可能是一项非常繁琐的工作。</p><p id="ade6" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">对于这种情况，我们可以使用被称为“匿名类”的语法技巧。下面的代码示例展示了如何实现这一点。关于匿名类的更多详细信息，请通读这个(<a class="ae kc" href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/tutorial/Java/javaOO/Anonymous classes . html</a>)。</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><h1 id="7230" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">带有Lambda表达式的比较器</h1><p id="9c8b" class="pw-post-body-paragraph kg kh iq kj b kk mn km kn ko mo kq kr lf mp ku kv lg mq ky kz lh mr lc ld le ij bi translated">匿名类看起来对提高我们的工作效率很有用，但是我们可以通过JAVA8中新引入的Lambda表达式进一步提高。如果你了解函数式编程语言，这并不是什么新鲜事。Lambda expression只是一个附加特性，反映了函数式编程范式的日益流行。Lambda expression的官方教程可以在这里找到(<a class="ae kc" href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html" rel="noopener ugc nofollow" target="_blank">http://www . Oracle . com/web folder/tech network/tutorials/OBE/Java/Lambda-quick start/index . html</a>)。</p><p id="bda7" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">使用Lambda表达式和List类中的新方法“sort ”,我们可以用一行代码对列表进行排序。您可能需要一些时间来熟悉这种风格的代码，但是您会惊讶于它能提高多少代码可读性。</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2112" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">上面的示例代码展示了三种不同的方式来编写Lambda表达式。</p></div></div>    
</body>
</html>