<html>
<head>
<title>Full production Django Docker configuration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">完全生产Django Docker配置</h1>
<blockquote>原文：<a href="https://itnext.io/full-production-django-docker-configuration-75824855da03?source=collection_archive---------0-----------------------#2020-05-25">https://itnext.io/full-production-django-docker-configuration-75824855da03?source=collection_archive---------0-----------------------#2020-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2dcf4fdbec28853ff0023807f95b305e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_hBb3eEmFWGKoi_O.jpg"/></div></div></figure><p id="8f8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当前的软件开发生态系统发展很快，似乎像Django或Rails这样的旧框架正在成为绝对的，但这是一个巨大的低估！Django是我最喜欢使用的独特框架之一，因为它包含了所有的东西，只需要一些简单的配置。</p><p id="e063" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设您想要基于现有的数据库和已经预定义的模型构建一个简单的管理面板。即使项目是用Node.js或Go编写的，我也总是使用Django来创建一个基本的管理面板，因为不需要UI编码，只需要简单的DB和python配置。</p><p id="961c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一方面，Django在制作API端点方面提供了很多灵活性和简单性，特别是当Django Graphene问世时，我们刚刚在https://treescale.com<a class="ae kz" href="https://treescale.com" rel="noopener ugc nofollow" target="_blank">用Django和GraphQL制作了完整的API。代码维护变得更加容易和灵活。</a></p><h1 id="42cf" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Django的码头工人？</h1><p id="550e" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">一般来说，python生态系统采用Virtualenv来运行python应用程序，就像当你想拥有多个python版本或特定库的多个版本时，你必须在不同的虚拟环境下运行它。有了Docker，事情变得简单了一些，因为Docker本身是一个完全不同的环境和文件系统，包含了所有的库，正因为如此，Python生态系统是容器化应用程序的首批采用者之一。</p><p id="a050" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当涉及到真正的DevOps部署或资源管理的便利性时，在Docker中运行Django是真正的交易破坏者。所以不管你喜不喜欢在Docker容器中运行Django，都比试图用Virtualenv配置它并单独管理代码传输要好得多。</p><h1 id="dab0" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">入门指南</h1><p id="4961" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">Django应用程序本身只是一个结构良好的python文件，只有一个入口点。其余的功能，如Django框架本身，都存储在python包目录中，通常，当您基于最佳实践开发Python项目时，您会保存文件<code class="fe md me mf mg b">requirements.txt</code>来管理包及其版本<code class="fe md me mf mg b">pip</code>。</p><p id="1a81" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">很可能你的<code class="fe md me mf mg b">requirements.txt</code>文件看起来像这样</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="ef1c" class="mp lb it mg b gy mq mr l ms mt">django==3.0.6<br/>graphene-django==2.10.0<br/>psycopg2===2.8.5<br/>django-graphql-jwt==0.3.1<br/>requests==2.23.0<br/>django-cors-headers==3.2.1</span></pre><p id="59db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我们在Django项目<a class="ae kz" href="https://treescale.com" rel="noopener ugc nofollow" target="_blank"> TeeScale </a>中的一个项目，它非常简单，但这里的关键部分是保持特定的包版本定义，否则，你会弄乱你的Docker构建和项目执行。有时包会随着一些重大的变化而更新，当它在您的本地开发环境中时，您看不到任何问题，但是当它进入Docker构建或生产时，它会崩溃。我去过那里，相信我，一点也不好玩！</p><p id="cc4d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">保存这个<code class="fe md me mf mg b">requirements.txt</code>文件的一个关键部分是能够自动化Dockerfile安装过程，否则，您将很难记住在您的项目中使用哪个包来提供Docker build上的安装脚本。</p><p id="d537" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">非常简单的Docker构建文件看起来像这样</strong></p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="48ac" class="mp lb it mg b gy mq mr l ms mt">FROM python:3-alpine<br/>ADD . /api<br/>WORKDIR /api </span><span id="030f" class="mp lb it mg b gy mu mr l ms mt"># You will need this if you need PostgreSQL, otherwise just skip this<br/>RUN apk update &amp;&amp; apk add postgresql-dev gcc python3-dev musl-dev libffi-dev<br/>RUN pip install -r requirements.txt</span><span id="c0e3" class="mp lb it mg b gy mu mr l ms mt">EXPOSE 8000</span><span id="ad0b" class="mp lb it mg b gy mu mr l ms mt">CMD ["./manage.py", "runserver"]</span></pre><p id="e61e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将用默认的启动脚本构建一个基本的Docker映像来运行Django开发服务器。继续看，这绝对不是量产版！</p><h1 id="ed31" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">生产用UWSGI</h1><p id="16df" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">如果您不知道专门为可伸缩Python服务器执行而设计的特定工具，那么在生产中运行Django可能会很有挑战性。事实上，最好的Python服务器之一是UWSGI，它为Pinterest或Dropbox等大型服务器提供支持！</p><p id="172f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">UWSGI基本上是一个并发Python执行服务器，它处理一般的HTTP请求，并使用OS的本地基于事件的网络原理模拟连接处理，而Django将有时间响应该请求。它非常类似于Node.js的请求处理原则，这为您的Django应用程序提供了一个巨大的机会，甚至可以每秒处理几千个请求。</p><p id="a7f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">带有UWSGI的简单Dockerfile看起来像这样</strong></p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="37e7" class="mp lb it mg b gy mq mr l ms mt">FROM python:3-alpine<br/>ADD . /api<br/>WORKDIR /api</span><span id="442b" class="mp lb it mg b gy mu mr l ms mt"># You will need this if you need PostgreSQL, otherwise just skip this<br/>RUN apk update &amp;&amp; apk add postgresql-dev gcc python3-dev musl-dev libffi-dev<br/>RUN pip install -r requirements.txt<br/># Installing uwsgi server<br/>RUN pip install uwsgi</span><span id="7526" class="mp lb it mg b gy mu mr l ms mt">EXPOSE 8000</span><span id="2596" class="mp lb it mg b gy mu mr l ms mt"># This is not the best way to DO, SEE BELOW!!<br/>CMD uwsgi --http "0.0.0.0:8000" --module api.wsgi --master --processes 4 --threads 2</span></pre><p id="cd06" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如你所见，如果你的应用程序名是<code class="fe md me mf mg b">api</code>，你可以通过指定一个像<code class="fe md me mf mg b">api.wsgi</code>这样的应用程序模块来运行你的Django服务器！有趣的是，有一个特定的配置，比如要启动多少个进程来并行执行，以及每个进程要支持多少个线程。</p><p id="b2f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通常我不喜欢在docker文件中编写这种大型配置命令，所以我在根目录下创建了一个名为<code class="fe md me mf mg b">runner.sh</code>的文件，并添加了启动一个实际的Django应用程序所需的所有东西。比如运行预定义的迁移或其他必要的事情。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="b8ae" class="mp lb it mg b gy mq mr l ms mt">#!/usr/bin/env sh</span><span id="0429" class="mp lb it mg b gy mu mr l ms mt"># Getting static files for Admin panel hosting!<br/>./manage.py collectstatic --noinput<br/>uwsgi --http "0.0.0.0:${PORT}" --module api.wsgi --master --processes 4 --threads 2</span></pre><p id="22e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">看看我是如何指定一个实际的<code class="fe md me mf mg b">PORT</code>来作为环境变量运行Django服务器的，这样我就可以通过Dockerfile或Docker执行环境来控制它。</p><p id="038d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">因此最终的docker文件将看起来像这样</strong></p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="6872" class="mp lb it mg b gy mq mr l ms mt">FROM python:3-alpine</span><span id="0b1d" class="mp lb it mg b gy mu mr l ms mt">ADD . /api<br/>WORKDIR /api</span><span id="f5e8" class="mp lb it mg b gy mu mr l ms mt"># You will need this if you need PostgreSQL, otherwise just skip this<br/>RUN apk update &amp;&amp; apk add postgresql-dev gcc python3-dev musl-dev libffi-dev<br/>RUN pip install uwsgi<br/>RUN pip install -r requirements.txt</span><span id="d4fa" class="mp lb it mg b gy mu mr l ms mt">ENV PORT=8000<br/>EXPOSE 8000</span><span id="19ba" class="mp lb it mg b gy mu mr l ms mt"># Runner script here<br/>CMD ["/api/runner.sh"]</span></pre><p id="850a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">构建这个Docker映像后，您将获得最简单有效的Django服务器，用于在生产环境中运行并支持大量负载！</p><h1 id="268f" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">下一步是什么？</h1><p id="e8e3" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">这只是一个Django服务器配置，但是您还将有其他微服务与您的Django服务器通信。这就是Docker配置派上用场的地方！我喜欢的设置方式是开始让Docker组合服务来一起配置所有东西，就像这个API Django服务器和PostgreSQL docker实例在同一个网络组中作为链接容器，这样它就不会从服务器公开暴露，但是Django将能够通过基本网络链接与PostgreSQL实例通信。即使当您运行Kubernetes集群时，您也可以简单地使用Kubernetes服务完成几乎相同的工作…无论如何，aaa！我可以谈很多关于为几乎任何应用程序设置Docker容器的优点，但是本文的重点是展示最简单的Docker映像配置，它能够运行几乎所有支持WSGI服务器的Django版本。</p><p id="8b43" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">敬请关注，别忘了在twitter上关注我，中号带手柄@tigranbs🤟</p></div></div>    
</body>
</html>