<html>
<head>
<title>What Rust can teach you, even if you are a C++ fan?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust有什么可以教你的，即使你是C++迷？</h1>
<blockquote>原文：<a href="https://itnext.io/what-rust-can-teach-you-even-if-you-are-a-c-fan-95efeceada73?source=collection_archive---------3-----------------------#2018-07-11">https://itnext.io/what-rust-can-teach-you-even-if-you-are-a-c-fan-95efeceada73?source=collection_archive---------3-----------------------#2018-07-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e25c2f211ecb0a6c9d299e9f480601ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2BTML0YyEJWwoAAP.png"/></div></div></figure><p id="958a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我开始使用Rust作为一个实验，去了解<em class="kz">他们是如何在不损失执行性能的情况下开发内存安全语言的？</em></p><p id="de85" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为一名没有任何特定语言偏好的软件开发人员，我接受了一个想法<code class="fe la lb lc ld b">If Rust compiler compiles code without any issue, it is unlikely that it will give Segmentation fault or there will memory leak</code>。那很酷，不是吗？</p><blockquote class="le lf lg"><p id="55b6" class="kb kc kz kd b ke kf kg kh ki kj kk kl lh kn ko kp li kr ks kt lj kv kw kx ky im bi translated">没有segfaults，没有未初始化的内存，没有强制错误，没有数据竞争，没有空指针，没有头文件，没有makefiles，没有autoconf，没有cmake，没有gdb。如果c/c++的所有问题都被魔杖一挥就解决了，那会怎么样？未来就在这里，https://news.ycombinator.com/item?id=10886253人<br/>T5</p></blockquote><p id="b22b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我不打算制作holly wars，相反，在这篇文章中，我将尝试解释我在Rust中最喜欢的东西，以及我在Rust中编码的前两周所学到的东西，顺便说一下，这提高了我在所有其他编程语言中的编码技能！</p><p id="f91e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以让我们开始吧！🎉</p><h1 id="ea4c" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">1.避免可变的静态声明</h1><p id="126a" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">Rust编译器不允许可变的静态/全局变量声明，事实上，它只允许声明非动态的标准类型(int、const string、float等)，这显然是因为已知的大小。有时候，我们真的需要保留一些全局变量来检查应用程序的每个部分，但是Rust compiler说“好吧！想怎么匹配就怎么检查，但是不要改静态变量，不安全！”</p><p id="63ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">静态声明通常不是线程安全的，而且因为Rust语言建立在拥有<code class="fe la lb lc ld b">move semantics</code>的思想之上，如果你拥有非标准类型的静态变量，你就不能进行匹配。我不确定发生这种情况是因为语言编译器是如何构建的，还是最初的设计，但起初我很惊讶我不能将我的自定义struct mutable对象声明为静态/全局变量，然后当我了解Rust的内存管理概念时，这开始对我有意义。</p><pre class="mo mp mq mr gt ms ld mt mu aw mv bi"><span id="a67d" class="mw lm it ld b gy mx my l mz na">// WRONG!!<br/>static mut SOME_VALUE: SomeType = SomeType{abc: 10};</span><span id="9da3" class="mw lm it ld b gy nb my l mz na">// Correct!<br/>static SOME_VALUE: SomeType = SomeType{abc: 10};</span></pre><p id="379a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">采取一种方式:</strong>不要声明静态/全局变量，以便稍后在其他语言中更改它们，这可能会导致问题(我知道，我知道你可以处理，跳过这一步😏).</p><h1 id="105e" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">2.用树形原则设计你的代码</h1><p id="9f85" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">从Rust的内存管理来看，它抛出了很多非连接的结构，导致“为什么我不能在这里声明我的结构对象？”。这种情况发生在几百行代码之后，但是当我面对这个问题时，我开始重新思考应用程序代码分配应该如何正确地设计代码，并遵循Rust的编译器规则。</p><p id="1645" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">假设您有一个应用程序，它将解析配置文件，并使用该信息启动HTTP服务器。</em></p><p id="8846" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如在Golang中，我会做一些名为<code class="fe la lb lc ld b">config</code>的包，用一个全局变量来表示应用程序配置。然后我将简单地导入这个包并使用这个全局变量。但是在以Rust的方式实现它之后，我真的很喜欢没有全局变量的方法，相反，我需要做这样的东西:</p><pre class="mo mp mq mr gt ms ld mt mu aw mv bi"><span id="8a8a" class="mw lm it ld b gy mx my l mz na">struct Config {<br/>    ...<br/>}</span><span id="f082" class="mw lm it ld b gy nb my l mz na">struct MainApp {<br/>    config: Config,<br/>    ...<br/>}</span><span id="be2e" class="mw lm it ld b gy nb my l mz na">impl MainApp {<br/>    fn new(config_file: &amp;str) -&gt; MainApp {<br/>        // Parsing config file and allocating Config object<br/>    }<br/>}</span></pre><p id="1ba5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">哪个代码看起来更好，你有一个单点主结构，它将分配、创建和声明所有其他操作你的应用程序所需的东西。事实上，这更有可能保持您的代码的可伸缩性，因为您知道哪个结构去哪里！(但这只是我的看法)</p><h1 id="e377" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">3.使用你申报的所有东西</h1><p id="8e09" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">默认情况下，Rust的编译器会给出关于未使用变量的警告，所以如果你想通过代码编译而没有任何“非绿色”输出，你必须删除未使用的变量/结构/特征，除非你真的需要它们，只是为了扩展代码库并在以后使用它们，有一个宏告诉Rust编译器“我真的需要这个，不要给出警告。”。我知道Golang和C++也存在这种情况(通过添加一些编译器标志)，但一般来说，内置这种特性有助于保持代码整洁。我在许多编程语言中都缺少这种类型的特性。</p><p id="a568" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在经历了Rust中的“未使用…”警告后，我开始配置JavaScript的ESLinter，为未使用的变量给出一个错误，Python linter等也是如此。我知道你们中的一些人可能在Rust之前就这样做了，但对我个人来说，这是来自Rust的情况。</p><h1 id="623e" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">4.让人们能够读懂错误信息</h1><p id="9dca" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">当我第一次开始运行Rust编译器时，我最喜欢的就是错误信息！它们非常有帮助，非常有用，尤其是如果你来自C++，有时GCC编译器会给出无用的错误消息，使你的调试更加混乱。例如，此错误消息通过标记问题发生的确切位置，给出了问题的解决方案</p><pre class="mo mp mq mr gt ms ld mt mu aw mv bi"><span id="ebce" class="mw lm it ld b gy mx my l mz na">fn main() {<br/>    let s = String::from("hello");</span><span id="56b2" class="mw lm it ld b gy nb my l mz na">change(&amp;s);<br/>}</span><span id="2b8e" class="mw lm it ld b gy nb my l mz na">fn change(some_string: &amp;String) {<br/>    some_string.push_str(", world");<br/>}</span><span id="a023" class="mw lm it ld b gy nb my l mz na"># cargo build<br/>error[E0596]: cannot borrow immutable borrowed content `*some_string` as mutable<br/> --&gt; error.rs:8:5<br/>  |<br/>7 | fn change(some_string: &amp;String) {<br/>  |                        ------- use `&amp;mut String` here to make mutable<br/>8 |     some_string.push_str(", world");<br/>  |     ^^^^^^^^^^^ cannot borrow as mutable</span></pre><p id="7b8a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过使用rust compiler，我开始在应用程序中犯这种错误，这改变了我们开始处理团队内部问题的方式。</p><h1 id="9e1d" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">5.尽可能编写更高层次的抽象</h1><p id="6105" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">在许多语言中，更高层次的抽象意味着更低的性能，但Rust并非如此。事实上，你会访问他们的主页，他们首先谨慎的是“抽象的零成本”。他们为此做了大量的编译器优化，并使用非面向对象的原则来帮助设计零成本的抽象(以及宏声明)。</p><p id="17f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但当我在Rust之后用其他语言写代码时，默认情况下我会尝试更具表达力的抽象，因为这是拥有可伸缩和更可读代码库的关键。即使对于基本的数组操作，Rust也给出了<code class="fe la lb lc ld b">map, filter, zip, etc...</code>抽象来防止多行循环和迭代器声明。当然，这是在抽象内部完成的，但是它们是以更优化的方式完成的，这将在代码中实现。</p><pre class="mo mp mq mr gt ms ld mt mu aw mv bi"><span id="6564" class="mw lm it ld b gy mx my l mz na">// Calculate the intermediate sum of this segment:<br/>let result = data_segment<br/>            // iterate over the characters of our segment..<br/>            .chars()<br/>            // .. convert text-characters to their number value..<br/>            .map(|c| c.to_digit(10).expect("should be a digit"))<br/>            // .. and sum the resulting iterator of numbers<br/>            .sum();</span></pre><p id="7ab8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的Python、Go或JS代码中进行这种抽象，提供了更好的应用程序设计方式，新员工开始更快地学习代码，因为他们大多只是重用我们的抽象。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="9466" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这5点都是基于我写了6个月的Rust应用程序的个人经验。</p><p id="5927" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Rust对我和我们的团队来说并不是主要的编程语言，但我们从它身上学到了很多，尤其是如何用其他编程语言编写更高效、更可扩展的代码库。</p><p id="a2e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以，如果你是一个C++爱好者，认为花时间在Rust上是一件很糟糕的事情，我肯定你是对的，但是为什么不试一试，然后给出一个理由。我很想听听你的意见。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="654b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读！💥，给一个👏并分享这篇文章或让我知道你对这个话题的看法。</p></div></div>    
</body>
</html>