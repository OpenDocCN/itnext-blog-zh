<html>
<head>
<title>Write better React, compose multiple functional HoCs, Higher-Order Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更好的反应，组成多个功能hoc，高阶组件</h1>
<blockquote>原文：<a href="https://itnext.io/write-better-react-compose-multiple-functional-hocs-higher-order-components-442a11bd2e86?source=collection_archive---------0-----------------------#2022-05-30">https://itnext.io/write-better-react-compose-multiple-functional-hocs-higher-order-components-442a11bd2e86?source=collection_archive---------0-----------------------#2022-05-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ae78d14e7f227862cf0f9143d12d9def.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eKp6CeYY-krBEKhXLz6oFg.jpeg"/></div></div></figure><p id="fa38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/write-better-javascript-function-composition-with-pipe-and-compose-93cc39ab16ee">之前的一篇文章</a>中，我写了关于使用管道和组合链接函数的<strong class="ka ir">的概念。今天，我想通过提供一些场景来扩展这个主题，在这些场景中，我发现<strong class="ka ir">函数组合</strong>在前端开发人员的日常生活中变得非常方便，他们使用React <strong class="ka ir">以更具功能性的方式应用多个高阶组件！</strong></strong></p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="cea1" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是高阶函数</h1><p id="ce38" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">在深入研究高阶组件之前，您应该熟悉<strong class="ka ir">高阶函数</strong>的含义，我们可以将其描述为<strong class="ka ir">一个至少执行以下</strong>之一的函数:</p><ul class=""><li id="a69d" class="mh mi iq ka b kb kc kf kg kj mj kn mk kr ml kv mm mn mo mp bi translated"><strong class="ka ir">将一个或多个函数作为参数</strong> s</li><li id="884e" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated"><strong class="ka ir">返回一个函数作为其结果</strong></li></ul><p id="c3e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们以一个你可能已经熟悉的标准ES高阶函数为例:<strong class="ka ir"><em class="mv">array . prototype . map</em></strong>，它将一个函数作为参数，用作回调，并将其应用于数组的每个元素。一个简单的提醒:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="bb0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以编写一个定制的高阶函数:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="972e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很明显，这是一个非常简单的例子，但是高阶函数有很多应用，这种方法的好处是<strong class="ka ir">你可以重用提供不同运算函数的HoF，减少代码重复，有利于</strong><a class="ae kw" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"/></a><strong class="ka ir">的单一责任原则。</strong></p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="a1a1" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">带React的高阶组件</h1><p id="c228" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">高阶组件<strong class="ka ir">与高阶函数</strong>非常相似，下面是React文档中的定义:<strong class="ka ir">“具体来说，高阶组件是一个接受一个组件并返回一个新组件的函数。”</strong>。</p><p id="ae54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个简单的例子非常有用，让我们首先定义一个标准组件，稍后我们将把它包装成一个特设组件:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="1657" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设您希望这个组件是用某种信息增强的<strong class="ka ir"/><strong class="ka ir">，在这个非常简单的例子中，我们传递一个自定义属性，一个静态用户，在实际应用程序中，您希望以某种方式获取它:</strong></p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e285" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以用新创建的HoC来包装应用程序组件:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="0b4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">应用程序中由“withUser”特设包装的每个组件都将拥有currentUser属性</strong>。如果我们有一个非常复杂的逻辑，这可能是一个非常好的模式来<strong class="ka ir">避免代码重复</strong>。你可以在<strong class="ka ir"> Klarna知识库</strong>中看到很多这方面的真实例子:</p><p id="b12e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://github.com/klarna/higher-Order-components" rel="noopener ugc nofollow" target="_blank">https://github.com/klarna/higher-Order-components</a></p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="b307" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">构成多个hoc</h1><p id="a91f" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">如果我们希望<strong class="ka ir">一个组件被多个hoc</strong>包装会怎样？好了，这里我们有compose at the rescue(它们在我的<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/write-better-javascript-function-composition-with-pipe-and-compose-93cc39ab16ee">上一篇文章</a>中有深入的解释)。让我们创建另一个简单的特设:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="d36d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以将我们的两个HoC封装在一起(<a class="ae kw" href="https://ramdajs.com/docs/#compose" rel="noopener ugc nofollow" target="_blank">我们可以使用Ramda函数compose，而不是创建我们的自定义函数</a></p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="85f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我创建了一个代码沙箱，所以你可以玩代码:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nc nb l"/></div></figure><h1 id="e35f" class="le lf iq bd lg lh nd lj lk ll ne ln lo lp nf lr ls lt ng lv lw lx nh lz ma mb bi translated">概述</h1><p id="bc8c" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">高阶组件对于<strong class="ka ir">抽象逻辑</strong>真的很有用，比如你的大部分页面会有相同的布局，也许它们共享相同的元素；<strong class="ka ir">它们易于处理</strong>，<strong class="ka ir">它们使代码更具可读性</strong>和<strong class="ka ir">它们不会改变原始组件，这意味着它们是纯函数</strong>。</p><p id="68b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你已经来了，谢谢你的阅读，❤</p><p id="5c94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我们用非常简单的组件解释了一些复杂的概念，并分享了一个你可能会觉得有用的模式。 <br/> <em class="mv">一些参考资料深入到本文的主要话题:</em></p><ul class=""><li id="0997" class="mh mi iq ka b kb kc kf kg kj mj kn mk kr ml kv mm mn mo mp bi translated"><a class="ae kw" href="https://tommmyy.github.io/ramda-react-redux-patterns/pages/react-ramda.html#high-order-component-hoc" rel="noopener ugc nofollow" target="_blank">https://tommmyy . github . io/ramda-react-redux-patterns/pages/react-ramda . html # high-order-component-hoc</a></li><li id="6f40" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated"><a class="ae kw" href="https://it.reactjs.org/docs/higher-order-components.html#:%7E:text=A%20higher%2Dorder%20component%20(HOC,and%20returns%20a%20new%20component" rel="noopener ugc nofollow" target="_blank">https://it . react js . org/docs/higher-order-components . html #:~:text = A % 20 higher % 2d order % 20 component % 20(HOC，and % 20 returns % 20a % 20 new % 20 component</a>。</li><li id="be23" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated"><a class="ae kw" href="https://github.com/klarna/higher-Order-components" rel="noopener ugc nofollow" target="_blank">https://github.com/klarna/higher-Order-components</a></li></ul></div></div>    
</body>
</html>