<html>
<head>
<title>Abstracting away side-effects with Higher-Order Functions in PowerShell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用PowerShell中的高阶函数抽象出副作用</h1>
<blockquote>原文：<a href="https://itnext.io/abstracting-away-side-effects-with-higher-order-functions-in-powershell-10c4ae98a42b?source=collection_archive---------4-----------------------#2020-04-06">https://itnext.io/abstracting-away-side-effects-with-higher-order-functions-in-powershell-10c4ae98a42b?source=collection_archive---------4-----------------------#2020-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="80ef" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用功能抽象的更干净、更安全的PowerShell代码</h2></div><p id="08e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我通常带着对状态和副作用的病态厌恶来写PowerShell。实际上，这些不受欢迎的模式通常是不可避免的，尤其是在DevOps中。像<code class="fe lf lg lh li b">git</code>和编译器这样不可避免的CLI要求有状态外壳光标在CLI被调用之前移动到不同的目录；必须维护可变集合；集成测试和基础设施代码通常需要在云中提供临时资源——所有这些操作都会改变我们系统的状态，并随后将系统置于未知、难以管理的状态。</p><p id="5df6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们回顾了一些利用<a class="ae le" href="https://medium.com/swlh/functional-programming-in-powershell-876edde1aadb" rel="noopener"> <em class="lj">高阶函数</em> </a>从我们的脚本中抽象出副作用管理的例子。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/a9edbd5c276a4d852f23b4fed27a3e55.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/0*1_cwXpmFXKr9dpXj.jpg"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">保持无国籍，我的朋友。</figcaption></figure><h1 id="7cb6" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">调用间接目录</h1><h2 id="eff0" class="mo lx it bd ly mp mq dn mc mr ms dp mg kr mt mu mi kv mv mw mk kz mx my mm mz bi translated">问题是</h2><p id="7aed" class="pw-post-body-paragraph ki kj it kk b kl na ju kn ko nb jx kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">通常在DevOps中，您需要在特定的目录中运行命令。例如，<code class="fe lf lg lh li b">git</code>(与大多数PowerShell命令不同)不接受目录路径参数，并期望您在执行之前<code class="fe lf lg lh li b">cd</code>到正确的目录。类似的，应用建设CLIs有<code class="fe lf lg lh li b">npm</code>、<code class="fe lf lg lh li b">docker</code>、<code class="fe lf lg lh li b">dotnet</code>等。，通常在根目录下运行效果最好。</p><p id="a1d4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们总是可以将<code class="fe lf lg lh li b">Push-Location</code>或<code class="fe lf lg lh li b">Set-Location</code>放入我们需要的目录中，但是当脚本完成时，我们总是要记得返回。更糟糕的是，我们需要添加样板<code class="fe lf lg lh li b">try</code> / <code class="fe lf lg lh li b">finally</code>语句，以防脚本失败——否则，运行脚本的人会意外地发现他们的终端位于与预期不同的位置。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="a89a" class="mo lx it bd ly mp mq dn mc mr ms dp mg kr mt mu mi kv mv mw mk kz mx my mm mz bi translated">解决方案</h2><p id="b005" class="pw-post-body-paragraph ki kj it kk b kl na ju kn ko nb jx kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">我们可以编写一个名为<code class="fe lf lg lh li b">Invoke-InDirectory</code>的<a class="ae le" href="https://medium.com/swlh/functional-programming-in-powershell-876edde1aadb" rel="noopener">高阶函数</a>来抽象出调用给定目录中的命令所需的样板文件，而不会产生副作用(如果命令出错，终端将位于意外的位置)。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="d45d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以用<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/declarative-devops-30788ddd43cd">声明性地编写<em class="lj"> what </em> </a> <em class="lj"> </em>(调用目录中的命令)而不是<em class="lj"> how </em> ( <code class="fe lf lg lh li b">try</code> / <code class="fe lf lg lh li b">finally</code>语句和<code class="fe lf lg lh li b">Push-Location</code> / <code class="fe lf lg lh li b">Pop-Location</code>调用)。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="93be" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">在上下文中调用</h1><h2 id="5eb2" class="mo lx it bd ly mp mq dn mc mr ms dp mg kr mt mu mi kv mv mw mk kz mx my mm mz bi translated">问题是</h2><p id="13e6" class="pw-post-body-paragraph ki kj it kk b kl na ju kn ko nb jx kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">在大型PowerShell脚本中，脚本输出可能会变得一塌糊涂。几乎不可能准确地说出哪一行代码发出了给定的日志行，或者哪一行抛出了错误。</p><h2 id="69ee" class="mo lx it bd ly mp mq dn mc mr ms dp mg kr mt mu mi kv mv mw mk kz mx my mm mz bi translated">解决方案</h2><p id="7192" class="pw-post-body-paragraph ki kj it kk b kl na ju kn ko nb jx kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">我们可以实现一个上下文记录器，它维护一个上下文字符串堆栈，并在脚本发出输出时将它们记录下来，这样您就总能确切地知道是哪个上下文块抛出了错误。为此，我通常使用<code class="fe lf lg lh li b"><a class="ae le" href="https://github.com/microsoft/Requirements" rel="noopener ugc nofollow" target="_blank">Requirements</a></code>框架；然而，我们可以在单个函数中实现相同的模式，维护一个堆栈来跟踪我们在程序中的位置。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="74fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们可以将一致的日志记录添加到我们的脚本中，例如本例中的React应用程序构建脚本。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="449c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有记录的输出都将以时间戳和上下文堆栈为前缀，您可以很容易地将它们与代码中的<code class="fe lf lg lh li b">Invoke-InContext</code>调用树关联起来。</p><h1 id="5a12" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">使用<insert your="" resource="">调用</insert></h1><h2 id="8860" class="mo lx it bd ly mp mq dn mc mr ms dp mg kr mt mu mi kv mv mw mk kz mx my mm mz bi translated">问题是</h2><p id="f9ef" class="pw-post-body-paragraph ki kj it kk b kl na ju kn ko nb jx kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">在部署服务时，您通常想要分配临时存储空间来存放工件，但是在部署之后，应该释放这个空间以节省成本。实现提供和删除存储的代码可能很繁琐，如果您的脚本不处理故障，您的存储可以保持分配。</p><p id="608e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个问题的一般情况在DevOps中经常出现。例如，集成测试管道可能希望在运行集成测试之前构建昂贵的生产基础设施资源，然后在测试完成后清除这些资源。</p><h2 id="6008" class="mo lx it bd ly mp mq dn mc mr ms dp mg kr mt mu mi kv mv mw mk kz mx my mm mz bi translated">解决方案</h2><p id="f583" class="pw-post-body-paragraph ki kj it kk b kl na ju kn ko nb jx kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">我们不像前面两个例子那样使用高阶函数模式来维护堆栈，而是在scriptblock执行完毕后使用我们的模式来运行清理代码。在这个例子中，我们创建了一个函数，它自动向用户提供一个新的存储上下文。用户不需要了解如何创建存储帐户和管理清理，这都是抽象的。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="3289" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">后续步骤</h1><p id="986b" class="pw-post-body-paragraph ki kj it kk b kl na ju kn ko nb jx kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">既然您已经看到了简化代码的高阶抽象的实际例子，那么请深入理解PowerShell 中的<a class="ae le" href="https://medium.com/swlh/functional-programming-in-powershell-876edde1aadb" rel="noopener">函数式编程，以便在您的代码库中更深入地应用这些概念。你也可以利用现有的框架，比如依赖于这种模式的<code class="fe lf lg lh li b"><a class="ae le" href="https://github.com/microsoft/Requirements" rel="noopener ugc nofollow" target="_blank">Requirements</a></code>和Pester。</a></p></div></div>    
</body>
</html>