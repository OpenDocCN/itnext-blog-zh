<html>
<head>
<title>An Exercise in Shortening Ids</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缩短身份证的练习</h1>
<blockquote>原文：<a href="https://itnext.io/an-exercise-in-shortening-ids-902b723fdd91?source=collection_archive---------2-----------------------#2022-08-03">https://itnext.io/an-exercise-in-shortening-ids-902b723fdd91?source=collection_archive---------2-----------------------#2022-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/608b01d0151d8b0cfad9020749e8a2eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ccxCO7uV0J0GFBcM7KgjA.jpeg"/></div></div></figure><p id="1a17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Web平台上，我们经常处理数字和二进制标签或标识符(id ),我们经常在URIs使用它们作为API端点或文件名。在这个过程中出现了几个问题:</p><ol class=""><li id="62c1" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">顺序id简化了id发现，并可能导致被称为“不安全的直接对象引用”<a class="ae lf" href="#1226" rel="noopener ugc nofollow"> </a>(如果缺少访问控制)的漏洞。它们还会泄露它们识别的数据的大小和速度，从而导致商业情报泄露。</li><li id="dda0" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">像UUID或MongoDB的ObjectId这样的随机ID更好。但是，它们比用于存储的顺序id大2到4倍，并且它们的默认十六进制编码对于URI来说不是最佳的，即，导致比必要的字符串更长。</li></ol><p id="8981" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">公开id的一个流行的解决方案是将一个单独的随机id作为“公共”id存储在一个“私有”序列id旁边。这种方法有两个主要问题:</p><ol class=""><li id="3c78" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">我们必须存储和索引一个大得多的额外字段。</li><li id="8df6" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">就架构而言，它通过将特定于应用程序的关注点与我们的领域实体相混合，违反了关注点的分离。</li></ol><p id="c281" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们能够以这样一种方式对现有的id进行编码:</p><ol class=""><li id="dc3f" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">混淆视听，使它们变得相当难以预测；</li><li id="b448" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">在URI允许的情况下尽量缩短；</li><li id="26c6" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">比其他选择做得更快？</li></ol><p id="820f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是由<a class="ae lf" href="https://github.com/zandaqo/objectid64" rel="noopener ugc nofollow" target="_blank">object 64</a>实施的一个此类解决方案的简要概述。</p><h1 id="9475" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">Base64</h1><p id="4aa2" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">我们对URI兼容字符串的要求将我们限制在以下66个字符的集合中<a class="ae lf" href="#d157" rel="noopener ugc nofollow">:<code class="fe mo mp mq mr b">A-Z a-z 0-9 - _ . ~</code>。自然，我们会将数字向下舍入到最接近的2的幂，剩下64个字符。</a></p><p id="e7cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用现成的Base64编码器不会混淆太多。然而，我们可以用可配置的字母表编写自己的编码器，其中改变字符的排列产生不同的编码:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="02df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应该注意的是，这不是加密:它只是混淆和缩短id足以劝阻业余爱好者。当需要真正隐藏ids时，使用加密，但是要注意它对性能的影响。</p><h1 id="4710" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">钻头旋转</h1><p id="8f94" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">为了用Base64编码数字id(即数字)，我们可以使用带除法和模运算的经典基本转换算法。然而，由于我们的基数是2的幂，我们可以通过使用按位移位代替除法和按位and代替模<a class="ae lf" href="#ce93" rel="noopener ugc nofollow"> </a>来大大加快实现速度(在合成基准测试中编码速度快2到5倍):</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e373" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，我们可以通过使用JavaScript现在内置的<code class="fe mo mp mq mr b">bigint</code>类型来处理64位顺序id。</p><h1 id="94b7" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">UUID起酥油</h1><p id="8c38" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在野外使用的UUID和ObjectId的十六进制编码对于我们的URI编码用例来说是次优的，我们可以使用效率提高25%的base64<a class="ae lf" href="#a235" rel="noopener ugc nofollow">⁴</a>(即产生更短的字符串)。虽然我们可以使用上面的Base转换算法从Base16转换到Base64，但我们可以通过创建一个查找表来做得更好。</p><p id="955a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，Base16使用编码4位的16个字符(2⁴ = 16)，而Base64使用编码6位的64个字符(2⁶ = 64)。因此，三个十六进制字符可以编码12位，与两个Base64字符相同。由于十六进制三元组的数量限制为16 = 64 = 4096，我们可以创建一个合理的查找表，将每个三元组链接到一对等效的Base64字符，并使用它在不进行任何计算的情况下从一个碱基转换到另一个碱基。</p><p id="ca3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过从十六进制转换为Base64，我们将ObjectId从24个字符缩短为16个字符，将UUID从36个字符缩短为22个字符:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5c5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而且比其他选择更快，尽管是以牺牲一点内存来换取速度。</p><p id="6d29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，如果我们得到二进制形式的id，我们可以完全放弃十六进制编码，直接编码成Base64:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="e028" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，一个简单的使ids URL友好的任务引导我们考虑架构，深入学习编码和基本转换，使用位旋转技巧和记忆化。最后，你对id的选择不应该被它们在URIs的样子所左右，甚至不应该被它们暴露的安全问题所左右——你总是可以编码(或加密)成你喜欢的形状。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="1226" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">【<strong class="ka ir">1</strong>】<a class="ae lf" href="https://cheatsheetseries.owasp.org/cheatsheets/Insecure_Direct_Object_Reference_Prevention_Cheat_Sheet.html" rel="noopener ugc nofollow" target="_blank">不安全直接物体参考预防小抄</a></p><p id="d157" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[ <strong class="ka ir"> 2 </strong> ] <a class="ae lf" href="https://datatracker.ietf.org/doc/html/rfc4648" rel="noopener ugc nofollow" target="_blank"> RFC 4648 </a></p><p id="ce93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[ <strong class="ka ir"> 3 </strong> ] <a class="ae lf" href="http://graphics.stanford.edu/~seander/bithacks.html#ModulusDivisionEasy" rel="noopener ugc nofollow" target="_blank">钻头旋转齿</a></p><p id="a235" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[ <strong class="ka ir"> 4 </strong> ] <a class="ae lf" href="https://en.wikipedia.org/wiki/Binary-to-text_encoding#Encoding_plain_text" rel="noopener ugc nofollow" target="_blank">二进制到文本编码</a></p></div></div>    
</body>
</html>