<html>
<head>
<title>Building Kubernetes Aggregated API Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建Kubernetes聚合API服务器</h1>
<blockquote>原文：<a href="https://itnext.io/our-journey-in-building-a-kubernetes-aggregated-api-server-29a4f9c1de22?source=collection_archive---------3-----------------------#2018-06-16">https://itnext.io/our-journey-in-building-a-kubernetes-aggregated-api-server-29a4f9c1de22?source=collection_archive---------3-----------------------#2018-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ce3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes有两个主要的扩展机制——自定义资源定义(CRD)和聚合API服务器。一个聚合API服务器是一个REST API服务器，它运行在集群上，可以使用kubectl访问。它将客户端身份验证委托给主API服务器。</p><p id="5868" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们分享我们在构建一个聚合API服务器来解决一个特定问题的实验。</p><p id="7d45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">问题:</em></p><p id="89d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们正在开发一个<a class="ae km" href="https://github.com/cloud-ark/kubeprovenance" rel="noopener ugc nofollow" target="_blank">发现工具</a>，帮助发现关于Kubernetes集群的动态信息。这种信息的一个例子是Kubernetes对象的动态组合。在Kubernetes中，有由其他资源组成的顶级资源。例如，一个部署由一个复制集组成，而复制集又由一个或多个pod组成。今天，对于给定父资源，找出整个子资源树并不简单。</p><p id="b79f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在构建这个工具时，我们的主要设计约束是不应该要求用户使用新的CLI工具来查找这些信息。他们应该可以直接使用kubectl。例如，用户应该可以使用以下命令来获取部署类型的所有对象的合成信息:</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="a4b2" class="kw kx iq ks b gy ky kz l la lb">kubectl<br/>get --raw /apis/../../namespaces/default/deployments/*/compositions</span></pre><p id="46a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这方面，我们认为我们的问题类似于Kubernetes 中的<a class="ae km" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/instrumentation/metrics-server.md" rel="noopener ugc nofollow" target="_blank"> metrics API服务器。特别是，查询到“../deployments/*/compositions”看起来类似于在metrics API服务器中使用定制指标。</a></p><p id="0ebd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们决定构建一个类似于<a class="ae km" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/instrumentation/custom-metrics-api.md" rel="noopener ugc nofollow" target="_blank">定制度量</a>服务器的东西。</p><p id="0403" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">达成解决方案:</em></p><p id="92af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">方法1: </em>我们从<a class="ae km" href="https://github.com/kubernetes-incubator/apiserver-builder" rel="noopener ugc nofollow" target="_blank"> apiserver-builder存储库</a>开始。它有大量的文档，并很好地概述了主API服务器和聚合API服务器之间的身份验证和授权是如何工作的。它还支持创建子资源，这正是我们所寻找的。不幸的是，使用这个库只能在您第一次创建的类型上创建子资源。如果我们想要创建“compositions”子资源，我们必须首先为它的父资源创建新的种类——在上面的例子中是“deployments”。</p><p id="52fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这不是我们想要的！我们想在现有的种类上添加子资源。所以使用apiserver-builder是行不通的。</p><p id="a53f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">方法2: </em>接下来，我们决定尝试一下<a class="ae km" href="https://github.com/kubernetes-incubator/custom-metrics-apiserver" rel="noopener ugc nofollow" target="_blank"> custom-metrics-apiserver </a>，因为它似乎使用子资源来定义现有Kubernetes种类上的自定义指标。不幸的是，它<a class="ae km" href="https://github.com/kubernetes-incubator/custom-metrics-apiserver/issues/10" rel="noopener ugc nofollow" target="_blank">没有足够的文档</a>。我们仍然试着使用它，但是那没有得到太多。</p><p id="98b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">方法3: </em>在前两种方法失败后，我们决定尝试<a class="ae km" href="https://github.com/kubernetes/sample-apiserver" rel="noopener ugc nofollow" target="_blank"> sample-apiserver </a>。它像记载的那样工作。然而，对于我们的用例来说，它有两个问题。首先，它只演示了如何添加将由聚合API服务器处理的新的顶级资源/种类。这不是我们感兴趣的。其次，它没有展示如何添加定制的子资源。不过，这个服务器有一个好处。它在工作！我们现在有了可以作为起点的东西。剩下的工作(我们也是这样认为的)就是弄清楚如何转换sample-apiserver，以便它能够支持现有Kubernetes种类上的“组合”子资源。</p><p id="37c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">方法4: </em>我们首先想到的是从sample-apiserver开始，然后一点一点地将custom-metrics-apiserver移植到其中。我们也是从这条路开始的。但是很快我们遇到了一个问题。原来sample-apiserver和custom-metrics-apiserver使用了两个Kubernetes子包的不同版本(apimachinery和apiserver ),并且这些版本是不兼容的。我们试图通过使用别名导入名称导入一个包来避免这个问题。然而，这不起作用，因为别名导入包中的导入仍然指向与别名包不兼容的非别名子包名称。深入思考这个问题，我们意识到除非Kubernetes为其包实现Golang即将发布的<a class="ae km" href="https://blog.golang.org/versioning-proposal" rel="noopener ugc nofollow" target="_blank">语义导入版本</a>，否则不可能在一个项目中使用同一个包的两个不兼容版本。</p><p id="7617" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">解决方案:</em>于是我们又回到了谈判桌前。感觉像是从custom-metrics-apiserver中得到一些我们可以使用的东西。事实证明确实有！为了注册定制的子资源端点，它使用go-restful库来创建REST路由，然后<a class="ae km" href="https://github.com/kubernetes-incubator/custom-metrics-apiserver/blob/102f5e88afde0d31116b5498e0cf939da91cb6ba/pkg/apiserver/cmapis.go#L59" rel="noopener ugc nofollow" target="_blank">将它们添加到GenericAPIServer </a>中定义的GoRestfulContainer。那是我们的线索。</p><p id="13ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那时，我们想出完整的解决方案只是时间问题。你可以在我们的<a class="ae km" href="https://github.com/cloud-ark/kubeprovenance" rel="noopener ugc nofollow" target="_blank"> kubediscovery github资源库</a>中找到它。使用它来创建您自己的带有自定义子资源的聚合API服务器。更好的是，使用它来找出集群中各种Kubernetes的动态组成。</p><p id="aace" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae km" href="https://cloudark.io/" rel="noopener ugc nofollow" target="_blank"> www.cloudark.io </a></p></div></div>    
</body>
</html>