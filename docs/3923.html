<html>
<head>
<title>Azure Event Hubs multi-protocol support</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure事件中心多协议支持</h1>
<blockquote>原文：<a href="https://itnext.io/azure-event-hubs-multi-protocol-support-d0e41834510b?source=collection_archive---------8-----------------------#2020-03-25">https://itnext.io/azure-event-hubs-multi-protocol-support-d0e41834510b?source=collection_archive---------8-----------------------#2020-03-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9fb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://docs.microsoft.com/azure/event-hubs/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure Event Hubs </a>是一个完全托管的平台即服务(PaaS ),作为一个数据流平台和事件接收服务，能够每秒接收和处理数百万个事件。客户端应用程序可以利用以下协议与服务交互:AMQP、<a class="ae kl" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Kafka </a>和HTTPS。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/13ba752521e23cb7306877065ee9064a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CE6tmjiTPm-vmiS3jkDxzA.png"/></div></div></figure><p id="7654" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇博文将简要介绍活动中心的多协议支持，以及它的重要性。第二部分将给出一个简单而实用的例子来演示这一点</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="ac7a" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">支持的协议</h1><p id="ed46" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">让我们很快过一遍！</p><h2 id="451e" class="mi lg iq bd lh mj mk dn ll ml mm dp lp jy mn mo lt kc mp mq lx kg mr ms mb mt bi translated">AMQP</h2><p id="f8d8" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated"><a class="ae kl" href="https://www.amqp.org/" rel="noopener ugc nofollow" target="_blank">高级消息队列协议(AMQP) 1.0 </a>是Azure事件中心的主要协议。这是一个<code class="fe mu mv mw mx b">OASIS</code>标准，它定义了在系统之间异步、安全、可靠地传输消息的协议。要使用Azure Event Hubs，你可以使用任何实现AMQP协议的特定语言客户端软件开发套件，包括<code class="fe mu mv mw mx b">.NET</code>、<code class="fe mu mv mw mx b">Java</code>、<code class="fe mu mv mw mx b">Python</code>、<code class="fe mu mv mw mx b">Go</code>、<code class="fe mu mv mw mx b">Nodejs</code>和<code class="fe mu mv mw mx b">C</code></p><blockquote class="my mz na"><p id="0c97" class="jn jo nb jp b jq jr js jt ju jv jw jx nc jz ka kb nd kd ke kf ne kh ki kj kk ij bi translated"><em class="iq">这些都是SDK</em><a class="ae kl" href="https://github.com/Azure/azure-event-hubs" rel="noopener ugc nofollow" target="_blank"><em class="iq">在GitHub上开源</em> </a></p></blockquote><p id="eed8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要深入了解AMQP协议如何在活动中心使用<a class="ae kl" href="https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-protocol-guide?toc=https://docs.microsoft.com/en-us/azure/event-hubs/TOC.json&amp;bc=https://docs.microsoft.com/en-us/azure/bread/toc.json&amp;WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">，请参考文档</a></p><h2 id="2e98" class="mi lg iq bd lh mj mk dn ll ml mm dp lp jy mn mo lt kc mp mq lx kg mr ms mb mt bi translated">阿帕奇卡夫卡</h2><p id="659e" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">Event Hubs提供了一个Kafka兼容的端点，您现有的基于Kafka的应用程序可以使用它作为运行您自己的Kafka集群的替代方法。这消除了设置Kafka和Zookeeper集群以及持续基础设施维护的需要。事件中心和Kafka在概念上是相同的，即Kafka集群对应于事件中心名称空间，Kafka主题相当于事件中心等。详情<a class="ae kl" href="https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview?WT.mc_id=medium-blog-abhishgu#kafka-and-event-hub-conceptual-mapping" rel="noopener ugc nofollow" target="_blank">请参考文档</a></p><p id="ca68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在任何编程语言中利用现有的Kafka客户端。我鼓励您查看GitHub 上的<a class="ae kl" href="https://github.com/Azure/azure-event-hubs-for-kafka" rel="noopener ugc nofollow" target="_blank">快速入门和教程，它们展示了在<code class="fe mu mv mw mx b">Java</code>、<code class="fe mu mv mw mx b">Node</code>、<code class="fe mu mv mw mx b">dotnet</code>、<code class="fe mu mv mw mx b">Python</code>、<code class="fe mu mv mw mx b">Go</code>等地Kafka客户端中使用事件中心的情况。</a></p><h2 id="c152" class="mi lg iq bd lh mj mk dn ll ml mm dp lp jy mn mo lt kc mp mq lx kg mr ms mb mt bi translated">HTTPS</h2><p id="2b5b" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">Event hubs还提供了一个可以被任何HTTP客户端利用的REST API。一些操作包括:</p><ul class=""><li id="8ecb" class="nf ng iq jp b jq jr ju jv jy nh kc ni kg nj kk nk nl nm nn bi translated"><a class="ae kl" href="https://docs.microsoft.com/rest/api/eventhub/send-event?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">发送数据</a></li><li id="f914" class="nf ng iq jp b jq no ju np jy nq kc nr kg ns kk nk nl nm nn bi translated"><a class="ae kl" href="https://docs.microsoft.com/rest/api/eventhub/send-partition-event?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">向特定分区发送数据</a></li><li id="d7a3" class="nf ng iq jp b jq no ju np jy nq kc nr kg ns kk nk nl nm nn bi translated"><a class="ae kl" href="https://docs.microsoft.com/rest/api/eventhub/send-batch-events?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">批量发送数据</a></li></ul></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="bdda" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">价值主张</h1><p id="54e4" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">这种多协议功能提供了很大的灵活性，您可以将它们结合起来用于特定的用例。这里有几个例子:</p><ul class=""><li id="b092" class="nf ng iq jp b jq jr ju jv jy nh kc ni kg nj kk nk nl nm nn bi translated">编写Kafka endpoint并使用基于<a class="ae kl" href="https://docs.microsoft.com/azure/azure-functions/functions-bindings-event-hubs?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">触发器的集成</a>构建一个具有<a class="ae kl" href="https://docs.microsoft.com/azure/azure-functions/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure功能</a>的无服务器消费者(这个场景将在后续的博客文章中介绍)</li><li id="5733" class="nf ng iq jp b jq no ju np jy nq kc nr kg ns kk nk nl nm nn bi translated">使用<code class="fe mu mv mw mx b">HTTPS</code>写，使用<code class="fe mu mv mw mx b">Kafka</code>读——例如，您的前端应用程序可以使用HTTPs发送点击流事件，您可以使用Kafka客户端处理这些事件</li><li id="0187" class="nf ng iq jp b jq no ju np jy nq kc nr kg ns kk nk nl nm nn bi translated">使用事件中心SDK(基于AMQP)发送事件，然后使用Kafka协议读取</li></ul><p id="b945" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然可以混合和匹配协议，那么生产端和消费端的应用程序如何理解发送和接收的消息呢？这里已经介绍了一些很棒的<a class="ae kl" href="https://docs.microsoft.com/azure/event-hubs/event-hubs-exchange-events-different-protocols?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">例子和最佳实践</a>，但这里是Tl；DR — <em class="nb">这是因为所有的协议客户端(卡夫卡、AMQP、HTTPS)都将消息视为原始字节</em>。这些字节使用特定的协议通过网络发送，即使使用不同的协议，消费者端也会收到相同的字节。如果生产或消费应用程序使用特定的格式，例如HTTP协议的JSON和基于Java的Kafka消费者客户端中的Java POJO，则由客户端应用程序将字节转换为它想要使用的格式。</p><p id="4f32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我所承诺的，下一篇博文将会讨论使用事件中心和Azure函数的无服务器处理。敬请期待！</p></div></div>    
</body>
</html>