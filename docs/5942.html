<html>
<head>
<title>Observing gRPC-based Microservices on Amazon EKS running Istio</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">观察亚马逊EKS上运行Istio的基于gRPC的微服务</h1>
<blockquote>原文：<a href="https://itnext.io/observing-grpc-based-microservices-on-amazon-eks-running-istio-77ba90dd8cc0?source=collection_archive---------0-----------------------#2021-07-06">https://itnext.io/observing-grpc-based-microservices-on-amazon-eks-running-istio-77ba90dd8cc0?source=collection_archive---------0-----------------------#2021-07-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bd81" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Jaeger、Zipkin、Prometheus、Grafana和Kiali在运行Istio服务网格的亚马逊EKS上观察基于gRPC的Kubernetes应用程序</h2></div><p id="76fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在之前的两篇文章中，<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-based-microservice-observability-with-istio-service-mesh-part-1-of-2-19084d13a866">基于Kubernetes的带有Istio服务网格的微服务可观察性</a>，我们探索了一套流行的开源可观察性工具，可以轻松地与Istio服务网格集成。这些工具包括用于分布式事务监控的<strong class="kk iu"> Jaeger </strong>和<strong class="kk iu"> Zipkin </strong>，用于指标收集和警报的<strong class="kk iu"> Prometheus </strong>，用于指标查询、可视化和警报的<strong class="kk iu"> Grafana </strong>，以及用于Istio整体可观察性和管理的<strong class="kk iu"> Kiali </strong>。我们完善了工具集，添加了用于日志处理和聚合的<strong class="kk iu"> Fluent Bit </strong>到<strong class="kk iu">Amazon cloud watch Container Insights</strong>。我们使用这些工具观察了一个部署在<strong class="kk iu">亚马逊弹性Kubernetes服务(亚马逊EKS) </strong>集群上的分布式、基于微服务的RESTful应用程序。运行在EKS上的应用平台使用亚马逊文档数据库作为持久数据存储，使用亚马逊MQ T21来交换消息。</p><div class="lf lg gp gr lh li"><a rel="noopener  ugc nofollow" target="_blank" href="/kubernetes-based-microservice-observability-with-istio-service-mesh-part-1-of-2-19084d13a866"><div class="lj ab fo"><div class="lk ab ll cl cj lm"><h2 class="bd iu gy z fp ln fr fs lo fu fw is bi translated">基于Kubernetes的Istio服务网格的微服务可观测性:第1部分，共2部分</h2><div class="lp l"><h3 class="bd b gy z fp ln fr fs lo fu fw dk translated">用Istio在亚马逊EKS上用Jaeger，Prometheus，Grafana，Kiali，Fluent Bit观察一个分布式系统…</h3></div><div class="lq l"><p class="bd b dl z fp ln fr fs lo fu fw dk translated">itnext.io</p></div></div><div class="lr l"><div class="ls l lt lu lv lr lw lx li"/></div></div></a></div><p id="74e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们将研究这些相同的可观察性工具来监控另一组基于Go的微服务，这些微服务使用<a class="ae le" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a>(又名<em class="ly"> Protobuf </em>)通过<a class="ae le" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> gRPC </a> (gRPC远程过程调用)和<a class="ae le" href="https://en.wikipedia.org/wiki/HTTP/2" rel="noopener ugc nofollow" target="_blank"> HTTP/2 </a>进行客户端-服务器通信，而不是更常见的RESTful JSON over HTTP。我们将了解Kubernetes、Istio和observability工具如何与gRPC无缝协作，就像它们在亚马逊EKS网站上与JSON over HTTP的协作一样。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/e53a5bab57af24bea3e7beefb965bc96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YpgnVG2WnmkBprCVLnb-7A.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">Kiali管理控制台展示了基于gRPC的参考应用平台</figcaption></figure><h1 id="15f3" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">技术</h1><h2 id="1156" class="ng mp it bd mq nh ni dn mu nj nk dp my kr nl nm na kv nn no nc kz np nq ne nr bi translated">gRPC</h2><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/3794eab7c3ae17fd8adfd9a2150b8ddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*Uo85WpCf-UQnyjauTcvIQA.png"/></div></figure><p id="4513" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据<a class="ae le" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> gRPC项目</a>，gRPC是一个现代开源的高性能<a class="ae le" href="https://en.wikipedia.org/wiki/Remote_procedure_call" rel="noopener ugc nofollow" target="_blank">远程过程调用</a> (RPC)框架，可以在任何环境下运行。借助对负载平衡、跟踪、运行状况检查和身份验证的可插拔支持，它可以高效地连接数据中心内和数据中心间的服务。gRPC也适用于分布式计算的最后一英里，将设备、移动应用程序和浏览器连接到后端服务。</p><p id="1835" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">gRPC最初是由谷歌创建的，十多年来，谷歌一直使用一个名为Stubby的通用RPC基础设施来连接其数据中心内和数据中心间运行的大量微服务。2015年3月，谷歌决定打造Stubby的下一个版本，并将其开源。gRPC现在在Google之外的许多组织中使用，包括Square、网飞、CoreOS、Docker、CockroachDB、Cisco和Juniper Networks。gRPC目前<a class="ae le" href="https://grpc.io/docs/#official-support" rel="noopener ugc nofollow" target="_blank">支持十多种语言</a>，包括C#、C++、Dart、Go、Java、Kotlin、Node、Objective-C、PHP、Python和Ruby。</p><p id="7f5c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据婉如·费南多发布的被广泛引用的2019年测试,“gRPC在接收数据时大约比REST快7倍&amp;在发送该特定有效载荷的数据时大约比REST快10倍。这主要是由于协议缓冲区的紧密打包和gRPC对HTTP/2的使用。</p><h2 id="2cd4" class="ng mp it bd mq nh ni dn mu nj nk dp my kr nl nm na kv nn no nc kz np nq ne nr bi translated">协议缓冲区</h2><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/d7fec7c34a1933e1e7f8b814199f8c88.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/format:webp/1*FJBdFOye93S1jHgGuC43Vw.png"/></div></figure><p id="02b4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用gRPC，您可以使用<a class="ae le" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a>(又名<em class="ly"> Protobuf </em>)来定义您的服务，这是一个强大的二进制序列化工具集和语言。根据谷歌的说法，协议缓冲区是谷歌的语言中立、平台中立、可扩展的序列化结构化数据的机制——想想XML，但更小、更快、更简单。Google之前的文档声称协议缓冲区比XML小3到10倍，快20到100倍。</p><p id="1be7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦您定义了您的<a class="ae le" href="https://developers.google.com/protocol-buffers/docs/overview#simple" rel="noopener ugc nofollow" target="_blank">消息</a>，您就可以在您的<code class="fe nu nv nw nx b">.proto</code>文件上运行针对您的应用程序语言的协议缓冲编译器来生成数据访问类。在<code class="fe nu nv nw nx b">proto3</code>语言版本中，协议缓冲区目前支持Java、Python、Objective-C、C++、Dart、Go、Ruby和C#中的生成代码，未来还会支持更多语言。在这篇文章中，我们已经为<a class="ae le" href="https://github.com/protocolbuffers/protobuf-go" rel="noopener ugc nofollow" target="_blank"> Go </a>编译了protobufs。你可以在Google的<a class="ae le" href="https://developers.google.com/protocol-buffers/docs/encoding" rel="noopener ugc nofollow" target="_blank">开发者门户</a>上阅读更多关于Protobuf的二进制wire格式。</p><h1 id="c0cd" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">参考应用平台</h1><p id="df42" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">为了演示可观察性工具的使用，我们将在AWS上为亚马逊EKS部署一个参考应用程序平台。开发应用程序平台是为了展示不同的Kubernetes平台，如EKS、GKE、AKS，以及服务网格、API管理、可观察性、CI/CD、DevOps和混沌工程等概念。该平台包括八个基于Go的微服务的后端，一般标记为服务A-服务H，一个基于Angular 12 TypeScript的前端UI，一个基于Go的gRPC网关反向代理，四个MongoDB数据库和一个RabbitMQ消息队列。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/4b55840eff21834568e18353928f0c44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aXNzBd8uZxcsu7Mz67IioQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">参考应用平台的基于角度的用户界面</figcaption></figure><p id="cff4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">参考应用程序平台旨在生成基于gRPC的同步服务到服务IPC(进程间通信)、基于异步TCP的服务到队列到服务通信以及基于TCP的服务到数据库通信。比如服务A调用服务B和服务C；服务B调用服务D和服务E；服务D向RabbitMQ队列发送一条消息，服务F使用这条消息并将其写入MongoDB，依此类推。当应用程序被部署到运行Istio服务网格的Kubernetes集群时，可以使用observability工具来观察平台的分布式服务通信。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi oe"><img src="../Images/a8d58aa1f79bacfefdabfa812ac2e4b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o1FO2HdaejlJD6vRqfehUg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">基于gRPC的参考应用平台的高层架构</figcaption></figure><h1 id="dc3f" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">转换为gRPC和协议缓冲区</h1><p id="8baa" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">在这篇文章中，八个Go微服务被修改为使用带有HTTP/2上的<a class="ae le" href="https://developers.google.com/protocol-buffers/" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a>的<a class="ae le" href="https://grpc.io" rel="noopener ugc nofollow" target="_blank"> gRPC </a>，而不是HTTP上的JSON。具体来说，服务使用版本3(又名<em class="ly"> proto3 </em>)的协议缓冲区。使用gRPC，gRPC客户端调用gRPC服务器。该平台的一些服务是gRPC服务器，另一些是gRPC客户端，还有一些同时充当客户端和服务器。</p><h2 id="a768" class="ng mp it bd mq nh ni dn mu nj nk dp my kr nl nm na kv nn no nc kz np nq ne nr bi translated">gRPC网关</h2><p id="89c3" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">在上面修改后的平台架构图中，注意添加了<a class="ae le" href="https://github.com/grpc-ecosystem/grpc-gateway" rel="noopener ugc nofollow" target="_blank"> gRPC网关反向代理</a>，它取代了API边缘的服务A。该代理将RESTful HTTP API转换为gRPC，位于基于Angular的Web UI和服务a之间。为了演示起见，假设大多数API消费者需要RESTful JSON over HTTP API，我们已经为该平台添加了一个gRPC网关反向代理。gRPC网关代理基于HTTP的客户机上的JSON和基于gRPC的微服务之间的通信。gRPC网关有助于同时提供gRPC和RESTful风格的API。</p><p id="90af" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">来自<a class="ae le" href="https://github.com/grpc-ecosystem/grpc-gateway" rel="noopener ugc nofollow" target="_blank"> grpc-gateway </a> GitHub项目网站的图表展示了反向代理是如何工作的。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi of"><img src="../Images/97313d801cdad266d285381a40ccf487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XlkS_1BS99dYzEw0_B6Elg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated"><em class="og">图礼貌:</em><a class="ae le" href="https://github.com/grpc-ecosystem/grpc-gateway" rel="noopener ugc nofollow" target="_blank"><em class="og">https://github.com/grpc-ecosystem/grpc-gateway</em></a></figcaption></figure><h2 id="a0f8" class="ng mp it bd mq nh ni dn mu nj nk dp my kr nl nm na kv nn no nc kz np nq ne nr bi translated">gRPC网关的替代方案</h2><p id="f14c" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">作为gRPC网关反向代理的替代方案，我们可以将基于TypeScript的Angular UI客户端转换为通过gRPC和protobufs进行通信，并直接与服务a进行通信。实现这一点的一个选项是<a class="ae le" href="https://github.com/grpc/grpc-web" rel="noopener ugc nofollow" target="_blank"> gRPC Web </a>，这是一个针对浏览器客户端的gRPC JavaScript实现。gRPC Web客户端通过一个特殊的代理连接到gRPC服务，默认情况下是Envoy。该项目的路线图包括gRPC Web在特定于语言的Web框架中得到支持的计划，这些语言包括Python、Java和Node。</p><h1 id="db1b" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">示范</h1><p id="0930" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">为了继续这篇文章的演示，请回顾上一篇文章第一部分中详细介绍的安装说明，使用Istio服务网格部署和配置亚马逊EKS集群、Istio、亚马逊MQ和DocumentDB。为了加速将修改后的基于gRPC的平台部署到<code class="fe nu nv nw nx b">dev</code>名称空间，我在项目中包含了一个舵图<code class="fe nu nv nw nx b">ref-app-grpc</code>。使用这个图表，您可以忽略前一篇文章中提到的将资源部署到<code class="fe nu nv nw nx b">dev</code>名称空间的任何说明。参见图表的<a class="ae le" href="https://github.com/garystafford/k8s-istio-observe-backend/blob/2021-istio/helm/ref-app-grpc/README.md" rel="noopener ugc nofollow" target="_blank">自述文件</a>获取进一步说明。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/41e1bb2c5af476cec89653d9740262b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kMSPCqAkOuOEEAGzwcXfBg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">从<a class="ae le" href="https://argoproj.github.io/argo-cd/" rel="noopener ugc nofollow" target="_blank"> Argo CD </a>看部署的基于gRPC的参考应用平台</figcaption></figure><h2 id="5af4" class="ng mp it bd mq nh ni dn mu nj nk dp my kr nl nm na kv nn no nc kz np nq ne nr bi translated">源代码</h2><p id="e7dc" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">基于gRPC的微服务源代码、Kubernetes资源和Helm chart位于<code class="fe nu nv nw nx b">2021-istio</code>分支的<a class="ae le" href="https://github.com/garystafford/k8s-istio-observe-backend" rel="noopener ugc nofollow" target="_blank">k8s-istio-observe-back end</a>项目存储库中。</p><div class="lf lg gp gr lh li"><a href="https://github.com/garystafford/k8s-istio-observe-backend" rel="noopener  ugc nofollow" target="_blank"><div class="lj ab fo"><div class="lk ab ll cl cj lm"><h2 class="bd iu gy z fp ln fr fs lo fu fw is bi translated">garystafter/k8s-istio-observe-back end</h2><div class="lp l"><h3 class="bd b gy z fp ln fr fs lo fu fw dk translated">两篇博文的源代码，基于Kubernetes的带有Istio服务网格的微服务可观察性。请参见…</h3></div><div class="lq l"><p class="bd b dl z fp ln fr fs lo fu fw dk translated">github.com</p></div></div><div class="lr l"><div class="oh l lt lu lv lr lw lx li"/></div></div></a></div><p id="b0c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个项目存储库是您在这个演示中需要的唯一源代码。</p><pre class="ma mb mc md gt oi nx oj ok aw ol bi"><span id="1bda" class="ng mp it nx b gy om on l oo op">git clone --branch 2021-istio --single-branch \<br/>  <a class="ae le" href="https://github.com/garystafford/k8s-istio-observe-backend.git" rel="noopener ugc nofollow" target="_blank">https://github.com/garystafford/k8s-istio-observe-backend.git</a></span></pre><p id="c968" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可选地，基于角度的web客户端源代码位于新的<code class="fe nu nv nw nx b">2021-grpc</code>分支上的<a class="ae le" href="https://github.com/garystafford/k8s-istio-observe-frontend/tree/2021-grpc" rel="noopener ugc nofollow" target="_blank">k8s-istio-observe-frontend</a>存储库中。源protobuf <code class="fe nu nv nw nx b">.proto</code>文件和buf编译的protobuf文件位于<a class="ae le" href="https://github.com/garystafford/pb-greeting" rel="noopener ugc nofollow" target="_blank"> pb-greeting </a>和<a class="ae le" href="https://github.com/garystafford/protobuf" rel="noopener ugc nofollow" target="_blank"> protobuf </a>项目存储库中。对于本文的演示，您不需要克隆任何这些项目。</p><div class="lf lg gp gr lh li"><a href="https://github.com/garystafford/k8s-istio-observe-frontend/tree/2021-grpc" rel="noopener  ugc nofollow" target="_blank"><div class="lj ab fo"><div class="lk ab ll cl cj lm"><h2 class="bd iu gy z fp ln fr fs lo fu fw is bi translated">garystafter/k8s-istio-observe-frontend</h2><div class="lp l"><h3 class="bd b gy z fp ln fr fs lo fu fw dk translated">两篇博文的源代码，基于Kubernetes的带有Istio服务网格的微服务可观察性。</h3></div><div class="lq l"><p class="bd b dl z fp ln fr fs lo fu fw dk translated">github.com</p></div></div><div class="lr l"><div class="oq l lt lu lv lr lw lx li"/></div></div></a></div><div class="lf lg gp gr lh li"><a href="https://github.com/garystafford/pb-greeting" rel="noopener  ugc nofollow" target="_blank"><div class="lj ab fo"><div class="lk ab ll cl cj lm"><h2 class="bd iu gy z fp ln fr fs lo fu fw is bi translated">garystafter/Pb-问候语</h2><div class="lp l"><h3 class="bd b gy z fp ln fr fs lo fu fw dk translated">参考应用平台的协议缓冲区(Protobuf)文件，在Istio observability演示博客文章中使用。</h3></div><div class="lq l"><p class="bd b dl z fp ln fr fs lo fu fw dk translated">github.com</p></div></div><div class="lr l"><div class="or l lt lu lv lr lw lx li"/></div></div></a></div><div class="lf lg gp gr lh li"><a href="https://github.com/garystafford/protobuf" rel="noopener  ugc nofollow" target="_blank"><div class="lj ab fo"><div class="lk ab ll cl cj lm"><h2 class="bd iu gy z fp ln fr fs lo fu fw is bi translated">garystafter/proto buf</h2><div class="lp l"><h3 class="bd b gy z fp ln fr fs lo fu fw dk translated">Protobuf主库。</h3></div><div class="lq l"><p class="bd b dl z fp ln fr fs lo fu fw dk translated">github.com</p></div></div><div class="lr l"><div class="os l lt lu lv lr lw lx li"/></div></div></a></div><p id="5045" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">服务、UI和反向代理的所有Docker映像都来自于<a class="ae le" href="https://hub.docker.com/search?q=%22garystafford&amp;type=image&amp;sort=updated_at&amp;order=desc" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/e0e33783cc1e74e80b9e60de884fad65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LefOdrAK9R_yJrfzWwKnlA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">这篇文章的所有图片都位于<a class="ae le" href="https://hub.docker.com/search?q=%22garystafford&amp;type=image&amp;sort=updated_at&amp;order=desc" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a></figcaption></figure><h1 id="f608" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">代码更改</h1><p id="d54a" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">虽然这篇文章不是专门讨论为gRPC和protobuf编写Go的，但是为了更好地理解这些技术的可观测性需求和功能，与之前的基于HTTP的JSON服务相比，回顾一下代码变化是有帮助的。</p><h2 id="c6b0" class="ng mp it bd mq nh ni dn mu nj nk dp my kr nl nm na kv nn no nc kz np nq ne nr bi translated">微服务</h2><p id="f7e9" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">首先，将下面显示的<a class="ae le" href="https://github.com/garystafford/k8s-istio-observe-backend/blob/2021-istio/services/protobuf-grpc/service-a-grpc/main.go" rel="noopener ugc nofollow" target="_blank">服务A </a>的修订源代码与前一篇文章中的<a class="ae le" href="https://github.com/garystafford/k8s-istio-observe-backend/blob/2021-istio/services/json-rest/service-a/main.go" rel="noopener ugc nofollow" target="_blank">原始代码</a>进行比较。该服务的代码几乎完全重写。例如，请注意服务A的以下代码更改，它与其他后端服务同义:</p><ul class=""><li id="42e3" class="ot ou it kk b kl km ko kp kr ov kv ow kz ox ld oy oz pa pb bi translated">导入<a class="ae le" href="https://github.com/garystafford/protobuf/tree/main/greeting/v3" rel="noopener ugc nofollow" target="_blank"> v3 greeting protobuf </a>包；</li><li id="d77c" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld oy oz pa pb bi translated">本地问候语结构被替换为<code class="fe nu nv nw nx b">pb.Greeting</code>结构；</li><li id="9ef3" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld oy oz pa pb bi translated">所有服务现在都托管在端口<code class="fe nu nv nw nx b">50051</code>上；</li><li id="3050" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld oy oz pa pb bi translated">HTTP服务器和所有API资源处理函数都被删除；</li><li id="47e9" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld oy oz pa pb bi translated">用于分布式跟踪的标头已从HTTP请求对象移动到在gRPC <code class="fe nu nv nw nx b">Context</code>类型中传递的元数据；</li><li id="762b" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld oy oz pa pb bi translated">服务A既是gRPC客户端又是服务器，由gRPC网关反向代理调用；</li><li id="e012" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld oy oz pa pb bi translated">主要的<code class="fe nu nv nw nx b">GreetingHandler</code>函数被protobuf包的<code class="fe nu nv nw nx b">Greeting</code>函数取代；</li><li id="08f7" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld oy oz pa pb bi translated">gRPC客户端，比如服务A，使用<code class="fe nu nv nw nx b">CallGrpcService</code>函数调用gRPC服务器；</li><li id="a5ae" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld oy oz pa pb bi translated">CORS处理从服务中卸载到Istio</li><li id="9f41" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld oy oz pa pb bi translated">记录方法基本没有变化；</li></ul><p id="e3d7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">修订的基于gRPC的服务A的源代码:</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="ph pi l"/></div></figure><h2 id="a6f2" class="ng mp it bd mq nh ni dn mu nj nk dp my kr nl nm na kv nn no nc kz np nq ne nr bi translated">问候协议缓冲区</h2><p id="78f4" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">下面显示的是问候v3协议缓冲区<code class="fe nu nv nw nx b">.proto</code>文件。最初在基于RESTful JSON的服务中被定义为结构的<code class="fe nu nv nw nx b">Greeting</code>中的字段基本上保持不变，然而，我们现在有了一个<a class="ae le" href="https://developers.google.com/protocol-buffers/docs/overview" rel="noopener ugc nofollow" target="_blank">消息</a>——包含一组类型化字段的集合。<code class="fe nu nv nw nx b">GreetingRequest</code>由单个<code class="fe nu nv nw nx b">Greeting</code>消息组成，而<code class="fe nu nv nw nx b">GreetingResponse</code>消息由多个<code class="fe nu nv nw nx b">repeated</code> ) <code class="fe nu nv nw nx b">Greeting</code>消息组成。服务在其请求中传递一个<code class="fe nu nv nw nx b">Greeting</code>消息，并接收一个由一个或多个消息组成的数组作为响应。</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="bade" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">protobuf是用流行的基于Go的协议编译器工具<a class="ae le" href="https://buf.build/" rel="noopener ugc nofollow" target="_blank"> Buf </a>编译的。使用Buf，生成四个文件:Go、Go gRPC、gRPC Gateway和Swagger (OpenAPI v2)。</p><pre class="ma mb mc md gt oi nx oj ok aw ol bi"><span id="9de7" class="ng mp it nx b gy om on l oo op">.<br/>├── greeting.pb.go<br/>├── greeting.pb.gw.go<br/>├── greeting.swagger.json<br/>└── greeting_grpc.pb.go</span></pre><p id="cfce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用两个文件配置Buf，<code class="fe nu nv nw nx b">buf.yaml</code>:</p><pre class="ma mb mc md gt oi nx oj ok aw ol bi"><span id="20b0" class="ng mp it nx b gy om on l oo op">version: v1beta1<br/>name: buf.build/garystafford/pb-greeting<br/>deps:<br/>  - buf.build/beta/googleapis<br/>  - buf.build/grpc-ecosystem/grpc-gateway<br/>build:<br/>  roots:<br/>    - proto<br/>lint:<br/>  use:<br/>    - DEFAULT<br/>breaking:<br/>  use:<br/>    - FILE</span></pre><p id="2437" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有，还有<code class="fe nu nv nw nx b">buf.gen.yaml</code>:</p><pre class="ma mb mc md gt oi nx oj ok aw ol bi"><span id="d7eb" class="ng mp it nx b gy om on l oo op">version: v1beta1<br/>plugins:<br/>  - name: go<br/>    out: ../protobuf<br/>    opt:<br/>      - paths=source_relative<br/>  - name: go-grpc<br/>    out: ../protobuf<br/>    opt:<br/>      - paths=source_relative<br/>  - name: grpc-gateway<br/>    out: ../protobuf<br/>    opt:<br/>      - paths=source_relative<br/>      - generate_unbound_methods=true<br/>  - name: openapiv2<br/>    out: ../protobuf<br/>    opt:<br/>      - logtostderr=true</span></pre><p id="eabf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编译后的protobuf代码包含在GitHub上的<a class="ae le" href="https://github.com/garystafford/protobuf/tree/main/greeting/v3" rel="noopener ugc nofollow" target="_blank"> protobuf </a>项目中，v3版本导入到各个微服务和反向代理中。下面是<code class="fe nu nv nw nx b">greeting.pb.go</code>编译的Go文件的一个片段。</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="ecf9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用Swagger，我们可以查看greeting protocol buffers的单一RESTful API资源，该资源通过HTTP GET方法公开。您可以使用基于Docker版本的<a class="ae le" href="https://hub.docker.com/r/swaggerapi/swagger-ui/" rel="noopener ugc nofollow" target="_blank"> Swagger UI </a>来查看<code class="fe nu nv nw nx b">protoc</code>生成的<a class="ae le" href="https://github.com/garystafford/protobuf/blob/main/greeting/v3/greeting.swagger.json" rel="noopener ugc nofollow" target="_blank"> swagger定义</a>。</p><pre class="ma mb mc md gt oi nx oj ok aw ol bi"><span id="b1c5" class="ng mp it nx b gy om on l oo op">docker run -p 8080:8080 -d --name swagger-ui \<br/>  -e SWAGGER_JSON=/tmp/greeting/v3/greeting.swagger.json \<br/>  -v ${GOAPTH}/src/protobuf:/tmp swaggerapi/swagger-ui</span></pre><p id="1fc0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Angular UI向<code class="fe nu nv nw nx b">/api/greeting</code>资源发出一个HTTP GET请求，该请求被转换成gRPC并代理给服务A，由<code class="fe nu nv nw nx b">Greeting</code>函数处理。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/1c47c02d2d0270d6c29f6f327c48eee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VnVH0GClYqL78AAmFW3zyg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">问候协议的大摇大摆的UI视图</figcaption></figure><h2 id="1a60" class="ng mp it bd mq nh ni dn mu nj nk dp my kr nl nm na kv nn no nc kz np nq ne nr bi translated">gRPC网关反向代理</h2><p id="c9ab" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">如前所述，<a class="ae le" href="https://github.com/grpc-ecosystem/grpc-gateway" rel="noopener ugc nofollow" target="_blank"> gRPC网关</a>反向代理是新的，它将RESTful HTTP API翻译成gRPC。在下面的代码示例中，请注意以下代码功能:</p><ol class=""><li id="67ca" class="ot ou it kk b kl km ko kp kr ov kv ow kz ox ld pj oz pa pb bi translated">导入<a class="ae le" href="https://github.com/garystafford/protobuf/tree/main/greeting/v3" rel="noopener ugc nofollow" target="_blank"> v3 greeting protobuf </a>包；</li><li id="69bf" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld pj oz pa pb bi translated"><code class="fe nu nv nw nx b">ServeMux</code>，一个请求复用器，将<code class="fe nu nv nw nx b">http</code>请求匹配到模式，并调用相应的处理程序；</li><li id="d13e" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld pj oz pa pb bi translated"><code class="fe nu nv nw nx b">RegisterGreetingServiceHandlerFromEndpoint</code>注册服务<code class="fe nu nv nw nx b">GreetingService</code>到<code class="fe nu nv nw nx b">mux</code>的<code class="fe nu nv nw nx b">http</code>处理程序。处理程序将请求转发给gRPC端点；</li><li id="a90c" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld pj oz pa pb bi translated"><code class="fe nu nv nw nx b">x-b3</code>用于分布式跟踪的请求头从传入的HTTP请求中收集，并传播到gRPC <code class="fe nu nv nw nx b">Context</code>类型的上游服务；</li></ol><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="ph pi l"/></div></figure><h1 id="84fe" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">Istio VirtualService和CORS</h1><p id="0b18" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">对于上一篇文章中的RESTful服务，CORS由服务A处理。服务A允许UI向后端API的域发出跨源请求。由于gRPC网关不直接支持跨来源资源共享(CORS)策略，我们已经使用反向代理的<code class="fe nu nv nw nx b">VirtualService</code>资源的<code class="fe nu nv nw nx b"><a class="ae le" href="https://istio.io/latest/docs/reference/config/networking/virtual-service/#CorsPolicy" rel="noopener ugc nofollow" target="_blank">CorsPolicy</a></code>配置将CORS责任卸载给Istio。转移这一职责使得CORS作为YAML的配置和掌舵图的一部分更容易管理。请参见下面的第20–28行。</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="ph pi l"/></div></figure><h1 id="f819" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">支柱一:原木</h1><p id="68ef" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">借用Jay Kreps在LinkedIn工程博客上的一句话，日志是一个只追加的、完全有序的记录序列，按时间排序。记录的排序定义了“时间”的概念，因为左边的条目被定义为比右边的条目更老。日志是过去发生的事件的历史记录。日志几乎和计算机一样历史悠久，是许多分布式数据系统和实时应用程序架构的核心。</p><h2 id="0064" class="ng mp it bd mq nh ni dn mu nj nk dp my kr nl nm na kv nn no nc kz np nq ne nr bi translated">基于Go的微服务日志记录</h2><p id="9158" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">有效的日志记录策略始于您记录什么、何时记录以及如何记录。作为平台日志策略的一部分，八个基于Go的微服务使用了<a class="ae le" href="https://github.com/sirupsen/logrus" rel="noopener ugc nofollow" target="_blank"> Logrus </a>，这是一个流行的Go结构化日志程序，于2014年首次发布。该平台的服务还实现了Banzai Cloud的<a class="ae le" href="https://github.com/banzaicloud/logrus-runtime-formatter" rel="noopener ugc nofollow" target="_blank"> logrus-runtime-formatter </a>。这两个日志包让我们能够更好地控制您记录的内容、记录的时间以及记录服务信息的方式。包的<a class="ae le" href="https://github.com/banzaicloud/logrus-runtime-formatter#usage" rel="noopener ugc nofollow" target="_blank">推荐配置</a>是最小的。Logrus的<code class="fe nu nv nw nx b">JSONFormatter</code>为第三方系统提供了简单的解析，并将附加的上下文数据字段注入到日志条目中。</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="d218" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与Go的简单日志包<a class="ae le" href="https://golang.org/pkg/log/" rel="noopener ugc nofollow" target="_blank"> log </a>相比，Logrus提供了几个优势。例如，日志条目不仅用于致命错误，也不应该在生产环境中输出所有详细日志条目。Logrus能够记录七个级别的日志:跟踪、调试、信息、警告、错误、致命和紧急。平台微服务的日志级别可以在运行时使用环境变量进行更改。</p><p id="8a91" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Banzai Cloud的<a class="ae le" href="https://github.com/banzaicloud/logrus-runtime-formatter" rel="noopener ugc nofollow" target="_blank"> logrus-runtime-formatter </a>自动用运行时和堆栈信息标记日志消息，包括函数名和行号——在故障排除时非常有用。在Banzai Cloud(现在是思科的一部分)格式化程序上有一个很好的帖子，<a class="ae le" href="https://banzaicloud.com/blog/runtime-logging/" rel="noopener ugc nofollow" target="_blank">Golang runtime Logrus Formatter</a>。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi pk"><img src="../Images/a5456f9f956ad806b04263501c681bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6sllqkuVdsiiaCE9yLMhjw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">从Amazon CloudWatch Insights查看服务A日志条目</figcaption></figure><p id="1941" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2020年，<a class="ae le" href="https://github.com/sirupsen/logrus" rel="noopener ugc nofollow" target="_blank"> Logus </a>进入维护模式。作者Simon Eskildsen(Shopify的首席工程师)表示，他们不会推出新功能。这并不意味着Logrus已经死了。Logrus拥有超过18，000颗GitHub星，将继续维护其安全性、错误修复和性能。作者表示，现在存在许多Logus的奇妙替代品，如<a class="ae le" href="https://github.com/rs/zerolog" rel="noopener ugc nofollow" target="_blank"> Zerolog </a>、<a class="ae le" href="https://github.com/uber-go/zap" rel="noopener ugc nofollow" target="_blank"> Zap </a>和<a class="ae le" href="https://github.com/apex/log" rel="noopener ugc nofollow" target="_blank"> Apex </a>。</p><h2 id="c15e" class="ng mp it bd mq nh ni dn mu nj nk dp my kr nl nm na kv nn no nc kz np nq ne nr bi translated">客户端角度UI日志记录</h2><p id="614f" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">同样，我使用<a class="ae le" href="https://www.npmjs.com/package/ngx-logger" rel="noopener ugc nofollow" target="_blank"> NGX Logger </a>增强了Angular UI的日志记录。NGX Logger是angular的一个简单的日志模块(<em class="ly">目前支持Angular 6+ </em>)。它允许“漂亮地打印”到控制台，并允许将日志消息发布到服务器端日志记录的URL。对于本演示，UI将只记录到web浏览器的控制台。与Logrus类似，NGX Logger支持多个日志级别:跟踪、调试、信息、警告、错误、致命和关闭。然而，NGX Logger不仅仅输出消息，还允许我们将格式正确的日志条目输出到浏览器的控制台。</p><p id="caa2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">日志输出的级别配置为取决于环境、生产或非生产。下面是Chrome中Angular UI的日志输出示例。因为UI的Docker映像是用生产配置构建的，所以日志级别被设置为<code class="fe nu nv nw nx b">INFO</code>。您不希望将详细日志输出中的潜在敏感信息暴露给生产中的最终用户。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/bcb10a2bad224f9dbb35c5ab669241bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w7y6hbakadGGSrbF308u5A.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">来自平台的Angular UI的客户端日志</figcaption></figure><p id="baf9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过向<code class="fe nu nv nw nx b">app.module.ts</code>文件添加以下三元运算符来控制日志记录级别。</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="ph pi l"/></div></figure><h2 id="6503" class="ng mp it bd mq nh ni dn mu nj nk dp my kr nl nm na kv nn no nc kz np nq ne nr bi translated">平台日志</h2><p id="0f48" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">基于在第一部分中构建、配置和部署的平台，您现在可以从多个来源访问日志。</p><ol class=""><li id="82c3" class="ot ou it kk b kl km ko kp kr ov kv ow kz ox ld pj oz pa pb bi translated">Amazon document db:Amazon cloud watch审计和Profiler日志；</li><li id="2349" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld pj oz pa pb bi translated">亚马逊MQ:亚马逊CloudWatch日志；</li><li id="f831" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld pj oz pa pb bi translated">亚马逊EKS: API服务器、审计、认证器、控制器管理器、调度器CloudWatch日志；</li><li id="03a7" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld pj oz pa pb bi translated">Kubernetes仪表板:个人EKS Pod和副本集日志；</li><li id="0c93" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld pj oz pa pb bi translated">Kiali:单个EKS豆荚和集装箱原木；</li><li id="baaa" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld pj oz pa pb bi translated">流畅位:EKS性能、主机、数据面板、应用CloudWatch日志；</li></ol><h2 id="91a6" class="ng mp it bd mq nh ni dn mu nj nk dp my kr nl nm na kv nn no nc kz np nq ne nr bi translated">流畅位</h2><p id="97d1" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">根据AWS最近的一篇博客文章，<a class="ae le" href="https://aws.amazon.com/blogs/containers/fluent-bit-integration-in-cloudwatch-container-insights-for-eks/" rel="noopener ugc nofollow" target="_blank">Fluent Bit Integration in CloudWatch Container Insights for EKS</a>，<a class="ae le" href="https://fluentbit.io/" rel="noopener ugc nofollow" target="_blank"> Fluent Bit </a>是一个开源的多平台日志处理器和转发器，允许您从不同的来源收集数据和日志，并将其统一发送到不同的目的地，包括cloud watch日志。Fluent Bit还完全兼容Docker和Kubernetes环境。使用新推出的Fluent Bit <code class="fe nu nv nw nx b">DaemonSet</code>，您可以将容器日志从您的EKS集群发送到CloudWatch logs进行日志存储和分析。</p><p id="9fe8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行Fluent Bit，EKS集群的性能、主机、数据平面和应用程序日志也将在Amazon CloudWatch中提供。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi pk"><img src="../Images/5b549e547dffcd24b5434858d310aed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bFrecWAN86ImRyJVt6k42w.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">来自演示的EKS集群的亚马逊云观察日志组</figcaption></figure><p id="daa1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在应用程序日志组中，您可以访问每个参考应用程序组件的单独日志流。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi pk"><img src="../Images/bf5d5ecc576a42d8e2f55250e8c4578d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5zjNx2n2r5ElW-a3DLXNSw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">来自应用程序日志组的Amazon CloudWatch日志流</figcaption></figure><p id="4b4f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在每个CloudWatch日志流中，您可以查看单个日志条目。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/68998066764ba98ff2f6ee0d62daa6b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nqYm-6GFqXKXiX_RhqldlQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">服务A的Amazon CloudWatch日志流</figcaption></figure><p id="6ba8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AnalyzingLogData.html" rel="noopener ugc nofollow" target="_blank"> CloudWatch Logs Insights </a>使您能够在亚马逊CloudWatch日志中交互式搜索和分析您的日志数据。您可以执行查询来帮助您更高效地响应操作问题。如果出现问题，您可以使用CloudWatch Logs Insights来确定潜在的原因并验证部署的修复。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/59a32052337dd2c4cd3be95c39d58277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UdcFzF37kGQ_mFYkmwAJ6A.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">Amazon CloudWatch日志洞察—在服务F的日志中发现的最新错误</figcaption></figure><p id="ed20" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">CloudWatch Logs Insights支持<a class="ae le" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html" rel="noopener ugc nofollow" target="_blank"> CloudWatch Logs Insights查询语法</a>，这是一种可以用来对日志组执行查询的查询语言。每个查询可以包含一个或多个查询命令，用Unix样式的管道字符(|)分隔。例如:</p><pre class="ma mb mc md gt oi nx oj ok aw ol bi"><span id="896c" class="ng mp it nx b gy om on l oo op">fields <a class="ae le" href="http://twitter.com/timestamp" rel="noopener ugc nofollow" target="_blank">@timestamp</a>, <a class="ae le" href="http://twitter.com/message" rel="noopener ugc nofollow" target="_blank">@message</a><br/>| filter kubernetes.container_name = "service-f" <br/>  and <a class="ae le" href="http://twitter.com/message" rel="noopener ugc nofollow" target="_blank">@message</a> like "error"<br/>| sort <a class="ae le" href="http://twitter.com/timestamp" rel="noopener ugc nofollow" target="_blank">@timestamp</a> desc<br/>| limit 20</span></pre><h1 id="bc72" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">支柱二:衡量标准</h1><p id="77ef" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">对于指标，我们将检查<a class="ae le" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/ContainerInsights.html" rel="noopener ugc nofollow" target="_blank">cloud watch Container Insights</a>、<a class="ae le" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank"> Prometheus </a>和<a class="ae le" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank"> Grafana </a>。Prometheus和Grafana是您作为Istio部署的一部分安装的业界领先的工具。</p><h1 id="7fcb" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">普罗米修斯</h1><p id="a509" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated"><a class="ae le" href="https://github.com/prometheus" rel="noopener ugc nofollow" target="_blank"> Prometheus </a>是一个开源系统监控和警报工具包，最初是在大约2012年<a class="ae le" href="https://soundcloud.com/" rel="noopener ugc nofollow" target="_blank"> SoundCloud </a>开发的。普罗米修斯于2016年加入<a class="ae le" href="https://cncf.io/" rel="noopener ugc nofollow" target="_blank">云原生计算基金会</a> (CNCF)，作为继<a class="ae le" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>之后主持的第二个项目。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/aa1c2668e8cdfddccdae9a0fed0d5df5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iW7ptiNBNl6mYE5S1je4wQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">负载测试期间容器内存使用情况的普罗米修斯图</figcaption></figure><p id="30ca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据<a class="ae le" href="https://istio.io/latest/docs/ops/integrations/prometheus/" rel="noopener ugc nofollow" target="_blank"> Istio </a>的说法，Prometheus插件是一个Prometheus服务器，预配置为收集Istio端点以收集指标。您可以将Prometheus与Istio一起使用，来记录跟踪Istio和服务网格中的应用程序的健康状况的指标。你可以使用像<a class="ae le" href="https://istio.io/latest/docs/ops/integrations/grafana/" rel="noopener ugc nofollow" target="_blank">格拉夫纳</a>和<a class="ae le" href="https://istio.io/latest/docs/tasks/observability/kiali/" rel="noopener ugc nofollow" target="_blank">基阿利</a>这样的工具来可视化度量。Istio Prometheus插件仅用于演示，并未针对性能或安全性进行调整。</p><p id="c7df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nu nv nw nx b"><a class="ae le" href="https://istio.io/latest/docs/reference/commands/istioctl/#istioctl-dashboard" rel="noopener ugc nofollow" target="_blank">istioctl dashboard</a></code>命令提供了对所有Istio web用户界面的访问。运行EKS集群，安装Istio，部署参考应用平台，从终端使用<code class="fe nu nv nw nx b"><a class="ae le" href="https://istio.io/latest/docs/reference/commands/istioctl/#istioctl-dashboard-prometheus" rel="noopener ugc nofollow" target="_blank">istioctl dashboard prometheus</a></code>命令访问Prometheus。您必须从终端登录AWS才能成功连接到Prometheus。如果你没有登录AWS，你会经常看到以下错误:<code class="fe nu nv nw nx b">Error: not able to locate &lt;tool_name&gt; pod: Unauthorized</code>。由于我们使用的是Istio插件的非生产演示版本，因此访问Prometheus不需要认证和授权。</p><p id="bf64" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据<a class="ae le" href="https://prometheus.io/docs/prometheus/latest/querying/basics/" rel="noopener ugc nofollow" target="_blank">普罗米修斯</a>的说法，用户使用一种叫做<a class="ae le" href="https://prometheus.io/docs/prometheus/latest/querying/basics/" rel="noopener ugc nofollow" target="_blank"> PromQL </a>(普罗米修斯查询语言)的函数式查询语言实时选择和汇总时序数据。表达式的结果既可以显示为图形，在Prometheus的表达式浏览器中以表格数据的形式查看，也可以由外部系统通过Prometheus的<a class="ae le" href="https://prometheus.io/docs/prometheus/latest/querying/api/" rel="noopener ugc nofollow" target="_blank"> HTTP API </a>使用。表达式浏览器包括一个下拉菜单，其中包含所有可用的指标作为构建查询的起点。下面是一些PromQL的例子，它们是在撰写本文时开发的。</p><pre class="ma mb mc md gt oi nx oj ok aw ol bi"><span id="53fa" class="ng mp it nx b gy om on l oo op">istio_agent_go_info{kubernetes_namespace="dev"}</span><span id="2ecf" class="ng mp it nx b gy pl on l oo op">istio_build{kubernetes_namespace="dev"}</span><span id="63e5" class="ng mp it nx b gy pl on l oo op">up{alpha_eksctl_io_cluster_name="istio-observe-demo", job="kubernetes-nodes"}</span><span id="5001" class="ng mp it nx b gy pl on l oo op">sum by (pod) (rate(container_network_transmit_packets_total{stack="reference-app",namespace="dev",pod=~"service-.*"}[5m]))</span><span id="ceb5" class="ng mp it nx b gy pl on l oo op">sum by (instance) (istio_requests_total{source_app="istio-ingressgateway",connection_security_policy="mutual_tls",response_code="200"})</span><span id="1ddd" class="ng mp it nx b gy pl on l oo op">sum by (response_code) (istio_requests_total{source_app="istio-ingressgateway",connection_security_policy="mutual_tls",response_code!~"200|0"})</span></pre><h2 id="e6f3" class="ng mp it bd mq nh ni dn mu nj nk dp my kr nl nm na kv nn no nc kz np nq ne nr bi translated">普罗米修斯蜜蜂</h2><p id="3ab3" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">Prometheus既有一个<a class="ae le" href="https://prometheus.io/docs/prometheus/latest/querying/api/#http-api" rel="noopener ugc nofollow" target="_blank"> HTTP API </a>又有一个<a class="ae le" href="https://prometheus.io/docs/prometheus/latest/management_api/" rel="noopener ugc nofollow" target="_blank">管理API </a>。除了Prometheus UI之外，还有许多有用的端点，可在<code class="fe nu nv nw nx b"><a class="ae le" href="http://localhost:9090/graph" rel="noopener ugc nofollow" target="_blank">http://localhost:9090/graph</a></code>获得。例如，列出所有命令行配置标志的Prometheus HTTP API端点在<code class="fe nu nv nw nx b"><a class="ae le" href="http://localhost:9090/api/v1/status/flags" rel="noopener ugc nofollow" target="_blank">http://localhost:9090/api/v1/status/flags</a></code>可用。列出所有可用普罗米修斯指标的端点可在<code class="fe nu nv nw nx b"><a class="ae le" href="http://localhost:9090/api/v1/label/__name__/values" rel="noopener ugc nofollow" target="_blank">http://localhost:9090/api/v1/label/__name__/values</a></code>获得；本演示中超过951项指标。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi pk"><img src="../Images/08bbf34e5c4f59294cb6fbd92fae767f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0b1bt95jm7eWYpFxuE3xhg.png"/></div></div></figure><p id="e6c3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe nu nv nw nx b"><a class="ae le" href="http://localhost:9090/metrics" rel="noopener ugc nofollow" target="_blank">http://localhost:9090/metrics</a></code>可以找到Prometheus端点，它列出了许多可用的指标，用<code class="fe nu nv nw nx b">HELP</code>和<code class="fe nu nv nw nx b">TYPE</code>来解释它们的功能。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi pk"><img src="../Images/b8618b31248f8d4361bec9e873e2c5dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6wMqJxWHVKIbCK0eBPNvqw.png"/></div></div></figure><h2 id="202e" class="ng mp it bd mq nh ni dn mu nj nk dp my kr nl nm na kv nn no nc kz np nq ne nr bi translated">了解指标</h2><p id="e448" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">除了这些端点，Istio导出并通过Prometheus提供的标准服务水平指标可在<a class="ae le" href="https://istio.io/latest/docs/reference/config/metrics/#metrics" rel="noopener ugc nofollow" target="_blank"> Istio标准指标</a>文档中找到。在他们的GitHub网站上的cAdvisor <a class="ae le" href="https://github.com/google/cadvisor/blob/master/docs/storage/prometheus.md#prometheus-container-metrics" rel="noopener ugc nofollow" target="_blank"> README </a>中也可以找到Prometheus中许多可用指标的解释。正如在这篇<a class="ae le" href="https://aws.amazon.com/blogs/containers/monitoring-amazon-eks-on-aws-fargate-using-prometheus-and-grafana/" rel="noopener ugc nofollow" target="_blank"> AWS博客文章</a>中提到的，cAdvisor指标也可以通过命令行使用以下命令获得:</p><pre class="ma mb mc md gt oi nx oj ok aw ol bi"><span id="dd3d" class="ng mp it nx b gy om on l oo op">export NODE=$(kubectl get nodes | sed -n '2 p' | awk {'print $1'})</span><span id="ec1c" class="ng mp it nx b gy pl on l oo op">kubectl get --raw "/api/v1/nodes/${NODE}/proxy/metrics/cadvisor"</span></pre><h2 id="8d7c" class="ng mp it bd mq nh ni dn mu nj nk dp my kr nl nm na kv nn no nc kz np nq ne nr bi translated">观察指标</h2><p id="b8ed" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">下面是部署到EKS的后端微服务容器的示例图。graph PromQL表达式返回工作集内存量，包括最近访问的内存、脏内存和内核内存(<code class="fe nu nv nw nx b">container_memory_working_set_bytes</code>)，按pod求和，以兆字节(MB)为单位。在显示的时间段内，服务上没有负载。</p><pre class="ma mb mc md gt oi nx oj ok aw ol bi"><span id="47ef" class="ng mp it nx b gy om on l oo op">sum by (pod) (container_memory_working_set_bytes{namespace="dev", container=~"service-.*|rev-proxy|angular-ui"}) / (1024^2)</span></pre><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/1c37e171342920b6407c1b93268fffa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IbSCP3I9xZ_0HxjjYEhS3A.png"/></div></div></figure><p id="8e58" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nu nv nw nx b">container_memory_working_set_bytes</code>度量与<code class="fe nu nv nw nx b">kubectl top</code>命令使用的度量相同(不是<code class="fe nu nv nw nx b">container_memory_usage_bytes</code>)。省略<code class="fe nu nv nw nx b">--containers=true</code>标志将输出pod对容器的统计数据。</p><pre class="ma mb mc md gt oi nx oj ok aw ol bi"><span id="e312" class="ng mp it nx b gy om on l oo op">&gt; kubectl top pod -n dev --containers=true | \<br/>    grep -v istio-proxy | sort -k 4 -r</span><span id="125d" class="ng mp it nx b gy pl on l oo op">POD                           NAME          CPU(cores) MEMORY(bytes)<br/>service-d-69d7469cbf-ts4t7    service-d     135m       13Mi<br/>service-d-69d7469cbf-6thmz    service-d     156m       13Mi<br/>service-d-69d7469cbf-nl7th    service-d     118m       12Mi<br/>service-d-69d7469cbf-fz5bh    service-d     118m       12Mi<br/>service-d-69d7469cbf-89995    service-d     136m       11Mi<br/>service-d-69d7469cbf-g4pfm    service-d     106m       10Mi<br/>service-h-69576c4c8c-x9ccl    service-h      33m        9Mi<br/>service-h-69576c4c8c-gtjc9    service-h      33m        9Mi<br/>service-h-69576c4c8c-bjgfm    service-h      45m        9Mi<br/>service-h-69576c4c8c-8fk6z    service-h      38m        9Mi<br/>service-h-69576c4c8c-55rld    service-h      36m        9Mi<br/>service-h-69576c4c8c-4xpb5    service-h      41m        9Mi<br/>...</span></pre><p id="2663" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在另一个Prometheus示例中，PromQL查询表达式返回以<a class="ae le" href="https://kubernetes.io/docs/tasks/configure-pod-container/assign-cpu-resource/#cpu-units" rel="noopener ugc nofollow" target="_blank"> CPU单位</a> (1个CPU = 1个AWS vCPU)度量的CPU资源的每秒<a class="ae le" href="https://prometheus.io/docs/prometheus/latest/querying/functions/#rate" rel="noopener ugc nofollow" target="_blank">速率，该速率是在过去5分钟内根据范围向量中的时间序列由pod求和得到的。在此期间，后端服务处于使用<code class="fe nu nv nw nx b">hey</code>的15个并发用户的一致模拟负载下。在此期间，四个服务D单元消耗了最多的CPU单元。</a></p><pre class="ma mb mc md gt oi nx oj ok aw ol bi"><span id="a559" class="ng mp it nx b gy om on l oo op">sum by (pod) (rate(container_cpu_usage_seconds_total{namespace="dev", container=~"service-.*|rev-proxy|angular-ui"}[5m])) * 1000</span></pre><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/bdf48cb0bd09d066c3a7e6f6cc219aed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rsci6AlB_7CMe20FpGvNow.png"/></div></div></figure><p id="dbfa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nu nv nw nx b">container_cpu_usage_seconds_total</code>度量与<code class="fe nu nv nw nx b">kubectl top</code>命令使用的度量相同。上面的PromQL表达式将查询结果乘以1，000，以匹配来自<code class="fe nu nv nw nx b">kubectl top</code>的结果，如下所示。</p><pre class="ma mb mc md gt oi nx oj ok aw ol bi"><span id="4bfd" class="ng mp it nx b gy om on l oo op">&gt; kubectl top pod -n dev --sort-by=cpu</span><span id="468c" class="ng mp it nx b gy pl on l oo op">NAME                          CPU(cores)   MEMORY(bytes)<br/>service-d-69d7469cbf-6thmz    159m         60Mi<br/>service-d-69d7469cbf-89995    143m         61Mi<br/>service-d-69d7469cbf-ts4t7    140m         59Mi<br/>service-d-69d7469cbf-fz5bh    135m         58Mi<br/>service-d-69d7469cbf-nl7th    132m         61Mi<br/>service-d-69d7469cbf-g4pfm    119m         62Mi<br/>service-g-c7d68fd94-w5t66      59m         58Mi<br/>service-f-7dc8f64799-qj8qv     56m         55Mi<br/>service-c-69fbc964db-knggt     56m         58Mi<br/>service-h-69576c4c8c-8fk6z     55m         58Mi<br/>service-h-69576c4c8c-4xpb5     55m         58Mi<br/>service-g-c7d68fd94-5cdc2      54m         58Mi<br/>...</span></pre><h2 id="7c02" class="ng mp it bd mq nh ni dn mu nj nk dp my kr nl nm na kv nn no nc kz np nq ne nr bi translated">限制</h2><p id="40db" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">普罗米修斯也暴露了容器资源的限制。例如，在参考平台的后端服务上设置的内存限制，使用<code class="fe nu nv nw nx b">container_spec_memory_limit_bytes</code>指标以兆字节(MB)为单位显示。当与服务消耗的实时资源一起查看时，这些指标有助于正确配置和监控Kubernetes管理功能，如<a class="ae le" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" rel="noopener ugc nofollow" target="_blank">水平Pod自动缩放器</a>。</p><pre class="ma mb mc md gt oi nx oj ok aw ol bi"><span id="2e01" class="ng mp it nx b gy om on l oo op">sum by (container) (container_spec_memory_limit_bytes{namespace="dev", container=~"service-.*|rev-proxy|angular-ui"}) / (1024^2) / count by (container) (container_spec_memory_limit_bytes{namespace="dev", container=~"service-.*|rev-proxy|angular-ui"})</span></pre><p id="1848" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者，Pod的内存限制:</p><pre class="ma mb mc md gt oi nx oj ok aw ol bi"><span id="9695" class="ng mp it nx b gy om on l oo op">sum by (pod) (container_spec_memory_limit_bytes{namespace="dev"}) / (1024^2)</span></pre><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/225267f9ec140d7179f8abdd8e5b77b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uc0VzYMW69N7nwllZjPaCA.png"/></div></div></figure><h2 id="e840" class="ng mp it bd mq nh ni dn mu nj nk dp my kr nl nm na kv nn no nc kz np nq ne nr bi translated">聚类指标</h2><p id="c50d" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">Prometheus还包含关于Istio组件、Kubernetes组件和EKS集群的指标。例如，<code class="fe nu nv nw nx b">istio-observe-demo</code> EKS集群的<code class="fe nu nv nw nx b">managed-ng-1</code>受管节点组中五个<code class="fe nu nv nw nx b">m5.large</code> EC2工作节点的总可用内存(GB)。</p><pre class="ma mb mc md gt oi nx oj ok aw ol bi"><span id="e8c1" class="ng mp it nx b gy om on l oo op">machine_memory_bytes{alpha_eksctl_io_cluster_name="istio-observe-demo", alpha_eksctl_io_nodegroup_name="managed-ng-1"} / (1024^3)</span></pre><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/949267d0b9997fd9d4c4e565531897d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rDRmPVf9cHFiDODkMy8Ubg.png"/></div></div></figure><p id="5755" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于物理核心总数，使用<code class="fe nu nv nw nx b">machine_cpu_physical_core</code>指标，对于vCPU核心，使用<code class="fe nu nv nw nx b">machine_cpu_cores</code>指标。</p><h1 id="42ef" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">格拉夫纳</h1><p id="c270" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">Grafana称自己是领先的时间序列分析开源软件。根据<a class="ae le" href="https://grafana.com/grafana" rel="noopener ugc nofollow" target="_blank"> Grafana Labs的说法，</a> Grafana允许您查询、可视化、提醒和了解您的指标，无论它们存储在哪里。您可以轻松创建、浏览和共享视觉效果丰富的数据驱动仪表板。Grafana还允许用户可视化地为他们最重要的指标定义警报规则。Grafana将不断评估规则，并可以发送通知。</p><p id="3bf9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您使用前一篇文章的<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-based-microservice-observability-with-istio-service-mesh-part-1-of-2-19084d13a866">第一部分</a>中演示的Istio addons过程部署了Grafana，请访问与其他工具类似的Grafana:</p><pre class="ma mb mc md gt oi nx oj ok aw ol bi"><span id="dcd3" class="ng mp it nx b gy om on l oo op">istioctl dashboard grafana</span></pre><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/473f5cc5a391d80b9eb3f022befd385d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gOE12Q_OQzFnUS217OGLQA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">Grafana主页</figcaption></figure><p id="fe63" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">据<a class="ae le" href="https://istio.io/docs/tasks/telemetry/using-istio-dashboard/#about-the-grafana-add-on" rel="noopener ugc nofollow" target="_blank">消息，Istio </a>，<a class="ae le" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank"> Grafana </a>是一款开源监控解决方案，用于为Istio配置仪表盘。您可以使用Grafana来监控服务网格中Istio和应用程序的健康状况。虽然您可以构建自己的仪表板，但Istio为网格和控制平面的所有最重要指标提供了一组预配置的仪表板。预配置的仪表板使用Prometheus作为数据源。</p><ul class=""><li id="0e16" class="ot ou it kk b kl km ko kp kr ov kv ow kz ox ld oy oz pa pb bi translated"><a class="ae le" href="https://grafana.com/grafana/dashboards/7639" rel="noopener ugc nofollow" target="_blank"> Mesh Dashboard </a>提供了Mesh中所有服务的概述。</li><li id="8982" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld oy oz pa pb bi translated"><a class="ae le" href="https://grafana.com/grafana/dashboards/7636" rel="noopener ugc nofollow" target="_blank"> Service Dashboard </a>提供了服务指标的详细分解。</li><li id="2972" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld oy oz pa pb bi translated"><a class="ae le" href="https://grafana.com/grafana/dashboards/7630" rel="noopener ugc nofollow" target="_blank">工作负载仪表板</a>提供工作负载指标的详细细分。</li><li id="642a" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld oy oz pa pb bi translated"><a class="ae le" href="https://grafana.com/grafana/dashboards/11829" rel="noopener ugc nofollow" target="_blank">性能仪表板</a>监控网格的资源使用情况。</li><li id="cd4c" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld oy oz pa pb bi translated"><a class="ae le" href="https://grafana.com/grafana/dashboards/7645" rel="noopener ugc nofollow" target="_blank">控制面板仪表板</a>监控控制面板的健康和性能。</li></ul><p id="2fdb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个<a class="ae le" href="https://grafana.com/grafana/dashboards/7639" rel="noopener ugc nofollow" target="_blank"> Istio Mesh仪表板</a>的例子，过滤后显示了在<code class="fe nu nv nw nx b">dev</code>名称空间中运行的八个后端服务工作负载。在此期间，后端服务处于使用<code class="fe nu nv nw nx b">hey</code>的大约20个并发用户的一致模拟负载下。您可以观察这些工作负载的请求的p50、p90和p99延迟。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/12feadc33210c16a1cf16bc8ac03e4c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JAXmITabgAD47pUFNZdVLA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">Istio网格操控板视图</figcaption></figure><p id="f144" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">仪表板由Grafana中的基本可视化构建模块<a class="ae le" href="https://grafana.com/docs/grafana/latest/panels/" rel="noopener ugc nofollow" target="_blank">面板</a>构建而成。每个面板都有一个特定于所选数据源(在本例中为Prometheus)的查询编辑器。查询编辑器允许您编写(PromQL)查询。例如，下面是负责Istio Mesh仪表板中显示的p50延迟面板的PromQL表达式查询。</p><pre class="ma mb mc md gt oi nx oj ok aw ol bi"><span id="a5bf" class="ng mp it nx b gy om on l oo op">label_join((histogram_quantile(0.50, sum(rate(istio_request_duration_milliseconds_bucket{reporter="source"}[1m])) by (le, destination_workload, destination_workload_namespace)) / 1000) or histogram_quantile(0.50, sum(rate(istio_request_duration_seconds_bucket{reporter="source"}[1m])) by (le, destination_workload, destination_workload_namespace)), "destination_workload_var", ".", "destination_workload", "destination_workload_namespace")</span></pre><p id="ad08" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个<a class="ae le" href="https://grafana.com/grafana/dashboards/7630" rel="noopener ugc nofollow" target="_blank"> Istio工作负荷仪表板</a>的例子。仪表板包含三个部分:常规、入站工作负载和出站工作负载。这里，我们过滤了来自参考平台后端服务在<code class="fe nu nv nw nx b">dev</code>名称空间中的出站流量。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/a36465945865a540bcd5ec3a51cf357b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CCmOsHXSnHyGd5k2txYyFQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">Istio工作量仪表板视图</figcaption></figure><p id="6c81" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是Istio工作负载仪表板的另一个视图，仪表板的入站工作负载部分被过滤为一个工作负载，即gRPC网关。gRPC网关接受来自Istio入口网关的传入流量，如仪表板面板所示。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/9411ba55f5b133e4a842471e3792b107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3hgCi2A_I4MlakY5ugWOIw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">Istio工作量仪表板视图</figcaption></figure><p id="2fb9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Grafana提供了浏览面板的能力。<a class="ae le" href="https://grafana.com/docs/grafana/latest/explore/" rel="noopener ugc nofollow" target="_blank"> Explore </a>去掉了仪表板和面板选项，以便您可以专注于查询。下面是一个面板示例，根据<code class="fe nu nv nw nx b">istio_tcp_sent_bytes_total</code>指标，显示了服务F的基于TCP的出口流量的稳定流。服务F消耗RabbitMQ队列(Amazon MQ)上的消息，并将消息写入MongoDB (DocumentDB)。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/3ebc5b33a5aad2705d88bbdcc1a0b307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uT6cfQhRhzhU8VOASauasg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">探索Grafana仪表板面板</figcaption></figure><h2 id="8613" class="ng mp it bd mq nh ni dn mu nj nk dp my kr nl nm na kv nn no nc kz np nq ne nr bi translated">Istio性能</h2><p id="85ed" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">您可以使用<a class="ae le" href="https://grafana.com/grafana/dashboards/11829" rel="noopener ugc nofollow" target="_blank"> Istio性能仪表板</a>监控Istio的资源使用情况。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/295f2738be2960e39cf27a8d7f149397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3rCKylebSIG5toJdJ7t8nw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">Istio性能仪表板视图</figcaption></figure><h2 id="0832" class="ng mp it bd mq nh ni dn mu nj nk dp my kr nl nm na kv nn no nc kz np nq ne nr bi translated">附加仪表板</h2><p id="d1d3" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">Grafana提供了一个包含官方和社区构建的仪表板的网站，其中包括上述Istio仪表板。将仪表板导入Grafana实例非常简单，只需复制仪表板URL或Grafana仪表板站点提供的ID，并将其粘贴到Grafana实例的仪表板导入选项中。但是，请注意，并不是Grafan网站中的每个Kubernetes仪表板都与您的特定版本的Kubernetes、Istio或EKS兼容，也不依赖Prometheus作为数据源。因此，您可能必须测试和调整导入的仪表板，以使它们工作。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi pk"><img src="../Images/09b08cac3a043412fc368dcab3a9de51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xeb-zcV19vE1b1dY6GKj8g.png"/></div></div></figure><p id="e8ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个由的<a class="ae le" href="https://grafana.com/orgs/instrumentisto" rel="noopener ugc nofollow" target="_blank">instruments团队开发的</a><a class="ae le" href="https://grafana.com/grafana/dashboards/315" rel="noopener ugc nofollow" target="_blank">Kubernetes cluster monitoring(via Prometheus)</a>(仪表板ID 315)的导入社区仪表板示例。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi pk"><img src="../Images/433d0deabd224ca294cfd57a30583564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HLmxg0wH_IF2SMGDohxRog.png"/></div></div></figure><h2 id="5834" class="ng mp it bd mq nh ni dn mu nj nk dp my kr nl nm na kv nn no nc kz np nq ne nr bi translated">发信号</h2><p id="7e3f" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">有效的可观察性策略必须不仅仅包括可视化结果的能力。有效的策略还必须检测异常情况，并通知(提醒)适当的资源或直接解决事故。格拉夫纳和普罗米修斯一样，能够发出警报和通知。您可以直观地定义关键指标的警报规则。然后，Grafana将根据规则持续评估指标，并在违反预定义阈值时发送通知。</p><p id="84bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Prometheus支持多个流行的<a class="ae le" href="http://docs.grafana.org/alerting/notifications/#all-supported-notifier" rel="noopener ugc nofollow" target="_blank">通知渠道</a>，包括PagerDuty、HipChat、Email、Kafka、Slack。下面是一个Prometheus通知通道的示例，它向Slack支持通道发送预警通知。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi pk"><img src="../Images/86f417dbbea362806ed37a3f7c71f56e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HTcSrXWSqDJMzKgv0v5TpA.png"/></div></div></figure><p id="d243" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个基于300 <a class="ae le" href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu" rel="noopener ugc nofollow" target="_blank">毫cpu </a>或毫核心(m)的任意高CPU使用率的警报示例。当单个pod的CPU使用率超过该值超过3分钟时，将会发送警报。高CPU使用率可能是由于水平Pod自动缩放器不起作用，或者HPA已达到其<code class="fe nu nv nw nx b">maxReplicas</code>限制，或者集群的现有工作节点中没有足够的资源来调度额外的Pod。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi pk"><img src="../Images/2d5c6307a34d34e877983103c832a50a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YLIjmsottTscfuYk5_ehfA.png"/></div></div></figure><p id="a0cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由警报触发，Prometheus向指定的Slack信道发送详细的通知。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi pk"><img src="../Images/717820e4512997d5d574ed232f5e15cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hYlHgew5hvrSzDL2HxO9NQ.png"/></div></div></figure><h1 id="8936" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">亚马逊云观察容器洞察</h1><p id="0401" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">最后，在指标类别中，<a class="ae le" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/ContainerInsights.html" rel="noopener ugc nofollow" target="_blank">Amazon cloud watch Container Insights</a>从您的容器化应用和微服务中收集、汇总、总结和可视化指标和日志。可以根据Container Insights收集的指标设置CloudWatch警报。Container Insights可用于亚马逊弹性容器服务(Amazon ECS)，包括亚马逊EC2上的Fargate、亚马逊EKS和Kubernetes平台。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi pk"><img src="../Images/46de90f21ddb28ae83ac9a16e9b9d326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CMCZB-7lbfz13ezCRq2MEg.png"/></div></div></figure><p id="d754" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在亚马逊EKS，Container Insights使用CloudWatch代理的容器化版本来发现集群中所有正在运行的容器。然后，它在性能堆栈的每一层收集性能数据。Container Insights使用<a class="ae le" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Embedded_Metric_Format.html" rel="noopener ugc nofollow" target="_blank">嵌入式指标格式</a>收集数据作为性能日志事件。这些性能日志事件是使用结构化JSON模式的条目，该模式支持大规模接收和存储高基数数据。</p><p id="60c0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-based-microservice-observability-with-istio-service-mesh-part-1-of-2-19084d13a866">之前的帖子</a>中，我们还为Prometheus安装了cloud watch Container Insights monitoring，它可以自动从容器化的系统和工作负载中发现Prometheus指标。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi pm"><img src="../Images/596f62616baf50284c305db865a498eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o-07nNLIvlpgg7d1J9MBcQ.png"/></div></div></figure><p id="613d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个基本性能监控CloudWatch Container Insights仪表板的示例。仪表板被过滤到EKS集群的<code class="fe nu nv nw nx b">dev</code>名称空间，参考应用程序平台在此运行。在此期间，使用<code class="fe nu nv nw nx b">hey</code>将后端服务置于模拟负载下。随着应用程序负载的增加，根据容器请求的资源和HPA配置,“容器数量”从20个容器增加到56个容器。还有一个CloudWatch警报，显示在屏幕右侧。任意高水平的网络传输活动触发了警报。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/8c6a51eb372f366c0a8c138360bfb72d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J5g7A6gpYxoe8iwWskvk8A.png"/></div></div></figure><p id="4943" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来是Container Insights在CPU模式下的容器图视图示例。您可以看到<code class="fe nu nv nw nx b">dev</code>名称空间的可视化表示，其中显示了每个后端服务的<code class="fe nu nv nw nx b">Service</code>和<code class="fe nu nv nw nx b">Deployment</code>资源。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/b2038fde81d4dbf90fa2c426785bd50d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XgaeSZ_CUFqnf3NYzryztg.png"/></div></div></figure><p id="e9d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面有一个警告图标，指示集群上的警报被触发。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/7c5c363bfd0856075fcf290c639e0c2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*unKADwgKdQjCFoUutcG7Kg.png"/></div></div></figure><p id="86f4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，CloudWatch Insights允许您从CloudWatch Insights跳转到CloudWatch Log Insights控制台。CloudWatch Insights还将为您编写CloudWatch Insights查询。下面，我们从CloudWatch Insights性能监控控制台中的Service D container metrics视图直接转到CloudWatch Log Insights控制台，带有一个查询，准备运行。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi pn"><img src="../Images/e6e05e473f03f2cb60942f145d4b012b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_yliA_wVawxxQgk0twP-1A.png"/></div></div></figure><h1 id="8812" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">支柱3:痕迹</h1><p id="8173" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">据<a class="ae le" href="https://opentracing.io/docs/overview/what-is-tracing/" rel="noopener ugc nofollow" target="_blank">开放跟踪网站</a>报道，分布式跟踪，也称为分布式请求跟踪，用于分析和监控应用程序，尤其是那些使用微服务架构构建的应用程序。分布式跟踪有助于查明故障发生的位置以及导致低性能的原因。</p><h2 id="c279" class="ng mp it bd mq nh ni dn mu nj nk dp my kr nl nm na kv nn no nc kz np nq ne nr bi translated">标题传播</h2><p id="8262" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">根据<a class="ae le" href="https://istio.io/docs/tasks/telemetry/distributed-tracing/#understanding-what-happened" rel="noopener ugc nofollow" target="_blank"> Istio </a>的说法，头传播可以通过客户端库来完成，比如<a class="ae le" href="https://zipkin.io/pages/tracers_instrumentation.html" rel="noopener ugc nofollow" target="_blank"> Zipkin </a>或者<a class="ae le" href="https://github.com/jaegertracing/jaeger-client-java/tree/master/jaeger-core#b3-propagation" rel="noopener ugc nofollow" target="_blank"> Jaeger </a>。报头传播也可以手动完成，称为跟踪上下文传播，记录在<a class="ae le" href="https://istio.io/latest/docs/tasks/observability/distributed-tracing/overview/#trace-context-propagation" rel="noopener ugc nofollow" target="_blank">分布式跟踪任务</a>中。或者，Istio代理可以自动发送跨度。应用程序需要传播适当的HTTP头，以便当代理发送跨度信息时，跨度可以正确地关联到单个跟踪中。为了实现这一点，应用程序需要从传入请求到任何传出请求收集并传播以下标头。</p><ul class=""><li id="3b0a" class="ot ou it kk b kl km ko kp kr ov kv ow kz ox ld oy oz pa pb bi translated"><code class="fe nu nv nw nx b">x-request-id</code></li><li id="9670" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld oy oz pa pb bi translated"><code class="fe nu nv nw nx b">x-b3-traceid</code></li><li id="ca14" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld oy oz pa pb bi translated"><code class="fe nu nv nw nx b">x-b3-spanid</code></li><li id="ef0c" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld oy oz pa pb bi translated"><code class="fe nu nv nw nx b">x-b3-parentspanid</code></li><li id="3fed" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld oy oz pa pb bi translated"><code class="fe nu nv nw nx b">x-b3-sampled</code></li><li id="109f" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld oy oz pa pb bi translated"><code class="fe nu nv nw nx b">x-b3-flags</code></li><li id="5379" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld oy oz pa pb bi translated"><code class="fe nu nv nw nx b">x-ot-span-context</code></li></ul><p id="f9bb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">标题起源于Zipkin项目的一部分。报头的B3部分以Zipkin的原名命名，<strong class="kk iu">B</strong>ig<strong class="kk iu">B</strong>rother<strong class="kk iu">B</strong>ird。跨服务调用传递这些头被称为<a class="ae le" href="https://github.com/openzipkin/b3-propagation" rel="noopener ugc nofollow" target="_blank"> B3传播</a>。根据<a class="ae le" href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/observability/tracing#arch-overview-tracing" rel="noopener ugc nofollow" target="_blank"> Zipkin </a>的说法，这些属性会在进程内传播，并最终传播到下游(通常通过HTTP头),以确保源自同一个根的所有活动都被收集在一起。</p><p id="5c1f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了用Jaeger和Zipkin演示分布式跟踪，gRPC网关传递b3头。基于RESTful JSON的服务在HTTP请求对象中传递这些头，而使用gRPC，这些头在gRPC <code class="fe nu nv nw nx b">Context</code>对象中传递。以下代码已添加到gRPC网关中。Istio sidecar代理(<a class="ae le" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank">特使</a>)生成初始的<a class="ae le" href="https://istio.io/latest/about/faq/#distributed-tracing" rel="noopener ugc nofollow" target="_blank">头</a>，然后这些头被传播到整个服务调用链。关键是只传播下游请求中带有值的头，如下面的代码所示。</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="ff71" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的CloudWatch日志中，我们看到了一个记录在服务a的日志消息中的HTTP请求头的例子。<code class="fe nu nv nw nx b">b3</code>头从gRPC网关反向代理传播到基于gRPC的Go服务。标头传播确保了跨整个服务调用链的完整分布式跟踪。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/372ed92827eac0eb048cee54b26ab288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eob0fievDVtiM9UM-Vw-ig.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">显示服务A的日志条目的CloudWatch日志洞察控制台</figcaption></figure><p id="4217" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从服务A传播的标头如下所示。注意从gRPC网关反向代理传播的<code class="fe nu nv nw nx b">b3</code>报头。</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="ph pi l"/></div></figure><h2 id="18e0" class="ng mp it bd mq nh ni dn mu nj nk dp my kr nl nm na kv nn no nc kz np nq ne nr bi translated">贼鸥</h2><p id="29dd" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">根据他们的网站介绍，<a class="ae le" href="https://www.jaegertracing.io/docs/1.10/" rel="noopener ugc nofollow" target="_blank"> Jaeger </a>受<a class="ae le" href="https://research.google.com/pubs/pub36356.html" rel="noopener ugc nofollow" target="_blank"> Dapper </a>和<a class="ae le" href="http://zipkin.io/" rel="noopener ugc nofollow" target="_blank"> OpenZipkin </a>的启发，是一个由<a class="ae le" href="http://uber.github.io/" rel="noopener ugc nofollow" target="_blank">优步科技</a>开源发布的分布式追踪系统。Jaeger用于对基于微服务的分布式系统进行监控和故障排除，包括分布式上下文传播、分布式事务监控、根本原因分析、服务依赖性分析以及性能和延迟优化。Jaeger网站包含Jaeger架构和一般追踪相关术语的有用概述。</p><p id="3844" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您使用上一篇文章的第一部分中演示的Istio addons过程部署了Jaeger，请像访问其他工具一样访问Jaeger:</p><pre class="ma mb mc md gt oi nx oj ok aw ol bi"><span id="9d99" class="ng mp it nx b gy om on l oo op">istioctl dashboard j<!-- -->aeger</span></pre><p id="5917" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是Jaeger UI的搜索视图示例，显示了一段时间内Angular UI和Istio Ingress网关服务的搜索结果。我们在顶部看到跟踪时间线，下面是跟踪结果列表。正如在Jaeger <a class="ae le" href="https://www.jaegertracing.io/docs/1.10/architecture/" rel="noopener ugc nofollow" target="_blank">网站</a>上讨论的那样，一条轨迹由跨度组成。span表示Jaeger中具有操作名称的逻辑工作单元。踪迹是通过系统的执行路径，并且可以被认为是<a class="ae le" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" rel="noopener ugc nofollow" target="_blank">有向无环图</a> (DAG)的<a class="ae le" href="https://www.jaegertracing.io/docs/1.10/architecture#span" rel="noopener ugc nofollow" target="_blank">跨度</a>。如果您使用过像Apache Spark这样的系统，您可能已经熟悉Dag的概念。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/602c499971ca343b527daaffae1a8a15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q6KWrEwmOTmSCcYCaeaYRg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">最新的角度UI跟踪</figcaption></figure><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/09d4c592f48f8cc3b7880fa862da1d8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mqZrnFNzqkmI37DMMbbNtA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">最新的Istio入口网关跟踪</figcaption></figure><p id="49b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是Jaeger的轨迹时间线模式中单个轨迹的详细视图。这16个跨度涵盖了参考平台的9个组件:7个后端服务、gRPC网关和Istio入口网关。每个跨度都有单独的计时，总跟踪时间为195.49毫秒，跟踪中的根跨度是Istio入口网关。加载在最终用户网络浏览器中的Angular UI通过Istio入口网关调用gRPC网关。从那里，我们看到了我们的服务到服务IPC的预期流程。服务A调用服务B和服务c，服务B调用服务E，服务E调用服务G和服务h。</p><p id="642b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个演示中，跟踪既没有跨越RabbitMQ消息队列，也没有跨越MongoDB。您将不会看到包含通过RabbitMQ从服务D到服务F的调用的跟踪。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/8bda91d2df958e50e6b47b939f83ab6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uZkSdtvR3viZ-J-4d1GeZQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">Istio入口网关分布式跟踪的详细视图</figcaption></figure><p id="34e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">跟踪时间线的可视化展示了参考平台的服务到服务IPC的同步性质，而不是使用RabbitMQ消息队列的解耦通信的异步性质。服务A等待其调用链中的每个服务做出响应，然后将其响应返回给请求者。</p><p id="9029" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Jaeger的跟踪时间线视图中，您可以钻取包含附加元数据的单个跨度。span的元数据包括被调用的API端点URL、HTTP方法、响应状态和其他几个头。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/313535b02585f897c5290d042667ea89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e8Io58C2ZvvOZLlE56Jisw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">Istio入口网关分布式跟踪的详细视图</figcaption></figure><p id="df44" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">跟踪统计视图也是可用的。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/ff845568f5166b010d13f1023763899d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P3diIGBFXzAw4NXWMnD6wg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">Istio入口网关分布式跟踪的跟踪统计信息</figcaption></figure><p id="fc25" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，Jaeger还有一个实验性的轨迹图形模式，可以显示同一轨迹的图形视图。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/a34e9f3135b5c1a9941ae6cf6744fa82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0vI9oSFTmpdCJanqTEf4Mg.png"/></div></div></figure><p id="f46c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Jaeger还包括一个比较跟踪功能和两个依赖视图:力定向图和DAG。我发现这两种观点与基亚利相比都相当原始。缺少对Kiali的访问，这些视图作为依赖图没有多大用处。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/6d74918cc719a9bb678698ed289ef787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v07h83ppsRCXiBPh7Tarjg.png"/></div></div></figure><h1 id="19d3" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">齐普金</h1><p id="0c68" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">Zipkin 是一个分布式跟踪系统，它帮助收集解决服务架构中的延迟问题所需的时间数据。根据2012年在<a class="ae le" href="https://blog.twitter.com/engineering/en_us/a/2012/distributed-systems-tracing-with-zipkin" rel="noopener ugc nofollow" target="_blank"> Twitter的工程博客</a>上的一篇帖子，Zipkin是在Twitter的第一个黑客周期间作为一个项目开始的。在那一周，他们实施了一个基本版本的<a class="ae le" href="http://research.google.com/pubs/pub36356.html" rel="noopener ugc nofollow" target="_blank">谷歌衣冠楚楚</a>节俭纸。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/29ff7cf2a948948f1b5c375edce1f4c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0FoCUuI_a0EjP9qB1p0q1A.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">在Zipkin中搜索最新踪迹的结果</figcaption></figure><p id="8cb1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Zipkin和Jaeger在能力上非常相似。我选择在这篇文章中关注耶格，因为比起齐普金，我更喜欢它。如果你想尝试Zipkin而不是Jaeger，你可以使用以下命令从Istio addons extras目录中移除Jaeger并<a class="ae le" href="https://istio.io/latest/docs/ops/integrations/zipkin/" rel="noopener ugc nofollow" target="_blank">安装Zipkin </a>。在帖子的第一部分，我们在部署Istio插件时没有默认安装Zipkin。请注意，在同一个Kubernetes集群中同时运行这两个工具会导致不可预测的跟踪结果。</p><pre class="ma mb mc md gt oi nx oj ok aw ol bi"><span id="3737" class="ng mp it nx b gy om on l oo op">kubectl delete -f <a class="ae le" href="https://raw.githubusercontent.com/istio/istio/release-1.10/samples/addons/jaeger.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/istio/istio/release-1.10/samples/addons/jaeger.yaml</a></span><span id="3d91" class="ng mp it nx b gy pl on l oo op">kubectl apply -f <a class="ae le" href="https://raw.githubusercontent.com/istio/istio/release-1.10/samples/addons/extras/zipkin.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/istio/istio/release-1.10/samples/addons/extras/zipkin.yaml</a></span></pre><p id="0a13" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">访问Zipkin类似于其他观察工具:</p><pre class="ma mb mc md gt oi nx oj ok aw ol bi"><span id="7b22" class="ng mp it nx b gy om on l oo op">istioctl dashboard zipkin</span></pre><p id="c640" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个在Zipkin的UI中可视化的分布式轨迹的例子，包含16个跨度，类似于上面显示的Jaeger中可视化的轨迹。该跨度包含参考平台的八个组件:八个后端服务中的七个和Istio入口网关。每个跨度都有单独的时序，总跟踪时间约为221 ms。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/e43ccc2d98d2a1e2b008e761f5beaed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xgr1ISUMZFrHAjONW39puw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">Zipkin中分布式跟踪的详细视图</figcaption></figure><p id="61c1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Zipkin还可以基于分布式跟踪可视化一个依赖图。下面是一个24小时内的流量模拟示例，显示了参考平台组件之间的网络流量，以依赖关系图的形式显示。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/0c6a71118429f7c9de4566104d4f42e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ohMjaV76aCHaU3ILHcnbdg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">显示24小时内流量的Zipkin依赖图</figcaption></figure><h1 id="a471" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">Kiali:微服务可观察性</h1><p id="3047" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">根据他们的网站所说，Kiali是一个基于Istio的服务网格的管理控制台。它提供了仪表板和可观察性，并允许您使用健壮的配置和验证功能来操作网格。它通过推断流量拓扑和显示网格的健康状况来显示服务网格的结构。Kiali提供了详细的指标、强大的验证、Grafana访问以及与Jaeger的分布式跟踪的强大集成。</p><p id="8ce3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您使用上一篇文章的第一部分中的<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-based-microservice-observability-with-istio-service-mesh-part-1-of-2-19084d13a866">演示的Istio addons过程部署了Kaili，请像访问其他工具一样访问Kiali:</a></p><pre class="ma mb mc md gt oi nx oj ok aw ol bi"><span id="5a6b" class="ng mp it nx b gy om on l oo op">istioctl dashboard kaili</span></pre><p id="1210" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了提高安全性，使用Istio文档中提到的<a class="ae le" href="https://istio.io/latest/docs/ops/integrations/kiali/#option-2-customizable-install" rel="noopener ugc nofollow" target="_blank">可定制安装</a>安装最新版本的Kaili。使用Kiali的<a class="ae le" href="https://kiali.io/documentation/latest/quick-start/#_install_via_kiali_server_helm_chart" rel="noopener ugc nofollow" target="_blank">Install via Kiali Server Helm Chart</a>选项添加了基于令牌的身份验证，类似于Kubernetes仪表板。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi pk"><img src="../Images/b2e9f128e89c9108b9370b99be1b0689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NESyTnJCMrPTsx-hGAKM7g.png"/></div></div></figure><p id="ca0b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Kiali的Overview选项卡提供了Istio服务网格中所有名称空间的全局视图，以及每个名称空间中应用程序的数量。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/9390b5f58d4daf442e98ed07d3bbb557.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wQOmiq7b3-RBqP3fwx_ItA.png"/></div></div></figure><p id="625a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Kiali UI中的Graph选项卡表示在Istio服务网格中运行的组件。下面，过滤集群的<code class="fe nu nv nw nx b">dev</code>名称空间，我们可以观察到Kiali映射了11个应用程序(工作负载)、11个服务和24个边缘(一个图形术语)。具体来说，我们看到位于服务网格边缘的Istio Ingres代理、gRPC网关、Angular UI和八个后端服务，所有这些服务都有各自的Envoy代理侧柜，它们都在接收流量(在本例中，服务F没有从另一个服务接收任何直接流量)、外部DocumentDB出口点和外部Amazon MQ出口点。请注意Istio中服务到服务的流量是如何流动的，从服务到它的sidecar代理，再到另一个服务的sidecar代理，最后到服务。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/a9f0c2982a9e37781cb0d152e3dd123d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dc1m4jCVCRJrCKzUb1tIfA.png"/></div></div></figure><p id="3dc1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Kiali允许您放大并关注图表中的单个组件及其各个指标。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/0cce7c19d018bc935508d1781e741063.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54O7hW-7r8-Kb9mzw_lTbQ.png"/></div></div></figure><p id="d894" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Kiali还可以显示图中每条边的平均请求时间和其他指标(两个组件之间的通信)。Kaili甚至可以使用Kiali的重放功能显示给定时间段内的这些指标，如下所示。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/fb724eed611f795cc5a5ab7178798f7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zUdtGzvbYEOsqh3qOn9YKQ.png"/></div></div></figure><p id="9cb0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“应用程序”选项卡列出了所有应用程序、它们的名称空间和标签。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/53fa0beab7c544af910a5f7b3e807992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z_rHe1lLxHMUAqSmxwBj0A.png"/></div></div></figure><p id="aea8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以在“应用程序”和“工作负载”选项卡上深入查看单个组件，并查看更多详细信息。详细信息包括总体运行状况、pod和Istio配置状态。下面是对<code class="fe nu nv nw nx b">dev</code>名称空间中服务A工作负载的概述。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/b15ad62c3f1251d166c151e3867c733b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hO4n24XXfzGjWbExc0bNKQ.png"/></div></div></figure><p id="7184" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">工作负载详细视图还包括入站和出站网络指标。下面是一个在<code class="fe nu nv nw nx b">dev</code>名称空间中服务A出站的例子。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/5e4aaa674f225aa1310ed7598fbca679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nBrLG6Xv8A3Mzzs2nV4oUQ.png"/></div></div></figure><p id="93af" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Kiali还可以让您访问单个pod的集装箱日志。尽管日志访问不如前面讨论的其他日志源那样用户友好，但是在Kiali中，除了度量(与Grafana集成)、跟踪(与Jaeger集成)和网格可视化之外，还可以使用日志，这可以作为非常有效的单一观察平台。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/29d7fe8224f8889845da625b37bfa8fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CqPjZueY8Q259Y83EIbwIw.png"/></div></div></figure><p id="148f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Kiali还有一个Istio配置选项卡。Istio配置选项卡显示用户环境中存在的所有可用Istio配置对象的列表。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/81dd78af1a27eee363b1a3f321fd849a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0aVCwE6cuFCm-e5MGn0MAg.png"/></div></div></figure><p id="003d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用Kiali来配置和管理Istio服务网格及其安装的资源。使用Kiali，您实际上可以修改已部署的资源，类似于使用<code class="fe nu nv nw nx b">kubectl edit</code>命令。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/8abbd09483f42b600d93d38d865fbaf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TMKRWZ3Th1OcKH9lWE5eSQ.png"/></div></div></figure><p id="2f58" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我经常发现Kiali是我解决平台问题的第一站。一旦我确定了有问题的特定组件或通信路径，我就会通过Grafana仪表板查看特定的应用程序日志和Prometheus指标。</p><h1 id="cfde" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">拆毁</h1><p id="d989" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">要拆除EKS集群、DocumentDB集群和Amazon MQ broker，请使用以下命令:</p><pre class="ma mb mc md gt oi nx oj ok aw ol bi"><span id="eeeb" class="ng mp it nx b gy om on l oo op"># EKS cluster<br/>eksctl delete cluster --name $CLUSTER_NAME</span><span id="2b77" class="ng mp it nx b gy pl on l oo op"># Amazon MQ<br/>aws mq list-brokers | jq -r '.BrokerSummaries[] | .BrokerId'aws mq delete-broker --broker-id <strong class="nx iu">{{ your_broker_id }}</strong></span><span id="cac5" class="ng mp it nx b gy pl on l oo op"># DocumentDB<br/>aws docdb describe-db-clusters \<br/>    | jq -r '.DBClusters[] | .DbClusterResourceId'aws docdb delete-</span><span id="326f" class="ng mp it nx b gy pl on l oo op">db-cluster \<br/>    --db-cluster-identifier <strong class="nx iu">{{ your_cluster_id }}</strong></span></pre><h1 id="9249" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">结论</h1><p id="21d5" class="pw-post-body-paragraph ki kj it kk b kl ny ju kn ko nz jx kq kr oa kt ku kv ob kx ky kz oc lb lc ld im bi translated">在这篇文章中，我们探索了一组流行的开源可观察性工具，它们很容易与Istio服务网格集成。这些工具包括用于分布式事务监控的Jaeger和Zipkin，用于指标收集和警报的Prometheus，用于指标查询、可视化和警报的Grafana，以及用于Istio整体可观察性和管理的Kiali。我们使用Fluent Bit完善了工具集，用于日志处理和转发到Amazon cloud watch Container Insights。使用这些工具，我们成功地观察了部署到亚马逊EKS的基于gRPC的分布式参考应用平台。</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="po pi l"/></div></figure></div><div class="ab cl pp pq hx pr" role="separator"><span class="ps bw bk pt pu pv"/><span class="ps bw bk pt pu pv"/><span class="ps bw bk pt pu"/></div><div class="im in io ip iq"><p id="ec01" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇博客代表我自己的观点，而不是我的雇主亚马逊网络服务公司(AWS)的观点。所有产品名称、徽标和品牌都是其各自所有者的财产。</p></div></div>    
</body>
</html>