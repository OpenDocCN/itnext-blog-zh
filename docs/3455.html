<html>
<head>
<title>React Responsive Slider</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应响应滑块</h1>
<blockquote>原文：<a href="https://itnext.io/react-responsive-slider-2ed4b07867b3?source=collection_archive---------2-----------------------#2019-12-19">https://itnext.io/react-responsive-slider-2ed4b07867b3?source=collection_archive---------2-----------------------#2019-12-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f7d9492e0ee37d6bef4e8461fe39a5e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y5x1AzCf89WWtle_VsTy0g.png"/></div></div></figure><h2 id="cd19" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">介绍</h2><p id="55ee" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">在我的上一篇文章<a class="ae lp" href="https://medium.com/@jkeohan/3-ways-to-implement-responsive-design-in-your-react-app-bcb6ee7eb424" rel="noopener"> 3种在React应用中实现响应式设计的方法</a>中，我讨论了几种在React应用中实现响应式设计的方法。这个应用的灵感来自mars.nasa.gov的<a class="ae lp" href="https://mars.nasa.gov/" rel="noopener ugc nofollow" target="_blank">，在这篇文章中，我继续重建网站的其他部分，主要关注实现主页标题部分的底部滑块功能。</a></p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="4c53" class="pw-post-body-paragraph ku kv iq kw b kx lw kz la lb lx ld le kh ly lg lh kl lz lj lk kp ma lm ln lo ij bi translated">这是一个部署版本和codesandbox:</p><p id="b799" class="pw-post-body-paragraph ku kv iq kw b kx lw kz la lb lx ld le kh ly lg lh kl lz lj lk kp ma lm ln lo ij bi translated">app:【https://02nz9.csb.app/ T4】</p><p id="4def" class="pw-post-body-paragraph ku kv iq kw b kx lw kz la lb lx ld le kh ly lg lh kl lz lj lk kp ma lm ln lo ij bi translated">code sandbox:<a class="ae lp" href="https://codesandbox.io/s/mars-slider-demo-02nz9" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/mars-slider-demo-02nz9</a></p><h2 id="c571" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">“BottomSlider”组件</h2><p id="8abf" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">创建一个组件来包含slider的所有元素和功能似乎是最实用的方法，尤其是因为我正在考虑将它包含在我想要构建的其他应用程序中。</p><p id="8ad3" class="pw-post-body-paragraph ku kv iq kw b kx lw kz la lb lx ld le kh ly lg lh kl lz lj lk kp ma lm ln lo ij bi translated">因为我总是想让自己跟上最新最棒的反应，所以我决定加入钩子。我已经包含了<strong class="kw ir"> useReducer </strong>来管理<strong class="kw ir"> PREV/NEXT/RESET </strong>状态，包含了<strong class="kw ir"> useEffect </strong>来在window.innerWidth值改变时启动<strong class="kw ir"> RESET </strong>状态，包含了<strong class="kw ir"> useRef </strong>来获取。支持滑块的光滑轨道元件。</p><p id="6acb" class="pw-post-body-paragraph ku kv iq kw b kx lw kz la lb lx ld le kh ly lg lh kl lz lj lk kp ma lm ln lo ij bi translated">这是基本结构。其他内容，如reducer的内部工作方式或sliderController对象，将在本文后面解释。</p><pre class="lq lr ls lt gt mb mc md me aw mf bi"><span id="35c3" class="jy jz iq mc b gy mg mh l mi mj">import React, { useReducer, useEffect, useRef } from  "react";<br/>import './BottomSlider.css'</span><span id="c7bf" class="jy jz iq mc b gy mk mh l mi mj">function BottomSlider() {</span><span id="8d8d" class="jy jz iq mc b gy mk mh l mi mj"> // useRef<br/> const slideTrackRef = useRef()</span><span id="f5f9" class="jy jz iq mc b gy mk mh l mi mj"> // useReducer <br/> const reducer = (state, action) =&gt; {<br/>  ...rest of code<br/> }<br/> const [sliders, dispatch] = useReducer(reducer, sliderController)</span><span id="038e" class="jy jz iq mc b gy mk mh l mi mj"> // useEffect<br/> useEffect( () =&gt; {<br/>   dispatch('RESET')<br/> }, [windowWidth()])</span><span id="aebe" class="jy jz iq mc b gy mk mh l mi mj"> ...rest of code<br/>}</span></pre><h2 id="b152" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">内容</h2><p id="4fa5" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">内容是我从火星站点镜像的一组对象。为了便于组织，我将内容放入自己的名为<strong class="kw ir"> BottomSliderData.js </strong>的文件中，并将其导入主<strong class="kw ir"> BottomSlider.js </strong>组件。</p><pre class="lq lr ls lt gt mb mc md me aw mf bi"><span id="d90a" class="jy jz iq mc b gy mg mh l mi mj">// BottomSlider.js Component<br/>import sliderContent from './BottomSliderData'</span><span id="bcb9" class="jy jz iq mc b gy mk mh l mi mj">// BottomSliderData.js<br/>   export default[{<br/>     title: 'Curiosity',<br/>     value: '2440 SOLS ON MARS'<br/>   },...additional objects]</span></pre><h2 id="41bd" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">呈现内容</h2><p id="6f85" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">因为我喜欢推断任何循环结构(。map)从组件<strong class="kw ir">返回</strong>语句<strong class="kw ir">，</strong>我选择创建一个名为<strong class="kw ir"> renderSlickTrackSlides </strong>的变量，它存储映射到<strong class="kw ir"> sliderContent </strong>数组和创建单个slider元素的结果。</p><pre class="lq lr ls lt gt mb mc md me aw mf bi"><span id="501d" class="jy jz iq mc b gy mg mh l mi mj">const renderSlickTrackSlides = sliderContent.map( (d,i) =&gt; (<br/>  &lt;article className="slide" key={i}&gt;<br/>   &lt;div className="image_and_description_container"&gt;<br/>    &lt;div className="readout"&gt;<br/>     &lt;div className="title"&gt;{d.title}&lt;/div&gt;<br/>     &lt;div className="value"&gt;{d.value}&lt;/div&gt;<br/>    &lt;/div&gt;<br/>   &lt;/div&gt;<br/>   &lt;span className="circle_plus"&gt;&lt;/span&gt;<br/>  &lt;/article&gt;<br/>))</span></pre><p id="5bd4" class="pw-post-body-paragraph ku kv iq kw b kx lw kz la lb lx ld le kh ly lg lh kl lz lj lk kp ma lm ln lo ij bi translated">的。<strong class="kw ir"> slick-track </strong>将渲染那些元素，并且已经被分配了之前定义的<strong class="kw ir">slide track ref</strong>reference<strong class="kw ir"/>。</p><pre class="lq lr ls lt gt mb mc md me aw mf bi"><span id="ca58" class="jy jz iq mc b gy mg mh l mi mj">&lt;div className="slick-track" ref={slideTrackRef}&gt;  <br/>   {renderSlickTracks}<br/>&lt;/div&gt;</span></pre><p id="c6dd" class="pw-post-body-paragraph ku kv iq kw b kx lw kz la lb lx ld le kh ly lg lh kl lz lj lk kp ma lm ln lo ij bi translated">按钮被放置在<strong class="kw ir">的两侧。slick-list </strong>元素，并被分配了直接从火星站点提取的背景图像。谢谢NASA！</p><pre class="lq lr ls lt gt mb mc md me aw mf bi"><span id="376c" class="jy jz iq mc b gy mg mh l mi mj">&lt;section className="dashboard"&gt;<br/> &lt;div className="slide_container"&gt;<br/>  &lt;button className="slick-prev"&gt;&lt;/button&gt;<br/>  &lt;div className="slick-list"&gt;<br/>   &lt;div className="slick-track" ref={slideTrackRef} &gt;  <br/>    {renderSlickTracks}<br/>   &lt;/div&gt;<br/>   &lt;button className="slick-next"&lt;/button&gt;<br/>  &lt;/div&gt;<br/> &lt;/div&gt;<br/>&lt;/section&gt;</span></pre><h2 id="90c6" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">添加事件侦听器</h2><p id="6a2b" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">点击事件被添加到两个<strong class="kw ir">。slick-prev </strong>和<strong class="kw ir">。slick-next </strong>元素，并被配置为调用用户的<strong class="kw ir">分派</strong>方法，向其传递两个值之一:<strong class="kw ir"> "PREV" </strong>或<strong class="kw ir"> "NEXT" </strong>。</p><pre class="lq lr ls lt gt mb mc md me aw mf bi"><span id="3b34" class="jy jz iq mc b gy mg mh l mi mj">&lt;section className="dashboard"&gt;<br/> &lt;div className="slide_container"&gt;<br/>  &lt;button className="slick-prev" onClick={() =&gt; dispatch('PREV')}&gt;<br/>  &lt;/button&gt;<br/>   ...slick-list<br/>  &lt;button className="slick-next" onClick={() =&gt; dispatch('NEXT')}&gt;<br/>  &lt;/button&gt;<br/> &lt;/div&gt;<br/>&lt;/section&gt;</span></pre><h2 id="e925" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">显示正确数量的幻灯片</h2><p id="42d0" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">响应式设计在这个项目中一直占据优先地位，所以我创建了<strong class="kw ir"> windowWidth() </strong>函数，该函数返回<strong class="kw ir"> window.innerWidth </strong>的当前值。</p><p id="6b86" class="pw-post-body-paragraph ku kv iq kw b kx lw kz la lb lx ld le kh ly lg lh kl lz lj lk kp ma lm ln lo ij bi translated"><strong class="kw ir"> numOfVisibleSlides() </strong>函数调用windowWidth()并返回一个值，该值等于基于特定断点当前正在播放的幻灯片的数量。</p><pre class="lq lr ls lt gt mb mc md me aw mf bi"><span id="78cc" class="jy jz iq mc b gy mg mh l mi mj">const windowWidth = () =&gt; {<br/>  return window.innerWidth;<br/>};</span><span id="2193" class="jy jz iq mc b gy mk mh l mi mj">const numOfVisibleSides = () =&gt; {<br/>  switch (true) {<br/>   case windowWidth() &lt;= 767 :<br/>    return 1<br/>   case windowWidth() &lt;= 1023 :<br/>    return 2<br/>   default :<br/>    return 3<br/>  }<br/>}</span></pre><p id="7219" class="pw-post-body-paragraph ku kv iq kw b kx lw kz la lb lx ld le kh ly lg lh kl lz lj lk kp ma lm ln lo ij bi translated">创建了一个<strong class="kw ir"> sliderController </strong>对象来跟踪以下属性:</p><ul class=""><li id="5647" class="ml mm iq kw b kx lw lb lx kh mn kl mo kp mp lo mq mr ms mt bi translated"><strong class="kw ir"> numOfVisibleSlides: </strong>当前窗口宽度下可见的幻灯片数量</li><li id="e623" class="ml mm iq kw b kx mu lb mv kh mw kl mx kp my lo mq mr ms mt bi translated"><strong class="kw ir">numOfSliders:</strong>slider content数组的当前长度</li><li id="553b" class="ml mm iq kw b kx mu lb mv kh mw kl mx kp my lo mq mr ms mt bi translated"><strong class="kw ir"> translateValue: </strong>滑块的当前过渡值</li></ul><pre class="lq lr ls lt gt mb mc md me aw mf bi"><span id="19a3" class="jy jz iq mc b gy mg mh l mi mj">const sliderController = {<br/> numOfVisibleSlides: numOfVisibleSldies(),<br/> numOfSliders: sliderContent.length,<br/> translateValue: 0<br/>}</span></pre><h2 id="8d7a" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">使用用户管理下一个和上一个状态</h2><p id="da88" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">对于更复杂的状态管理，useReducer挂钩是一个很好的选择。如果您是useReducer的新手，那么额外的代码开销初看起来可能很大，但是，它是管理您的状态和应用程序逻辑的一个很好的工具，从而使它更加直观和可读。</p><p id="5968" class="pw-post-body-paragraph ku kv iq kw b kx lw kz la lb lx ld le kh ly lg lh kl lz lj lk kp ma lm ln lo ij bi translated">useReducer被传递了一个<strong class="kw ir"> reducer </strong>函数，该函数被绑定到<strong class="kw ir"> dispatch </strong>方法和绑定到<strong class="kw ir"> sliders </strong>变量的<strong class="kw ir"> sliderController </strong>数组。</p><pre class="lq lr ls lt gt mb mc md me aw mf bi"><span id="4dd1" class="jy jz iq mc b gy mg mh l mi mj">const [sliders, dispatch] = useReducer(reducer, sliderController)</span></pre><p id="5299" class="pw-post-body-paragraph ku kv iq kw b kx lw kz la lb lx ld le kh ly lg lh kl lz lj lk kp ma lm ln lo ij bi translated"><strong class="kw ir">【下一步】</strong>和<strong class="kw ir">【上一步】</strong>动作与当前分配给前进/后退按钮的事件监听器相关联。<strong class="kw ir">“重置”</strong>被添加以重置用户的用户状态，从而在window.innerWidth值改变时将滑块转换回其原始位置。</p><pre class="lq lr ls lt gt mb mc md me aw mf bi"><span id="9ad2" class="jy jz iq mc b gy mg mh l mi mj">function reducer(state,action) {<br/> switch(action) {<br/>  case 'RESET' :<br/>    return sliderController<br/>  case 'PREV' :<br/>   return handlePrev(state)<br/>  case 'NEXT' :<br/>   return handleNext(state)<br/>  default :<br/>   return state<br/> }<br/>}</span></pre><p id="4914" class="pw-post-body-paragraph ku kv iq kw b kx lw kz la lb lx ld le kh ly lg lh kl lz lj lk kp ma lm ln lo ij bi translated">useReducer利用switch语句，因为它比试图读取一系列if/else if/else语句更直观。</p><h2 id="efbb" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">走向</h2><p id="7676" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated"><strong class="kw ir"> handleNext() </strong>函数需要执行以下操作:</p><ul class=""><li id="7d76" class="ml mm iq kw b kx lw lb lx kh mn kl mo kp mp lo mq mr ms mt bi translated">计算沿水平轴向左转换的距离</li><li id="e946" class="ml mm iq kw b kx mu lb mv kh mw kl mx kp my lo mq mr ms mt bi translated">应用过渡并显示序列中的下一张幻灯片</li><li id="244f" class="ml mm iq kw b kx mu lb mv kh mw kl mx kp my lo mq mr ms mt bi translated">一旦达到幻灯片的最大数量限制，禁止进一步过渡</li><li id="2210" class="ml mm iq kw b kx mu lb mv kh mw kl mx kp my lo mq mr ms mt bi translated">返回包含这些更改的状态的新版本</li></ul><pre class="lq lr ls lt gt mb mc md me aw mf bi"><span id="5570" class="jy jz iq mc b gy mg mh l mi mj">function handleNext({numOfVisibleSlides, numOfSlides, translateValue}) {</span><span id="2367" class="jy jz iq mc b gy mk mh l mi mj">  if (numOfVisibleSlides &gt;= numOfSlides) {<br/>    return { numOfVisibleSlides, numOfSlides, translateValue }<br/>   }</span><span id="cff7" class="jy jz iq mc b gy mk mh l mi mj">  let value = numOfVisibleSides()</span><span id="9e43" class="jy jz iq mc b gy mk mh l mi mj">  translateValue += -(slideTrackWidth() / value);</span><span id="2be1" class="jy jz iq mc b gy mk mh l mi mj">  return {<br/>   numOfVisibleSlides: numOfVisibleSlides += 1,<br/>   numOfSlides,<br/>   translateValue<br/>  }<br/>}</span></pre><h2 id="9134" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">向后移动</h2><p id="2ba1" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated"><strong class="kw ir"> handlePrev() </strong>函数需要执行以下操作:</p><ul class=""><li id="43db" class="ml mm iq kw b kx lw lb lx kh mn kl mo kp mp lo mq mr ms mt bi translated">计算沿水平轴向右过渡的距离</li><li id="78a0" class="ml mm iq kw b kx mu lb mv kh mw kl mx kp my lo mq mr ms mt bi translated">应用过渡并显示序列中的下一张幻灯片</li><li id="52fd" class="ml mm iq kw b kx mu lb mv kh mw kl mx kp my lo mq mr ms mt bi translated">一旦达到幻灯片的基本限制，防止进一步过渡</li><li id="2da7" class="ml mm iq kw b kx mu lb mv kh mw kl mx kp my lo mq mr ms mt bi translated">返回包含这些更改的状态的新版本</li></ul><pre class="lq lr ls lt gt mb mc md me aw mf bi"><span id="09b2" class="jy jz iq mc b gy mg mh l mi mj">function handlePrev({numOfVisibleSlides, numOfSlides, translateValue}) {</span><span id="94b8" class="jy jz iq mc b gy mk mh l mi mj"> if (numOfVisibleSlides &lt;= numOfVisibleSides()) {<br/>  return { numOfVisibleSlides, numOfSlides, translateValue }<br/> }</span><span id="5b7e" class="jy jz iq mc b gy mk mh l mi mj"> let value = numOfVisibleSides()</span><span id="f0e2" class="jy jz iq mc b gy mk mh l mi mj"> translateValue += slideTrackWidth() / value;</span><span id="1721" class="jy jz iq mc b gy mk mh l mi mj"> return {<br/>  numOfVisibleSlides: numOfVisibleSlides -= 1,<br/>  numOfSlides,<br/>  translateValue<br/> }<br/>}</span></pre><p id="516f" class="pw-post-body-paragraph ku kv iq kw b kx lw kz la lb lx ld le kh ly lg lh kl lz lj lk kp ma lm ln lo ij bi translated">两个函数都调用<strong class="kw ir"> slideTrackWidth </strong>函数，该函数返回当前<strong class="kw ir">的宽度。光滑轨道</strong>。它的宽度将根据窗口宽度而变化。</p><pre class="lq lr ls lt gt mb mc md me aw mf bi"><span id="7437" class="jy jz iq mc b gy mg mh l mi mj">const slideTrackWidth = () =&gt; {<br/> return slideTrackRef.current.clientWidth;<br/>};</span></pre><h2 id="7611" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">结论</h2><p id="de3e" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">经过几次重构和一点点钩子魔术，我创建了一个可重用的响应组件。</p></div></div>    
</body>
</html>