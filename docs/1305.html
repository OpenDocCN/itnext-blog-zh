<html>
<head>
<title>Do-it-yourself: Client-side State Management — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自己动手:客户端状态管理—第2部分</h1>
<blockquote>原文：<a href="https://itnext.io/do-it-yourself-client-side-state-management-part-2-f1767b5bfc9b?source=collection_archive---------4-----------------------#2018-09-04">https://itnext.io/do-it-yourself-client-side-state-management-part-2-f1767b5bfc9b?source=collection_archive---------4-----------------------#2018-09-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a4ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kl translated">在上一篇文章中，我们已经研究了对可观察对象使用Flux statement管理流。我们添加了一个定制的<em class="ku"> BehaviorSubject </em>类，并将其合并到流中，以使流<strong class="jp ir">对状态变化做出反应</strong>。流程如下所示:</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi kv"><img src="../Images/b434e12290509a6d5d3c1317d1e25c2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bMKJz_g0BWrFukb0nDkhCg.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">电流</figcaption></figure><p id="a5a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将研究使用<strong class="jp ir">中间件</strong>的概念，并尝试将应用程序的一些业务逻辑转移到可重用的构建模块中。中间件将允许我们分解和简化更新应用程序状态的逻辑。</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi ll"><img src="../Images/d8821c3df249a864fc3355eeed10cd12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6A8AtjSi7L7f8CZmXOEP9w.png"/></div></div></figure><p id="dbcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="ku">中间件</em>就位后，我们将尝试在使用<strong class="jp ir">选择器</strong>从商店检索信息时实现可重用性和简单性。</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi ll"><img src="../Images/e921fda1dbf89eaecac83cdd6d7e2b15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yYMZqdKiImeVFvccmatIMg.png"/></div></div></figure></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h1 id="3401" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">密码</h1><p id="e830" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">完整的源代码共享在<a class="ae mw" href="https://github.com/justguy/MyTasks" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上。</p></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h1 id="5176" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">商店</h1><p id="7267" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">新的商店将利用上面提到的所有概念，并且足够通用，因此您可以将它用于任何需要的数据结构。</p><p id="bb49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">初始存储包含基本内容:状态和dispatcher，并公开方法来支持以前版本中使用的所有功能，但请注意，存储不包含任何业务逻辑。更新信息所需的所有逻辑将使用reducers提供。这保持了商店的清洁和可重复使用。</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">Redux存储的实现</figcaption></figure></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h1 id="a1c7" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">还原剂</h1><p id="767f" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">Reducers处理更新应用程序状态的逻辑。它们使用动作来激活，并返回状态的更新副本。行动包含使缩减者能够执行其工作的信息。</p><p id="ba9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的简单应用程序中，与业务逻辑相关的操作是面向任务的，那么我们需要什么呢？</p><ul class=""><li id="26f5" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated">装入(或取出)</li><li id="4050" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">设置所有任务</li><li id="10dc" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">更新任务</li><li id="8f7c" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">删除任务</li></ul><p id="5af5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们的任务操作文件如下所示:</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a6bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个动作都需要类型(字符串)和有效负载(对象)。meta是可选的，可以包含任何有助于跟踪或记录操作的信息。</p><p id="d9c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您会注意到每个任务都以<em class="ku">【Tasks】</em>前缀开始，这样我们就可以区分不同对象类型的类似任务。这些动作现在可以在一个reducer中使用了。目前我们只需要一个减速器- <em class="ku">任务减速器:</em></p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9aec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个reducer接收当前状态，操纵它，并返回更新的版本(存储中的第14行)。然后在存储中更新新的状态(存储中的第17行)。现在，我们的不可变存储可以处理变化，并检查所有与流量相关的内容。</p><p id="f003" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们添加新的缩减器时，我们需要小心并记住，将缩减器引入商店的顺序很重要，因为每个缩减器将在第一个缩减器之后添加，将从其前任获得更新的状态。</p></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h1 id="ee59" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">中间件</h1><p id="d7ae" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">由于reducers执行业务逻辑，在流程中有特定的工作，所以我们不会使用它们来执行其他类型的操作(如日志记录、获取等)。).这就是中间件发挥作用的地方。这些是可重用的curried函数，可以与我们使用的业务对象类型无关。</p><p id="10fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在初始化期间将它们提供给商店(与减速器相同)，并在减速器之前运行它们<strong class="jp ir">。</strong></p><p id="84b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的应用有3个<strong class="jp ir">核心中间件</strong>(位于<em class="ku">js/中间件/核心</em>下):</p><ul class=""><li id="ea83" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated"><em class="ku"> actionSplitter </em> —接受一组动作，并将其拆分为独立的动作，以便减速器处理</li><li id="f7a3" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated"><em class="ku"> api </em> —处理与api相关的操作(在本例中:fetch)</li><li id="3ac8" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated"><em class="ku">记录器</em> —将操作和状态变化记录到控制台</li></ul><p id="577c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们看看API中间件，我们可以看到它是通用的，可以从任何URL获取任何类型的中间件，这意味着它是可重用的:</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="3f0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当API中间件接收到获取信息的请求时，第一件事是发送请求继续处理(第4行)。为什么？因为当API操作完成时，会分派一个新的动作(第11、12行)。</p><p id="95b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还有一个在核心中间件和我们的业务逻辑之间“连接”的任务中间件——这是我们的<strong class="jp ir">功能中间件</strong>(位于<em class="ku"> js/middleware/feature </em>下):</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8931" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">任务中间件首先向下发送动作(第7行)，然后开始处理请求。您会注意到，例如，<em class="ku">FETCH _ TASKS("[TASKS]FETCH ")</em>分派了一个新的动作:API REQUEST("<em class="ku">[TASKS]API _ REQUEST</em>")，它由API中间件处理。</p><p id="694b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是为什么我们向商店提供中间件的顺序很重要:</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f286" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，现在我们可以向我们的商店添加中间件支持(第46–58行):</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="mx my l"/></div></figure></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h1 id="fb75" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">选择器</h1><p id="4d5b" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">选择器是从存储中检索信息的干净且可重用的方法。它们是可定制的，可以接受参数，并且知道状态的业务逻辑和结构。当使用选择器时，我们将所有与信息检索相关的逻辑放在一个公共位置，因此应用程序的其余部分不会因结构的改变而改变。从关注点分离的角度来看，这很好。</p><p id="32e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看任务选择器:</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9d86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该文件包括我们的应用程序所需的三个选择器:</p><ul class=""><li id="3b75" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated"><em class="ku">任务</em> —获取所有任务</li><li id="660f" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated"><em class="ku">任务</em> —根据ID获取具体的任务</li><li id="a938" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated"><em class="ku"> taskCount </em> —获取任务总数或已完成任务总数(是的，我可以使用第一个选择器，但是我的应用程序必须知道如何将任务定义为“完成”)</li></ul><p id="8496" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，显示已完成任务的计数器和总任务数是通过订阅状态更改和<em class="ku"> taskCount </em>选择器完成的:</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="mx my l"/></div></figure></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h1 id="bbdf" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">现在都在一起</h1><p id="15ac" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">当应用程序加载时，它创建一个新的存储，并传入所有中间件和reducer(<em class="ku">tasks app . js</em>):</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="3679" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">稍后，在呈现时，它订阅状态更改并设置所有需要的逻辑。最后，它调度<em class="ku"> fetchTasks() </em>，这是我们的ACTIONcreator，它创建请求商店加载任务列表的动作。</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="2647" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您查看控制台，您将能够看到正在运行的内容和信息传输:</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi nn"><img src="../Images/d9d08f9f030d7b64a184ede85c5b9226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_HrvSWLBwEttFXKotqOMLw.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">首次加载时控制台中的记录器输出</figcaption></figure><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi no"><img src="../Images/93377572a6f9ab818027fd035793462c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G2NbZLJqM6RK6KSYdcavqA.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">获取和设置任务操作</figcaption></figure><p id="d4cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你完成一个任务时，一个单独的动作被分派:<em class="ku">【任务】更新</em>:</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="gh gi np"><img src="../Images/fab96a11ba513dcfdcfcd1174842f64a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*J3Wc-AAZyXilz8WOR9Pbag.png"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">更新任务控制台输出包括所有必需的信息</figcaption></figure><p id="d155" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以看到第一个任务的<em class="ku"> completed </em>值已经从<em class="ku"> true </em>变为<em class="ku"> false </em>。记录器中的分组使得识别变更的来源和跟踪变得容易。</p><p id="5907" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在一切都像以前一样运行:</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/3f8f363cd16c2383d18f9d3c791df114.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/1*0gCNzshITVX-ptXn3l2Eew.gif"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">添加、更新和撤销正在工作！</figcaption></figure></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h1 id="7a93" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">下一步是什么？</h1><p id="53e1" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">现在我们已经有了一个<em class="ku">完美的</em>小应用程序(呵呵)和一个非常简单的基础设施，我们可以开始考虑扩展了:</p><ul class=""><li id="1b46" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated">通过避免不必要的更新来提高性能</li><li id="2e2d" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">添加外部API支持</li><li id="0e22" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">添加更多数据结构</li><li id="5954" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">添加对自动更新/重复任务的支持</li><li id="1a7b" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">使用外部工具(如Redux DevTools)</li></ul><p id="93f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">敬请关注。</p></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h1 id="d371" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">参考</h1><p id="c216" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">项目结构很大程度上基于<a class="nr ns ep" href="https://medium.com/u/91e7a417e575?source=post_page-----f1767b5bfc9b--------------------------------" rel="noopener" target="_blank"> Nir Kaufman </a>的书<a class="ae mw" href="https://leanpub.com/thinking-in-Redux" rel="noopener ugc nofollow" target="_blank">在Redux </a>中思考。</p><p id="5142" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">@pearlmcphee有一篇关于选择器的很棒的文章。</p></div></div>    
</body>
</html>