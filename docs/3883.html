<html>
<head>
<title>Encrypt data with a password in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中使用密码加密数据</h1>
<blockquote>原文：<a href="https://itnext.io/encrypt-data-with-a-password-in-go-b5366384e291?source=collection_archive---------1-----------------------#2020-03-18">https://itnext.io/encrypt-data-with-a-password-in-go-b5366384e291?source=collection_archive---------1-----------------------#2020-03-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d5ae30e61536c23cd4839666c1f50b9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Jy250MvJVLAIn5I8"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@shaneavery?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">谢恩·艾弗里</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="b659" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h1><p id="1f1d" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当我们加密数据时，通常我们会创建一个随机密钥来解密该数据。在某些特定情况下，人们希望使用用户指定的密钥来解密数据，就像密码一样。然而，用于加密算法的密钥通常需要至少32个字节。但是，很可能我们的密码达不到这个标准，所以我们需要一个解决方案。最近，我需要这样一种方法，在这篇文章中，我将列出我所做的来解决这个问题。但在我们进入实质之前。</p><p id="4ab8" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">免责声明</strong>:我不是加密专家，我已经提到了我在这篇文章中提供的解决方案的来源。我恳求你阅读/观看这些资料来更好地理解它。同样，如果帖子/代码中有任何错误，请让我知道或留下评论，以便我可以更新它，这样就不会有错误的方法/技术的延续。</p><p id="825d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">好了，既然我们已经解决了这个问题，让我们开始吧！(注:你也可以在这里查看这个帖子<a class="ae kc" href="https://bruinsslot.jp/post/golang-crypto" rel="noopener ugc nofollow" target="_blank">)</a></p><h1 id="af1a" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">加密</h1><p id="5a57" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们首先从加密我们的数据开始。我们将从创建接受一个<code class="fe me mf mg mh b">key</code>和一个<code class="fe me mf mg mh b">data</code>参数的<code class="fe me mf mg mh b">Encrypt</code>函数开始。基于此，我们将使用<code class="fe me mf mg mh b">key</code>对可以解密的数据进行加密。首先，我们将使用32个随机字节生成密钥，稍后我们将用我们的密码替换它。下面显示了能够加密我们的数据的代码，由生成的密钥提供。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1a5b" class="mq ke iq mh b gy mr ms l mt mu">import (<br/>    "crypto/aes"<br/>    "crypto/cipher"<br/>    "crypto/rand"<br/>)<br/><br/>func Encrypt(key, data []byte) ([]byte, error) {<br/>    blockCipher, err := aes.NewCipher(key)<br/>    if err != nil {<br/>        return nil, err<br/>    }<br/><br/>    gcm, err := cipher.NewGCM(blockCipher)<br/>    if err != nil {<br/>        return nil, err<br/>    }<br/><br/>    nonce := make([]byte, gcm.NonceSize())<br/>    if _, err = rand.Read(nonce); err != nil {<br/>        return nil, err<br/>    }<br/><br/>    ciphertext := gcm.Seal(nonce, nonce, data, nil)<br/><br/>    return ciphertext, nil<br/>}</span></pre><p id="fa4b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">所以，让我们检查一下代码，看看我们在做什么。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ed0a" class="mq ke iq mh b gy mr ms l mt mu">func Encrypt(key, data []byte) ([]byte, error)</span></pre><p id="8d6d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">首先，我们开始创建我们的<code class="fe me mf mg mh b">Encrypt</code>函数，它将接受一个<code class="fe me mf mg mh b">key</code>和一个<code class="fe me mf mg mh b">data</code>参数。我们将使用一个<code class="fe me mf mg mh b">byte</code>切片代替一个<code class="fe me mf mg mh b">io.Reader</code>作为<code class="fe me mf mg mh b">data</code>参数。而使用<code class="fe me mf mg mh b">io.Reader</code>将允许我们对实现<code class="fe me mf mg mh b">io.Reader</code>接口的所有其他类型使用<code class="fe me mf mg mh b">Encrypt</code>函数。(Ryer <a class="ae kc" href="https://gist.github.com/erroneousboat/d01e57e3c0470c645e72ae663c7955fa#ref-ryer2015" rel="noopener ugc nofollow" target="_blank"> 2015 </a>)然而，正是因为<code class="fe me mf mg mh b">io.Reader</code>作为数据流的性质，当我们想要解密<code class="fe me mf mg mh b">ciphertext</code>时，我们需要看到它的整体。一种解决方案是将流分成离散的块，然而这将大大增加问题的复杂性。<a class="ae kc" href="#f6d0" rel="noopener ugc nofollow"/>(iso<a class="ae kc" href="#efb4" rel="noopener ugc nofollow">2015</a>)</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7465" class="mq ke iq mh b gy mr ms l mt mu">blockCipher, err := aes.NewCipher(key)</span></pre><p id="597a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们正在根据我们提供的<code class="fe me mf mg mh b">key</code>初始化分组密码。这里我们使用的是<code class="fe me mf mg mh b">crypto/aes</code> <a class="ae kc" href="#63b9" rel="noopener ugc nofollow"> </a>包，它实现了AES <a class="ae kc" href="#5627" rel="noopener ugc nofollow"> </a> <a class="ae kc" href="#bf25" rel="noopener ugc nofollow"> ⁴ </a>(高级加密标准)加密算法。AES是一种对称密钥加密算法，对于现代用例来说足够安全。此外，AES在大多数平台上使用硬件加速，因此使用起来会非常快。(坦克斯利<a class="ae kc" href="#985d" rel="noopener ugc nofollow"> 2016 </a>)</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cfb1" class="mq ke iq mh b gy mr ms l mt mu">gcm, err := cipher.NewGCM(blockCipher)</span></pre><p id="1469" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这里我们用特定的<em class="mv">模式</em>包装分组密码。我们这样做是因为我们不应该直接使用一个<code class="fe me mf mg mh b">cipher.Block</code>接口。这是因为分组密码只加密16字节的数据，仅此而已。所以如果你调用<code class="fe me mf mg mh b">blockCiper.Encrypt()</code>，它只会加密前16个字节。因此，我们需要在此之上的东西，包装分组密码，这些被称为<em class="mv">模式</em>。同样，我们有几种<em class="mv">模式</em>可供选择，这里我们将使用<em class="mv">伽罗瓦计数器模式</em> (GCM) <a class="ae kc" href="#4df4" rel="noopener ugc nofollow"> ⁵ </a>，具有标准随机数长度。</p><p id="4c4a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">只有GCM提供认证加密，它实现了<code class="fe me mf mg mh b">cipher.AEAD</code>接口(认证加密和相关数据)<a class="ae kc" href="#810e" rel="noopener ugc nofollow"> ⁶ </a>。认证加密意味着你的数据不仅是机密的、秘密的和加密的，而且现在是防篡改的。如果有人改变了<code class="fe me mf mg mh b">ciphertext</code>，你将无法有效地解密它。当你使用认证加密时，如果有人篡改了你的数据，它就无法解密。(坦克斯利<a class="ae kc" href="#985d" rel="noopener ugc nofollow">2016</a>；2015年</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5856" class="mq ke iq mh b gy mr ms l mt mu">nonce := make([]byte, gcm.NonceSize())<br/>if _, err = rand.Read(nonce); err != nil {<br/>    return nil, err<br/>}</span></pre><p id="1605" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在加密我们的字节之前，我们需要生成一个随机化的<code class="fe me mf mg mh b">nonce</code>，它的长度由GCM指定。<code class="fe me mf mg mh b">nonce</code>代表:<em class="mv">号曾经使用过</em>，是一段不应该重复的数据，并且只能与任何特定的键组合使用一次。含义:不要重复一个<code class="fe me mf mg mh b">key</code>和一个<code class="fe me mf mg mh b">nonce</code>的组合超过一次。但是，你如何保持跟踪呢？如果我们对一个<code class="fe me mf mg mh b">nonce</code>使用足够大的数字，我们可能对这个用例没问题。(Isom<a class="ae kc" href="#efb4" rel="noopener ugc nofollow">2015</a>；Viega和Messier <a class="ae kc" href="#be38" rel="noopener ugc nofollow"> 2003 </a>，134-35)我们通过使用Go的<code class="fe me mf mg mh b">crypto/rand</code>包将随机字节读入<code class="fe me mf mg mh b">nonce</code>字节片来实现。<a class="ae kc" href="#c9f0" rel="noopener ugc nofollow"> ⁷ </a></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2be2" class="mq ke iq mh b gy mr ms l mt mu">encryptedData := gcm.Seal(nonce, nonce, bData, nil)</span></pre><p id="809d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们将用来加密数据的<code class="fe me mf mg mh b">nonce</code>也需要用来解密数据。所以我们需要能够在解密的时候引用它，策略之一就是把它加到加密的数据里。在这个例子中，我们将把<code class="fe me mf mg mh b">nonce</code>加到加密数据的前面。我们通过将<code class="fe me mf mg mh b">nonce</code>作为<code class="fe me mf mg mh b">Seal</code>函数的第一个参数<code class="fe me mf mg mh b">dst</code>传入来实现这一点，因此加密的数据将被附加到它的后面。<a class="ae kc" href="#1aa0" rel="noopener ugc nofollow"> ⁸ </a>我们可以做到这一点，因为<code class="fe me mf mg mh b">nonce</code>不一定要保密，它只需要独一无二。(坦克斯利<a class="ae kc" href="#985d" rel="noopener ugc nofollow"> 2016 </a>)</p><h1 id="8953" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">解释</h1><p id="1443" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">现在，我们能够加密我们的数据，让我们实现<code class="fe me mf mg mh b">Decrypt</code>函数。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fb1b" class="mq ke iq mh b gy mr ms l mt mu">import (<br/>    "crypto/aes"<br/>    "crypto/cipher"<br/>)</span><span id="b555" class="mq ke iq mh b gy mw ms l mt mu">func Decrypt(key, data []byte) ([]byte, error) {<br/>    blockCipher, err := aes.NewCipher(key)<br/>    if err != nil {<br/>        return nil, err<br/>    }</span><span id="3d5f" class="mq ke iq mh b gy mw ms l mt mu">    gcm, err := cipher.NewGCM(blockCipher)<br/>    if err != nil {<br/>        return nil, err<br/>    }</span><span id="f942" class="mq ke iq mh b gy mw ms l mt mu">   nonce, ciphertext := data[:gcm.NonceSize()], data[gcm.NonceSize():]</span><span id="d8a3" class="mq ke iq mh b gy mw ms l mt mu">    plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)<br/>    if err != nil {<br/>        return nil, err<br/>    }</span><span id="4f8c" class="mq ke iq mh b gy mw ms l mt mu">    return plaintext, nil<br/>}</span></pre><p id="594e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">让我们再次检查代码，看看它做了什么。它与<code class="fe me mf mg mh b">Encrypt</code>函数的代码基本相同，所以让我们检查不同的部分。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="011e" class="mq ke iq mh b gy mr ms l mt mu">nonce, ciphertext := data[:gcm.NonceSize()], data[gcm.NonceSize():]</span></pre><p id="6c59" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">还记得在上一节中，我们使用<code class="fe me mf mg mh b">gcm.Seal</code>在<code class="fe me mf mg mh b">data</code>前添加了<code class="fe me mf mg mh b">nonce</code>来创建<code class="fe me mf mg mh b">ciphertext</code>吗？现在我们需要拆分这些部分，这样我们就可以独立使用它们了。我们通过根据<code class="fe me mf mg mh b">gcm</code>提供的<code class="fe me mf mg mh b">nonce</code>的大小分割<code class="fe me mf mg mh b">data</code>来创建这些部分。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5bec" class="mq ke iq mh b gy mr ms l mt mu">plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)</span></pre><p id="5515" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">现在，我们使用<code class="fe me mf mg mh b">gcm.Open</code>将<code class="fe me mf mg mh b">ciphertext</code>解密成<code class="fe me mf mg mh b">plaintext</code>。<a class="ae kc" href="#9327" rel="noopener ugc nofollow"> ⁹ </a></p><h1 id="783a" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">钥匙</h1><p id="cbf0" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们已经向<code class="fe me mf mg mh b">Encrypt</code>和<code class="fe me mf mg mh b">Decrypt</code>函数传递了一个<code class="fe me mf mg mh b">key</code>，但是我们还没有创建它，所以让我们开始吧。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5aeb" class="mq ke iq mh b gy mr ms l mt mu">import (<br/>    "crypto/rand"<br/>)</span><span id="9797" class="mq ke iq mh b gy mw ms l mt mu">func GenerateKey() ([]byte, error) {<br/>    key := make([]byte, 32)</span><span id="63b5" class="mq ke iq mh b gy mw ms l mt mu">    _, err := rand.Read(key)<br/>    if err != nil {<br/>        return nil, err<br/>    }</span><span id="6755" class="mq ke iq mh b gy mw ms l mt mu">    return key, nil<br/>}</span></pre><p id="72b1" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这里我们使用Go的<code class="fe me mf mg mh b">crypto/rand</code>包生成一个随机的<code class="fe me mf mg mh b">key</code>。对于AES，我们需要一个长度为32字节的<code class="fe me mf mg mh b">key</code>,所以我们制作一个大小为32的字节片。然后我们让<code class="fe me mf mg mh b">rand.Read()</code>用随机字节填充切片。<a class="ae kc" href="#dcc0" rel="noopener ugc nofollow"> ⁰ </a></p><p id="6ed8" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">现在我们已经有足够的信息来加密和解密一些数据，所以让我们把它们放在一起并进行测试:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="02c0" class="mq ke iq mh b gy mr ms l mt mu">// crypto.go<br/>package main</span><span id="7efc" class="mq ke iq mh b gy mw ms l mt mu">import (<br/>    "crypto/aes"<br/>    "crypto/cipher"<br/>    "crypto/rand"<br/>    "encoding/hex"<br/>    "fmt"<br/>    "log"<br/>)</span><span id="e77d" class="mq ke iq mh b gy mw ms l mt mu">func Encrypt(key, data []byte) ([]byte, error) {<br/>    blockCipher, err := aes.NewCipher(key)<br/>    if err != nil {<br/>        return nil, err<br/>    }</span><span id="200c" class="mq ke iq mh b gy mw ms l mt mu">    gcm, err := cipher.NewGCM(blockCipher)<br/>    if err != nil {<br/>        return nil, err<br/>    }</span><span id="8b3b" class="mq ke iq mh b gy mw ms l mt mu">    nonce := make([]byte, gcm.NonceSize())<br/>    if _, err = rand.Read(nonce); err != nil {<br/>        return nil, err<br/>    }</span><span id="a830" class="mq ke iq mh b gy mw ms l mt mu">    ciphertext := gcm.Seal(nonce, nonce, data, nil)</span><span id="3496" class="mq ke iq mh b gy mw ms l mt mu">    return ciphertext, nil<br/>}</span><span id="32b6" class="mq ke iq mh b gy mw ms l mt mu">func Decrypt(key, data []byte) ([]byte, error) {<br/>    blockCipher, err := aes.NewCipher(key)<br/>    if err != nil {<br/>        return nil, err<br/>    }</span><span id="3c47" class="mq ke iq mh b gy mw ms l mt mu">    gcm, err := cipher.NewGCM(blockCipher)<br/>    if err != nil {<br/>        return nil, err<br/>    }</span><span id="a395" class="mq ke iq mh b gy mw ms l mt mu">    nonce, ciphertext := data[:gcm.NonceSize()], data[gcm.NonceSize():]</span><span id="d9d9" class="mq ke iq mh b gy mw ms l mt mu">    plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)<br/>    if err != nil {<br/>        return nil, err<br/>    }</span><span id="7276" class="mq ke iq mh b gy mw ms l mt mu">    return plaintext, nil<br/>}</span><span id="b933" class="mq ke iq mh b gy mw ms l mt mu">func GenerateKey() ([]byte, error) {<br/>    key := make([]byte, 32)</span><span id="fdc5" class="mq ke iq mh b gy mw ms l mt mu">    _, err := rand.Read(key)<br/>    if err != nil {<br/>        return nil, err<br/>    }</span><span id="b947" class="mq ke iq mh b gy mw ms l mt mu">    return key, nil<br/>}</span><span id="7bf4" class="mq ke iq mh b gy mw ms l mt mu">func main() {<br/>    data := []byte("our super secret text")</span><span id="888f" class="mq ke iq mh b gy mw ms l mt mu">    key, err := GenerateKey()<br/>    if err != nil {<br/>        log.Fatal(err)<br/>    }</span><span id="ab98" class="mq ke iq mh b gy mw ms l mt mu">    ciphertext, err := Encrypt(key, data)<br/>    if err != nil {<br/>        log.Fatal(err)<br/>    }</span><span id="b5e4" class="mq ke iq mh b gy mw ms l mt mu">    fmt.Printf("ciphertext: %s\n", hex.EncodeToString(ciphertext))</span><span id="5e64" class="mq ke iq mh b gy mw ms l mt mu">    plaintext, err := Decrypt(key, ciphertext)<br/>    if err != nil {<br/>        log.Fatal(err)<br/>    }</span><span id="44f0" class="mq ke iq mh b gy mw ms l mt mu">    fmt.Printf("plaintext: %s\n", plaintext)<br/>}</span></pre><p id="fc1b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">并且，我们可以使用以下代码运行此示例:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7c0d" class="mq ke iq mh b gy mr ms l mt mu">$ go run crypto.go</span></pre><p id="f10c" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">现在，我们有足够的东西用一个随机密钥来加密和解密我们的<code class="fe me mf mg mh b">data</code>。这很酷，现在我们有了一个允许我们加密和解密我们的<code class="fe me mf mg mh b">data</code>的<code class="fe me mf mg mh b">key</code>。但是这意味着<code class="fe me mf mg mh b">key</code>现在变成了我们的密码，我们不能自己选择，另外它有32个字节的长度。</p><p id="cff2" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">但是，正如帖子开头提到的，我们希望能够通过提供我们自己的<code class="fe me mf mg mh b">key</code>即我们选择使用的密码来加密和解密数据。我们将在下一节中完成这项工作。</p><h1 id="087b" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">密码</h1><p id="c812" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">现在，<code class="fe me mf mg mh b">aes.NewCipher()</code>需要一个16、24或32字节的<code class="fe me mf mg mh b">key</code>，在这个例子中我们使用的是一个32字节的<code class="fe me mf mg mh b">key</code>。然而，我们的密码可能不会是32字节。所以我们需要将我们的密码转换成一个合适的<code class="fe me mf mg mh b">key</code>。我们通过使用<em class="mv">密钥派生函数</em> (KDF) <a class="ae kc" href="#89bb" rel="noopener ugc nofollow"> </a>来“延伸”密码，使其成为合适的加密密钥。这个按键拉伸<a class="ae kc" href="#3f07" rel="noopener ugc nofollow"> </a>的特点就是慢。这样做是为了使攻击者需要花费大量的资源来试图对密码进行暴力攻击。我们有几个KDF的选项:Argon2 <a class="ae kc" href="#ea51" rel="noopener ugc nofollow"> </a>、scrypt <a class="ae kc" href="#a85f" rel="noopener ugc nofollow"> ⁴ </a>、bcrypt <a class="ae kc" href="#38e8" rel="noopener ugc nofollow"> ⁵ </a>和pbkdf2 <a class="ae kc" href="#af62" rel="noopener ugc nofollow"> ⁶ </a>。选择哪一个取决于几个因素，但主要是它有多安全。<a class="ae kc" href="#3055" rel="noopener ugc nofollow">⁷</a>t20】⁸t22】⁹t24】⁰<a class="ae kc" href="#0c55" rel="noopener ugc nofollow"/><a class="ae kc" href="#f629" rel="noopener ugc nofollow"/></p><p id="a4bf" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">典型地，在KDF中，我们有一个<code class="fe me mf mg mh b">password</code>、一个<code class="fe me mf mg mh b">salt</code>和一个<code class="fe me mf mg mh b">iterations</code>自变量。<code class="fe me mf mg mh b">salt</code> <a class="ae kc" href="#fcb3" rel="noopener ugc nofollow"> </a>用于防止攻击者仅存储密码/密钥对，并防止攻击者预先计算派生密钥的字典，因为不同的salt产生不同的输出。每个密码都必须用用于导出密钥的<code class="fe me mf mg mh b">salt</code>进行检查。(Isom<a class="ae kc" href="#efb4" rel="noopener ugc nofollow">2015</a>；维基百科<a class="ae kc" href="#7ac3" rel="noopener ugc nofollow"> 2020 </a>)其中<code class="fe me mf mg mh b">salt</code>与<code class="fe me mf mg mh b">nonce</code>相关，也需要随机生成。和<code class="fe me mf mg mh b">nonce</code>一样，<code class="fe me mf mg mh b">salt</code>不需要保密，它需要独一无二。<code class="fe me mf mg mh b">iterations</code>参数或<em class="mv">难度参数</em>，表示重复该过程的次数。这是因为，即使有了<code class="fe me mf mg mh b">salt</code>，一个<em class="mv">字典攻击</em>仍然是可能的，但是有了<code class="fe me mf mg mh b">iterations</code>计数，它将减慢从一个密码计算一个<code class="fe me mf mg mh b">key</code>的时间。(维耶加和梅西耶<a class="ae kc" href="#be38" rel="noopener ugc nofollow"> 2003 </a>，141-42)</p><p id="4a74" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在这个例子中，我们将使用<em class="mv"> scrypt </em>，所以让我们看看如何在我们的程序中实现它。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2f81" class="mq ke iq mh b gy mr ms l mt mu">import (<br/>    "crypto/rand"</span><span id="4b71" class="mq ke iq mh b gy mw ms l mt mu">    "golang.org/x/crypto/scrypt"<br/>)</span><span id="0ce8" class="mq ke iq mh b gy mw ms l mt mu">func DeriveKey(password, salt []byte) ([]byte, []byte, error) {<br/>    if salt == nil {<br/>        salt = make([]byte, 32)<br/>        if _, err := rand.Read(salt); err != nil {<br/>            return nil, nil, err<br/>        }<br/>    }</span><span id="c0b2" class="mq ke iq mh b gy mw ms l mt mu">    key, err := scrypt.Key(password, salt, 1048576, 8, 1, 32)<br/>    if err != nil {<br/>        return nil, nil, err<br/>    }</span><span id="34cf" class="mq ke iq mh b gy mw ms l mt mu">    return key, salt, nil<br/>}</span></pre><p id="d6ca" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">让我们再次检查代码，看看它做了什么。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8bc4" class="mq ke iq mh b gy mr ms l mt mu">func DeriveKey(password, salt []byte) ([]byte, []byte, error)</span></pre><p id="82f5" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这里我们接受作为参数的一部分字节的密码，并返回结果<code class="fe me mf mg mh b">key</code>和<code class="fe me mf mg mh b">salt</code>。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8462" class="mq ke iq mh b gy mr ms l mt mu">salt := make([]byte, 32)<br/>if _, err := rand.Read(salt); err != nil {<br/>    return err<br/>}</span></pre><p id="66f4" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">就像我们的<code class="fe me mf mg mh b">Encrypt</code>函数一样，我们将用32个随机字节创建<code class="fe me mf mg mh b">salt</code>。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c0c8" class="mq ke iq mh b gy mr ms l mt mu">key, err := scrypt.Key(password, salt, 1048576, 8, 1, 32)</span></pre><p id="e91e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这里我们使用来自<code class="fe me mf mg mh b">golang.org/x/</code>库的<code class="fe me mf mg mh b">scrypt</code>包。<a class="ae kc" href="#e5f2" rel="noopener ugc nofollow"> ⁴ </a>从文档中我们可以看到<code class="fe me mf mg mh b">Key</code>函数接受以下参数:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c0f4" class="mq ke iq mh b gy mr ms l mt mu">func Key(password, salt []byte, N, r, p, keyLen int) ([]byte, error)</span></pre><p id="00fd" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">论点<code class="fe me mf mg mh b">password</code>和<code class="fe me mf mg mh b">salt</code>不言自明。<code class="fe me mf mg mh b">N</code>是迭代的次数。在C. Percival给出的演示中，建议对于交互式登录使用16384 (2^14)迭代，对于文件加密使用1048576 (2^20)迭代。(珀西瓦尔<a class="ae kc" href="#bbcd" rel="noopener ugc nofollow"> 2005a </a>，<a class="ae kc" href="#3f6a" rel="noopener ugc nofollow">2005 b</a>；Isom <a class="ae kc" href="#efb4" rel="noopener ugc nofollow"> 2015 </a>自变量<code class="fe me mf mg mh b">r</code>和<code class="fe me mf mg mh b">p</code>必须满足<em class="mv">r</em>*<em class="mv">p</em>&lt;2^30，如果不满足限制，函数返回一个<code class="fe me mf mg mh b">nil</code>字节片和一个错误。(Golang文档<a class="ae kc" href="#ea28" rel="noopener ugc nofollow"> 2020 </a>)。<code class="fe me mf mg mh b">r</code>参数定义了相对内存开销参数，它控制底层哈希中的块大小，建议值为8。<code class="fe me mf mg mh b">p</code>参数是相对CPU成本参数，其推荐值为1。(Isom<a class="ae kc" href="#efb4" rel="noopener ugc nofollow">2015</a>；Percival <a class="ae kc" href="#bbcd" rel="noopener ugc nofollow"> 2005a </a>)参数<code class="fe me mf mg mh b">keyLen</code>定义了作为键返回的字节长度，如前所述，这将是32个字节。</p><h1 id="e6a0" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结果</h1><p id="556c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">现在我们已经创建了我们的<code class="fe me mf mg mh b">DeriveKey</code>函数，我们需要更新我们的代码来支持它。让我们这样做，它应该类似于下面的代码:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="441e" class="mq ke iq mh b gy mr ms l mt mu">// scrypt.go<br/>package main</span><span id="457d" class="mq ke iq mh b gy mw ms l mt mu">import (<br/>    "crypto/aes"<br/>    "crypto/cipher"<br/>    "crypto/rand"<br/>    "crypto/sha256"<br/>    "encoding/hex"<br/>    "fmt"<br/>    "log"</span><span id="91b9" class="mq ke iq mh b gy mw ms l mt mu">    "golang.org/x/crypto/scrypt"<br/>)</span><span id="0049" class="mq ke iq mh b gy mw ms l mt mu">func Encrypt(key, data []byte) ([]byte, error) {<br/>    key, salt, err := DeriveKey(key, nil)<br/>    if err != nil {<br/>        return nil, err<br/>    }</span><span id="04fa" class="mq ke iq mh b gy mw ms l mt mu">    blockCipher, err := aes.NewCipher(key)<br/>    if err != nil {<br/>        return nil, err<br/>    }</span><span id="62e0" class="mq ke iq mh b gy mw ms l mt mu">    gcm, err := cipher.NewGCM(blockCipher)<br/>    if err != nil {<br/>        return nil, err<br/>    }</span><span id="b15f" class="mq ke iq mh b gy mw ms l mt mu">    nonce := make([]byte, gcm.NonceSize())<br/>    if _, err = rand.Read(nonce); err != nil {<br/>        return nil, err<br/>    }</span><span id="442d" class="mq ke iq mh b gy mw ms l mt mu">    ciphertext := gcm.Seal(nonce, nonce, data, nil)</span><span id="888c" class="mq ke iq mh b gy mw ms l mt mu">    ciphertext = append(ciphertext, salt...)</span><span id="0cfa" class="mq ke iq mh b gy mw ms l mt mu">    return ciphertext, nil<br/>}</span><span id="79c4" class="mq ke iq mh b gy mw ms l mt mu">func Decrypt(key, data []byte) ([]byte, error) {<br/>    salt, data := data[len(data)-32:], data[:len(data)-32]</span><span id="e465" class="mq ke iq mh b gy mw ms l mt mu">    key, _, err := DeriveKey(key, salt)<br/>    if err != nil {<br/>        return nil, err<br/>    }</span><span id="3193" class="mq ke iq mh b gy mw ms l mt mu">    blockCipher, err := aes.NewCipher(key)<br/>    if err != nil {<br/>        return nil, err<br/>    }</span><span id="4d90" class="mq ke iq mh b gy mw ms l mt mu">    gcm, err := cipher.NewGCM(blockCipher)<br/>    if err != nil {<br/>        return nil, err<br/>    }</span><span id="3dfa" class="mq ke iq mh b gy mw ms l mt mu">    nonce, ciphertext := data[:gcm.NonceSize()], data[gcm.NonceSize():]</span><span id="9355" class="mq ke iq mh b gy mw ms l mt mu">    plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)<br/>    if err != nil {<br/>        return nil, err<br/>    }</span><span id="0f25" class="mq ke iq mh b gy mw ms l mt mu">    return plaintext, nil<br/>}</span><span id="9cda" class="mq ke iq mh b gy mw ms l mt mu">func DeriveKey(password, salt []byte) ([]byte, []byte, error) {<br/>    if salt == nil {<br/>        salt = make([]byte, 32)<br/>        if _, err := rand.Read(salt); err != nil {<br/>            return nil, nil, err<br/>        }<br/>    }</span><span id="e259" class="mq ke iq mh b gy mw ms l mt mu">    key, err := scrypt.Key(password, salt, 1048576, 8, 1, 32)<br/>    if err != nil {<br/>        return nil, nil, err<br/>    }</span><span id="1110" class="mq ke iq mh b gy mw ms l mt mu">    return key, salt, nil<br/>}</span><span id="b142" class="mq ke iq mh b gy mw ms l mt mu">func main() {<br/>    var (<br/>        password = []byte("mysecretpassword")<br/>        data     = []byte("our super secret text")<br/>    )</span><span id="33a3" class="mq ke iq mh b gy mw ms l mt mu">    ciphertext, err := Encrypt(password, data)<br/>    if err != nil {<br/>        log.Fatal(err)<br/>    }</span><span id="2e0a" class="mq ke iq mh b gy mw ms l mt mu">    fmt.Printf("ciphertext: %s\n", hex.EncodeToString(ciphertext))</span><span id="ceb7" class="mq ke iq mh b gy mw ms l mt mu">    plaintext, err := Decrypt(password, ciphertext)<br/>    if err != nil {<br/>        log.Fatal(err)<br/>    }</span><span id="62f3" class="mq ke iq mh b gy mw ms l mt mu">    fmt.Printf("plaintext: %s\n", plaintext)<br/>}</span></pre><p id="15bf" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">而且，我们能够运行和测试它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e71f" class="mq ke iq mh b gy mr ms l mt mu"># First we need to get the scrypt package<br/>$ go get -u golang.org/x/crypto/scrypt</span><span id="716d" class="mq ke iq mh b gy mw ms l mt mu">$ go run scrypt.go</span></pre><p id="5ffe" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们已经更新了一些部分，所以让我们过一遍。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="74f4" class="mq ke iq mh b gy mr ms l mt mu">key, salt, err := DeriveKey(key, nil)</span></pre><p id="29d8" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在<code class="fe me mf mg mh b">Encrypt</code>函数中，我们通过传递包含在<code class="fe me mf mg mh b">key</code>参数中的密码来创建我们的密钥。我们将<code class="fe me mf mg mh b">nil</code>作为salt参数传入，这是因为我们想要创建<code class="fe me mf mg mh b">salt</code>，因为这是我们第一次加密<code class="fe me mf mg mh b">data</code>。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7149" class="mq ke iq mh b gy mr ms l mt mu">ciphertext = append(ciphertext, salt...)</span></pre><p id="8c42" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">此外，在<code class="fe me mf mg mh b">Encrypt</code>函数中，我们将<code class="fe me mf mg mh b">salt</code>追加到<code class="fe me mf mg mh b">ciphertext</code>中。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c1ce" class="mq ke iq mh b gy mr ms l mt mu">salt, data := data[len(data)-32:], data[:len(data)-32]</span></pre><p id="930e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">而且，因为我们将<code class="fe me mf mg mh b">salt</code>追加到了<code class="fe me mf mg mh b">ciphertext</code>，我们需要在<code class="fe me mf mg mh b">Decrypt</code>函数中对其进行分割，因为我们将在<code class="fe me mf mg mh b">DeriveKey</code>函数中使用它。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bd3e" class="mq ke iq mh b gy mr ms l mt mu">key, _, err := DeriveKey(key, salt)</span></pre><p id="9483" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">正如您在这里看到的，我们将salt传递给<code class="fe me mf mg mh b">DeriveKey</code>函数，我们将能够检索到我们用来加密数据的<code class="fe me mf mg mh b">key</code>。</p><h1 id="a50c" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="cbcd" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">因此，我们创建了两种方法来加密和解密Go中的数据。首先，我们使用AES加密算法对数据进行加密，为此我们创建了一个用于解密数据的随机密钥。随后，我们更新了代码以支持使用密码作为我们的密钥。我们已经通过使用<em class="mv">密钥派生函数</em>对我们的密码进行<em class="mv">密钥扩展</em>来实现这一点，并且我们已经使用<em class="mv"> scrypt </em>来实现这一点。希望这篇文章对你有用，我再次建议你阅读和观看我列出的资源，并查看其他资源，以全面了解如何正确安全地加密数据，如果你有任何建议，请告诉我。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="55eb" class="kd ke iq bd kf kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la bi translated">参考</h1><p id="ea28" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Golang文档。2020."包加密。"2020.<a class="ae kc" href="https://godoc.org/golang.org/x/crypto/scrypt" rel="noopener ugc nofollow" target="_blank">https://godoc.org/golang.org/x/crypto/scrypt</a>。</p><p id="efb4" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">伊索姆凯尔。2015.<em class="mv">实用密码术用Go </em>。Leanpub。<a class="ae kc" href="https://leanpub.com/gocrypto/read" rel="noopener ugc nofollow" target="_blank">https://leanpub.com/gocrypto/read</a>。</p><p id="bbcd" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">帕西瓦尔，C. 2005a。" scrypt:一个新的密钥派生函数."<a class="ae kc" href="https://www.bsdcan.org/2009/schedule/attachments/86_scrypt_slides.pdf" rel="noopener ugc nofollow" target="_blank">https://www . BSD can . org/2009/schedule/attachments/86 _ scrypt _ slides . pdf</a>。</p><p id="3f6a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">— -.2005年b"通过顺序记忆硬函数的强密钥派生."https://www.tarsnap.com/scrypt/scrypt.pdf。</p><p id="01af" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">Ryer，M. 2015。“木卫一。深度读者。”2015.<a class="ae kc" href="https://medium.com/@matryer/golang-advent-calendar-day-seventeen-io-reader-in-depth-6f744bb4320b" rel="noopener">https://medium . com/@ matryer/golang-advent-calendar-day-seventh-io-reader-in-depth-6f 744 bb 4320 b</a>。</p><p id="985d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">坦克斯利，G. 2016。“去找密码开发人员。”<a class="ae kc" href="https://youtu.be/2r_KMzXB74w" rel="noopener ugc nofollow" target="_blank">https://youtu.be/2r_KMzXB74w</a>。</p><p id="be38" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">Viega，j .和M. Messier。2003.<em class="mv">C和C++ </em>安全编程指南。奥莱利媒体。</p><p id="7ac3" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">维基百科。2020."密钥推导函数——维基百科，免费的百科全书."2020.<a class="ae kc" href="https://en.wikipedia.org/wiki/Key_derivation_function" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Key_derivation_function</a>。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="b156" class="kd ke iq bd kf kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la bi translated">脚注</h1><p id="f6d0" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">[1]如何用streams实现加密的一些参考:<a class="ae kc" href="https://www.reddit.com/r/golang/comments/87wcik/how_do_you_encrypt_large_ioreader_streams/dwp2k0g?utm_source=share&amp;utm_medium=web2x" rel="noopener ugc nofollow" target="_blank"> Reddit评论</a>；<a class="ae kc" href="https://medium.com/blend-engineering/encrypting-streams-in-go-6cff6062a107" rel="noopener">迈克尔·特纳——加密围棋流</a>；<a class="ae kc" href="https://github.com/minio/sio/issues/26#issuecomment-378012290" rel="noopener ugc nofollow" target="_blank"> Minio — Github发行</a></p><p id="63b9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[2] <a class="ae kc" href="https://golang.org/pkg/crypto/aes/" rel="noopener ugc nofollow" target="_blank"> Go文档:AES </a></p><p id="5627" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">【3】<a class="ae kc" href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard" rel="noopener ugc nofollow" target="_blank">维基百科:AES </a></p><p id="bf25" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[4] <a class="ae kc" href="https://www.youtube.com/watch?v=O4xNJsjtN6E" rel="noopener ugc nofollow" target="_blank">电脑爱好者— AES讲解</a></p><p id="4df4" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[5] <a class="ae kc" href="https://en.wikipedia.org/wiki/Galois/Counter_Mode" rel="noopener ugc nofollow" target="_blank">维基百科:GCM </a></p><p id="810e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[6] <a class="ae kc" href="https://golang.org/pkg/crypto/cipher/#AEAD" rel="noopener ugc nofollow" target="_blank"> Go文档:AEAD </a></p><p id="c9f0" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[7] <a class="ae kc" href="https://golang.org/pkg/crypto/rand/#Read" rel="noopener ugc nofollow" target="_blank"> Go文档:兰德。阅读</a></p><p id="1aa0" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[8] <a class="ae kc" href="https://golang.org/src/crypto/cipher/gcm.go" rel="noopener ugc nofollow" target="_blank"> Go源代码:GCM </a></p><p id="9327" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[9] <a class="ae kc" href="https://golang.org/src/crypto/cipher/gcm.go" rel="noopener ugc nofollow" target="_blank">围棋源代码:GCM </a></p><p id="dcc0" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[10] <a class="ae kc" href="https://golang.org/pkg/crypto/rand/#Read" rel="noopener ugc nofollow" target="_blank">围棋文献:兰德。阅读</a></p><p id="89bb" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[11] <a class="ae kc" href="https://en.wikipedia.org/wiki/Key_derivation_function" rel="noopener ugc nofollow" target="_blank">维基百科:KDF </a></p><p id="3f07" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[12] <a class="ae kc" href="https://en.wikipedia.org/wiki/Key_stretching" rel="noopener ugc nofollow" target="_blank">维基百科:按键拉伸</a></p><p id="ea51" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[13] <a class="ae kc" href="https://en.wikipedia.org/wiki/Argon2" rel="noopener ugc nofollow" target="_blank">维基百科:Argon2 </a></p><p id="a85f" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[14] <a class="ae kc" href="https://en.wikipedia.org/wiki/Scrypt" rel="noopener ugc nofollow" target="_blank">维基百科:scrypt </a></p><p id="38e8" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[15] <a class="ae kc" href="https://en.wikipedia.org/wiki/Bcrypt" rel="noopener ugc nofollow" target="_blank">维基百科:bcrypt </a></p><p id="af62" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[16] <a class="ae kc" href="https://en.wikipedia.org/wiki/PBKDF2" rel="noopener ugc nofollow" target="_blank">维基百科:pbkdf2 </a></p><p id="3055" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[17] <a class="ae kc" href="https://medium.com/@mpreziuso/password-hashing-pbkdf2-scrypt-bcrypt-and-argon2-e25aaf41598e" rel="noopener"> Michele Prezioso —密码散列:PBKDF2，Scrypt，Bcrypt </a></p><p id="c87a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[18]<a class="ae kc" href="https://medium.com/@mpreziuso/password-hashing-pbkdf2-scrypt-bcrypt-and-argon2-e25aaf41598e" rel="noopener">Michele Prezioso——密码散列:Scrypt、Bcrypt和ARGON2 </a></p><p id="9de3" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[19]<a class="ae kc" href="https://crypto.stackexchange.com/questions/35275/whats-the-difference-between-pbkdf-and-sha-and-why-use-them-together/61306#61306" rel="noopener ugc nofollow" target="_blank">stack exchange—pbk df和SHA有什么区别，为什么要一起使用？</a></p><p id="cc38" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[20] <a class="ae kc" href="https://github.com/bitwarden/jslib/issues/52" rel="noopener ugc nofollow" target="_blank"> Github — Bitwarden第52期</a></p><p id="0c55" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[21] <a class="ae kc" href="https://github.com/bitwarden/server/issues/589" rel="noopener ugc nofollow" target="_blank"> Github — Bitwarden第589期</a></p><p id="f629" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[22] <a class="ae kc" href="https://en.wikipedia.org/wiki/PBKDF2#Alternatives_to_PBKDF2" rel="noopener ugc nofollow" target="_blank">维基百科:pbkdf2替代品</a></p><p id="fcb3" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[23] <a class="ae kc" href="https://en.wikipedia.org/wiki/Salt_(cryptography)" rel="noopener ugc nofollow" target="_blank">维基百科:Salt(密码学)</a></p><p id="e5f2" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[24] <a class="ae kc" href="https://godoc.org/golang.org/x/crypto/scrypt" rel="noopener ugc nofollow" target="_blank"> Go文档:scrypt </a></p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><p id="2d3c" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="mv">原载于</em><a class="ae kc" href="https://bruinsslot.jp/post/golang-crypto/" rel="noopener ugc nofollow" target="_blank"><em class="mv">https://bruinsslot.jp/post/golang-crypto/</em></a><em class="mv">。</em></p></div></div>    
</body>
</html>