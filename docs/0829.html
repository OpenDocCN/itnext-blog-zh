<html>
<head>
<title>Introducing Luna — JavaScript Testing Done Right</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍Luna——JavaScript测试做对了</h1>
<blockquote>原文：<a href="https://itnext.io/introducing-luna-javascript-testing-done-right-437a738cc1ed?source=collection_archive---------5-----------------------#2018-06-05">https://itnext.io/introducing-luna-javascript-testing-done-right-437a738cc1ed?source=collection_archive---------5-----------------------#2018-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/79f95736d68734736beea64a9554b2a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xusPSFMJBbeosQm2LUfQhg.png"/></div></div></figure><h2 id="d598" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">问题是</h2><p id="3d16" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">我相信你在读这篇文章的时候会想:</p><blockquote class="lp lq lr"><p id="f4af" class="ku kv ls kw b kx lt kz la lb lu ld le lv lw lg lh lx ly lj lk lz ma lm ln lo ij bi translated">已经有一百万个JavaScript测试框架。为什么这个世界需要另一个？</p></blockquote><p id="4e52" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le kh lw lg lh kl ly lj lk kp ma lm ln lo ij bi translated">这也是我的第一个想法。我正在做一个项目，决定要添加一些单元测试。我试过AVA。然后我试了胶带。然后是摩卡。那就开玩笑吧。三个小时后，我又回到了起点。盒子里什么都没有。我陷入了与Babel配置、ES6模块导入/解析失败、外部依赖、测试配置等的斗争中。我越来越沮丧。</p><p id="3500" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le kh lw lg lh kl ly lj lk kp ma lm ln lo ij bi translated">作为一个已经写了很长时间软件的人，如果我有这么多的麻烦，那么我只能想象新开发人员会经历什么。我怀疑很多人放弃了，最终根本没有写任何测试。</p><h2 id="5122" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">各种各样的工具</h2><p id="83ab" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">现在是读者插话的时候了:</p><blockquote class="lp lq lr"><p id="8ba1" class="ku kv ls kw b kx lt kz la lb lu ld le lv lw lg lh lx ly lj lk lz ma lm ln lo ij bi translated">但是先生，很明显你一定是个白痴。我使用这些框架，它们非常容易设置。启动和运行需要几分钟时间。</p></blockquote><p id="879b" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le kh lw lg lh kl ly lj lk kp ma lm ln lo ij bi translated">恭喜你。我为你高兴。我不是说我的经历是每个人都分享的。这真的取决于你从事的具体项目。</p><p id="4fda" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le kh lw lg lh kl ly lj lk kp ma lm ln lo ij bi translated">无论哪种方式，我们至少应该能够同意，所有不同的JavaScript构建工具使得向您的项目添加测试变得更加困难。</p><p id="dc20" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le kh lw lg lh kl ly lj lk kp ma lm ln lo ij bi translated">Karma、Mocha、Jasmine、Jest、Sinon、Chai、、Babel、Gulp、Grunt、Webpack、Buble、Rollup、jsdom等等。</p><p id="f8a1" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le kh lw lg lh kl ly lj lk kp ma lm ln lo ij bi translated">在编写单个测试之前，您必须编写大量的样板代码。我在<a class="ae mb" href="https://karma-runner.github.io/2.0/config/configuration-file.html" rel="noopener ugc nofollow" target="_blank"> Karma文档</a>中数了50多个配置选项，其中许多都有自己的子选项集！事实上，Karma是其他单元测试运行者的运行者，而<a class="ae mb" href="https://www.youtube.com/watch?v=MVw8N3hTfCI" rel="noopener ugc nofollow" target="_blank">的介绍视频</a>大约15分钟长，这应该告诉你你需要知道的一切。</p><p id="3080" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le kh lw lg lh kl ly lj lk kp ma lm ln lo ij bi translated">大多数测试框架需要插件或其他工具来做简单的事情，比如代码覆盖。它可能不一定很难添加，但它仍然是您必须采取的额外步骤。</p><p id="eef4" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le kh lw lg lh kl ly lj lk kp ma lm ln lo ij bi translated">尽管大多数JavaScript代码都是为在浏览器中运行而编写的，但在一些测试框架中，使用浏览器进行测试并不容易，甚至是不可能的。想一想。他们建议你使用jsdom，一个在服务器端模拟浏览器dom的节点工具。当然，这在某些情况下可能行得通，但是测试不应该默认为浏览器设计吗？</p><h2 id="b8aa" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">一个解决方案</h2><p id="9d38" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">我最近写了很多go，我真正喜欢的是go的测试是如何直接内置在语言中的。您可以创建一个文件，添加一些测试，并运行它们，而不必安装任何外部依赖项。</p><p id="3498" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le kh lw lg lh kl ly lj lk kp ma lm ln lo ij bi translated">这是激发我创作露娜的部分原因。我一直在寻找一个能够正常工作的单元测试框架，并且不需要任何疯狂的配置或外部库。我希望能够在代码中的任何地方添加测试函数，运行测试，并查看结果。</p><p id="1949" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le kh lw lg lh kl ly lj lk kp ma lm ln lo ij bi translated">结果<strong class="kw ir">露娜根本没有配置</strong>。</p><p id="8164" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le kh lw lg lh kl ly lj lk kp ma lm ln lo ij bi translated">为了达到这个目的，它对你的工作环境做了一些假设。您的测试必须写成ES6模块，您的代码也应该如此。除了JSX，露娜不传输任何源代码。这意味着如果你正在使用Coffeescript或Typescript，你现在就要倒霉了。</p><h2 id="e1ff" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">它是如何工作的？</h2><p id="f4d2" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">Luna搜索任何名字以<code class="fe mc md me mf b">test</code>开头的函数，这些函数是从你让它查找的任何文件和目录中导出的。然后，它使用rollup的API在内存中动态创建一个测试运行包。每个测试函数都被调用，并通过一个<code class="fe mc md me mf b">assert</code>方法传递一个对象的实例。使用控制台日志将结果传递回主进程。</p><p id="735f" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le kh lw lg lh kl ly lj lk kp ma lm ln lo ij bi translated">这意味着一切都是独立的，不需要全局变量。此外，您不需要导入任何定制库来运行您的测试，因为测试函数本身已经从您的代码中提取出来了。</p><h2 id="4c86" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">其他好吃的</h2><ul class=""><li id="10d0" class="mg mh iq kw b kx ky lb lc kh mi kl mj kp mk lo ml mm mn mo bi translated">由于Luna的工作方式，你可以在任何你想要的地方包含测试函数，包括在你的源文件中。<strong class="kw ir"> <em class="ls">注意:</em> </strong> <em class="ls">只有当您在构建您的产品包时使用树抖动来剥离测试代码时，才推荐这样做。</em></li><li id="d27f" class="mg mh iq kw b kx mp lb mq kh mr kl ms kp mt lo ml mm mn mo bi translated">浏览器测试是内置的，默认情况下运行。它使用<a class="ae mb" href="https://github.com/GoogleChrome/puppeteer" rel="noopener ugc nofollow" target="_blank">木偶师</a>来运行最新版本的Chromium。</li><li id="b832" class="mg mh iq kw b kx mp lb mq kh mr kl ms kp mt lo ml mm mn mo bi translated">它使用背压队列来支持并发性，以允许测试并行运行。如果一些测试是CPU密集型的或者需要一段时间来运行，这是很有用的。</li><li id="3cd5" class="mg mh iq kw b kx mp lb mq kh mr kl ms kp mt lo ml mm mn mo bi translated">它自动生成代码覆盖报告，而不需要安装任何额外的库(通过<code class="fe mc md me mf b">--no-coverage</code>标志来禁用它们)。</li><li id="02ad" class="mg mh iq kw b kx mp lb mq kh mr kl ms kp mt lo ml mm mn mo bi translated">当你的测试有错误时，Luna会自动翻译并应用源代码映射到代码覆盖报告和堆栈跟踪，即使puppeter<a class="ae mb" href="https://github.com/GoogleChrome/puppeteer/issues/985" rel="noopener ugc nofollow" target="_blank">不支持它们</a>。</li><li id="789b" class="mg mh iq kw b kx mp lb mq kh mr kl ms kp mt lo ml mm mn mo bi translated">Luna使用的assert函数受到了<a class="ae mb" href="https://github.com/power-assert-js/power-assert" rel="noopener ugc nofollow" target="_blank"> power-assert </a>的启发，因此如果您的测试失败，您可以确切地看到语句的哪一部分失败了，而不是类似于<code class="fe mc md me mf b">Failed asserting that false is true</code>的一般消息。下面是一个失败测试的输出示例:</li></ul><pre class="mu mv mw mx gt my mf mz na aw nb bi"><span id="0ce0" class="jy jz iq mf b gy nc nd l ne nf">test/test-assert.js</span><span id="21ab" class="jy jz iq mf b gy ng nd l ne nf">❌ testGetData</span><span id="6731" class="jy jz iq mf b gy ng nd l ne nf">24<br/>25    t.assert(data3.message === 'Something should be false');<br/>26                   |<br/>                     "Something should be true"</span></pre><ul class=""><li id="3603" class="mg mh iq kw b kx lt lb lu kh nh kl ni kp nj lo ml mm mn mo bi translated">它支持对数组和对象的比较，而不必使用任何自定义语法(只需使用<code class="fe mc md me mf b">==</code>或<code class="fe mc md me mf b">!=</code>进行比较):</li></ul><pre class="mu mv mw mx gt my mf mz na aw nb bi"><span id="8956" class="jy jz iq mf b gy nc nd l ne nf">t.assert(list == ['one', 'two', 'three']);</span></pre><ul class=""><li id="12ed" class="mg mh iq kw b kx lt lb lu kh nh kl ni kp nj lo ml mm mn mo bi translated">它自动将JSX代码编译成<code class="fe mc md me mf b">React.createElement</code>语法。</li><li id="9722" class="mg mh iq kw b kx mp lb mq kh mr kl ms kp mt lo ml mm mn mo bi translated">卢娜的测试由卢娜负责。多么meta！</li></ul><h2 id="12e3" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">结论</h2><p id="1ef8" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">我确信它并不完美，因为没有适用于所有人的灵丹妙药，特别是考虑到当今JavaScript的发展状况，但我相信它是朝着正确方向迈出的一步，我希望其他人也这样认为，并发现它很有用！</p><p id="1088" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le kh lw lg lh kl ly lj lk kp ma lm ln lo ij bi translated">您可以在<a class="ae mb" href="https://github.com/ccampbell/luna-testing" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到更多信息并阅读完整文档。</p><p id="8c68" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le kh lw lg lh kl ly lj lk kp ma lm ln lo ij bi translated">另外，请务必查看<a class="ae mb" href="https://craig.is/testing/code" rel="noopener ugc nofollow" target="_blank">项目介绍页面</a>。</p></div></div>    
</body>
</html>