<html>
<head>
<title>JaCh — Power of Go Channels in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JaCh——Java中Go通道的力量</h1>
<blockquote>原文：<a href="https://itnext.io/jach-power-of-go-channels-in-java-e8678a48b47f?source=collection_archive---------3-----------------------#2021-07-04">https://itnext.io/jach-power-of-go-channels-in-java-e8678a48b47f?source=collection_archive---------3-----------------------#2021-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8392133f80a3573015c224611eeab413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PtmQQj8N4nS7oZCc"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">马克西米利安·魏斯贝克尔在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="14fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Google的Go从一开始就被设计成将软件和硬件的最新发展直接融入到语言中。为了实现多个运行线程之间共享数据访问的同步，传统语言依赖锁和监视器，go从<a class="ae kc" href="http://www.usingcsp.com/" rel="noopener ugc nofollow" target="_blank">通信顺序进程</a>中获得灵感，并围绕通道和Go例程构建其同步和数据访问模式。</p><p id="d24e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Go对共享数据结构的方法通常被浓缩成以下语句:</p><blockquote class="lb lc ld"><p id="e871" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">不通过共享内存进行交流；相反，通过交流来分享记忆。</p></blockquote><p id="3949" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着传统语言使用锁和互斥锁来控制对多线程间共享数据的访问，而Go鼓励进程通过通道交流状态。这意味着共享内存只能由通道访问，并且每个并行例程可以独立地处理共享数据，而不用担心竞争情况。</p><h2 id="066b" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">在Java中调整通道和例程</h2><p id="111b" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">JaCh(Java Channels的缩写)是一个库，它试图将Go通道的功能及其特性引入Java语言，并在简单易用的API中鼓励CSP的Java设计模式。</p><p id="4d20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">通道</strong>作为一种数据结构，一端接受数据写入，另一端将数据输出到数据读取器。尽管没有关于数据顺序的明确保证，但它仍然可以被建模为一个<strong class="kf ir">队列。</strong> Java内置了对<a class="ae kc" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">blocking queue</strong></a><strong class="kf ir"/>的支持，这也保证了通道读线程和写线程可以分别在空线程和满线程的情况下被阻塞。</p><p id="9b08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">例程</strong>非常类似于Java中的一个线程。将例程简单地实现为一个<a class="ae kc" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Runnable </strong> </a>对象的包装器是有意义的，该对象可以在线程池中执行。</p><h2 id="413a" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">通过交流分享记忆</h2><p id="5b80" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">尽管没有强制执行，Go的理念鼓励通道使用具体类型而不是指针类型。这确保了内存不会被go-routines共享。副作用是在通道中传递的对象需要是轻量级的，以便于更快的内存复制。</p><p id="7fbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Java中，每个对象实际上都是一个对象引用(类似于指针)。每当一个对象按原样写入Java通道时，它的引用将实际驻留在通道中，并且实际的对象将在线程间共享——这将违反通过通信共享内存的原则。为了确保每个对象在被写入通道之前都被复制到一个新对象，使用了一个<code class="fe mg mh mi mj b">Copier</code>实例。JaCh使用<a class="ae kc" href="https://github.com/EsotericSoftware/kryo" rel="noopener ugc nofollow" target="_blank"> Kryo </a>作为默认的复印机实现，但是用户可以自由实现他们自己的复印机。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="edd6" class="mr lj iq bd lk ms mt mu ln mv mw mx lq my mz na lt nb nc nd lw ne nf ng lz nh bi translated">JaCh与Go频道</h1><p id="0e96" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">在这一节中，我们来看看JaCh和Go的通道之间的一些特性对等性。下表简要介绍了JaCh提供的模拟Go通道的特性</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="91dc" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">创建频道</h2><p id="3ea1" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">JaCh在<code class="fe mg mh mi mj b">JachChannels</code>类中定义了静态的<code class="fe mg mh mi mj b">make</code>方法来轻松创建通道。</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="cebf" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">在通道上迭代</h2><p id="e956" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">JaCh使用<code class="fe mg mh mi mj b">Channel</code>接口来建模通道，通道又从<code class="fe mg mh mi mj b">Iterable</code>扩展而来。这意味着JaCh中的通道可以使用增强的for循环(for-each循环)或者使用<code class="fe mg mh mi mj b">forEach</code>方法并传递一个<code class="fe mg mh mi mj b">Consumer</code>来迭代。因为JaCh通道是在不同的线程中异步关闭的，所以迭代器不可能干净地退出，只能通过抛出异常来退出循环。因此，for-each循环需要包装在try-catch块中。<code class="fe mg mh mi mj b">forEach</code>方法很好地处理了这种情况，不需要任何try-catch包装。</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="14ea" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">选择，用于-选择和选择-默认</h2><p id="77b8" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">由于通道是Go中的本地构造，它提供了直接的语言绑定来等待多个通道，并在数据到达时选择一个通道。此外，这样的select语句可以在for循环中连续轮询不同的通道，直到所有通道都关闭或者循环通过中断退出。</p><p id="13c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JaCh试图使用<code class="fe mg mh mi mj b">select</code>和<code class="fe mg mh mi mj b">untilDone</code>方法提供一个类似的构造。因为这些方法接受一个<code class="fe mg mh mi mj b">Consumer</code>类型，所以与匿名内部类或lambda相关的限制适用于这些情况。其中最值得注意的是，消费者内部使用的任何变量都必须是final或<a class="ae kc" href="https://www.baeldung.com/java-effectively-final" rel="noopener ugc nofollow" target="_blank">有效的final </a>。为了提前打破循环，在<code class="fe mg mh mi mj b">Selector</code>类中提供了一个特殊的消费者<code class="fe mg mh mi mj b">BREAK_ACTION</code>。</p><h2 id="fa9a" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">计时器和计时器</h2><p id="a56e" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">JaCh还提供了创建<code class="fe mg mh mi mj b">Timer</code>或<code class="fe mg mh mi mj b">Ticker</code>的能力，它们在某个时间间隔后通过信道发送信息。尽管Java已经有了自己的<code class="fe mg mh mi mj b">Timer</code>和<code class="fe mg mh mi mj b">TimerTask</code>版本，但是这些类允许用户围绕基于定时器接收数据的通道来设计他们的代码。</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="126f" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">JaCh中的例程</h2><p id="df30" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">由于函数是Go中的一级对象，所以要创建go-routine，只需调用以<code class="fe mg mh mi mj b">go</code>关键字为前缀的函数即可。JaCh提供了一种类似的方法，通过多个<code class="fe mg mh mi mj b">go</code>方法创建一个例程。<code class="fe mg mh mi mj b">go</code>方法接受一个lambda函数，该函数可以接受0到9个参数，后跟参数值。然后，它在一个单独的线程中运行这个lambda，给人一种并行go-routine的错觉。</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h1 id="62d6" class="mr lj iq bd lk ms no mu ln mv np mx lq my nq na lt nb nr nd lw ne ns ng lz nh bi translated">得到JaCh</h1><p id="3e53" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">JaCh在central中作为maven库提供。下面的pom依赖项将把它添加到您的项目中使用</p><pre class="ni nj nk nl gt nt mj nu nv aw nw bi"><span id="a88f" class="li lj iq mj b gy nx ny l nz oa">&lt;dependency&gt;<br/>    &lt;groupId&gt;io.github.daichi-m&lt;/groupId&gt;<br/>    &lt;artifactId&gt;jach&lt;/artifactId&gt;<br/>    &lt;version&gt;LATEST_VERSION&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="b3a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它是在MIT许可下开源的，代码可以在<a class="ae kc" href="https://github.com/daichi-m/jach" rel="noopener ugc nofollow" target="_blank"> Github </a>中获得。repo还有一个<a class="ae kc" href="https://github.com/daichi-m/jach/tree/develop/samples" rel="noopener ugc nofollow" target="_blank"> samples项目</a>，其中包含JaCh各种特性的示例代码。</p><h1 id="507a" class="mr lj iq bd lk ms no mu ln mv np mx lq my nq na lt nb nr nd lw ne ns ng lz nh bi translated">脚注</h1><ol class=""><li id="83b9" class="ob oc iq kf b kg mb kk mc ko od ks oe kw of la og oh oi oj bi translated"><a class="ae kc" href="https://golang.org/doc/effective_go#concurrency" rel="noopener ugc nofollow" target="_blank">有效的围棋</a>是了解更多围棋通道和套路的绝佳去处。</li><li id="96c0" class="ob oc iq kf b kg ok kk ol ko om ks on kw oo la og oh oi oj bi translated">选择Kryo而不是原生Java序列化的原因是，它比原生Java版本快得多，相当轻量级，并且足够稳定，可以跨多个流行的开源项目使用。</li></ol></div></div>    
</body>
</html>