<html>
<head>
<title>Communication Between Micro-front ends</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微前端之间的通信</h1>
<blockquote>原文：<a href="https://itnext.io/communication-between-micro-front-ends-f3c04d4c138e?source=collection_archive---------1-----------------------#2021-09-01">https://itnext.io/communication-between-micro-front-ends-f3c04d4c138e?source=collection_archive---------1-----------------------#2021-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b0604958fce37e01472f1c508504343f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wcz8bAOjRdV6D0wTJQSBWg.jpeg"/></div></div></figure><p id="f7a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">微前端(MFE)现在非常流行。它是热的，它是性感的，并且在大多数情况下，是不相关的(MFE是一个大项目的解决方案。它的存在是为了分离关注点)。但遗憾的是，大多数关于MFE的帖子都是关于初始设置的，而不是关于实际的生产就绪代码。我们如何在微前端之间交流？</p><p id="fbe3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将把它分成两种不同类型的项目。</p><ol class=""><li id="f43c" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">每个MFE都可以在不同的框架中编写的应用程序。</li><li id="639c" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">全部使用相同框架的应用程序(为了示例Angular)。</li></ol></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><p id="28d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="lr">框架不可知通信</em> </strong></p><p id="2686" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以肯定地说，所有UI框架之间的<strong class="ka ir">共同点</strong>就是窗口元素。这是我们的机会之窗。</p><p id="379a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于本例，我们将创建一个自定义事件(浏览器提供的一个全局函数)</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="de66" class="mb mc iq lx b gy md me l mf mg"><em class="lr">const customEvent </em>= <em class="lr">new </em>CustomEvent('eventFromMfe', {detail: {name: 'Ryan'}})</span></pre><p id="a525" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">"<em class="lr"> customEvent </em>"事件还没有被触发，而是在等待我们想触发它的时候。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="6b54" class="mb mc iq lx b gy md me l mf mg">window.dispatchEvent(<em class="lr">customEvent</em>);</span></pre><p id="12cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经触发了一个事件。我们不“期待”回应。有点UDP的心态。<br/>在我们众多mfe之一的某个地方，我们在窗口上有一个被动事件监听器，等待我们的自定义事件被调度。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="bb1f" class="mb mc iq lx b gy md me l mf mg">window.addEventListener('eventFromMfe', (customEvent: <em class="lr">CustomEvent</em>) =&gt; {<br/>    <em class="lr">const </em>{detail} = customEvent || {}<br/>    console.log('data from custom event', JSON.stringify(detail))<br/>})</span></pre><p id="e54d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以让不同mfe中的多个侦听器等待相同的事件发生，并运行代码来响应它们。</p><p id="46d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一种非常<strong class="ka ir">手动</strong>的方式来创建我们MFE之间的通信。我们可以使用一个名为<a class="ae mh" href="https://www.npmjs.com/package/pubsub-js" rel="noopener ugc nofollow" target="_blank"> pubsub-js </a>(非常有名)的漂亮的库，它执行类似的过程，但是具有更加反应式的风格(我非常确定在幕后它与窗口事件非常相似，如果我错了，请纠正我)。</p><p id="12dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意:<br/>使用这种方法允许项目使用不同的微前端，以与框架无关的心态共存。虽然这很有效，但我很难相信一个拥有足够大项目的公司会使用不同的框架。创建良好的团队间沟通太复杂了。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><p id="67de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="lr">【通过商店沟通(单类型框架)</em> </strong></p><p id="ddbf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">商店是我们想要在我们所有的Angular MFEs之间共享的东西。它让我们能够访问商店数据，并更加独立地工作。我们可以完全篡改存储来影响存储数据，但是我们也可以“滥用”动作的工作方式。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="a359" class="mb mc iq lx b gy md me l mf mg"><em class="lr">// MFE1</em></span><span id="aa13" class="mb mc iq lx b gy mi me l mf mg"><em class="lr">const </em>globalLoadingAction = createAction('[MFE-Action] Loading', props&lt;{loading: <em class="lr">boolean</em>}&gt;())</span></pre><p id="be0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">MFE可以通过存储调度<em class="lr"> globalLoadingAction </em>事件，而不需要任何缩减器或效果。这是一种全球事件，类似于我们的window.dispatch</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="142e" class="mb mc iq lx b gy md me l mf mg"><em class="lr">// MFE2</em></span><span id="fb1f" class="mb mc iq lx b gy mi me l mf mg"><em class="lr">this</em>.actions$.pipe(<br/>    ofType(globalLoadingAction), // only listen to the event<br/>).subscribe((action: Action) =&gt; {<br/>    <em class="lr">this</em>.toggleGlobalLoading<br/>})</span></pre><p id="5880" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的第二个MFE连接到同一个存储，在singleton instances module-federations给我们的帮助下，我们从我们的第二个MFE中监听相关的动作并处理我们的逻辑。这将导致更像“乒乓式”的交流，但这会给你一个非常分散的代码库。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><p id="0719" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lr">注意事项</em>:</p><p id="3d38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当使用某种商定的语言时，比如动作或自定义事件的枚举，我们可以使用NPM包来处理这个问题，并被所有MFE共享。由于我们沟通的每一部分都是分离的，包版本管理就成了一个问题(大部分情况下)。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><p id="4549" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望这对您有所帮助:)，并为您提供探索和测试mfe所需的动力。对于任何问题和帮助，你可以随时联系我，我会尽力帮助你</p></div></div>    
</body>
</html>