<html>
<head>
<title>Monitoring Kubernetes Jobs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">监控Kubernetes作业</h1>
<blockquote>原文：<a href="https://itnext.io/monitoring-kubernetes-jobs-8adc241a7b60?source=collection_archive---------2-----------------------#2021-06-14">https://itnext.io/monitoring-kubernetes-jobs-8adc241a7b60?source=collection_archive---------2-----------------------#2021-06-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f30eb5021976b79a21c3b347f2d25bc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xXK05jJJYIhdWggvPi8ZCw.png"/></div></div></figure><p id="ec47" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi kz translated"><span class="l la lb lc bm ld le lf lg lh di">A</span>Kubernetes<a class="ae li" href="https://kubernetes.io/docs/concepts/workloads/controllers/job/" rel="noopener ugc nofollow" target="_blank">T5】Job</a>是一个表示有限任务的控制器对象。作业与其他控制器对象的不同之处在于，作业在任务运行到完成时管理任务，而不是像部署、复制集和状态集那样管理所需的状态。当达到指定的成功完成次数时，作业就完成了。当您想要创建执行特定任务然后退出的pod时，可以使用Kubernetes作业。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="ccba" class="lt lu it lp b gy lv lw l lx ly"><strong class="lp iu">apiVersion</strong>: batch/v1<br/><strong class="lp iu">kind</strong>: Job<br/><strong class="lp iu">metadata</strong>:<br/>  <strong class="lp iu">name</strong>: pi<br/><strong class="lp iu">spec</strong>:<br/>  <strong class="lp iu">template</strong>:<br/>    <strong class="lp iu">spec</strong>:<br/>      <strong class="lp iu">containers</strong>:<br/>      - <strong class="lp iu">name</strong>: pi<br/>        <strong class="lp iu">image</strong>: perl<br/>        <strong class="lp iu">command</strong>: ["perl",  "-Mbignum=bpi", "-wle", "print bpi(2000)"]<br/>      <strong class="lp iu">restartPolicy</strong>: Never<br/>  <strong class="lp iu">backoffLimit</strong>: 4</span></pre><h1 id="7aa5" class="lz lu it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">Cronjobs:自动化Kubernetes作业</h1><p id="1cd4" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated">一个<a class="ae li" href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/" rel="noopener ugc nofollow" target="_blank"> <em class="lj"> CronJob </em> </a>按照重复的时间表创建作业。自动化作业在Linux或UNIX系统上运行起来就像Cron任务一样。</p><p id="951e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">CronJobs对于创建定期和重复的任务很有用，比如运行备份或发送电子邮件。CronJobs还可以将单个任务安排在特定的时间，例如，如果您希望将一个作业安排在一个低活动期。</p><p id="1913" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">CronJob在其调度的每个执行时间创建一个作业对象。<code class="fe nb nc nd lp b">.spec.successfulJobsHistoryLimit</code>和<code class="fe nb nc nd lp b">.spec.failedJobsHistoryLimit </code>字段指定应该保留多少个已完成和失败的任务。默认情况下，它们分别设置为3和1。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="7e21" class="lt lu it lp b gy lv lw l lx ly"><strong class="lp iu">apiVersion</strong>: batch/v1<br/><strong class="lp iu">kind</strong>: CronJob<br/><strong class="lp iu">metadata</strong>:<br/>  <strong class="lp iu">name</strong>: hello<br/><strong class="lp iu">spec</strong>:<br/>  <strong class="lp iu">schedule</strong>: "*/1 * * * *"<br/>  <strong class="lp iu">jobTemplate</strong>:<br/>    <strong class="lp iu">spec</strong>:<br/>      <strong class="lp iu">template</strong>:<br/>        <strong class="lp iu">spec</strong>:<br/>          <strong class="lp iu">containers</strong>:<br/>          - <strong class="lp iu">name</strong>: hello<br/>            <strong class="lp iu">image</strong>: busybox<br/>            <strong class="lp iu">imagePullPolicy</strong>: IfNotPresent<br/>            <strong class="lp iu">command</strong>:<br/>            - /bin/sh<br/>            - -c<br/>            - date; echo Hello from the Kubernetes cluster<br/>          <strong class="lp iu">restartPolicy</strong>: OnFailure<br/>  <strong class="lp iu">successfulJobsHistoryLimit</strong>: 1<br/>  <strong class="lp iu">failedJobsHistoryLimit</strong>: 1</span></pre><p id="dca8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据下面的说明，Kubernetes将只保留一个失败的作业和一个成功的作业:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="7c9e" class="lt lu it lp b gy lv lw l lx ly">NAME               COMPLETIONS   DURATION   AGE<br/>hello-4111706356   0/1           2m         10d<br/>hello-4111706356   1/1           5s         5s</span></pre><p id="663c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每次作业运行完成时，旧的成功/失败的作业对象都会被清除。在监控Kubernetes作业时，了解Kubernetes保留这些作业的历史记录是非常重要的。</p><p id="df0c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">CronJobs有局限性和独特性。例如，在某些情况下，单个CronJob可以创建多个作业。所以，乔布斯应该是幂等的。</p><h1 id="0811" class="lz lu it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">监控Kubernetes作业</h1><p id="0bf9" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated">监控(非并发)Kubernetes作业不是一件容易的事情，但是可以使用<a class="ae li" href="https://github.com/kubernetes/kube-state-metrics" rel="noopener ugc nofollow" target="_blank"><em class="lj">kube-state-metrics</em></a>和<a class="ae li" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lj"> Prometheus </em> </a>来实现。</p><p id="ebe3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">kube-state-metrics是一个简单的服务，它监听Kubernetes API服务器并生成关于对象状态的度量。它并不关注单个Kubernetes组件的健康状况，而是关注内部各种对象的健康状况，比如部署、节点、单元以及对我们有利的作业。</p><p id="9bbc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在kube-state-metrics报告的所有<a class="ae li" href="https://github.com/kubernetes/kube-state-metrics/blob/master/docs/job-metrics.md" rel="noopener ugc nofollow" target="_blank">指标</a>中，我们将使用以下指标:</p><ul class=""><li id="d52b" class="ne nf it kd b ke kf ki kj km ng kq nh ku ni ky nj nk nl nm bi translated"><strong class="kd iu"> kube_job_owner: </strong>查找作业和触发它的CronJob之间的关系。</li><li id="45f7" class="ne nf it kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated"><strong class="kd iu">kube _ Job _ status _ start _ time:</strong>找出作业被触发的时间。</li><li id="85a2" class="ne nf it kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated"><strong class="kd iu"> kube_job_status_failed </strong>:找出哪些作业失败了。</li><li id="f19d" class="ne nf it kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated"><strong class="kd iu">kube _ cron job _ spec _ suspend</strong>:过滤掉暂停的作业。</li></ul><p id="a1f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是一个指标示例，其中包含由CronJob为在计划中运行的“hello”作业生成的标签:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="d5d7" class="lt lu it lp b gy lv lw l lx ly">kube_job_owner{<strong class="lp iu">job_name</strong>=”hello-1604875860", <strong class="lp iu">namespace</strong>=”myNamespace”, <strong class="lp iu">owner_is_controller</strong>=”true”, <strong class="lp iu">owner_kind</strong>=”CronJob”, <strong class="lp iu">owner_name</strong>=”hello”} 1</span><span id="7f74" class="lt lu it lp b gy ns lw l lx ly">kube_job_status_start_time{<strong class="lp iu">job_name</strong>="hello-1604875860", <strong class="lp iu">namespace</strong>="myNamespace"} 1604875874</span><span id="4f8d" class="lt lu it lp b gy ns lw l lx ly">kube_job_status_failed{<strong class="lp iu">job_name</strong>="hello-1604875860", <strong class="lp iu">namespace</strong>="myNamespace", <strong class="lp iu">reason</strong>="BackoffLimitExceeded"} 1</span><span id="375b" class="lt lu it lp b gy ns lw l lx ly">kube_cronjob_spec_suspend{<strong class="lp iu">cronjob</strong>="hello",<strong class="lp iu">job</strong>="kube-state-metrics", <strong class="lp iu">namespace</strong>="myNamespace"} 0</span></pre><p id="0ec6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">kube-state-metrics将报告所有现有对象的度量。如前所述，通常会保留作业的历史记录，以便调试故障(与<code class="fe nb nc nd lp b">.spec.successfulJobsHistoryLimit</code>和<code class="fe nb nc nd lp b">.spec.failedJobsHistoryLimit</code>中指定的一样多)。这意味着失败的作业将持续被报告为失败，即使该作业的后续执行已经成功。这里的困难是识别由同一个CronJob(同一个<code class="fe nb nc nd lp b">owner_name</code>)触发的一组作业的最后一次运行，并且只在这一次失败时发出警报。</p><p id="0f63" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于<code class="fe nb nc nd lp b">kube_job_status_failed</code>指标不包含<code class="fe nb nc nd lp b">owner_name</code>标签，所以第一步是连接这两个指标:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="1223" class="lt lu it lp b gy lv lw l lx ly">max(<br/>  kube_job_status_start_time<br/>  * ON(job_name,namespace) GROUP_RIGHT()<br/>  kube_job_owner{owner_name!=””}<br/>  )<br/>BY (job_name, owner_name, namespace)</span></pre><blockquote class="nt nu nv"><p id="9f20" class="kb kc lj kd b ke kf kg kh ki kj kk kl nw kn ko kp nx kr ks kt ny kv kw kx ky im bi translated">我们使用<code class="fe nb nc nd lp b">max</code>查询函数，因为根据Prometheus scrape配置，指标可能包含类似<code class="fe nb nc nd lp b">pod=”kube-state-metrics-asdfaikhp-9fjk76”</code>的标签。如果pod失效，或者您正在为HA(高可用性)运行多个kube-state-metrics pod，则最大查询功能将只根据需要为每个作业返回一个结果。</p></blockquote><p id="f419" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设我们的作业历史包含两个作业(一个失败，另一个成功)，结果将如下所示:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="0835" class="lt lu it lp b gy lv lw l lx ly">{<strong class="lp iu">job_name</strong>=”hello-1623578940", <strong class="lp iu">namespace</strong>=”myNamespace”, <strong class="lp iu">owner_name</strong>=”hello”} 1623578959<br/>{<strong class="lp iu">job_name</strong>=”hello-1617667200", <strong class="lp iu">namespace</strong>=”myNamespace”, <strong class="lp iu">owner_name</strong>=”hello”} 1617667204</span></pre><p id="b00e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们知道了每个作业的所有者，我们需要找出最后执行的是哪个作业。我们可以通过按<code class="fe nb nc nd lp b">owner_name</code>标签聚合结果来实现这一点:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="8dcd" class="lt lu it lp b gy lv lw l lx ly">max(<br/>  kube_job_status_start_time<br/>  * ON(job_name,namespace) GROUP_RIGHT()<br/>  kube_job_owner{owner_name!=""}<br/>) <br/>BY (owner_name)</span></pre><p id="a906" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将这两个查询放在一起:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="ab35" class="lt lu it lp b gy lv lw l lx ly">max(<br/> kube_job_status_start_time<br/> * ON(job_name,namespace) GROUP_RIGHT()<br/> kube_job_owner{owner_name!=””}<br/>)<br/>BY (job_name, owner_name, namespace)<br/>== ON(owner_name) GROUP_LEFT()<br/>max(<br/> kube_job_status_start_time<br/> * ON(job_name,namespace) GROUP_RIGHT()<br/> kube_job_owner{owner_name!=””}<br/>)<br/>BY (owner_name)</span></pre><p id="2984" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">结果将显示每个CronJob最后执行的作业，并且只显示最后一个作业:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="518a" class="lt lu it lp b gy lv lw l lx ly">{<strong class="lp iu">job_name</strong>=”hello-1623578940", <strong class="lp iu">namespace</strong>=”myNamespace”, <strong class="lp iu">owner_name</strong>=”hello”} 1623578959</span></pre><p id="38c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了可读性，我们借此机会将<code class="fe nb nc nd lp b">job_name</code>和<code class="fe nb nc nd lp b">owner_name</code>标签分别替换为<code class="fe nb nc nd lp b">job</code>和<code class="fe nb nc nd lp b">cronjob</code>:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="33c0" class="lt lu it lp b gy lv lw l lx ly">label_replace(<br/>  label_replace(<br/>    max(<br/>      kube_job_status_start_time<br/>      * ON(job_name,namespace) GROUP_RIGHT()<br/>      kube_job_owner{owner_name!=””}<br/>    )<br/>    BY (job_name, owner_name, namespace)<br/>    == ON(owner_name) GROUP_LEFT()<br/>    max(<br/>      kube_job_status_start_time<br/>      * ON(job_name,namespace) GROUP_RIGHT()<br/>      kube_job_owner{owner_name!=””}<br/>    )<br/>    BY (owner_name),<br/>  “job”, “$1”, “job_name”, “(.+)”),<br/>“cronjob”, “$1”, “owner_name”, “(.+)”)</span></pre><p id="4a24" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将使用<em class="lj"> r </em> <a class="ae li" href="https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/#recording-rules" rel="noopener ugc nofollow" target="_blank"> <em class="lj">记录规则:</em> </a>将这个查询的结果存储在一个新的度量中</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="68b4" class="lt lu it lp b gy lv lw l lx ly">- record: job:kube_job_status_start_time:max<br/>  expr: |<br/>    label_replace(<br/>      label_replace(<br/>        max(<br/>          kube_job_status_start_time<br/>          * ON(job_name,namespace) GROUP_RIGHT()<br/>          kube_job_owner{owner_name!=””}<br/>        )<br/>        BY (job_name, owner_name, namespace)<br/>        == ON(owner_name) GROUP_LEFT()<br/>        max(<br/>          kube_job_status_start_time<br/>          * ON(job_name,namespace) GROUP_RIGHT()<br/>          kube_job_owner{owner_name!=””}<br/>        )<br/>        BY (owner_name),<br/>      “job”, “$1”, “job_name”, “(.+)”),<br/>    “cronjob”, “$1”, “owner_name”, “(.+)”)</span></pre><p id="3843" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经有了给定cronjob的最近启动的作业，我们想利用<code class="fe nb nc nd lp b">kube_job_status_failed</code>指标找出哪些作业失败了:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="d1ff" class="lt lu it lp b gy lv lw l lx ly">- record: job:kube_job_status_failed:sum<br/>  expr: |<br/>    clamp_max(<br/>      job:kube_job_status_start_time:max,1)<br/>      * ON(job) GROUP_LEFT()<br/>      label_replace(<br/>        label_replace(<br/>          (kube_job_status_failed != 0),<br/>          “job”, “$1”, “job_name”, “(.+)”),<br/>        “cronjob”, “$1”, “owner_name”, “(.+)”)</span></pre><p id="23f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">clamp_max将<code class="fe nb nc nd lp b">job:kube_job_status_start_time:max</code>的结果转换成一组上限为1的时间序列，我们可以用它通过乘法来过滤失败的作业。结果是一个新的度量<code class="fe nb nc nd lp b">job:kube_job_status_failed:sum</code>，它包含一组最近失败的作业。</p><p id="4718" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后一步是为失败的作业设置警报:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="d33c" class="lt lu it lp b gy lv lw l lx ly">- alert: CronJobStatusFailed<br/>  expr: |<br/>    job:kube_job_status_failed:sum<br/>    * ON(cronjob,namespace) GROUP_LEFT()<br/>    (kube_cronjob_spec_suspend == 0)</span></pre><p id="c65a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了避免误报，我们已经从相同的作业中排除了暂停的作业。</p><h2 id="74f6" class="lt lu it bd ma nz oa dn me ob oc dp mi km od oe mm kq of og mq ku oh oi mu oj bi translated">关于这篇文章</h2><p id="7c60" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated">这篇文章很大程度上受到几年前由特里斯坦发表的一篇文章的启发。由于kube-state-metrics随着时间的推移改变了一些指标，我们一直在使用略有不同的表达式，随着最近2.0版的发布，我们不得不使用一组不同的指标。核心思想是一样的，所以谢谢Tristan的分享！</p><h1 id="6f96" class="lz lu it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">结论</h1><p id="1518" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated">虽然kube-state-metrics报告的指标非常有用且丰富，但它们并没有使失败作业的警报任务变得容易。我们希望您会发现这很有用，因为我们在首次设置作业监控时就发现了Tristan的文章。</p></div></div>    
</body>
</html>