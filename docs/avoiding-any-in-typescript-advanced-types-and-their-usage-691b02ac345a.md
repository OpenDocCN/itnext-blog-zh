# 在 TypeScript 中避免任何—高级类型及其用法

> 原文：<https://itnext.io/avoiding-any-in-typescript-advanced-types-and-their-usage-691b02ac345a?source=collection_archive---------1----------------------->

TypeScript 为 JavaScript 开发人员提供了在代码中提供严格类型的机会。然而，由于 JavaScript 的性质，在某些情况下，提供准确的类型并不是一项简单的任务。在这种情况下，程序员倾向于使用*any*——一种允许用户在里面存储任何东西的打字撬锁。在这篇文章中，我想展示一些内置类型和内置类型脚本特性，您可以使用它们来避免任何 T2 或简化一些自定义类型。

![](img/82a079e55b986a2e163e144d3adea528.png)

# JavaScript 对象

很可能，几乎每个 JavaScript 开发人员都曾经使用过一个对象作为类似地图的集合。然而，对于严格类型来说，如何键入可能不是那么明显(特别是对于[无字符串文字](https://palantir.github.io/tslint/rules/no-string-literal/) TSLint 规则)。第一个定位选项是 *any* ，但是我们丢失了值类型的信息。所以，我们可以严格地用特定的键来输入一个接口——但是这样我们就不能给对象添加任何东西。另一个选项是*对象*或 *{}* ，但这意味着“空对象”，所以我们不能在其中设置任何东西。那么，标准的方式是什么？

*记录*

让我们来看看定义:

清单 1 来自 lib.es5.ts 的记录定义

以及用法:

清单 2 使用记录类型的例子

如您所见，这意味着开发人员可以输入任何键，但是值必须是特定的类型。更重要的是，我们可以将它与其他类型结合起来，从而用一些预定义的键(甚至不同值类型的键)来创建字典！)通过 IntelliSense 可见，例如:

清单 3 使用记录类型的更高级的例子

我不认为我需要写这个的实际用法。当然，我们有一个名为“Map”的内置 ES6 集合，它为字典提供了更好的体验，但根据[基准](https://jsperf.com/es6-map-vs-object-properties/73)，当我们只想设置和获取值时，使用对象(Record)会更快。

# 其他类型属性的质量修改器

当我们已经有一个定义了属性的类型，但我们不喜欢它的定义方式时，该怎么办？也许我们希望所有的属性都是可选的、必需的或只读的？TypeScript 中还包含了类型*部分*、*必需*和*只读*。让我们看看它们的定义:

清单 4 lib . es5 . ts 中的部分、必需和只读定义

当然，正如文章的标题所告诉我们的，只有*部分*可以真正用来代替*任何*，但这三者在某种程度上是相互联系的，所以不一起写它们是一种浪费。

它们提供了一些非常实用的用法。Readonly 在 React 的类型化中很常见——在组件中，有些东西你不能直接编辑，但是你是定义类型的人，比如组件的状态或属性。

*部分*用在你想提供不提供整个对象的可能性的地方。一个流行的用法示例是提供通过一个函数(或构造函数)设置对象值的可能性，而不是通过单独设置属性。下面的清单给出了这种用法的一个例子。

清单 5 使用部分

*要求*是*的反义词，偏*。然而，这里的用法并不简单，因为它在编译期间检查是否所有东西都在类型级别上设置。既然没见过什么好的，实用的用法，就不提供了。如果你有一些，请让我知道。

# 挑选和省略某一类型的特定部分

之前我们讨论了 *Partial* ，它允许我们将类型中的一切都变成可选的。也就是说，我们可能还希望获取对象的特定部分，而不将其更改为可选的(这使得键入更加严格)。我来介绍一下*挑*:

清单 6 从 lib.es5.ts 中挑选定义

Pick 的工作方式是这样的:它只接受第二种类型的特定属性。下面是它如何工作的一个例子:

清单 7 Pick 的用法

*Pick* 可能看起来不是很有用，因为事实上它只从第二种类型中获取给定的键或键。所以你可能会问:为什么我们不直接使用第二种类型，或者只从那些键构建一个类型？原因是这样的——我们保留了原始类型的信息。为什么*不偏*？区别在于当你在编译器设置中打开 *strictNullChecks* 标志时。让我们回顾一个例子:

清单 Pick 和 Partial 之间的区别

如您所见， *Pick* 不允许像在原始类型中定义的那样设置空值(也是未定义的)。 *Partial* 只是让一切都可以为空，所以它确实中断了原来的输入。在实践中，它被用在，例如，React，setState 函数中。

也就是说，我提到了省略。我们没有内置的类型，但是我们可以像这样为自己创建一个:

清单 9 省略类型的定义

*(更新:* [*)既然 TypeScript 3.5，我们已经内置了省略类型*](https://github.com/Microsoft/TypeScript/wiki/What%27s-new-in-TypeScript#typescript-35) *，所以没必要自己定义)*

这样，我们可以执行下面的事情:

清单 10 使用 Omit 的例子

如果将这个清单中的对象 e 和 f 与清单 7 中的对象 c 和 d 进行比较，您会发现我们得到了完全相反的东西。在 Ramda 中可以看到一个使用*省略*的例子，用来描述一个叫做*省略*的函数的结果(很惊讶吧？).

# 未知和高级元组类型

我在文章的这一部分简要描述的两个 TypeScript 特性都是在 TypeScript 3.0 中引入的，我已经在[我的关于 TypeScript 3.0 的文章](/typescript-3-0-what-has-come-19f81d1fac60)中介绍了它们。

当我们不知道对象的正确类型时，应该使用 unknown。不像*任何*，它不允许你对一个值做任何操作，直到我们知道它的类型(通过适当的类型检查)。

我所说的高级元组类型主要是指用元组类型提取和传播函数参数，这是在 TypeScript 3.0 中引入的。有了它们，我们可以为数组中的特定值定义特定的类型。虽然乍一看，这听起来不是很有帮助，但它们在键入函数式编程特性(如 compose)时会很有用。

我鼓励您阅读我在上面链接的文章，以获得更详细的描述，以及用法示例，这样您可以更好地掌握它们。

# 摘要

TypeScript 有很多类型化的武器，可以用来在 JavaScript 的动态类型化环境中保持静态类型。整个问题是它是隐藏的，它的用法并不总是那么简单。然而，虽然本文没有描述 TypeScript 提供的所有功能，但我希望它能帮助您编写可以更好地键入的代码。

> 这篇文章也发表在 Synergy Codes 的[博客上，Synergy Codes](https://www.synergycodes.com/blog/software-development/avoiding-any-in-typescript-advanced-types)是一家专注于流程可视化、映射和建模的软件公司。
> 您对创建数据可视化应用感兴趣吗？[点击这里了解 GoJS 库](https://synergycodes.com/gojs-ebook/)！