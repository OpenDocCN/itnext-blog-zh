<html>
<head>
<title>Adding security layers to your App on OpenShift - Part 6: PKI as a Service with Vault and Cert Manager</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在OpenShift上向您的应用程序添加安全层-第6部分:使用Vault和Cert Manager的PKI服务</h1>
<blockquote>原文：<a href="https://itnext.io/adding-security-layers-to-your-app-on-openshift-part-6-pki-as-a-service-with-vault-and-cert-e6dbbe7028c7?source=collection_archive---------0-----------------------#2020-03-12">https://itnext.io/adding-security-layers-to-your-app-on-openshift-part-6-pki-as-a-service-with-vault-and-cert-e6dbbe7028c7?source=collection_archive---------0-----------------------#2020-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="782f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天，保护你的应用程序是必须的，但是如果你没有在一开始就考虑它，那么在不修改代码的情况下引入它是很困难的。幸运的是，像<a class="ae kl" href="http://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>这样的容器和平台带来的新的云原生模式提供了简单的方法来解决安全问题，而无需接触代码。</p><p id="36d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本系列的第一部分中，我们已经学习了如何将我们的<code class="fe km kn ko kp b">fruits-catalog</code>应用程序部署为容器。我们已经在Red Hat Kubernetes发行版<a class="ae kl" href="http://www.openshift.com/" rel="noopener ugc nofollow" target="_blank"> OpenShift </a>上展示了容器化的好处，并完成了我们如何在TLS支持下通过<a class="ae kl" href="https://docs.openshift.com/container-platform/3.11/dev_guide/routes.html" rel="noopener ugc nofollow" target="_blank"> Route </a>轻松保护对应用程序的访问。</p><p id="45c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，我们并没有深入研究TLS证书是如何颁发和分发的……我们应用了使用通配符证书的默认配置——这对于任务关键型平台来说可能是一个非常糟糕的想法。这个新的部分是关于如何在这个高度不稳定的云本地环境中自动化证书管理。我们将使用<a class="ae kl" href="https://cert-manager.io/" rel="noopener ugc nofollow" target="_blank"> Cert-Manager </a>和<a class="ae kl" href="http://vaultproject.io/" rel="noopener ugc nofollow" target="_blank"> Hashicorp Vault </a>来部署一个<a class="ae kl" href="https://en.wikipedia.org/wiki/Public_key_infrastructure" rel="noopener ugc nofollow" target="_blank"> PKI </a>作为服务方法，从而深入研究证书发布的细节。</p><blockquote class="kq kr ks"><p id="98df" class="jn jo kt jp b jq jr js jt ju jv jw jx ku jz ka kb kv kd ke kf kw kh ki kj kk ij bi translated">这部分由Hashicorp的<a class="ae kl" href="https://medium.com/@nehrman" rel="noopener"> Nicolas Ehrman </a>实现并校对。感谢Nico的帮助和建议！</p></blockquote><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/91101e49045bbf764735c952fe63028f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KRLOrLxTS7neWm4VJhXZQQ.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">第6部分—使用Vault和证书管理器的PKI服务</figcaption></figure><p id="936a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kt">这篇文章是一个更大的系列文章的一部分，讲述了如何给现有的应用程序增加安全层。到目前为止公布的其他部分有:</em></p><ul class=""><li id="f3c8" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-1-deployment-and-tls-ingress-9ef752835599" rel="noopener"> <em class="kt">第1部分——部署和TLS入口</em> </a></li><li id="0a37" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-2-8320018bcdd1" rel="noopener"> <em class="kt">第二部分——使用Keycloak进行认证和授权</em> </a></li><li id="5b40" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-3-secret-management-with-vault-8efd4ec29ec4" rel="noopener"> <em class="kt">第三部分——金库秘密管理</em> </a></li><li id="bc3f" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-4-dynamic-secrets-with-vault-b5fe1fc7709b" rel="noopener"> <em class="kt">第四部分——带金库的动态秘密</em> </a></li><li id="8a71" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-5-mutual-tls-with-istio-a8800c2e4df4" rel="noopener"> <em class="kt">第5部分——与Istio </em> </a>的相互TLS</li><li id="2be6" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated"><em class="kt">第6部分—使用保管库和证书管理器的PKI服务(本文)</em></li></ul><h1 id="fda0" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">我们想在这部分实现什么？</h1><p id="27d9" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">如上所述，默认的OpenShift设置使用通配符证书来保护所有需要TLS传输的路由。因为这在许多情况下可能是一个真正的好主意，比如非生产环境、只有很少终端可以公开的初创公司或对成本感到困扰的公司(即使<a class="ae kl" href="https://community.letsencrypt.org/t/acme-v2-and-wildcard-certificate-support-is-live/55579" rel="noopener ugc nofollow" target="_blank"> Let's Encrypt现在提供免费的通配符证书</a>)；对于大多数公司来说，这通常不是一个好主意。事实上，通配符证书与安全原则相矛盾，即<a class="ae kl" href="https://searchdisasterrecovery.techtarget.com/definition/risk-mitigation" rel="noopener ugc nofollow" target="_blank">降低风险</a>。一旦通配符证书遭到破坏或损坏，或者需要刷新，所有子域以及使用它的应用程序都会受到影响！</p><p id="3a0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，管理每个应用程序的证书颁发、撤销和续订(尤其是在高度不稳定的环境中)可能是一项艰巨的任务，如果不是自动化的话。这就是<a class="ae kl" href="https://cert-manager.io/" rel="noopener ugc nofollow" target="_blank">证书管理器</a>出现的原因！Cert Manager是一款自动化软件，用于在云环境中自动管理证书。它允许发布、刷新和撤销证书，并与我们想要存储根证书和中间证书颁发机构的Vault很好地集成。</p><p id="8be5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们将为OpenShift部署名为<a class="ae kl" href="https://github.com/redhat-cop/cert-utils-operator" rel="noopener ugc nofollow" target="_blank"> Cert Utils </a>的Cert Manager及其配套工具。该组件将在部署时用于发布关于即将到来的部署请求的证书，并将它们注入我们的资源。新组件将对我们部署链上的两个新事件做出反应:</p><ul class=""><li id="fdc2" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">名为<code class="fe km kn ko kp b">Certificate</code>的新Kubernetes资源的创建/更新/删除(这实际上是一个证书发布请求)，</li><li id="d4b7" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated">创建/更新/删除我们已经存在的<code class="fe km kn ko kp b">Route</code></li></ul><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ne"><img src="../Images/0422dd592dbeab9556a83b0008c3d5ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0e0TBjMSSHuPi2NFcn4nvg.png"/></div></div></figure><p id="4cd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完整流程可以描述如下:</p><ol class=""><li id="2c9e" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk nf lt lu lv bi translated">在应用程序<code class="fe km kn ko kp b">Certificate</code>上发生“变更事件”时，Cert Manager将负责发布与请求参数相对应的新证书。为此，Cert Manager将调用拥有我们的根私钥基础结构和一些中间私钥基础结构的Vault，</li><li id="86ac" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk nf lt lu lv bi translated">在颁发新证书之前，Vault将使用Kubernetes作为身份验证提供者来检查证书管理器的真实性和权限。然后，它将创建一个由根CA签名的特定证书，</li><li id="32aa" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk nf lt lu lv bi translated">证书管理器将把这个新证书存储为Kubernetes <a class="ae kl" href="https://kubernetes.io/docs/concepts/configuration/secret/" rel="noopener ugc nofollow" target="_blank">秘密</a>。证书信息确实由三个属性表示到这个秘密中:<code class="fe km kn ko kp b">ca.crt</code>、<code class="fe km kn ko kp b">tls.crt</code>和<code class="fe km kn ko kp b">tls.key</code></li><li id="8f99" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk nf lt lu lv bi translated">在应用程序<code class="fe km kn ko kp b">Route</code>上的“变更事件”中，Cert Utils将检索先前创建的秘密，</li><li id="32a7" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk nf lt lu lv bi translated">然后，它将变异—在这里意味着“注入”—使用这个新证书的路由。该路由被重新配置为使用这个新生成的证书来使用和公开对应用程序端点的访问。</li></ol><h1 id="d7e4" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">如何应用？</h1><blockquote class="kq kr ks"><p id="950c" class="jn jo kt jp b jq jr js jt ju jv jw jx ku jz ka kb kv kd ke kf kw kh ki kj kk ij bi translated">在开始动手操作之前，我们假设您已经部署并配置了Vault来使用Kubernetes身份验证。如何做到这一点在本系列的第3部分中有详细介绍。</p></blockquote><p id="a63b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们开始配置Vault来托管我们的PKI。第一步是安装一个新的<code class="fe km kn ko kp b">pki</code>后端。接下来，必须使用CA证书和关联的私钥来配置Vault。我们将利用后端的自签名根生成支持，但Vault也支持生成中间CA(带有用于签名的CSR)或直接在后端设置PEM编码的证书和私钥包。</p><p id="9a8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的设置中，我们将使用一个根证书来签署CA中间证书。因为它是一个根，我们想为证书设置一个长的最大生命周期；因为它支持最大装载TTL，所以在生成与我们的全局集群URL相对应的新CA证书之前，我们首先对其进行调整——这是<code class="fe km kn ko kp b">$COMMON_NAME</code>:</p><pre class="ky kz la lb gt ng kp nh ni aw nj bi"><span id="b5f4" class="nk mc iq kp b gy nl nm l nn no">$ vault secrets enable -tls-skip-verify pki<br/>Success! Enabled the pki secrets engine at: pki/</span><span id="7be8" class="nk mc iq kp b gy np nm l nn no">$ vault secrets tune -tls-skip-verify -max-lease-ttl=8760h pki<br/>Success! Tuned the secrets engine at: pki/</span><span id="4488" class="nk mc iq kp b gy np nm l nn no">$ export COMMON_NAME=$(echo $(oc whoami --show-server) | sed -E -n 's=<a class="ae kl" href="https://api.(.*):6443=\1=p')" rel="noopener ugc nofollow" target="_blank">https://api.(.*):6443=\1=p')</a></span><span id="ac83" class="nk mc iq kp b gy np nm l nn no">$ vault write -tls-skip-verify pki/root/generate/internal \<br/>    common_name="$COMMON_NAME Root Authority" \<br/>    ttl=8760h</span></pre><p id="f198" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在必须设置我们的中间CA，为此我们将使用一个不同的名为<code class="fe km kn ko kp b">pki_int</code>的PKI后端。我们还可以在这里调整已颁发证书的最大TTL，它应该小于或等于根CA TTL。然后，我们必须要求中介生成一个证书签名请求，该请求将被存储到一个名为<code class="fe km kn ko kp b">pki_int.csr</code>的本地文件中。然后，我们从中间机构获取签名请求，并使用根机构对其进行签名；然后将得到的签名证书设置为中间机构。下面的命令就是这样做的:</p><pre class="ky kz la lb gt ng kp nh ni aw nj bi"><span id="6dc4" class="nk mc iq kp b gy nl nm l nn no">$ vault secrets enable -tls-skip-verify -path=pki_int pki<br/>Success! Enabled the pki secrets engine at: pki_int/</span><span id="2906" class="nk mc iq kp b gy np nm l nn no">$ vault secrets tune -tls-skip-verify -max-lease-ttl=30m pki_int<br/>Success! Tuned the secrets engine at: pki_int/</span><span id="0f34" class="nk mc iq kp b gy np nm l nn no">$ vault write -tls-skip-verify -field=csr pki_int/intermediate/generate/internal \<br/>    common_name="apps.$COMMON_NAME Intermediate Authority" \<br/>    ttl=4760h &gt;&gt; <a class="ae kl" href="http://twitter.com/pki_int" rel="noopener ugc nofollow" target="_blank">pki_int</a>.csr</span><span id="4af2" class="nk mc iq kp b gy np nm l nn no">$ vault write -tls-skip-verify -field=certificate pki/root/sign-intermediate csr=<a class="ae kl" href="http://twitter.com/pki_int" rel="noopener ugc nofollow" target="_blank">@pki_int</a>.csr format=pem_bundle ttl=4760h &gt;&gt; <a class="ae kl" href="http://twitter.com/signed_certificate" rel="noopener ugc nofollow" target="_blank">signed_certificate</a>.pem</span><span id="2a48" class="nk mc iq kp b gy np nm l nn no">$ vault write -tls-skip-verify pki_int/intermediate/set-signed certificate=<a class="ae kl" href="http://twitter.com/signed_certificate" rel="noopener ugc nofollow" target="_blank">@signed_certificate</a>.pem<br/>Success! Data written to: pki_int/intermediate/set-signed</span></pre><p id="ccaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们必须配置使用这个中间PKI的URL端点。我们还必须配置一个角色——一个映射到用于生成新证书的策略的逻辑名称。例如，我们在这里使用了一个由第三个命令创建的策略<code class="fe km kn ko kp b">cert-manager-vault-issuer-pki-policy</code>引用的<code class="fe km kn ko kp b">example-opentlc-com</code>角色:</p><pre class="ky kz la lb gt ng kp nh ni aw nj bi"><span id="0fb1" class="nk mc iq kp b gy nl nm l nn no">$ vault write -tls-skip-verify pki_int/config/urls \<br/>    issuing_certificates="$VAULT_ADDR/v1/pki_int/ca" \<br/>    crl_distribution_points="$VAULT_ADDR/v1/pki_int/crl"<br/>Success! Data written to: pki_int/config/urls</span><span id="6e88" class="nk mc iq kp b gy np nm l nn no">$ vault write -tls-skip-verify pki_int/roles/example-opentlc-com \<br/>    allowed_domains="apps.$COMMON_NAME" \<br/>    allow_subdomains=true \<br/>    max_ttl=1h<br/>Success! Data written to: pki_int/roles/example-opentlc-com</span><span id="7f65" class="nk mc iq kp b gy np nm l nn no">$ vault policy write -tls-skip-verify cert-manager-vault-issuer-pki-policy ./k8s/cert-manager-vault-issuer-policy-pki.hcl<br/>Success! Uploaded policy: cert-manager-vault-issuer-pki-policy</span></pre><p id="a7d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，保险库部分是确定的，让我们处理证书管理器的东西！我们将开始创建一个新项目来托管我们的新组件<code class="fe km kn ko kp b">cert-manager</code>和<code class="fe km kn ko kp b">cert-utils</code>。我们需要注释这个新的名称空间，告诉Cert Manager不要验证这个项目。</p><pre class="ky kz la lb gt ng kp nh ni aw nj bi"><span id="7b88" class="nk mc iq kp b gy nl nm l nn no">$ oc new-project cert-manager<br/>$ oc label namespace cert-manager certmanager.k8s.io/disable-validation=true<br/>$ oc apply --validate=false -f <a class="ae kl" href="https://github.com/jetstack/cert-manager/releases/download/v0.13.0/cert-manager-openshift.yaml" rel="noopener ugc nofollow" target="_blank">https://github.com/jetstack/cert-manager/releases/download/v0.13.0/cert-manager-openshift.yaml</a></span></pre><p id="a6f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于OpenShift，我们需要部署Cert Utils配套组件。这可以使用Helm打包实用程序来完成:您需要在工作站上安装<code class="fe km kn ko kp b">helm</code> CLI工具。</p><pre class="ky kz la lb gt ng kp nh ni aw nj bi"><span id="0fbd" class="nk mc iq kp b gy nl nm l nn no">$ helm version<br/>version.BuildInfo{Version:"v3.0.3", GitCommit:"ac925eb7279f4a6955df663a0128044a8a6b7593", GitTreeState:"clean", GoVersion:"go1.13.7"}</span><span id="3423" class="nk mc iq kp b gy np nm l nn no">$ export CERT_UTILS_CHART_VERSION=$(helm search repo cert-utils-operator/cert-utils-operator | grep cert-utils-operator/cert-utils-operator | awk '{print $2}')</span><span id="2a7f" class="nk mc iq kp b gy np nm l nn no">$ helm fetch cert-utils-operator/cert-utils-operator --version ${CERT_UTILS_CHART_VERSION}</span><span id="220f" class="nk mc iq kp b gy np nm l nn no">$ helm template cert-utils-operator-${CERT_UTILS_CHART_VERSION}.tgz --namespace cert-manager | oc apply -f - -n cert-manager</span></pre><p id="ed17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Cert Manager上，我们必须声明一个<code class="fe km kn ko kp b">Issuer</code>，它将能够使用一些PKI来处理证书创建。幸运的是，证书管理器有一个保险库实现。为了只允许此颁发者向Vault请求新证书，我们必须创建一个专用服务帐户，其令牌和相关证书将用于配置此<code class="fe km kn ko kp b">vault-issuer</code>。在保险库端，在实际创建发行者之前，我们必须声明这个<code class="fe km kn ko kp b">cert-manager-vault-issuer</code>服务帐户可以用来触发之前声明的策略:</p><pre class="ky kz la lb gt ng kp nh ni aw nj bi"><span id="9be4" class="nk mc iq kp b gy nl nm l nn no">$ oc create sa cert-manager-vault-issuer -n cert-manager</span><span id="592e" class="nk mc iq kp b gy np nm l nn no">$ export CERT_MANAGER_ISSUER_TOKEN=$(oc get sa/cert-manager-vault-issuer -n cert-manager -o yaml | grep cert-manager-vault-issuer-token | awk '{print $3}')</span><span id="17b4" class="nk mc iq kp b gy np nm l nn no">$ export VAULT_LISTENER_CERT=$(oc exec -n fruits-catalog -it $(oc get pods -n fruits-catalog | grep vault | awk '{print $1}') -- /bin/sh -c "cat /var/run/secrets/kubernetes.io/certs/tls.crt")</span><span id="f8b6" class="nk mc iq kp b gy np nm l nn no"># Report this values in vault-issuer.yml<br/>$ sed -i '' 's=CERT_MANAGER_ISSUER_TOKEN='"$CERT_MANAGER_ISSUER_TOKEN"'=' k8s/vault-issuer.yml<br/>$ sed -i '' 's=VAULT_LISTENER_CERT='"$(echo $VAULT_LISTENER_CERT | base64)"'=' k8s/vault-issuer.yml</span><span id="a816" class="nk mc iq kp b gy np nm l nn no">$ vault write -tls-skip-verify auth/kubernetes/role/cert-manager-vault-issuer \<br/>  bound_service_account_names=cert-manager-vault-issuer \<br/>  bound_service_account_namespaces=cert-manager \<br/>  policies=cert-manager-vault-issuer-pki-policy \<br/>  ttl=24h<br/>Success! Data written to: auth/kubernetes/role/cert-manager-vault-issuer</span><span id="1650" class="nk mc iq kp b gy np nm l nn no">$ oc apply -f ./k8s/vault-issuer.yml -n cert-manager</span></pre><p id="82dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在应该可以运行了！</p><h1 id="dce2" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">检查它是否按预期工作</h1><p id="26ef" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">现在，最后创建一个<code class="fe km kn ko kp b">Certificate</code>资源，该资源将由证书管理器处理，以颁发新证书并创建请求的机密:</p><pre class="ky kz la lb gt ng kp nh ni aw nj bi"><span id="d715" class="nk mc iq kp b gy nl nm l nn no">$ export FRUITS_CATALOG_ROUTE=$(oc get routes fruits-catalog -n fruits-catalog | grep fruits-catalog | awk '{print $2}')</span><span id="288e" class="nk mc iq kp b gy np nm l nn no">$ sed -i '' 's=FRUITS_CATALOG_ROUTE='"$FRUITS_CATALOG_ROUTE"'=g' k8s/fruits-catalog-route-certificate.yml</span><span id="ed38" class="nk mc iq kp b gy np nm l nn no">$ oc apply -f ./k8s/fruits-catalog-route-certificate.yml -n fruits-catalog</span></pre><p id="9963" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几秒钟后，检查是否创建了新的<code class="fe km kn ko kp b">fruits-catalog-route-secret</code>密钥，并保存了密钥和ca.crt条目:</p><pre class="ky kz la lb gt ng kp nh ni aw nj bi"><span id="a172" class="nk mc iq kp b gy nl nm l nn no">$ oc get secrets fruits-catalog-route-secret -o yaml -n fruits-catalog<br/>apiVersion: v1<br/>data:<br/>  ca.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURsRENDQW55Z0F3SUJBZ0lVYitML1luZStaNGhLcUFNRXZwaW0wcDRsSnZVd0RRWUpLb1pJaHZjTkFRRUwKQlFBd1N6RkpNRWNHQTFVRUF4TkFZMngxYzNSbGNpMXdZWEpwY3kweVltUTBMbkJoY21sekxUSmlaRFF1WlhoaApiWEJzWlM1dmNHVnVkR3hqTG1OdmJTQlNiMjkwSUVGMWRHaHZjbWwwZVRBZUZ3MHlNREF6TURZeE16VTBOREphCkZ3MHlNREE1TWpBeU1UVTFNVEphTUZneFZqQlVCZ05WQkFNVFRXRndjSE11WTJ4MWMzUmxjaTF3WVhKcGN5MHkKWW1RMExuQmhjbWx6TFRKaVpEUXVaWGhoYlhCc1pTNXZjR1Z1ZEd4akxtTnZiU0JKYm5SbGNtMWxaR2xoZEdVZwpRWFYwYUc5eWFYUjVNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDQVFFQXdKb1RabGtSCkNPWDBNdHBzVitpaHdQeHRFOG1vVTZMVVpsd2FLR2NuNk5CVWRDdHhpdGpoTGpqLzliTjdFT3I0ZkYxQXIxL1QKcFlodThPSEdaNDZNQlhzZjVJOUE1dmJIVlBLZnhDMFZsckgzd1dPend1M2pFRGFPdE11NDZFYjlMeWhNRXk5QQpMaXYyalhSdEFhRWpOU0F5WlJtRTF0RWRNWTdha2xjVkc3a21jLy9qblN3NUJwSEpuNElnZVFoQTgzSDl1WWoxCmN6Y3ZnL1pMbk0zTmVJY01mTFhtZDFSN2NZZEhBam1adDdFMGZuVTBkaDdQajlmRnZ4MUIraDFMYnRRQ1J3a2oKeXAvbmlrb0tIQkJLZk41SkxwYkJ6TXFpNm1uVmdlbzJjNUx2Y0t2WmlmUEMzTlFodFBRODRoYWNmWUtMVm5ESApKN2ZybS83VzV3aW9zd0lEQVFBQm8yTXdZVEFPQmdOVkhROEJBZjhFQkFNQ0FRWXdEd1lEVlIwVEFRSC9CQVV3CkF3RUIvekFkQmdOVkhRNEVGZ1FVa0daN3l1Rm1pcGl3a2JNdDdOUGxIQTdTNlZjd0h3WURWUjBqQkJnd0ZvQVUKVElUZVBtMUdQT0tFbXpyTjhSaGJBUm9IQ0VFd0RRWUpLb1pJaHZjTkFRRUxCUUFEZ2dFQkFEcVE5cWhaTHJ3bwpISXE0YlJOUTJYODI4WTZsYno0V3BrdDNGalQyNCtwMWVFaGdLYVhvV2d5RmlxekxxRnZoSmhRUFRhZ2JYL1JUCmgyODgwd2hvYTROUExxR2pZK0hUdjRkcnZNaVJWY0I3S0F3WUFLbWxiamluRk9MNS9abzROVFJESUJPWGpQWVcKcVFBRUxtb1FvNVpXQ01HOC8ycWFoRWVYM3dvV293Mm5oRW1DLzNFTTV4NEhLRGZuOXA3azYvZFU4NmN3TnhPNwpYcVJZcExyQ2xnUUpLS09aYWJPeHdSVk02TmNGUTR0c3ZGRGZGOXJEdjNXc0VhV1JkRlA0RzdjeUhSOGk2a1J3CmFHUFdaTHQyRk9xZ1locWNWU094V3pMbWhEaFg4bkN2S1pEUHhWa1pBcUFyVGVidlRHZDhyZkVsVDdrVDkrTFQKMVVRSWN4ZmNCcm89Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0=<br/>[...]</span></pre><p id="ef45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在是时候注释您的路由了，这样这个秘密条目将被注入到您的路由中，以便向访问应用程序的用户提供这个特定的证书:</p><pre class="ky kz la lb gt ng kp nh ni aw nj bi"><span id="5b0f" class="nk mc iq kp b gy nl nm l nn no">$ oc annotate routes/fruits-catalog cert-utils-operator.redhat-cop.io/certs-from-secret=fruits-catalog-route-secret -n fruits-catalog</span></pre><p id="26b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，在检查路线详细信息和获取证书信息之前，请等待几秒钟:</p><pre class="ky kz la lb gt ng kp nh ni aw nj bi"><span id="8de5" class="nk mc iq kp b gy nl nm l nn no">$ oc get route fruits-catalog -o yaml -n fruits-catalog<br/>apiVersion: route.openshift.io/v1<br/>kind: Route<br/>metadata:<br/>  annotations:<br/>    cert-utils-operator.redhat-cop.io/certs-from-secret: fruits-catalog-route-secret<br/>    [...]<br/>  labels:<br/>    app: fruits-catalog<br/>    expose: "true"<br/>    group: com.github.lbroudoux.msa<br/>    provider: fabric8<br/>    version: 1.0.0-SNAPSHOT<br/>  name: fruits-catalog<br/>  namespace: fruits-catalog<br/>  [...]<br/>  port:<br/>    targetPort: 8080<br/>  tls:<br/>    caCertificate: |-<br/>      -----BEGIN CERTIFICATE-----<br/>    MIIDlDCCAnygAwIBAgIUb+L/Yne+Z4hKqAMEvpim0p4lJvUwDQYJKoZIhvcNAQEL<br/>    BQAwSzFJMEcGA1UEAxNAY2x1c3Rlci1wYXJpcy0yYmQ0LnBhcmlzLTJiZDQuZXhh<br/>    bXBsZS5vcGVudGxjLmNvbSBSb290IEF1dGhvcml0eTAeFw0yMDAzMDYxMzU0NDJa<br/>    Fw0yMDA5MjAyMTU1MTJaMFgxVjBUBgNVBAMTTWFwcHMuY2x1c3Rlci1wYXJpcy0y<br/>    YmQ0LnBhcmlzLTJiZDQuZXhhbXBsZS5vcGVudGxjLmNvbSBJbnRlcm1lZGlhdGUg<br/>    QXV0aG9yaXR5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwJoTZlkR<br/>    COX0MtpsV+ihwPxtE8moU6LUZlwaKGcn6NBUdCtxitjhLjj/9bN7EOr4fF1Ar1/T<br/>    pYhu8OHGZ46MBXsf5I9A5vbHVPKfxC0VlrH3wWOzwu3jEDaOtMu46Eb9LyhMEy9A<br/>    Liv2jXRtAaEjNSAyZRmE1tEdMY7aklcVG7kmc//jnSw5BpHJn4IgeQhA83H9uYj1<br/>    czcvg/ZLnM3NeIcMfLXmd1R7cYdHAjmZt7E0fnU0dh7Pj9fFvx1B+h1LbtQCRwkj<br/>    yp/nikoKHBBKfN5JLpbBzMqi6mnVgeo2c5LvcKvZifPC3NQhtPQ84hacfYKLVnDH<br/>    J7frm/7W5wioswIDAQABo2MwYTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUw<br/>    AwEB/zAdBgNVHQ4EFgQUkGZ7yuFmipiwkbMt7NPlHA7S6VcwHwYDVR0jBBgwFoAU<br/>    TITePm1GPOKEmzrN8RhbARoHCEEwDQYJKoZIhvcNAQELBQADggEBADqQ9qhZLrwo<br/>    HIq4bRNQ2X828Y6lbz4Wpkt3FjT24+p1eEhgKaXoWgyFiqzLqFvhJhQPTagbX/RT<br/>    h2880whoa4NPLqGjY+HTv4drvMiRVcB7KAwYAKmlbjinFOL5/Zo4NTRDIBOXjPYW<br/>    qQAELmoQo5ZWCMG8/2qahEeX3woWow2nhEmC/3EM5x4HKDfn9p7k6/dU86cwNxO7<br/>    XqRYpLrClgQJKKOZabOxwRVM6NcFQ4tsvFDfF9rDv3WsEaWRdFP4G7cyHR8i6kRw<br/>    aGPWZLt2FOqgYhqcVSOxWzLmhDhX8nCvKZDPxVkZAqArTebvTGd8rfElT7kT9+LT<br/>     1UQIcxfcBro=<br/>      -----END CERTIFICATE-----<br/>[...]</span></pre><p id="8ddf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您甚至可以验证路由的<code class="fe km kn ko kp b">caCertificate</code>是在<code class="fe km kn ko kp b">ca.crt</code>秘密条目中找到的base64解码字符串:</p><pre class="ky kz la lb gt ng kp nh ni aw nj bi"><span id="f371" class="nk mc iq kp b gy nl nm l nn no">$ echo LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURsRENDQW55Z0F3SUJBZ0lVYitML1luZStaNGhLcUFNRXZwaW0wcDRsSnZVd0RRWUpLb1pJaHZjTkFRRUwKQlFBd1N6RkpNRWNHQTFVRUF4TkFZMngxYzNSbGNpMXdZWEpwY3kweVltUTBMbkJoY21sekxUSmlaRFF1WlhoaApiWEJzWlM1dmNHVnVkR3hqTG1OdmJTQlNiMjkwSUVGMWRHaHZjbWwwZVRBZUZ3MHlNREF6TURZeE16VTBOREphCkZ3MHlNREE1TWpBeU1UVTFNVEphTUZneFZqQlVCZ05WQkFNVFRXRndjSE11WTJ4MWMzUmxjaTF3WVhKcGN5MHkKWW1RMExuQmhjbWx6TFRKaVpEUXVaWGhoYlhCc1pTNXZjR1Z1ZEd4akxtTnZiU0JKYm5SbGNtMWxaR2xoZEdVZwpRWFYwYUc5eWFYUjVNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDQVFFQXdKb1RabGtSCkNPWDBNdHBzVitpaHdQeHRFOG1vVTZMVVpsd2FLR2NuNk5CVWRDdHhpdGpoTGpqLzliTjdFT3I0ZkYxQXIxL1QKcFlodThPSEdaNDZNQlhzZjVJOUE1dmJIVlBLZnhDMFZsckgzd1dPend1M2pFRGFPdE11NDZFYjlMeWhNRXk5QQpMaXYyalhSdEFhRWpOU0F5WlJtRTF0RWRNWTdha2xjVkc3a21jLy9qblN3NUJwSEpuNElnZVFoQTgzSDl1WWoxCmN6Y3ZnL1pMbk0zTmVJY01mTFhtZDFSN2NZZEhBam1adDdFMGZuVTBkaDdQajlmRnZ4MUIraDFMYnRRQ1J3a2oKeXAvbmlrb0tIQkJLZk41SkxwYkJ6TXFpNm1uVmdlbzJjNUx2Y0t2WmlmUEMzTlFodFBRODRoYWNmWUtMVm5ESApKN2ZybS83VzV3aW9zd0lEQVFBQm8yTXdZVEFPQmdOVkhROEJBZjhFQkFNQ0FRWXdEd1lEVlIwVEFRSC9CQVV3CkF3RUIvekFkQmdOVkhRNEVGZ1FVa0daN3l1Rm1pcGl3a2JNdDdOUGxIQTdTNlZjd0h3WURWUjBqQkJnd0ZvQVUKVElUZVBtMUdQT0tFbXpyTjhSaGJBUm9IQ0VFd0RRWUpLb1pJaHZjTkFRRUxCUUFEZ2dFQkFEcVE5cWhaTHJ3bwpISXE0YlJOUTJYODI4WTZsYno0V3BrdDNGalQyNCtwMWVFaGdLYVhvV2d5RmlxekxxRnZoSmhRUFRhZ2JYL1JUCmgyODgwd2hvYTROUExxR2pZK0hUdjRkcnZNaVJWY0I3S0F3WUFLbWxiamluRk9MNS9abzROVFJESUJPWGpQWVcKcVFBRUxtb1FvNVpXQ01HOC8ycWFoRWVYM3dvV293Mm5oRW1DLzNFTTV4NEhLRGZuOXA3azYvZFU4NmN3TnhPNwpYcVJZcExyQ2xnUUpLS09aYWJPeHdSVk02TmNGUTR0c3ZGRGZGOXJEdjNXc0VhV1JkRlA0RzdjeUhSOGk2a1J3CmFHUFdaTHQyRk9xZ1locWNWU094V3pMbWhEaFg4bkN2S1pEUHhWa1pBcUFyVGVidlRHZDhyZkVsVDdrVDkrTFQKMVVRSWN4ZmNCcm89Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0= | base64 -D</span><span id="fef3" class="nk mc iq kp b gy np nm l nn no">-----BEGIN CERTIFICATE-----MIIDlDCCAnygAwIBAgIUb+L/Yne+Z4hKqAMEvpim0p4lJvUwDQYJKoZIhvcNAQEL<br/>BQAwSzFJMEcGA1UEAxNAY2x1c3Rlci1wYXJpcy0yYmQ0LnBhcmlzLTJiZDQuZXhh<br/>bXBsZS5vcGVudGxjLmNvbSBSb290IEF1dGhvcml0eTAeFw0yMDAzMDYxMzU0NDJa<br/>Fw0yMDA5MjAyMTU1MTJaMFgxVjBUBgNVBAMTTWFwcHMuY2x1c3Rlci1wYXJpcy0y<br/>YmQ0LnBhcmlzLTJiZDQuZXhhbXBsZS5vcGVudGxjLmNvbSBJbnRlcm1lZGlhdGUg<br/>QXV0aG9yaXR5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwJoTZlkR<br/>COX0MtpsV+ihwPxtE8moU6LUZlwaKGcn6NBUdCtxitjhLjj/9bN7EOr4fF1Ar1/T<br/>pYhu8OHGZ46MBXsf5I9A5vbHVPKfxC0VlrH3wWOzwu3jEDaOtMu46Eb9LyhMEy9A<br/>Liv2jXRtAaEjNSAyZRmE1tEdMY7aklcVG7kmc//jnSw5BpHJn4IgeQhA83H9uYj1<br/>czcvg/ZLnM3NeIcMfLXmd1R7cYdHAjmZt7E0fnU0dh7Pj9fFvx1B+h1LbtQCRwkj<br/>yp/nikoKHBBKfN5JLpbBzMqi6mnVgeo2c5LvcKvZifPC3NQhtPQ84hacfYKLVnDH<br/>J7frm/7W5wioswIDAQABo2MwYTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUw<br/>AwEB/zAdBgNVHQ4EFgQUkGZ7yuFmipiwkbMt7NPlHA7S6VcwHwYDVR0jBBgwFoAU<br/>TITePm1GPOKEmzrN8RhbARoHCEEwDQYJKoZIhvcNAQELBQADggEBADqQ9qhZLrwo<br/>HIq4bRNQ2X828Y6lbz4Wpkt3FjT24+p1eEhgKaXoWgyFiqzLqFvhJhQPTagbX/RT<br/>h2880whoa4NPLqGjY+HTv4drvMiRVcB7KAwYAKmlbjinFOL5/Zo4NTRDIBOXjPYW<br/>qQAELmoQo5ZWCMG8/2qahEeX3woWow2nhEmC/3EM5x4HKDfn9p7k6/dU86cwNxO7<br/>XqRYpLrClgQJKKOZabOxwRVM6NcFQ4tsvFDfF9rDv3WsEaWRdFP4G7cyHR8i6kRw<br/>aGPWZLt2FOqgYhqcVSOxWzLmhDhX8nCvKZDPxVkZAqArTebvTGd8rfElT7kT9+LT<br/>1UQIcxfcBro=<br/>-----END CERTIFICATE----</span></pre><p id="24b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，您只需使用路由的URL打开一个浏览器窗口，该URL已被修改为使用由我们的PKI颁发的自定义证书。你会看到，申请现在是使用TLS与此证书信息。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi nq"><img src="../Images/247ddd2e946a8b2be85067a327f1b706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G4ZBwtSyLr15A_GxTeCd-A.png"/></div></div></figure><p id="395c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还可以查看Vault后端UI —转到中间PKI详细信息—以检查它是否确实生成了新证书。第一个是先前由我们的根CA生成和签名的引用。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi nq"><img src="../Images/535460538b6ebe5c53b414cdaff538bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KCUZ0Zr5UqJ_YIymCrQ9HA.png"/></div></div></figure><h1 id="1651" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">结论</h1><p id="ddba" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">在这一部分中，我们已经看到了像云原生应用程序这样快速移动的应用程序是如何受益于完全自动化的公钥基础设施的。设置完成后，您的开发人员或部署人员可以完全自主地请求和使用为其应用程序定制的证书。此外，这些请求和使用通过常规的Kubernetes资源进行管理，这些资源可以使用<a class="ae kl" href="https://blog.openshift.com/introduction-to-gitops-with-openshift/" rel="noopener ugc nofollow" target="_blank"> GitOps </a>方法轻松地进行版本控制和保护！</p><p id="754f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种配置非常好的一部分——如果您已经部署了演示并等待大约45分钟，您将能够检查它😉—Vault+Cert Manager+Cert Utils自动管理已颁发证书的续订。在证书到期之前，证书管理器将向Vault发出新的颁发请求，并将使用新证书更新机密。Cert Utils将收到秘密更新的通知，并进而更新路由。最后，OpenShift路由器将使用滚动更新机制重新部署一个新的<code class="fe km kn ko kp b">Route</code>，保证应用程序用户不会遭受任何停机时间。</p><p id="b71f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢你花时间阅读这篇文章:我知道这是一篇又长又复杂的文章。我希望你在这里学到了一些东西。通过鼓掌或评论来获得反馈或鼓励是很受欢迎的🙏</p></div></div>    
</body>
</html>