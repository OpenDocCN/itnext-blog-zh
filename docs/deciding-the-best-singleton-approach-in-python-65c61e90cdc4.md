# 关于在 Python 中决定最佳单例方法的教程

> 原文：<https://itnext.io/deciding-the-best-singleton-approach-in-python-65c61e90cdc4?source=collection_archive---------1----------------------->

1994 年，单体设计模式诞生了。根据 GoF 的书，它是四种创造性的设计模式之一，意在将一个类的实例化限制为一个实例。激发这种模式的是日志记录或数据库系统等用例，在这些用例中，您需要单个协调器实例。

这篇文章是关于在 python 中实现单例设计模式的最佳方法。

**TLDR** :元类方法似乎是这里给出的三种方法中最好的选择。它在可测试性方面超越了装饰方法——因为它更容易测试——并且在可读性、可重用性和可测试性方面消灭了传统方法。

这里给出的全部代码(和测试)可以在 Replit 编码平台中获得。

[](https://replit.com/@PauloMiguel1/design-pattern-creational-singleton) [## 设计模式创造单例

### 以下是在 python 中实现单例设计模式的四种最常见的方式

replit.com](https://replit.com/@PauloMiguel1/design-pattern-creational-singleton) 

Udemy 上有一个很棒的在线课程，它更详细地解释了如何用 python 实现每个设计模式。我强烈推荐。

[https://www.udemy.com/course/design-patterns-python/](https://www.udemy.com/course/design-patterns-python/)

Python 提供了许多方法来实现它，三种最常见的方法是使用元类、装饰器或通过分配实现(也称为经典单例)。为了决定哪种方法是最好的，我从可读性、可重用性和可测试性的角度比较了这三种方法。

这里给出的用例是一个简单数据库连接的实现，该连接仅限于单个实例。`Database`是目标类，为了让它工作，它在实例化期间需要一个 URL，供`connect`方法使用。

这是我想限制为单个实例的目标类

# 通过元类的单例

元类提供了一种在创建过程中自动改变类的特殊方法。它可以指定该类的行为方式。

所以我可以创建一个元类，如果它已经存在，就避免构造目标类的对象。`__call__`将会是派生类构造的编排者，可以肯定的是`__init__`只会被调用一次。

通过元类实现单例

# 单例通过装饰器

2003 年，通过 PEP[318](https://www.python.org/dev/peps/pep-0318/)——函数和方法的装饰器，装饰器语法被引入 Python。python 中的装饰器是对函数和方法的扩展。这意味着它甚至可以在不修改原始扩展代码的情况下添加功能。

要构建一个，我只需要创建一个函数的函数，它将返回一个类的单个实例。然后，在我们的目标类中应用`@singleton`语法修饰。

通过装饰器实现单例

# 经典单例

经典的方法包括在目标类中构建单例。每当实例化时，`__new__`和`__init__`都会被调用。前者是创建对象的时候，后者是初始化对象。

知道我给`__new__`分配了目标类的构造，而`__init__`只是确保它只初始化属性一次。

通过经典方法实现单例

# 决定最佳方法

最后，重要的是拥有可维护的代码。为了做到这一点，我考虑了使代码可维护的三个标准:可读性、可重用性和可测试性。

## 可读性分数

1.  元类:太好了
2.  装饰者:太好了
3.  经典:不太好

关于可读性，元类和装饰器方法比经典方法更清楚地表达了它们的意图。

仅仅通过阅读目标类的第一行，你就会意识到该类的单例行为。然而，经典的方法是隐式的，所以你需要真正阅读实现来理解这个类是单例的。

## 可重用性得分

1.  元类:太好了
2.  装饰者:太好了
3.  经典:不太好

关于可重用性，你可以在许多类中使用元类和装饰器。它们独立于目标类，这使得它们可以重用。

然而，经典的方法是与目标类高度耦合的，所以如果你想有另一个单独的类，你必须复制相同的代码。

## 测试性得分

1.  元类:太好了
2.  装饰者:太好了
3.  经典:不太好

关于可测试性，期望用有效和无效的 URL 测试`Database`，并检查它在`connect`期间的行为。第一个测试`test_connect__when_url_is_valid_returns_success`应该返回成功，但是`test_connect__when_url_is_invalid_raise_error`应该由于无效的 URL 而引发一个错误。

休斯顿，我们有麻烦了。通过运行测试集，我意识到当它们一起运行时，其中一个测试总是会失败。这是因为两者都期望目标类的不同状态，如果我们保持单例行为，每个测试集都将有第一个测试用例创建的实例(有效的或者无效的)。

因此，解决方案是模仿单例行为，因为我们的目标只是测试`Database`类的逻辑。

看看经典的方法，我不能嘲笑单例，因为它与类高度耦合。在这种情况下，甚至“嘲笑”单身行为也没有意义，因为这也属于`Database`的职责。

使用装饰器方法，我能够轻松地移除单例行为。使用库`[undecorated](https://pypi.org/project/undecorated/)`,我移除了装饰模式，可以轻松运行整个测试集。

至于元类，那就更简单了，我只需要测试没有实现 singleton 的`_Database`类(记住，只有`DatabaseSingleton`有)

测试单例元类方法

# 最佳选择:通过元类的单例

元类方法似乎是三种方法中最好的，因为它比装饰方法更容易测试，并且在可读性、可重用性和可测试性方面比经典方法好得多。