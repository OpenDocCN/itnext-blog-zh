<html>
<head>
<title>Acceptance Test Driven Development with React/Redux — Part 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React/Redux的验收测试驱动开发—第5部分</h1>
<blockquote>原文：<a href="https://itnext.io/acceptance-test-driven-development-with-react-redux-part-5-995577d28eff?source=collection_archive---------4-----------------------#2018-03-15">https://itnext.io/acceptance-test-driven-development-with-react-redux-part-5-995577d28eff?source=collection_archive---------4-----------------------#2018-03-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5c8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">更新1 </em> </strong> : <em class="kl">本文是一个系列的一部分，查看完整系列:</em> <a class="ae km" href="https://medium.com/@juntao.qiu/acceptance-test-driven-test-with-react-redux-part-1-7ae8cb4fab00" rel="noopener">第一部分</a>、<em class="kl"> </em> <a class="ae km" href="https://medium.com/@juntao.qiu/acceptance-test-driven-test-with-react-redux-part-2-127949a6e47e" rel="noopener">第二部分</a>、<a class="ae km" href="https://medium.com/@juntao.qiu/acceptance-test-driven-test-with-react-redux-part-3-903e1e58e706" rel="noopener">第三部分</a>、<a class="ae km" href="https://medium.com/@juntao.qiu/acceptance-test-driven-development-with-react-redux-part-4-5db545953ed3" rel="noopener">第四部分</a>和<a class="ae km" href="https://medium.com/@juntao.qiu/acceptance-test-driven-development-with-react-redux-part-5-995577d28eff" rel="noopener">第五部分</a>。</p><p id="d68d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">更新2 </em> </strong>:我出版了一本名为<a class="ae km" href="https://leanpub.com/build-react-app-with-atdd" rel="noopener ugc nofollow" target="_blank"> <em class="kl">用验收测试驱动开发构建React应用</em> </a>的书，涵盖了更多关于ATDD和React的话题和实践，<a class="ae km" href="https://leanpub.com/build-react-app-with-atdd" rel="noopener ugc nofollow" target="_blank">请查看</a>！</p><h1 id="def1" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">搜索</h1><p id="e8d6" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我们的第三个特性是用户可以通过名字搜索书籍。当图书列表变得很长时，这非常有用(当内容超过一个屏幕或一页时，用户很难找到他要找的内容)</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lq"><img src="../Images/2638c064ea711efe244aca197890b291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A9aIv8OlcLtO2h-8."/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated"><a class="ae km" href="https://unsplash.com/@sabrituzcu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sabri Tuzcu </a>在<a class="ae km" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的“一张桌子的特写，上面有一台iMac和一部显示时间的智能手机”</figcaption></figure><h1 id="3921" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">接收试验</h1><p id="0660" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">类似地，我们从编写一个<code class="fe mg mh mi mj b">acceptance test</code>开始:</p><pre class="lr ls lt lu gt mk mj ml mm aw mn bi"><span id="242e" class="mo ko iq mj b gy mp mq l mr ms">test('Show books which name contains keyword', async () =&gt; {<br/>    await page.goto(`${appUrlBase}/`)</span><span id="053b" class="mo ko iq mj b gy mt mq l mr ms">    const input = await page.waitForSelector('input.search')<br/>    page.type('input.search', 'design')</span><span id="0cbc" class="mo ko iq mj b gy mt mq l mr ms">    // await page.screenshot({path: 'search-for-design.png'});<br/>    await page.waitForSelector('.book .title')<br/>    const books = await page.evaluate(() =&gt; {<br/>      return [...document.querySelectorAll('.book .title')].map(el =&gt; el.innerText)<br/>    })</span><span id="b679" class="mo ko iq mj b gy mt mq l mr ms">    expect(books.length).toEqual(1)<br/>    expect(books[0]).toEqual('Domain-driven design')<br/>  })</span></pre><p id="5c74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们尝试在<code class="fe mg mh mi mj b">.search</code>输入框中键入关键字<code class="fe mg mh mi mj b">design</code>，并期望只有<code class="fe mg mh mi mj b">Domain-driven design</code>出现在图书列表中。</p><p id="cbb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最简单的实现方法是修改<code class="fe mg mh mi mj b">BookListContainer</code>并添加一个<code class="fe mg mh mi mj b">input</code>:</p><pre class="lr ls lt lu gt mk mj ml mm aw mn bi"><span id="7fd2" class="mo ko iq mj b gy mp mq l mr ms">render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;input type="text" className="search" placeholder="Type to search" /&gt;<br/>        &lt;BookList {...this.state}/&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }</span></pre><p id="2b71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后为<code class="fe mg mh mi mj b">input</code>组件定义一个<code class="fe mg mh mi mj b">change</code>事件的处理方法:</p><pre class="lr ls lt lu gt mk mj ml mm aw mn bi"><span id="87ef" class="mo ko iq mj b gy mp mq l mr ms">filterBook(e) {<br/>    this.setState({<br/>      term: e.target.value<br/>    })</span><span id="4845" class="mo ko iq mj b gy mt mq l mr ms">    axios.get(`http://localhost:8080/books?q=${e.target.value}`).then(res =&gt; {<br/>      this.setState({<br/>        books: res.data,<br/>        loading: false<br/>      })<br/>    }).catch(err =&gt; {<br/>      this.setState({<br/>        loading: false,<br/>        error: err<br/>      })<br/>    })<br/>  }</span></pre><p id="4d04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并将其绑在<code class="fe mg mh mi mj b">input</code>组件上:</p><pre class="lr ls lt lu gt mk mj ml mm aw mn bi"><span id="b071" class="mo ko iq mj b gy mp mq l mr ms">&lt;input type="text" className="search" placeholder="Type to search" onChange={this.filterBook}<br/>               value={this.state.term}/&gt;</span></pre><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mu"><img src="../Images/895506cc0a0973910ae3f176f858e3f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IBB3tsRhi0iETa6ykfHzpg.png"/></div></div></figure><p id="5f7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我们使用<code class="fe mg mh mi mj b">books?q=${e.target.value}</code>作为获取数据的URL，这是由<code class="fe mg mh mi mj b">json-server</code>提供的全文搜索API，你只需要将<code class="fe mg mh mi mj b">books?q=domain</code>发送到后端，它将返回所有包含<code class="fe mg mh mi mj b">domain</code>的内容。</p><p id="375d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以像这样在命令行上尝试:</p><pre class="lr ls lt lu gt mk mj ml mm aw mn bi"><span id="c621" class="mo ko iq mj b gy mp mq l mr ms">curl <a class="ae km" href="http://localhost:8080/books?q=domain" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/books?q=domain</a></span></pre><p id="2654" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们的测试又变绿了。让我们跳到<code class="fe mg mh mi mj b">Red-Green-Refactoring</code>的下一步。</p><h1 id="fdd0" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">重构</h1><p id="5c9a" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">显然，<code class="fe mg mh mi mj b">filterBook</code>与<code class="fe mg mh mi mj b">componentDidMount</code>中的代码几乎相同，我们可以提取一个函数<code class="fe mg mh mi mj b">fetchBooks</code>来消除重复:</p><pre class="lr ls lt lu gt mk mj ml mm aw mn bi"><span id="8c8c" class="mo ko iq mj b gy mp mq l mr ms">componentDidMount() {<br/>    this.fetchBooks()<br/>  }</span><span id="cda7" class="mo ko iq mj b gy mt mq l mr ms">  fetchBooks() {<br/>    const {term} = this.state<br/>    axios.get(`http://localhost:8080/books?q=${term}`).then(res =&gt; {<br/>      this.setState({<br/>        books: res.data,<br/>        loading: false<br/>      })<br/>    }).catch(err =&gt; {<br/>      this.setState({<br/>        loading: false,<br/>        error: err<br/>      })<br/>    })<br/>  }</span><span id="7948" class="mo ko iq mj b gy mt mq l mr ms">  filterBook(e) {<br/>    this.setState({<br/>      term: e.target.value<br/>    }, this.fetchBooks)<br/>  }</span></pre><p id="2c24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Emm，比以前好。由于<code class="fe mg mh mi mj b">fetchBooks</code>将网络请求和<code class="fe mg mh mi mj b">state</code>的变化结合在一起，我们可以将它们分成定义2个功能:</p><pre class="lr ls lt lu gt mk mj ml mm aw mn bi"><span id="7ebe" class="mo ko iq mj b gy mp mq l mr ms">updateBooks(res) {<br/>    this.setState({<br/>      books: res.data,<br/>      loading: false<br/>    })<br/>  }</span><span id="3f49" class="mo ko iq mj b gy mt mq l mr ms">  updateError(err) {<br/>    this.setState({<br/>      loading: false,<br/>      error: err<br/>    })<br/>  }</span><span id="bfa4" class="mo ko iq mj b gy mt mq l mr ms">  fetchBooks() {<br/>    const {term} = this.state<br/>    axios.get(`http://localhost:8080/books?q=${term}`).then(this.updateBooks).catch(this.updateError)<br/>  }</span><span id="ae1e" class="mo ko iq mj b gy mt mq l mr ms">  filterBook(e) {<br/>    this.setState({<br/>      term: e.target.value<br/>    }, this.fetchBooks)<br/>  }</span></pre><p id="2d82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在代码变得清晰易读了。</p><h1 id="36a2" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">更进一步</h1><p id="1e67" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">比方说，别人可能想在他自己的页面上使用我们刚刚完成的搜索框，我们该如何重用它？实际上，这非常困难，因为当前搜索框与<code class="fe mg mh mi mj b">BookListContainer</code>中的rest代码紧密相关，我们需要提取到另一个组件<code class="fe mg mh mi mj b">SearchBox</code>:</p><pre class="lr ls lt lu gt mk mj ml mm aw mn bi"><span id="d711" class="mo ko iq mj b gy mp mq l mr ms">import React from 'react'</span><span id="6cce" class="mo ko iq mj b gy mt mq l mr ms">function SearchBox({term, onChange}) {<br/>  return (&lt;input type="text" className="search" placeholder="Type to search" onChange={onChange}<br/>                 value={term}/&gt;)<br/>}</span><span id="4505" class="mo ko iq mj b gy mt mq l mr ms">export default SearchBox</span></pre><p id="809b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">提取后，<code class="fe mg mh mi mj b">BookListContainer</code>的<code class="fe mg mh mi mj b">render</code>方法变为:</p><pre class="lr ls lt lu gt mk mj ml mm aw mn bi"><span id="62cc" class="mo ko iq mj b gy mp mq l mr ms">render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;SearchBox term={this.state.term} onChange={this.filterBook} /&gt;<br/>        &lt;BookList {...this.state}/&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }</span></pre><p id="5115" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于单元测试，我们可以简单地这样测试:</p><pre class="lr ls lt lu gt mk mj ml mm aw mn bi"><span id="1c43" class="mo ko iq mj b gy mp mq l mr ms">import React from 'react'<br/>import {shallow} from 'enzyme'<br/>import SearchBox from './SearchBox'</span><span id="b198" class="mo ko iq mj b gy mt mq l mr ms">describe('SearchBox', () =&gt; {<br/>  it('Handle searching', () =&gt; {<br/>    const onChange = jest.fn()<br/>    const props = {<br/>      term: '',<br/>      onChange<br/>    }</span><span id="3a46" class="mo ko iq mj b gy mt mq l mr ms">    const wrapper = shallow(&lt;SearchBox {...props}/&gt;)<br/>    expect(wrapper.find('input').length).toEqual(1)</span><span id="d8ef" class="mo ko iq mj b gy mt mq l mr ms">    wrapper.simulate('change', 'domain')<br/>    <br/>    expect(onChange).toHaveBeenCalled()<br/>    expect(onChange).toHaveBeenCalledWith('domain')<br/>  })<br/>})</span></pre><p id="e0f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我们使用<code class="fe mg mh mi mj b">jest.fn()</code>来创建一个<code class="fe mg mh mi mj b">spy</code>对象，它可以记录调用的轨迹。我们使用<code class="fe mg mh mi mj b">enzyme</code>提供的<code class="fe mg mh mi mj b">simulate</code> API来模拟一个<code class="fe mg mh mi mj b">change</code>事件，以<code class="fe mg mh mi mj b">domain</code>作为它的有效负载。然后，我们可以期待<code class="fe mg mh mi mj b">onChange</code>方法已经被数据<code class="fe mg mh mi mj b">domain</code>调用。</p><p id="1261" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们注意到<code class="fe mg mh mi mj b">SearchBox</code>只是一个演示组件，我们可以将它移动到<code class="fe mg mh mi mj b">components</code>文件夹:</p><pre class="lr ls lt lu gt mk mj ml mm aw mn bi"><span id="f3a1" class="mo ko iq mj b gy mp mq l mr ms">src<br/>├── App.css<br/>├── App.js<br/>├── components<br/>│   ├── BookDetail<br/>│   │   ├── index.js<br/>│   │   └── index.test.js<br/>│   ├── BookList<br/>│   │   ├── index.css<br/>│   │   ├── index.js<br/>│   │   └── index.test.js<br/>│   └── SearchBox<br/>│       ├── index.js<br/>│       └── index.test.js<br/>├── containers<br/>│   ├── BookDetailContainer.js<br/>│   └── BookListContainer.js<br/>├── e2e.test.js<br/>├── index.css<br/>├── index.js<br/>└── setupTests.js</span></pre><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mv"><img src="../Images/da047d5d2a2631905ce3d0c0d0bb3af0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qMMEWnf70KREdBGWk2A04g.png"/></div></div></figure><h1 id="f0fc" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">一些风格更新</h1><pre class="lr ls lt lu gt mk mj ml mm aw mn bi"><span id="2b7b" class="mo ko iq mj b gy mp mq l mr ms">.search {<br/>    box-sizing: border-box;<br/>    width: 100%;<br/>    padding: 2px 4px;<br/>    height: 32px;<br/>}</span></pre><p id="2ed7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们的用户界面看起来很像一个真正的应用程序:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mw"><img src="../Images/aeb6be0c6efeb5d1e40b755250d49a7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SDx8XOJjxnPOd5cAH4TXKg.png"/></div></div></figure><p id="532d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，让我们重组<code class="fe mg mh mi mj b">container</code>文件夹，使其与<code class="fe mg mh mi mj b">component</code>文件夹保持一致:</p><pre class="lr ls lt lu gt mk mj ml mm aw mn bi"><span id="e634" class="mo ko iq mj b gy mp mq l mr ms">src<br/>├── App.css<br/>├── App.js<br/>├── components<br/>│   ├── BookDetail<br/>│   │   ├── index.js<br/>│   │   └── index.test.js<br/>│   ├── BookList<br/>│   │   ├── index.css<br/>│   │   ├── index.js<br/>│   │   └── index.test.js<br/>│   └── SearchBox<br/>│       ├── index.css<br/>│       ├── index.js<br/>│       └── index.test.js<br/>├── containers<br/>│   ├── BookDetailContainer<br/>│   │   └── index.js<br/>│   └── BookListContainer<br/>│       └── index.js<br/>├── e2e.test.js<br/>├── index.css<br/>├── index.js<br/>└── setupTests.js</span></pre><p id="a82e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在每个文件夹中定义了一个<code class="fe mg mh mi mj b">index.js</code>,然后您可以简单地通过文件夹名称导入它，就像</p><pre class="lr ls lt lu gt mk mj ml mm aw mn bi"><span id="40ce" class="mo ko iq mj b gy mp mq l mr ms">import BookListContainer from "./containers/BookListContainer/"</span></pre><p id="245a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">否则，您可能会看到路径中的一些重复，如下所示:</p><pre class="lr ls lt lu gt mk mj ml mm aw mn bi"><span id="9618" class="mo ko iq mj b gy mp mq l mr ms">import BookListContainer from "./containers/BookListContainer/BookListContainer"</span></pre><p id="0217" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了，我们已经完成了所有3个功能！让我们看看这里有什么:</p><ul class=""><li id="bb91" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nc nd ne nf bi translated">3表示组件(BookDetail、BookList、SearchBox)及其单元测试</li><li id="897d" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">2个容器组件(BookDetailContainer、BookListContainer)</li><li id="410f" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">3个验收测试，涵盖最有价值的路径(列表、细节和搜索)</li></ul></div></div>    
</body>
</html>