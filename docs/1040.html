<html>
<head>
<title>Vuelidate Validation Messages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vuelidate验证消息</h1>
<blockquote>原文：<a href="https://itnext.io/vuelidate-validation-messages-7c318322fd87?source=collection_archive---------4-----------------------#2018-07-10">https://itnext.io/vuelidate-validation-messages-7c318322fd87?source=collection_archive---------4-----------------------#2018-07-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/5ab7252b0034244d8e3a0ea521ee9cc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*sk7wHlHYFCbAPyO4fX7IKw.png"/></div></figure><h1 id="fddb" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">更新</h1><p id="e723" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我写了一个名为<a class="ae lq" href="https://gitlab.com/rhythnic/vuelidate-messages" rel="noopener ugc nofollow" target="_blank"> vuelidate-messages </a>的库，可以在npm上找到。API和实现与下面描述的类似。</p><h1 id="e401" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">介绍</h1><p id="fbcf" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><a class="ae lq" href="https://monterail.github.io/vuelidate/#getting-started" rel="noopener ugc nofollow" target="_blank"> Vuelidate </a>在存储表单验证状态方面做得很好。它不支持显示错误消息。另一个非常流行的<a class="ae lq" href="https://vuejs.org/v2/guide/" rel="noopener ugc nofollow" target="_blank"> Vue </a>表单验证库，<a class="ae lq" href="https://baianat.github.io/vee-validate/" rel="noopener ugc nofollow" target="_blank"> Vee-validate </a>，对在组件中显示错误消息提供了强大的支持。尽管这是有代价的。Vee-validate可能会增加你的包的大小，对我来说，这个API比Vuelidate要复杂一些。Vuelidate更多地依赖于约定，以减少API面。我也喜欢Vuelidate用于验证对象和叶节点的共享API的对称性。</p><p id="e82b" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">如果您选择Vuelidate，那么您必须解决显示错误消息的问题。最流行的打包解决方案是<a class="ae lq" href="https://dobromir-hristov.github.io/vuelidate-error-extractor/" rel="noopener ugc nofollow" target="_blank">vuelidate-error-extractor</a>。我其实没试过。这可能是一个不错的选择，但是对我来说，包含验证消息组件模板和包装每个输入意味着这个解决方案太复杂了。此外，我们在工作中使用了<a class="ae lq" href="https://vuetifyjs.com/en/getting-started/quick-start" rel="noopener ugc nofollow" target="_blank"> Vuetify </a>。Vuetify已经有了一个传递错误消息的道具，我不想包装v-text-field组件。</p><p id="c69e" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">Vuelidate已经存储了验证状态。我们的解决方案不应该在状态中存储错误消息，所以我们可以避免试图保持它们同步的问题。这意味着组件数据不在考虑范围内。计算属性也不起作用，因为验证对象的形状可能会改变，很可能是在数组中添加和删除项目时。这就给我们留下了方法。这里给出的解决方案使用Vue组件方法来分析Vuelidate验证字段($v.name)，如果该字段在某些方面无效，则返回一条验证消息。</p><h1 id="ae49" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">试映</h1><p id="b903" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">下面是在Vue组件中使用该解决方案的预览。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="4481" class="mf jv iq mb b gy mg mh l mi mj">&lt;template&gt;<br/>  &lt;div&gt;<br/>    &lt;input v-model="name" /&gt;<br/>    &lt;span&gt;{{validationMsg($v.name)}}&lt;/span&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="3938" class="mf jv iq mb b gy mk mh l mi mj">&lt;script&gt;<br/>import { required, minLength } from 'vuelidate/lib/validators'<br/>import { validationMessage } from '../our-solution'</span><span id="218f" class="mf jv iq mb b gy mk mh l mi mj">const validations = {<br/>  name: {<br/>    required,<br/>    txtMinLen: minLength(2)<br/>  }<br/>}</span><span id="8dc1" class="mf jv iq mb b gy mk mh l mi mj">export default {<br/>  data () {<br/>    return { name: '' } <br/>  },<br/>  validations,<br/>  methods: {<br/>    validationMsg: validationMessage(validations)<br/>  }<br/>}<br/>&lt;/script&gt;</span></pre><h1 id="d01b" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">步骤1-验证消息创建者</h1><p id="67c9" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">解决方案的第一部分是提供消息。这里我们使用函数作为支持在消息中使用参数的简单方法。该函数还将被Vue组件的上下文调用，因此该函数可以访问<a class="ae lq" href="http://kazupon.github.io/vue-i18n/" rel="noopener ugc nofollow" target="_blank"> VueI18n </a> API。但是要注意，因为箭头函数被绑定到创建它们的上下文中，所以它们不能访问Vue组件实例。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="9378" class="mf jv iq mb b gy mg mh l mi mj">const plural = (words, count) =&gt; {<br/>  words = words.split('|').map(x =&gt; x.trim())<br/>  return count &gt; 1 ? words[2].replace('{n}', count) : words[count]<br/>}</span><span id="92a5" class="mf jv iq mb b gy mk mh l mi mj">export const validationMessageCreators = {<br/>  required: () =&gt; 'Required',<br/>  email: () =&gt; 'Invalid email',<br/>  txtMinLen: ({ $params }) =&gt; {<br/>    const min = plural(<br/>      'no characters | one character | {n} characters',<br/>      $params.txtMinLen.min<br/>    )<br/>    return `Must be at least ${min}`<br/>  }<br/>}</span></pre><p id="549d" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">该解决方案依赖于将Vuelidate验证对象中的键与validationMessageCreators对象中的键进行匹配。例如，要使用<strong class="ku ir"> txtMinLen </strong>验证消息，您的验证对象应该是这样的:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="05cb" class="mf jv iq mb b gy mg mh l mi mj">const validations = {<br/>  name: {<br/>    txtMinLen: minLength(2)<br/>  }<br/>}</span></pre><h1 id="a05d" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">步骤2 —解析验证器密钥的验证对象</h1><p id="6895" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="ku ir">更新</strong>:我没有在npm包中包含步骤2。</p><p id="3485" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">这个函数将递归解析您的验证对象，并构建一个验证器所有键的列表。这样做的主要原因是它允许我们检查(在步骤3中)我们有所有验证器的消息。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="a96d" class="mf jv iq mb b gy mg mh l mi mj">const isFn = x =&gt; typeof x === 'function'</span><span id="9eee" class="mf jv iq mb b gy mk mh l mi mj">// Given a Vuelidate validations object, find the validator keys<br/>function extractValidatorKeys (validations) {<br/>  const keys = Object.keys(validations)<br/>  const validatorKeys = keys.filter(x =&gt; isFn(validations[x]))<br/>  const nested = keys.filter(x =&gt; !isFn(validations[x]))<br/>  return validatorKeys.concat(<br/>    ...nested.map(x =&gt; extractValidatorKeys(validations[x]))<br/>  )</span></pre><h1 id="af86" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">步骤3 — Vue组件方法</h1><p id="17f4" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这是我们导出的函数。您将使用验证消息和验证对象来处理它，并得到一个接受Vuelidate字段的函数。我选择只返回一个错误。我不喜欢在每个输入字段中一次显示多个错误，但是您可以很容易地修改它来返回一个数组。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="3490" class="mf jv iq mb b gy mg mh l mi mj">export const getValidationMessage = messages =&gt; validations =&gt; {<br/>  let keys = extractValidatorKeys(validations)</span><span id="17d2" class="mf jv iq mb b gy mk mh l mi mj">  // check to make sure all validators have error messages<br/>  const missing = keys.filter(x =&gt; !(x in messages))<br/>  if (missing.length) {<br/>    console.warn(<br/>      'Validators missing validation messages: %s',<br/>      missing.join(', ')<br/>    )<br/>    // remove keys that don't have validation messages<br/>    keys = keys.filter(x =&gt; missing.indexOf(x) &lt; 0)<br/>  }<br/>  <br/>  // Vue component method<br/>  // Given a vuelidate field object, maybe return a string<br/>  return function (...args) {<br/>    let field = args[0]<br/>    if (!field.$error) return ''<br/>    for (let i = 0; i &lt; keys.length; i++) {<br/>      let key = keys[i]<br/>      if (field[key] === false) {<br/>        return messages[key].apply(this, args)<br/>      }<br/>    }<br/>    return ''<br/>  }<br/>}</span></pre><h1 id="96ad" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">步骤4-导出课程实用程序</h1><p id="abe5" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">最后，我们将使用validationMessageCreators来处理实用程序，以使导入更容易。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="365c" class="mf jv iq mb b gy mg mh l mi mj">export const validationMessage =<br/>    getValidationMessage(validationMessageCreators)</span></pre><h1 id="aa33" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="a4ce" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">解决方案本质上是将验证键映射到错误消息。我不确定，但是我假设Vue组件方法，在示例中被称为“errors ”,在组件每次更新时为每个输入运行。该函数中的代码量很少，我没有注意到任何缓慢的行为，但是如果您有一个非常大的表单，您可能需要一种优化技术，比如记忆化，使用计算属性，或者将表单分成多个组件。</p><p id="4042" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated"><a class="ae lq" href="https://gitlab.com/rhythnic/vuelidate-messages" rel="noopener ugc nofollow" target="_blank">vuelidate-消息包</a></p></div></div>    
</body>
</html>