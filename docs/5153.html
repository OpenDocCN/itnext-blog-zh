<html>
<head>
<title>Using gRPC with TLS, Golang and React (No Envoy)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将gRPC与TLS、Golang和React一起使用(无特使)</h1>
<blockquote>原文：<a href="https://itnext.io/using-grpc-with-tls-golang-and-react-no-envoy-92e898bf8463?source=collection_archive---------0-----------------------#2020-12-26">https://itnext.io/using-grpc-with-tls-golang-and-react-no-envoy-92e898bf8463?source=collection_archive---------0-----------------------#2020-12-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/5fd22e7dd0b6fa49f05364eaeace4830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*1VGeedTemPaSFeMYW8WJHA.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">我们将使用的技术堆栈有React、Golang、gRPC。</figcaption></figure><p id="a9db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi kz translated">几个月前，我开始了一个想使用gRPC的项目。这是一次奇妙的经历。我真的很喜欢如何使用protobuf和gRPC在后端和前端拥有相同的客户端。</p><p id="b5e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我的开发阶段，我遇到了一些小问题。因此，当在互联网上搜索在web应用程序中使用gRPC的解决方案时，似乎几乎每个人都推荐<a class="ae li" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank">特使</a>反向代理。我开始使用envoy，它工作得非常好，有很多例子显示如何设置它。</p><p id="0073" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我从普通的HTTP迁移到<strong class="kd iu"> HTTPS </strong>时，问题开始出现。envoy的配置示例变得令人害怕，许多示例相互矛盾。并补充说我想使用<strong class="kd iu"> gRPC元数据</strong>特性，这开始变得很难设置。我需要另一个解决方案。</p><p id="2764" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我遇到了罗杰·查普曼，他写了一篇关于在没有特使的情况下使用g RPC网络客户端的文章。他解释了<a class="ae li" href="https://github.com/improbable-eng/grpc-web" rel="noopener ugc nofollow" target="_blank">impossible</a>的团队如何为HTTP服务器创建了一个包装器，可用于处理gRPC请求。这是一个很大的帮助，我决定与你们这些地鼠分享我的经验。</p><p id="c54a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将是一个系列的一部分，我们将继续开发应用程序来探索gRPC和Golang的不同方面。</p><ul class=""><li id="8782" class="ll lm it kd b ke kf ki kj km ln kq lo ku lp ky lq lr ls lt bi translated">[第一部分] —你现在正在读它</li><li id="b2bb" class="ll lm it kd b ke lu ki lv km lw kq lx ku ly ky lq lr ls lt bi translated"><a class="ae li" href="https://programmingpercy.tech/blog/embedd-web-application-golang/" rel="noopener ugc nofollow" target="_blank">[第1.1部分] —在Golang二进制文件中嵌入React应用程序</a></li><li id="7834" class="ll lm it kd b ke lu ki lv km lw kq lx ku ly ky lq lr ls lt bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/grpc-interceptors-e221aa4cc49">【第二部分】— gRPC拦截器</a></li><li id="0648" class="ll lm it kd b ke lu ki lv km lw kq lx ku ly ky lq lr ls lt bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/streaming-data-with-grpc-2eb983fdee11">【第3部分】—使用gRPC传输数据</a></li></ul><p id="675e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们编写一个使用react应用程序与gRPC服务器通信的示例项目。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="19a8" class="mg mh it bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">项目设置</h1><p id="4faf" class="pw-post-body-paragraph kb kc it kd b ke ne kg kh ki nf kk kl km ng ko kp kq nh ks kt ku ni kw kx ky im bi translated">让我们首先创建一个新文件夹，并为这个项目初始化一个Go模块。(注意完整的代码可以在https://github.com/percybolmer/grpcexample的<a class="ae li" href="https://github.com/percybolmer/grpcexample" rel="noopener ugc nofollow" target="_blank">找到)。我们将首先创建所需的文件夹，例如包含证书的<code class="fe nj nk nl nm b">cert</code>和保存我们构建的静态react应用程序的<code class="fe nj nk nl nm b">ui/src</code>。</a></p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="84e0" class="nv mh it nm b gy nw nx l ny nz">mkdir grpcexample<br/>cd grpcexample<br/>go mod init github.com/percybolmer/grpcexample<br/>touch main.go<br/>mkdir -p ui/src<br/>mkdir cert<br/>mkdir pingpong</span></pre><p id="9ad5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们开始编写我们的API之前，让我们确保我们已经准备好使用证书。为了生成这个，我们将使用<a class="ae li" href="https://www.openssl.org/" rel="noopener ugc nofollow" target="_blank"> openssl </a>。为了使事情变得简单一点，我创建了一个脚本来为我们完成这项工作，只需运行下面的脚本，它就会为我们生成文件。要运行这个脚本，你还需要在同一个目录中有一个名为<code class="fe nj nk nl nm b">certificate.conf</code>的文件。脚本和配置文件都可以在下面找到。</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">证书生成脚本。</figcaption></figure><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">这个配置应该放在名为certificate.conf的文件中。</figcaption></figure><p id="99f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我已经将脚本和配置文件放在了<code class="fe nj nk nl nm b">cert</code>文件夹中。运行之后，您应该会在/cert中找到一些新文件。让我们继续我们的Go API。</p><h1 id="2c67" class="mg mh it bd mi mj oc ml mm mn od mp mq mr oe mt mu mv of mx my mz og nb nc nd bi translated">gRPC服务</h1><p id="8ba5" class="pw-post-body-paragraph kb kc it kd b ke ne kg kh ki nf kk kl km ng ko kp kq nh ks kt ku ni kw kx ky im bi translated">因此，使用这种设置的最大好处是，我们可以轻松地在react和Go backend中使用同一个客户端来与API对话。</p><p id="8292" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以创建一个Protobuf模式来为我们生成客户端，而不是在Go和Javascript中重写相同的结构。</p><p id="e660" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将生成一个允许我们Ping的Ping/Pong服务，我们可以从React和Go应用程序中调用它。这是一个非常简单的protobuf示例，但是您可以根据自己的项目需要轻松地进行修改。</p><p id="2eaf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，确保您已经安装了Protoc，这样您就可以基于原型模式生成代码。如何安装协议可以在<a class="ae li" href="https://grpc.io/docs/protoc-installation/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="fb6d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了protocol，我们还需要插件来生成go代码和javascript代码。用go get很容易获取go代码。</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="9b5e" class="nv mh it nm b gy nw nx l ny nz">go get -u google.golang.org/protobuf/cmd/protoc-gen-go<br/>go install google.golang.org/protobuf/cmd/protoc-gen-go<br/><br/>go get -u google.golang.org/grpc/cmd/protoc-gen-go-grpc<br/>go install google.golang.org/grpc/cmd/protoc-gen-go-grpc</span></pre><p id="996a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，根据这里中<a class="ae li" href="https://github.com/grpc/grpc-web#code-generator-plugin" rel="noopener ugc nofollow" target="_blank">的说明安装javascript生成器</a></p><p id="7467" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们编写原型模式并生成一些代码。</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="b075" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你不了解protobuf，我建议你访问他们的官方网站<a class="ae li" href="https://grpc.io/docs/what-is-grpc/introduction/" rel="noopener ugc nofollow" target="_blank">来了解一下。简而言之，消息是API将用作请求和响应的对象。API本身是由关键字service声明的。在上面的模式中，我们有一个API，它有一个Ping方法。</a></p><p id="8a06" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我将它放在grpcexample根目录下的一个名为<code class="fe nj nk nl nm b">pingpong/service.proto</code>的文件中。<br/>现在，为了生成文件，我们将运行protocol。</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="e2dd" class="nv mh it nm b gy nw nx l ny nz">protoc service.proto --js_out=import_style=commonjs,binary:./../ui/src/ --grpc-web_out=import_style=commonjs,mode=grpcwebtext:./../ui/src/ --go-grpc_out=. --go_out=.</span></pre><p id="e638" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里发生的事情是，我们运行Protoc二进制文件来为Javascript和Go应用程序生成客户端代码。我们还生成gRPC服务。</p><p id="dbfe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">运行之后，你应该在<code class="fe nj nk nl nm b">grpcexample/pingong</code>中找到两个新文件，分别名为<code class="fe nj nk nl nm b">service_grpc.pb.go</code>和<code class="fe nj nk nl nm b">service.pb.go</code>，包含gRPC服务和Golang客户端，在<code class="fe nj nk nl nm b">ui/src</code>中应该有<code class="fe nj nk nl nm b">service_grpc_web_pb.js</code>和<code class="fe nj nk nl nm b">service_pb.js</code>，它们是javascript客户端。</p><p id="ce02" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">到目前为止，我的文件夹看起来像这样</p><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/bd2afc8a4a10b8c8e8f5bb3fd4ec8884.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/1*FQLxDxr6GEWesMv3DgqQrA.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">到目前为止的项目结构。</figcaption></figure><p id="7462" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们开始在Go应用程序中使用生成的代码。</p><h1 id="4cfd" class="mg mh it bd mi mj oc ml mm mn od mp mq mr oe mt mu mv of mx my mz og nb nc nd bi translated">Golang后端</h1><p id="fcc8" class="pw-post-body-paragraph kb kc it kd b ke ne kg kh ki nf kk kl km ng ko kp kq nh ks kt ku ni kw kx ky im bi translated">让我们首先创建一个Golang应用程序，它用于通过TLS提供一个简单的gRPC API。这个应用程序也将为我们稍后从react应用程序进行的静态构建提供服务。</p><p id="0ee6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建<code class="fe nj nk nl nm b"><em class="oi">main.go</em></code>，这里我们将创建一个函数，它使用我们生成的证书来通过TLS提供HTTP API。该功能将使用<a class="ae li" href="https://godoc.org/google.golang.org/grpc/credentials" rel="noopener ugc nofollow" target="_blank">google.golang.org/grpc/credentials</a>。这个包允许我们指出生成的pem文件和服务器密钥，然后它将读取这些文件并输出一个我们可以在gRPC服务器中使用的传输配置结构。可以将传输配置插入grpc服务器以要求TLS。</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">generate lsapi——一个如何使用TLS连接到gRPC服务器的golang示例</figcaption></figure><p id="c152" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">很好，所以用TLS设置gRPC服务器很容易..但是让我们花点时间想想。生成的代码怎么知道Ping函数应该做什么？你说得对，不会。</p><p id="3dad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">原型中的服务定义只创建一个与服务匹配的接口。所以如果你打开<code class="fe nj nk nl nm b">service_grpc.pb.go</code>，你会发现它定义了一个类似于</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">乒乓接口——协议生成的gRPC服务器接口</figcaption></figure><p id="508e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们必须创建一个结构来实现这个接口。我创建了一个名为<code class="fe nj nk nl nm b">server.go</code>的新文件来保存逻辑。</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">这个要点展示了一个实现乒乓服务器接口的结构。</figcaption></figure><p id="beec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，这个PingPong服务将始终返回一个true。在本教程中，我们将只专注于使一切工作，添加有趣的API调用逻辑将留给你。</p><p id="3689" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是Go中gRPC在basic中的工作方式，你生成一个接口，你创建一个实现该接口的结构，然后你可以用同样生成的<code class="fe nj nk nl nm b">RegisterPingPongServer</code>函数将你的结构注册为服务器。这需要一个<code class="fe nj nk nl nm b">grpc.Server</code>对象和一个<code class="fe nj nk nl nm b">PingPong</code>接口。<br/>所以，如果你愿意，你可以通过实现这样一个主函数来启动这个Pingpong。</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">在TLS上运行gRPC API的完整示例。</figcaption></figure><p id="8d4e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们创建一个简单的gRPC客户机，以确保在继续之前一切正常。让我们创建一个名为client的文件夹，并在其中创建一个main.go</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="06ee" class="nv mh it nm b gy nw nx l ny nz">mkdir client<br/>cd client<br/>touch main.go</span></pre><p id="1b13" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们首先加载一个我们可以被客户端使用的证书</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">Golang —如何从文件中加载TLS证书和密钥</figcaption></figure><p id="4caa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后一个简单的main函数启动一个连接并从服务器调用Ping</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">从服务器调用Ping的gRPC客户端。</figcaption></figure><p id="8c93" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试试吧！<br/>转到项目根文件夹并执行</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="1891" class="nv mh it nm b gy nw nx l ny nz">go run *.go<br/>// Open a new terminal <br/>cd client<br/>go run main.go<br/></span></pre><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/55ff71c2153ab6f4a435ba2ceccef1da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*_8gSqlf3rcmXq3so-TSD7w.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">您应该会看到客户端记录的Pong响应，如下所示</figcaption></figure><p id="b146" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">太好了，它起作用了！然而，我们的目标是为web应用程序托管gRPC API。</p><p id="fb7f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们离开golang客户端，回到服务器。通常，此时您会将Envoy配置为API所在端口的反向代理。但是我们将把API包装在由implementable-eng创建的gRPC-web包装器中。</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="3815" class="nv mh it nm b gy nw nx l ny nz">go get -u github.com/improbable-eng/grpc-web/go/grpcweb</span></pre><p id="c990" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将在<em class="oi"> main.go </em>中创建一个新的结构，称为grpcMultiplexer，它包含一个包装的gRPC服务器。这个struct只会有一个函数，这个函数是一个普通http路由器的中间件。原因是gRPC请求将在与常规https请求相同的端口上多路复用。<br/>听起来很难，但它只有11行代码。</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="48e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们创建HTTP文件服务器来服务我们未来的React应用程序。<br/>该文件服务器也将由grpcMultiplexer包装。因此http请求将由常规的http服务器处理，而gRPC请求将被传递到gRPC服务器。</p><p id="b2b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们更新一下main.go</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">用HTTP处理程序包装gRPC处理程序的Golang示例</figcaption></figure><p id="0bfe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尝试访问<a class="ae li" href="https://localhost:8080" rel="noopener ugc nofollow" target="_blank"> https://localhost:8080 </a>应该可以。您现在只会看到一个src文件夹，让我们马上修复它。还要记住，浏览器会抱怨，因为它是一个自我生成的证书。</p><h1 id="cfeb" class="mg mh it bd mi mj oc ml mm mn od mp mq mr oe mt mu mv of mx my mz og nb nc nd bi translated">让我们构建web应用程序</h1><p id="e9e0" class="pw-post-body-paragraph kb kc it kd b ke ne kg kh ki nf kk kl km ng ko kp kq nh ks kt ku ni kw kx ky im bi translated">为了创建react应用程序，我将使用<a class="ae li" href="https://reactjs.org/docs/create-a-new-react-app.html" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>。</p><p id="a246" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于那些不熟悉React和Nodejs的人，我将做一个非常简短的介绍，介绍如何启动和运行它。</p><p id="3c9d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先你需要<a class="ae li" href="https://www.npmjs.com/get-npm" rel="noopener ugc nofollow" target="_blank">安装NPM </a>。<br/>我在跑Centos，可以用yum。</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="dde6" class="nv mh it nm b gy nw nx l ny nz">yum install npm</span></pre><p id="e18a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">安装了npm之后，您还需要安装npx和一些gRPC库。</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="73a3" class="nv mh it nm b gy nw nx l ny nz">npm install -g npx<br/>npm add grpc-web<br/>npm add google-protobuf</span></pre><p id="7175" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦安装了npx，让我们使用<a class="ae li" href="https://reactjs.org/docs/create-a-new-react-app.html" rel="noopener ugc nofollow" target="_blank"> creact-react-app </a>命令为我们生成一个新的应用程序。</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="6e46" class="nv mh it nm b gy nw nx l ny nz">cd ui<br/>npx create-react-app pingpongapp</span></pre><p id="1270" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它将创建一个名为pingpongapp的新文件夹，其中将有一堆文件夹和文件。我们需要做的是纠正文件结构中的一个小错误。我们生成的javascript文件在<code class="fe nj nk nl nm b">grpcexample/ui/src</code>中，我们需要将它们移动到<code class="fe nj nk nl nm b">grpcexample/ui/pingpongapp/src/proto</code>。</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="74dd" class="nv mh it nm b gy nw nx l ny nz">mkdir pingpongapp/src/proto<br/>mv src/* pingpongapp/src/proto/<br/>rm -rf src</span></pre><p id="7543" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们也更新main.go，现在HTTP文件服务器指向“ui/”，我们应该将其更新为“ui/pingpongapp/build”。这个文件夹还不存在，不用担心。</p><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/18d871876121282c4d723182cf643cac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*to4fkbPb-8nEjOLpWp0l3Q.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">我们将路径改为指向pingpongapp中的构建目录。它将在下一步中创建</figcaption></figure><p id="8220" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们进入react应用程序并构建它，看看到目前为止一切正常。</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="458b" class="nv mh it nm b gy nw nx l ny nz">cd ui/pingpongapp<br/>npm run build<br/>cd ../..<br/>go run *.go</span></pre><p id="d56c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们已经构建了react应用程序，并重启了go后端。访问<a class="ae li" href="https://localhost:8080" rel="noopener ugc nofollow" target="_blank"> localhost:8080 </a>你应该会看到</p><figure class="nn no np nq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="om on di oo bf op"><div class="gh gi ol"><img src="../Images/52ce6fb548dbd58bb4beb173a992aef3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s244zggVmp1RX8YM30RPVw.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">默认react应用程序加载屏幕</figcaption></figure><p id="e0b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">太好了！现在我们有了一个运行gRPC api的服务器，我们通过TLS托管react应用程序。让我们修改应用程序以使用API。</p><p id="6954" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开<code class="fe nj nk nl nm b">pingpongapp/src/App.js</code></p><p id="ce3c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以删除应用程序函数中返回的所有内容。</p><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/8cd45afbd80fdb0b633627146114e319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*j2EBNJ6Qjx4RbD5aWSa3IA.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">这是最初的App.js的样子</figcaption></figure><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi or"><img src="../Images/ada1d54b8450fd82125238a5e38fd2b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*jOrSx9gboHrDQe9DzfeNNg.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">删除所有内容，这样你就有了一个类似这样的文件。</figcaption></figure><p id="c918" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们需要导入gRPC客户端，这是在文件的顶部完成的。<br/>我们还将导入PingRequest，因为我们需要它来发送我们的请求。<br/>这个react应用程序将使用<a class="ae li" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> React钩子和state </a>，所以它们也需要作为导入。</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="4a2b" class="nv mh it nm b gy nw nx l ny nz">import React, {useState, useEffect } from 'react';<br/>import { PingPongClient } from './proto/service_grpc_web_pb';<br/>import { PingRequest } from './proto/service_pb';</span></pre><p id="63f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">应用程序将超级简单。它将显示当前的ping状态(始终为真)。每秒将发送一个请求。</p><p id="ccc2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我用注释概述了react代码，以解释发生了什么。</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="81ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们重新构建react应用程序</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="8278" class="nv mh it nm b gy nw nx l ny nz">npm run build</span></pre><p id="ad8a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您在构建时遇到问题，说Proto没有定义，如下图所示，您需要修改构建脚本中的一些配置，因为这是一个已知的bug。</p><figure class="nn no np nq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="om on di oo bf op"><div class="gh gi os"><img src="../Images/1482e091faefedf6c6d4a62e0f6b8917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VE9txKZabmsTOqEm38445w.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">一些版本可能会抛出proto错误，这可以通过取消protobuf文件的eslinter来修复。</figcaption></figure><p id="b61c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你没有遇到麻烦，跳过以下部分。<br/>创建一个<em class="oi">。react应用程序根目录下的env </em>文件。的。env文件中只有一行，它是对常规eslinter的扩展。</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="f867" class="nv mh it nm b gy nw nx l ny nz">echo "EXTEND_ESLINT=true" &gt; .env</span></pre><p id="b332" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你还需要打开<code class="fe nj nk nl nm b">package.json</code>，寻找<code class="fe nj nk nl nm b">eslintConfig</code>部分。<br/>这个应该用<code class="fe nj nk nl nm b">ignorePatterns:**/*_pb.js</code>来扩展，这样做是为了忽略任何名字中包含<code class="fe nj nk nl nm b">_pb.js</code>的文件。</p><p id="58dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我的eslintConfig的样子</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="54e7" class="nv mh it nm b gy nw nx l ny nz">"eslintConfig": {</span><span id="ff76" class="nv mh it nm b gy ot nx l ny nz">"extends": [<br/>"react-app",<br/>"react-app/jest"<br/>],<br/>"ignorePatterns": ["**/*_pb.js"]<br/>},</span></pre><p id="7612" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">构建成功后，返回并重启后端，重新访问<br/><a class="ae li" href="https://localhost:8080" rel="noopener ugc nofollow" target="_blank"><em class="oi">https://localhost:8080</em></a><em class="oi">。</em></p><p id="5594" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您现在应该看到一个错误的状态，三秒钟后变为真。<br/>就这样，您现在正在运行一个react应用程序，它可以在没有envoy的情况下与gRPC api进行通信！</p><figure class="nn no np nq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="om on di oo bf op"><div class="gh gi ou"><img src="../Images/cf8af3ed577e1e74bae84945ef4659c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LFRtjIkUlMxeergWYrfbxw.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">状态已更新，API调用正在定期进行。</figcaption></figure><p id="9d5d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读，你可以在<a class="ae li" href="https://github.com/percybolmer/grpcexample" rel="noopener ugc nofollow" target="_blank">https://github.com/percybolmer/grpcexample</a>看到完整代码。</p><p id="ec9a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">参见<a class="ae li" href="https://percybolmer1.medium.com/embedding-a-web-application-in-a-golang-binary-f9733b25bbf7" rel="noopener">第二部分</a>关于将web应用程序嵌入到单个二进制文件中。</p><div class="ov ow gp gr ox oy"><a href="https://percybolmer.medium.com/membership" rel="noopener follow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">阅读珀西·博尔默(以及媒体上成千上万的其他作家)的每一个故事</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">percybolmer.medium.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm jv oy"/></div></div></a></div></div></div>    
</body>
</html>