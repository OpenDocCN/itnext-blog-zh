<html>
<head>
<title>Superfast search with RediSearch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带重复搜索的超快速搜索</h1>
<blockquote>原文：<a href="https://itnext.io/superfast-search-with-redisearch-b80be3672070?source=collection_archive---------0-----------------------#2022-12-26">https://itnext.io/superfast-search-with-redisearch-b80be3672070?source=collection_archive---------0-----------------------#2022-12-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c0f31524e4310d90da12d3ca3898cf47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*V5ibTMD0gEToHnqw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">再研究</figcaption></figure><p id="f908" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">搜索对所有应用程序来说都是越来越必要的。随着数据以高容量和高速度积累，我们数据管道的其余部分必须能够从这些数据中提取正确的信息和见解。搜索是实现这一目标的主要工具之一。</p><p id="b88b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">尽管有了多媒体革命，我们收集的许多数据都是文本形式的。这可以由社交媒体源、网络爬虫摘录、消费者评论、医疗报告、流地理位置更新等等产生。基于区分大小写的精确字符串匹配进行搜索的时代已经一去不复返了。我们需要一个能够大规模管理文本的系统来处理这些数据。我们需要对文本进行超高速模糊查询。</p><p id="ea60" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">RediSearch为这样的需求提供了一个极好的解决方案。通过重新搜索，我们可以处理流数据以及静态数据。模糊文本搜索是一个基本功能。除此之外，RediSearch支持对数字和地理位置数据进行复杂的搜索。当然，我们可以认为基本的标签搜索是理所当然的。</p><p id="90e2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个博客涵盖了再搜索的核心概念，以及演示这个概念的代码片段。</p><h1 id="5d7c" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">核心概念</h1><p id="e209" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">仅有语法是不够的。为了充分利用任何工具，如果我们了解它是如何工作的，会有所帮助。有了这样的认识，我们就能很快掌握语法，并有效地运用它。记住这一点，让我们从支持再研究的一些核心概念和技术开始。</p><h1 id="ebad" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">倒排索引</h1><p id="3565" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">再研究是基于倒排索引的概念。以防我们忘记，Redis是一家NoSQL的关键/价值商店。我们没有任何模式约束。因此，所有的关系概念都可以放在一边。</p><p id="eeab" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Redis需要一种不同的方法来加速搜索。它为数据中出现的所有内容维护一个“倒排索引”。这意味着，对于我们添加到RedisDB的每个索引实体，RediSearch提取所有单个值，并将条目添加到索引结构中。这些条目包含将可搜索值映射到原始键的反向映射(因此，它被称为反向索引)。因此，我们可以将数据中的任何实体映射到Redis DB中该对象的键。</p><p id="8665" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">高效搜索有两个步骤。第一步是识别用户试图搜索的值。识别了值之后，第二步是获取引用包含我们识别的值的对象的键。倒排索引帮助我们完成第二步。一旦我们确定了用户想要搜索的值，我们就可以毫无延迟地跳到关键点。现在让我们检查第一步。</p><h1 id="ddb8" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">速度背后的秘密</h1><p id="a319" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">Trie(数字搜索树/前缀树)是一种能够在大型数据集上实现快速检索的数据结构。术语“trie”来自短语“Information Re* <em class="mg"> trie </em> *val”。简而言之，trie将文本数据组织成由前缀构建的树。那是什么意思？</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/f67a9fddbf5181b7b8820b00a0b2df35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5U4Xz5I2OSbbbrpt.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">单词查找树</figcaption></figure><p id="cf75" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">顾名思义，前缀树构建了一个前缀树。这是什么意思？任何字符串都可以被视为前缀序列。如果我们使用这样的前缀树来索引文本语料库，我们可以通过直接遍历树来定位任何节点——而不是通过计数或扫描。因此，定位任何单词的时间复杂度与数据量无关。同时，吸收新数据的复杂性也很低。</p><p id="a73e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这使得对大量数据进行可扩展的超高速搜索成为可能。</p><p id="1df2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">“再研究”更进了一步。该树不需要用直接从原始文本中提取的单个字符来实现。我们在构建前缀树的时候可以更聪明。它可以使用从文本中提取的引理来构建。当我们创建这样的索引时，我们可以在海量数据上实现超高速模糊搜索。这就是重新搜索文本查询效率背后的秘密。有关实现模糊搜索的更多信息，请参考这篇维基百科文章。</p><h1 id="8b82" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">标签索引</h1><p id="0116" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">标签搜索意味着比全功能文本搜索更快。当我们知道字段包含我们直接查询的特定文本时，我们使用标签索引。我们在不需要模糊搜索的领域使用它。标签搜索可以提供更简单的索引。</p><h1 id="2f7a" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">数字索引</h1><p id="f291" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">RediSearch为数字数据定义了一个唯一的索引结构。数值查询通常基于计算范围。基于不同值的索引对此类查询没有帮助。我们需要更好的东西。我们不应该将每个数字视为一个独立的实体，而应该以一种识别数字与其值的关系的方式来索引它们。</p><p id="1ce1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">RediSearch通过创建基于二进制范围树的数字索引来实现这一点。这种指数将相互接近的数字组合在一起。因此，在数字索引树中，这样的组存储在“范围节点”上，而不是每个节点一个数字。这说起来容易做起来难。我们如何确定一个节点的大小？对于可以装进一个节点的数字，我们如何定义接近度的阈值？RediSearch有一个自适应算法，可以实现这种分组和将数字分类到组中。</p><h1 id="ff49" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">地理索引</h1><p id="6626" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">多年来，移动电话/物联网设备及其地理位置已经成为流入我们数据库的数据的重要组成部分。它是数据分析的重要组成部分。随着地理空间数据负载的增加，地理空间查询的性能是数据库性能的重要组成部分。自然，再研究尽最大努力解决这个领域。</p><p id="8fd5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">RediSearch基于点与点之间的接近程度进行地理索引。这种接近度是基于地理空间查询计算的距离来识别的。然后将这些点收集到范围树中，以便进行快速搜索和分组。</p><h1 id="efbc" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">得分</h1><p id="7bef" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">一个搜索查询可能会返回几个结果。我们不想用大量的数据淹没客户。根据分数对数据进行排序是有意义的，这样客户机就可以选择比结果集的其余部分更相关的内容。</p><p id="0c5a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">评分不同于排序。排序基于字段内容的绝对值。分数衡量搜索结果的每个值的相关性。这种评分的准确性和灵活性是提高搜索效率的重要因素。</p><p id="2b79" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">通过重新搜索，可以使用重新搜索中的预定义函数或提高部分结果分数的自定义函数来计算这些分数。</p><h1 id="3108" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">设置</h1><p id="0c88" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">你的手指是否渴望键入一些代码？我们快到了！现在让我们着手建立Redis所需的数据库和工具。</p><h1 id="e57a" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">安装Redis</h1><p id="9b58" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">不要安装！</p><p id="82d7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们用安装在笔记本电脑上的数据库开发和测试代码的日子已经一去不复返了。欢迎来到云端。有了Redis云账户，你只需要点击几下，免费的数据库实例就准备好了。为什么要把你的笔记本电脑弄得乱七八糟？</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/dc6e7cd905220294099f9e409d745458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IVqOHquZfOaDc3Z0.gif"/></div></div></figure><ol class=""><li id="9065" class="mn mo it kh b ki kj km kn kq mp ku mq ky mr lc ms mt mu mv bi translated">跳转到<a class="ae mm" href="https://redis.info/3NBGJRT" rel="noopener ugc nofollow" target="_blank"> Redis云</a>。如果您没有帐户，请在一分钟内创建一个。</li><li id="72eb" class="mn mo it kh b ki mw km mx kq my ku mz ky na lc ms mt mu mv bi translated">如果你不想记住太多密码，注册Google/GitHub。</li><li id="f55c" class="mn mo it kh b ki mw km mx kq my ku mz ky na lc ms mt mu mv bi translated">登录后，单击创建订阅。然后接受所有默认设置，创建一个新的免费订阅。你可以选择你喜欢的云和地区。我更喜欢使用AWS，托管在us-east-1地区。</li><li id="da98" class="mn mo it kh b ki mw km mx kq my ku mz ky na lc ms mt mu mv bi translated">订阅后，单击“新建数据库”创建一个新的数据库实例。</li><li id="b02c" class="mn mo it kh b ki mw km mx kq my ku mz ky na lc ms mt mu mv bi translated">再次接受所有默认设置，并单击“Activate database”来激活数据库实例。</li><li id="80de" class="mn mo it kh b ki mw km mx kq my ku mz ky na lc ms mt mu mv bi translated">给它几分钟来设置。而在那里，数据库正等着你开始学习。只需记下数据库URL。</li><li id="b370" class="mn mo it kh b ki mw km mx kq my ku mz ky na lc ms mt mu mv bi translated">另外，请注意数据库密码。复制到记事本。然后注销web控制台。</li></ol><h1 id="1d3b" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">Redis洞察</h1><p id="3ba6" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">这是使用Redis的必备工具。你可以从<a class="ae mm" href="https://redis.info/3wMR7PR" rel="noopener ugc nofollow" target="_blank">这个链接</a>下载。安装和设置很简单。单击ADD REDIS DATABASE配置新的连接，并提供您在上述步骤中选择的数据库详细信息。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nb"><img src="../Images/a8a28f9dd480c325ad30a6e54e6b8833.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HgaXkyicQP6s6L7q.png"/></div></div></figure><h1 id="20c9" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">给我看代码</h1><p id="a825" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">你是不是理论过量了？现在让我们尝试一些可以帮助我们应用一些概念的代码。我们将浏览一些代码片段，并构建一个使用RediSearch的API。这个例子着重于文本搜索。Redis为我们提供了一个简单的命令行界面，以及用大多数通用语言编写的有用的SDK模块。</p><p id="dee7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将构建一个JavaScript应用程序，它使用<a class="ae mm" href="https://redis.js.org/" rel="noopener ugc nofollow" target="_blank">节点Redis </a>模块与Redis服务器通信。除了JavaScript代码，我们还可以看到相应的CLI命令。</p><p id="a04c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们需要一个文本丰富的数据集保存在我们的数据库中，并展示搜索功能。为此，我们将使用从Kaggle获得的大量诗歌。JSON块可以在这个<a class="ae mm" href="https://share.krazyminds.com/kagglerenaissancepoems.json" rel="noopener ugc nofollow" target="_blank">链接</a>上找到。</p><h1 id="1481" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">密码</h1><p id="07d6" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">数据库准备好了，让我们详细检查代码。您可以在这个<a class="ae mm" href="https://github.com/solegaonkar/redisearch-blog" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>中找到完整的源代码。在本地克隆存储库。您将需要<a class="ae mm" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank"> NodeJS </a>来运行这段代码。代码准备好之后，打开文件<code class="fe nc nd ne nf b">config/default.json</code>。</p><p id="c01a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">更新该文件，以包含创建数据库时获得的Redis URL和密码。</p><p id="adc6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，快速浏览一下JavaScript代码。查看app.js</p><h1 id="4c32" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">进口</h1><p id="de8d" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">像任何其他JavaScript代码一样，我们从导入开始。我们需要ExpressJs来创建API。此外，对于详细的应用程序，我们使用Axios、md5和config等辅助库。</p><p id="80d2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最重要的是redis模块，它帮助我们与Redis数据库进行通信，而不必担心底层细节。</p><pre class="mi mj mk ml gt ng nf nh bn ni nj bi"><span id="92c5" class="nk le it nf b be nl nm l nn no">const express = require("express");<br/>const redis = require("redis");<br/>const axios = require("axios");<br/>const md5 = require("md5");<br/>const config = require("config");</span></pre><h1 id="e889" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">Redis客户端</h1><p id="6c56" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">所有导入就绪后，我们实例化客户机以连接Redis数据库。连接细节来自我们在<code class="fe nc nd ne nf b">config/default.json</code>中提供的配置。</p><pre class="mi mj mk ml gt ng nf nh bn ni nj bi"><span id="da4b" class="nk le it nf b be nl nm l nn no">const client = redis.createClient(config.redis);<br/>client.on("error", (err) =&gt; console.log("Redis Client Error", err));<br/>await client.connect().then((e) =&gt; console.log("Connected"))<br/>    .catch((e) =&gt; console.log("Not connected"));</span></pre><h1 id="9b76" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">加载数据</h1><p id="2115" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">接下来，我们从互联网上获取诗歌数据，并将其加载到数据库中。这是原始数据设置步骤。在幕后，Redis客户机调用<code class="fe nc nd ne nf b">HSET</code>命令来填充所需的数据。</p><pre class="mi mj mk ml gt ng nf nh bn ni nj bi"><span id="6966" class="nk le it nf b be nl nm l nn no">var promiseList = list.map((poem, i) =&gt;<br/>  Promise.all(Object.keys(poem).map((key) =&gt; client.hSet(`poem:${md5(i)}`, key, poem[key])))<br/>);<br/>await Promise.all(promiseList);</span></pre><h1 id="81a0" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">创建索引</h1><p id="9926" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">有了数据库中的数据，我们开始创建索引。这就完成了数据库的设置。注意这里我们有一些文本索引和一些标签索引。诗歌的年代和类型有一个标签索引，因为我们不希望围绕它们有复杂的查询。</p><pre class="mi mj mk ml gt ng nf nh bn ni nj bi"><span id="1eee" class="nk le it nf b be nl nm l nn no">await client.ft.create(<br/>  "idx:poems",<br/>  {<br/>    content: redis.SchemaFieldTypes.TEXT,<br/>    author: redis.SchemaFieldTypes.TEXT,<br/>    title: { type: redis.SchemaFieldTypes.TEXT, sortable: true },<br/>    age: redis.SchemaFieldTypes.TAG,<br/>    type: redis.SchemaFieldTypes.TAG,<br/>  },<br/>  {<br/>    ON: "HASH",<br/>    PREFIX: "poem:",<br/>  }<br/>);</span></pre><p id="1d8d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">可以在Redis CLI中使用以下命令完成同样的操作</p><pre class="mi mj mk ml gt ng nf nh bn ni nj bi"><span id="f5f3" class="nk le it nf b be nl nm l nn no">FT.CREATE idx:poems ON HASH PREFIX 1 poem: SCHEMA content TEXT author TEXT title TEXT SORTABLE age TAG type TAG</span></pre><h1 id="cc74" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">作者API</h1><p id="a18b" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">对于数据库设置，我们从express服务器开始。实例化express应用程序后，我们可以创建第一个API来基于作者搜索诗歌。注意，它是一个正则表达式。因此，它将获取任何与表达式匹配的作者姓名。此外，搜索不区分大小写。</p><pre class="mi mj mk ml gt ng nf nh bn ni nj bi"><span id="bcba" class="nk le it nf b be nl nm l nn no">app.get("/author/:author", function (req, res) {<br/>  client.ft.search("idx:poems", `@author: /${req.params.author}/`)<br/>    .then((result) =&gt; res.send(result.documents));<br/>});</span></pre><p id="b39a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">尝试用<a class="ae mm" href="http://127.0.0.1:3000/author/william" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:3000/author/William</a>调用API。</p><p id="3e1a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">它将获取所有以威廉为名的作者所写的诗歌。</p><p id="c779" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">CLI也可以达到同样的效果</p><pre class="mi mj mk ml gt ng nf nh bn ni nj bi"><span id="5607" class="nk le it nf b be nl nm l nn no">FT.SEARCH idx:poems "@author:/william/"</span></pre><h1 id="98d2" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">模糊搜索API</h1><p id="898a" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">该示例显示了另一种搜索功能，即模糊搜索。请注意搜索表达式中的%符号。这意味着模糊搜索。现在，搜索也将匹配相似的词。</p><pre class="mi mj mk ml gt ng nf nh bn ni nj bi"><span id="285e" class="nk le it nf b be nl nm l nn no">app.get("/fuzzy/:text", function (req, res) {<br/>  client.ft.search("idx:poems", `%${req.params.text}%`)<br/>     .then((result) =&gt; res.send(result.documents));<br/>});</span></pre><p id="ac00" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">尝试用<a class="ae mm" href="http://127.0.0.1:3000/fuzzy/speak" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:3000/fuzzy/speak</a>调用API</p><p id="302a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">它将获取包含与口语相似的单词的诗歌。CLI也可以达到同样的效果</p><pre class="mi mj mk ml gt ng nf nh bn ni nj bi"><span id="ccfb" class="nk le it nf b be nl nm l nn no">FT.SEARCH idx:poems "%speak%"</span></pre><h1 id="060e" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">更多信息</h1><p id="ce49" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">这只是再研究潜力的一瞥。要了解更多详情，请查看:</p><ol class=""><li id="44f5" class="mn mo it kh b ki kj km kn kq mp ku mq ky mr lc ms mt mu mv bi translated"><a class="ae mm" href="https://developer.redis.com/?utm_campaign=write_for_redis" rel="noopener ugc nofollow" target="_blank">企业Redis </a></li><li id="9f40" class="mn mo it kh b ki mw km mx kq my ku mz ky na lc ms mt mu mv bi translated"><a class="ae mm" href="https://www.youtube.com/watch?v=vyxdC1qK4NE" rel="noopener ugc nofollow" target="_blank">面向开发者的Redis】</a></li></ol></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="dd0c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这篇文章是与Redis合作的</p></div></div>    
</body>
</html>