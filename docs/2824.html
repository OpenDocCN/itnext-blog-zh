<html>
<head>
<title>Going Buildless</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">去无建筑</h1>
<blockquote>原文：<a href="https://itnext.io/going-buildless-cffeb67f6289?source=collection_archive---------4-----------------------#2019-08-09">https://itnext.io/going-buildless-cffeb67f6289?source=collection_archive---------4-----------------------#2019-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5cd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大家好👋</p><p id="920d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在异地恋，这意味着每隔几周我就要坐飞机去英国。每次我在飞机上的时候，我都会想如果能读一些reddit上的帖子该有多好。我可以做的是找到一个reddit应用程序，让你缓存离线发布的帖子(我肯定有一个)，<em class="kl">或</em>我可以借此机会自己写点东西，使用一些最新最棒的技术和网络标准，找点乐子！</p><p id="e9b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最重要的是，最近有很多关于我喜欢称之为“无构建”的讨论，我认为这是一个非常迷人和伟大的最新发展。这也正是这篇文章的内容；给发展带来乐趣。</p><p id="c194" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也喜欢把这篇博客想象成对社区中一些真正了不起的人的敬意，他们使一些真正了不起的事情成为可能，也是一些令人兴奋的新技术和标准的展示，随着我们的发展，我将链接到所有这些好东西。</p><p id="98d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，这不是一个循序渐进的教程，但是如果你想查看代码，你可以在<a class="ae km" href="https://github.com/thepassle/reddit-pwa" rel="noopener ugc nofollow" target="_blank"> github </a>上找到完成的项目。我们的最终结果应该是这样的:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/6fe5f233edf951e9e512688431ed3cd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DS1UJv3M6jSjPp23x1eGEg.png"/></div></div></figure><p id="c5af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以让我们直入主题，快速安装<em class="kl">几个</em>依赖项:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="dd89" class="le lf iq la b gy lg lh l li lj">npm i <a class="ae km" href="http://twitter.com/babel/core" rel="noopener ugc nofollow" target="_blank">@babel/core</a> babel-loader <a class="ae km" href="http://twitter.com/babel/preset-env" rel="noopener ugc nofollow" target="_blank">@babel/preset-env</a> <a class="ae km" href="http://twitter.com/babel/preset-react" rel="noopener ugc nofollow" target="_blank">@babel/preset-react</a> webpack webpack-cli react react-dom redux react-redux html-webpack-plugin are-you-tired-yet html-loader webpack-dev-server</span></pre><p id="5649" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我开玩笑的。我们不会用这些的。我们将努力避免尽可能多的工具/依赖，并保持较低的准入门槛。</p><p id="0b3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们<em class="kl">将</em>使用的是:</p><ul class=""><li id="5976" class="lk ll iq jp b jq jr ju jv jy lm kc ln kg lo kk lp lq lr ls bi translated">对于这个项目，我们将使用LitElement作为我们的组件模型。它易于使用，重量轻，接近金属，并利用web组件。</li><li id="a73e" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated"><a class="ae km" href="https://github.com/vaadin/vaadin-router" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">@ vaa din/router</strong></a><br/>vaa din路由器是一款真的很小(&lt; 7kb)的路由器，拥有*牛逼*的开发者体验，我怎么推荐都不够。</li><li id="ca07" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated"><a class="ae km" href="https://github.com/pikapkg/web" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">@ Pika/web</strong></a><br/>Pika将帮助我们将我们的模块整合在一起，以便于开发。</li><li id="5250" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated"><a class="ae km" href="https://open-wc.org/developing/es-dev-server.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">es-dev-server</strong></a><br/>我们在<a class="ae km" href="https://www.open-wc.org" rel="noopener ugc nofollow" target="_blank"> open-wc </a>做的一个简单的现代web开发工作流的开发服务器。虽然任何http服务器都可以；请随意带你自己的。</li></ul><p id="59b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅此而已。我们还将使用一些浏览器标准，即:<a class="ae km" href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/" rel="noopener ugc nofollow" target="_blank"> es模块</a>、<a class="ae km" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank"> web组件</a>、<a class="ae km" href="https://github.com/WICG/import-maps" rel="noopener ugc nofollow" target="_blank">导入-映射</a>、<a class="ae km" href="https://github.com/WICG/kv-storage" rel="noopener ugc nofollow" target="_blank">kv-存储</a>和<a class="ae km" href="https://developers.google.com/web/fundamentals/primers/service-workers/" rel="noopener ugc nofollow" target="_blank">服务人员</a>。</p><p id="f39f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，让我们继续安装我们的依赖项:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="b306" class="le lf iq la b gy lg lh l li lj">npm i -S lit-element <a class="ae km" href="http://twitter.com/vaadin/router" rel="noopener ugc nofollow" target="_blank">@vaadin/router</a><br/>npm i -D <a class="ae km" href="http://twitter.com/pika/web" rel="noopener ugc nofollow" target="_blank">@pika/web</a> es-dev-server</span></pre><p id="0c4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还将在“package.json”中添加一个“postinstall”挂钩，它将为我们运行Pika:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="26db" class="le lf iq la b gy lg lh l li lj">“scripts”: {<br/>    “start”: “es-dev-server”,<br/>    “postinstall”: “pika-web”<br/>}</span></pre><h1 id="f339" class="ly lf iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">🐭鼠兔</h1><p id="9ee8" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">Pika是Fred K. Schott 的一个项目，旨在将2014年怀旧的简单性带到2019年的网络开发中。Fred正在做各种各样令人敬畏的事情，例如，他制作了<a class="ae km" href="https://www.pika.dev/" rel="noopener ugc nofollow" target="_blank"> pika.dev </a>，可以让你轻松地在npm上搜索现代JavaScript包。他最近还在恐龙化石2019上发表了他的演讲<a class="ae km" href="https://www.youtube.com/watch?v=2Wwx-lF5NhE" rel="noopener ugc nofollow" target="_blank">重塑注册表</a>，我强烈推荐你观看。</p><p id="8c45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">`<a class="ae km" href="http://twitter.com/pika/web" rel="noopener ugc nofollow" target="_blank"> @pika/web </a>`更进一步。如果我们运行“pika-web ”,它会将我们的依赖项作为单个javascript文件安装到一个新的“web_modules/”目录中。如果您的依赖项在其“package.json”清单中导出了一个ES“module”入口点，Pika会支持它。如果您有任何可传递的依赖项，Pika将为您的依赖项中的任何共享代码创建单独的块。简易柠檬榨汁机。</p><p id="b5fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着，在我们的例子中，我们的输出看起来像这样:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="d185" class="le lf iq la b gy lg lh l li lj">└─ web_modules/<br/>    ├─ lit-element.js<br/>    └─ <a class="ae km" href="http://twitter.com/vaadin" rel="noopener ugc nofollow" target="_blank">@vaadin</a><br/>    └─ router.js</span></pre><p id="3168" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太棒了。就是这样。我们已经准备好了我们的依赖项，作为单个javascript模块文件，这将使我们在这篇博文的后面变得非常方便，敬请关注！</p><h1 id="f6ee" class="ly lf iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">📥导入地图</h1><p id="3e10" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">好吧！现在我们已经解决了依赖关系，让我们开始工作吧。我们将制作一个“index.html ”,看起来像这样:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="7886" class="le lf iq la b gy lg lh l li lj">&lt;html&gt;<br/>    &lt;! — head etc →<br/>    &lt;body&gt;<br/>        &lt;reddit-pwa-app&gt;&lt;/reddit-pwa-app&gt;<br/>        &lt;script src=”./src/reddit-pwa-app.js” type=”module”&gt;&lt;/script&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="e5f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和“reddit-pwa-app.js ”:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="5694" class="le lf iq la b gy lg lh l li lj">import { LitElement, html } from ‘lit-element’;</span><span id="3c72" class="le lf iq la b gy na lh l li lj">class RedditPwaApp extends LitElement {<br/> <br/> // …<br/> <br/>   render() {<br/>      return html`<br/>         &lt;h1&gt;Hello world!&lt;/h1&gt;<br/>      `;<br/>   }<br/>}</span><span id="0b6a" class="le lf iq la b gy na lh l li lj">customElements.define(‘reddit-pwa-app’, RedditPwaApp);</span></pre><p id="82d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有了一个好的开始。让我们试着看看目前为止在浏览器中是什么样子，让我们启动服务器，打开浏览器，然后…这是什么？一个错误？</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nb"><img src="../Images/5fd0b18a426d4a0a8e3d681c8139b47f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AX4oGcgccaPnh73E1uej5A.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">哦天啊。</figcaption></figure><p id="b36a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们甚至还没有开始。好吧，让我们看看。这里的问题是我们的模块说明符是空的。他们是<em class="kl">裸模块说明符</em>。这意味着没有指定路径，没有文件扩展名，它们只是…非常简单。我们的浏览器不知道该怎么做，所以它会抛出一个错误。</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="43a7" class="le lf iq la b gy lg lh l li lj">import { LitElement, html } from ‘lit-element’; // ← bare module specifier<br/>import { Router } from ‘<a class="ae km" href="http://twitter.com/vaadin/router" rel="noopener ugc nofollow" target="_blank">@vaadin/router</a>’; // ← bare module specifier<br/><br/>import { foo } from ‘./bar.js’; // ← not bare!<br/>import { html } from ‘<a class="ae km" href="https://unpkg.com/lit-html'" rel="noopener ugc nofollow" target="_blank">https://unpkg.com/lit-html'</a>; // ← not bare!</span></pre><p id="58fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，我们可以为此使用一些工具，比如webpack或rollup，或者一个开发服务器，它可以将裸模块说明符重写为对浏览器有意义的东西，这样我们就可以加载我们的导入。但这意味着我们必须引入一堆工具，投入配置，我们试图在这里保持最小化。我们只想写代码！为了解决这个问题，我们来看看<a class="ae km" href="https://github.com/WICG/import-maps" rel="noopener ugc nofollow" target="_blank">的进口地图</a>。</p><p id="dcd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Import maps是一个新提议，它允许您控制JavaScript导入的行为。使用导入映射，我们可以控制JavaScript“import”语句和“import()”表达式获取哪些URL，并允许在非导入上下文中重用该映射。这很好，有几个原因:</p><ul class=""><li id="9450" class="lk ll iq jp b jq jr ju jv jy lm kc ln kg lo kk lp lq lr ls bi translated">允许我们的裸模块说明符工作</li><li id="8826" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">提供回退解决方案，以便“从“jquery”导入$;`可以先尝试转到CDN，但如果CDN服务器出现故障，就退回到本地版本</li><li id="4fc7" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">启用对<a class="ae km" href="https://github.com/tc39/proposal-javascript-standard-library/" rel="noopener ugc nofollow" target="_blank">内置模块</a>的多填充或其他控制(稍后将详细介绍，请抓紧！)</li><li id="1946" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">解决了<a class="ae km" href="https://dev.to/open-wc/nested-dependencies-in-frontend-558c" rel="noopener ugc nofollow" target="_blank">嵌套依赖问题</a>(去看看那个博客吧！)</li></ul><p id="790f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">听起来很甜蜜，不是吗？导入映射目前在Chrome 75+中可用，在一个标志后面，记住这一点，让我们转到我们的“index.html ”,并将导入映射添加到我们的“”:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="c071" class="le lf iq la b gy lg lh l li lj">&lt;head&gt;<br/>   &lt;script type="importmap"&gt;<br/>      {<br/>        "imports": {<br/>          "<a class="ae km" href="http://twitter.com/vaadin/router" rel="noopener ugc nofollow" target="_blank">@vaadin/router</a>": "/web_modules/@vaadin/router.js",<br/>          "lit-element": "/web_modules/lit-element.js"<br/>        }<br/>      }<br/>   &lt;/script&gt;<br/>&lt;/head&gt;</span></pre><p id="efcf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们返回浏览器，刷新页面，就不会再有错误了，我们应该会看到`<h1> Hello world！在我们的屏幕上。</h1></p><p id="042c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">导入地图是一个非常有趣的新标准，绝对是你应该关注的东西。如果你有兴趣尝试它们，并基于“yarn.lock”文件生成你自己的导入贴图，你可以试试我们的<a class="ae km" href="https://www.open-wc.org" rel="noopener ugc nofollow" target="_blank">open-WC</a><a class="ae km" href="https://github.com/open-wc/open-wc/tree/master/packages/import-maps-generate" rel="noopener ugc nofollow" target="_blank">import-maps-generate</a>包。我真的很兴奋看到人们将结合进口地图开发什么。</p><h1 id="50bb" class="ly lf iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">📡服务行业人员</h1><p id="cde8" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">好了，我们要稍微提前一点时间。我们已经让我们的依赖项工作，我们已经设置了我们的路由器，我们已经完成了一些API调用来从reddit获取数据，并将其显示在我们的屏幕上。查看所有代码有点超出了这篇博客的范围，但是请记住，如果您想阅读实现细节，可以在github repo中找到所有代码。</p><p id="4e00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们制作这个应用程序是为了在飞机上阅读reddit的帖子，如果我们的应用程序可以离线工作，如果我们可以以某种方式保存一些帖子来阅读，那就太好了。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ng"><img src="../Images/bfa06d2260b1c849f24c6defa8be9413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dy7fi-0SjXK3eyBlFYhyEA.jpeg"/></div></div></figure><p id="0f61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">服务工作者是一种在后台运行的JavaScript工作者。你可以把它想象成位于网页和网络之间。每当你的网页发出请求时，它首先通过服务人员。这意味着我们可以拦截请求，并对其进行处理！比如说；我们可以让请求通过网络获得响应，并在它返回时缓存它，这样我们可以在以后离线时使用缓存的数据。我们也可以使用服务人员<em class="kl">预先保管我们的资产。这意味着我们可以预先缓存我们的应用程序可能需要的任何关键资产，以便脱机工作。如果我们没有网络连接，我们可以简单地返回到我们缓存的资产，并且仍然有一个工作的(尽管是离线的)应用程序。</em></p><p id="2892" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你有兴趣了解更多关于渐进式网络应用和服务工作者的知识，我<em class="kl">强烈推荐你阅读<a class="ae km" href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/" rel="noopener ugc nofollow" target="_blank">杰克·阿奇博尔德</a><a class="ae km" href="https://twitter.com/jaffathecake" rel="noopener ugc nofollow" target="_blank">的离线食谱</a>。以及这个视频教程<a class="ae km" href="https://www.youtube.com/watch?v=GSSP5BxBnu0&amp;list=PLIiQ4B5FSuphk6P-zg_E3W9zL3J22U4dT" rel="noopener ugc nofollow" target="_blank">系列</a>作者<a class="ae km" href="https://twitter.com/JoubranJad" rel="noopener ugc nofollow" target="_blank"> Jad Joubran </a>。</em></p><p id="491b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，让我们继续实现一个服务工作者。在我们的“index.html”中，我们将添加以下代码片段:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="d26d" class="le lf iq la b gy lg lh l li lj">&lt;script&gt;<br/>    if ('serviceWorker' in navigator) {<br/>      window.addEventListener('load', () =&gt; {<br/>        navigator.serviceWorker.register('./sw.js').then(() =&gt; {<br/>          console.log('ServiceWorker registered!');<br/>        }, (err) =&gt; {<br/>          console.log('ServiceWorker registration failed: ', err);<br/>        });<br/>      });<br/>    }<br/>&lt;/script&gt;</span></pre><p id="620c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还将在项目的根目录下添加一个“sw.js”文件。因此，我们即将预缓存我们的应用程序的资产，这就是Pika让我们的生活变得非常简单的地方。如果您看一下服务工作者文件中的安装处理程序:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="1f11" class="le lf iq la b gy lg lh l li lj">self.addEventListener('install', (event) =&gt; {<br/>  event.waitUntil(<br/>    caches.open(CACHENAME).then((cache) =&gt; {<br/>      return cache.addAll([<br/>        '/',<br/>        './web_modules/lit-element.js',<br/>        './web_modules/@vaadin/router.js',<br/>        './src/reddit-pwa-app.js',<br/>        './src/reddit-pwa-comment.js',<br/>        './src/reddit-pwa-search.js',<br/>        './src/reddit-pwa-subreddit.js',<br/>        './src/reddit-pwa-thread.js',<br/>        './src/utils.js',<br/>      ]);<br/>    })<br/>  );<br/>});</span></pre><p id="d0dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你会发现我们完全控制了我们的资产，我们有一个好的，干净的文件列表，我们需要离线工作。</p><h1 id="1fb3" class="ly lf iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">📴离线</h1><p id="528d" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">没错。既然我们已经缓存了离线工作的资源，如果我们能够保存一些可以离线阅读的文章，那就太好了。通往罗马的道路有很多，但由于我们有点处于边缘，我们将选择:Kv-存储！</p><h1 id="a2f2" class="ly lf iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">📦内置模块</h1><p id="cc18" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">这里有几件事要说一下。Kv-storage是一个<a class="ae km" href="https://developers.google.com/web/updates/2019/03/kv-storage#what_are_built-in_modules" rel="noopener ugc nofollow" target="_blank"> <em class="kl">内置模块</em> </a>。内置模块非常类似于常规的JavaScript模块，除了它们是浏览器自带的。值得注意的是，虽然浏览器自带内置模块，但它们并没有<em class="kl">而</em>暴露在全局范围内，而是以‘STD:’命名(是的，真的。).这有几个优点:它们不会增加启动新的JavaScript运行时上下文的任何开销(例如，新的选项卡、工作器或服务工作器)，并且它们不会消耗任何内存或CPU，除非它们被实际导入，并且避免了与现有代码的命名冲突。</p><p id="63d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个有趣的，如果不是有点争议的，作为内置模块的提议是<a class="ae km" href="https://github.com/jackbsteinberg/std-toast" rel="noopener ugc nofollow" target="_blank"> std-toast </a>元素和<a class="ae km" href="https://github.com/tkent-google/std-switch/blob/master/README.md" rel="noopener ugc nofollow" target="_blank"> std-switch </a>元素。</p><h1 id="8f62" class="ly lf iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">🗃kv-存储</h1><p id="7b92" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">好了，说完这些，我们来谈谈<a class="ae km" href="https://github.com/WICG/kv-storage" rel="noopener ugc nofollow" target="_blank"> kv存储</a>。Kv-storage(或<br/> " <em class="kl"> key value </em> storage ")与localStorage非常相似，除了几个<strong class="jp ir">主要的</strong>区别，它位于IndexedDB之上。</p><p id="62d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">kv-storage的动机是localStorage是同步的，这会导致糟糕的性能和同步问题。它还仅限于字符串键/值对。另一种方法，IndexedDb，很难使用。它如此难以使用的原因是它早于承诺，这导致了非常糟糕的开发者体验。不好玩。然而，Kv-storage非常有趣，异步、<em class="kl">和</em>易于使用！考虑下面的例子:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="cef8" class="le lf iq la b gy lg lh l li lj">import { storage, /* StorageArea */ } from "std:kv-storage";</span><span id="49b8" class="le lf iq la b gy na lh l li lj">(async () =&gt; {<br/>  await storage.set("mycat", "Tom");<br/>  console.log(await storage.get("mycat")); // Tom<br/>})();</span></pre><blockquote class="nh ni nj"><p id="d1f0" class="jn jo kl jp b jq jr js jt ju jv jw jx nk jz ka kb nl kd ke kf nm kh ki kj kk ij bi translated">注意我们是如何从“std:kv-storage”导入的？这个导入说明符也是空的，但在这种情况下没关系，因为它实际上是浏览器附带的。</p></blockquote><p id="239d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相当整洁。我们可以很好地使用它来添加一个“离线保存”按钮，并简单地存储reddit线程的JSON数据，并在需要时获取它。</p><p id="3507" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">` reddit-pwa-thread.js:52 `:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="53ea" class="le lf iq la b gy lg lh l li lj">const savedPosts = new StorageArea("saved-posts");</span><span id="eab3" class="le lf iq la b gy na lh l li lj">// ...</span><span id="f33e" class="le lf iq la b gy na lh l li lj">async saveForOffline() {<br/>  await savedPosts.set(this.location.params.id, this.thread); // id of the post + thread as json<br/>  this.isPostSaved = true;<br/>}</span></pre><p id="5732" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果我们单击“保存以供脱机使用”按钮，转到开发人员工具的“应用程序”选项卡，我们可以看到一个“kv-storage:saved-posts ”,其中保存了这篇文章的JSON数据:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nn"><img src="../Images/747a256c8365d1267b72513723bf91ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3MKLRUkK44WIMkjmQRxGLw.png"/></div></div></figure><p id="d129" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们返回到我们的搜索页面，我们会看到一个已保存帖子的列表，其中包含我们刚刚保存的帖子:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi no"><img src="../Images/2e5154c684b257cc40b73c50b8d1e1d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0iNOW1_Js68GeofYYVjffA.png"/></div></div></figure><h1 id="34d2" class="ly lf iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">🔮聚合填充</h1><p id="d371" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">非常好。然而，我们即将遇到另一个问题。生活在边缘很有趣，但也很危险。我们在这里遇到的问题是，在撰写本文时，kv-storage只是在Chrome中的一个标志后面实现的。这显然不太好。幸运的是，有一个polyfill可用，同时我们可以展示另一个真正有用的导入特性——地图；多填充！</p><p id="1607" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们安装kv-storage-polyfill:</p><p id="df02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">` NPM I-S kv-存储-聚合填充'</p><blockquote class="nh ni nj"><p id="27b0" class="jn jo kl jp b jq jr js jt ju jv jw jx nk jz ka kb nl kd ke kf nm kh ki kj kk ij bi translated">请注意，我们的“安装后”钩子将再次为我们运行Pika</p></blockquote><p id="a8fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们将以下内容添加到“index.html”中的导入映射中:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="1740" class="le lf iq la b gy lg lh l li lj">&lt;script type="importmap"&gt;<br/>  {<br/>    "imports": {<br/>      "<a class="ae km" href="http://twitter.com/vaadin/router" rel="noopener ugc nofollow" target="_blank">@vaadin/router</a>": "/web_modules/@vaadin/router.js",<br/>      "lit-element": "/web_modules/lit-element.js",<br/>      "/web_modules/kv-storage-polyfill.js": [<br/>        "std:kv-storage",<br/>        "/web_modules/kv-storage-polyfill.js"<br/>      ]<br/>    }<br/>  }<br/>&lt;/script&gt;</span></pre><p id="6e95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，这里发生的情况是，每当请求或导入`/ web _ modules/kv-storage-poly fill . js '时，浏览器将首先<em class="kl">尝试查看` std:kv-storage '是否可用；但是，如果失败，它将加载“/ web _ modules/kv-storage-poly fill . js”。</em></p><p id="00c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以在代码中，如果我们导入:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="b7b2" class="le lf iq la b gy lg lh l li lj">import { StorageArea } from '/web_modules/kv-storage-polyfill.js';</span></pre><p id="5ac9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是将要发生的事情:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="b5a3" class="le lf iq la b gy lg lh l li lj">"/web_modules/kv-storage-polyfill.js": [     // when I'm requested<br/>  "std:kv-storage",                          // try me first!<br/>  "/web_modules/kv-storage-polyfill.js"      // or fallback to me<br/>]</span></pre><h1 id="a110" class="ly lf iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">🎉结论</h1><p id="37e6" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">我们现在应该有一个简单的、功能性的PWA，具有最小的依赖性。这个项目有一些我们可以抱怨的吹毛求疵的地方，它们可能都是公平的。比如说；我们可能不需要使用鼠兔，但它确实让我们的生活变得很容易。关于添加一个简单的Webpack配置，您可以提出同样的论点，但是您没有抓住要点。这里的重点是做一个好玩的应用，同时使用一些最新的功能，去掉一些流行语，入门门槛低。正如弗雷德·肖特所说:“在2019年，你应该使用捆扎机，因为你想这样做，而不是因为你需要这样做。”</p><p id="ec44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，如果你对吹毛求疵感兴趣，你可以阅读<a class="ae km" href="https://github.com/lukejacksonn/perflink/issues/15" rel="noopener ugc nofollow" target="_blank">这篇关于使用Webpack vs Pika vs buildless的精彩讨论</a>，你会从Webpack核心团队的<a class="ae km" href="https://twitter.com/TheLarkInn" rel="noopener ugc nofollow" target="_blank"> Sean Larkinn </a>以及Pika的创造者<a class="ae km" href="https://twitter.com/FredKSchott" rel="noopener ugc nofollow" target="_blank"> Fred K. Schott </a>那里获得一些很好的见解。</p><p id="dfe7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望你喜欢这篇博文，我希望你能学到一些东西，或者发现一些新的有趣的人。现在这个领域有许多令人兴奋的发展，我希望我能让你和我一样对它们感到兴奋。如果你有任何问题、评论、反馈或挑剔，请随时在twitter上联系我，地址是<a class="ae km" href="https://twitter.com/passle_" rel="noopener ugc nofollow" target="_blank"> @passle_ </a>或<a class="ae km" href="https://twitter.com/openwc" rel="noopener ugc nofollow" target="_blank"> @openwc </a>，不要忘记查看<a class="ae km" href="https://www.open-wc.org" rel="noopener ugc nofollow" target="_blank">open-wc.org</a>😉。</p><h1 id="6ed6" class="ly lf iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">荣誉奖</h1><p id="eea5" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">在结束这篇博客之前，我想对一些非常有趣的人说几句话，他们正在做一些伟大的事情，你可能想关注一下。</p><p id="6fe0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开始:<a class="ae km" href="https://twitter.com/guybedford" rel="noopener ugc nofollow" target="_blank">盖伊·贝德福德</a>，他写了<a class="ae km" href="https://github.com/guybedford/es-module-shims" rel="noopener ugc nofollow" target="_blank">es-模块-垫片</a>，嗯，垫片es模块，并导入地图。如果你问我，这是一个相当惊人的壮举，并允许我实际上使用这些新技术中的一些尚未在所有浏览器上实现。</p><p id="dc3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你对更多相同的东西感兴趣，你绝对应该看看<a class="ae km" href="https://twitter.com/lukejacksonn" rel="noopener ugc nofollow" target="_blank">卢修斯·杰克逊</a>T6】的演讲<a class="ae km" href="https://www.youtube.com/watch?v=mVjZQrsXBQE" rel="noopener ugc nofollow" target="_blank">不要构建那个应用！没有网络包，没有烦恼🤓🤙正如路加所说。</a></p><p id="5e00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还要感谢<a class="ae km" href="https://twitter.com/PowersBenny" rel="noopener ugc nofollow" target="_blank"> Benny Powers </a>和<a class="ae km" href="http://github.com/larsdenbakker" rel="noopener ugc nofollow" target="_blank"> Lars den Bakker </a>的有益评论和反馈。</p></div></div>    
</body>
</html>