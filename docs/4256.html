<html>
<head>
<title>It’s Time To Kill The Password</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">是时候杀密码了</h1>
<blockquote>原文：<a href="https://itnext.io/its-time-to-kill-the-password-bbab40f36ba0?source=collection_archive---------2-----------------------#2020-05-25">https://itnext.io/its-time-to-kill-the-password-bbab40f36ba0?source=collection_archive---------2-----------------------#2020-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="2f65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如何通过Web身份验证为无密码的未来做好准备</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/46b07e43eb6f482fdcae09c87d011efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5pK9T0pYaLR9ElRh"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://unsplash.com/@icons8?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Icons8团队</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="c135" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">想象一下，你在某个地方的保险箱里藏了一些非常贵重的珠宝。</p><p id="e59f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打开这个保险箱的唯一方法是把密码交给另一个人，他会为你打开它。你把密码写在一张纸上，放进信封，合上信封，然后交给这个人。</p><p id="bf79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个人也必须沿着街道走到你的保险箱。在这个过程中，代码可能会丢失，甚至被盗。</p><p id="cb76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，你甚至不知道这个人是否可信。</p><p id="f1d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf">你会同意这种保障吗？似乎不太安全，是吗？</em></p><p id="7c5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的问题是，打开你的保险箱的密码现在是一个<em class="lf">共享秘密</em>，这也是密码的问题。</p><p id="55d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当你需要登录一个网站来访问你的电子邮件或银行账户时，你向服务器发送你的密码来证明你就是你所声称的那个人。</p><p id="eb5b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是你和你的银行账户、电子邮件或其他敏感数据之间唯一的障碍。这也是站在黑客和你的敏感数据之间的唯一考虑。</p><p id="86f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，如果黑客设法窃取你的密码或猜测它，因为它是薄弱的，他们可以完全访问你的数据。大约80%的黑客入侵都与被盗密码或弱密码有关。</p><h1 id="2f8e" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">密码是通向您数据的大门</h1><p id="b490" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">你可以在大多数通往你公司的门上装上厚重的锁，但是如果只有一扇门仍然敞开着，这些锁就帮不了你了。</p><p id="9b1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个弱密码就足以危及你所有的安全措施。</p><p id="7ab9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">密码管理器有助于使您的数据更加安全，但仍然不能防止密码通过网络钓鱼攻击被窃取。这种风险可以通过使用双因素身份认证(2FA)来最小化，幸运的是，2FA <a class="ae le" href="https://duo.com/blog/the-2019-state-of-the-auth-report-has-2fa-hit-mainstream-yet" rel="noopener ugc nofollow" target="_blank">的采用率从2017年的仅28%上升到2019年的53</a>。</p><p id="d7f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是即使是2FA也不能幸免于复杂的网络钓鱼攻击。这对人们来说也不方便，而方便是人们仍然使用<a class="ae le" href="https://www.nbcnews.com/better/lifestyle/worst-passwords-2019-they-re-so-weak-even-novice-hacker-ncna1106626" rel="noopener ugc nofollow" target="_blank">令人震惊的弱密码</a>的主要原因。</p><h1 id="a57a" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">如何停止分享你的秘密</h1><p id="0d45" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">如果你的密码是一个秘密，那么保护它的最好方法显然是停止分享它。但由于你需要与网络应用程序共享它来登录，这不是一个选项。</p><p id="c028" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">网络认证为此提供了一个解决方案。</p><p id="efa9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它通过使用非对称加密消除了对密码的需求，非对称加密涉及一对由公钥和私钥组成的密钥对。公钥被用来加密只有相应的私钥才能解密的东西<em class="lf">。</em></p><p id="16a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">想象一下你想给我发一条秘密信息。我可以给你一个有钥匙的盒子，把这个秘密信息放进去。你可以把消息放在盒子里然后锁住，但是你不能<em class="lf">解锁</em>它。</p><p id="8359" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用于消息的盒子是公钥，而可以打开盒子的密钥是私钥。</p><p id="9899" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我可以自由地将我的公钥(只能上锁的盒子)分发给任何想给我发送秘密消息的人，因为没有相应的私钥，它实际上是没有用的。所以我的私钥是保密的，不应该被共享。</p><p id="0dfd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是Web身份验证(WebAuthn)的基础。</p><h1 id="d94d" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">WebAuthn如何工作</h1><p id="b0db" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">WebAuthn允许你使用名为<em class="lf">授权码的硬件设备登录网站，比如苹果的TouchID、Windows Hello或USB安全密钥。</em></p><p id="744e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些授权码通常会生成并存储一个由公钥和私钥组成的新密钥对(称为<em class="lf">凭证</em>)。然后，该凭证可用于向网站注册。</p><p id="1151" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注册后，可以从身份验证器中检索该凭证，以便用户登录该网站。</p><p id="4d0b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不是客户端向服务器发送密码，而是服务器向客户端发送一个非常大的随机字符串，称为<em class="lf">挑战</em>。然后，客户端用私钥对这个质询进行签名，这意味着它生成了这个质询的散列。</p><p id="1b58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，客户机将这个散列连同相应的公钥一起发送回服务器。</p><p id="116f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，服务器可以用公钥验证这个散列，这证明客户端拥有相应的私钥，并且认证成功。</p><p id="440d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">没有共享的秘密，只有一个公钥，没有相应的私钥是没有用的。这意味着存储这些公钥的数据库对黑客不再有吸引力，网络钓鱼也不再有用。</p><p id="f1bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">私钥安全地存储在硬件验证器中。最重要的是，WebAuthn中使用的所有凭证都是有作用域的，这意味着为某个网站(来源)创建的凭证只能<em class="lf">用于该来源。</em></p><p id="99cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建用于注册的凭证，然后使用它进行身份验证是相当简单的步骤，在客户端需要两次调用:</p><p id="4201" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">navigator.credentials.create()</code>创建注册凭证，<code class="fe mj mk ml mm b">navigator.credentials.get()</code>检索认证凭证</p><p id="3dbb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们详细了解一下注册新凭据并使用它进行身份验证的步骤。</p><h1 id="fcaf" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">注册凭据</h1><p id="d984" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">我们需要采取的第一步是创建一个新的凭证(keypair ),并将其注册到我们想要进行身份验证的网站。</p><p id="61cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要创建新凭据:</p><pre class="kp kq kr ks gt mn mm mo mp aw mq bi"><span id="b6d7" class="mr lh it mm b gy ms mt l mu mv">const credential = await navigator.credentials.create({<br/>    publicKey: {<br/>      challenge: {<br/>        type: "Buffer",<br/>        data: [53, 69, 96, 194, ...]<br/>      }, <br/>      rp: {<br/>        name: "What PWA Can Do Today",<br/>        id: "whatpwacando.today"<br/>      },<br/>      user: {<br/>        id: {<br/>          type: "Buffer",<br/>          data: [134, 196, 104, ...]<br/>        }, <br/>        name: "webauthn@whatpwacando.today", <br/>        displayName: "WebAuthn"<br/>      },<br/>      pubKeyCredParams: [{alg: -7, type: "public-key"}],<br/>      <!-- -->authenticatorSelectionCriteria:  {<br/>        attachment: "platform",<br/>        userVerification: "required"<br/>      },<br/>      timeout: 60000<br/>    }<br/>});</span></pre><p id="77c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对<code class="fe mj mk ml mm b">navigator.credentials.create()</code>的调用接收一个带有单键<code class="fe mj mk ml mm b">publicKey</code>的对象，该对象包含创建新凭证的配置。</p><p id="c7a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来分解属性:</p><p id="7c31" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">challenge</code>是从服务器接收的随机字符串，必须用公钥签名，以证明用户拥有相应的私钥。</p><p id="fc07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">rp</code>代表依赖方，这是负责注册和认证用户的实体，即我们要注册的网站。<code class="fe mj mk ml mm b">id</code>必须是网站域名的子集。</p><p id="91e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">user</code>包含当前注册用户的信息。它必须至少包含属性<code class="fe mj mk ml mm b">id</code>，该属性用于将用户与凭证相关联。它是在服务器上生成的。</p><p id="eb76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">pubKeyCredParams</code>是一个对象数组，描述将要创建的凭证的特性。目前，<code class="fe mj mk ml mm b">type</code>唯一可能的值是“公钥”，而<code class="fe mj mk ml mm b">alg</code>的值-7表示具有SHA-256的椭圆曲线算法ECDSA。</p><p id="05be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">authenticatorSelectionCriteria</code>为允许创建凭据的授权码设置标准。<br/> <code class="fe mj mk ml mm b">attachment: "platform"</code>意味着我们想要一个绑定到客户端的不可移除的认证器。<br/> <code class="fe mj mk ml mm b">userVerification</code>表示是否需要用户交互来验证用户。因为我们希望使用指纹进行身份验证，所以该值应该为“true”。</p><p id="94e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">timeout</code>包含脚本等待注册过程完成的时间(毫秒)。<em class="lf">注意，这是一个可能被浏览器覆盖的提示。</em></p><p id="fbc4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当注册过程完成时，返回一个<code class="fe mj mk ml mm b">PublicKeyCredential</code>对象:</p><pre class="kp kq kr ks gt mn mm mo mp aw mq bi"><span id="1cd1" class="mr lh it mm b gy ms mt l mu mv">PublicKeyCredential {<br/>  id: "Aa-aGSY1jGxNZlF9...",<br/>  rawId: ArrayBuffer(103), <br/>  <!-- -->response: AuthenticatorAttestationResponse {<br/>    attestationObject: ArrayBuffer(265),<br/>    clientDataJSON: ArrayBuffer(266)<br/>  },<br/>  type: "public-key"<br/>}</span></pre><p id="6ab2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">id</code>是新创建的凭证的ID，用于在用户尝试进行身份验证时识别它。</p><p id="b24c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">rawId</code>是二进制形式的<code class="fe mj mk ml mm b">id</code>。</p><p id="102a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们<em class="lf">注册</em>一个新凭证时<code class="fe mj mk ml mm b">response</code>是类型<code class="fe mj mk ml mm b">AuthenticatorAttestationResponse</code>。<br/>当我们<em class="lf">认证</em>时，它的类型是<code class="fe mj mk ml mm b">AuthenticatorAssertionResponse</code>。</p><p id="e506" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">response</code>中的<code class="fe mj mk ml mm b">clientDataJSON</code>是从浏览器传递到认证器的数据，用于将凭证与服务器和浏览器相关联。</p><p id="6c6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">attestationObject</code>包含新生成的公钥、可选的证明证书和其他用于在服务器上验证的元数据。</p><p id="6a69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">type</code>当前可能只保存值“公钥”。</p><p id="29d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在可以将凭证发送到服务器，以下列形式进行注册:</p><pre class="kp kq kr ks gt mn mm mo mp aw mq bi"><span id="d5fc" class="mr lh it mm b gy ms mt l mu mv">const data = {<br/>  rawId,<br/>  response: {<br/>    attestationObject,<br/>    clientDataJSON,<br/>    id: credential.id,<br/>    type: credential.type<br/>  }<br/>};</span></pre><h1 id="ad13" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">用凭证认证</h1><p id="8403" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">现在我们已经注册了我们的凭证，让我们尝试进行身份验证！</p><p id="89e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就像注册一样，我们只需要一个简单的呼叫来进行认证:</p><pre class="kp kq kr ks gt mn mm mo mp aw mq bi"><span id="1fe1" class="mr lh it mm b gy ms mt l mu mv">const credential = await navigator.credentials.get({<br/>  publicKey: {<br/>    <!-- -->challenge: {<br/>      type: "Buffer",<br/>      data: [236, 146, 80, ...]<br/>    },<br/>    allowCredentials: [<br/>      <!-- -->{<br/>        id: credential.rawId,<br/>        type: "public-key",<br/>        transports: ["internal"]<br/>      }<br/>    <!-- -->],<br/>    rpId: "whatpwacando.today",<br/>    <!-- -->userVerification: "required"<br/>  <!-- -->}<br/>});</span></pre><p id="d62a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在调用<code class="fe mj mk ml mm b">navigator.credentials.get()</code>来检索与我们在options对象中传递的所有标准相匹配的凭证。这个对象也有一个保存实际标准的键<code class="fe mj mk ml mm b">publicKey</code>。</p><p id="d2dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">challenge</code>也是来自服务器的随机字符串，必须用公钥对其进行签名，以证明用户拥有相应的私钥。</p><p id="08d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">allowCredentials</code>是包含凭据描述符的数组，这些凭据描述符限制了用于身份验证的凭据。<br/> <code class="fe mj mk ml mm b">id</code>是我们之前创建的凭证的<code class="fe mj mk ml mm b">rawId</code>属性。<br/>目前，<code class="fe mj mk ml mm b">type</code>唯一可能的值是“公钥”。<br/> <code class="fe mj mk ml mm b">transports</code>是一个数组，指定客户端和认证者之间可能的传输。<code class="fe mj mk ml mm b">internal</code>表示认证器与客户端设备绑定，不可移除，如指纹识别器。</p><p id="1f75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf">根据规范</em> <code class="fe mj mk ml mm b">allowCredentials</code> <em class="lf">是可选的，但我注意到当它被省略时，Chrome会回退到注册一个新的凭据，而不是检索一个现有的凭据，从而导致错误。</em></p><p id="ecc7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf">还要注意，这需要我们传入凭证的</em> <code class="fe mj mk ml mm b">rawId</code> <em class="lf">，这意味着我们需要将它存储在某个地方。在我稍后提供的演示中，</em> <code class="fe mj mk ml mm b">rawId</code> <em class="lf">存储在客户端的</em> <code class="fe mj mk ml mm b">localStorage</code> <em class="lf">中。在真实的场景中，用户将提供一个用户名，然后使用该用户名从服务器上的数据库中检索</em> <code class="fe mj mk ml mm b">rawId</code> <em class="lf">。</em></p><p id="5379" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">rpId</code>是依赖方的标识符。如果未提供，则默认为网站的域。</p><p id="8456" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">userVerification</code>表示是否需要用户交互来验证用户。因为我们希望使用指纹进行身份验证，所以该值应该为“true”。</p><p id="23cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当找到符合所有标准的凭证时，它将作为<code class="fe mj mk ml mm b">PublicKeyCredential</code>返回:</p><pre class="kp kq kr ks gt mn mm mo mp aw mq bi"><span id="7aba" class="mr lh it mm b gy ms mt l mu mv">PublicKeyCredential {<br/>  id: "AdvZkPu73G7...",<br/>  rawId: ArrayBuffer(103), <br/>  <!-- -->response: AuthenticatorAssertionResponse {<br/>    authenticatorData: ArrayBuffer(37),<br/>    clientDataJSON: ArrayBuffer(372), <br/>    signature: ArrayBuffer(72),<br/>    userHandle: ArrayBuffer(32)<br/>  },<br/>  type: "public-key"<br/>}</span></pre><p id="1d41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">id</code>是检索到的凭证的ID。</p><p id="4dc6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">rawId</code>是二进制形式的<code class="fe mj mk ml mm b">id</code>。</p><p id="9236" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">response</code>现在属于<code class="fe mj mk ml mm b">AuthenticatorAssertionResponse</code>类型。</p><p id="15de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">response</code>中的<code class="fe mj mk ml mm b">authenticatorData</code>与注册步骤中的<code class="fe mj mk ml mm b">attestationObject</code>相似，但不包含公钥。它用于身份验证过程中的验证。</p><p id="b4a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">response</code>中的<code class="fe mj mk ml mm b">clientDataJSON</code>是从浏览器传递到认证器的数据，用于将凭证与服务器和浏览器相关联。</p><p id="ef21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">signature</code>是由检索到的凭证的私钥生成的(惊奇)签名，将使用私钥来验证它是否有效。</p><p id="3c0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">userHandle</code>是在注册步骤中提供的<code class="fe mj mk ml mm b">user.id</code>的值，将用于将用户与凭证相关联。</p><p id="88f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">type</code>目前可能只持有值“公钥”。</p><p id="03e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在将以下中的凭据发送到服务器进行身份验证:</p><pre class="kp kq kr ks gt mn mm mo mp aw mq bi"><span id="5a20" class="mr lh it mm b gy ms mt l mu mv">const data = {<br/>  rawId: credential.rawId,<br/>  response: {<br/>    authenticatorData,<br/>    signature,<br/>    userHandle,<br/>    clientDataJSON,<br/>    id: credential.id,<br/>    type: credential.type<br/>  }<br/>};</span></pre><h1 id="66f6" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">服务器端代码</h1><p id="2cde" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">为了在服务器端验证凭证，我使用了<a class="ae le" href="https://github.com/webauthn-open-source/fido2-lib" rel="noopener ugc nofollow" target="_blank"> fido2-lib </a>库，这使得这个过程相当简单。</p><p id="1b0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是由于这个库包含一个bug，使我无法在演示中使用它，所以我分叉了repo并修复了这个bug。这个叉子在演示中使用，可以在<a class="ae le" href="https://github.com/DannyMoerkerke/fido2-lib" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="a271" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您对解析和验证认证数据的确切步骤感兴趣，您可以<a class="ae le" href="https://w3c.github.io/webauthn/" rel="noopener ugc nofollow" target="_blank">阅读规范</a>或阅读<a class="ae le" href="https://webauthn.guide" rel="noopener ugc nofollow" target="_blank"> webauthn.guide </a>上的精彩描述。</p><p id="34a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">服务器端代码包含执行注册和身份验证所需的四个路由。这些路线将按下列顺序依次调用。</p><p id="e7ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">/registration-options</code>返回传递给<code class="fe mj mk ml mm b">navigator.credentials.create()</code>的配置对象。这包含来自服务器的质询、用户id、关于依赖方的信息以及要创建的凭证的其他标准。</p><p id="402a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">/register</code>接收创建的凭证并验证它。如果通过验证，公钥将被存储。请注意，该演示将它存储在用户会话中。在实际场景中，用户名将存储在数据库中，以检索凭证的id，并在下一个路由中将其发送回去。</p><p id="3240" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">/authentication-options</code>返回传递给<code class="fe mj mk ml mm b">navigator.credentials.get()</code>的配置对象。它再次包含来自服务器的挑战。在演示中，在客户端添加了<code class="fe mj mk ml mm b">allowCredentials</code>，并从<code class="fe mj mk ml mm b">localStorage</code>中检索所需的<code class="fe mj mk ml mm b">rawId</code>凭证。<br/>在实际场景中，用户将提供用户名，然后使用该用户名从数据库中检索凭证的<code class="fe mj mk ml mm b">rawId</code>。在这种情况下，也可以在服务器端填充<code class="fe mj mk ml mm b">allowCredential</code>。</p><p id="7723" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">/authenticate</code>接收从客户端检索到的凭证并验证它。如果通过验证，则认证成功。</p><p id="190f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以在<a class="ae le" href="https://github.com/DannyMoerkerke/webauthn-demo" rel="noopener ugc nofollow" target="_blank"> Github </a>上查看演示和源代码，工作演示也是<a class="ae le" href="https://whatpwacando.today" rel="noopener ugc nofollow" target="_blank">PWA今天可以做的事情</a>的一部分。</p><h1 id="666c" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结论</h1><p id="de81" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">Web身份验证使web应用程序能够提供非常可靠和安全的身份验证机制。它消除了密码的使用，极大地提高了安全性，因为不再共享机密，网络钓鱼攻击变得无用。</p><p id="eca5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它让用户不必记忆密码，让网络应用程序不必存储和管理密码。用户可以使用他们的指纹或USB密钥方便地登录，使弱密码和重复使用的密码成为历史。</p><p id="935e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以<a class="ae le" href="https://twitter.com/dannymoerkerke" rel="noopener ugc nofollow" target="_blank">在Twitter </a>上关注我，我经常在那里写关于PWAs、网络组件和现代网络功能的文章。</p></div></div>    
</body>
</html>