<html>
<head>
<title>Single-line persistence definitions in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的单行持久性定义</h1>
<blockquote>原文：<a href="https://itnext.io/single-line-persistence-definitions-in-swift-31f32a1dd2aa?source=collection_archive---------1-----------------------#2018-10-02">https://itnext.io/single-line-persistence-definitions-in-swift-31f32a1dd2aa?source=collection_archive---------1-----------------------#2018-10-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4bce" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于如何减少用户默认/钥匙串访问代码，有很多想法。这里有一个我一直在使用的简单而优雅的解决方案。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e77c109e10e96edfc576daac609ba560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qrm6NliqLh2Fy5ZSCkm3eQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">下面是我们将要完成的任务(不要担心，定义不需要是静态的！)</figcaption></figure><p id="3746" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个好的键值存储解决方案应该具有以下特性:</p><ul class=""><li id="76c7" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">强类型访问</li><li id="0681" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">所有可能的钥匙都在一个地方</li><li id="ad11" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">开发人员不应该需要手动编写setters和getters。</li><li id="fbf6" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">商店的位置应该很容易改变(例如，你应该能够决定将一个值从<code class="fe mf mg mh mi b">UserDefaults</code>移动到钥匙链中，而不需要太多额外的努力)</li><li id="edf1" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">对存储的引用应该标记为只读</li></ul><p id="61fb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">借助泛型和<code class="fe mf mg mh mi b">ExpressibleByStringLiteral</code>的力量，我们可以创建一个解决方案，它不依赖于某处存在的带有键列表或手动访问器列表的枚举。</p><h2 id="5290" class="mj mk iq bd ml mm mn dn mo mp mq dp mr le ms mt mu li mv mw mx lm my mz na nb bi translated">所有键值存储的共同点</h2><p id="ad6e" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">所有键值存储解决方案都能够存储原语对象。让我们把这看作是未来实现的共同标准，所以我们所有存储的对象都应该能够把它们自己表示为原语。</p><pre class="kg kh ki kj gt nh mi ni nj aw nk bi"><span id="fdb4" class="mj mk iq mi b gy nl nm l nn no">protocol StoredObject {<br/>    associatedtype Primitive<br/>    func toPrimitive() -&gt; Primitive?<br/>    static func from(primitive: Primitive) -&gt; Self?<br/>}</span></pre><p id="564a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们想存储一个原语，我们可以很容易地遵循这个协议:</p><pre class="kg kh ki kj gt nh mi ni nj aw nk bi"><span id="d332" class="mj mk iq mi b gy nl nm l nn no">extension String: StoredObject {<br/>    <br/>    typealias Primitive = String<br/>    <br/>    func toPrimitive() -&gt; Primitive? {<br/>        return self<br/>    }<br/>    <br/>    static func from(primitive: Primitive) -&gt; Primitive? {<br/>        return primitive<br/>    }<br/>}</span></pre><p id="b6c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">实际上，你知道吗，我们不想重复<code class="fe mf mg mh mi b">Int</code>、<code class="fe mf mg mh mi b">Float</code>、<code class="fe mf mg mh mi b">Bool</code>等所有代码。让我们创建另一个协议来实现这两个简单的功能:</p><pre class="kg kh ki kj gt nh mi ni nj aw nk bi"><span id="6696" class="mj mk iq mi b gy nl nm l nn no">protocol StoredAsSelf: StoredObject where Primitive == Self { }<br/><br/>extension StoredAsSelf {<br/>    <br/>    func toPrimitive() -&gt; Primitive? {<br/>        return self<br/>    }<br/>    <br/>    static func from(primitive: Primitive) -&gt; Primitive? {<br/>        return primitive<br/>    }<br/>}</span></pre><p id="043d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以现在对于我们想要存储的基本类型，我们需要做的就是:</p><pre class="kg kh ki kj gt nh mi ni nj aw nk bi"><span id="8fd5" class="mj mk iq mi b gy nl nm l nn no">extension String: StoredAsSelf {<br/>    typealias Primitive = String<br/>}<br/><br/>extension Int: StoredAsSelf {<br/>    typealias Primitive = Int<br/>}<br/><br/>extension Float: StoredAsSelf {<br/>    typealias Primitive = Float<br/>}</span></pre><p id="5edd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">太好了！如果您想要存储一个非原语类型(例如一个<code class="fe mf mg mh mi b">Date</code>)，只需通过将其分解成一个原语来遵循协议:</p><pre class="kg kh ki kj gt nh mi ni nj aw nk bi"><span id="4d8a" class="mj mk iq mi b gy nl nm l nn no">extension Date: StoredObject {<br/><br/>    typealias Primitive = TimeInterval<br/><br/>    func toPrimitive() -&gt; Primitive? {<br/>        return timeIntervalSince1970<br/>    }<br/><br/>    static func from(primitive: Primitive) -&gt; Date? {<br/>        return Date(timeIntervalSince1970: primitive)<br/>    }<br/>}</span></pre><p id="0d44" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">很简单！</p><h2 id="c1cc" class="mj mk iq bd ml mm mn dn mo mp mq dp mr le ms mt mu li mv mw mx lm my mz na nb bi translated">通用存储包装</h2><p id="d6b8" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">对于我们想要使用的每个存储解决方案，我们应该制作一个强类型的包装器。我将使用<code class="fe mf mg mh mi b">UserDefaults</code>作为例子，但是您当然可以为任何第三方解决方案实现它。</p><p id="4c5e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mf mg mh mi b">ExpressibleByStringLiteral</code>允许我们用字符串实例化一个对象。这非常符合我们的需求，因为我们需要一个与我们的<code class="fe mf mg mh mi b">StoredObject</code>配对的键，并且我们可以使用泛型来推断<code class="fe mf mg mh mi b">StoredObject</code>的类型。但是如果你以前使用过<code class="fe mf mg mh mi b">ExpressibleByStringLiteral</code>，你会知道有三个初始化器需要实现:<code class="fe mf mg mh mi b">init(stringLiteral:)</code>、<code class="fe mf mg mh mi b">init(unicodeScalarLiteral:)</code>和<code class="fe mf mg mh mi b">init(extendedGraphemeClusterLiteral:)</code>。在我看来这是不必要的，所以(再次)让我们创建一个协议来悄悄地实现后两个:</p><pre class="kg kh ki kj gt nh mi ni nj aw nk bi"><span id="0717" class="mj mk iq mi b gy nl nm l nn no">protocol StringLiteralBoilerplate {<br/>    init(stringLiteral value: String)<br/>}<br/><br/>extension StringLiteralBoilerplate {<br/>    typealias StringLiteralType = String<br/><br/>    init(unicodeScalarLiteral value: String) {<br/>        self.init(stringLiteral: value)<br/>    }<br/><br/>    init(extendedGraphemeClusterLiteral value: String) {<br/>        self.init(stringLiteral: value)<br/>    }<br/>}</span></pre><p id="9985" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在剩下的就是创建我们的存储包装器了。它将有一个必须是<code class="fe mf mg mh mi b">StoredObject</code>的泛型类型，并且它将完成<code class="fe mf mg mh mi b">ExpressibleByStringLiteral</code>的实现:</p><pre class="kg kh ki kj gt nh mi ni nj aw nk bi"><span id="6e60" class="mj mk iq mi b gy nl nm l nn no">struct Storable&lt;Object&gt;: ExpressibleByStringLiteral, StringLiteralBoilerplate where Object: StoredObject {<br/><br/>    private let key: String<br/>    private let store = UserDefaults.standard</span><span id="1ae9" class="mj mk iq mi b gy np nm l nn no">    init(stringLiteral value: String) {<br/>        self.key = value<br/>    }<br/><br/>    var value: Object? {<br/>        set {<br/>            store.set(newValue?.toPrimitive(), forKey: key)<br/>        }<br/>        get {<br/>            guard let p = store.value(forKey: key) as? Object.Primitive else { return nil }<br/>            return Object.from(primitive: p)<br/>        }<br/>    }<br/>}</span></pre><p id="bfdf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">同样，你不需要在这里使用<code class="fe mf mg mh mi b">UserDefaults</code>——如果你也需要钥匙链存储，简单地创建另一个类似的结构<code class="fe mf mg mh mi b">KeychainStorable</code>,并适当地填充它！</p><h2 id="a970" class="mj mk iq bd ml mm mn dn mo mp mq dp mr le ms mt mu li mv mw mx lm my mz na nb bi translated">把所有的放在一起</h2><p id="8434" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">我已经在几个应用程序中设置了我的持久性定义，如下所示:</p><pre class="kg kh ki kj gt nh mi ni nj aw nk bi"><span id="3bce" class="mj mk iq mi b gy nl nm l nn no">struct Persistence {<br/>    <br/>    struct TabBar {<br/>        var infoiewDate: Storable&lt;Date&gt; = "t.viewDate.info"<br/>        var diaryViewDate: Storable&lt;Date&gt; = "t.viewDate.diary"<br/>        var messagesViewDate: Storable&lt;Date&gt; = "t.viewDate.mess"<br/>    }</span><span id="60f6" class="mj mk iq mi b gy np nm l nn no">    struct Utility {<br/>        var upgradeAlertIgnored: Storable&lt;Bool&gt; = "u.upgradeIgnored"<br/>        var token: KeychainStorable&lt;String&gt; = "u.token"<br/>        var graphData: RAMStorable&lt;[Graph.Body]&gt; = "u.graphData"<br/>    }</span><span id="ab13" class="mj mk iq mi b gy np nm l nn no">    ...<br/>}</span></pre><p id="d19f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，在需要读取存储数据的类中，实例化您需要的项目组:</p><pre class="kg kh ki kj gt nh mi ni nj aw nk bi"><span id="f1d4" class="mj mk iq mi b gy nl nm l nn no">private var persistence = Persistence.Utility()</span><span id="22ce" class="mj mk iq mi b gy np nm l nn no">...</span><span id="8d26" class="mj mk iq mi b gy np nm l nn no">persistence.upgradeAlertIgnored.value = true <em class="nq">// set/get using .value</em></span></pre><p id="c622" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，在定义组时使用<code class="fe mf mg mh mi b">struct</code>的一个好的副作用是，如果在上面的例子中使用<code class="fe mf mg mh mi b">let</code>，那么你的持久性引用将是只读的！当然，如果有一天你决定将一个特定的值存储在Keychain中，而不是存储在<code class="fe mf mg mh mi b">UserDefaults</code>中，你可以简单地改变存储结构的名称。</p><p id="b77a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，由于对存储的访问实际上是单例式的，所以在编写单元测试时不会有任何问题——只需创建持久性组的另一个实例，并根据需要断言值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/f6a5aa9a2e7e092860eef1e862de38d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*agHOaM5DKsiIq67zIs9eEw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">过去几个月我一直在东京工作！我添加这张照片是因为a)我喜欢它，b) Medium不让我选择第一张图片作为特色图片，除非有第二张😉</figcaption></figure></div></div>    
</body>
</html>