<html>
<head>
<title>Evolving your RESTful APIs, a step-by-step approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">进化RESTful APIs，一步一步的方法</h1>
<blockquote>原文：<a href="https://itnext.io/evolving-apis-9cb69ea47754?source=collection_archive---------7-----------------------#2022-02-27">https://itnext.io/evolving-apis-9cb69ea47754?source=collection_archive---------7-----------------------#2022-02-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8a3586b7b704bd5242af8809847e2605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h_IBEjDJX1YSoFmKKzWNXQ.jpeg"/></div></div></figure><p id="ce1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">设计一个直观、用户友好的RESTful API是一项艰巨的工作。如果这是你的第一次尝试，它可能已经是一项艰巨的任务了。规划API的生命周期管理可能是事后的想法。但无论如何这都是可能的:在这篇文章中，我想提出一个简单的方法来改进你的API，即使它不是计划中的。</p><h1 id="e435" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">最初的情况</h1><p id="f85b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们考虑一个在使用时会说“Hello”的示例应用程序。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="7a1e" class="mi kx iq me b gy mj mk l ml mm">&gt; curl http://org. apisix/hello<br/>Hello world</span><span id="9d8b" class="mi kx iq me b gy mn mk l ml mm">&gt; curl http://org. apisix/hello/Joe<br/>Hello Joe</span></pre><p id="ee48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">底层技术不重要；我们将关注API部分。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/b12eb1471e94e949c33e6606054ac390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b_UY4HdvxaudkMxFUb9QNQ.png"/></div></div></figure><h1 id="b81b" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">使用API网关</h1><p id="1160" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">第一步也是最关键的一步是停止将应用程序直接暴露给互联网，并在它们之间建立一个API网关。如果你不熟悉API网关的概念，你可以把它想象成一个增强的反向代理。维基百科提供了以下定义:</p><blockquote class="mp mq mr"><p id="609f" class="jy jz ms ka b kb kc kd ke kf kg kh ki mt kk kl km mu ko kp kq mv ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">网关</em> </strong> <em class="iq">:充当API前端的服务器，接收API请求，实施节流和安全策略，将请求传递给后端服务，然后将响应传回给请求者。网关通常包括一个转换引擎，用于动态地编排和修改请求和响应。网关还可以提供收集分析数据和提供缓存等功能。网关可以提供支持认证、授权、安全、审计和法规遵从性的功能。</em></p><p id="8c98" class="jy jz ms ka b kb kc kd ke kf kg kh ki mt kk kl km mu ko kp kq mv ks kt ku kv ij bi translated"><em class="iq"> — </em> <a class="ae mw" href="https://en.%20wikipedia.%20org/wiki/API_management" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> API管理</em> </a></p></blockquote><p id="d77b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我将使用<a class="ae mw" href="https://apisix.%20apache.%20org/" rel="noopener ugc nofollow" target="_blank"> Apache APISIX </a>,但是您可以随意使用您最熟悉的一个。</p><p id="32b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">公开网关而不是应用程序要求您更新DNS记录以指向网关而不是应用程序，并等待它在全球范围内传播。这可能需要一些时间。为了跟踪传播，您可以使用类似<a class="ae mw" href="https://dnschecker.%20org/" rel="noopener ugc nofollow" target="_blank"> dnschecker </a>的网站。</p><p id="8c1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，您首先需要将HTTP请求从网关路由到您的应用程序。<br/>使用APISIX，您可以通过向网关发送HTTP请求来创建一个<em class="ms">路由</em>。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="6788" class="mi kx iq me b gy mj mk l ml mm">curl http://apisix:9080/apisix/admin/routes/1 -H 'X-API-KEY: xyz' -X PUT -d ' # 1-2<br/>{<br/>  "name": "Direct Route to Old API",               # 3<br/>  "methods": ["GET"],                              # 4<br/>  "uris": ["/hello", "/hello/", "/hello/*"],       # 5<br/>  "upstream": {                                    # 6<br/>    "type": "roundrobin",                          # 8<br/>    "nodes": {<br/>      "oldapi:8081": 1                             # 7<br/>    }<br/>  }<br/>}'</span></pre><ol class=""><li id="7003" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv nc nd ne nf bi translated">APISIX可以分配一个自动生成的ID或使用提供的ID。在本例中，我们选择后者，在URL — <code class="fe ng nh ni me b">1</code>中传递它，并使用<code class="fe ng nh ni me b">PUT</code>动词</li><li id="4ac2" class="mx my iq ka b kb nj kf nk kj nl kn nm kr nn kv nc nd ne nf bi translated">为了更新路由，我们需要传递API键</li><li id="222c" class="mx my iq ka b kb nj kf nk kj nl kn nm kr nn kv nc nd ne nf bi translated">命名路由不是必需的，但是它可以让我们更好地理解它的作用</li><li id="7486" class="mx my iq ka b kb nj kf nk kj nl kn nm kr nn kv nc nd ne nf bi translated">要路由的HTTP方法的数组</li><li id="e72b" class="mx my iq ka b kb nj kf nk kj nl kn nm kr nn kv nc nd ne nf bi translated">要路由的URL数组</li><li id="6ba5" class="mx my iq ka b kb nj kf nk kj nl kn nm kr nn kv nc nd ne nf bi translated">上游是后端应用程序。在我们的例子中，它是Hello World API。</li><li id="ac46" class="mx my iq ka b kb nj kf nk kj nl kn nm kr nn kv nc nd ne nf bi translated">节点及其各自权重的散列表。权重只有在有多个节点时才有意义，但在这个简单的场景中并非如此。</li><li id="1d6d" class="mx my iq ka b kb nj kf nk kj nl kn nm kr nn kv nc nd ne nf bi translated">配置多个节点时使用的平衡算法</li></ol><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/da5c714583c3e5ff30c73902e218b2e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YbiNasG1KtLF2ndC24Y0qw.png"/></div></div></figure><p id="6c21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一阶段，您可以查询网关并获得与之前相同的结果:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="b05c" class="mi kx iq me b gy mj mk l ml mm">&gt; curl http://org. apisix/hello<br/>Hello world</span><span id="8b1b" class="mi kx iq me b gy mn mk l ml mm">&gt; curl http://org. apisix/hello/Joe<br/>Hello Joe</span></pre><h1 id="cdc9" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">API版本</h1><p id="9aba" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">发展一个API意味着多个版本的API在某个时候需要共存。版本1的API有三个选项:</p><ul class=""><li id="4737" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv np nd ne nf bi translated">查询参数:</li></ul><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="c43d" class="mi kx iq me b gy mj mk l ml mm">curl <a class="ae mw" href="http://org." rel="noopener ugc nofollow" target="_blank">http://org.</a> apisix/hello?version=1<br/>curl <a class="ae mw" href="http://org." rel="noopener ugc nofollow" target="_blank">http://org.</a> apisix/hello?version=2</span></pre><ul class=""><li id="6675" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv np nd ne nf bi translated">标题:</li></ul><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="c65a" class="mi kx iq me b gy mj mk l ml mm">curl -H 'Version: 1' <a class="ae mw" href="http://org." rel="noopener ugc nofollow" target="_blank">http://org.</a> apisix/hello<br/>curl -H 'Version: 2' <a class="ae mw" href="http://org." rel="noopener ugc nofollow" target="_blank">http://org.</a> apisix/hello</span></pre><ul class=""><li id="a33c" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv np nd ne nf bi translated">路径:</li></ul><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="811c" class="mi kx iq me b gy mj mk l ml mm">curl <a class="ae mw" href="http://org." rel="noopener ugc nofollow" target="_blank">http://org.</a> apisix/v1/hello<br/>curl <a class="ae mw" href="http://org." rel="noopener ugc nofollow" target="_blank">http://org.</a> apisix/v2/hello</span></pre><p id="c96c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很多文章都写了什么是最佳选择。在本文的范围内，我们将使用基于路径的版本控制，因为它是最普遍的。如果您想使用其他选项，APISIX支持它们。</p><p id="2192" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上一节中，我们创建了一个<em class="ms">路由</em>，它包装了一个<em class="ms">上游</em>。APISIX允许我们创建一个带有专用ID的上游，以便在几个路由之间重用它。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="e377" class="mi kx iq me b gy mj mk l ml mm">curl http://apisix:9080/apisix/admin/upstreams/1 -H 'X-API-KEY: xyz' -X PUT -d ' # 1<br/>{<br/>  "name": "Old API",                                                             # 2<br/>  "type": "roundrobin",<br/>  "nodes": {<br/>    "oldapi:8081": 1<br/>  }<br/>}'</span></pre><ol class=""><li id="33de" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv nc nd ne nf bi translated">使用<code class="fe ng nh ni me b">upstreams</code>路径</li><li id="1602" class="mx my iq ka b kb nj kf nk kj nl kn nm kr nn kv nc nd ne nf bi translated">新上游的有效负载</li></ol><p id="6f1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在将查询转发到上游之前，我们还需要重写到达网关的查询。后者知道<code class="fe ng nh ni me b">/hello</code>，不知道<code class="fe ng nh ni me b">/v1/hello</code>。APISIX允许这样的转换、过滤等。，通过插件。让我们创建一个插件配置来重写路径:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="9a71" class="mi kx iq me b gy mj mk l ml mm">curl http://apisix:9080/apisix/admin/plugin_configs/1 -H 'X-API-KEY: xyz' -X PUT -d ' # 1<br/>{<br/>  "plugins": {<br/>    "proxy-rewrite": {                                        # 2<br/>      "regex_uri": ["/v1/(.*)", "/$1"]                        # 3<br/>    }<br/>  }<br/>}'</span></pre><ol class=""><li id="dbd7" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv nc nd ne nf bi translated">使用<code class="fe ng nh ni me b">plugin-configs</code>路径</li><li id="413a" class="mx my iq ka b kb nj kf nk kj nl kn nm kr nn kv nc nd ne nf bi translated">使用<a class="ae mw" href="https://apisix.%20apache.%20org/docs/apisix/plugins/proxy-rewrite/" rel="noopener ugc nofollow" target="_blank">代理重写</a>插件</li><li id="2350" class="mx my iq ka b kb nj kf nk kj nl kn nm kr nn kv nc nd ne nf bi translated">删除版本前缀</li></ol><p id="8108" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以创建引用新创建的上游和插件配置的版本化路由:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="ea90" class="mi kx iq me b gy mj mk l ml mm">curl http://apisix:9080/apisix/admin/routes/2 -H 'X-API-KEY: xyz' -X PUT -d '  # 1<br/>{<br/>  "name": "Versioned Route to Old API",<br/>  "methods": ["GET"],<br/>  "uris": ["/v1/hello", "/v1/hello/", "/v1/hello/*"],<br/>  "upstream_id": 1,<br/>  "plugin_config_id": 1<br/>}'</span></pre><ol class=""><li id="05f6" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv nc nd ne nf bi translated">看，马，一条新路线！</li></ol><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/d4bb727e0c8c0ac4a4515f3892075196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CHg4OXT-_Wo4gXN__xImLw.png"/></div></div></figure><p id="fba0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在此阶段，我们已经配置了两条路由，一条是版本化的，另一条是非版本化的:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="76e3" class="mi kx iq me b gy mj mk l ml mm">&gt; curl http://org. apisix/hello<br/>Hello world</span><span id="bfea" class="mi kx iq me b gy mn mk l ml mm">&gt; curl http://org. apisix/v1/hello<br/>Hello world</span></pre><h1 id="b72b" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">将用户从非版本化路径迁移到版本化路径</h1><p id="8642" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们已经对我们的API进行了版本化，但是我们的用户可能仍然使用遗留的非版本化的API。我们希望它们迁移，但是我们不能因为用户不知道就删除遗留路由。幸运的是，301 HTTP状态代码是我们的朋友:我们可以让用户知道资源已经从\ <a class="ae mw" href="http://org" rel="noopener ugc nofollow" target="_blank"> http://org </a>转移了。API six/hello to \<a class="ae mw" href="http://org" rel="noopener ugc nofollow" target="_blank">http://org</a>。apisix/v1/hello。需要在初始路由上配置<a class="ae mw" href="https://apisix.%20apache.%20org/docs/apisix/plugins/redirect/" rel="noopener ugc nofollow" target="_blank">重定向</a>插件；</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="5623" class="mi kx iq me b gy mj mk l ml mm">curl http://apisix:9080/apisix/admin/routes/1 -H 'X-API-KEY: xyz' -X PATCH -d '<br/>{<br/>  "plugins": {<br/>    "redirect": {<br/>      "uri": "/v1$uri",<br/>      "ret_code": 301<br/>    }<br/>  }<br/>}'</span></pre><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/71db5003ba5019af445014c307d1db8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o_dlplVMQvYrQ3CPenieVw.png"/></div></div></figure><p id="4e94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果很有趣:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="01d5" class="mi kx iq me b gy mj mk l ml mm">&gt;curl http://apisix. org/hello</span><span id="e730" class="mi kx iq me b gy mn mk l ml mm">&lt;html&gt;<br/>&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;<br/>&lt;hr&gt;&lt;center&gt;openresty&lt;/center&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span><span id="8fa4" class="mi kx iq me b gy mn mk l ml mm">&gt;curl -L apisix:9080/hello                     # 1<br/>Hello world</span></pre><ol class=""><li id="feee" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv nc nd ne nf bi translated"><code class="fe ng nh ni me b">-L</code>选项跟随重定向</li></ol><p id="4bff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要么用户将透明地使用新的端点，因为他们将跟随，要么他们的集成中断，他们将注意到301状态和要使用的新API位置。</p><h1 id="23f9" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">了解你的用户</h1><p id="a69d" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">您可能已经注意到，到目前为止，我们还不知道谁在使用我们的API。当我们必须引入一个变化时，我们必须有创造性，不破坏用户的使用。其他变化可能不那么容易应付。因此，我们应该努力了解我们的用户，以便在必要时联系他们。</p><p id="1581" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">老实说吧。大多数开发者，包括我自己，如果可以避免的话，都不喜欢注册和给出联系方式。我想这是营销团队的错，他们不理解我们的心态——不要打电话给我，我会打电话给你。然而，在这种特殊情况下，这将是有益的。</p><p id="fd5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“核”选项完全不允许用户在系统注册之前调用我们的API。我更喜欢另一种选择:限制未注册用户在一段时间内可以拨打的电话数量。如果他们达到了限制，我们将返回著名的429 HTTP状态和邀请他们注册的消息。</p><p id="4f0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在撰写本文时，还没有现成的插件可以做到这一点。但是有可能写出我们自己的。APISIX位于Lua引擎之上，所有提供的插件都是用Lua编写的。或者，可以用Go、Python、WebAssembly或任何基于JVM的语言编写插件。</p><p id="b1f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了简单起见，我写了一个Lua插件。由于这篇文章的目标不是理解Lua，我就不深入探讨了。如果你对代码感兴趣，可以在<a class="ae mw" href="https://github.%20com/nfrankel/evolve-apis/blob/master/unauth-limit-plugin/src/unauth-limit.%20lua" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。当公众准备好了，我们还有几个步骤要完成:</p><ol class=""><li id="40ad" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv nc nd ne nf bi translated">配置APISIX以使用目录:</li></ol><p id="4dfb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ng nh ni me b">apisix: extra_lua_path: "/opt/apisix/?.lua"</code></p><p id="2ffe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">APISIX可以使用位于<code class="fe ng nh ni me b">/opt/apisix/</code>文件夹中的任何Lua脚本</p><p id="8385" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.加载插件:</p><p id="1aff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">APISIX可以自己热重装。我们不需要重启它，也不需要停机来添加额外的插件！</p><p id="95a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ng nh ni me b">curl http://apisix:9080/apisix/admin/plugins/reload -H 'X-API-KEY: xyz' -X PUT</code></p><p id="07fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.修补现有插件配置:</p><p id="ca4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们需要配置插件本身。由于我们创建了一个专用的插件配置，我们只需用新的配置更新它:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="2310" class="mi kx iq me b gy mj mk l ml mm">curl http://apisix:9080/apisix/admin/plugin_configs/1 -H 'X-API-KEY: xyz' -X PATCH -d '<br/>{<br/>  "plugins": {<br/>    "proxy-rewrite": {                                # 1<br/>      "regex_uri": ["/v1/(.*)", "/$1"]<br/>    },<br/>    "unauth-limit": {                                 # 2<br/>      "count": 1,                                     # 3<br/>      "time_window": 60,                              # 3<br/>      "key_type": "var",                              # 4<br/>      "key": "consumer_name",                         # 4<br/>      "rejected_code": 429,<br/>      "rejected_msg": "Please register at https://apisix. org/register to get your API token and enjoy unlimited calls"<br/>    }<br/>  }<br/>}'</span></pre><ol class=""><li id="798a" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv nc nd ne nf bi translated">不幸的是，我们需要重复现有的插件配置。APISIX团队正在解决这个问题，所以你可以在不知道现有插件的情况下在配置中添加一个插件。</li><li id="2c2c" class="mx my iq ka b kb nj kf nk kj nl kn nm kr nn kv nc nd ne nf bi translated">我们的插件！</li><li id="9492" class="mx my iq ka b kb nj kf nk kj nl kn nm kr nn kv nc nd ne nf bi translated">如果用户通过了身份验证，插件会限制用户每60秒只能打一次电话。否则，它不限制任何东西。</li><li id="13a7" class="mx my iq ka b kb nj kf nk kj nl kn nm kr nn kv nc nd ne nf bi translated">在下一节中解释</li></ol><p id="381d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以检查它是否如预期的那样运行:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="f2fe" class="mi kx iq me b gy mj mk l ml mm">&gt;curl apisix:9080/v1/hello<br/>Hello world</span><span id="094d" class="mi kx iq me b gy mn mk l ml mm">&gt;curl apisix:9080/v1/hello<br/>{"error_msg":"Please register at https:\/\/apisix. org\/register to get your API token and enjoy unlimited calls"}</span></pre><p id="87f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">的确如此。</p><h1 id="7ef9" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">创建用户</h1><p id="0c67" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">您可能会开始看到您的用户访问注册页面，这取决于您对未授权使用的限制程度。注册有许多方面；它可以是:</p><ul class=""><li id="6eb9" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv np nd ne nf bi translated">自动化或需要尽可能多的手动验证步骤</li><li id="37f2" class="mx my iq ka b kb nj kf nk kj nl kn nm kr nn kv np nd ne nf bi translated">免费还是付费</li><li id="b7a1" class="mx my iq ka b kb nj kf nk kj nl kn nm kr nn kv np nd ne nf bi translated">简单到询问一封无需进一步验证的电子邮件，或者复杂到需要更多数据</li><li id="31a7" class="mx my iq ka b kb nj kf nk kj nl kn nm kr nn kv np nd ne nf bi translated">等等。</li></ul><p id="4dd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这要看你的具体语境。</p><p id="5e0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于APISIX，最终，它转化为一个新的<em class="ms">消费者</em>。要创建这样的消费者，我们需要配置一个指定身份验证的插件。一些身份验证插件是现成可用的:basic、API key、JWT、OpenId、LDAP、Keycloak等。</p><p id="2989" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章的范围内，<a class="ae mw" href="https://apisix.%20apache.%20org/docs/apisix/plugins/key-auth" rel="noopener ugc nofollow" target="_blank"> key-auth插件</a>已经足够了。让我们配置一个由API密钥验证的消费者对象:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="cd1e" class="mi kx iq me b gy mj mk l ml mm">curl http://apisix:9080/apisix/admin/consumers -H 'X-API-KEY: xyz' -X PUT -d '<br/>{<br/>  "username": "johndoe",                 # 1<br/>  "plugins": {<br/>    "key-auth": {                        # 2<br/>      "key": "mykey"                     # 3<br/>    }<br/>  }<br/>}'</span></pre><ol class=""><li id="fabf" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv nc nd ne nf bi translated">消费者的ID</li><li id="c242" class="mx my iq ka b kb nj kf nk kj nl kn nm kr nn kv nc nd ne nf bi translated">要使用的插件</li><li id="1589" class="mx my iq ka b kb nj kf nk kj nl kn nm kr nn kv nc nd ne nf bi translated">有效令牌是<code class="fe ng nh ni me b">mykey</code></li></ol><p id="1ac4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意默认的头是<code class="fe ng nh ni me b">apikey</code>。有可能配置另一个:请检查密钥认证插件<a class="ae mw" href="https://apisix.%20apache.%20org/docs/apisix/plugins/key-auth#attributes" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="0d86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以测试我们的设置，并验证它是否符合我们的要求:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="8761" class="mi kx iq me b gy mj mk l ml mm">&gt;curl -H 'apikey: mykey' apisix:9080/v1/hello<br/>Hello world</span><span id="c3d4" class="mi kx iq me b gy mn mk l ml mm">&gt;curl -H 'apikey: mykey' apisix:9080/v1/hello<br/>Hello world</span></pre><h1 id="b101" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">生产中的测试</h1><p id="24e7" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在这个阶段，我们现在准备让用户了解我们的Hello world API的改进版本。我假设我们的团队已经彻底测试过了，但是新代码总是有风险的。部署现有应用程序的一个充满bug的新版本会对API提供商的形象(和收入)产生负面影响！).</p><p id="8657" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了将风险降至最低，一个公认的策略是放飞金丝雀:</p><blockquote class="mp mq mr"><p id="e5d4" class="jy jz ms ka b kb kc kd ke kf kg kh ki mt kk kl km mu ko kp kq mv ks kt ku kv ij bi translated"><em class="iq"> Canary release是一种降低在生产中引入新软件版本的风险的技术，它通过在将变更推广到整个基础架构并提供给所有人之前，缓慢地将变更推广到一小部分用户。</em></p><p id="7e60" class="jy jz ms ka b kb kc kd ke kf kg kh ki mt kk kl km mu ko kp kq mv ks kt ku kv ij bi translated"><em class="iq">—</em><a class="ae mw" href="https://martinfowler.%20com/bliki/CanaryRelease.%20html" rel="noopener ugc nofollow" target="_blank"><em class="iq">canary release</em></a></p></blockquote><p id="9d22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果某个东西失败了，它只会影响一小部分用户群，我们将能够在没有太大影响的情况下恢复更改。然而，通过API网关，我们可以在canary发布之前引入一个步骤:我们将生产流量复制到新的API端点。尽管网关会丢弃响应，但我们可以发现额外的错误，而对用户没有任何影响。</p><p id="7885" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">APISIX提供了<a class="ae mw" href="https://apisix.%20apache.%20org/docs/apisix/plugins/proxy-mirror" rel="noopener ugc nofollow" target="_blank">代理镜像</a>插件来复制到其他节点的生产流量。让我们更新我们的插件配置:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="f5f1" class="mi kx iq me b gy mj mk l ml mm">curl http://apisix:9080/apisix/admin/plugin_configs/1 -H 'X-API-KEY: xyz' -X PATCH -d '<br/>{<br/> "plugins": {<br/>    "proxy-rewrite": {<br/>      "regex_uri": ["/v1/(.*)", "/$1"]<br/>    },<br/>    "unauth-limit": {<br/>      "count": 1,<br/>      "time_window": 60,<br/>      "key_type": "var",<br/>      "key": "consumer_name",<br/>      "rejected_code": 429,<br/>      "rejected_msg": "Please register at https://apisix. org/register to get your API token and enjoy unlimited calls"<br/>    },<br/>    "proxy-mirror": {<br/>      "host": "http://new. api:8082"                             # 1<br/>    }<br/>  }<br/>}'</span></pre><ol class=""><li id="1b6e" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv nc nd ne nf bi translated">APISIX也会向该主机发送流量</li></ol><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/f8e4abd146ac692c0823bd8a927c41c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xCD9nMP__Sp-IJZCtMh9Zw.png"/></div></div></figure><p id="2a24" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以监控新的和旧的端点，以确保前者不会比后者发生更多的错误。如果没有，我们可以修复错误并重新部署，直到它的情况。我们现在准备释放金丝雀。</p><p id="88ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们创建一个指向新API的上游:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="4cb5" class="mi kx iq me b gy mj mk l ml mm">curl http://apisix:9080/apisix/admin/upstreams/2 -H 'X-API-KEY: xyz' -X PUT -d '<br/>{<br/>  "name": "New API",<br/>  "type": "roundrobin",<br/>  "nodes": {<br/>    "newapi:8082": 1<br/>  }<br/>}'</span></pre><p id="da7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们可以用<a class="ae mw" href="https://apisix.%20apache.%20org/docs/apisix/plugins/traffic-split/" rel="noopener ugc nofollow" target="_blank">流量分流</a>替换<code class="fe ng nh ni me b">proxy-mirror</code>插件:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="afb2" class="mi kx iq me b gy mj mk l ml mm">curl http://apisix:9080/apisix/admin/plugin_configs/1 -H 'X-API-KEY: xyz' -X PATCH -d '<br/>{<br/> "plugins": {<br/>    "proxy-rewrite": {<br/>      "regex_uri": ["/v1/(.*)", "/$1"]<br/>    },<br/>    "unauth-limit": {<br/>      "count": 1,<br/>      "time_window": 60,<br/>      "key_type": "var",<br/>      "key": "consumer_name",<br/>      "rejected_code": 429,<br/>      "rejected_msg": "Please register at https://apisix. org/register to get your API token and enjoy unlimited calls"<br/>    },<br/>    "traffic-split": {<br/>      "rules": [<br/>        {<br/>          "weighted_upstreams": [      # 1<br/>            {<br/>              "upstream_id": 2,<br/>              "weight": 1<br/>            },<br/>            {<br/>              "weight": 1<br/>            }<br/>          ]<br/>        }<br/>      ]<br/>    }<br/>  }<br/>}'</span></pre><ol class=""><li id="72a4" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv nc nd ne nf bi translated">出于演示目的，将50%的流量发送到新的API。在现实生活中，您可能会从更低的起点开始，甚至只为新端点配置内部用户。</li></ol><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="5502" class="mi kx iq me b gy mj mk l ml mm">curl -L -H 'apikey: mykey' apisix:9080/hello<br/>Hello world</span><span id="f72d" class="mi kx iq me b gy mn mk l ml mm">curl -L -H 'apikey: mykey' apisix:9080/hello<br/>Hello world (souped-up version!)</span></pre><p id="bced" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果一切正常，我们可以逐渐增加发送到新API的流量百分比，直到达到100%。我们现在可以移除流量分割，并从默认端点重定向到v2，而不是v1。</p><h1 id="f23c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">反对旧版本</h1><p id="4190" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">大多数用户可能会迁移到新版本以从中受益，但他们中的一小部分人会留在v1上。有各种各样的原因:没有合适的时间(提示:从来都不是)，太贵，没有足够的动力去迁移，等等。但是作为API提供者，每个部署的版本都有一定的成本。您可能需要在某个时候淘汰v1。</p><p id="25c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">REST不是一个标准，但是IETF有一个关于它的草案规范。有关更多详细信息，请阅读<a class="ae mw" href="https://tools.%20ietf.%20org/id/draft-dalal-deprecation-header-03.%20html" rel="noopener ugc nofollow" target="_blank">弃用HTTP头字段</a>。顾名思义，它基于特定的HTTP响应头。</p><p id="d1cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在API网关的帮助下，我们可以配置路由来传达其未来的废弃和替换。为此，APISIX提供了<a class="ae mw" href="https://apisix.%20apache.%20org/docs/apisix/plugins/response-rewrite/" rel="noopener ugc nofollow" target="_blank">响应-重写</a>。虽然它可以重写响应的任何部分，但我们将使用它来添加额外的deprecation头:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="c835" class="mi kx iq me b gy mj mk l ml mm">curl -v http://apisix:9080/apisix/admin/plugin_configs/1 -H 'X-API-KEY: xyz' -X PATCH -d '<br/>{<br/> "plugins": {<br/>    "proxy-rewrite": {<br/>      "regex_uri": ["/v1/(.*)", "/$1"]<br/>    },<br/>    "unauth-limit": {<br/>      "count": 1,<br/>      "time_window": 60,<br/>      "key_type": "var",<br/>      "key": "consumer_name",<br/>      "rejected_code": 429,<br/>      "rejected_msg": "Please register at https://apisix. org/register to get your API token and enjoy unlimited calls"<br/>    },<br/>    "response-rewrite": {<br/>      "headers": {<br/>        "Deprecation": "true",<br/>        "Link": "&lt;$scheme://apisix:$server_port/v2/hello&gt;; rel=\"successor-version\""<br/>      }<br/>    }<br/>  }<br/>}'</span><span id="854b" class="mi kx iq me b gy mn mk l ml mm">curl -v -H 'apikey: mykey' apisix:9080/v1/hello</span><span id="98b7" class="mi kx iq me b gy mn mk l ml mm">&lt; HTTP/1. 1 200 <br/>&lt; Content-Type: text/plain;charset=UTF-8<br/>&lt; Content-Length: 11<br/>&lt; Connection: keep-alive<br/>&lt; Date: Fri, 18 Feb 2022 16:33:30 GMT<br/>&lt; Server: APISIX/2. 12. 0<br/>&lt; Link: &lt;http://apisix:9080/v2/hello&gt;; rel="successor-version"<br/>&lt; Deprecation: true<br/>&lt; <br/>Hello world</span></pre><h1 id="22f8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="22a1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在这篇文章中，我们描述了一个简单的逐步过程来管理你的API的生命周期:</p><ol class=""><li id="bb4f" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv nc nd ne nf bi translated">不要直接公开你的APIs在前端设置一个API网关</li><li id="c2e4" class="mx my iq ka b kb nj kf nk kj nl kn nm kr nn kv nc nd ne nf bi translated">使用路径、查询参数或请求头对现有API进行版本化</li><li id="840a" class="mx my iq ka b kb nj kf nk kj nl kn nm kr nn kv nc nd ne nf bi translated">将用户从未版本化的端点迁移到状态代码为301的版本化端点</li><li id="b720" class="mx my iq ka b kb nj kf nk kj nl kn nm kr nn kv nc nd ne nf bi translated">轻轻地推动你的用户注册</li><li id="bbd7" class="mx my iq ka b kb nj kf nk kj nl kn nm kr nn kv nc nd ne nf bi translated">在生产中测试，首先通过复制流量，然后将一小部分用户转移到新版本</li><li id="b6ba" class="mx my iq ka b kb nj kf nk kj nl kn nm kr nn kv nc nd ne nf bi translated">正式发布新版本</li><li id="1de6" class="mx my iq ka b kb nj kf nk kj nl kn nm kr nn kv nc nd ne nf bi translated">通过标准响应头传达对旧版本的反对意见</li></ol><p id="d4e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更进一步:</strong></p><ul class=""><li id="9e27" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv np nd ne nf bi translated"><a class="ae mw" href="https://apisix.%20apache.%20org/" rel="noopener ugc nofollow" target="_blank">阿帕奇APISIX </a></li></ul></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="3242" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ms">原载于</em> <a class="ae mw" href="https://blog.frankel.ch/evolve-apis/" rel="noopener ugc nofollow" target="_blank"> <em class="ms">一个Java极客</em></a><em class="ms">2022年2月27日</em></p></div></div>    
</body>
</html>