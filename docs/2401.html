<html>
<head>
<title>Different ways to achieve encapsulation in JavaScript(ES6)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript(ES6)中实现封装的不同方法</h1>
<blockquote>原文：<a href="https://itnext.io/different-ways-to-achieve-encapsulation-in-javascript-es6-7cb938e83f2d?source=collection_archive---------1-----------------------#2019-05-18">https://itnext.io/different-ways-to-achieve-encapsulation-in-javascript-es6-7cb938e83f2d?source=collection_archive---------1-----------------------#2019-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ff1be2dedfe80aa5c6561da1da1fc492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XQ-Jm8pc0HAsF_hJw0eFhA.jpeg"/></div></div></figure><p id="54fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">JavaScript是一种强大的语言，充满了不同的范例，可以让您编写有趣而灵活的代码。然而，与此同时，它缺少其他语言所具有的一些基本结构特征。到目前为止，JavaScript最大的异常之一是它不能本地支持封装。</p><p id="943b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">范围系统是由TypeScript引入的，TypeScript是JavaScript的超集。但不幸的是，这还不是一个明显的胜利，因为，虽然它给你一个警告，TypeScript代码仍然编译和运行，即使当你访问私有变量。</p><p id="3afb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，人们想出了使用语言的其他特性来实现封装的方法。在这篇文章中，我将讨论最广泛使用的方法。</p><h1 id="2f08" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">休闲小站</h1><p id="3375" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">实现伪封装最简单的方法是在私有成员前加上一个特殊的符号，向客户端指示私有范围。使用<code class="fe mc md me mf b">_</code>符号作为前缀是一种常见的惯例。当然，这实际上不会阻止任何人访问你的私有变量，所以我们在这里不做过多的描述。</p><h1 id="9eb8" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">工厂功能和关闭</h1><p id="f343" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">简单地说，工厂函数是用来创建对象的新实例的函数。工厂函数通常是使用<code class="fe mc md me mf b">new</code>关键字直接创建对象的首选。原因是因为使用工厂函数给了你自由和灵活性来改变对象的实例化过程，而不需要客户知道这种改变。</p><p id="f87a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与<a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" rel="noopener ugc nofollow" target="_blank">闭包</a>一起使用的工厂函数通常是实现封装的首选方法，因为它很简单。让我们来看看这个例子:</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="ad95" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的代码是通过工厂函数和闭包实现封装的典型例子。虽然实现非常简单，但它确实带来了内存使用损失。原因是，对于<code class="fe mc md me mf b">Hedgehog</code>函数的每个新实例，都将重新创建方法<code class="fe mc md me mf b">zoom</code>。下面是一个使用ES6语法的相同实现:</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="f0fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如你所见，为了让<code class="fe mc md me mf b">zoom</code>方法访问<code class="fe mc md me mf b">speed</code>和<code class="fe mc md me mf b">name</code>，我们必须把它放在构造函数中。在某些情况下，这种惩罚是可以接受的，你可以使用它。同样，为了减少过热，你可以定义不在构造函数之外使用私有变量的方法，就像我们对<code class="fe mc md me mf b">jump</code>方法所做的那样。</p><h1 id="796a" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">弱映射和名称空间</h1><p id="4cab" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">通过使用<code class="fe mc md me mf b"><a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" rel="noopener ugc nofollow" target="_blank">WeakMap</a></code>对象存储私有成员，可以避免使用工厂函数和闭包带来的内存损失。因为一个<code class="fe mc md me mf b">WeakMap</code>可以用来存储该类的多个实例的私有成员，所以避免了代价。让我们看看这个例子，以便更好地理解这个概念:</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="f2be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">事情是这样的:</p><ul class=""><li id="9c54" class="mn mo it kd b ke kf ki kj km mp kq mq ku mr ky ms mt mu mv bi translated">我们将<code class="fe mc md me mf b">Hedgehog</code>类包装在自调用函数中并返回它。通过这种方式，我们可以确保我们的私有数据只被创建一次，并且我们的类对于客户端来说是即时可用的。</li><li id="b61e" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky ms mt mu mv bi translated">在自调用函数内，但在<code class="fe mc md me mf b">Hedgehog</code>类之外，我们存储我们的<code class="fe mc md me mf b">WeakMap</code>。这个映射用于存储每个<code class="fe mc md me mf b">Hedgehog</code>类实例的私有变量。地图中的每个值都是一个对象，我们称之为<code class="fe mc md me mf b">namespace</code>。本质上，<code class="fe mc md me mf b">namespace</code>是一个私有对象，具有键-值对，只对持有对它的引用的<code class="fe mc md me mf b">Hedgehog</code>类的特定实例可用。</li><li id="de35" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky ms mt mu mv bi translated">如前所述，由于我们只为<code class="fe mc md me mf b">Hedgehog</code>类的多个实例存储一个映射，过热大大减少了。</li></ul><p id="4d11" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们选择<code class="fe mc md me mf b">WeakMap</code>进行存储，而不是使用常规的<code class="fe mc md me mf b">Map</code>或普通的JavaScript对象，这是有原因的:</p><ul class=""><li id="f962" class="mn mo it kd b ke kf ki kj km mp kq mq ku mr ky ms mt mu mv bi translated">弱映射允许您使用JavaScript对象作为键。其他种类的字典集合只允许您使用原语。</li><li id="fdf4" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky ms mt mu mv bi translated">因为<code class="fe mc md me mf b">WeakMap</code>持有对其项目的弱引用，所以避免了内存泄漏。这允许这些项在丢失所有其他引用时被垃圾回收。</li><li id="d7a7" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky ms mt mu mv bi translated">弱映射保证对象只能使用<code class="fe mc md me mf b">get</code>方法访问。<code class="fe mc md me mf b">WeakMap</code>没有任何其他访问其项目的方法(<em class="nb">循环，</em> <code class="fe mc md me mf b"><em class="nb">Object.keys()</em></code> <em class="nb">等</em>)。</li></ul><h1 id="3fa2" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用符号(某种封装)</h1><p id="1f79" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">最后一种方法是使用新的ES6特性——符号。符号是一种保证唯一的原语。它的主要用途之一是用作字典集合的关键字。</p><p id="9ed9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里的技巧是使用闭包来定义私有符号。让我们看看这个例子:</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="039e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用这个方法，<code class="fe mc md me mf b">Hedgehog</code>类的每个实例都有自己的<code class="fe mc md me mf b">this[speed]</code>变量实例，由于在顶部定义了<code class="fe mc md me mf b">speed</code>符号，这个变量仍然可以被类中的其他方法访问。当使用点符号和迭代对象集合或使用<code class="fe mc md me mf b">Object.keys()</code>时，符号是不可访问的。所以它确实提供了某种程度的封装。</p><p id="1514" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然在大多数情况下，符号确实提供了足够的封装级别，但是仍然可以使用<code class="fe mc md me mf b">Object.getOwnPropertySymbols</code>来破解。虽然，大多数时候客户端应该得到提示，不会试图使用那些私有属性。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="9fd5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是这篇文章的全部内容。希望您学到了一些用JavaScript实现封装的新方法。感谢阅读！</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="9ab4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nb">原载于2019年5月18日</em><a class="ae mg" href="https://isamatov.com/encapsulation-in-javascript-es6/" rel="noopener ugc nofollow" target="_blank"><em class="nb">https://isamatov.com</em></a><em class="nb">。</em></p></div></div>    
</body>
</html>