<html>
<head>
<title>How I learned to Stop Worrying and Love Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我是如何学会不再担心并爱上Docker的</h1>
<blockquote>原文：<a href="https://itnext.io/how-i-learned-to-stop-worrying-and-love-docker-ff4b268ed5b0?source=collection_archive---------5-----------------------#2020-01-09">https://itnext.io/how-i-learned-to-stop-worrying-and-love-docker-ff4b268ed5b0?source=collection_archive---------5-----------------------#2020-01-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="2e9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你已经做到了。您成功构建了您的后端！这是你告诉自己忘记你是如何<em class="ko">建造</em>这个该死的东西，把注意力放在UI上的部分。</p><p id="88cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实上，在构建过程中，认为<em class="ko">理所当然</em>的心态就是我们如何得到<em class="ko">眼泪</em>。在这种情况下，很容易忘记您的包管理器已经过时，忘记您曾经通过NVM切换到Node 9.x，或者忘记您现在在一台完全不同的机器上。</p><p id="c3ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在处理共享项目时，您可能会问自己一些问题:</p><ul class=""><li id="1ea5" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">在本地工作时，我如何避免担心再次复制生产构建环境？</li><li id="9190" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">我能在共享代码之前隔离并解决我的构建问题吗？</li><li id="4a5a" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">我如何确保与我一起工作的其他人在拉/叉时处于相同的环境中？</li></ul><p id="4077" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些可能是你头脑中的一些疑惑，但是像Docker这样的工具可以帮你抽象出大部分。Docker为我们提供了一个值得信赖的、独立的构建过程，这样您就可以放心地测试和共享代码。</p><p id="ab41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到本系列结束时，我们应该能够创建一个数据库，生成一个模式，播种DB，初始化我们的服务器，并运行PGAdmin通过一个Docker命令连接所有这些，而不用担心当其他人必须处理它时会发生什么。</p><p id="b863" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">听起来很不错，那么我需要知道些什么？</strong></p><p id="42dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你要做的第一件事是<a class="ae ld" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank">安装docker </a>。根据您使用的操作系统，您的说明可能会有所不同。完成后，在您的终端中键入:</p><p id="4a20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe le lf lg lh b">docker version</code></p><p id="27be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您应该会看到类似这样的内容:</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi li"><img src="../Images/1037bea25bfd90df238e7235b25595c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/0*XLc20klwInLZvjIl.png"/></div></figure><p id="8417" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Docker本身是一个广泛的主题，因此为了简洁和本系列的范围，我们将把事情浓缩为:<a class="ae ld" href="https://docs.docker.com/engine/reference/commandline/images/" rel="noopener ugc nofollow" target="_blank">图像</a>、<a class="ae ld" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank">docker文件</a>和<a class="ae ld" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> docker-compose </a>。</p><p id="aa31" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了对Docker有一个更高层次的概述，这里有一篇杰夫·黑尔的优秀文章。</p><h1 id="c41e" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">那么图像到底是什么呢？</h1><p id="7298" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated"><strong class="js iu">简而言之，映像是一个文件，它的唯一目的是承载程序运行的依赖和配置。</strong></p><p id="cb0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">理解图像<em class="ko">是</em>的最简单方法是在你的终端上输入:<code class="fe le lf lg lh b">docker run hello-world</code>。</p><p id="7079" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果一切顺利，你应该得到一个看起来像胡言乱语的提要。然而，它们是关于我们如何在这个提示中与<strong class="js iu">图像</strong>交互的一些说明。</p><pre class="lj lk ll lm gt mt lh mu mv aw mw bi"><span id="efba" class="mx lr it lh b gy my mz l na nb">1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the "hello-world" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.</span></pre><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/1833d92c0d58950246ce578fd7b99b0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/0*ledRYAZu0LRLrVWV.gif"/></div></figure><p id="db2a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">是的</em> …什么是守护进程？</p><p id="59e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据维基的说法:</p><blockquote class="nd ne nf"><p id="0d6e" class="jq jr ko js b jt ju jv jw jx jy jz ka ng kc kd ke nh kg kh ki ni kk kl km kn im bi translated"><em class="it">守护程序是类Unix操作系统上的一种程序，它在后台运行，而不是在用户的直接控制下，等待特定事件或条件的发生而被激活。</em></p></blockquote><p id="4312" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">迷人，太好了。</p><p id="13c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以在按回车键和提示符之间的某个地方，这个Docker守护进程正在为我们做所有的脏工作，当它完成时，它返回一个<code class="fe le lf lg lh b">hello-world</code>。</p><p id="a3c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你运行<code class="fe le lf lg lh b">docker ps -a</code>，你应该会得到类似这样的东西</p><pre class="lj lk ll lm gt mt lh mu mv aw mw bi"><span id="99e4" class="mx lr it lh b gy my mz l na nb">| CONTAINER ID | IMAGE | COMMAND | CREATED | STATUS | PORTS | NAMES | | ------------ | :---------: | :------: | :------------: | :-----------------------: | :---: | ------- | | a0adf8a9dbe5 | hello-world | "/hello" | 23 minutes ago | Exited ( 0 ) 23 minutes ago | | example |</span></pre><p id="0f9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">现在</strong>我们知道我们有这个<code class="fe le lf lg lh b">hello-world</code>图像，在我们的电脑里，我们从这个<a class="ae ld" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> <em class="ko"> DockerHub </em> </a>地方把它拉出来，听起来有点像GitHub，但是是为了图像。此图像的唯一目的是打印<em class="ko">“来自码头工人的你好”</em>。几乎所有的节点都有图像，postgres，ubuntu，如果它是一个环境，那么很可能有一个图像。</p><p id="1d28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可能已经注意到，在我们的<em class="ko">“码头工人您好”</em>之前，我们收到了一条信息:</p><pre class="lj lk ll lm gt mt lh mu mv aw mw bi"><span id="8f3c" class="mx lr it lh b gy my mz l na nb">Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world 1b930d010525: Pull complete</span></pre><p id="71bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Docker足够聪明，可以在从DockerHub中提取图片之前检查任何现有的图片，这非常漂亮。</p><p id="0678" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，现在我们知道了什么是<strong class="js iu">映像</strong>以及Docker如何获取这些<em class="ko">依赖关系</em>和<em class="ko">配置</em>供我们的程序运行。下一个要真正理解的概念是<a class="ae ld" href="https://www.docker.com/resources/what-container" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">容器</strong> </a>。不必深究容器和进程之间的关系(这里有一篇Jessica Grebenschikov<a class="ae ld" href="https://medium.com/@jessgreb01" rel="noopener">的文章</a>可以提供一些线索)，容器本质上是运行我们代码的图像的一个实例。</p><p id="5a08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是一个有趣的小图表，展示了容器在我们的应用程序中是如何运行的:</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/256ec6eaf2673ac4524b7fe173d4e3f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*JTaMjEmNqV3VzwfY.png"/></div></figure><p id="91f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很好，现在我们知道了这种关系，但是我们应该如何着手<strong class="js iu">构建</strong>这些容器呢？说到构建容器，Docker给了我们一个强大的工具来帮助我们，这个工具叫做<a class="ae ld" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> Dockerfiles </strong> </a>。</p><h1 id="c959" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">docker文件只是一组指令</h1><p id="cb98" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">直接来自文件:</p><blockquote class="nd ne nf"><p id="a92b" class="jq jr ko js b jt ju jv jw jx jy jz ka ng kc kd ke nh kg kh ki ni kk kl km kn im bi translated"><em class="it">docker file是一个文本文档，它包含用户可以在命令行上调用的所有命令来组合一个图像。使用docker build，用户可以创建一个连续执行几个命令行指令的自动化构建。</em></p></blockquote><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/34fb8e9cd6d1c976d6b5be0a1f4f0097.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*WIcgng6kODsqaDZO.gif"/></div></figure><p id="a97d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从为<a class="ae ld" href="https://sailsjs.com/" rel="noopener ugc nofollow" target="_blank"> Sails </a> API容器编写自己的指令集开始。在您的终端中:</p><pre class="lj lk ll lm gt mt lh mu mv aw mw bi"><span id="c28b" class="mx lr it lh b gy my mz l na nb">mkdir docker-example cd docker-example touch Dockerfile</span></pre><p id="31d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的Docker文件中，让我们告诉Docker为了成功地构建一个Sails应用程序它需要知道什么:</p><pre class="lj lk ll lm gt mt lh mu mv aw mw bi"><span id="c3ae" class="mx lr it lh b gy my mz l na nb">FROM node:alpine <br/>RUN apk add - -no-cache git <br/>RUN mkdir usr/src/ <br/>RUN cd /usr/src &amp;&amp; git clone https://github.com/nelson-lopez/sails-example <br/>WORKDIR /usr/src/sails-example <br/>RUN npm install CMD [ "node", "app.js" ]</span></pre><p id="6ee5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以继续运行我们的构建了:</p><p id="83e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe le lf lg lh b">docker build -t sails .</code></p><p id="2ac4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们这里说的就是:docker，在这个<strong class="js iu"> <em class="ko">目录</em> </strong> ( <strong class="js iu">的上下文中，用标签(<strong class="js iu"> -t </strong> ) <strong class="js iu"> <em class="ko">风帆</em> </strong>构建一个新的容器。</strong>)。</p><p id="3919" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在Docker将检查我们当前的目录，并看到有一个现有的<strong class="js iu"> Dockerfile </strong>并运行该构建，将其命名为<strong class="js iu"> sails </strong>。</p><p id="6526" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事情正在发生。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/81cacffd83eda7c6499ae1e85b726650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*h_VHultaEdw-7939.png"/></div></figure><p id="0e60" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们一步一步地看看我们的构建发生了什么:</p><p id="2871" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe le lf lg lh b">FROM node:alpine</code>这里我们告诉Docker为我们的程序运行拉一个瘦节点<strong class="js iu">映像</strong>。注意，<code class="fe le lf lg lh b">FROM</code>给了Docker<em class="ko">图像</em>的上下文。</p><p id="6103" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe le lf lg lh b">RUN apk add --no-cache git</code> <strong class="js iu"> <em class="ko">节点:阿尔卑斯山</em> </strong>没有安装<em class="ko"> git </em>所以Docker现在看到了这个命令并为我们安装了<strong class="js iu"> git </strong>。</p><p id="0cc3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:从github repo构建可以是非传统的，但是对于这个例子，我想展示Docker是多么的多才多艺。</p><p id="0700" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe le lf lg lh b">RUN mkdir usr/src/</code>这里没有什么太花哨的，我们只是为我们的源代码做一个文件夹。</p><p id="ab73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe le lf lg lh b">RUN cd /usr/src &amp;&amp; git clone https://github.com/nelson-lopez/sails-example</code>现在我们已经有了一个包含<strong class="js iu">节点</strong>和<strong class="js iu"> git </strong>的环境，我们可以继续进行回购了。但是首先我们必须进入源目录。</p><p id="cdd4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe le lf lg lh b">WORKDIR /usr/src/sails-example</code>我们的src目录现在有了一个<em class="ko">sails-示例</em>文件夹，来自我们提取的repo。为了将容器的上下文设置到那个文件夹，我们现在必须给它一个<code class="fe le lf lg lh b">WORKDIR</code>。在这种情况下，它的'/usr/src/sails-example '。</p><p id="1382" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe le lf lg lh b">RUN npm install</code>我们安装我们的帆依赖。</p><p id="026b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们指定<code class="fe le lf lg lh b">node app.js</code>作为运行容器时要执行的命令。</p><p id="4bdf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太好了，现在我们要做的就是运行这该死的东西。我们首先使用<code class="fe le lf lg lh b">run</code>命令，然后使用<code class="fe le lf lg lh b">-p</code>标志将一个端口映射到我们的容器。在我们的终端中，让我们运行<code class="fe le lf lg lh b">docker run -p 3001:1337</code>将端口<strong class="js iu"> 3001 </strong>映射到我们的容器，如果一切按计划进行，我们应该看到以下内容:</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/11e4e7587340c7765420de9f601eb86d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*iAmoHxGsn-XmHBr8.png"/></div></figure><p id="c69e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们在浏览器中转到<code class="fe le lf lg lh b">localhost:3001</code>，我们可以看到Sails正在运行。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/2ca67e3be72c10661d9016dfc6171ba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*0KUVEbC3lrPCZMoW.png"/></div></figure><p id="69b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您已经有了一个在本地运行的Sails应用程序，只需两个命令和不到15行代码，无需CLI！这只是你能用Docker做的事情的皮毛。拥有一个容器固然很好，但是当你将多个容器组合在一起制作一个多面应用时，Docker才真正大放异彩。</p><p id="9b28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本系列的下一部分，我们将讨论<strong class="js iu"> docker-compose </strong>如何将一切编织在一起。只需订阅下面的通知时，它被释放。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="136a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">最初发布于</em><a class="ae ld" href="https://speakerbox.now.sh/docker/" rel="noopener ugc nofollow" target="_blank"><em class="ko">https://speaker box . now . sh</em></a><em class="ko">。</em></p></div></div>    
</body>
</html>