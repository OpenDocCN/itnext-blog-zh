<html>
<head>
<title>webpack: From 0 to automated testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">webpack:从0到自动化测试</h1>
<blockquote>原文：<a href="https://itnext.io/webpack-from-0-to-automated-testing-4634844d5c3c?source=collection_archive---------0-----------------------#2018-12-26">https://itnext.io/webpack-from-0-to-automated-testing-4634844d5c3c?source=collection_archive---------0-----------------------#2018-12-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/37df6123dcbd36bc10a15ce3d8dfc8ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*prPXC1wJpFbp-vLdKykXrg.png"/></div></div></figure><div class=""/><p id="714e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">自1995年问世以来，JavaScript在语言和生态系统方面都发生了巨大的变化。现在，这种语言正被用来在前端和后端制作更大的工具和web应用程序，对于这些大型JavaScript项目，人们会导入大量不同的第三方代码。这些依赖可以是方便的JS功能库(如Lodash)、React、Angular或Vue等框架、自动化测试代码(如Mocha或Jest ),甚至是添加到JavaScript语言本身的代码(如Flow ),用于为JS提供C++或Go等语言中的静态类型。</p><p id="002c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于所有这些复杂性，HTML用一堆<code class="fe kw kx ky kz b">&lt;script&gt; </code>标签导入所有JavaScript变得很麻烦而且容易出错，比如:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="4cb5" class="li lj jb kz b gy lk ll l lm ln">&lt;script src="path/to/lodash.js"&gt;&lt;/script&gt;<br/>&lt;script src="path/to/my-helper-functions.js"&gt;&lt;script&gt;<br/>&lt;script&gt;<br/>  // This code can now use functions from lodash.js and<br/>  // my-helper-functions.js<br/>&lt;/script&gt;</span></pre><p id="c911" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您只有两个脚本要导入时，这可能很容易管理，但是二十个或数百个脚本呢？构建一个由数百个<code class="fe kw kx ky kz b">&lt;script&gt;</code>标签组成的堆栈并以正确的顺序导入它们需要大量的思考，而且随着依赖列表的增长和变化，维护起来会很头疼。</p><p id="6840" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是，管理依赖关系之间错综复杂的关系网是机器人最擅长的思维方式。因此，对于制作大型专业web应用程序来说，自动化构建过程是必不可少的，而webpack是处理这一问题的一个非常流行的工具。它为您的JavaScript、CSS等构建了一个依赖图，输出单个文件的<strong class="ka jc">包</strong>代码，因此您可以用一个<code class="fe kw kx ky kz b">&lt;script&gt;</code>标签导入您需要的所有JavaScript！</p><p id="25d2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本教程中，我们将为一个小型web应用程序构建一个webpack，然后我们将看到如何使用webpack来设置自动化测试。</p><h1 id="4967" class="lo lj jb bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">制作应用程序</h1><p id="a6ba" class="pw-post-body-paragraph jy jz jb ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">对于这个示例应用程序，我们将为树懒绘制一张地图，以找到剑桥出售木槿茶的当地商店。因为剑桥淡水池塘的每一只树懒都知道芙蓉茶是最好的慢下来的茶！</p><figure class="la lb lc ld gt is gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/96238154b79760340d685ca080d3c4a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*QfFbyUSFRy-qAwnLfgA47g.jpeg"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">注意:现实生活中没有生活在淡水池上的树懒，但是树懒在爬树一整天后确实喜欢美味的芙蓉花！</figcaption></figure><p id="5eef" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，创建一个名为<code class="fe kw kx ky kz b">webpack-mocha-tutorial</code>的目录，在其中创建一个<code class="fe kw kx ky kz b">app/src</code>目录，并运行<code class="fe kw kx ky kz b">npm init</code>或<code class="fe kw kx ky kz b">yarn init</code>。应用程序的代码在这里是<a class="ae mv" href="https://github.com/andyhaskell/webpack-mocha-tutorial" rel="noopener ugc nofollow" target="_blank">这里是</a>，存储库的<a class="ae mv" href="https://github.com/andyhaskell/webpack-mocha-tutorial/commits/master" rel="noopener ugc nofollow" target="_blank">提交历史</a>是按照教程编写的，所以我将链接到每个提交以跟踪代码更改，除了提交1，它只是设置了repo。</p><p id="0050" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该应用程序的基本结构如下所示:</p><ul class=""><li id="8fde" class="mw mx jb ka b kb kc kf kg kj my kn mz kr na kv nb nc nd ne bi translated">你有一个文件<code class="fe kw kx ky kz b">app/src/distance.js</code>，它导出一个运行距离公式的函数(实际上我们应该使用地理坐标的大圆距离公式)，以及一个告诉我们一系列点中哪个点离你最近的函数</li></ul><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="1878" class="li lj jb kz b gy lk ll l lm ln">// distance takes in two points, represented as objects with<br/>// numeric x and y values and returns the distance between them<br/>//<br/>// [TODO] Use great-circle distance, not 2D distance, which we're<br/>// only using to keep the code in this tutorial short<br/>function distance(p2, p1) {<br/>  let yDist = p2.y - p1.y;<br/>  let xDist = p2.x - p1.x;<br/>  return Math.sqrt(Math.pow(yDist, 2) + Math.pow(xDist, 2));<br/>}</span><span id="9d1b" class="li lj jb kz b gy nf ll l lm ln">// sortByDistance takes in your location and an array of points<br/>// and returns the array of points sorted<br/>function sortByDistance(myPt, points) {<br/>  return points.sort(<br/>    (pt1, pt2) =&gt; distance(pt1, myPt) - distance(pt2, myPt));<br/>}</span></pre><ul class=""><li id="59b2" class="mw mx jb ka b kb kc kf kg kj my kn mz kr na kv nb nc nd ne bi translated">您有一个名为<code class="fe kw kx ky kz b">app/src/page.js</code>的文件，它使用<code class="fe kw kx ky kz b">distance.js</code>中的代码从列表中获取最近的商店，然后在页面上显示出来</li></ul><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="597d" class="li lj jb kz b gy lk ll l lm ln">let stores = [<br/>  {name: "Cambridge Naturals",     x: -71.1189, y: 42.3895},<br/>  {name: "Sarah's Market",         x: -71.1311, y: 42.3823},<br/>  {name: "Whole Foods Fresh Pond", x: -71.1420, y: 42.3904},<br/>];</span><span id="9e47" class="li lj jb kz b gy nf ll l lm ln">let here = {name: "You are here",  x: -71.1470, y: 42.3834};<br/>let nearest = sortByDistance(here, stores)[0];<br/>document.getElementById("nearest-store").innerHTML = nearest.name;</span></pre><ul class=""><li id="543d" class="mw mx jb ka b kb kc kf kg kj my kn mz kr na kv nb nc nd ne bi translated">最后，你有了你的HTML网页，<code class="fe kw kx ky kz b">index.html</code>。</li></ul><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="f7fa" class="li lj jb kz b gy lk ll l lm ln">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Closest store with hibiscus tea&lt;/title&gt;<br/>  &lt;/head&gt;</span><span id="e1bd" class="li lj jb kz b gy nf ll l lm ln">  &lt;body&gt;<br/>    &lt;p&gt;Nearest store is &lt;span id="nearest-store"&gt;&lt;/span&gt;&lt;/p&gt;<br/>    &lt;script src="app/src/distance.js"&gt;&lt;/script&gt;<br/>    &lt;script src="app/src/page.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;<br/></span></pre><p id="55cb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总体目录结构是:</p><figure class="la lb lc ld gt is gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/d5d5e656487a739c38bfb55b1ed2af0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*1pxZtM7yrL8hf-OgX8s4LQ.jpeg"/></div></figure><p id="db13" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你在浏览器中打开index.html，你会看到离新鲜池塘最近的地方是扶轮社附近的全食超市。</p><figure class="la lb lc ld gt is gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/78e1f8233f15cf16a6a6647e95704ea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*s_Krco4Y2LqidZ5i364dNA.png"/></div></figure><p id="889c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，<code class="fe kw kx ky kz b">distance.js</code>定义了我们的距离函数，然后<code class="fe kw kx ky kz b">page.js</code>使用它们运行，将sortByDistance函数的结果放入DOM。但是如果你看看你的文件之间的依赖关系，你的<code class="fe kw kx ky kz b">page.js</code>文件依赖于你的<code class="fe kw kx ky kz b">distance.js</code>文件，而不是相反(<a class="ae mv" href="https://github.com/andyhaskell/webpack-mocha-tutorial/commit/13a7f43fb1a0f92445bcd67d99a5586e3c8adcb0" rel="noopener ugc nofollow" target="_blank">提交2 </a>)。</p><p id="5c7c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，您就有了一个设置，在依赖图的基础上，您基本上有一个JavaScript文件page.js。所以，如果你能让index.html导入一个带有一个<code class="fe kw kx ky kz b">&lt;script&gt;</code>标签的JavaScript文件，那就太好了。使用webpack，您可以做到这一点！</p><h1 id="0efc" class="lo lj jb bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">输入webpack</h1><p id="ea36" class="pw-post-body-paragraph jy jz jb ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">正如我在开始时提到的，<a class="ae mv" href="https://webpack.js.org" rel="noopener ugc nofollow" target="_blank"> webpack </a>是一个工具，它可以让你获取你的web应用程序所需的所有代码，并将其转换成一个生产就绪包。要得到它，使用npm或yarn来安装它:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="edf8" class="li lj jb kz b gy lk ll l lm ln">yarn add --dev webpack webpack-cli</span></pre><p id="f775" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这个命令，现在您的<code class="fe kw kx ky kz b">node_modules</code>中就有了webpack及其命令行工具，并且可以用<code class="fe kw kx ky kz b">webpack</code>命令行工具运行它。但是在运行这个webpack构建之前，我们需要让我们的page.js文件实际导入distance.js中的代码。因此，我们让distance.js通过添加以下行来导出它的函数:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="8c14" class="li lj jb kz b gy lk ll l lm ln">module.exports = {distance, sortByDistance};</span></pre><p id="702c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了让page.js使用导出的<code class="fe kw kx ky kz b">sortByDistance</code>函数，我们添加了一行代码:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="3df5" class="li lj jb kz b gy lk ll l lm ln">import {sortByDistance} from "./distance";</span></pre><p id="1083" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">酷，我们已经连接了我们的JavaScript依赖项。现在让我们使用webpack来构建我们的应用程序！运行以下命令:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="9911" class="li lj jb kz b gy lk ll l lm ln">npx webpack app/src/page.js</span></pre><p id="e168" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在你应该会看到一个新的文件，<code class="fe kw kx ky kz b">dist/main.js</code>，它包含了你在page.js和distance.js中的所有代码。现在让<code class="fe kw kx ky kz b">index.html</code>导入<code class="fe kw kx ky kz b">dist/main.js</code>而不是在<code class="fe kw kx ky kz b">app/src</code>中导入你的脚本，如下所示:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="0a51" class="li lj jb kz b gy lk ll l lm ln">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Closest store with hibiscus tea&lt;/title&gt;<br/>  &lt;/head&gt;</span><span id="716f" class="li lj jb kz b gy nf ll l lm ln">  &lt;body&gt;<br/>    &lt;p&gt;Nearest store is &lt;span id="nearest-store"&gt;&lt;/span&gt;&lt;/p&gt;<br/>    <strong class="kz jc">&lt;script src="dist/main.js"&gt;&lt;/script&gt;</strong><br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="cfd0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在在你的浏览器中打开这个文件，你应该仍然有工作的代码。这个main.js文件包含distance.js和page.js中的所有代码，因此您可以从一个文件导入所有内容！</p><p id="015e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其工作方式是，使用命令<code class="fe kw kx ky kz b">npx webpack app/src/page.js</code>，您指定JavaScript代码的起点，或者用webpack术语来说，<strong class="ka jc">入口点</strong>是page.js。因此webpack读取page.js，并在该文件中看到行<code class="fe kw kx ky kz b">import {sortByDistance} from ./distance</code>。现在它知道page.js有distance.js作为依赖项。根据代码中的所有依赖关系，webpack构建了一个<strong class="ka jc">依赖图</strong>，并使用它来构造您的<strong class="ka jc">捆绑包</strong> JavaScript文件<code class="fe kw kx ky kz b">dist/main.js</code>。(<a class="ae mv" href="https://github.com/andyhaskell/webpack-mocha-tutorial/commit/551d1392d46df44dd10f759bfe268c9dfb5cd49e" rel="noopener ugc nofollow" target="_blank">提交3 </a>)</p><figure class="la lb lc ld gt is gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/c6d2641edbf59f1a5617fc70b36f8463.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*_dFIIMtJ47q3m7Ch4-Z5mA.jpeg"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">webpack从我们的入口点page.js构建依赖图</figcaption></figure><p id="c7fe" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便说一下，这也适用于让您的代码在您的<code class="fe kw kx ky kz b">node_modules</code>中导入第三方依赖项。让我们尝试用jQuery而不是<code class="fe kw kx ky kz b">document.getElementById</code>来进行DOM操作。首先安装jQuery:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="4143" class="li lj jb kz b gy lk ll l lm ln">yarn add --dev jquery</span></pre><p id="f80a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后更新page.js以包含和使用jQuery:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="a155" class="li lj jb kz b gy lk ll l lm ln">import {sortByDistance} from "./distance";<br/><strong class="kz jc">import $ from "jQuery";</strong></span><span id="a4e9" class="li lj jb kz b gy nf ll l lm ln">let stores = [<br/>  {name: "Cambridge Naturals",     x: -71.1189, y: 42.3895},<br/>  {name: "Sarah's Market",         x: -71.1311, y: 42.3823},<br/>  {name: "Whole Foods Fresh Pond", x: -71.1420, y: 42.3904},<br/>];</span><span id="cc4c" class="li lj jb kz b gy nf ll l lm ln">let here = {name: "You are here",  x: -71.1470, y: 42.3834};<br/>let nearest = sortByDistance(here, stores)[0];<br/><strong class="kz jc">$("#nearest-store").html(nearest.name);</strong></span></pre><p id="3d6d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在你的依赖图是:</p><figure class="la lb lc ld gt is gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/cb8bd37adfdbbe300628c43a5926fce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*PSwNQkZaR1JJjg9nfy2oeQ.jpeg"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">page.js导入jQuery的新依赖图</figcaption></figure><p id="00f9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你做了<code class="fe kw kx ky kz b">npx webpack app/src/page.js</code>并重新加载index.html，尽管你的dist/main.js文件因为包含jQuery代码而变得更大，你的web应用程序仍然可以工作！</p><p id="4a72" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们继续之前，进入您的package.json文件并添加这三行:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="7518" class="li lj jb kz b gy lk ll l lm ln">"scripts": {<br/>  "build": "webpack app/src/page.js"<br/>}</span></pre><p id="3bde" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果你正在运行你的webpack构建，你只需要输入<code class="fe kw kx ky kz b">yarn build</code>就可以了，而不需要记住<code class="fe kw kx ky kz b">npx webpack app/src/page.js</code>。除了更容易键入之外，如果您的构建命令发生变化，您可以使用新的构建命令更新package.json文件中的那一行，然后您仍然可以使用<code class="fe kw kx ky kz b">yarn build</code>来构建应用程序，而不是让您和您的工程团队习惯于运行新的命令。(<a class="ae mv" href="https://github.com/andyhaskell/webpack-mocha-tutorial/commit/76df5a1fcf71cdae2cec55714b019d8e2530382a" rel="noopener ugc nofollow" target="_blank">提交4 </a>)</p><h1 id="15f8" class="lo lj jb bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">使用webpack.config.js文件配置webpack</h1><p id="1967" class="pw-post-body-paragraph jy jz jb ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">您看到的命令<code class="fe kw kx ky kz b">npx webpack app/src/page.js</code>是webpack的默认行为。如果您运行<code class="fe kw kx ky kz b">webpack [entry-file.js]</code>，那么webpack从该条目文件构建一个依赖图，并在<code class="fe kw kx ky kz b">dist/main.js</code>中输出一个包文件。但是如果用配置文件配置webpack，您可以控制入口点和输出点的位置。将这段代码放到webpack-mocha-tutorial目录下的一个名为<code class="fe kw kx ky kz b">webpack.config.js</code>的文件中:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="f3d4" class="li lj jb kz b gy lk ll l lm ln">module.exports = {<br/>  entry: __dirname + "/app/src/page.js",<br/>  output: {<br/>    path: __dirname + "/dist/",<br/>  }<br/>}</span></pre><p id="e78b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在如果你运行<code class="fe kw kx ky kz b">npx webpack</code>或者你可以像以前一样做同样的构建，不要在命令行参数中指定你的入口点，因为它现在在<code class="fe kw kx ky kz b">webpack.config.js</code>中！这也意味着您可以更新您的<code class="fe kw kx ky kz b">package.json</code>文件的构建脚本:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="ca48" class="li lj jb kz b gy lk ll l lm ln">"build": "webpack",</span></pre><p id="9bd4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您要将webpack配置文件中的输出路径更改为类似于<code class="fe kw kx ky kz b">__dirname + "/somewhere_else"</code>的路径，那么再次运行<code class="fe kw kx ky kz b">yarn build</code>命令会将捆绑文件放入<code class="fe kw kx ky kz b">somewhere_else/main.js</code>中。(<a class="ae mv" href="https://github.com/andyhaskell/webpack-mocha-tutorial/commit/c0f145d430d333f78865241d3846661a5fe30abe" rel="noopener ugc nofollow" target="_blank">提交5 </a>)</p><p id="566f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是webpack配置文件不仅仅是用来设置输入和输出文件的位置。您还可以通过使用<strong class="ka jc">加载器</strong>来设置webpack <em class="nk">在依赖图中遇到不同类型的文件时做什么，加载器基本上是以某种方式转换您的代码的JavaScript程序。例如，您可以在webpack配置文件中设置一条规则，规定如果webpack在其依赖关系图中遇到一个TypeScript文件，则该文件将通过一个加载程序发送，该加载程序会将其从TypeScript转换为常规JavaScript。</em></p><p id="5b8b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们要用的装载机是巴别塔装载机。如果你以前没有用过，<a class="ae mv" href="https://babeljs.io" rel="noopener ugc nofollow" target="_blank"> Babel </a>是一个工具，它获取使用现代特性的JS代码，并将其转换为向后兼容的等价代码。这使得您的应用程序可以在较旧的浏览器上工作，或者更一般地说，可以在尚不支持一些新的JavaScript特性的浏览器上工作。毕竟，一些使用我们应用的树懒自2009年以来就没有更新过他们的浏览器。我们编写的部分代码无法在2009版浏览器上运行:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="bac4" class="li lj jb kz b gy lk ll l lm ln">return points.sort((pt1, pt2) =&gt;<br/>  distance(pt1, myPt) — distance(pt2, myPt));</span></pre><p id="fe2f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们用的是箭头函数，那些还没有被发明出来。所以让我们用babel-loader把这个箭头函数送过去吧！首次运行:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="3974" class="li lj jb kz b gy lk ll l lm ln">yarn add --dev babel-core babel-loader@7.1.5 babel-preset-env</span></pre><p id="a201" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在webpack.config.js中，将这段代码添加到<code class="fe kw kx ky kz b">module.exports</code>对象中:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="75fb" class="li lj jb kz b gy lk ll l lm ln">module: {<br/>  rules: [<br/>    {<br/>      test: /\.js$/,<br/>      exclude: ["/node_modules/"],<br/>      use: [<br/>        {<br/>          loader: "babel-loader",<br/>          options: {<br/>            presets: ["env"],<br/>          },<br/>        },<br/>      ],<br/>    },<br/>  ],<br/>},</span></pre><p id="2bed" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这为我们的webpack构建添加了一个新的<strong class="ka jc">规则</strong>。如果webpack在依赖关系树中遇到一个以<code class="fe kw kx ky kz b">.js</code>结尾的文件(比如distance.js)，而这个文件不在<code class="fe kw kx ky kz b">node_modules</code>中(比如jQuery)，那么我们的规则适用于这个文件。</p><p id="73a9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，任何匹配这个规则的文件都将通过规则的<code class="fe kw kx ky kz b">use</code>数组中的所有加载器(在我们的例子中，它只是babel-loader)。因此<code class="fe kw kx ky kz b">distance.js</code>和<code class="fe kw kx ky kz b">page.js</code>通过babel-loader运行，导致<code class="fe kw kx ky kz b">distance.js</code>的箭头功能被移除，然后webpack继续其构建您的包的快乐之路。同时，当webpack遇到jQuery时，它只是加载代码，因为jQuery在<code class="fe kw kx ky kz b">node_modules</code>目录中，所以没有任何加载器。</p><figure class="la lb lc ld gt is gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/18f77664776cb7a0a9510957549103b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*EyMwoSFoTt9M-sXI7RywoQ.jpeg"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">webpack决定对依赖图中的每个文件使用哪些加载器</figcaption></figure><p id="b2e9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您运行<code class="fe kw kx ky kz b">yarn build</code>并进入<code class="fe kw kx ky kz b">dist/main.js</code>的源代码，对应于您的排序函数的代码现在使用<code class="fe kw kx ky kz b">function</code>关键字，而不是箭头函数！(<a class="ae mv" href="https://github.com/andyhaskell/webpack-mocha-tutorial/commit/8064767238ea4639f46b9c01b1e5f3ed475eb54c" rel="noopener ugc nofollow" target="_blank">提交6 </a>)</p><figure class="la lb lc ld gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nm"><img src="../Images/a824a5e18e44938c6f52f951ae0d5a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cnj0miFX_kbm6oTGuLk12Q.png"/></div></div></figure><figure class="la lb lc ld gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nn"><img src="../Images/c8c947550633b4ed6dbb40c1ce4304d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qzkDcvqSDqQ20CYS_1nc-Q.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">上图中高亮显示的代码是dist/main.js中添加babel-loader之前的sortByDistance函数，下方高亮显示的代码是添加babel-loader之后的同一个函数。注意上面我们使用了一个箭头函数，而下面我们有一个2009友好的函数关键字。</figcaption></figure><p id="f51d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的应用已经准备就绪！但是为了保持代码的可维护性，我们应该为它编写一些测试。</p><h1 id="0c46" class="lo lj jb bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">向我们的构建添加一些测试覆盖</h1><p id="dc13" class="pw-post-body-paragraph jy jz jb ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">让我们在distance.js文件中添加一些测试覆盖率。我们将使用<a class="ae mv" href="https://mochajs.org" rel="noopener ugc nofollow" target="_blank"> Mocha </a>，一个用于编写测试的基于测试套件的工具，并将<a class="ae mv" href="https://www.chaijs.com" rel="noopener ugc nofollow" target="_blank"> Chai </a>作为我们的断言库，所以运行这个命令:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="3561" class="li lj jb kz b gy lk ll l lm ln">yarn add --dev mocha chai</span></pre><p id="aef3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后创建一个新的<code class="fe kw kx ky kz b">app/test</code>目录和一个新文件<code class="fe kw kx ky kz b">app/test/distance.test.js</code>，其中包含以下代码:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="3a64" class="li lj jb kz b gy lk ll l lm ln">import {expect} from "chai";<br/>import {distance, sortByDistance} from "../src/distance";</span><span id="67b1" class="li lj jb kz b gy nf ll l lm ln">describe("distance", function() {<br/>  it("calculates distance with the good ol' Pythagorean Theorem", function() {<br/>    let origin = {x: 0.0, y: 0.0};<br/>    let point = {x: 3.0, y: 4.0};<br/>    expect(distance(point, origin)).to.equal(5);<br/>  });<br/>});</span><span id="79a7" class="li lj jb kz b gy nf ll l lm ln">describe("sortByDistance", function() {<br/>  it("sortsByDistance", function() {<br/>    let places = [<br/>      {name: "Far away", x: 100, y: 50},<br/>      {name: "Nearby", x: 20, y: 10},<br/>    ];<br/>    let origin = {name: "Origin", x: 0, y: 0};</span><span id="3834" class="li lj jb kz b gy nf ll l lm ln">    let sorted = sortByDistance(origin, places);<br/>      expect(sorted[0].name).to.equal("Nearby");<br/>      expect(sorted[1].name).to.equal("Far away");<br/>    });<br/>});</span></pre><p id="4125" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的<code class="fe kw kx ky kz b">distance</code>和<code class="fe kw kx ky kz b">sortByDistance</code>函数有自己的测试函数，它们断言距离函数计算距离公式，sortByDistance函数使用距离公式对坐标数组进行排序，使用Mocha测试套件和Chai断言。非常标准的测试设置。</p><p id="06f1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，如果我们运行<code class="fe kw kx ky kz b">mocha app/test/distance.test.js</code>，我们将得到一个错误，我们的JavaScript是无效的，因为它包含了<code class="fe kw kx ky kz b">import</code>关键字，这是节点目前不支持的。但是，如果我们通过使用webpack来管理测试代码的依赖性，从而绕过这个限制，会怎么样呢？(注意:这也可以通过在我们的测试文件中使用<code class="fe kw kx ky kz b">require</code>而不是<code class="fe kw kx ky kz b">import</code>来简单地解决，但是如果您正在测试像使用类型注释的流类型JavaScript或使用。vue文件，因为这两者都需要转换成常规的JS)。</p><p id="73c6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的测试流程是这样的:</p><ol class=""><li id="b955" class="mw mx jb ka b kb kc kf kg kj my kn mz kr na kv no nc nd ne bi translated">让webpack从我们的测试文件开始构建依赖关系树，而不是从我们的应用程序文件开始。</li><li id="eb4c" class="mw mx jb ka b kb np kf nq kj nr kn ns kr nt kv no nc nd ne bi translated">webpack然后会生成一个JavaScript文件，包含我们所有的测试代码及其依赖项，没有<code class="fe kw kx ky kz b">import</code>关键字</li><li id="7c57" class="mw mx jb ka b kb np kf nq kj nr kn ns kr nt kv no nc nd ne bi translated">然后，我们通过在这个JavaScript文件上运行Mocha来进行测试</li></ol><p id="baa1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看起来像这样:</p><figure class="la lb lc ld gt is gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/c97fdb42d3b5ec71e80a329f4f93ed50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*qzX-Iqn3sOBF9WV5ga1OAA.jpeg"/></div></figure><p id="b63d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，这也意味着我们要制作两个独立的版本。一个将我们的应用程序代码作为入口点，将<code class="fe kw kx ky kz b">dist</code>文件夹作为输出目录，另一个将我们的测试文件作为入口点，将<code class="fe kw kx ky kz b">test-dist</code>作为输出目录。因此，让我们更新我们的webpack配置文件以支持第二次构建:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="103f" class="li lj jb kz b gy lk ll l lm ln">let glob = require("glob");</span><span id="69fa" class="li lj jb kz b gy nf ll l lm ln">let entry = __dirname + "/app/src/page.js";<br/>let outputPath = __dirname + "/dist/";</span><span id="9057" class="li lj jb kz b gy nf ll l lm ln">if (process.env.TESTBUILD) {<br/>  entry = glob.sync(__dirname + "/app/test/**/*.test.js");<br/>  outputPath = __dirname + "/test-dist/";<br/>}</span><span id="8ed1" class="li lj jb kz b gy nf ll l lm ln">module.exports = {<br/>  entry: entry,<br/>  output: {<br/>    path: outputPath,<br/>  },<br/>  // rest of webpack config file stays the same</span></pre><p id="4a47" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是做什么的？在第五行，我们有一个if语句，如果我们的环境变量TESTBUILD有一个非空值，我们就运行这个语句。因此，如果我们运行<code class="fe kw kx ky kz b">TESTBUILD=true webpack</code>，那么我们将输入if语句，但是如果我们只运行<code class="fe kw kx ky kz b">npx webpack</code>，我们就不会这样做。</p><p id="65d8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在if语句中，我们更改哪个JS文件是我们入口点。我们的输出路径不是到<code class="fe kw kx ky kz b">dist</code>文件夹，而是到<code class="fe kw kx ky kz b">test-dist</code>文件夹。我们的入口点不再是<code class="fe kw kx ky kz b">app/src/path.js</code>作为我们的条目，而是匹配glob表达式<code class="fe kw kx ky kz b">app/test/**/*.test.js</code>的所有文件的数组。换句话说，所有文件都是:</p><ol class=""><li id="fb44" class="mw mx jb ka b kb kc kf kg kj my kn mz kr na kv no nc nd ne bi translated">在<code class="fe kw kx ky kz b">app/test</code>目录下的一个路径中</li><li id="a295" class="mw mx jb ka b kb np kf nq kj nr kn ns kr nt kv no nc nd ne bi translated">有一条以<code class="fe kw kx ky kz b">.test.js</code>结尾的路径</li></ol><p id="bbe1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将新的入口点和输出路径传递到<code class="fe kw kx ky kz b">module.exports</code>对象中，webpack运行它来构建我们的测试。如你所见，webpack配置是常规的JavaScript，所以我们可以使用Node的标准库和if语句像JavaScript一样配置它。运行<code class="fe kw kx ky kz b">TESTBUILD=true npx webpack</code>，你应该会看到一个<code class="fe kw kx ky kz b">test-dist</code>目录。如果您运行<code class="fe kw kx ky kz b">npx mocha test-dist/main.js</code>，您应该会看到您的测试正在运行！</p><figure class="la lb lc ld gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/ae9f361e2b24eca176d180d62ac0f4e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N_8ZDwZs-_LQxn7QUNXy8w.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">他们通过了！</figcaption></figure><p id="c7de" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，在<code class="fe kw kx ky kz b">package.json</code>的“脚本”部分添加这一行:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="49bf" class="li lj jb kz b gy lk ll l lm ln">"test": "TESTBUILD=true webpack &amp;&amp; mocha test-dist/main.js &amp;&amp; rm -rf test-dist"</span></pre><p id="f0d7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着现在当您运行<code class="fe kw kx ky kz b">yarn test</code>时，您使用webpack构建您的<code class="fe kw kx ky kz b">test-dist</code>版本，然后在该版本上运行Mocha，最后，<code class="fe kw kx ky kz b">rm -rf test-dist</code>删除test-dist目录，因为我们已经用完了它。(<a class="ae mv" href="https://github.com/andyhaskell/webpack-mocha-tutorial/commit/b5a69f819abdf5c45a6dbbeb19e366924e9bfe05" rel="noopener ugc nofollow" target="_blank">提交7 </a>)</p><h1 id="ce81" class="lo lj jb bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">源代码映射我们的测试代码</h1><p id="b8c9" class="pw-post-body-paragraph jy jz jb ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">现在我们已经有了我们的测试版本，但是当我们测试我们的代码时，有一件事情会变得很烦人。如果我们在我们的<code class="fe kw kx ky kz b">test-dist/main.js </code>文件上运行Mocha，并且我们的一个测试失败了，那会是什么样子呢？让我们在<code class="fe kw kx ky kz b">app/test/distance.test.js</code>让距离公式测试失败:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="be07" class="li lj jb kz b gy lk ll l lm ln">describe("distance", function() {<br/>  it("calculates distance with the good ol' Pythagorean Theorem", function() {<br/>    let origin = {x: 0.0, y: 0.0};<br/>    let point = {x: 3.0, y: 4.0};</span><span id="8bba" class="li lj jb kz b gy nf ll l lm ln">    <strong class="kz jc">expect(distance(point, origin)).to.equal(2071);</strong><br/>  });<br/>});</span></pre><p id="c25c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行<code class="fe kw kx ky kz b">yarn test</code>你应该得到这个</p><figure class="la lb lc ld gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nv"><img src="../Images/1e85ac4d5c70d53105bd2c0e0f8a43f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nuuvLPZhq-MDcbPlnjM5QQ.png"/></div></div></figure><p id="b191" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试失败了，但是你看不到你的原始测试代码是哪一行，如果你的web应用有很多测试，你的测试失败的那一行可能很难找到。</p><figure class="la lb lc ld gt is gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/5c16d7730bd0a687e13da85844df9e96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*tgwuc9ot4o3DnZtYgNo9jg.jpeg"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">Lola the Micropanda在test-dist/main.js的第116行寻找失败的断言</figcaption></figure><p id="192c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">失败的代码在<code class="fe kw kx ky kz b">app/test/distance.test.js</code>的第8行，但是我们在<code class="fe kw kx ky kz b">test-dist/main.js</code>上运行Mocha，所以从Mocha的角度来看，失败的断言在第116行。幸运的是，webpack支持<strong class="ka jc">源代码映射</strong>，它可以告诉你哪一行代码对应于一个bug。源映射就像一个特殊标记的谷物盒中的解码器环，您可以使用您的解码器环和捆绑的main.js文件来获取对应于捆绑代码的原始代码行。这份完整早餐的一部分，现在是这份完整webpack配置的一部分！更新您的<code class="fe kw kx ky kz b">webpack.config.js</code>文件中的if语句:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="0a18" class="li lj jb kz b gy lk ll l lm ln">let entry = __dirname + "/app/src/path.js";<br/>let outputPath = __dirname + "/dist/";<br/><strong class="kz jc">let devtool = "";</strong></span><span id="7c10" class="li lj jb kz b gy nf ll l lm ln">if (process.env.TESTBUILD) {<br/>  entry = glob.sync(__dirname + "/app/test/**/*.test.js");<br/>  outputPath = __dirname + "/test-dist/";<br/>  <strong class="kz jc">devtool = "source-map";</strong><br/>}</span></pre><p id="e323" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在module.exports对象中添加一行:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="2928" class="li lj jb kz b gy lk ll l lm ln">devtool: devtool,</span></pre><p id="151d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，在您的测试构建中，您的test-dist目录将包含一个源映射文件。运行<code class="fe kw kx ky kz b">npx webpack TESTBUILD=true</code>，你的<code class="fe kw kx ky kz b">test-dist</code>目录将会有一个<code class="fe kw kx ky kz b">main.js.map</code>文件和<code class="fe kw kx ky kz b">main.js</code>包。</p><figure class="la lb lc ld gt is gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/3485fd13607e6d4fe7f3e536e5426673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*s5HbJtsPxGjxRibieg9c5Q.jpeg"/></div></figure><p id="3298" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了让Mocha在运行测试时使用这个源映射，我们只需要再安装一个包:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="f159" class="li lj jb kz b gy lk ll l lm ln">yarn add --dev source-map-support</span></pre><p id="b765" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在要使用它，我们只需要更新我们的<code class="fe kw kx ky kz b">package.json</code>的<code class="fe kw kx ky kz b">scripts.test</code>部分中的Mocha脚本:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="9009" class="li lj jb kz b gy lk ll l lm ln">TESTBUILD=true webpack &amp;&amp; mocha test-dist/main.js --require source-map-support/register &amp;&amp; rm -rf test-dist</span></pre><p id="213d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Mocha中的那个标志，<code class="fe kw kx ky kz b">--require source-map-support/register</code>让Mocha要求source-map-support包，这意味着Mocha将使用可用的source map。所以现在如果你运行<code class="fe kw kx ky kz b">yarn test</code>，当你得到一个失败的断言时，你会知道它在哪一行，并且可以修复代码！</p><figure class="la lb lc ld gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ny"><img src="../Images/a84c1a06648bda8ff798abae30b5393a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1PX6_WHDDuQ2b-3I0LnKXA.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">断言fail位于distance.test.js的第8行</figcaption></figure><p id="223b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">洛拉同意，源地图确实是，它在哪里！(<a class="ae mv" href="https://github.com/andyhaskell/webpack-mocha-tutorial/commit/0085f471b94cb69f504a71a1c8761b80320ddeff" rel="noopener ugc nofollow" target="_blank">提交8 </a>)</p><figure class="la lb lc ld gt is gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/6d747a5d1840a94059aae4d5ccc367ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*-PU5W1VwcE5nCbQZH_5xGw.jpeg"/></div></figure><p id="db90" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，现在您已经为您的常规发行版构建和测试构建设置了源代码映射。从现在开始，您可以在此基础上构建更多的方法，例如将多个JavaScript加载器链接在一起以在管道中处理您的代码，或者将webpack作为开发服务器运行以立即查看您的代码更改对最终webpack构建的影响，因此继续尝试将我们不同的包组合到您的应用程序的<code class="fe kw kx ky kz b">webpack.config.js</code>文件中，因为我们只是触及了表面。</p><p id="e9bf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下次见，继续偷懒！</p><p id="dd9e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">树懒图片由Jenny Jozwiak拍摄，由2.0 在<a class="ae mv" href="https://creativecommons.org/licenses/by/2.0/" rel="noopener ugc nofollow" target="_blank"> CC下授权</a></p></div></div>    
</body>
</html>