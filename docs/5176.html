<html>
<head>
<title>Designing Microservices with ExpressJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ExpressJS设计微服务</h1>
<blockquote>原文：<a href="https://itnext.io/designing-microservices-with-expressjs-eb23e4f02192?source=collection_archive---------1-----------------------#2021-01-03">https://itnext.io/designing-microservices-with-expressjs-eb23e4f02192?source=collection_archive---------1-----------------------#2021-01-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/d24d2bc48478fe21098db4a5ccb265bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GU69jLygQuRCoC-Gx2rFLA.png"/></div></div></figure><div class=""/><p id="f6fb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我将解释如何在NodeJS中开发一个基于微服务的架构。我创建了一个票务管理应用程序场景，我画它来解释。</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi kw"><img src="../Images/ec2447accde456570b7b6a2b810e8985.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eAxskYbJVmMsPT-g_1dAEQ.png"/></div></div></figure><p id="73c0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在开始之前，我不会解释所有与ExpressJS相关的细节，因为你可以从下面的Github链接下载项目文件。</p><p id="b344" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">https://github . com/yildizberkay/micro services-with-express js</p><h1 id="2fef" class="lb lc jb bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">方案</h1><p id="5728" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">在上图中，Nginx有两个职责。第一个是管理所有的流量，第二个是检查用户的身份验证。在这篇文章中，我不会深入讨论授权问题。这可能是另一篇文章的主题。</p><p id="33d4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也有认证和票务服务，它们只有一种模式。授权服务处理注册和授权验证，而票证服务管理属于用户的票证。</p><p id="a33c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有两个公开端点，无需任何身份验证即可注册和登录。中间件管理auth服务的认证，而Nginx管理其余服务的认证。如果任何请求到达票务服务，Nginx将向auth服务询问令牌的有效性，根据结果，它将拒绝或接受它们。如果请求被接受，Nginx还会将活动用户的id和报头一起传递给票务服务。</p><h1 id="d212" class="lb lc jb bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">微服务设计</h1><h2 id="91f5" class="me lc jb bd ld mf mg dn lh mh mi dp ll kj mj mk lp kn ml mm lt kr mn mo lx mp bi translated">微服务的文件夹结构</h2><pre class="kx ky kz la gt mq mr ms mt aw mu bi"><span id="82f6" class="me lc jb mr b gy mv mw l mx my">- tests<br/>- src<br/>  - db<br/>    - config<br/>    - models<br/>  - enums<br/>  - exceptions<br/>  - middlewares<br/>  - services<br/>  - utils<br/>  - index.js<br/>  - routes.js<br/>  - server.js</span></pre><p id="6686" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mz">测试</em>文件夹是<em class="mz"> src </em>文件夹的反映。测试以相同的路径和名称进行。名字的后缀是。<em class="mz"> test.js </em>扩展。</p><p id="9016" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mz"> src/db/config </em>保存数据库概要文件。这些配置文件可以用环境参数来修改。在这个实现中，我们有3个概要文件作为<em class="mz">开发</em>、<em class="mz">测试</em>和<em class="mz">生产</em>。数据库模型保存在<em class="mz"> src/db/models </em>文件夹下。我们使用Sequelize作为ORM，但我不会深入细节，只是定义模型并使用它。如果你想了解这个ORM的细节，它有很好的文档。</p><p id="7ae4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mz"> src/exceptions </em>保存微服务特定的异常类。一个异常类包含一个<em class="mz">名称</em>和<em class="mz"> httpStatusCode </em>。<em class="mz"> globalErrorHandler </em>使用这两个参数生成一个错误响应。</p><p id="7d4f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有的业务逻辑都位于<em class="mz"> src/services </em>文件夹下。业务逻辑文件可以通过模型名称来分隔。</p><p id="6cba" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我没有创建routes文件夹，因为它们是只包含一个模型的简单服务，并且有一个主端点。如果您计划通过另一种策略来分解您的微服务，您可以创建一个routes文件夹，并将您的路径存储在该文件夹下。</p><h2 id="8c9f" class="me lc jb bd ld mf mg dn lh mh mi dp ll kj mj mk lp kn ml mm lt kr mn mo lx mp bi translated">用中间件处理认证</h2><p id="1f45" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">认证服务在用户认证中使用<a class="ae na" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JWT标准</a>。<em class="mz"> authHandler </em>是我们的关键中间件。它获取<em class="mz">授权</em>密钥并解析它。在第5行中，JWT被验证。如果无效，它将返回401状态代码。</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nb"><img src="../Images/bdfc76ae9627af0eb2f71e2dc94880b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UKIg7OnRPtDpPqMTVd6IPQ.png"/></div></div></figure><h2 id="cfdf" class="me lc jb bd ld mf mg dn lh mh mi dp ll kj mj mk lp kn ml mm lt kr mn mo lx mp bi translated">Nginx和Auth服务之间的通信</h2><p id="f021" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated"><em class="mz"> /check-token </em>端点返回200状态码，并将<em class="mz"> User-Id </em>属性添加到头中。Nginx稍后将处理该属性。</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nc"><img src="../Images/f5e5b0a5e50c39f43634c4b356cc211f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O43zSqNEENmxZMQvZGD3Jw.png"/></div></div></figure><h2 id="17ff" class="me lc jb bd ld mf mg dn lh mh mi dp ll kj mj mk lp kn ml mm lt kr mn mo lx mp bi translated">从票务服务获取用户标识</h2><p id="425a" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">Nginx将头中的User-Id传递给所有其他用auth实现的服务。</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/b756b09b994c37d323c7355b66d038dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fDfoTwurZoc0iBp1JHbr_w.png"/></div></div></figure><h1 id="3063" class="lb lc jb bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">网关设计</h1><h2 id="d239" class="me lc jb bd ld mf mg dn lh mh mi dp ll kj mj mk lp kn ml mm lt kr mn mo lx mp bi translated">Nginx作为网关</h2><p id="4f62" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">Nginx是一个独特的web服务器，你只需要几行代码就可以把它配置成负载平衡器或网关。当Nginx在Docker容器上工作时，它可以看到同一网络中的其他服务。</p><p id="d14b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下面的代码中，它处理来自8080的所有请求。<em class="mz"> location /auth </em>捕捉以<em class="mz"> /auth </em>开始的端点，并用<em class="mz"> proxy_pass将到来的请求传递给<em class="mz">http://service-auth:3000</em>。你可能会问Nginx如何识别这个主机名。Docker将为位于同一网络中的所有容器设置该主机名。</em></p><pre class="kx ky kz la gt mq mr ms mt aw mu bi"><span id="9f74" class="me lc jb mr b gy mv mw l mx my">server {<br/>  listen 8080;<br/>  location /auth {<br/>    rewrite ^/auth/(.*) /$1 break;<br/>    <br/>    proxy_pass        http://service-auth:3000;<br/>    proxy_redirect    off;<br/>    proxy_set_header  Host $host;<br/>    ...<br/>  }<br/>}</span></pre><p id="6c7e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个简单的演示。如果你的服务变得更加复杂和拥挤，你也可以使用像<a class="ae na" href="https://www.consul.io/" rel="noopener ugc nofollow" target="_blank"> Consul </a>这样的服务发现解决方案。</p><h2 id="54b0" class="me lc jb bd ld mf mg dn lh mh mi dp ll kj mj mk lp kn ml mm lt kr mn mo lx mp bi translated">证明</h2><p id="4363" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated"><a class="ae na" href="http://nginx.org/en/docs/http/ngx_http_auth_request_module.html" rel="noopener ugc nofollow" target="_blank"><em class="mz">auth _ request</em></a><em class="mz"/>模块在请求服务之前处理所有的认证事务。在认证请求完成后，<em class="mz"> auth_request_set </em>将来自认证结果的任何值设置为一个本地变量，如<em class="mz"> $user_id </em>，这样我们可以在以后使用它来传递。</p><pre class="kx ky kz la gt mq mr ms mt aw mu bi"><span id="d8bd" class="me lc jb mr b gy mv mw l mx my">location /ticket {<br/>  auth_request /check-token;<br/>  auth_request_set $user_id $sent_http_user_id;<br/><br/>  rewrite ^/ticket/(.*) /$1 break;<br/><br/>  proxy_pass        <a class="ae na" href="http://service-ticket:3000;" rel="noopener ugc nofollow" target="_blank">http://service-ticket:3000;</a><br/>  proxy_set_header  User-Id $user_id;<br/>  ...<br/>}</span></pre><p id="97e4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，<em class="mz"> /check-token </em>定义在哪里呢？我们定义了一个内部位置，它被直接传递给auth service的相关端点。</p><pre class="kx ky kz la gt mq mr ms mt aw mu bi"><span id="67bd" class="me lc jb mr b gy mv mw l mx my">location /check-token {<br/>  internal;<br/>  proxy_pass        http://service-auth:3000/check-token;<br/>  ...<br/>}</span></pre><h2 id="7f16" class="me lc jb bd ld mf mg dn lh mh mi dp ll kj mj mk lp kn ml mm lt kr mn mo lx mp bi translated">负载平衡</h2><p id="6712" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">您可能有一组授权服务，并放置了一个内部负载平衡器。为此，我可以建议两个策略。</p><p id="fc08" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">策略一:Nginx上游</strong> <br/> <em class="mz">上游</em>如果你想用Nginx，来帮我们。它用于组合一组服务器，并具有负载平衡能力。</p><pre class="kx ky kz la gt mq mr ms mt aw mu bi"><span id="066f" class="me lc jb mr b gy mv mw l mx my">upstream service-auth {<br/>  server service-auth-1:3000;<br/>  server service-auth-2:3000;<br/>  server service-auth-3:3000;<br/>}<br/><br/>server {<br/>  listen 8080;<br/>  location /auth {<br/>    rewrite ^/auth/(.*) /$1 break;<br/>    <br/>    proxy_pass        http://service-auth;<br/>    proxy_redirect    off;<br/>    proxy_set_header  Host $host;<br/>  }<br/>}</span></pre><ul class=""><li id="2840" class="ne nf jb ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated"><a class="ae na" href="https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/" rel="noopener ugc nofollow" target="_blank">https://docs . nginx . com/nginx/admin-guide/load-balancer/http-load-balancer/</a></li></ul><p id="7a00" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">策略二:像PM2 <br/>这样的流程管理器服务器可以用PM2或者StrongLoop这样的流程管理器来运行。它们提供集群模式，任何数量的应用程序都可以在一个容器中工作。</strong></p><ul class=""><li id="8e33" class="ne nf jb ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated"><a class="ae na" href="https://pm2.keymetrics.io/docs/usage/docker-pm2-nodejs/#starting-a-configuration-file" rel="noopener ugc nofollow" target="_blank">https://PM2 . key metrics . io/docs/usage/docker-PM2-nodejs/# starting-a-configuration-file</a></li></ul><h1 id="0203" class="lb lc jb bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="a5d4" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">感谢你阅读这篇文章。我试图简单地解释，它当然有更多的细节，但这些细节是由你的需求决定的。我也创建了部署脚本，但是我将在另一篇文章中解释细节。你可以在下面的Github链接中找到帖子的所有运行代码。</p><p id="38d2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，记住没有唯一正确的方法。尤其是在JavaScript中:)</p><p id="0fc8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Github资源库:<a class="ae na" href="https://github.com/yildizberkay/microservices-with-expressjs" rel="noopener ugc nofollow" target="_blank">https://github . com/yildizberkay/micro services-with-express js</a></p></div></div>    
</body>
</html>