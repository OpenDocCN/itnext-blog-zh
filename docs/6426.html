<html>
<head>
<title>How to elegantly deal with null references</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何优雅地处理空引用</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-elegantly-deal-with-null-references-86a94494428?source=collection_archive---------3-----------------------#2021-11-14">https://itnext.io/how-to-elegantly-deal-with-null-references-86a94494428?source=collection_archive---------3-----------------------#2021-11-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/48cfacf5754fa29a76bdfa6b36e3a258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*grXh4I4b57qaKStUdUx8fA.jpeg"/></div></figure><div class=""/><p id="c0b7" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">事情是这样的:在过去的几年里，在更优雅地处理空引用方面有了很多改进。最突出的是，C#8增加了可空引用类型特性，这允许以一种很好的方式对空引用进行编译时检查。它是所有以前试图做类似事情的库的“官方”替代，基于来自Resharper或其他人的类似[NotNull]的属性。</p><p id="81cd" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这些变化是非常受欢迎的，它们确实有助于编写更安全的代码，尤其是当涉及到我从未想过可能返回空引用的方法时。</p><p id="15e5" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">不过，对我来说，这只是正确处理空值的一半。尽管这些变化有所帮助，但它们也导致了大量的无效支票。现在您对什么可能为空或不为空有了更好的了解，您的代码可能会有更多这样的部分:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="5cc0" class="le lf ja la b gy lg lh l li lj">public interface IMyInterface<br/>{<br/> void Run(string message);<br/>}</span><span id="9172" class="le lf ja la b gy lk lh l li lj">internal class MyImplementer : IMyInterface<br/>{<br/> public void Run(string message) =&gt; Console.WriteLine(message);<br/>}</span><span id="5542" class="le lf ja la b gy lk lh l li lj">void Main()<br/>{<br/> // Our null reference<br/> IMyInterface? potentialNullInterface = null;<br/> if (potentialNullInterface is null)<br/> {<br/>     potentialNullInterface = new MyImplementer();<br/> }</span><span id="c1b1" class="le lf ja la b gy lk lh l li lj"> ...<br/> <br/> if (potentialNullInterface is not null)<br/> {<br/>  potentialNullInterface.Run("Hello World");<br/> }</span><span id="1535" class="le lf ja la b gy lk lh l li lj"> ...<br/>  <br/> IMyInterface? otherInterface = potentialNullInterface ?? new MyImplementer();</span><span id="7b33" class="le lf ja la b gy lk lh l li lj"> ...<br/> <br/> otherInterface?.Run("Hello World"); <br/>}</span></pre><p id="5917" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这些只是关于如何检查可空性的一些例子。尤其是空合并检查非常简洁和方便，但有时甚至这些检查都感觉太臃肿或太复杂而难以考虑。这只是你在阅读代码部分时必须记住的另一点上下文。</p><h1 id="f534" class="ll lf ja bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">空对象模式</h1><p id="e615" class="pw-post-body-paragraph jx jy ja jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">除了在代码中散布空检查，还有另一种叫做空对象(有时也称为void对象)的方法，它绝对不需要空检查，但仍然具有相同的行为。让我们来看一个可能熟悉的场景。</p><p id="e078" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">假设您编写了一些代码来为一个任意的操作提供度量标准，并且您通过下面的简单实现做到了这一点:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="c6ad" class="le lf ja la b gy lg lh l li lj">public interface IMetricsWriter<br/>{<br/> Task IncreaseCounter(string counterName);<br/>}</span><span id="58c2" class="le lf ja la b gy lk lh l li lj">internal class MetricsWriter : IMetricsWriter<br/>{<br/> private readonly HttpClient _metricsSinkClient;</span><span id="11a1" class="le lf ja la b gy lk lh l li lj">public MetricsWriter(HttpClient metricsSinkClient) =&gt; _metricsSinkClient = metricsSinkClient;</span><span id="3202" class="le lf ja la b gy lk lh l li lj">public async Task IncreaseCounter(string counterName)<br/> {<br/>  // Post our new metrics to a server<br/>  await _metricsSinkClient.PostAsync(...);<br/> }<br/>}</span></pre><p id="b310" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">目前看来还算合理。您实现了一个接口和一个将指标写入远程端点的实现。</p><p id="d542" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在使用它的时候，你的新接口可能会通过DI注入到另一个类中，例如:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="751b" class="le lf ja la b gy lg lh l li lj">public class LoginService<br/>{<br/> private readonly IMetricsWriter _metricsWriter;</span><span id="368d" class="le lf ja la b gy lk lh l li lj">public LoginService(IMetricsWriter metricsWriter) =&gt; _metricsWriter = metricsWriter;<br/> <br/> public async Task Login(string userName, string password)<br/> {<br/>  // Do some login actions here<br/>  ...<br/>  <br/>  await _metricsWriter.IncreaseCounter("Login");<br/> }<br/>}</span></pre><p id="0312" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">太好了！现在，我们有了一个登录服务，一旦它收到一个登录，就会自动增加一个指标。</p><p id="eb6a" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，在某个时间点，您决定要构建另一个服务，它与我们的初始服务共享完全相同的LoginService，但是对于这个服务，我们<strong class="jz jb">不想</strong>跟踪任何指标。现在该怎么办？使指标编写器可为空？这肯定是可行的，但是您最终会得到这样的结果:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="780d" class="le lf ja la b gy lg lh l li lj">public async Task Login(string userName, string password)<br/> {<br/>  // Do some login actions here<br/>  <br/>  if (_metricsWriter is not null)<br/>  {<br/>   await _metricsWriter.IncreaseCounter("Login");<br/>  }<br/> }</span></pre><p id="e621" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这看起来还不错，但是如果服务增长，可能会出现更多这样的场景，通过您必须实现的所有检查和保护，它将变得越来越复杂。让我们采取另一种方法。让我们坚持最初的非空服务，改为实现一个<strong class="jz jb">空对象</strong>！</p><p id="7dcb" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">实现实际上非常简单:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="4407" class="le lf ja la b gy lg lh l li lj">public interface IMetricsWriter<br/>{<br/> Task IncreaseCounter(string counterName);<br/>}</span><span id="14c2" class="le lf ja la b gy lk lh l li lj">internal class NullMetricsWriter : IMetricsWriter<br/>{<br/> public Task IncreaseCounter(string counterName) =&gt; Task.CompletedTask;<br/>}</span></pre><p id="4dc9" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">就是这样！我们已经实现了一个100%兼容的接口实现，只是这个实现完全没有任何变化。我们所做的就是返回一个完成的任务，这样我们就符合方法签名了。</p><p id="96c2" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因为我们最初说过，通过依赖注入将<strong class="jz jb">度量写入器</strong>注入到服务中，所以我们现在要做的就是将这个新的null实现绑定到我们新服务中的接口。</p><p id="960d" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后，当有人登录时，我们新的null实现被触发来增加计数器，完全不做任何事情，但仍然返回其完成的任务，调用服务很高兴。不需要更多的空检查，但是我们实现了与常规空引用相同的流程。</p><p id="9561" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">概括一下:虽然通常您会将null视为与接口的实际实现完全不同的实体，但是null对象模式将可空性行为提升到了我们的对象的第一类实现。它不再需要空检查，因为它<strong class="jz jb">是我们接口的有效实现。</strong></p><h1 id="3579" class="ll lf ja bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">何时不使用它</h1><p id="6a79" class="pw-post-body-paragraph jx jy ja jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">空对象模式是我喜欢使用的东西，但它也不是适合所有用例的解决方案。在您开始用这个解决方案替换所有的空支票之前，有一些事情需要记住。</p><ol class=""><li id="5a32" class="mn mo ja jz b ka kb ke kf ki mp km mq kq mr ku ms mt mu mv bi translated">当使用这种模式时，<strong class="jz jb">调用者绝对看不出</strong>在一个接口后面可能有一个空对象。如果你的同事查看了LoginService并运行了它，<strong class="jz jb">如果不知道你的DI注册，他就无法知道那里有什么。他甚至可能认为这正确地编写了度量标准，并将其部署到生产中，并且可能在一周之后感到惊讶，当他查看您的度量标准时，什么也没有看到。通过适当的空值检查，这一点很明显。</strong></li><li id="a4a8" class="mn mo ja jz b ka mw ke mx ki my km mz kq na ku ms mt mu mv bi translated">使用该模式作为应用程序启动和到事件总线的异步连接之间的桥梁可能很有吸引力，例如，通过一个<strong class="jz jb"> NullEvent </strong>，直到您可以用一个适当的事件替换它。但是同样，null事件只会吞噬每个调用，有时为了不丢失数据，您最好先实现一个缓冲。</li><li id="10d7" class="mn mo ja jz b ka mw ke mx ki my km mz kq na ku ms mt mu mv bi translated">如果你做得太多，你可能会分配很多不必要的对象。您可能想考虑创建这些对象的单例实现，这很容易做到，因为这些对象中没有状态，因此没有并发问题。</li><li id="8a3c" class="mn mo ja jz b ka mw ke mx ki my km mz kq na ku ms mt mu mv bi translated">当您有返回值的方法时，使用这种模式尤其棘手。对于引用类型，您通常可以很容易地通过，因为您可以退回到null。但是，如果一个空对象必须实现的方法返回一个值类型，该怎么办呢？对于返回int的签名，你会返回0吗？这里可能会出现许多定义问题。</li></ol><p id="2f45" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但是即使有提到的缺点，它仍然是一个很好的模式，特别是当涉及到您可能想要避开的非关键接口时，可能是为了测试目的，或者是为了解决依赖注入设置，如果这些依赖的消费者对处理特定的接口不感兴趣的话。这方面的主要例子是日志记录、指标甚至事件。</p><p id="6469" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">总而言之:你必须评估这是否适合你的应用环境。缺点是否值得，或者您的代码部分是否重要？无论结果如何，拥有另一个工具总是有助于您获得尽可能干净的代码。</p></div></div>    
</body>
</html>