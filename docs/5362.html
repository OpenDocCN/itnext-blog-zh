<html>
<head>
<title>Automatic refactoring with jscodeshift/codemods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用jscodeshift/codemods进行自动重构</h1>
<blockquote>原文：<a href="https://itnext.io/automatic-refactoring-with-jscodeshift-codemods-45c219eaf992?source=collection_archive---------0-----------------------#2021-02-17">https://itnext.io/automatic-refactoring-with-jscodeshift-codemods-45c219eaf992?source=collection_archive---------0-----------------------#2021-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9c95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我想通过<code class="fe ko kp kq kr b">jscodeshift</code>的一些用法来介绍一些关于如何在日常工作中应用自动重构的技巧。更具体地说，我将在最近开发和维护设计系统的过程中，介绍我们如何使用<code class="fe ko kp kq kr b">jscodeshift</code>来升级突破性的API更改，以最小化对我们的消费者的影响。</p><p id="df69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您的<em class="ks">组件</em>有内部或外部消费者时，如果您没有访问消费代码库的权限(您不能直接对代码库应用更改)，那么这里讨论的技术和模式对您也是有用的。如果你的日常工作更多的是关于如何为应用程序使用现有的组件库，我认为它也是有用的。毕竟，在大多数软件系统中，我们同时是消费者和提供者。</p><h1 id="db8e" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">一个简单的用例</h1><p id="7b1f" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">现在让我们想象你有一个花哨的组件库(姑且称之为fancylib)发布，在库中有一个<code class="fe ko kp kq kr b">Button</code>。按钮有一个名为<code class="fe ko kp kq kr b">loading</code>的属性，用来表示它正在异步工作。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lw"><img src="../Images/b2754ed1f187bd25b8501ea36fc28a17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P-Jd9JsZnCrho7fSeY_Ssg.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">(图片来源:<a class="ae mm" href="https://xd.adobe.com/ideas/process/ui-design/designing-interactive-buttons-states/" rel="noopener ugc nofollow" target="_blank">https://xd . adobe . com/ideas/process/ui-design/design-interactive-buttons-States/</a>)</figcaption></figure><p id="1a3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在代码中，这个<code class="fe ko kp kq kr b">loading</code>由于某种原因被定义为一个叫做<code class="fe ko kp kq kr b">isInLoadingStatus</code>的公共道具。用户可以利用它来控制<code class="fe ko kp kq kr b">Button</code>的状态。</p><pre class="lx ly lz ma gt mn kr mo mp aw mq bi"><span id="ffd1" class="mr ku it kr b gy ms mt l mu mv">import Button from '@fancylib/button';<br/>​<br/>const app = () =&gt; (<br/>    &lt;Button isInLoadingStatus&gt;Click me&lt;/Button&gt;<br/>)</span></pre><p id="47c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在一次代码审查会议上，一个实习生问了一个以前没有人问过的问题:所有的<code class="fe ko kp kq kr b">boolean</code>状态在其他地方都被命名为一个工作，比如<code class="fe ko kp kq kr b">checked</code>、<code class="fe ko kp kq kr b">disabled</code>。所以为了遵循惯例，我们应该将<code class="fe ko kp kq kr b">isInLoadingStatus</code>重命名为<code class="fe ko kp kq kr b">loading</code>。多好的主意啊！</p><pre class="lx ly lz ma gt mn kr mo mp aw mq bi"><span id="ebc2" class="mr ku it kr b gy ms mt l mu mv">import Button from '@fancylib/button';<br/>​<br/>const app = () =&gt; (<br/>    &lt;Button loading&gt;Click me&lt;/Button&gt;<br/>)</span></pre><p id="15c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">而且如果你能接触到<code class="fe ko kp kq kr b">Button</code>的所有用法，字符串替换几乎是一个直接且80%高效的解决方案。然而，简单地使用<code class="fe ko kp kq kr b">Shift+F6</code>会有很多问题。</p><h2 id="6edf" class="mr ku it bd kv mw mx dn kz my mz dp ld kb na nb lh kf nc nd ll kj ne nf lp ng bi translated">更复杂的案件</h2><p id="af5e" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">例如，如果使用者有自己的按钮包装，如下面的代码片段，则全局搜索/替换将是不可能的:</p><pre class="lx ly lz ma gt mn kr mo mp aw mq bi"><span id="468d" class="mr ku it kr b gy ms mt l mu mv">import Button as FancyButton from '@fancylib/button';<br/>​<br/>const MyEvenFancierButton = (props: FancyButtonProps) =&gt; (<br/>    const theme = {<br/>        backgroundColor: "orangered",<br/>        color: "white"<br/>    };<br/>    &lt;FancyButton {...props} theme={theme}&gt;Click me&lt;/FancyButton&gt;<br/>);</span></pre><p id="09c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，作为一个流行的库，<code class="fe ko kp kq kr b">Button</code>有许多内部和外部用户，当然你不能访问所有的用户。你需要其他方法。</p><p id="00ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你需要一个更复杂的工具——一个能理解使用代码结构的工具——来帮你做脏活。如果整个过程能够以某种方式自动完成，那就太完美了。</p><h2 id="f3ca" class="mr ku it bd kv mw mx dn kz my mz dp ld kb na nb lh kf nc nd ll kj ne nf lp ng bi translated">使用jscodeshift</h2><p id="57c2" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated"><code class="fe ko kp kq kr b">jscodeshift</code>正是这样一个工具(工具集)。简单来说，<code class="fe ko kp kq kr b">jscodeshift</code>将源代码解析成一棵树(抽象语法树)，并提供<code class="fe ko kp kq kr b">API</code>给开发者操纵那棵树上的节点，最终生成回源代码的树。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nh"><img src="../Images/9c6a975cb1f51c9d4adbb324a3abd468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1MBLr5yRjN70NBsljHCzjA.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">代码— AST — AST —代码</figcaption></figure><p id="5d64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">换句话说，它理解你的代码，并有<code class="fe ko kp kq kr b">API</code>按照你的意愿修改代码。通过说它是一个工具集，它实际上包含了几个工具:</p><ul class=""><li id="a1e8" class="ni nj it js b jt ju jx jy kb nk kf nl kj nm kn nn no np nq bi translated">将源代码解析到AST的解析器</li><li id="f7cb" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated">执行<code class="fe ko kp kq kr b">transform</code>的运行器(可以应用于解析树的脚本)</li></ul><h1 id="273b" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">实现转换</h1><p id="5934" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">让我们看一个简单的脚本来完成上面用<code class="fe ko kp kq kr b">jscodeshift</code>讨论的自动转换。<code class="fe ko kp kq kr b">jscodeshift</code>的工作方式是:首先你需要定义一个<code class="fe ko kp kq kr b">transform</code>脚本，这个脚本需要遵守协议，这样它才能被识别，然后<code class="fe ko kp kq kr b">jscodeshfit</code>将启动一个<code class="fe ko kp kq kr b">runner</code>来将这个<code class="fe ko kp kq kr b">transform</code>应用到一个文件或一个文件夹下的所有文件。比如下面的命令:</p><pre class="lx ly lz ma gt mn kr mo mp aw mq bi"><span id="29c0" class="mr ku it kr b gy ms mt l mu mv">jscodeshift -t myTransform src</span></pre><p id="17c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意这里的<code class="fe ko kp kq kr b">myTransform</code>是您的<code class="fe ko kp kq kr b">transform</code>脚本名称，<code class="fe ko kp kq kr b">src</code>是包含您所有要转换的<code class="fe ko kp kq kr b">JavaScript</code>或<code class="fe ko kp kq kr b">TypeScript</code>文件的文件夹。</p><h2 id="5be1" class="mr ku it bd kv mw mx dn kz my mz dp ld kb na nb lh kf nc nd ll kj ne nf lp ng bi translated">定义一个转换函数</h2><p id="50b3" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">换句话说，我们需要将所有的转换逻辑放到<code class="fe ko kp kq kr b">transform</code>中。本质上<code class="fe ko kp kq kr b">transform</code>是一个具有某种特征的函数:</p><pre class="lx ly lz ma gt mn kr mo mp aw mq bi"><span id="d313" class="mr ku it kr b gy ms mt l mu mv">import { Transform } from "jscodeshift";<br/>​<br/>const transform: Transform = (file, api, options) =&gt; {<br/>  //...<br/>};<br/>​<br/>export default transform;</span></pre><p id="2090" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ko kp kq kr b">file</code>有解析过的文件对象，<code class="fe ko kp kq kr b">api</code>是<code class="fe ko kp kq kr b">jscodeshift</code> API对象的处理程序，你可以用它来搜索，变异一个解析过的文件对象。<code class="fe ko kp kq kr b">options</code>然后是一个可选参数，可以用来传递其他选项(如最终结果的格式)到转换。在函数体中，我们可以使用<code class="fe ko kp kq kr b">jscodeshift</code>的API来操纵AST进行修改。</p><p id="ede9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">整个过程非常类似于使用<code class="fe ko kp kq kr b">DOM</code>API来改变网页上的元素:通过一些属性(css类名或HTML id)来查找元素，然后对搜索结果进行一些处理。只有在这里你改变的对象是<code class="fe ko kp kq kr b">Statement</code>、<code class="fe ko kp kq kr b">Function</code>或<code class="fe ko kp kq kr b">Condition</code> s</p><p id="3bd5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们进入具体的API之前，让我们看一下AST。这将是我们在本文剩余部分的主要关注点。</p><h2 id="e6b5" class="mr ku it bd kv mw mx dn kz my mz dp ld kb na nb lh kf nc nd ll kj ne nf lp ng bi translated">抽象语法树</h2><p id="e824" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">简而言之，AST是编译过程中解析短语之后的中间对象。我们的源代码被解析为<code class="fe ko kp kq kr b">Token</code>,然后<code class="fe ko kp kq kr b">Token</code>被解析为语法，然后是树。因此，如果你使用像<a class="ae mm" href="https://astexplorer.net/" rel="noopener ugc nofollow" target="_blank"> AST Explorer </a>这样的工具来检查你的代码，你可以实时看到这棵树。</p><p id="b3b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，我们的片段:</p><pre class="lx ly lz ma gt mn kr mo mp aw mq bi"><span id="9537" class="mr ku it kr b gy ms mt l mu mv">import Button from '@fancylib/button';<br/>​<br/>const app = () =&gt; (<br/>    &lt;Button isInLoadingStatus&gt;Click me&lt;/Button&gt;<br/>)</span></pre><p id="3624" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解析后会出现类似右边面板上的树的东西。所有的元素都有一个类型和它的值。比如<code class="fe ko kp kq kr b">isInLoadingStatus</code>被识别为类型<code class="fe ko kp kq kr b">JSXIdentifier</code>，变量<code class="fe ko kp kq kr b">app</code>被识别为<code class="fe ko kp kq kr b">VariableDeclarator</code>等等。所有这些有效的元素都将是一棵树的一个节点。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nw"><img src="../Images/9bf51e969698cd89bfd55bc17e3e636a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*grTejdLtusPD3-tzsxGDLQ.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">AST浏览器</figcaption></figure><p id="7c1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在你应该对AST有了一个基本的了解，让我们进入<code class="fe ko kp kq kr b">transform</code>函数。您实际上可以使用来自<a class="ae mm" href="https://astexplorer.net/" rel="noopener ugc nofollow" target="_blank"> AST Explorer </a>的IDE来做一些快速调试和测试(注意这里我们使用<code class="fe ko kp kq kr b">jscodeshift</code>作为转换器):</p><p id="eb03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们可以定义<code class="fe ko kp kq kr b">transform</code>函数如下:</p><pre class="lx ly lz ma gt mn kr mo mp aw mq bi"><span id="dc8e" class="mr ku it kr b gy ms mt l mu mv">// Press ctrl+space for code completion<br/>export default function transformer(file, api) {<br/>  const j = api.jscodeshift;<br/>​<br/>  return j(file.source)<br/>    .find(j.JSXIdentifier)<br/>    .forEach(path =&gt; {<br/>      if(path.node.name === "isInLoadingStatus") {<br/>          j(path).replaceWith(<br/>            j.identifier('loading')<br/>          )<br/>        }<br/>    })<br/>    .toSource();<br/>}</span></pre><p id="0a09" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，它会找到所有的<code class="fe ko kp kq kr b">JSXIdentifier</code>并遍历它们中的每一个，如果值是<code class="fe ko kp kq kr b">isInLoadingStatus</code>，我们将其更改为<code class="fe ko kp kq kr b">loading</code>。注意右下角的结果:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nw"><img src="../Images/bce16d775a50b6729d088c3ad27ea68d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KAifHYYWs2dZHGzvXT0MXw.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">使用AST Explorer作为调试的IDE</figcaption></figure><h2 id="ca6d" class="mr ku it bd kv mw mx dn kz my mz dp ld kb na nb lh kf nc nd ll kj ne nf lp ng bi translated">测试驱动开发</h2><p id="475f" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">此外，作为一个严肃的开发者，我们在大多数情况下不应该依赖在线IDE。幸运的是,<code class="fe ko kp kq kr b">jscodeshift</code>和<code class="fe ko kp kq kr b">jest</code>可以完美地一起工作，这也是在编写转换时应用测试驱动开发的一个极好的场景，因为:</p><ul class=""><li id="77bf" class="ni nj it js b jt ju jx jy kb nk kf nl kj nm kn nn no np nq bi translated">投入和产出都是确定的</li><li id="8ac5" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated">大多数用法(消费者如何使用您的代码)也很容易编写</li><li id="ac3e" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated">每一步都可以被很好地定义并且很小</li></ul><p id="2ac4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并且<code class="fe ko kp kq kr b">jscodeshift</code>在<code class="fe ko kp kq kr b">jscodeshift/dist/testUtils</code>中提供了一些助手，所以你可以非常容易地定义一个测试用例:</p><pre class="lx ly lz ma gt mn kr mo mp aw mq bi"><span id="e806" class="mr ku it kr b gy ms mt l mu mv">import { defineInlineTest } from 'jscodeshift/dist/testUtils';<br/>import transformer from './transformer';<br/>​<br/>describe('transformer', () =&gt; {<br/>  defineInlineTest(<br/>    { default: transformer, parser: 'tsx' }, <br/>    {},<br/>    `<br/>    import Button from '@fancylib/button';<br/>  <br/>    export default () =&gt; (<br/>      &lt;Button isInLoadingStatus&gt;Click me&lt;/Button&gt;<br/>    );<br/>    `,<br/>    `<br/>    import Button from '@fancylib/button';<br/>  <br/>    export default () =&gt; (<br/>      &lt;Button loading&gt;Click me&lt;/Button&gt;<br/>    );<br/>    `,<br/>    'change isInLoadingStatus to loading'<br/>  );<br/>});</span></pre><p id="cb61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你对字符串模板不太适应，它也支持基于文件的测试，这样你可以为更复杂的情况定义<code class="fe ko kp kq kr b">input</code>和<code class="fe ko kp kq kr b">output</code>到文件中。</p><p id="b4f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">向前看，我们不想用<code class="fe ko kp kq kr b">transform</code>去换一个不属于我们图书馆的<code class="fe ko kp kq kr b">Button</code>。例如，另一个库中有<code class="fe ko kp kq kr b">Button</code>，而<code class="fe ko kp kq kr b">Button</code>也有一个<code class="fe ko kp kq kr b">isInLoadingStatus</code>道具。</p><p id="ef2a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要一个测试用例来确保我们不会意外地改变它:</p><pre class="lx ly lz ma gt mn kr mo mp aw mq bi"><span id="46b6" class="mr ku it kr b gy ms mt l mu mv">defineInlineTest(<br/>    { default: transformer, parser: 'tsx' }, <br/>    {},<br/>    `<br/>    import Button from '@facebook/button';<br/>  <br/>    export default () =&gt; (<br/>      &lt;Button isInLoadingStatus&gt;Click me&lt;/Button&gt;<br/>    );<br/>    `,<br/>    `<br/>    import Button from '@facebook/button';<br/>  <br/>    export default () =&gt; (<br/>      &lt;Button isInLoadingStatus&gt;Click me&lt;/Button&gt;<br/>    );<br/>    `,<br/>    'should not change isInLoadingStatus to loading from other package'<br/>  );</span></pre><p id="c473" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相应的逻辑是:</p><pre class="lx ly lz ma gt mn kr mo mp aw mq bi"><span id="b46e" class="mr ku it kr b gy ms mt l mu mv">// Press ctrl+space for code completion<br/>export default function transformer(file, api) {<br/>  const j = api.jscodeshift;<br/>  const root = j(file.source);<br/>​<br/>  const specifiers = root<br/>    .find(j.ImportDeclaration)<br/>    .filter((path) =&gt; path.node.source.value === "@fancylib/button")<br/>    .find(j.ImportDefaultSpecifier);<br/>​<br/>  if (specifiers.length === 0) {<br/>    return;<br/>  }<br/>  <br/>  //...<br/>}</span></pre><p id="30b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也就是说，我们首先搜索所有的<code class="fe ko kp kq kr b">import</code>语句，过滤掉那些不感兴趣的。您可能已经注意到，我们有一堆像<code class="fe ko kp kq kr b">j.ImportDeclaration</code>和<code class="fe ko kp kq kr b">j.ImportDefaultSpecifier</code>这样的常量，是的，它们正是来自AST Explorer的标记名。</p><p id="f673" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个过程或多或少类似于我们使用DOM API所做的事情:</p><pre class="lx ly lz ma gt mn kr mo mp aw mq bi"><span id="5135" class="mr ku it kr b gy ms mt l mu mv">document.querySelectorAll('a')<br/>    .filter(anchor =&gt; anchor.classList.includes('button'))<br/>    .forEach(anchor =&gt; anchor.style["text-decoration"] = "underline")</span></pre><p id="1dd6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ks">如果您发现这里有太多活动部件，不要惊慌，开始时感到有些力不从心是完全正常的</em></p><p id="b087" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">恐怕把所有的代码都放在一篇文章里会太无聊，所以我就不在这里贴代码片段了，你可以从这里找到<a class="ae mm" href="https://github.com/abruzzi/codemod-demo" rel="noopener ugc nofollow" target="_blank">一切。</a></p><h2 id="3105" class="mr ku it bd kv mw mx dn kz my mz dp ld kb na nb lh kf nc nd ll kj ne nf lp ng bi translated">潜在的陷阱</h2><p id="0bac" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">当你厌倦了对不同版本的组件做无休止的修补时，在任何地方使用<code class="fe ko kp kq kr b">jscodeshift</code>都是非常诱人的。但我需要诚实地说，它有一些缺点。</p><p id="4b46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，虽然它简化了底层的API，但是<code class="fe ko kp kq kr b">jscodeshift</code>API本身有点麻烦，而且它有一个相对陡峭的学习曲线。一个<code class="fe ko kp kq kr b">transform</code>的开发过程中会有很多调试。另外，如果你想让<code class="fe ko kp kq kr b">transform</code>涵盖所有场景，有些情况下成本太高。最后，当一个组件有许多版本时，对于每个主要版本，如果你有一个<code class="fe ko kp kq kr b">transform</code>的话，如果有人想从一个非常旧的版本升级到最新的版本将会很棘手。将会有一些版本控制等等来确保所有的<code class="fe ko kp kq kr b">transform</code>可以被等幂地应用。</p><h1 id="33e3" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">摘要</h1><p id="3c2a" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">在本文中，通过一个过于简化的例子，我们介绍了在日常工作中需要自动迁移组件时为什么以及如何使用<code class="fe ko kp kq kr b">jscodeshift</code>。我们讨论了AST和<code class="fe ko kp kq kr b">jscodeshift</code>的基础知识，以及如何在开发过程中使用AST Explorer进行辅助。</p><h1 id="4d63" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">参考</h1><ul class=""><li id="b772" class="ni nj it js b jt lr jx ls kb nx kf ny kj nz kn nn no np nq bi translated">【React发布的一些代码模块</li><li id="59bd" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated"><a class="ae mm" href="https://astexplorer.net/" rel="noopener ugc nofollow" target="_blank"> AST探险家</a></li><li id="eab4" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated"><a class="ae mm" href="https://github.com/abruzzi/codemod-demo" rel="noopener ugc nofollow" target="_blank">本帖中提到的源代码</a></li><li id="2e91" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated"><a class="ae mm" href="https://skovy.dev/jscodeshift-custom-transform/" rel="noopener ugc nofollow" target="_blank">jscodeshift的另一个详细教程</a></li></ul></div></div>    
</body>
</html>