<html>
<head>
<title>12 Powerful Principles for Robust React Apps (Industry Secrets Revealed!)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">强大的React应用程序的12个强大原则(行业机密泄露！)</h1>
<blockquote>原文：<a href="https://itnext.io/12-powerful-principles-for-robust-react-apps-industry-secrets-revealed-16a2a0159e11?source=collection_archive---------3-----------------------#2020-06-24">https://itnext.io/12-powerful-principles-for-robust-react-apps-industry-secrets-revealed-16a2a0159e11?source=collection_archive---------3-----------------------#2020-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3e03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是交易。这不是一个关于在哪里放置分号<code class="fe kl km kn ko b">;</code>或者如何分配数组<code class="fe kl km kn ko b">[]</code>的深度风格指南，这是一个简短而实用的顶级指南，可以快速地在代码库的可读性、可伸缩性和可靠性方面获得巨大的改进。为所有技能水平编写。这是用React Native编写的...但是它可以扩展到React应用程序。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/baad672a09f6c1d949c97548b690c946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_0ocihP2CN9_jMSbH-hXYg.jpeg"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">照片由<a class="ae lf" href="https://unsplash.com/@felixrstg?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">菲利克斯·罗斯蒂格</a>在<a class="ae lf" href="/s/photos/friends?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="7aa3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你有一个现有的项目，这些原则并不需要在一次大的重构中完成，相反，它们是指路明灯，可以随着时间的推移应用到你自己的实践和惯例中。</p><h1 id="c224" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">1.按类型划分的扁平结构</h1><p id="fcac" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">react本机应用程序的结构应该按类型划分。以下是一个可扩展的示例结构:</p><pre class="kq kr ks kt gt mj ko mk ml aw mm bi"><span id="bccb" class="mn lh iq ko b gy mo mp l mq mr">/components<br/>    /tests<br/>    /styles<br/>       my-component-style.js<br/>    my-component.js</span><span id="bb13" class="mn lh iq ko b gy ms mp l mq mr">/pages<br/>    /tests<br/>	  /styles<br/>       home-page-style.js<br/>    home-page-style.js</span><span id="244e" class="mn lh iq ko b gy ms mp l mq mr">/utils<br/>   alert-with-exit-app.js<br/>   get-distance-between-points.js<br/>   set-android-icon.js<br/>   use-component-size.js</span><span id="dabe" class="mn lh iq ko b gy ms mp l mq mr">/config<br/>   images.js<br/>   main-tab-strings.js<br/>   debug-config.js</span><span id="7e09" class="mn lh iq ko b gy ms mp l mq mr">/theme<br/>   metrics.js<br/>   global-styles.js</span></pre><p id="818a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，这种结构是可扩展的。“/theme”文件夹中的文件也可以移动到“/config”文件夹中。对于“/utils”文件夹也是如此，如果您有200个包含自定义react挂钩的文件，您可以创建一个名为“/hooks”的新文件夹。</p><p id="251b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">建议您不要超出两个文件夹来拆分组件，即使您有数千个组件(<strong class="jp ir">开发人员不通过文件夹搜索，他们使用热键和搜索</strong>)，这是因为这些文件夹有'/styles '和'/tests '的子文件夹，创建更多的文件夹是额外的开销。</p><p id="9d46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的示例将组件分为“/pages”和“/components”，以提供应用程序的高级概述。每个根页面都可以通过“/pages”文件夹访问。确保每个根页面都加上<code class="fe kl km kn ko b">-page</code>或<code class="fe kl km kn ko b">-screen</code>的后缀。对于较小的应用程序，您可以将页面放入“/components”文件夹并删除“/pages”...但是当应用程序变大时，对应用程序的结构和可用页面有一个高层次的概述是很有用的。</p><blockquote class="mt mu mv"><p id="99b4" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated"><em class="iq">为什么？当试图对新组件进行分类时，通过域划分特性会产生开销，从而导致摩擦。对于大多数项目来说，按类型划分是最好的方法。</em></p></blockquote><p id="78c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">关于</strong> <strong class="jp ir"> Index.js导出的说明</strong></p><p id="c2b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用平面结构时，不需要使用绝对导入。扁平结构与相对导入配合得很好…绝对导入破坏了IDE智能。您应该考虑在每个文件夹中使用一个<code class="fe kl km kn ko b">index.js</code>，例如'/components '，'/utils '等。这允许您用一条语句导出和导入文件:</p><pre class="kq kr ks kt gt mj ko mk ml aw mm bi"><span id="4041" class="mn lh iq ko b gy mo mp l mq mr">import {<br/>  alertWithExitApp,<br/>  getDistanceBetweenPoints,<br/>  useComponentSize<br/>} from "../utils";</span></pre><p id="e46d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这确实需要一些额外的开销来维护<code class="fe kl km kn ko b">index.js</code>文件中的导出，但是简化导入的好处通常会超过维护开销。</p><h1 id="ce6d" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">2.每个文件一次导出</h1><p id="35c3" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">每个功能和组件都应该被分割成单独的文件。与上面的配置和主题文件夹相同，每个文件应该只包含一个对象配置。例如，<code class="fe kl km kn ko b">images.js</code>包含一个需要所有应用程序图像的对象。每个文件应与导出的功能、组件或配置的名称相匹配，例如<code class="fe kl km kn ko b">function getDistanceBetweenPoints</code>应在文件名<code class="fe kl km kn ko b">get-distance-between-points.js</code>中。</p><p id="7eec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想提供点符号API。例如，自定义控制台api。警告，。要做到这一点，您可以从您的文件中导出<code class="fe kl km kn ko b">customConsole</code>，它将是一个具有各种功能的对象:</p><pre class="kq kr ks kt gt mj ko mk ml aw mm bi"><span id="70fe" class="mn lh iq ko b gy mo mp l mq mr">export const customConsole = {<br/>   log: () =&gt; ...,<br/>   warn: () =&gt; ...,<br/>   error: () =&gt; ...,<br/>}</span></pre><blockquote class="mt mu mv"><p id="d444" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated"><em class="iq">为什么？这使得代码库在查找组件、函数和对象时更容易导航。当文件遵循详细的命名约定时，它还减少了重复代码的机会。</em></p></blockquote><h1 id="031b" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">3.使用命名导出</h1><p id="352b" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">将所有功能、组件和配置导出为命名导出。如<code class="fe kl km kn ko b">import { MyComponent } from "./components/MyComponent"</code>。不是默认。</p><blockquote class="mt mu mv"><p id="e8a3" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated"><em class="iq">为什么？导出命名导出会阻止相同的函数、组件和配置在您的代码库中获取不同的名称，从而降低复杂性和开销。</em></p></blockquote><h1 id="562d" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">4.始终使用功能部件(从React 16.8开始)</h1><p id="9295" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">随着React 16.8中钩子的引入，你应该总是使用带有钩子的功能组件而不是类组件。</p><blockquote class="mt mu mv"><p id="69a0" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated"><em class="iq">为什么？</em></p><p id="dac9" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">在一个函数组件中，你可以声明你的变量、进程属性，并声明一次外部状态，然后在你的组件中使用它，而不必将这些值绑定到组件或状态。</p><p id="4895" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">因为没有考虑将函数绑定到上下文“this”和生命周期方法的开销，所以复杂性更低。</p></blockquote><h1 id="d64d" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">5.在同一位置声明组件变量</h1><p id="7276" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">组件级状态和变量应该总是在功能组件的顶部声明。注释可以用来分隔普通的变量组，以提高可读性，但这不是必须的。下面是一个真实的例子:</p><pre class="kq kr ks kt gt mj ko mk ml aw mm bi"><span id="8817" class="mn lh iq ko b gy mo mp l mq mr">const EditProfileScreen = ({ componentId }) =&gt; {<br/>  /** Redux */<br/>  const isBiometricByDefault = useSelector(state =&gt; getIsBiometricByDefault(state));<br/>  const { <br/>		isLoading: isSubmitting, <br/>		errors <br/>	} = useSelector(state =&gt; getNetworkRequestByType(state, UPDATE_USER_REQUEST));<br/>  const {<br/>    authToken,<br/>    name,<br/>    email,<br/>    birthday,<br/>    mobile,<br/>    marketingEmails,<br/>    postcode<br/>  } = useSelector(state =&gt; getUser(state));<br/>  const dispatch = useDispatch();<br/>  /** Hooks */<br/>  const formikRef = useRef(null);<br/>  const [biometricType, biometricTypeAsString] = useBiometricType();<br/>  const [confirmPasswordError, setConfirmPasswordError] = useState(false);<br/>  /** Variables */<br/>  const firstName = getFirstNameFromName(name);<br/>  const lastName = getLastNameFromName(name);<br/>  const mobilePrefix = getMobilePrefixFromString(mobile);<br/>  const mobileNumber = getMobileNumberFromString(mobile);<br/>  /** Effects */<br/>  useEffect(() =&gt; ...</span></pre><blockquote class="mt mu mv"><p id="d2ed" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated"><em class="iq">为什么？这停止了跨大型组件的变量的重新声明，并通过给出所有数据和处理需求以及该组件的顶层概述来帮助减少代码。</em></p></blockquote><h1 id="c1ac" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">6.将回调提取到嵌套函数中</h1><p id="e0da" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">您的<code class="fe kl km kn ko b">useEffects</code>和组件(例如<code class="fe kl km kn ko b">&lt;MyComponent onPress={...}</code>)中的回调应该提取到组件底部的函数中:</p><pre class="kq kr ks kt gt mj ko mk ml aw mm bi"><span id="cd4d" class="mn lh iq ko b gy mo mp l mq mr">useEffect(() =&gt; onFirstNameChanged(), [firstName])</span><span id="fd34" class="mn lh iq ko b gy ms mp l mq mr">return (<br/>	 &lt;MyComponent onPress={onPressMyComponent}<br/>   ...</span><span id="6379" class="mn lh iq ko b gy ms mp l mq mr">function onPressMyComponent() ...<br/>function onFirstNameChanged() ...</span></pre><blockquote class="mt mu mv"><p id="6530" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated"><em class="iq">为什么？这保持了组件的组织性和可读性。就像把你的衣服放在你的衣柜里一样，你不能把所有的东西都扔在地板上…不要对你的应用程序做同样的事情。</em></p></blockquote><h1 id="b876" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">7.不要将组件嵌套在组件中</h1><p id="d1ac" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">当将较大的组件分割成较小的部分时，使用<code class="fe kl km kn ko b">&lt;Components /&gt;</code>而不是渲染函数，例如<code class="fe kl km kn ko b">renderComponent</code>。这个非常简单...不要将JSX放在变量或函数中进行条件渲染。使用具有描述性名称的组件。</p><p id="17cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">renderBottomFooterConditions() { ...</code> ❌</p><p id="4d91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">my-component-bottom-footer-conditions.js -&gt; &lt;MyComponentBottomFooterConditions</code> ✅</p><p id="cd56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用“渲染”功能是避开“2。“每个文件一次导出”原则…</p><p id="f06f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我明白你在做什么👀我对此不以为然。</p><blockquote class="mt mu mv"><p id="cfa8" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated"><em class="iq">为什么？与组成成分反应。当某个东西足够复杂，以至于内联JSX三元组不够用，额外的处理和复杂的条件要求它被提取到自己的函数中时，只需创建一个新的组件。</em></p></blockquote><h1 id="d5c8" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">8.展平组件道具</h1><p id="e15d" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">在大多数情况下，在通过props将对象传递给组件之前，先将其展平。在某些情况下，您可能希望将一个对象作为组件属性进行传递，例如<em class="mw">“您有一组公共的数据处理逻辑，需要在应用程序的多个地方发生… </em> <a class="ae lf" href="https://medium.com/@lukebrandonfarrell/component-composition-for-dummies-cd94515a360e" rel="noopener"> <em class="mw">参见示例</em></a><em class="mw">”</em>。在使用带有JavaScript的类型系统(如TypeScript)时，这一原则可以更加灵活……仍然建议将道具扁平化。</p><blockquote class="mt mu mv"><p id="b288" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated"><em class="iq">为什么？</em></p><p id="9e63" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">使用对象比使用单值变量更复杂，也更容易出错；布尔值，数字，字符串。</p><p id="9812" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">将一个对象传递给一个组件会将它耦合到那个对象数据结构，在大多数情况下，您希望您的组件比这更灵活。</p></blockquote><h1 id="16ca" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">9.将样式与组件分开</h1><p id="9e90" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">样式应该被分离到一个单独的文件中。按照这个指南，你的样式必须存在于组件文件夹根级的<code class="fe kl km kn ko b">/styles</code>文件夹中。如果您使用多个文件夹来分割组件(如组件/容器)，则每个文件夹都有一个单独的样式文件夹。</p><blockquote class="mt mu mv"><p id="846f" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated"><em class="iq">为什么？分离样式增加了组件代码的可读性，并促进了样式在应用程序中的重用。</em></p></blockquote><h1 id="c045" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">10.遵循命名约定</h1><p id="1959" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">遵循项目的命名约定，您可以有自己的命名约定，但这里是默认约定:</p><ul class=""><li id="ec40" class="na nb iq jp b jq jr ju jv jy nc kc nd kg ne kk nf ng nh ni bi translated">文件和文件夹名称应该用kebab-case: <code class="fe kl km kn ko b">my-new-component.js</code></li><li id="7e44" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">在组件之外声明的常量应该是开始用例:<code class="fe kl km kn ko b">IconSources</code></li><li id="292b" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">导入到组件中的图像应该是开始案例:<code class="fe kl km kn ko b">import ArrowImage from 'assets/arrow.png';</code></li><li id="4de3" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">函数应该用camel-case编写:<code class="fe kl km kn ko b">getDistanceBetweenPoints</code></li><li id="8a88" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">组件中的变量和函数应该是骆驼形状:<code class="fe kl km kn ko b">const activeBrandId ...</code></li><li id="f8f2" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">组件应使用起始名称命名:<code class="fe kl km kn ko b">&lt;MyComponent /&gt;</code></li><li id="aca5" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">来自第三方库的默认和命名导入应该遵循项目命名约定:<code class="fe kl km kn ko b">import { SetPlatformIcon: setPlatformIcon } from 'rn-native-icon'</code></li></ul><blockquote class="mt mu mv"><p id="4f51" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated"><em class="iq">为什么？保持一切整洁— </em>玛丽·近藤</p></blockquote><h1 id="f3a9" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">10.使用描述性命名</h1><p id="9f2d" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">变量名和函数名应该是描述性的，而不是一般性的:</p><p id="6b61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">let messageForTheWarningBanner = messages?.message_for_banner</code> ✅</p><p id="dc1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">let message = messages?.message_for_banner</code> ❌</p><p id="1855" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解构的进一步示例:</p><pre class="kq kr ks kt gt mj ko mk ml aw mm bi"><span id="20a7" class="mn lh iq ko b gy mo mp l mq mr">const { name: companyName } = useSelector(state =&gt; getOrganisation(state));<br/>const { email: currentEmail } = useSelector(state =&gt; getUser(state));</span></pre><blockquote class="mt mu mv"><p id="d80d" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated"><em class="iq">为什么？它使代码更容易理解。</em></p></blockquote><h1 id="a635" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">评论</h1><p id="106d" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">“我们是如何”和“为什么”来到这里的！？</p><p id="82e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请…评论你的代码。如果你不注释你的代码，那么下面解释如何注释代码。注释极大地增加了项目的健壮性，不注释代码就像卖一本没有说明的“自己构建”书架。</p><h1 id="6768" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">11.解释“为什么”,而不是“如何”</h1><p id="4c1c" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">注释用于解释代码背后的“为什么”。“如何做”可以从代码中推断出来。谈谈你选择编写这部分代码的原因。下面是一个真实应用程序中单个变量的注释:</p><pre class="kq kr ks kt gt mj ko mk ml aw mm bi"><span id="1508" class="mn lh iq ko b gy mo mp l mq mr">/**<br/> * Used so the rebrand alert does not appear multiple times,<br/> * as if the user exits the app, this will trigger new user data<br/> * to be fetched, which will trigger new organisation data to be<br/> * fetched, which will lead to multiple FETCH_ORGANISATION_RESPONSE<br/> * and multiple instances of this generator function waiting at<br/> * `call(waitUntilStack...`.<br/> */<br/>let isRebrandAlertShowed = false;</span></pre><blockquote class="mt mu mv"><p id="94d4" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated"><em class="iq">为什么？“如何”可以从代码中推断出来……而“为什么”却永远消失了。</em></p></blockquote><h1 id="923f" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">12.用注释分解程序流</h1><p id="92a8" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">注释可以用来分解程序的控制流，使其更具可读性。注意:在适用的情况下，应使用“为什么”注释，这些注释“有助于如何做”，但不能代替“为什么”:</p><pre class="kq kr ks kt gt mj ko mk ml aw mm bi"><span id="0a02" class="mn lh iq ko b gy mo mp l mq mr">// Used to close the array in our JavaScript file<br/>iconsJavascriptContent = iconsJavascriptContent + "]";</span><span id="e221" class="mn lh iq ko b gy ms mp l mq mr">// We use object assign, this takes the existing icons, our primary icon, and icons folder and updates them<br/>plistObject["CFBundleIcons"]["CFBundleAlternateIcons"] = <br/>    Object.assign(plistObject["CFBundleIcons"]["CFBundleAlternateIcons"], PRIMARY_ICON, icons);</span><span id="b0d8" class="mn lh iq ko b gy ms mp l mq mr">// Build the plist object back into an XML list<br/>const result = plist.build(plistObject);</span><span id="cbbd" class="mn lh iq ko b gy ms mp l mq mr">// Write the modified plist file back to source<br/>try {<br/>    fs.writeFileSync(PLIST_PATH, result);<br/>    terminal.white(`\\n The plist file ${PLIST_PATH} was updated with new app icons. \\n`);<br/>} catch(e) {<br/>    return terminal.red(err);<br/>}</span><span id="36ad" class="mn lh iq ko b gy ms mp l mq mr">// Write to the JavaScript file used in the app to keep track of our active icons<br/>try {<br/>    fs.writeFileSync(JS_FILE_PATH, iconsJavascriptContent);<br/>} catch(e) {<br/>    return terminal.red(err);<br/>}</span></pre><blockquote class="mt mu mv"><p id="da7c" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated"><em class="iq">为什么？为经验不足、不能立即理解“如何做”的开发人员增加可读性。</em></p></blockquote></div></div>    
</body>
</html>