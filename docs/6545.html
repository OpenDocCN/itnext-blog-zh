<html>
<head>
<title>Using Git submodules to streamline Node.js package development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Git子模块简化Node.js包开发</h1>
<blockquote>原文：<a href="https://itnext.io/using-git-submodules-to-streamline-node-js-package-development-d3b358abab0e?source=collection_archive---------1-----------------------#2021-12-14">https://itnext.io/using-git-submodules-to-streamline-node-js-package-development-d3b358abab0e?source=collection_archive---------1-----------------------#2021-12-14</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj jr"><img src="../Images/acc742a1bf82cff467a7a2b0aff938de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nCkL2r4TFcZwFVuM.jpg"/></div></div></figure><p id="4d5b" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><strong class="ke iv">在开发Node.js包时，我们通常会创建一个测试应用程序来测试这个包。这意味着对于包中的每个源代码更改，我们必须将包重新安装到测试应用程序的<em class="la"> node_modules </em>目录中，这可能会非常令人沮丧。Git的子模块特性可以简化这一过程，让您直接编辑测试应用程序和包，而不需要重新安装。</strong></p><p id="714e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">开始之前，我们先回顾一下情况。假设我们正在开发一个名为<code class="fe lb lc ld le b">P</code>的包。这是一个很好的小图书馆，可以做一些有用的事情。稍后我们将使用一个人工示例包。为了开发这个包，编写一个程序(或者两三个)来测试这个包通常是有帮助的。我说的不是测试套件，而是真正的程序。</p><p id="dac5" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在我的例子中，正在开发的应用程序是AkashaCMS，一个静态网站生成器。AkashaCMS生态系统中有几个包。他们中的大多数在包中有单元测试，但是我也创建了几个用于功能测试的示例网站。</p><p id="eb52" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">其中之一是<a class="ae lf" href="https://github.com/akashacms/akashacms-example" rel="noopener ugc nofollow" target="_blank"> akashacms-example网站</a>，它既是akashacms项目的工作示例，也是我开发AkashaCMS功能的功能测试。项目已经被重新设计，使用子模块来简化包的开发。</p><p id="586d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">换句话说，<code class="fe lb lc ld le b">akashacms-example</code>是一个可以实施我们一揽子计划的例子。</p><p id="11df" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">一般来说，<code class="fe lb lc ld le b">A</code>应用程序必须将<code class="fe lb lc ld le b">P</code>安装在它的<code class="fe lb lc ld le b">node_modules</code>目录中。然后我们可以编辑<code class="fe lb lc ld le b">A</code>的代码来尝试<code class="fe lb lc ld le b">P</code>中的功能。但是，如果/当我们必须改变<code class="fe lb lc ld le b">P</code>中的代码时，会发生什么呢？</p><p id="5e6d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">正常情况下，我们会打开两个编辑器窗口，一个指向<code class="fe lb lc ld le b">P</code>中的文件，另一个指向<code class="fe lb lc ld le b">A</code>。一旦我们在<code class="fe lb lc ld le b">P</code>中编辑了一个文件，我们必须将更改后的文件复制到<code class="fe lb lc ld le b">A/node_modules/P</code>中。过了一段时间，这变得很乏味，当然有时我们会忘记更新<code class="fe lb lc ld le b">A</code>中的文件，然后想知道为什么我们在代码中所做的改变没有改变任何行为。</p><p id="17af" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">有一个npm命令<code class="fe lb lc ld le b">npm link</code>，它的意思是简化这个问题。顾名思义，它<em class="la">将</em>包<code class="fe lb lc ld le b">P</code>链接到应用程序的<code class="fe lb lc ld le b">node_modules</code>目录中。然后我们可以自由编辑<code class="fe lb lc ld le b">P</code>和<code class="fe lb lc ld le b">A</code>，而不需要从<code class="fe lb lc ld le b">P</code>到<code class="fe lb lc ld le b">A</code>重新安装文件。但是，当我阅读<code class="fe lb lc ld le b">npm link</code>文档时，它令人困惑，我从来没有这样做过。</p><h1 id="3914" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">Git子模块和Node.js开发</h1><p id="565d" class="pw-post-body-paragraph kc kd iu ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz in bi translated">相反，我发现Git子模块更加直接。关于子模块入门的完整教程:<a class="ae lf" href="https://techsparx.com/software-development/git/submodules.html" rel="noopener ugc nofollow" target="_blank">如何以及为什么使用Git子模块</a></p><p id="141c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">简言之，Git子模块是:</p><ul class=""><li id="5154" class="mj mk iu ke b kf kg kj kk kn ml kr mm kv mn kz mo mp mq mr bi translated">父Git储存库包含引用一个或多个其他Git储存库的子模块配置</li><li id="1654" class="mj mk iu ke b kf ms kj mt kn mu kr mv kv mw kz mo mp mq mr bi translated">外部存储库出现在签出的父存储库的目录树中</li><li id="66f2" class="mj mk iu ke b kf ms kj mt kn mu kr mv kv mw kz mo mp mq mr bi translated">父存储库包含对外部存储库的引用，以及要签出的提交的SHA-1散列</li></ul><p id="8d9a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这个特性似乎最适合支持包开发。即，</p><ul class=""><li id="7747" class="mj mk iu ke b kf kg kj kk kn ml kr mm kv mn kz mo mp mq mr bi translated">在<code class="fe lb lc ld le b">A</code>的存储库中，将其配置为嵌入<code class="fe lb lc ld le b">P</code>存储库作为子模块</li><li id="d0a5" class="mj mk iu ke b kf ms kj mt kn mu kr mv kv mw kz mo mp mq mr bi translated"><code class="fe lb lc ld le b">A</code>应该是测试应用程序</li><li id="d3a8" class="mj mk iu ke b kf ms kj mt kn mu kr mv kv mw kz mo mp mq mr bi translated">在<code class="fe lb lc ld le b">A</code>的<code class="fe lb lc ld le b">package.json</code>中，我们使用一个本地文件引用作为<code class="fe lb lc ld le b">P</code>的<code class="fe lb lc ld le b">dependency</code>——使npm在<code class="fe lb lc ld le b">node_modules</code>中创建一个到<code class="fe lb lc ld le b">P</code>目录的符号链接</li></ul><p id="8670" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这是计划，所以让我们做它。</p><h1 id="fc65" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">创建两个存储库</h1><p id="9054" class="pw-post-body-paragraph kc kd iu ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz in bi translated">在GitHub/GitLab/Gitea/etc中创建两个存储库，一个用于应用程序，另一个用于包。为此，我们创建了两个:</p><p id="c439" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">首先，我们克隆<code class="fe lb lc ld le b">sample-app</code>存储库:</p><pre class="mx my mz na gu nb le nc nd aw ne bi"><span id="3873" class="nf lh iu le b gz ng nh l ni nj">$ git clone git@github.com:robogeek/sample-app-2021-12-12.git <br/>... <br/>$ git submodule init <br/>$ git submodule add \<br/>     https://github.com/robogeek/sample-package-2021-12-12.git \<br/>     package <br/>Cloning into '.../sample-app-2021-12-12/package'... <br/>remote: Enumerating objects: 4, done. <br/>remote: Counting objects: 100% (4/4), done. <br/>remote: Compressing objects: 100% (4/4), done. <br/>remote: Total 4 (delta 0), reused 0 (delta 0), pack-reused 0 <br/>Receiving objects: 100% (4/4), done. <br/>$ git submodule update --recursive --remote --checkout</span></pre><p id="d258" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们将展示存储库是如何初始化的。当您看到这篇文章时，存储库已经完全设置好了，并且可以运行了。无论如何，我们从一个空白存储库开始，我们做的第一件事是使用<code class="fe lb lc ld le b">git submodule add</code>引入<code class="fe lb lc ld le b">sample-package</code>存储库。</p><p id="e71f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">让我们从在<code class="fe lb lc ld le b">sample-package</code>存储库中设置一个简单的包开始:</p><pre class="mx my mz na gu nb le nc nd aw ne bi"><span id="1a3a" class="nf lh iu le b gz ng nh l ni nj">$ cd package <br/>$ npm init -y <br/>... <br/>$ git add package.json  <br/>$ git commit -m 'Initial revision' package.json  <br/>[main 4a14cf6] Initial revision <br/> 1 file changed, 12 insertions(+) <br/> create mode 100644 package.json</span></pre><p id="6be7" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这将创建一个包含默认<code class="fe lb lc ld le b">package.json</code>的空白Node.js项目。默认情况下，它支持CommonJS模块，并将<code class="fe lb lc ld le b">index.js</code>指定为<code class="fe lb lc ld le b">main</code>模块。因此，让我们创建一个名为<code class="fe lb lc ld le b">index.js</code>的文件，其中包含:</p><pre class="mx my mz na gu nb le nc nd aw ne bi"><span id="4957" class="nf lh iu le b gz ng nh l ni nj">module.exports.hello = (txt) =&gt; {<br/>     console.log(`Hello ${txt}`); <br/>};</span></pre><p id="dbd1" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">从一个简单的包开始。我们稍后将对此进行修改。</p><p id="029c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">接下来，让我们设置<code class="fe lb lc ld le b">sample-app</code>目录:</p><pre class="mx my mz na gu nb le nc nd aw ne bi"><span id="7152" class="nf lh iu le b gz ng nh l ni nj">$ cd .. <br/>$ npm init -y</span></pre><p id="14a3" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这将设置一个空白默认值<code class="fe lb lc ld le b">package.json</code>。在此基础上，添加以下内容:</p><pre class="mx my mz na gu nb le nc nd aw ne bi"><span id="a030" class="nf lh iu le b gz ng nh l ni nj">"dependencies": {<br/>       "package": "./package"   <br/>}</span></pre><p id="cc6d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这个依赖说明符引用了一个本地文件，即我们刚刚在<code class="fe lb lc ld le b">package</code>目录中创建的包。</p><p id="ca94" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">接下来，创建一个名为<code class="fe lb lc ld le b">app.js</code>的文件，其中包含:</p><pre class="mx my mz na gu nb le nc nd aw ne bi"><span id="9192" class="nf lh iu le b gz ng nh l ni nj">const P = require('package');  <br/>P.hello('There');</span></pre><p id="62aa" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们已经导入了这个包，将其命名为<code class="fe lb lc ld le b">P</code>，并将它导出的方法命名为。这是演示子模块使用的良好开端。</p><p id="8043" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">然后运行这些命令</p><pre class="mx my mz na gu nb le nc nd aw ne bi"><span id="8fb1" class="nf lh iu le b gz ng nh l ni nj">$ npm install</span><span id="e631" class="nf lh iu le b gz nk nh l ni nj">added 1 package, and audited 3 packages in 1s <br/>found 0 vulnerabilities <br/>$ ls -l node_modules/ <br/>total 0 <br/>lrwxr-xr-x 1 david admin 10 Dec 12 22:48 package -&gt; ../package <br/>$ node app.js Hello There</span></pre><p id="8719" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这些命令在<code class="fe lb lc ld le b">sample-app</code>目录中执行。它会安装运行应用程序所需的任何依赖项。我们在<code class="fe lb lc ld le b">package.json</code>中列出的唯一依赖项是<code class="fe lb lc ld le b">package</code>目录。因此，产生<code class="fe lb lc ld le b">node_modules</code>的唯一项目是那个包。</p><p id="505c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">注意<code class="fe lb lc ld le b">package</code>是一个到<code class="fe lb lc ld le b">package</code>目录的符号链接。这是我们努力创造的关键。符号链接让我们编辑<code class="fe lb lc ld le b">package</code>目录中的文件，并立即将编辑反映在为<code class="fe lb lc ld le b">node_modules</code>中的应用程序安装的代码中。</p><p id="0944" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">最后一位演示了我们有一个工作的应用程序。</p><h1 id="cdc1" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">将初始文件提交到存储库</h1><p id="db75" class="pw-post-body-paragraph kc kd iu ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz in bi translated">我们有一个正在开发的包的初始代码，以及一个用于测试该包的示例应用程序。这意味着我们已经到达了第一个里程碑，拥有最小可行的产品。有必要将这个里程碑提交给存储库。</p><pre class="mx my mz na gu nb le nc nd aw ne bi"><span id="114c" class="nf lh iu le b gz ng nh l ni nj">$ cd package <br/>$ git status -s <br/>?? index.js <br/>$ git add . <br/>$ git commit -a -m 'Initial Revision' <br/>[main 5623118] Initial Revision <br/> 1 file changed, 4 insertions(+) <br/> create mode 100644 index.js <br/>$ git push <br/>Enumerating objects: 7, done. <br/>Counting objects: 100% (7/7), done. <br/>Delta compression using up to 4 threads <br/>Compressing objects: 100% (6/6), done. <br/>Writing objects: 100% (6/6), 810 bytes | 810.00 KiB/s, done. <br/>Total 6 (delta 1), reused 0 (delta 0), pack-reused 0 <br/>remote: Resolving deltas: 100% (1/1), done. <br/>To <a class="ae lf" href="https://github.com/robogeek/sample-package-2021-12-12.git" rel="noopener ugc nofollow" target="_blank">https://github.com/robogeek/sample-package-2021-12-12.git</a><br/>    c8adfa5..5623118  main -&gt; main</span></pre><p id="adf1" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们从<code class="fe lb lc ld le b">package</code>目录开始，添加任何存在的文件，并将它们推送到存储库。</p><p id="bd6f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">为了使用HTTPS URL，我们用GitHub配置了一个<em class="la">访问令牌</em>，并提供了这个令牌作为密码。</p><p id="2924" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">现在，让我们在<code class="fe lb lc ld le b">sample-app</code>目录中做同样的事情:</p><pre class="mx my mz na gu nb le nc nd aw ne bi"><span id="2f50" class="nf lh iu le b gz ng nh l ni nj">$ cd .. <br/>$ git add .  <br/>$ git status -s <br/>A  .gitmodules <br/>A  app.js <br/>A  package <br/>A  package.json  <br/>$ git commit -m 'Add submodules' .gitmodules package  <br/>[main 53100a7] Add submodules <br/> 2 files changed, 4 insertions(+) <br/> create mode 100644 .gitmodules <br/> create mode 160000 package  <br/>$ git commit -a -m 'Initial Revision' <br/>[main f243c11] Initial Revision <br/> 2 files changed, 27 insertions(+) <br/> create mode 100644 app.js <br/> create mode 100644 package.json <br/>$ git push <br/>Enumerating objects: 8, done. <br/>Counting objects: 100% (8/8), done. <br/>Delta compression using up to 4 threads <br/>Compressing objects: 100% (7/7), done. <br/>Writing objects: 100% (7/7), 1.06 KiB | 1.06 MiB/s, done. <br/>Total 7 (delta 1), reused 0 (delta 0), pack-reused 0 <br/>remote: Resolving deltas: 100% (1/1), done. <br/>To github.com:robogeek/sample-app-2021-12-12.git<br/>    39bca02..f243c11  main -&gt; main</span></pre><p id="c398" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们又有一些文件要添加。前两个是Git用来记录子模块配置数据的内务文件。我们分别提交它们，所以它们有正确的提交消息。然后，我们提交其余的，并将所有内容推送到存储库。</p><h1 id="aabf" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">一起检查应用程序和包层次结构</h1><p id="bbe2" class="pw-post-body-paragraph kc kd iu ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz in bi translated">我们创造了这个:</p><pre class="mx my mz na gu nb le nc nd aw ne bi"><span id="3aca" class="nf lh iu le b gz ng nh l ni nj">$ tree . <br/>. <br/>├── README.md <br/>├── app.js <br/>├── node_modules <br/>│   └── package <br/>├── package <br/>│   ├── README.md <br/>│   ├── index.js <br/>│   └── package.json <br/>└── package.json <br/>3 directories, 6 files</span></pre><p id="4df5" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">一个目录，它是一个Git存储库，包含Node.js应用程序。其中包含另一个目录，其中包含Node.js包。这个图中没有显示，但是<code class="fe lb lc ld le b">package</code>目录也是一个Git存储库，并且作为一个子模块来管理。</p><p id="d1f8" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">理解的一种方法是使用这些命令:</p><pre class="mx my mz na gu nb le nc nd aw ne bi"><span id="e52e" class="nf lh iu le b gz ng nh l ni nj">$ git remote -v <br/>origin  git@github.com:robogeek/sample-app-2021-12-12.git (fetch) <br/>origin  git@github.com:robogeek/sample-app-2021-12-12.git (push) <br/>$ cd package <br/>$ git remote -v <br/>origin  https://github.com/robogeek/sample-package-2021-12-12.git (fetch) <br/>origin  https://github.com/robogeek/sample-package-2021-12-12.git (push)</span></pre><p id="58f6" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">每一个的Git URL都是不同的，反映出每一个都是自己的Git存储库。因此，当我们推送提交时，每个提交都进入相应的存储库。您可以在知识库网站上访问它们。</p><p id="4251" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">创建此层次结构的目的是简化将应用程序和包作为一个单元编辑的过程。</p><h1 id="2ad1" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">同时修改包和应用程序</h1><p id="19df" class="pw-post-body-paragraph kc kd iu ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz in bi translated">现在我们已经有了一个包含子模块的存储库，并且我们已经仔细检查了它，让我们尝试修改子模块中的包。毕竟，这就是我们带您来这里看这篇文章的目的。</p><p id="6031" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们从管理层的一个特性请求开始:“<em class="la">做一个改变</em>”。唉，那些经理有时对他们的特性要求不明确。你回去找经理澄清，她说需要平方根函数。</p><p id="0032" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">经理不知道<code class="fe lb lc ld le b">Math.sqrt</code>做的，我们包里也不需要这样的功能吗？</p><p id="95a9" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">无论如何，我们正在做的是在一个包中实现一个改变。当然，在真实的场景中，这将是一个有用的改变。但是这个示例应用程序显然是人为的，所以我们就顺其自然吧。</p><p id="1e0a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在<code class="fe lb lc ld le b">package</code>目录中当然是我们的包。打开<code class="fe lb lc ld le b">package/index.js</code>并添加以下内容:</p><pre class="mx my mz na gu nb le nc nd aw ne bi"><span id="8539" class="nf lh iu le b gz ng nh l ni nj">module.exports.square_root = function square_root(n) {<br/>     let _n;<br/>     if (Number.isInteger(n)) {<br/>         _n = Number.parseInt(n);<br/>         if (Number.isNaN(_n)) {<br/>             throw new Error(`${n} is an Integer that did not parse`);<br/>         }<br/>     } else if (Number.isNaN(Number.parseFloat(n))) {<br/>         throw new Error(`${n} did not parseFloat`);<br/>     } else {<br/>         _n = Number.parseFloat(n);<br/>     }<br/>     return Math.sqrt(_n); <br/>};</span></pre><p id="2376" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这满足了所要求的特性，并且增加了一些错误检查。正如在<em class="la">编程风格的元素</em>中所说，检查函数的参数很重要。</p><p id="f248" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">因为我们的测试应用程序是关于测试软件包的，所以让我们把它添加到<code class="fe lb lc ld le b">app.js</code>:</p><pre class="mx my mz na gu nb le nc nd aw ne bi"><span id="af8b" class="nf lh iu le b gz ng nh l ni nj">console.log(`20: ${P.square_root(20)}`); <br/>console.log(`0: ${P.square_root(0)}`); <br/>console.log(`-20: ${P.square_root(-20)}`); <br/>console.log(`twenty: ${P.square_root('twenty')}`);</span></pre><p id="37b9" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">它尝试了平方根函数行为的几个重要变化。运行应用程序时，我们会得到以下结果:</p><pre class="mx my mz na gu nb le nc nd aw ne bi"><span id="ab5b" class="nf lh iu le b gz ng nh l ni nj">$ node app.js  <br/>Hello There <br/>20: 4.47213595499958 <br/>0: 0 <br/>-20: NaN <br/>/Volumes/Extra/akasharender/t/sample-app-2021-12-12/package/index.js:14<br/>         throw new Error(`${n} did not parseFloat`);<br/>         ^</span></pre><p id="4010" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这是预期的输出。要理解为什么这是预期输出，建议重温高中数学。</p><p id="1304" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">既然我们已经使用特别测试验证了该行为，我们应该进入<code class="fe lb lc ld le b">package</code>目录，添加一个单元测试目录，并添加一个单元测试来验证该行为。是的，这是我们应该做的。但出于篇幅的考虑，我们将略去。</p><p id="3b2e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">更重要的是注意到这是多么容易。即使<code class="fe lb lc ld le b">package</code>安装在<code class="fe lb lc ld le b">sample-app</code>的<code class="fe lb lc ld le b">node_modules</code>目录中，我们也可以编辑它的源文件，它们会被立即识别出来。</p><p id="ca16" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">另一个优势是我们可以轻松地将代码提交到存储库:</p><p id="445e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">要准备，请运行以下命令:</p><pre class="mx my mz na gu nb le nc nd aw ne bi"><span id="f11c" class="nf lh iu le b gz ng nh l ni nj">$ git status -s  <br/>M app.js  <br/>m package <br/>$ cd package <br/>$ git status -s  <br/>M index.js</span></pre><p id="3c7d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">父存储库和子存储库中都进行了更改。先说<code class="fe lb lc ld le b">package</code>的变化:</p><pre class="mx my mz na gu nb le nc nd aw ne bi"><span id="3cbc" class="nf lh iu le b gz ng nh l ni nj">$ git commit -a -m 'Add sqrt function' <br/>[main fd1629b] Add sqrt function <br/> 1 file changed, 15 insertions(+)  <br/>$ git push <br/>Enumerating objects: 5, done. <br/>Counting objects: 100% (5/5), done. <br/>Delta compression using up to 4 threads <br/>Compressing objects: 100% (3/3), done. <br/>Writing objects: 100% (3/3), 324 bytes | 324.00 KiB/s, done. <br/>Total 3 (delta 2), reused 0 (delta 0), pack-reused 0 <br/>remote: Resolving deltas: 100% (2/2), completed with 2 local objects. <br/>To github.com:akashacms/akashacms-example.git</span></pre><p id="16a6" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这是正常的Git实践，提交更改，然后推送到存储库。</p><p id="da69" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">请注意，存储库是使用HTTPS URL引用的。为此，我们在GitHub帐户中创建了一个访问令牌。</p><pre class="mx my mz na gu nb le nc nd aw ne bi"><span id="0407" class="nf lh iu le b gz ng nh l ni nj">$ cd .. <br/>$ git status -s  <br/>M app.js  <br/>M package</span></pre><p id="8532" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">返回到<code class="fe lb lc ld le b">sample-app</code>目录，我们看到状态中的小写<code class="fe lb lc ld le b">m</code>现在已经变成了大写<code class="fe lb lc ld le b">M</code>。不管这意味着什么，肯定与在<code class="fe lb lc ld le b">package</code>做出改变有关。</p><p id="d84e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">顺便说一下，<code class="fe lb lc ld le b">package</code>中改变的是存储库中最新提交的SHA-1。因为我们已经在子模块中提交了，所以最新的SHA-1必须记录在<code class="fe lb lc ld le b">sample-app</code>中。</p><p id="78eb" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">运行以下代码很有用:</p><pre class="mx my mz na gu nb le nc nd aw ne bi"><span id="eb50" class="nf lh iu le b gz ng nh l ni nj">$ git diff <br/>diff --git a/app.js b/app.js <br/>index ec46eb4..2086daf 100644 <br/>--- a/app.js <br/>+++ b/app.js <br/>@@ -2,3 +2,8 @@<br/>  const P = require('package');<br/>    P.hello('There'); <br/>+ <br/>+console.log(`20: ${P.square_root(20)}`); <br/>+console.log(`0: ${P.square_root(0)}`); <br/>+console.log(`-20: ${P.square_root(-20)}`); <br/>+console.log(`twenty: ${P.square_root('twenty')}`); <br/>diff --git a/package b/package <br/>index 5623118..fd1629b 160000 <br/>--- a/package <br/>+++ b/package <br/>@@ -1 +1 @@ <br/>-Subproject commit 5623118d4b3621163740c84c33ca345c0c320054 <br/>+Subproject commit fd1629bad48ca6d6b5ffa5f80c8b2a5ea160dbae</span></pre><p id="2f3d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">使用<code class="fe lb lc ld le b">diff</code>,我们看到SHA-1提交散列确实发生了变化。</p><pre class="mx my mz na gu nb le nc nd aw ne bi"><span id="a10d" class="nf lh iu le b gz ng nh l ni nj">$ git commit -a -m 'Exercise the square_root function' <br/>[main 3a8f0d8] Exercise the square_root function <br/> 2 files changed, 6 insertions(+), 1 deletion(-)  <br/>$ git push <br/>Enumerating objects: 5, done. <br/>Counting objects: 100% (5/5), done. <br/>Delta compression using up to 4 threads <br/>Compressing objects: 100% (3/3), done. <br/>Writing objects: 100% (3/3), 421 bytes | 421.00 KiB/s, done. <br/>Total 3 (delta 1), reused 0 (delta 0), pack-reused 0 <br/>remote: Resolving deltas: 100% (1/1), completed with 1 local object. <br/>To github.com:robogeek/sample-app-2021-12-12.git<br/>    f243c11..3a8f0d8  main -&gt; main</span></pre><p id="45f8" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">而且，我们可以将提交推送到存储库。</p><p id="0033" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">那不也是以自然正常的方式发生的吗？这不是很容易吗？</p><p id="3921" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们的下一个任务是访问存储库并检查发生了什么变化。</p><h1 id="9715" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">签出<code class="fe lb lc ld le b">sample-app</code>库</h1><p id="eda4" class="pw-post-body-paragraph kc kd iu ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz in bi translated">因为<code class="fe lb lc ld le b">sample-app</code>存储库有子模块，所以在克隆它的存储库时会涉及到更多。通常我们只要运行<code class="fe lb lc ld le b">git clone</code>就可以了。对于子模块，我们必须确保子模块也被检出。</p><pre class="mx my mz na gu nb le nc nd aw ne bi"><span id="fc51" class="nf lh iu le b gz ng nh l ni nj">$ git clone --recursive git@github.com:robogeek/sample-app-2021-12-12.git <br/>Cloning into 'sample-app-2021-12-12'... <br/>remote: Enumerating objects: 14, done. <br/>remote: Counting objects: 100% (14/14), done. <br/>remote: Compressing objects: 100% (12/12), done. <br/>Receiving objects: 100% (14/14), done. <br/>Resolving deltas: 100% (4/4), done. remote: <br/>Total 14 (delta 4), reused 9 (delta 2), pack-reused 0 <br/>Submodule 'package' (https://github.com/robogeek/sample-package-2021-12-12.git) registered for path 'package' <br/>Cloning into '/Volumes/Extra/akasharender/t/t/sample-app-2021-12-12/package'... <br/>remote: Enumerating objects: 13, done.         <br/>remote: Counting objects: 100% (13/13), done.         <br/>remote: Compressing objects: 100% (11/11), done.         <br/>remote: Total 13 (delta 4), reused 8 (delta 2), pack-reused 0         <br/>Receiving objects: 100% (13/13), done. <br/>Resolving deltas: 100% (4/4), done. <br/>Submodule path 'package': checked out 'fd1629bad48ca6d6b5ffa5f80c8b2a5ea160dbae'</span></pre><p id="dd8e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">最简单的是添加<code class="fe lb lc ld le b">--recursive</code>选项，如下所示。通读这个输出，您会看到它识别了子模块<code class="fe lb lc ld le b">package</code>并继续克隆它。注意，它检查了前面提到的提交散列。</p><p id="8124" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">如果我们进入子模块，我们会学到一些有趣的东西:</p><pre class="mx my mz na gu nb le nc nd aw ne bi"><span id="d680" class="nf lh iu le b gz ng nh l ni nj">$ cd package <br/>$ git branch <br/>* (HEAD detached at fd1629b) <br/>  main <br/>$ git status <br/>HEAD detached at fd1629b <br/>nothing to commit, working tree clean</span></pre><p id="af1c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">文件<code class="fe lb lc ld le b">package/index.js</code>有<code class="fe lb lc ld le b">square_root</code>功能，所以代码被正确检出。但是，存储库处于<em class="la">分离头</em>状态。当处于这种状态时，您将很难做出更改并将它们推送到存储库，因为相反您会得到错误。</p><p id="e79a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">解决这个问题的方法很简单:</p><pre class="mx my mz na gu nb le nc nd aw ne bi"><span id="5c75" class="nf lh iu le b gz ng nh l ni nj">$ git checkout main <br/>Switched to branch 'main' <br/>Your branch is up to date with 'origin/main'.  <br/>$ git status <br/>On branch main Your branch is up to date with 'origin/main'.  <br/>nothing to commit, working tree clean</span></pre><p id="2ea4" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这使得子模块不再处于分离的头部状态。</p><h1 id="0e8d" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">常规应用呢？</h1><p id="dde4" class="pw-post-body-paragraph kc kd iu ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz in bi translated">为什么我们建议Node.js子模块的最佳用途是为Node.js应用程序开发一个示例应用程序？将子模块用于常规的生产Node.js应用程序怎么样？</p><p id="cec8" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">区别在于谁将使用该应用程序，以及它们的设置是否容易。</p><p id="25ba" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">考虑像<code class="fe lb lc ld le b">postcss</code>和<code class="fe lb lc ld le b">serverless</code>这样的命令行开发工具。两者都在Node.js中实现，安装说明是运行<code class="fe lb lc ld le b">npm install -g PACKAGE-NAME</code>，之后就可以运行这个工具了。对于应用程序提供商来说，重要的是安装体验要尽可能简单，以便为他们的客户提供尽可能少的采用障碍。</p><p id="f6df" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">安装过程不能是首先克隆一个Git库，运行一些额外的命令，等等。它必须是简单的，如<code class="fe lb lc ld le b">npm install</code>，之后客户可以使用应用程序。</p><p id="d389" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">上面描述的技术包括这种<code class="fe lb lc ld le b">dependencies</code>:</p><pre class="mx my mz na gu nb le nc nd aw ne bi"><span id="e482" class="nf lh iu le b gz ng nh l ni nj">"dependencies": {<br/>     "package-name": "./modules/package-name" <br/>}</span></pre><p id="8cfc" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">目录<code class="fe lb lc ld le b">./modules/package-name</code>由Git子模块填充代码。因此，在运行<code class="fe lb lc ld le b">npm install</code>之前，设置这样一个应用程序需要克隆Git存储库并运行Git命令。因此，通过npm发布这样的应用程序是不可行或不可能的，因为安装体验只是简单的<code class="fe lb lc ld le b">npm install</code>。</p><p id="e871" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">注意:我说的<code class="fe lb lc ld le b">npm install</code>，也是指等价的<code class="fe lb lc ld le b">yarn</code>命令。</p><p id="a06e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">有些生产应用交付场景不涉及运行<code class="fe lb lc ld le b">npm install</code>的最终客户。在这种情况下，最终用户可能不会安装应用程序，而是使用web服务，或者在电子应用程序的情况下，运行预构建的GUI。</p><p id="2b0c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这并不意味着该技术只能用于样品或测试应用。</p><p id="70e4" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">考虑一个不同的场景，一个Node.js web应用程序作为Docker容器交付。在这种情况下，<code class="fe lb lc ld le b">Dockerfile</code>将包含如下命令:</p><pre class="mx my mz na gu nb le nc nd aw ne bi"><span id="5c3c" class="nf lh iu le b gz ng nh l ni nj">RUN git clone --recursive CLONE-URL /app <br/>WORKDIR /app <br/>RUN npm install</span></pre><p id="351c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这和前面的例子大致相同。我们将存储库克隆到容器映像中的一个目录中，然后切换到该目录，并在正在构建的容器中运行<code class="fe lb lc ld le b">npm install</code>。</p><p id="1f3a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这个容器映像的最终用户不知道您使用了子模块。他们得到的是一个完整的映像，其中包含运行应用程序所需的所有文件。</p><h1 id="e552" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">摘要</h1><p id="b742" class="pw-post-body-paragraph kc kd iu ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz in bi translated">我们已经简要介绍了如何在Node.js包开发中使用Git子模块。</p><p id="46f0" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这让我们可以轻松地编辑包的源代码，并立即重新运行示例应用程序，而不需要同步任何更改。这简化了我们的开发工作流程。我们可以在一个或多个子模块目录中自由地进行更改，然后通过在子模块中运行单元测试套件，或者通过对父存储库中的应用程序运行专门的测试来验证我们的更改。</p><p id="2fee" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在撰写本文的过程中，我使用了<code class="fe lb lc ld le b">akashacms-example</code>示例网站，对<code class="fe lb lc ld le b">akashacms-dlassets</code>包中的一个特性进行了修改。这个示例网站(见上面的链接)是一个示例应用程序的例子，人们可以用它来练习软件包。在过去使用它进行特性开发是令人沮丧的，因为需要不断地从源目录复制变更到<code class="fe lb lc ld le b">node_modules</code>。使用子模块使它变得轻而易举。</p><h1 id="3158" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">关于作者</h1><p id="75cc" class="pw-post-body-paragraph kc kd iu ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz in bi translated"><a class="ae lf" href="https://techsparx.com/about.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ke iv"> <em class="la">大卫·赫伦</em> </strong> </a> <em class="la">:大卫·赫伦是一名作家和软件工程师，专注于技术的明智使用。他对太阳能、风能和电动汽车等清洁能源技术特别感兴趣。David在硅谷从事了近30年的软件工作，从电子邮件系统到视频流，再到Java编程语言，他已经出版了几本关于Node.js编程和电动汽车的书籍。</em></p></div><div class="ab cl nl nm hy nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="in io ip iq ir"><p id="5b65" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><em class="la">原载于</em><a class="ae lf" href="https://techsparx.com/nodejs/tools/submodules.html" rel="noopener ugc nofollow" target="_blank"><em class="la">https://techsparx.com</em></a><em class="la">。</em></p></div></div>    
</body>
</html>