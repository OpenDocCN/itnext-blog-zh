<html>
<head>
<title>Faster Maven builds in Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker中更快的Maven构建</h1>
<blockquote>原文：<a href="https://itnext.io/faster-maven-builds-in-docker-31594948cdef?source=collection_archive---------3-----------------------#2021-10-10">https://itnext.io/faster-maven-builds-in-docker-31594948cdef?source=collection_archive---------3-----------------------#2021-10-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0fc5c993e7592a09c961aecc15983c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mkibOpJu_THXZZzq9RDQ1A.png"/></div></div></figure><p id="18c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上周，我描述了<a class="ae kw" href="https://blog.frankel.ch/faster-maven-builds/1/" rel="noopener ugc nofollow" target="_blank">不同的技术</a>来加固你的Maven构建。今天，我想扩大范围，对Docker 中的Maven builds <em class="kx">做同样的事情。</em></p><p id="58cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在每次运行之间，我们通过添加一个空行来更改源代码；在每个部分之间，我们删除所有构建的图像，包括作为多阶段构建结果的中间图像。这个想法是为了避免重用以前构建的映像。</p><h1 id="bfcb" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">基线</h1><p id="e060" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">为了计算一个有用的基线，我们需要一个示例项目。我为此创建了一个<a class="ae kw" href="https://github.com/nfrankel/fast-maven-builds" rel="noopener ugc nofollow" target="_blank"> one </a>:这是一个相对较小的Kotlin项目。</p><p id="5565" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是相关的<code class="fe mb mc md me b">Dockerfile</code>:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="ee36" class="mn kz iq me b gy mo mp l mq mr">FROM openjdk:11-slim-buster as build                         #1</span><span id="f577" class="mn kz iq me b gy ms mp l mq mr">COPY .mvn .mvn                                               #2<br/>COPY mvnw .                                                  #2<br/>COPY pom.xml .                                               #2<br/>COPY src src                                                 #2</span><span id="ab75" class="mn kz iq me b gy ms mp l mq mr">RUN ./mvnw -B package                                        #3</span><span id="eac7" class="mn kz iq me b gy ms mp l mq mr">FROM openjdk:11-jre-slim-buster                              #4</span><span id="c4c3" class="mn kz iq me b gy ms mp l mq mr">COPY --from=build target/fast-maven-builds-1.0.jar .         #5</span><span id="f521" class="mn kz iq me b gy ms mp l mq mr">EXPOSE 8080</span><span id="3696" class="mn kz iq me b gy ms mp l mq mr">ENTRYPOINT ["java", "-jar", "fast-maven-builds-1.0.jar"]     #6</span></pre><ol class=""><li id="8733" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated">从包装步骤的JDK图像开始</li><li id="8330" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">添加所需资源</li><li id="6dd8" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">创建罐子</li><li id="05f6" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">从JRE开始映像创建步骤</li><li id="d84e" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">复制上一步中的罐子</li><li id="9544" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">设置入口点</li></ol><p id="c4d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们执行构建:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="c615" class="mn kz iq me b gy mo mp l mq mr">time DOCKER_BUILDKIT=0 docker build -t fast-maven:1.0 . #1</span></pre><ol class=""><li id="36ad" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated">暂时忘记环境变量，我将在下一节解释</li></ol><p id="8259" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是五次运行的结果:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="ae13" class="mn kz iq me b gy mo mp l mq mr">* 0.36s user 0.53s system 0% cpu 1:53.06 total<br/>* 0.36s user 0.56s system 0% cpu 1:52.50 total<br/>* 0.35s user 0.55s system 0% cpu 1:56.92 total<br/>* 0.36s user 0.56s system 0% cpu 2:04.55 total<br/>* 0.38s user 0.61s system 0% cpu 2:04.68 total</span></pre><h1 id="4121" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">赢得胜利的构建套件</h1><p id="b0bf" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">最后一个命令行使用了<code class="fe mb mc md me b">DOCKER_BUILDKIT</code>环境变量。这是告诉Docker使用传统引擎的方式。如果你有一段时间没有更新Docker，这是你正在使用的引擎。如今，<a class="ae kw" href="https://github.com/moby/buildkit" rel="noopener ugc nofollow" target="_blank"> BuildKit </a>已经取代了它，成为新的默认设置。</p><p id="0fe5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">BuildKit带来了几项性能改进:</p><ul class=""><li id="cbbf" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv nh mz na nb bi translated">自动垃圾收集</li><li id="c5c1" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv nh mz na nb bi translated">并发依赖解析</li><li id="1335" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv nh mz na nb bi translated">高效的指令缓存</li><li id="0b2a" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv nh mz na nb bi translated">构建缓存导入/导出</li><li id="7b35" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv nh mz na nb bi translated">等等。</li></ul><p id="5f84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们在新的引擎上重新执行前面的命令:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="8810" class="mn kz iq me b gy mo mp l mq mr">time docker build -t fast-maven:1.1 .</span></pre><p id="cd58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是第一次运行时控制台日志的摘录:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="cb9c" class="mn kz iq me b gy mo mp l mq mr">...<br/> =&gt; =&gt; transferring context: 4.35kB<br/> =&gt; [build 2/6] COPY .mvn .mvn<br/> =&gt; [build 3/6] COPY mvnw .<br/> =&gt; [build 4/6] COPY pom.xml .<br/> =&gt; [build 5/6] COPY src src<br/> =&gt; [build 6/6] RUN ./mvnw -B package<br/>...</span><span id="a57a" class="mn kz iq me b gy ms mp l mq mr">0.68s user 1.04s system 1% cpu 2:06.33 total</span></pre><p id="4361" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相同命令的以下执行结果略有不同:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="e092" class="mn kz iq me b gy mo mp l mq mr">...<br/> =&gt; =&gt; transferring context: 1.82kB<br/> =&gt; CACHED [build 2/6] COPY .mvn .mvn<br/> =&gt; CACHED [build 3/6] COPY mvnw .<br/> =&gt; CACHED [build 4/6] COPY pom.xml .<br/> =&gt; [build 5/6] COPY src src<br/> =&gt; [build 6/6] RUN ./mvnw -B package<br/>...</span></pre><p id="7a3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请记住，我们会在运行之间更改源代码。我们不改变的文件，即<code class="fe mb mc md me b">.mvn</code>、<code class="fe mb mc md me b">mvnw</code>和<code class="fe mb mc md me b">pom.xml</code>，由build kit<em class="kx">缓存</em>。但是这些资源很小，所以缓存不会显著改善构建时间。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="87a5" class="mn kz iq me b gy mo mp l mq mr">* 0.69s user 1.01s system 1% cpu 2:05.08 total<br/>* 0.65s user 0.95s system 1% cpu 1:58.51 total<br/>* 0.68s user 0.99s system 1% cpu 1:59.31 total<br/>* 0.64s user 0.95s system 1% cpu 1:59.82 total</span></pre><p id="cd8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">快速浏览日志可以发现，构建中最大的瓶颈是所有依赖项(包括插件)的下载。每次我们修改源代码时都会发生这种情况。这就是BuildKit没有提升性能的原因。</p><h1 id="087b" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">层，层，层</h1><p id="65ed" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我们应该把精力集中在从属关系上。为此，我们可以利用<em class="kx">层</em>并将构建分为两步:</p><ul class=""><li id="9235" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv nh mz na nb bi translated">第一步，我们下载依赖项</li><li id="308b" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv nh mz na nb bi translated">在第二个例子中，我们进行适当的包装</li></ul><p id="ea55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每一步都创建一个层，第二步依赖于第一步。</p><p id="d913" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了分层，如果我们改变第二层的源代码，第一层不受影响，可以重用。我们不需要再次下载依赖项。新的<code class="fe mb mc md me b">Dockerfile</code>看起来像:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="df6e" class="mn kz iq me b gy mo mp l mq mr">FROM openjdk:11-slim-buster as build</span><span id="5b4f" class="mn kz iq me b gy ms mp l mq mr">COPY .mvn .mvn<br/>COPY mvnw .<br/>COPY pom.xml .</span><span id="ebac" class="mn kz iq me b gy ms mp l mq mr">RUN ./mvnw -B dependency:go-offline                          #1</span><span id="46af" class="mn kz iq me b gy ms mp l mq mr">COPY src src</span><span id="a453" class="mn kz iq me b gy ms mp l mq mr">RUN ./mvnw -B package                                        #2</span><span id="c97b" class="mn kz iq me b gy ms mp l mq mr">FROM openjdk:11-jre-slim-buster</span><span id="1047" class="mn kz iq me b gy ms mp l mq mr">COPY --from=build target/fast-maven-builds-1.2.jar .</span><span id="e563" class="mn kz iq me b gy ms mp l mq mr">EXPOSE 8080</span><span id="ce8e" class="mn kz iq me b gy ms mp l mq mr">ENTRYPOINT ["java", "-jar", "fast-maven-builds-1.2.jar"]</span></pre><ol class=""><li id="0682" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated">目标<code class="fe mb mc md me b">go-offline</code>下载所有的依赖项和插件</li><li id="35ae" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">此时，所有依赖项都是可用的</li></ol><p id="4df7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意<code class="fe mb mc md me b">go-offline</code>并不下载所有东西。如果您尝试使用<code class="fe mb mc md me b">-o</code>选项(用于离线)，该命令将不会成功运行。是<a class="ae kw" href="https://issues.apache.org/jira/browse/MDEP-82" rel="noopener ugc nofollow" target="_blank">一个众所周知的老bug </a>。在所有情况下，都是“足够好”。</p><p id="d800" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们运行构建:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="ced1" class="mn kz iq me b gy mo mp l mq mr">time docker build -t fast-maven:1.2 .</span></pre><p id="9f85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一次运行花费的时间比基线长得多:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="60eb" class="mn kz iq me b gy mo mp l mq mr">0.84s user 1.21s system 1% cpu 2:35.47 total</span></pre><p id="6bcc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，后续的构建要快得多。更改源代码只会影响第二层，不会触发(大多数)依赖项的下载:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="1f81" class="mn kz iq me b gy mo mp l mq mr">* 0.23s user 0.36s system 5% cpu 9.913 total<br/>* 0.21s user 0.33s system 5% cpu 9.923 total<br/>* 0.22s user 0.38s system 6% cpu 9.990 total<br/>* 0.21s user 0.34s system 5% cpu 9.814 total<br/>* 0.22s user 0.37s system 5% cpu 10.454 total</span></pre><h1 id="9887" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">构建中的卷装载</h1><p id="1db0" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">构建分层极大地改善了构建时间。我们可以改变源代码，并保持低。不过，还有一个问题。更改单个依赖关系会使该层无效，因此我们需要再次下载所有依赖关系。</p><p id="1f2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是，BuildKit在构建期间引入了<strong class="ka ir">卷挂载(而不仅仅是在运行期间)。有几种类型的挂载可供选择，但我们感兴趣的是<a class="ae kw" href="https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/syntax.md#run---mounttypecache" rel="noopener ugc nofollow" target="_blank">缓存挂载</a>。这是一个<em class="kx">实验性的</em>特性，所以你需要明确地选择加入:</strong></p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="a2f8" class="mn kz iq me b gy mo mp l mq mr"># syntax=docker/dockerfile:experimental                      #1<br/>FROM openjdk:11-slim-buster as build</span><span id="1070" class="mn kz iq me b gy ms mp l mq mr">COPY .mvn .mvn<br/>COPY mvnw .<br/>COPY pom.xml .<br/>COPY src src</span><span id="4311" class="mn kz iq me b gy ms mp l mq mr">RUN --mount=type=cache,target=/root/.m2,rw ./mvnw -B package #2</span><span id="2b94" class="mn kz iq me b gy ms mp l mq mr">FROM openjdk:11-jre-slim-buster</span><span id="6b19" class="mn kz iq me b gy ms mp l mq mr">COPY --from=build target/fast-maven-builds-1.3.jar .</span><span id="1003" class="mn kz iq me b gy ms mp l mq mr">EXPOSE 8080</span><span id="8322" class="mn kz iq me b gy ms mp l mq mr">ENTRYPOINT ["java", "-jar", "fast-maven-builds-1.3.jar"]</span></pre><ol class=""><li id="b5b7" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated">选择加入实验功能</li><li id="5e00" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">使用缓存构建</li></ol><p id="b910" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是时候运行构建了:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="f428" class="mn kz iq me b gy mo mp l mq mr">time docker build -t fast-maven:1.3 .</span></pre><p id="d20b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">构建时间高于常规构建，但仍低于层构建:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="e831" class="mn kz iq me b gy mo mp l mq mr">0.71s user 1.01s system 1% cpu 1:50.50 total</span></pre><p id="c10e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下构件与层相当:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="c12a" class="mn kz iq me b gy mo mp l mq mr">* 0.22s user 0.33s system 5% cpu 9.677 total<br/>* 0.30s user 0.36s system 6% cpu 10.603 total<br/>* 0.24s user 0.37s system 5% cpu 10.461 total<br/>* 0.24s user 0.39s system 6% cpu 10.178 total<br/>* 0.24s user 0.35s system 5% cpu 10.283 total</span></pre><p id="4e79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，与层相反，我们只需要下载更新的依赖关系。这里，我们把科特林的版本从<code class="fe mb mc md me b">1.5.30</code>改成<code class="fe mb mc md me b">1.5.31</code>:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="cb15" class="mn kz iq me b gy mo mp l mq mr">&lt;properties&gt;<br/>    &lt;kotlin.version&gt;1.5.31&lt;/kotlin.version&gt;<br/>&lt;/properties&gt;</span></pre><p id="12eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就构建时间而言，这是一个巨大的改进:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="9253" class="mn kz iq me b gy mo mp l mq mr">* 0.41s user 0.57s system 2% cpu 44.710 total</span></pre><h1 id="3bf7" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">考虑到Maven守护进程</h1><p id="b993" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在之前关于<a class="ae kw" href="https://blog.frankel.ch/faster-maven-builds/1/" rel="noopener ugc nofollow" target="_blank">常规Maven构建</a>的帖子中，我提到了Maven守护进程。让我们相应地改变我们的构建:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="0ec0" class="mn kz iq me b gy mo mp l mq mr">FROM openjdk:11-slim-buster as build</span><span id="7032" class="mn kz iq me b gy ms mp l mq mr">ADD https://github.com/mvndaemon/mvnd/releases/download/0.6.0/mvnd-0.6.0-linux-amd64.zip . #1</span><span id="11f3" class="mn kz iq me b gy ms mp l mq mr">RUN apt-get update \                                         #2<br/> &amp;&amp; apt-get install unzip \                                  #3<br/> &amp;&amp; mkdir /opt/mvnd \                                        #4<br/> &amp;&amp; unzip mvnd-0.6.0-linux-amd64.zip \                       #5<br/> &amp;&amp; mv mvnd-0.6.0-linux-amd64/* /opt/mvnd                    #6</span><span id="4186" class="mn kz iq me b gy ms mp l mq mr">COPY .mvn .mvn<br/>COPY mvnw .<br/>COPY pom.xml .<br/>COPY src src</span><span id="73dd" class="mn kz iq me b gy ms mp l mq mr">RUN /opt/mvnd/bin/mvnd -B package                            #7</span><span id="b22a" class="mn kz iq me b gy ms mp l mq mr">FROM openjdk:11-jre-slim-buster</span><span id="7bc3" class="mn kz iq me b gy ms mp l mq mr">COPY --from=build target/fast-maven-builds-1.4.jar .</span><span id="a45e" class="mn kz iq me b gy ms mp l mq mr">EXPOSE 8080</span><span id="9974" class="mn kz iq me b gy ms mp l mq mr">ENTRYPOINT ["java", "-jar", "fast-maven-builds-1.4.jar"]</span></pre><ol class=""><li id="fef6" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated">下载最新版本的Maven守护程序</li><li id="d0a3" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">刷新包索引</li><li id="cf01" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">安装<code class="fe mb mc md me b">unzip</code></li><li id="d261" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">创建专用文件夹</li><li id="e848" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">提取我们在步骤1中下载的归档文件</li><li id="d8e0" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">将提取的归档文件的内容移动到以前创建的文件夹中</li><li id="d7c2" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">使用<code class="fe mb mc md me b">mvnd</code>代替Maven包装器</li></ol><p id="a692" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们现在运行构建:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="d4ee" class="mn kz iq me b gy mo mp l mq mr">docker build -t fast-maven:1.4 .</span></pre><p id="49b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该日志输出以下内容:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="89f3" class="mn kz iq me b gy mo mp l mq mr">* 0.70s user 1.01s system 1% cpu 1:51.96 total<br/>* 0.72s user 0.98s system 1% cpu 1:47.93 total<br/>* 0.66s user 0.93s system 1% cpu 1:46.07 total<br/>* 0.76s user 1.04s system 1% cpu 1:50.35 total<br/>* 0.80s user 1.18s system 1% cpu 2:01.45 total</span></pre><p id="6515" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与基线相比，没有明显的改善。</p><p id="9903" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我试图创建一个专用的<code class="fe mb mc md me b">mvnd</code>图像，并将其用作父图像:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="9605" class="mn kz iq me b gy mo mp l mq mr"># docker build -t mvnd:0.6.0 .<br/>FROM openjdk:11-slim-buster as build</span><span id="6c55" class="mn kz iq me b gy ms mp l mq mr">ADD https://github.com/mvndaemon/mvnd/releases/download/0.6.0/mvnd-0.6.0-linux-amd64.zip .</span><span id="ce46" class="mn kz iq me b gy ms mp l mq mr">RUN --mount=type=cache,target=/var/cache/apt,rw apt-get update \<br/> &amp;&amp; apt-get install unzip \<br/> &amp;&amp; mkdir /opt/mvnd \<br/> &amp;&amp; unzip mvnd-0.6.0-linux-amd64.zip \<br/> &amp;&amp; mv mvnd-0.6.0-linux-amd64/* /opt/mvnd</span><span id="9e60" class="mn kz iq me b gy ms mp l mq mr"># docker build -t fast-maven:1.5 .<br/>FROM mvnd:0.6.0 as build</span><span id="562d" class="mn kz iq me b gy ms mp l mq mr"># ...</span></pre><p id="efaf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法以任何显著的方式改变了输出。</p><p id="6ec2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mb mc md me b">mvnd</code>只有在守护进程多次运行时才是好的。我找不到和Docker一起做的方法。如果你对如何实现它有任何想法，请告诉我；额外加分，如果你能给我指出一个实现。</p><h1 id="012e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="b52e" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在Docker中加速Maven构建的性能与常规构建有很大不同。在Docker中，限制因素是依赖项的下载速度。如果您停留在旧版本上，您需要使用层来缓存依赖项。</p><p id="df14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于BuildKit，我建议使用新的缓存挂载功能，以避免在层失效时下载所有依赖项。</p><p id="8b7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章的完整源代码可以在<a class="ae kw" href="https://github.com/ajavageek/fast-maven-builds" rel="noopener ugc nofollow" target="_blank"> Github </a>上以Maven格式找到。</p><p id="053d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更进一步:</strong></p><ul class=""><li id="5c00" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv nh mz na nb bi translated"><a class="ae kw" href="https://blog.frankel.ch/faster-maven-builds/1/" rel="noopener ugc nofollow" target="_blank">更快的Maven构建</a></li><li id="8b49" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv nh mz na nb bi translated"><a class="ae kw" href="https://blog.mobyproject.org/introducing-buildkit-17e056cc5317" rel="noopener ugc nofollow" target="_blank">介绍BuildKit </a></li><li id="9d98" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv nh mz na nb bi translated"><a class="ae kw" href="https://mydeveloperplanet.com/2019/03/13/docker-layers-explained/" rel="noopener ugc nofollow" target="_blank"> Docker层解释</a></li><li id="e094" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv nh mz na nb bi translated"><a class="ae kw" href="https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/syntax.md#build-mounts-run---mount" rel="noopener ugc nofollow" target="_blank">建造坐骑</a></li></ul></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="e377" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">原载于</em> <a class="ae kw" href="https://blog.frankel.ch/faster-maven-builds/2/" rel="noopener ugc nofollow" target="_blank"> <em class="kx">一个Java极客</em></a><em class="kx">2021年10月10日</em></p></div></div>    
</body>
</html>