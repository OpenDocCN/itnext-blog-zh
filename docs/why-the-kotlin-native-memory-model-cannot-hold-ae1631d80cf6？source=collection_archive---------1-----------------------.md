# 为什么科特林/原生记忆模型不成立。

> 原文：<https://itnext.io/why-the-kotlin-native-memory-model-cannot-hold-ae1631d80cf6?source=collection_archive---------1----------------------->

![](img/8f4c08f4591a8191929a41152b0f5d7f.png)

冰冻是美丽的。(照片由[贾科莫·贝拉尔迪](https://unsplash.com/@giacbrd?utm_source=medium&utm_medium=referral)拍摄)

***编辑:本文描述的记忆模型并不成立。Jetbrains 在一篇***[***2020 年 7 月的帖子***](https://blog.jetbrains.com/kotlin/2020/07/kotlin-native-memory-management-roadmap/) ***中公布了一个急需的改动，其中已经更新了一篇***[***2021 年 5 月的帖子***](https://blog.jetbrains.com/kotlin/2021/05/kotlin-native-memory-management-update/) ***。由于新的内存管理器尚未稳定或默认，因此本文仍然相关。然而，请注意，本文中描述的一切都将在未来发生变化，Jetbrains 正在积极努力减轻所描述的痛苦。***

你听说过 Kotlin 多平台，它与你通常看到的银弹多平台不同:

*   它实际上编译成“本机”二进制文件。这意味着 Android 的 JVM 字节码或 iOS 的 LLVM /二进制位。
*   它提出了一个专用于多平台的完整的代码架构，允许平台特定的实现。
*   它有着惊人的互操作性故事，无论是与 Swift、JS、C &当然还有 Java。
*   它是由实际设计该语言的公司开发和支持的，所以它不是“添加”在语言之上，而是从一开始就存在的。

所以也许这一次，会有所不同。也许会有用。也许有一个银弹。怀着喜悦的心情，您开始将依赖于 JVM 的 Kotlin 代码移植到多平台架构上，它可以编译了！

你运行它…

```
Uncaught Kotlin exception: kotlin.native.concurrent.InvalidMutabilityException: mutation attempt of frozen com.Whatever@1aec038
```

这是因为，是的，Kotlin/Native runtime 实际上强制执行了一批非常重要的线程相关代码健全性规则，第一条是:

> 数据要么是可变的，要么是共享的。

如果您需要共享一个对象，您可以冻结它，因为:

> 冻结的数据不能被改变。

另外:

> 冻结对象会冻结它引用的所有内容。冻结的对象不能解冻。

那么,“静态”数据呢，比如顶级变量或对象？
嗯:

> 默认情况下，顶级对象被冻结。

这不是一个关于如何克服这些限制或如何正确地让代码在 Kotlin 多平台上工作的故事。这是一个关于局限性本身的故事。

首先，我们需要了解这些局限性背后的原因。它们是哲学的和实用的。

从哲学上讲，这是一个范式转变。没有可共享的可变数据，就不需要互斥，这意味着没有竞争条件以及固定的性能。这个模型鼓励我们以不同于我们习惯的方式来思考我们的代码:我们不是在线程之间共享资源，而是命名一个负责资源的线程并向它发送动作。只有一个线程访问资源，所有其他线程都要求所有者线程代表它们对资源执行操作。这种模型被称为“基于演员的编程”, KotlinX Coroutines 库(有趣的是，正是因为这些限制，kot linx Coroutines 库不支持 Kotlin/Native 上的多线程)使这个模型变得非常简单。然而，他们正在[为之努力](https://github.com/Kotlin/kotlinx.coroutines/issues/462)。

实际上，实施这一点意味着运行时垃圾收集器更容易编写、可优化和可预测。

我真的很喜欢这些约束。我碰巧认为，一种编程语言强加给我们的约束越多，我们就越不会发布有问题的应用程序。

那么，这些约束有什么问题呢？
可悲的是，很多。虽然约束本身是合理的，非常有趣，但它们在 Kotlin/Native 编译器&运行时的实现是有问题的。原因如下:

**1:这些限制仅适用于 kot Lin/Native**

Kotlin/Native 只有作为多平台体验的一部分才有价值。悲伤却真实。没有一个 iOS 程序员会用 Kotlin 而不是 Swift 来制作一个仅支持 iOS 的应用程序。也没有一个高性能的服务器程序员会喜欢 Kotlin/Native 而不是 C++或 Rust。高性能桌面应用也是如此。Kotlin/Native 可能获得一些关注的唯一领域是嵌入式。这还远远没有完成。

因为这些限制是 Kotlin/Native 独有的，它们将程序员从 Kotlin 多平台体验中推开。当他们试图移植现有的工作代码时，不得不重新思考他们的整个架构，这让他们中的大多数人感到沮丧。

还有，由于对应的 API 只存在于 Kotlin/Native 中，这使得[几乎不可能](https://github.com/Kotlin/kotlinx.coroutines/issues/462#issuecomment-450035178)用通用代码&通用语义编写一些库。

**2:这些限制是纯粹的。我们很实际。**

当你第一次开始思考基于演员的编程时，你会大吃一惊。你觉得开明，聪明。将代码分解成参与者意味着划分资源和职责。每个参与者的功能都是原子性的，每个参与者都可以与其他参与者就其原子功能之外的请求进行通信。这是一种非常有趣、安全、伟大的编码方式……直到你开始进行基准测试。

请理解我与那些认为#PerfMatters 无处不在，无时不在的人相去甚远。我更喜欢“效率高于性能”的人。然而，有时候性能确实很重要。一切都取决于上下文，我们不能排除关键路径中性能的必要性。

看看[这个基准](https://gist.github.com/SalomonBrys/688b2ccc10e3a7cea47966bf57d1cf89)。下面是它打印的内容:

```
With Mutex:
Completed 1000000 actions in 661 ms
Counter = 1000000
With Semaphore:
Completed 1000000 actions in 413 ms
Counter = 1000000
With Lock:
Completed 1000000 actions in 81 ms
Counter = 1000000
With Actor:
Completed 1000000 actions in 576 ms
Counter = 1000000
```

系统锁比 actors 快 7 倍。这个*可能*是件大事。
如果共享资源不是通过关键路径访问的，那么演员的表现绝对没问题。如果是的话，那就有问题了。
那是因为只有*一个*演员被限制在*一个*线程中。基于 Actor 的编程的优点也是它的弱点:每次你需要访问资源时，都有消息在线程间传递。

演员大部分时候都很棒，但不是每次都很棒。

哦。该基准测试甚至没有显示使用读写锁的好处，因为它非常依赖于上下文，但是在很少写入和大量读取的情况下，使用这样的锁可以进一步提高 actors 的性能。

**3:这些限制在运行时强制执行**

在 JVM 或 JS 中编译和运行良好的代码在本机运行时会崩溃。
只需 5 行代码:

```
object Foo { var bar = 21 }
fun main() {
    Foo.bar = 42 // Crash happens here!
    *println*(Foo.bar)
}
```

记得吗？这是“*顶层对象默认冻结*”和“*冻结的数据不能变异*”的工作。

因为这些限制是在运行时强制实施的，所以编译器和 IDE 都不会警告你正在做*禁止*的事情。它会编译，在 JVM & JS 中运行良好，在 Native 中崩溃。
事实上，IDE 的编译器没有办法警告你，因为不变性不是类型系统的一部分。

第 1 点和第 2 点的影响是相似的:这让开发者望而却步。关于观点，这可以是好事也可以是坏事。有人可能会说“如果你不喜欢做正确的事情，就离开我的语言”。是的，强迫开发者执行好的实践是一件非常好的事情。我们都喜欢将可空性嵌入到 Kotlin 类型系统中，即使我们必须编写额外的可空性检查。迫使开发者进行范式转变可能是件好事，但我担心 JetBrains 低估了这种转变的成本。我担心强迫开发者采用他们“更好”的方式，实际上是在把他们推开。这是一种直觉，我没有数据支持它。但是，作为一个专业认证的 Kotlin 训练师，我看到过 Kotlin/Native 的采用被推迟正是因为这个。

然而，最让我困扰的是第三点。就我个人而言，我无法理解 JetBrains 是如何认为让这么简单的代码编译并在运行时崩溃是没问题的。
kot Lin 如此受欢迎的一个主要原因是*确切地说是*，因为在编译时会检测到许多崩溃，从而阻止应用程序的编译和部署。这就是为什么人们喜欢可空性、智能强制转换、(非常)强类型等。
在运行时强制实施不变性似乎是一个巨大的错误。感觉就像*让狼进羊圈*(法语表达)。突然，在 Kotlin/Native 中编译并在任何其他平台上运行的代码会崩溃，而没有太多警告。突然，感觉这种语言在和我们作对，而不是和我们合作。感觉科特林背叛了我们。

有两种方法可以改善这种情况。要么修复语言，要么修复运行时。

我们如何修复这种语言？一种方法是将**常量类**添加到语言中，这将被描述为“一个只有不可变数据的类:要么是原语，要么是常量对象”。这种方法的一个好处是允许 [hashcode 优化](https://github.com/Kotlin/KEEP/pull/51)。那么就不需要 freeze() API: const 类是 freeze 的定义。再者，“const”已经是一个语言关键词了。
另一种方式是像 Rust 一样实现[所有权](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html) & [并发原语](https://doc.rust-lang.org/book/ch16-00-concurrency.html)。我很乐意这样做，但我担心 Kotlin 已经偏离这些原则太多了，而且为时已晚(此外，Rust 中的所有权与内存收集高度相关)。

可悲的是，修复语言是一个更加复杂和令人生畏的方法，所以看起来 JetBrains 正在走一条更容易的路。是好事吗？
我应该说没有办法确定这种新的“放松模式”真的会上市。这可能只是一个测试。
修复运行时确实降低了门槛，因为每个程序员都可以继续用他们过去的方式编码，但我无法停止这样的感觉，即我们作为一个语言社区，可能正在失去“正确并发”的梦想。也许我们还不够努力？

结论来了:以它目前的形式，它的记忆模式正在伤害 Kotlin/Native。这使得编写不管平台如何都具有相同语义的多平台代码变得非常困难，这使得开发人员望而却步，并且这使人感觉这种语言在运行时崩溃，强制执行工具没有显示的任意规则，从而与我们作对。

它撑不住了。
我真的希望不会。

这并不意味着范式本身就是错误的。只是实现。有很多方法可以以一种正确的、不那么令人沮丧的方式实现这一点，我真诚地希望 Kotlin 语言设计者会选择这条路。如果没有，那么编译器插件可能是我们尝试新事物的一种方式！