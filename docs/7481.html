<html>
<head>
<title>A Deep Dive of CVE-2022–33987 (Got allows a redirect to a UNIX socket)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CVE-2022–33987的深度剖析(Got允许重定向到UNIX套接字)</h1>
<blockquote>原文：<a href="https://itnext.io/a-deep-dive-of-cve-2022-33987-got-allows-a-redirect-to-a-unix-socket-cdeed53944f7?source=collection_archive---------1-----------------------#2022-10-06">https://itnext.io/a-deep-dive-of-cve-2022-33987-got-allows-a-redirect-to-a-unix-socket-cdeed53944f7?source=collection_archive---------1-----------------------#2022-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4487" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个星期，几乎毫无例外，我都会遇到一件让我困惑、娱乐或者最常见的激怒我的事情。我决定记录我的冒险经历。</p><p id="612a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我订阅了几个PHP项目的安全版本。我这样做并不是因为PHP项目有很多弱点(好吧，它们可能有)，而是因为它们是最受审查的代码之一。所以上周当我看到<a class="ae kl" href="https://www.mediawiki.org/wiki/MediaWiki" rel="noopener ugc nofollow" target="_blank"> MediaWiki </a>发布了一个新的安全版本时，我想更深入地了解一下。</p><h1 id="a753" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">背景</strong></h1><p id="6cae" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在正常环境下，使用<a class="ae kl" href="http://invalid:/" rel="noopener ugc nofollow" target="_blank"> Github的分支/标签比较功能</a>，可以快速识别版本之间的安全补丁。MediaWiki <a class="ae kl" href="https://phabricator.wikimedia.org/T311360" rel="noopener ugc nofollow" target="_blank">在他们的Phabricator </a>上保存了大量的项目信息，这有助于这项工作。浏览2.81.4版本中的提交，我注意到变化大致分为三个阵营:</p><p id="f2f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1)准备好PHP 9对传递给内置函数的空类型的弃用，这些内置函数需要字符串(更多细节参见<a class="ae kl" href="https://phpandmysql.com/updates/passing-null-to-string-functions/" rel="noopener ugc nofollow" target="_blank">本博客</a>)</p><p id="43c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2)依赖性更新(其中一些是安全更新，这是我们所关心的)</p><p id="85c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3)通过最近的更改修复一些性能问题</p><p id="30ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像任何好的项目一样，更新易受攻击的依赖关系对安全故事来说是至关重要的，MediaWiki似乎在这方面做得很好(尽管在此版本中修补的漏洞已在2022年5月25日上游修补)。通过查看提交，我们在一些上看到以下消息:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="48e5" class="ly kn iq lu b gy lz ma l mb mc">Updating got to 11.8.5</span><span id="f20f" class="ly kn iq lu b gy md ma l mb mc">* GHSA-pfrx-2q88-qq97</span></pre><p id="490a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有趣的是，MediaWiki皮肤和扩展正在运行易受攻击的版本'<em class="me"> got </em>'，一个节点HTTP请求库。当我意识到一个PHP项目的安全发布是由于一个节点安全问题时，我有一种复杂的感觉，但我继续前进。以下是带有凸起的子模块<em class="me">得到了</em>版本。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="58ea" class="ly kn iq lu b gy lz ma l mb mc">skins/MinervaNeue</span><span id="87d3" class="ly kn iq lu b gy md ma l mb mc">extensions/Math</span><span id="078b" class="ly kn iq lu b gy md ma l mb mc">extensions/AbuseFilter</span></pre><h1 id="b55f" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">问题</strong></h1><p id="4e16" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">那么，<em class="me">让</em>做的事情有什么不好呢？事实证明，在一个有点令人想起的问题中，问题是对一个有点模糊的方案的方案处理。</p><p id="2641" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回到2015年9月的<a class="ae kl" href="http://invalid:/" rel="noopener ugc nofollow" target="_blank">版本4.1.1 </a> , <em class="me">获得了</em>对<a class="ae kl" href="https://github.com/sindresorhus/got/pull/96" rel="noopener ugc nofollow" target="_blank">通过Unix域套接字</a>发出请求的支持。概述的目的很简单，用户可能希望向运行在本地服务器上的套接字发出请求。这与向localhost发出请求没有太大区别，但是，<a class="ae kl" href="https://en.wikipedia.org/wiki/Unix_domain_socket" rel="noopener ugc nofollow" target="_blank"> Unix sockets </a> <em class="me">倾向于</em>运行更强大的IPC工具，提供的用例是“docker”和“fleet”，这给了你一些思路。</p><p id="53f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果是他们最终增加了对Unix模式:“unix:/”和HTTP Unix模式:“http://unix:/”的支持。他们从现在已被否决的请求框架中借用了<a class="ae kl" href="https://github.com/request/request/pull/516" rel="noopener ugc nofollow" target="_blank">后一种格式(稍后会详细介绍)。有趣的是，使用直接的“unix:/”方案实际上并不可行，至少在11.8.3中是这样的，其中的依赖项<em class="me"> http-timer </em>无法解析这种URL格式(哎呀):</a></p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="a54d" class="ly kn iq lu b gy lz ma l mb mc">at origin.emit (node_modules/@szmarczak/http-timer/dist/source/index.js:43:20)</span><span id="9568" class="ly kn iq lu b gy md ma l mb mc">code: ‘ERR_INVALID_PROTOCOL’</span></pre><p id="9137" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题的关键不是发出Unix套接字请求，而是重定向如何发生的本质。<strong class="jp ir">如果恶意用户能够向易受攻击的应用程序提供URL，他们可以提供解析为30x重定向的URL，该URL最终位于unix:// socket位置。</strong>向本地主机或本地网络发出请求很大程度上就是<a class="ae kl" href="https://en.wikipedia.org/wiki/Server-side_request_forgery" rel="noopener ugc nofollow" target="_blank">服务器站点请求伪造</a> ( <strong class="jp ir"> #SSRF </strong>)。通常，我们期望开发者过滤这样的请求，这里的问题是标准开发者没有办法阻止这种方案被使用，因为<strong class="jp ir">即使他们最初验证了URL，<em class="me">得到</em>正在自动处理重定向</strong>。</p><p id="a3e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有趣的是，<em class="me"> got </em>建议不同的库添加SSRF保护，<a class="ae kl" href="https://github.com/hanover-computing/got-ssrf" rel="noopener ugc nofollow" target="_blank"> got-ssrf </a>。这将最终防止问题，因为URL的“unix”部分将最终成为URL的主机名，got-ssrf将尝试解决这个问题，但失败了，因此它返回:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="1396" class="ly kn iq lu b gy lz ma l mb mc">RequestError: getaddrinfo ENOTFOUND unix</span></pre><p id="b1b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一点上，我们想看看用户可以用Unix套接字做什么。最明显的例子是Docker之类的服务，但有时你也可以检查文件是否存在。本地用户通常能够使用类似下面的内容直接与Docker套接字通信:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="a89f" class="ly kn iq lu b gy lz ma l mb mc">curl — silent -XGET — unix-socket /var/run/docker.sock <a class="ae kl" href="http://localhost/version" rel="noopener ugc nofollow" target="_blank">http://localhost/version</a></span></pre><p id="5bdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这相当于下面的<em class="me">中得了</em>:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="4f65" class="ly kn iq lu b gy lz ma l mb mc">got(‘http://unix:/var/run/docker.sock:/version')</span></pre><p id="9dbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前一个例子很做作，但是<a class="ae kl" href="https://docs.docker.com/engine/api/v1.41/" rel="noopener ugc nofollow" target="_blank"> Docker管理API </a>更强大，给出了请求方法(GET、POST等)。)，它支持类似于<a class="ae kl" href="https://docs.docker.com/engine/api/v1.41/#tag/Container/operation/ContainerCreate" rel="noopener ugc nofollow" target="_blank">创建容器</a>(POST)<a class="ae kl" href="https://docs.docker.com/engine/api/v1.41/#tag/Container/operation/ContainerKill" rel="noopener ugc nofollow" target="_blank">杀死容器</a>(POST)<a class="ae kl" href="https://docs.docker.com/engine/api/v1.41/#tag/System/operation/SystemAuth" rel="noopener ugc nofollow" target="_blank">检查授权配置</a>(POST)<a class="ae kl" href="https://docs.docker.com/engine/api/v1.41/#tag/Exec/operation/ContainerExec" rel="noopener ugc nofollow" target="_blank">在运行的容器中执行命令</a>(POST)<a class="ae kl" href="https://docs.docker.com/engine/api/v1.41/#tag/Container/operation/ContainerLogs" rel="noopener ugc nofollow" target="_blank">获取容器日志</a>(GET)<a class="ae kl" href="https://docs.docker.com/engine/api/v1.41/#tag/Container/operation/ContainerExport" rel="noopener ugc nofollow" target="_blank">导出容器或图像</a> (GET)等等。</p><p id="564b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更糟糕的是，在<em class="me">GET</em>中，许多HTTP状态代码都遵循重定向，因此攻击者可以使用307或308将POST请求及其内容传递给Unix套接字<a class="ae kl" href="https://github.com/sindresorhus/got/blob/623229fad64b89a58c68c9f47fc36a4883cc994a/documentation/2-options.md#methodrewriting" rel="noopener ugc nofollow" target="_blank">，而无需将其重写为GET </a>请求，如果易受攻击的应用程序正在编制POST请求。</p><p id="3de5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我前面提到过，<em class="me">得到了</em> <a class="ae kl" href="https://github.com/request/request/pull/516" rel="noopener ugc nofollow" target="_blank">从现在已经弃用的</a><a class="ae kl" href="https://github.com/request/request" rel="noopener ugc nofollow" target="_blank"> <em class="me">请求</em>框架</a>中借用了http://unix/ formatting 。如果我没有查看'<em class="me"> request </em>'框架，看看是否会出现同样的漏洞，那我就失职了。如你所料，是的，它也很脆弱。严格来说，这也应该是一个独特的CVE，但因为<em class="me">请求</em>已被否决，他们不太可能响应。有趣的是，有一个<a class="ae kl" href="https://github.com/request/request/issues/2327" rel="noopener ugc nofollow" target="_blank">已知的问题</a>，要求设置主机头，这在更多情况下无法工作。我想是小小的胜利。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="d1f0" class="ly kn iq lu b gy lz ma l mb mc">import request from 'request'<br/><br/>// http://127.0.0.1:81 redirects with a 307 to http://unix:/var/run/docker.sock:/version<br/>request({<br/>    uri: 'http://127.0.0.1:81',<br/>    headers: {<br/>    'host' : "anything"<br/>    },<br/>  },<br/>  function (error, response, body) {<br/>    console.log('body:', body);<br/>});</span></pre><p id="e970" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解决方案</strong></p><p id="f910" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">对于大多数人来说，解决方案是将<em class="me">升级到版本11.8.4或更高版本。</em></strong>此外，如果接受不可信的URL进行解析，<strong class="jp ir">开发人员需要了解SSRF，</strong> <a class="ae kl" href="https://github.com/sindresorhus/got/blame/main/documentation/2-options.md#L952" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">执行URL净化/验证</strong> </a> <strong class="jp ir">以确保他们没有解析敏感的URL</strong>。</p><p id="9b3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从<em class="me">的人们那里得到的</em>的解决方案是相当<a class="ae kl" href="https://github.com/sindresorhus/got/pull/2047" rel="noopener ugc nofollow" target="_blank">直接</a>的。开发人员简单地<a class="ae kl" href="https://github.com/sindresorhus/got/blob/d54cd3f85a2763f73084327a6e7690caa6472c5f/source/core/index.ts#L731" rel="noopener ugc nofollow" target="_blank">检查以确保具有Unix套接字的重定向URL被阻止，除非初始化的URL也是Unix套接字</a>。<a class="ae kl" href="https://github.com/sindresorhus/got/issues/2046" rel="noopener ugc nofollow" target="_blank">他们还提议</a>将选项<a class="ae kl" href="https://github.com/sindresorhus/got/blob/main/documentation/2-options.md#enableunixsockets" rel="noopener ugc nofollow" target="_blank"> EnableUnixSockets </a>默认为false，以在默认情况下完全禁用Unix域。</p><p id="c54c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">至于MediaWiki，事实证明他们只是使用了<em class="me"> got </em>作为他们测试套件</strong>的一部分，所以大部分情况下他们没有受到影响，但不管怎样，他们更新了他们的依赖项，这很好。<strong class="jp ir">不幸的是，他们更新的一些模块</strong> <a class="ae kl" href="https://github.com/wikimedia/mediawiki-extensions-AbuseFilter/blob/master/package-lock.json#L8436" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">也依赖</strong> </a> <strong class="jp ir">对<em class="me">的请求，</em>既被弃用，又如我所展示的，易受攻击</strong>。哇，为了这个结论走了很长一段路，是吧？</p></div></div>    
</body>
</html>