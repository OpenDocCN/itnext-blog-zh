<html>
<head>
<title>Micro APIs with OpenFaaS and .NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有OpenFaaS和。网</h1>
<blockquote>原文：<a href="https://itnext.io/micro-apis-with-openfaas-and-net-f82115efce4?source=collection_archive---------5-----------------------#2021-02-04">https://itnext.io/micro-apis-with-openfaas-and-net-f82115efce4?source=collection_archive---------5-----------------------#2021-02-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/81d9c04470cfb4a37305d41a16271a40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*aFM1ZId_4mKv1vub9F6mTQ.png"/></div></figure><p id="6088" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">无服务器功能正变得越来越流行，但并不是一切都适合这种模式。尽管可以为资源上的每个操作创建一个带有函数的API，但这很容易变得难以管理。</p><p id="0994" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">幸运的是，OpenFaaS可以承载各种类型的工作负载，而不仅仅是功能，只要它们服务于HTTP流量，假设是短暂存储，并且是无状态的。这意味着，如果我们愿意(不是说我们应该)，我们可以将整个API捆绑在一个工作负载之后。</p><h1 id="30a5" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">微型API</h1><p id="1214" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">微API背后的想法是拥有一个微服务来实现特定上下文的API——通常是一个或非常有限的一组资源。这种特殊的环境确保你不会重复太多的代码，并关注微服务的行为。</p><p id="378d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">经验法则是，它应该足够小，以便只关注重要的事情(上下文)，并且足够大，以便避免代码重复和碎片化(超出上下文)。</p><p id="1d77" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">例如，如果我们的上下文是用户，那么微API应该只关注用户。另一方面，如果我们的上下文是博客中的帖子，那么<em class="lv">可能</em>是微API既处理帖子又处理帖子评论——或者我们可能有两个独立的微API。</p><p id="73c6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">作为一个例子，让我们考虑我们想要管理待办事项列表上的笔记。我们的上下文是notes，我们需要以下操作:</p><ul class=""><li id="ce3a" class="lw lx iq jw b jx jy kb kc kf ly kj lz kn ma kr mb mc md me bi translated">获取笔记列表</li><li id="2e42" class="lw lx iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">检索现有便笺</li><li id="c3f7" class="lw lx iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">添加新注释</li><li id="8901" class="lw lx iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">更改现有便笺</li><li id="8ad4" class="lw lx iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">删除便笺</li></ul><p id="4ac9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的微API将实现notes资源和上述操作。没别的了。</p><h1 id="bdf1" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><strong class="ak">环境</strong></h1><p id="9056" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">本文并不关注如何设置一个可用的OpenFaaS集群，而是假设您已经有了一个或者知道如何设置。这样做有多种选择，从托管kubernetes集群到<a class="ae mk" href="https://minikube.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank"> minikube </a>或<a class="ae mk" href="https://github.com/openfaas/faasd" rel="noopener ugc nofollow" target="_blank"> faasd </a>。你可以看一下<a class="ae mk" href="https://goncalo-a-oliveira.medium.com/setting-up-openfaas-with-minikube-28ed2f78dd1b" rel="noopener">这篇文章</a>来学习如何用<a class="ae mk" href="https://minikube.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank"> minikube </a>建立一个环境。</p><h1 id="ae9e" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">ASPNET函数</h1><p id="f56c" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">我们可以用。NET并使用Dockerfile托管它，但这将意味着为每个微API编写Dockerfile和所有项目样板文件。因此，我们将使用<a class="ae mk" href="https://github.com/goncalo-oliveira/faas-aspnet-template" rel="noopener ugc nofollow" target="_blank"> ASPNET Functions </a>模板来处理所有这些问题，并且最近添加了一个新的控制器模板，正好适合这些场景。</p><h2 id="dd8c" class="ml kt iq bd ku mm mn dn ky mo mp dp lc kf mq mr lg kj ms mt lk kn mu mv lo mw bi translated">装置</h2><p id="cd79" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">模板随<code class="fe mx my mz na b">faas-cli</code>一起安装，从git存储库中取出。</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="f83a" class="ml kt iq na b gy nj nk l nl nm">$ faas-cli template pull <a class="ae mk" href="https://github.com/goncalo-oliveira/faas-aspnet-template" rel="noopener ugc nofollow" target="_blank">https://github.com/goncalo-oliveira/faas-aspnet-template</a></span></pre><p id="5c75" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这将安装三个模板:</p><ul class=""><li id="db62" class="lw lx iq jw b jx jy kb kc kf ly kj lz kn ma kr mb mc md me bi translated">aspnet</li><li id="db75" class="lw lx iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">aspnet控制器</li><li id="e21b" class="lw lx iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">aspnet-fsharp</li></ul><p id="7444" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mx my mz na b">aspnet</code>和<code class="fe mx my mz na b">aspnet-fsharp</code>模板是为功能设计的，专注于做一个单一的操作。然而，<code class="fe mx my mz na b">aspnet-controller</code>模板实现了一个<code class="fe mx my mz na b">Controller</code>类，允许我们实现多个操作。</p><h2 id="a013" class="ml kt iq bd ku mm mn dn ky mo mp dp lc kf mq mr lg kj ms mt lk kn mu mv lo mw bi translated">创建我们的微API</h2><p id="f9a9" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">让我们从使用<code class="fe mx my mz na b">aspnet-controller</code>模板创建我们的工作负载开始。</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="b0dc" class="ml kt iq na b gy nj nk l nl nm">$ faas-cli new --lang aspnet-controller notes</span></pre><p id="c52f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">查看笔记文件夹，我们可以看到一个<code class="fe mx my mz na b">Controller.cs</code>和一个<code class="fe mx my mz na b">Startup.cs</code>文件。<code class="fe mx my mz na b">Startup.cs</code>基本上是空的，因为所有的样板文件都在别处处理。在这里，我们将只添加与我们的项目相关的内容。</p><p id="ba2c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mx my mz na b">Controller.cs</code>本质上是一个Hello World，几乎是一个空白页。</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="b0de" class="ml kt iq na b gy nj nk l nl nm">using System;<br/>using System.Threading.Tasks;<br/>using Microsoft.AspNetCore.Mvc;</span><span id="73a8" class="ml kt iq na b gy nn nk l nl nm">namespace OpenFaaS<br/>{<br/>    [ApiController]<br/>    [Route("/")]<br/>    public class Controller : ControllerBase<br/>    {<br/>        [HttpGet]<br/>        public Task&lt;IActionResult&gt; GetAsync()<br/>        {<br/>            var result = new<br/>            {<br/>                Message = "Hello!"<br/>            };</span><span id="f150" class="ml kt iq na b gy nn nk l nl nm">            return Task.FromResult&lt;IActionResult&gt;( Ok( result ) );<br/>        }<br/>    }<br/>}</span></pre><p id="d5fc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我们继续之前，让我们在本地运行我们的项目。有几种方法可以做到这一点，但我们将使用<a class="ae mk" href="https://github.com/goncalo-oliveira/faas-run" rel="noopener ugc nofollow" target="_blank"> FaaS运行器</a>来完成，因为这对调试很有用。</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="b425" class="ml kt iq na b gy nj nk l nl nm">$ cd notes<br/>$ dotnet build</span><span id="db8e" class="ml kt iq na b gy nn nk l nl nm">$ faas-run bin/Debug/netstandard2.0/function.dll<br/>OpenFaaS ASPNET Function Loader</span><span id="c253" class="ml kt iq na b gy nn nk l nl nm">To debug attach to process id 1705.</span><span id="eb1f" class="ml kt iq na b gy nn nk l nl nm">Loaded function assembly bin/Debug/netstandard2.0/function.dll.<br/>info: Microsoft.Hosting.Lifetime[0]<br/>      Now listening on: <a class="ae mk" href="http://[::]:9000" rel="noopener ugc nofollow" target="_blank">http://[::]:9000</a></span></pre><p id="0f85" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">默认情况下，它运行在端口9000上，但是我们可以用<code class="fe mx my mz na b">--port</code>标志来改变它。让我们试试我们的服务。</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="fbde" class="ml kt iq na b gy nj nk l nl nm">$ curl localhost:9000<br/>{"message":"Hello!"}</span></pre><h2 id="774a" class="ml kt iq bd ku mm mn dn ky mo mp dp lc kf mq mr lg kj ms mt lk kn mu mv lo mw bi translated">实施操作</h2><p id="4bc2" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">我们首先为笔记的结构创建一个<code class="fe mx my mz na b">Note.cs</code>文件。</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="9428" class="ml kt iq na b gy nj nk l nl nm">using System;</span><span id="4b7f" class="ml kt iq na b gy nn nk l nl nm">namespace OpenFaaS<br/>{<br/>    public class Note<br/>    {<br/>        public string Id { get; set; }<br/>        public string Content { get; set; }<br/>    }<br/>}</span></pre><p id="a68f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由于这只是出于教育目的，我们没有将笔记存储在物理存储上，因此，在服务运行时，我们只是将它们保存在内存中，使用静态字典。我们也不会为并发性而烦恼。我们还删除了<code class="fe mx my mz na b">async</code>,因为没有任务，以提高代码的可读性。</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="630c" class="ml kt iq na b gy nj nk l nl nm">public class Controller : ControllerBase<br/>{<br/>    private static readonly IDictionary&lt;string, Note&gt; dictionary = new Dictionary&lt;string, Note&gt;();</span></pre><p id="096e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在让我们实现我们的操作。我们从音符列表开始。该操作将只返回笔记的id，而不是它们的内容。我们删除现有的<code class="fe mx my mz na b">GetAsync</code>方法，并添加以下内容:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="f05e" class="ml kt iq na b gy nj nk l nl nm">[HttpGet]<br/>public IActionResult Get()<br/>{<br/>    var notes = dictionary.Values.Select( note =&gt; new Note<br/>    {<br/>        Id = note.Id<br/>    } )<br/>    .ToArray();</span><span id="0e0b" class="ml kt iq na b gy nn nk l nl nm">    if ( !notes.Any() )<br/>    {<br/>        return NoContent();<br/>    }</span><span id="42eb" class="ml kt iq na b gy nn nk l nl nm">    return Ok( notes );<br/>}</span></pre><p id="621e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在检索单个注释的操作，在这里我们需要添加一个路由模板。</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="a000" class="ml kt iq na b gy nj nk l nl nm">[HttpGet( "{id}" )]<br/>public IActionResult GetSingle( string id )<br/>{<br/>    if ( !dictionary.TryGetValue( id, out var note ) )<br/>    {<br/>        return NotFound();<br/>    }</span><span id="bbea" class="ml kt iq na b gy nn nk l nl nm">    return Ok( note );<br/>}</span></pre><p id="8c3a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里没有什么不同于我们使用Web API所做的。让我们添加剩余的操作。</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="972f" class="ml kt iq na b gy nj nk l nl nm">[HttpPost]<br/>public IActionResult Post( [FromBody] Note note )<br/>{<br/>    note.Id = Guid.NewGuid().ToString();</span><span id="d3fe" class="ml kt iq na b gy nn nk l nl nm">    dictionary.Add( note.Id, note );</span><span id="38a7" class="ml kt iq na b gy nn nk l nl nm">    // we should return a 201 Created response here<br/>    // but let's keep it simple as it's not the<br/>    // purpose of the article<br/>    return Ok( note );<br/>}</span><span id="4a7f" class="ml kt iq na b gy nn nk l nl nm">[HttpPut( "{id}" )]<br/>public IActionResult Put( string id, [FromBody] Note note )<br/>{<br/>    if ( !dictionary.ContainsKey( id ) )<br/>    {<br/>        return NotFound();<br/>    }</span><span id="27b5" class="ml kt iq na b gy nn nk l nl nm">    note.Id = id;</span><span id="1b30" class="ml kt iq na b gy nn nk l nl nm">    dictionary[id] = note;</span><span id="5c3e" class="ml kt iq na b gy nn nk l nl nm">    return Ok( note );<br/>}</span><span id="884d" class="ml kt iq na b gy nn nk l nl nm">[HttpDelete( "{id}" )]<br/>public IActionResult Delete( string id )<br/>{<br/>    if ( !dictionary.ContainsKey( id ) )<br/>    {<br/>        return NotFound();<br/>    }</span><span id="cc20" class="ml kt iq na b gy nn nk l nl nm">    dictionary.Remove( id );</span><span id="61a1" class="ml kt iq na b gy nn nk l nl nm">    return NoContent();<br/>}</span></pre><p id="283b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">完整的源代码可以在<a class="ae mk" href="https://github.com/goncalo-oliveira/example-openfaas-microapi" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><h2 id="b03a" class="ml kt iq bd ku mm mn dn ky mo mp dp lc kf mq mr lg kj ms mt lk kn mu mv lo mw bi translated">测试它</h2><p id="03dc" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">就是这样。让我们构建它并在本地运行它。</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="125e" class="ml kt iq na b gy nj nk l nl nm">$ dotnet build</span><span id="fd9f" class="ml kt iq na b gy nn nk l nl nm">$ faas-run bin/Debug/netstandard2.0/function.dll</span></pre><p id="0408" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们试一试。我们将首先插入两个音符。我在Linux上用的是<code class="fe mx my mz na b">curl</code>，不过你可以用<a class="ae mk" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>或者别的。</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="2e6a" class="ml kt iq na b gy nj nk l nl nm">$ curl -X POST -H "Content-Type: application/json" \<br/> -d '{"content": "this is my first note"}' \<br/> localhost:9000<br/>{"id":"37b3ad6a-2f60-49aa-95c8-9fd7cdac0e3f","content":"this is my first note"}</span><span id="83d9" class="ml kt iq na b gy nn nk l nl nm">$ curl -X POST -H "Content-Type: application/json" \<br/> -d '{"content": "a second note"}' \<br/> localhost:9000<br/>{"id":"c98d058d-e24e-4b23-907a-9a2d4d298ad6","content":"a second note"}</span></pre><p id="3ad0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们现在应该有两个音符。我们来列举一下。</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="4534" class="ml kt iq na b gy nj nk l nl nm">$ curl localhost:9000<br/>[{"id":"37b3ad6a-2f60-49aa-95c8-9fd7cdac0e3f"},{"id":"c98d058d-e24e-4b23-907a-9a2d4d298ad6"}]</span></pre><p id="79b5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们使用id来检索第二个笔记。</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="8c7a" class="ml kt iq na b gy nj nk l nl nm">$ curl localhost:9000/c98d058d-e24e-4b23-907a-9a2d4d298ad6<br/>{"id":"c98d058d-e24e-4b23-907a-9a2d4d298ad6","content":"a second note"}</span></pre><p id="4ea6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们将更新第二个音符并再次检索它。</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="5c3b" class="ml kt iq na b gy nj nk l nl nm">$ curl -X PUT -H "Content-Type: application/json" \<br/> -d '{"content": "still my second note"}' \<br/> localhost:9000/c98d058d-e24e-4b23-907a-9a2d4d298ad6<br/>{"id":"c98d058d-e24e-4b23-907a-9a2d4d298ad6","content":"still my second note"}</span><span id="5ea1" class="ml kt iq na b gy nn nk l nl nm">$ curl localhost:9000/c98d058d-e24e-4b23-907a-9a2d4d298ad6<br/>{"id":"c98d058d-e24e-4b23-907a-9a2d4d298ad6","content":"still my second note"}</span></pre><p id="f3f6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">唯一缺少的操作是删除一条注释。我们先删除第一个。</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="a85e" class="ml kt iq na b gy nj nk l nl nm">$ curl -X DELETE localhost:9000/37b3ad6a-2f60-49aa-95c8-9fd7cdac0e3f</span><span id="280a" class="ml kt iq na b gy nn nk l nl nm">$ curl localhost:9000<br/>[{"id":"c98d058d-e24e-4b23-907a-9a2d4d298ad6"}]</span></pre><h2 id="26e5" class="ml kt iq bd ku mm mn dn ky mo mp dp lc kf mq mr lg kj ms mt lk kn mu mv lo mw bi translated">多个控制器</h2><p id="bf2d" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">尽管模板被明确设计成只有一个控制器，但这只是概念上的，并不是限制。如果我们的环境需要不止一个控制器，我们可以这样做。我们甚至可以删除<code class="fe mx my mz na b">Controller.cs</code>文件并添加我们自己的控制器，例如<code class="fe mx my mz na b">CarsController.cs</code>和<code class="fe mx my mz na b">ModelsController.cs</code>——就像我们对常规Web API所做的一样。</p><p id="6a12" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请记住，如果你开始添加与特定上下文无关的东西，那么它可能就不再是一个微API了。</p><h1 id="7f0a" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">最后的话</h1><p id="0410" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">微API的概念很有趣，介于无服务器功能和微服务之间。由于OpenFaaS能够运行除函数之外的不同工作负载，我们可以使用相同的工具并从中受益。</p><p id="5415" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你喜欢，一定要鼓掌，并随时发表评论。另外，别忘了在GitHub上启动<a class="ae mk" href="https://github.com/openfaas/faas" rel="noopener ugc nofollow" target="_blank"> OpenFaaS </a>和<a class="ae mk" href="https://github.com/goncalo-oliveira/faas-aspnet-template" rel="noopener ugc nofollow" target="_blank"> ASPNET Functions </a>项目，以示支持。</p></div></div>    
</body>
</html>