<html>
<head>
<title>Jenkins X — Managing Jenkins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jenkins X —管理Jenkins</h1>
<blockquote>原文：<a href="https://itnext.io/jenkins-x-managing-jenkins-926f0e0f8bcf?source=collection_archive---------4-----------------------#2019-08-07">https://itnext.io/jenkins-x-managing-jenkins-926f0e0f8bcf?source=collection_archive---------4-----------------------#2019-08-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/62b18f26b7bdc2e8a70b500c03bd7801.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WPUrgP0-oC4NeYwA.png"/></div></div></figure><p id="4b07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">欢迎回到我关于Jenkins X的迷你系列。在上一篇文章中，我讨论了如何在预览环境中启用TLS。这一次我们将讨论Jenkins服务器，以及我们如何在<a class="ae kz" href="https://www.datameer.com/" rel="noopener ugc nofollow" target="_blank"> Datameer </a>管理作业和配置的变更和更新。</p><p id="5751" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我承认，写这篇文章花了我太多的时间。主要是因为它有太多的方面和角度，我无法决定正确的结构，经常交换出大量的信息，但半小时后又交换回来。你甚至会发现应用这篇文章中的观点比实际阅读它们要快。</p><blockquote class="la"><p id="a142" class="lb lc it bd ld le lf lg lh li lj ky dk translated">还是那句话，没有鸡没有蛋…</p></blockquote><p id="a551" class="pw-post-body-paragraph kb kc it kd b ke lk kg kh ki ll kk kl km lm ko kp kq ln ks kt ku lo kw kx ky im bi translated">我决定采用以下结构，尽量让每个部分都是可选的，让你挑选最适合自己的部分:</p><ol class=""><li id="e6f1" class="lp lq it kd b ke kf ki kj km lr kq ls ku lt ky lu lv lw lx bi translated"><strong class="kd iu">创建Jenkins映像</strong> <br/>本节将向您展示如何创建一个定制的docker映像，并将其集成到您当前的Jenkins X版本中。</li><li id="2996" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky lu lv lw lx bi translated"><strong class="kd iu"> <em class="md">奖励部分:</em>我们如何安全地更新Jenkins X </strong> <br/>正如标题所示，这提供了一种无压力的方法来更新和升级Jenkins X平台。</li><li id="86d6" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky lu lv lw lx bi translated"><strong class="kd iu">持久插件</strong> <br/>在这里，我将讨论跨pod重启持久化我们的插件更新。</li><li id="913a" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky lu lv lw lx bi translated"><strong class="kd iu"> OAuth for Jenkins(手动)</strong> <br/>本节将向您展示如何使用GitHub或Google为Jenkins启用OAuth。我还将探索“基于矩阵的安全性”,以便对用户权限进行更好的控制。</li><li id="dbbf" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky lu lv lw lx bi translated"><strong class="kd iu"> OAuth for Jenkins(自动)</strong> <br/>同上，但在pod重新启动后仍然存在。</li><li id="df73" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky lu lv lw lx bi translated"><strong class="kd iu">持续工作</strong> <br/>我将介绍一种持续工作的方法。</li></ol></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="7e03" class="ml mm it bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">1.创造詹金斯形象</h1><p id="5588" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated">Jenkins X平台已经自带了自己的<a class="ae kz" href="https://github.com/jenkins-x/jenkins-x-image" rel="noopener ugc nofollow" target="_blank"> Jenkins docker image </a>和一套很好的插件来帮助你入门。然而，插件是嵌入到映像中的，这意味着它们和映像本身一样古老。</p><figure class="np nq nr ns gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/4d522a0f1516a6ee4b36394103ce3521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BhADzWJJIKuIm6k2yvL73A.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">谁没见过这个？</figcaption></figure><p id="07e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这也意味着，如果pod出于任何原因需要重新启动，在活动系统上所做的任何更改都将丢失。这包括:</p><ul class=""><li id="5308" class="lp lq it kd b ke kf ki kj km lr kq ls ku lt ky nx lv lw lx bi translated">任何插件更新</li><li id="c2a2" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">任何附加插件</li><li id="715e" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">詹金斯的配置有什么变化吗</li></ul><p id="0f93" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，我们需要一种方法来保持所有的变化。默认的Jenkins映像已经安装了JCASC插件,所以这似乎是一个很好的开始。然而，虽然这个插件在后面会有用，我们决定不使用它来添加额外的插件，因为JCasC插件是在启动时安装/更新的，这意味着pod重新启动的次数会大大增加。</p><p id="7a82" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">相反，我们决定创造自己的形象。为了让你开始，在Jenkins X网站上有一些关于创建自定义图像的信息<a class="ae kz" href="https://jenkins-x.io/getting-started/config/#jenkins-image" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="a338" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我的犯罪搭档伊利亚·沙伊斯尔塔诺夫(Ilya Shaisultanov)随后拿出一个詹金斯文件来创建自定义的詹金斯图像。虽然我不能提供完整的文件，但基本上是这样的。</p><p id="276b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">给定一个版本化方案<code class="fe oa ob oc od b">&lt;upstream-version&gt;-&lt;inhouse-version&gt;</code>:</p><ul class=""><li id="a677" class="lp lq it kd b ke kf ki kj km lr kq ls ku lt ky nx lv lw lx bi translated">从<br/><a class="ae kz" href="https://api.github.com/repos/jenkins-x/jenkins-x-image/tags" rel="noopener ugc nofollow" target="_blank">https://api.github.com/repos/jenkins-x/jenkins-x-image/tags</a>获取最新上游版本</li><li id="16a5" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">从我们自己的库获取最新的定制版本:<br/> <code class="fe oa ob oc od b">gcloud container images list-tags $DOCKER_IMAGE — format json</code></li><li id="491a" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">确定我们是否需要构建一个新版本</li><li id="fb7a" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">如有必要，构建并发布</li></ul><p id="0d08" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最初的docker文件如下所示:</p><pre class="np nq nr ns gt oe od of og aw oh bi"><span id="2172" class="oi mm it od b gy oj ok l ol om">FROM jenkinsxio/jenkinsx:REPLACE_UPSTREAM_VERSION</span><span id="3ec3" class="oi mm it od b gy on ok l ol om">COPY plugins.txt /usr/share/jenkins/ref/custom-plugins.txt</span><span id="9867" class="oi mm it od b gy on ok l ol om">RUN /usr/local/bin/install-plugins.sh &lt; /usr/share/jenkins/ref/custom-plugins.txt</span></pre><p id="4a74" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据Jenkins X文档,<code class="fe oa ob oc od b">plugins.txt</code>可以包含您希望以下列形式安装的任何附加自定义插件:</p><pre class="np nq nr ns gt oe od of og aw oh bi"><span id="e92b" class="oi mm it od b gy oj ok l ol om">&lt;plugin-name&gt;:&lt;plugin-version&gt;</span></pre><p id="0dc6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们只剩下以下使用skaffold.yaml构建docker映像的文件:</p><pre class="np nq nr ns gt oe od of og aw oh bi"><span id="e2b7" class="oi mm it od b gy oj ok l ol om">├── Dockerfile         # docker image to build<br/>├── plugins.txt        # any extra plugins to include<br/>└── skaffold.yaml      # skaffold to build and push the image</span></pre><p id="c4bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">几分钟后，我们有了我们的图像:<code class="fe oa ob oc od b">my-reg/my-company/jenkins-x-image:0.0.70–1</code></p><p id="e5f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了把这个图像添加到你的詹金斯X版本中，我们需要通过把它添加到我们的<code class="fe oa ob oc od b">myvalues.yaml</code>中来覆盖默认的舵图表值。这将看起来像:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="9cf0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经有了映像，我们需要刷新Jenkins X版本。这将在下一节中讨论。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="fe8e" class="ml mm it bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated"><strong class="ak">我们如何安全刷新詹金斯X </strong></h1><p id="ada6" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated">打电话给<code class="fe oa ob oc od b">jx upgrade platform</code>可能是一项艰巨的任务。</p><p id="e0f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尤其是像我一样，有多个配置不同的集群。我从来不确定<code class="fe oa ob oc od b">jx</code>二进制文件会在本地<code class="fe oa ob oc od b">~/.jx/</code>目录中找到什么。</p><p id="a648" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是你可以采取的一些措施，以最大限度地降低出错的几率:</p><ul class=""><li id="79fa" class="lp lq it kd b ke kf ki kj km lr kq ls ku lt ky nx lv lw lx bi translated">确保您的当前目录包含正确的<code class="fe oa ob oc od b">myvalues.yaml</code></li><li id="5170" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">创建一个临时目录并运行<code class="fe oa ob oc od b">export JX_HOME=${JX_TEMP_DIR}</code></li><li id="5c4c" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">用<br/> <code class="fe oa ob oc od b">jx step helm list | grep jenkins-x</code>找到平台当前发布的版本</li><li id="e386" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">用当前发布的版本更新，有效地用您新创建的值文件刷新平台:<br/> <code class="fe oa ob oc od b">jx upgrade platform --batch-mode --verbose --version ${JX_VERSION} --always-upgrade</code></li></ul><blockquote class="oq or os"><p id="da02" class="kb kc md kd b ke kf kg kh ki kj kk kl ot kn ko kp ou kr ks kt ov kv kw kx ky im bi translated"><strong class="kd iu">注意:</strong>需要<code class="fe oa ob oc od b">--always-upgrade</code>选项来强制升级过程</p></blockquote><p id="6ea0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有一个小脚本可以做到这一点:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="cbad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">运行脚本并更新平台后，您应该可以使用您的映像看到Jenkins部署:</p><pre class="np nq nr ns gt oe od of og aw oh bi"><span id="a578" class="oi mm it od b gy oj ok l ol om">$ kubectl get deployments.apps jenkins \<br/>  -oyaml -o'jsonpath={ .spec.template.spec.containers[0].image }</span><span id="4f38" class="oi mm it od b gy on ok l ol om">my-reg/my-company/jenkins-x-image:0.0.70–1<!-- --> </span></pre><p id="ff4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在下一节中，我们将讨论如何填充<code class="fe oa ob oc od b">plugins.txt</code>。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="9da1" class="ml mm it bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">持久插件</h1><p id="55d0" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated">根据Jenkins X文档,<code class="fe oa ob oc od b">plugins.txt</code>可以包含你想要安装的任何额外的定制插件。这让我想到…</p><blockquote class="la"><p id="fd03" class="lb lc it bd ld le lf lg lh li lj ky dk translated">"为什么不让它包含所有我的插件？"</p></blockquote><p id="1be5" class="pw-post-body-paragraph kb kc it kd b ke lk kg kh ki ll kk kl km lm ko kp kq ln ks kt ku lo kw kx ky im bi translated">在<strong class="kd iu">脚本控制台</strong>页面(<code class="fe oa ob oc od b">http://JENKINS_URL/script</code>)运行一个小脚本就可以实现列出所有插件及其各自的版本。在jenkinsci/docker GitHub页面上提到了另一种获得插件的方法<a class="ae kz" href="https://github.com/jenkinsci/docker#plugin-version-format" rel="noopener ugc nofollow" target="_blank">，但是我更喜欢这种方式。</a></p><p id="1c52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的控制台脚本如下所示:</p><pre class="np nq nr ns gt oe od of og aw oh bi"><span id="731e" class="oi mm it od b gy oj ok l ol om">Jenkins.instance.pluginManager.plugins.stream().sorted().collect(java.util.stream.Collectors.toList()).each { plugin -&gt; <br/>    println ("${plugin.getShortName()}:${plugin.getVersion()}")<br/>}<br/>x=""</span></pre><blockquote class="oq or os"><p id="0c85" class="kb kc md kd b ke kf kg kh ki kj kk kl ot kn ko kp ou kr ks kt ov kv kw kx ky im bi translated"><strong class="kd iu">注1: </strong>结尾的<code class="fe oa ob oc od b">x=""</code>是为了避免groovy在结尾打印结果而做的一点小改动。抛开它，明白我的意思。<br/> <strong class="kd iu">注2: </strong>插件列表已经排序，使得git diffs更容易阅读。</p></blockquote><p id="44bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这也可以使用以下脚本自动完成:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="oo op l"/></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">列出远程服务器的Jenkins插件的脚本</figcaption></figure><p id="6508" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在可以用来自Jenkins服务器的所有实际插件来更新<code class="fe oa ob oc od b">plugins.txt</code>了。</p><blockquote class="oq or os"><p id="4ae0" class="kb kc md kd b ke kf kg kh ki kj kk kl ot kn ko kp ou kr ks kt ov kv kw kx ky im bi translated"><strong class="kd iu">注意:</strong>更新UI中插件的实际过程仍然是手动的。</p><p id="ed43" class="kb kc md kd b ke kf kg kh ki kj kk kl ot kn ko kp ou kr ks kt ov kv kw kx ky im bi translated">然而，在我看来，这是正确的，因为这应该是詹金斯管理员有意识的决定。但是，例如，如果您有一个临时服务器，您总是可以首先更新临时服务器上的插件，测试它们，然后使用临时服务器来提供新映像的列表，以便在生产中使用。</p></blockquote></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="dd02" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试一下新的<code class="fe oa ob oc od b">plugins.txt</code>，好吗:</p><ul class=""><li id="4064" class="lp lq it kd b ke kf ki kj km lr kq ls ku lt ky nx lv lw lx bi translated">通过UI更新你的Jenkins插件，也许添加一个新的插件</li><li id="7049" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">使用<code class="fe oa ob oc od b">refresh-plugins.sh</code>更新您的<code class="fe oa ob oc od b">plugins.txt</code></li><li id="c8f7" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">建立新的码头工人形象</li><li id="472a" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">用新的图像版本更新<code class="fe oa ob oc od b">myvalues.yaml</code></li><li id="0a72" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">使用<code class="fe oa ob oc od b">refresh-jx-platform.sh</code>更新您的Jenkins X版本</li><li id="515e" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">重启詹金斯吊舱按:<br/> <code class="fe oa ob oc od b">kubectl scale deployment jenkins --replicas 0</code> <br/> <code class="fe oa ob oc od b">kubectl scale deployment jenkins --replicas 1</code></li></ul><blockquote class="la"><p id="73b6" class="lb lc it bd ld le ow ox oy oz pa ky dk translated">成功！我的插件是最新的！</p></blockquote><p id="de43" class="pw-post-body-paragraph kb kc it kd b ke lk kg kh ki ll kk kl km lm ko kp kq ln ks kt ku lo kw kx ky im bi translated">所以在添加了刷新脚本和<code class="fe oa ob oc od b">myvalues.yaml</code>之后，我们现在有了以下文件:</p><pre class="np nq nr ns gt oe od of og aw oh bi"><span id="b27b" class="oi mm it od b gy oj ok l ol om">├── my-jenkins-image<br/>│   ├── Dockerfile<br/>│   ├── plugins.txt<br/>│   ├── refresh-plugins.sh<br/>│   └── skaffold.yaml<br/>└── my-jx-platform<br/>    ├── myvalues.yaml<br/>    └── refresh-jx-platform.sh</span></pre><p id="514c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在来解决认证和许可的问题…</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="4041" class="ml mm it bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">詹金斯的OAuth(手动步骤)</h1><p id="15f0" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated">首先，简单介绍一下OAuth到底是什么。</p><p id="f85c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">OAuth 2.0规范与<em class="md">授权</em>的关系大于<em class="md">认证</em>，因此允许第三方服务提供商(在本例中为Google或GitHub)授予用户访问特定资源的权限，在本例中为Jenkins。OAuth 2.0的来龙去脉超出了本文的范围，但作为一个初学者，这里有<a class="ae kz" href="https://stackoverflow.com/a/33704657/1838659" rel="noopener ugc nofollow" target="_blank">Takahiko Kawasaki</a>对Stackoverflow 的精彩解释。</p><p id="d4cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本节将介绍Google和GitHub的OAuth。不管提供者是谁，这一部分的步骤基本上都是相同的:</p><ul class=""><li id="e4a4" class="lp lq it kd b ke kf ki kj km lr kq ls ku lt ky nx lv lw lx bi translated">安装合适的Jenkins插件</li><li id="894c" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">创建OAuth客户端应用程序</li><li id="9ecc" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">使用OAuth应用程序配置插件:<br/> <code class="fe oa ob oc od b">clientID</code> <br/> <code class="fe oa ob oc od b">clientSecret</code></li><li id="704f" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">配置授权策略</li></ul><blockquote class="oq or os"><p id="2fbf" class="kb kc md kd b ke kf kg kh ki kj kk kl ot kn ko kp ou kr ks kt ov kv kw kx ky im bi translated"><strong class="kd iu">专业提示:</strong>如果您在这些步骤中犯了一个错误，并且不知道如何修复它，只需重启Jenkins pod，您将再次获得您的原始配置，因为没有保存任何内容...还没！</p></blockquote></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="4bd1" class="ml mm it bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated"><a class="ae kz" href="https://plugins.jenkins.io/github-oauth" rel="noopener ugc nofollow" target="_blank">谷歌登录插件</a></h1><p id="a07c" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated">文档很少，但工作得足够好。在GitHub上使用这个插件的一个小缺点是不支持Google Groups。这意味着所有非标准权限都需要单独应用。这将在下面的身份验证策略一节中进一步解释。</p><p id="f072" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有一个很好的帖子解释了如何<a class="ae kz" href="http://www.tothenew.com/blog/jenkins-google-authentication/" rel="noopener ugc nofollow" target="_blank">安装和配置谷歌登录插件</a>。</p><p id="4b2e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">没有必要重新发明轮子，嘿🤷‍♂?</p><h1 id="0e04" class="ml mm it bd mn mo pb mq mr ms pc mu mv mw pd my mz na pe nc nd ne pf ng nh ni bi translated"><a class="ae kz" href="https://plugins.jenkins.io/github-oauth" rel="noopener ugc nofollow" target="_blank"> GitHub认证插件</a></h1><p id="bdae" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated">这个插件似乎更成熟一点，同时支持团队和GitHub Enterprise。如果你有选择的话，我会推荐你使用这个插件。</p><p id="c8bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，这是另一篇解释<a class="ae kz" href="https://jenkins.io/solutions/github/" rel="noopener ugc nofollow" target="_blank">如何安装和配置GitHub OAuth插件</a>的精彩文章。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="090f" class="ml mm it bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">配置“基于矩阵的安全性”</h1><p id="2afa" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated">一旦插件配置完成，我们就可以定制我们的“基于矩阵的安全”策略。这里要考虑的主要区别是授权方法，因为这决定了Jenkins如何看待用户，以及我们需要在矩阵规则中放置什么。</p><p id="abeb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">“Google OAuth”</strong>根据用户的电子邮件地址授予用户访问权限，因此任何非标准矩阵规则将<strong class="kd iu">需要使用个人电子邮件地址</strong>，如下所示:</p><figure class="np nq nr ns gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pg"><img src="../Images/8c53101674846c9066d11356290fe2fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NSiiEWo9FoHaLPTu-CNUxg.png"/></div></div></figure><blockquote class="oq or os"><p id="67fd" class="kb kc md kd b ke kf kg kh ki kj kk kl ot kn ko kp ou kr ks kt ov kv kw kx ky im bi translated"><strong class="kd iu">注意:</strong>认证用户代表那些由您的Google OAuth客户端应用程序认证的用户。</p></blockquote></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="ec97" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">“GitHub OAuth”</strong>另一方面，授权访问基于:</p><ul class=""><li id="0a0d" class="lp lq it kd b ke kf ki kj km lr kq ls ku lt ky nx lv lw lx bi translated">个人用户名</li><li id="2f4c" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">全球组织</li><li id="5d11" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">组织内的团队</li></ul><p id="8cdc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这使得基于团队或组织而不仅仅是个人的角色分配更加容易。以下是插件网站的摘录:</p><figure class="np nq nr ns gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ph"><img src="../Images/f309ffe294fe194f8dc26565d2f75744.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IBihFLLyWPJYaxeCMt7oiw.png"/></div></div></figure><blockquote class="oq or os"><p id="d2fb" class="kb kc md kd b ke kf kg kh ki kj kk kl ot kn ko kp ou kr ks kt ov kv kw kx ky im bi translated"><strong class="kd iu">注意:</strong>同样，经过身份验证的用户代表那些由您的GitHub OAuth客户端应用程序进行身份验证的用户。</p><p id="b62d" class="kb kc md kd b ke kf kg kh ki kj kk kl ot kn ko kp ou kr ks kt ov kv kw kx ky im bi translated">❗️❗️❗️<strong class="kd iu">——b e w a r e—</strong>❗️❗️❗<br/>认证用户可能是指任何登录到GitHub so️的人，确保你使用不属于你的组织的外部用户进行测试。您可以删除已认证用户的所有权限，并且只允许您的GitHub组织或用户访问。</p></blockquote></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="d1ce" class="ml mm it bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">完了？有用吗？恭喜你！</h1><p id="f1fc" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated">现在，您已经为Jenkins实例设置了OAuth，并配置了您的访问和安全权限。让我们快速回顾一下我们所做的工作。我们有:</p><ul class=""><li id="4530" class="lp lq it kd b ke kf ki kj km lr kq ls ku lt ky nx lv lw lx bi translated">安装了合适的Jenkins插件</li><li id="08f1" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">创建了OAuth客户端应用程序</li><li id="0cda" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">使用<code class="fe oa ob oc od b">clientId</code>和<code class="fe oa ob oc od b">clientSecret</code>来配置插件</li><li id="1b5e" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">确定了一组规则，姑且称之为<code class="fe oa ob oc od b">authz_strategy_config</code>，为“基于矩阵的安全性”微调访问权限</li></ul></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="3315" class="ml mm it bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated"><strong class="ak"> OAuth for Jenkins(自动)</strong></h1><p id="de36" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated">现在我们有了正确的设置，让我们在pod重新启动时保持所有的设置。</p><p id="1df0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来的步骤将假设我们使用Google OAuth方法。GitHub OAuth所需的任何更改都将在每个部分的底部注明。</p><h2 id="0421" class="oi mm it bd mn pi pj dn mr pk pl dp mv km pm pn mz kq po pp nd ku pq pr nh ps bi translated">持久化OAuth插件</h2><p id="95de" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated">我们已经在这篇文章的前面讨论了持久化插件，所以，如果你对插件的状态满意，简单地说:</p><ul class=""><li id="b985" class="lp lq it kd b ke kf ki kj km lr kq ls ku lt ky nx lv lw lx bi translated">拿着单子</li><li id="66fb" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">为docker图像更新您的<code class="fe oa ob oc od b">plugins.txt</code></li></ul><h2 id="48f7" class="oi mm it bd mn pi pj dn mr pk pl dp mv km pm pn mz kq po pp nd ku pq pr nh ps bi translated">应用安全配置</h2><p id="6c80" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated">现在，官方的Jenkins docker映像为您提供了一种可能性，通过将groovy脚本放在<code class="fe oa ob oc od b">/usr/share/jenkins/ref/init.groovy.d</code>目录中，您可以添加自己的<a class="ae kz" href="https://github.com/jenkinsci/docker#setting-the-number-of-executors" rel="noopener ugc nofollow" target="_blank">定制配置脚本</a>。</p><p id="ef6c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将使用这个特性来添加两个groovy脚本(脚本被编号以确保执行的顺序):</p><ul class=""><li id="c1e4" class="lp lq it kd b ke kf ki kj km lr kq ls ku lt ky nx lv lw lx bi translated"><code class="fe oa ob oc od b"><strong class="kd iu">scripts/001SecurityRealm.groovy.override</strong></code> <br/>设置詹金斯的安全领域</li><li id="f4bc" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated"><code class="fe oa ob oc od b"><strong class="kd iu">scripts/002AuthStrategy.groovy.override</strong></code> <br/>配置授权策略</li></ul><blockquote class="oq or os"><p id="37bb" class="kb kc md kd b ke kf kg kh ki kj kk kl ot kn ko kp ou kr ks kt ov kv kw kx ky im bi translated"><strong class="kd iu">快速注意上</strong> <code class="fe oa ob oc od b"><strong class="kd iu"><em class="it">.override</em></strong></code> <strong class="kd iu">后缀。</strong> <br/>默认的docker图像行为是不会阻止用户界面上的任何改变。需要覆盖后缀来确保文件系统上的任何同名文件总是被docker映像中的文件覆盖，因为我们不应该在UI中进行更改，对吗？；-) <br/>详见<a class="ae kz" href="https://github.com/jenkinsci/docker/issues/563#issuecomment-343433407" rel="noopener ugc nofollow" target="_blank">本评论</a>。</p></blockquote><p id="8379" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的docker文件现在看起来像这样:</p><pre class="np nq nr ns gt oe od of og aw oh bi"><span id="10f5" class="oi mm it od b gy oj ok l ol om">FROM jenkinsxio/jenkinsx:REPLACE_UPSTREAM_VERSION</span><span id="cc25" class="oi mm it od b gy on ok l ol om"># add groovy scripts to configure oauth<br/>COPY scripts/*.override /usr/share/jenkins/ref/init.groovy.d/</span><span id="6c49" class="oi mm it od b gy on ok l ol om">COPY plugins.txt /usr/share/jenkins/ref/custom-plugins.txt</span><span id="6c3e" class="oi mm it od b gy on ok l ol om">RUN /usr/local/bin/install-plugins.sh &lt; /usr/share/jenkins/ref/custom-plugins.txt</span></pre><p id="66b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看那些脚本。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="c916" class="oi mm it bd mn pi pj dn mr pk pl dp mv km pm pn mz kq po pp nd ku pq pr nh ps bi translated">安全领域脚本</h2><p id="05ea" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated">该脚本需要一个文件<code class="fe oa ob oc od b">/etc/jenkins-secrets/google-client-auth</code>。该文件包含两行<code class="fe oa ob oc od b">clientID</code>和<code class="fe oa ob oc od b">clientSecret</code></p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="oo op l"/></div></figure><blockquote class="oq or os"><p id="e41b" class="kb kc md kd b ke kf kg kh ki kj kk kl ot kn ko kp ou kr ks kt ov kv kw kx ky im bi translated"><strong class="kd iu"> GitHub OAuth: <br/> </strong> —脚本可以在<a class="ae kz" href="https://gist.github.com/sboardwell/1d3a555bd6eaabb49045aaf8ea5a80f4" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">这里</strong> </a>找到。<br/>-不同之处在于:<br/>-文件名应为(…)。/github-client-auth) <br/> — —使用的安全领域(导入和构造函数)</p></blockquote><h2 id="a4a4" class="oi mm it bd mn pi pj dn mr pk pl dp mv km pm pn mz kq po pp nd ku pq pr nh ps bi translated">基于矩阵的安全脚本</h2><p id="cd5c" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated">Sam Gleske在GitHub 上的工作值得称赞。如果有机会，我强烈推荐任何感兴趣的人看看他的剧本。</p><p id="0df1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我扩展了<a class="ae kz" href="https://github.com/samrocketman/jenkins-bootstrap-shared/blob/master/scripts/configure-matrix-authorization-strategy.groovy" rel="noopener ugc nofollow" target="_blank">configure-matrix-authorization-strategy . groovy</a>以允许通过外部文件进行配置。该脚本本身是不言自明的，它需要一个文件<code class="fe oa ob oc od b">/etc/jenkins-secrets/authz-strategy-config</code>,然后用于配置“基于矩阵的安全性”。</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="oo op l"/></div></figure><h2 id="8766" class="oi mm it bd mn pi pj dn mr pk pl dp mv km pm pn mz kq po pp nd ku pq pr nh ps bi translated">创建docker映像和凭据</h2><p id="f0c7" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated">以下是创建自定义Jenkins docker映像所需的文件:</p><pre class="np nq nr ns gt oe od of og aw oh bi"><span id="2032" class="oi mm it od b gy oj ok l ol om">├── Dockerfile<br/>├── plugins-refresh.sh <br/>├── plugins.txt<br/>└── scripts<br/>    ├── 001SecurityRealm.groovy.override      # &lt;- Google or GitHub<br/>    └── 002AuthorisationStrategy.groovy.override</span></pre><p id="8049" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在使用这个映像之前，我们还需要创建包含必要凭证的秘密。我选择创建一个秘密来保存这两组凭证，但是您可以随意设置。</p><p id="f77b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来创造这个秘密:</p><pre class="np nq nr ns gt oe od of og aw oh bi"><span id="1bb5" class="oi mm it od b gy oj ok l ol om">apiVersion: v1<br/>kind: Secret<br/>metadata:<br/>  name: jenkins-security-secrets<br/>data:<br/>  authz-strategy-config: BASE64_ENCODED_AUTH_STRATEGY <br/>  google-client-auth: BASE64_ENCODED_GOOGLE_FILE</span></pre><p id="9d01" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">问题中的文件看起来像什么(仅作为示例):</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="89dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，有了图像和秘密，我们可以对<code class="fe oa ob oc od b">myvalues.yaml</code>进行必要的修改。我们需要:</p><ul class=""><li id="972a" class="lp lq it kd b ke kf ki kj km lr kq ls ku lt ky nx lv lw lx bi translated">更新docker图像</li><li id="a4cc" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">将秘密装入詹金斯舱</li></ul><p id="8ee6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">添加持久性块后，我们的新<code class="fe oa ob oc od b">myvalues.yaml</code>看起来像:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="oo op l"/></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">myvalues.yaml与詹金斯-安全-秘密挂载</figcaption></figure><p id="8a95" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">重新启动Jenkins pod，迎接你的应该是一个免登录、酷毙了的OAuth 2.0体验。现在检查授权策略。请非管理员同事访问该网站。他们是否被授权，他们在服务器上的权限是什么，都应该基于你自己制定的授权策略。</p><blockquote class="la"><p id="20ac" class="lb lc it bd ld le lf lg lh li lj ky dk translated">OAuth、安全矩阵和最新插件！结果！</p></blockquote><p id="3630" class="pw-post-body-paragraph kb kc it kd b ke lk kg kh ki ll kk kl km lm ko kp kq ln ks kt ku lo kw kx ky im bi translated">接下来，工作！</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="ba35" class="ml mm it bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">持续工作</h1><p id="2d0f" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated">在我们开始实施事情之前，我想简单解释一下我们决策背后的思维过程。我们对在Jenkins中归档构建结果不感兴趣。为此，我们应该真正信任各种云提供商来处理我们持续的量声明。无论如何，我们已经发布了工件来显示哪些运行是成功的:-)。</p><p id="5b60" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，我们想要的是:</p><ul class=""><li id="a7e7" class="lp lq it kd b ke kf ki kj km lr kq ls ku lt ky nx lv lw lx bi translated">将我们所有的作业和项目保存在git存储库中</li><li id="dead" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">能够按需创建或更新工作</li><li id="f662" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">为使其在Jenkins启动时可用</li></ul><h2 id="5c6d" class="oi mm it bd mn pi pj dn mr pk pl dp mv km pm pn mz kq po pp nd ku pq pr nh ps bi translated">作业DSL插件</h2><p id="9408" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated">虽然Jenkins X有<code class="fe oa ob oc od b"><a class="ae kz" href="https://jenkins-x.io/commands/jx_import/" rel="noopener ugc nofollow" target="_blank">jx import</a></code>命令，但是无法备份创建的Jenkins作业。因此，由于我们想自己管理作业，我们决定使用<a class="ae kz" href="https://github.com/jenkinsci/job-dsl-plugin" rel="noopener ugc nofollow" target="_blank">作业DSL插件</a>。我不会深入这个插件的细节以及如何使用它。有很多例子，尤其是在插件的<a class="ae kz" href="https://github.com/jenkinsci/job-dsl-plugin/wiki" rel="noopener ugc nofollow" target="_blank"> wiki页面上。</a></p><p id="de77" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我使用<a class="ae kz" href="https://github.com/sheehan/job-dsl-gradle-example" rel="noopener ugc nofollow" target="_blank"> gradle项目示例</a>作为模板，并将我们自己的作业放入其中，包括种子作业作业脚本。</p><p id="e664" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">添加了一个Jenkinsfile来在PR上运行测试，并在master上处理作业DSL脚本。因为我不想给DSL脚本完全的管理权限(见下文)，所以我需要添加一点<code class="fe oa ob oc od b">try { … } catch { … }</code>来允许脚本在被修改的情况下被批准。</p><figure class="np nq nr ns gt ju gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/c373c2ba3962aaed44673e12303c745d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*zVi7kkg3Uk0gu6jiRgyB7g.png"/></div></figure><p id="6950" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">种子作业的Jenkinsfile如下所示:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="42d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我已经有了Jenkinsfile，只需要知道把它放在哪里就行了。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="3e56" class="oi mm it bd mn pi pj dn mr pk pl dp mv km pm pn mz kq po pp nd ku pq pr nh ps bi translated">Jenkins CasC插件</h2><p id="c64d" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated">正如我前面提到的，Jenkins X默认安装了<a class="ae kz" href="https://github.com/jenkinsci/configuration-as-code-plugin" rel="noopener ugc nofollow" target="_blank"> Jenkins CasC插件</a>,这是一个很好的起点。这里，来自中国航天科技集团网站:</p><blockquote class="oq or os"><p id="12c9" class="kb kc md kd b ke kf kg kh ki kj kk kl ot kn ko kp ou kr ks kt ov kv kw kx ky im bi translated">如果不设置环境变量<code class="fe oa ob oc od b">CASC_JENKINS_CONFIG</code>，插件将默认在<code class="fe oa ob oc od b">$JENKINS_ROOT/jenkins.yaml</code>中寻找一个配置文件。</p></blockquote><p id="2620" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么很简单，我们需要做的就是创建文件并使用它来配置我们的服务器。多亏了伊利亚·沙伊苏塔诺夫的这个公关，事情变得更好了。我们现在能够通过舵图直接添加额外的配置文件。</p><p id="7776" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们基本上可以用CasC配置一切了。查看<a class="ae kz" href="https://www.praqma.com/stories/start-jenkins-config-as-code/" rel="noopener ugc nofollow" target="_blank">演示页面</a>了解可能的事情。天空现在是真正的极限，选项(和问题)是无穷无尽的:</p><ul class=""><li id="4b4c" class="lp lq it kd b ke kf ki kj km lr kq ls ku lt ky nx lv lw lx bi translated">你把你所有的工作都放在casc文件里了吗？</li><li id="8ad2" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">您是否在JCasc中配置授权策略？</li><li id="3584" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">github-oauth，google-oauth怎么样？</li><li id="940b" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">您需要一个种子作业吗，或者您可以直接从JCasC运行job-dsl吗？</li><li id="9d8c" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">等等，等等</li></ul><blockquote class="oq or os"><p id="fffb" class="kb kc md kd b ke kf kg kh ki kj kk kl ot kn ko kp ou kr ks kt ov kv kw kx ky im bi translated"><strong class="kd iu">注意:</strong>我们最终会将我们的init脚本从docker镜像移动到CasC文件，但那是将来的事情，我仍然不确定插件如何处理配置yaml中不在Vault中的秘密。</p></blockquote><p id="249a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">顺便说一下，这是另一篇关于使用JCasC的好文章。</p><p id="da76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们决定使用单个种子作业，而不是将所有作业放在JCasC文件中，该文件本身放在<code class="fe oa ob oc od b">myvalues.yaml</code>中。它会变得很乱，不会像真正的工作那样考虑到公关和测试。</p><p id="fe8b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">也就是说，我们的新<code class="fe oa ob oc od b">myvalues.yaml</code>现在看起来像:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="a03b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，当我们更新Jenkins X平台时…</p><ul class=""><li id="71f4" class="lp lq it kd b ke kf ki kj km lr kq ls ku lt ky nx lv lw lx bi translated">我们将看到预安装的多分支种子作业</li><li id="5842" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">分支索引将运行，触发主分支运行</li><li id="a9d7" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky nx lv lw lx bi translated">然后创造你们所有的工作岗位。</li></ul><blockquote class="la"><p id="b30a" class="lb lc it bd ld le ow ox oy oz pa ky dk translated">插件、安全和作业！</p><p id="3a16" class="lb lc it bd ld le lf lg lh li lj ky dk translated">所有自动化和所有持续的詹金斯吊舱重启！</p></blockquote><figure class="pv pw px py pz ju gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/0ba8acb372f9bdce4efc97b020308be8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*PmncWQdPlXY4-ctJ.jpeg"/></div></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="4504" class="ml mm it bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">摘要</h1><p id="59a5" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated">在这篇文章中，我们已经讨论了很多内容，但是我希望我能够把相关的部分分解成足够小的部分，以便让你知道什么是可能的。</p><p id="6574" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Jenkins X非常出色地将所有合适的组件整合在一起，创建了一个功能齐全的CI/CD平台。然而，随着项目进展如此之快，它也相当不稳定，尤其是因为有如此多的移动部分需要管理。</p><p id="fd4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是……在这里或那里做一点调整，仍然有可能保持一个稳定的平台，同时仍然可以根据您的需求进行定制。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="f410" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一篇文章将关注Jenkins X中的Nexus实例，特别是如何添加您自己的定制存储库。</p><p id="c5db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在那之前…</p></div></div>    
</body>
</html>