<html>
<head>
<title>Connecting Elixir Nodes with libcluster, locally and on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在本地和Kubernetes上连接Elixir节点和libcluster</h1>
<blockquote>原文：<a href="https://itnext.io/connecting-elixir-nodes-with-libcluster-locally-and-on-kubernetes-feb704158d41?source=collection_archive---------2-----------------------#2019-02-06">https://itnext.io/connecting-elixir-nodes-with-libcluster-locally-and-on-kubernetes-feb704158d41?source=collection_archive---------2-----------------------#2019-02-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1b7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最初发表于:【poeticoding.com】</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><h2 id="e8e5" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">资源</h2><p id="e3a7" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">GitHub:<a class="ae kl" href="https://github.com/bitwalker/libcluster" rel="noopener ugc nofollow" target="_blank">lib cluster</a><br/>GitHub:<a class="ae kl" href="https://github.com/poeticoding/phoenix_chat_example/tree/libcluster" rel="noopener ugc nofollow" target="_blank">poeticoding/phoenix _ chat _ example</a><br/>docker hub:<a class="ae kl" href="https://cloud.docker.com/repository/docker/alvises/phoenix-chat-example" rel="noopener ugc nofollow" target="_blank">alvises/phoenix-chat-example</a></p><h2 id="1d92" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">有用的文章</h2><p id="d444" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated"><a class="ae kl" href="https://www.poeticoding.com/running-elixir-in-docker-containers/" rel="noopener ugc nofollow" target="_blank">在Docker容器中运行药剂</a> <br/> <a class="ae kl" href="https://www.poeticoding.com/distributed-phoenix-chat-with-pubsub-pg2-adapter/" rel="noopener ugc nofollow" target="_blank">使用PubSub PG2适配器的分布式Phoenix Chat</a><br/><a class="ae kl" href="https://www.poeticoding.com/create-a-high-availability-kubernetes-cluster-on-aws-with-kops/" rel="noopener ugc nofollow" target="_blank">使用Kops在AWS上创建高可用性Kubernetes集群</a></p><h2 id="e94b" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">副本</h2><p id="ab77" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">在前几篇文章中，我们看到了如何使我们的凤凰聊天应用程序分布式；一开始是Redis，之后是将节点连接在一起的分布式仙丹。</p><p id="ccb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们只有一个问题:我们必须手动连接到IEX控制台中的节点。这是生产中的一个问题。在这个视频中，我们将看到如何在本地使用libcluster库，以及在具有动态数量节点的Kubernetes集群上，对Phoenix chat节点进行自动集群。</p><p id="29cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从我github帐户<a class="ae kl" href="https://github.com/poeticoding/phoenix_chat_example" rel="noopener ugc nofollow" target="_blank"> poeticoding </a>下载凤凰聊天示例的第一个<a class="ae kl" href="https://github.com/poeticoding/phoenix_chat_example" rel="noopener ugc nofollow" target="_blank">代码，并使用</a><a class="ae kl" href="https://github.com/poeticoding/phoenix_chat_example/tree/pubsub_pg2" rel="noopener ugc nofollow" target="_blank"> pubsub_pg2 </a>分支。让我们克隆代码，并检查到pubsub_pg2分支。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="d6ea" class="kt ku iq ls b gy lw lx l ly lz">$ git clone https://github.com/poeticoding/phoenix_chat_example.git<br/>...<br/>$ cd phoenix_chat_example<br/>$ git co pubsub_pg2<br/>$ mix deps.get</span></pre><p id="d108" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们下载依赖项，并尝试在本地运行它，这样我们就可以将端口作为一个环境变量传递，因此端口<code class="fe ma mb mc ls b">4000</code>处的第一个节点。我们给一个名字，第一个节点<code class="fe ma mb mc ls b">A</code>。我们启动另一个凤凰服务器，节点<code class="fe ma mb mc ls b">B</code>，端口<code class="fe ma mb mc ls b">4001</code>。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="3a6c" class="kt ku iq ls b gy lw lx l ly lz"># Node A<br/>$ PORT=4000 iex --sname a -S mix phx.server<br/># Node B<br/>$ PORT=4001 iex --sname b -S mix phx.server</span></pre><p id="c9e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好极了。现在让我们将节点<code class="fe ma mb mc ls b">A</code>连接到<code class="fe ma mb mc ls b">B</code>。我们看到，这需要正确连接。让我们用这两种浏览器试试聊天应用程序。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="bfba" class="kt ku iq ls b gy lw lx l ly lz">iex(a@mbp)&gt; Node.connect :b@mbp<br/>true<br/>iex(b@mbp)&gt; Node.list<br/>[:a@mbp]</span></pre><p id="6bfe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，让我们用一个选项卡连接到<code class="fe ma mb mc ls b">4000</code>(节点A)，另一个选项卡连接到<code class="fe ma mb mc ls b">4001</code>(节点B)。我们看到消息被正确地传播。</p><h2 id="3ad2" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">libcluster</h2><p id="9a9f" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">我们必须使用<code class="fe ma mb mc ls b">Node</code>模块中的<code class="fe ma mb mc ls b">connect/1</code>功能手动连接节点。让我们看看如何使用<code class="fe ma mb mc ls b"><a class="ae kl" href="https://github.com/bitwalker/libcluster" rel="noopener ugc nofollow" target="_blank">libcluster</a></code>来自动连接节点。</p><p id="fc3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以首先，我们需要添加<a class="ae kl" href="https://hex.pm/packages/libcluster" rel="noopener ugc nofollow" target="_blank"> libcluster库</a>作为依赖项。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="b971" class="kt ku iq ls b gy lw lx l ly lz"># mix.exs<br/>defp deps do <br/>  [<br/>    ...<br/>    {:libcluster, "~&gt; 3.0"}<br/>  ] <br/>end</span><span id="fe99" class="kt ku iq ls b gy md lx l ly lz"># lib/chat.ex<br/>defmodule Chat do<br/>  use Application<br/><br/>  def start(_type, _args) do<br/>    import Supervisor.Spec, warn: false<br/><br/>    topologies = [<br/>      chat: [<br/>        strategy: Cluster.Strategy.Gossip<br/>      ]<br/>    ]<br/><br/>    children = [<br/>      {Cluster.Supervisor, [topologies, [name: Chat.ClusterSupervisor]]},<br/>      supervisor(Chat.Endpoint, [])<br/>    ]<br/>    opts = [strategy: :one_for_one, name: Chat.Supervisor]<br/>    Supervisor.start_link(children, opts)<br/>  end<br/>end</span></pre><p id="bc07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们需要启动一个<code class="fe ma mb mc ls b">Cluster.Supervisor</code>，它是<code class="fe ma mb mc ls b">libcluster</code>库的一部分，带有一些<code class="fe ma mb mc ls b">topologies</code>。我们使用<code class="fe ma mb mc ls b">Gossip</code>策略，该策略使用多播UDP将节点名称透露给网络中的其他节点。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="4e94" class="kt ku iq ls b gy lw lx l ly lz"># Node A<br/>$ PORT=4000 iex --sname a -S mix phx.server<br/># Node B<br/>$ PORT=4001 iex --sname b -S mix phx.server<br/># Node C<br/>$ PORT=4002 iex --sname c -S mix phx.server</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi me"><img src="../Images/11f5d39e1f6c9e8c497150cfda84c0ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*MgDsw02aH3z_loj2.png"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">三个凤凰节点连接</figcaption></figure><p id="f3f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了，它应该马上就能工作。与之前一样，我们启动一个节点，端口<code class="fe ma mb mc ls b">4000</code>上的<code class="fe ma mb mc ls b">A</code>节点和端口<code class="fe ma mb mc ls b">4001</code>上的节点B。您会看到节点A现在连接到节点B，反之亦然。节点列表。我们发现我们不必手动连接它们。如果我在端口<code class="fe ma mb mc ls b">4002</code>上添加另一个名为<code class="fe ma mb mc ls b">C</code>的节点，情况也是如此。它们会自动连接。</p><h2 id="c152" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">库伯内特斯</h2><p id="f0a0" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">现在，让我们看看如何在Kubernetes上部署这个分布式应用程序，并使用libcluster自动对节点(即Elixir节点)进行集群。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi me"><img src="../Images/55be727867fe8f330ccf969da882eccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*U4sL7aeic-3R0r4I.png"/></div></figure><p id="8a77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在我的Kubernetes本地设置上部署多个聊天节点。但是，我要向您展示的是，任何云提供商都不需要做任何根本性的改变。我们将使用Kubernetes部署来部署我们的聊天节点，我们将借助libcluster和一种称为Kubernetes headless服务的东西将它们自动连接在一起，我们稍后会看到这种服务。然后我们将创建一个负载平衡器，它将把不同浏览器的连接分散到不同的聊天节点。</p><p id="075c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，什么是无头服务呢？<a class="ae kl" href="https://github.com/poeticoding/phoenix_chat_example/blob/libcluster/nginx_kube_test.yaml" rel="noopener ugc nofollow" target="_blank">我已经把这个文件，Nginx kube测试</a>。您可以在<a class="ae kl" href="https://github.com/poeticoding/phoenix_chat_example/tree/libcluster" rel="noopener ugc nofollow" target="_blank"> libcluster分支下找到所有这些代码。</a>所以，让我们试着用一个简单的Nginx部署来看看，什么是无头服务。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="7617" class="kt ku iq ls b gy lw lx l ly lz"># nginx_kube_test.yaml<br/>kind: Service<br/>apiVersion: v1<br/><br/>metadata:<br/>  name: nginx-nodes<br/>  namespace: default<br/>spec:<br/>  clusterIP: None<br/>  selector:<br/>    app: nginx<br/>  ports:<br/>    - name: http<br/>      port: 80</span></pre><p id="892f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个服务，但是我们指定了<code class="fe ma mb mc ls b">clusterIP: None</code>，DNS将是nginx- nodes，在<code class="fe ma mb mc ls b">default</code>名称空间下。而港口，在这种情况下，要去的目标港口是<code class="fe ma mb mc ls b">80</code>。</p><p id="b860" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这只是一个有4个副本的Nginx部署。让我们创建服务和部署。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="4391" class="kt ku iq ls b gy lw lx l ly lz">$ kubectl apply -f nginx_kube_test.yaml</span></pre><p id="1893" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们开始安装<code class="fe ma mb mc ls b">dnsutils</code>和<code class="fe ma mb mc ls b">curl</code>的<code class="fe ma mb mc ls b">ubuntu</code>集装箱。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="bd4b" class="kt ku iq ls b gy lw lx l ly lz">$ kubectl run bash --rm -it --image ubuntu --bash<br/># apt-get update &amp;&amp; apt-get install dnsutils curl -y<br/># nslookup nginx-nodes</span></pre><p id="5a98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们看到，使用这个DNS，我们能够列出所有nginx节点。如果我们横向扩展添加更多副本，我们会再次看到新节点都出现在列表中。</p><p id="5e66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们开始改变拓扑结构。所以我们现在使用<code class="fe ma mb mc ls b">Cluster.Kubernetes.DNS strategy</code>，它将使用我们将要创建的无头服务。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="9676" class="kt ku iq ls b gy lw lx l ly lz"># lib/chat.ex<br/>topologies = [<br/>  k8s_chat: [<br/>    strategy: Cluster.Strategy.Kubernetes.DNS,<br/>      config: [<br/>        service: "chat-nodes",<br/>        application_name: "chat"<br/>      ]<br/>    ]<br/>  ]</span><span id="0c0b" class="kt ku iq ls b gy md lx l ly lz"># web/controllers/page_controller.ex<br/>defmodule Chat.PageController do<br/>  use Chat.Web, :controller<br/><br/>  def index(conn, _params) do<br/>    self_node = inspect(node())<br/>    nodes = inspect(Node.list())<br/>    render(conn, "index.html", %{node: self_node, nodes: nodes})<br/>  end<br/>end</span><span id="7e34" class="kt ku iq ls b gy md lx l ly lz"># web/templates/page/index.html.eex<br/>&lt;div&gt;<br/>  &lt;p&gt;nodes: &lt;%=@nodes%&gt;&lt;/p&gt;<br/>  &lt;p&gt;self: &lt;%=@node%&gt;&lt;/p&gt;<br/>&lt;/div&gt;<br/>&lt;div id="messages" class="container"&gt;<br/>&lt;/div&gt;<br/>...</span></pre><p id="943f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以应用程序现在已经准备好了。我们需要建立一个码头工人的形象。但是在构建Docker映像之前，我们将首先看到无头服务Kubernetes文件。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="c694" class="kt ku iq ls b gy lw lx l ly lz">kind: Service<br/>apiVersion: v1<br/><br/>metadata:<br/>  name: chat-nodes<br/>  namespace: default<br/>spec:<br/>  clusterIP: None<br/>  selector:<br/>    app: chat<br/>  ports:<br/>    - name: epmd<br/>      port: 4369</span></pre><p id="c8c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们公开EPMD，DNS是<code class="fe ma mb mc ls b">chat-nodes</code>。我们还创建了一个聊天负载平衡器。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="8f0f" class="kt ku iq ls b gy lw lx l ly lz">kind: Service<br/>apiVersion: v1<br/><br/>metadata:<br/>  name: chat<br/>  namespace: default<br/>spec:<br/>  type: LoadBalancer<br/>  selector:<br/>    app: chat<br/>  ports:<br/>    - name: http<br/>      port: 8000<br/>      targetPort: 4000</span></pre><p id="c09a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">来看看部署。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="629d" class="kt ku iq ls b gy lw lx l ly lz">---<br/>kind: Deployment<br/>apiVersion: apps/v1<br/>metadata:<br/>  name: chat<br/>  namespace: default<br/>spec:<br/>  replicas: 4<br/>  selector:<br/>    matchLabels:<br/>      app: chat<br/><br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: chat<br/>    spec:<br/>      containers:<br/>      - name: phoenix-chat<br/>        image: chat:libcluster #alvises/phoenix-chat-example:libcluster-kube<br/>        ports:<br/>        - containerPort: 4000<br/>        env:<br/>        - name: PORT<br/>          value: "4000"<br/>        - name: PHOENIX_CHAT_HOST<br/>          value: "localhost"<br/>        - name: ERLANG_COOKIE<br/>          value: "secret"<br/>        - name: MY_POD_IP<br/>          valueFrom:<br/>            fieldRef:<br/>              fieldPath: status.podIP<br/>        command: ["elixir"]<br/>        args: [<br/>          "--name", <br/>          "chat@$(MY_POD_IP)", <br/>          "--cookie","$(ERLANG_COOKIE)", <br/>          "--no-halt", <br/>          "-S","mix",<br/>          "phx.server"<br/>        ]</span></pre><p id="48fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们首先要创建4个副本。我们将建立我们的形象，但你可以使用我在DockerHub上发布的形象:<a class="ae kl" href="https://cloud.docker.com/u/alvises/repository/docker/alvises/phoenix-chat-example" rel="noopener ugc nofollow" target="_blank">alvises/phoenix-chat-example:lib cluster-kube</a>。<br/>公开的容器端口是<code class="fe ma mb mc ls b">4000</code>，我们还需要在每个节点中设置相同的Erlang cookie(在生产中更好地使用Kubernetes Secrets)。</p><p id="be76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重要的部分是环境变量<code class="fe ma mb mc ls b">MY_POD_IP</code>。我们定义了一个环境变量，在这里我们设置每个节点的IP。然后，我们在启动服务器时使用这个变量来指定节点名和cookie</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="14b7" class="kt ku iq ls b gy lw lx l ly lz">elixir --name chat@$(MY_POD_IP) --cookie $(ERLANG_COOKIE) --no-halt -S mix phx.server</span></pre><p id="aa55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">构建Docker映像非常简单。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="a6f4" class="kt ku iq ls b gy lw lx l ly lz">$ docker image build -t chat:libcluster .</span></pre><p id="ee5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在Kubernetes中创建聊天部署和服务</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="9f06" class="kt ku iq ls b gy lw lx l ly lz">$ kubectl create -f kube_chat_deploy_and_svc.yaml</span></pre><p id="0a02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们将负载平衡器连接到我们的本地端口<code class="fe ma mb mc ls b">8000</code>。我们看到节点列表，节点会自动连接。如果我们添加新的副本，我们几乎会立即在节点列表下看到新节点。</p><h2 id="d84c" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">包裹</h2><p id="b395" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">我们看到使用<code class="fe ma mb mc ls b">libcluster</code>将节点连接在一起并进行部署是多么容易，在Kubernetes上也是如此，这是一个分布式Phoenix聊天应用程序。</p><p id="4fe0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您有任何问题或不清楚的地方，请在下面的评论区发表评论，订阅新的文章和视频。下周见！</p></div></div>    
</body>
</html>