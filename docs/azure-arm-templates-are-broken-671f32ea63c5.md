# Azure ARM 模板和 Azure cloud 中作为代码的基础设施的可悲状态

> 原文：<https://itnext.io/azure-arm-templates-are-broken-671f32ea63c5?source=collection_archive---------0----------------------->

一个咆哮，希望能让雷德蒙的人听听，并试图解决它。

# 开始

起初有光。和服务器。但是服务器供应和设置变成了工具和雪花设置的泥潭。鉴于此，有人有了一个好主意。因此“作为代码的基础设施”来到了这个世界。

![](img/b127f1d4c235ba7171d1dbd56ae52ea3.png)

# 基础设施作为代码

作为代码的基础设施是一个伟大的概念，是 devops 的支柱。其核心是将我们的云基础设施视为代码= >用可部署的代码来描述它。拥有一个从 push 开始的 CI/CD 管道，以及一个基于 PRs 和带有 git revert 的回滚的 review 管道。作为代码的基础设施的 Azure 工具选择是 ARM 模板(ARM 代表 Azure 资源管理器)。ARM 模板是 JSON(稍后查看关于 sad 技术选择的更多信息)，它们由参数、变量、资源和输出(还有其他一些东西)组成。也可以从模板外部传递参数:从参数文件或从 CLI，从而允许我们在不同的场景中重用模板(例如 staging/prod)或动态获取参数(例如从 keyVault)。由于 JSON 很难描述复杂的场景，ARM 模板有一个函数的概念，它被描述为一个 JSON 数组。例如，concat 函数:

```
{“name“:”[concat(‘my-prefix’, parameters('environment'), '-this-service')]”}
```

ARM 模板还有一个其他解决方案缺乏的“杀手锏”:从 azure UI 下载当前设置的模板，允许从 UI 点击驱动的设置过渡到代码形式的基础设施。当然，这并不总是有效的，但是有时候这是一个救命稻草，尤其是在处理文档化 API 的时候。

到目前为止，我已经描述了一个不错的技术栈。虽然它有一些内在的问题，如即使对于琐碎的任务也非常冗长(这也是 AWS Cloudformation 的问题)，但它是解决代码基础设施问题的好办法。要是这是真的就好了

但是我们很乐观，所以我们用我们的基础设施和 CI 管道建立了一个 git repo 来验证和部署这些变化。看妈妈！我们像大男孩一样把基础设施作为代码来做！什么会出错？

# ARM 模板的失败

# 严格的 JSON(没有评论的生活)

开发人员是 ARM 模板的使用者，作为开发人员，代码的可维护性和可读性是重中之重。为了在我们的代码中实现这一点，我们试图将代码分解为模块、类和函数。我们思考有意义的命名，并向未来的读者(可能是一个月后的我们)评论我们的逻辑和决定。请记住，开发人员花在阅读代码上的时间比写代码多 10 倍。选择一种严格的基于模式的 JSON 作为实现语言使得这变得非常困难。例如，您不能添加特定 api 方案中不支持的字段，可能是为了您自己的文档，这些字段也可能用于用一些脚本和描述来包装 ARM 模板。虽然我可以理解这是一个“警告”还是一个可选的“严格”模式，但是把它作为一个错误似乎是错误的。

在研究这篇文章的时候，我发现我可以添加一个`*元数据*'对象，该对象将包含一个`*评论*'属性到每个对象，这应该是一个解决方案，但只允许在某些地方发表评论。此外，当你快速迭代 ARM 模板，试图找出确切的正确设置时，我通常会添加/删除代码块，能够注释掉不需要的代码块会很有帮助。但不是严格的 JSON。不允许这样。为什么不是 YAML？汤姆。甚至是带注释的 JSON？

# 参数-到处都是参数

ARM 模板有一个参数的概念，可以在模板中用默认值和类型来定义，也可以用“参数文件”和/或 CLI 中的参数来覆盖。参数和变量(可由参数和其他变量和函数组合而成)允许我们的模板是动态的。在我们的转移环境中，我们可能需要 2 台虚拟机，而在另一个环境中需要 8 台。不同类型的虚拟机、区域等。这是有用的。问题是当我们对多个模板使用单个覆盖参数文件时，我们在基础设施的 CI 流程中遇到过这种情况。我们使用一个模板，因为我们在多个模板中使用了(一些)参数，这是一个合理的用例。问题是当一个参数文件包含一个没有在模板中定义的参数时，你会得到一个错误。因此，您发现自己要么使用大量的参数文件，复制重复的值，并希望在有变化时不要错过一个；或者是 ***parametitis*** 的可怕症状:复制所有模板中的单个文件参数，包括那些不会使用它们的模板。目前我们在每个模板中有数百行参数，而每个模板只使用了很少的几行；使他们更难阅读和推理。

# 确认

作为代码工具的基础设施的一个重要部分是验证模板的能力；最好甚至做一次演习，让你断言会创建什么，并验证你的模板的正确性。Azure ARM 不提供模拟运行选项 AFAIK，但它有一个验证命令，唯一的问题是验证非常有限。实际的验证运行是验证 JSON 模板、丢失的参数(见上文)以及一些丢失的依赖项。不幸的是，当我们尝试实际部署模板时，我们发现还有另一个验证步骤，只有在部署了特定的组件(可能已经运行了很久)然后失败时，才会检查这个步骤。

如果验证命令不进行验证，那么它有什么意义呢？我最近遇到的一个更糟糕的问题是一些验证，这些验证不是检查可能由模板构建的 AST(抽象语法树),而是试图根据实际部署的组件而不是声明的组件来验证某些属性；忽略声明的依赖关系树。因此，除非我先部署这些组件，然后添加依赖组件，否则模板会失败。从很多方面来看，这都是一种反模式。

# 可组合性

软件开发的一个重要部分是可组合性，我们不想写 10，000 个巨大的 LOC 文件。我们想要可以阅读的小文件，我们想要一种在不同场景中组合和重用它们的方法。

例如，假设我有一个为特定微服务创建资源的模板，我宁愿为每个资源(例如 postgresql 数据库和 redis 缓存)创建一个预定义的工作模板，只需在定义该服务所需资源的模板中组合它们。虽然 ARM 有链接模板(templateUri)的概念，但它仅限于由 http 位置提供服务的模板。这是 ARM 模板团队的一个非常糟糕的决定。为什么不允许本地模板？通常建议的解决方法是将模板上传到 blob 存储(如 Azure 存储帐户),并从那里通过 SASL 提供模板。但是为什么呢？这只会增加复杂性，上传要链接的内容——如果模板没有通过验证怎么办？还是在部署过程中出现了其他错误？现在我们还必须清理远程上传的资源。显然，这不是一个真正解决方案，所以我们发现自己有巨大的 ARM 模板，不可读，几乎不可行。

# 幂等性

作为代码系统的基础设施的一个重要要求是幂等的。多次运行相同的部署代码不会改变结果。通常，这还意味着对于已经按照描述部署的基础架构组件来说，速度会更快。随着时间的推移，您的云基础架构环境几乎不可避免地会增长，描述它的代码也会随之增长。但是我们通常都是重新部署的？每一次基础设施的推进，我们都必须确保它不会破坏/改变已经按照描述设置好的东西。遗憾的是，对于某些部分，ARM 无法保证这一点。具体到 Azure Kubernetes 服务，我遇到过多次重新部署同一个集群以各种方式破坏集群的情况。

最糟糕的是，它很脆弱，各种 API 变化会引入新的错误。我最近在 Azure arm 模板中发现了 2 个错误，使用最新的 api 版本和标准 lb，您无法重新部署已部署的 AKS 集群，除非它在您创建它时使用的确切节点数中，并且没有自动缩放。如果您更改计数以适应当前的节点数，就会遇到一个验证，如果您保持原来的计数，就会遇到另一个验证。我们刚刚在模板中禁用了 AKS 部署，因为这个 bug 使得它无法工作。大型部署会遇到速率限制(虽然很难将这些部署分开，见上文),这些速率限制是硬编码的，支持人员无法升级它们。

整个事情感觉就像他们没有在他们自己的过程中真正使用它；如此容易捕捉的错误直接交付到生产中。

我会继续使用 ARM 模板吗？目前是的，因为我不想放弃作为代码的基础设施。但这是一个非常糟糕的体验，不修复它，我看不出高级 Devops 实践者会心甘情愿地选择 Azure 云。