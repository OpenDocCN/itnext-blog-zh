<html>
<head>
<title>Microservices and continuous delivery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务和持续交付</h1>
<blockquote>原文：<a href="https://itnext.io/microservices-and-continuous-delivery-1e8c75b37ab1?source=collection_archive---------3-----------------------#2019-05-16">https://itnext.io/microservices-and-continuous-delivery-1e8c75b37ab1?source=collection_archive---------3-----------------------#2019-05-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="567e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">想象一个典型的情况——昨天你的devops工程师被老虎吃了。你很难过，因为他没有完成你项目的发布系统。它包含4个存储库:2个后端，1个前端，1个数据管道。</p><p id="eb7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您应该为您明天的项目建立一个部署管道。</p><p id="6a21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，您将了解如何设置<a class="ae ko" href="https://jenkins.io/" rel="noopener ugc nofollow" target="_blank"> Jenkins </a>、<a class="ae ko" href="https://www.ansible.com/" rel="noopener ugc nofollow" target="_blank"> Ansible </a>和<a class="ae ko" href="https://github.com/comtihon/catcher" rel="noopener ugc nofollow" target="_blank"> Catcher </a>来用E2E测试和最少的工作构建多环境生产就绪CI/CD。</p><h1 id="c2a7" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">独立管道</h1><p id="16ea" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">第一步是为每个服务建立一个单独的管道。我假设您是一名优秀的开发人员，并且您为每个服务都有一个单独的git存储库。</p><p id="5038" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，你需要做的就是写一个Jenkins管道，并通过组织插件手动或自动地将其提供给Jenkins。每次提交时都会触发管道。它将对每个分支进行测试。在环境分支(开发、阶段或主)的情况下，它也将构建docker映像并将它部署到正确的环境。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/bb45a6016781ddbbe330fe40e3e24086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rksVq5YJQXpUQJbY.png"/></div></div></figure><h2 id="dac0" class="me kq it bd kr mf mg dn kv mh mi dp kz kb mj mk ld kf ml mm lh kj mn mo ll mp bi translated">设置一个<a class="ae ko" href="https://jenkins.io/doc/book/pipeline/syntax/#agent" rel="noopener ugc nofollow" target="_blank">代理</a></h2><p id="1d4f" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">代理是每个詹金斯管道的起点。最常见的就是<code class="fe mq mr ms mt b">agent any</code>，除非你不需要什么特别的东西。</p><h2 id="9942" class="me kq it bd kr mf mg dn kv mh mi dp kz kb mj mk ld kf ml mm lh kj mn mo ll mp bi translated">设置<a class="ae ko" href="https://jenkins.io/doc/book/pipeline/syntax/#triggers" rel="noopener ugc nofollow" target="_blank">触发器</a></h2><p id="11e1" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">您的管道应该在每次提交时被触发。如果无法从外部网络访问您的Jenkins，请使用<code class="fe mq mr ms mt b">pollSCM</code>。</p><h2 id="fbb9" class="me kq it bd kr mf mg dn kv mh mi dp kz kb mj mk ld kf ml mm lh kj mn mo ll mp bi translated">设置<a class="ae ko" href="https://jenkins.io/doc/book/pipeline/syntax/#environment" rel="noopener ugc nofollow" target="_blank">环境</a>变量</h2><p id="1dde" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">它们使您的生活变得更加容易，因为它们允许您以最小的改动复制粘贴您的Jenkinsfile。<br/>环境应包括docker图像名称。</p><pre class="lt lu lv lw gt mu mt mv mw aw mx bi"><span id="7fd1" class="me kq it mt b gy my mz l na nb">environment { <br/>  IMAGE_NAME = "&lt;your_docker_registry_url:port&gt;/&lt;your_project&gt;:${env.BUILD_NUMBER}-${env.BRANCH_NAME}" <br/>  LATEST_IMAGE_NAME = "&lt;your_docker_registry_url:port&gt;/&lt;your_project&gt;:latest-${env.BRANCH_NAME}" <br/>}</span></pre><h2 id="d4f8" class="me kq it bd kr mf mg dn kv mh mi dp kz kb mj mk ld kf ml mm lh kj mn mo ll mp bi translated">设置普通<a class="ae ko" href="https://jenkins.io/doc/book/pipeline/syntax/#stage" rel="noopener ugc nofollow" target="_blank">步骤</a></h2><p id="4ec5" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">公共步骤是应该在每个分支上调用的步骤。即使是特征分支。</p><pre class="lt lu lv lw gt mu mt mv mw aw mx bi"><span id="fbb3" class="me kq it mt b gy my mz l na nb">steps { <br/>  sh "make test" <br/>}</span></pre><p id="8485" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">记住，坚持标准是明智的决定(否则你也会被老虎吃掉)。因此，确保您的存储库中有一个<a class="ae ko" href="https://en.wikipedia.org/wiki/Makefile" rel="noopener ugc nofollow" target="_blank"> Makefile </a>。它是你的朋友，因为它允许你建立语言无关的管道。即使你的新开发人员不知道你的编程语言或构建系统，他们也会理解，调用<code class="fe mq mr ms mt b">make test</code>将测试你的项目。</p><p id="52db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这也是通知的合适位置。使用<code class="fe mq mr ms mt b">slackSend</code>到<a class="ae ko" href="https://jenkins.io/doc/pipeline/steps/slack/" rel="noopener ugc nofollow" target="_blank">向项目的<a class="ae ko" href="https://slack.com" rel="noopener ugc nofollow" target="_blank">时差</a>通道发送</a>通知。</p><pre class="lt lu lv lw gt mu mt mv mw aw mx bi"><span id="0dff" class="me kq it mt b gy my mz l na nb">slackSend color: "warning", message: "Started: ${env.JOB_NAME} - ${env.BUILD_NUMBER} (&lt;${env.BUILD_URL}|Open&gt;)"</span></pre><h2 id="6f17" class="me kq it bd kr mf mg dn kv mh mi dp kz kb mj mk ld kf ml mm lh kj mn mo ll mp bi translated">设置特殊的构建步骤</h2><p id="21fe" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">特殊步骤是仅在对特殊分支进行更改时运行的步骤。Jenkins允许您使用when条件:</p><pre class="lt lu lv lw gt mu mt mv mw aw mx bi"><span id="24ab" class="me kq it mt b gy my mz l na nb">stage('Build') {<br/>  when {<br/>    expression {<br/>      return env.BRANCH_NAME == 'master' || env.BRANCH_NAME == 'develop' || env.BRANCH_NAME == 'stage' <br/>    }<br/>  } <br/>  steps { <br/>    sh "docker build -t ${env.IMAGE_NAME} ."<br/>    sh "docker push ${env.IMAGE_NAME}" <br/>    sh "docker tag ${env.IMAGE_NAME} ${env.LATEST_IMAGE_NAME}" <br/>    sh "docker push ${env.LATEST_IMAGE_NAME}" <br/>  }<br/>}</span></pre><h2 id="deb4" class="me kq it bd kr mf mg dn kv mh mi dp kz kb mj mk ld kf ml mm lh kj mn mo ll mp bi translated">设置特定于环境的部署</h2><p id="3abd" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">除了<code class="fe mq mr ms mt b">when</code>条件，您还应该选择合适的映像或配置来部署正确的环境。我使用<a class="ae ko" href="https://mesosphere.github.io/marathon/" rel="noopener ugc nofollow" target="_blank">马拉松</a>和我的dev/stage/prod使用不同的CPU限制、秘密和其他配置。它们存储在<code class="fe mq mr ms mt b">marathon/marathon_&lt;env&gt;.json</code>中。因此，在部署之前，您应该选择合适的配置文件。为此使用脚本:</p><pre class="lt lu lv lw gt mu mt mv mw aw mx bi"><span id="a48d" class="me kq it mt b gy my mz l na nb">stage('Deploy_api'){<br/>  when {<br/>    expression { <br/>      return env.BRANCH_NAME == 'master' || env.BRANCH_NAME == 'develop' || env.BRANCH_NAME == 'stage' <br/>    }<br/>  } <br/>  steps { <br/>    script { <br/>      if (env.BRANCH_NAME == 'master') { <br/>        env.MARATHON = "marathon/marathon_prod.json" <br/>      } else if (env.BRANCH_NAME == 'stage') { <br/>        env.MARATHON = "marathon/marathon_stage.json" <br/>      } else { <br/>        env.MARATHON = "marathon/marathon_dev.json" <br/>      } <br/>    } <br/>    marathon( <br/>        url: 'http://leader.mesos:8080', <br/>        docker: "${env.IMAGE_NAME}", <br/>        filename: "${env.MARATHON}" <br/>    ) <br/>  } <br/>}</span></pre><h1 id="9923" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">可能的提升角色</h1><p id="8ce7" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">设置从一个环境到另一个环境的提升的最简单的方法是触发之前配置的单独的管道。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nc"><img src="../Images/9af2058fba46df8d0f5e36ad5478bc28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6PCgY1Iofg17D6Z7.png"/></div></div></figure><p id="20f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在之前的<a class="ae ko" href="https://justtech.blog/2019/04/27/ansible-and-jenkins-automate-your-scritps/" rel="noopener ugc nofollow" target="_blank">文章</a>中，我向您展示了将Jenkins与Ansible一起使用要好得多。这里没有例外(想象一下，老虎也吃了你的詹金斯机器)。</p><p id="ed4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用包装在Ansible角色中的python脚本。对于那些没有读过我上一篇文章的人来说，可以使用groovy jenknis共享库，但不推荐使用:</p><ul class=""><li id="e6ad" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn ni nj nk nl bi translated">开发和调试这样的库是很困难的，因为本地安装了不同版本的Jenkins、Jenkins groovy插件和groovy。</li><li id="f56b" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated">这使得您的发布高度依赖于您的Jenkins，这是可以的，直到您决定转移到另一个配置项，或者您的Jenkins停机，您需要进行发布。</li></ul><h2 id="8450" class="me kq it bd kr mf mg dn kv mh mi dp kz kb mj mk ld kf ml mm lh kj mn mo ll mp bi translated">Python脚本</h2><p id="6b1b" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">要触发从开发到阶段的升级，您应该将开发合并到阶段并推动它。仅此而已。推送后，它的内部管道将被触发。</p><p id="1f55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">python脚本本身:</p><ol class=""><li id="2d86" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn nr nj nk nl bi translated">克隆存储库</li><li id="7de7" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn nr nj nk nl bi translated">签出您要提升的分支机构</li><li id="c533" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn nr nj nk nl bi translated">合并以前环境的分支</li><li id="19c7" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn nr nj nk nl bi translated">推它！</li></ol><p id="53a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这看起来很容易，尽管这里有一些提示。</p><p id="caff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">比起python的库，更喜欢你系统的git。在这种情况下，您可以在本地运行时使用自己的密钥。</p><pre class="lt lu lv lw gt mu mt mv mw aw mx bi"><span id="ef96" class="me kq it mt b gy my mz l na nb">def call_with_output(cmd: str, directory='.'): <br/>  output = subprocess.Popen(cmd.split(' '), <br/>                            stdout=subprocess.PIPE, <br/>                            stderr=subprocess.STDOUT, <br/>                            cwd=directory) <br/>  stdout, stderr = output.communicate() <br/>  if stderr is None: <br/>    return stdout <br/>  raise Exception(stderr)</span></pre><p id="b926" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您的存储库不是公共的，您应该通过令牌克隆它。注意，<code class="fe mq mr ms mt b">git_user</code>、<code class="fe mq mr ms mt b">git_token</code>和<code class="fe mq mr ms mt b">company</code>是可变变量。它们不会经常改变，所以我将它们存储在角色的默认变量中。</p><pre class="lt lu lv lw gt mu mt mv mw aw mx bi"><span id="d489" class="me kq it mt b gy my mz l na nb">call_with_output(f'git clone <a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/{{">https://{{</a> git_user }}:{{ git_token }}@github.com/{{ company }}/{ repo }.git')</span></pre><p id="e385" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果没有变化就不要调用<code class="fe mq mr ms mt b">push</code>就好。但是并不是所有的git版本都有相同的输出。<code class="fe mq mr ms mt b">up-to-date</code>不同于<code class="fe mq mr ms mt b">up to date</code>。我花了一段时间才注意到这一点。</p><pre class="lt lu lv lw gt mu mt mv mw aw mx bi"><span id="4a03" class="me kq it mt b gy my mz l na nb">changes = call_with_output(f"git merge { from_branch }", repo).decode("utf-8").strip() <br/>if changes != "Already up to date." and changes != "Already up-to-date.": <br/>  call_with_output(f"git push origin HEAD:{ to_branch }", repo)</span></pre><p id="bbfd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将时差通知直接发送到项目的频道也是一个好主意。你可以通过slack <a class="ae ko" href="https://api.slack.com/incoming-webhooks" rel="noopener ugc nofollow" target="_blank"> webhook </a>来完成。</p><pre class="lt lu lv lw gt mu mt mv mw aw mx bi"><span id="33b2" class="me kq it mt b gy my mz l na nb">def notify_slack(callback, message): <br/>  response = requests.post(callback, <br/>                           data=json.dumps({'text': message}), <br/>                           headers={'Content-Type': 'application/json'} ) <br/>  if response.status_code != 200: <br/>    raise ValueError('Request to slack returned an error %s, the response is:\n%s' <br/>                     % (response.status_code, response.text) )</span></pre><h1 id="ac44" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">詹金斯共享管道</h1><p id="60e5" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">现在你有了一个负责推销角色。是时候为整个项目创建一个Jenkins管道了，它会为你调用Ansible。这个管道可以由您手动触发，也可以由项目的任何服务自动触发。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/cfd66ee2d21dd11c954f4884b89de82a.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/0*HN2mqCFvTC-HS-Gy.png"/></div></figure><p id="7a42" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从添加参数开始:</p><pre class="lt lu lv lw gt mu mt mv mw aw mx bi"><span id="1d9f" class="me kq it mt b gy my mz l na nb">parameters { <br/>  choice(choices: 'develop\nstage\nmaster', description: 'Which environment should I check?', name: 'environment') <br/>}</span></pre><p id="f35a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">部署步骤:</p><pre class="lt lu lv lw gt mu mt mv mw aw mx bi"><span id="1392" class="me kq it mt b gy my mz l na nb">stage('Promote dev to stage') { <br/>  when { <br/>    expression { <br/>      return params.environment == 'develop' <br/>    } <br/>  } <br/>  steps { <br/>    deploy_all('develop', 'stage')<br/>  }<br/>}</span></pre><p id="638a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中<code class="fe mq mr ms mt b">deploy_all</code>使用您创建的角色下载您的ansible存储库，并为正在部署的项目的每个服务调用它。</p><pre class="lt lu lv lw gt mu mt mv mw aw mx bi"><span id="d65e" class="me kq it mt b gy my mz l na nb">def deploy_all(from, to) { <br/>  git branch: 'master', <br/>      credentialsId: "${env.GIT_USER_ID}", <br/>      url: "https://github.com/&lt;your_company&gt;/&lt;your_ansible_repo&gt;"    <br/>  deploy('repo_1', from, to) <br/>  deploy('repo_2', from, to) <br/>  deploy('repo_3', from, to) <br/>} </span><span id="6e4e" class="me kq it mt b gy nt mz l na nb">def deploy(repo, from, to) { <br/>  ansiblePlaybook( <br/>        playbook: "${env.PLAYBOOK_ROOT}/deploy_service.yaml", <br/>        inventory: "inventories/dev/hosts.ini", <br/>        credentialsId: ${env.SSH_USER_ID}, <br/>        extras: '-e "to=' + "${to}" + ' from=' +"${from}" + ' repo=' + "${repo}" + ' slack=' + "${env.SLACK_CALLBACK}" + '" -vvv') <br/>}</span></pre><p id="3a53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在您拥有了所有服务的部署管道，并且可以手动调用它。这比手动调用3个项目的管道快3倍。但这还不是我们的目标。</p><p id="c83a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要这个管道被我们的任何内部管道触发。</p><p id="e178" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将此步骤添加到服务的所有3个Jenkins文件中:</p><pre class="lt lu lv lw gt mu mt mv mw aw mx bi"><span id="508b" class="me kq it mt b gy my mz l na nb">stage('Trigger promotion pipeline) { <br/>  when { <br/>    expression { <br/>      return env.BRANCH_NAME == 'master' || env.BRANCH_NAME == 'develop' || env.BRANCH_NAME == 'stage' <br/>    } <br/>  } <br/>  steps { <br/>    build job: "../&lt;jenkins_promote_project_pipeline_name&gt;/master", <br/>          wait: false, <br/>          parameters: [ <br/>            string(name: 'environment', value: String.valueOf(env.BRANCH_NAME)) <br/>          ] <br/>  } <br/>}</span></pre><p id="d261" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">自动化部分现在完成了。合并功能分支后，将运行本地服务的测试，并将服务部署到开发环境中。之后，管道立即触发整个项目的推广管道。所有被更改的服务都将被部署到下一个环境中。</p><h1 id="eeb5" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">添加端到端测试</h1><p id="d6fd" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">自动提升是好的，但它有什么意义呢？它只是将您的更改从一个环境转移到另一个环境，而没有任何高级别的验收测试？</p><p id="4c0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Catcher的文章<a class="ae ko" href="https://justtech.blog/2019/05/16/end-to-end-microservices-testing-with-catcher/" rel="noopener ugc nofollow" target="_blank">中，我已经提到过，绿色服务的测试不能给你绝对的把握，你的服务可以正常地相互作用。为了确保整个系统正常工作，您需要在您的推广渠道中添加端到端测试。</a></p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/c78880654355a04bbfe07e5789fa7422.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/0*8PBf2lCbbT9Wjk3X.png"/></div></figure><p id="3fb1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要添加Catcher端到端测试，只需在Jenkins共享管道的存储库项目中创建<code class="fe mq mr ms mt b">inventory</code>和<code class="fe mq mr ms mt b">tests</code>(我假设您有单独的git存储库，其中存储了管道、带有部署描述的自述文件等)。</p><p id="4004" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在清单中，您应该提到针对每种环境的所有项目服务。<code class="fe mq mr ms mt b">develop</code>的费用:</p><pre class="lt lu lv lw gt mu mt mv mw aw mx bi"><span id="898d" class="me kq it mt b gy my mz l na nb">backend1: "http://service1.dev:8000" <br/>frontend: "http://service2.dev:8080" <br/>backend2: "http://service3.dev:9000" <br/>database: "http://service4.dev:5432"</span></pre><p id="319f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe mq mr ms mt b">tests</code>中，您应该进行端到端测试。最简单的事情就是检查他们的健康状况。它会告诉你，他们至少在工作。</p><pre class="lt lu lv lw gt mu mt mv mw aw mx bi"><span id="bd6b" class="me kq it mt b gy my mz l na nb">--- <br/>steps: <br/>  - http: <br/>      name: 'Check frontend is up' <br/>      get: <br/>        url: '{{ backend1 }}' <br/>  - http: <br/>      name: 'Check backend1 is up' <br/>      post: <br/>        url: '{{ backend1 }}/graphql' <br/>        body: ''' { __schema { types { name } } }''' <br/>        headers: <br/>          Content-Type: "application/graphql" <br/>  - http: <br/>      name: 'Check backend2 is up' <br/>      get: <br/>        url: '{{ backend2 }}/healthcheck' <br/>  - postgres: <br/>      conf: '{{ database }}' <br/>      query: 'select 1'</span></pre><p id="2821" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在部署之前，将测试步骤添加到您的jenkins管道中。不要忘记创建一个Makefile文件。</p><pre class="lt lu lv lw gt mu mt mv mw aw mx bi"><span id="b47a" class="me kq it mt b gy my mz l na nb">stage('Prepare') { <br/>  steps { <br/>    sh "make conda" <br/>    sh "make requirements" <br/>  }<br/>}</span></pre><p id="7cc5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">确保您选择了合适的环境。你应该总是测试相同的环境，这在<code class="fe mq mr ms mt b">patameter.environment</code>中有详细说明。</p><pre class="lt lu lv lw gt mu mt mv mw aw mx bi"><span id="71a9" class="me kq it mt b gy my mz l na nb">stage('Test') { <br/>  steps { <br/>    script { <br/>      if (params.environment == 'develop') { <br/>        env.INVENTORY = "dev.yml" <br/>      } else { <br/>        env.INVENTORY = "stage.yml" <br/>      } <br/>    } <br/>    sh "make test INVENTORY=${env.INVENTORY}" <br/>  } <br/>}</span></pre><p id="aa33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Makefile的一部分:</p><pre class="lt lu lv lw gt mu mt mv mw aw mx bi"><span id="0b1b" class="me kq it mt b gy my mz l na nb">CONDA_ENV_NAME ?= my_e2e_env <br/>ACTIVATE_ENV = source activate ./$(CONDA_ENV_NAME) </span><span id="fe38" class="me kq it mt b gy nt mz l na nb">.PHONY: conda <br/>conda: $(CONDA_ENV_NAME) <br/>$(CONDA_ENV_NAME): <br/>  conda create -p $(CONDA_ENV_NAME) --copy -y python=$(PY_VERSION) <br/>  $(ACTIVATE_ENV) &amp;&amp; python -s -m pip install -r requirements.txt </span><span id="7f4c" class="me kq it mt b gy nt mz l na nb">.PHONY: requirements <br/>requirements: <br/>  $(ACTIVATE_ENV) &amp;&amp; python -s -m pip install -r requirements.txt </span><span id="12ec" class="me kq it mt b gy nt mz l na nb">.PHONY: test <br/>test: <br/>  $(ACTIVATE_ENV) &amp;&amp; catcher script/tests -i inventory/${INVENTORY}</span></pre><h1 id="1f7e" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">禁用自动产品升级</h1><p id="559f" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">端到端测试不错，但并不完美。您不应该让每个更改都实时部署在prod上。除非你喜欢晚上工作。</p><p id="528a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为<code class="fe mq mr ms mt b">promote stage to master</code>管道的步骤添加一个输入。如果没有人按这个输入，它将被忽略。</p><pre class="lt lu lv lw gt mu mt mv mw aw mx bi"><span id="7686" class="me kq it mt b gy my mz l na nb">stage('Promote stage to prod') { <br/>  when { <br/>    expression { <br/>      return params.environment == 'stage' <br/>    } <br/>  } <br/>  steps { <br/>    script { <br/>      def userInput = false <br/>      try { <br/>        timeout(time: 60, unit: 'SECONDS') { <br/>          userInput = input(id: 'userInput', <br/>                            message: 'Promote current stage to prod?', <br/>                            parameters: [ <br/>                                [$class: 'BooleanParameterDefinition', defaultValue: false, description: '', name: 'Promote']<br/>                            ])<br/>        }<br/>      } catch(err) { <br/>      } <br/>      if (userInput) { <br/>        print('Deploying prod') <br/>        deploy_all('stage', 'master') <br/>      } else { <br/>        print('Skip deploy') <br/>      } <br/>    } <br/>  } <br/>}</span></pre><p id="7dc9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，只有在stage的e2e测试成功并且用户决定要升级更改后，才会部署prod。</p><h1 id="7939" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">结论</h1><p id="983f" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">这种管道允许您一次部署一堆微服务，只需对现有基础架构进行最少的更改，因为我们重用每个服务的内部部署管道，您可能已经有了。</p><p id="d262" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它并不完美，因为它没有考虑不完整的构建或红色服务级别测试。但它允许您在部署期间节省时间，并通过在一个位置设置所有相关服务来消除人为错误因素。</p><p id="0c14" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的下一篇文章中，我将向您展示一组微服务的回滚管道的示例。</p></div></div>    
</body>
</html>