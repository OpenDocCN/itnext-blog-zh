<html>
<head>
<title>The Top 10 Most Common Mistakes I’ve Seen in Go Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在Go项目中见过的最常见的10个错误</h1>
<blockquote>原文：<a href="https://itnext.io/the-top-10-most-common-mistakes-ive-seen-in-go-projects-4b79d4f6cd65?source=collection_archive---------0-----------------------#2019-07-17">https://itnext.io/the-top-10-most-common-mistakes-ive-seen-in-go-projects-4b79d4f6cd65?source=collection_archive---------0-----------------------#2019-07-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6bf87105470b9f96526d5e96e123d6ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OveXMMjlMGJT4lElwwLBnQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">信用:<a class="ae kc" href="http://teachertoolkit.co.uk" rel="noopener ugc nofollow" target="_blank">teachertoolkit.co.uk</a></figcaption></figure><h1 id="0bf9" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">开始前的注意事项</h1><p id="0310" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">随着这篇文章的成功，我想到这样的信息可以很好地适合这本书。因此，这是我未来的书:<strong class="ld ir"> 100个Go错误</strong>。它将于2022年出版，但已经可以作为MEAP (Manning Early Access Program)使用:</p><div class="lz ma gp gr mb mc"><a href="https://www.manning.com/books/100-go-mistakes-how-to-avoid-them" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd ir gy z fp mh fr fs mi fu fw ip bi translated">100个Go错误:如何避免它们</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">在你的Go代码中发现你自己都不知道的错误，并通过避免常见的…</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">www.manning.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq jw mc"/></div></div></a></div><h1 id="7eb9" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h1><p id="e9ba" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这篇文章是我在围棋项目中看到的最常见的错误列表。顺序并不重要。</p><h1 id="a5b1" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">未知的枚举值</h1><p id="cebd" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们看一个简单的例子:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="621a" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">这里，我们使用<code class="fe nc nd ne nf b">iota</code>创建了一个enum，它产生了以下状态:</p><pre class="mr ms mt mu gt ng nf nh ni aw nj bi"><span id="f1a2" class="nk ke iq nf b gy nl nm l nn no">StatusOpen = 0<br/>StatusClosed = 1<br/>StatusUnknown = 2</span></pre><p id="634d" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">现在，让我们假设这个<code class="fe nc nd ne nf b">Status</code>类型是JSON请求的一部分，并且将被编组/解组。我们可以设计以下结构:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="dfd1" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">然后，收到这样的请求:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="83b8" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">在这里，没什么特别的，地位会被取消安排到<code class="fe nc nd ne nf b">StatusOpen</code>吧？</p><p id="3f24" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">然而，让我们来看另一个请求，其中没有设置状态值(无论出于什么原因):</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="6836" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">在这种情况下，<code class="fe nc nd ne nf b">Request</code>结构的<code class="fe nc nd ne nf b">Status</code>字段将被初始化为其<strong class="ld ir">零值</strong>(对于<code class="fe nc nd ne nf b">uint32</code>类型:0)。所以，<code class="fe nc nd ne nf b">StatusOpen</code>而不是<code class="fe nc nd ne nf b">StatusUnknown</code>。</p><p id="48bc" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">最佳实践是将枚举的未知值设置为0:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="3f74" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">这里，如果状态不是JSON请求的一部分，它将被初始化为<code class="fe nc nd ne nf b">StatusUnknown</code>，正如我们所期望的。</p><h1 id="f304" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">标杆管理</h1><p id="18f5" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">正确的基准很难。有很多因素会影响给定的结果。</p><p id="4375" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">一个常见的错误就是被一些编译器优化忽悠了。让我们从<a class="ae kc" href="https://github.com/teivah/bitvector/" rel="noopener ugc nofollow" target="_blank"><em class="np">tei vah/bit vector</em></a>库中取一个具体的例子:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="d7d6" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">该函数清除给定范围内的位。为了使它成为长凳，我们可能要这样做:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="2174" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">在这个基准测试中，编译器会注意到<code class="fe nc nd ne nf b">clear</code>是一个叶函数(没有调用任何其他函数)，所以它会<strong class="ld ir">内联</strong>它。一旦它被内联，它也会注意到没有副作用。因此<code class="fe nc nd ne nf b">clear</code>调用将被简单地删除，导致不准确的结果。</p><p id="49db" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">一种方法是将结果设置为全局变量，如下所示:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="fcd1" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">这里，编译器不知道调用是否会产生副作用。因此，基准将是准确的。</p><h2 id="8066" class="nk ke iq bd kf nq nr dn kj ns nt dp kn lm nu nv kr lq nw nx kv lu ny nz kz oa bi translated">进一步阅读</h2><div class="lz ma gp gr mb mc"><a href="https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html#watch_out_for_compiler_optimisations" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd ir gy z fp mh fr fs mi fu fw ip bi translated">高性能围棋研讨会</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">注意编译器优化</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">dave.cheney.net</p></div></div><div class="ml l"><div class="ob l mn mo mp ml mq jw mc"/></div></div></a></div><h1 id="cb9e" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">指针！到处都是指针！</h1><p id="ed70" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">通过值传递变量将创建该变量的副本。而通过指针传递只会复制内存地址。</p><p id="bc31" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">因此，传递指针总是比<strong class="ld ir">快</strong>，不是吗？</p><p id="59bd" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">如果你相信这一点，请看看<a class="ae kc" href="https://gist.github.com/teivah/a32a8e9039314a48f03538f3f9535537" rel="noopener ugc nofollow" target="_blank">这个例子</a>。这是一个基于0.3 KB数据结构的基准测试，我们通过指针然后通过值来传递和接收。0.3 KB并不算大，但应该与我们每天看到的数据结构类型相差不远(对我们大多数人来说)。</p><p id="5d39" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">当我在本地环境中执行这些基准测试时，通过值传递比通过指针传递快4倍多。这可能有点违反直觉，对吗？</p><p id="4a86" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">对这一结果的解释与围棋如何管理内存有关。我不能像威廉·肯尼迪那样出色地解释它，但是让我们试着总结一下。</p><p id="fa0a" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">可以在<strong class="ld ir">堆</strong>或<strong class="ld ir">栈</strong>上分配变量。作为草稿:</p><ul class=""><li id="5531" class="oc od iq ld b le mx li my lm oe lq of lu og ly oh oi oj ok bi translated">堆栈包含给定<strong class="ld ir"> goroutine </strong>的<strong class="ld ir">正在进行的</strong>变量。一旦函数返回，变量就会从堆栈中弹出。</li><li id="203a" class="oc od iq ld b le ol li om lm on lq oo lu op ly oh oi oj ok bi translated">堆中包含了<strong class="ld ir">共享的</strong>变量(全局变量等。).</li></ul><p id="ab39" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">让我们看一个简单的例子，在这里我们返回一个值:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="9f37" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">这里，当前的goroutine创建了一个<code class="fe nc nd ne nf b">result</code>变量。这个变量被压入当前堆栈。一旦函数返回，客户端将收到该变量的副本。变量本身从堆栈中弹出。它仍然存在于内存中，直到被另一个变量擦除，但是它<strong class="ld ir">不能再被访问</strong>。</p><p id="1526" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">现在，同样的例子，但是有一个指针:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="79a2" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated"><code class="fe nc nd ne nf b">result</code>变量仍然由当前的goroutine创建，但是客户端将收到一个指针(变量地址的副本)。如果<code class="fe nc nd ne nf b">result</code>变量从堆栈中弹出，这个函数<strong class="ld ir">的客户端就不能再访问它了。</strong></p><p id="14a2" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">在这种情况下，Go编译器会将<strong class="ld ir">变量<code class="fe nc nd ne nf b">result</code>转义</strong>到一个变量可以共享的地方:<strong class="ld ir">堆</strong>。</p><p id="367f" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">然而，传递指针是另一种情况。例如:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="3cd1" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">因为我们在同一个goroutine中调用<code class="fe nc nd ne nf b">f</code>，所以不需要对<code class="fe nc nd ne nf b">p</code>变量进行转义。它被简单地推到堆栈中，子函数可以访问它。</p><p id="c5d4" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">例如，这是在<code class="fe nc nd ne nf b">io.Reader</code>的<code class="fe nc nd ne nf b">Read</code>方法中接收切片而不是返回切片的直接结果。返回一个片(这是一个指针)会将它转义到堆中。</p><p id="417a" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">那为什么栈这么<strong class="ld ir">快</strong>呢？有两个主要原因:</p><ul class=""><li id="f6c4" class="oc od iq ld b le mx li my lm oe lq of lu og ly oh oi oj ok bi translated">堆栈不需要有一个<strong class="ld ir">垃圾收集器</strong>。正如我们所说的，变量一旦创建就被简单地推入，然后一旦函数返回就从堆栈中弹出。不需要一个复杂的过程来回收未使用的变量等等。</li><li id="4d5a" class="oc od iq ld b le ol li om lm on lq oo lu op ly oh oi oj ok bi translated">一个堆栈属于一个goroutine，因此与在堆上存储变量相比，存储变量不需要<strong class="ld ir">同步</strong>。这也导致了性能的提高。</li></ul><p id="f4dc" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">作为结论，当我们创建一个函数时，我们的默认行为应该是使用<strong class="ld ir">值而不是指针</strong>。只有当我们想要<strong class="ld ir">共享</strong>一个变量时，才应该使用指针。</p><p id="fb7f" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">然后，如果我们遇到性能问题，一个可能的优化是检查指针在某些特定情况下是否有用。使用下面的命令:<code class="fe nc nd ne nf b">go build -gcflags "-m -m"</code>可以知道编译器何时将变量转义到堆中。</p><p id="45cc" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">但是，对于我们的大多数日常用例来说，值是最合适的。</p><h2 id="eea8" class="nk ke iq bd kf nq nr dn kj ns nt dp kn lm nu nv kr lq nw nx kv lu ny nz kz oa bi translated"><strong class="ak">延伸阅读</strong></h2><div class="lz ma gp gr mb mc"><a href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd ir gy z fp mh fr fs mi fu fw ip bi translated">栈和指针的语言机制</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">前奏这是一个四部分系列的第一篇文章，将提供对机械和设计的理解…</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">www.ardanlabs.com</p></div></div><div class="ml l"><div class="oq l mn mo mp ml mq jw mc"/></div></div></a></div><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="or mw l"/></div></figure><h1 id="cf3b" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">中断for/switch或for/select</h1><p id="13fe" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">如果<code class="fe nc nd ne nf b">f</code>返回true，下面的例子会发生什么？</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="fd88" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">我们将调用<code class="fe nc nd ne nf b">break</code>语句。然而，这将中断<code class="fe nc nd ne nf b">switch</code>语句，<strong class="ld ir">而不是for循环</strong>。</p><p id="b2fa" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">相同的问题:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="d8ce" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated"><code class="fe nc nd ne nf b">break</code>与<code class="fe nc nd ne nf b">select</code>语句有关，与for循环无关。</p><p id="7369" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">断开for/switch或for/select的一个可能的解决方案是使用标记为break 的<strong class="ld ir">，如下所示:</strong></p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="d939" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">错误管理</h1><p id="65aa" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">围棋处理错误的方式还有点年轻。如果这是Go 2最值得期待的特性之一，那就不是巧合了。</p><p id="f7a4" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">当前的标准库(在Go 1.13之前)只提供了构造错误的函数，所以你可能想看看<a class="ae kc" href="https://github.com/pkg/errors" rel="noopener ugc nofollow" target="_blank"> <em class="np"> pkg/errors </em> </a>(如果还没有这样做的话)。</p><p id="9467" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">这个库很好地遵循了下面的经验法则，而这条法则并不总是被遵守:</p><p id="3c17" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated"><em class="np">一个错误应该只处理</em> <strong class="ld ir"> <em class="np">一次</em> </strong> <em class="np">。记录错误</em> <strong class="ld ir"> <em class="np">就是</em> </strong> <em class="np">处理错误。因此，错误应该</em><strong class="ld ir"><em class="np"/></strong><em class="np">被记录或传播。</em></p><p id="171b" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">对于当前的标准库，很难做到这一点，因为我们可能想给错误添加一些上下文，并有某种形式的层次结构。</p><p id="7f48" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">让我们看一个例子，看看REST调用会导致什么样的DB问题:</p><pre class="mr ms mt mu gt ng nf nh ni aw nj bi"><span id="758c" class="nk ke iq nf b gy nl nm l nn no">unable to serve HTTP POST request for customer 1234<br/> |_ unable to insert customer contract abcd<br/>     |_ unable to commit transaction</span></pre><p id="9a5c" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">如果我们使用<em class="np"> pkg/errors </em>，我们可以这样做:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="c4cc" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">初始错误(如果不是外部库返回的)可以用<code class="fe nc nd ne nf b">errors.New</code>创建。中间层<code class="fe nc nd ne nf b">insert</code>通过添加更多的上下文来包装这个错误。然后，父进程通过记录错误来处理它。每个级别要么返回错误，要么处理错误。</p><p id="ec4c" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">例如，我们可能还想检查错误原因本身，以实现重试。假设我们有一个来自外部库的<code class="fe nc nd ne nf b">db</code>包来处理数据库访问。这个库可能会返回一个名为<code class="fe nc nd ne nf b">db.DBError</code>的暂时错误。为了确定我们是否需要重试，我们必须检查错误原因:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="9902" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">这是使用<code class="fe nc nd ne nf b">errors.Cause</code>完成的，它也来自<em class="np"> pkg/errors </em>:</p><p id="89b5" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">我见过的一个常见错误是部分使用<em class="np"> pkg/errors </em>。例如，检查错误是这样完成的:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="c2b5" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">在本例中，如果<code class="fe nc nd ne nf b">db.DBError</code>被包装，它将永远不会触发重试。</p><div class="lz ma gp gr mb mc"><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd ir gy z fp mh fr fs mi fu fw ip bi translated">不要只是检查错误，要优雅地处理它们</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">这篇文章摘自我最近在日本东京举行的GoCon春季会议上的演讲。我花了很多…</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">dave.cheney.net</p></div></div></div></a></div><h1 id="3972" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">切片初始化</h1><p id="924f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">有时，我们知道切片的最终长度。例如，假设我们想要将一个切片<code class="fe nc nd ne nf b">Foo</code>转换为一个切片<code class="fe nc nd ne nf b">Bar</code>，这意味着两个切片将具有相同的长度。</p><p id="8535" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">我经常看到切片这样初始化:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="81d7" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">切片不是一个神奇的结构。在引擎盖下，如果没有更多可用空间，它会实施一个<strong class="ld ir">增长</strong>战略。在这种情况下，会自动创建一个新数组(具有更大的容量<a class="ae kc" href="https://www.darkcoding.net/software/go-how-slices-grow/" rel="noopener ugc nofollow" target="_blank">)并复制所有项目。</a></p><p id="0dc3" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">现在，假设我们需要多次重复这个增长操作，因为我们的<code class="fe nc nd ne nf b">[]Foo</code>包含数千个元素？插入的分摊时间复杂度(平均值)将保持为O(1)，但实际上，它将对性能产生<strong class="ld ir">影响</strong>。</p><p id="6e79" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">因此，如果我们知道最终长度，我们可以:</p><ul class=""><li id="e94e" class="oc od iq ld b le mx li my lm oe lq of lu og ly oh oi oj ok bi translated">用预定义的长度初始化它:</li></ul><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><ul class=""><li id="fd67" class="oc od iq ld b le mx li my lm oe lq of lu og ly oh oi oj ok bi translated">或者用0长度和预定义的容量初始化它:</li></ul><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="e7d9" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">最好的选择是什么？第一个稍微快一点。然而，您可能更喜欢第二种方法，因为它可以使事情更加一致:不管我们是否知道初始大小，在片的末尾添加元素都是使用<code class="fe nc nd ne nf b">append</code>来完成的。</p><h1 id="5a5b" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">上下文管理</h1><p id="c299" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe nc nd ne nf b">context.Context</code>经常被开发者误解。根据官方文件:</p><blockquote class="os ot ou"><p id="dd46" class="lb lc np ld b le mx lg lh li my lk ll ov mz lo lp ow na ls lt ox nb lw lx ly ij bi translated">上下文携带截止日期、取消信号和其他跨API边界的值。</p></blockquote><p id="1ff7" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">这种描述太普通了，以至于有些人不知道为什么以及如何使用它。</p><p id="e59a" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">让我们试着详述一下。上下文可以承载:</p><ul class=""><li id="61c3" class="oc od iq ld b le mx li my lm oe lq of lu og ly oh oi oj ok bi translated">一个<strong class="ld ir">期限</strong>。它表示持续时间(例如250 ms)或日期时间(例如<code class="fe nc nd ne nf b">2019-01-08 01:00:00</code>)，如果达到该时间，我们认为必须取消正在进行的活动(I/O请求、等待通道输入等)。).</li><li id="b5cd" class="oc od iq ld b le ol li om lm on lq oo lu op ly oh oi oj ok bi translated">一个<strong class="ld ir">取消信号</strong>(基本上是一个<code class="fe nc nd ne nf b">&lt;-chan struct{}</code>)。在这里，行为是相似的。一旦我们收到信号，我们必须停止正在进行的活动。例如，假设我们收到两个请求。一个用来插入一些数据，另一个用来取消第一个请求(因为它不再相关了)。这可以通过在第一个调用中使用可取消的上下文来实现，一旦我们得到第二个请求，这个上下文就会被取消。</li><li id="c8ee" class="oc od iq ld b le ol li om lm on lq oo lu op ly oh oi oj ok bi translated">键/值的列表(都基于一个<code class="fe nc nd ne nf b">interface{}</code>类型)。</li></ul><p id="7a9a" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">补充两点。首先，上下文是<strong class="ld ir">可组合的</strong>。因此，我们可以有一个上下文来承载一个截止日期和一个键/值列表。此外，多个goroutines可以<strong class="ld ir">共享</strong>相同的上下文，因此取消信号可以潜在地停止<strong class="ld ir">多个活动</strong>。</p><p id="d7a3" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">回到我们的话题，这里有一个我看到的具体错误。</p><p id="62a4" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">一个Go应用程序是基于<a class="ae kc" href="https://github.com/urfave/cli" rel="noopener ugc nofollow" target="_blank"> <em class="np"> urfave/cli </em> </a>(如果你不知道，这是一个在Go中创建命令行应用程序的很好的库)。一旦开始，开发人员<em class="np">从某种应用程序上下文继承</em>。这意味着当应用程序停止时，库将使用这个上下文来发送一个取消信号。</p><p id="bdca" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">我所经历的是，这个上下文是在调用gRPC端点时直接传递的。这是<strong class="ld ir">而不是</strong>我们想要做的。</p><p id="c2e8" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">相反，我们希望向gRPC库指示:<em class="np">请在应用程序停止时或100毫秒后取消请求。</em></p><p id="b671" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">为了实现这一点，我们可以简单地创建一个组合上下文。如果<code class="fe nc nd ne nf b">parent</code>是应用上下文的名称(由<em class="np">ur save/CLI</em>创建)，那么我们可以简单地这样做:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="3d5c" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">上下文理解起来并不复杂，在我看来，这是这种语言最好的特点之一。</p><h2 id="08d5" class="nk ke iq bd kf nq nr dn kj ns nt dp kn lm nu nv kr lq nw nx kv lu ny nz kz oa bi translated">进一步阅读</h2><div class="lz ma gp gr mb mc"><a href="http://p.agnihotry.com/post/understanding_the_context_package_in_golang/" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd ir gy z fp mh fr fs mi fu fw ip bi translated">了解golang中的上下文包</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">go中的上下文包在与API和慢流程交互时可以派上用场，特别是在…</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">p.agnihotry.com</p></div></div><div class="ml l"><div class="oy l mn mo mp ml mq jw mc"/></div></div></a></div><div class="lz ma gp gr mb mc"><a href="https://grpc.io/blog/deadlines/" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd ir gy z fp mh fr fs mi fu fw ip bi translated">gRPC和截止日期</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">当您使用gRPC时，gRPC库负责通信、编组、解组和截止日期强制…</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">grpc.io</p></div></div></div></a></div><h1 id="89de" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">不使用-race选项</h1><p id="354d" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我经常看到的一个错误是在没有<code class="fe nc nd ne nf b">-race</code>选项的情况下测试Go应用程序。</p><p id="3701" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">正如这份<a class="ae kc" href="https://blog.acolyer.org/2019/05/17/understanding-real-world-concurrency-bugs-in-go/" rel="noopener ugc nofollow" target="_blank">报告</a>中所描述的，尽管Go是<em class="np">“为了让并发编程更容易、更不容易出错而设计的</em>”，但我们仍然饱受并发问题的困扰。</p><p id="0dcb" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">显然，Go race检测器不能解决所有的并发问题。然而，它是<strong class="ld ir">有价值的</strong>工具，我们应该在测试我们的应用程序时总是启用它。</p><h2 id="00bb" class="nk ke iq bd kf nq nr dn kj ns nt dp kn lm nu nv kr lq nw nx kv lu ny nz kz oa bi translated">进一步阅读</h2><div class="lz ma gp gr mb mc"><a href="https://medium.com/@val_deleplace/does-the-race-detector-catch-all-data-races-1afed51d57fb" rel="noopener follow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd ir gy z fp mh fr fs mi fu fw ip bi translated">Go race检测器能捕获所有的数据竞争错误吗？</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">TL；DR:当数据竞争情况发生时，它会检测到这些情况。</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">medium.com</p></div></div><div class="ml l"><div class="oz l mn mo mp ml mq jw mc"/></div></div></a></div><h1 id="04b4" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">使用文件名作为输入</h1><p id="c46e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">另一个常见的错误是将文件名传递给函数。</p><p id="7241" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">假设我们必须实现一个函数来计算文件中空行的数量。最自然的实现应该是这样的:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="fe84" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated"><code class="fe nc nd ne nf b">filename</code>作为输入给出，所以我们打开它，然后实现我们的逻辑，对吗？</p><p id="dd82" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">现在，假设我们想在这个函数的基础上实现<strong class="ld ir">单元测试</strong>来测试一个普通文件、一个空文件、一个不同编码类型的文件等等。它很容易变得非常难以管理。</p><p id="9300" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">此外，如果我们想要实现相同的逻辑，但是对于一个HTTP主体，例如，我们将不得不为此创建另一个函数。</p><p id="b1be" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">Go附带了两个伟大的抽象:<code class="fe nc nd ne nf b">io.Reader</code>和<code class="fe nc nd ne nf b">io.Writer</code>。我们可以简单地传递一个<code class="fe nc nd ne nf b">io.Reader</code>来代替传递文件名，这个<code class="fe nc nd ne nf b">io.Reader</code>将<strong class="ld ir">抽象出</strong>数据源。</p><p id="ab19" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">是文件吗？一个HTTP主体？字节缓冲区？这并不重要，因为我们仍将使用相同的<code class="fe nc nd ne nf b">Read</code>方法。</p><p id="f7c7" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">在我们的例子中，我们甚至可以缓冲输入来逐行读取它。所以，我们可以用<code class="fe nc nd ne nf b">bufio.Reader</code>和它的<code class="fe nc nd ne nf b">ReadLine</code>方法:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="00f7" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">打开文件本身的责任现在委托给了<code class="fe nc nd ne nf b">count</code>客户:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="d2b0" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">在第二种实现中，不管实际的数据源是什么，都可以调用函数<strong class="ld ir">。同时，这将<strong class="ld ir">促进</strong>我们的单元测试，因为我们可以简单地从<code class="fe nc nd ne nf b">string</code>创建一个<code class="fe nc nd ne nf b">bufio.Reader</code>:</strong></p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="3fad" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Goroutines和循环变量</h1><p id="3b4f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我见过的最后一个常见错误是在循环变量中使用goroutines。</p><p id="ed63" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">以下示例的输出是什么？</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="bf95" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated"><code class="fe nc nd ne nf b">1 2 3</code>不分先后？没有。</p><p id="61f9" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">在这个例子中，每个goroutine <strong class="ld ir">共享</strong>同一个变量实例，所以它将产生<code class="fe nc nd ne nf b">3 3 3</code>(最有可能)。</p><p id="0eac" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">有两种方法可以解决这个问题。第一个是将变量<code class="fe nc nd ne nf b">i</code>的值传递给闭包(内部函数):</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="13ca" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">第二个是在for循环范围内创建另一个变量:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="04f2" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">调用<code class="fe nc nd ne nf b">i := i</code>可能看起来有点奇怪，但它完全有效。在循环中意味着在另一个作用域中。所以<code class="fe nc nd ne nf b">i := i</code>创建了另一个名为<code class="fe nc nd ne nf b">i</code>的变量实例。当然，为了可读性，我们可能想用不同的名称来调用它。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><a href="https://twitter.com/teivah"><div class="gh gi pa"><img src="../Images/8fa32b4483c3ffb458830e0701b481e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*X_dKhY6YNVrgK77xKtH8yg.png"/></div></a><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">❤️喜欢我的工作吗？你可以考虑成为GitHub赞助商:<a class="ae kc" href="https://github.com/sponsors/teivah" rel="noopener ugc nofollow" target="_blank">https://github.com/sponsors/teivah</a>。</figcaption></figure><h2 id="247e" class="nk ke iq bd kf nq nr dn kj ns nt dp kn lm nu nv kr lq nw nx kv lu ny nz kz oa bi translated">进一步阅读</h2><div class="lz ma gp gr mb mc"><a href="https://www.manning.com/books/100-go-mistakes-how-to-avoid-them" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd ir gy z fp mh fr fs mi fu fw ip bi translated">100个Go错误:如何避免它们</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">在你的Go代码中发现你自己都不知道的错误，并通过避免常见的…</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">www.manning.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq jw mc"/></div></div></a></div><div class="lz ma gp gr mb mc"><a href="https://github.com/golang/go/wiki/CommonMistakes" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd ir gy z fp mh fr fs mi fu fw ip bi translated">golang/go</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">当新的程序员开始使用Go或者老的Go程序员开始使用一个新概念时，有一些共同的…</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">github.com</p></div></div><div class="ml l"><div class="pb l mn mo mp ml mq jw mc"/></div></div></a></div><h2 id="c01d" class="nk ke iq bd kf nq nr dn kj ns nt dp kn lm nu nv kr lq nw nx kv lu ny nz kz oa bi translated">翻译</h2><ul class=""><li id="0008" class="oc od iq ld b le lf li lj lm pc lq pd lu pe ly oh oi oj ok bi translated"><a class="ae kc" href="https://tomotoes.com/blog/the-top-10-most-common-mistakes-ive-seen-in-go-projects/" rel="noopener ugc nofollow" target="_blank">中文</a></li><li id="1b7d" class="oc od iq ld b le ol li om lm on lq oo lu op ly oh oi oj ok bi translated"><a class="ae kc" href="https://37yonub.ru/articles/common-mistakes" rel="noopener ugc nofollow" target="_blank">俄语</a></li><li id="83dc" class="oc od iq ld b le ol li om lm on lq oo lu op ly oh oi oj ok bi translated"><a class="ae kc" href="https://blog.faradars.org/top-10-most-common-mistakes-in-go-projects/" rel="noopener ugc nofollow" target="_blank">波斯语</a></li><li id="d6f5" class="oc od iq ld b le ol li om lm on lq oo lu op ly oh oi oj ok bi translated"><a class="ae kc" href="https://techblog.szksh.cloud/the-top-10-most-common-mistakes-ive-seen-in-go-projects/" rel="noopener ugc nofollow" target="_blank">日语</a>(仅限子部分)</li><li id="a63d" class="oc od iq ld b le ol li om lm on lq oo lu op ly oh oi oj ok bi translated"><a class="ae kc" href="https://blog.otso.fr/2019-12-26-top-10-erreurs-communes-projets-golang.html" rel="noopener ugc nofollow" target="_blank">法语</a></li></ul><p id="d464" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">你还有其他想分享的翻译吗？请随时联系我，以便我可以在这里包括它。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/1be1009eeb21be8dacfbf3afe8e56b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*Y9Gm4W5rGboaalEE5hZyhQ.png"/></div></figure><p id="1a91" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">你还想提到其他常见的错误吗？欢迎分享，继续讨论；)</p></div></div>    
</body>
</html>