<html>
<head>
<title>Kubernetes Authorization via Open Policy Agent</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过开放策略代理的Kubernetes授权</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-authorization-via-open-policy-agent-a9455d9d5ceb?source=collection_archive---------0-----------------------#2019-01-09">https://itnext.io/kubernetes-authorization-via-open-policy-agent-a9455d9d5ceb?source=collection_archive---------0-----------------------#2019-01-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5627" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在最佳实践的Kubernetes集群中，对Kubernetes APIServer的每个请求都经过身份验证和授权。<a class="ae kl" href="https://kubernetes.io/docs/reference/access-authn-authz/authorization/" rel="noopener ugc nofollow" target="_blank">授权</a>通常由<a class="ae kl" href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/" rel="noopener ugc nofollow" target="_blank"> RBAC </a>授权模块实现。但是还有其他选择，这篇博文解释了如何利用<a class="ae kl" href="https://kubernetes.io/docs/reference/access-authn-authz/webhook/" rel="noopener ugc nofollow" target="_blank"> Webhook </a>授权模块，通过<a class="ae kl" href="https://www.openpolicyagent.org/" rel="noopener ugc nofollow" target="_blank">开放策略代理(OPA) </a>实现高级授权策略。还有另一篇博文是关于如何针对生产环境对这个解决方案进行微调的(<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/optimizing-open-policy-agent-based-kubernetes-authorization-via-go-execution-tracer-7b439bb5dc5b">通过Go Execution Tracer </a>优化基于开放策略代理的Kubernetes授权)。</p><h1 id="6242" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">动机</h1><p id="cc42" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们是一个为公司内部客户提供托管Kubernetes集群的团队。为了提供一种接近上游的Kubernetes体验，我们希望授予我们的客户类似集群管理员的访问权限。但是为了确保基线的安全性和稳定性，我们不想授予完全的集群管理权限。例如:</p><ul class=""><li id="9d5a" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">我们希望允许对除“kube-system”之外的任何名称空间的完全访问，因为我们的基础设施(例如监控和日志记录)部署在那里。</li><li id="9637" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">我们希望实施一项PodSecurityPolicy，不允许以“root”用户身份运行容器或直接装载“hostPath”卷。</li></ul><p id="87c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的第一个实现是通过Kubernetes RBAC和一个定制运营商实现的。基本思想是通过RBAC角色绑定授予所有必要的权利。因此，除了“kube-system ”(通过操作符),我们为客户提供了每个名称空间的集群角色“admin”。每当我们发现某些东西不能按预期工作时，我们就添加额外的权限，或者通过每个名称空间的角色，或者通过一个集群角色。这导致了许多针对特定用例的单独规则，并且从长期来看是不可维护的。特别是随着我们的用户群继续增长，每当有人检测到与我们的配置不匹配的边缘情况时，调整角色实际上是不可行的。</p><p id="0a49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们没有基于白名单配置授权，而是切换到基于黑名单的模型。我们实际上想要的是给予我们的客户集群管理访问权，并且只限制一些特定的权限。因此，通过开放策略代理基于黑名单的实现是一个自然的选择。</p><h2 id="4cce" class="md kn iq bd ko me mf dn ks mg mh dp kw jy mi mj la kc mk ml le kg mm mn li mo bi translated">白名单与基于黑名单的授权</h2><p id="0f32" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">大多数关于授权的需求可以通过角色和角色绑定简单地使用RBAC授权模块来实现，这在<a class="ae kl" href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/" rel="noopener ugc nofollow" target="_blank">使用RBAC授权</a>中有解释。但是RBAC在设计上仅限于白名单，也就是说，对于每个请求，它都会检查其中一个角色和角色绑定是否适用，在这种情况下，请求会被批准。只有在不匹配的情况下请求才会被拒绝，没有办法明确地拒绝请求。起初，这听起来并不是一个很大的限制，但是一些特定的用例需要更多的灵活性。例如:</p><ul class=""><li id="66a4" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">用户应该能够在除“kube-system”之外的所有名称空间中创建/更新/删除pod。通过RBAC实现这一点的唯一方法是在每个名称空间的基础上分配权限，例如通过部署集群角色和每个名称空间角色绑定。如果名称空间随时间变化，您必须手动部署这个RoleBindings，或者为此运行一个操作符。</li><li id="d2bd" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">Kubernetes集群提供了预安装的存储类。用户应该能够创建/更新/删除自定义存储类，但不能修改预安装的存储类。如果要通过RBAC实施，用户必须拥有创建存储类的权限，并且在创建存储类后，必须分配额外的权限来更新和删除该存储类。如上所述，这可以通过运营商来实现。</li></ul><p id="e00c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你有很多这样的用例时，你会得到很多通过操作符实现的定制逻辑。这迟早不会扩展，因为有大量的操作员和伴随的RBAC角色，很难理解用户实际上拥有什么权限。我们将展示这两种情况都可以通过开放策略代理更容易地实现。</p><h2 id="7e2d" class="md kn iq bd ko me mf dn ks mg mh dp kw jy mi mj la kc mk ml le kg mm mn li mo bi translated">Webhook授权模块与验证Webhook和变异Webhook</h2><p id="8818" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">一些高级用例也可以通过<a class="ae kl" href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/" rel="noopener ugc nofollow" target="_blank">动态准入控制</a>实现，即ValidatingWebhook或MutatingWebhook。还有一些博客文章深入探讨了开放策略代理如何用于此目的:<a class="ae kl" href="https://medium.com/@jimmy.ray/policy-enabled-kubernetes-with-open-policy-agent-3b612b3f0203" rel="noopener">Policy Enabled Kubernetes with Open Policy Agent</a>和<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-compliance-with-open-policy-agent-3d282179b1e9">Kubernetes Compliance with Open Policy Agent</a>。动态准入控制有一个限制，即webhooks只能在Kubernetes资源上创建、更新和删除事件时调用。例如，拒绝get请求是不可能的。但是与Webhook授权模块相比，它们也有优势，因为它们可以根据Kubernetes资源的内容拒绝请求。这些是Webhook授权模块无法访问的信息。作为参考，Webhook授权模块基于<a class="ae kl" href="https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/authorization/types.go#L30" rel="noopener ugc nofollow" target="_blank"> SubjectAccessReviews </a>做出决定，而ValidatingWebhook和MutatingWebhook基于<a class="ae kl" href="https://github.com/kubernetes/api/blob/master/admission/v1beta1/types.go#L29" rel="noopener ugc nofollow" target="_blank"> AdmissionReviews </a>做出决定。在我们的实现中，我们通过授权模块和变异Webhook集成了OPA。</p><h1 id="1619" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">体系结构</h1><p id="41be" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">本节在概念层面上展示了Kubernetes如何与开放策略代理集成。因为开放策略代理本身不实现Kubernetes所需的REST接口，所以Kubernetes策略控制器将Kubernetes SubjectAccessReviews和AdmissionReviews转换为开放策略代理查询。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mp"><img src="../Images/26410164c3a1abd0dafb656acc801851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-s7y7xbncJB7Fqy0Zuxe4A.png"/></div></div></figure><p id="0c37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于Kubernetes API服务器收到的每个请求，将执行以下序列:</p><ol class=""><li id="2aa4" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk nb lv lw lx bi translated">请求已通过身份验证。</li><li id="03f6" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk nb lv lw lx bi translated">基于由认证提取的用户信息，请求被授权:<br/> 1。首先调用Webhook。在我们的例子中，Webhook可以拒绝请求，也可以将请求转发给RBAC。Kubernetes Webhook也可以允许请求，但是在Kubernetes策略控制器中没有实现。<br/> 2。其次，执行RBAC模块。如果RBAC不允许这个请求，这个请求就会被拒绝。</li><li id="9cea" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk nb lv lw lx bi translated">如果请求导致持久性的改变，例如创建/更新/删除资源，则执行准入控制器(MutatingWebhook只是其中之一)。点击阅读更多关于准入控制器<a class="ae kl" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/" rel="noopener ugc nofollow" target="_blank">的信息。</a></li></ol><p id="4152" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，根据我们想要拒绝的具体内容，我们现在可以实现授权或准入OPA策略。关于如何配置这个场景的更多信息可以在这里找到<a class="ae kl" href="https://github.com/open-policy-agent/kubernetes-policy-controller" rel="noopener ugc nofollow" target="_blank">open-policy-agent/kubernetes-policy-controller(授权场景)</a>。</p><h1 id="d40d" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">例子</h1><p id="e78f" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">本节展示了如何使用该设置来实现上述用例。</p><h2 id="be22" class="md kn iq bd ko me mf dn ks mg mh dp kw jy mi mj la kc mk ml le kg mm mn li mo bi translated">在除kube-system之外的每个名称空间中创建/更新/删除窗格</h2><p id="6d34" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">基本思想是通过RBAC授予集群范围内的pods创建/更新/删除权限，然后使用OPA策略拒绝对kube系统中的pods的访问。首先，我们授予“用户”组创建/更新/删除窗格的权限:</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="c59d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在,“用户”组中的每个用户都可以在集群范围内创建/更新/删除pod。为了通过OPA限制这些权限，部署了以下策略:</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="aeb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">备注:</strong></p><ul class=""><li id="a772" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">我们必须排除“系统:kube-控制器-管理器”和“系统:kube-调度器”,因为Kubernetes控制器管理器和调度器都必须能够访问pod。</li><li id="e4ce" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">只需从策略中删除“resource . spec . resource attributes . resource = " pods " ”,我们就可以限制对“kube-system”中所有命名空间资源的访问。</li><li id="5eb4" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">我们必须小心否定正确的动词。在RBAC，简单的“删除”允许“删除”和“删除集合”(参见<a class="ae kl" href="https://kubernetes.io/docs/reference/access-authn-authz/authorization/" rel="noopener ugc nofollow" target="_blank">授权概述</a>)。</li><li id="d796" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">开放策略代理使得为我们所有的策略编写单元测试变得非常容易。有关更多信息，请参见<a class="ae kl" href="https://www.openpolicyagent.org/docs/how-do-i-test-policies.html" rel="noopener ugc nofollow" target="_blank">如何测试策略？</a>。</li></ul><h2 id="83ac" class="md kn iq bd ko me mf dn ks mg mh dp kw jy mi mj la kc mk ml le kg mm mn li mo bi translated">在特定存储类上创建/更新/删除</h2><p id="4c71" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在本例中，我们希望授予用户对除“ceph”之外的所有存储类的创建/更新/删除权限。与第一个示例一样，我们必须通过RBAC授予用户访问权限:</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="9a05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们拒绝通过OPA访问存储类“ceph”。因此，我们部署了以下策略:</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="04b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个策略的单元测试可以这样实现:</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="2409" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结论</h1><p id="b41a" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">总之，与内置的RBAC授权相比，OPA允许更灵活的策略，尤其是在不使用额外操作符的情况下。在我看来，直接集成OPA作为授权模块和准入控制器是很好的，但同时Kubernetes策略控制器在Kubernetes和OPA之间架起了一座桥梁。可以实施的一些启示:</p><ul class=""><li id="4a21" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">拒绝访问特定的CustomResourceDefinitions，例如“calico”</li><li id="491f" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">拒绝对特定群集角色的访问，例如“群集管理”、“管理”、“编辑”、“查看”</li><li id="0a1f" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">仅允许端口转发到“kube-system”中的某些特定pod</li><li id="ac87" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">创建可以在哪些命名空间中使用哪些PodSecurityPolicies的映射</li><li id="e408" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">允许访问validating webhook configuration s，除了一些预安装的配置</li></ul><p id="a757" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何看待开放策略代理作为Kubernetes的策略引擎？您有哪些使用案例，它们已经被RBAC覆盖了吗？如果不是，您希望通过开放策略代理实现什么？</p><p id="5d30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您计划在生产中通过开放策略代理使用策略实施，我建议您也阅读<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/optimizing-open-policy-agent-based-kubernetes-authorization-via-go-execution-tracer-7b439bb5dc5b">通过Go Execution Tracer优化基于开放策略代理的Kubernetes授权</a>。</p><p id="ca33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果有任何进一步的问题，请写评论或通过<a class="ae kl" href="https://twitter.com/sbueringer" rel="noopener ugc nofollow" target="_blank"> @sbueringer </a>联系我。</p><p id="f080" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢<a class="ae kl" href="https://twitter.com/bavarian_bidi" rel="noopener ugc nofollow" target="_blank">马里奥·康斯坦蒂</a>和<a class="ae kl" href="https://twitter.com/chrischdi" rel="noopener ugc nofollow" target="_blank">克里斯蒂安·施洛特</a>在实施和审核这篇博文时给予的帮助:)感谢开放策略代理和Kubernetes策略控制器的所有贡献者，特别是<a class="ae kl" href="https://github.com/rite2nikhil" rel="noopener ugc nofollow" target="_blank"> Nikhil Bhatia </a>和<a class="ae kl" href="https://github.com/tsandall" rel="noopener ugc nofollow" target="_blank"> Torin Sandall </a>对我们实现开放策略代理授权模块集成的支持。</p></div></div>    
</body>
</html>