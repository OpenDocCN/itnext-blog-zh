<html>
<head>
<title>Kubernetes: ServiceAccounts, JWT-tokens, authentication, and RBAC authorization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes:服务账户、JWT令牌、认证和RBAC授权</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-serviceaccounts-jwt-tokens-authentication-and-rbac-authorization-e769f3d85a28?source=collection_archive---------2-----------------------#2020-11-22">https://itnext.io/kubernetes-serviceaccounts-jwt-tokens-authentication-and-rbac-authorization-e769f3d85a28?source=collection_archive---------2-----------------------#2020-11-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/748b92ab1e2dca4abc78177b8ed17bae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LwQ5TrmSSdHxgqBn6oahvw.png"/></div></div></figure><p id="05fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于认证和授权，Kubernetes有这样的概念:用户账户<em class="kw"/>和服务账户<em class="kw"/>。</p><p id="4983" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用户帐户—用于从外部访问群集的常见用户配置文件，而服务帐户用于从群集内部授予访问权限。</p><p id="3b13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ServiceAccounts旨在为Kubernetes Pod提供一个身份，供其容器在对Kubernetes API-server执行API请求时对其进行身份验证和授权。</p><h1 id="9e58" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">内容</h1><ul class=""><li id="e6e9" class="lv lw iq ka b kb lx kf ly kj lz kn ma kr mb kv mc md me mf bi translated"><a class="ae mg" href="https://rtfm.co.ua/en/kubernetes-serviceaccounts-jwt-tokens-authentication-and-rbac-authorization/#Default_ServiceAccount" rel="noopener ugc nofollow" target="_blank">默认服务账户</a></li><li id="3198" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated"><a class="ae mg" href="https://rtfm.co.ua/en/kubernetes-serviceaccounts-jwt-tokens-authentication-and-rbac-authorization/#default_token" rel="noopener ugc nofollow" target="_blank">默认令牌</a></li><li id="da4f" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated"><a class="ae mg" href="https://rtfm.co.ua/en/kubernetes-serviceaccounts-jwt-tokens-authentication-and-rbac-authorization/#JWT_token" rel="noopener ugc nofollow" target="_blank"> JWT令牌</a></li><li id="521d" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated"><a class="ae mg" href="https://rtfm.co.ua/en/kubernetes-serviceaccounts-jwt-tokens-authentication-and-rbac-authorization/#JWT_token_and_authentification" rel="noopener ugc nofollow" target="_blank"> JWT令牌和认证</a></li><li id="d7dc" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated"><a class="ae mg" href="https://rtfm.co.ua/en/kubernetes-serviceaccounts-jwt-tokens-authentication-and-rbac-authorization/#ServiceAccounts,_and_RBAC" rel="noopener ugc nofollow" target="_blank">服务账户和RBAC </a></li><li id="4918" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated"><a class="ae mg" href="https://rtfm.co.ua/en/kubernetes-serviceaccounts-jwt-tokens-authentication-and-rbac-authorization/#RoleBindig_for_ServiceAccount" rel="noopener ugc nofollow" target="_blank">服务帐户的role bindig</a></li><li id="73ce" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated"><a class="ae mg" href="https://rtfm.co.ua/en/kubernetes-serviceaccounts-jwt-tokens-authentication-and-rbac-authorization/#ServiceAccounts_and_security" rel="noopener ugc nofollow" target="_blank">服务账户和安全</a></li><li id="b609" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated"><a class="ae mg" href="https://rtfm.co.ua/en/kubernetes-serviceaccounts-jwt-tokens-authentication-and-rbac-authorization/#Useful_links" rel="noopener ugc nofollow" target="_blank">有用链接</a></li></ul><h1 id="a933" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">默认服务帐户</h1><p id="e601" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">每个Kubernetes名称空间都有自己的默认ServiceAccount (SA ),它是在创建名称空间时创建的。</p><p id="acf3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们检查一下<em class="kw">默认的</em>名称空间:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="89af" class="my ky iq mu b gy mz na l nb nc">$ kubectl --namespace default get serviceaccount<br/>NAME SECRETS AGE<br/>default 1 176d</span></pre><p id="08de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于每个ServiceAccount，都会生成一个令牌并存储为Kubernetes秘密。</p><p id="0942" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查默认服务协议:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="a064" class="my ky iq mu b gy mz na l nb nc">$ kubectl --namespace default get serviceaccount default -o yaml<br/>apiVersion: v1<br/>kind: ServiceAccount<br/>metadata:<br/>creationTimestamp: “2020–05–25T12:04:49Z”<br/>name: default<br/>namespace: default<br/>resourceVersion: “296”<br/>selfLink: /api/v1/namespaces/default/serviceaccounts/default<br/>uid: 19cc2b5f-fbc3–403e-a7c7-d62361a4038a<br/>secrets:<br/>- name: default-token-292g9</span></pre><p id="a2e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是这个SA的令牌——<em class="kw">默认令牌-292g9 </em>机密:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="12e0" class="my ky iq mu b gy mz na l nb nc">…<br/>secrets:<br/>- name: default-token-292g9</span></pre><h2 id="cbde" class="my ky iq bd kz nd ne dn ld nf ng dp lh kj nh ni ll kn nj nk lp kr nl nm lt nn bi translated">默认令牌</h2><p id="3553" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">现在，检查秘密的内容:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="373d" class="my ky iq mu b gy mz na l nb nc">$ kubectl get secret default-token-292g9 -o yaml<br/>apiVersion: v1<br/>data:<br/>ca.crt: LS0…sdA==<br/>token: ZXl…TWc=<br/>kind: Secret<br/>metadata:<br/>annotations:<br/>kubernetes.io/service-account.name: default<br/>kubernetes.io/service-account.uid: 19cc2b5f-fbc3–403e-a7c7-d62361a4038a<br/>creationTimestamp: “2020–05–25T12:04:49Z”<br/>name: default-token-292g9<br/>namespace: default<br/>resourceVersion: “294”<br/>selfLink: /api/v1/namespaces/default/secrets/default-token-292g9<br/>uid: 07a46645–0083–45a0-a640–6e6a78ebd9b1<br/>type: kubernetes.io/service-account-token</span></pre><p id="3de1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">起初，它的类型是<code class="fe no np nq mu b">kubernetes.io/service-account-token</code>。</p><p id="4d21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里另一个有趣的部分是保存两个记录的<code class="fe no np nq mu b">data</code>-<code class="fe no np nq mu b">ca.cert</code>、и <code class="fe no np nq mu b">token</code>。</p><p id="6064" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果某个令牌不是来自默认名称空间，将会有第三个字段指定该令牌所属的名称空间。</p><p id="f7aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe no np nq mu b">ca.cert</code>由集群的主密钥签名，因此集群扮演认证机构的角色，并允许pod或应用程序验证API-server。</p><p id="9892" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而现在，让我们一起去调查<code class="fe no np nq mu b">token</code>部分。</p><h2 id="07e9" class="my ky iq bd kz nd ne dn ld nf ng dp lh kj nh ni ll kn nj nk lp kr nl nm lt nn bi translated">JWT代币</h2><p id="6ccf" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">为了使从终端工作更容易—将<code class="fe no np nq mu b">data.token</code>值保存到一个变量:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="3ea7" class="my ky iq mu b gy mz na l nb nc">$ token=”ZXl…TWc=”</span></pre><p id="a5ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe no np nq mu b">base64</code>获取其内容:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="5328" class="my ky iq mu b gy mz na l nb nc">$ echo $token | base64 -d<br/>eyJ[…]iJ9.eyJ[…]ifQ.g5I[…]3Mg</span></pre><p id="a756" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我用[…]删除了一些数据，但是我们可以看到该值被用点分成了三个部分:</p><ul class=""><li id="b3e0" class="lv lw iq ka b kb kc kf kg kj nr kn ns kr nt kv mc md me mf bi translated"><em class="kw">标头</em> —描述令牌是如何签名的</li><li id="4f7b" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated"><em class="kw">有效负载</em> —令牌的实际数据，如到期日期、颁发者等，参见<a class="ae mg" href="https://tools.ietf.org/html/rfc7519#section-4.1" rel="noopener ugc nofollow" target="_blank"> RFC-7519 </a></li><li id="1e0d" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated"><em class="kw">签名</em> —用于验证令牌未被修改，并可用于验证发送者</li></ul><p id="38e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">参见<a class="ae mg" href="https://jwt.io/introduction/" rel="noopener ugc nofollow" target="_blank">文档&gt; &gt; &gt; </a>。</p><p id="a23b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要检查令牌的内容，我们可以使用<code class="fe no np nq mu b">jwt</code>实用程序或在<a class="ae mg" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> jwt.io </a>网站上。</p><p id="9fa0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的例子中，有效负载部分有以下几行:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="9d60" class="my ky iq mu b gy mz na l nb nc">{<br/>  "iss": "kubernetes/serviceaccount",<br/>  "kubernetes.io/serviceaccount/namespace": "default",<br/>  "kubernetes.io/serviceaccount/secret.name": "default-token-s8m4t",<br/>  "kubernetes.io/serviceaccount/service-account.name": "default",<br/>  "kubernetes.io/serviceaccount/service-account.uid": "b4514006-4c9a-4c30-92c8-1cc1c058b31c",<br/>  "sub": "system:serviceaccount:default:default"<br/>}</span></pre><p id="84aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里的<code class="fe no np nq mu b"><a class="ae mg" href="https://tools.ietf.org/html/rfc7519#section-4.1.2" rel="noopener ugc nofollow" target="_blank">sub</a></code>字段中，我们可以看到ServiceAccount名称，也就是谁向Kubernetes API-server提供了这个令牌，因此服务器将知道这个令牌来自谁。</p><p id="1edd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，那密码呢？在<code class="fe no np nq mu b">sub</code>中有一个“登录名”——但是他的“密码”在哪里呢？</p><p id="563a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是正在播放的第三部分——签名。</p><h2 id="7430" class="my ky iq bd kz nd ne dn ld nf ng dp lh kj nh ni ll kn nj nk lp kr nl nm lt nn bi translated">JWT令牌和认证</h2><p id="b024" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">我无法从谷歌搜索到的资料中看到这些细节，请参见本帖的<a class="ae mg" href="https://rtfm.co.ua/en/?p=25299#Useful_links" rel="noopener ugc nofollow" target="_blank">有用链接</a>部分，尽管对我来说——这是该计划最有趣的部分。</p><p id="383a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们回到令牌的第一部分——<em class="kw">报头</em>，在我们的例子中，它定义了RS256算法类型，即RSA(<em class="kw">Rivest-sha mir-ad leman</em>)—具有私钥和公钥的非对称算法，并使用SHA-256算法进行签名。</p><p id="f6f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们检查一下<a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/jwt.io"> jwt.io </a>上的令牌:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/9783d013e5b5ef4aacb48d956c4197cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Kx7AcDiWQfBHD6Ih.png"/></div></div></figure><p id="462b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="kw">无效签名</em> </strong> —因为我们没有提供私钥和公钥来验证令牌。</p><p id="721e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为AWS Elastic Kubernetes服务上的主密钥存储在控制平面节点上，我们无法访问它们——让我们使用<code class="fe no np nq mu b"><a class="ae mg" href="https://rtfm.co.ua/kubernetes-zapusk-minikube-na-arch-linux/" rel="noopener ugc nofollow" target="_blank">minikube</a></code>进行测试。</p><p id="80c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行本地集群:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="9449" class="my ky iq mu b gy mz na l nb nc">$ minikube start</span></pre><p id="f531" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在它的默认命名空间中，我们可以看到已经存在的标记:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="b4e2" class="my ky iq mu b gy mz na l nb nc">$ kubectl get secrets<br/>NAME TYPE DATA AGE<br/>default-token-s8m4t kubernetes.io/service-account-token 3 2m44s</span></pre><p id="8a34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">抓取<code class="fe no np nq mu b">token</code>字段并用<code class="fe no np nq mu b">base64</code>解码:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="55e3" class="my ky iq mu b gy mz na l nb nc">$ kubectl get secrets -o jsonpath=’{.items[0].data.token}’ | base64 -d<br/>eyJhbGciO[…]61O_LxbM_-tiLjyjeCZw</span></pre><p id="0cf7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到jwt.io，粘贴上面收到的字符串:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/462e6cbce0389684e789cf926e4cbe9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4NhKpUZFB7v1BHEt.png"/></div></div></figure><p id="afa8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">仍然<strong class="ka ir"> <em class="kw">无效签名</em></strong>——但是去你的<code class="fe no np nq mu b">minikube</code>拿它的公共证书—<code class="fe no np nq mu b">~/.minikube/ca.crt</code>文件:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="7be3" class="my ky iq mu b gy mz na l nb nc">$ cat ~/.minikube/ca.crt<br/> — — -BEGIN CERTIFICATE — — -<br/>MIIDBjCCAe6gAwIBAgIBATANBgkqhkiG9w0BAQsFADAVMRMwEQYDVQQDEwptaW5p<br/>…<br/>0g+FhVM92T+yV38vYLO/HaKeiOzIcgHHkAoLJZd/K/Mu7crwIuGlcCVhrjcHoa3p<br/>Md34ZTeqxA4J3w==<br/> — — -END CERTIFICATE — — -</span></pre><p id="35b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将其粘贴到<em class="kw">公钥或证书</em>字段。</p><p id="fc77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">找到<code class="fe no np nq mu b">minikube</code>集群的私钥——实际上，它也用于调用<code class="fe no np nq mu b">ca.crt</code>和令牌，即<code class="fe no np nq mu b">~/.minikube/ca.key</code>文件:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="f43a" class="my ky iq mu b gy mz na l nb nc">$ cat ~/.minikube/ca.key<br/> — — -BEGIN RSA PRIVATE KEY — — -<br/>MIIEowIBAAKCAQEAtDRDag2D7UBaBmWQwTKVLjuKTuat4eD/oThRgfi5bcCnwooG<br/>…<br/>xnL96EHthflb3NaS4GKuJYzNAPhfOdMw96Ce8KtNYpMYjRhNF9TN<br/> — — -END RSA PRIVATE KEY — — -</span></pre><p id="f9d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将其粘贴到<em class="kw">私钥</em>字段:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/6f1ae0544d8908bd4326569e7cf1d86f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ioH0eKFxi7UPCrUi.png"/></div></div></figure><p id="6f3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="kw">签名验证</em> </strong> —对，有效！令牌持有者的真实性得到验证。</p><p id="869e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，回到服务帐户:</p><ul class=""><li id="0699" class="lv lw iq ka b kb kc kf kg kj nr kn ns kr nt kv mc md me mf bi translated">对于服务帐户，会创建一个令牌来保存SA名称</li><li id="ad30" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated">令牌由Kubernetes集群的主密钥签名</li><li id="4b9f" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated">一个pod使用这个令牌向API服务器发出一个请求来认证他</li><li id="8a3c" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated">API服务器通过使用其公钥来验证令牌，并验证令牌未被修改并且确实是由这个Kubernetes clutser发布的</li></ul><p id="5984" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们来看看在实践中这是如何工作的，以及如何在这里使用Kubernetes RBAC。</p><h1 id="6d65" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">服务帐户和RBAC</h1><p id="cefb" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">对于每个没有指定ServiceAccount的Pod，将附加<em class="kw">默认</em> ServiceAccount，并安装其<em class="kw">默认</em>令牌。</p><p id="11ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到我们的EKS集群，运行一个Pod:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="2a01" class="my ky iq mu b gy mz na l nb nc">$ kubectl run -i --tty --rm ca-test-pod --image=radial/busyboxplus:curl<br/>kubectl run — generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run — generator=run-pod/v1 or kubectl create instead.<br/>If you don’t see a command prompt, try pressing enter.<br/>[ root@ca-test-pod-5c96c78d7f-wqlsq:/ ]$</span></pre><p id="533a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查<code class="fe no np nq mu b">volumeMounts</code>、<code class="fe no np nq mu b">serviceAccount</code>和<code class="fe no np nq mu b">volumes</code>:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="9de7" class="my ky iq mu b gy mz na l nb nc">$ kubectl get pod ca-test-pod-5c96c78d7f-wqlsq -o yaml<br/>apiVersion: v1<br/>kind: Pod<br/>…<br/>volumeMounts:<br/>- mountPath: /var/run/secrets/kubernetes.io/serviceaccount<br/>name: default-token-292g9<br/>readOnly: true<br/>…<br/>serviceAccount: default<br/>serviceAccountName: default<br/>…<br/>volumes:<br/>- name: default-token-292g9<br/>secret:<br/>defaultMode: 420<br/>secretName: default-token-292g</span></pre><p id="3ce9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在pod内部检查<code class="fe no np nq mu b">/var/run/secrets/kubernetes.io/serviceaccount</code>目录内容:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="3d20" class="my ky iq mu b gy mz na l nb nc">[ root@ca-test-pod-5c96c78d7f-wqlsq:/ ]$ ls -1 /var/run/secrets/kubernetes.io/serviceaccount<br/>ca.crt<br/>namespace<br/>token</span></pre><p id="7c50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并回忆一下<em class="kw">default-token-292 g9</em>Secret的<code class="fe no np nq mu b">data</code>部分的内容:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="2e3c" class="my ky iq mu b gy mz na l nb nc">$ kubectl get secret default-token-292g9 -o yaml<br/>apiVersion: v1<br/>data:<br/>ca.crt: LS0t[…]<br/>namespace: ZGVmYXVsdA==<br/>token: ZXlKaGJ<br/>…</span></pre><p id="50b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尝试在没有认证的情况下执行对API-server的请求—使用特殊服务<em class="kw"> kubernetes </em>，将<code class="fe no np nq mu b">-k</code>或<code class="fe no np nq mu b">--insecure</code>添加到<code class="fe no np nq mu b">curl</code>以跳过服务器的证书验证</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="f739" class="my ky iq mu b gy mz na l nb nc">[ root@ca-test-pod-5c96c78d7f-wqlsq:/ ]$ curl -k <a class="ae mg" href="https://kubernetes" rel="noopener ugc nofollow" target="_blank">https://kubernetes</a><br/>{<br/>“kind”: “Status”,<br/>“apiVersion”: “v1”,<br/>“metadata”: {<br/>},<br/>“status”: “Failure”,<br/>“message”: “forbidden: User \”system:anonymous\” cannot get path \”/\””,<br/>“reason”: “Forbidden”,<br/>“details”: {<br/>},<br/>“code”: 403<br/>}</span></pre><p id="66f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">酷——我们得到了403，禁止。</p><p id="1129" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，添加两个变量——一个带有<code class="fe no np nq mu b">ca.crt</code>和令牌:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="1143" class="my ky iq mu b gy mz na l nb nc">[ root@ca-test-pod-5c96c78d7f-wqlsq:/ ]$ CERT=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt<br/>[ root@ca-test-pod-5c96c78d7f-wqlsq:/ ]$ TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)</span></pre><p id="2930" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再次运行<code class="fe no np nq mu b">curl</code>——让我们尝试获取名称空间中的pod列表，这次没有使用<code class="fe no np nq mu b">--insecure</code>,而是使用<code class="fe no np nq mu b">Authorization</code>头进行授权:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="4920" class="my ky iq mu b gy mz na l nb nc">[ root@ca-test-pod-5c96c78d7f-wqlsq:/ ]$ curl — cacert $CERT -H “Authorization: Bearer $TOKEN” “https://kubernetes/api/v1/namespaces/default/pods/"<br/>{<br/>“kind”: “Status”,<br/>“apiVersion”: “v1”,<br/>“metadata”: {<br/>},<br/>“status”: “Failure”,<br/>“message”: “pods is forbidden: User \”system:serviceaccount:default:default\” cannot list resource \”pods\” in API group \”\” in the namespace \”default\””,<br/>“reason”: “Forbidden”,<br/>“details”: {<br/>“kind”: “pods”<br/>},<br/>“code”: 403<br/>}</span></pre><p id="5ed2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，我们能够看到我们的用户——<code class="fe no np nq mu b">User "system:serviceaccount:default:default"</code>,但是它没有执行请求的权限，因为默认情况下所有用户和服务帐户都没有权限(最小权限原则，POLP)。</p><h2 id="77d6" class="my ky iq bd kz nd ne dn ld nf ng dp lh kj nh ni ll kn nj nk lp kr nl nm lt nn bi translated">ServiceAccount的RoleBindig</h2><p id="7785" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">为了赋予我们的服务帐户权限，我们需要为普通用户创建一个<a class="ae mg" href="https://rtfm.co.ua/kubernetes-znakomstvo-chast-5-rbac-avtorizaciya-i-primery-role-i-rolebinding/" rel="noopener ugc nofollow" target="_blank"> RoleBinding </a>或ClusterRoleBinding。</p><p id="7e25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建到默认ClusterRole <em class="kw">视图</em>的RoleBinding映射，参见<a class="ae mg" href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles" rel="noopener ugc nofollow" target="_blank">面向用户的角色</a>:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="1125" class="my ky iq mu b gy mz na l nb nc">$ kubectl create rolebinding ca-test-view --clusterrole=view --serviceaccount=default:default<br/>rolebinding.rbac.authorization.k8s.io/ca-test-view created</span></pre><p id="111b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并再次运行<code class="fe no np nq mu b">curl</code>:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="4c3d" class="my ky iq mu b gy mz na l nb nc">[ root@ca-test-pod-5c96c78d7f-wqlsq:/ ]$ curl — cacert $CERT -H “Authorization: Bearer $TOKEN” “https://kubernetes/api/v1/namespaces/default/pods/"<br/>{<br/>“kind”: “PodList”,<br/>“apiVersion”: “v1”,<br/>“metadata”: {<br/>“selfLink”: “/api/v1/namespaces/default/pods/”,<br/>“resourceVersion”: “66892356”<br/>},<br/>“items”: [<br/>{<br/>“metadata”: {<br/>“name”: “ca-test-pod-5c96c78d7f-wqlsq”,<br/>“generateName”: “ca-test-pod-5c96c78d7f-”,<br/>“namespace”: “default”,<br/>“selfLink”: “/api/v1/namespaces/default/pods/ca-test-pod-5c96c78d7f-wqlsq”,<br/>“uid”: “f0d77cfe-38ab-48e9-aaf3-f344f1d343f3”,<br/>“resourceVersion”: “66888089”,<br/>“creationTimestamp”: “2020–11–17T16:08:09Z”,<br/>“labels”: {<br/>“pod-template-hash”: “5c96c78d7f”,<br/>“run”: “ca-test-pod”<br/>},<br/>…<br/>“qosClass”: “BestEffort”<br/>}<br/>}<br/>]</span></pre><h1 id="f824" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">服务帐户和安全性</h1><p id="67f2" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">请记住，拥有对机密和服务帐户的访问权限的任何pod都可以附加任何令牌，因此能够执行此类令牌所允许的操作。</p><p id="e1ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，通过使用<a class="ae mg" href="https://rtfm.co.ua/en/kubernetes-update-aws-route53-dns-from-an-ingress/" rel="noopener ugc nofollow" target="_blank"> ExternalDNS </a>的ServiceAccount这样的pod会把我们的AWS Route53弄得一团糟。</p><p id="0c51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是为什么使用RBAC规则和用户角色来划分对资源的访问非常重要，例如，只允许从一个命名空间访问资源。</p><h1 id="e301" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">有用的链接</h1><ul class=""><li id="b2c4" class="lv lw iq ka b kb lx kf ly kj lz kn ma kr mb kv mc md me mf bi translated"><a class="ae mg" href="https://dzone.com/articles/using-rbac-with-service-accounts-in-kubernetes" rel="noopener ugc nofollow" target="_blank">通过Kubernetes中的服务账户使用RBAC</a></li><li id="5a08" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated"><a class="ae mg" href="https://thenewstack.io/kubernetes-access-control-exploring-service-accounts/" rel="noopener ugc nofollow" target="_blank"> Kubernetes访问控制:探索服务账户</a></li><li id="69de" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated"><a class="ae mg" href="https://medium.com/better-programming/k8s-tips-using-a-serviceaccount-801c433d0023" rel="noopener"> Kubernetes提示:使用服务账户</a></li><li id="d041" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated"><a class="ae mg" href="https://jwt.io/introduction/" rel="noopener ugc nofollow" target="_blank">什么是JSON Web Token？</a></li><li id="7b60" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated"><a class="ae mg" href="https://jamesdefabia.github.io/docs/user-guide/service-accounts/" rel="noopener ugc nofollow" target="_blank"> kubernetes.io:服务账户</a></li><li id="8453" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated"><a class="ae mg" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/" rel="noopener ugc nofollow" target="_blank"> kubernetes.io:认证</a></li><li id="2f3e" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated"><a class="ae mg" href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles" rel="noopener ugc nofollow" target="_blank"> kubernetes.io:使用RBAC授权</a></li><li id="a9c9" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated"><a class="ae mg" href="https://telegraphhillsoftware.com/the-dark-arts-of-iam-rbac-read-only-kubernetes-access/" rel="noopener ugc nofollow" target="_blank">IAM的黑魔法&amp;RBAC——只读库伯内特访问</a></li><li id="a716" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated"><a class="ae mg" href="https://www.magalix.com/blog/kubernetes-authentication" rel="noopener ugc nofollow" target="_blank"> Kubernetes认证</a></li><li id="e4ca" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated"><a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/securing-kubernetes-withistio-end-user-authentication-using-json-web-tokens-jwt-97f4bb8e71c6">使用JSON Web令牌(JWT)和Auth0对Kubernetes进行Istio最终用户认证</a></li><li id="0225" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated"><a class="ae mg" href="https://www.cncf.io/blog/2020/07/31/kubernetes-rbac-101-authentication/" rel="noopener ugc nofollow" target="_blank"> Kubernetes RBAC 101:认证</a></li><li id="8164" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated"><a class="ae mg" href="https://medium.com/better-programming/how-to-authorize-non-kubernetes-clients-with-istio-on-your-k8s-cluster-8a90fe95b137" rel="noopener">如何在K8s集群上使用Istio授权非Kubernetes客户端</a></li><li id="0cf1" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated"><a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/how-does-client-authentication-work-on-amazon-eks-c4f2b90d943b">亚马逊EKS上的Kubernetes客户端认证</a></li><li id="3e01" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated"><a class="ae mg" href="https://www.nickaws.net/aws/kubernetes/2018/08/16/Verifying-digital-certificates.html" rel="noopener ugc nofollow" target="_blank">验证EKS数字证书</a></li><li id="4b66" class="lv lw iq ka b kb mh kf mi kj mj kn mk kr ml kv mc md me mf bi translated">三种现实的方法去了解库伯内特·RBAC</li></ul></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="2b14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">最初发布于</em> <a class="ae mg" href="https://rtfm.co.ua/en/kubernetes-serviceaccounts-jwt-tokens-authentication-and-rbac-authorization/" rel="noopener ugc nofollow" target="_blank"> <em class="kw"> RTFM: Linux，devo PSисистемноеадмиитииииииованниде</em></a><em class="kw">。</em></p></div></div>    
</body>
</html>