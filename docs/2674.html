<html>
<head>
<title>Practical guide to securing gRPC connections with Go and TLS — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保护gRPC与Go和TLS连接的实用指南—第1部分</h1>
<blockquote>原文：<a href="https://itnext.io/practical-guide-to-securing-grpc-connections-with-go-and-tls-part-1-f63058e9d6d1?source=collection_archive---------1-----------------------#2019-07-09">https://itnext.io/practical-guide-to-securing-grpc-connections-with-go-and-tls-part-1-f63058e9d6d1?source=collection_archive---------1-----------------------#2019-07-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="188a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与Go和gRPC建立安全TLS连接有不同的方法。与普遍的看法相反，您不需要手动向gRPC客户机提供服务器证书来加密连接。这篇文章将提供不同场景的代码示例列表。如果你只想看代码，去源代码<a class="ae ko" href="https://github.com/nleiva/grpc-tls" rel="noopener ugc nofollow" target="_blank">库</a>。您需要克隆这个<a class="ae ko" href="https://github.com/nleiva/grpc-tls" rel="noopener ugc nofollow" target="_blank">库</a>来跟进(Go1.11+)。</p><blockquote class="kp kq kr"><p id="bebf" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">" Web浏览器不持有TLS的公共证书，为什么我的应用程序要持有？"[ <a class="ae ko" href="http://gophersre.com/2019/06/21/grpc-dont-supply-a-client-cert/" rel="noopener ugc nofollow" target="_blank">不需要:gRPC客户端认证进入</a></p></blockquote><p id="faa0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是三篇系列文章的第一部分。在<a class="ae ko" href="https://medium.com/@nleiva/practical-guide-to-securing-grpc-connections-with-go-and-tls-part-2-994ef93b8ea9?sk=de526794eb30887988c9c78cf077fdf6" rel="noopener">第2部分</a>中，我们将用<a class="ae ko" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank">让我们加密</a>和自动化证书管理环境(ACME)来讨论公共证书，最后在第3部分中讨论相互认证。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi kw"><img src="../Images/a7aa6d603f05b67422d37559de333698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bldf6VALPr-8ivuvYyi4dw.png"/></div></div></figure><h1 id="1322" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">介绍</h1><p id="c44d" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">如<a class="ae ko" href="https://tools.ietf.org/html/rfc5246" rel="noopener ugc nofollow" target="_blank"> RFC 5246 </a>，<em class="ks">所述，传输层安全(TLS)协议的主要目标是在两个通信应用程序之间提供隐私和数据完整性</em>。TLS是gRPC内置的身份验证机制之一。<em class="ks">它集成了TLS，并提倡使用TLS对服务器进行身份验证，并对客户端和服务器之间交换的所有数据进行加密</em> " [ <a class="ae ko" href="https://grpc.io/docs/guides/auth/" rel="noopener ugc nofollow" target="_blank"> gRPC身份验证</a> ]。</p><p id="a830" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了建立TLS连接，客户端必须向服务器发送一个<code class="fe ml mm mn mo b">Client Hello</code>消息来启动TLS握手。<em class="ks">TLS握手协议允许服务器和客户端在应用程序协议发送或接收其第一个字节的数据</em> [ <a class="ae ko" href="https://tools.ietf.org/html/rfc5246" rel="noopener ugc nofollow" target="_blank"> RFC 5246 </a> ]之前，相互认证并协商加密算法和密钥。</p><p id="cf54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个<code class="fe ml mm mn mo b">Client Hello</code>消息包括客户端支持建立安全连接的选项列表；TLS版本、随机数、会话ID、密码套件、压缩方法和扩展名，如下面的数据包捕获所示。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi mp"><img src="../Images/ab7aec557d0517abe8e4e00536ad11a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fxBOLcyhU6FyQOsrq7QLSw.png"/></div></div></figure><p id="2d7e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">服务器回复一个<code class="fe ml mm mn mo b">Server Hello</code>，包括它的首选TLS版本、一个随机数、一个会话ID以及所选的密码套件和压缩方法(下图中的<code class="fe ml mm mn mo b">TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</code>和<code class="fe ml mm mn mo b">null</code>)。服务器还将包括一个签名的TLS证书。client⁠(取决于其configuration⁠)将通过证书颁发机构(CA)验证该证书，以证明服务器的身份。CA是颁发数字证书的可信方。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi mq"><img src="../Images/84efcbdc4ef1b8a6f16def20009c31a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZVYDeVbZZYtDthE04gFbkg.png"/></div></div></figure><p id="6efe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">证书也可以出现在单独的消息中，如下面的截图所示。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi mr"><img src="../Images/9ceec10a0b17cfb2e2c4b460cf6d9352.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yx0rHe4Ss1O_yq-LcoZ7Uw.png"/></div></div></figure><p id="cb04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">协商之后，他们通过加密通道开始客户端密钥交换(对称与非对称加密)。接下来，他们开始发送加密的应用程序数据。我对这部分有点过于简化了，但我认为我们已经有足够的上下文来评估接下来的代码片段。</p><h1 id="8483" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">证书</h1><p id="3204" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">在开始编写代码之前，我们先来谈谈证书。X.509 v3证书格式在<a class="ae ko" href="https://tools.ietf.org/html/rfc5280" rel="noopener ugc nofollow" target="_blank"> RFC 5280 </a>中有详细描述。它对服务器的公钥和数字签名进行编码(以验证证书的真实性)。</p><pre class="kx ky kz la gt ms mo mt mu aw mv bi"><span id="b42d" class="mw lj it mo b gy mx my l mz na">Certificate  ::=  SEQUENCE  {<br/>    tbsCertificate       TBSCertificate,<br/>    signatureAlgorithm   AlgorithmIdentifier,<br/>    signatureValue       BIT STRING  }</span></pre><p id="09ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在你问之前，TBS意味着要被签署。</p><pre class="kx ky kz la gt ms mo mt mu aw mv bi"><span id="7ef7" class="mw lj it mo b gy mx my l mz na">TBSCertificate  ::=  SEQUENCE  {<br/>    version         [0]  EXPLICIT Version DEFAULT v1,<br/>    serialNumber         CertificateSerialNumber,<br/>    signature            AlgorithmIdentifier,<br/>    issuer               Name,<br/>    validity             Validity,<br/>    subject              Name,<br/>    subjectPublicKeyInfo SubjectPublicKeyInfo,<br/>    ...<br/>    }</span></pre><p id="3a66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">X.509证书的一些最相关的字段是:</p><ul class=""><li id="ba5c" class="nb nc it js b jt ju jx jy kb nd kf ne kj nf kn ng nh ni nj bi translated"><code class="fe ml mm mn mo b">subject</code>:证书签发主体名称。</li><li id="ad60" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated"><code class="fe ml mm mn mo b">subjectPublicKey</code>:公钥和密钥使用的算法(如RSA、DSA或Diffie-Hellman)。见下文。</li><li id="63f3" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated"><code class="fe ml mm mn mo b">issuer</code>:签发证书的CA的名称</li><li id="bf94" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated"><code class="fe ml mm mn mo b">signature</code>:CA签署证书所用算法的算法标识符(同<code class="fe ml mm mn mo b">signatureAlgorithm</code>)。</li></ul><pre class="kx ky kz la gt ms mo mt mu aw mv bi"><span id="36b7" class="mw lj it mo b gy mx my l mz na">SubjectPublicKeyInfo  ::=  SEQUENCE  {<br/>    algorithm            AlgorithmIdentifier,<br/>    subjectPublicKey     BIT STRING  }</span></pre><p id="eb02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以在<a class="ae ko" href="https://golang.org/pkg/crypto/x509/#Certificate" rel="noopener ugc nofollow" target="_blank"> x.509库</a>中看到这个Go代码。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="9495" class="mw lj it bd lk nr ns dn lo nt nu dp ls kb nv nw lw kf nx ny ma kj nz oa me ob bi translated"><strong class="ak">创建自签名证书</strong></h2><p id="7304" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">虽然SSL证书在由可信的证书颁发机构(CA)颁发时最为可靠，但出于本文的目的，我们将使用自签名证书，这意味着我们自己对它们进行签名(我们就是CA)。在第2部分中，我们将使用<a class="ae ko" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank">来加密</a>证书。</p><p id="fa9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面描述了创建它们的步骤，我们依靠<code class="fe ml mm mn mo b">openssl</code>和一个配置文件(<code class="fe ml mm mn mo b">certificate.conf</code>)来选择主题替换名称(<code class="fe ml mm mn mo b">subjectAltName</code>)而不是不推荐的通用名称(<code class="fe ml mm mn mo b">CN</code>)。</p><p id="2acc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了一次性再现所有这些，您可以在克隆了<a class="ae ko" href="https://github.com/nleiva/grpc-tls" rel="noopener ugc nofollow" target="_blank">存储库</a>之后运行<code class="fe ml mm mn mo b">make cert</code>(这是后面所有gRPC示例的先决条件)。步骤如下。</p><p id="7b3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">创建根签名密钥</strong></p><pre class="kx ky kz la gt ms mo mt mu aw mv bi"><span id="88f9" class="mw lj it mo b gy mx my l mz na">openssl genrsa -out ca.key 4096</span></pre><p id="05e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">生成自签名根证书</strong></p><p id="1a05" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以修改“/C=US/ST=NJ/O=CA，Inc.”以适合您的位置和虚构的CA名称。</p><pre class="kx ky kz la gt ms mo mt mu aw mv bi"><span id="eac3" class="mw lj it mo b gy mx my l mz na">openssl req -new -x509 -key ca.key -sha256 -subj "/C=US/ST=NJ/O=CA, Inc." -days 365 -out ca.cert</span></pre><p id="fdc5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将为我们的CA生成以下证书。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi oc"><img src="../Images/55763a7828cbd833c6db7dabc0e8ecfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*crbeS1avOeCJ2rW13SRP4Q.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated">CA证书</figcaption></figure><p id="6f43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为服务器创建一个密钥证书</p><pre class="kx ky kz la gt ms mo mt mu aw mv bi"><span id="b7aa" class="mw lj it mo b gy mx my l mz na">openssl genrsa -out service.key 4096</span></pre><p id="d159" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">创建签约CSR </strong></p><pre class="kx ky kz la gt ms mo mt mu aw mv bi"><span id="df42" class="mw lj it mo b gy mx my l mz na">openssl req -new -key service.key -out service.csr -config certificate.conf</span></pre><p id="3439" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">为服务器生成证书</strong></p><pre class="kx ky kz la gt ms mo mt mu aw mv bi"><span id="9a25" class="mw lj it mo b gy mx my l mz na">openssl x509 -req -in service.csr -CA ca.cert -CAkey ca.key -CAcreateserial -out service.pem -days 365 -sha256 -extfile certificate.conf -extensions req_ext</span></pre><p id="51dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将产生以下证书。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi oc"><img src="../Images/57d668a87a3f2e3402806c9f336ad338.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*18hjw2pRLuRPXAX50saxxA.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated">服务器证书</figcaption></figure><p id="af16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">验证</strong></p><p id="dc8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也可以看看带<code class="fe ml mm mn mo b">openssl</code>的证书。</p><pre class="kx ky kz la gt ms mo mt mu aw mv bi"><span id="4c9b" class="mw lj it mo b gy mx my l mz na">$ openssl x509 -in service.pem -text -noout<br/>Certificate:<br/>    Data:<br/>        Version: 3 (0x2)<br/>        Serial Number: 12273773735572067708 (0xaa55342eea4ad57c)<br/>    Signature Algorithm: sha256WithRSAEncryption<br/>        Issuer: C=US, ST=NJ, O=CA, Inc.<br/>        Validity<br/>            Not Before: Jun 28 13:56:36 2019 GMT<br/>            Not After : Jun 27 13:56:36 2020 GMT<br/>        Subject: C=US, ST=NJ, O=Test, Inc., CN=localhost<br/>        Subject Public Key Info:<br/>            Public Key Algorithm: rsaEncryption<br/>                Public-Key: (4096 bit)<br/>                Modulus:<br/>                    00:c4:02:ab:d6:21:ac:38:58:98:cc:dc:65:b6:9b:<br/>                    df:96:8f:4a:f9:9a:e2:ce:3a:65:78:07:6a:8b:d0:<br/>                    ...</span></pre><h1 id="84f4" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">gRPC服务</h1><p id="68a3" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">现在，让我们来看看我们如何应用并利用Go和gRPC以及一个非常简单的gRPC服务来检索用户名。我们将查询“ID=1 ”,这将返回用户<code class="fe ml mm mn mo b">Nicolas</code>。protobuf定义如下。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="2678" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编译后的代码已经在<a class="ae ko" href="https://github.com/nleiva/grpc-tls" rel="noopener ugc nofollow" target="_blank">库</a>中生成。可以用<code class="fe ml mm mn mo b">make proto</code>重新编译。</p><h1 id="d1db" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">不安全的连接</h1><p id="65e6" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">让我们检查几个不推荐的实践。</p><h2 id="8fc0" class="mw lj it bd lk nr ns dn lo nt nu dp ls kb nv nw lw kf nx ny ma kj nz oa me ob bi translated">不加密的连接</h2><p id="d3f4" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">如果你不想加密连接，Go <code class="fe ml mm mn mo b">grpc</code>包为客户端提供了<code class="fe ml mm mn mo b">DialOption</code> <code class="fe ml mm mn mo b">WithInsecure()</code>。这一点，加上没有任何<code class="fe ml mm mn mo b">ServerOption</code>的服务器将导致一个未加密的连接。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ae34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了重现这种情况，在一个选项卡中运行<code class="fe ml mm mn mo b">make run-server-insecure</code>，在另一个选项卡中运行<code class="fe ml mm mn mo b">run-client-insecure</code>。</p><pre class="kx ky kz la gt ms mo mt mu aw mv bi"><span id="7d2a" class="mw lj it mo b gy mx my l mz na">$ make run-server-insecure<br/>2019/07/05 18:08:03 Creating listener on port: 50051<br/>2019/07/05 18:08:03 Starting gRPC services<br/>2019/07/05 18:08:03 Listening for incoming connections</span></pre><p id="766e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在另一个选项卡中</p><pre class="kx ky kz la gt ms mo mt mu aw mv bi"><span id="9a2a" class="mw lj it mo b gy mx my l mz na">$ make run-client-insecure<br/>User found:  Nicolas</span></pre><h2 id="1908" class="mw lj it bd lk nr ns dn lo nt nu dp ls kb nv nw lw kf nx ny ma kj nz oa me ob bi translated">客户端不对服务器进行身份验证</h2><p id="dfc1" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">在这种情况下，我们使用服务器的公钥加密连接，但是客户端不会验证服务器证书的完整性，因此您无法确保您实际上是在与服务器对话，而不是与中间人对话(<code class="fe ml mm mn mo b">man-in-the-middle</code>攻击)。</p><p id="888a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，我们在之前创建的服务器端提供了公钥和私钥对。客户端需要将<code class="fe ml mm mn mo b">tls</code>包中的配置标志<code class="fe ml mm mn mo b">InsecureSkipVerify</code>设置为<code class="fe ml mm mn mo b">true</code>。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1551" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了重现这一点，在一个选项卡中运行<code class="fe ml mm mn mo b">make run-server</code>,在另一个选项卡中运行<code class="fe ml mm mn mo b">run-client</code>。</p><h1 id="fba7" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">安全连接</h1><p id="47bc" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">让我们看看如何加密通信渠道，并验证我们正在与我们认为的人交谈。</p><h2 id="d6cd" class="mw lj it bd lk nr ns dn lo nt nu dp ls kb nv nw lw kf nx ny ma kj nz oa me ob bi translated">自动下载服务器证书并验证它</h2><p id="77b1" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">为了验证服务器的身份(认证它)，客户端使用认证机构(CA)证书<strong class="js iu">来认证服务器证书上的CA签名。</strong>您可以向您的客户端提供CA证书，或者依靠您的操作系统中包含的一组可信CA证书(可信密钥库)。</p><p id="ff10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">没有CA证书文件</strong></p><p id="4691" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在前面的例子中，除了将<code class="fe ml mm mn mo b">InsecureSkipVerify</code>标志设置为<code class="fe ml mm mn mo b">true</code>之外，我们并没有在客户端做任何特殊的事情来加密连接。在这种情况下，我们将把标志切换到<code class="fe ml mm mn mo b">false</code>，看看会发生什么。不会建立连接，客户端会记录<code class="fe ml mm mn mo b">x509: certificate signed by unknown authority</code>。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c6e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了重现这一点，在一个选项卡中运行<code class="fe ml mm mn mo b">make run-server</code>，在另一个选项卡中运行<code class="fe ml mm mn mo b">run-client-noca</code>。</p><p id="00fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">带有证书颁发机构的证书文件</strong></p><p id="2431" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们手动提供CA cert文件(<code class="fe ml mm mn mo b">ca.cert</code>)并将<code class="fe ml mm mn mo b">InsecureSkipVerify</code>选项保留为<code class="fe ml mm mn mo b">false</code>。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1c9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了重现这种情况，在一个选项卡中运行<code class="fe ml mm mn mo b">make run-server</code>，在另一个选项卡中运行<code class="fe ml mm mn mo b">run-client-ca</code>。</p><p id="70b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">系统(操作系统/浏览器)中包含CA证书</strong></p><p id="db43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个空的<code class="fe ml mm mn mo b">tls</code>配置(<code class="fe ml mm mn mo b">tls.Config{}</code>)将负责加载您的系统证书。我们将在本系列文章的第2部分中验证这个场景(使用来自<a class="ae ko" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank">的证书，让我们为公共域加密</a>)。</p><p id="dce9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您也可以使用<code class="fe ml mm mn mo b">SystemCertPool()</code>从系统中手动加载CA证书。</p><pre class="kx ky kz la gt ms mo mt mu aw mv bi"><span id="db10" class="mw lj it mo b gy mx my l mz na">certPool, err := x509.SystemCertPool()</span></pre><p id="b6ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">如果您有服务器证书并且信任它</strong></p><p id="194a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是互联网教程中最常见的场景。如果您拥有服务器和客户端，您可以与客户端预先共享服务器的证书(<code class="fe ml mm mn mo b">service.pem</code>)，并直接使用它来加密通道。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="71bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了重现这一点，在一个选项卡中运行<code class="fe ml mm mn mo b">make run-server</code>,在另一个选项卡中运行<code class="fe ml mm mn mo b">run-client-file</code>。</p><h1 id="f282" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="fa3d" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">为gRPC设置TLS有不同的方法。提供完整性和隐私并不需要太多的努力，所以强烈建议您远离像<code class="fe ml mm mn mo b">WithInsecure()</code>或者将<code class="fe ml mm mn mo b">InsecureSkipVerify</code>标志设置为<code class="fe ml mm mn mo b">true</code>这样的方法。</p><p id="ebf8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">敬请期待<a class="ae ko" href="https://medium.com/@nleiva/practical-guide-to-securing-grpc-connections-with-go-and-tls-part-2-994ef93b8ea9?sk=de526794eb30887988c9c78cf077fdf6" rel="noopener">第二部</a>和第三部！。</p><p id="455f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">延伸阅读:</p><ul class=""><li id="8eeb" class="nb nc it js b jt ju jx jy kb nd kf ne kj nf kn ng nh ni nj bi translated"><a class="ae ko" href="https://www.linuxjournal.com/content/understanding-public-key-infrastructure-and-x509-certificates" rel="noopener ugc nofollow" target="_blank">了解公钥基础设施和X.509证书</a>作者<a class="ae ko" href="https://www.linkedin.com/in/jeff-woods-a50b921" rel="noopener ugc nofollow" target="_blank">杰夫·伍兹</a></li><li id="8c06" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated"><a class="ae ko" href="https://jbrandhorst.com/post/grpc-auth/" rel="noopener ugc nofollow" target="_blank">由<a class="ae ko" href="https://twitter.com/JohanBrandhorst" rel="noopener ugc nofollow" target="_blank"> Johan Brandhorst </a>进行gRPC客户端认证</a></li><li id="4a39" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated"><a class="ae ko" href="https://bbengfort.github.io/programmer/2017/03/03/secure-grpc.html" rel="noopener ugc nofollow" target="_blank">通过TLS/SSL保护gRPC</a>作者<a class="ae ko" href="https://twitter.com/bbengfort" rel="noopener ugc nofollow" target="_blank"> Benjamin Bengfort </a></li><li id="8807" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated"><a class="ae ko" href="https://www.youtube.com/watch?v=kxKLYDLzuHA" rel="noopener ugc nofollow" target="_blank">安全连接的Go程序员指南</a>作者<a class="ae ko" href="https://twitter.com/lizrice" rel="noopener ugc nofollow" target="_blank">利兹·赖斯</a></li><li id="bbeb" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated"><a class="ae ko" href="https://medium.com/@nleiva/practical-guide-to-securing-grpc-connections-with-go-and-tls-part-2-994ef93b8ea9?sk=de526794eb30887988c9c78cf077fdf6" rel="noopener">保护gRPC与Go和TLS连接的实用指南—第2部分</a></li><li id="f1c4" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated">第三部分</li></ul></div></div>    
</body>
</html>