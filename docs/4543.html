<html>
<head>
<title>Security Zones in OpenShift worker nodes — Part III — Network Configuration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenShift工作节点中的安全区域—第三部分—网络配置</h1>
<blockquote>原文：<a href="https://itnext.io/security-zones-in-openshift-worker-nodes-part-iii-network-configuration-3a887854a4d?source=collection_archive---------0-----------------------#2020-07-21">https://itnext.io/security-zones-in-openshift-worker-nodes-part-iii-network-configuration-3a887854a4d?source=collection_archive---------0-----------------------#2020-07-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/aecb097b08d2df50db860e7b66c747f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4nEgRVYBjzIGtm9E7IJQLQ.jpeg"/></div></div></figure><p id="998e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本帖中，我们将重点关注在安全区域中分离入口和出口流量所需的网络配置。我们还将配置一个额外的网络，用于从pod直接访问(Multus中的二级接口)。</p><p id="50a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在开始配置该部件之前，您应该完成前面的步骤:</p><div class="kw kx gp gr ky kz"><a href="https://medium.com/@luis.ariz/security-zones-in-openshift-worker-nodes-part-ii-grouping-workers-8e97f1d601ba" rel="noopener follow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">OpenShift工人节点中的安全区域—第二部分—工人分组</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">这是本系列的第二部分，我们将配置两组不同的工作人员。</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">medium.com</p></div></div><div class="li l"><div class="lj l lk ll lm li ln jw kz"/></div></div></a></div><h1 id="f263" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">概观</h1><p id="b03d" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">我们配置的下一步是分割网络流量。请记住，我们是从这个设置开始的:</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/066db8e1de958361d4cc96341153c8ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*64xD9pBflPqdqJaowRNU6g.png"/></div></div></figure><p id="fbe4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一点上，我们希望通过添加一个连接到专用接入网络的新入口控制器，为想要访问我们新安全区域上的应用的用户创建一个新的入口点。</p><p id="23e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要包括一个防火墙，将连接到安全的网络。这也将</p><p id="1645" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一步中，我们还将为我们的pod配置额外的网络(OpenShift SDN的外部),在我们的情况下，这些网络将是孤立的网络(您需要连接到该网络才能访问其上的资源，这些网络上不会有任何网关)。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/31c2a4911c8ed242012e0dd852dde8b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WQlR8BXVZJd4BTKhiys4dA.png"/></div></div></figure><blockquote class="mx my mz"><p id="34c6" class="jy jz na ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated">注意:如果您正在使用Machine API创建新节点，此时不可能在MachineSet定义中包含多个接口，因此您需要将这些接口附加到虚拟机，作为一个额外的步骤</p></blockquote><p id="1ec7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，本节将涵盖:</p><ul class=""><li id="6704" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">分离出口流量</li><li id="8d74" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">分割入口流量</li><li id="aa63" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">外部VLAN访问配置(Multus)</li><li id="3fb5" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">SDN内部的防火墙规则(网络策略规则)</li></ul><p id="914b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">分流出口流量</strong></p><p id="7dbd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很容易配置，只要你在两者之间放置一个新的路由器。这是因为默认情况下，pod使用节点的IP来访问外部资源，而且由于我们使用的是位于已知网络中的专用节点，这些节点连接到这个新路由器，因此我们可以根据需要管理该流量。</p><p id="33d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在示例中包括了防火墙，这样我们可以阻止来自特定区域的连接。还有其他选择，例如，您可以在OpenShift 中<a class="ae ns" href="https://docs.openshift.com/container-platform/4.5/networking/openshift_sdn/configuring-egress-firewall.html" rel="noopener ugc nofollow" target="_blank">配置出口防火墙，以限制一些或所有pod可以从集群内部访问的外部主机，即使没有外部防火墙。</a></p><p id="e4b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有另一种可能有用的配置。<a class="ae ns" href="https://docs.openshift.com/container-platform/4.5/networking/openshift_sdn/assigning-egress-ips.html" rel="noopener ugc nofollow" target="_blank">您可以配置一个IP池，并将该池附加到一个命名空间，以便在该命名空间中使用其中一个IP而不是节点的IP。</a>为什么这会有用？考虑一个必须区分通过源IP访问其服务的用户的外部系统，或者使用IP-用户相关性进行跟踪的系统。在这些情况下，如果您使用节点的IP，您无法知道流量是来自一个名称空间还是来自任何其他名称空间，因为源IP是运行在同一主机上的所有pod的某个IP，独立于它们所属的名称空间。</p><p id="8047" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的例子中，我们不会配置它，但是如果它对您的特定用例有意义，您应该研究这个选项。</p><p id="578c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">分裂外部的VLAN (Multus) </strong></p><p id="e329" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这也很容易，您只需决定哪些VLAN连接到每个区域中的节点，例如，您可以在您的交换机中只允许新区域worker中的VLAN X，因此即使OpenShift中的任何人在安全区域worker之外配置它，它也不会工作。</p><p id="eff1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">分流入口流量</strong></p><p id="cc8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">入口情况不同，因为我们需要在集群中有一个新的“入口点”。该入口点是入口控制器。我们可以创建一个新的路由器，并使用入口控制器路由分片功能将“基本域URI”附加到这个新的控制器。</p><p id="62b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是首先，什么是入口控制器？Kubernetes有一个对象管理对集群中服务的外部访问:<em class="na"> Ingress </em>对象。为了让入口资源工作，集群必须运行一个<em class="na">入口控制器</em>，它实际上实现了入口资源，接受流量并查看<em class="na">服务的POD端点。</em></p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/49c0ae6441667abb600a211d816dd0f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TEZV-DPkHv15rQFn56m9Iw.png"/></div></div></figure><p id="aa4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此<em class="na">入口控制器</em>是管理进入集群的入口流量的实现，正如您可以想象的，在vanilla Kubernetes中有多个选项，有时每个选项都有自己的功能</p><p id="2114" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在OpenShift中，入口控制器基于ha proxy(OCP 4.4版的v2)，但是您可以使用两种不同的对象来创建它:</p><ul class=""><li id="77f4" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">Kubernetes <em class="na">入口</em>物体</li><li id="daf9" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">OpenShift <em class="na">路线</em>对象</li></ul><p id="619a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个是标准的Kubernetes对象，而第二个是在OpenShift中完成的API的扩展，能够提供更大的功能列表:</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/2ff412a82ca10160dfc5d41703526638.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*zY32ItvsZ2Y7CWgDfmVXFA.png"/></div></figure><p id="7ca3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认情况下，你将使用<em class="na"> Route </em>对象(因为它们有更多的功能)，但是如果你想坚持标准的Kubernetes特性，你也可以这样做。在我们的例子中，我们将使用<em class="na">路由(路由器入口控制器)。</em></p><p id="a3ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="na">IngressController</em>定义附加了一个在OpenShift部署期间配置的域，但是您可以创建不同的域，甚至可以将这些域附加到其他Ingres controller。</p><p id="6713" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们想要使用通配符<em class="na">* . securezoneapps .&lt;ocpclustername&gt;来访问新安全区域的应用程序。&lt;域&gt;和</em>让<em class="na">* . apps .&lt;OCP clustername&gt;。&lt;域&gt; </em>访问“常规区”应用程序。后一种路由已经在我们的OpenShift集群中进行了配置，我们只需要创建新的路由器并将新的域分配给这些路由器，同时将新的路由器绑定到所需的安全访问+工作节点……这正是我们在配置中要做的事情。</p><p id="d623" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于我们的设计理念，还有一点必须讨论，接入网附加到IngressController，以及它是如何“发布”的。</p><p id="1b81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们了解IngressController是如何在集群外部“发布”的。IngressControllers是PODs，因此它们必须使用Kubernetes构件来使它们在SDN外部可用。Kubernetes有多种类型，可以将外部流量定向到PODs，如将接口配置为<em class="na">主机网络</em> ( <code class="fe nv nw nx ny b">hostNetwork: true</code>)或使用类型为NodePort的<a class="ae ns" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank"> <em class="na">服务</em>、类型为LoadBalancer的<em class="na">服务</em>等，</a>默认情况下，OpenShift中的Ingres controller(<em class="na">endpoint publishingstrategy</em>键)，根据已部署的平台选择主机网络、服务节点端口或服务负载平衡器:</p><ul class=""><li id="cdb9" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">AWS: <code class="fe nv nw nx ny b"><strong class="ka ir">LoadBalancerService</strong></code>(带外部范围)</li><li id="00c4" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">天蓝色:<code class="fe nv nw nx ny b"><strong class="ka ir">LoadBalancerService</strong></code>(带外景)</li><li id="7c12" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">GCP: <code class="fe nv nw nx ny b"><strong class="ka ir">LoadBalancerService</strong></code>(带外视镜)</li><li id="a24c" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">其他:<code class="fe nv nw nx ny b"><strong class="ka ir">HostNetwork</strong></code></li></ul><p id="7617" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的实验室是使用裸机UPI在虚拟机上部署的，让我们检查一下我的路由器使用的是什么，首先让我们看看它是否使用了<em class="na">主机网络:</em></p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="ff04" class="od lp iq ny b gy oe of l og oh">$ oc get pod -n openshift-ingress router-default-7869647cbd-48w5c -o yaml | grep -i hostnetwork<br/>    openshift.io/scc: hostnetwork<br/>        f:hostNetwork: {}<br/>  hostNetwork: true</span></pre><p id="c303" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的例子中，我的路由器是使用HostNetwork发布的。</p><p id="67e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用主机网络有一些缺点，例如，它限制了Pod可以被调度的位置的数量，因为我不能在同一个节点中放置两个监听同一个TCP端口的不同的Pod。这很重要，因为我们的路由器将在端口TCP 80和443中侦听，所以我们每个节点只能有一个路由器，并且我们在配置副本数量时需要考虑到这一点(我们希望专用两个节点来运行我们的路由器，所以我不能配置2个以上的副本)。</p><p id="00b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，我们已经了解了如何从外部访问IngressControllers，但是如何在安全区域和常规区域中进行单独的访问呢？</p><p id="5a7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯，如果使用<em class="na">负载均衡器</em>类型，有了新的LB，你将有一个不同的接入点。问题是，我能使用<em class="na">负载均衡器</em>型吗？嗯，我的部署是模拟裸机UPI安装，这意味着我不能使用服务<em class="na">负载平衡器</em>类型，我将需要使用<em class="na">主机网络或节点端口服务。</em></p><blockquote class="mx my mz"><p id="b54b" class="jy jz na ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated">注意:将来OpenShift可能会支持<a class="ae ns" href="https://metallb.universe.tf/" rel="noopener ugc nofollow" target="_blank"> MetalLB </a>在裸机部署中提供负载平衡器服务类型。</p></blockquote><p id="a7da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我使用<em class="na">主机网络或节点端口服务</em>的情况下，我只需在我的节点中配置额外的网络(默认情况下，IngressController将监听所有节点接口)。</p><p id="d0ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于新的接入网络配置，最好理解我的节点中的当前配置是什么，以便更好地理解将在下面解释的一些概念。让我们回顾一下secure access+worker节点中的接口，这样我们就知道这个外部访问网络将使用的接口名称。我们需要进入节点来回顾一下。</p><p id="0ed5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在OpenShift 4.5中，我们有三个选项(两个来自CLI，一个来自Web控制台)来运行访问节点的命令行(不要在服务器内部更改配置，请记住，您必须对RHCOS节点使用MachineConfig！):</p><ul class=""><li id="e779" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">CLI方法1:使用您在安装过程中注入的ssh密钥和预先配置的“核心”用户跳转到带有SSH的节点。您可以使用命令<em class="na"> oc get node -o wide </em>知道节点的IP</li></ul><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="7af9" class="od lp iq ny b gy oe of l og oh">$ oc get node  -o wide | awk {'print $1" " $6'} | column -t<br/>NAME                               INTERNAL-IP<br/>master0.ocp.136.243.40.222.nip.io  192.168.120.11<br/>master1.ocp.136.243.40.222.nip.io  192.168.120.12<br/>master2.ocp.136.243.40.222.nip.io  192.168.120.13<br/>worker0.ocp.136.243.40.222.nip.io  192.168.120.15<br/>worker1.ocp.136.243.40.222.nip.io  192.168.120.16<br/>worker2.ocp.136.243.40.222.nip.io  192.168.126.17<br/>worker3.ocp.136.243.40.222.nip.io  192.168.126.18<br/>worker4.ocp.136.243.40.222.nip.io  192.168.126.19</span><span id="975f" class="od lp iq ny b gy oi of l og oh">$ ssh -i sshkey core@192.168.126.17<br/>Red Hat Enterprise Linux CoreOS 45.82.202007062333-0<br/>  Part of OpenShift 4.5, RHCOS is a Kubernetes native operating system<br/>  managed by the Machine Config Operator (`clusteroperator/machine-config`).</span><span id="db94" class="od lp iq ny b gy oi of l og oh">WARNING: Direct SSH access to machines is not recommended; instead,<br/>make configuration changes via `machineconfig` objects:<br/>  <a class="ae ns" href="https://docs.openshift.com/container-platform/4.5/architecture/architecture-rhcos.html" rel="noopener ugc nofollow" target="_blank">https://docs.openshift.com/container-platform/4.5/architecture/architecture-rhcos.html</a></span><span id="e993" class="od lp iq ny b gy oi of l og oh">---<br/>[core@worker2 ~]$</span></pre><ul class=""><li id="264e" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">CLI方法2:使用<em class="na">oc debug node/&lt;name&gt;</em>在节点中创建特权pod(记住运行<em class="na"> chroot /host </em>以允许运行所有命令并访问节点中的所有文件)</li></ul><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="5f29" class="od lp iq ny b gy oe of l og oh">$ oc debug node/worker2.ocp.136.243.40.222.nip.io<br/>Starting pod/worker2ocp13624340222nipio-debug ...<br/>To use host binaries, run `chroot /host`<br/>Pod IP: 192.168.126.17<br/>If you don't see a command prompt, try pressing enter.</span><span id="d434" class="od lp iq ny b gy oi of l og oh">sh-4.2# chroot /host</span><span id="c75b" class="od lp iq ny b gy oi of l og oh">sh-4.4# hostname<br/>worker2.ocp.136.243.40.222.nip.io</span></pre><ul class=""><li id="99ac" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">Web控制台方法(OCP 4.5中的新功能):这与<em class="na"> oc调试</em>相同，但是是图形化的</li></ul><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/c16e2ab2562fb7a472f20b9699577b23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*WYkzP9HyKZdv_Tk509HmWg.gif"/></div></div></figure><p id="4b0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的例子中，当我运行"<em class="na"> ip a </em>"来检查接口时，我得到如下输出:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="ef5c" class="od lp iq ny b gy oe of l og oh">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br/>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br/>    inet 127.0.0.1/8 scope host lo<br/>       valid_lft forever preferred_lft forever<br/>    inet6 ::1/128 scope host <br/>       valid_lft forever preferred_lft forever<br/>2: ens3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000<br/>    link/ether 52:54:60:00:01:0c brd ff:ff:ff:ff:ff:ff<br/>    inet 192.168.126.17/24 brd 192.168.126.255 scope global dynamic noprefixroute ens3<br/>       valid_lft 14110sec preferred_lft 14110sec<br/>    inet6 fe80::c3bd:f88:4446:df63/64 scope link noprefixroute <br/>       valid_lft forever preferred_lft forever<br/>3: ens4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000<br/>    link/ether 52:54:60:20:01:0c brd ff:ff:ff:ff:ff:ff<br/>    inet 192.168.250.191/24 brd 192.168.250.255 scope global dynamic noprefixroute ens4<br/>       valid_lft 3313sec preferred_lft 3313sec<br/>    inet6 fe80::5ea4:1b25:f01d:9e9c/64 scope link noprefixroute <br/>       valid_lft forever preferred_lft forever<br/>4: ens10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000<br/>    link/ether 52:54:00:e2:2c:79 brd ff:ff:ff:ff:ff:ff<br/>    inet 192.168.210.227/24 brd 192.168.210.255 scope global dynamic noprefixroute ens10<br/>       valid_lft 3312sec preferred_lft 3312sec<br/>    inet6 fe80::79a4:e366:be9d:41e7/64 scope link noprefixroute <br/>       valid_lft forever preferred_lft forever<br/>9: ovs-system: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000<br/>    link/ether b6:3c:74:9b:a9:44 brd ff:ff:ff:ff:ff:ff<br/>10: br0: &lt;BROADCAST,MULTICAST&gt; mtu 1450 qdisc noop state DOWN group default qlen 1000<br/>    link/ether ea:6c:07:83:7d:46 brd ff:ff:ff:ff:ff:ff<br/>11: vxlan_sys_4789: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 65000 qdisc noqueue master ovs-system state UNKNOWN group default qlen 1000<br/>    link/ether fe:db:05:6d:2b:31 brd ff:ff:ff:ff:ff:ff<br/>    inet6 fe80::fcdb:5ff:fe6d:2b31/64 scope link <br/>       valid_lft forever preferred_lft forever<br/>12: tun0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UNKNOWN group default qlen 1000<br/>    link/ether 42:e9:24:8f:31:93 brd ff:ff:ff:ff:ff:ff<br/>    inet 10.129.2.1/23 brd 10.129.3.255 scope global tun0<br/>       valid_lft forever preferred_lft forever<br/>    inet6 fe80::40e9:24ff:fe8f:3193/64 scope link <br/>       valid_lft forever preferred_lft forever<br/>13: veth5da406c1@if3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master ovs-system state UP group default <br/>    link/ether d6:f4:29:19:4d:c8 brd ff:ff:ff:ff:ff:ff link-netns a67d8aab-da1d-40c7-97a4-948e785ae899<br/>    inet6 fe80::d4f4:29ff:fe19:4dc8/64 scope link <br/>       valid_lft forever preferred_lft forever</span></pre><p id="0734" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以在这个虚拟机上找到一个网桥(br0)接口、veth接口、一个用于SDN的隧道接口(tun0)和三个“物理”网卡:<em class="na"> ens3 </em>、<em class="na"> ens4 </em>和<em class="na"> ens10 </em>。第一个是用于SDN的网卡，<em class="na"> ens4 </em>是我们想要用来将VLANs直接连接到PODs (Multus)的网卡，而<em class="na"> ens10 </em>是连接到外部接入网络的接口(只存在于安全接入+工作节点中)。</p><p id="ee2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，您在命令行输出中看到了更多东西吗？是的，这些网卡已经有了一个IP，这是因为我已经在这些网络上启用了DHCP，所以我们可以说“我们已经完成了接口配置”，但是如果您没有基于MAC地址配置IP分配(因此IP可能会更改)，最好至少为绑定到IngressControllers的IP配置静态IP，因为您应该放置一个指向所有这些节点的负载平衡器，所以您必须事先知道IP，以便在负载平衡器池上配置它们…所以我们来看一下如何配置RHCOS接口，更具体地说，配置静态IP。</p><p id="f0ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有一件事。我们希望只配置静态IP，而不是额外的网关，因为我的示例设置将负载平衡器直接连接到接入网络，作为OpenShift secure access+worker节点，因此不需要外部路由器来连接节点和负载平衡器。这是一种常见的设置，但是如果您需要在带有IngressController和负载平衡器的节点之间建立L3连接，您还需要在节点中配置静态路由，请记住这一点。</p><p id="eb06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在OpenShift 4.5中，如果您的节点中有Red Hat CoreOS，则有多种方法来处理网络配置(如果是RHEL，则必须在节点上手动配置或通过外部自动化进行配置):</p><ul class=""><li id="2338" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">机器操作员:还记得我们讨论过如果您使用Red Hat CoreOs，如何在节点上配置操作系统吗？，嗯，接口配置是一种OS配置，所以你可以用这种方法在节点中配置一个新接口的参数。在MachineConfig中，您可以在节点上的特定位置包含文件，这样您就可以将网络配置文件放在正确的路径中，这样就完成了，唯一的缺点是您需要使用URL格式对文件进行编码(想象一下，您想要放置“Hello World”，您将必须写下“Hello%20World”)，但是您可以使用python来帮助完成这一工作。的确，这种配置的例子并不多，但是你可以查看下面的例子，看看如何配置python命令(alias命令都在一行中，尽管这里显示的是多行)，以及如何在MachineConfig中使用输出…但是…这种方法有一个问题，即<em class="na">machine config</em>被设计为应用于一个服务器池，因此在所有节点上有一个通用的配置。如果您正在配置DHCP，这是可以的，但是如果您想要配置静态IP…那么，这些IP必须是唯一的。您可以为每个节点创建一个<em class="na"> MachineConfigPool </em>(即使用标签【kubernetes.io/hostname<em class="na">】而不是每个角色(或者至少是每个具有静态IP的节点)。</em></li></ul><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="6650" class="od lp iq ny b gy oe of l og oh">$ alias urlencode='python3 -c "import sys, urllib.parse; print(urllib.parse.quote(sys.argv[1]))"'</span><span id="e865" class="od lp iq ny b gy oi of l og oh">$ urlencode 'DEVICE="ens10"<br/>&gt; BOOTPROTO="static"<br/>&gt; NM_CONTROLLED="yes"<br/>&gt; ONBOOT="yes"<br/>&gt; TYPE="Ethernet"<br/>&gt; IPADDR=192.168.210.102<br/>&gt; NETMASK=255.255.255.0<br/>DEVICE%3D%22ens10%22%0ABOOTPROTO%3D%22static%22%0ANM_CONTROLLED%3D%22yes%22%0AONBOOT%3D%22yes%22%0ATYPE%3D%22Ethernet%22%0AIPADDR%3D192.168.210.102%0ANETMASK%3D255.255.255.0</span><span id="adf7" class="od lp iq ny b gy oi of l og oh">apiVersion: machineconfiguration.openshift.io/v1<br/>kind: MachineConfig<br/>metadata:<br/>  labels:<br/>    machineconfiguration.openshift.io/hostname: worker2.ocp.136.243.40.222.nip.io<br/>  name: 50-example-nicconfig<br/>spec:<br/>  config:<br/>    ignition:<br/>      version: 2.2.0<br/>    storage: <br/>      files: <br/>      - contents: <br/>         source: data:,DEVICE%3D%22ens10%22%0ABOOTPROTO%3D%22static%22%0ANM_CONTROLLED%3D%22yes%22%0AONBOOT%3D%22yes%22%0ATYPE%3D%22Ethernet%22%0AIPADDR%3D192.168.210.102%0ANETMASK%3D255.255.255.0<br/>       filesystem: root<br/>       mode: 420<br/>       path: /etc/sysconfig/network-scripts/ifcfg-ens10</span></pre><ul class=""><li id="fcce" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">集群网络操作员:此方法旨在用于Multus接口配置，而不是用于节点网络配置。您可以查看<a class="ae ns" href="https://docs.openshift.com/container-platform/4.5/networking/multiple_networks/understanding-multiple-networks.html" rel="noopener ugc nofollow" target="_blank"> Openshift文档中的一些示例，了解Multus的一些配置示例。</a></li><li id="c12b" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">NMSTATE操作符:这是我的首选方式。Kubernetes-nmstate操作符提供了一个通过Kubernetes API驱动的声明性节点网络配置。这意味着您可以在Kubernetes对象中指定节点的接口配置(种类:<em class="na">节点网络配置策略</em>)。这样做的唯一缺点是，默认情况下，OpenShift中不包含它，但我们有一个好消息，当您在集群上安装<a class="ae ns" href="https://www.openshift.com/blog/blog-openshift-virtualization-whats-new-with-virtualization-from-red-hat" rel="noopener ugc nofollow" target="_blank"> OpenShift容器虚拟化</a>时，它会安装这个<em class="na"> nmstate </em>操作符，因此这里的技巧是<a class="ae ns" href="https://docs.openshift.com/container-platform/4.4/cnv/cnv_install/installing-container-native-virtualization.html" rel="noopener ugc nofollow" target="_blank">安装OpenShift容器虚拟化操作符</a>，以便更容易配置节点的网络。我对此不太确定，但可能在未来，<em class="na">nm state</em>T13的<a class="ae ns" href="https://github.com/kubevirt/cluster-network-addons-operator#nmstate" rel="noopener ugc nofollow" target="_blank">网络附加选项将在</a><a class="ae ns" href="https://github.com/openshift/cluster-network-operator" rel="noopener ugc nofollow" target="_blank">OpenShift ClusterNetworkOperator</a>中提供，安装起来会更容易(甚至会默认提供)。看看下面的例子。注意nodeSelector，我们不能使用包含多个节点的“通用”选择器(即安全区域角色)，如果您想要配置唯一的静态IP)。</li></ul><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="ac20" class="od lp iq ny b gy oe of l og oh">apiVersion: nmstate.io/v1alpha1<br/>kind: NodeNetworkConfigurationPolicy<br/>metadata:<br/>  name: worker2-extaccess-static<br/>spec:<br/>  nodeSelector:<br/>    kubernetes.io/hostname: worker2.ocp.136.243.40.222.nip.io<br/>  desiredState:<br/>    interfaces:<br/>    - name: ens10<br/>      type: ethernet<br/>      state: up<br/>      ipv4:<br/>        address:<br/>        - ip: 192.168.210.62<br/>          prefix-length: 24<br/>        dhcp: false<br/>        enabled: true</span></pre><p id="a3fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以想象，我想使用<em class="na"> nmstate </em>方法，但是这里我们发现了两个问题。</p><p id="9a35" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个问题很容易解决，默认情况下我们的集群上没有<em class="na"> nmstate </em>，但是我们可以安装OpenShift虚拟化(CNV操作符),这将部署它，正如您已经知道的那样。</p><p id="93cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个问题稍微复杂一点。在我们的用例中，我们必须创建一个不同的工作人员组，除非我们指定(使用污点和容忍)，否则我们不想在其中运行工作负载。嗯，当你安装一个操作符并创建操作符CRD时，它一定已经实现了容错的用法，这意味着你可以在操作符内置的容错之上添加你的容错。在OpenShift虚拟化操作符中，该实现还没有准备好，所以当您部署它时，一些功能将只在非自定义感染的节点上工作，所以我们不能在我们的安全区域中使用<em class="na"> nmstate </em>操作符功能。</p><p id="339d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好的，那么我们可以选择第二个选项:MachineConfigs，但是请记住我们在MachineConfigs中遇到的独特配置的问题。</p><p id="4411" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以现在，在解释了我们拥有的多个选项以及为什么我们不能将它们用于这个用例之后，我们可以说我们将要做一些激烈的事情，以另一种受支持的方式配置接口，通过重新安装节点和使用内核参数设置静态ips 的<a class="ae ns" href="https://docs.openshift.com/container-platform/4.5/installing/installing_bare_metal/installing-bare-metal.html#installation-user-infra-machines-static-network_installing-bare-metal" rel="noopener ugc nofollow" target="_blank">，但是由于我不想重新开始，我将做一些我们“不应该”做的事情:我们将在RHCOS上手动配置接口。还记得我之前说过的不要手动配置任何东西吗？我们应该使用机器操作员还是其他方式？在这种情况下，我不想每个节点都有一个MachineConfigPool，也不想重新安装节点，所以我将使用手动配置(<strong class="ka ir">我不知道这种方法的可支持性</strong>)。希望在不久的将来，我们会让<em class="na"> nmstate </em>操作符在OpenShift中处理污点。</a></p><p id="027f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将在下一节中进行实际配置(OpenShift配置)。</p><p id="e629" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们了解了Ingres controller是如何发布的，以及我们如何配置将用于访问它的网络，我们现在就可以专注于如何在默认的和新的Ingres controller之间划分使用。</p><p id="8138" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以通过两种方式选择将由IngressController发布的路由:</p><ul class=""><li id="8108" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated"><a class="ae ns" href="https://docs.openshift.com/container-platform/4.5/networking/ingress-operator.html#nw-ingress-sharding-route-labels_configuring-ingress" rel="noopener ugc nofollow" target="_blank">使用<em class="na"> routeSelector </em> </a>:用户可以使用一个标签来选择何时在这个IngressController中发布路由</li><li id="d051" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated"><a class="ae ns" href="https://docs.openshift.com/container-platform/4.5/networking/ingress-operator.html#nw-ingress-sharding-namespace-labels_configuring-ingress" rel="noopener ugc nofollow" target="_blank">使用命名空间选择器</a>:带有此标签的某些命名空间将始终在此IngressController中发布它们的路由</li></ul><p id="a9c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们不包括任何选择器，IngressControllers将发布所有路由，因此我们的想法是为默认和安全区域Ingres controller配置相反的选择器，这样我们就可以确保当我们要发布安全区域应用程序时，默认Ingres controller不会包括它，只有安全区域Ingres controller能够路由该URL。</p><p id="1c77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们应该清楚如何管理对这个<em class="na"> IngressController </em>的访问。如果我们选择路由标签，任何用户都可以使用该标签来使用新的<em class="na"> IngressController，</em>，这是不可取的，所以在我们的例子中，由于clusteradmin将是唯一一个创建项目/名称空间的人(我们将在下一篇文章中介绍这一点)，我们可以在名称空间中分配一个标签，该标签允许在安全区域中创建路由，同时我们阻止其他用户使用安全的IngressController。</p><p id="d91e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们需要配置相反的标签，因此我们也将配置默认的IngressController，但是，为了尽量减少默认对象和已部署对象中的重新配置，我们将采用以下方式:</p><ul class=""><li id="1a31" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">新的IngressController:仅可由“带有标签X”的命名空间使用</li><li id="f975" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">默认IngressController:只能由“没有标签X”的命名空间使用</li></ul><p id="73cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">SDN内部防火墙</strong></p><p id="50c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ns" href="https://kubernetes.io/docs/concepts/services-networking/network-policies/" rel="noopener ugc nofollow" target="_blank"> Kubernetes有一个称为网络策略的特性</a>，如果网络插件支持(默认OpenShift SDN支持)，它允许配置防火墙规则来阻止SDN内部的连接。</p><p id="b42e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您需要考虑到某些网络插件具有扩展功能，例如在Calico(您也可以将Calico与OpenShift一起使用，因为它是一个经过认证的网络插件)中，您有适用于整个集群(GlobalNetworkPolicy)的规则，而不是基于每个名称空间。</p><p id="4d79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的例子中，我将使用默认配置的OpenShift SDN(这里不讨论另一种“多租户”配置)</p><p id="a703" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在开始解释我们如何使用网络策略之前，您需要考虑到Multus或pods与HostNetwork使用的接口不在网络策略规则实施范围内，在这些情况下，您需要使用外部防火墙。</p><p id="447f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">得益于网络策略，用户可以在其命名空间中配置防火墙规则，例如，他们可以配置拒绝当前命名空间中的所有非白名单流量，或者允许所有流量，但仅允许来自另一个特定命名空间的流量，或者配置常规源网络许可。您需要记住的是，用户根据名称空间配置网络策略。</p><p id="4185" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您认为默认情况下所有网络流都被允许进入集群，那么这与我们有关。这里我们可以采取几种方法:</p><ul class=""><li id="de6e" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">我们可以让用户阻止任何不需要的流量</li><li id="8f25" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">作为管理员，我们可以在任何新创建的名称空间中包含默认的拒绝所有网络策略，并让用户打开他们需要的连接</li><li id="a187" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">作为管理员，我们根据所需的网络策略为用户创建名称空间(并且我们防止用户触及内部防火墙规则)</li></ul><p id="73a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您信任您的用户，选项1是好的，因为如果他们没有配置正确的规则(或者即使他们没有配置任何东西)，一些不好的事情可能会发生，因为没有什么会阻止跨区域流量。</p><p id="37d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">选项2类似于选项1，但对用户来说更容易，因为他们需要专门打开正确的流程。</p><p id="2c19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用选项，3个集群管理员可以完全控制用户访问，但是我们将在创建新项目时限制灵活性，因为用户需要要求管理员提前创建和设置他们的项目/名称空间。</p><p id="430c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将选择选项3，这样我可以在下一节解释如何限制用户创建项目的能力以及其他权限限制配置。</p><p id="092c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于RBAC将在下一节中配置，此时我们只需担心为每个新命名空间配置什么默认网络策略。为了在我们的安全区域中保持安全，我会说新的名称空间将不能与任何其他名称空间通信(默认情况下)，但是“正确的”Ingresscontroller将能够到达pod，因此用户可以发布他们的应用程序的路由。</p><h1 id="0be4" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated"><strong class="ak"> OpenShift配置(网络配置)</strong></h1><blockquote class="mx my mz"><p id="8bba" class="jy jz na ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated">注意:我们将使用具有集群管理员权限的OpenShift用户来完成所有这些配置</p></blockquote><p id="fb29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一步，正如我们之前讨论的，我们需要在我的节点中配置接入网络，以便新路由器能够使用它。</p><p id="513d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将在这里讨论<strong class="ka ir">最坏的情况</strong>，所以当你已经有了一个节点，并且你意识到你想用它作为一个访问+工作者。我为什么这么说？嗯，在阅读了下面的解释之后，你会更好地理解，如果你想在安装那个节点之前设置任何静态IP，最好提前知道</p><p id="ee17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">1-在接入+工作节点上配置外部接入网络</strong></p><p id="a270" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用ssh、<em class="na"> oc debug、</em>或Web控制台(方法如上所述)跳转到节点，执行如下操作:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="6145" class="od lp iq ny b gy oe of l og oh">$ oc debug node/worker2.ocp.136.243.40.222.nip.io<br/>Starting pod/worker2ocp13624340222nipio-debug ...<br/>To use host binaries, run `chroot /host`<br/>Pod IP: 192.168.126.17<br/>If you don't see a command prompt, try pressing enter.</span><span id="9824" class="od lp iq ny b gy oi of l og oh">sh-4.2# chroot /host</span><span id="cb7f" class="od lp iq ny b gy oi of l og oh">sh-4.4# nmcli con show</span><span id="a34d" class="od lp iq ny b gy oi of l og oh">NAME                UUID                                  TYPE      DEVICE <br/>Wired connection 2  14c0ead1-d070-35d9-8287-6eba5e33137e  ethernet  ens3   <br/>Wired connection 1  69d836ff-ce43-33d9-a2ab-856d06c5fdba  ethernet  ens10  <br/>Wired connection 3  41c7c035-f058-3cb2-a33e-746035acc7fc  ethernet  ens4</span><span id="7c2a" class="od lp iq ny b gy oi of l og oh">sh-4.4# nmcli con mod "Wired connection 1" ipv4.addresses 192.168.210.102/24</span><span id="0eb2" class="od lp iq ny b gy oi of l og oh">sh-4.4# nmcli con mod "Wired connection 1" ipv4.method manual</span><span id="d822" class="od lp iq ny b gy oi of l og oh">sh-4.4# nmcli con down "Wired connection 1"</span><span id="29bb" class="od lp iq ny b gy oi of l og oh">Connection 'Wired connection 1' successfully deactivated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/6)</span><span id="d1cc" class="od lp iq ny b gy oi of l og oh">sh-4.4# nmcli con up "Wired connection 1"</span><span id="63a6" class="od lp iq ny b gy oi of l og oh">Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/7)</span><span id="742f" class="od lp iq ny b gy oi of l og oh">sh-4.4# ip a show ens10</span><span id="c251" class="od lp iq ny b gy oi of l og oh">4: ens10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000<br/>    link/ether 52:54:00:e2:2c:79 brd ff:ff:ff:ff:ff:ff<br/>    inet 192.168.210.102/24 brd 192.168.210.255 scope global noprefixroute ens10<br/>       valid_lft forever preferred_lft forever<br/>    inet6 fe80::79a4:e366:be9d:41e7/64 scope link noprefixroute <br/>       valid_lft forever preferred_lft forever</span></pre><p id="dc26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在另一个安全访问+工作节点中重复该操作。</p><blockquote class="mx my mz"><p id="97bc" class="jy jz na ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated">注意:同样，为这一非常具体的使用情形配置静态IP的最佳方式是在部署节点时(查看上一节中的说明)，而不是在节点上使用nmcli或任何其他直接配置。</p></blockquote><p id="a463" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">2-创建新的Ingres controller</strong></p><p id="a8a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在接入网络中有了带有静态IP的节点，现在是时候创建将在该网络上侦听的新IngressControllers了。新IngressController配置的要点是:</p><ul class=""><li id="35e3" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">我将使用新安全区域的<em class="na">* . Secure apps .&lt;OCP-cluster-name&gt;&lt;domain&gt;</em>URL。</li><li id="332b" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">我还将使用节点选择器来确保IngressController将由安全访问+工作节点托管。</li><li id="ea46" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">我将用标签“<em class="na"> securityzone= secure </em>”配置一个命名空间选择器</li></ul><p id="b865" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对象应该是这样的:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="9468" class="od lp iq ny b gy oe of l og oh">apiVersion: operator.openshift.io/v1<br/>kind: IngressController<br/>metadata:<br/>  name: secure-ingress<br/>  namespace: openshift-ingress-operator<br/>spec:<br/>  endpointPublishingStrategy:<br/>    type: HostNetwork <br/>  domain: secureapps.ocp.136.243.40.222.nip.io<br/>  replicas: 2<br/>  nodePlacement:<br/>    nodeSelector:<br/>      matchLabels:<br/>        node-role.kubernetes.io/secure-worker: ""<br/>        ingressaccess: "true"<br/>  namespaceSelector:<br/>    matchExpressions:<br/>      - key: securityzone<br/>        operator: In<br/>        values:<br/>        - secure</span></pre><p id="ae39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如前所述，我们还需要配置默认的IngressController，通过配置一个<em class="na"> namespacesSelector </em>，它只允许用户访问任何没有“<em class="na"> securityzone= secure </em>标签的名称空间。</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="2569" class="od lp iq ny b gy oe of l og oh">$  oc edit ingresscontrollers.operator.openshift.io -n openshift-ingress-operator default</span></pre><p id="c024" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您需要添加粗体文本中的内容:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="8604" class="od lp iq ny b gy oe of l og oh">...<br/>spec:<br/><strong class="ny ir">  namespaceSelector:<br/>    matchExpressions:<br/>    - key: securityzone<br/>      operator: DoesNotExist</strong><br/>...</span></pre><p id="3821" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果创建新的IngressController对象，您将立即看到在名称空间“<em class="na"> openshift-ingress </em>”下创建了两个窗格:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="abff" class="od lp iq ny b gy oe of l og oh"># oc get pod -n openshift-ingress<br/>NAME                                          READY   STATUS    RESTARTS   AGE<br/>router-default-7869647cbd-48w5c               1/1     Running   0          30h<br/>router-default-7869647cbd-q6597               1/1     Running   0          31h<br/>router-secure-zone-ingress-5956858749-8v4gr   0/1     Pending   0          48s<br/>router-secure-zone-ingress-5956858749-jcftz   0/1     Pending   0          47s</span></pre><p id="f358" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以等，但是我告诉你，他们不会从<em class="na">待定</em>通过，为什么？因为我们试图将一些工作负载(IngressController)放在我们的超级超级安全区域中，而不给it访问它的权限。请记住，我们通过配置容差来提供访问权限，但在这里，直接在这些单元中配置容差并不是一个好主意，因为它们可能会被销毁或创建，这取决于我们是否扩大或减少副本的数量。我们可以做的是在默认情况下，在<em class="na"> OpenShift-Ingress </em>名称空间中创建的所有工作负载中配置我们的容忍度。</p><p id="b8fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有一个特殊的注释<strong class="ka ir">scheduler.alpha.kubernetes.io/defaultTolerations</strong>，我们可以将它包含在命名空间对象中(不在项目对象中，考虑到这一点),它在所有部署中注入容错配置。在我们的例子中，我们希望配置这种容忍:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="2f48" class="od lp iq ny b gy oe of l og oh">tolerations:<br/>    - key: securityzone<br/>      operator: Equal<br/>      value: secure<br/>      effect: NoSchedule</span></pre><p id="3303" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，注释将是粗体文本(提取自<em class="na"> openshift-ingress </em>名称空间对象定义):</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="6f4a" class="od lp iq ny b gy oe of l og oh">...<br/>  annotations:<br/>    openshift.io/node-selector: ''<br/>    openshift.io/sa.scc.mcs: 's0:c24,c4'<br/>    openshift.io/sa.scc.supplemental-groups: 1000560000/10000<br/>    openshift.io/sa.scc.uid-range: 1000560000/10000<br/><strong class="ny ir">    scheduler.alpha.kubernetes.io/defaultTolerations: '[{"Key": "securityzone", "Operator":"Equal", "Value": "secure", "effect": "NoSchedule"}]'</strong><br/>  managedFields:<br/> ...</span></pre><p id="0ab4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在名称空间定义中包含该行，然后删除处于挂起状态的pod(<em class="na">oc delete pod xxxx</em>)，然后您将看到如何创建两个新的pod，这一次它们将达到“正在运行”状态。您还可以检查它们在哪里运行，它们应该在安全访问+worker节点中(在我的例子中是worker2和worker3):</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="34dc" class="od lp iq ny b gy oe of l og oh">oc get pod -o wide -n openshift-ingress | awk {'print $1" " $2" " $7'} | column -t<br/>NAME                                         READY  NODE<br/>router-default-7869647cbd-48w5c              1/1    worker1.ocp.136.243.40.222.nip.io<br/>router-default-7869647cbd-q6597              1/1    worker0.ocp.136.243.40.222.nip.io<br/>router-secure-zone-ingress-5956858749-5ftt4  1/1    worker2.ocp.136.243.40.222.nip.io<br/>router-secure-zone-ingress-5956858749-crrrp  1/1    worker3.ocp.136.243.40.222.nip.io</span></pre><p id="5ddd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">3-网络策略</strong></p><p id="c3d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认情况下，任何命名空间都允许所有流量，但是一旦您配置了任何网络策略，只有策略中允许的流量不会被丢弃，因此我们需要配置规则以允许我们想要的流量，在我的示例中:</p><ul class=""><li id="3c57" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">项目/命名空间内的所有流量</li><li id="cb7e" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">所有来自OpenShift监控系统的流量</li><li id="53d2" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">来自IngressController的流量</li></ul><p id="008f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前两点很容易。对于第一个规则，我们只需要在名称空间中配置这个规则:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="4eab" class="od lp iq ny b gy oe of l og oh">kind: NetworkPolicy<br/>apiVersion: networking.k8s.io/v1<br/>metadata:<br/>  namespace: &lt;namespace name&gt;<br/>  name: allow-same-namespace<br/>spec:<br/>  podSelector:<br/>  ingress:<br/>  - from:<br/>    - podSelector: {}</span></pre><p id="ab98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下一节(RBAC配置)中，我们将看到如何在名称空间创建中默认注入这个规则。</p><p id="b0ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了允许监控系统:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="683f" class="od lp iq ny b gy oe of l og oh">apiVersion: networking.k8s.io/v1<br/>kind: NetworkPolicy<br/>metadata:<br/>  namespace: &lt;namespace name&gt;<br/>  name: allow-from-openshift-monitoring<br/>spec:<br/>  ingress:<br/>  - from:<br/>    - namespaceSelector:<br/>        matchLabels:<br/>          network.openshift.io/policy-group: monitoring<br/>  podSelector: {}<br/>  policyTypes:<br/>  - Ingress</span></pre><p id="8fca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一个有点棘手。</p><p id="8039" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经限制了从“错误的”Ingres Controller对区域的访问，因为正如我们已经看到的那样，我们配置了命名空间选择器，所以我们在这里应该做的唯一事情是允许来自Ingres controllers的流量进入命名空间(Ingres controllers在openshift-ingress命名空间中运行)…但是，正如您可以在<a class="ae ns" href="https://docs.openshift.com/container-platform/4.1/networking/configuring-networkpolicy.html" rel="noopener ugc nofollow" target="_blank"> OpenShift文档</a>中找到的，如果IngressController配置了<code class="fe nv nw nx ny b"><strong class="ka ir">endpointPublishingStrategy: HostNetwork</strong></code>，那么Ingress Controller Pod在主机网络上运行。</p><p id="087c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当在主机网络上运行时，来自入口控制器的流量被分配了<code class="fe nv nw nx ny b"><strong class="ka ir">netid:0</strong></code>虚拟网络ID (VNID)。与入口运营商相关联的名称空间的<code class="fe nv nw nx ny b"><strong class="ka ir">netid</strong></code>不同，因此<code class="fe nv nw nx ny b"><strong class="ka ir">allow-from-openshift-ingress</strong></code>网络策略中的<code class="fe nv nw nx ny b"><strong class="ka ir">matchLabel</strong></code>与来自<code class="fe nv nw nx ny b"><strong class="ka ir">default</strong></code>入口控制器的流量不匹配。</p><p id="519a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为<code class="fe nv nw nx ny b"><strong class="ka ir">default</strong></code>名称空间被分配了<code class="fe nv nw nx ny b"><strong class="ka ir">netid:0</strong></code> VNID，所以您可以通过用<code class="fe nv nw nx ny b"><strong class="ka ir">network.openshift.io/policy-group: ingress</strong></code>标记您的<code class="fe nv nw nx ny b"><strong class="ka ir">default</strong></code>名称空间来允许来自<code class="fe nv nw nx ny b"><strong class="ka ir">default</strong></code>入口控制器的流量。</p><p id="f828" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总之，我们需要向命名空间添加一个标签“default ”,这样我们就可以使用该标签来允许Ingres controller流量，因为我们的Ingres controller是使用HostNetwork发布的，它强制使用默认命名空间而不是openshift-ingress命名空间</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="3ce2" class="od lp iq ny b gy oe of l og oh">oc edit namespace default</span></pre><p id="cf96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">包括粗体文本的标签:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="7487" class="od lp iq ny b gy oe of l og oh">apiVersion: v1<br/>kind: Namespace<br/>metadata:<br/><strong class="ny ir">  labels:<br/>    network.openshift.io/policy-group: ingress</strong><br/>  annotations:<br/>...</span></pre><p id="c261" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您可以使用以下网络策略来允许IngressTraffic:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="fee5" class="od lp iq ny b gy oe of l og oh">apiVersion: networking.k8s.io/v1<br/>kind: NetworkPolicy<br/>metadata:<br/>  namespace: &lt;namespace name&gt;<br/>  name: allow-from-openshift-ingress<br/>spec:<br/>  ingress:<br/>  - from:<br/>    - namespaceSelector:<br/>        matchLabels:<br/>          network.openshift.io/policy-group: ingress<br/>  podSelector: {}<br/>  policyTypes:<br/>  - Ingress</span></pre><p id="8b7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 4-Multus </strong></p><p id="e311" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了配置Multus，您必须在<em class="na">networks . operator . open shift . io</em>对象类型的<em class="na"> cluster </em>实例中添加一个“附加网络”。</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="d187" class="od lp iq ny b gy oe of l og oh">oc edit networks.operator.openshift.io cluster</span></pre><p id="7598" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<em class="na">规格</em>部分添加<em class="na">附加网络</em>，包括:</p><ul class=""><li id="d42e" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">您允许使用VLAN命名空间</li><li id="8e68" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">插件类型(<a class="ae ns" href="https://docs.openshift.com/container-platform/4.5/networking/multiple_networks/understanding-multiple-networks.html" rel="noopener ugc nofollow" target="_blank">有多个可用的插件</a>，我在这个例子中使用的是<em class="na"> macvlan </em>，你可以设置其他配置，比如其他模式中的VLAN id，比如“<em class="na">桥</em>类型)</li><li id="b845" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">主界面</li><li id="e745" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">IPAM配置(我在这个网络中没有DHCP，所以我将在我的pod上配置静态IP)</li></ul><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="345d" class="od lp iq ny b gy oe of l og oh">...<br/>spec:<br/><strong class="ny ir">  additionalNetworks:<br/>    - name: test-vlan<br/>      namespace: test-securezone<br/>      rawCNIConfig: '{ "cniVersion": "0.3.1", "type": "macvlan", "capabilities": { "ips": true }, "master": "ens4", "mode": "bridge", "ipam": { "type": "static" } }'<br/>      type: Raw</strong><br/>  clusterNetwork:<br/>...</span></pre><p id="6978" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">仅此而已。您只需要允许正确的VLANs访问正确的名称空间(记住，最终将由集群管理员创建名称空间，查看下一节关于RBAC的内容以了解更多信息)。</p><h1 id="6d74" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated"><strong class="ak">配置测试(网络配置)</strong></h1><p id="0e4a" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">测试我们将创建两个名称空间和两个应用程序，一个在“常规区域”，另一个在“安全区域”，然后我们将运行一些测试:</p><ul class=""><li id="3909" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">检查应用程序是否可以通过路由访问，但只能由它们自己区域的入口控制器访问。</li><li id="c434" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">检查出口流量是否正在使用节点的IPs</li><li id="cf2d" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">检查应用程序是否无法通信(在应用网络策略后)</li><li id="494c" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">检查两个应用程序是否都可以在其pod中使用外部VLAN(Multus)</li></ul><p id="e69d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">1-入口流量</strong></p><p id="9da4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们首先创建名称空间和应用程序(它将显示POD的名称)，首先是在常规区域上运行的应用程序。</p><p id="7421" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">命名空间:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="6150" class="od lp iq ny b gy oe of l og oh">apiVersion: v1<br/>kind: Namespace<br/>metadata:<br/>  name: test-regularzone</span></pre><p id="8bbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应用程序:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="ab5e" class="od lp iq ny b gy oe of l og oh">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  namespace: test-regularzone<br/>  name: test<!-- -->-regularzone<br/>  labels:<br/>    app: test<!-- -->-regularzone<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: test<!-- -->-regularzone<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: test<!-- -->-regularzone<br/>    spec:<br/>      containers:<br/>      - name: test<!-- -->-regularzone<br/>        image: gcr.io/google-samples/hello-app:1.0</span></pre><p id="2b95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后是在安全区域运行的那个。</p><p id="1c79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于此命名空间，我们需要添加一个标签，以便为在此命名空间中创建的路由选择我们的安全IngressController:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="2fef" class="od lp iq ny b gy oe of l og oh">apiVersion: v1<br/>kind: Namespace<br/>metadata:<br/>  name: test-securezone<br/><strong class="ny ir">  labels:<br/>    securityzone: secure</strong></span></pre><p id="9439" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应用程序:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="850d" class="od lp iq ny b gy oe of l og oh">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  namespace: test-securezone<br/>  name: test<!-- -->-securezone<br/>  labels:<br/>    app: test<!-- -->-securezone<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: test<!-- -->-securezone<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: test<!-- -->-securezone<br/>    spec:<br/>      containers:<br/>      - name: test<!-- -->-securezone<br/>        image: gcr.io/google-samples/hello-app:1.0<br/><strong class="ny ir">    </strong><strong class="ny ir">  tolerations:<br/>        - key: "</strong><strong class="ny ir">securityzone</strong><strong class="ny ir">"<br/>          operator: "Equal"<br/>          value: "secure"<br/>          effect: "NoSchedule"</strong><br/><strong class="ny ir">      nodeSelector:<br/>        node-role.kubernetes.io/secure-worker: ''</strong></span></pre><p id="9f60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们检查运行它们的节点，以确保哪个区域托管它们:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="cc54" class="od lp iq ny b gy oe of l og oh">$ oc get pod -o wide --all-namespaces | grep test | awk {'print $2" " $8'} | column -t<br/>test-regularzone-95f775f45-vcnmg   worker0.ocp.136.243.40.222.nip.io<br/>test-securezone-7b9f668668-p8rpk   worker4.ocp.136.243.40.222.nip.io</span></pre><p id="23d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一切似乎都很好，现在让我们使用一个路由发布应用程序，但是为了这样做我们需要有一个<em class="na">服务</em>对象。因为我刚刚创建了一个<em class="na">部署</em>对象，所以还没有<em class="na">服务</em>。这很重要，因为如果我使用"<em class="na"> oc new-app </em>"命令，它将创建<em class="na">部署</em>和<em class="na">服务</em>。我将创建这两个服务。</p><p id="1ac5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于常规区域应用程序(该应用程序在POD中的端口8080上运行):</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="982c" class="od lp iq ny b gy oe of l og oh">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: test-regularzone<br/>  namespace: test-regularzone<br/>spec:<br/>  selector:<br/>    app: test-regularzone<br/>  ports:<br/>    - name: 8080-tcp<br/>      protocol: TCP<br/>      port: 8080<br/>      targetPort: 8080</span></pre><p id="1c7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于安全区域应用程序:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="6219" class="od lp iq ny b gy oe of l og oh">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: test-securezone<br/>  namespace: test-securezone<br/>spec:<br/>  selector:<br/>    app: test-securezone<br/>  ports:<br/>    - name: 8080-tcp<br/>      protocol: TCP<br/>      port: 8080<br/>      targetPort: 8080</span></pre><p id="98d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以创建路线了。我们可以使用“<em class="na">oc expose service&lt;service name&gt;</em>”命令或路由对象定义来发布应用程序。我将第一种方法用于常规区域的应用程序，第二种方法用于安全区域，这样你就可以同时看到这两种方法。</p><p id="69f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我从常规区域应用程序开始。我在命令中使用默认域名(这是针对“常规区域”)包含主机名</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="112e" class="od lp iq ny b gy oe of l og oh">$ oc expose svc test-regularzone -n test-regularzone --hostname=hello.apps.ocp.136.243.40.222.nip.io</span><span id="3d31" class="od lp iq ny b gy oi of l og oh">route.route.openshift.io/test-regularzone exposed</span></pre><p id="97ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于运行安全区域的服务器，我将使用描述符进行配置(也可以使用OC CLI，这只是为了展示一个不同的示例):</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="78ff" class="od lp iq ny b gy oe of l og oh">kind: Route<br/>apiVersion: route.openshift.io/v1<br/>metadata:<br/>  name: test-securezone<br/>  namespace: test-securezone<br/>spec:<br/>  host: hello.secureapps.ocp.136.243.40.222.nip.io<br/>  to:<br/>    kind: Service<br/>    name: test-securezone<br/>  port:<br/>    targetPort: 8080-tcp</span></pre><p id="735a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们检查一下常规区域的服务:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="626c" class="od lp iq ny b gy oe of l og oh">$ curl hello.apps.ocp.136.243.40.222.nip.io<br/>Hello, world!<br/>Version: 1.0.0<br/>Hostname: test-regularzone-95f775f45-vcnmg</span></pre><p id="0a58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在安全区域中:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="254f" class="od lp iq ny b gy oe of l og oh">$ curl hello.secureapps.ocp.136.243.40.222.nip.io<br/>Hello, world!<br/>Version: 1.0.0<br/>Hostname: test-securezone-7b9f668668-p8rpk</span></pre><p id="cf2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还可以检查每个路由仅由一个控制器提供服务。由于命名空间标签，test-regularzone路由托管在默认的IngressController:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="15d7" class="od lp iq ny b gy oe of l og oh">oc describe route hello -n test-regularzone<br/>Name:                   hello<br/>Namespace:              test-regularzone<br/>Created:                18 minutes ago<br/>Labels:                 &lt;none&gt;<br/>Annotations:            &lt;none&gt;<br/>Requested Host:         hello.apps.ocp.136.243.40.222.nip.io<br/>                          exposed on router default (host apps.ocp.136.243.40.222.nip.io) 18 minutes ago<br/>Path:                   &lt;none&gt;<br/>TLS Termination:        &lt;none&gt;<br/>Insecure Policy:        &lt;none&gt;<br/>Endpoint Port:          8080-tcp</span><span id="7262" class="od lp iq ny b gy oi of l og oh">Service:        test-regularzone<br/>Weight:         100 (100%)<br/>Endpoints:      10.128.2.72:8080</span></pre><p id="9122" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并且test-securezone路由托管在安全IngressController中:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="5a58" class="od lp iq ny b gy oe of l og oh">oc describe route hello -n test-securezone<br/>Name:                   hello<br/>Namespace:              test-securezone<br/>Created:                18 minutes ago<br/>Labels:                 &lt;none&gt;<br/>Annotations:            &lt;none&gt;<br/>Requested Host:         hello.secureapps.ocp.136.243.40.222.nip.io<br/>                          exposed on router secure-zone-ingress (host secureapps.ocp.136.243.40.222.nip.io) 9 minutes ago<br/>Path:                   &lt;none&gt;<br/>TLS Termination:        &lt;none&gt;<br/>Insecure Policy:        &lt;none&gt;<br/>Endpoint Port:          8080-tcp</span><span id="328e" class="od lp iq ny b gy oi of l og oh">Service:        test-securezone<br/>Weight:         100 (100%)<br/>Endpoints:      10.131.2.19:8080</span></pre><p id="ebd6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，您如何能够完全确定您到达了正确的IngressController(因此负载平衡器、DNS、路由等是正确的)。嗯，使用<em class="na"> tcpdump </em>是一个很好的选择，但是，既然它是一个不可变的操作系统并且<em class="na"> tcpdump </em>没有作为容器映像提供，你怎么能在Red Hat CoreOS中运行<em class="na"> tcpdump </em>呢？这里有一个窍门…</p><p id="ae4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在RHCOS中，您可以找到创建Fedora容器的"<em class="na"> toolbox" </em>命令，并且您可以在那里安装对节点进行故障排除所需的任何工具，在执行<em class="na"> toolbox start </em>之后，检查如何安装<em class="na"> tcpdump </em>(已经安装了<em class="na"> tcpdump </em>，但是您可以使用此过程来安装您想要的任何东西):</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="ce84" class="od lp iq ny b gy oe of l og oh">$ oc debug node/worker2.ocp.136.243.40.222.nip.io</span><span id="a17f" class="od lp iq ny b gy oi of l og oh">Starting pod/worker2ocp13624340222nipio-debug ...<br/>To use host binaries, run `chroot /host`<br/>Pod IP: 192.168.126.17<br/>If you don't see a command prompt, try pressing enter.</span><span id="a771" class="od lp iq ny b gy oi of l og oh">sh-4.2# chroot /host</span><span id="d715" class="od lp iq ny b gy oi of l og oh">sh-4.4# toolbox start</span><span id="5c58" class="od lp iq ny b gy oi of l og oh">Trying to pull registry.redhat.io/rhel8/support-tools...<br/>Getting image source signatures<br/>Copying blob fc5aa93e3b58 done<br/>Copying blob 1a6747857d79 done<br/>Copying blob 7256d4208767 done<br/>Copying config 18ef4c45e2 done<br/>Writing manifest to image destination<br/>Storing signatures<br/>18ef4c45e2b0cf15d13eabcb5f3f50fdcdb281f599dc4b259e6a4a896644cf75<br/>Spawning a container 'toolbox-' with image 'registry.redhat.io/rhel8/support-tools'<br/>Detected RUN label in the container image. Using that as the default...<br/>command: podman run -it --name toolbox- --privileged --ipc=host --net=host --pid=host -e HOST=/host -e NAME=toolbox- -e IMAGE=registry.redhat.io/rhel8/support-tools:latest -v /run:/run -v /var/log:/var/log -v /etc/machine-id:/etc/machine-id -v /etc/localtime:/etc/localtime -v /:/host registry.redhat.io/rhel8/support-tools:latest</span><span id="feb7" class="od lp iq ny b gy oi of l og oh">[root@worker2 /]# yum install tcpdump -y</span><span id="452c" class="od lp iq ny b gy oi of l og oh">Updating Subscription Management repositories.<br/>Unable to read consumer identity<br/>Subscription Manager is operating in container mode.<br/>This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.<br/>Red Hat Universal Base Image 8 (RPMs) - BaseOS                                                                                                                                                                 3.5 MB/s | 766 kB     00:00   <br/>Red Hat Universal Base Image 8 (RPMs) - AppStream                                                                                                                                                               23 MB/s | 3.9 MB     00:00   <br/>Red Hat Universal Base Image 8 (RPMs) - CodeReady Builder                                                                                                                                                      105 kB/s |  11 kB     00:00   <br/>Package tcpdump-14:4.9.2-6.el8.x86_64 is already installed.<br/>Dependencies resolved.<br/>Nothing to do.<br/>Complete!</span></pre><p id="d0ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以在运行IngressControllers的所有节点中运行<em class="na"> tcpdump </em>，然后在尝试获取两个URL时检查数据包的去向。在我的例子中，我在我们为新的IngressController配置的<em class="na"> ens10 </em>接口中运行了<em class="na"> tcpdump </em>，当我试图访问<em class="na">hello . secure apps . OCP . 136 . 243 . 40 . 222 . nip . io</em>时，我在那里获得了流量，但当我试图访问<em class="na">hello . apps . OCP . 136 . 243 . 40 . 222 . nip . io【T23</em></p><p id="f82f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您还可以运行额外的测试，您可以在/etc/hosts中为指向“错误的”Ingres controller的URL配置一个静态条目，从而模拟有人试图访问默认Ingres controller中的安全区域路由。这将会失败，因为正如我们所看到的，路由只在“正确的”Ingresscontroller中发布。</p><p id="84cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">2-出口交通</strong></p><p id="6374" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是默认行为，所以我不会进行这个测试，但是如果您想要仔细检查，您可以使用<em class="na"> tcpdump </em>来检查出口流量是否正在使用节点的IP。</p><p id="e26f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在运行PODs的主机上运行<em class="na"> tcpdump </em>，然后跳转到PODs终端并尝试访问外部资源。我们不能使用我们已经部署的pod，因为映像限制了对我们想要使用的命令的访问，所以我们可以使用我们在第一节中使用的部署对象，在第一节中，我们使用了<em class="na"> centos/tools </em>映像，并以特权访问权限运行它(查看下一点，我将确切地执行该操作)。</p><p id="6e09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">3-网络策略</strong></p><p id="2800" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这些测试，我们还需要一个映像来运行带有ping、curl等功能的bash，因此我将使用<em class="na"> centos/tools </em>映像部署几个PODs。如果您像我们之前那样部署该映像，当您尝试在容器内使用ping时，将会得到以下错误:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="724e" class="od lp iq ny b gy oe of l og oh">ping: permission denied (are you root?)<br/>command terminated with exit code 1</span></pre><p id="8392" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用这个映像，但是我们将使用ROOT用户启动它，ROOT用户需要足够的权限来执行此操作。最好的方法是创建一个ServiceAccount，赋予这个帐户特殊的权限，然后使用它启动部署。让我们开始创建ServiceAccount，每个名称空间一个:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="1d43" class="od lp iq ny b gy oe of l og oh">$  oc create serviceaccount -n test-regularzone privilegeduser</span><span id="2fc3" class="od lp iq ny b gy oi of l og oh">serviceaccount/privilegeduser created</span><span id="92e3" class="od lp iq ny b gy oi of l og oh">$ oc create serviceaccount -n test-securezone privilegeduser</span><span id="5ccc" class="od lp iq ny b gy oi of l og oh">serviceaccount/privilegeduser created</span></pre><p id="3148" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后将权限授予服务帐户:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="0805" class="od lp iq ny b gy oe of l og oh">$  oc adm policy add-scc-to-user privileged -n test-regularzone -z privilegeduser</span><span id="4a45" class="od lp iq ny b gy oi of l og oh">clusterrole.rbac.authorization.k8s.io/system:openshift:scc:privileged added: "privilegeduser"</span><span id="c8fa" class="od lp iq ny b gy oi of l og oh">$ oc adm policy add-scc-to-user privileged -n test-securezone -z privilegeduser</span><span id="01cc" class="od lp iq ny b gy oi of l og oh">clusterrole.rbac.authorization.k8s.io/system:openshift:scc:privileged added: "privilegeduser"</span></pre><p id="c7d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，使用ServiceAccount创建<em class="na">部署</em>，并在容器定义中添加<em class="na">security context</em><em class="na">privileged</em>，在规范中添加<em class="na"> runAsUser:0 </em>。常规区域中应用程序的<em class="na">部署</em>定义(检查粗体文本):</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="fef0" class="od lp iq ny b gy oe of l og oh">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  namespace: test-regularzone<br/>  name: test-regularcentos<br/>  labels:<br/>    app: test-regularcentos<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: test-regularcentos<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: test-regularcentos<br/>    spec:<br/><strong class="ny ir">      serviceAccountName: privilegeduser<br/></strong>      <strong class="ny ir">securityContext:<br/>        runAsUser: 0</strong><br/>      containers:<br/>      - name: test-regularcentos<br/>        image: centos/tools<br/>        command: ["/bin/bash", "-c", "sleep 9000000"]<br/><strong class="ny ir">        </strong><strong class="ny ir">securityContext:<br/>          privileged: true <br/>          runAsUser: 0</strong></span></pre><p id="7b4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个在安全区:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="e172" class="od lp iq ny b gy oe of l og oh">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  namespace: test-securezone<br/>  name: test-securecentos<br/>  labels:<br/>    app: test-securecentos<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: test-securecentos<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: test-securecentos<br/>    spec:<br/><strong class="ny ir">      serviceAccountName: privilegeduser</strong><br/><strong class="ny ir">      </strong><strong class="ny ir">securityContext: <br/>        runAsUser: 0</strong><br/>      containers:<br/>      - name: test-securecentos<br/>        image: centos/tools<br/>        command: ["/bin/bash", "-c", "sleep 9000000"]<br/><strong class="ny ir">        </strong><strong class="ny ir">securityContext:<br/>          privileged: true</strong><strong class="ny ir"> </strong><br/>      tolerations:<br/>        - key: "securityzone"<br/>          operator: "Equal"<br/>          value: "secure"<br/>          effect: "NoSchedule"<br/>      nodeSelector:<br/>        node-role.kubernetes.io/secure-worker: ''</span></pre><p id="ae33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们跳进豆荚终端，试着从一个ping到另一个。您可以通过多种方式在POD中运行命令:</p><ul class=""><li id="325d" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">使用<em class="na">" oc exec&lt;pod name&gt;-ti—&lt;command&gt;"</em>(在本例中，该命令可以是<em class="na">/bin/bash</em>…<em class="na">/usr/bin/bash</em>，因为映像在该路径中托管bash)</li></ul><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="6fe8" class="od lp iq ny b gy oe of l og oh">$ oc exec -n test-regularzone test-regularcentos-5d88db7c55-2tcn9 -ti -- hostname</span><span id="aa84" class="od lp iq ny b gy oi of l og oh">test-regularcentos-5d88db7c55-2tcn9</span></pre><ul class=""><li id="a752" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">使用<em class="na">“oc rsh&lt;pod name&gt;”</em></li></ul><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="fbc7" class="od lp iq ny b gy oe of l og oh">$ oc rsh -n test-regularzone test-regularcentos-5d88db7c55-2tcn9<br/>sh-4.2$ hostname<br/>test-regularcentos-5d88db7c55-2tcn9</span></pre><ul class=""><li id="f22a" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">使用Web控制台</li></ul><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/1b5f9a081e3ca18db03a42798ca379e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mJzt2b3-4eSxeC9j0Urk6A.gif"/></div></div></figure><p id="286d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们执行以下PINGs命令:</p><ul class=""><li id="a2e6" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">同一命名空间中的源和目标</li><li id="8a2d" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">不同命名空间中的源和目标</li></ul><p id="ba6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我首先检查test-securezone名称空间中一个pod的IP:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="9eaa" class="od lp iq ny b gy oe of l og oh">$ oc exec -n test-securezone test-securecentos-757dd94f95-p4x8z -ti -- ip a | grep inet</span><span id="31f2" class="od lp iq ny b gy oi of l og oh">inet 127.0.0.1/8 scope host lo<br/>    inet6 ::1/128 scope host <br/>    inet 10.131.2.22/23 brd 10.131.3.255 scope global eth0<br/>    inet6 fe80::4822:8dff:fe0e:b4a1/64 scope link</span></pre><p id="a5a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以尝试从不同名称空间中的另一个POD ping它(<em class="na"> test-regularzone </em>)，ping失败:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="f077" class="od lp iq ny b gy oe of l og oh">$ oc exec -n test-regularzone test-regularcentos-cc5d9555c-98xv5 -ti -- ping 10.131.2.22<br/>PING 10.131.2.12 (10.131.2.22) 56(84) bytes of data.<br/>...</span></pre><p id="ea1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以检查一下，如果您尝试相反的方法，从安全区域ping到常规区域，也会失败。</p><p id="90cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我尝试ping同一个名称空间中的两个pod(<em class="na">test-regular zone</em>)，ping就会成功。这次我们使用“oc get pod”命令检查IP:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="b4bc" class="od lp iq ny b gy oe of l og oh">$ oc get pod -n test-regular -o wide | awk {'print $1" " $6'} | column -t</span><span id="0136" class="od lp iq ny b gy oi of l og oh">NAME                                IP<br/>test-regularcentos-cc5d9555c-8m7vg  10.131.2.13<br/>test-regularzone-95f775f45-nnws2    10.131.2.12</span></pre><p id="1200" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们运行ping命令:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="c3e5" class="od lp iq ny b gy oe of l og oh">$ oc exec -n test-regular test-regularcentos-cc5d9555c-8m7vg -ti -- ping 10.131.2.12<br/>PING 10.131.2.12 (10.131.2.12) 56(84) bytes of data.<br/>64 bytes from 10.131.2.12: icmp_seq=1 ttl=64 time=0.928 ms<br/>64 bytes from 10.131.2.12: icmp_seq=2 ttl=64 time=0.138 ms<br/>...</span></pre><p id="bce6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一个测试是检查IngressController是否被允许，您只需请求已经创建的路由:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="c92c" class="od lp iq ny b gy oe of l og oh">$ curl <a class="ae ns" href="http://hello.apps.ocp.136.243.40.222.nip.io/" rel="noopener ugc nofollow" target="_blank">http://hello.apps.ocp.136.243.40.222.nip.io/</a></span><span id="efab" class="od lp iq ny b gy oi of l og oh">Hello, world!<br/>Version: 1.0.0<br/>Hostname: test-regularzone-95f775f45-nnws2</span><span id="cc9a" class="od lp iq ny b gy oi of l og oh"><br/>$ curl <a class="ae ns" href="http://hello.secureapps.ocp.136.243.40.222.nip.io/" rel="noopener ugc nofollow" target="_blank">http://hello.secureapps.ocp.136.243.40.222.nip.io/</a><br/>Hello, world!<br/>Version: 1.0.0<br/>Hostname: test-securezone-7b9f668668-rlsjk</span></pre><p id="448b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 4-Multus </strong></p><p id="82ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们部署一个连接到我们允许的网络的具有静态IP的POD(名称:<em class="na"> test-vlan </em>)，并检查我是否连接到群集外部的IP:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="b5ba" class="od lp iq ny b gy oe of l og oh">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  namespace: test-securezone<br/>  name: test-secure-multus<br/>  labels:<br/>    app: test-secure-multus<br/>  annotations:<br/>    k8s.v1.cni.cncf.io/networks: '[<br/>        {<br/>                "name": "test-vlan",<br/>                "ips": ["192.168.250.5/24"]<br/>        }<br/>]'<br/>spec:<br/>  serviceAccountName: privilegeduser<br/>  securityContext: <br/>    runAsUser: 0<br/>  containers:<br/>  - name: test-securecentos<br/>    image: centos/tools<br/>    command: ["/bin/bash", "-c", "sleep 9000000"]<br/>    securityContext:<br/>      privileged: true <br/>  tolerations:<br/>    - key: "securityzone"<br/>      operator: "Equal"<br/>      value: "secure"<br/>      effect: "NoSchedule"<br/>  nodeSelector:<br/>    node-role.kubernetes.io/secure-worker: ''</span></pre><p id="376b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">部署POD后，检查192.168.250.5 IPs是否已分配给POD:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="010c" class="od lp iq ny b gy oe of l og oh">oc exec -n test-securezone test-secure-multus  -ti -- ip a | grep inet<br/>    inet 127.0.0.1/8 scope host lo<br/>    inet6 ::1/128 scope host <br/>    inet 10.131.2.23/23 brd 10.131.3.255 scope global eth0<br/>    inet6 fe80::d431:79ff:fe60:3a3e/64 scope link <br/>    inet 192.168.250.5/24 brd 192.168.250.255 scope global net1<br/>    inet6 fe80::e03c:7fff:feab:9402/64 scope link</span></pre><p id="a8c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并尝试ping外部IP (192.168.250.192)</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="65b2" class="od lp iq ny b gy oe of l og oh">oc exec -n test-securezone test-secure-multus  -ti -- ping 192.168.250.192<br/>PING 192.168.250.192 (192.168.250.192) 56(84) bytes of data.<br/>64 bytes from 192.168.250.192: icmp_seq=1 ttl=64 time=2.00 ms<br/>64 bytes from 192.168.250.192: icmp_seq=2 ttl=64 time=0.222 ms</span></pre><p id="3b7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您还可以检查未被允许的名称空间是否不能使用该网络。尝试在<em class="na"> test-regularzone </em>名称空间中创建此POD:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="b76e" class="od lp iq ny b gy oe of l og oh">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  namespace: test-regularzone<br/>  name: test-regular-multus<br/>  labels:<br/>    app: test-regular-multus<br/>  annotations:<br/>    k8s.v1.cni.cncf.io/networks: '[<br/>        {<br/>                "name": "test-vlan",<br/>                "ips": ["192.168.250.6/24"]<br/>        }<br/>]'<br/>spec:<br/>  serviceAccountName: privilegeduser<br/>  securityContext: <br/>    runAsUser: 0<br/>  containers:<br/>  - name: test-securecentos<br/>    image: centos/tools<br/>    command: ["/bin/bash", "-c", "sleep 9000000"]<br/>    securityContext:<br/>      privileged: true</span></pre><p id="923b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您不会得到任何错误，但是如果您检查POD的状态，您会看到它是如何卡在<em class="na">容器中的。</em></p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="57ed" class="od lp iq ny b gy oe of l og oh">oc get pod -n test-regularzone<br/>NAME                                 READY   STATUS              RESTARTS   AGE<br/>test-regular-multus                  0/1     <strong class="ny ir">ContainerCreating</strong>   0          3m37s<br/>test-regularcentos-cc5d9555c-8m7vg   1/1     Running             0          16m<br/>test-regularzone-95f775f45-nnws2     1/1     Running             0          79m</span></pre><p id="4908" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您想知道发生了什么，请查看事件:</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="fd00" class="od lp iq ny b gy oe of l og oh">oc describe pod test-regular-multus  -n test-regularzone</span></pre><p id="dcf5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你会看到实际的</p><pre class="ms mt mu mv gt nz ny oa ob aw oc bi"><span id="5f4b" class="od lp iq ny b gy oe of l og oh">cannot find a network-attachment-definition (test-vlan) in namespace (test-regularzone)</span></pre><h1 id="4b38" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">只差一步了</h1><p id="5060" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">你快完成了，不要放弃。在下一篇文章中，我们将配置RBAC和其他限制，只允许我们的OpenShift集群用户的子集能够使用安全区域。</p><div class="kw kx gp gr ky kz"><a href="https://medium.com/@luis.ariz/security-zones-in-openshift-worker-nodes-part-iv-user-restrictions-and-recap-5ec0ba7bdaf9" rel="noopener follow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">OpenShift工作节点中的安全区域—第四部分—用户限制和概述</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">这是关于如何在你的OpenShift workers中配置安全区域的最后一篇文章。</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">medium.com</p></div></div><div class="li l"><div class="ok l lk ll lm li ln jw kz"/></div></div></a></div></div></div>    
</body>
</html>