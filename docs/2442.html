<html>
<head>
<title>Build a basic service container in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中构建一个基本服务容器</h1>
<blockquote>原文：<a href="https://itnext.io/build-a-rudimentary-dependency-container-in-go-d0c9800ccb24?source=collection_archive---------2-----------------------#2019-05-24">https://itnext.io/build-a-rudimentary-dependency-container-in-go-d0c9800ccb24?source=collection_archive---------2-----------------------#2019-05-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/5ddeaff79ff8a6c05766b243b4eee3a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hTjtO3BeTC7IEjU4yi9dqA.jpeg"/></div></div></figure><div class=""/><p id="c2b6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我特别是在PHP和Symfony/Laravel上工作了很长时间，我非常喜欢这种框架:应用程序容器——一个包含正确运行应用程序所需的所有依赖项的对象。</p><p id="188d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Go中的大多数RESTful APIs示例使用普通闭包来处理请求，但是我发现在构建比简单端点更复杂的东西时，这有一点限制。</p><p id="d001" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于最近的一个任务，我想出了一个基本的依赖容器，我相信它可以很好地满足这个目的。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="bf54" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">启动服务器</h1><p id="03fa" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">首先，让我们启动一个HTTP服务器来处理请求:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="2424" class="mp le jb ml b gy mq mr l ms mt">package cmd</span><span id="53c7" class="mp le jb ml b gy mu mr l ms mt">import (<br/> "github.com/lucavallin/goat-webshop/pkg/api"<br/> "github.com/lucavallin/goat-webshop/pkg/herd"<br/> "github.com/spf13/cobra"<br/> "os"<br/> "path/filepath"<br/>)</span><span id="f890" class="mp le jb ml b gy mu mr l ms mt">var serveCmd = &amp;cobra.Command{<br/> Use:   "serve",<br/> Short: "Start API server for the Goat Webshop",<br/> Long: "Start API server for the Goat Webshop",<br/> Run: func(cmd *cobra.Command, args []string) {<br/>  Serve()<br/> },<br/>}</span><span id="b99f" class="mp le jb ml b gy mu mr l ms mt">func init() {<br/> rootCmd.AddCommand(serveCmd)<br/>}</span><span id="f1b6" class="mp le jb ml b gy mu mr l ms mt">// Serve stars the APIs for the goat-webshop<br/>func Serve() {<br/> herdPath, _ := filepath.Abs("data/herd.xml")<br/> herdRepo := herd.NewXMLFileRepository(herdPath)<br/> app := api.NewApp(herdRepo)</span><span id="9228" class="mp le jb ml b gy mu mr l ms mt"> app.Run(os.Getenv("PORT"))<br/>}</span></pre><p id="5736" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个代码片段中，我使用<a class="ae mv" href="https://github.com/spf13/cobra" rel="noopener ugc nofollow" target="_blank"> Cobra </a>构建一个基于命令的应用程序，而<strong class="ka jc"> Serve() </strong>函数是它的入口点。调用<strong class="ka jc"> api时。NewApp() </strong>创建了一个新的应用程序容器——它保存了我在执行过程中需要的依赖项(在本例中是一个存储库，基于XML)。</p><p id="4b3e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> app。Run() </strong>有效地启动应用程序，使用<strong class="ka jc">操作系统从环境中读取所需的端口。Getenv("PORT") </strong> —我在Heroku上托管这些API，这就是它如何在那里工作的<strong class="ka jc">。</strong></p><p id="aac5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应用程序的主入口可能会因为更多的依赖项而看起来很混乱，但根据这条推文，这似乎没什么问题:</p><figure class="mg mh mi mj gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="0dfe" class="ld le jb bd lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw nc ly lz ma bi translated">集装箱</h1><p id="8e01" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">当服务器运行时，让我们看看在<strong class="ka jc"> api内部发生了什么。NewApp() </strong>:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="dfff" class="mp le jb ml b gy mq mr l ms mt">package api</span><span id="edcc" class="mp le jb ml b gy mu mr l ms mt">import (<br/> "github.com/gin-gonic/gin"<br/> "github.com/lucavallin/goat-webshop/pkg/herd"<br/> "log"<br/>)</span><span id="8bba" class="mp le jb ml b gy mu mr l ms mt">// App contains all the dependencies needed for the API<br/>type App struct {<br/> herdRepo herd.Repository<br/> router   *gin.Engine<br/>}</span><span id="35f5" class="mp le jb ml b gy mu mr l ms mt">// NewApp creates a new app with the needed dependencies<br/>func NewApp(herdRepo herd.Repository) *App {<br/> router := gin.Default()</span><span id="6889" class="mp le jb ml b gy mu mr l ms mt"> app := &amp;App{herdRepo, router}<br/> app.router.GET("/herd/:days", app.GetHerdHandler())</span><span id="d96c" class="mp le jb ml b gy mu mr l ms mt"> return app<br/>}</span><span id="49eb" class="mp le jb ml b gy mu mr l ms mt">// Run starts the APIs<br/>func (app *App) Run(port string) {<br/> log.Fatal(app.router.Run(":" + port))<br/>}</span></pre><p id="4710" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> NewApp() </strong>接收我们需要的存储库，创建并返回一个<strong class="ka jc"> App </strong>对象，其中包含依赖项和路由器。我用<strong class="ka jc">杜松子酒</strong>做这个，因为我发现它使用起来既简单又干净——它也是最常见的。</p><p id="4b71" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有趣的是端点的处理程序:它是一个必须在<strong class="ka jc"> app </strong>对象上调用的方法，这样可以确保在处理请求时，我们可以访问我们需要的依赖项。</p><h1 id="053c" class="ld le jb bd lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw nc ly lz ma bi translated">处理程序示例</h1><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="df9d" class="mp le jb ml b gy mq mr l ms mt">package api</span><span id="fb42" class="mp le jb ml b gy mu mr l ms mt">import (<br/> "github.com/gin-gonic/gin"<br/> "github.com/lucavallin/goat-webshop/pkg/herd"<br/> "strconv"<br/>)</span><span id="df80" class="mp le jb ml b gy mu mr l ms mt">...</span><span id="fc81" class="mp le jb ml b gy mu mr l ms mt">// GetHerdHandler handlers GET to /goat-webshop/herd/:days<br/>func (app *App) GetHerdHandler() func(c *gin.Context) {<br/> return func(c *gin.Context) {<br/>  elapsedDays, _ := strconv.Atoi(c.Param("days"))<br/>  newHerd := app.herdRepo.Get()<br/>  newHerd.Age(elapsedDays)</span><span id="7ce1" class="mp le jb ml b gy mu mr l ms mt">  c.JSON(http.StatusOK, newHerd)<br/> }<br/>}</span></pre><p id="b297" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">忽略业务逻辑，因为它与目的无关，专注于这一行:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="07ab" class="mp le jb ml b gy mq mr l ms mt">newHerd := app.herdRepo.Get()</span></pre><p id="05a2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于依赖关系包含在<strong class="ka jc"> app </strong>对象中，我们现在可以访问它们，但避免了紧密耦合的代码:存储库(或任何其他您可能需要的服务)驻留在依赖关系容器中，从不直接公开——这使得在需要时很容易被替换(例如，它目前是基于XML的，但如果您足够清醒，您可能希望使用真正的数据库)。</p><p id="9b47" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，端点处理程序只能在app对象(实际上是一个指向它的指针)上调用，以确保我们需要的依赖项总是可用的。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="f1e7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> <em class="nd">想了解更多围棋和创新知识？关注@lucavallin上的</em> </strong> <a class="ae mv" href="https://twitter.com/lucavallin" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc"> <em class="nd">推特</em> </strong> </a> <strong class="ka jc"> <em class="nd">和</em></strong><a class="ae mv" href="https://github.com/lucavallin" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc"><em class="nd">Github</em></strong></a><strong class="ka jc"><em class="nd">或者来Xebia工作室</em></strong><a class="ae mv" href="https://www.xebia.studio/" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc"><em class="nd"/></strong><strong class="ka jc"><em class="nd">和我们见面吧！</em> </strong></a></p></div></div>    
</body>
</html>