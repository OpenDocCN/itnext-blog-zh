<html>
<head>
<title>SQL Caching and Table Partitioning (Follow-up)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL缓存和表分区(后续)</h1>
<blockquote>原文：<a href="https://itnext.io/mysql-caching-and-table-partitioning-c65d7010216e?source=collection_archive---------1-----------------------#2022-11-20">https://itnext.io/mysql-caching-and-table-partitioning-c65d7010216e?source=collection_archive---------1-----------------------#2022-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1ee6e43077b84fed54e184640c7692c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W1zbf7AsJlz_Gdq7S5MCOQ.png"/></div></div></figure><p id="b7ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">继我的上一篇文章<a class="ae kw" href="https://medium.com/itnext/techniques-for-optimising-sql-queries-c362dbe626b4" rel="noopener">优化SQL查询的技术</a>之后，我将再讨论两个主题来提高查询和数据库的性能。</p><ul class=""><li id="11f8" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><a class="ae kw" href="#80a5" rel="noopener ugc nofollow">T3】缓存SQL查询结果集T5】</a></li><li id="972d" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><a class="ae kw" href="#00df" rel="noopener ugc nofollow"> <strong class="ka ir">表分区<br/></strong></a><strong class="ka ir">——</strong><a class="ae kw" href="#c5ba" rel="noopener ugc nofollow"><strong class="ka ir">什么是分区</strong></a><strong class="ka ir"><br/>——</strong><a class="ae kw" href="#fe4f" rel="noopener ugc nofollow"><strong class="ka ir">分区的类型有哪些</strong></a><strong class="ka ir"><br/>——</strong><a class="ae kw" href="#d04c" rel="noopener ugc nofollow"><strong class="ka ir">为什么分区</strong></a><strong class="ka ir"><br/>——</strong><a class="ae kw" href="#dd78" rel="noopener ugc nofollow"><strong class="ka ir">分区和索引</strong> </a> <strong class="ka ir"/></li></ul><h1 id="80a5" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">缓存SQL查询结果集</h1><p id="7972" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">我们在SQL数据库中有两级缓存。默认情况下启用一级缓存，而必须配置二级缓存。你可以在这篇由<a class="mo mp ep" href="https://medium.com/u/c3c2a62da97b?source=post_page-----c65d7010216e--------------------------------" rel="noopener" target="_blank"> Darshan Dalwadi </a>撰写的<a class="ae kw" href="https://medium.com/swlh/what-is-hibernate-caching-introduction-of-level-1-level-2-cache-8ea7339a5052" rel="noopener">文章</a>中阅读更多关于一级和二级缓存的内容。</p><p id="8484" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于默认情况下一级缓存是启用的，所以我们唯一能做的就是根据我们用来连接和处理数据库的技术或ORM，将缓存驱动程序改为使用数组、文件或任何其他类型。</p><p id="a101" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，二级缓存是禁用的，因此我们必须启用它，并根据我们的需求进行配置。这可以通过<a class="ae kw" href="https://medium.com/@mena.meseha/memcached-synchronizes-with-mysql-data-42a5d09c8b11" rel="noopener"> MemCached </a>进行配置，MemCached 由<a class="mo mp ep" href="https://medium.com/u/a7eb0e304f8a?source=post_page-----c65d7010216e--------------------------------" rel="noopener" target="_blank">米娜·阿尤布</a>、<a class="ae kw" href="https://dltlabs.medium.com/the-art-of-caching-with-redis-eaaa89ae74be" rel="noopener"> Redis </a>提供快速介绍，由<a class="mo mp ep" href="https://medium.com/u/aca22eb440b9?source=post_page-----c65d7010216e--------------------------------" rel="noopener" target="_blank"> DLT实验室</a>、Riak或任何其他服务提供，我们可以将它们用作与SQL兼容的缓存。</p><p id="e972" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在来自<a class="mo mp ep" href="https://medium.com/u/8493c3c4b789?source=post_page-----c65d7010216e--------------------------------" rel="noopener" target="_blank"> Sudheer Sandu </a>的这篇<a class="ae kw" href="https://medium.com/@sudheer.sandu/distributed-caching-the-only-guide-youll-ever-need-fe152357f912" rel="noopener">文章</a>中，您会发现对缓存的详细解释，包括数据库缓存。</p><h1 id="00df" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">表分区</h1><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/8005c6189650d3e780abd39f9844f310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6O7OpQzbQ3uktOdFe8dRaQ.png"/></div></div></figure><h2 id="c5ba" class="mv lm iq bd ln mw mx dn lr my mz dp lv kj na nb lz kn nc nd md kr ne nf mh ng bi translated">什么是分区？</h2><p id="003f" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">分区将一个表分成更小的逻辑部分，称为“分区”。看起来还是像张桌子。分区是用CREATE或ALTER语句定义的。</p><pre class="mr ms mt mu gt nh ni nj bn nk nl bi"><span id="a5ed" class="nm lm iq ni b be nn no l np nq">CREATE TABLE Sales ( saleDate date, … ) <br/>  PARTITION BY KEY(saleDate) PARTITIONS 16;<br/><br/>ALTER TABLE Sales <br/>  ADD PARTITION (date = '2016-05-14');</span></pre><p id="1833" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">SQL engine知道如何将表分成更小的部分，并使用这些信息来加速查询。在许多小零件上的操作通常比在一个大桌子上更快。</p><h2 id="fe4f" class="mv lm iq bd ln mw mx dn lr my mz dp lv kj na nb lz kn nc nd md kr ne nf mh ng bi translated">分区的类型有哪些？</h2><p id="83a2" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">总共有5种分区类型，其中两种类型在现有分区中还可以有其他分区。所有这些分区类型都在下面进行了解释。</p><ul class=""><li id="408b" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir">范围分区</strong>根据给定范围内的列值将行分配给分区。</li></ul><pre class="mr ms mt mu gt nh ni nj bn nk nl bi"><span id="10ba" class="nm lm iq ni b be nn no l np nq">CREATE TABLE Table (<br/>  id INT NOT NULL,<br/>  firstname VARCHAR(25) NOT NULL,<br/>  joined DATE NOT NULL<br/>)<br/>PARTITION BY RANGE( id) (<br/>  PARTITION p0 VALUES LESS THAN (100),<br/>  PARTITION p1 VALUES LESS THAN (200),<br/>  PARTITION p2 VALUES LESS THAN (300)<br/>);</span></pre><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/ae4bb826827e7429d9375687e89a19b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*c03wMw7YsxT6AlPKZYEHrg.png"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">范围划分</figcaption></figure><ul class=""><li id="b59a" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir">列表分区</strong>类似于按范围分区，除了分区是根据与一组离散值之一匹配的列来选择的。</li></ul><pre class="mr ms mt mu gt nh ni nj bn nk nl bi"><span id="f62d" class="nm lm iq ni b be nn no l np nq">CREATE TABLE Table (val INT)<br/>PARTITION BY LIST(val)(<br/>  PARTITION myFirstPart VALUES IN (1,3,5),<br/>  PARTITION MyPart VALUES IN (2,4,6),<br/>  .........<br/>);</span></pre><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/b068ee4adbe4f9231ce382995d9341aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RpGz3_06cs3vK0mVUMnBDw.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">列表分区</figcaption></figure><ul class=""><li id="cdf7" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir">散列分区</strong>是指根据用户定义的表达式返回的值选择一个<strong class="ka ir"> </strong>分区，该表达式对要插入到表中的行中的列值进行操作。该函数可以由SQL中产生非负整数值的任何有效表达式组成。这种类型的扩展，线性散列，也是可用的。</li></ul><pre class="mr ms mt mu gt nh ni nj bn nk nl bi"><span id="e513" class="nm lm iq ni b be nn no l np nq">CREATE TABLE Sales (<br/>  id INT NOT NULL,<br/>  store_name VARCHAR(30),<br/>  store_id INT<br/>)<br/>PARTITION BY HASH(store_id) PARTITIONS 4;</span></pre><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/49ea173fc4619e29197ef275fb8286c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3W-1PwlVEXN7gk-Q"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">哈希分区</figcaption></figure><ul class=""><li id="dba9" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir">键分区类似于哈希分区，只是只提供了一个或多个要评估的列，并且SQL server提供了自己的哈希函数。这些列可以包含除整数值之外的其他值，因为SQL提供的散列函数保证了整数结果，而不管列数据类型如何。这种类型的扩展，线性键，也是可用的。</strong></li></ul><pre class="mr ms mt mu gt nh ni nj bn nk nl bi"><span id="54b8" class="nm lm iq ni b be nn no l np nq">CREATE TABLE Sales ( order_date date, ... )<br/>  PARTITION BY KEY(order_date) PARTITIONS 4;</span></pre><ul class=""><li id="7095" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir">列分区</strong>是范围和列表分区的变体。列分区允许在分区键中使用多个列。所有这些列都被考虑在内，以便将行放置在分区中，并确定在分区修剪中要检查哪些分区的匹配行。</li></ul><pre class="mr ms mt mu gt nh ni nj bn nk nl bi"><span id="4e76" class="nm lm iq ni b be nn no l np nq">CREATE TABLE rcx (<br/>  a INT,<br/>  b INT,<br/>  c CHAR(3),<br/>  d INT<br/>)<br/>PARTITION BY RANGE COLUMNS(a,d,c) (<br/>  PARTITION p0 VALUES LESS THAN (5,10,'ggg'),<br/>  PARTITION p1 VALUES LESS THAN (10,20,'mmm'),<br/>  PARTITION p2 VALUES LESS THAN (15,30,'sss'),<br/>  PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)<br/>);</span></pre><ul class=""><li id="04ab" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir">子分区，</strong>范围和列表分区可以用键和散列子分区。在下图中，它显示了按月份细分的区域范围。我们看到了如何查询表以获得更快结果的不同组合。如果我们查询整个表，扫描并返回一个结果需要3分钟，但是如果我们只查询所有地区的9月份，我们在15秒内得到一个结果。</li></ul><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/520914b01458f216b39fc0f7a9ae8d39.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/0*7eWv-6p4Bcsu0Rjo"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">按月份和地区细分</figcaption></figure><h2 id="d04c" class="mv lm iq bd ln mw mx dn lr my mz dp lv kj na nb lz kn nc nd md kr ne nf mh ng bi translated"><strong class="ak">为什么要分区？</strong></h2><p id="c6f0" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">通过对表进行分区，除了获取数据之外，我们还可以只删除特定分区上的数据。唯一的缺点是它只适用于范围和列表分区。</p><p id="907e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于非索引列，我们可以更快地获得结果。这是因为SQL优化器知道分区表达式，并且当分区表达式中使用的列在查询where条件中时，可以在扫描表时消除分区。</p><p id="d048" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以减少甚至消除索引(分区定义仍然需要索引)！</p><p id="e958" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加索引可以更快，因为它们只添加在表的一部分上，并且所有的优化都可以按分区进行。</p><p id="02c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果数据只被添加到一个分区，那么你可以只优化那个分区，而不是在整个表上运行优化。</p><h2 id="dd78" class="mv lm iq bd ln mw mx dn lr my mz dp lv kj na nb lz kn nc nd md kr ne nf mh ng bi translated"><strong class="ak">分区和索引</strong></h2><p id="e2f5" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">我们必须了解表分区中使用的索引类型。</p><ul class=""><li id="9606" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir">唯一索引<br/> </strong>我们需要唯一索引分区，并且在表的分区表达式中使用的每一列都必须是该表上每个唯一键的一部分。<br/>这并不意味着您必须只有唯一的键，如果您这样做了，那么它们中的每一个都必须包括分区表达式中使用的所有值！</li><li id="cb26" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">非唯一索引<br/> </strong>分区表中也可以有非唯一索引。分区引擎将在每个分区上执行单独的非并行索引查找！如果分区数量很少(4个),性能可能还可以，但是如果分区数量很大，性能就会变得很差。如果您必须拥有非唯一索引，请保持较低的分区数量(&lt; 16)。太多的分区，超过124，开始真正减慢非唯一索引查找</li></ul><p id="fcf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">设计良好的分区表很少甚至没有索引！它应该总是少于非分区表，因为它需要重新设计索引！</p><h2 id="4430" class="mv lm iq bd ln mw mx dn lr my mz dp lv kj na nb lz kn nc nd md kr ne nf mh ng bi translated">分区维护</h2><p id="57a4" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">表分区不是做一次就忘了的事情。它需要日复一日的维护。</p><p id="edc0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果需要，我们需要相应地修正索引。</p><p id="e3ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">定期在分区上运行优化和分析流程，例如每晚为每个分区运行5-10分钟的作业。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/d72e31dbdae149021feb37a548b7c2dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XYsW603fm3-EUHo7"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">优化分区</figcaption></figure><pre class="mr ms mt mu gt nh ni nj bn nk nl bi"><span id="5609" class="nm lm iq ni b be nn no l np nq">CREATE TABLE Sale (<br/>  saleID INT AUTO_INCREMENT PRIMARY KEY, <br/>  salesDate TIMESTAMP, <br/>  storeID smallint, <br/>  amount decimal(10,2)<br/>);<br/>Alter table Sale Partition by hash(saleID) partitions 7;<br/>Alter table sale optimize partition P1;</span></pre><p id="f7e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">插入、更新和删除将照常进行，默认情况下将针对最后一个分区</p><p id="5f11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于上述原因，尽量将分区数量控制在16个或更少，最好是8个或更少。</p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="6d28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望你觉得这些信息有用，并随时让我知道你的想法。</p><p id="1db9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想和我联系，你可以关注或联系我的任何社交网站，或者通过我的<a class="ae kw" href="https://abame.github.io/" rel="noopener ugc nofollow" target="_blank">个人网站</a>上的联系方式。</p></div></div>    
</body>
</html>