<html>
<head>
<title>Managing Ingress Controllers on Kubernetes: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">管理Kubernetes上的入口控制器:第2部分</h1>
<blockquote>原文：<a href="https://itnext.io/managing-ingress-controllers-on-kubernetes-part-2-36a64439e70a?source=collection_archive---------2-----------------------#2018-12-12">https://itnext.io/managing-ingress-controllers-on-kubernetes-part-2-36a64439e70a?source=collection_archive---------2-----------------------#2018-12-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f0f4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">实现它:各种入口控制器</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e4ac61676535fb45dd0d73880a14eef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vX5KvWFWokDLP2JD"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">伊琳娜·布洛克在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="d0f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">制造入口资源实际上并不建立任何路由能力。为此，我们需要一个入口控制器。与Kubernetes集群上部署的所有其他控制器一样，入口控制器监视入口资源的变化，然后使用规则定义来路由传入流量。</p><p id="7f43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">入口控制器通常作为pod在集群中实施。它们由社区和其他第三方提供。因此，有许多不同的实现。有些甚至提供类似的功能。这意味着要做出选择，在有选择的地方，有时很难找到最佳选择。</p><p id="58f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，为了帮助您做出选择，让我们比较一些更受欢迎的入口控制器，从Nginx入口控制器开始。</p><h2 id="1e07" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">Nginx入口控制器</h2><p id="4e76" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们要看的第一个入口控制器是由Kubernetes社区维护的基于Nginx的入口控制器(以下简称为<a class="ae kv" href="https://kubernetes.github.io/ingress-nginx/" rel="noopener ugc nofollow" target="_blank"> k8s-ingress-nginx控制器</a>)。这不要与Nginx社区维护的基于Nginx的Ingress控制器，或基于Nginx Plus的商用Ingress控制器相混淆。它们在本质上是相似的，但是k8s-ingress-nginx-控制器支持比Nginx社区支持的控制器更高级的配置，而Nginx Plus控制器必须通过订阅获得许可。</p><p id="2f45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">k8s-ingress-nginx控制器基于nginx反向代理的开源版本，但在中编译了一些额外的第三方模块。让我们来看看使它与众不同的一些特征。</p><h2 id="1268" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">高度可配置</h2><p id="3d40" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Nginx是一个高度可配置的反向代理，许多不同的配置选项作为k8s-ingress-nginx控制器的一部分直接可用。控制器自带一个全面的<a class="ae kv" href="https://github.com/kubernetes/ingress-nginx/blob/master/internal/ingress/controller/config/config.go" rel="noopener ugc nofollow" target="_blank">默认配置</a>，包含在控制器本身中，可以用几种方式覆盖。</p><p id="799c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要微调Nginx配置，该配置将应用于与k8s ingress-nginx控制器相关联的任何入口资源定义中的规则相匹配的流量，必须将该配置定义和部署为ConfigMap，控制器的命令行参数(— <code class="fe mq mr ms mt b">configmap</code>)在其部署资源定义中引用该配置。例如，要将默认的<code class="fe mq mr ms mt b">keep-alive</code>值从<code class="fe mq mr ms mt b">75</code>更改为<code class="fe mq mr ms mt b">60</code>，ConfigMap必须包含以下代码片段:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="a789" class="ls lt iq mt b gy my mz l na nb">data:</span><span id="b859" class="ls lt iq mt b gy nc mz l na nb"> keep-alive: "60"</span></pre><p id="043a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果偏好在入口资源定义级别而不是在控制器级别提供配置定制，则可以将注释应用于特定入口资源定义，指定相关配置。假设我们有一个入口资源定义，这是与k8s-ingress-nginx控制器相关联的众多定义之一，并且我们需要对访问规则中定义的服务后端的用户进行身份验证，我们可以使用以下注释作为入口资源定义的一部分:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="7513" class="ls lt iq mt b gy my mz l na nb">metadata:</span><span id="51df" class="ls lt iq mt b gy nc mz l na nb">  name: important-service annotations:</span><span id="c5b3" class="ls lt iq mt b gy nc mz l na nb">    nginx.ingress.kubernetes.io/auth-type: basic</span><span id="6090" class="ls lt iq mt b gy nc mz l na nb">    nginx.ingress.kubernetes.io/auth-secret: users</span></pre><p id="28cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用配置的最后一种方法是通过使用模板文件，使用Golang文本/模板语法指定配置。这是一种更高级的定制技术，但在未来的控制器更新中容易出现重大变化。</p><p id="1e3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总而言之，k8s-ingress-nginx控制器提供了全面的入口功能，具有相同的默认配置，但能够微调该配置，以适应几乎任何使用情况。</p><h2 id="967e" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">高效的配置重新加载</h2><p id="dd6a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在Kubernetes等动态的云原生环境中，工作负载会不断地被部署、扩展和删除。为了将流量路由到组成服务的pod，k8s-ingress-nginx控制器使用服务端点而不是其虚拟IP地址。这意味着底层Nginx配置需要不断刷新，以便控制器知道将流量路由到哪里。如果持续的端点变化迫使Nginx每次都重新加载，这可能会显著影响控制器的性能及其有效路由入口流量的能力。</p><p id="5d8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，k8s-ingress-nginx控制器避免了端点变化时的这种需要，包括了控制器监视端点变化的OpenResty <code class="fe mq mr ms mt b">lua_nginx_module. </code>，为Lua处理程序提供了一个列表，Lua处理程序确定传入请求应该发送到哪个后端对等点或端点。Nginx然后负责路由请求。</p><p id="ceb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在部署了大量服务的集群中，无需不断重新加载配置，这使得k8s-ingress-nginx控制器成为管理入口的可行选择。需要注意的是，虽然k8s-ingress-nginx控制器从0.12版本开始就有动态配置重新加载功能，但从0.18版本开始，该功能仅默认开启。</p><h2 id="3660" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">支持TCP/UDP服务</h2><p id="271f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Kubernetes Ingress通常仅限于第7层HTTP路由，并不提供任何基于寻址端口和协议路由流量的“本地”功能。但是，k8s-ingress-nginx控制器可以为基于TCP和UDP的服务配置ConfigMap，这使它能够将面向客户端的端口映射到命名空间服务和端口。每个协议的配置图需要在启动时作为参数提供给控制器。公开服务的配置图片段可能如下所示:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="e4e8" class="ls lt iq mt b gy my mz l na nb">data:<br/>  6379: “default/redis:6379”</span></pre><p id="9984" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从技术上来说，这是对Kubernetes Ingress API对象中缺乏第4层负载平衡支持的一种变通办法，但尽管如此，这仍然是k8s-ingress-nginx控制器的一个有用特性。</p><h2 id="db9f" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">会话关联性</h2><p id="2b5e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们已经讨论过k8s-ingress-nginx控制器使用端点API来监视pods的变化，而不是基于服务的虚拟IP地址来路由流量，这带来了一些有用的好处。通过kube-proxy绕过服务请求的正常代理，它允许对客户端连接使用会话亲缘关系，这是通过路由到服务的虚拟IP不可能实现的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://info.giantswarm.io/guide-to-managing-ingress-controllers"><div class="gh gi nd"><img src="../Images/c46c9bc5c32531dc4b9e02fbc12fd9f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*VVAGMXjltR6ssPFbThUjFg.png"/></div></a></figure><h2 id="cbeb" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">轮廓入口控制器</h2><p id="f9b4" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Contour是一个开源的入口控制器，它使用了另一个广受好评的云原生代理；<a class="ae kv" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank">特使</a>。除了作为反向代理之外，Envoy还有许多应用，但它非常适合作为入口控制器。</p><p id="e6e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，Contour Ingress controller被部署为单个pod，由一个Envoy容器和一个Contour容器组成，后者充当Envoy的“管理服务器”。轮廓组件的主要用途是双重的。首先，它监视与Ingress相关联的各种Kubernetes API对象的变化，然后将它们转换为Envoy使用的等效资源对象。其次，它通过实现Envoy使用的各种发现服务(xDS)API来响应Envoy的轮询，并返回必要的配置供Envoy使用。Contour通过gRPC提供xDS APIs，Envoy使用它们。该入口控制器的独特之处在于:</p><h2 id="69bd" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">对象翻译</h2><p id="5cbb" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Kubernetes和Envoy说的不是同一种语言。Kubernetes依赖于入口、<a class="ae kv" href="https://blog.giantswarm.io/basic-kubernetes-concepts-iii-services-give-abstraction/" rel="noopener ugc nofollow" target="_blank">服务</a>、<a class="ae kv" href="https://blog.giantswarm.io/understanding-basic-kubernetes-concepts-v-daemon-sets-and-jobs/" rel="noopener ugc nofollow" target="_blank">端点</a>和<a class="ae kv" href="https://blog.giantswarm.io/understanding-basic-kubernetes-concepts-iv-secrets-and-configmaps/" rel="noopener ugc nofollow" target="_blank">秘密</a>等资源。Contour Ingress控制器通过在这些Kubernetes资源和相应的Envoy资源之间执行转换来实现动态配置更改。</p><p id="3fe7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Envoy集群大致相当于Kubernetes服务，Contour和Envoy之间的通信是使用Envoy的集群发现服务(CDS) API进行的。监听器发现服务(LDS) API用于配置Envoy监听器，数据由包含TLS工件的入口对象和秘密对象提供。入口对象还提供路由配置，通过路由配置发现服务(RDS) API进行通信。最后，使用端点发现服务(EDS) API将Kubernetes端点对象转换为Envoy ClusterLoadAssignment对象。</p><h2 id="ffaa" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">API驱动的配置</h2><p id="7cd8" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">虽然k8s-ingress-nginx控制器通过包含OpenResty lua_nginx_ module避免了配置重载，但Contour Ingress控制器受益于Envoy的动态API驱动配置。这意味着Envoy不需要重新加载配置，从而确保控制器保持高性能，即使在配置不断变化的情况下也是如此，正如我们在云原生的容器化环境中所预期的那样。</p><h2 id="d778" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">IngressRoute自定义资源定义</h2><p id="f26e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">虽然Contour Ingress controller与标准Ingress API资源配合得非常好，但它也可以利用名为IngressRoute的自定义资源。Kubernetes 1.1在2015年底引入了标准的入口API资源。自那以后，它的变化很小，并且没有完全模拟许多入口场景所需的行为。因此，许多入口控制器利用<a class="ae kv" href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/" rel="noopener ugc nofollow" target="_blank">注释</a>来克服默认入口API资源的不足。</p><p id="0f37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了改善这一点，CRD入口路线旨在通过更全面的功能来丰富Kubernetes入口体验。一些额外的功能包括:加权和负载平衡策略的定义、特定路由到多个上游服务的负载平衡路由、上游服务粒度的健康检查等等。</p><p id="d120" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Envoy提供的API驱动配置非常适合入口控制器，Ingres route CRD提供的功能使Contour入口控制器成为管理Kubernetes集群入口的强大资源。</p><p id="ed92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们来看看这个系列的最后一个入口控制器，Traefik入口控制器:</p><h2 id="1658" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">Traefik入口控制器</h2><p id="3eae" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">得知Traefik入口控制器基于<a class="ae kv" href="https://traefik.io/" rel="noopener ugc nofollow" target="_blank"> Traefik </a>反向代理和负载均衡器并不奇怪。与Envoy非常相似，Traefik是在最近的容器驱动的云原生运动中构思出来的。它是开源软件，由它的创造者Containous提供商业支持。Traefik本质上是通用的，除了Kubernetes之外，它还支持各种不同的基础设施环境或“提供商”。</p><p id="0c6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Traefik入口控制器的工作方式与前面讨论过的入口控制器非常相似，它使用标准的入口API对象和包含在二进制文件中的控制器，后者是从最小Docker映像部署的。控制器根据被监视的Kubernetes API对象动态更新其配置，并提供了一个默认的内置Traefik配置，如果需要，可以覆盖该配置。</p><p id="c1e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Traefik入口控制器实现与入口API对象相关联的行为，为群集中部署的服务提供基于主机和路径的路由。然而，作为一个全面的反向代理，Traefik入口控制器通过一组可选注释提供了许多有趣的配置选项。让我们来看看一些更有趣的功能。</p><h2 id="5fb9" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">限速</h2><p id="675c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Traefik入口控制器可以通过指定平均速率和突发速率来限制在给定时间段内发送到后端服务的客户端请求的数量。此限制适用于每个客户端IP地址。使用<code class="fe mq mr ms mt b">traefik.ingress.kubernetes.io/rate-limit </code>键指定速率限制，YAML值指定请求的时间段、平均值和突发数。这对于保护后端服务不被请求淹没特别有用，并且可以防止DDoS攻击。</p><h2 id="951b" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">断路</h2><p id="7352" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">断路是大多数现代代理的一个相当标准的特性，当后端被认为处于故障或失败状态时，它允许系统关闭到后端的路由。Traefik入口控制器通过定义延迟和/或网络错误和/或HTTP响应代码比率的表达式来提供这种能力。断路器表达式是使用作为后端服务定义的一部分提供的<code class="fe mq mr ms mt b">traefik.ingress.kubernetes.io/circuit-breaker-expression </code>注释提供的。</p><h2 id="21c2" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">会话关联性</h2><p id="2fa7" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">粘性会话可以通过在后端服务上将<code class="fe mq mr ms mt b">traefik.ingress.kubernetes.io/affinity </code>注释设置为“true”来实现。另一个注释允许设置cookie的名称。</p><h2 id="0921" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">具有服务权重的流量分流</h2><p id="4d74" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><code class="fe mq mr ms mt b">traefik.ingress.kubernetes.io/service-weights</code>注释允许根据为每个服务定义的权重，在不同的后端服务之间分割寻址到特定主机和路径的流量。该键的值是YAML，它为每个提供服务指定一个百分比。以这种方式进行流量分离的完美用例是执行canary版本，其中一部分流量可以被定向到canary服务，随着对新版本的信心增加而逐渐增加。服务权重是Traefik即将发布的1.7版本的一项功能，在此之前的版本中不可用。</p><p id="b9fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这只是Traefik入口控制器提供的功能的一个子集，通过使用入口或服务对象注释，还可以获得许多更高级的功能。</p><blockquote class="ne nf ng"><p id="9742" class="kw kx nh ky b kz la jr lb lc ld ju le ni lg lh li nj lk ll lm nk lo lp lq lr ij bi translated"><a class="ae kv" href="https://medium.com/@GiantSwarm/managing-ingress-controllers-on-kubernetes-part-3-2984b3616249" rel="noopener"> <strong class="ky ir">阅读第3部分:管理SSL/TLS的选项</strong> </a></p></blockquote><p id="a099" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由<a class="ae kv" href="https://twitter.com/puja108" rel="noopener ugc nofollow" target="_blank">Puja Abbas si</a>——开发者倡导者@ <a class="ae kv" href="https://giantswarm.io/" rel="noopener ugc nofollow" target="_blank">巨型群体</a>撰写</p><div class="nl nm gp gr nn no"><a href="https://twitter.com/puja108" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">puja Abbas si @ # kube con # kube Khan(@ puja 108)| Twitter</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">Puja Abbassi的最新推文@ #KubeCon #KubeKhan (@puja108)。开发者倡导者@ GiantSwarm &amp; Researcher</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">twitter.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc kp no"/></div></div></a></div><p id="29c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">准备好将您的云原生项目投入生产了吗？只需在https://giantswarm.io/<a class="ae kv" href="https://giantswarm.io/" rel="noopener ugc nofollow" target="_blank">申请免费试用</a></p></div></div>    
</body>
</html>