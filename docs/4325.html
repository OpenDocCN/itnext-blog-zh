<html>
<head>
<title>IaC with Terraform and Azure DevOps, Part 2: Pipeline Templates and Linting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Terraform和Azure DevOps的IaC，第2部分:管道模板和林挺</h1>
<blockquote>原文：<a href="https://itnext.io/iac-with-terraform-and-azure-devops-part-2-pipeline-templates-and-linting-e4ab5553010?source=collection_archive---------5-----------------------#2020-06-08">https://itnext.io/iac-with-terraform-and-azure-devops-part-2-pipeline-templates-and-linting-e4ab5553010?source=collection_archive---------5-----------------------#2020-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="177d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">这是关于Terraform、Azure DevOps和用代码管理基础设施的系列文章的第2部分。参见第一部分</em> <a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/infrastructure-as-code-iac-with-terraform-azure-devops-f8cd022a3341"> <em class="ko">此处</em> </a> <em class="ko">。</em></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/f3796fe95d11b46e343c2cbb25f36dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AjMGXp8R0JXbx4eH"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">照片由<a class="ae kp" href="https://unsplash.com/@cristinagavrila?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯蒂娜·加夫里拉</a>在<a class="ae kp" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="22e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本系列的上一篇文章中，我们介绍了在Azure DevOps中创建YAML管道来运行Terraform的基础知识。我们的目标是将我们的基础设施作为代码来管理，为了这个目标，我们希望我们的管道——部署所述代码——尽可能地简洁、可配置，并遵守<a class="ae kp" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank"> DRY原则</a>。</p><h1 id="d22e" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">模板变量</h1><p id="9be8" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">在本系列的第一篇文章中，我们创建了一个简单的管道，在顶部定义了变量。以这种方式定义的变量被认为是“全局的”，这意味着它们适用于管道中的每个阶段、工作和任务。如果这些变量在我们管道的每个阶段都是相同的，这将是很好的，但是如果我们想要部署到多个环境呢？如果我们想使用Terraform在一个管道中构建不同的环境呢？我们需要为正在部署的每个组件传递一组不同的tfvars、远程状态和文件夹路径。到目前为止，我们有一个静态管道，它有一个至关重要的问题:我们将配置与管道定义本身混合在一起。管道必须尽可能简洁地与环境相适应。</p><p id="3c74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们将我们在管道顶部定义的变量移动到一个名为<code class="fe mj mk ml mm b">dev_vars.yml</code>的YAML文件中。我们将把它放在一个名为<code class="fe mj mk ml mm b">vars</code>的文件夹中，就在保存管道yaml文件的目录下:</p><pre class="kr ks kt ku gt mn mm mo mp aw mq bi"><span id="d10a" class="mr lh it mm b gy ms mt l mu mv">➜ tree -L 2<br/>.<br/>├── pipeline.yml<br/>└── vars<br/>    └── dev_vars.yml</span></pre><p id="a8b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个文件中，我们将把前面的所有变量声明为键值对:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b7c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们的变量保存在一个模板文件中，我们可以在需要它们的阶段直接调用它们，而不是在管道顶部硬编码它们:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a939" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着我们可以为我们部署到的每个环境创建多个可变模板。我们甚至可以将变量分离到特定于帐户和特定于环境的文件中，然后使用多个<code class="fe mj mk ml mm b">— template:</code>参数在管道中组合起来！现在，我们将坚持使用一个环境和一个变量模板，以保持简单。</p><h1 id="eecc" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">模板化Azure DevOps管道任务</h1><p id="ee38" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">我们可以转换任务、工作和阶段——是的，甚至阶段！—转换成模板。模板可以被认为是类似的函数；它们接受参数(如果您选择定义它们)，然后用这些值执行定义的指令。我们将获取组成我们的<code class="fe mj mk ml mm b">terraform plan</code>的三个任务，并通过执行以下操作将它们转换成一个模板:</p><ol class=""><li id="129a" class="my mz it js b jt ju jx jy kb na kf nb kj nc kn nd ne nf ng bi translated">创建一个名为<code class="fe mj mk ml mm b">templates </code>的文件夹，并在这里创建一个名为<code class="fe mj mk ml mm b">terraform_plan.yml</code>的模板文件。</li><li id="5ce1" class="my mz it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">在地形计划阶段从<code class="fe mj mk ml mm b">steps</code>中剪下所有东西并粘贴到这个文件中。</li></ol><p id="89ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是我们的文件夹结构现在的样子:</p><pre class="kr ks kt ku gt mn mm mo mp aw mq bi"><span id="3bbe" class="mr lh it mm b gy ms mt l mu mv">➜ tree -L 2<br/>.<br/>├── pipeline.yml<br/>├── templates<br/>│   └── terraform_plan.yml<br/>└── vars<br/>    └── dev_vars.yml</span></pre><p id="b18f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以及我们的模板文件目前的样子:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="cf35" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了使其像函数一样工作，我们将执行以下操作:</p><ol class=""><li id="4641" class="my mz it js b jt ju jx jy kb na kf nb kj nc kn nd ne nf ng bi translated">定义在主管道中调用时模板将接受的参数</li><li id="ba38" class="my mz it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">通过使用<code class="fe mj mk ml mm b">${{ parameters.parameterName }}</code>语法将使用<code class="fe mj mk ml mm b">$(variableName)</code>语法的变量引用更改为参数</li></ol><p id="0b9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦这些都完成了，你的模板应该是这样的:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="e14a" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">组合变量和阶段/作业/任务模板</h1><p id="cefe" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">我们现在有了模板化的变量和模板化的管道作业。让我们用新模板替换之前作业定义下的任务，并将我们在管道顶部定义的变量传递给模板。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f5c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太棒了。现在，如果Terraform需要与另一个组件一起运行或针对另一个环境运行，我们只需创建一个新的变量模板。就是这样。这里有一个例子，说明我们如何在同一个管道中对两个环境运行Terraform，只需改变我们传递给作业的<code class="fe mj mk ml mm b">template</code>:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div></div>    
</body>
</html>