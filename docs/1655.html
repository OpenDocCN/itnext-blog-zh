<html>
<head>
<title>Trying Paint Worklet in Safari Technology Preview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">尝试在Safari Technology Preview中绘制Worklet</h1>
<blockquote>原文：<a href="https://itnext.io/trying-paint-wroklet-in-safari-technology-preview-fc02f58c30e7?source=collection_archive---------9-----------------------#2018-12-20">https://itnext.io/trying-paint-wroklet-in-safari-technology-preview-fc02f58c30e7?source=collection_archive---------9-----------------------#2018-12-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/1efb3c9665547281e9cb0b3b56cd4ad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vs1PW-NSOdm2j00qAER_Lg.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">撒哈拉沙漠探险</figcaption></figure><div class=""/><p id="b632" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">作为CSS Houdini的忠实粉丝，我很高兴Safari团队决定在开发中采用Paint API。第一个实现是Safari Technology Preview (TP) 69附带的。但是在72版本的changelog中，我看到了令人兴奋的消息——可以将<code class="fe la lb lc ld b">&lt;image&gt;</code>作为输入属性传递给Paint Worklet🤩。我想在此时此地玩它。不幸的是，这并不容易。</p><h1 id="de57" class="le lf jf bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">初始设置</h1><p id="14b3" class="pw-post-body-paragraph kc kd jf ke b kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz ij bi translated">第一个挑战是进行初始配置🤓。App Store里找不到Safari TP，需要从developer.apple.com的<a class="ae mh" href="https://developer.apple.com/safari/download/" rel="noopener ugc nofollow" target="_blank">手动下载。好的一面是它应该可以从App Store获得更新。然后你需要找到如何启用实验API。作为一个Chrome用户，我已经开始寻找一些标志设置标签，但没有运气。要在Safari TP中启用画图API，你需要进入<em class="mi">“开发”</em>“➡”<em class="mi">“实验功能”</em>菜单并切换<em class="mi">“CSS画图API”</em>选项。在我开始我的实验之前，我决定尝试我之前已经</a><a class="ae mh" href="https://vitaliy-bobrov.github.io/blog/exploring-the-css-paint-api/" rel="noopener ugc nofollow" target="_blank">创建过的演示。他们在Chrome中工作，但是他们中的一些人需要Chrome Canary，因为那里使用了一些其他的胡迪尼部件。所以我已经导航到基本的</a><a class="ae mh" href="https://vitaliy-bobrov.github.io/css-paint-demos/hello-world/" rel="noopener ugc nofollow" target="_blank">画图小工具演示</a> …它死了😭。</p><h1 id="db2d" class="le lf jf bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">死亡演示调查</h1><p id="a72a" class="pw-post-body-paragraph kc kd jf ke b kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz ij bi translated">屏幕上不是四个圆圈，而是白色背景。这意味着回退值没有应用，因为我已经使用了黑色。那很有趣，🧐.当我打开检查器时，我看到带有<code class="fe la lb lc ld b">paint</code>功能的背景被应用到元素上。然后我打开控制台，出现了一个错误——<code class="fe la lb lc ld b">ReferenceError: Can't find variable: paint</code>。这令人困惑，我没有在Worklet类定义中使用任何名为“paint”的变量。所以我尝试在控制台中手动加载它:</p><pre class="mj mk ml mm gt mn ld mo mp aw mq bi"><span id="9ebf" class="mr lf jf ld b gy ms mt l mu mv">CSS.paintWorklet.addModule('paint.js');</span></pre><p id="af1f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">又出现了同样的错误。Hm，<code class="fe la lb lc ld b">addModule</code>方法应该接受带有自定义painter实现的文件路径。有一个与安全相关的限制，类似于Web和服务工作者，所有的工作小程序代码都应该写在一个单独的文件中。他们有完全不同的JavaScript上下文，不应该访问任何全局数据。所以我尝试了不同的路径变化:</p><pre class="mj mk ml mm gt mn ld mo mp aw mq bi"><span id="b106" class="mr lf jf ld b gy ms mt l mu mv">CSS.paintWorklet.addModule('/paint.js');</span></pre><p id="d9c0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我又出错了，但是是一个不同的错误。似乎这个函数试图将path解释为一个代码。在<a class="ae mh" href="https://webkit.org/blog/8547/release-notes-for-safari-technology-preview-72/" rel="noopener ugc nofollow" target="_blank">发行说明</a>中有修改过的Safari源代码的链接。所以我决定在那里找到一个解释。和Chrome一样，Safari也是用C++写的。我不是这种语言的大专家，但至少能明白是怎么回事。</p><h1 id="e4fd" class="le lf jf bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">源代码Safari</h1><p id="d160" class="pw-post-body-paragraph kc kd jf ke b kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz ij bi translated">我已经开始探索开放与Paint API相关的变化的链接。我检查的第一件事是测试，因为它们是当前实现的最佳来源。它们只是HTML文件，看起来就像这样(为了显示要点，我将示例做得更短):</p><figure class="mj mk ml mm gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="199f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">工作流代码存储在带有自定义mime类型“text/worklet”的脚本标签中，然后文本内容被传递给<code class="fe la lb lc ld b">importWorklet</code>助手。这证实了我的猜测，我继续查找源代码。过了一段时间，我在<a class="ae mh" href="https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/worklets/Worklet.cpp?rev=239067" rel="noopener ugc nofollow" target="_blank"> Worklet.cpp </a>文件中发现了一条很棒的评论:</p><pre class="mj mk ml mm gt mn ld mo mp aw mq bi"><span id="90a0" class="mr lf jf ld b gy ms mt l mu mv">// FIXME: We should download the source from the URL <br/>// <a class="ae mh" href="https://bugs.webkit.org/show_bug.cgi?id=191136" rel="noopener ugc nofollow" target="_blank">https://bugs.webkit.org/show_bug.cgi?id=191136</a></span></pre><p id="dc83" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以我跟踪了WebKit Bugzilla中bug 的<a class="ae mh" href="https://bugs.webkit.org/show_bug.cgi?id=191136" rel="noopener ugc nofollow" target="_blank">链接。评论解释了一切:</a></p><blockquote class="my mz na"><p id="f93c" class="kc kd mi ke b kf kg kh ki kj kk kl km nb ko kp kq nc ks kt ku nd kw kx ky kz ij bi translated"><em class="jf">目前，对Worklet::addModule(字符串url)的调用使用url作为代码。它应该按照规范异步获取脚本。—贾斯汀·米肖，2018–10–31</em></p></blockquote><p id="0768" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe la lb lc ld b">addModule</code>方法不是获取文件，而是从字符串中解析代码🤦‍♂️.</p><h1 id="46a4" class="le lf jf bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">工作区</h1><p id="d71e" class="pw-post-body-paragraph kc kd jf ke b kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz ij bi translated">我的发现意味着我需要用painters将我的JS文件转换成一个字符串，但仅限于Safari。直到他们根据<a class="ae mh" href="https://www.w3.org/TR/css-paint-api-1/" rel="noopener ugc nofollow" target="_blank">规范</a>实现该方法。有几种可能的解决方案:</p><ol class=""><li id="80ed" class="ne nf jf ke b kf kg kj kk kn ng kr nh kv ni kz nj nk nl nm bi translated">以字符串形式编写代码😅</li><li id="ddf0" class="ne nf jf ke b kf nn kj no kn np kr nq kv nr kz nj nk nl nm bi translated">使用自定义mime类型在脚本标记中编写代码🤡</li><li id="6670" class="ne nf jf ke b kf nn kj no kn np kr nq kv nr kz nj nk nl nm bi translated">手动获取JS文件并转换为字符串🤠</li></ol><p id="1f20" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我决定采用第三种选择。我想检测Safari浏览器，请求一个脚本，并将其转换为字符串。</p><h1 id="aa3f" class="le lf jf bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">检测Safari</h1><p id="fb36" class="pw-post-body-paragraph kc kd jf ke b kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz ij bi translated">在当前版本的演示中，我在注册Paint Worklet之前使用了功能检测:</p><figure class="mj mk ml mm gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6114" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">之后，我需要检测Safari浏览器。经过短暂的调查，我使用了下一个用户代理检查片段:</p><figure class="mj mk ml mm gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="06b6" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个有点混乱，但是Safari的用户代理应该包含“Safari”，而不是“Chrome”。因为Chrome两者都有🤣。</p><h1 id="b74c" class="le lf jf bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">请求文件</h1><p id="a5b7" class="pw-post-body-paragraph kc kd jf ke b kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz ij bi translated">这是最简单的任务，因为Safari支持大多数现代的JavaScrip特性。我使用Fetch API来请求文件。然后我将响应解析为<code class="fe la lb lc ld b">Blob</code>:</p><figure class="mj mk ml mm gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d4da" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们不允许在异步函数之外使用<code class="fe la lb lc ld b">await</code>,这就是为什么我将调用包装在async IIFE中的原因。</p><h1 id="5bd7" class="le lf jf bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将文件转换为字符串</h1><p id="51bb" class="pw-post-body-paragraph kc kd jf ke b kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz ij bi translated">我发现，将<code class="fe la lb lc ld b">Blob</code>转换成字符串的最简单方法是使用文件阅读器API。这个API的语义看起来与现代的不同，因为它非常古老。首先，我们需要创建<code class="fe la lb lc ld b">FileReader</code>实例。然后监听“load”事件。只有在这之后，我们才能开始阅读过程:</p><figure class="mj mk ml mm gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6fe3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是最后一个阶段，几乎所有的演示都可以在Safari中运行🎉。一些问题仍然存在，我会在最近的时间内修复它们。这是一个有趣的旅程，但正如我在源代码中发现的那样，Safari团队实现了许多Chrome Canary中没有完成的功能。但这是一个完全不同的故事，我一定会在不久的将来分享我的实验。下面是生成的加载代码:</p><figure class="mj mk ml mm gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="9e1d" class="le lf jf bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="a823" class="pw-post-body-paragraph kc kd jf ke b kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz ij bi translated">制作一些未记录的和实验性的东西总是探索Web平台API的好方法。最重要的是，它教会我们保持评论和测试与时俱进，因为它们是真理的主要来源。玩得开心👻！</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="fbed" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="mi">原载于</em><a class="ae mh" href="https://vitaliy-bobrov.github.io/blog/trying-paint-wroklet-in-safari-tp/" rel="noopener ugc nofollow" target="_blank"><em class="mi">vitaliy-bobrov . github . io</em></a><em class="mi">。</em></p></div></div>    
</body>
</html>