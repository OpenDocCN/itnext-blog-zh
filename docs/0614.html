<html>
<head>
<title>Jenkins with HTTPS Using NGINX and Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">詹金斯与HTTPS使用NGINX和Docker</h1>
<blockquote>原文：<a href="https://itnext.io/setting-up-https-for-jenkins-with-nginx-everything-in-docker-4a118dc29127?source=collection_archive---------1-----------------------#2018-04-17">https://itnext.io/setting-up-https-for-jenkins-with-nginx-everything-in-docker-4a118dc29127?source=collection_archive---------1-----------------------#2018-04-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1839" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，在AWS EC2实例上运行Docker中的Jenkins很容易。您只需确保Docker已经<a class="ae kl" href="https://gist.github.com/weibeld/21fb18497eb78104aa4ef83b0fd27081" rel="noopener ugc nofollow" target="_blank">安装在EC2实例上</a>，然后运行下面的<code class="fe km kn ko kp b">docker run</code>命令，如文档中的<a class="ae kl" href="https://jenkins.io/doc/book/installing/#downloading-and-running-jenkins-in-docker" rel="noopener ugc nofollow" target="_blank">所示:</a></p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="4c9e" class="ky kz iq kp b gy la lb l lc ld">docker run \<br/>  -d \<br/>  --rm \<br/>  -u root \<br/>  -p 8080:8080 \<br/>  -v jenkins-data:/var/jenkins_home \<br/>  -v /var/run/docker.sock:/var/run/docker.sock \<br/>  jenkinsci/blueocean</span></pre><p id="654d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您拥有域<code class="fe km kn ko kp b">mydomain.com</code>，那么您可以转到您的DNS服务器，为<code class="fe km kn ko kp b">jenkins.mydomain.com</code>创建一个CNAME记录，将其值设置为您的AWS EC2实例的公共域名，您的Jenkins安装将在<code class="fe km kn ko kp b">http://jenkins.mydomain.com</code>公开访问。</p><p id="7b40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，并不是说URI方案是<code class="fe km kn ko kp b">http</code>而不是<code class="fe km kn ko kp b">https</code>。Jenkins ( <a class="ae kl" href="https://github.com/jenkinsci/winstone" rel="noopener ugc nofollow" target="_blank"> Winstone </a>)内置的web服务器默认使用HTTP。这意味着你和Jenkins之间的所有通信都是不加密的。那么，如果你想使用HTTPS加密你的流量呢？</p><p id="5e0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一种选择是将内置的Jenkins Winstone服务器配置为使用HTTPS。这可能会有一些麻烦，但不推荐，即使是官方的詹金斯医生也不推荐。</p><p id="7d90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一个更简单的解决方案，即使用一个<strong class="jp ir">反向代理</strong>。在这种情况下，反向代理处理所有HTTPS的东西，这允许您在反向代理后面以默认配置(使用HTTP)运行Jenkins。在本教程中，我们将使用<a class="ae kl" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> NGINX </a>反向代理，我们将所有东西作为Docker容器运行。</p><p id="0bf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于此解决方案，以下步骤是必要的:</p><ol class=""><li id="1f8d" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated"><a class="ae kl" href="#4d9a" rel="noopener ugc nofollow">了解什么是反向代理。</a></li><li id="ef81" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated"><a class="ae kl" href="#0fa3" rel="noopener ugc nofollow">为</a> <code class="fe km kn ko kp b"><a class="ae kl" href="#0fa3" rel="noopener ugc nofollow">jenkins.mydomain.com</a></code> <a class="ae kl" href="#0fa3" rel="noopener ugc nofollow">创建一个TLS服务器证书。</a></li><li id="68ec" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated"><a class="ae kl" href="#c915" rel="noopener ugc nofollow">使用正确的配置运行反向代理和Jenkins容器。</a></li></ol><p id="9799" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文的其余部分，我将逐一描述这些步骤。</p><h1 id="4d9a" class="ls kz iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">什么是反向代理？</h1><p id="9c64" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">和往常一样，带有“反向”修饰语的术语不是很直观。基本上，有两种类型的代理，它们被称为<strong class="jp ir">正向代理</strong>和<strong class="jp ir">反向代理</strong>。下图说明了它们的作用:</p><figure class="kq kr ks kt gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mu"><img src="../Images/aa18c258ee048a82875fa88331850b2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dy03NFF_pj4Mkx7gEzADXA.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">正向代理(左)与反向代理(右)。</figcaption></figure><h2 id="20c7" class="ky kz iq bd lt ng nh dn lx ni nj dp mb jy nk nl mf kc nm nn mj kg no np mn nq bi translated">正向代理</h2><p id="6c0e" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">转发代理是一种服务器，它代表一组明确定义的客户端向互联网上的任意服务器执行请求。</p><p id="cc95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，如果你正在使用一个转发代理，并且你从你的浏览器请求<a class="ae kl" href="http://google.com," rel="noopener ugc nofollow" target="_blank">http://google.com</a>/，那么你的浏览器本身不做这个请求，而是把它转发给转发代理。转发代理执行对<code class="fe km kn ko kp b">google.com</code>web服务器的请求，获取响应，并将该响应返回到您的浏览器。</p><p id="c9f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe km kn ko kp b">google.com</code>的网络服务器不知道这个请求最初来自你。它只能看到转发代理的IP地址作为请求的源IP地址，而看不到您的笔记本电脑的IP地址。因此，对于web服务器，看起来请求来自转发代理。</p><p id="7322" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，使用转发代理的一个常见用例是对web服务器隐藏您的IP地址。</p><h2 id="2d97" class="ky kz iq bd lt ng nh dn lx ni nj dp mb jy nk nl mf kc nm nn mj kg no np mn nq bi translated">反向代理</h2><p id="351d" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">反向代理是一种服务器，它通过互联网接收来自任意客户端的请求，并将这些请求转发给一组定义明确的服务器之一。</p><p id="7c06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，如果你有一个反向代理在你的网站<code class="fe km kn ko kp b"><a class="ae kl" href="http://mydomain.com" rel="noopener ugc nofollow" target="_blank">http://mydomain.com</a></code>的web服务器前运行，那么任何对<code class="fe km kn ko kp b">http://mydomain.com</code>的请求实际上都是由你的反向代理接收，而不是由你的web服务器接收。然后，反向代理将这个请求转发到您的web服务器，web服务器处理它，将响应返回给您的反向代理，反向代理将响应返回给客户端。</p><p id="b646" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">发出请求的客户机不知道它实际上是在与一个反向代理交互，而不是直接与您的web服务器交互。</p><p id="c39d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">反向代理的一个常见用例是让它处理某些任务，这样反向代理背后的应用服务器就不需要处理这些任务。这种任务的一个例子是处理<strong class="jp ir"> TLS </strong>网络层(例如，实现HTTPS)。这就是我们在这篇文章中要做的。</p><p id="b8bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">反向代理也可用于<strong class="jp ir">负载平衡</strong>。例如，如果您的反向代理后面有多个web服务器为同一个网站服务，那么反向代理可以在这些web服务器上平均分配传入的请求，从而降低单个web服务器过载的风险。</p><h1 id="0fa3" class="ls kz iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">获取TLS服务器证书</h1><p id="3077" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">为了使用HTTPS，我们需要为要用于我们的web服务器的域获取一个公钥证书。但要做到这一点，我们首先需要了解HTTPS到底是什么。</p><h2 id="c2b7" class="ky kz iq bd lt ng nh dn lx ni nj dp mb jy nk nl mf kc nm nn mj kg no np mn nq bi translated">什么是HTTPS？</h2><p id="9334" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">HTTPS可以重新表述为<strong class="jp ir">“通过TLS的HTTP”</strong>。TLS代表<strong class="jp ir">传输层安全</strong>，是一个加密网络协议层，可以插在网络协议栈的传输层(如TCP)和应用层(如HTTP)之间。下图说明了这一点:</p><figure class="kq kr ks kt gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nr"><img src="../Images/3de698b83f8934b1158818b1e6ac8d0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T3OY7OS-A5lrtUZAsmXFZg.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">HTTP(左)与HTTPS(右)协议栈。</figcaption></figure><p id="8afd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ns">注意:你可能经常听到术语SSL(安全套接字层)。事实上，术语SSL经常与TLS互换使用，但这是错误的。SSL是TLS的前身协议，现在已被弃用。</em></p><p id="bab4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，如果单独使用HTTP，我们就说HTTP。如果在TLS之上使用HTTP，我们就谈论HTTPS。更详细地说，如果我们使用HTTP，那么HTTP层以纯文本的形式将消息向下传递到TCP层(接收消息时也是同样的方式)。另一方面，如果我们使用HTTPS，那么HTTP层将纯文本消息传递给TLS层，TLS对这些消息进行加密，并将它们作为密文传递给TCP(接收消息时也是同样的方式)。</p><p id="222c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TLS使用对称加密算法来加密邮件。该算法以及对称密钥在初始握手期间在客户端和服务器之间进行协商。对称加密提供了通信的<strong class="jp ir">机密性</strong> <em class="ns"> </em>。</p><p id="1636" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了保密性，TLS还提供<strong class="jp ir">服务器</strong> <strong class="jp ir">认证</strong>。这意味着服务器(例如web服务器)必须向客户端(例如浏览器)证明其身份。这是通过公钥加密和TLS服务器证书来完成的。我将在下一节解释这是如何工作的。</p><p id="6dd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TLS还定义了<strong class="jp ir">客户端认证</strong>。这意味着客户端(例如浏览器)必须通过TLS客户端证书向服务器(例如web服务器)证明其身份。然而，这一功能在实践中很少使用。</p><h2 id="2866" class="ky kz iq bd lt ng nh dn lx ni nj dp mb jy nk nl mf kc nm nn mj kg no np mn nq bi translated">TLS服务器身份验证</h2><p id="2f8c" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">想要向其客户端验证自身身份的服务器需要有一个私钥和一个公钥，以及一个公钥证书。在与客户机连接时，客户机向服务器发送一个所谓的质询，即一段任意的数据，并请求服务器用服务器的私钥加密这段数据。</p><p id="457b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，服务器将加密的质询连同服务器证书一起发送回客户端。然后，客户端用服务器的公钥(在证书中)解密加密的质询。如果解密成功，客户端就知道它正在与之对话的服务器确实是证书中列出的主体。这是因为只有<em class="ns">这个</em>主体应该拥有与证书中的公钥相对应的私钥。</p><h2 id="2b2a" class="ky kz iq bd lt ng nh dn lx ni nj dp mb jy nk nl mf kc nm nn mj kg no np mn nq bi translated">什么是公钥证书？</h2><p id="f430" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">下面是对公钥加密的简短介绍。它解释了证书如何工作，包括<strong class="jp ir">信任链</strong>和<strong class="jp ir">根证书</strong>的概念。</p><p id="0bc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不想了解证书是如何运作的，只是想获得一个，可以直接跳转到<strong class="jp ir"> <em class="ns"> </em> </strong> <a class="ae kl" href="#8d39" rel="noopener ugc nofollow"> <strong class="jp ir"> <em class="ns">“如何获得证书？”</em> </strong> </a>。</p><p id="a125" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://en.wikipedia.org/wiki/Public_key_certificate" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">公钥证书</strong> </a> <strong class="jp ir"> </strong>是包含三条信息的文本文档:</p><ul class=""><li id="bfc7" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk nt lk ll lm bi translated">一个<strong class="jp ir">主题</strong>的描述(例如，一个个人、一家公司或一个由域名标识的网络服务器)</li><li id="bedd" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk nt lk ll lm bi translated">一个<strong class="jp ir">公钥</strong></li><li id="66fe" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk nt lk ll lm bi translated">可信第三方的<strong class="jp ir">数字签名</strong>，证明<strong class="jp ir">该公钥属于该主体</strong></li></ul><p id="a6cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上，证书所做的只是确认给定的公钥属于给定的主体。</p><p id="21e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">举个例子，如果一个subject叫做<em class="ns"> Google </em>，有一个公钥<em class="ns"> P </em>，那么对应的证书会说:“我确认公钥<em class="ns"> P </em>属于<em class="ns"> Google </em>”。</p><p id="86a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">证书的可信度依赖于确认证书内容的可信第三方的数字签名。该数字签名由证书的颁发者提供。证书的发行者被称为<a class="ae kl" href="https://en.wikipedia.org/wiki/Certificate_authority" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"/></a>认证机构。</p><figure class="kq kr ks kt gt mv gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/3b6a994c924b6ec6b70f8e18d0abaafd.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*sLMgHPS655XT2FY5LNxasA.png"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">由三个证书组成的信任链(在Chrome中查看)。自下而上:1)由加密认证中心颁发的域名证书。2)让我们加密由根证书颁发机构颁发的自己的证书。3)根证书机构的根证书。</figcaption></figure><p id="c346" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">文档的<a class="ae kl" href="https://en.wikipedia.org/wiki/Digital_signature" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">数字签名</strong> </a>通常只不过是用签名者的私钥加密的文档的散列。如果这个签名可以用签名者的公钥解密，那么我们知道这个签名一定是由这个签名者制作的，因为这个签名者是唯一可以访问这个私钥的主体。</p><p id="caec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当客户端验证服务器的证书时，它还必须验证该证书上CA的数字签名。如前所述，这是通过尝试用CA的公钥(众所周知)解密签名来实现的。但是现在客户机似乎又回到了起点:它有一个主题(CA)和一个公钥，该公钥声称是CA的公钥，但是没有证据证明这个公钥确实属于这个CA。</p><p id="05b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解决方案是另一个证书。即由另一个CA，比如说<em class="ns"> CA-2 </em>颁发的证书，该证书确认声称是第一个CA，比如说<em class="ns"> CA-1 </em>的公钥，实际上是<em class="ns"> CA-1的</em>公钥。此证书有<em class="ns"> CA-2 </em>的数字签名。但作为客户，我们仍不能止步于此。我们还必须核实该证书上<em class="ns"> CA-2 </em>的签名。为此，我们需要<em class="ns"> CA-2的</em>公钥(它是公开可用的)。现在，我们又有了一个主题(<em class="ns"> CA-2 </em>)和一个公钥，但是没有证据证明这个公钥真的属于<em class="ns"> CA-2 </em>。解决方案是…再一个证书。即由<em class="ns"> CA-3 </em>签发的证书，确认所讨论的公钥确实是<em class="ns"> CA-2 </em>的公钥。而且这个证书有<em class="ns"> CA-3 </em>的数字签名，我们反过来需要验证。</p><p id="9d12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图说明了这一过程:</p><figure class="kq kr ks kt gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nv"><img src="../Images/4bdd5c7d75bdbe5e03810be90c1f6a38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8s1BbwC86SCaQTtapmV4Ug.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">由三个证书组成的信任链，包括根证书。</figcaption></figure><p id="3df5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以看到，这产生了一个称为<a class="ae kl" href="https://en.wikipedia.org/wiki/Chain_of_trust" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">信任链</strong> </a> <strong class="jp ir">的证书链。理论上，信任链可以无限长，但实际上并非如此。典型的网站信任链由三到四个证书组成。</strong></p><p id="6c95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么信任链的终点在哪里呢？答案是用一个所谓的<a class="ae kl" href="https://en.wikipedia.org/wiki/Root_certificate" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">根证书</strong> </a>。根证书是其签名不需要验证的证书。特别是根证书是自签名的，也就是说，数字签名是由颁发证书的同一个CA制作的。</p><p id="40c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根证书是由根CA颁发的，根证书通常确认根CA声称是他们的公钥，实际上是根CA的公钥。而且这个确认不是别人做的，是root-CA自己做的。您可以在下图中看到，根证书的主题和颁发者是相同的。</p><figure class="kq kr ks kt gt mv gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/ea2a42dc570801d965e6f331c7a834bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*tO8mGQn7hvSucZygGOYnqQ.png"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">在一个根证书中，主体和签发者是相同的，签名也是由他们做出的。</figcaption></figure><p id="fb94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，我们如何信任根CA和根证书呢？答案是它们在人类术语下是可信的，而不是在密码术语下。根-CA受到监管并接受公众审查，根证书通常由浏览器和操作系统供应商精心挑选，并包含在他们的产品中。例如，在macOS上，您可以在“钥匙串访问”中看到受信任的根证书集(这些根证书也被Google Chrome使用):</p><figure class="kq kr ks kt gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nw"><img src="../Images/5f5a04623ebd702a3170813c3a13bd83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wxgfacf_Kx66iu0mTwiz9w.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">macOS上“钥匙串访问”中的根证书。</figcaption></figure><p id="f765" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种对信任链和根证书的探索只是为了提供信息。你通常不需要处理它。唯一的例外是，如果您必须验证系统不知道的根证书(例如，您的浏览器或操作系统)。在这种情况下，您必须在您的系统上安装这个根证书(当然，如果您信任它)。</p><p id="4123" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，你需要知道的是如何为你自己的域名获得一个证书，以便为你的网络服务器设置HTTPS。这是下一节的主题。</p><h2 id="8d39" class="ky kz iq bd lt ng nh dn lx ni nj dp mb jy nk nl mf kc nm nn mj kg no np mn nq bi translated">怎么拿证？</h2><p id="f814" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">那么，我们怎样才能得到一个公钥证书来设置詹金斯和HTTPS呢？一般来说，为了获得证书，你必须带着你的公钥和你自己(主体)的一些信息去证书颁发机构(CA)，请求CA为你创建一个证书(你做一个所谓的<a class="ae kl" href="https://en.wikipedia.org/wiki/Certificate_signing_request" rel="noopener ugc nofollow" target="_blank">证书签名请求</a>)。</p><p id="06a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CA随后会验证您确实是您所声称的那个人。如果成功，他们会创建您的证书并将其连同信任链中的所有证书(根证书除外)一起返回给您。也就是说，您不仅可以取回自己的证书，还可以取回CA的证书，以及签署该CA证书的CA的证书，等等。</p><p id="d8b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，大多数传统的ca都是商业实体，获得证书不是免费的。此外，证书签名请求是一个手动过程，可能需要很长时间才能完成。</p><p id="4341" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，有一个替代解决方案。</p><h2 id="cdb8" class="ky kz iq bd lt ng nh dn lx ni nj dp mb jy nk nl mf kc nm nn mj kg no np mn nq bi translated">免费的解决方案</h2><p id="9c3b" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated"><a class="ae kl" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">我们来加密</strong> </a> <strong class="jp ir"> </strong>是一个完全免费颁发证书的非营利性CA。此外，他们使用<a class="ae kl" href="https://en.wikipedia.org/wiki/Automated_Certificate_Management_Environment" rel="noopener ugc nofollow" target="_blank">自动证书管理环境(ACME) </a>协议，该协议自动化了身份验证和证书颁发过程。有了这个解决方案，获得证书不仅是免费的，而且只是几分钟的事情。</p><p id="b229" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从Let's Encrypt获取证书的推荐方式是使用ACME客户端的<a class="ae kl" href="https://certbot.eff.org/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">cert bot</strong></a><strong class="jp ir"/>。</p><p id="c0eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，我们希望使用该证书作为TLS服务器证书，通过我们的域名<code class="fe km kn ko kp b">jenkins.mydomain.com</code>访问HTTPS的Jenkins。在这种情况下，证书的主题将只是域名<code class="fe km kn ko kp b">jenkins.mydomain.com</code>，我们必须向Let's Encrypt证明我们是这个域名的所有者。</p><p id="031c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有这些都将由Certbot通过我们必须为该域创建的DNS记录来完全自动地完成。</p><p id="bf19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从Let's Encrypt获得Certbot证书的一般说明是这里的<a class="ae kl" href="https://certbot.eff.org/lets-encrypt/ubuntuxenial-other" rel="noopener ugc nofollow" target="_blank"/>。它基本上由以下步骤组成:</p><ol class=""><li id="ff31" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated">在您的DNS服务器上，为域名<code class="fe km kn ko kp b">jenkins.mydomain.com</code>创建一个CNAME或别名记录，指向您有权访问的主机。</li><li id="4c2d" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">登录到该主机并安装Certbot。</li><li id="6213" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">运行<code class="fe km kn ko kp b">certbot certonly</code>。</li></ol><p id="ffe1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！Certbot为您创建一个公钥/私钥对，通过DNS记录进行域所有权验证，并从Let's Encrypt获得主题<code class="fe km kn ko kp b">jenkins.mydomain.com</code>的公钥证书。</p><p id="809f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Certbot将证书保存在本地主机的以下目录中:</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="554f" class="ky kz iq kp b gy la lb l lc ld">/etc/letsencrypt/live/jenkins.mydomain.com</span></pre><p id="58fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">特别是，该目录将包含以下相关文件(以及其他一些不需要的文件):</p><ul class=""><li id="2d5c" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk nt lk ll lm bi translated"><code class="fe km kn ko kp b">fullchain.pem</code>:包含您的证书(不包括根证书)的信任链。</li><li id="6dd7" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk nt lk ll lm bi translated"><code class="fe km kn ko kp b">privkey.pem</code>:你的私钥。</li></ul><p id="1bb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些文件是你用NGINX反向代理为Jenkins设置HTTPS所需要的，下一节将会解释。</p><h1 id="c915" class="ls kz iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">在Docker中设置NGINX和Jenkins</h1><p id="2acd" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">我们有以下目标:</p><ul class=""><li id="03bf" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk nt lk ll lm bi translated">在Docker中运行Jenkins。</li><li id="7e1f" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk nt lk ll lm bi translated">和HTTPS一起去见詹金斯。</li><li id="b1ff" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk nt lk ll lm bi translated">通过反向代理处理HTTPS，让Jenkins使用默认的HTTP配置。</li></ul><p id="4804" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图说明了该解决方案的体系结构:</p><figure class="kq kr ks kt gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nx"><img src="../Images/79be11c5e62776b8e101208a8ba35180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5DqSdXw_RxLKGs1daWRVwA.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">在Jenkins Docker容器前面运行NGINX Docker容器，以便允许HTTPS访问Jenkins。</figcaption></figure><p id="a453" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们运行两个独立的Docker容器，一个使用NGINX，一个使用Jenkins。对于nginx，我们使用了<a class="ae kl" href="https://hub.docker.com/r/jwilder/nginx-proxy/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">jwilder/NGINX-proxy</strong></a><strong class="jp ir"/>容器，大大方便了容器内部NGINX反向代理的配置。</p><p id="2563" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">jwilder/nginx-proxy容器将nginx与<a class="ae kl" href="https://github.com/jwilder/docker-gen" rel="noopener ugc nofollow" target="_blank"> docker-gen </a>文件生成器结合起来。docker-gen是一个工具，它允许基于主机上运行的容器的元数据来创建文件。在jwilder/nginx-proxy容器的情况下，docker-gen能够为运行在同一容器中的nginx自动生成一个配置文件。</p><p id="a507" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些其他容器的元数据以环境变量的形式提供，这些变量由<code class="fe km kn ko kp b">docker run</code>命令的<code class="fe km kn ko kp b">-e</code>选项指定。用jwilder/nginx-proxy设置HTTPS的官方说明是<a class="ae kl" href="https://github.com/jwilder/nginx-proxy#ssl-support" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="0708" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，我们希望指示NGINX将所有对<code class="fe km kn ko kp b">jenkins.mydomain.com</code>的请求路由到Jenkins容器的端口8080(这是Jenkins监听的默认端口)。下面是启动Jenkins容器的命令:</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="931d" class="ky kz iq kp b gy la lb l lc ld">docker run \<br/>  -d \<br/>  --rm \<br/>  -u root \<br/>  -v /var/run/docker.sock:/var/run/docker.sock \<br/>  -v jenkins-data:/var/jenkins_home \<br/>  -v "$HOME":/home \<br/>  -e VIRTUAL_HOST=jenkins.mydomain.com \<br/>  -e VIRTUAL_PORT=8080 \<br/>  jenkinsci/blueocean</span></pre><p id="4944" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与正常运行Jenkins的主要区别是出现了<code class="fe km kn ko kp b">VIRTUAL_HOST</code>和<code class="fe km kn ko kp b">VIRTUAL_PORT</code>环境变量，它们允许jwilder/nginx-proxy容器中的docker-gen为nginx生成适当的配置文件。此外，上面的命令没有向主机发布任何端口(通常用<code class="fe km kn ko kp b">-p</code>选项来完成)，这是因为Jenkins将隐藏在NGINX反向代理后面，不需要处理任何对主机本身的外部请求。</p><p id="5c82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">jwilder/nginx-proxy容器需要我们在上一节中生成的证书和私钥。这些文件必须以某种方式命名，并通过<code class="fe km kn ko kp b">-v</code>选项传递给绑定挂载卷中的容器。</p><p id="9576" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，将最后一节中的<code class="fe km kn ko kp b">fullchain.pem</code>和<code class="fe km kn ko kp b">privkey.pem</code>复制到当前主机，并重命名为:</p><ul class=""><li id="abe4" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk nt lk ll lm bi translated"><code class="fe km kn ko kp b">fullchain.pem</code> → <code class="fe km kn ko kp b">jenkins.mydomain.com.crt</code></li><li id="eca8" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk nt lk ll lm bi translated"><code class="fe km kn ko kp b">privkey.pem</code> → <code class="fe km kn ko kp b">jenkins.mydomain.com.key</code></li></ul><p id="b7a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面，我将假设这些文件在本地主机的目录<code class="fe km kn ko kp b">/home/you/certs</code>中。</p><p id="c950" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦这些文件准备就绪，使用以下命令运行jwilder/nginx-proxy容器:</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="a5c1" class="ky kz iq kp b gy la lb l lc ld">docker run \<br/>  -d \<br/>  --rm \<br/>  -p 80:80 \<br/>  -p 443:443 \<br/>  -v /var/run/docker.sock:/tmp/docker.sock:ro \<br/>  -v /home/you/certs:/etc/nginx/certs \<br/>  jwilder/nginx-proxy</span></pre><p id="acf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！现在NGINX被正确配置为代表Jenkins处理HTTPS。</p><p id="0f11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您在浏览器中访问<code class="fe km kn ko kp b"><a class="ae kl" href="https://jenkins.mydomain.com/." rel="noopener ugc nofollow" target="_blank">https://jenkins.mydomain.com</a></code>，您应该会看到类似这样的内容:</p><figure class="kq kr ks kt gt mv gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/a2eaaa47c071473bb6590b928e3dbdab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FZ9G-WTdAUD5h9lBQjdfWA.png"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">HTTPS为詹金斯实现了一个NGINX反向代理。</figcaption></figure><p id="9c98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，在这个解决方案中，HTTP请求被自动强制到HTTPS。也就是说，如果有人请求<code class="fe km kn ko kp b">http://jenkins.mydomain.com</code>，该请求仍然被作为HTTPS处理(并出现在浏览器中，如上图所示)，这通常是一种期望的行为。</p></div></div>    
</body>
</html>