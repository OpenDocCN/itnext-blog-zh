<html>
<head>
<title>Scraping and Storing Crypto-currency Prices with Scala and PostgreSQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Scala和PostgreSQL抓取和存储加密货币价格</h1>
<blockquote>原文：<a href="https://itnext.io/scraping-and-storing-crypto-currency-prices-with-scala-and-postgresql-a6bb86a66f74?source=collection_archive---------3-----------------------#2019-08-26">https://itnext.io/scraping-and-storing-crypto-currency-prices-with-scala-and-postgresql-a6bb86a66f74?source=collection_archive---------3-----------------------#2019-08-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/></div><div class="ab cl jq jr hx js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="im in io ip iq"><p id="8d77" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">简介</strong></p><p id="69e3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">网络抓取大多涉及文本密集型任务，如产品评论抓取、收集房地产列表，甚至跟踪在线声誉和存在。当一个应用程序只抓取字符串数据类型进行定性分析时，它可能不需要类型安全。然而，如果web抓取的最终目标是对价格或天气预报进行定量分析，使用类型安全语言可能会非常方便。</p><p id="ef80" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在本文中，我们的目标是给出一个有趣的小例子，通过使用Scala并将其存储到PostgreSQL数据库中来获取加密货币的价格。为了降低价格，我们选择使用CoinMarketCap <a class="ae kv" href="https://coinmarketcap.com/" rel="noopener ugc nofollow" target="_blank">主页</a>。这是一个加密货币知识网站，也提供关于市场资本化(相对市场规模)、流通供应量和交易量的信息。尽管把所有这些信息放在一起看很有趣，但为了简单起见，我们将只讨论价格。</p><p id="9667" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这篇文章可能被认为是一个教程，它需要docker-compose和Scala的基础知识。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi kw"><img src="../Images/036237078a695a321ffb573372edcf88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XIv7wtoBBxf95mezwstG6Q.jpeg"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">本教程使用的管道的摘要</figcaption></figure><p id="1a58" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">工具和步骤</strong></p><p id="b52e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在Scala中进行web抓取时，我们将使用一个名为scala-scraper的HTML解析库和<strong class="jz iu"> JSoup </strong>。接下来，我们将使用一个名为<strong class="jz iu"> doobie </strong>的功能性JDBC工具，将刮出的价格插入PostgreSQL数据库。</p><p id="d8e7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">尽管我们提到了一些花哨的库和工具名称，但真正的魔力发生在case类中。对于对CoinMarketCap主页的每次调用，我们的目标是检索具有类型安全的长加密货币表。为此，我们创建了CoinCreate和CoinInsert case类以及配套对象。</p><p id="b89b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们将首先解释case类及其伴随对象，因为我们的目标是在创建它们的同时对数据建模。然后，我们将解释从主页检索更新的价格表的简单函数。最后，我们将解释如何将表记录插入到本地运行的PostgreSQL数据库中。我们可以用这个简单的<a class="ae kv" href="https://github.com/nazliander/scrape-insert-postgresql/blob/master/simple-tutorial/docker-compose-setup/docker-compose.yml" rel="noopener ugc nofollow" target="_blank"> docker-compose文件</a>来驱动数据库。在docker-compose文件中，我们用名称<code class="fe lm ln lo lp b">dev</code>、用户名<code class="fe lm ln lo lp b">admin</code>和密码<code class="fe lm ln lo lp b">admin</code>初始化了一个PostgreSQL数据库。</p><p id="79bc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">本教程中介绍的步骤显示在上面的管道中。</p><p id="9a88" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">案例类和伴随对象</strong></p><p id="ab31" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">尽管可能有不同的方法来建模数据，我们可以从创建两个case类开始，分别是<em class="lq"> CoinCreate </em>和<em class="lq"> CoinInsert </em>。这些将帮助我们在抓取价格表并插入数据库时保持数据类型的安全。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lr"><img src="../Images/4151cbdf85493276b22e42b5b9b988ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QEZWeKAqcfOVbnDkQtHUFg.png"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">来自CoinMarketCap主页价格表的视图</figcaption></figure><p id="1e49" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe lm ln lo lp b">CoinCreate</code>旨在安全地键入一对加密货币代码及其当前价格。因此，它有两个参数<code class="fe lm ln lo lp b">code</code>(指货币代码)和<code class="fe lm ln lo lp b">price</code>(美元现价)。然而，在考虑它的伴随对象时，我们需要考虑每行中价格记录的形状。例如，如果我们只考虑在我们的case类中使用硬币名称和价格，在一组记录中它们的索引将是<code class="fe lm ln lo lp b">1</code>和<code class="fe lm ln lo lp b">3</code>。这非常类似于表的列索引。</p><p id="14e4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">通过观察价格表(您可以从主页上找到一个截图)，我们决定使用一个伴随对象来拥有一个apply方法，用于将String List的输入函数转换为<code class="fe lm ln lo lp b">CoinCreate</code>。虽然这种转换并不那么简单，但是我们可以使用helper函数只获取硬币代码(<code class="fe lm ln lo lp b">getCoinCode</code>)并将美元价格字符串转换为double ( <code class="fe lm ln lo lp b">numberStringToDouble</code>)。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">CoinCreate case类及其伴随对象</figcaption></figure><p id="79aa" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe lm ln lo lp b">CoinInsert</code>旨在安全地键入一对加密货币代码、其当前价格和用于插入时间记录的日志时间戳。我们可以在PostgreSQL中插入一个向量<code class="fe lm ln lo lp b">CoinCreate</code>时使用这个case类。由于它的参数与<code class="fe lm ln lo lp b">CoinCreate</code>非常相似，我们可以创建一个简单的伴随对象来将<code class="fe lm ln lo lp b">CoinCreate</code>转换为<code class="fe lm ln lo lp b">CoinInsert</code>。这个对象的apply方法可以自然地将当前时间戳添加到一个<code class="fe lm ln lo lp b">CoinCreate</code>中以获得一个<code class="fe lm ln lo lp b">CoinInsert</code>。</p><p id="04f7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，<code class="fe lm ln lo lp b">CoinCreate</code>案例类和<code class="fe lm ln lo lp b">CoinInsert</code>案例类之间的唯一区别是当前的<code class="fe lm ln lo lp b">Timestamp</code>，标记为<code class="fe lm ln lo lp b">logTimestamp</code>参数。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">CoinInsert case类及其配套对象</figcaption></figure><p id="cc66" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">刮削功能</strong></p><p id="5d40" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">用<strong class="jz iu"> scala-scraper </strong>和<strong class="jz iu"> JSoup </strong>刮相当容易。首先，我们需要通过创建一个新的<strong class="jz iu"> JSoup </strong>浏览器来获得对主页的请求。一个新的浏览器可以从网上获取HTML。因为我们只需要HTML解析<strong class="jz iu"> JSoup </strong>就足够了，对于使用页面的Javascript，可以使用其他浏览器选项。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">获取请求功能</figcaption></figure><p id="89ad" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">通过使用GET请求，我们需要找到主表并将其存储为字符串向量。幸运的是，当我们指定要寻找一个表格元素时，<strong class="jz iu"> scala-scraper </strong>的<code class="fe lm ln lo lp b">table</code>方法为我们完成了所有工作。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">表格刮擦功能</figcaption></figure><p id="bdeb" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最后，我们需要对向量进行切片，从第二个索引开始直到最后几行，因为第一行包含列名(标题)。产生的切片向量仍将包含HTML元素为字符串的表行。因此，我们可以从函数式编程中受益，映射所有的表行(向量元素)，同时提取元素中的文本，然后转换为<code class="fe lm ln lo lp b">CoinCreate</code>(使用定制的apply函数很舒服)。</p><p id="d618" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">插入功能</strong></p><p id="6616" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">doobie 是Scala的一个令人惊叹的函数式JDBC层。它提供了一种编写任何JDBC程序的函数式方法。在本教程中，我们将保持简单，只编写一个连接<code class="fe lm ln lo lp b">Transactor</code>来连接本地PostgreSQL数据库，并编写一个插入函数来进行类型安全的事务。</p><p id="bc9b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了连接到数据库，我们需要使用一个<code class="fe lm ln lo lp b">Transactor</code>来声明驱动程序的类型(在我们的例子中是PostgreSQL驱动程序)、连接的URL、用户名、密码和执行上下文(EC)。交易者需要一个隐式的val来定义EC。对于非阻塞操作<strong class="jz iu"> doobie </strong>的<code class="fe lm ln lo lp b">Transactor</code>使用<code class="fe lm ln lo lp b">contextShift</code>。为了测试我们的代码，doobie文档推荐使用同步EC。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">用于建立JDBC连接器的处理器</figcaption></figure><p id="c07e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了编写逐行插入函数，我们可以使用SQL插值。该函数有一个输入<code class="fe lm ln lo lp b">CoinInsert</code>和一个输出<code class="fe lm ln lo lp b">Update0</code>(表示参数已知的参数化语句)。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">用doobie进行SQL插值</figcaption></figure><p id="82ad" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最后，我们可以通过使用<code class="fe lm ln lo lp b">getCoinUpdatedTable</code>函数来请求主页。这将返回一个字符串向量。</p><p id="8c49" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，我们可以使用这个向量(<code class="fe lm ln lo lp b">coinTable</code>)将<code class="fe lm ln lo lp b">CoinCreate</code>转换为<code class="fe lm ln lo lp b">CoinInsert</code> case类，并执行我们在上一步中准备的insert语句。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">完成所有抓取和插入工作的几行代码</figcaption></figure><p id="5fd2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">遗言</strong></p><p id="3246" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">多亏了<strong class="jz iu"> doobie </strong>，只需几行代码，我们就能从CoinMarketCap获取加密货币的价格，并将其插入本地PostgreSQL数据库。虽然代码完成了它的工作，但是现在，源代码可以用异常处理和监控来扩展。整个主类可以在下面找到。你可以在Github仓库中找到整个项目。</p><p id="5fd1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这篇短文中，我们旨在向web抓取介绍一些Scala概念。要了解更多关于数据工程的知识，你可以选择参加<a class="ae kv" href="https://www.linkit.nl/vacatures/data-engineering/0007529/data-engineering-apprenticeship-starts-feb-1st-2020" rel="noopener ugc nofollow" target="_blank">训练营</a>进行实践培训，做更多项目，阅读和分享更多内容。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="ls lt l"/></div></figure></div></div>    
</body>
</html>