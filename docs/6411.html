<html>
<head>
<title>Filter Architecture In Your Front-end Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">前端项目中的过滤器架构</h1>
<blockquote>原文：<a href="https://itnext.io/filter-architecture-in-your-front-end-project-6bd9108a8d7f?source=collection_archive---------3-----------------------#2021-11-09">https://itnext.io/filter-architecture-in-your-front-end-project-6bd9108a8d7f?source=collection_archive---------3-----------------------#2021-11-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/734c3fdcebb457f8c32f60b1469e01f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tOO04G24d1YU0zzZnmkGOQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@weareambitious?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">雄心勃勃的创意公司——Rick Barrett</a>拍摄于<a class="ae kc" href="https://unsplash.com/s/photos/net?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="53e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您从事一个中型到大型的项目时，您可能需要处理许多API请求和响应。您向后端服务器发送请求体，服务器返回响应。这是一种非常常见的获取数据的方式。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/2e892900bcf41dd30677866a0530ad3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q5rt6NhcEo_0aIy0xap_KQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">正常提取过程</figcaption></figure><p id="416f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在此过程中，有时您会注意到返回的响应可能包含不必要的数据，并且数据格式与您的前端项目标准不兼容或不一致。例如，不匹配的参数键、不同的命名约定、不同的对象格式等。而所有这些“未经过滤”的数据将成为一个无意的罪魁祸首，创造错误，增加你的技术债务。</p><p id="ffe7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，通常您会花时间不断调试和修复它，直到您的组件正确显示响应。但是，你想过为什么吗？为什么所有这些bug都会发生？为什么你一直在处理这件事？</p><p id="9a96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您在前端项目中已经有了一套代码标准，就意味着您有了一个遵循指南。您可以防止API响应弄乱您的代码。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lg"><img src="../Images/6e24ee597281921de3771d1467d752d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g3X6ay784N5-nQUiECowbQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">法国艾格-莫特斯城墙</figcaption></figure><p id="b6a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，想象你是这片土地的主人，你在城市的门口设置了一个检查站。你需要知道谁在穿过这个城市，他们只有在特定的权利和许可下才能进来。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lh"><img src="../Images/e261b494839b032208bff703886edfd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0qF59S9T1zCRgrAjTPKNHg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">过滤提取过程</figcaption></figure><p id="688a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，这里来了<strong class="kf ir">滤波器架构</strong>。它作为一个<strong class="kf ir">中网</strong>停留在请求&amp;获取API响应的进程之间。基本上，您将修改您的请求和响应主体，也可以在数据获取过程中将其称为<strong class="kf ir"> <em class="li">有效负载、</em> </strong>。</p><p id="cae1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当服务器返回响应数据时，您将根据您的要求过滤原始API数据。之后，将格式化的数据存储到Redux或项目上的任何其他状态管理位置。</p><blockquote class="lj lk ll"><p id="7ff8" class="kd ke li kf b kg kh ki kj kk kl km kn lm kp kq kr ln kt ku kv lo kx ky kz la ij bi translated"><strong class="kf ir"> <em class="iq">提醒一下，保存前过滤一下。</em>T15】</strong></p></blockquote><p id="a23e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，您使用<code class="fe lp lq lr ls b">camelCase</code>作为前端负载的键，但是后端接收<code class="fe lp lq lr ls b">snack_case</code>作为键。然后，在这种情况下，您将通过重命名键来格式化您的有效负载，以便符合后端要求。您可以考虑创建一个全局函数来执行这种逻辑变化。反之亦然，这同样适用于返回的API响应。您可以转换响应中的键名，使其与您的前端标准相匹配。因此，您的前端代码将始终保持其标准，以获得更好的可维护性、更容易的调试和更少的错误。</p><p id="9d43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除此之外，当您收到API返回的响应时，您还可以过滤掉不必要的数据。例如，您有一个由多个卡片组成的部分，这些卡片在您的页面中显示图书信息。每张卡片只显示书的名字、封面、作者和出版商。但是，API会返回冗余信息，如服务bean、作者注释、出版商注释等。所有这些不需要的信息都可以过滤掉，并在传递给你的卡组件之前重新格式化。</p><h2 id="b944" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated">过滤技巧</h2><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/4a376a27ed0b7c5783df9e2e1fd223c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VKAaoAMlFtMawJYMe4IXNw.jpeg"/></div></div></figure><p id="fd3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们以图书信息<em class="li">(上面提到的)</em>为演示案例。下面是一个使用<code class="fe lp lq lr ls b">map()</code>重命名键并删除书数组<em class="li"> </em>中不需要的数据的例子:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/795ecefdd359062837ed27ec11f3a5b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BYgtuE8JAr9qqcF-K0igbQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Visual Studio代码| <a class="ae kc" href="https://marketplace.visualstudio.com/items?itemName=AyakoSky.fluffy-theme" rel="noopener ugc nofollow" target="_blank">蓬松主题</a></figcaption></figure><p id="1b36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，您可以看到我只获取了卡组件所需的数据。然后，我使用<code class="fe lp lq lr ls b">get()</code>从原始数组中检索值。下面是<code class="fe lp lq lr ls b">get()</code>的工作原理:</p><pre class="lc ld le lf gt mo ls mp mq aw mr bi"><span id="2d41" class="lt lu iq ls b gy ms mt l mu mv">get(object, 'your object path, can be nested one', 'fallback value')</span></pre><p id="482b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果API数据在上面的任何键中传回空值，它将使用我默认分配的回退值。我在这里分配了一个空字符串。您可以根据需要指定任何默认的回退值。如果你明智地使用，这种方法有助于减少错误。更多信息，可以阅读<a class="ae kc" href="https://lodash.com/docs/4.17.15#get" rel="noopener ugc nofollow" target="_blank"> Lodash </a>的官方文档。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/be4b19806ff9a4413813bf33c8878f9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5F0m0SVSAwWzrok8rIAW9Q.png"/></div></div></figure><p id="b896" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读！如果你觉得这篇文章有帮助，请给我一些掌声！编码快乐&amp;干杯！</p></div></div>    
</body>
</html>