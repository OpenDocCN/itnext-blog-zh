# 反应式编程方式下的 C++贪吃蛇游戏

> 原文：<https://itnext.io/snake-game-on-c-in-the-reactive-programming-way-19310a73923a?source=collection_archive---------0----------------------->

大家好，欢迎来到现代 C++和反应式编程的世界=)

今天，我们将通过 SFML 和反应式编程范式(在 [ReactivePlusPlus](https://github.com/victimsnino/ReactivePlusPlus) 库的帮助下)创建一个简单的贪吃蛇游戏。(如果你不熟悉反应式编程，从这篇[文章](https://medium.com/@victimsnino/what-is-actually-reactive-programming-in-modern-c-part-1-base-929355ac2901?source=friends_link&sk=59986e68b0688469c65ca0c757bbfd89)或任何其他资源开始，因为这篇文章没有详细描述操作符，而是使用了它们。)

**注**:最终结果可以在 [github](https://github.com/victimsnino/ReactivePlusPlus/tree/main/src/samples/sfml/snake) 上找到。灵感来自[用反应流驯服蛇](https://blog.thoughtram.io/rxjs/2017/08/24/taming-snakes-with-reactive-streams.html) (RxJs 实现)

**剧透:-)**

![](img/f243ff4e10140edb4b75e08fbb7b62ee.png)

首先，我们需要做两件重要的事情:

1.  创建一个渲染游戏的窗口
2.  从此窗口处理事件。

第一点非常简单，所以让我们来探讨第二点:

# 处理事件

大多数图形库使用**事件**来通知用户代码关于窗口产生的一些事件。例如，请求关闭窗口的事件、鼠标移动、按键等。因此，这是任何游戏逻辑的主要部分——以某种方式处理事件。因此，在大多数情况下，主游戏循环如下所示:

简而言之，可以用下一种方式来描述:

*   outer while——这是一个帧循环——每次循环结束时，我们将渲染内容显示到显示器上→生成一个新的帧
*   在循环内部，首先，我们处理事件以对用户的输入做出反应，例如，对关闭应用程序的请求做出反应
*   然后我们需要画出整个场景
*   将内容显示到窗口(并完成框架)
*   清除下一帧的窗口内容(将与下一个“显示”一起显示)==开始新的一帧

这种方法也以完美的方式依赖于反应式编程范式。因此，让我们创建一个可观察对象，它将把从窗口获得的事件与当前事件一起发出。

我们来详细了解一下。我们创建了全局`run_loop` 调度器，它是我们游戏的“主游戏循环”调度器，用来调度主循环的动作。然后我们创建一个 observable，它使用这个调度器提交一个递归任务来发送一个关于新帧的事件，然后从窗口发送任何就绪事件并结束。然后，我们创建这样一个可观察对象，并将其发布给多个订户的多播值。

然后，我们需要显示窗口，直到用户请求关闭应用程序。在此之前，我们需要处理来自`run_loop`的事件:

这里我们订阅我们的可观察事件，只取“关闭”事件，取 1 个事件，当这样的事件发生时关闭窗口。由于我们只接受 1 个事件，第一个事件后`root_subscription`将被取消订阅。因此，我们可以使用它作为应用程序是否仍然活动的指示器，如果它是真的，我们可以从我们的运行循环中调度事件。

所以，基地“主游戏循环”准备好了，我们可以前进了。

现在让我们添加代码来清除窗口并在窗口中显示新内容。我们可以用下面的方法来做:

现在我们的窗口正在清除和显示每一帧！酷！现在我们可以开始实现与我们的蛇相关的主要游戏逻辑了！

# 核心游戏逻辑

Sooo…接下来我们需要实现什么？

1.  键盘事件的处理
2.  基于键盘事件的蛇身运动
3.  展示蛇
4.  苹果的产卵，展示它们
5.  如果苹果被吃了，蛇就会长大

让我们来落实这几点吧！会很有趣的！=)

## 键盘事件

键盘事件用于选择蛇的移动方向。只有几个键负责这个。因此，我们需要过滤掉所有不感兴趣的事件和按键，并将这些事件转换为 snake 方向。让我们从选择键盘事件开始:

因此，我们可以观察到`sf::Event::KeyEvent`，它会通知我们新的键盘事件(而且仅仅是关于它们！).现在我们需要将关键事件转换成我们未来蛇的方向。可以通过以下方式完成:

在这里，我们检查它是否是一个“原始”按键事件(没有按下任何修饰键),并且仅当它对我们的按键感兴趣时才映射到方向。由于我们的蛇必须移动，即使没有任何键被按下，我们强迫它从`initial_direction`开始。

让我们继续前进，实现与蛇的运动相关的核心逻辑！

## 蛇形运动

一般来说，蛇的移动逻辑是这样的:每隔一段时间，我们需要按照最后选择的方向移动蛇的身体。来实施吧！

这里我们做我们上面讨论的所有事情=)每隔 200 毫秒，我们采用通过键盘事件获得的最后一个方向，根据 snake 规则更新这个方向(下一个方向不能与上一个方向相反)，并“向前”移动 snake 身体。可观察的将做它直到蛇吃自己。我觉得看起来好简单好理解。=)

现在我们准备展示我们的蛇！

## 画蛇

为了正确显示对象，我们需要在每一帧上绘制它们。这意味着我们的行动取决于当前的潮流。在这个过程中，我们需要在最后一个位置画蛇。所以，让我们以下面的方式来制作我们的“游戏逻辑函数”:它将返回可绘制对象的可观察值，然后调用者将对此做一些事情(在我们的例子中显示到窗口)。

因此，我们只需将坐标向量转换为可绘制对象的可观察值，并将它们显示在窗口中。由于每一个新的帧，我们将提供新的对象的可观察性，我们使用`switch_on_next`来改变可绘制对象的底层来源。

这时，我们有了可以根据按键移动甚至吃掉自己的蛇(在这种情况下，游戏只是“停止”)。让我们给我们的蛇加点食物吧！=)

## 生成苹果

怎样才能生成苹果？我们可以用哪个事件来做这件事？我觉得应该是蛇位！为什么？因为当蛇和我们的苹果相交时，我们需要重新生成苹果的位置，让蛇变长。所以，让我们开始吧！

然后我们需要以某种方式把我们的苹果拉到窗口。为此，我们需要将它添加到我们的`drawable_objects`可观测值中。我们稍微修改一下。

哇！现在我们有了苹果，蛇甚至可以吃它！但是蛇的长度不变。让我们修理它！

## 让蛇变长

我们如何确定何时应该增加蛇的尺寸？有很多可能的方法，但最简单的是 next:当苹果的位置改变时，我们可以增加蛇的大小，因为只有当蛇吃它时才会发生这种情况。好的，但是我们需要做什么来改变蛇的大小呢？我们需要给可观察到的生成蛇的身体添加关于大小的信息。我们可以借助学科来做！Snake body 将订阅它以获取关于大小变化的事件，而 apple position observable 将向主题发送事件**。来实施吧！**

所以，我们对`move_snake`做了一点改变，使用蛇的长度，如果需要的话增加它的长度。现在我们的蛇吃苹果就长！太神奇了！

最后，我们用反应式编程的方式实现了一个简单的游戏。很可能，从代码点的大小来看，它不是最简单的解决方案，但至少它是可以理解的，并且是线性的:我们构建对事件做出反应的数据流，没有复杂的分支/循环逻辑，整个游戏逻辑是线性的。游戏最后的“核心”逻辑功能是:

## 最终结果:

![](img/f243ff4e10140edb4b75e08fbb7b62ee.png)

这都是为了今天！下一篇文章再见！=)