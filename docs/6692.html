<html>
<head>
<title>This is how Variadic Arguments could work in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这就是可变参数在C#中的工作方式</h1>
<blockquote>原文：<a href="https://itnext.io/this-is-how-variadic-arguments-could-work-in-c-e2034a9c241?source=collection_archive---------0-----------------------#2022-01-31">https://itnext.io/this-is-how-variadic-arguments-could-work-in-c-e2034a9c241?source=collection_archive---------0-----------------------#2022-01-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/db5cabe2aea1e7f6276b5dcbadcad6a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mcbnb1PKgyKXzUB2Frj66A.png"/></div></div></figure><p id="d881" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，C#的方法只能接受固定数量的参数，这在未来几年内几乎不会改变。这大大有助于语言保持简单！</p><p id="da09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是…我们热爱实验！让我们把变量论证变成一件事。最重要的是，我们要给他们一个<em class="kw">归纳</em>数学定义。</p><p id="6da6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">给不耐烦的人:<a class="ae kx" href="https://github.com/WhiteBlackGoose/InductiveVariadics" rel="noopener ugc nofollow" target="_blank"> github </a>。</p><h1 id="2deb" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">现在的方式是什么？</h1><h2 id="e0a1" class="lw kz iq bd la lx ly dn le lz ma dp li kj mb mc lm kn md me lq kr mf mg lu mh bi translated">关键字参数</h2><p id="2f4f" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">一个非常基本和古老的C#特性允许根据需要列出任意多的指定类型的参数:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/cdf801bde9440add022b20b568a765e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*U3B9GmoIPzuuApW7gLE4aQ.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">带有params关键字的函数示例</figcaption></figure><p id="6f82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是创建数组的语法糖:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/0febe5cf25fc3b5acbb15e3430215998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*i6JOh-iYj6ndns_X1PXf4g.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">脱糖</figcaption></figure><h2 id="8807" class="lw kz iq bd la lx ly dn le lz ma dp li kj mb mc lm kn md me lq kr mf mg lu mh bi translated">使超载</h2><p id="7108" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">这是一种经典的定义方法(或类型)的方式，方法(或类型)的参数数量有所不同。</p><p id="a93b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种“变通方法”的一个很好的例子是Func/Action委托，<a class="ae kx" href="https://source.dot.net/#System.Private.CoreLib/Function.cs,7a86aba051da82dd" rel="noopener ugc nofollow" target="_blank">在BCL:</a></p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/7e7dd5e1355d79cb85c4c85f001b3424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0MK5XeitVTMxke9R3IGGoQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">Func 委托的声明</figcaption></figure><p id="d06d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，我们也可以定义方法。</p><h1 id="9f5c" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">我们想要什么？</h1><p id="4dd3" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">我们希望能够根据需要处理任意类型的参数。在C++中，有一种模板语法，可以根据函数的用法在编译时生成一个新函数。</p><p id="8898" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将通过C# 9的源代码生成器使用类似的方法。我们将分析所使用的方法，并生成对基本方法和转换方法的适当调用链。它们是什么？让我来介绍下一部分吧！</p><h1 id="205c" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">归纳定义</h1><p id="7a51" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">别担心，这是一个非常简单的概念(我们说的是关于naturals的归纳)。基本上，归纳是一种在给定基础和从上一个状态到下一个状态的转换的情况下递归定义某物的方法。</p><h2 id="ce2a" class="lw kz iq bd la lx ly dn le lz ma dp li kj mb mc lm kn md me lq kr mf mg lu mh bi translated">问题示例</h2><p id="157e" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">假设我们需要Concat函数，它可以处理字符串、浮点数和整型数。它将创建一个字符串生成器，添加一个新的值，然后最终转换成字符串。</p><h2 id="bb4c" class="lw kz iq bd la lx ly dn le lz ma dp li kj mb mc lm kn md me lq kr mf mg lu mh bi translated">基础</h2><p id="4ee8" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">首先，让我们定义一下这一切是从什么开始的。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/c7c85c85843935e9f627d337d744e32d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G9FzX4eTKYLPPC1T4A9P9A.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">归纳定义的Concat的基底定义</figcaption></figure><p id="6d16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以不管有多少个元素，初始状态都是一个新的字符串生成器。数学上，f(0) = new StringBuilder()。</p><h2 id="4c08" class="lw kz iq bd la lx ly dn le lz ma dp li kj mb mc lm kn md me lq kr mf mg lu mh bi translated">从先前状态到新状态的转换</h2><p id="9108" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">现在假设我们已经讨论了N个论点。我们想定义函数到N + 1的转移。</p><p id="a647" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们想为int，string和float定义它。所以我们来定义三个过渡！</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/5c9874216aea1de250bb08fe8d626d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KBF_0XzW_rvoURfV9XA3NA.png"/></div></div></figure><p id="dc53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的“折叠”基本上是f(N)，而我们想要定义f(N + 1)。</p><p id="fd6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">数学上我们定义F(N + 1) = F(N)。Append(值[N + 1])。</p><p id="9523" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以如果我们展开这些转换，我们得到</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/54ab8b4f3082232d1515544f64998e9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CCXvCZ0dxnqrpYoTk6wytw.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">展开的过渡</figcaption></figure><h2 id="6966" class="lw kz iq bd la lx ly dn le lz ma dp li kj mb mc lm kn md me lq kr mf mg lu mh bi translated">定稿</h2><p id="2601" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">归纳部分结束了，所以这里的终结只是为了方便我们这些编码者。有人打算用StringBuilder做什么？</p><p id="05ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是我们最终确定的原因:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/6441da85106ea961877aa3308442306e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KTR5dI8nEUHjxXJ7h5zLDw.png"/></div></div></figure><p id="fb33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">瞧。我们通过归纳递归地定义了Concat。根据函数式编程，我们将其左折叠。</p><h1 id="e138" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">它是如何工作的？</h1><p id="8b18" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">对于上面的例子，让我们考虑这个调用:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/41ac0cb85533be6891b3aa734276ac0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*fotTueP6aqnqirTAvYHFNw.png"/></div></figure><p id="3567" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它是一个<strong class="ka ir"> int </strong>，然后是一个<strong class="ka ir"> float </strong>，然后是一个<strong class="ka ir"> string </strong>，然后又是一个<strong class="ka ir"> float </strong>。</p><p id="0170" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是我们的源生成器(SG)为它生成的内容:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/c8969a176ad18223bbcb52724c89a8f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pNknlbA4nDyvDeuTT_CTAg.png"/></div></div></figure><p id="c893" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这正是我们调用它的方式，注意它是如何使用归纳法的:它通过调用我们的基类方法来创建基类，然后执行所有保持“状态”的转换，最后完成它。</p><h1 id="7bc2" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">通用归纳变量</h1><p id="8e52" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">以上版本适用于重载。现在让我们把它通用化。我们将打印每个值，并对它们的大小求和。</p><p id="2ee3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们有一个通用的重载，而不是有限数量的重载:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/71ae5f414a03c6a1e2153dea690a309f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bX1pvBkE0vRzgeIbaOxWmQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">计算大小并打印每个值的函数定义</figcaption></figure><p id="fd10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是我们的SG为三个参数生成的内容:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/e9db63ec351387d68f55ff9463f256ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8XToaV_WqEicCnqfUZ104A.png"/></div></div></figure><h1 id="e7ed" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">源生成器是如何工作的</h1><p id="0dff" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">不幸的是，我省略了文章的这一部分。我不是SG专家，那才是应该写SG:专家的人。代码在<a class="ae kx" href="https://github.com/WhiteBlackGoose/InductiveVariadics/blob/main/InductiveVariadics.SourceGenerator/SourceGenerator.cs" rel="noopener ugc nofollow" target="_blank">这里</a>可用，它不处理许多情况(例如一般约束)并且用旧的。NET 5 SG API。</p><p id="c3f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本上，我的想法是找到该方法的所有用法，对于每个唯一的用法，我都基于base、transition和finalization方法的名称生成一个适当的重载，这些方法都具有BaseOf、TransitionOf和FinalizationOf属性。</p><h1 id="c808" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">灵感</h1><p id="de6a" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated"><a class="ae kx" href="https://github.com/FiniteReality" rel="noopener ugc nofollow" target="_blank">有限性</a>首先使<a class="ae kx" href="https://github.com/FiniteReality/VariadicGenerics" rel="noopener ugc nofollow" target="_blank">可变泛型</a>。它的工作方式不是归纳定义，而是从生成的方法中调用每个“基本”方法。</p><p id="11ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以在那个实现中，你的每个基类方法不“知道”其他参数，它只为一个参数工作。</p><p id="a300" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于变量日志记录或打印，或者更多，它可能会变得很方便，但是没有我在本文中展示的那么通用。</p><p id="32ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那个项目启发我做了一个更高级的变量论证的归纳版本。</p><h1 id="920e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="4b8c" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">所以这里我们考虑了一种简单的方法来定义和使用varargs，就像在C++中使用它们一样。</p><p id="b5bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">整个想法是，我们通过基于第N + 1个参数定义N + 1个参数的函数和N个参数的函数值来收集所有参数的状态。</p><p id="5267" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它的用途可能是减少使用params object[]造成的性能影响和类型不安全性，同时保持一个好的API和定义可变函数的简单方法。</p><p id="f31e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您的关注！我的<a class="ae kx" href="https://github.com/WhiteBlackGoose" rel="noopener ugc nofollow" target="_blank"> github </a>，<a class="ae kx" href="https://twitter.com/WhiteBlackGoose" rel="noopener ugc nofollow" target="_blank"> twitter </a>。</p></div></div>    
</body>
</html>