<html>
<head>
<title>Introducing Saturn-GQL: An Opinionated Way to Develop GraphQL API’s</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍Saturn-GQL:开发GraphQL API的自以为是的方法</h1>
<blockquote>原文：<a href="https://itnext.io/introducing-saturn-gql-an-opinionated-way-to-develop-graphql-apis-d99bf4d0790e?source=collection_archive---------3-----------------------#2018-04-04">https://itnext.io/introducing-saturn-gql-an-opinionated-way-to-develop-graphql-apis-d99bf4d0790e?source=collection_archive---------3-----------------------#2018-04-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3df9b4410841e1aa35b2cc2b4ee2f7b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bAFKrtqovmv99qrJ_rdW4g.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://en.wikipedia.org/wiki/Apollo_17" rel="noopener ugc nofollow" target="_blank">阿波罗17号</a>T3】土星五号火箭由不知名的NASA雇员拍摄，由基普·蒂格扫描—<a class="ae kc" href="http://www.hq.nasa.gov/alsj/a17/images17.html" rel="noopener ugc nofollow" target="_blank">http://www.hq.nasa.gov/alsj/a17/images17.html</a>(图片编号KSC-72PC-589)直接链接:<a class="ae kc" href="http://www.hq.nasa.gov/alsj/a17/ap17-KSC-72PC-589.jpg" rel="noopener ugc nofollow" target="_blank">http://www.hq.nasa.gov/alsj/a17/ap17-KSC-72PC-589.jpg</a>，公共领域，<a class="ae kc" href="https://commons.wikimedia.org/w/index.php?curid=452085" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/w/index.php?curid=452085</a></figcaption></figure><blockquote class="kd ke kf"><p id="326a" class="kg kh ki kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">TL；DR: Saturn-GQL提供了一个接口来帮助你组织你的GraphQL端点。它是一个自以为是的库，在你的GraphQL API中实施模块化。它利用了GraphQL模式语言，这使得它非常适合利用Apollo graphql-tools库的项目。</p></blockquote></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><blockquote class="kd ke kf"><p id="eb39" class="kg kh ki kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><a class="ae kc" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fintroducing-saturn-gql-an-opinionated-way-to-develop-graphql-apis-d99bf4d0790e%3Futm_source%3Dmedium_sharelink%26utm_medium%3Dsocial%26utm_campaign%3Dbuffer" rel="noopener ugc nofollow" target="_blank">点击这里在LinkedIn上分享这篇文章</a></p></blockquote><p id="6c03" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lm kt ku kv ln kx ky kz lo lb lc ld le ij bi translated">GraphQL已经迅速成为创建API的头号工具。与旧的方式相反，客户机能够指定它想要接收什么数据，这有助于开创软件开发的新时代。有了理解客户机请求的能力，服务器现在可以限制它查询的数据，从而提高性能。但是这篇文章不是关于GraphQL的。它是关于让GraphQL成为一个充满活力的生态系统的工具。</p><p id="e5ac" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lm kt ku kv ln kx ky kz lo lb lc ld le ij bi translated">正如开源领域最好的想法一样，围绕GraphQL及其参考实现已经创建了一个充满活力的工具生态系统。Apollo(由Meteor Development Group创建)是一家将自己定位为GraphQL生态系统中开源工具和付费产品的首选目的地的公司。</p><p id="b3b1" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lm kt ku kv ln kx ky kz lo lb lc ld le ij bi translated"><code class="fe lp lq lr ls b">graphql-tools</code>就是这样一个开源库。它来自Apollo，是一种构建GraphQL模式的自以为是的方法。它允许将业务逻辑(如何查询数据存储和返回数据)从GraphQL模式定义中分离出来(例如，如何进行变异、查询、自定义标量等..是在GraphQL中定义的)。</p><p id="7c28" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lm kt ku kv ln kx ky kz lo lb lc ld le ij bi translated">在我工作的开源团队中，我们开发并开源了<a class="ae kc" href="https://github.com/electric-it/saturn-gql" rel="noopener ugc nofollow" target="_blank"> Saturn-GQL </a>，它建立在阿波罗<code class="fe lp lq lr ls b">graphql-tools</code>提出的想法之上。<strong class="kj ir"> Saturn-GQL提供了一个自以为是但非常简单的接口来生成GraphQL模式</strong>。只需将包含GraphQL端点的顶级目录传递给它(后面的例子)，并在另一端获得一个用GraphQL模式语言编写的完全充实的模式。例如，这可以传递给<code class="fe lp lq lr ls b">graphql-tools</code>中的<code class="fe lp lq lr ls b">makeExecutableSchema</code>工具，通过您的HTTP服务器提供服务。</p><p id="fe9f" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lm kt ku kv ln kx ky kz lo lb lc ld le ij bi translated">正如我提到的，Saturn-GQL是创建GraphQL API的一种自以为是的方式。如果您在一个大型团队中工作，或者有跨项目团队，那么利用像Saturn-GQL这样有主见的库可以减少总的开发时间，并且可以为项目的新(内部)队友提供一个更平滑、更有效的入门过程。让我们看一个简单的例子。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="99fd" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lm kt ku kv ln kx ky kz lo lb lc ld le ij bi translated">首先，用<code class="fe lp lq lr ls b">npm install saturn-gql</code>安装土星-GQL</p><p id="e745" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lm kt ku kv ln kx ky kz lo lb lc ld le ij bi translated">下面展示了一个示例目录结构，它将作为GraphQL API服务器的基础。</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="7caa" class="mb mc iq ls b gy md me l mf mg">myapp<br/>|___ src/<br/>  |___ app.js<br/>  |___ api/<br/>    |___ users/<br/>      |___ index.js<br/>      |___ type.js<br/>      |___ queries.js<br/>      |___ mutations.js<br/>      |___ resolvers.js<br/>    |___ teams/<br/>      |___ index.js<br/>      |___ type.js<br/>      |___ queries.js<br/>      |___ mutations.js<br/>      |___ resolvers.js<br/></span></pre><p id="bf16" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lm kt ku kv ln kx ky kz lo lb lc ld le ij bi translated">这里是固执己见的部分。为了使用Saturn-GQL，上面目录结构中列出的文件必须具有类似于下面代码示例<a class="ae kc" href="#c8d2" rel="noopener ugc nofollow"> </a>的内部结构。我们将创建上面的<code class="fe lp lq lr ls b">users</code>集合的示例实现。</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="24ca" class="mb mc iq ls b gy md me l mf mg">################<br/># type.js<br/>################</span><span id="0ca3" class="mb mc iq ls b gy mh me l mf mg">export const type = `<br/>  type User {<br/>    id: Int!<br/>    firstName: String<br/>    lastName: String<br/>  }<br/>`;<br/><br/>export const typeQuery = `<br/>  users: [User]<br/>  getUser(id: Int!): User<br/>`;<br/><br/>export const typeMutation = `<br/>  addUser(newUser: User!): User<br/>`;</span></pre><p id="6dc5" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lm kt ku kv ln kx ky kz lo lb lc ld le ij bi translated">现在已经定义了您的类型，我们可以创建包含应用程序业务逻辑的文件。</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="02dd" class="mb mc iq ls b gy md me l mf mg">################<br/># queries.js<br/>################</span><span id="7b8d" class="mb mc iq ls b gy mh me l mf mg">export const queries = {<br/>  users(_) { return database.getUsers(); },<br/>  getUser(_, { id }) { return database.getUserById(id); },<br/>};</span></pre><p id="dfe9" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lm kt ku kv ln kx ky kz lo lb lc ld le ij bi translated">下面是一个示例<code class="fe lp lq lr ls b">mutations.js</code>文件:</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="4826" class="mb mc iq ls b gy md me l mf mg">################<br/># mutations.js<br/>################</span><span id="8486" class="mb mc iq ls b gy mh me l mf mg">export const mutations = {<br/>  addUser(_, { user }) =&gt; {<br/>    if (!user) {<br/>      throw new Error('Can\'t create user with empty user object');<br/>    }<br/>    const newUser = database.createUser(user);<br/>    return newUser;<br/>  },<br/>};</span></pre><p id="2a8d" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lm kt ku kv ln kx ky kz lo lb lc ld le ij bi translated">在每个集合中有一个创建自定义解析器的选项，但是为了简洁，我将只留下一个到官方Saturn-GQL文档的链接。最后只需将其全部导出到index.js文件中。<strong class="kj ir">index . js文件导出的项目的命名很重要</strong>。如果它们的名字和下面的不一样，土星将不会像预期的那样工作。就像我说的，<a class="ae kc" href="https://github.com/electric-it/saturn-gql/blob/master/src/index.js#L26" rel="noopener ugc nofollow" target="_blank">它非常固执己见</a>。</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="f3d4" class="mb mc iq ls b gy md me l mf mg">################<br/># index.js<br/>################</span><span id="1624" class="mb mc iq ls b gy mh me l mf mg">import { type, typeMutation, typeQuery } from './type';<br/>import { queries } from './queries';<br/>import { mutations } from './mutations';</span><span id="57cc" class="mb mc iq ls b gy mh me l mf mg">export {<br/>  type,<br/>  typeMutation,<br/>  typeQuery,<br/>  queries,<br/>  mutations,<br/>};</span></pre><p id="7a20" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lm kt ku kv ln kx ky kz lo lb lc ld le ij bi translated">所以现在你要做的就是创建一个新的<code class="fe lp lq lr ls b">Saturn</code>对象并运行<code class="fe lp lq lr ls b">makeSchema()</code>。然后你可以把它从<code class="fe lp lq lr ls b">graphql-tools</code>传递给<code class="fe lp lq lr ls b">makeExecutableSchema()</code>函数…</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="7bb6" class="mb mc iq ls b gy md me l mf mg">import Saturn from 'saturn';<br/>const saturn = new Saturn(`${__dirname}/api`);</span><span id="abc4" class="mb mc iq ls b gy mh me l mf mg">// Graphql Schema<br/>const schema = makeExecutableSchema(saturn.makeSchema());</span><span id="e9fb" class="mb mc iq ls b gy mh me l mf mg">export default schema;</span></pre><p id="2c1d" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lm kt ku kv ln kx ky kz lo lb lc ld le ij bi translated">…您就可以愉快地构建GraphQL API了！然后，您可以将它导入到Apollo express-graphql服务器，或者您计划为graphql端点提供服务的服务器。</p><p id="e5b5" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lm kt ku kv ln kx ky kz lo lb lc ld le ij bi translated">希望你喜欢我们的新图书馆！就像我上面提到的，这是一种非常固执的实现GraphQL的方式，当然也不是唯一的方式。Saturn-GQL只是为GraphQL生态系统增加价值的众多包中的一个。它的开发是为了帮助我们促进不同开发团队之间的合作和理解，同时快速加入新的团队成员。我们希望它也能为你的团队做同样的事情！</p><p id="ceb2" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lm kt ku kv ln kx ky kz lo lb lc ld le ij bi translated">谢谢你坚持到现在。我们对扩大和扩展功能持开放态度，所以请随意<a class="ae kc" href="https://github.com/electric-it/saturn-gql" rel="noopener ugc nofollow" target="_blank">提出拉请求</a>！</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="c8d2" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lm kt ku kv ln kx ky kz lo lb lc ld le ij bi translated"><a class="ae kc" href="#bf16" rel="noopener ugc nofollow"/><code class="fe lp lq lr ls b">mutations.js</code>和<code class="fe lp lq lr ls b">resolvers.js</code>文件是可选的，因为你并不总是需要一个目录中的变异或自定义解析器。</p></div></div>    
</body>
</html>