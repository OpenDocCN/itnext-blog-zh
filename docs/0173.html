<html>
<head>
<title>Pipeline Stormy Clouds into Sunny Clouds</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">把暴风雨的云变成晴朗的云</h1>
<blockquote>原文：<a href="https://itnext.io/an-emoji-lovers-guide-to-functional-programming-part-2-800b438c7ce3?source=collection_archive---------0-----------------------#2017-10-11">https://itnext.io/an-emoji-lovers-guide-to-functional-programming-part-2-800b438c7ce3?source=collection_archive---------0-----------------------#2017-10-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/340a0bbf86d5ec4926929328322c8f60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gvPr1Dhzh8XB2BckHqZkrQ.png"/></div></div></figure><h2 id="57e1" class="iz ja jb bd b dl jc jd je jf jg jh dk ji translated" aria-label="kicker paragraph">表情符号爱好者的函数式编程指南</h2><div class=""/><div class=""><h2 id="5d62" class="pw-subtitle-paragraph kh jk jb bd b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dk translated">数组映射、数组归约和使用管道的函数组合的高级用法</h2></div><p id="c074" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><em class="lv">用表情符号和JavaScript学习函数式编程。代码示例应该足够简单，不需要任何先验知识就可以理解，但是我可以想象它看起来有点奇怪。还有，JavaScript实际上不允许表情符号作为JavaScript变量名。出于这个原因，这些代码示例不会在没有修改的情况下运行。</em></p><ul class=""><li id="5d08" class="lw lx jb lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-1-241d8d4c9223" rel="noopener"> <em class="lv">用食物表情符号制作便便。</em>T15】</a></li><li id="4cf2" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-2-800b438c7ce3" rel="noopener"> <em class="lv">把暴风云变成晴朗的云。</em>T19】</a></li><li id="34ed" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-3-ef78e3156e" rel="noopener"> <em class="lv">用减速器建造独角兽！</em> </a></li><li id="f0f3" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-4-735c17ca4113" rel="noopener"> <em class="lv">现在是管道操作员！</em> </a></li><li id="cb51" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-5-a6bc3324a839" rel="noopener"> <em class="lv">为食肉动物过滤肉类。</em> </a></li><li id="7665" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-6-5c1d441d36af" rel="noopener"> <em class="lv">用归约器递归。</em> </a></li></ul></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="2c82" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们从上次的<code class="fe ms mt mu mv b">add</code>和<code class="fe ms mt mu mv b">subtract</code>方法开始:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="177f" class="ne nf jb mv b gy ng nh l ni nj">add = additive =&gt; item =&gt; item + additive<br/>subtract = subtractor =&gt; item =&gt; item - subtractor</span></pre><p id="3e91" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们谈到了使用多种<code class="fe ms mt mu mv b">map</code>语句来将我们的乌云变成晴朗的云:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="fe4a" class="ne nf jb mv b gy ng nh l ni nj">[⛅, 🌦️] = (<br/>    [🌩️, ⛈️️]<br/>    .map(subtract(⚡))<br/>    .map(add(☀️))<br/>)</span></pre><p id="3f85" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">但是你知道吗，我们可以通过加减法去掉一个<code class="fe ms mt mu mv b">map</code>:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="0760" class="ne nf jb mv b gy ng nh l ni nj">addSun = add(☀️)<br/>removeLightning = subtract(⚡)</span><span id="8340" class="ne nf jb mv b gy nk nh l ni nj">[⛅, 🌦️] = (<br/>    [🌩️, ⛈️️]<br/>    .map(item =&gt; (<br/>        removeLightning(<br/>            addSun(item)<br/>        )<br/>    )<br/>)</span></pre><p id="6da7" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们为什么要这么做？我们可以保持我们的两个<code class="fe ms mt mu mv b">map</code>声明，每个人都会很高兴！通常，这就是你要做的，但是在某些情况下，你可能需要不同的方式来使用<code class="fe ms mt mu mv b">compose</code>或者<code class="fe ms mt mu mv b">pipe</code>来链接。它们执行完全相同的功能，除了<code class="fe ms mt mu mv b">pipe</code>以类似于<a class="ae mf" href="https://en.wikipedia.org/wiki/Polish_notation" rel="noopener ugc nofollow" target="_blank">波兰符号</a>的相反顺序接受参数:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="7189" class="ne nf jb mv b gy ng nh l ni nj">compose = (second, first, item) =&gt; second(first(item))</span><span id="800b" class="ne nf jb mv b gy nk nh l ni nj">pipe = (item, first, second) =&gt; second(first(item))</span></pre><p id="ca44" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">通常这些返回函数不是直接取<code class="fe ms mt mu mv b">item</code>:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="1f1d" class="ne nf jb mv b gy ng nh l ni nj">compose = (second, first) =&gt; item =&gt; second(first(item))</span><span id="faef" class="ne nf jb mv b gy nk nh l ni nj">pipe = (first, second) =&gt; item =&gt; second(first(item))</span></pre><p id="dbb3" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们将使用<code class="fe ms mt mu mv b">pipe</code>作为例子，因为它通过从左向右阅读降低了复杂性。</p><p id="0b61" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">让我们假设我们需要微优化我们的代码，两个地图太多了。如果我们想把它放到一张地图上，我们需要组合我们的函数。正如我们在前面的例子中看到的，这可能会很快变得很糟糕！编写一个简化的<code class="fe ms mt mu mv b">pipe</code>函数，我们可以完成我们的目标并保持代码整洁:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="3fc5" class="ne nf jb mv b gy ng nh l ni nj">pipe = (first, second) =&gt; item =&gt; second(first(item))</span><span id="37a8" class="ne nf jb mv b gy nk nh l ni nj">[⛅, 🌦️] = [🌩️, ⛈️️].map(pipe(subtract(⚡), add(☀️)))</span></pre><p id="df27" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">既然我们已经弄清楚了<code class="fe ms mt mu mv b">pipe</code>的基础，我们需要写一个真正的。这意味着我们必须能够给<code class="fe ms mt mu mv b">pipe</code>无限多的函数，让它按顺序调用。</p><p id="1901" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">从功能上来说，使用<code class="fe ms mt mu mv b">reduce</code>很简单，但是如果不了解基础知识，这很难推理。让我们从程序上来看:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="58d7" class="ne nf jb mv b gy ng nh l ni nj">item = null</span><span id="1f57" class="ne nf jb mv b gy nk nh l ni nj">updateItem = change =&gt; {<br/>    item = change(item)<br/>}</span><span id="45a1" class="ne nf jb mv b gy nk nh l ni nj">pipe = (...functions) =&gt; {<br/>    [item] = functions.splice(0, 1)<br/>    <br/>    for(let i = 0, l = functions.length; i &lt; l; i++) {<br/>        updateItem(functions[i])<br/>    }<br/>    <br/>    return item<br/>}</span><span id="c4e8" class="ne nf jb mv b gy nk nh l ni nj">⛅ = pipe(☁️, subtract(⚡), add(☀️))</span></pre><p id="c78f" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在这个例子中，没有闭包。我们首先直接传入云表情符号，然后添加我们的其他功能作为单独的参数。</p><p id="fe5f" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们在程序<code class="fe ms mt mu mv b">pipe</code>中做的第一件事是删除第一个参数。那将是我们的<code class="fe ms mt mu mv b">item</code>。我们将循环其余的函数，一个接一个地调用它们，并将<code class="fe ms mt mu mv b">item</code>更新为最新值，直到我们完成了返回修改后的<code class="fe ms mt mu mv b">item</code>的循环。相当混乱。</p><p id="2674" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这段代码有很多变异。我们正在创建<code class="fe ms mt mu mv b">item</code>，然后每次在代码中的其他地方循环时都改变<code class="fe ms mt mu mv b">item</code>的值，而<code class="fe ms mt mu mv b">updateItem</code>正在产生副作用。</p><p id="1221" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这里还有一个问题:<code class="fe ms mt mu mv b">splice</code>。这个函数使数组变异；取出一组值，并将剩余的值留在原始数组中。当然，当代码很小的时候，它现在是有意义的，但是当你添加更多的代码时，弄清楚<code class="fe ms mt mu mv b">item</code>和<code class="fe ms mt mu mv b">functions</code>数组的状态将变得更加困难。</p><p id="3b16" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">函数式编程不再需要突变和副作用。通过移除它们，我们最终写出了更易于单元测试和多线程的纯函数。眼下，出现bug的可能性很高。对于纯函数，这种可能性大大降低。</p><p id="1354" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">下面是同样的<code class="fe ms mt mu mv b">pipe</code>使用不变性、函数组合和<code class="fe ms mt mu mv b">reduce</code>。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="5cb1" class="ne nf jb mv b gy ng nh l ni nj">pipeReducer = (item, change) =&gt; change(item)</span><span id="6602" class="ne nf jb mv b gy nk nh l ni nj">pipe = (...functions) =&gt; {<br/>    [startingItem] = functions<br/>    <br/>    return (<br/>        functions<br/>        .slice(1)<br/>        .reduce(pipeReducer, startingItem)<br/>    )<br/>}</span><span id="5bc3" class="ne nf jb mv b gy nk nh l ni nj">⛅ = pipe(🌩️, subtract(⚡), add(☀️))</span></pre><p id="7b77" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">注意我们是如何使用<code class="fe ms mt mu mv b">slice</code>(不可变版本的<code class="fe ms mt mu mv b">splice</code>)的，这样我们就不必改变我们的函数数组。我们做的第一件事就是用解构的方法从<code class="fe ms mt mu mv b">functions</code>中抽出<code class="fe ms mt mu mv b">startingItem</code>。接下来，我们再次使用<code class="fe ms mt mu mv b">slice</code>，这一次除了第一项之外获取所有内容。然后，我们可以在较小的数组上运行<code class="fe ms mt mu mv b">reduce</code>,并对一个又一个返回值调用<code class="fe ms mt mu mv b">change(item)</code>。</p><p id="4918" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">当<code class="fe ms mt mu mv b">reduce</code>像<code class="fe ms mt mu mv b">map</code>一样遍历数组中的每个值时，每次迭代都会获得前一个值和当前值。主要区别是它最终返回任何类型的单个值。同样，如果你不给<code class="fe ms mt mu mv b">reduce</code>一个初始值，它将默认使用数组中的第一个值。这意味着我们可以进一步简化:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="042d" class="ne nf jb mv b gy ng nh l ni nj">pipeReducer = (item, change) =&gt; change(item)</span><span id="1e87" class="ne nf jb mv b gy nk nh l ni nj">pipe = (...functions) =&gt; functions.reduce(pipeReducer)</span><span id="c1b8" class="ne nf jb mv b gy nk nh l ni nj">⛅ = pipe(🌩️, subtract(⚡), add(☀️))</span></pre><p id="6705" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在看起来真的很棒！就像<code class="fe ms mt mu mv b">add</code>和<code class="fe ms mt mu mv b">subtract</code>一样，我们希望使用闭包，这样<code class="fe ms mt mu mv b">pipe</code>就可以生成新的函数。写管道有几种方法。一种是显式传递我们的起始项作为<code class="fe ms mt mu mv b">reduce</code>的初始值:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="b5e9" class="ne nf jb mv b gy ng nh l ni nj">pipe = (...functions) =&gt; startingItem =&gt; (<br/>    functions<br/>    .reduce(pipeReducer, startingItem)<br/>)</span></pre><p id="1c1f" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">另一种方法是将我们的<code class="fe ms mt mu mv b">startingItem</code>添加到一个数组中，并将<code class="fe ms mt mu mv b">concat</code>添加到我们的流水线函数中:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="a3f1" class="ne nf jb mv b gy ng nh l ni nj">pipe = (...functions) =&gt; startingItem =&gt; (<br/>    [startingItem]<br/>    .concat(functions)<br/>    .reduce(pipeReducer)<br/>)</span></pre><p id="7c85" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">你选择哪一个都没关系。对于纯函数，只要相同的输入总是得到相同的输出，您总是可以尽可能地重构内部函数。使用这两种方法中的任何一种，我们最终都会得到相同的结果:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="3743" class="ne nf jb mv b gy ng nh l ni nj">changeStormyToSunny = pipe(subtract(⚡), add(☀️))</span><span id="b0fa" class="ne nf jb mv b gy nk nh l ni nj">⛅ = changeStormyToSunny(☁️)</span></pre><p id="4288" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">作为一个主要的好处，我们突然有了可重复使用的天气变化代码！使用我们关于闭包、函数生成器和<code class="fe ms mt mu mv b">pipe</code>的知识，我们可以将double <code class="fe ms mt mu mv b">map</code>重构为一个单一的、可读的<code class="fe ms mt mu mv b">map</code>。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="7a3c" class="ne nf jb mv b gy ng nh l ni nj">add = additive =&gt; item =&gt; item + additive<br/>subtract = subtractor =&gt; item =&gt; item - subtractor</span><span id="0b83" class="ne nf jb mv b gy nk nh l ni nj">pipeReducer = (item, change) =&gt; change(item)<br/>pipe = (...functions) =&gt; startingItem =&gt; (<br/>    functions<br/>    .reduce(pipeReducer, startingItem)<br/>)</span><span id="cc95" class="ne nf jb mv b gy nk nh l ni nj">changeStormyToSunny = pipe(subtract(⚡), add(☀️))</span><span id="c9af" class="ne nf jb mv b gy nk nh l ni nj">[⛅, 🌦️] = [🌩️, ⛈️️].map(changeStormyToSunny)</span></pre><p id="ed21" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="lb jl">感受简单！</strong></p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h2 id="38ca" class="ne nf jb bd nl nm nn dn no np nq dp nr li ns nt nu lm nv nw nx lq ny nz oa jh bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-3-ef78e3156e" rel="noopener">点击这里进入第三部分！</a></h2><h1 id="af41" class="ob nf jb bd nl oc od oe no of og oh nr kq oi kr nu kt oj ku nx kw ok kx oa ol bi translated">更多阅读</h1><p id="b4c8" class="pw-post-body-paragraph kz la jb lb b lc om kl le lf on ko lh li oo lk ll lm op lo lp lq oq ls lt lu ij bi translated">如果您对与函数式编程相关的更多主题感兴趣，您应该看看我的其他文章:</p><ul class=""><li id="f12a" class="lw lx jb lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae mf" rel="noopener ugc nofollow" target="_blank" href="/how-to-safely-refactor-old-code-part-1-a1a853263fec">安全重构旧代码:第1部分</a></li><li id="21e8" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated">使用Redux的秘密:createNamespaceReducer</li><li id="c67f" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/using-redux-reducers-in-react-components-4e92985dd9cb" rel="noopener">在React组件中使用Redux还原剂</a></li><li id="7284" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/redux-observable-can-solve-your-state-problems-15b23a9649d7" rel="noopener"> Redux-Observable可以解决你的状态问题</a></li><li id="98bf" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/flicblog/flic-buttons-and-the-observable-customization-using-rxjs-2214bc53d407" rel="noopener"> RxJS和可观察的Flic按钮</a></li></ul></div></div>    
</body>
</html>