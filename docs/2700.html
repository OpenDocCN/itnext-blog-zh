<html>
<head>
<title>Essential JavaScript patterns (pt1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基本JavaScript模式(pt1)</h1>
<blockquote>原文：<a href="https://itnext.io/essential-javascript-patterns-pt1-f59a0e3c912e?source=collection_archive---------3-----------------------#2019-07-14">https://itnext.io/essential-javascript-patterns-pt1-f59a0e3c912e?source=collection_archive---------3-----------------------#2019-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/57cc507ce4ed0b423aa7d391a2e34ec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fgIJy-ZZ5g7YHKfYILX7zg.jpeg"/></div></div></figure><p id="1f7c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">设计模式是由比我们聪明得多的开发人员传递给我们的知识，我们可以用它来解决某些软件设计问题。它们帮助我们保持项目的可维护性和代码的优雅性。</p><p id="10a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个由两部分组成的系列中，我将介绍六种基本模式，它们可以帮助您在使用JavaScript开发时保持代码的可维护性。设计模式在很大程度上是由<a class="ae kz" href="https://en.wikipedia.org/wiki/Design_Patterns" rel="noopener ugc nofollow" target="_blank"> GoF </a>(四人帮)推广的。这里描述的这些模式的变体适应了JavaScript的多功能特性。</p><p id="be1a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是由两部分组成的系列文章的第一部分，我们将回顾工厂、代理和策略模式。</p><h1 id="97e7" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">工厂</h1><p id="11da" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">这是第一个也可以说是最容易掌握的模式。工厂模式在开发领域被广泛使用，归结为两个简单的概念:</p><ul class=""><li id="59e7" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">通过将对象初始化封装在一个名为“工厂”的函数中来抽象它。</li><li id="205f" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">让客户端使用工厂，而不是直接初始化对象。</li></ul><p id="fd53" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看一个例子:</p><p id="9db5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">想象一下我们有这样一个<code class="fe mr ms mt mu b">Pet</code>类:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0186" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以创建一个新的<code class="fe mr ms mt mu b">Pet</code>实例，如下所示:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="096b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">到目前为止一切顺利！但是如果我们决定将允许的物种仅限于猫和狗呢？这意味着我们必须修改<code class="fe mr ms mt mu b">Pet</code>对象初始化的每个实例，并添加对有效物种的检查。如果我们在整个项目中初始化了很多实例，这可能会变得难以管理。</p><p id="d445" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这本来是可以避免的吗？是啊！我们可以定义一个工厂函数，并用它来初始化我们的<code class="fe mr ms mt mu b">Pet</code>实例:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7ea2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意，我们没有导出<code class="fe mr ms mt mu b">Pet</code>类本身，而是导出了工厂函数<code class="fe mr ms mt mu b">createPet</code>。此函数创建并返回该类的新实例。</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="21f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们在项目中到处使用<code class="fe mr ms mt mu b">createPet</code>来定义新的<code class="fe mr ms mt mu b">Pet</code>对象。因此，如果我们决定限制允许的物种，我们所要做的就是修改我们的<code class="fe mr ms mt mu b">createPet</code>函数:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a8c3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从客户端的角度来看，什么都没有改变，它仍然使用<code class="fe mr ms mt mu b">createPet</code>函数来初始化新的实例。很明显，工厂模式使我们的对象初始化过程更加灵活。</p><h1 id="4ac7" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">代理人</h1><p id="77ce" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">这种模式的目的是在不修改对象本身的情况下增强对象的功能。增强功能的包装器称为“代理”，而目标对象称为“主题”。代理反映了主体的内部结构，因此两者可以互换使用。</p><p id="6bdd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种模式提供了很多好处，下面是其中的一些:</p><ul class=""><li id="3104" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">访问控制—代理可以验证客户端是否有权访问主题</li><li id="4c2c" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">参数验证—代理可以在将函数参数传递给主题之前验证它们</li><li id="0bd2" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">缓存—代理可以缓存主体执行的一些繁重计算的结果，以避免不必要的重新计算。</li></ul><p id="2996" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看一个简单的代理实现:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="358f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，实现代理非常容易。enhanced方法是我们添加代理的自定义逻辑来增强主题功能的地方。而委托方法是我们不加任何修改地使用主体方法的地方。</p><p id="7673" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以使用以下两个选项中的任何一个来避免手动编写委托方法:</p><ul class=""><li id="fec8" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">可以用<code class="fe mr ms mt mu b"><a class="ae kz" href="https://www.npmjs.com/package/delegates" rel="noopener ugc nofollow" target="_blank">delegates</a></code>之类的NPM包。</li><li id="19dc" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">新的ES6规范包括一个类<code class="fe mr ms mt mu b">Proxy</code>，可以用来创建一个新的代理:<code class="fe mr ms mt mu b">new Proxy(target, handler)</code>。这里的<code class="fe mr ms mt mu b">target</code>是我们的主语，而<code class="fe mr ms mt mu b">handler</code>是一个特殊的宾语，它指定了代理的行为。</li></ul><p id="fecd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">代理的上述实现很简单，但是它不能保证代理和主体之间的完全可交换性。为了解决这个问题，我们可以使用主题的原型来创建代理:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="04b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的代码中，我们使用<code class="fe mr ms mt mu b">Object.create()</code>创建了主题原型的副本。接下来，我们将它分配给用于创建新代理的<code class="fe mr ms mt mu b">Proxy</code>函数。如果您运行这段代码，您应该会看到<code class="fe mr ms mt mu b">console.log</code>打印<code class="fe mr ms mt mu b">true</code>:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="762e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用这个实现，我们增加了代理和主题之间的可交换性。</p><h1 id="575b" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">战略</h1><p id="e688" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">当有某种算法在整个应用程序中不断重复，逻辑上略有变化时，这种模式会非常方便。这种情况下的算法称为“上下文”，而变量部分称为“策略”。</p><p id="b1da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了在应用程序的不同部分使用不同的策略之外，上下文的逻辑不会改变。一个很好的例子就是具有多个不同可用通道的通知系统。根据用户的偏好，您可以使用不同的渠道发送通知，同时保持系统的核心逻辑不变。</p><p id="3e80" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有一个图表来说明这个概念:</p><figure class="mv mw mx my gt ju gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/977d559e626a939ab018dbc5a34defd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/0*rr2Jhh9vuZDLcpFm"/></div></figure><p id="7a41" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，所有策略都有相同的接口，这使得我们的上下文可以在它们之间无缝切换。希望您能很快想象出这种模式可能有用的所有不同场景。</p><p id="d300" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你感兴趣，你可以在我的另一篇博客文章中阅读更多关于策略模式的内容。</p><p id="a3e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个帖子到此为止！在第二部分中，我们将讨论其他三种模式:适配器、观察者和公开构造函数。</p><p id="ca14" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢您的阅读！</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="0a0d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nj">原载于2019年7月14日</em><a class="ae kz" href="https://isamatov.com/essential-javascript-patterns-pt1/" rel="noopener ugc nofollow" target="_blank"><em class="nj">【https://isamatov.com</em></a><em class="nj">。</em></p></div></div>    
</body>
</html>