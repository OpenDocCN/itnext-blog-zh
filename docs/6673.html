<html>
<head>
<title>Paginating, sorting and filtering data from a Data Action</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对数据操作中的数据进行分页、排序和过滤</h1>
<blockquote>原文：<a href="https://itnext.io/paginating-sorting-and-filtering-data-from-a-data-action-f5cb997fdc60?source=collection_archive---------2-----------------------#2022-01-24">https://itnext.io/paginating-sorting-and-filtering-data-from-a-data-action-f5cb997fdc60?source=collection_archive---------2-----------------------#2022-01-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6f1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">这是一篇关于用</em> <a class="ae km" href="https://www.outsystems.com/" rel="noopener ugc nofollow" target="_blank"> <em class="kl"> OutSystems平台</em> </a> <em class="kl">开发的文章。如果您还没有使用OutSystems进行开发，您应该:)。</em></p><h1 id="5d62" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">前言</h1><p id="5334" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">在反应式应用程序中，可以使用屏幕聚合来检索数据。如果您在表格小部件中显示数据，并且您想要对数据进行分页、排序和/或过滤，您需要在您的屏幕聚合中解决这些问题，如官方文档中的<a class="ae km" href="https://success.outsystems.com/Documentation/11/Developing_an_Application/Design_UI/Creating_and_editing_tables/Table_pagination_and_sorting" rel="noopener ugc nofollow" target="_blank">所述。然而，数据经常来自调用REST服务方法或服务动作的数据动作，这些动作可能不支持分页、排序或过滤，而是返回所有可用记录的完整、未分页且可能未排序的列表。不幸的是，OutSystems没有描述在这种情况下如何处理分页、排序和/或过滤的规范方法。在这篇文章中，我将描述我认为最好、最快的方法。</a></p><h1 id="ba58" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">页码</h1><p id="b1d7" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">让我们先来看看分页。在反应式应用程序中，分页由OutSystems UI <em class="kl">分页</em>小部件处理。分页小部件有三个重要参数，<em class="kl"> StartIndex </em>、<em class="kl"> MaxRecords </em>和<em class="kl"> TotalCount </em>。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/395ab90342f4f5a526e1e47d5c2aa8ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:376/format:webp/1*jZc8CXLhZbKaObtkggcyxQ.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">分页小部件，导航UI流的一部分。</figcaption></figure><p id="80d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">StartIndex是显示的第一条数据记录的索引，MaxRecords是显示的记录总数，TotalCount是所有页面的记录总数。Pagination小部件使用MaxRecords和TotalCount计算总页数，使用MaxRecords和StartIndex计算当前页面。它还使用这些值来显示100个项目中的第1到第10个消息(其中1是StartIndex的值，10是StartIndex+max records-1的值，100是TotalCount的值)。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mc"><img src="../Images/92ca2151aa33718ddc8cf730559b7b98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f8xFxboPkNA8wuyIrhMdUA.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">运行中的分页小部件。这个表中有很多记录。</figcaption></figure><p id="9dd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值得注意的是，分页小部件显示的内容完全独立于表格小部件显示的内容。在传统的Web应用程序中，表记录小部件保存总列表，通过从RichWidgets引用的一些操作，表记录本身负责显示正确的页面，使其与RichWidgets List_Navigation小部件(它是OutSystems UI Pagination小部件的传统Web等价物)同步。但是在反应式应用程序中，表格小部件显示其源属性列表中的任何内容。因此，开发人员有责任确保它显示正确的内容，并与分页小部件保持同步。</p><p id="e651" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我在这篇文章的前言中所写的，如果源是一个屏幕集合的输出，那么OutSystems文档会详细告诉您该做什么。但在数据行动的问题上，它不幸保持沉默。现在可能很清楚了，因为Table小部件显示源列表中的所有内容，所以您需要确保源列表只包含单个页面的记录，页面由Pagination小部件决定。如果您从数据操作中收到一个完整的记录列表，您将需要从该列表中提取一个子部分，并将其用作源列表。</p><p id="6d6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，您当然需要一个数据操作(在屏幕的上下文菜单中称为“从其他来源获取数据”)。在数据操作中，您调用REST方法、服务器操作、服务操作或SQL查询，甚至是提供数据的聚合。当然，在使用SQL或Aggregate时，您可以使用规定的方法进行分页，但是特别是对于不返回太多记录(比如最多几千条)的繁重查询，您可能最好提取一次数据，而不是在用户跳到另一个页面时刷新查询(或者对数据进行排序或过滤，请参阅本文后面的内容)。数据操作应该输出获取的整个列表——这将成为您的源列表。但是不要使用这个列表作为表的来源！正如我上面提到的，这将显示表中的所有记录，并且没有分页。</p><p id="03e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您将Pagination小部件拖到画布上时，它的属性窗格会为强制输入参数以及OnNavigate事件的处理程序屏幕操作显示红色边框。每当用户单击其中一个导航按钮(后退、前进、页码)或输入页码(如果ShowGoToPage属性设置为True)时，将触发该事件。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/39c132e008cd06f9366a6788c11b7bc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*hy2ZQCbncVSNkQSovAEJ1Q.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">分页属性窗格</figcaption></figure><p id="64a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果单击处理程序的向下箭头，并选择<em class="kl"> New Client Action </em>，将创建一个名为PaginationOnNavigate的客户端操作，它有一个名为NewStartIndex的输入参数。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/15e9d667ea9d850064e4f76e836f9040.png" data-original-src="https://miro.medium.com/v2/resize:fit:324/format:webp/1*DnVZIrimVujtjhjhSZNn7g.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">自动生成的分页导航</figcaption></figure><p id="e784" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建paginationnavigate后，将数据操作的“获取后打开”属性设置为paginationnavigate，NewStartIndex为0。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/b0eeb450f994b496d8fe2eca8fcb4da7.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*H-LCgCl-BB_zaTtOE43QRA.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">Fetch后的On设置为PaginationOnNavigate。</figcaption></figure><p id="61a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这确保了无论我们做什么来确保正确的数据被显示，它也将发生在数据刚刚被获取的时候。</p><p id="aa11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于表不能直接使用数据动作的输出作为源，我们需要一个屏幕局部变量来保存我们实际想要显示的数据。为了简单起见，我在这里假设列表的数据类型与数据动作的输出相同，但是根据您是否希望基于数据执行任何计算或查找，您可以使用不同的结构。对于我们的例子，让我们调用本地变量<em class="kl">page data</em>。接下来，将PagedData设置为表的源。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mk"><img src="../Images/e7009794d9ecd6e9307ad3319f3a3069.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*CUfRDukIbZrmVgC-GzmIQQ.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">我们的PagedData列表现在是我们的表的来源</figcaption></figure><p id="4659" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Pagination小部件仍然有错误，因为我们还没有设置StartIndex、MaxRecords和TotalCount属性。我们将为此创建三个屏幕局部变量，为了简单起见，我们称它们为<em class="kl"> StartIndex </em>、<em class="kl"> MaxRecords </em>和<em class="kl"> TotalCount </em>。将这些分配给分页的属性:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/92a2ee45dfac10005c142e4888697433.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*SAYNjTxsjo2-NY4dwDpmEA.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">分页小部件属性全部填写完毕</figcaption></figure><p id="a380" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了防止分页在屏幕打开时显示错误，请将MaxRecords默认值设置为您希望每页显示的记录数，例如10。</p><p id="6e1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在PaginationOnNavigate操作中，我们现在需要用数据操作输出的正确记录填充PagedData列表。由于平台没有为我们提供开箱即用的操作来从列表中提取一部分，因此我们需要使用For Each来实现这一点。我们使用等于NewStartIndex输入变量的开始索引和等于MaxRecords的最大迭代次数来迭代数据操作的输出。在For Each内添加一个ListAppend，它将数据操作输出列表的当前追加到PagedData列表中。因为PaginationOnNavigate将被多次调用，所以我们还需要在For Each的前面列出Clear PagedData，否则列表会随着每次调用而增长。</p><p id="de87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要做的最后一件事是将屏幕局部变量StartIndex设置为NewStartIndex输入变量，将TotalCount设置为数据操作输出列表的长度，这样Pagination小部件就可以使用正确的值。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/e2f7614967405ce22632d93c432b7b57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*ok0QxSz-OnwLgkM47e-iXA.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">已完成的分页导航。为了清楚起见，任务被分开了，但是你通常把它们放在一个单独的任务中。</figcaption></figure><p id="79f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，我们的分页就完成了！</p><h1 id="c597" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">整理</h1><p id="6035" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">接下来我们来看看排序。表格小部件支持开箱即用的排序。如果你点击一个标题单元格，你会看到它的一个属性叫做<em class="kl">排序属性</em>。如果设置了该选项，列名称后会自动出现一个双箭头，您可以单击该箭头对列进行排序。默认情况下，当您将变量拖到表上时，Service Studio将自动为所有列创建排序。删除不想排序的列的排序属性文本。</p><p id="9d15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">表的另一个属性是On Sort事件，该事件在用户单击可排序列的标题时触发。要生成用于排序的屏幕操作，请单击向下箭头并选择“排序客户端操作时新建”。然后，Service Studio将创建一个名为OnSort的操作，参数为SortBy。在表属性中，SortBy被设置为<em class="kl"> ClickedColumn </em>。这是当您单击可排序的标题时，表生成的排序事件的输出。它被设置为您为列的排序属性设置的任何文本。Service Studio还生成一个名为<em class="kl">表排序</em>的屏幕局部变量。该变量在自动生成的OnSort操作中使用，并将保存当前排序列的排序属性值。</p><p id="b352" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您打开OnSort操作，您将看到以下自动生成的代码:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/634180f89c8a0fd2d1f25ddcf9bef8c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*Db-v-v4Vz-Nif98Gsba2hQ.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">自动生成的分类代码。是的，第一个If上面只有四条网格线，而其他的都有五条😠。</figcaption></figure><p id="888b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们不能直接使用这个代码，如果只是因为它有一个刷新数据，我们不会使用。但是让我们分析一下代码到底做了什么。在If中，代码检查被点击的列是否有变化。为此，它将TableSort局部变量与SortBy输入进行比较。由于TableSort保存当前排序列的Sort属性的值(见下文)，当TableSort等于SortBy时，没有变化。我不确定它为什么检查SortBy是否为空——据我所知，SortBy总是被填充。当有变化时，True分支中的赋值将“DESC”(带有前导空格)添加到TableSort变量中。这做了两件事:它确保如果您再次单击该列，if将转到False分支(因此它在升序和降序排序之间切换)，其次，如果您有一个Screen Aggregate，它应该使用TableSort作为动态排序，并且通过添加DESC，它将降序排序而不是升序排序。False分支简单地将TableSort设置为SortBy输入，然后两个分支都将StartIndex设置为0，因此我们的分页小部件知道从第1页开始。注意，这里写的是StartIndex2，这似乎是Service Studio中的一个错误:它创建了另一个StartIndex变量，而我们自己已经创建了一个。最后，它调用Refresh Data来刷新您的表可能绑定到的屏幕聚合。</p><p id="5c9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我所说的，我们不能使用这段代码，但我们将创建类似的东西来排序我们的内存中数据操作输出列表。首先，在列名中添加“DESC”是没有用的，因为我们不使用聚合。因此，我们将添加另一个屏幕局部变量，称为IsSortDesc。如果为真，我们将降序排列，否则我们将升序排列。像在自动生成的代码中一样，我们首先通过比较TableSort和SortBy来检查我们是否单击了同一个列。如果它们相等，我们切换IsSortDesc的值(通过将“not IsSortDesc”赋给IsSortDesc)。否则，我们将把SortBy赋给TableSort，并将IsSortDesc设置为False，因为我们总是希望从升序开始排序。</p><p id="1ca8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了对列表进行排序，我们使用ListSort。我们将排序的列表是数据操作的输出(<em class="kl">而不是</em>paged Data，当然，我们希望页面显示一页的全部排序数据，而不仅仅是对页面上的内容进行排序)。必须在表达式中使用If，根据TableSort/SortBy的值(由于赋值，它们相等)设置“By”属性。升序属性可以设置为“不是IsSortDesc"⁴.</p><p id="2c51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们调用PaginationOnNavigate，使用0的NewStartIndex。因为PaginationOnNavigate使用数据操作的输出来填充PagedData列表，所以它现在将使用排序后的列表。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mo"><img src="../Images/9bb9fc27b7fe523fe35e56b56507e36e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pjARRwDcNkAPjMYAuMqv8g.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">我们自己的OnSort排序操作。看看每样东西的间隔是多么的均匀！🥰注意到“名称”和“功能”是DataAction1的两个属性。本例中的输出列表结构。</figcaption></figure><p id="7d77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后要做的一件事是，如果数据操作返回一个排序列表(通常REST方法或服务操作将返回按某个属性排序的列表，或者您可以在数据操作中使用ListSort在检索后对其进行排序)，则给TableSort一个默认值，该值等于排序所依据的列。如果不这样做，用户第一次单击该列标题时什么也不会发生，因为TableSort不等于SortBy，ListSort将按升序排序。</p><p id="199c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">排序到此为止！</p><h1 id="9a2e" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">过滤</h1><p id="38c2" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我们通常想做的最后一件事是允许用户过滤列表。我将假设您在一个表单中有一些过滤输入字段，一个“过滤”按钮用于过滤输入，一个“清除”按钮用于清除输入。您可能有不同的实现，这并不重要，只要有一些值来过滤列表。</p><p id="7743" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先要意识到的是，因为我们没有聚合来进行过滤，所以我们需要ListFilter来过滤我们的列表。过滤列表通常是总列表的子集，因此在我们的例子中是数据动作输出的子集。正是这个子集需要分页和排序，所以排序和分页都需要应用于子集。为了实现这一点，我们首先创建另一个屏幕局部变量来保存这个过滤后的列表，其类型与数据动作的输出类型相同。我们称之为FilteredData。</p><p id="c49c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，在PaginationOnNavigate操作中，我们用FilteredData(来自DataAction)替换For Each记录列表输入。Output)和带有FilteredData.Current的ListAppend元素。此外，对TotalCount的赋值被更改，以便它采用FilteredData列表的长度，而不是数据操作的输出list⁵.</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/1740501f0a3cfa443623d5537de9a531.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*D0MNcPVyOeuWgu2IP4M56g.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">对PaginationOnNavigate操作的更改</figcaption></figure><p id="838e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们需要能够实际过滤列表。为此，我们创建了一个名为OnFilter的新屏幕操作。我们还将“过滤器”按钮的点击事件设置为新的OnFilter动作。接下来我们需要编写OnFilter的逻辑。首先，我们将把数据操作的输出分配给FilteredList —如果我们根本不过滤(因为我们的过滤器输入是空的)，这是默认情况。接下来，我们将检查屏幕上的每个过滤器输入，看用户是否输入了什么。对于这个例子，我将假设“Name”列和“Function”列的过滤器输入。我还为过滤器输入使用了一个名为<em class="kl"> Filter </em>的结构类型的本地屏幕变量，但是如果你愿意，你也可以使用单独的变量。</p><p id="8493" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果一个过滤器输入被填充，我们将一个ListFilter应用到过滤后的列表，使用您想要用于过滤的任何条件。在这个例子中，我有一些自由文本输入，我想根据该文本的出现情况过滤列表，类似于聚合中的“like”。为此，我们使用一个条件，该条件使用内置的Index函数，在附属的list属性中搜索过滤器输入，将两者都转换为小写(因为我们希望比较不区分大小写，就像在数据库搜索中一样)。之后，我们将ListFilter的输出分配给FilteredData。我们对每个滤波器input⁶.重复这一过程</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mq"><img src="../Images/2c6eb3355a851f6770edfdbb30260ea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-k3VxMHNHuPlAT7B-Lprsg.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">我们目前所做的。但这还不是全部！</figcaption></figure><p id="972e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来要做的是对过滤后的列表进行排序。当然，如果数据动作的输出列表已经被过滤，排序列表也将被过滤。但是，如果在过滤之后，用户对列表进行了不同的排序，我们需要对过滤后的列表进行排序，而不是对数据操作的output⁷.进行排序为此，我们在过滤后调用OnSort操作。但是，您可能还记得，OnSort从检查表排序是否等于排序开始，如果等于，就恢复排序顺序。在应用过滤器的情况下，当然不应该这样做，因为每次用户过滤列表时，排序顺序都会颠倒。因此，我们向OnSort操作添加了一个非强制布尔参数，称为IsFromFilter，它指示是从OnFilter操作(True)还是从表的OnSort事件(False)调用它。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/cb890f25d7e29d79a6874f8e1b935d95.png" data-original-src="https://miro.medium.com/v2/resize:fit:304/format:webp/1*oEBSgi9ZbDFOW524Hv9vVQ.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">添加了IsFromFilter的OnSort。</figcaption></figure><p id="ae45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们从OnFilter调用OnSort，将IsFromFilter设置为True。注意，由于OnSort已经调用了PaginationOnNavigate，所以我们不需要从OnFilter调用该操作。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ms"><img src="../Images/fcd5ae79118e79888261a59c33c0e37a.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*CDGtW1jk7y_4vx5Be1YKuA.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">OnFilter的最终版本，增加了OnSort。</figcaption></figure><p id="08b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们需要处理“清除”按钮。按下时，所有过滤器应被清除，表中的数据应代表这一点。你可以用两种方法来做这件事:添加一个单独的名为OnFilterClear的屏幕操作，或者类似的操作，在这个操作中，你可以清除赋值操作中的过滤器并调用OnSort。或者，这也是我通常选择的，向OnFilter添加一个非强制的<em class="kl"> IsClear </em>输入参数，在“Clear”按钮的单击事件中将其设置为True(在为其分配OnFilter之后)，并在OnFilter中处理它。因为这些都很琐碎，所以我在下面照原样展示。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/a6686eee42ef08455812d89c5ce9b070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*4i-7Agos-96XriYOv-k3gw.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">OnFilter操作包括清除过滤器。“虚拟”赋值只是为了让箭头顺畅地流动。</figcaption></figure><p id="3bd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">倒数第二件要做的事情是更新。首先，我们需要使用新的IsFromFilter输入参数。如果它的值为True，我们将绕过检查要排序的列的代码，直接进行排序。此外，由于我们现在应该使用FilteredData列表而不是数据操作的输出，ListSort必须使用filtered列表。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/6d81ea8e7aee5015428c31619e49de60.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*e4p-k1QWZ4SEOwrHitKgtA.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">OnSort增加了对IsFromFilter的检查，并修改了ListSort。</figcaption></figure><p id="2fc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，因为PaginationOnNavigate和OnSort现在都使用FilteredData而不是数据操作的输出列表，所以我们需要在数据操作完成后直接将输出列表分配给FilteredData。目前，我们在Fetch动作之后调用PaginationOnNavigate as On，但是我们不能在那里分配它，因为那样会将过滤列表重置为完整列表，并使任何过滤列表的尝试无效。相反，我们应该调用OnFilter，因为赋值已经在那里了。额外的好处是，如果我们有一个非空的默认过滤器，列表将根据该过滤器进行过滤(并随后正确排序)，并显示给用户，而无需他们按下“过滤器”按钮。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/e351902afe3eddbabbcbc91a50a034dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*81u-ba7LvEbUnBhS-beeYA.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">在Fetch之后现在调用OnFilter</figcaption></figure><p id="0182" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就这样，我们现在也有了过滤功能！</p><h1 id="daa7" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">结束语</h1><p id="bac1" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">当您有一个屏幕集合来获取您的数据时，似乎是一件相当琐碎的事情，即。当数据来自返回非分页列表的数据操作时，分页、排序和过滤就不那么简单了(在我的经验中，这是一种常见的情况)。在本文中，我已经展示了如何在客户端使用ListAppend、ListSort和ListFilter来实现这一点——我希望这能有所帮助。作为参考，我还<a class="ae km" href="https://www.outsystems.com/forge/component-overview/12354/paginating-data-action-example" rel="noopener ugc nofollow" target="_blank">上传了一个Forge组件</a>来展示上面的操作，使用一个虚拟的REST服务来检索数据。一如既往，快乐编码！</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="8e29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，可能是故意的，因为Service Studio不知道我们已经拥有的StartIndex是否用于当前表，因为表和分页小部件之间没有连接。</p><p id="6cf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我见过类似“If(IsSortDesc = True，False，True)”的代码，但是看在上帝的份上，请不要这样做！</p><p id="184a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，如果您真的需要，您可以跟踪每一列的最后排序顺序，并使用它，但我不建议这样做，因为它可能会使用户感到困惑。</p><p id="438f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">⁴Alternatively您可以使用一个名为IsSortAsc的变量，将其默认值设置为True，如果TableSort不等于SortBy，则将其赋值为True，并将其直接用作升序的输入。</p><p id="16a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">⁵There's不止一个位置，我们可以分配总数。我们最初是在PaginationOnNavigateAction中完成的，因为它是在数据操作完成之后调用的(因为数据操作是在Fetch操作之后进行的)。虽然我们将改变这个位置，但它仍然是一个方便的位置，因为我们只需要一次赋值。</p><p id="9c89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">⁶It可以使用单个列表过滤器，结合所有过滤器的条件。然而，一旦你有一两个以上的过滤器，代码很快就会变得难以辨认，所以我总是选择单独的列表过滤器。根据我的经验，这不会导致性能或内存问题，但是如果您有一个非常大的列表，为了提高性能，可能需要组合过滤器。但一如既往，不要过早优化！</p><p id="4fe1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">⁷Alternatively，我们可以对输出列表进行排序，然后在每次用户应用不同的排序时对其进行过滤，但与只对过滤后的列表进行排序而不对输出列表进行再次过滤相比，这将是非常浪费的。</p></div></div>    
</body>
</html>