<html>
<head>
<title>A loader for your components with Angular CDK Overlay</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带角度CDK覆盖的组件加载器</h1>
<blockquote>原文：<a href="https://itnext.io/a-loader-for-your-components-with-angular-cdk-overlay-ebf5a4962e4d?source=collection_archive---------1-----------------------#2019-10-02">https://itnext.io/a-loader-for-your-components-with-angular-cdk-overlay-ebf5a4962e4d?source=collection_archive---------1-----------------------#2019-10-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="98fe" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">有角的</h2><div class=""/><p id="cde6" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我们经常处理异步数据，即从远程web服务获取的数据。为了改善用户体验(UX)，一种常见的方法是添加一个加载器来指示正在发生的事情。</p><p id="536e" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在本文中，我将向您展示如何使用一个简单的指令向所有组件快速添加一个加载器。为此，我们将使用角度CDK叠加功能。</p><div class="kx ky gp gr kz la"><a href="https://material.angular.io/cdk/overlay/overview" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd jd gy z fp lf fr fs lg fu fw jc bi translated">角状材料</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">叠加CDK要素</h3></div></div></div></a></div><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi li"><img src="../Images/06a8c84d56d3f38857b034507716386f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Zbm96gQfNM4Cva0d"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">照片由<a class="ae ly" href="https://unsplash.com/@nordwood?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">诺德伍德主题</a>在<a class="ae ly" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="006b" class="mg mh it bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">叠加CDK快速介绍</h1><p id="56d1" class="pw-post-body-paragraph jz ka it kb b kc ne ke kf kg nf ki kj kk ng km kn ko nh kq kr ks ni ku kv kw im bi translated">我猜你知道如何创建一个角度项目，所以我跳过这一步。让我们从添加棱角分明的材料开始，这得益于:</p><p id="c4cb" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><code class="fe nj nk nl nm b">ng add @angular/material</code></p><p id="f041" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">以及<em class="nn">装载机组件</em>:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3de3" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">不要忘记将它添加为一个<em class="nn"> entryComponent </em>，因为它没有在模板中被引用:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="940d" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">最后，我们可以在<code class="fe nj nk nl nm b">app.component.ts</code>文件中使用这个加载器:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="bc21" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">您可能已经注意到，我们在<code class="fe nj nk nl nm b">overlayRef</code>上附加了一个<em class="nn">组件门户</em>。您可以在<a class="ae ly" href="https://material.angular.io/cdk/portal/overview" rel="noopener ugc nofollow" target="_blank"> cdk文档</a>中找到该特性的完整描述。</p><p id="094a" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><em class="nn">TL；博士(来自博士)</em></p><blockquote class="nq"><p id="0639" class="nr ns it bd nt nu nv nw nx ny nz kw dk translated">一个<code class="fe nj nk nl nm b">Portal</code>是一个UI，它可以动态地呈现到页面上的一个空位上。</p></blockquote><p id="22af" class="pw-post-body-paragraph jz ka it kb b kc oa ke kf kg ob ki kj kk oc km kn ko od kq kr ks oe ku kv kw im bi translated">通过运行应用程序并点击按钮，我们会看到:</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi of"><img src="../Images/c6d74c9e24b611bd16beee1e22b86718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nxA4x0s9Dh6pv0T6i9sy3w.gif"/></div></div></figure><p id="01f1" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">哇，这是一个开始！！然而，我们不能<em class="nn">关闭</em>这个覆盖图，它呈现在整个页面上……让我们继续，将这个加载器插入到一个组件中。</p><h1 id="c778" class="mg mh it bd mi mj og ml mm mn oh mp mq mr oi mt mu mv oj mx my mz ok nb nc nd bi translated">在组件上方显示装载器<em class="ol"/></h1><p id="5814" class="pw-post-body-paragraph jz ka it kb b kc ne ke kf kg nf ki kj kk ng km kn ko nh kq kr ks ni ku kv kw im bi translated">为了定位特定的组件，我们必须重新定义现有的<em class="nn"> OverlayContainer </em>类，如下所示:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9979" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这将允许指定一个容器元素(在我们的例子中，我们的组件)。但是你不用<em class="nn">覆盖容器</em>而是用<em class="nn">覆盖。</em>因此你必须创建一个新的类扩展<em class="nn">覆盖</em>，让我们把它命名为… <em class="nn">动态覆盖</em>:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9c1e" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这是很多代码，但是我们需要注入所有这些服务和特性来适应最初的<em class="nn">覆盖</em>。我已经创建了一个包含默认配置的<code class="fe nj nk nl nm b">createWithDefaultConfig</code>方法(<code class="fe nj nk nl nm b">hasBackdrop</code>和<code class="fe nj nk nl nm b">positionStrategy</code>已经定义好了，但是如何增强这个配置取决于你，<a class="ae ly" href="https://material.angular.io/cdk/overlay/api#OverlayConfig" rel="noopener ugc nofollow" target="_blank"> doc </a>)。</p><p id="63f8" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这就是我们所需要的，不多也不少！让我们在一个<code class="fe nj nk nl nm b">MatTable</code>上试试吧。</p><p id="06d6" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这里，我刚刚从<a class="ae ly" href="https://material.angular.io/components/table/overview#getting-started" rel="noopener ugc nofollow" target="_blank">表基本示例</a>中复制/粘贴了一个。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3962" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">当点击<em class="nn">刷新</em>按钮时，我们可以看到覆盖图只在桌面上弹出。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi of"><img src="../Images/7bc5e48b4ac64c3f43052a3e1b88ea0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wKaEKe9ENm-aDbj6vI93JQ.gif"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">(注意:在GIF的最后，加载器仍然被渲染)</figcaption></figure><h1 id="ff15" class="mg mh it bd mi mj og ml mm mn oh mp mq mr oi mt mu mv oj mx my mz ok nb nc nd bi translated">越来越接近真实世界</h1><p id="74fc" class="pw-post-body-paragraph jz ka it kb b kc ne ke kf kg nf ki kj kk ng km kn ko nh kq kr ks ni ku kv kw im bi translated">嗯，这个叠加看起来很好，但它仍然没有消失。这是很重要的，使它消失的数据提取。为此，我创建了一个<em class="nn"> OverlayLoading指令</em>。这样，该指令可以在您想要的每个组件上重用。它需要一个<code class="fe nj nk nl nm b">Observable&lt;boolean&gt;</code>作为参数来指示覆盖图应该被附加还是被分离(分别意味着数据被获取或被提取)。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7f97" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">然后，您将能够像这样使用它:</p><pre class="lj lk ll lm gt om nm on oo aw op bi"><span id="345c" class="oq mh it nm b gy or os l ot ou">import { Component } from '@angular/core';<br/>import { Observable, interval } from 'rxjs';<br/>import { map } from 'rxjs/operators';</span><span id="143a" class="oq mh it nm b gy ov os l ot ou">@Component({<br/>  selector: 'app-root',<br/>  template:<br/>    `&lt;mat-card&gt;<br/>      &lt;mat-card-header&gt;<br/>        &lt;mat-card-title&gt;Overlay Loading Components&lt;/mat-card-title<br/>      &lt;/mat-card-header&gt;<br/>      &lt;mat-card-content&gt;<br/>        &lt;app-table-basic-example<br/>          <strong class="nm jd">[overlayLoading]="fetchingData$"</strong>&gt;<br/>        &lt;/app-table-basic-example&gt;<br/>      &lt;/mat-card-content&gt;<br/>    &lt;/mat-card&gt;`<br/>})<br/>export class AppComponent {<br/>  displayOverlay = [true, false];</span><span id="6e3b" class="oq mh it nm b gy ov os l ot ou">  // An <em class="nn">Observable</em> sending true/false with 2s interval.<br/>  <strong class="nm jd">fetchingData$</strong>: Observable&lt;boolean&gt; = <br/>    interval(2000).pipe(map(i =&gt; this.displayOverlay[i]));<br/>}</span></pre><h1 id="9ffd" class="mg mh it bd mi mj og ml mm mn oh mp mq mr oi mt mu mv oj mx my mz ok nb nc nd bi translated">一个真实的用例</h1><p id="27fe" class="pw-post-body-paragraph jz ka it kb b kc ne ke kf kg nf ki kj kk ng km kn ko nh kq kr ks ni ku kv kw im bi translated">这个<em class="nn">覆盖加载指令</em>对于使任何组件<strong class="kb jd"> <em class="nn">数据</em> <em class="nn">可加载</em> </strong>非常有用，这意味着您可以向它提供一个可观察值，指示数据是否被获取。</p><p id="129a" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">使用存储时，当您想从远程Web API获取数据时，它非常有用。你必须使用两个模块状态:一个用于实体(即用户状态)，另一个用于UI。这些效果将有助于管理动作调度:</p><ul class=""><li id="afae" class="ow ox it kb b kc kd kg kh kk oy ko oz ks pa kw pb pc pd pe bi translated">在实体模块中使用“空”操作来触发数据提取</li><li id="6923" class="ow ox it kb b kc pf kg pg kk ph ko pi ks pj kw pb pc pd pe bi translated">在您的模块效果中，捕捉此动作以:</li></ul><ol class=""><li id="8843" class="ow ox it kb b kc kd kg kh kk oy ko oz ks pa kw pk pc pd pe bi translated">向UI状态分派一个动作，指示正在获取数据(那么上面的<strong class="kb jd"> fetchingData$ </strong>为真)</li><li id="ca44" class="ow ox it kb b kc pf kg pg kk ph ko pi ks pj kw pk pc pd pe bi translated">发送API请求</li></ol><ul class=""><li id="74bf" class="ow ox it kb b kc kd kg kh kk oy ko oz ks pa kw pb pc pd pe bi translated">当数据被接收时，<code class="fe nj nk nl nm b">pipe</code>和<code class="fe nj nk nl nm b">map</code>它:</li></ul><ol class=""><li id="6b89" class="ow ox it kb b kc kd kg kh kk oy ko oz ks pa kw pk pc pd pe bi translated">一个新的实体动作，它将通过实体缩减器将数据设置到您的状态中</li><li id="21d6" class="ow ox it kb b kc pf kg pg kk ph ko pi ks pj kw pk pc pd pe bi translated">向UI状态分派一个动作以指示数据已被获取(那么上面的<strong class="kb jd"> fetchingData$ </strong>为falsy)。</li></ol><h1 id="7f5a" class="mg mh it bd mi mj og ml mm mn oh mp mq mr oi mt mu mv oj mx my mz ok nb nc nd bi translated">如果我想添加一些自定义功能怎么办？</h1><h2 id="8734" class="oq mh it bd mi pl pm dn mm pn po dp mq kk pp pq mu ko pr ps my ks pt pu nc iz bi translated">数据注入</h2><p id="c9b7" class="pw-post-body-paragraph jz ka it kb b kc ne ke kf kg nf ki kj kk ng km kn ko nh kq kr ks ni ku kv kw im bi translated">目前，一切都很好，但你可能认为加载器模板非常静态，你想定制它！你100%正确，使用<em class="nn">角度注射器</em>是可能的。</p><p id="69d8" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">首先，我们需要定义将要使用的数据模型。为了简单起见，我只定义了一个<em class="nn">标题</em>和一个<em class="nn">加载器类型</em>，它们要么是微调器，要么是进度条。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7995" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">然后将提供的配置应用到加载器模板:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="fc66" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这是<em class="nn">容易</em>的部分，不过不用担心，剩下的就简单明白了。当我们实例化一个<em class="nn"> ComponentPortal </em>(在指令中)时，我们必须想办法<strong class="kb jd"> <em class="nn">注入</em> </strong>一些数据(我们的配置)以便定义我们的模板。我们的配置将由<code class="fe nj nk nl nm b">@Input()</code>提供。</p><p id="f39f" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">幸运的是，在其构造函数中，ComponentPortal类接受一个注入器。因此，我们来注入:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="08f6" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">最后，我们必须更新<em class="nn"> AppComponent </em>来为指令提供配置:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2ac3" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">遗言:别忘了更新App模块导入<code class="fe nj nk nl nm b">MatProgressSpinnerModule</code>。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi of"><img src="../Images/9800a8d7972bbe859c2f5c13858edb11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iHYzSOiq8SyIFmZvCfitQQ.gif"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">由于所提供的配置，这是一个定制的加载器。</figcaption></figure></div></div>    
</body>
</html>