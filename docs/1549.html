<html>
<head>
<title>Type Vuex without TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不带类型脚本的Vuex类型</h1>
<blockquote>原文：<a href="https://itnext.io/type-vuex-without-typescript-4f183b83a907?source=collection_archive---------0-----------------------#2018-11-21">https://itnext.io/type-vuex-without-typescript-4f183b83a907?source=collection_archive---------0-----------------------#2018-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="d239" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">这是没有TypeScript 的<a class="ae kp" href="https://medium.com/@znck/type-vue-without-typescript-b2b49210f0b" rel="noopener"> Type Vue的续篇，如果你还没有读过，我建议你先读一下。</a></p></blockquote><h2 id="5cb6" class="kq kr iq bd ks kt ku dn kv kw kx dp ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">Vuex确实支持类型！</h2><p id="211c" class="pw-post-body-paragraph jq jr iq jt b ju lm jw jx jy ln ka kb kz lo ke kf ld lp ki kj lh lq km kn ko ij bi translated">Vue的官方状态管理库支持TypeScript。它提供了<code class="fe lr ls lt lu b">MutationTree</code>和<code class="fe lr ls lt lu b">ActionTree</code>类型的帮助器，以在突变和动作中获得自动完成和智能感知。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi lv"><img src="../Images/7264bf67e4eea72be82ab1b13295116d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LnxkcfTpOyKbIklSdqtqyA.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">用<strong class="bd ks">类型脚本</strong>编写的Vuex存储实现</figcaption></figure><p id="ece0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kz kd ke kf ld kh ki kj lh kl km kn ko ij bi translated">我们也可以用JSDoc <code class="fe lr ls lt lu b">@type</code>注释在JavaScript中获取类型。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ml"><img src="../Images/754a719bb50c6cc9a2d577462adb59b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-l43MKpfLTc11RKiIoRtBw.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">用<strong class="bd ks"> JavaScript </strong>编写的Vuex商店实现</figcaption></figure><p id="c52b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kz kd ke kf ld kh ki kj lh kl km kn ko ij bi translated">如果我们使用options语法来创建一个商店，大多数样板注释都是不必要的。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ml"><img src="../Images/4dfbd42cfc885a84484fd92571c7e5aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F7UfyK2EfUZnnIqxp4NoCQ.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">使用options语法用<strong class="bd ks"> JavaScript </strong>编写的Vuex商店实现</figcaption></figure><p id="2540" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kz kd ke kf ld kh ki kj lh kl km kn ko ij bi translated">然而，Vuex的类型脚本API是有限的。<code class="fe lr ls lt lu b">commit</code>和<code class="fe lr ls lt lu b">dispatch</code>中的类型检查和智能感知非常原始。</p><div class="lw lx ly lz gt ab cb"><figure class="mm ma mn mo mp mq mr paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><img src="../Images/df64f7d5fff292182378b6d254fb0f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Z-lHrByiSi4X0gO_ke8ngQ.png"/></div></figure><figure class="mm ma mn mo mp mq mr paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><img src="../Images/12f4c8c33a2a43b5f9fec2de75f5bad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*K16fconEBZhUp7HZfh2OtQ.png"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk ms di mt mu translated">Vuex存储的提交(左)和分派(右)方法中的智能感知</figcaption></figure></div><p id="f3c5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kz kd ke kf ld kh ki kj lh kl km kn ko ij bi translated">正如你在上面看到的，我们得到intellisense让我们知道<code class="fe lr ls lt lu b">commit</code>和<code class="fe lr ls lt lu b">dispatch</code>把字符串作为第一个参数，但是我们没有得到注册的动作和突变的列表。不管有没有打字稿，我们在这里都无能为力。然而，有许多第三方软件包试图在Vuex商店和模块中获得正确的类型。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/6e6b0131706d6af4cb8f69f91af6e1ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*o-oxNO3EMW08IrRdvn3Ixw.gif"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated"><a class="ae kp" href="https://npmsearch.com/?q=keywords:vuex,typescript" rel="noopener ugc nofollow" target="_blank">用于类型脚本的Vuex助手包</a></figcaption></figure><p id="cddc" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kz kd ke kf ld kh ki kj lh kl km kn ko ij bi translated">我们不会仅仅为了得到正确的类型而引入新的依赖项，因为大多数人只使用Vuex。不过<a class="ae kp" href="https://github.com/ktsn/vuex-class" rel="noopener ugc nofollow" target="_blank"> vuex-class </a>、<a class="ae kp" href="https://github.com/istrib/vuex-typescript" rel="noopener ugc nofollow" target="_blank"> vuex-typescript </a>和<a class="ae kp" href="https://github.com/championswimmer/vuex-module-decorators" rel="noopener ugc nofollow" target="_blank"> vuex-module-decorators </a>值得一提的是辅助vuex店铺的第三方包。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6dac" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kz kd ke kf ld kh ki kj lh kl km kn ko ij bi translated">Vuex的下一个版本将使用一个与TypeScript兼容的API来构建。</p><p id="f736" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kz kd ke kf ld kh ki kj lh kl km kn ko ij bi translated">由于Vuex的TypeScript API的限制，我们在提交突变和分派动作方面做不了什么。尽管有了命名空间模块，我们可以限制存储的范围，并保持单个存储模块的可理解性。然而，Vuex的另一个领域可以使用类型和智能感知。</p><h2 id="5a57" class="kq kr iq bd ks kt ku dn kv kw kx dp ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">在Vue组件中使用Vuex存储</h2><p id="6bee" class="pw-post-body-paragraph jq jr iq jt b ju lm jw jx jy ln ka kb kz lo ke kf ld lp ki kj lh lq km kn ko ij bi translated">Vuex提供了<code class="fe lr ls lt lu b">mapState</code>、<code class="fe lr ls lt lu b">mapGetters</code>、<code class="fe lr ls lt lu b">mapActions</code>和<code class="fe lr ls lt lu b">mapMutations</code>助手来简化Vue组件中的绑定存储状态。然而，API是基于字符串文字的，不可能提供类型和智能感知。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi my"><img src="../Images/9f703b525f049336e388ad4c97e08da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z_wHiJrh-ss4vekWxrR6RQ.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">在Vue组件中使用Vuex存储</figcaption></figure><p id="ad1d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kz kd ke kf ld kh ki kj lh kl km kn ko ij bi translated">这个问题在TypeScript世界里还没有解决，在JavaScript世界里我们也没什么可做的。然而，存在一种模式，据我所知，Chris Fritz的企业样板文件可以得到改进。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h2 id="a97a" class="kq kr iq bd ks kt ku dn kv kw kx dp ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">Vuex中的助手模式</h2><p id="ea63" class="pw-post-body-paragraph jq jr iq jt b ju lm jw jx jy ln ka kb kz lo ke kf ld lp ki kj lh lq km kn ko ij bi translated">根据Chris的helper模式，我们创建一个store helper文件，Vuex store用法的所有<code class="fe lr ls lt lu b">mapXxx</code>方法调用都收集在这里。我们可以创建<code class="fe lr ls lt lu b">computed</code>和<code class="fe lr ls lt lu b">methods</code>属性的上下文组，这些属性可以直接添加到组件中。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ng"><img src="../Images/d4cc70276466ad1ea0b5c46fb4ac885e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O1DWSZV4FdI283eP0al7tQ.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">Vuex助手模式示例</figcaption></figure><p id="2cec" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kz kd ke kf ld kh ki kj lh kl km kn ko ij bi translated">除了提供智能感知增强的可能性之外，这种模式还减少了应用程序中受Vuex影响的外围应用。比方说，如果Vuex引入了重大变更，那么我们只需更新<code class="fe lr ls lt lu b">helpers.js</code>文件。此外，它还减少了代码占用，增加了<code class="fe lr ls lt lu b">mapXxx</code>在不同包之间的重用。</p><h2 id="139d" class="kq kr iq bd ks kt ku dn kv kw kx dp ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">用助手模式编写的Vuex商店智能感知</h2><p id="d5ed" class="pw-post-body-paragraph jq jr iq jt b ju lm jw jx jy ln ka kb kz lo ke kf ld lp ki kj lh lq km kn ko ij bi translated">我们可以用这样一种方式注释助手的导出，以便在组件中使用时获得更好的智能感知。</p><p id="7aa9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kz kd ke kf ld kh ki kj lh kl km kn ko ij bi translated">例如，在下面的代码片段中，<code class="fe lr ls lt lu b">addTodo</code>方法接受类型为<code class="fe lr ls lt lu b">string</code>的<code class="fe lr ls lt lu b">text</code>参数。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi nh"><img src="../Images/6cf0a66d05311454a0648c4daf128b01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TU62tQdkA372qlLQHKe2zA.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">Vuex映射方法中的智能感知</figcaption></figure><p id="f264" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kz kd ke kf ld kh ki kj lh kl km kn ko ij bi translated">上面代码段中的Intellisense不是自动的；它需要使用JSDocs进行一些类型转换。例如，helpers模块导出的<code class="fe lr ls lt lu b">todosMethods</code>对象的类型上应该有<code class="fe lr ls lt lu b">addTodo</code>方法。因此，通过使用<code class="fe lr ls lt lu b">@typedef</code>的类型定义，我们可以将该类型命名为<code class="fe lr ls lt lu b">TodoMethods</code>。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ni"><img src="../Images/a0834f86635d80bd2443fb26a32550ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sJ-KnNGV_I1uAndq5Pm6PQ.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">带有JSDoc类型注释的Vuex助手</figcaption></figure><p id="1f7d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kz kd ke kf ld kh ki kj lh kl km kn ko ij bi translated">在上面的类型定义中，<code class="fe lr ls lt lu b">TodoMethods</code>有一个类型函数的属性<code class="fe lr ls lt lu b">addTodo</code>。为了定义一个函数类型，我们可以使用一个双花括号，类似于Vue的小胡子语法(<code class="fe lr ls lt lu b">{{ ... }}</code>)。在双花括号中，我们以格式<code class="fe lr ls lt lu b">(param: type): return-type</code>添加类型，因此对于接受一个字符串参数的函数，我们有<code class="fe lr ls lt lu b">{{ (text: string): void }}</code>。因为我们知道一个动作总是返回一个承诺，我们可以将<code class="fe lr ls lt lu b">addTodo</code>方法类型扩充为<code class="fe lr ls lt lu b">{{ (text: string): Promise&lt;void&gt; }}</code>。类似地，我们可以给计算属性添加一个类型，但是按照API的要求，这些应该是函数。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi nj"><img src="../Images/84e705a0744bddfb145b382b3d41f43b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rsLiRM5DSevrl4RJUeWNow.png"/></div></div></figure><p id="e9bf" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kz kd ke kf ld kh ki kj lh kl km kn ko ij bi translated">这种方法有点脆弱，因为<code class="fe lr ls lt lu b">mapXxx</code>中使用的属性的任何变化都可能影响JSDoc类型定义。此外，任何添加到<code class="fe lr ls lt lu b">mapXxx</code>函数的新属性都需要将类型定义添加到相应的typedef中。</p><p id="1461" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kz kd ke kf ld kh ki kj lh kl km kn ko ij bi translated">此外，如果您注意到上面代码片段中的<code class="fe lr ls lt lu b">completedTodos</code>类型，它表示<code class="fe lr ls lt lu b">any[]</code>。这是由于VS代码中的一个错误，不能正确显示导入的类型。</p><div class="lw lx ly lz gt ab cb"><figure class="mm ma nk mo mp mq mr paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><img src="../Images/a25ca43a61141a5cd48d92d98d4e5739.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*kTjXRrSDiFw2eeHSccpkcw.png"/></div></figure><figure class="mm ma nl mo mp mq mr paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><img src="../Images/b387812a075ace13f877b17a7208041b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*ZDKUD5btJsOOutRid33sXg.png"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk nm di nn mu translated">VS代码中的错误，无法显示导入的文件</figcaption></figure></div></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="ad54" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kz kd ke kf ld kh ki kj lh kl km kn ko ij bi translated">这就是Vuex和没有TypeScript的类型的所有人。如果你有任何问题，你可以在推特上联系我。</p></div></div>    
</body>
</html>