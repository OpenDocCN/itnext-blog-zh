# (不要害怕)组件

> 原文：<https://itnext.io/dont-fear-the-components-754babc5db77?source=collection_archive---------3----------------------->

## 一个简单的例子，说明对组件的重构是如何让你的生活变得更加轻松的！

我已经使用 React 几年了，这些年来，我注意到有一个开发生命周期♻️，它倾向于为每个组件重复自己。我们在单个文件上创建一个简单的组件，不超过 30 - 40 行代码，您可以在其中定义它的工作方式、内部状态以及如何呈现给最终用户。您还可以创建一个测试文件，在其中测试您实现的逻辑，传递不同的属性并查看您的组件的行为。

![](img/6b8793e38afe72026f2ce3b6c1ba5b41.png)

到目前为止，一切看起来都很好！你的组件是可重用的，有它自己的测试，它负责一个简单的任务。但是，一个新的特性出现了，我们需要给它添加一些代码。我们添加那些变化，我们调整我们的风格和测试来匹配它们，瞧！我们的组件显示了这个新的很酷的特性😎😎我们仍然将它封装在单个组件内的单个文件中。

# 雪成分效应

然而，我们知道这并没有结束。新特性不断出现，一个曾经只有 40 行代码的组件变成了一个非常复杂的文件，有 500 多行代码负责多种职责，我们的测试和样式表也开始遭受同样的症状。我称之为 ***雪花组件效应*** ❄️❄️ *，*我们不断地给一个组件添加代码和特性，然后它就变成了这个怪物，在我们的整个发布中困扰着我们👻👻

那么如何才能把这种影响降到最低呢？为了发现这些情况，我们需要注意什么？我们如何重构我们的代码来阻止*雪元素效果*？

# 实际例子

我决定最好通过一系列代码示例来看看这些场景，这些代码示例说明了一个简单的组件如何快速升级，以及什么样的代码气味告诉我们**“嘿，也许我们可以将它移到另一个组件！”**。这些代码有味道👃👃这并不意味着你做错了什么，它们只是一些指针，可以**帮助你弄清楚你正在做的事情对你当前的情况是否有意义，并且可能发现有更好的方法！**所有这些背后的想法是**代码对你和你的团队有意义**，并且你正在做的决定不会在将来束缚你。

因此，我创建了一个小网站，展示最新的 PS4 游戏，显示标题、图像和游戏本身的链接:

![](img/24068274fc90e199cc8945e53d171b6e.png)

在我看来，这是去年最好的游戏，但战神是最好的

快速浏览一下组件，我们可以说它看起来足够简单了🤔🤔？我们的组件应该有一个游戏列表，每个游戏都有一个标题、一个图像源和要重定向的链接，我们将遍历这些游戏，并为每个游戏创建链接标签和图像标签:

虽然看起来很简单，但我们已经可以确定一些事情，这些事情会对我们的逻辑提出一些问题:

*   我们将游戏列表传递给我们的组件，因此为了检查每个游戏是否有正确的信息，我们创建了一个道具类型验证，检查道具*游戏*是否是一个具有特定形状的数组，它已经开始看起来像一个小雪球。**在呈现游戏列表的组件上验证游戏信息有意义吗？**呈现游戏列表的组件应该验证每个游戏的信息，还是应该只关心如何呈现游戏列表，而不管游戏有什么？
*   如果我们想以不同的方式呈现这些游戏，比如使用有序列表或简单的 div，会怎么样呢？一个特定游戏的渲染是否与有一个列表联系在一起？**如果我们想在非列表环境中渲染一个游戏，该怎么办？**
*   我们为组件创建了两个基类名称，一个名为 *"games"* ，我们将它用于与游戏列表相关的所有元素，另一个名为 *"game"* ，用于与游戏本身相关的所有元素，我们将根据元素的不同使用其中的一个。这已经向我们展示了样式和类名有不同的基础，这取决于我们所渲染的内容。将这些类定义放在同一个文件中有帮助吗？样式表呢？在同一个文件中为" *games"* 元素和 *"game"* 元素设置样式有意义吗？

现在假设我们发布了这个组件，几个星期后新的需求出现了:

*   我们想给我们认为有特色的游戏增加一些视觉上的区别，也许是某种边框轮廓，只是为了抓住用户对这些游戏的注意力
*   我们还希望显示哪些游戏不可用，可能是由于缺货的情况，我们希望防止用户点击它。

从数据的角度来看，给每个游戏添加一些标志是有意义的，也许像*是有特色的*和*是可用的。但是我们的组件会怎么样呢？为了满足这些需求，我们将在组件中添加特定的 css 类，以防游戏被推荐或可用，并且如果游戏不可用，还会阻止点击链接。*

这一新要求增加了一些关键变化，也应该引起讨论:

*   我们在定义的数组上添加了 isAvailable 和 isFeatured 的属性类型。但是这些是新道具，这个组件的消费者可能需要一段时间来适应这些新道具。因此，为了避免显示正确的类型警告以及导致意外的行为，我们希望默认为一个特定的值。由于这些是布尔值，所以应该很容易，所以假设我们将默认 isFeatured = false 和 isAvailable = true。但是看看这个例子，我们如何才能真正做到呢？我们目前有一个形状数组，我们如何编写默认的道具呢？一个对象的默认属性应该依赖于保存它的数据结构吗？我们可以通过为这些道具创建一个特定的默认函数来实现，但是我们会改变数组，这会导致不稳定的行为。
*   与这些功能相关的更改现在直接绑定到呈现游戏列表的组件。如果将来的某个时候，这些 css 类发生了变化，或者我们需要添加新的种类，我们总是会回到游戏组件。这里我们可以问自己，**与迭代对象相关的功能存在于迭代它们的组件旁边有意义吗？**
*   另外，让我们来看看这个组件的测试。我们将需要定义不同的数组，以便尝试最初的要求，以及当游戏有特色和可用时如何渲染游戏:

*   游戏组件真的应该关心游戏列表中是否有一些特色游戏和一些可用的游戏吗？**这个组件应该测试与迭代对象相关的边缘案例吗？**难道它们不是更多与游戏本身相关的测试案例吗？如果我们想测试链接上的点击，并看到它在游戏不可用时触发 preventDefault 函数，那么在游戏组件测试中测试它有意义吗？

# 一个可能的解决方案

到目前为止，我们已经看到，我们做出了几个决定，使游戏组件和每个游戏本身真正相互耦合。但是如果我们把这些部分分开，为游戏本身创建另一个组件会怎么样呢？

游戏组件，没有与游戏本身相关的逻辑，它只知道需要在列表中呈现它们

封装了与游戏相关的所有逻辑，它不依赖于游戏呈现的上下文

所以我们创建了两个独立的组件，一个叫做游戏，另一个叫做游戏。通过这样做，我们获得了几个好处:

*   最引人注目的是游戏组件**变成了更小更简单的组件**。它现在更容易阅读和维护，测试将只需要通过和测试与游戏道具和标题道具相关的场景。**无需为游戏特定功能创建边缘案例。**
*   用于类的名称空间现在被分离在两个组件之间，使得我们的类相互独立。分离这些组件也允许我们分离我们的风格，可能为每个组件创建单独的文件。
*   游戏道具直接在游戏组件上验证，而不是在游戏组件中验证。**游戏组件实际上是一个声明渲染**所必需的东西的组件，并不依赖于保存它们的数据结构。同样，**我们可以为 isAvailable 和 isFeatured 声明那些默认道具**，直接在游戏组件中设置默认行为。
*   我们还使游戏组件独立于它所呈现的上下文。以前，没有办法在列表之外呈现图像。现在，我们可以在任何我们想要的地方使用游戏组件，在列表中，单独地，或者以另一种方式。当分离组件时，我们可以提取功能并增加我们的可重用性。
*   最后，**测试变得更加简单和有针对性**，因为例如，与特色和可用性功能相关的测试是在游戏组件上直接测试的，而游戏组件并不知道这一点。在未来，如果游戏组件有进一步的变化，我们将添加适当的测试到该套件中，我们的游戏组件对此仍然是不可知的。

# 总结一下！

当我们的组件从一段可维护和可重用的代码变成一个包含大量功能的大型复杂组件时，在开发 React 组件时肯定会有一个断点。这起初看起来很简单，但在开发过程的后期，迭代和新功能会将这些组件变成一个雪球，每次都添加越来越多的代码，成为这个庞大的结构，每个人都害怕被它击中。

为了避免这种情况，请花些时间仔细考虑每个功能应该放在哪里，以及它放在特定的组件中是否有意义，或者迁移到另一个组件可能会在将来的某个时候节省您的时间。试着看看是什么帮助你的代码更容易维护和阅读，我希望我找到的这些指针能让你知道在编写 React 组件时应该问什么问题:)