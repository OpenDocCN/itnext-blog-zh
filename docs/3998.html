<html>
<head>
<title>How to rewrite HTTP-Request-Paths in Quarkus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Quarkus中重写HTTP-Request-Paths</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-rewrite-http-request-paths-in-quarkus-aa85c3400d95?source=collection_archive---------7-----------------------#2020-04-07">https://itnext.io/how-to-rewrite-http-request-paths-in-quarkus-aa85c3400d95?source=collection_archive---------7-----------------------#2020-04-07</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><p id="cfc1" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在我们的项目中，我们有一个REST-Api监听<em class="km"> BASE_PATH/v1.0/resource </em>。现在人们也想通过调用<em class="km"> BASE_PATH/v1/resource </em>来访问这个。这篇文章向您展示了如何在没有额外外部工具的情况下在<a class="ae kn" href="https://quarkus.io/" rel="noopener ugc nofollow" target="_blank"> Quarkus </a>中实现这一点。</p><figure class="kp kq kr ks gu kt gi gj paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gi gj ko"><img src="../Images/8cd166cbce1c2c1eb8d9180ca5286c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gcwh0o3Zz7bVVzx9lZ-GLQ.jpeg"/></div></div><figcaption class="la lb gk gi gj lc ld bd b be z dk translated">Gerald Schmidtkunz auf Pixabay </figcaption></figure><p id="af42" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">Quarkus内部构建了许多技术，其中一项是<a class="ae kn" href="https://vertx.io" rel="noopener ugc nofollow" target="_blank"> Eclipse Vert.x </a>。<a class="ae kn" href="https://vertx.io/docs/vertx-web/java/#_basic_vert_x_web_concepts" rel="noopener ugc nofollow" target="_blank"> Vert.x Web路由器</a>(及其包含的Netty)提供了HTTP-stack的较低层，其他层如OpenAPI servlet或RestEasy for JAX-RS构建于其上。这意味着，每个传入的HTTP请求都会通过Vert。x在它被分派之前。</p><figure class="kp kq kr ks gu kt gi gj paragraph-image"><div class="gi gj le"><img src="../Images/43b36357d2aef58a29ceeb421ea813bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*XQunwOIlaM_g5FiEjS0loA.png"/></div><figcaption class="la lb gk gi gj lc ld bd b be z dk translated">通过堆栈的HTTP请求方式</figcaption></figure><p id="e41f" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">如果你看了上面的内容，那么很明显Vert.x是进行这种重写处理的地方(它可以是Netty，但是虽然Netty很强大，但它也太低级了，无法处理；Vert.x在那里做了很多繁重的工作，是做这件事的最佳层)。</p><p id="6d0c" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">Vert.x提供了所谓的RouteFilters，可以插入内部转发路径。这些过滤器只是Vert.x路由处理程序的特殊类型，其中完成工作的方法用<em class="km">io . quar kus . vertx . web . route filter .</em>注释</p><pre class="kp kq kr ks gu lf lg lh li aw lj bi"><span id="8b11" class="lk ll ir lg b gz lm ln l lo lp"><strong class="lg is">@RouteFilter</strong>(400)                             //  (1)<br/>void myRedirector(RoutingContext rc) {<br/>  String uri = rc.request().uri();            //  (2)<br/> <br/>  if (uri.startsWith("<em class="km">BASE_PATH/v1/"</em>)) {       //  (3)<br/>    String remain = uri.substring("<em class="km">BASE_PATH/v1/"</em>.length());  // (4)<br/>   <br/>    rc.<strong class="lg is">reroute</strong>("<em class="km">BASE_PATH/v1.0/" </em>+remain);     //  (5)<br/>    return; // &lt;-- This is important here<br/>  }<br/>  rc.next();<br/>}</span></pre><p id="77f0" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在(1)中，我们需要给过滤器一个优先级；较高的数字意味着该筛选器比优先级较低的筛选器更早被调用。在②中我们确定了请求——URI。如果它匹配我们想要重写的前缀(3)，我们确定URI的剩余部分(4)，它也包含查询参数等。在(5)中，我们用新的URI调用route()，通知Vert.x它应该进行重写。记住不要在之后调用<em class="km"> rc.next() </em>很重要，因为这会混淆Vert.x。</p><h2 id="67c6" class="lk ll ir bd lq lr ls dn lt lu lv dp lw jz lx ly lz kd ma mb mc kh md me mf mg bi translated">结论</h2><p id="cc7f" class="pw-post-body-paragraph jo jp ir jq b jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ml kj kk kl ik bi translated"><a class="ae kn" href="https://vertx.io/docs/vertx-web/java/#_basic_vert_x_web_concepts" rel="noopener ugc nofollow" target="_blank"> Vert.x web路由器</a>是Quarkus中的逻辑点，用于独立于更高层中使用的应用程序框架来修改HTTP请求。你也可以在反应路线指南中阅读更多关于<a class="ae kn" href="https://quarkus.io/guides/reactive-routes" rel="noopener ugc nofollow" target="_blank"> Quarkus和Vert.x的相互作用。</a></p></div></div>    
</body>
</html>