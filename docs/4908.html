<html>
<head>
<title>I Want My MT(v)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我想要我的MT(v)</h1>
<blockquote>原文：<a href="https://itnext.io/i-want-my-mt-v-6d7c691fb308?source=collection_archive---------3-----------------------#2020-10-21">https://itnext.io/i-want-my-mt-v-6d7c691fb308?source=collection_archive---------3-----------------------#2020-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="782f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">或者在golang中使用Actor模式的多线程</h2></div><p id="3d77" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">那没用，那是你做的方式<br/>免费的频道和免费的线程</em></p><p id="671c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">(本博客授权</em><a class="ae lf" href="https://creativecommons.org/licenses/by/4.0/" rel="noopener ugc nofollow" target="_blank"/><em class="le">所有代码授权</em><a class="ae lf" href="https://www.apache.org/licenses/LICENSE-2.0" rel="noopener ugc nofollow" target="_blank"><em class="le">https://www.apache.org/licenses/LICENSE-2.0</em></a><em class="le">)</em></p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/ad1a657141631307361445f11a2c15e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dTcPggmX02gGNRrJ4nXn_Q.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">吉他图片来自<a class="ae lf" href="https://flyclipart.com/electric-guitar-clipart-free-download-clip-art-electric-guitar-clipart-729992" rel="noopener ugc nofollow" target="_blank">https://flyclipart . com/electric-guitar-clip art-free-download-clip-art-electric-guitar-clip art-729992</a></figcaption></figure><p id="0792" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我最近和一位工程师一起审查代码，在那里我提出了一个消息队列的golang抽象。他们发现我的界面很奇怪，因为我本质上是使用goroutines和channels执行同步动作。考虑以下接口:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/af3976202a3b11f3f64e2d18c66f05f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*SMzK8AzYC7MucFuEaqpIxQ.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">目标接口</figcaption></figure><p id="eb2d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想在这个接口上写一个抽象，接受各种实现(例如写到一个保持打开的文件的末尾)，解决线程安全问题，并允许我的程序一次处理任意数量的队列。</p><h1 id="64ca" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">标准解决方案</h1><p id="a314" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">我的同事提出了以下抽象接口:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/0e07ad09f32599645b288a8243ffdada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*kXqN3PudBbpoOViFtyibNQ.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">golang的Java</figcaption></figure><p id="3f14" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">写</em>和<em class="le">转储</em>功能是同步的，并且至少在某种程度上是上下文感知的(稍后将详细介绍)。这是一个非常合理的抽象，您可以用标准的面向对象的方式来使用:</p><p id="1bfd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">1)创建编写器。</p><p id="12e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2)打电话写一些路线。</p><p id="1d6b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">3)调用goroutines中的Dump。</p><p id="2967" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">4)使用某种内存屏障来保证这些操作不会竞争。</p><p id="3edb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个实现示例:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mv"><img src="../Images/bf5f876823c4e7c4fb098e46bb933ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6CTqBqsVKcPuJJ6scvqXkg.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">互斥使它变得安全</figcaption></figure><p id="0d2b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">互斥体用于保护这两个映射结构。这些映射包含对非线程安全对象的引用。即使对映射的访问是在临界区内完成的，也不能在内存屏障之外的队列对象上调用任何方法。这是不幸的，因为我们不能利用<em class="le"> Prep </em>函数的纯粹性，并且在没有潜在竞争条件的情况下并行使用它。</p><p id="c9eb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该实现可以同步使用，如下所示:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mw"><img src="../Images/3fae077e2a23659056546dd045299c0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IjgUVkhNRnNIzCYN_LTA6A.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">简单而优雅</figcaption></figure><p id="3a22" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">异步地:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mx"><img src="../Images/77266780943a30c0ff55cf1d8abdfb68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AyfyCsguZih4HtjIOtT0wg.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">叉和加入，就像过去一样</figcaption></figure><p id="515e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个界面很简单。只要它与相对较少的并发写入者一起使用，并且队列的写入时间/CPU成本相对较低，这种解决方案就能很好地发挥作用。不幸的是，当编写库抽象时，创建抽象的人对如何使用它几乎没有控制。理想的做法是避免为了写入一个队列而必须锁定所有命名队列，并且理想的做法是在系统中引入弹性，以处理突发流量/在<em class="le">准备</em> / <em class="le">写入</em>时的可变等待时间。</p><h1 id="f114" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">演员解决方案</h1><p id="b401" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">下面的接口将编写器本身呈现为一个响应任意信号的参与者，而不是一个单独的“<em class="le"> Write </em>方法。此结构代表用户行事，但间接这样做:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi my"><img src="../Images/2914d8c9d8ff8f093bb3d2bdb88da12d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rr30Qki8KRdLTL1zmk0CFQ.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">它使用信道，所以它必须很快</figcaption></figure><p id="e069" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很大程度上是不言自明的。actor必须在可以使用之前被"<em class="le"> Started </em>"，一旦完成，就可以创建作为写通道(隐式线程安全)的Writers。虽然它不接受纯字节，但是它有一个新的用户可以用来交互的对象，即<em class="le"> WriteRequest </em>:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/b72cf387cdc6bb7bc0598cd78ac26ab3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*voVqSAlu_aQ5Z13En7uzqQ.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">golang的Javascript</figcaption></figure><p id="d7ff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个对象是简单地从一个字节片输入中创建的，但也作为一个承诺。当调用者希望知道写操作的结果时，只有当写操作完成时(或者上下文已经过期)，才能使用“<em class="le">”方法发出回调。</em></p><p id="afa0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">了解了这一点，我们可以看看这些演员是如何构成的:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi na"><img src="../Images/5ce38cf1e5e2936e7cb36aeb5e8409e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ptBU-sdeQLJBmDKtSWYaFw.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">队列在哪里？</figcaption></figure><p id="a011" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，<em class="le"> AsyncWriter </em>中的一切都是线程安全的，假设<em class="le"> open </em>函数不会对不同的命名队列产生副作用。还要注意，与前面的编写器不同，结构中没有存储打开队列的位置。相反，它们存在于函数堆栈中。在我们开始之前，首先让我们看一下公共编写器函数，因为它也说明了golang中这个actor模式的一个关键特性:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nb"><img src="../Images/301d0cb6e4821ff4e269bb33aeca5683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v717ppr0-GMSl_uigdKn1g.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">这里没有排队，你忘了吗？</figcaption></figure><p id="a293" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">引用我同事的话:“什么是<em class="le"> chan chan </em>？”。由于每个命名队列的通道必须由actor线程创建，因此通道的通道用于与调用者通信。<em class="le"> Writer </em>方法是从“线程0”中调用的，因此用于任何给定队列的通道通信也必须通过一个通道。此外，请注意，上下文不再以同样的方式使用。go上下文的<em class="le"> Done() </em>通道在每个select中使用，而不是检查临界区中的错误条件(以避免关机时的睡眠理发师问题)。在上下文过期(关闭等)的情况下，内部通道上的接收/发送决不会阻塞。).</p><p id="23ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，考虑到公共接口，这里是演员本身:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/7835a43c044866054552f2b6a76217e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*U829TSXGwEEspmpVJ0oNcw.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">说真的，我想你忘了实际的队列…</figcaption></figure><p id="45fd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“<em class="le"> actor </em>”方法是私有的，并且像该实现中的所有方法一样，不是指针接收器(接收结构的副本，不能直接改变任何成员)。actor方法包含两个映射，但是同样，队列本身也不存在。actor的主循环包含关闭上下文2种情况:</p><p id="9478" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">1)接收一个转储请求，将其发送给“<em class="le">转储</em>方法。</p><p id="2a73" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2)接收“作者”请求。</p><p id="5071" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关注主路径，我们看到返回给<em class="le">作者</em>的调用者的通道图在这里被管理，还有转储数据的逻辑。每当一个新的队列被打开时，另一个线程就开始代表actor，一个"<em class="le"> receiver </em>"来实际读取给调用者的通道。进入<em class="le">接收器</em>后，我们终于在堆栈上找到了开放队列:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/fd74fd47fddaa35351429abb3527e0e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*W4G7JaLl3oQeYsj_yBPn8Q.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">最后，但为什么它只在堆栈上？</figcaption></figure><p id="2280" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像它的父goroutine一样，这个接收器只是一个用于 - <em class="le">选择</em>循环的<em class="le">。接收并处理转储队列的请求。这里进行非线程安全的"<em class="le"> Write </em>"调用，结果交给一个goroutine来处理。响应承诺是无缓冲的，因此在没有立即调用“<em class="le"> Then </em>”的情况下，这是必要的。</em></p><p id="a178" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了这些，问题可能是，我们为什么要烦恼呢？看这个演员是怎么用的有帮助。从测试中我们看到了一个原型函数:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/0dc7073fa477985812d2302c45ffd93a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*LvEyQWunguOnP0hnbvNt4Q.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">想象一下在Initialize()方法或构造函数中使用它</figcaption></figure><p id="8a52" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建并开始编写器(暂时忽略间谍<em class="le"> NewSlowQ </em>)。收集了几个命名队列供以后写入。</p><p id="2af6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于同步操作，由于承诺和对上下文的处理，代码比第一个实现稍微复杂一些:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/54d9a7df67f9a10fb8e427e12d0edf52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*u516YFXABYaQ4L8kxHB58g.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">现在看起来很像Javascript</figcaption></figure><p id="877f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更复杂，但是我们已经获得了一个优于面向对象方法的优势:它的核心是上下文感知的。与其他会阻塞<em class="le"> Prep </em>和<em class="le"> Write </em>的实现不同，当上下文结束时，主执行将立即被释放，一旦这些调用异步完成，相关的goroutines将自动终止。</p><p id="591e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不甘示弱的异步实现稍微复杂一些，但大多数是锅炉板线程管理:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/10e4dac21814ef9193220b3e97dce6d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*9YzjxrHbrzyGYI0I8DZiFg.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">…更深入一点</figcaption></figure><p id="c049" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将利用通道收集错误，依赖于actor本身的相同技术。唯一值得注意的区别是<em class="le">错误</em>通道相对较短，如果它已满，额外的错误将被丢弃(没有"<em class="le">零</em>"错误可能会浪费资源和队列深度)</p><h1 id="d70d" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">证明它</h1><p id="06b0" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">解释了这个机制之后，我们又回到了根本问题:为什么要这么麻烦？已经说明了，除了更好地处理上下文，标准的面向对象解决方案可以异步使用。证明演员是更好的方法的唯一方法是测量它。我用以下场景构建了基准:</p><ol class=""><li id="3c13" class="nh ni it kk b kl km ko kp kr nj kv nk kz nl ld nm nn no np bi translated">两种实现的同步操作。</li><li id="080b" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated">两种实现的异步操作。</li><li id="4a23" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated">猝发操作，其中停滞期的持续时间与流量洪流之间的写入时间大致相同。</li><li id="d80d" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated">10、100和500同时打开队列。</li></ol><p id="5c50" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">队列的“实现”如下:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nv"><img src="../Images/c06daf290ed802575e29bde555aa338c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fsyhx7QcVFnvNiIKrX723A.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">一个纯粹的“Prep”函数通过输入的一个副本，对于这些测试preRatio==1</figcaption></figure><p id="f169" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">原始数据:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nw"><img src="../Images/b62a5ffcbe150416e64571300aa6d802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HgLuyFJyGrkkOSSTi_AB_Q.png"/></div></div></figure><p id="0b09" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有漂亮的照片:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nx"><img src="../Images/6504605a1ad1086ab27affd0f38f7dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*orkGiU_ziOL_tPivsvnETA.png"/></div></div></figure><p id="16b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有许多功能会立即跳出来:</p><ol class=""><li id="48c4" class="nh ni it kk b kl km ko kp kr nj kv nk kz nl ld nm nn no np bi translated">当同步使用时，传统的互斥方法在某些情况下比actor执行得更好(~%10)。</li><li id="cca2" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated">异步使用时，actor始终比基于互斥的解决方案高出40%左右。</li><li id="2fba" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated">对开放队列的引用的非线程安全性迫使互斥方法保护整个写操作。由于这个关键部分，异步线程的性能无法产生更好的结果。</li><li id="1fbb" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated">参与者处理突发流量的效率要高得多，而且随着管理的队列越来越多，这种效率会显著提高(速度提高4倍)。</li></ol><h1 id="34d4" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">结论</h1><p id="aeaa" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">在说明行动者模式的过程中，还应该清楚的是，通过在golang中以不同的方式思考问题，可以获得很大的效率收益。“<em class="le">陈</em>”和“<em class="le">走</em>”关键词应该被当作一等公民对待，因为他们是。正确使用时，它们应该像go代码中的“<em class="le"> if </em>”和“<em class="le"> for </em>”控制结构一样常见。</p><p id="6eb8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通道不仅仅是一个通信缓冲区。这个实现说明了它们可以实现其他同步抽象，比如承诺。反过来，Goroutines可以负责管理只能通过通道访问并存储在堆栈上的动态资源。它们不仅需要使程序的各个部分异步。最后，通过这两个核心关键字，golang“context”与actor模式协同工作，在多线程代码中创建快速取消和关闭行为。</p><p id="88e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">示例都是在Apache 2.0许可下获得许可的，可在<a class="ae lf" href="https://github.com/weberr13/ChannelsForNothing/" rel="noopener ugc nofollow" target="_blank">https://github.com/weberr13/ChannelsForNothing/</a>获得</p></div></div>    
</body>
</html>