<html>
<head>
<title>Ahaless: write serverless application OOP on top of Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器:在Typescript之上编写无服务器应用程序OOP</h1>
<blockquote>原文：<a href="https://itnext.io/ahaless-write-serverless-application-oop-on-top-of-typescript-ffbab8e5c4db?source=collection_archive---------1-----------------------#2020-02-21">https://itnext.io/ahaless-write-serverless-application-oop-on-top-of-typescript-ffbab8e5c4db?source=collection_archive---------1-----------------------#2020-02-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b67d00d0e81b017ae4651f8ce676546c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iPgmsUJHbmY8YJDdI9kevg.jpeg"/></div></div></figure><blockquote class="jy jz ka"><p id="4b2a" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="iq">在所谓的云原生技术中，无服务器已经变得非常流行。它承诺只为您使用的东西付费，并自动扩展，这将标杆设置到了一个新的高度。你不必担心基础设施，只需担心你的代码。</em></p><p id="1818" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="iq">与此同时</em><strong class="ke ir"><em class="iq">JavaScript</em></strong><em class="iq">或者更准确地说Node.js已经成为编写无服务器应用程序最流行的语言之一。可能有很多原因，但我猜想JavaScript在serverless中的流行是由于它们的一些相似之处:都专注于快速的</em><strong class="ke ir"><em class="iq"/></strong><em class="iq">上市时间，并且都在</em> <strong class="ke ir"> <em class="iq">前端</em> </strong> <em class="iq">开发人员中特别受欢迎。</em></p><p id="628b" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="iq">来源:</em><a class="ae la" href="https://lesscodeismore.dev/serverless-typescript/" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://lesscodeismore.dev/serverless-typescript/</em></a></p></blockquote><h1 id="4bf6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我们的问题呢？</h1><p id="9c7a" class="pw-post-body-paragraph kb kc iq ke b kf lz kh ki kj ma kl km mb mc kp kq md me kt ku mf mg kx ky kz ij bi translated">在<a class="ae la" href="https://ahamove.com/" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir">a移除</strong> </a>，我们大量使用Javascript with Serverless。然而，用Javascript编写无服务器应用程序有一些缺点。例如，我们必须一次又一次地编写重复的代码。虽然我们可以为所有项目创建一个模板，但这不是一个好主意，因为这些代码仍然在我们的源代码中重复。此外，当我们添加新函数或更改这些名称时，我们必须更新<code class="fe mh mi mj mk b">serverless.yml</code>文件——这是一项繁琐的任务。</p><p id="3df3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km mb ko kp kq md ks kt ku mf kw kx ky kz ij bi translated">另一方面，Javascript是一种动态类型语言。它没有类型检查，自动补全不好用，容易出错。</p><h1 id="c077" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为什么我们使用Typescript！</h1><p id="4eec" class="pw-post-body-paragraph kb kc iq ke b kf lz kh ki kj ma kl km mb mc kp kq md me kt ku mf mg kx ky kz ij bi translated">Typescript解决了我们的问题，与无服务器框架和AWS Lambdas一起工作很好。它有类型检查、更好的IDE支持、严格的空检查、类、接口、装饰器等等……我们可以在开发阶段检查语法错误。</p><h1 id="11f1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是依赖注入？</h1><blockquote class="jy jz ka"><p id="391c" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">依赖注入是一种技术，通过它一个对象提供另一个对象的依赖。</p><p id="3599" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">引用自<a class="ae la" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">维基</a></p></blockquote><p id="72c3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km mb ko kp kq md ks kt ku mf kw kx ky kz ij bi translated">那是什么意思？你的软件的某个<em class="kd">部分</em>(通常称为<em class="kd">注入器</em>)负责构建对象，而不是手动构建你的对象。</p><p id="965c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km mb ko kp kq md ks kt ku mf kw kx ky kz ij bi translated">想象下面的代码:</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/c89f2a4aab38b6d9dcb1a347ecdbecf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sDIlv0N8hZEhuROQCZAORw.png"/></div></div></figure><p id="a3cd" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km mb ko kp kq md ks kt ku mf kw kx ky kz ij bi translated">这是不好的，有很多原因，比如类之间有直接和不可交换的依赖关系，测试会变得非常困难，遵循你的代码变得非常困难，组件的重用变得更加困难，等等..另一方面，<em class="kd">依赖注入将</em>依赖注入到你的构造函数中，使得所有这些<em class="kd">不好的</em>东西都过时了:安装</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/61ba020b9477525b2bee9e2a96656c15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l_U8UljmGdd7UeqqIdLsLg.png"/></div></div></figure><p id="5626" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km mb ko kp kq md ks kt ku mf kw kx ky kz ij bi translated"><em class="kd">不凉。</em></p><p id="d3a9" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km mb ko kp kq md ks kt ku mf kw kx ky kz ij bi translated">通过使用负责创建对象的<em class="kd">注入器</em>，您可以简单地完成如下操作:</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/4918f926822e615bef7ada860bbb59d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4wTIKjYlaHuKVKwFclGJSQ.png"/></div></div></figure><p id="4955" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km mb ko kp kq md ks kt ku mf kw kx ky kz ij bi translated"><em class="kd">更好。</em></p><p id="5b64" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km mb ko kp kq md ks kt ku mf kw kx ky kz ij bi translated">有很多理由说明为什么应该进行依赖注入，包括可测试性、可维护性、可读性等等..再说一遍，如果你还不知道，那是时候学习一些重要的东西了。</p><blockquote class="jy jz ka"><p id="0e0f" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">来源:<a class="ae la" href="https://nehalist.io/dependency-injection-in-typescript/" rel="noopener ugc nofollow" target="_blank">https://nehalist.io/dependency-injection-in-typescript/</a></p></blockquote><h1 id="3193" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我们如何解决这些问题？</h1><p id="f452" class="pw-post-body-paragraph kb kc iq ke b kf lz kh ki kj ma kl km mb mc kp kq md me kt ku mf mg kx ky kz ij bi translated">我们决定基于<a class="ae la" href="https://serverless.com/plugins/serverless-plugin-typescript/" rel="noopener ugc nofollow" target="_blank">server less-plugin-typescript</a>创建一个新的框架，它也有DI模式。我们称它为<strong class="ke ir"> Ahaless </strong></p><h1 id="d870" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">装置</h1><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="2060" class="mu lc iq mk b gy mv mw l mx my"># Step 1: Install serverless globally<br/>npm i -g serverless</span><span id="165a" class="mu lc iq mk b gy mz mw l mx my"># Step 2: Create service in new folder using a custom template<br/>serverless create --template-url <a class="ae la" href="https://github.com/lynkxyz/ahaless-template" rel="noopener ugc nofollow" target="_blank">https://github.com/lynkxyz/ahaless-template</a> --path hello-cat</span><span id="4bf7" class="mu lc iq mk b gy mz mw l mx my"># Step 3: Go to the folder and install dependencies<br/>cd hello-cat &amp;&amp; yarn</span></pre><p id="f109" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km mb ko kp kq md ks kt ku mf kw kx ky kz ij bi translated">在这个模板中，我们使用了两个插件:</p><ul class=""><li id="50fd" class="na nb iq ke b kf kg kj kk mb nc md nd mf ne kz nf ng nh ni bi translated"><a class="ae la" href="https://www.npmjs.com/package/@ahamove/ahaless" rel="noopener ugc nofollow" target="_blank"> @ahamove/ahaless </a>(我们会在本博客后面解释)</li><li id="3f05" class="na nb iq ke b kf nj kj nk mb nl md nm mf nn kz nf ng nh ni bi translated"><a class="ae la" href="https://www.npmjs.com/package/@ahamove/serverless-generate-functions" rel="noopener ugc nofollow" target="_blank">@ ahamove/server less-generate-functions</a>(会根据<code class="fe mh mi mj mk b">Ahaless</code>生成无服务器函数)</li></ul><h1 id="d93d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">开始</h1><p id="ccce" class="pw-post-body-paragraph kb kc iq ke b kf lz kh ki kj ma kl km mb mc kp kq md me kt ku mf mg kx ky kz ij bi translated">首先，我们可以看到项目结构类似于Angular和NestJS。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/6f4b6d2df884fbcf4bd505a304f704e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_sQAq_Az7NXqGU6epJ6dvw.png"/></div></div></figure><p id="fd0c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km mb ko kp kq md ks kt ku mf kw kx ky kz ij bi translated">我们在根项目中有<code class="fe mh mi mj mk b">handler.ts</code>文件。我们需要将所有子模块导入到根<code class="fe mh mi mj mk b">module</code>中，让<code class="fe mh mi mj mk b">Ahaless</code>知道你想要使用什么模块。在这个例子中，我们使用了两个模块。还有<code class="fe mh mi mj mk b">DatabaseModule</code>和<code class="fe mh mi mj mk b">CatsModule</code>。<code class="fe mh mi mj mk b">static exports</code>使用NodeJS的全局导出对象将所有函数导出到它的。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/0c85abbbb66d7bfea0c3a73c50546a25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8tGcuBCVcc9iIOd5FG0t4Q.png"/></div></div></figure><p id="fed9" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km mb ko kp kq md ks kt ku mf kw kx ky kz ij bi translated">在<code class="fe mh mi mj mk b">cats.service.ts</code>文件中，我们定义了一个名为<code class="fe mh mi mj mk b">CatsService</code>的类。我们在类之前添加了一个装饰器<code class="fe mh mi mj mk b">@injectable</code>，让<code class="fe mh mi mj mk b">Ahaless</code>知道它是一个依赖类，然后我们可以在以后注入它。这个类构造函数还注入了一个服务is <code class="fe mh mi mj mk b">DatabaseService</code>。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/47c7046a063eed2c88acc2cca31fb8d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZB5cSORvsZvtyqmsyGaFLg.png"/></div></div></figure><p id="65e3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km mb ko kp kq md ks kt ku mf kw kx ky kz ij bi translated">在<code class="fe mh mi mj mk b">cats.handler.ts</code>文件中，我们创建一个名为<code class="fe mh mi mj mk b">CatsHandler</code>的类。<code class="fe mh mi mj mk b">@handler</code>装饰器表明这个类是一个控制器。在类体中，我们使用这些<code class="fe mh mi mj mk b">@get</code>、<code class="fe mh mi mj mk b">@post</code>装饰器来从<code class="fe mh mi mj mk b">GET</code>和<code class="fe mh mi mj mk b">POST</code>方法中调用这些函数。默认情况下，<code class="fe mh mi mj mk b">Ahaless</code>将使用函数名来创建API路径，但是如果您想要使用自定义名称，您可以将<code class="fe mh mi mj mk b">path</code>名称作为第一个参数传递。另外，你也可以使用<code class="fe mh mi mj mk b">@medthod</code>、<code class="fe mh mi mj mk b">@put</code>、<code class="fe mh mi mj mk b">@delete</code>装饰者。</p><p id="869f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km mb ko kp kq md ks kt ku mf kw kx ky kz ij bi translated">我们还提供了<code class="fe mh mi mj mk b">@validator</code>来验证<code class="fe mh mi mj mk b">body</code>和<code class="fe mh mi mj mk b">param</code>参数。你可以查看<a class="ae la" href="https://github.com/typestack/class-validator" rel="noopener ugc nofollow" target="_blank">类验证器</a>的文档以获得更多信息。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/046bcda0e658a87a40b2633a858669fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Br9T7V1X6qG3KiMFXMMbGQ.png"/></div></div></figure><p id="c68f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km mb ko kp kq md ks kt ku mf kw kx ky kz ij bi translated">在我们的例子中，我们定义API <code class="fe mh mi mj mk b">create_cat</code>的主体必须具有<code class="fe mh mi mj mk b">name</code>类型<code class="fe mh mi mj mk b">string</code>。如果键<code class="fe mh mi mj mk b">name</code>无效或丢失。它会向客户端抛出错误。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/ae93895cc1cc6872b049143ba4483c24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RIJHrt1nqhg7Fu3hJtvpwg.png"/></div></div></figure><p id="9890" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km mb ko kp kq md ks kt ku mf kw kx ky kz ij bi translated">最后，您需要将<code class="fe mh mi mj mk b">CatsHandler</code>和<code class="fe mh mi mj mk b">CatsService</code>导入到<code class="fe mh mi mj mk b">CatsModule</code>中。不需要将<code class="fe mh mi mj mk b">exports</code>对象设置为子模块中的<code class="fe mh mi mj mk b">static exports</code>。只需在根模块中完成即可。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/636736c849d48791f15c6d7a1cd28be0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7DkNjnt574oB00tpId_szw.png"/></div></div></figure><p id="1f4c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km mb ko kp kq md ks kt ku mf kw kx ky kz ij bi translated">要运行这个项目，只需运行这个命令。<code class="fe mh mi mj mk b">Ahaless</code>将自动生成功能列表。你再也不需要那样了。</p><h1 id="f027" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="a387" class="pw-post-body-paragraph kb kc iq ke b kf lz kh ki kj ma kl km mb mc kp kq md me kt ku mf mg kx ky kz ij bi translated">我们解决了我们的问题。我们可以使用DI模式、类型检查、更好的IDE支持、严格的空检查、类、接口、装饰器等等。此外，我们可以编写许多无服务器功能，但不需要编写重复的代码。干！！！</p><p id="5a20" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km mb ko kp kq md ks kt ku mf kw kx ky kz ij bi translated">然而，它也有一些缺点，如:</p><ul class=""><li id="1bf1" class="na nb iq ke b kf kg kj kk mb nc md nd mf ne kz nf ng nh ni bi translated"><a class="ae la" href="https://docs.nestjs.com/fundamentals/async-providers" rel="noopener ugc nofollow" target="_blank">异步提供者</a></li><li id="86dd" class="na nb iq ke b kf nj kj nk mb nl md nm mf nn kz nf ng nh ni bi translated"><a class="ae la" href="https://docs.nestjs.com/fundamentals/circular-dependency" rel="noopener ugc nofollow" target="_blank">循环依赖</a></li><li id="173a" class="na nb iq ke b kf nj kj nk mb nl md nm mf nn kz nf ng nh ni bi translated">测试</li></ul><p id="93a1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km mb ko kp kq md ks kt ku mf kw kx ky kz ij bi translated">如果您想为我们的项目做出贡献或有任何问题，请提出您的请求并在<a class="ae la" href="https://github.com/lynkxyz/ahaless" rel="noopener ugc nofollow" target="_blank"> Github页面</a>中创建新问题</p></div></div>    
</body>
</html>