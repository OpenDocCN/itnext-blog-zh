<html>
<head>
<title>Integrating Hibernate Reactive with Spring</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">集成Hibernate Reactive和Spring</h1>
<blockquote>原文：<a href="https://itnext.io/integrating-hibernate-reactive-with-spring-5427440607fe?source=collection_archive---------0-----------------------#2021-08-27">https://itnext.io/integrating-hibernate-reactive-with-spring-5427440607fe?source=collection_archive---------0-----------------------#2021-08-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ac03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Hibernate启动了一个子项目——Hibernate Reactive支持反应流，但是在我写这篇文章的时候，Spring仍然没有支持Hibernate Reactive。好消息是集成工作并不复杂。在这篇文章中，我们将尝试集成最新的Hibernate Reactive和Spring框架。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/f9351fb548f3e465146a30fb41d9fca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n4q8pWVkhuvNGMID3AOKHw.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/@qriusv?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Vivek Kumar </a>在<a class="ae lb" href="https://unsplash.com/s/photos/china-landscape?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="4348" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在前一篇<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/integrating-vertx-application-with-spring-framework-fb8fca81a357">将Vertx与Spring框架集成</a>和<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/building-a-vertx-application-with-smallrye-mutiny-bindings-spring-and-hibernate-reactive-5cf10b57983a">后一篇</a>中，我们已经将Hibernate Reactive与Spring IOC容器集成，但是在那些帖子中，web处理是由Vertx Web完成的。在这篇文章中，我们将使用现有的Spring WebFlux。</p><p id="dbbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打开浏览器，导航到<a class="ae lb" href="https://start.spring.io" rel="noopener ugc nofollow" target="_blank">https://start . spring . io</a>，生成一个Spring项目框架，包含以下依赖关系:</p><ul class=""><li id="4b23" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><em class="ll"> WebFlux </em></li><li id="0805" class="lc ld iq jp b jq lm ju ln jy lo kc lp kg lq kk lh li lj lk bi translated"><em class="ll">龙目岛</em></li></ul><p id="f6ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将下载的文件解压到光盘中，并将项目导入到IDE中。</p><p id="b06d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打开项目<em class="ll"> pom.xml </em>文件，添加以下依赖项。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="6dcd" class="lw lx iq ls b gy ly lz l ma mb">&lt;dependency&gt;<br/>    &lt;groupId&gt;io.vertx&lt;/groupId&gt;<br/>    &lt;artifactId&gt;vertx-pg-client&lt;/artifactId&gt;<br/>    &lt;version&gt;${vertx-pg-client.version}&lt;/version&gt;<br/>&lt;/dependency&gt;</span><span id="62e8" class="lw lx iq ls b gy mc lz l ma mb">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.hibernate.reactive&lt;/groupId&gt;<br/>    &lt;artifactId&gt;hibernate-reactive-core&lt;/artifactId&gt;<br/>    &lt;version&gt;${hibernate-reactive.version}&lt;/version&gt;<br/>&lt;/dependency&gt;</span><span id="1b72" class="lw lx iq ls b gy mc lz l ma mb">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;<br/>    &lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt;<br/>    &lt;optional&gt;true&lt;/optional&gt;<br/>&lt;/dependency&gt;</span></pre><p id="6826" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码中:</p><ul class=""><li id="127f" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><code class="fe md me mf ls b">vertx-pg-client</code>是休眠反应所需的Postgres反应驱动程序。</li><li id="bcf1" class="lc ld iq jp b jq lm ju ln jy lo kc lp kg lq kk lh li lj lk bi translated"><code class="fe md me mf ls b">hibernate-reactive-core</code>是Hibernate Reactive的核心依赖。</li><li id="5be5" class="lc ld iq jp b jq lm ju ln jy lo kc lp kg lq kk lh li lj lk bi translated">类似于一般的Hibernate/JPA支持，<code class="fe md me mf ls b">hibernate-jpamodelgen</code>用于从<code class="fe md me mf ls b">@Entity</code>类生成实体元数据类。</li></ul><p id="3d44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将<em class="ll"> persistence.xml </em>添加到<em class="ll">src/main/resources/META-INF</em>文件夹中。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="7d5e" class="lw lx iq ls b gy ly lz l ma mb">&lt;persistence <br/>             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br/>             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd"<br/>             version="2.2"&gt;</span><span id="b709" class="lw lx iq ls b gy mc lz l ma mb">    &lt;persistence-unit name="blogPU"&gt;<br/>        &lt;provider&gt;org.hibernate.reactive.provider.ReactivePersistenceProvider&lt;/provider&gt;</span><span id="898e" class="lw lx iq ls b gy mc lz l ma mb">        &lt;class&gt;com.example.demo.Post&lt;/class&gt;</span><span id="b062" class="lw lx iq ls b gy mc lz l ma mb">        &lt;properties&gt;</span><span id="0b6c" class="lw lx iq ls b gy mc lz l ma mb">            &lt;!-- PostgreSQL --&gt;<br/>            &lt;property name="javax.persistence.jdbc.url"<br/>                      value="jdbc:postgresql://localhost:5432/blogdb"/&gt;</span><span id="442a" class="lw lx iq ls b gy mc lz l ma mb">            &lt;!-- Credentials --&gt;<br/>            &lt;property name="javax.persistence.jdbc.user"<br/>                      value="user"/&gt;<br/>            &lt;property name="javax.persistence.jdbc.password"<br/>                      value="password"/&gt;</span><span id="97eb" class="lw lx iq ls b gy mc lz l ma mb">            &lt;!-- The Vert.x SQL Client connection pool size --&gt;<br/>            &lt;property name="hibernate.connection.pool_size"<br/>                      value="10"/&gt;</span><span id="abec" class="lw lx iq ls b gy mc lz l ma mb">            &lt;!-- Automatic schema export --&gt;<br/>            &lt;property name="javax.persistence.schema-generation.database.action"<br/>                      value="drop-and-create"/&gt;</span><span id="7fc2" class="lw lx iq ls b gy mc lz l ma mb">            &lt;!-- SQL statement logging --&gt;<br/>            &lt;property name="hibernate.show_sql" value="true"/&gt;<br/>            &lt;property name="hibernate.format_sql" value="true"/&gt;<br/>            &lt;property name="hibernate.highlight_sql" value="true"/&gt;</span><span id="e610" class="lw lx iq ls b gy mc lz l ma mb">        &lt;/properties&gt;</span><span id="2c39" class="lw lx iq ls b gy mc lz l ma mb">    &lt;/persistence-unit&gt;</span><span id="52df" class="lw lx iq ls b gy mc lz l ma mb">&lt;/persistence&gt;</span></pre><p id="fc4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意<code class="fe md me mf ls b">provider</code>必须使用新Hibernate Reactive中提供的<code class="fe md me mf ls b">ReactivePersistenceProvider</code>类。您必须将所有的实体类添加到这个<em class="ll"> persistence.xml </em>文件中。</p><p id="28b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后声明一个<code class="fe md me mf ls b">Mutiny.SessionFactory</code> bean。<code class="fe md me mf ls b">blogPU</code>是在<em class="ll"> persistence.xml </em>文件中配置的持久性单元名称。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="60e2" class="lw lx iq ls b gy ly lz l ma mb">@Bean<br/>public Mutiny.SessionFactory sessionFactory() {<br/>    return Persistence.createEntityManagerFactory("blogPU")<br/>        .unwrap(Mutiny.SessionFactory.class);<br/>}</span></pre><p id="0fd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个示例实体类。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="0c78" class="lw lx iq ls b gy ly lz l ma mb">@Data<br/>@NoArgsConstructor<br/>@AllArgsConstructor(staticName = "of")<br/>@Builder<br/>@Entity<br/>@Table(name = "posts")<br/>public class Post {</span><span id="7f16" class="lw lx iq ls b gy mc lz l ma mb">    @Id<br/>    @GeneratedValue(generator = "uuid")<br/>    @GenericGenerator(name = "uuid", strategy = "uuid2")<br/>    UUID id;<br/>    String title;<br/>    String content;</span><span id="b948" class="lw lx iq ls b gy mc lz l ma mb">    @Builder.Default<br/>    @Column(name = "created_at")<br/>    @CreationTimestamp<br/>    LocalDateTime createdAt = LocalDateTime.now();<br/>}</span></pre><p id="67cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后为它创建一个<code class="fe md me mf ls b">Repository</code>类。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="a62b" class="lw lx iq ls b gy ly lz l ma mb">@Component<br/>@RequiredArgsConstructor<br/>public class PostRepository {<br/>    private static final Logger LOGGER = Logger.getLogger(PostRepository.class.getName());</span><span id="5e06" class="lw lx iq ls b gy mc lz l ma mb">    private final Mutiny.SessionFactory sessionFactory;</span><span id="e301" class="lw lx iq ls b gy mc lz l ma mb">    public Uni&lt;List&lt;Post&gt;&gt; findAll() {<br/>        CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder();<br/>        // create query<br/>        CriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.class);<br/>        // set the root class<br/>        Root&lt;Post&gt; root = query.from(Post.class);<br/>        return this.sessionFactory.withSession(session -&gt; session.createQuery(query).getResultList());<br/>    }</span><span id="fd2b" class="lw lx iq ls b gy mc lz l ma mb">    public Uni&lt;List&lt;Post&gt;&gt; findByKeyword(String q, int offset, int limit) {</span><span id="68d0" class="lw lx iq ls b gy mc lz l ma mb">        CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder();<br/>        // create query<br/>        CriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.class);<br/>        // set the root class<br/>        Root&lt;Post&gt; root = query.from(Post.class);</span><span id="dba7" class="lw lx iq ls b gy mc lz l ma mb">        // if keyword is provided<br/>        if (q != null &amp;&amp; !q.trim().isEmpty()) {<br/>            query.where(<br/>                cb.or(<br/>                    cb.like(root.get(Post_.title), "%" + q + "%"),<br/>                    cb.like(root.get(Post_.content), "%" + q + "%")<br/>                )<br/>            );<br/>        }<br/>        //perform query<br/>        return this.sessionFactory.withSession(session -&gt; session.createQuery(query)<br/>            .setFirstResult(offset)<br/>            .setMaxResults(limit)<br/>            .getResultList());<br/>    }<br/></span><span id="6f2e" class="lw lx iq ls b gy mc lz l ma mb">    public Uni&lt;Post&gt; findById(UUID id) {<br/>        Objects.requireNonNull(id, "id can not be null");<br/>        return this.sessionFactory.withSession(session -&gt; session.find(Post.class, id))<br/>            .onItem().ifNull().failWith(() -&gt; new PostNotFoundException(id));<br/>    }</span><span id="4c00" class="lw lx iq ls b gy mc lz l ma mb">    public Uni&lt;Post&gt; save(Post post) {<br/>        if (post.getId() == null) {<br/>            return this.sessionFactory.withSession(session -&gt;<br/>                session.persist(post)<br/>                    .chain(session::flush)<br/>                    .replaceWith(post)<br/>            );<br/>        } else {<br/>            return this.sessionFactory.withSession(session -&gt; session.merge(post).onItem().call(session::flush));<br/>        }<br/>    }</span><span id="17f1" class="lw lx iq ls b gy mc lz l ma mb">    public Uni&lt;Integer&gt; deleteById(UUID id) {<br/>        CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder();<br/>        // create delete<br/>        CriteriaDelete&lt;Post&gt; delete = cb.createCriteriaDelete(Post.class);<br/>        // set the root class<br/>        Root&lt;Post&gt; root = delete.from(Post.class);<br/>        // set where clause<br/>        delete.where(cb.equal(root.get(Post_.id), id));<br/>        // perform update<br/>        return this.sessionFactory.withTransaction((session, tx) -&gt;<br/>            session.createQuery(delete).executeUpdate()<br/>        );<br/>    }</span><span id="9c08" class="lw lx iq ls b gy mc lz l ma mb">    public Uni&lt;Integer&gt; deleteAll() {<br/>        CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder();<br/>        // create delete<br/>        CriteriaDelete&lt;Post&gt; delete = cb.createCriteriaDelete(Post.class);<br/>        // set the root class<br/>        Root&lt;Post&gt; root = delete.from(Post.class);<br/>        // perform update<br/>        return this.sessionFactory.withTransaction((session, tx) -&gt;<br/>            session.createQuery(delete).executeUpdate()<br/>        );<br/>    }</span><span id="14c3" class="lw lx iq ls b gy mc lz l ma mb">}</span></pre><p id="898b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，我们已经将Hibernate Reactive与Spring IOC容器集成在一起，接下来我们将使用<code class="fe md me mf ls b">PostRepositoy</code>与后端数据库握手。让我们开始构建web处理部分。</p><p id="f9bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Hibernate Reactive中有两种不同类型的异步API，一种基于Java 8 <code class="fe md me mf ls b">CompletionStage</code>，另一种基于<a class="ae lb" href="https://smallrye.io/smallrye-mutiny" rel="noopener ugc nofollow" target="_blank"> Smallrye社区项目</a>。后者完全实现了Reactive Streams规范，我们在本文中使用SmallRye哗变。</p><p id="b6f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但遗憾的是，Spring并没有像RxJava 2/3等那样内置Smallrye兵变支持。</p><p id="0059" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用一些可能的解决方案来克服这一障碍。</p><ul class=""><li id="75ab" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">将SmallRye APIs转换为Reactor API，然后在<code class="fe md me mf ls b">RouterFunction</code>或<code class="fe md me mf ls b">Controller</code>类中直接使用Reactor API。</li><li id="58ca" class="lc ld iq jp b jq lm ju ln jy lo kc lp kg lq kk lh li lj lk bi translated">类似于Spring WebFlux中现有的RxJava 1/2/3、JDK 9+流支持，我们可以将Smallry Munity注册为另一个ReactiveStreams正式反应器的替代方案。</li></ul><p id="8595" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们一个一个的去探索。</p><p id="522c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们尝试将社区API转换为反应器API。假设我们将使用<code class="fe md me mf ls b">RouterFunction</code>来处理web请求。</p><p id="515b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将以下依赖项添加到项目<em class="ll"> pom.xml </em>文件中。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="bd9f" class="lw lx iq ls b gy ly lz l ma mb">&lt;dependency&gt;<br/>    &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt;<br/>    &lt;artifactId&gt;mutiny-reactor&lt;/artifactId&gt;<br/>    &lt;version&gt;${mutiny-reactor.version}&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="7b84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe md me mf ls b">mutiny-reactor</code>提供了一些可以用来在SmallRye哗变和Reactor之间转换API的工具。</p><p id="3b3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个<code class="fe md me mf ls b">PostsHandler</code>的例子，我们将所有的web处理程序集中在一个类中。在这个类中，我们将所有的兵变API转换为反应堆API。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="3fc5" class="lw lx iq ls b gy ly lz l ma mb">@Component<br/>@RequiredArgsConstructor<br/>class PostsHandler {</span><span id="56dd" class="lw lx iq ls b gy mc lz l ma mb">    private final PostRepository posts;</span><span id="7a02" class="lw lx iq ls b gy mc lz l ma mb">    public Mono&lt;ServerResponse&gt; all(ServerRequest req) {<br/>        return ServerResponse.ok().body(this.posts.findAll().convert().with(toMono()), Post.class);<br/>    }</span><span id="3b4d" class="lw lx iq ls b gy mc lz l ma mb">    public Mono&lt;ServerResponse&gt; create(ServerRequest req) {<br/>        return req.bodyToMono(CreatePostCommand.class)<br/>            .flatMap(post -&gt; this.posts.save(<br/>                        Post.builder()<br/>                            .title(post.getTitle())<br/>                            .content(post.getContent())<br/>                            .build()<br/>                    )<br/>                    .convert().with(toMono())<br/>            )<br/>            .flatMap(p -&gt; ServerResponse.created(URI.create("/posts/" + p.getId())).build());<br/>    }</span><span id="fea7" class="lw lx iq ls b gy mc lz l ma mb">    public Mono&lt;ServerResponse&gt; get(ServerRequest req) {<br/>        var id = UUID.fromString(req.pathVariable("id"));<br/>        return this.posts.findById(id).convert().with(toMono())<br/>            .flatMap(post -&gt; ServerResponse.ok().body(Mono.just(post), Post.class))<br/>            .switchIfEmpty(ServerResponse.notFound().build());<br/>    }</span><span id="de4c" class="lw lx iq ls b gy mc lz l ma mb">    public Mono&lt;ServerResponse&gt; update(ServerRequest req) {</span><span id="3b56" class="lw lx iq ls b gy mc lz l ma mb">        var id = UUID.fromString(req.pathVariable("id"));<br/>        return Mono.zip((data) -&gt; {<br/>                    Post p = (Post) data[0];<br/>                    UpdatePostCommand p2 = (UpdatePostCommand) data[1];<br/>                    p.setTitle(p2.getTitle());<br/>                    p.setContent(p2.getContent());<br/>                    return p;<br/>                },<br/>                this.posts.findById(id).convert().with(toMono()),<br/>                req.bodyToMono(UpdatePostCommand.class)<br/>            )<br/>            //.cast(Post.class)<br/>            .flatMap(post -&gt; this.posts.save(post).convert().with(toMono()))<br/>            .flatMap(post -&gt; ServerResponse.noContent().build());<br/>    }</span><span id="6a6c" class="lw lx iq ls b gy mc lz l ma mb">    public Mono&lt;ServerResponse&gt; delete(ServerRequest req) {<br/>        var id = UUID.fromString(req.pathVariable("id"));<br/>        return this.posts.deleteById(id).convert().with(toMono())<br/>            .flatMap(d -&gt; ServerResponse.noContent().build());<br/>    }<br/>}</span></pre><p id="3bb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后在一个<code class="fe md me mf ls b">RouterFunction</code> bean中组装web处理程序。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="63d0" class="lw lx iq ls b gy ly lz l ma mb">@Bean<br/>public RouterFunction&lt;ServerResponse&gt; routes(PostsHandler handler) {<br/>    return route(GET("/posts"), handler::all)<br/>        .andRoute(POST("/posts"), handler::create)<br/>        .andRoute(GET("/posts/{id}"), handler::get)<br/>        .andRoute(PUT("/posts/{id}"), handler::update)<br/>        .andRoute(DELETE("/posts/{id}"), handler::delete);<br/>}</span></pre><p id="45a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在启动应用程序时，添加一个<code class="fe md me mf ls b">DataInitializer</code> bean来初始化一些示例数据。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="8444" class="lw lx iq ls b gy ly lz l ma mb">@Component<br/>@RequiredArgsConstructor<br/>public class DataInitializer implements ApplicationRunner {</span><span id="041a" class="lw lx iq ls b gy mc lz l ma mb">    private final static Logger LOGGER = Logger.getLogger(DataInitializer.class.getName());</span><span id="30eb" class="lw lx iq ls b gy mc lz l ma mb">    private final Mutiny.SessionFactory sessionFactory;</span><span id="3c60" class="lw lx iq ls b gy mc lz l ma mb">    @Override<br/>    public void run(ApplicationArguments args) throws Exception {<br/>        LOGGER.info("Data initialization is starting...");</span><span id="60a6" class="lw lx iq ls b gy mc lz l ma mb">        Post first = Post.of(null, "Hello Spring", "My first post of Spring", null);<br/>        Post second = Post.of(null, "Hello Hibernate Reactive", "My second Hibernate Reactive", null);</span><span id="b9c8" class="lw lx iq ls b gy mc lz l ma mb">        sessionFactory<br/>            .withTransaction(<br/>                (conn, tx) -&gt; conn.createQuery("DELETE FROM Post").executeUpdate()<br/>                    .flatMap(r -&gt; conn.persistAll(first, second))<br/>                    .chain(conn::flush)<br/>                    .flatMap(r -&gt; conn.createQuery("SELECT p from Post p", Post.class).getResultList())<br/>            )<br/>            .subscribe()<br/>            .with(<br/>                data -&gt; LOGGER.log(Level.INFO, "saved data:{0}", data),<br/>                throwable -&gt; LOGGER.warning("Data initialization is failed:" + throwable.getMessage())<br/>            );<br/>    }<br/>}</span></pre><p id="ea2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">启动Postgres数据库。有一个<a class="ae lb" href="https://github.com/hantsy/spring-puzzles/blob/master/hibernate-reactive/docker-compose.yml" rel="noopener ugc nofollow" target="_blank"><em class="ll">docker-compose . yml</em></a>文件可用于在Docker容器中启动Postgres实例。</p><p id="88ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后通过Spring Boot Maven插件运行应用程序。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="ca43" class="lw lx iq ls b gy ly lz l ma mb">// start postgres database<br/>docker compose up </span><span id="c72a" class="lw lx iq ls b gy mc lz l ma mb">// run the application<br/>mvn clean spring-root:run</span></pre><p id="322e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当应用程序成功运行时，打开您的终端，尝试使用<code class="fe md me mf ls b">curl</code>命令测试<a class="ae lb" href="http://localhost:8080/posts" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/posts</a>端点。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="bdc8" class="lw lx iq ls b gy ly lz l ma mb"># curl http://localhost:8080/posts<br/>[{"id":"0998578e-0553-480b-bbb7-e96fd402455f","title":"Hello Spring","content":"My first post of Spring","createdAt":"2021-08-26T22:37:02.076284"},{"id":"e09ffa71-905f-4241-9449-0860977de666","title":"Hello Hibernate Reactive","content":"My second Hibernate Reactive","createdAt":"2021-08-26T22:37:02.116677"}]</span><span id="e6b3" class="lw lx iq ls b gy mc lz l ma mb"># curl http://localhost:8080/posts/0998578e-0553-480b-bbb7-e96fd402455f<br/>{"id":"0998578e-0553-480b-bbb7-e96fd402455f","title":"Hello Spring","content":"My first post of Spring","createdAt":"2021-08-26T22:37:02.076284"}</span></pre><p id="f8aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么我们来讨论第二种解决方案。</p><p id="15b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Spring内部使用一个<code class="fe md me mf ls b">ReactiveAdapterRegistry</code>来注册所有的reactive streams实现，比如RxJava 2/3、JDK 9+ Flow等。当序列化实现者的特定API时，它将查找注册表并将其转换为可由Spring框架处理的标准RectiveStreams APIs。</p><p id="6054" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将创建一个新的适配器来注册预期的哗变API。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="3b31" class="lw lx iq ls b gy ly lz l ma mb">@Component<br/>@RequiredArgsConstructor<br/>@Slf4j<br/>public class MutinyAdapter {<br/>    private final ReactiveAdapterRegistry registry;</span><span id="278e" class="lw lx iq ls b gy mc lz l ma mb">    @PostConstruct<br/>    public void registerAdapters(){<br/>        log.debug("registering MutinyAdapter");<br/>        registry.registerReactiveType(<br/>            ReactiveTypeDescriptor.singleOptionalValue(Uni.class, ()-&gt; Uni.createFrom().nothing()),<br/>            uni -&gt;((Uni&lt;?&gt;)uni).convert().toPublisher(),<br/>            publisher -&gt;  Uni.createFrom().publisher(publisher)<br/>        );</span><span id="b426" class="lw lx iq ls b gy mc lz l ma mb">        registry.registerReactiveType(<br/>            ReactiveTypeDescriptor.multiValue(Multi.class, ()-&gt; Multi.createFrom().empty()),<br/>            multi -&gt; (Multi&lt;?&gt;) multi,<br/>            publisher-&gt; Multi.createFrom().publisher(publisher));<br/>    }<br/>}</span></pre><p id="7dbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后创建一个直接调用<code class="fe md me mf ls b">PostRepository</code>的<code class="fe md me mf ls b">@RestController</code> bean。如你所见，所有方法都直接返回一个<code class="fe md me mf ls b">ResponseEntity</code>类型或一个<code class="fe md me mf ls b">Uni&lt;ResponseEntity&gt;</code>类型，不需要显式的转换工作。</p><pre class="km kn ko kp gt lr ls lt lu aw lv bi"><span id="8ce8" class="lw lx iq ls b gy ly lz l ma mb">@RestController<br/>@RequestMapping("/posts")<br/>@RequiredArgsConstructor<br/>class PostController {</span><span id="c914" class="lw lx iq ls b gy mc lz l ma mb">    private final PostRepository posts;</span><span id="a6cb" class="lw lx iq ls b gy mc lz l ma mb">    @GetMapping(value = "", produces = MediaType.APPLICATION_JSON_VALUE)<br/>    public ResponseEntity&lt;?&gt; all() {<br/>        return ok().body(this.posts.findAll());<br/>    }</span><span id="133c" class="lw lx iq ls b gy mc lz l ma mb">    @PostMapping(value = "", consumes = MediaType.APPLICATION_JSON_VALUE)<br/>    public Uni&lt;ResponseEntity&lt;?&gt;&gt; create(@RequestBody CreatePostCommand data) {<br/>        return this.posts.save(<br/>                Post.builder()<br/>                    .title(data.getTitle())<br/>                    .content(data.getContent())<br/>                    .build()<br/>            )<br/>            .map(p -&gt; created(URI.create("/posts/" + p.getId())).build());<br/>    }</span><span id="fd1c" class="lw lx iq ls b gy mc lz l ma mb">    @GetMapping(value = "{id}", produces = MediaType.APPLICATION_JSON_VALUE)<br/>    public Uni&lt;ResponseEntity&lt;Post&gt;&gt; get(@PathVariable UUID id) {<br/>        return this.posts.findById(id)<br/>            .map(post -&gt; ok().body(post));<br/>    }</span><span id="2205" class="lw lx iq ls b gy mc lz l ma mb">    @PutMapping(value = "{id}", consumes = MediaType.APPLICATION_JSON_VALUE)<br/>    public Uni&lt;ResponseEntity&lt;?&gt;&gt; update(@PathVariable UUID id, @RequestBody UpdatePostCommand data) {</span><span id="7fed" class="lw lx iq ls b gy mc lz l ma mb">        return Uni.combine().all()<br/>            .unis(<br/>                this.posts.findById(id),<br/>                Uni.createFrom().item(data)<br/>            )<br/>            .combinedWith((p, d) -&gt; {<br/>                p.setTitle(d.getTitle());<br/>                p.setContent(d.getContent());<br/>                return p;<br/>            })<br/>            .flatMap(this.posts::save)<br/>            .map(post -&gt; noContent().build());<br/>    }</span><span id="b42a" class="lw lx iq ls b gy mc lz l ma mb">    @DeleteMapping("{id}")<br/>    public Uni&lt;ResponseEntity&lt;?&gt;&gt; delete(@PathVariable UUID id) {<br/>        return this.posts.deleteById(id).map(d -&gt; noContent().build());<br/>    }<br/>}</span></pre><p id="ec43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再次运行此应用程序，您将获得与前一个解决方案相同的结果。</p><h2 id="c05b" class="lw lx iq bd mg mh mi dn mj mk ml dp mm jy mn mo mp kc mq mr ms kg mt mu mv mw bi translated">从我的GitHub获得这篇文章的源代码，它们在两个独立的项目中可用，<a class="ae lb" href="https://github.com/hantsy/spring-puzzles/tree/master/hibernate-reactive" rel="noopener ugc nofollow" target="_blank"> hibernate-reactive </a>和<a class="ae lb" href="https://github.com/hantsy/spring-puzzles/tree/master/hibernate-reactive-mutiny" rel="noopener ugc nofollow" target="_blank">hibernate-reactive-哗变</a>。</h2></div></div>    
</body>
</html>