<html>
<head>
<title>I’ve successfully converted 10 lines of Bash script into a 100 lines of code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我已经成功地将10行Bash脚本转换成了100行代码</h1>
<blockquote>原文：<a href="https://itnext.io/ive-successfully-converted-10-lines-bash-script-into-a-100-lines-of-code-8d5dc73751a1?source=collection_archive---------0-----------------------#2020-04-06">https://itnext.io/ive-successfully-converted-10-lines-bash-script-into-a-100-lines-of-code-8d5dc73751a1?source=collection_archive---------0-----------------------#2020-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1d1ed2a862091a3a9b30d55b79247a5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i41nO0tn9quikZ-z"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@aleskrivec?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ales Krivec </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="2429" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我有10行bash脚本，用于在命令行上显示虚拟机的信息，作为虚拟机命令行程序的一部分。</p><p id="3f28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此命令用于在命令行中列出虚拟机信息，如下所示:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="7ed2" class="ll lm iq lh b gy ln lo l lp lq">$ vermin ls<br/>VM NAME  IMAGE           CPU  MEM     TAGS<br/>vm_01    ubuntu/bionic   2    4096    spark kafka hadoop<br/>vm_02    ubuntu/bionic   1    1024<br/>vm_03    ubuntu/bionic   1    1024</span></pre><p id="8479" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我遇到的问题是，该脚本为每个显示信息的虚拟机花费了大约<strong class="kf ir"> 150 ms </strong>。<br/>在上面的示例中，它花费了大约<strong class="kf ir"> 500毫秒，</strong>如果我有更多虚拟机，它将花费更多时间。</p><p id="2a22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们继续我为改进脚本运行时间所做的工作之前，让我们展示一下bash脚本:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lr ls l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">bash脚本片段</figcaption></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="a6b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的脚本——除了读取一些文件——调用命令<code class="fe ma mb mc lh b">vboxmanage showinfo myvm --machinereadable</code>,这显然是脚本中最耗时的指令。</p><p id="f935" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我决定为我拥有的每个虚拟机并行运行这个命令，这样就不用花费(<strong class="kf ir">虚拟机数量* 150毫秒)</strong>，总时间大约需要150毫秒。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="f06d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我决定使用<strong class="kf ir"> Golang </strong>，这样我就可以利用它惊人的goroutines来并行调用我所拥有的虚拟机的<code class="fe ma mb mc lh b">vmboxmanage</code>命令。</p><p id="f1b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是<a class="ae kc" href="https://github.com/mhewedy/vermin/blob/6bf3ba223447a0b262faf51bb11cdbb0c1dddbf1/vms/list.go#L83-L103" rel="noopener ugc nofollow" target="_blank">代码中与</a>相关的部分:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="e383" class="ll lm iq lh b gy ln lo l lp lq"><strong class="lh ir">type </strong>vmInfoList []*vmInfo<br/>....<br/>....</span><span id="2df5" class="ll lm iq lh b gy md lo l lp lq">numVms := len(vms)<br/><br/>infoList := make(vmInfoList, numVms)<br/><strong class="lh ir">var </strong>wg sync.WaitGroup<br/>wg.Add(numVms)<br/><br/><strong class="lh ir">for </strong>i, vmName := <strong class="lh ir">range </strong>vms {<br/>   <strong class="lh ir">go func</strong>(vm string, i int) {<br/>      infoList[i] = getVMInfo(vm)<br/>      wg.Done()<br/>   }(vmName, i)<br/>}</span><span id="518b" class="ll lm iq lh b gy md lo l lp lq">wg.Wait()</span></pre><p id="81df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的要点是，我在虚拟机上循环，对于每一个虚拟机，我在一个调用命令<code class="fe ma mb mc lh b">vboxmanage</code>并执行其他I/O操作并将<code class="fe ma mb mc lh b">vmInfo</code>结构返回给调用者的goroutine(把它想象成一个轻量级线程)中调用<code class="fe ma mb mc lh b">getVMInfo</code>。</p><p id="e9a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我使用来自每个goroutine的<strong class="kf ir">通道</strong>将结果收集到一个<strong class="kf ir"> select </strong>语句中，该语句带有一个等待结果的循环，一旦我得到了所有等待的结果，我就中断。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="c8db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这如何提高我的程序的性能？</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="4827" class="ll lm iq lh b gy ln lo l lp lq">$ time vermin ls<br/>VM NAME  IMAGE           CPU  MEM      TAGS<br/>vm_01    ubuntu/bionic   2    4096     spark kafka hadoop<br/>vm_02    ubuntu/bionic   1    1024<br/>vm_03    ubuntu/bionic   1    1024</span><span id="0835" class="ll lm iq lh b gy md lo l lp lq">vm ls 0.14s user 0.12s system 118% cpu 0.219 total</span></pre><p id="c787" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如图所示，性能从<strong class="kf ir"> n * 150毫秒</strong>(在本例中大约为450到500毫秒)上升到大约220毫秒。</p><p id="b9cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在5个虚拟机上重复了上面的命令，我得到了一个相似的数字。</p><p id="c609" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在<a class="ae kc" href="https://github.com/mhewedy/vm/blob/7d08c983387d6f92784c280490925a7cbc01dd14/vminfo/main.go" rel="noopener ugc nofollow" target="_blank"> GitHub上找到完整的100多行代码。</a></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="d7bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能认为500毫秒甚至1秒钟并不算长，但是让我告诉你，<code class="fe ma mb mc lh b"><em class="lb">docker ps</em></code>显示10个容器<strong class="kf ir">的信息需要不到<strong class="kf ir"> 100毫秒</strong>。</strong></p><p id="751a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我完成上面的程序后，我意识到VirtualBox(我所依赖的)使用一个<code class="fe ma mb mc lh b">XML</code>格式的文件来存储关于每个VM的信息，所以我可能会尝试读取和解析该文件，甚至使程序更具响应性。</p><p id="539b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">顺便说一下，我写bash脚本用了10 ~ 15分钟，而go程序花了1 ~ 2个小时:)。</p><p id="e55f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是包含整个程序的GitHub repo:<br/><em class="lb">(如果你认为有用，请在项目的GitHub页面上打个星号</em>🚀)</p><div class="me mf gp gr mg mh"><a href="https://github.com/mhewedy/vermin" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd ir gy z fp mm fr fs mn fu fw ip bi translated">mhewedy/害虫</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">目录:害虫是一个智能，简单和强大的命令行工具，用于Linux，Windows和macOS。它被设计成…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">github.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv jw mh"/></div></div></a></div></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="76ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更新:</p><p id="5ffa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我直接从<code class="fe ma mb mc lh b">.vbox</code>文件中读取虚拟机信息后，程序现在正在运行，5个虚拟机只需要不到<strong class="kf ir"> 80毫秒</strong>。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="5dbf" class="ll lm iq lh b gy ln lo l lp lq">$ time vermin ls<br/>VM NAME  IMAGE           CPU  MEM      TAGS<br/>vm_01    ubuntu/bionic   2    4096      spark kafka hadoop<br/>vm_02    ubuntu/bionic   1    1024<br/>vm_03    ubuntu/bionic   1    1024<br/>vm_04    ubuntu/bionic   1    1024<br/>vm_05    ubuntu/bionic   1    1024</span><span id="7219" class="ll lm iq lh b gy md lo l lp lq">vm ls  0.03s user 0.03s system 76% cpu 0.077 total</span></pre><p id="79f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更新2:</p><p id="2b85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我已经根据Reddit 中<a class="ae kc" href="https://www.reddit.com/r/golang/comments/gpdmb4/ive_successfully_converted_10_lines_bash_script/" rel="noopener ugc nofollow" target="_blank">评论的建议，将代码从使用通道和选择器改为简单使用<code class="fe ma mb mc lh b">WaitGroup</code>。</a></p></div></div>    
</body>
</html>