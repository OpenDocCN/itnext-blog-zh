<html>
<head>
<title>How to use a RecyclerView to show images from storage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用RecyclerView显示存储中的图像</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-use-a-recyclerview-to-show-images-from-storage-c99ac407599f?source=collection_archive---------5-----------------------#2019-07-06">https://itnext.io/how-to-use-a-recyclerview-to-show-images-from-storage-c99ac407599f?source=collection_archive---------5-----------------------#2019-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/799a4cc7bb1727bb0dca03c0120d5229.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*DtYCIJi5RZadyNYhRK_oqw.gif"/></div></figure><h1 id="a794" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">眼前的问题</h1><p id="4893" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><a class="ae lq" href="https://developer.android.com/guide/topics/ui/layout/recyclerview" rel="noopener ugc nofollow" target="_blank"> RecyclerView </a>小部件是ListView的一个更高级、更灵活的版本。它根据滚动位置管理和优化视图固定器绑定，并回收视图，以便只使用少量视图来处理大量列表项。鉴于RecyclerView <a class="ae lq" href="https://github.com/googlesamples/android-RecyclerView/" rel="noopener ugc nofollow" target="_blank">示例应用程序</a>已经过时，甚至无法编译，本教程旨在展示一种相对快速的方法来将RecyclerView添加到现代Android Studio项目中，并使用它来显示我们将下载到设备的随机图像列表。</p><h1 id="2620" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">创建新项目</h1><p id="dabd" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">创建新项目(或打开现有项目)。在创建项目时，我们将选择为这个示例添加一个滚动活动，但是您可以选择您想要的任何布局。</p><p id="dff5" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">现在运行它进行一个小的健全性检查:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/e0a4256e9e40de2a766b3e802710769c.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*3hGLkq6HJsYuJkXc.png"/></div></figure><h1 id="ca8c" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">添加列表片段</h1><p id="9c6b" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">右击项目文件夹-&gt;添加-&gt;片段(列表)-&gt;完成</p><p id="3abd" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">这将创建一个包含大量样板代码的RecyclerView。让我们回顾一下添加的类:</p><p id="0fd9" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated"><code class="fe ma mb mc md b">MyItemRecyclerViewAdapter</code> -创建视图持有人，它持有列表中项目的视图，并将数据绑定到视图持有人内部的视图。</p><p id="3534" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated"><code class="fe ma mb mc md b">ItemFragment</code> -保存和初始化适配器的片段。</p><p id="8934" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated"><code class="fe ma mb mc md b">Dummy/DummyContent</code> -填充列表的虚拟项目。我们将用我们的图片项目替换那些。</p><p id="b2d9" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated"><code class="fe ma mb mc md b">fragment_item_list.xml</code> -包含RecyclerView小工具。</p><p id="cb89" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated"><code class="fe ma mb mc md b">fragment_item.xml</code> -列表中每个项目的布局。</p><p id="f292" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">现在我们需要将我们创建的片段添加到我们的活动中。在<code class="fe ma mb mc md b">content_scrolling.xml</code>中，将文本视图替换为:</p><pre class="lw lx ly lz gt me md mf mg aw mh bi"><span id="1779" class="mi jv iq md b gy mj mk l ml mm">&lt;fragment android:name="com.example.myapplication.ItemFragment"<br/>    android:id="@+id/main_fragment"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent" /&gt;</span></pre><p id="a3d4" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">我们还将让活动实现我们的交互监听器接口:</p><pre class="lw lx ly lz gt me md mf mg aw mh bi"><span id="eafe" class="mi jv iq md b gy mj mk l ml mm">implements ItemFragment.OnListFragmentInteractionListener</span></pre><p id="8597" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">在将它添加到activity类之后，您必须实现onListFragmentInteraction方法，您可以使用建议窗口自动实现它。这是添加的自动生成的方法:</p><pre class="lw lx ly lz gt me md mf mg aw mh bi"><span id="5b93" class="mi jv iq md b gy mj mk l ml mm">@Override<br/>public void onListFragmentInteraction(DummyContent.DummyItem item) {    <br/>}</span></pre><p id="d030" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">现在运行项目，查看列表显示和滚动:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/51f8f8029d62b61223f85dc0c99ea02c.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*-ycAjp6xwujfN_Nr.png"/></div></figure><h1 id="d59f" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">替换虚拟内容</h1><p id="4ee6" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在android studio中，将<code class="fe ma mb mc md b">DummyContent.java</code>重命名为<code class="fe ma mb mc md b">PictureContent.java</code>(以及类名)，并将其移出<code class="fe ma mb mc md b">dummy</code>包。删除虚拟包。我们还将删除<code class="fe ma mb mc md b">DummyItem</code>类，并在一个新文件中创建一个POJO类<code class="fe ma mb mc md b">PictureItem</code>，包含图片URI和创建日期:</p><pre class="lw lx ly lz gt me md mf mg aw mh bi"><span id="dc55" class="mi jv iq md b gy mj mk l ml mm">class PictureItem {<br/>    public Uri uri;<br/>    public String date;<br/>}</span></pre><p id="a132" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">在<code class="fe ma mb mc md b">PictureContent</code>中，用<code class="fe ma mb mc md b">PictureItem</code>创作替换<code class="fe ma mb mc md b">DummyItem</code>创作:</p><pre class="lw lx ly lz gt me md mf mg aw mh bi"><span id="ac87" class="mi jv iq md b gy mj mk l ml mm">public class PictureContent {<br/>    static final List&lt;PictureItem&gt; ITEMS = new ArrayList&lt;&gt;();<br/><br/>    public static void loadImage(File file) {<br/>        PictureItem newItem = new PictureItem();<br/>        newItem.uri = Uri.fromFile(file);<br/>        newItem.date = getDateFromUri(newItem.uri);<br/>        addItem(newItem);<br/>    }<br/><br/>    private static void addItem(PictureItem item) {<br/>        ITEMS.add(0, item);<br/>    }<br/>}</span></pre><p id="6d07" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">现在我们将更新<code class="fe ma mb mc md b">fragment_item.xml</code>来显示我们的图像项，用<code class="fe ma mb mc md b">ImageView</code>表示图像，用<code class="fe ma mb mc md b">TextView</code>表示创建日期:</p><pre class="lw lx ly lz gt me md mf mg aw mh bi"><span id="ed62" class="mi jv iq md b gy mj mk l ml mm">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    android:orientation="horizontal"&gt;<br/><br/>    &lt;ImageView<br/>        android:id="@+id/item_image_view"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:contentDescription="@string/app_name"<br/>        android:scaleType="centerInside"<br/>        android:padding="10dp" /&gt;<br/><br/>    &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:orientation="vertical"&gt;<br/>    &lt;TextView<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:layout_margin="@dimen/text_margin"<br/>        android:text="@string/created_at"<br/>        android:textAppearance="?attr/textAppearanceListItem" /&gt;<br/><br/>    &lt;TextView<br/>        android:id="@+id/item_date_tv"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:layout_margin="@dimen/text_margin"<br/>        android:textAppearance="?attr/textAppearanceListItem" /&gt;<br/>    &lt;/LinearLayout&gt;<br/>&lt;/LinearLayout&gt;</span></pre><p id="ac21" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">最后，在<code class="fe ma mb mc md b">MyItemRecyclerViewAdapter</code>中，替换内容以将新的数据字段绑定到新的视图:</p><pre class="lw lx ly lz gt me md mf mg aw mh bi"><span id="f0de" class="mi jv iq md b gy mj mk l ml mm">public class MyItemRecyclerViewAdapter extends RecyclerView.Adapter&lt;MyItemRecyclerViewAdapter.ViewHolder&gt; {<br/><br/>    private final List&lt;PictureItem&gt; mValues;<br/>    private final OnListFragmentInteractionListener mListener;<br/><br/>    public MyItemRecyclerViewAdapter(List&lt;PictureItem&gt; items, OnListFragmentInteractionListener listener) {<br/>        mValues = items;<br/>        mListener = listener;<br/>    }<br/><br/>    @Override<br/>    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {<br/>        View view = LayoutInflater.from(parent.getContext())<br/>                .inflate(R.layout.fragment_item, parent, false);<br/>        return new ViewHolder(view);<br/>    }<br/><br/>    @Override<br/>    public void onBindViewHolder(final ViewHolder holder, int position) {<br/>        holder.mItem = mValues.get(position);<br/>        holder.mImageView.setImageURI(mValues.get(position).uri);<br/>        holder.mDateView.setText(mValues.get(position).date);<br/><br/>        holder.mView.setOnClickListener(new View.OnClickListener() {<br/>            @Override<br/>            public void onClick(View v) {<br/>                if (null != mListener) {<br/>                    // Notify the active callbacks interface (the activity, if the<br/>                    // fragment is attached to one) that an item has been selected.<br/>                    mListener.onListFragmentInteraction(holder.mItem);<br/>                }<br/>            }<br/>        });<br/>    }<br/><br/>    @Override<br/>    public int getItemCount() {<br/>        return mValues.size();<br/>    }<br/><br/>    public class ViewHolder extends RecyclerView.ViewHolder {<br/>        public final View mView;<br/>        public final ImageView mImageView;<br/>        public final TextView mDateView;<br/>        public PictureItem mItem;<br/><br/>        public ViewHolder(View view) {<br/>            super(view);<br/>            mView = view;<br/>            mImageView = view.findViewById(R.id.item_image_view);<br/>            mDateView = view.findViewById(R.id.item_date_tv);<br/>        }<br/>    }<br/>}</span></pre><h1 id="bae2" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">加载图片</h1><p id="ef02" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">现在，我们将用保存在设备存储器中的图像填充列表。将图像加载方法添加到<code class="fe ma mb mc md b">PictureContent</code>:</p><pre class="lw lx ly lz gt me md mf mg aw mh bi"><span id="8112" class="mi jv iq md b gy mj mk l ml mm">public static void loadSavedImages(File dir) {<br/>    ITEMS.clear();<br/>    if (dir.exists()) {<br/>        File[] files = dir.listFiles();<br/>        for (File file : files) {<br/>            String absolutePath = file.getAbsolutePath();<br/>            String extension = absolutePath.substring(absolutePath.lastIndexOf("."));<br/>            if (extension.equals(".jpg")) {<br/>                loadImage(file);<br/>            }<br/>        }<br/>    }<br/>}<br/><br/>private static String getDateFromUri(Uri uri){<br/>    String[] split = uri.getPath().split("/");<br/>    String fileName = split[split.length - 1];<br/>    String fileNameNoExt = fileName.split("\\.")[0];<br/>    SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");<br/>    String dateString = format.format(new Date(Long.parseLong(fileNameNoExt)));<br/>    return dateString;<br/>}<br/><br/>public static void loadImage(File file) {<br/>    PictureItem newItem = new PictureItem();<br/>    newItem.uri = Uri.fromFile(file);<br/>    newItem.date = getDateFromUri(newItem.uri);<br/>    addItem(newItem);<br/>}</span></pre><p id="25dc" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">我们将从我们的活动<code class="fe ma mb mc md b">ScrollingActivity</code>中调用<code class="fe ma mb mc md b">loadSavedImages</code>，因此我们首先需要获得对回收器视图的引用。添加两个字段:</p><pre class="lw lx ly lz gt me md mf mg aw mh bi"><span id="09fb" class="mi jv iq md b gy mj mk l ml mm">private RecyclerView.Adapter recyclerViewAdapter; private RecyclerView recyclerView;</span></pre><p id="d59b" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">在<code class="fe ma mb mc md b">onCreate</code>中哪个会被懒加载:</p><pre class="lw lx ly lz gt me md mf mg aw mh bi"><span id="403e" class="mi jv iq md b gy mj mk l ml mm">if (recyclerViewAdapter == null) {<br/>    Fragment currentFragment = getSupportFragmentManager().findFragmentById(R.id.main_fragment);<br/>    recyclerView = (RecyclerView) currentFragment.getView();<br/>    recyclerViewAdapter = ((RecyclerView) currentFragment.getView()).getAdapter();<br/>}</span></pre><p id="f9f2" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">在<code class="fe ma mb mc md b">onResume</code>中，我们将添加对<code class="fe ma mb mc md b">loadSavedImages</code>的调用:</p><pre class="lw lx ly lz gt me md mf mg aw mh bi"><span id="6598" class="mi jv iq md b gy mj mk l ml mm">@Override<br/>protected void onResume() {<br/>    super.onResume();<br/><br/>    runOnUiThread(new Runnable() {<br/>        @Override<br/>        public void run() {<br/>            loadSavedImages(context.getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS));<br/>            recyclerViewAdapter.notifyDataSetChanged();<br/>        }<br/>    });<br/>}</span></pre><blockquote class="mn mo mp"><p id="3926" class="ks kt mq ku b kv lr kx ky kz ls lb lc mr lt lf lg ms lu lj lk mt lv ln lo lp ij bi translated"><em class="iq">注意，我们正在从</em> <code class="fe ma mb mc md b"><em class="iq">DIRECTORY_DOWNLOADS</em></code> <em class="iq">加载文件，这是一个存储下载文件的传统文件夹。</em></p></blockquote><h1 id="3d55" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">下载图片</h1><p id="6c01" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">每当点击浮动动作按钮时，我们将使用内置的DownloadManager类从Lorem Picsum 下载随机图片。</p><p id="26c3" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">将下载方法添加到<code class="fe ma mb mc md b">PictureContent</code>:</p><pre class="lw lx ly lz gt me md mf mg aw mh bi"><span id="9a79" class="mi jv iq md b gy mj mk l ml mm">public static void downloadRandomImage(DownloadManager downloadmanager, Context context) {<br/>    long ts = System.currentTimeMillis();<br/>    Uri uri = Uri.parse(context.getString(R.string.image_download_url));<br/><br/>    DownloadManager.Request request = new DownloadManager.Request(uri);<br/>    request.setTitle("My File");<br/>    request.setDescription("Downloading");<br/>    request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE);<br/>    request.setVisibleInDownloadsUi(false);<br/>    String fileName = ts + ".jpg";<br/>    request.setDestinationInExternalFilesDir(context, Environment.DIRECTORY_DOWNLOADS, fileName);<br/><br/>    downloadmanager.enqueue(request);<br/>}</span></pre><p id="1c4b" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">这会将文件下载到<code class="fe ma mb mc md b">DIRECTORY_DOWNLOADS</code>，并以当前时间戳作为文件名。</p><p id="d4cd" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">在<code class="fe ma mb mc md b">strings.xml</code>中设置<code class="fe ma mb mc md b">image_download_url</code>:</p><pre class="lw lx ly lz gt me md mf mg aw mh bi"><span id="749f" class="mi jv iq md b gy mj mk l ml mm">&lt;string name="image_download_url"&gt;https://picsum.photos/200/300/?random&lt;/string&gt;</span></pre><blockquote class="mn mo mp"><p id="4ce9" class="ks kt mq ku b kv lr kx ky kz ls lb lc mr lt lf lg ms lu lj lk mt lv ln lo lp ij bi translated">不要忘记将互联网权限添加到清单中</p></blockquote><p id="0da7" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">现在我们需要处理下载完成事件。将以下内容添加到活动的<code class="fe ma mb mc md b">onCreate</code>:</p><pre class="lw lx ly lz gt me md mf mg aw mh bi"><span id="5339" class="mi jv iq md b gy mj mk l ml mm">onComplete = new BroadcastReceiver() {<br/>    public void onReceive(Context context, Intent intent) {<br/>        String filePath="";<br/>        DownloadManager.Query q = new DownloadManager.Query();<br/>        q.setFilterById(intent.getExtras().getLong(DownloadManager.EXTRA_DOWNLOAD_ID));<br/>        Cursor c = downloadManager.query(q);<br/><br/>        if (c.moveToFirst()) {<br/>            int status = c.getInt(c.getColumnIndex(DownloadManager.COLUMN_STATUS));<br/>            if (status == DownloadManager.STATUS_SUCCESSFUL) {<br/>                String downloadFileLocalUri = c.getString(c.getColumnIndex(DownloadManager.COLUMN_LOCAL_URI));<br/>                filePath = Uri.parse(downloadFileLocalUri).getPath();<br/>            }<br/>        }<br/>        c.close();<br/>        PictureContent.loadImage(new File(filePath));<br/>        recyclerViewAdapter.notifyItemInserted(0);<br/>        progressBar.setVisibility(View.GONE);<br/>        fab.setVisibility(View.VISIBLE);<br/>    }<br/>};<br/><br/>context.registerReceiver(onComplete, new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE));</span></pre><p id="e571" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">当下载管理器完成下载时，这是获取下载文件名称的(相当冗长)方式。在得到<code class="fe ma mb mc md b">filePath</code>之后，我们调用<code class="fe ma mb mc md b">PictureContent.loadImage</code>，将它添加到我们的列表中。</p><blockquote class="mn mo mp"><p id="e114" class="ks kt mq ku b kv lr kx ky kz ls lb lc mr lt lf lg ms lu lj lk mt lv ln lo lp ij bi translated"><em class="iq">通知调用</em> <code class="fe ma mb mc md b"><em class="iq">recyclerViewAdapter.notifyItemInserted(0)</em></code> <em class="iq">。这将导致列表用我们插入的新项目(在索引0处)刷新</em></p></blockquote><h1 id="6a97" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">旁白:用Asset Studio创建加号图标</h1><p id="132c" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">作为最后的润色，我们将使用Android Studio的Asset Studio更新FAB的图标，以创建一个矢量材质图标。右键单击res文件夹，然后选择“新建&gt;矢量资源”。点击按钮，搜索关键字<code class="fe ma mb mc md b">add</code>:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mu"><img src="../Images/db93b23176f70d943d9f3878c20ffb8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_qWDjsy6JvRwcPWN.png"/></div></div></figure><p id="f7a3" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">这将为我们提供正材质图标。将颜色改为白色，并将xml保存在drawable文件夹中。</p><p id="58d3" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated">就是这样！现在我们有一个滚动循环视图显示下载的图片:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/b1b2c7e74cd51507c9901a24c21773d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*Rd0ERV8NMKTc1qwq.gif"/></div></figure><blockquote class="mn mo mp"><p id="ef52" class="ks kt mq ku b kv lr kx ky kz ls lb lc mr lt lf lg ms lu lj lk mt lv ln lo lp ij bi translated"><em class="iq">全源可见</em> <a class="ae lq" href="https://github.com/syonip/android-recycler-example" rel="noopener ugc nofollow" target="_blank"> <em class="iq">此处</em> </a></p></blockquote></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="761d" class="pw-post-body-paragraph ks kt iq ku b kv lr kx ky kz ls lb lc ld lt lf lg lh lu lj lk ll lv ln lo lp ij bi translated"><em class="mq">最初发表于</em><a class="ae lq" href="https://www.learningsomethingnew.com/how-to-use-a-recycler-view-to-show-images-from-storage" rel="noopener ugc nofollow" target="_blank"><em class="mq">https://www.learningsomethingnew.com</em></a><em class="mq">。</em></p></div></div>    
</body>
</html>