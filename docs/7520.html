<html>
<head>
<title>Few things to know before launching a SvelteKit app in prod</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在prod中启动SvelteKit应用程序之前需要知道的几件事</h1>
<blockquote>原文：<a href="https://itnext.io/few-things-to-know-before-launching-a-sveltekit-app-in-prod-754c5f84ac61?source=collection_archive---------3-----------------------#2022-10-19">https://itnext.io/few-things-to-know-before-launching-a-sveltekit-app-in-prod-754c5f84ac61?source=collection_archive---------3-----------------------#2022-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/81b153810f1076f8b5eae9433fa3f75b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_95nJBkOTJfNugcX"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@kolamdigital?utm_source=Papyrs&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安迪·赫尔曼万</a>在<a class="ae kf" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><p id="7bb5" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">上周，新版本的<a class="ae kf" href="https://internetcomputer.org/nns" rel="noopener ugc nofollow" target="_blank">NNS-dapp</a>(NNS的dapp，世界上最大的daop之一，管理着<a class="ae kf" href="https://internetcomputer.org/" rel="noopener ugc nofollow" target="_blank">互联网计算机</a>)引入了一个名为“Stake Maturity”的新特性，对其模型进行了轻微的设计更新，并改变了其构建系统。</p><p id="3bf0" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">事实上，虽然前端应用程序曾经在唯一的<a class="ae kf" href="https://rollupjs.org/" rel="noopener ugc nofollow" target="_blank"> Rollup </a> bundler的帮助下打包，但它被迁移到了同时使用<a class="ae kf" href="https://vitejs.dev/" rel="noopener ugc nofollow" target="_blank"> Vite </a>、<a class="ae kf" href="https://esbuild.github.io/" rel="noopener ugc nofollow" target="_blank"> esbuild </a>和Rollup的<a class="ae kf" href="https://kit.svelte.dev/" rel="noopener ugc nofollow" target="_blank"> SvelteKit </a> *上。<em class="ll"> </em></p><p id="8a70" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">以下是我一路走来学到的三件事。我希望它们对您有所帮助，这样您也可以在生产中安全地部署您的应用程序。</p><p id="5ac4" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><em class="ll"> *路由方面没有任何变化，但</em></p></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="effa" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">​1.CSP破解Firefox中的应用</h1><p id="b998" class="pw-post-body-paragraph kn ko it kp b kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf lg mo li lj lk im bi translated">内容安全策略(CSP)是一个附加的安全层，有助于检测和缓解某些类型的攻击，包括跨站点脚本(XSS)和数据注入攻击(来源<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP" rel="noopener ugc nofollow" target="_blank"> MDN </a>)。</p><p id="eec9" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">因为我们关心安全性，所以我们当然实施了这类规则。值得注意的是策略<code class="fe mp mq mr ms b">script-src</code>将<code class="fe mp mq mr ms b">index.html</code>页面的脚本标签列入白名单——使用它们的<code class="fe mp mq mr ms b">sha256</code>脚本散列——而<code class="fe mp mq mr ms b">'script-dynamic'</code>用于加载在浏览器中运行应用程序所需的所有代码块。</p><p id="cb19" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">虽然这在以前的bundler中行得通，但我们实际上惊讶地发现，SvelteKit(2022年10月)并不真正支持这种政策组合(见第<a class="ae kf" href="https://github.com/sveltejs/kit/issues/3558" rel="noopener ugc nofollow" target="_blank"> #3558 </a>期)。它可以在Chrome和Safari中运行，但是在Firefox中会中断，我说的“中断”是指all应用程序根本不会被渲染。</p><p id="1455" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">为了解决这个问题，我们找到了以下解决方法:添加一个构建后脚本，将SvelteKit注入HTML页面的代码提取到一个单独的JS文件中，然后注入我们自己的脚本加载器🤪。</p><p id="094d" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这可以通过以下方式实现:</p><p id="30bf" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">​1.将一个空的<code class="fe mp mq mr ms b">main.js</code>添加到<code class="fe mp mq mr ms b">static</code>文件夹中(这有助于避免在本地开发时出现问题)。</p><p id="82c1" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">​2.在html根页面的<code class="fe mp mq mr ms b">&lt;head /&gt;</code>中添加一个脚本加载器，即在<code class="fe mp mq mr ms b">src/app.html</code>页面中。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="98ec" class="nb ln it ms b gy nc nd l ne nf">&lt;script&gt;<br/>    const loader = document.createElement("script");<br/>    loader.type = "module";<br/>    loader.src = "./main.js";<br/>    document.head.appendChild(loader);<br/>&lt;/script&gt;</span></pre><p id="3d4b" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">​3.创建一个后期构建脚本—例如<code class="fe mp mq mr ms b">./scripts/build.csp.mjs</code>。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="2bbb" class="nb ln it ms b gy nc nd l ne nf">#!/usr/bin/env node<br/><br/>import { readFileSync, writeFileSync } from "fs";<br/>import { join } from "path";<br/><br/>const publicIndexHTML = join(process.cwd(), "public", "index.html");<br/><br/>const buildCsp = () =&gt; {<br/>  const indexHTMLWithoutStartScript = extractStartScript();<br/>  writeFileSync(publicIndexHTML, indexHTMLWithoutStartScript);<br/>};<br/><br/>/**<br/> * Using a CSP with 'strict-dynamic' with SvelteKit breaks in Firefox.<br/> * Issue: https://github.com/sveltejs/kit/issues/3558<br/> *<br/> * As workaround:<br/> * 1. we extract the start script that is injected by SvelteKit in index.html into a separate main.js<br/> * 2. we remove the script content from index.html but, let the script tag as anchor<br/> * 3. we use our custom script loader to load the main.js script<br/> */<br/>const extractStartScript = () =&gt; {<br/>  const indexHtml = readFileSync(publicIndexHTML, "utf-8");<br/><br/>  const svelteKitStartScript =<br/>    /(&lt;script type=\"module\" data-sveltekit-hydrate[\s\S]*?&gt;)([\s\S]*?)(&lt;\/script&gt;)/gm;<br/><br/>  // 1. extract SvelteKit start script to a separate main.js file<br/>  const [_script, _scriptStartTag, content, _scriptEndTag] =<br/>    svelteKitStartScript.exec(indexHtml);<br/>  const inlineScript = content.replace(/^\s*/gm, "");<br/><br/>  writeFileSync(<br/>    join(process.cwd(), "public", "main.js"),<br/>    inlineScript,<br/>    "utf-8"<br/>  );<br/><br/>  // 2. replace SvelteKit script tag content with empty<br/>  return indexHtml.replace(svelteKitStartScript, "$1$3");<br/>};<br/><br/>buildCsp();</span></pre><p id="104c" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">​4.在<code class="fe mp mq mr ms b">package.json</code>连锁剧本。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="21ab" class="nb ln it ms b gy nc nd l ne nf">{<br/>    "scripts": {<br/>        "build:csp": "node scripts/build.csp.mjs",<br/>        "build": "vite build &amp;&amp; npm run build:csp"<br/>    }<br/>}</span></pre></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="b550" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">​2.构建再现性</h1><p id="8cf4" class="pw-post-body-paragraph kn ko it kp b kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf lg mo li lj lk im bi translated">可复制构建是一个编译软件的过程，它确保生成的二进制代码可以被复制(来源<a class="ae kf" href="https://en.wikipedia.org/wiki/Reproducible_builds" rel="noopener ugc nofollow" target="_blank">维基百科</a>)。我们关心确定性编译，因为我们希望允许验证在编译过程中没有引入漏洞或后门。</p><p id="db50" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这一直都很管用。然而，在迁移之后，我们无法再在多台计算机上为捆绑的wasm计算相同的sha。</p><p id="f9ab" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">经过一些调试，我们找到了问题的两个根本原因。</p><p id="a1bb" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">​1.如果没有特定的<a class="ae kf" href="https://kit.svelte.dev/docs/configuration#version" rel="noopener ugc nofollow" target="_blank">版本</a>提供给SvelteKit，它将生成一个时间戳来标识当前的应用程序版本——也就是说，如果没有提供版本，SvelteKit会在绑定的JS代码中注入一个时间戳。每次构建，每次都有一个新的时间戳。</p><p id="73b4" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">为了解决这个问题，我们在<code class="fe mp mq mr ms b">package.json</code>中读取版本号，并在<code class="fe mp mq mr ms b">svelte.config.js</code>中将其提供给套件。通过这种方式，只要我们不改变语义数字，每个构建版本都是静态的。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="3c17" class="nb ln it ms b gy nc nd l ne nf">import adapter from "@sveltejs/adapter-static";<br/>import autoprefixer from "autoprefixer";<br/>import { readFileSync } from "fs";<br/>import preprocess from "svelte-preprocess";<br/>import { fileURLToPath } from "url";<br/><br/>const file = fileURLToPath(new URL("package.json", import.meta.url));<br/>const json = readFileSync(file, "utf8");<br/>const { version } = JSON.parse(json);<br/><br/>const config = {<br/>  preprocess: preprocess({<br/>    postcss: {<br/>      plugins: [autoprefixer],<br/>    },<br/>  }),<br/><br/>  kit: {<br/>    adapter: adapter({<br/>      pages: "public",<br/>      assets: "public",<br/>      fallback: "index.html",<br/>      precompress: false,<br/>    }),<br/>    serviceWorker: {<br/>      register: false,<br/>    },<br/>    version: {<br/>      name: version, // &lt;---- here provide version<br/>    },<br/>    trailingSlash: "always",<br/>  },<br/>};<br/><br/>export default config;</span></pre><p id="2b7c" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">​2.SvelteKit——或Vite——添加一个<code class="fe mp mq mr ms b">public/vite-manifest.json</code>文件，该文件包含应用程序所有生成的不可变资产的列表。很遗憾，此文件当前未被排序。因此，作为一个快速解决方案，我们添加了一个bash脚本来完成这项工作。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="545d" class="nb ln it ms b gy nc nd l ne nf">#!/usr/bin/env bash<br/>set -euxo pipefail<br/>cd "$(dirname "$(realpath "$0")")/.."<br/># shellcheck disable=SC2094 # This reads the entire file into memory and then writes it out, so is correct.<br/>cat &lt;&lt;&lt;"$(jq --sort-keys . public/vite-manifest.json)" &gt;public/vite-manifest.json</span></pre><p id="d6dc" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们在<code class="fe mp mq mr ms b">package.json</code>中也链接了Bash脚本。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="5d56" class="nb ln it ms b gy nc nd l ne nf">{<br/>    "scripts": {<br/>        "build:csp": "node scripts/build.csp.mjs",<br/>        "build": "vite build &amp;&amp; npm run build:csp &amp;&amp; ./scripts/make-reproducible"<br/>    }<br/>}</span></pre></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="5fc7" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">3.多填充缓冲剂</h1><p id="82f5" class="pw-post-body-paragraph kn ko it kp b kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf lg mo li lj lk im bi translated">我一直使用Chovy的<a class="ae kf" href="https://stackoverflow.com/a/72220289/5404186" rel="noopener ugc nofollow" target="_blank"> SO解决方案</a>为IC上的前端dapps填充缓冲API，但它不再完全有效。虽然在<code class="fe mp mq mr ms b">vite.config.js</code>中将<code class="fe mp mq mr ms b">global</code>重新定义为<code class="fe mp mq mr ms b">globalThis</code>仍然有效，但是没有为“缓冲区”应用聚合填充。</p><p id="20fb" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这就是为什么我们在安装了(<code class="fe mp mq mr ms b">npm i buffer</code>)浏览器的<a class="ae kf" href="https://www.npmjs.com/package/buffer" rel="noopener ugc nofollow" target="_blank">缓冲区</a>模块依赖之后，在根<code class="fe mp mq mr ms b">+layout.ts</code>中添加了一个“手动”polyfill。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="7250" class="nb ln it ms b gy nc nd l ne nf">import { Buffer } from "buffer";<br/>globalThis.Buffer = Buffer;</span></pre><p id="add7" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">然而，我们发现这在开发或生产版本中可以在本地正常工作，但是在生产中可能会成为一个问题，因为不能保证获取<code class="fe mp mq mr ms b">+layout.js</code>文件的速度会比使用它的页面更快。</p><p id="8794" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这就是为什么除了上面的附加组件之外，在捆绑的生产JS代码中注入polyfied缓冲区是值得的。这可以在一个汇总插件(<code class="fe mp mq mr ms b">npm i @rollup/plugin-inject -D</code>)的帮助下完成。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="4c3b" class="nb ln it ms b gy nc nd l ne nf">import inject from "@rollup/plugin-inject";<br/>import { sveltekit } from "@sveltejs/kit/vite";<br/>import type { UserConfig } from "vite";<br/><br/>const config: UserConfig = {<br/>  plugins: [sveltekit()],<br/>  build: {<br/>    target: "es2020",<br/>    rollupOptions: {<br/>      // Polyfill Buffer for production build. <br/>      // The hardware wallet needs Buffer.<br/>      plugins: [<br/>        inject({<br/>          include: ["node_modules/@ledgerhq/**"],<br/>          modules: { Buffer: ["buffer", "Buffer"] },<br/>        }),<br/>      ],<br/>    },<br/>  },<br/>  optimizeDeps: {<br/>    esbuildOptions: {<br/>      // Node.js global to browser globalThis<br/>      define: {<br/>        global: "globalThis",<br/>      },<br/>    },<br/>  },<br/>};<br/><br/>export default config;</span></pre><p id="035c" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">注意事项:</p><ul class=""><li id="1b18" class="ng nh it kp b kq kr ku kv ky ni lc nj lg nk lk nl nm nn no bi translated">我们需要上述硬件钱包相关功能的polyfill。这就是为什么当我们使用Rollup插件时，我们将它的范围扩大到<code class="fe mp mq mr ms b">ledgerhq</code>库。</li><li id="333a" class="ng nh it kp b kq np ku nq ky nr lc ns lg nt lk nl nm nn no bi translated">这个解决方案还不是最佳的，因为我们应用了两次polyfill也就是说，我们实际上在产品构建中加载了太多的JavaScript代码。我不太确定我是否同意，但这仍然可以改进。</li><li id="a580" class="ng nh it kp b kq np ku nq ky nr lc ns lg nt lk nl nm nn no bi translated">web worker代码无法使用上述解决方案进行聚合。如果你需要这样做，你可能需要进一步调查。</li></ul></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="62dd" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="9425" class="pw-post-body-paragraph kn ko it kp b kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf lg mo li lj lk im bi translated">这是所有的乐趣和游戏，直到你发现的问题并不存在，当你在当地发展😁。我很高兴我们解决了所有这些问题，并能够迁移。使用ViteJS简化开发人员的体验，并将dapp移植到SvelteKit打开了新的可能性，特别是我们关于路由的一些想法，但是，我可能会在另一篇博客文章中讲述更多😉。</p><p id="8456" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">到无限远处<br/>大卫</p></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><p id="f949" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">更多冒险，请在🖖推特上关注我</p></div></div>    
</body>
</html>