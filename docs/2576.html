<html>
<head>
<title>Kubernetes Journey — Up and running out of the cloud — Master and Worker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes之旅——启动和运行云计算——主人和工人</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-journey-up-and-running-out-of-the-cloud-master-and-worker-6328775b347f?source=collection_archive---------4-----------------------#2019-06-17">https://itnext.io/kubernetes-journey-up-and-running-out-of-the-cloud-master-and-worker-6328775b347f?source=collection_archive---------4-----------------------#2019-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e55fe308c3f3cf268fea283067d592fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T1RDrK1e2YnyoO0c2brXzg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">弗拉德·沙波奇尼科夫在<a class="ae kc" href="https://unsplash.com/search/photos/twin-build?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="e59b" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在本文中，我们将介绍构成<strong class="km ir"> Kubernetes主</strong>和<strong class="km ir">工人</strong> ( <strong class="km ir">控制器管理器</strong>、<strong class="km ir"> API服务器</strong>、<strong class="km ir"> etcd </strong>、<strong class="km ir">调度器、Kubelet、</strong>等)组件的每一项。我强烈建议您阅读参考链接，以便更好地理解每个组件的作用，以及它们如何适应一个<strong class="km ir"> Kubernetes集群</strong>。</p><p id="0978" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-journey-up-and-running-out-of-the-cloud-kubernetes-overview-5012994b8955">上一篇文章</a>中，我们介绍了<strong class="km ir"> Kubernetes </strong>，并提供了其主要组件的简要概述。</p><p id="ab78" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这些文章是我们Kubernetes之旅的一部分。我希望您对深入研究如何从云中安装和配置Kubernetes感到兴奋！</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="6c78" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">如果你不想等到所有的文章都发表了，又想马上动手，可以随意克隆项目的Github repo。它完全实用，文档也在不断改进:</p><div class="li lj gp gr lk ll"><a href="https://github.com/mvallim/kubernetes-under-the-hood" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab fo"><div class="ln ab lo cl cj lp"><h2 class="bd ir gy z fp lq fr fs lr fu fw ip bi translated">罩下的姆瓦利姆/库伯内特斯</h2><div class="ls l"><h3 class="bd b gy z fp lq fr fs lr fu fw dk translated">本教程是有人计划安装一个Kubernetes集群，并希望了解一切如何配合在一起…</h3></div><div class="lt l"><p class="bd b dl z fp lq fr fs lr fu fw dk translated">github.com</p></div></div><div class="lu l"><div class="lv l lw lx ly lu lz jw ll"/></div></div></a></div></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="f327" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">掌握</h1><p id="b531" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated">主节点负责编排与运行在工作节点上的容器相关的所有活动。它负责调度和部署集群应用程序，收集关于工作节点和单元的信息，以及许多其他活动。</p><h2 id="6d86" class="nd mb iq bd mc ne nf dn mg ng nh dp mk kv ni nj mo kz nk nl ms ld nm nn mw no bi translated">配置主节点的一些方法</h2><figure class="nq nr ns nt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/7b1b372c734a2e144a2b0b3bca242925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d9C_3gGwanxyQXAOD21dxg.png"/></div></div></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h2 id="60b9" class="nd mb iq bd mc ne nf dn mg ng nh dp mk kv ni nj mo kz nk nl ms ld nm nn mw no bi translated">堆叠控制平面和etcd节点</h2><blockquote class="nu"><p id="d735" class="nv nw iq bd nx ny nz oa ob oc od lh dk translated">在这种方法中，服务作为容器运行，并由kubeadm自动设置。</p></blockquote><p id="4f7a" class="pw-post-body-paragraph kk kl iq km b kn oe kp kq kr of kt ku kv og kx ky kz oh lb lc ld oi lf lg lh ij bi translated">堆叠式HA集群是一种拓扑结构(见下图)，其中etcd提供的分布式数据存储集群堆叠在由运行控制平面组件的<strong class="km ir"> kubeadm </strong>管理的节点形成的集群之上。</p><p id="0e26" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">每个控制平面节点运行一个<strong class="km ir">API-服务器</strong>、<strong class="km ir">调度器</strong>和<strong class="km ir">控制器-管理器</strong>的实例。使用负载平衡器将<strong class="km ir"> api-server </strong>暴露给工作节点(在我们的解决方案中，我们将使用HA代理)。它还创建一个本地etcd成员，该etcd成员仅与运行在同一节点上的<strong class="km ir"> api-server </strong>通信。这同样适用于本地<strong class="km ir">控制器管理器</strong>和<strong class="km ir">调度器</strong>实例。</p><p id="82b5" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这种拓扑将控制平面和etcd成员耦合在它们运行的同一节点上。与带有外部etcd节点的集群相比，它的设置更简单，管理复制也更简单。</p><p id="8a17" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">然而，堆叠集群会遇到耦合失败的风险。如果一个节点出现故障，etcd成员和控制平面实例都会丢失，冗余性也会受到影响。您可以通过添加更多控制平面节点来降低这种风险。</p><p id="d567" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">因此，您应该为一个HA群集运行至少三个堆叠控制平面节点。</p><figure class="nq nr ns nt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/f5cab9d203186f8de5d74e986d2db8eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qmfPwMkd-xnDt3-CUMZ7yg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd mc"> kubeadm </strong> HA拓扑—堆叠式etcd</figcaption></figure><blockquote class="ok ol om"><p id="ae78" class="kk kl on km b kn ko kp kq kr ks kt ku oo kw kx ky op la lb lc oq le lf lg lh ij bi translated">参考:<a class="ae kc" href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/ha-topology/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/setup/production-environment/tools/kube ADM/ha-topology/</a></p></blockquote></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h2 id="bb0f" class="nd mb iq bd mc ne nf dn mg ng nh dp mk kv ni nj mo kz nk nl ms ld nm nn mw no bi translated">堆叠控制平面和外部etcd节点</h2><blockquote class="nu"><p id="9354" class="nv nw iq bd nx ny nz oa ob oc od lh dk translated">在这种方法中，服务作为容器运行，并由kubeadm进行部分配置。</p></blockquote><p id="8cca" class="pw-post-body-paragraph kk kl iq km b kn oe kp kq kr of kt ku kv og kx ky kz oh lb lc ld oi lf lg lh ij bi translated">具有外部etcd节点的HA集群是一种拓扑结构(见下图),其中etcd提供的分布式数据存储集群位于运行控制面板组件的节点形成的集群外部。</p><p id="8348" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">像在堆叠etcd拓扑中一样，外部etcd拓扑中的每个控制平面节点运行<strong class="km ir">API-服务器</strong>、<strong class="km ir">调度器</strong>和<strong class="km ir">控制器-管理器</strong>的一个实例。并且使用负载平衡器将<strong class="km ir"> api-server </strong>暴露给工作节点。然而，etcd成员在单独的主机上运行，并且每个etcd主机与每个控制平面节点的<strong class="km ir"> api-server </strong>通信。</p><p id="d7f8" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这种拓扑结构将控制平面和etcd成员分离。因此，它提供了一种高可用性设置，其中丢失控制平面实例或etcd成员的影响较小，并且不会像堆叠高可用性拓扑那样影响集群冗余。</p><p id="0c41" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">但是，这种拓扑需要的主机数量是堆叠式HA拓扑的两倍。对于采用此拓扑的HA集群，至少需要三台主机用于控制面板节点，三台主机用于etcd节点。</p><figure class="nq nr ns nt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi or"><img src="../Images/bd2021ffcaae2b3bdfbc44c3a1f959ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0hFgN16x6LU4beotlOTx3A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd mc"> kubeadm </strong> HA拓扑—外部etcd</figcaption></figure><blockquote class="ok ol om"><p id="1d5f" class="kk kl on km b kn ko kp kq kr ks kt ku oo kw kx ky op la lb lc oq le lf lg lh ij bi translated">参考:<a class="ae kc" href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/ha-topology/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/setup/production-environment/tools/kube ADM/ha-topology/</a></p></blockquote></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h2 id="5e19" class="nd mb iq bd mc ne nf dn mg ng nh dp mk kv ni nj mo kz nk nl ms ld nm nn mw no bi translated">控制平面服务和外部etcd节点</h2><blockquote class="nu"><p id="7164" class="nv nw iq bd nx ny nz oa ob oc od lh dk translated">在这种方法中，服务作为独立的进程运行，应该手动配置，而不使用<strong class="ak"> kubeadm </strong>。它提供了更多的灵活性，但也要求设置集群的人做更多的工作。</p></blockquote><p id="9af2" class="pw-post-body-paragraph kk kl iq km b kn oe kp kq kr of kt ku kv og kx ky kz oh lb lc ld oi lf lg lh ij bi translated">具有外部etcd节点的HA集群控制平面是一种拓扑结构(见下图),其中etcd提供的分布式数据存储集群位于运行控制平面组件的节点所形成的集群外部。</p><p id="7197" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">像在堆叠控制平面和外部etcd节点拓扑中一样，外部etcd拓扑中的每个控制平面节点运行一个<strong class="km ir">API-服务器</strong>、<strong class="km ir">调度器</strong>和<strong class="km ir">控制器-管理器</strong>的实例。并且使用负载平衡器将<strong class="km ir"> api-server </strong>暴露给工作节点。<strong class="km ir"> etcd </strong>成员运行在单独的主机上，每个etcd主机与控制平面节点的所有<strong class="km ir"> api-server </strong>通信。</p><p id="a751" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这种拓扑在同一个节点上运行<strong class="km ir"> api-server </strong>、<strong class="km ir">控制器-管理器</strong>和<strong class="km ir">调度器</strong>作为<strong class="km ir">独立服务</strong>，而<strong class="km ir"> etcd </strong>运行在自己的节点上。因此，它提供了一种高可用性设置，在这种设置中，失去控制平面实例或etcd成员的影响较小，并且不会像在堆叠高可用性拓扑中那样影响群集冗余。</p><p id="28ed" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">但是，这种拓扑需要的主机数量是堆叠式HA拓扑的两倍。对于采用此拓扑的HA集群，至少需要三台主机用于控制面板节点，三台主机用于etcd节点。另外，你必须一个接一个地安装和配置服务。</p><figure class="nq nr ns nt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi os"><img src="../Images/3fa19c69247ccb843e8de8368804566e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7RQa30Q7nAEvaR0ldhJ4Mw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Kubernetes控制平面服务外部etcd</figcaption></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h2 id="ea00" class="nd mb iq bd mc ne nf dn mg ng nh dp mk kv ni nj mo kz nk nl ms ld nm nn mw no bi translated">我们将使用哪一个？</h2><p id="f746" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated"><strong class="km ir"> <em class="on">堆叠控制平面和etcd节点</em> </strong> <em class="on">，因为这样做将需要我们做更少的配置，需要使用更少的实例。</em></p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h2 id="0934" class="nd mb iq bd mc ne nf dn mg ng nh dp mk kv ni nj mo kz nk nl ms ld nm nn mw no bi translated">成分</h2><ul class=""><li id="6e1a" class="ot ou iq km b kn my kr mz kv ov kz ow ld ox lh oy oz pa pb bi translated"><strong class="km ir"> kubeadm: </strong>一个工具，用于提供<strong class="km ir"> kubeadm init </strong>和<strong class="km ir"> kubeadm join </strong>作为创建Kubernetes集群的最佳实践“快速路径”。<br/> <strong class="km ir"> kubeadm </strong>执行必要的操作，使最小可行集群启动并运行。按照设计，它只关心引导，而不关心机器的供应。同样，安装各种有用的插件，如Kubernetes仪表板、监控解决方案和特定于云的插件，也不在范围之内。<br/>使用<strong class="km ir"> kubeadm </strong>作为所有部署的基础将更容易创建一致的集群。</li><li id="ba2b" class="ot ou iq km b kn pc kr pd kv pe kz pf ld pg lh oy oz pa pb bi translated"><strong class="km ir"> kubelet </strong>:在worker节点上运行的服务，它读取Pod清单并确保它们定义的容器已经启动并正在运行。</li><li id="60d8" class="ot ou iq km b kn pc kr pd kv pe kz pf ld pg lh oy oz pa pb bi translated"><strong class="km ir"> etcd </strong>:一致且高度可用的键值存储，用作Kubernetes所有集群数据的后备存储。如果你的<strong class="km ir"> Kubernetes </strong>集群使用<strong class="km ir"> etcd </strong>作为它的后备存储器，<a class="ae kc" href="https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster" rel="noopener ugc nofollow" target="_blank">确保你有一个这些数据的备份计划</a>。</li><li id="dba4" class="ot ou iq km b kn pc kr pd kv pe kz pf ld pg lh oy oz pa pb bi translated">一个强调简单性、健壮性和可移植性的容器运行时。containerd是一个容器运行时，在Linux或Windows上作为守护进程运行。containerd负责获取和存储容器映像、执行容器、提供网络访问等等。(在我们的解决方案中，我们将使用<strong class="km ir"> Docker </strong>来实现这个目的)</li><li id="1852" class="ot ou iq km b kn pc kr pd kv pe kz pf ld pg lh oy oz pa pb bi translated"><strong class="km ir"> api-server </strong>:主服务器上公开Kubernetes API的组件。它是Kubernetes控制平面的前端。它被设计为水平扩展—也就是说，它通过部署更多实例来扩展。</li><li id="b52a" class="ot ou iq km b kn pc kr pd kv pe kz pf ld pg lh oy oz pa pb bi translated"><strong class="km ir">控制器管理器</strong>:运行控制器的主机上的组件。从逻辑上讲，每个控制器都是一个独立的进程，但是为了降低复杂性，它们都被编译成一个二进制文件并在一个进程中运行。</li><li id="f64d" class="ot ou iq km b kn pc kr pd kv pe kz pf ld pg lh oy oz pa pb bi translated"><strong class="km ir">调度器</strong>:主节点上的组件，监视新创建的没有分配工作节点的pod，并为它们选择一个工作节点。为调度决策考虑的因素包括个体和集体资源需求、硬件/软件/策略约束、相似性和反相似性规范、数据局部性、工作负载间干扰和截止时间。</li></ul><figure class="nq nr ns nt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ph"><img src="../Images/8cdc087b5d25bb6566388d38501d5c6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NRGvoGWnkI0ytC3N"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Pod创建流程(<a class="ae kc" href="http://heptio.com" rel="noopener ugc nofollow" target="_blank"><strong class="bd mc">heptio.com</strong></a>)</figcaption></figure><ul class=""><li id="9bfb" class="ot ou iq km b kn ko kr ks kv pi kz pj ld pk lh oy oz pa pb bi translated">kube-proxy :它是一个网络代理，运行在集群中的每个工作节点上。<strong class="km ir"> kube-proxy </strong>负责请求转发。<strong class="km ir"> kube-proxy </strong>允许TCP和UDP流转发或跨一组后端功能的循环TCP和UDP转发。</li><li id="3541" class="ot ou iq km b kn pc kr pd kv pe kz pf ld pg lh oy oz pa pb bi translated"><strong class="km ir">DNS cluster add-on</strong>:Kubernetes DNS在集群上调度一个DNS Pod和服务，并配置kubelets来告诉各个容器使用DNS服务的IP来解析DNS名称。<br/>集群中定义的每个服务(包括DNS服务器本身)都被分配了一个DNS名称。默认情况下，客户端Pod的DNS搜索列表将包括Pod自己的名称空间和群集的默认域。下面的例子很好地说明了这一点:<br/>假设在Kubernetes名称空间<strong class="km ir">栏</strong>中有一个名为<strong class="km ir"> foo </strong>的服务。在名称空间<strong class="km ir"> bar </strong>中运行的Pod可以通过简单地对<strong class="km ir"> foo </strong>进行DNS查询来查找这个服务。在名称空间<strong class="km ir"> quux </strong>中运行的Pod可以通过对<strong class="km ir"> foo.bar </strong>进行DNS查询来查找这个服务。</li><li id="b6fc" class="ot ou iq km b kn pc kr pd kv pe kz pf ld pg lh oy oz pa pb bi translated">cni插件:这个插件是一种网络插件，符合appc/CNI规范。这使得能够连接在不同节点上运行的pod，并且能够灵活地集成不同种类的网络解决方案(覆盖、纯L3等)。<br/> ‣关于Kubernetes和CNI的信息参见<a class="ae kc" href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/#cni" rel="noopener ugc nofollow" target="_blank"> <strong class="km ir">本</strong> </a>。<br/> ‣有关Kubernetes和CNI的信息，请参见“<a class="ae kc" href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/#cni" rel="noopener ugc nofollow" target="_blank"> <strong class="km ir">网络插件</strong> </a>”。</li></ul><blockquote class="ok ol om"><p id="69a9" class="kk kl on km b kn ko kp kq kr ks kt ku oo kw kx ky op la lb lc oq le lf lg lh ij bi translated">参考资料https://kubernetes.io/docs/reference/glossary/?<br/>‣<a class="ae kc" href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/reference/setup-tools/kube ADM/kube ADM/</a>t37】‣<a class="ae kc" href="https://kubernetes.io/docs/reference/glossary/?fundamental=true" rel="noopener ugc nofollow" target="_blank">基本面=真</a><br/>‣<a class="ae kc" href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#introduction" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/services-networking/DNS-pod-service/#简介</a></p></blockquote></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="d7dc" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">工人</h1><p id="a651" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated">Workers是机器(节点，可以是物理的或虚拟机),由<strong class="km ir"> Kubernetes </strong>管理的容器在其中有效地运行。为了让工人节点由<strong class="km ir"> Kubernetes </strong>管理，它们必须安装<strong class="km ir"> Kubelet </strong>代理。所有与主服务器的通信都是通过这个代理进行的，因此集群操作也是通过这个代理执行的。</p><h2 id="f939" class="nd mb iq bd mc ne nf dn mg ng nh dp mk kv ni nj mo kz nk nl ms ld nm nn mw no bi translated">配置工作节点的一些方法</h2><figure class="nq nr ns nt gt jr gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/b26883021ede744b7f0981980ab548cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*84rirMsIuqxqqEwJQSvO-w.png"/></div></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h2 id="fddb" class="nd mb iq bd mc ne nf dn mg ng nh dp mk kv ni nj mo kz nk nl ms ld nm nn mw no bi translated">堆叠的工作节点</h2><blockquote class="nu"><p id="1bc8" class="nv nw iq bd nx ny nz oa ob oc od lh dk translated">在这种方法中，服务作为容器运行，并由kubeadm自动设置。</p></blockquote><p id="ca3e" class="pw-post-body-paragraph kk kl iq km b kn oe kp kq kr of kt ku kv og kx ky kz oh lb lc ld oi lf lg lh ij bi translated">堆叠工人是一种拓扑结构(见上图)，其中每个节点运行一个<strong class="km ir"> kubelet </strong>、<strong class="km ir"> kube-proxy </strong>、<strong class="km ir"> cni-plugins </strong>和<strong class="km ir"> containerd </strong>的实例。<br/>在这种拓扑中配置一个工作器更简单。只需安装<strong class="km ir"> kubeadm </strong>、<strong class="km ir"> kubelet </strong>和<strong class="km ir"> containerd </strong>即可。其他组件(<strong class="km ir"> kube-proxy </strong>和<strong class="km ir"> cni-plugins </strong>)将在执行<strong class="km ir"> kubeadm join </strong>命令时，当工人加入集群时被初始化。</p><p id="0e40" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这种方法将kube-proxy和cni-plugins作为容器运行。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h2 id="24a8" class="nd mb iq bd mc ne nf dn mg ng nh dp mk kv ni nj mo kz nk nl ms ld nm nn mw no bi translated">沃克服务公司</h2><blockquote class="nu"><p id="2d93" class="nv nw iq bd nx ny nz oa ob oc od lh dk translated">在这种方法中，服务作为独立的进程运行，应该手动配置，而不使用kubeadm。它提供了更多的灵活性，但也要求设置集群的人做更多的工作。</p></blockquote><p id="908d" class="pw-post-body-paragraph kk kl iq km b kn oe kp kq kr of kt ku kv og kx ky kz oh lb lc ld oi lf lg lh ij bi translated">工作者服务是一个拓扑(见上图)，其中每个节点运行一个<strong class="km ir"> kubelet </strong>、<strong class="km ir"> kube-proxy </strong>、<strong class="km ir"> cni-plugins </strong>和<strong class="km ir"> containerd的实例。此外，您必须逐个安装和配置服务。</strong></p><p id="718f" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这种方法将kube-proxy和cni-plugins作为独立的服务运行。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h2 id="8a60" class="nd mb iq bd mc ne nf dn mg ng nh dp mk kv ni nj mo kz nk nl ms ld nm nn mw no bi translated">我们将使用哪一个？</h2><p id="0e8a" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated"><strong class="km ir"> <em class="on">堆叠工作者节点</em> </strong> <em class="on">，因为这样做会要求我们做较少的配置。</em></p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h2 id="5262" class="nd mb iq bd mc ne nf dn mg ng nh dp mk kv ni nj mo kz nk nl ms ld nm nn mw no bi translated">成分</h2><p id="4c79" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated">组件<strong class="km ir"> kubelet </strong>、<strong class="km ir"> kube-proxy </strong>、<strong class="km ir"> cni-plugins </strong>和<strong class="km ir"> containerd </strong>在主节点和工作节点上工作相同。检查它们的定义。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="8e47" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我希望你喜欢这篇文章以及这个系列的其他文章。在下一篇文章中，我们将更深入地了解<strong class="km ir"> etcd </strong>的细节，描述组成它的各个部分，以及它们如何相互交互。</p><p id="f952" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">别担心。我们几乎完成了所有这些的理论基础(可能在接下来的2或3篇文章中),并将很快开始接触真正酷的东西！</p><p id="7969" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">不要忘记在下面的评论中留下你的反馈。不断完善这一系列的内容非常重要。</p><p id="0123" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我再次强烈推荐您关注我的Medium，这样您就不会错过本系列中发表的任何新文章。如果你错过了这个系列的第一篇文章，你可以在这里查看<a class="ae kc" href="https://medium.com/@mtvallim/kubernetes-journey-up-and-running-out-of-the-cloud-introduction-f04a811c92a5" rel="noopener"/>。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="4669" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">回头见！！</p><p id="bc65" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">再见</p></div></div>    
</body>
</html>