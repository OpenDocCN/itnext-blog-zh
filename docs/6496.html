<html>
<head>
<title>Modern C++ in Advent of Code: Day3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代C++代码的出现:第三天</h1>
<blockquote>原文：<a href="https://itnext.io/modern-c-in-advent-of-code-day3-4a105922b5d0?source=collection_archive---------3-----------------------#2021-12-03">https://itnext.io/modern-c-in-advent-of-code-day3-4a105922b5d0?source=collection_archive---------3-----------------------#2021-12-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="35f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是代码问世的第三天。今天，我们将探索算法和比特拨弄。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/5519f4e88fa66563e2fd615fe8ecef94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P1UwmnkDiZmq3XplIRcEdA.png"/></div></div></figure><p id="d67e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一如既往，请先尝试解决问题，然后再看解决方案。对于本系列中的所有文章，<a class="ae kl" href="https://medium.com/@happy.cerberus/list/advent-of-code-2021-using-modern-c-c5814cb6666e" rel="noopener">查看这个列表</a>。</p><h1 id="9a5c" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第三天:第一部分</h1><p id="b11f" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">今天的目标是处理二进制数，在第一部分中，目标是从最频繁和最不频繁的位构造数。因此，例如，给定三个数字的列表<code class="fe mb mc md me b">0b111, 0b100, 0b000</code>，对于第一位，最频繁的位是1，对于第二个0和第三个0。所以由最频繁出现的位组成的数字是<code class="fe mb mc md me b">0b100</code>，由最不频繁出现的位组成的数字是<code class="fe mb mc md me b">0b011</code>。</p><p id="27e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码出现时的问题规范没有说明在出现平局的情况下我们应该做什么，例如<code class="fe mb mc md me b">0b111, 0b000</code>。因此，我不得不做出判断，认为<code class="fe mb mc md me b">1</code>位更频繁。因此，由最频繁出现的位产生的数将是<code class="fe mb mc md me b">0b111</code>，由最不频繁出现的位产生的数将是<code class="fe mb mc md me b">0b000</code>。</p><p id="74a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个未指明的方面是在类似<code class="fe mb mc md me b">0b101, 0b100, 0b111</code>的情况下会发生什么。数字是由最不常用的位<code class="fe mb mc md me b">0b010</code>还是<code class="fe mb mc md me b">0b110</code>组成的？我再次进行了判断调用，我确实将零个实例算作有效频率，所以这里的结果将是<code class="fe mb mc md me b">0b010</code>。</p><p id="7bc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这个序言，让我们进入解决方案。是的，复数，因为从输入中逐个读取数字的流版本和期望所有数据都在一个向量中的内存解决方案展示了不同的可能方法。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="5293" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将讨论为什么我们指定宽度，为什么我们在两个版本中指定不同的宽度，但是像往常一样，让我们从测试开始。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="7df5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里唯一需要注意的是，将位宽动态指定为函数参数允许输入具有不同的宽度。相反，接受位宽作为模板参数的版本要求所有测试输入都是一致的。</p><p id="b4bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们正在测试<code class="fe mb mc md me b">epsilon_rate</code>函数，但是我还没有指定它的函数原型。原因是，我们可以简单地将γ速率作为它的补充来计算ε速率。请注意，这只适用于我们将0频率视为有效频率的情况。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="3a24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mb mc md me b">UINT32_MAX</code>将所有32位设置为<code class="fe mb mc md me b">1</code>。当我们移位它时，我们从最低有效位开始创建一个零序列(<code class="fe mb mc md me b">1111 &lt;&lt; 2 == 1100</code>)。反转该值会创建一个“与”掩码，该掩码将在计算补码后删除任何设置为1的多余位。</p><pre class="kn ko kp kq gt mh me mi mj aw mk bi"><span id="852c" class="ml kz iq me b gy mm mn l mo mp">// ex. for width = 4 and gamma_rate = 1010<br/>UINT_MAX &lt;&lt; 4           == 1111 1111 1111 1111 1111 1111 1111 0000<br/>mask = ~(UINT_MAX &lt;&lt; 4) == 0000 0000 0000 0000 0000 0000 0000 1111<br/>~gamma_rate             == 1111 1111 1111 1111 1111 1111 1111 0101<br/>~gamma_rate &amp; mask      ==                                    0101</span></pre><p id="1128" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在向您展示伽玛速率的解决方案之前，我需要讨论两个辅助函数:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="7899" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mb mc md me b">div2_roundup</code>功能将允许我们检查哪个频率更高。<code class="fe mb mc md me b">v&amp;1</code>返回最低有效位，如果数字是奇数则返回1，如果数字是偶数则返回0。</p><p id="84e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mb mc md me b">has_bit_set</code>函数中，我们首先构造一个在测试位置设置了单个位的数。如果该位被置位，按位AND将返回一个非零值，否则返回零。当转换为布尔值时，非零值被视为真，零被视为假。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="cffd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">外部循环(第3行)遍历了20个比特.因为我们需要从左到右构建数字，所以我们需要从最高有效位到最低有效位迭代。一旦我们考虑一个特定的位，我们必须计算有多少个数字设置了这个位。公式<code class="fe mb mc md me b">cnt_one &gt;= div2_roundup(data.size())</code>是一个布尔表达式，如果一半或更多的数字设置了该位，则返回true，否则返回false。之后，我们使用bool到int转换:</p><ul class=""><li id="b013" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated">如果一半或更多的数字将此位设置为1，则条件为真，这将转换为1，因此我们向结果添加1位</li><li id="8ccb" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">如果一半或更多的数字将此位设置为0，则条件为假，这将转换为0，因此我们在结果中添加一个0位</li></ul><p id="e0b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个版本要求我们将数据预读到一个向量中。这可能不太方便，所以让我们来看看流式版本:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="31f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们这里有两个阶段。首先，我们通过处理输入来计算频率(第5-10行)。我们使用<code class="fe mb mc md me b">std::bitset&lt;width&gt;</code>大大简化了这个任务。我们可以迭代每个数字的位，并累加在每个位置看到的1的数量。然而，<code class="fe mb mc md me b">std::bitset</code>也迫使我们将位宽作为模板参数传递。结果的构造(第11–14行)与之前的版本相同。</p><p id="d52e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后是主函数，这里我选择了向量变量，因为它对主函数提出了额外的要求，即将输入读入向量:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="cb31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们再次使用<code class="fe mb mc md me b">std::bitset</code>来读取二进制数，而不是使用<code class="fe mb mc md me b">std::ransform</code>中的运算，我们使用<code class="fe mb mc md me b">std::identity{}</code>来返回传递给它的任何东西，但是然后我们使用成员函数<code class="fe mb mc md me b">to_ulong()</code>来投影每个<code class="fe mb mc md me b">std::bitset</code>，该函数返回作为无符号长整数读取的位。投影是C++20中引入的<code class="fe mb mc md me b">std::ranges</code>的新特性之一。</p><h1 id="0ff9" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第三天:第二部分</h1><p id="705e" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在第二部分，我们将再次玩比特。任务是选择两个数字。同样，一个将遵循“最多”路径，另一个将遵循“最少”路径。然而，随着我们的搜索，我们将缩小我们的选择。因此，在选择<code class="fe mb mc md me b">oxygen_generator</code>状态时，我们将首先选择最频繁的第一位。这将是<code class="fe mb mc md me b">oxygen_generator</code>状态的第一位。然后，我们将选择范围缩小到最频繁的第一位，并从中选择最频繁的第二位。例如:</p><pre class="kn ko kp kq gt mh me mi mj aw mk bi"><span id="4478" class="ml kz iq me b gy mm mn l mo mp">0b1111, 0b1011, 0b1101, 0b0100<br/>most_freq = 1, result = 1...<br/>0bx111, 0bx011, 0bx101<br/>most_freq = 1, result = 11..<br/>0bxx11, 0bxx01<br/>most_freq = 1 result = 111.<br/>0bxxx1<br/>most_freq = 1, result = 1111</span></pre><p id="f062" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们进入解决方案之前，让我们看一下我们的声明:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="0001" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试是:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="8c84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你熟悉排序算法，你可能会在问题描述中注意到一些熟悉的东西。事实上，这的确有快速排序的味道。</p><p id="1ab7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们可以遵循快速排序逻辑，但是因为我们只关心一个值，所以我们将只在分区的一侧递归。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="490a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们根据当前位的值对数据进行分区(使用<code class="fe mb mc md me b">std::partition</code>)。这意味着分割点之前和之后的所有元素都具有相同值的相应位。根据两个范围(开始到分割点与分割点到结束)中的哪一个更大，我们或者递归选择最常见的<code class="fe mb mc md me b">oxygen_rating</code>(更长的范围)或者最不常见的<code class="fe mb mc md me b">co2_rating</code>(更短的范围)。</p><p id="f342" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们也只在给定子范围上递归，这意味着我们只考虑具有最常见或最不常见位的元素。最后，当我们只有一个元素或者已经查看了所有的位时，我们结束。</p><p id="3261" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们必须解决只有一个分区的情况。当所有数字都具有相同的位值时，就会发生这种情况。在这种情况下，分割点等于终点。</p><p id="e46b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">综上所述，我们的主要功能如下:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><h1 id="4b68" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">链接和技术说明</h1><p id="52d2" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">每日解决方案存储库位于:<a class="ae kl" href="https://github.com/HappyCerberus/moderncpp-aoc-2021" rel="noopener ugc nofollow" target="_blank">https://github.com/HappyCerberus/moderncpp-aoc-2021</a>。</p><p id="8740" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://medium.com/@happy.cerberus/list/advent-of-code-2021-using-modern-c-c5814cb6666e" rel="noopener">查看此列表，了解《代号</a>问世前几天的文章。</p><p id="b3c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请不要忘记亲自尝试<a class="ae kl" href="https://adventofcode.com/2021" rel="noopener ugc nofollow" target="_blank">降临码</a>。</p><h1 id="3a8c" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">感谢您的阅读</h1><p id="c93b" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">感谢您阅读这篇文章。你喜欢吗？</p><p id="8877" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还在T2的YouTube上发布视频。你有问题吗？在<a class="ae kl" href="https://twitter.com/SimonToth83" rel="noopener ugc nofollow" target="_blank">推特</a>或<a class="ae kl" href="https://www.linkedin.com/in/simontoth" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我。</p></div></div>    
</body>
</html>