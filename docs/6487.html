<html>
<head>
<title>Modern C++ in Advent of Code: Day1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代C++代码的出现:第一天</h1>
<blockquote>原文：<a href="https://itnext.io/modern-c-in-advent-of-code-day1-18f7697d4f6b?source=collection_archive---------0-----------------------#2021-12-01">https://itnext.io/modern-c-in-advent-of-code-day1-18f7697d4f6b?source=collection_archive---------0-----------------------#2021-12-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="487b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个新系列中，我将使用现代C++一步一步地指导您解决《2021年代码降临》的问题。由于这是本系列的第一部分，我还将描述Bazel构建系统的设置。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/1af63613208764bda1eb46c92d159010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nepFXPKpbrNDoSz5HNS3lg.png"/></div></div></figure><p id="941b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不熟悉<a class="ae kx" href="https://adventofcode.com/2021" rel="noopener ugc nofollow" target="_blank">代码</a>的出现，我强烈建议你在查看这些解决方案之前自己解决它。</p><h2 id="de43" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">第一天:第一部分</h2><p id="567c" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">给我们一个数列(正整数)。我们的目标是当系列中的一个数字高于前一个数字时，计算案例的数量。因此，举例来说，<code class="fe lw lx ly lz b">0 0 0 0 0</code>的正确答案应该是<code class="fe lw lx ly lz b">0</code>，而<code class="fe lw lx ly lz b">1 2 3 4 5</code>的正确答案应该是<code class="fe lw lx ly lz b">4</code>。</p><p id="5e88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从准备这个问题的测试用例开始，然后我们将跳入解决方案。但首先，我们需要决定我们到底想如何提供解决方案。因为这只是简单的计数，一个自由函数就足够了，而且因为我们将从文件中读取数据，所以输入参数为<code class="fe lw lx ly lz b">std::istream</code>是有意义的。因此，我决定选择<code class="fe lw lx ly lz b">uint32_t count_increasing(std::istream&amp; s);</code>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="a204" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我使用Google Test作为测试运行时环境，只是因为它是Bazel的一个简单的默认环境。测试采用表驱动测试，我们将所有的输入和预期的输出格式化成一个数组，然后遍历子用例。如果您决定使用这种类型的测试，确保您使用<code class="fe lw lx ly lz b">EXPECT</code>风格的测试宏而不是<code class="fe lw lx ly lz b">ASSERT</code>，<code class="fe lw lx ly lz b">EXPECT</code>宏将继续测试执行，即使在失败之后，这就是我们在这里想要的。我们希望看到表中所有失败的子案例，而不是停留在第一个案例上。</p><p id="eed5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这个，我们就可以继续前进，实施解决方案。答案已经在问题提法里了。我们需要“统计案例”，C++提供了一个<code class="fe lw lx ly lz b">std::count</code>算法。我们可以使用旧的C++版本，也可以使用C++20中引入的<code class="fe lw lx ly lz b">std::ranges</code>版本。下面是C++20版本:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="7fc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们一行一行地检查解决方案。</p><ul class=""><li id="1895" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated">在第8行中，我们使用了<code class="fe lw lx ly lz b">std::count_if</code>，这是一个变量，它计算所提供的可调用函数返回<code class="fe lw lx ly lz b">true</code>的情况。</li><li id="c78c" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">第9行，我们使用<code class="fe lw lx ly lz b">std::ranges::istream_view&lt;uint32_t&gt;</code>从一个期望正整数序列的<code class="fe lw lx ly lz b">istream </code>构造一个视图。</li><li id="1c09" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">第10行是我们的有状态lambda，它记住了最后看到的元素，并返回它是否小于当前元素。<code class="fe lw lx ly lz b">std::exchange</code>会将<code class="fe lw lx ly lz b">prev</code>设置为<code class="fe lw lx ly lz b">curr</code>，并返回<code class="fe lw lx ly lz b">prev</code>的先前值。</li></ul><p id="8bc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以使用<code class="fe lw lx ly lz b">bazel test //...</code>来对照测试检查解决方案(详见最后一节)。然后，我们需要一个简单的main来打开一个带有适当输入的文件，并将其传递给<code class="fe lw lx ly lz b">count_increasing</code>函数。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><h2 id="6938" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">第一天:第二部分</h2><p id="f119" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">在第二部分，我们有一个额外的任务。我们首先需要计算三个元素的滑动窗口和，而不是比较每个测量值。例如，在<code class="fe lw lx ly lz b">1 2 3 4 5</code>的情况下，我们将比较<code class="fe lw lx ly lz b">1+2+3 &lt; 2+3+4</code>和<code class="fe lw lx ly lz b">2+3+4 &lt; 3+4+5</code>。</p><p id="ddb0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种变化不需要对界面进行任何调整。因此，我们可以坚持使用相同的功能原型，像以前一样，我们可以准备一组简单的测试。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="d93a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用C++20范围实现这个有点棘手。视图是延迟计算的，它们不适合有状态的lambdas。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="a1d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们仍然可以使用视图来构建一个表示三个元素总和的视图(第3–6行)。从逻辑上讲，我们现在想要使用<code class="fe lw lx ly lz b">std::ranges::views::drop(2)</code>来删除前两个部分和(在<code class="fe lw lx ly lz b">1 2 3 4 5</code>示例中，它们是<code class="fe lw lx ly lz b">0+0+1</code>和<code class="fe lw lx ly lz b">0+1+2</code>)。不幸的是，由于有状态lambda，这并不可行。</p><p id="5ff6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以将drop逻辑移动到我们的<code class="fe lw lx ly lz b">count_if</code>(第11-14行)中，使得阅读起来更加困难。希望有了C++23中的扩展和修正，这段代码会干净很多(例如使用<code class="fe lw lx ly lz b">zip_with</code>)。</p><p id="fa2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目前，一个更干净的解决方案是范围循环:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="0bf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于<code class="fe lw lx ly lz b">std::ranges::istream_view</code>，这个解决方案仍然是C++20。</p><p id="b5b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一步是像第1部分一样将解决方案包装在主函数中。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><h1 id="37c1" class="mq kz iq bd la mr ms mt ld mu mv mw lg mx my mz lj na nb nc lm nd ne nf lp ng bi translated">巴泽尔</h1><p id="b96f" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">最后，我想简单讨论一下Bazel构建系统。在我的项目中，Bazel是我的个人偏好，原因如下:</p><ul class=""><li id="c2a7" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated">构建文件非常清晰易读</li><li id="771c" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">轻松地与其他构建系统互操作，并且可以从git存储库或tarballs中引入外部库</li><li id="1fc4" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">扩展性非常好</li><li id="0467" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">在一个沙箱中运行所有的东西，这强制执行密封测试</li></ul><p id="2787" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，下面是两种解决方案及其测试的<code class="fe lw lx ly lz b">BUILD</code>文件:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="9ede" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像GoogleTest这样的外部依赖项是在<code class="fe lw lx ly lz b">WORKSPACE </code>文件中配置的。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="050a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果外部项目没有使用Bazel，您将需要做更多的配置，但大多数情况下就是这么简单。</p><p id="3b80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编译器标志和其他配置存在于<code class="fe lw lx ly lz b">.bazelrc</code>中，或者可以在命令行上传递。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="a26e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过至少创建一个工作区和一个构建文件来配置您的构建之后，您就可以开始运行Bazel了。</p><ul class=""><li id="e4de" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated">构建一切:<code class="fe lw lx ly lz b">bazel build //...</code></li><li id="470b" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">测试一切:<code class="fe lw lx ly lz b">bazel test //...</code></li><li id="70a3" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">构建具体文件:<code class="fe lw lx ly lz b">bazel build //day1:sonar-trivial</code></li><li id="b9c3" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">运行具体文件:<code class="fe lw lx ly lz b">bazel run //day1:sonar-sliding</code></li><li id="48c3" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">带标志运行:<code class="fe lw lx ly lz b">bazel run //day1:sonar-sliding -- $(pwd)/day1/input.txt</code></li></ul><h1 id="fbeb" class="mq kz iq bd la mr ms mt ld mu mv mw lg mx my mz lj na nb nc lm nd ne nf lp ng bi translated">链接和技术说明</h1><p id="40ee" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">每日解决方案存储库位于:<a class="ae kx" href="https://github.com/HappyCerberus/moderncpp-aoc-2021" rel="noopener ugc nofollow" target="_blank">https://github.com/HappyCerberus/moderncpp-aoc-2021</a>。</p><p id="95f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于《代码降临》中其他日子的文章，<a class="ae kx" href="https://medium.com/@happy.cerberus/list/advent-of-code-2021-using-modern-c-c5814cb6666e" rel="noopener">看看这个列表</a>。</p><p id="5a4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请不要忘记亲自尝试<a class="ae kx" href="https://adventofcode.com/2021" rel="noopener ugc nofollow" target="_blank">降临码</a>。</p><h1 id="a92b" class="mq kz iq bd la mr ms mt ld mu mv mw lg mx my mz lj na nb nc lm nd ne nf lp ng bi translated">感谢您的阅读</h1><p id="f1a2" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">感谢您阅读这篇文章。你喜欢吗？</p><p id="0a66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也在YouTube上发布视频。你有问题吗？在Twitter或LinkedIn上联系我。</p></div></div>    
</body>
</html>