<html>
<head>
<title>Swift Superiority over C++ in Handling the Visitor Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift在处理访问者模式方面优于C++</h1>
<blockquote>原文：<a href="https://itnext.io/making-visitor-pattern-obsolete-using-swift-c16e49a2e52f?source=collection_archive---------0-----------------------#2016-12-28">https://itnext.io/making-visitor-pattern-obsolete-using-swift-c16e49a2e52f?source=collection_archive---------0-----------------------#2016-12-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="070a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过学习Swift如何解决C++软件架构中的一个常见问题，感受Swift的强大，这个问题没有优雅的解决方案。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/51df5a99201fb7437af5d4bdea25a81f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iZQQBd6q7sjTAqbRH8KZiA.png"/></div></div></figure><p id="4804" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为一名C++开发人员，我广泛使用了面向对象的设计模式。其中一种模式叫做<strong class="kt ir">访客模式，</strong>最早由<a class="ae ln" href="https://en.wikipedia.org/wiki/Design_Patterns" rel="noopener ugc nofollow" target="_blank">四人组</a>在著名的<a class="ae ln" href="https://en.wikipedia.org/wiki/Design_Patterns" rel="noopener ugc nofollow" target="_blank">设计模式</a>一书中描述。</p><p id="6960" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我选择在这个故事中讲述这种模式，因为这是为什么Swift允许您编写比C++更优雅、更易维护的代码的最清晰的例子之一。当我几年前写下这个故事时，我受到了一篇由Ron Avitzur撰写的文章的启发，这篇文章的标题是:<a class="ae ln" href="https://www.swift.org/blog/graphing-calculator/" rel="noopener ugc nofollow" target="_blank">将图形计算器从C++移植到Swift </a>。</p><p id="f2a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Ron谈到他如何通过从C++移植到Swift来大幅减少代码的大小:</p><blockquote class="lo"><p id="ad09" class="lp lq iq bd lr ls lt lu lv lw lx lm dk translated">最终，该端口的可维护性、可读性和紧凑性大大提高。当我移植功能的单个部分时，Swift源代码通常只有相应C++代码的30%。</p></blockquote><p id="a986" class="pw-post-body-paragraph kr ks iq kt b ku ly jr kw kx lz ju kz la ma lc ld le mb lg lh li mc lk ll lm ij bi translated">这篇文章的许多评论者认为Swift能够如此显著地减少代码量是不可思议的。我希望这个故事能让好奇的人知道这是怎么可能的。</p><p id="e765" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在C++中，访问者模式允许你解决一些棘手的问题，但是它是通过增加相当多的复杂性来实现的。为了维护代码，您或其他开发人员需要能够容易地理解代码。难读的代码比易读的代码更难维护。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi md"><img src="../Images/f1299ae805517885b1612542c7d801a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I8TSA3feRp3goWD7g_fNuw.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">macOS Finder中使用的谓词编辑器，用于过滤文件系统中符合一组标准的文件。</figcaption></figure><p id="a5b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将介绍的代码示例基于我构建图形用户界面(GUI)的经验，该界面用于表示过滤对象集合的规则。macOS file manager Finder和iTunes都使用这种基于规则的过滤器，称为<em class="mi">谓词编辑器</em>。</p><h1 id="02f3" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">用谓词编辑器定义过滤器规则</h1><p id="9d94" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">谓词是返回布尔值的运算符或函数。下面是一个谓词，它用一个比较运算符组合了两个表达式:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="2e67" class="nl mk iq nh b gy nm nn l no np">a + 3 &gt; 4 - 2b</span></pre><p id="459c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在内存中，我们可以将它表示为一个对象树。这里每种颜色代表不同类别的对象或类。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl nq"><img src="../Images/c669850c98f4b0e73e2e127e7b1f025d.png" data-original-src="https://miro.medium.com/v2/format:webp/1*4NTpH1lSC-z7D3Zf3kYmrA.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">表达式树表示:<em class="nr"> a + 3 &gt; 4 — 2b </em></figcaption></figure><p id="a8ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在macOS上，有许多支持通过GUI编辑器创建谓词的应用程序示例。iTunes中的智能播放列表就是一个例子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl nq"><img src="../Images/ab3cb0221106513035c94ea7c46c791e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*muEgJtv43E5eOl2ENZW49A.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">在iTunes中配置谓词编辑器以查找20世纪90年代发行的歌曲。</figcaption></figure><p id="6447" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">想象一下，我们想用C++创建这样一个编辑器。因此，我们需要一个GUI，它允许我们编写一个谓词。一旦我们得到了谓词，我们可能想要过滤MP3歌曲的列表，以找到可以归类为90年代音乐的歌曲。</p><p id="82b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们就考虑简单点的吧。我们如何表达25首播放最多的歌曲的谓词？下面是iTunes的一种做法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl nq"><img src="../Images/dba94f1e7f560dd439175ca8ea01998e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*DweANr4IDhmHBSLoND6JsA.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">用于在GUI中构建谓词表达式的谓词编辑器。每一行都是一个子谓词表达式。</figcaption></figure><p id="8928" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们关注其中一个子表达式，假设我们希望歌曲播放的次数大于零:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="fa7a" class="nl mk iq nh b gy nm nn l no np">plays &gt; 0</span></pre><p id="6895" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以构建一个表达式树来表示这个表达式。表达式的每一部分都是由不同的C++类表示的表达式树中的一个节点。例如，播放次数将是每首歌曲的属性<code class="fe ns nt nu nh b">plays</code>。我们用一个<code class="fe ns nt nu nh b">AttributeExpression</code>类来表示这样的属性。数字0由一个<code class="fe ns nt nu nh b">ConstantExpression</code>类表示，以此类推。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="f2ef" class="nl mk iq nh b gy nm nn l no np">// C++ code for defining an expression tree for `plays &gt; 0`</span><span id="cfe2" class="nl mk iq nh b gy nv nn l no np">Expression *plays = AttributeExpression("plays");<br/>Expression *zero  = ConstantExpression(0);<br/>Predicate *pred = LargerThanPredicate(plays, zero);<br/>playedsongs = allsongs.filter(pred);</span></pre><p id="d977" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以为了使用谓词，我们处理<code class="fe ns nt nu nh b">Expression</code>和<code class="fe ns nt nu nh b">Predicate</code>对象。我们的目标是能够使用如前所示的图形用户界面构建这种表达式树。在这个接口中，每个子表达式都作为单独的一行来处理。我们如何用代码表示这个接口？</p><p id="3df7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以用一个<code class="fe ns nt nu nh b">PredEditorRow</code>类来代表每一行的GUI。然而，有许多不同种类的行。谓词可以任意嵌套，所以我们需要复合行。</p><p id="65f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们重温我们的第一个音乐智能列表。90年代的音乐谓词大概是这样的:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="24c0" class="nl mk iq nh b gy nm nn l no np">1990 &lt; year &lt; 1999 &amp;&amp; (mediakind == "music" || mediakind == "music video")</span></pre><p id="668d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以年份范围可以用一个<code class="fe ns nt nu nh b">PredEditorLeafRow</code>来表示,“媒体种类”行必须有一个父对象，这个父对象可以是一个<code class="fe ns nt nu nh b">PredEditorCompositeRow</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/15d08e06c06439fcc8471d982f0ae959.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Til4ytisFPitdz6Uzp9vPg.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">每一行都是一个预编辑行，但是我们区分叶行和复合行。</figcaption></figure><p id="1d97" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们用<a class="ae ln" href="https://en.wikipedia.org/wiki/Composite_pattern" rel="noopener ugc nofollow" target="_blank">复合设计模式</a>来表示谓词编辑器。这一行最右边的部分将代表我们要比较属性的某种形式的表达式。可以简单地表示为文本字段中的一个数字或字符串。但是它也可以是合法值的列表、调色板中的颜色等。因此，为了处理所需的灵活性，我们可以使用一种<a class="ae ln" href="https://en.wikipedia.org/wiki/Strategy_pattern" rel="noopener ugc nofollow" target="_blank">策略模式</a>。在我们的图表中，我们将其表示为<code class="fe ns nt nu nh b">ExpressionEditor</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl nq"><img src="../Images/fb1209bf616914e370b3cecf5cdbed86.png" data-original-src="https://miro.medium.com/v2/format:webp/1*SYjCjKB4A2mbak7D4btvPA.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">描述用于定义谓词编辑器图形用户界面(GUI)的C++类的UML图。</figcaption></figure><p id="1149" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">想象一下，每一行都指向一个表达式编辑器，可以与另一个编辑器交换。细节并不重要，因为我们主要对访问者模式的实现感兴趣。这只是给出一个大概的想法。</p><h1 id="5ee6" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">使用访问者遍历表达式树</h1><p id="774c" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">面临的挑战是:给定一个表示谓词的对象树，我们如何将它转化为谓词编辑器的GUI元素树。如果我们从磁盘上读取一个谓词表示，并想为它显示一个编辑器，就会出现这个问题。</p><p id="24c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样的对象树将不是同质的，因为它将由表达式和谓词对象组成。每个对象都有自己的子类。表达式可以细分为例如属性表达式和常数。因为它不是同质的，所以没有简单的方法以通用的方式遍历这样的结构。</p><p id="3e9d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是为什么一个访问者是有益的。我们可以设计我们的表达式和谓词类来接受类型<code class="fe ns nt nu nh b">PredVisitor</code>的访问者。然后我们可以用不同的子类来构建不同类型的数据结构。例如，<code class="fe ns nt nu nh b">PredEditorVisitor</code>子类可以从一个谓词构建一个GUI，而<code class="fe ns nt nu nh b">PredJSONVisitor</code>子类可以将谓词以JSON格式存储到磁盘。</p><p id="7f3a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面的UML图显示了谓词类和访问者是如何相互连接的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl nq"><img src="../Images/8ff5aee379201688524538218f862265.png" data-original-src="https://miro.medium.com/v2/format:webp/1*XgDilhLy0vd0c9BzqXLUSw.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">黄色代表抽象基类，灰色方框是具体的实现类。</figcaption></figure><p id="fd1f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在内部，<code class="fe ns nt nu nh b">PredEditorVisitor</code>将需要两个堆栈来跟踪父节点，因为我们构建GUI。对于谓词，我们首先获得顶部的父节点，因此我们必须自顶向下构建。复杂的是有不同种类的父节点。表达式节点有一个比较谓词作为父节点。而比较谓词必须有一个像AND、OR、XOR等复合谓词作为父节点。因此，我们维护两个不同的堆栈<code class="fe ns nt nu nh b">compositeStack</code>和<code class="fe ns nt nu nh b">leafStack</code>:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="6773" class="nl mk iq nh b gy nm nn l no np"><strong class="nh ir">class</strong> PredEditorVisitor : PredVisitor {<br/>    <strong class="nh ir">virtual</strong> void visit(AttributeExpression *exp);<br/>    <strong class="nh ir">virtual</strong> void visit(ConstantExpression *exp);<br/>    <strong class="nh ir">virtual</strong> void visit(LargerThanPredicate *pred);<br/><strong class="nh ir">private</strong>:<br/>    Stack&lt;PredEditorCompositeRow *&gt; compositeStack;<br/>    Stack&lt;PredEditorLeafRow *&gt; leafStack;<br/>    MetaData *metaData; // Describe data we are filtering<br/>}</span></pre><p id="b89e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每当访问者访问谓词表达式树中的一个节点时，它必须决定将创建的GUI组件放在哪个堆栈中。使用哪个堆栈取决于我们访问的是表达式、比较还是复合谓词。下面是一个访问<em class="mi">复合</em>谓词节点的例子:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="2a0c" class="nl mk iq nh b gy nm nn l no np"><strong class="nh ir">void</strong><br/>PredEditorVisitor::Visit(CompoundPredicate *pred) {<br/>    PredEditorCompositeRow *row = <strong class="nh ir">new</strong> PredEditorCompositeRow(pred);<br/>    <strong class="nh ir">if</strong> (!compositeStack.empty())<br/>        compositeStack.top()-&gt;addChild(row);<br/>    <br/>    compositeStack.push_back(row);<br/>    <strong class="nh ir">for</strong> (Predicate *child: pred) {<br/>        pred-&gt;Accept(this);<br/>    }<br/>    compositeStack.pop_back();<br/>}</span></pre><p id="6500" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当访问一个<em class="mi">比较</em>谓词节点时，我们利用叶栈:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="7192" class="nl mk iq nh b gy nm nn l no np"><strong class="nh ir">void</strong><br/>PredEditorVisitor::Visit(ComparisonPredicate *pred) {<br/>    PredEditorLeafRow *row = new PredEditorLeafRow(<br/>              metaData-&gt;attributes, operationsForAttribute);<br/>    <br/>    <strong class="nh ir">if</strong> (!compositeStack.empty())<br/>      compositeStack.top()-&gt;addChild(row);<br/>    <br/>    leafStack.push_back(row)<br/>    pred-&gt;leftExpression-&gt;accept(this)<br/>    row-&gt;selectOperator(pred-&gt;operator)    <br/>    pred-&gt;rightExpression-&gt;accept(this)<br/>    <br/>    leaf_stack_.pop_back();<br/>}</span></pre><p id="8e17" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们所做的只是添加新类型的访问者，那么这种解决方案相当有效。然而，如果添加了新的谓词和表达式，那么就很难管理，因为您需要更新每个访问者。</p><h1 id="7720" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">使用Swift类扩展使访问者变得多余</h1><p id="2f9d" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">我们的C++解决方案需要使用访问者，因为我们无法预先知道我们可能想要为谓词创建什么样的GUI，或者我们想要将其序列化为什么样的格式。我们还希望分离关注点，不要将GUI代码与模型代码混在一起。</p><p id="bb28" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了Swift，你可以用类扩展解决这样的问题。类扩展允许我们向现有的类添加功能。</p><p id="1c7f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设我们从另一家公司购买了现成的谓词和表达式类，比如说Translusion。即使代码是封闭源代码并且不能被修改，我们仍然可以通过类扩展为它们添加功能。现有的谓词和表达式代码将<em class="mi">而不是</em>依赖于这些新的扩展。来自Translusion的类不需要知道我们对它们的类所做的任何扩展。我们实现了完全脱钩。</p><h2 id="6178" class="nl mk iq bd ml nx ny dn mp nz oa dp mt la ob oc mv le od oe mx li of og mz oh bi translated">使用Swift中的类扩展从表达式树构建谓词编辑器</h2><p id="e50d" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">让我们回顾一下C++ visitor解决方案中的一些案例。首先，我们看了如何使用访问者从复合谓词创建嵌套行。</p><p id="1466" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用Swift，我们只需为每个谓词和表达式子类添加一个创建GUI行的方法。首先，我们要为表达式和谓词添加一个默认方法，以防我们添加了一个新的子类而忘记实现我们的GUI行创建代码。我们总是需要访问我们要为其创建谓词和表达式的数据的描述，因为例如，可用于字符串数据的比较运算符对于例如数字是不同的。因此，我们总是需要提供某种元数据对象。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="e6d7" class="nl mk iq nh b gy nm nn l no np"><strong class="nh ir">extension</strong> Expression {<br/>   <strong class="nh ir">func</strong> createExpressionEditor(meta: MetaData) -&gt; ExpressionEditor {<br/>       <strong class="nh ir">var</strong> attr = self.attribute(meta)<br/>       <strong class="nh ir">return</strong> ExpressionEditor.editorFor(attr, attr.defaultOperator) <br/>   }</span><span id="759e" class="nl mk iq nh b gy nv nn l no np">   <strong class="nh ir">func</strong> attribute(meta: MetaData) -&gt; Attribute {<br/>       <strong class="nh ir">return</strong> meta.defaultAttribute<br/>   }<br/>}<br/><br/><strong class="nh ir">extension</strong> Predicate {<br/>   <strong class="nh ir">func</strong> createPredEditorRow(meta: MetaData) -&gt; PredEditorRow? {<br/>       <strong class="nh ir">return</strong> nil<br/>   }<br/>}</span></pre><p id="466c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，对于每个子类，我们实现代码来为特定类型的谓词或表达式创建GUI行。例如，让我们看看<code class="fe ns nt nu nh b">ComparisonPredicate</code>:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="09ea" class="nl mk iq nh b gy nm nn l no np"><strong class="nh ir">extension</strong> ComparisonPredicate {<br/>   <strong class="nh ir">func</strong> createPredEditorRow(meta: MetaData) -&gt; PredEditorRow? {<br/>       <strong class="nh ir">let</strong> row = PredEditorLeafRow(meta.attributes,<br/>                                   meta.operationsForAttribute)<br/>       row.selectAttribute(leftExpression.attribute(meta))<br/>       row.selectOperator(self.operator(meta))<br/>       row.expressionEditor = rightExpression.createExpressionEditor(meta)<br/>       <strong class="nh ir">return</strong> row<br/>   }<br/>}</span></pre><p id="51ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">获得细节并不重要，但是让我们大致了解一下正在发生的事情:我们一次为一行创建GUI。我们需要配置这一行，因此在左边它显示了一个下拉列表，列出了我们也将应用谓词的对象的可能属性。谓词可以应用于歌曲、电子邮件、文件或图像等对象。如果我们过滤电子邮件，那么meta将包含有关电子邮件对象的元数据，例如电子邮件可能具有的属性:</p><ul class=""><li id="be22" class="oi oj iq kt b ku kv kx ky la ok le ol li om lm on oo op oq bi translated"><strong class="kt ir">发件人</strong> —谁发的邮件</li><li id="1526" class="oi oj iq kt b ku or kx os la ot le ou li ov lm on oo op oq bi translated"><strong class="kt ir">收件人</strong>——我们将电子邮件发送给谁</li><li id="6835" class="oi oj iq kt b ku or kx os la ot le ou li ov lm on oo op oq bi translated"><strong class="kt ir">主题</strong> —邮件的主题</li><li id="4a97" class="oi oj iq kt b ku or kx os la ot le ou li ov lm on oo op oq bi translated"><strong class="kt ir">优先级</strong> —这封邮件有多重要</li></ul><p id="738d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在决定哪些运算符可用于比较时，选择了哪些属性是很重要的。</p><p id="491b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">重要的是看到我们如何容易地添加GUI特定的代码作为非GUI类的扩展。这并没有破坏关注点的分离，因为同一个类可以很容易地在以后重用，而没有任何GUI依赖性。扩展不能添加成员变量或更改现有方法的行为。</p><p id="eb63" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以通过在它们的共享基类中实现扩展来处理所有复合谓词，如AND、OR、XOR:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="9114" class="nl mk iq nh b gy nm nn l no np"><strong class="nh ir">extension</strong> CompoundPredicate {<br/>   <strong class="nh ir">func</strong> createPredEditorRow(meta: MetaData) -&gt; PredEditorRow? {<br/>       <strong class="nh ir">let</strong> row = PredEditorCompositeRow(pred)<br/>       <strong class="nh ir">for</strong> childpred in self {<br/>           row.addChild(childpred.createPredEditorRow(meta))<br/>       }<br/>   }<br/>}</span></pre><p id="0f5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以看到，在迭代子谓词时，我们不需要任何类型的转换，因为编译器知道每个谓词都有一个<code class="fe ns nt nu nh b">createPredEditorRow</code>，因为我们将它作为扩展添加到了<code class="fe ns nt nu nh b">Predicate</code>协议中。</p><h2 id="5c96" class="nl mk iq bd ml nx ny dn mp nz oa dp mt la ob oc mv le od oe mx li of og mz oh bi translated">使用类扩展生成JSON表示</h2><p id="d0ad" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">实现JSON序列化比重新创建GUI容易得多。扩展允许我们将序列化代码放在与谓词代码完全分离的文件中。</p><p id="11ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">和以前一样，我们需要在基类或协议中创建JSON代码，这样编译器就会知道<code class="fe ns nt nu nh b">createJSONRepresentation</code>对所有子类都可用。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="33ed" class="nl mk iq nh b gy nm nn l no np"><strong class="nh ir">extension</strong> Expression {<br/>    <strong class="nh ir">func</strong> createJSONRepresentation() -&gt; Any? {<br/>        <strong class="nh ir">return</strong> nil<br/>    }<br/>}<br/><br/><strong class="nh ir">extension</strong> Predicate {<br/>    <strong class="nh ir">func</strong> createJSONRepresentation() -&gt; Any?<br/>        <strong class="nh ir">return</strong> nil<br/>    }<br/>}</span><span id="96dd" class="nl mk iq nh b gy nv nn l no np"><strong class="nh ir">extension</strong> AttributeExpression {<br/>   <strong class="nh ir">func</strong> createJSONRepresentation() -&gt; Any? {<br/>       <strong class="nh ir">return</strong> ["type" : "AttributeExpression", "name", self.name] <br/>}</span><span id="1475" class="nl mk iq nh b gy nv nn l no np"><strong class="nh ir">extension</strong> ConstantExpression {<br/>   <strong class="nh ir">func</strong> createJSONRepresentation() -&gt; Any? {<br/>       <strong class="nh ir">return</strong> ["type" : "ConstantExpression", "value", self.value] <br/>}</span><span id="13e1" class="nl mk iq nh b gy nv nn l no np"><strong class="nh ir">extension</strong> ComparisonPredicate {<br/>   <strong class="nh ir">func</strong> createJSONRepresentation() -&gt; Any? {<br/>       <strong class="nh ir">return</strong> <br/>          ["type" : "ComparisonPredicate",<br/>       "operator" : self.comparisonOperator,<br/>"leftExpression"  : self.leftExpression.createJSONRepresentation(),<br/>"rightExpression" : self.rightExpression.createJSONRepresentation()]<br/>   } <br/>}</span></pre><h1 id="22bc" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">结论</h1><p id="6311" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">诚然，谓词编辑器的例子可能不容易理解。但是这强调了另一个事实，即解决这类问题是相当复杂的，当你需要依赖访问者模式时，它们会变得更加复杂。因为Swift支持类扩展，功能是第一类的等等，许多常见的设计模式消失了或者变得无关紧要。这是件好事。设计模式从根本上说是一种语言气味。它们指出了需要发明设计模式的语言中缺乏的特性。</p></div></div>    
</body>
</html>