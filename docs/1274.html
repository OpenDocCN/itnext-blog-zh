<html>
<head>
<title>Combining HOCs with the new React’s Context API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将HOCs与新React的上下文API相结合</h1>
<blockquote>原文：<a href="https://itnext.io/combining-hocs-with-the-new-reacts-context-api-9d3617dccf0b?source=collection_archive---------0-----------------------#2018-08-27">https://itnext.io/combining-hocs-with-the-new-reacts-context-api-9d3617dccf0b?source=collection_archive---------0-----------------------#2018-08-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="077d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React最近发布了一个次要版本(16.3)，其中包括一个大肆宣传的上下文API的“稳定”版本。它被大肆宣传的原因是React让开发人员可以提前接触到API的“测试”版本。它现在得到了他们团队的官方支持，并被强烈推荐使用。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><h1 id="6a1d" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">但是，什么是上下文API呢？</h1><p id="b08c" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">如果你不知道<strong class="jp ir">什么是</strong>上下文API，我推荐你阅读<a class="ae lv" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React的官方文档</a>或者这篇由<a class="lw lx ep" href="https://medium.com/u/db72389e89d8?source=post_page-----9d3617dccf0b--------------------------------" rel="noopener" target="_blank"> Kent C. Dodds </a>撰写的<a class="ae lv" href="https://medium.com/dailyjs/reacts-%EF%B8%8F-new-context-api-70c9fe01596b" rel="noopener">文章</a>。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/0e25a1e3629868d21b77c02eb07ffd63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PDeEZW6eUSBL2GQ1H1XTLg.png"/></div></div></figure></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><h1 id="9bff" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">为什么要使用它的灵感</h1><p id="9126" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">大约12个月前，我开始写我想在<a class="ae lv" href="https://www.askable.com/" rel="noopener ugc nofollow" target="_blank"> Askable </a>使用的结构的初稿。根据我以前的经验，我尝试使用React和Redux。React听起来像是一个显而易见的选择，但Redux不是。</p><p id="3a1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要误会，Redux是一个很神奇的工具。然而，我总是觉得我必须写太多的代码来实现我想要的。编写动作、归约器、连接器等等不是一件容易的事情(特别是如果你有一个嵌套结构的状态)。</p><p id="d97d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我决定不使用Redux，并检查一些替代品，因为我想快速交付特性。</p><h2 id="8543" class="mk kt iq bd ku ml mm dn ky mn mo dp lc jy mp mq lg kc mr ms lk kg mt mu lo mv bi translated">问题是</h2><p id="53e7" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">我面临的主要问题是找到一种简单的方法，在不同的文件中使用公共组件，而不必将它们导入到每个文件中。</p><p id="876f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，您有一个名为<code class="fe mw mx my mz b">Header.js</code>的组件，并且想要调用一个名为<code class="fe mw mx my mz b">modalPricing.js</code>的模态组件。把<code class="fe mw mx my mz b">modalPricing.js</code>文件直接包含到你的<code class="fe mw mx my mz b">Header.js</code>里问题不大。但是，如果您需要将同一个文件调用到您的<code class="fe mw mx my mz b">Footer.js</code>中呢？你会导入同样的文件吗？如果你不得不在其他地方调用同一个模态呢？</p><p id="5ee0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您采用这种解决方案，您将会在DOM中出现同一个模态窗口的多个实例。您可能知道，这不是一个好的做法。</p><h2 id="40a3" class="mk kt iq bd ku ml mm dn ky mn mo dp lc jy mp mq lg kc mr ms lk kg mt mu lo mv bi translated">解决方案</h2><p id="1d57" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">我可以使用Redux Provider并传递props来打开/关闭模态。然而，正如我之前提到的，我不想走这条路。此外，我不想在我的项目中包含另一个依赖项。</p><p id="9f0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是当我看到React团队计划支持开箱即用的上下文API时，我感到兴奋的主要原因。理论上，这将解决我的问题。</p><p id="9fd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我决定使用“就这么做”的方法:)</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><h1 id="841a" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">将上下文API与HOC一起使用</h1><p id="e677" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">在使用新API一段时间后，包装组件的过度使用困扰着我。将一个上下文包装到您的组件中没什么大不了的，但是如果您有多个上下文呢？在到达组件之前，您会包装多个上下文吗？它可以工作，但是开发人员的体验会受到影响。</p><p id="6f9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，假设您有三个上下文——auth context、AppContext和ComponentsContext。你会把你的组件包装成三个不同的上下文来得到你想要的吗？我不这么认为。</p><p id="0aa3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我为这个问题找到的解决方案是结合新的上下文API和HOC的(<a class="ae lv" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件文档</a>)。</p><p id="11c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我们来看看怎么实现。:)</p><p id="d119" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里查看这篇文章的知识库:<a class="ae lv" href="https://github.com/xicovarisco/context-api-with-hocs" rel="noopener ugc nofollow" target="_blank"> Github上下文Api </a></p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><h2 id="f9ab" class="mk kt iq bd ku ml mm dn ky mn mo dp lc jy mp mq lg kc mr ms lk kg mt mu lo mv bi translated">1 —创建您的React提供程序</h2><p id="bd38" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated"><em class="na"> appProvider.js </em></p><pre class="lz ma mb mc gt nb mz nc nd aw ne bi"><span id="becb" class="mk kt iq mz b gy nf ng l nh ni">import React, { Component } from 'react';<br/>import { PricingModal, Snackbar } from 'src/components/common';</span><span id="6aa6" class="mk kt iq mz b gy nj ng l nh ni">// Create a new context for the app<br/>export const AppContext = React.createContext('app');</span><span id="b42b" class="mk kt iq mz b gy nj ng l nh ni">// Creates a provider Component<br/>class AppProvider extends Component {<br/>    constructor(props) {<br/>        super(props);</span><span id="8d66" class="mk kt iq mz b gy nj ng l nh ni">        this.state = {<br/>            openPricingModal: false<br/>        };</span><span id="40a0" class="mk kt iq mz b gy nj ng l nh ni">       this.onOpenPricingModal = this.onOpenPricingModal.bind(this);<br/>    }</span><span id="e439" class="mk kt iq mz b gy nj ng l nh ni">     onOpenPricingModal() {<br/>        this.setState({ openPricingModal: true });<br/>    }</span><span id="3a0b" class="mk kt iq mz b gy nj ng l nh ni">    render() {<br/>        return (<br/>            &lt;<strong class="mz ir">AppContext.Provider</strong><br/>                value={{<br/>                    state: this.state,<br/>                    <strong class="mz ir">onOpenPricingModal</strong>: this.onOpenPricingModal<br/>                }}<br/>            &gt;<br/>                {this.props.children}<br/>                &lt;PricingModal<br/>                    open={this.state.openPricingModal}<br/>                    onClose={() =&gt; this.setState({ openPricingModal: false })}<br/>                /&gt;<br/>           <strong class="mz ir"> &lt;/AppContext.Provider&gt;</strong><br/>        );<br/>    }<br/>}</span><span id="cf27" class="mk kt iq mz b gy nj ng l nh ni">export default AppProvider;</span></pre><h2 id="50b5" class="mk kt iq bd ku ml mm dn ky mn mo dp lc jy mp mq lg kc mr ms lk kg mt mu lo mv bi translated">2-为您的上下文创建一个特设</h2><p id="3ad5" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated"><em class="na"> withAppContext.js </em></p><pre class="lz ma mb mc gt nb mz nc nd aw ne bi"><span id="bca3" class="mk kt iq mz b gy nf ng l nh ni">import React from 'react';<br/>import { AppContext } from 'src/components/common';</span><span id="8527" class="mk kt iq mz b gy nj ng l nh ni">export function withAppContext(Component) {<br/>    return function WrapperComponent(props) {<br/>        return (<br/>            &lt;AppContext.Consumer&gt;<br/>                {state =&gt; &lt;Component {...props} context={state} /&gt;}<br/>            &lt;/AppContext.Consumer&gt;<br/>        );<br/>    };<br/>}</span></pre><h2 id="60a9" class="mk kt iq bd ku ml mm dn ky mn mo dp lc jy mp mq lg kc mr ms lk kg mt mu lo mv bi translated">3 —将根组件包装到提供程序中</h2><p id="edf0" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated"><em class="na"> app.js </em></p><pre class="lz ma mb mc gt nb mz nc nd aw ne bi"><span id="b5bc" class="mk kt iq mz b gy nf ng l nh ni">import React, { Component } from 'react';<br/>import { AppProvider } from 'src/components/common';</span><span id="16d9" class="mk kt iq mz b gy nj ng l nh ni">class App extends Component {<br/>    render() {<br/>        return (<br/>            <strong class="mz ir">&lt;AppProvider&gt;</strong><br/>                {/* Your component here */}<br/>            <strong class="mz ir">&lt;/AppProvider&gt;</strong><br/>        );<br/>    }<br/>}</span><span id="4a01" class="mk kt iq mz b gy nj ng l nh ni">export default App;</span></pre><h2 id="a92f" class="mk kt iq bd ku ml mm dn ky mn mo dp lc jy mp mq lg kc mr ms lk kg mt mu lo mv bi translated">4-在组件上使用上下文HOC</h2><p id="6155" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated"><em class="na"> header.js </em></p><pre class="lz ma mb mc gt nb mz nc nd aw ne bi"><span id="ba8f" class="mk kt iq mz b gy nf ng l nh ni">import React, { Component } from 'react';<br/>import { withAppContext } from 'src/components/HOCS';</span><span id="d0a9" class="mk kt iq mz b gy nj ng l nh ni">class Header extends Component {<br/>    render() {<br/>        return (<br/>            &lt;div className="headerComponent"&gt;<br/>                &lt;a<br/>                    className="pricingContainer"<br/>                    onClick={<strong class="mz ir">this.props.context.onOpenPricingModal</strong>}<br/>                &gt;<br/>                    &lt;p className="buy"&gt;<br/>                        Pricing. &lt;strong&gt;save up to 27%&lt;/strong&gt;<br/>                    &lt;/p&gt;<br/>                &lt;/a&gt;<br/>            &lt;/div&gt;<br/>        );<br/>    }<br/>}</span><span id="6a4b" class="mk kt iq mz b gy nj ng l nh ni">export default withAppContext(Header);</span></pre><h1 id="d4f0" class="ks kt iq bd ku kv nk kx ky kz nl lb lc ld nm lf lg lh nn lj lk ll no ln lo lp bi translated">结论</h1><p id="fabe" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">将HOC与新的React的上下文API结合使用，可以为您提供灵活性、可伸缩性和良好的开发人员体验。您可以根据需要创建任意多的上下文，并将它们封装到您需要使用的组件中。</p><p id="44d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果不使用Redux，这是保持代码简洁和不多次导入同一个组件的简单方法。</p><p id="6917" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae lv" href="https://askable.com" rel="noopener ugc nofollow" target="_blank"> Askable </a>，我们在生产中的所有项目中广泛使用这种模式，我们团队之间的接受度很高。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="2e60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lv" href="http://askable.com" rel="noopener ugc nofollow" target="_blank"> Askable </a>是一个寻找你的<strong class="jp ir">完美</strong>参与者的平台，最初是作为<a class="ae lv" href="https://www.orangedigital.com.au" rel="noopener ugc nofollow" target="_blank"> Orange Digital </a>的衍生产品开发的。在澳大利亚运行用户测试。跳转到我们的<a class="ae lv" href="https://au.askable.com/" rel="noopener ugc nofollow" target="_blank">登陆页面</a>或我们的<a class="ae lv" href="http://askable.com/" rel="noopener ugc nofollow" target="_blank">网站</a>了解更多详情。</p></div></div>    
</body>
</html>