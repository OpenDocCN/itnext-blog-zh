<html>
<head>
<title>A Quickstart Guide to Using Serializer With Your Ruby on Rails API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Ruby on Rails API中使用序列化程序的快速入门指南</h1>
<blockquote>原文：<a href="https://itnext.io/a-quickstart-guide-to-using-serializer-with-your-ruby-on-rails-api-d5052dea52c5?source=collection_archive---------0-----------------------#2018-07-09">https://itnext.io/a-quickstart-guide-to-using-serializer-with-your-ruby-on-rails-api-d5052dea52c5?source=collection_archive---------0-----------------------#2018-07-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e5af45512e2e5dc1883cb936f115df57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HWrhA3nQ6PnPInnU0CwI8w.jpeg"/></div></div></figure><p id="2d23" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Ruby on Rails是API的绝佳选择，因为渲染JSON就像<code class="fe kz la lb lc b">render :json</code>一样简单。然而，开箱即用，Rails提供了一些非常难看的数据。进入<a class="ae ld" href="https://github.com/rails-api/active_model_serializers/blob/v0.10.6/docs/general/getting_started.md" rel="noopener ugc nofollow" target="_blank">序列化器</a>，gem允许我们格式化我们的JSON而不需要在前端动一根手指。我们可以只选择<em class="le">我们想要的</em>信息，也可以通过一个请求访问我们的关系。看一下这个简单的例子，比较一下结果:</p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lf"><img src="../Images/fc350fd0afd30196f4e26dd916cf70a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cS8Ba_SWaXekt0ZvCUWm8g.jpeg"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">左边是标准，右边是序列化</figcaption></figure><h1 id="5aaf" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">装置</h1><p id="2484" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">在您完成设置您的<a class="ae ld" href="https://hashrocket.com/blog/posts/how-to-make-rails-5-api-only" rel="noopener ugc nofollow" target="_blank"> API Rails项目</a>之后，您只需要将序列化程序gem添加到您的gem文件<code class="fe kz la lb lc b">gem 'active_model_serializers'</code>中，然后运行<code class="fe kz la lb lc b">bundle install</code>。感谢Rails的魔力，这就是它所需要的一切。</p><h1 id="83e0" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">建立我们的标准文件</h1><p id="60d2" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">对于这个例子，我们将保持简单，只有人和他们的猫，在这种情况下，一个“属于”“有很多”的关系。所以，以下是你应该模仿的所有东西:</p><figure class="lg lh li lj gt ju"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="07dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">复制之后，不要忘记创建、迁移和播种您的数据库。</p><h1 id="8a79" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">设置序列化程序文件</h1><p id="537e" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">首先，让我们得到所有的猫，只有他们的名字，身份证，和最喜欢的食物。为此，要么使用<code class="fe kz la lb lc b">rails g serializer cat</code>，要么手动创建一个包含以下内容的/app/serializer/cat _ serializer . Rb文件:</p><pre class="lg lh li lj gt mt lc mu mv aw mw bi"><span id="45b2" class="mx lp it lc b gy my mz l na nb">class CatSerializer &lt; ActiveModel::Serializer<br/>  attributes :id, :name, :favorite_food<br/>end</span></pre><p id="11db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为您安装了序列化程序，所以Rails现在会在呈现资源之前查看这个文件夹。每个模型在这个文件夹中都需要一个相应的序列化程序文件。这是因为当你将一个对象传递给控制器中的一个<code class="fe kz la lb lc b">render :json</code>行时，现在是由序列化程序决定实际显示哪些属性。通过访问您的<code class="fe kz la lb lc b">/cats</code>路线来测试一下，看看JSON得到了什么渲染，然后移除<code class="fe kz la lb lc b">favorite_food</code>属性。现在，尝试为Person构建序列化程序。</p><h1 id="a791" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">引入关系</h1><p id="4ecd" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">你<em class="le">能不能</em>做这样的事去见猫的主人:</p><pre class="lg lh li lj gt mt lc mu mv aw mw bi"><span id="eed9" class="mx lp it lc b gy my mz l na nb">class CatSerializer &lt; ActiveModel::Serializer<br/>  attributes :id, :name, :person<br/>end </span></pre><p id="bb14" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这很好，Rails知道每个<code class="fe kz la lb lc b">Cat</code>都属于一个<code class="fe kz la lb lc b">Person</code>，所以它会渲染出完整的对象…但这是序列化器的全部意义。我们不需要<strong class="kd iu"/><strong class="kd iu">完整的</strong>对象，只需要我们需要的属性。为此，我们可以使用自定义函数来缩小搜索范围:</p><pre class="lg lh li lj gt mt lc mu mv aw mw bi"><span id="62cb" class="mx lp it lc b gy my mz l na nb">class CatSerializer &lt; ActiveModel::Serializer<br/>  attributes :id, :name, :owner <br/>  def owner<br/>    {owner_id: self.object.person.id, <br/>     owner_name: self.object.person.name}<br/>  end <br/>end</span></pre><p id="2655" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的属性中，我们告诉序列化程序使用<code class="fe kz la lb lc b">owner</code>方法，然后我们将其定义为返回一个结构化散列。这种方法的另一个好处是，我们可以将模糊的“人”头衔重新定义为前端的“所有者”。我们的<code class="fe kz la lb lc b">Person</code>类也可以以类似的方式显示他们的每只猫:</p><pre class="lg lh li lj gt mt lc mu mv aw mw bi"><span id="42d2" class="mx lp it lc b gy my mz l na nb">class PersonSerializer &lt; ActiveModel::Serializer<br/>  attributes :id, :cats<br/>  def cats <br/>    self.object.cats.map do |cat|<br/>      {name: cat.name, <br/>       age: cat.age,<br/>       favoriteFood: cat.favorite_food}<br/>    end <br/>  end <br/>end</span></pre><p id="fe39" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们得到了真正的<strong class="kd iu"><em class="le"/></strong>花式并覆盖了默认的<code class="fe kz la lb lc b">cats</code>方法以更好地适应我们的需要。因为我们的前端是JS，所以我们也给我们的散列键一个有效的JS变量名，<code class="fe kz la lb lc b">favoriteFood,</code>，这样一旦它到达那里就可以很容易地<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-object-destructuring-in-modern-javascript-59758ebfb778">析构</a>。</p><p id="e5f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">关系不一定只是“属于”“有很多”的关系，“多对多”也可以，还有“有一个”的关系。</p><h1 id="e4f9" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">那是什么东西呢？</h1><p id="5cb3" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">你会注意到我们正在通过<code class="fe kz la lb lc b">self.object</code>做所有这些。这里的<code class="fe kz la lb lc b">self</code>指的是<code class="fe kz la lb lc b">&lt;CatSerializer&gt;</code>(或<code class="fe kz la lb lc b">&lt;PersonSerializer&gt;</code>)实例，它有一个名为<code class="fe kz la lb lc b">object</code>的属性，这个属性是它当前正在经历的JSON对象。我之所以说现在，是因为序列化程序本质上是遍历所有给它的东西。如果它在一个索引路径上，它将遍历内部的每个对象并格式化它，但是它将对来自<code class="fe kz la lb lc b">show</code>路径的单个对象做同样的事情。还有，我喜欢显式，但你不一定要，那个<code class="fe kz la lb lc b">self</code>不放就是隐式。</p><h1 id="d57b" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">这些只是基础</h1><p id="6a83" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">您可以使用一个<a class="ae ld" href="https://www.youtube.com/watch?v=Ah5SaN1linA" rel="noopener ugc nofollow" target="_blank"> ApplicationSerializer文件或一些show方法来给出一个html模板</a>，为不同的路由创建多个自定义序列化器，或者跳转到<a class="ae ld" href="https://github.com/rails-api/active_model_serializers/blob/v0.10.6/docs/general/serializers.md" rel="noopener ugc nofollow" target="_blank">文档以获得更多信息</a>，但是我在这里概述的内容应该足以让您的API同时起步。</p><p id="f0aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">大家编码快乐，</p><p id="b254" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">麦克风</p></div></div>    
</body>
</html>