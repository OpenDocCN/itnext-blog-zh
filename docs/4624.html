<html>
<head>
<title>Introducing Joist</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">引入托梁</h1>
<blockquote>原文：<a href="https://itnext.io/introducing-joist-313f111a428?source=collection_archive---------2-----------------------#2020-08-06">https://itnext.io/introducing-joist-313f111a428?source=collection_archive---------2-----------------------#2020-08-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/5b91416bf06e485fcdb1143d2157ef2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*rJNZL3mO-lhMvNBiliW7Tw.png"/></div></figure><p id="35a7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我已经做到了。我做了一件每个人都告诉你作为开发者不要直接遵循“不要构建自己的cms(我也做过)”的事情。我自己搭建了框架，<a class="ae ks" href="https://github.com/joist-framework/joist" rel="noopener ugc nofollow" target="_blank">托梁</a>。</p><p id="0a80" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在过去的2年左右的时间里，我一直在思考我个人是如何喜欢编写应用程序和构建组件的，但我找不到任何东西能完全按照我想要的方式来做。所以我建了托梁，一个我想用的我不介意你也想用的框架:)。</p><p id="bbed" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我想要的一些东西:</p><ul class=""><li id="ef3c" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated">依赖注入</li><li id="421f" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">小的</li><li id="1668" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">固执己见的状态管理</li><li id="f664" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">与框架无关的组件(web组件)</li><li id="a4df" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">视图层不可知(你可以随时在无视图库、lit-html和lighterhtml之间切换。)</li></ul><p id="ebde" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我看来，托梁符合我的所有标准。它在某些方面固执己见，而在另一些方面却很灵活。在它自己的<strong class="jw ir">@托梁/组件</strong>和<strong class="jw ir">@托梁/di </strong>一起在<strong class="jw ir"> ~2kb </strong> gzipped和<strong class="jw ir">~ 5kb</strong>lit-html中称重。</p><h1 id="6fbf" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">入门指南</h1><p id="f471" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">开始使用托梁最简单的方法是转到<a class="ae ks" href="https://webcomponents.dev/new/" rel="noopener ugc nofollow" target="_blank"> webcomponents.dev </a>并使用托梁启动器。Webcomponents.dev是一个优秀的站点，它允许您使用各种库来构建和发布组件。(说真的，即使你不关心托梁，你也应该去看看。)</p><p id="bf33" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你想建立一个应用程序，你可以使用创建Snowpack应用程序(CSP)。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="dcf9" class="mt li iq mp b gy mu mv l mw mx">npx create-snowpack-app my-app --template @joist/starter-snowpack</span></pre><p id="55df" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这将为您设置一个开发服务器，通过<a class="ae ks" href="https://rollupjs.org/" rel="noopener ugc nofollow" target="_blank">汇总</a>进行生产构建，通过<a class="ae ks" href="https://github.com/modernweb-dev/web/tree/master/packages/test-runner" rel="noopener ugc nofollow" target="_blank"> web-test-runner </a>进行单元测试。</p><h1 id="349a" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">元素</h1><p id="072e" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">托梁与视图库无关，但内置了对lit-html的支持，我们将在所有示例中使用它。现在让我们看看托梁元素是什么样子的。</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="5b37" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">通过扩展JoistElement基本定制元素并添加一些组件元数据来定义一个托梁组件。元数据包括新元素的标签名、元素的默认状态和呈现功能。一个托梁渲染函数被传递一个名为RenderCtx的对象。</p><h1 id="b824" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">组件样式</h1><p id="31ed" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">当您使用阴影dom时，您可以使用组件“styles”属性应用样式。当可用时，托梁将利用<a class="ae ks" href="https://developers.google.com/web/updates/2019/02/constructable-stylesheets" rel="noopener ugc nofollow" target="_blank">可构造样式sheets </a>,但是允许渲染器退回到没有支持的浏览器。</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="2752" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">依赖注入</h1><p id="4cb8" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">托梁的核心是依赖注入器。依赖注入器本身完全独立于组件，并且在它自己的包中。每个托梁组件都有自己的注入器，这些注入器继承自单个全局注入器。这允许托梁组件构建它们自己的本地范围的服务以及共享全局单例。用“服务”装饰器装饰的服务将被视为单件。</p><p id="3bae" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">服务可以通过“注入”装饰器注入到其他服务的构造函数中。</p><p id="1999" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">定制元素可以用“get”装饰器注入服务。这将服务映射到实现InjectorBase接口的任何类上的属性。你甚至可以将它与其他web组件库一起使用，比如微软的FASTElement。</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="26b4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">带有get decorator的基于属性的DI是“懒惰的”，这意味着服务直到第一次被请求时才会被实例化。</p><h1 id="b3ff" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">状态</h1><p id="929f" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">托梁构件区分了图元属性和内部状态。更新内部状态将导致组件视图更新。这是为了使状态更新显式。状态的任何变化都会导致视图的变化。通过状态服务可以访问托梁的组件状态。您可以使用setValue和patchValue方法更新状态，并使用onChange观察状态变化。</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="d0e7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">组件状态是异步更新的，这意味着您可以向setValue和patchValue传递一个解析到新状态的承诺。</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="9175" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">性能</h1><p id="6b03" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">由于托梁元素是自定义元素，因此属性的行为与HTMLElement的行为相同。用“property”装饰器来装饰您的属性，这将导致每当属性被更新时，您的elements onPropChanges方法被用一个PropChangs列表调用。您可以使用该反馈来确定元素应该何时更新。</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="28c1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">属性也有一个用于运行时验证的挂钩。属性装饰器可以接受一个或多个验证函数，这些函数将在设置属性时运行。如果您正在分发组件，这尤其有用。验证器函数要么返回null(表示没有错误),要么返回错误消息。</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="2832" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">经理人</h1><p id="aba6" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">处理程序是托梁更独特的特性之一。处理程序是将“动作”映射到相应方法的方式。多个方法可以映射到一个操作。多个操作可以映射到一个方法。处理程序也可以基于正则表达式匹配操作。一般流程是<strong class="jw ir">事件- &gt;处理程序- &gt;状态改变</strong>。<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/how-to-handle-yourself-in-joist-fa4b52b2b085">查看这篇文章，更深入地了解处理程序。</a></p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="b5ce" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结束语</h1><p id="5b34" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">这是一个快速和肮脏的托梁概述。托梁是为固执己见而建造的，但也可以按菜单使用。我在这里没有提到的包是<a class="ae ks" href="https://github.com/joist-framework/joist/tree/master/packages/router" rel="noopener ugc nofollow" target="_blank">@托梁/路由器</a>，它是稳定的，但仍在开发中。托梁是一个我已经考虑了很久的项目，我想我对结果很满意！试试看，让我知道你的想法。</p></div></div>    
</body>
</html>