<html>
<head>
<title>Avoiding Stringly-typed in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免在Kotlin中输入字符串</h1>
<blockquote>原文：<a href="https://itnext.io/avoid-stringly-typed-in-kotlin-e802c4d0607c?source=collection_archive---------4-----------------------#2022-02-20">https://itnext.io/avoid-stringly-typed-in-kotlin-e802c4d0607c?source=collection_archive---------4-----------------------#2022-02-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8d65918a13d24a8a6270b5734d706188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qy616Vtfno4_3kLLtcjXlw.jpeg"/></div></div></figure><p id="3b89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">几年前，我在科特林开发了一个基于卡蒙达·BPMN的应用程序来帮助我管理我的会议提交工作流程。它在Trello中跟踪我的提交，并在谷歌日历和谷歌表单中同步它们。Google日历提供了一个REST API。随着REST APIs的发展，到处都充斥着<code class="fe kw kx ky kz b">String</code>。以下是代码的摘录:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="db4f" class="li lj iq kz b gy lk ll l lm ln">fun execute(color: String, availability: String) {<br/>    findCalendarEntry(client, google, execution.conference)?.let {<br/>        it.colorId = color                                      // 1<br/>        it.transparency = availability                          // 2<br/>        client.events()<br/>              .update(google.calendarId, it.id, it).execute()<br/>    }<br/>}</span></pre><ol class=""><li id="b848" class="lo lp iq ka b kb kc kf kg kj lq kn lr kr ls kv lt lu lv lw bi translated">设定事件的颜色。有效值为“0”、“1”、…到“11”</li><li id="914b" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated">设置事件的可用性。有效值为<code class="fe kw kx ky kz b">"transparent"</code>和<code class="fe kw kx ky kz b">"opaque"</code></li></ol><p id="62ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，我的经验告诉我应该支持强类型。我也想避免错别字。我想在这篇文章中列出一些使用<code class="fe kw kx ky kz b">String</code>的替代方法。</p><h1 id="ae8e" class="mc lj iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">常数</h1><p id="41e0" class="pw-post-body-paragraph jy jz iq ka b kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">书中最古老的技巧，在大多数语言中都可以使用，就是定义常量。在Java 5之前，开发人员经常使用这种替代方法<em class="ne"/>,因为这是唯一可用的方法。它看起来像这样:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="6a12" class="li lj iq kz b gy lk ll l lm ln">const val Default = "0"<br/>const val Blue = "1"<br/>const val Green = "2"<br/>const val Free = "transparent"<br/>const val Busy = "opaque"</span></pre><p id="fa42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以相应地调用该函数:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="668f" class="li lj iq kz b gy lk ll l lm ln">execute(Blue, Busy)</span></pre><p id="177b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">常量有助于纠正错别字。另一方面，它们不能强制执行强类型:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="f632" class="li lj iq kz b gy lk ll l lm ln">execute(Blue, Red)        // 1<br/>execute(Free, Red)        // 2</span></pre><ol class=""><li id="b1f2" class="lo lp iq ka b kb kc kf kg kj lq kn lr kr ls kv lt lu lv lw bi translated">传两个颜色，但是编译器没问题</li><li id="0a44" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated">颠倒论点；编译器还是好的</li></ol><h1 id="ad02" class="mc lj iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">键入别名</h1><p id="a755" class="pw-post-body-paragraph jy jz iq ka b kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">类型别名背后的想法是将现有类型的名称改为更有意义的名称。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="b62e" class="li lj iq kz b gy lk ll l lm ln">typealias Color = String<br/>typealias Availability = String</span></pre><p id="a212" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，我们可以改变函数的签名:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="be77" class="li lj iq kz b gy lk ll l lm ln">fun execute(color: Color, availability: Availability) {<br/>    // ...<br/>}</span></pre><p id="13e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是，类型别名只是装饰性的。不管别名是什么，一辆<code class="fe kw kx ky kz b">String</code>仍然是一辆<code class="fe kw kx ky kz b">String</code>。我们仍然可以编写不正确的代码:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="c80a" class="li lj iq kz b gy lk ll l lm ln">execute(Blue, Red)       // 1<br/>execute(Free, Red)       // 1</span></pre><ol class=""><li id="8ad6" class="lo lp iq ka b kb kc kf kg kj lq kn lr kr ls kv lt lu lv lw bi translated">什么都没有改善</li></ol><h1 id="4eb2" class="mc lj iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">列举</h1><p id="254a" class="pw-post-body-paragraph jy jz iq ka b kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">无论是在Java还是Kotlin中，枚举都是走向强类型的第一步。我相信大多数开发者都知道它们。让我们将代码改为使用枚举:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="09fb" class="li lj iq kz b gy lk ll l lm ln">enum class Color(val id: String) {<br/>    Default("0"),<br/>    Blue("1"),<br/>    Green("2"),<br/>}</span><span id="d6fd" class="li lj iq kz b gy nf ll l lm ln">enum class Availability(val value: String) {<br/>    Free("transparent"),<br/>    Busy("opaque"),<br/>}</span></pre><p id="6267" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要相应地改变函数，包括签名和实现:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="7a79" class="li lj iq kz b gy lk ll l lm ln">fun execute(color: Color, availability: Availability) {<br/>    findCalendarEntry(client, google, execution.conference)?.let {<br/>        it.colorId = color.id                                   // 1<br/>        it.transparency = availability.value                    // 1<br/>        client.events()<br/>            .update(google.calendarId, it.id, it).execute()<br/>    }<br/>}</span></pre><ol class=""><li id="9c75" class="lo lp iq ka b kb kc kf kg kj lq kn lr kr ls kv lt lu lv lw bi translated">提取由<code class="fe kw kx ky kz b">enum</code>包装的值</li></ol><p id="d9f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">枚举的使用强制了强类型:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="1dc4" class="li lj iq kz b gy lk ll l lm ln">execute(Color.Blue, Availability.Busy)          // 1<br/>execute(Color.Blue, Color.Red)                  // 2<br/>execute(Availability.Free, Color.Blue)          // 2</span></pre><ol class=""><li id="a97c" class="lo lp iq ka b kb kc kf kg kj lq kn lr kr ls kv lt lu lv lw bi translated">编制</li><li id="71c5" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated">不编译！</li></ol><h1 id="3cfa" class="mc lj iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">内嵌类</h1><p id="0c8e" class="pw-post-body-paragraph jy jz iq ka b kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">Kotlin最近的一个特性完全致力于强类型:内联类。内联类包装单个“原始”值，例如<code class="fe kw kx ky kz b">Int</code>或<code class="fe kw kx ky kz b">String</code>。想象一下下面的类:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="d4ac" class="li lj iq kz b gy lk ll l lm ln">data class Person(givenName: String, familyName: String)</span></pre><p id="ef42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个类的调用方必须记住第一个参数是名还是姓。Kotlin已经通过允许命名参数提供了帮助:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="137c" class="li lj iq kz b gy lk ll l lm ln">val p = Person(givenName = "John", familyName = "Doe")</span></pre><p id="7d48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，我们可以通过将<code class="fe kw kx ky kz b">String</code>包装在两个不同的值类型中来改进上面的代码片段，每个角色一个值类型。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="79ef" class="li lj iq kz b gy lk ll l lm ln">@JvmInline value class GivenName(value: String)<br/>@JvmInline value class FamilyName(value: String)</span><span id="0c51" class="li lj iq kz b gy nf ll l lm ln">val p = Person(GivenName("John"), FamilyName("Doe"))</span></pre><p id="9651" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一点上，一个人不能把一个名字换成一个姓，反之亦然。同样，我们可以在示例中使用值类，并在伴随对象中定义可能的值。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="9b47" class="li lj iq kz b gy lk ll l lm ln">@JvmInline<br/>value class Color(val id: String) {<br/>    companion object {<br/>        val Default = Color("0")<br/>        val Blue = Color("1")<br/>        val Green = Color("2")<br/>    }<br/>}</span><span id="1375" class="li lj iq kz b gy nf ll l lm ln">@JvmInline<br/>value class Availability(val value: String) {<br/>    companion object {<br/>        val Free = Availability("transparent")<br/>        val Busy = Availability("opaque")<br/>    }<br/>}</span><span id="a8aa" class="li lj iq kz b gy nf ll l lm ln">execute(Color.Blue, Availability.Busy)          // 1<br/>execute(Color.Blue, Color.Red)                  // 2<br/>execute(Availability.Free, Color.Blue)          // 2</span></pre><ol class=""><li id="fad5" class="lo lp iq ka b kb kc kf kg kj lq kn lr kr ls kv lt lu lv lw bi translated">编制</li><li id="e49e" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated">不编译！</li></ol><h1 id="662e" class="mc lj iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">密封类</h1><p id="4d84" class="pw-post-body-paragraph jy jz iq ka b kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">密封类是强制强类型的另一种可能方式。限制是我们需要在同一个包中定义一个密封类的所有子类。不能有任何第三方继承。实际上，它为您的代码创建了类<code class="fe kw kx ky kz b">open</code>，为客户端代码创建了类<code class="fe kw kx ky kz b">final</code>。</p><p id="e03b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们不像在值类中那样定义一个类型和它的几个实例，而是直接定义不同的类型。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="22dd" class="li lj iq kz b gy lk ll l lm ln">sealed class Color(val id: String) {<br/>    object Default: Color("0")<br/>    object Blue:    Color("1")<br/>    object Green:   Color("2")<br/>}</span><span id="b049" class="li lj iq kz b gy nf ll l lm ln">sealed class Availability(val value: String) {<br/>    object Free : Availability("transparent")<br/>    object Busy : Availability("opaque")<br/>}</span><span id="789b" class="li lj iq kz b gy nf ll l lm ln">execute(Color.Blue, Availability.Busy)          // 1<br/>execute(Color.Blue, Color.Red)                  // 2<br/>execute(Availability.Free, Color.Blue)          // 2</span></pre><ol class=""><li id="11d1" class="lo lp iq ka b kb kc kf kg kj lq kn lr kr ls kv lt lu lv lw bi translated">编制</li><li id="c003" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated">不编译！</li></ol><p id="b877" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，我在它们各自的父类中定义了对象。根据您的上下文，您可能希望将它们设置为顶级。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="4f12" class="li lj iq kz b gy lk ll l lm ln">sealed class Color(val id: String)<br/>object Default: Color("0")<br/>object Blue:    Color("1")<br/>object Green:   Color("2")</span><span id="8b51" class="li lj iq kz b gy nf ll l lm ln">sealed class Availability(val value: String)<br/>object Free : Availability("transparent")<br/>object Busy : Availability("opaque")</span><span id="c72a" class="li lj iq kz b gy nf ll l lm ln">execute(Blue, Busy)</span></pre><h1 id="833c" class="mc lj iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">结论</h1><p id="2ad2" class="pw-post-body-paragraph jy jz iq ka b kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">Kotlin提供了几个选项来加强API的强类型:枚举、值类和密封类。</p><p id="5928" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然大多数开发人员对枚举非常熟悉，但我建议考虑值和密封类，因为它们给表带来了额外的好处。</p><p id="9a3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更进一步:</strong></p><ul class=""><li id="a3a3" class="lo lp iq ka b kb kc kf kg kj lq kn lr kr ls kv ng lu lv lw bi translated"><a class="ae nh" href="https://kotlinlang.org/docs/enum-classes.html" rel="noopener ugc nofollow" target="_blank">枚举类</a></li><li id="831a" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv ng lu lv lw bi translated"><a class="ae nh" href="https://kotlinlang.org/docs/inline-classes.html" rel="noopener ugc nofollow" target="_blank">内嵌类</a></li><li id="eab9" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv ng lu lv lw bi translated"><a class="ae nh" href="https://kotlinlang.org/docs/sealed-classes.html" rel="noopener ugc nofollow" target="_blank">密封类</a></li></ul></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="012f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ne">最初发表于2022年2月20日</em> <a class="ae nh" href="https://blog.frankel.ch/avoid-stringly-typed-kotlin/" rel="noopener ugc nofollow" target="_blank"> <em class="ne">一个Java极客</em> </a> <em class="ne"/></p></div></div>    
</body>
</html>