<html>
<head>
<title>Don’t underestimate Recursion: it’s far more powerful, than most people think</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要低估递归:它比大多数人想象的要强大得多</h1>
<blockquote>原文：<a href="https://itnext.io/dont-underestimate-recursion-it-s-far-more-powerful-than-most-people-think-130a1077f3a6?source=collection_archive---------3-----------------------#2022-02-22">https://itnext.io/dont-underestimate-recursion-it-s-far-more-powerful-than-most-people-think-130a1077f3a6?source=collection_archive---------3-----------------------#2022-02-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/79d3cb6e62d6e1c295e7c95e790a56a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pGVGa8vJODJOyfpi-YcQug.png"/></div></div></figure><p id="a2c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你当然知道什么是递归。它的技术含义是<em class="kw">仅仅是</em> <strong class="ka ir">通过自身</strong>定义某物。</p><p id="4e9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以简单的定义它实际上可以<strong class="ka ir">完全改变</strong>你写命令式算法的方式。你是Java开发人员吗？C#？Python？F#？没关系，它适用于所有通用编程语言！</p><h1 id="e567" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">让我们来定义循环</h1><p id="f682" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在我的世界里，循环不是“做一件事n次”或“当一个条件为真时重复”。在我的世界里，loop的迭代实际上是一个函数，它改变了某个全局状态，loop是这类函数的链，从某个初始状态开始:</p><blockquote class="ma mb mc"><p id="c997" class="jy jz kw ka b kb kc kd ke kf kg kh ki md kk kl km me ko kp kq mf ks kt ku kv ij bi translated">循环是初始状态和转换(迭代)的有限链。</p></blockquote><p id="f1c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以这段伪代码为例:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/4923d76ddcf74e8ab1a32092f1ccb74b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-1KyvrtgzKz7PRSMjjpC-Q.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">常规循环添加元素</figcaption></figure><p id="ee7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它的全局状态是一个“和”与“我”的元组。它的跃迁是用arr[i]和i + 1求和，我来演示一下:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/53f54725bd0d0efe3feed12e615589c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ti-zbUFhK_Ks5U1Mg_Wj_Q.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">具有初始状态的链式转变再现相同的循环</figcaption></figure><p id="4957" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我“硬编码”了“func”的三个嵌套调用，但是我们应该怎么做才能让这个链自动化呢？</p><p id="0948" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以“教”函数实际调用它自己！</p><h1 id="383f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">从循环到递归</h1><p id="8ca1" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">让我们的函数调用它自己。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/6f31997ee94542c8f5274f2983f5d710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ZjeXXhhDrbk4-8OOVLc6w.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">递归定义的函数，对数组的所有元素求和</figcaption></figure><p id="b140" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能已经注意到了，这是一个无限递归，所以类似于for或while的条件，我们将把它作为一个延续条件:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/edb5aa09b2745d017444676e77cb6c74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xcs3q7WlsufXeN9HPMqeFA.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">将循环转化为递归</figcaption></figure><p id="8656" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们递归定义了循环！事实上，这是尾部递归，直接从循环/到循环的转换和递归(我稍后会解释)。</p><p id="2576" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能已经注意到这是一个<em class="kw">归纳</em>定义。我们有<em class="kw">基</em>是针对“I”等于或大于3，我们有跃迁，是“假设func定义为i + 1，那么I的func定义如下”。</p><p id="c82a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我是归纳的忠实爱好者，几周前我甚至用C#写了一篇关于归纳变量的文章。</p><p id="a8bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个定义的关键在于它的简单性。没有“动作”，没有移动的变量。它所做的只是返回一个或另一个东西。这纯粹是牛逼不是吗？</p><h1 id="b4cd" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">为什么我们需要递归？</h1><p id="ef40" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">因为<strong class="ka ir">更简单</strong>。更容易<strong class="ka ir">读</strong>，更容易<strong class="ka ir">写</strong>，最终变得更容易<strong class="ka ir">调试</strong>。</p><h2 id="a554" class="mt ky iq bd kz mu mv dn ld mw mx dp lh kj my mz ll kn na nb lp kr nc nd lt ne bi translated">更容易阅读</h2><p id="d81a" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">好吧…让我们举一个非常基本的例子。阶乘。以下是循环定义:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/b72b7d38fd939793cbe15e0306a85564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J17C-ydJSYn58cJvtb22xw.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">用循环定义的阶乘</figcaption></figure><p id="2c95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，你能告诉我阶乘(0)返回什么吗？阶乘(4)呢？它应该是24次，还是少了一次迭代(6次)或多了一次迭代(120次)？你需要知道如果1..n包容不包容，大概，然后仔细建模。</p><p id="bc3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，阶乘的“模型”定义是什么？</p><p id="d266" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/1b245aa9753fb314ede1fbb5fe115e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gnp1Ppv_VmYG7d-e5t-fhg.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">递归定义的阶乘</figcaption></figure><p id="e392" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你不需要考虑一个东西有多少次迭代。您只需要知道它对于基本情况(0和1)是正确的，并且它正确地从n转换到n-1。你确信它能正常工作。</p><h2 id="0d1f" class="mt ky iq bd kz mu mv dn ld mw mx dp lh kj my mz ll kn na nb lp kr nc nd lt ne bi translated">写作高手</h2><p id="6a3e" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这次我们来看看斐波那契数列。在数学中，它的定义如下:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/238b09f218d2fc41161afa6138142c38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3G-JFnmRq9fVNAyB5eMD9A.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">斐波那契数列的直接数学定义</figcaption></figure><p id="f832" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，我们都明白没有人会像这样写代码:这是非常低效的。</p><p id="0ef0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个必要的解决方案:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/9d20c9e4287e841a94f2b9d4fe48b0da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*qHK8pcLLqJLBQ6nW7R5WBA.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">用循环定义的斐波那契数</figcaption></figure><p id="4bc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，同样的问题。你能预测5的产量吗？你确定你应该返回a而不是b吗？应该有n次还是n-1次还是n+1次迭代？</p><p id="e224" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我们实际上可以用递归公式来解决同样的时间复杂度，这就是记忆化。在带有decorators(可以修改函数)的语言中，我们需要做的就是在上面添加一个:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/8cb5b82c4e682b6ecdf1e7c3ea2a624a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rdK4KlEx82XgEz1tr9cacg.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">斐波那契记忆</figcaption></figure><p id="a5cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">函数是纯的，即对相同的输入返回相同的答案，所以我们只需要缓存它，瞧，时间复杂度是线性的！</p><p id="4cb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(对于没有装饰器的语言，你可以检查输入是否在字典中，这并不难做到)</p><h2 id="15aa" class="mt ky iq bd kz mu mv dn ld mw mx dp lh kj my mz ll kn na nb lp kr nc nd lt ne bi translated">更容易调试</h2><p id="835c" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">看起来调试循环应该更容易，而不是一直跳下去，你只需要检查迭代。</p><p id="3d4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，调试递归定义的函数至少有两个好处:</p><ul class=""><li id="71c3" class="nk nl iq ka b kb kc kf kg kj nm kn nn kr no kv np nq nr ns bi translated">您可以随时检查/评估任何输入的函数值(但是您不能运行任意迭代次数的循环)</li><li id="384f" class="nk nl iq ka b kb nt kf nu kj nv kn nw kr nx kv np nq nr ns bi translated">您可以看到调用堆栈，并且可以看到每个堆栈<em class="kw">帧的变量值。</em></li></ul><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/dd2cd43afde6ae26f7f8efb7ee77ba70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8CUUb9sYIKihngSxVc368A.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">检查先前调用帧的变量。交互式运行函数</figcaption></figure><h1 id="df5c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">我们能用递归做什么？</h1><p id="7bbc" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我展示了人工例子，但实际上，你可以用递归做任何循环。例如，考虑这种遍历树的模式:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/8d4047393a69102bfbb2315a1c377c69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D4MzHDLUecmS4kmOZyqlPA.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">在带循环的二叉查找树中求值</figcaption></figure><p id="4f46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它的对等物:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/f9f6b45c90934db29e0f3efdb51f2d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yeinX6Liu_YG4o6IhLFbRQ.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">递归查找二叉查找树中的值</figcaption></figure><p id="6fbd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看起来不是干净多了吗？在复杂的算法中，读写这样的代码要容易得多，你通常甚至不会去调试它！</p><p id="a499" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于询问直到给出有效答案的已知问题呢？</p><p id="d3e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是命令式代码:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/25f80383a23828185fb8a21c599d366c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VNJDEioOYvxkv2keOdCZJw.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">强制性实施</figcaption></figure><p id="b9a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，我们如何声明“n”并预先为其设置null以进入循环，以及我们如何复制条件n==null以检查输入的数字是否正确！</p><p id="90ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们剔除那些丑陋的东西:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/a9fd1be8beb4e883104981ff78ace95a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pktRoODJUbTHSTFSkipbLA.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">递归实现</figcaption></figure><p id="96c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看到多简单了吧？这是对的直接翻译</p><ol class=""><li id="35d4" class="nk nl iq ka b kb kc kf kg kj nm kn nn kr no kv od nq nr ns bi translated">请求输入一个数字</li><li id="dfe1" class="nk nl iq ka b kb nt kf nu kj nv kn nw kr nx kv od nq nr ns bi translated">读号码</li><li id="7391" class="nk nl iq ka b kb nt kf nu kj nv kn nw kr nx kv od nq nr ns bi translated">如果为空，则报告错误并重试</li><li id="ff3e" class="nk nl iq ka b kb nt kf nu kj nv kn nw kr nx kv od nq nr ns bi translated">否则，退回去</li></ol><p id="c96b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，你能对之前的命令循环做同样的事情吗？这大概是这样的</p><ol class=""><li id="cc67" class="nk nl iq ka b kb kc kf kg kj nm kn nn kr no kv od nq nr ns bi translated">假设号码无效</li><li id="d879" class="nk nl iq ka b kb nt kf nu kj nv kn nw kr nx kv od nq nr ns bi translated">无效时，请求输入一个数字</li><li id="4d8b" class="nk nl iq ka b kb nt kf nu kj nv kn nw kr nx kv od nq nr ns bi translated">将读取值分配给数字</li><li id="5960" class="nk nl iq ka b kb nt kf nu kj nv kn nw kr nx kv od nq nr ns bi translated">如果为空，则报告错误</li><li id="08be" class="nk nl iq ka b kb nt kf nu kj nv kn nw kr nx kv od nq nr ns bi translated">从2开始</li><li id="fec8" class="nk nl iq ka b kb nt kf nu kj nv kn nw kr nx kv od nq nr ns bi translated">返回</li></ol><p id="1df8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">哦…</p><h1 id="3213" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">其他递归的东西呢？</h1><p id="109b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">不仅函数可以递归定义。我甚至可以说世界上的一切都可以被递归定义——但是让我先介绍几个实际的例子。我们可以或者应该递归定义的另一件事是类型。</p><h2 id="c760" class="mt ky iq bd kz mu mv dn ld mw mx dp lh kj my mz ll kn na nb lp kr nc nd lt ne bi translated">递归类型</h2><p id="2d29" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">一个简单的例子是二叉树节点。二叉树的一个节点通常有0、1或2个相同类型的子节点。这是一个相当简单的例子。</p><p id="ad32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在函数式或函数优先语言中，有一种类型叫做list(相当于我们在离散数学中所说的string)。基本上，这个想法是一个列表</p><ul class=""><li id="24b9" class="nk nl iq ka b kb kc kf kg kj nm kn nn kr no kv np nq nr ns bi translated">要么空着</li><li id="1438" class="nk nl iq ka b kb nt kf nu kj nv kn nw kr nx kv np nq nr ns bi translated">或者有第一个元素，其余的也是列表</li></ul><p id="f5af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个伪定义:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/44c753c21de86f6a2b74e9f13d946db8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*njeL-QkphDHVfPS9TZfTKQ.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">列表的归纳定义</figcaption></figure><p id="1b57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中T是一个泛型类型参数，因此您可以替换任何类型。</p><p id="7862" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样的列表允许我们避免遍历索引，并允许我们动态地构造列表，而不必预先创建集合并填充它。例如，这里有一个对整型列表元素求和的函数:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/671b66b378d799455676a92cb53b3a32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vMSG8foZY13SUd6mdEFlIg.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">遍历列表</figcaption></figure><p id="ad87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们所做的只是考虑了列表的两种可能状态:当它为空时(那么总和为0)，当有第一个元素和其余元素时(那么总和就是第一个元素加上其余元素的总和)。</p><p id="6878" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简单吧？但是多方便啊！</p><p id="089b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，假设您想要获取偶数索引的元素。你当然可以用I做一个循环，看看它是否是偶数，等等。等等，但是让我们考虑下面的方法:</p><ul class=""><li id="d592" class="nk nl iq ka b kb kc kf kg kj nm kn nn kr no kv np nq nr ns bi translated">如果它是空的，返回空的</li><li id="4e06" class="nk nl iq ka b kb nt kf nu kj nv kn nw kr nx kv np nq nr ns bi translated">如果它只有一个元素，则返回一个元素的列表</li><li id="27b1" class="nk nl iq ka b kb nt kf nu kj nv kn nw kr nx kv np nq nr ns bi translated">如果它有两个元素和其余元素，则取第一个元素加上此函数的结果作为其余元素</li></ul><p id="10f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想写就写:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/13b7b89ea9308b4c293368c51fdaf4fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rIA25FuuOetbHgmDTwSecQ.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">遍历列表</figcaption></figure><p id="9d3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种类型的链表叫做<em class="kw">单链表</em>。</p><h2 id="335a" class="mt ky iq bd kz mu mv dn ld mw mx dp lh kj my mz ll kn na nb lp kr nc nd lt ne bi translated">相互递归</h2><p id="b03f" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这是关于定义A到B，B是通过A定义的(尽管在这个循环中可以有任意数量的“实体”)。<a class="ae ms" href="https://blog.yaakov.online/red-green-trees/" rel="noopener ugc nofollow" target="_blank">红绿树</a>相互递归定义。一般来说，这种类型的递归不太常见。</p><h1 id="49a4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">语言支持</h1><p id="6b6d" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我展示了如何在大多数通用语言中优雅地使用递归来代替样板文件和可读性差得多的代码。</p><p id="02a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我们可以通过对语言语法、数据结构和编译器的特殊支持来超越它！</p><h2 id="0caa" class="mt ky iq bd kz mu mv dn ld mw mx dp lh kj my mz ll kn na nb lp kr nc nd lt ne bi translated">尾部递归优化</h2><p id="e6e0" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">或者TCO(尾部调用优化)是关于编译/降低你的尾部递归到实际的循环。它是由编译器优化的，这样你的递归定义的函数至少和循环一样有效！</p><p id="715f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再来说通话。如你所知，当你调用一个函数时，当前指令被保存，然后函数被调用，执行返回到调用后的指令。</p><p id="3ce6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当你想在它之后做某事时，它是需要的。例如，在factorial定义为<em class="kw"> n * factorial (n-1) </em>的情况下，在您调用了内部factorial之后，您希望将其乘以n，然后返回。</p><p id="68d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑这个伪代码:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/b668b8c44b454f16811a690aba6af23e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fD3udrToLmg_jfMoal7Iww.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">sumSquares的伪机器代码</figcaption></figure><p id="4658" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它将从0到n的整数的平方相加。所以这个想法是，当参数为0时，我们将0赋给返回值，并跳转到返回地址。否则，我们保存当前地址，调用它自己的n-1，加上n，然后跳转到返回地址。</p><p id="4f75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，如果你不想在函数调用后做任何事情，你可以直接<em class="kw">跳到</em>而不是调用。让我们添加来自“累加器”的参数“ACC”——它将累加总和。实现如下:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/3d3a25dc45a0d90739a7dec4193f3c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KDTYxQssCSzPllVm9gAs4g.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">带累加器的递归定义</figcaption></figure><p id="8839" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，它看起来与我们在开始时讨论的循环非常接近。把“n”换成“I”，把“acc”换成“sum”，就会得到一个循环，对吧？就是这个想法。让我们考虑一下它的伪代码:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/234e36335b851b0628071b960fc62fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pWSorVGH7aWHizcT1f-OFQ.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">用于直接翻译的机器代码</figcaption></figure><p id="5f02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">但是</em>事实上“call”已经把结果放进ret了。所以把调用的结果赋给ret是完全没有意义的。此外…如果我们只是从那里返回，为什么我们需要回到这一点？如果在调用“ret”之后包含了正确的值，那么我们所需要的就是通过跳转到函数本身来结束我们的函数！</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/b355764f21fbf17777824dd50ea3a98d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6HLFfEVjyEjVxMzir-ZEhA.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">用跳转替换尾调用</figcaption></figure><p id="6d45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们把它反编译成一种伪语言:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/f4925e5f7ad836bcc3be24384ce224dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_EJWJ2Gzbx8IqyVtmYgiVg.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">反编译的伪机器代码</figcaption></figure><p id="ab8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，这是一个while循环。只要读出来:如果n是零那么返回，否则做点什么跳到开头。下面是while循环的等价形式:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/0eb7eb6e14958426d23dc682c014bb72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lFivgahmXlLG4Nq3of1N_w.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">反编译成while循环</figcaption></figure><p id="4ecb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就这样，看到了吗？这里的关键思想是你写递归定义的函数，编译器为你把它们展开成一个循环！</p><p id="1f54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是，并不是所有的编译器都支持它，但它存在于Kotlin(带tailrec)、F#(和ML家族)、Scala等等。</p><h2 id="e771" class="mt ky iq bd kz mu mv dn ld mw mx dp lh kj my mz ll kn na nb lp kr nc nd lt ne bi translated">数据结构</h2><p id="cb68" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">虽然递归不必处理不可变的结构，但它可能需要动态地构造新的对象。在像F#这样的语言中</p><ul class=""><li id="67eb" class="nk nl iq ka b kb kc kf kg kj nm kn nn kr no kv np nq nr ns bi translated">单向链表(上面已经介绍过)</li><li id="c8af" class="nk nl iq ka b kb nt kf nu kj nv kn nw kr nx kv np nq nr ns bi translated">用红黑树制作的持久地图和集合</li><li id="51ae" class="nk nl iq ka b kb nt kf nu kj nv kn nw kr nx kv np nq nr ns bi translated">受歧视的工会</li></ul><p id="94cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有这些都鼓励在没有副作用的情况下创建递归函数，这减少了潜在的错误。</p><p id="344a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">老实说，DUs本身应该有一个单独的条款。事情越简单，它可能有越多的含义！</p><h2 id="6e54" class="mt ky iq bd kz mu mv dn ld mw mx dp lh kj my mz ll kn na nb lp kr nc nd lt ne bi translated">句法</h2><p id="3295" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">当有适当的语法支持时，编写递归定义的函数要容易得多:</p><ul class=""><li id="9dac" class="nk nl iq ka b kb kc kf kg kj nm kn nn kr no kv np nq nr ns bi translated">考虑不同情况— <em class="kw">模式匹配</em></li><li id="2b94" class="nk nl iq ka b kb nt kf nu kj nv kn nw kr nx kv np nq nr ns bi translated">构建和解构列表和元组</li></ul><p id="0414" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当一门语言提供了方便记忆你的函数的方法，例如，通过decorators，这也是很棒的。</p><p id="0410" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当一种语言提供了一种方法来确保一个函数是TCO优化的，这也是很棒的。例如，Kotlin <a class="ae ms" href="https://kotlinlang.org/docs/functions.html#tail-recursive-functions" rel="noopener ugc nofollow" target="_blank">提供了</a>“tailrec ”,如果无法进行优化，它会发出警告。</p><h1 id="a658" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">何时不使用递归</h1><p id="1d7a" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">递归仍然是一种工具。对于许多使用单一递归的操作(也就是说，从函数本身调用函数，并且调用次数不超过1次)，可以使用序列操作。它们在不同的语言中有不同的称呼，<a class="ae ms" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/" rel="noopener ugc nofollow" target="_blank"> C#的LINQ </a>，<a class="ae ms" href="https://kotlinlang.org/docs/collection-transformations.html" rel="noopener ugc nofollow" target="_blank">科特林的序列</a>等等。</p><p id="1bd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的关键是当递归比它的替代品更好的时候使用递归。然而，编写一个过滤偶数的显式函数可能应该替换为使用过滤序列函数。</p><p id="34b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一种情况是当编译器不支持TCO <em class="kw">或者</em>的时候你的函数不受TCO <em class="kw">而是</em>嵌套调用的数量是几千或者几十万。那么它可能会消耗你的大量筹码，甚至耗尽你的筹码。但是实际上，一个函数遍历这么大的序列并不常见。</p><h1 id="888b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="a817" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">递归真的让我很开心。我相信它足够简单，每个人都能理解它和它的优点。</p><p id="e6e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢关注，原来比我想象的要稍微长一点:)。</p><p id="70d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的<a class="ae ms" href="https://github.com/WhiteBlackGoose" rel="noopener ugc nofollow" target="_blank"> github/WhiteBlackGoose </a>，<a class="ae ms" href="https://twitter.com/WhiteBlackGoose" rel="noopener ugc nofollow" target="_blank">Twitter/white black goose</a>。</p></div></div>    
</body>
</html>