<html>
<head>
<title>Building An End-to-end Application with LoopBack &amp; React.js — Part 2: Creating Service Proxy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用LoopBack &amp; React.js构建端到端应用程序—第2部分:创建服务代理</h1>
<blockquote>原文：<a href="https://itnext.io/building-an-end-to-end-application-with-loopback-react-js-part-2-creating-service-proxy-7ffac2bd7980?source=collection_archive---------3-----------------------#2021-06-22">https://itnext.io/building-an-end-to-end-application-with-loopback-react-js-part-2-creating-service-proxy-7ffac2bd7980?source=collection_archive---------3-----------------------#2021-06-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e311cb91e9443b3ad05fafb1bd884f58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8jMFzunn7XGSehe9FHYBKw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@othentikisra?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">以色列宫</a>在<a class="ae kc" href="https://unsplash.com/s/photos/connection?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="91e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的<a class="ae kc" href="https://mobilediana.medium.com/building-an-end-to-end-application-with-loopback-react-js-7a22d726c35d" rel="noopener">前一篇博客</a>中，我介绍了应用程序可以做什么，并且创建了连接到GitHub REST API的数据源。在本文中，我将创建LoopBack应用程序的其余部分的框架:</p><ul class=""><li id="9f5d" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">创建调用我们在数据源中定义的函数的服务代理</li><li id="d0b9" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">通过创建一个控制器来公开回送应用程序的REST APIs</li></ul><p id="c57d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回到我们的图表，它显示了我们在第1部分已经做了什么，以及我们将在第2部分做什么。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lp"><img src="../Images/d751e0805f8bf1c11ee7e6764e9aa225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ZviwYJZrGo9FxHNW969hQ.png"/></div></div></figure><p id="ebc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想看看完成的LoopBack应用程序是什么样子，你可以点击<a class="ae kc" href="https://github.com/dhmlau/loopback4-example-github" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="7da8" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">服务代理</h1><p id="3205" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated"><a class="ae kc" href="https://loopback.io/doc/en/lb4/Service.html" rel="noopener ugc nofollow" target="_blank">服务</a>是一个环回的概念，指的是一个具有执行本地或远程操作的方法的对象。</p><p id="9820" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要创建服务代理，运行<code class="fe ne nf ng nh b">lb4 service</code>命令:</p><pre class="lq lr ls lt gt ni nh nj nk aw nl bi"><span id="8c74" class="nm mc iq nh b gy nn no l np nq">$ lb4 service<br/>? Service type: Remote service proxy backed by a data source<br/>? Please select the datasource GithubdsDatasource<br/>? Service name: GHQueryService<br/>   create src/services/gh-query-service.service.ts<br/>   update src/services/index.ts</span><span id="4f74" class="nm mc iq nh b gy nr no l np nq">Service GhQueryService was/were created in src/services</span></pre><p id="e3c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步，我们将把GitHubDataSource中定义的函数映射到新创建的<code class="fe ne nf ng nh b">GhQueryService</code>中的方法。</p><p id="ca1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe ne nf ng nh b">services/gh-query-service.service.ts</code>中，更新<code class="fe ne nf ng nh b">GhQueryService</code>界面，增加3个界面。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="de55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，服务代理完成了！让我们转向控制器。</p><h1 id="5012" class="mb mc iq bd md me nu mg mh mi nv mk ml mm nw mo mp mq nx ms mt mu ny mw mx my bi translated">控制器</h1><p id="5971" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">C <a class="ae kc" href="https://loopback.io/doc/en/lb4/Controller.html" rel="noopener ugc nofollow" target="_blank"> ontroller </a>是另一个公开REST APIs的环回概念。你可以使用<code class="fe ne nf ng nh b">lb4 controller</code>命令来创建控制器。您将被询问是否想要创建一个空的控制器或带有CRUD功能的REST控制器。如果您创建控制器来连接到一个存储库，那么选择CRUD选项来节省您的一些输入可能是好的。然而，在我们的例子中，我们只需要一个空的控制器。</p><pre class="lq lr ls lt gt ni nh nj nk aw nl bi"><span id="89a7" class="nm mc iq nh b gy nn no l np nq">$ lb4 controller<br/>? Controller class name: GHQuery<br/>Controller GhQuery will be created in src/controllers/gh-query.controller.ts</span><span id="0755" class="nm mc iq nh b gy nr no l np nq">? What kind of controller would you like to generate? Empty Controller<br/>   create src/controllers/gh-query.controller.ts<br/>   update src/controllers/index.ts</span><span id="96db" class="nm mc iq nh b gy nr no l np nq">Controller GhQuery was/were created in src/controllers</span></pre><p id="e2ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nz">注意:环回控制器CLI将字符串“Controller”附加到您在提示中指定的控制器类名上。</em></p><p id="d7c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在该控制器中，我们将:</p><ul class=""><li id="84c9" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">注入我们刚刚创建的GhQueryService服务代理</li><li id="2bde" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">添加一个暴露为<code class="fe ne nf ng nh b">/issues/repo/{repo}/label/{label}</code>的函数。</li></ul><p id="42be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">装饰器意味着它是一个GET方法。有关更多细节，请参见<a class="ae kc" href="https://loopback.io/doc/en/lb4/Decorators_openapi.html" rel="noopener ugc nofollow" target="_blank"> OpenAPI装饰器</a>文档。另一个技巧是查看<a class="ae kc" href="https://loopback.io/doc/en/lb4/todo-tutorial.html" rel="noopener ugc nofollow" target="_blank"> ToDo教程</a>中的<a class="ae kc" href="https://github.com/strongloop/loopback-next/blob/master/examples/todo/src/controllers/todo.controller.ts" rel="noopener ugc nofollow" target="_blank"> TodoController </a>。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h1 id="44fb" class="mb mc iq bd md me nu mg mh mi nv mk ml mm nw mo mp mq nx ms mt mu ny mw mx my bi translated">正在创建个人访问令牌</h1><p id="8b54" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">还记得当我们创建数据源时，我们指定使用环境变量<code class="fe ne nf ng nh b">TOKEN</code>作为<code class="fe ne nf ng nh b">Authorization</code>头吗？如果您还没有这个令牌，我们现在需要生成它。这将是我们测试它之前的最后一步。</p><p id="011c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了生成个人访问令牌，</p><ul class=""><li id="cd44" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">登录GitHub后，进入设置&gt;开发者设置或简单的<a class="ae kc" href="https://github.com/settings/apps" rel="noopener ugc nofollow" target="_blank">https://github.com/settings/apps</a></li><li id="dd50" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">点击左侧的<strong class="kf ir">个人访问令牌</strong></li><li id="0b61" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">点击<strong class="kf ir">生成新令牌</strong>。</li><li id="075f" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">选中“回购”和“用户”复选框。这对于本申请的目的来说已经足够了</li><li id="55fa" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">生成后，请确保将其存储在安全的地方，因为您将无法再次看到令牌值。如果丢失了，需要撤销。</li></ul><p id="1739" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在用于启动应用程序的终端中，设置<code class="fe ne nf ng nh b">TOKEN</code>环境变量。运行下面的命令:</p><pre class="lq lr ls lt gt ni nh nj nk aw nl bi"><span id="07e7" class="nm mc iq nh b gy nn no l np nq">export TOKEN='token &lt;your_personal_access_token&gt;'</span></pre><h1 id="6258" class="mb mc iq bd md me nu mg mh mi nv mk ml mm nw mo mp mq nx ms mt mu ny mw mx my bi translated">测试它</h1><p id="1254" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">我们准备好出发了！在同一终端中，启动应用程序:</p><pre class="lq lr ls lt gt ni nh nj nk aw nl bi"><span id="aa5f" class="nm mc iq nh b gy nn no l np nq">npm start</span></pre><p id="1109" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看到<code class="fe ne nf ng nh b">Server is running at <a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/[::1]:3000S">http://[::1]:3000</a></code>后，去<a class="ae kc" href="http://localhost:3000/explorer." rel="noopener ugc nofollow" target="_blank">http://localhost:3000/explorer。</a></p><p id="1264" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以放入任何你想测试的东西。对我来说，我有这个:</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/c1776de942ad8f16271d3a9e4a87f5e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*olVjpstVv9WU-fSIqbko0A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">运行/issues/repo/{ repo }/label/{ label }端点</figcaption></figure><p id="2bad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您应该会看到类似下面的响应:</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/a7ced78db32377854c810a13c88d57ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u9H7uo-pvVw10KiUoUo2pg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">样本结果</figcaption></figure><h1 id="fb69" class="mb mc iq bd md me nu mg mh mi nv mk ml mm nw mo mp mq nx ms mt mu ny mw mx my bi translated">下一步是什么？</h1><p id="62c1" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">你可能意识到少了些什么。返回的项目数总是小于30，即使<code class="fe ne nf ng nh b">total_count</code>表示更大的数量。这是因为默认情况下GitHub APIs一次只返回30个项目。我们可以将每个页面增加到最多100个结果，但是之后，我们仍然需要遍历页面来获得所有结果。我将在下一篇文章中展示如何做到这一点。敬请期待！</p></div></div>    
</body>
</html>