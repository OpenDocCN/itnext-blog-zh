<html>
<head>
<title>Transducers Speed Up JavaScript Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">转换器加速JavaScript数组</h1>
<blockquote>原文：<a href="https://itnext.io/using-transducers-to-speed-up-javascript-arrays-92677d000096?source=collection_archive---------1-----------------------#2019-01-13">https://itnext.io/using-transducers-to-speed-up-javascript-arrays-92677d000096?source=collection_archive---------1-----------------------#2019-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/95b6856b235e66a8285efc34c765d4dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rcNWkN-4EbHwEHGF"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">图片由<a class="ae jd" href="https://unsplash.com/@simson_petrol?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">森石油</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><div class=""/><div class=""><h2 id="e728" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">处理大型JavaScript数组真的很慢</h2></div><p id="893b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我将介绍使用转换器提高大型JavaScript数组处理速度的方法。本文建立在我上一篇文章的发现之上: <a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/speed-up-javascript-array-processing-8d601c57bb0d">加速JavaScript数组处理</a> <em class="lr">。</em></p><p id="3db4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"><em class="lr">TL；dr </em> </strong> <em class="lr"> JavaScript数组处理很慢，但是有了传感器，你可以解决很多这样的问题。尽管如此，你还是要首先考虑你的原生选择。</em></p><p id="cc80" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我从未想过我会需要它，但我实际上需要使用我的解决方案<a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/speed-up-javascript-array-processing-8d601c57bb0d"> <em class="lr">加速JavaScript数组处理</em> </a>来加速加载我最近正在编写的一个Chrome插件。</p><p id="7306" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个插件在一个列表中加载了超过26，800个条目，并对它们进行了一些处理。令人惊讶的是，即使有几个<code class="fe ls lt lu lv b">filter</code>和<code class="fe ls lt lu lv b">map</code>函数，它还是非常快。直到我开始做一些高级处理，需要将数组的大小复制到53，700多项。这时，我注意到速度下降了许多个数量级。</p><p id="dbaa" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> <em class="lr">免责声明:</em> </strong> <em class="lr">所有代码示例都是杜撰的，但我把它们做得和实际实现差不多。这些例子的处理时间比我的实际实现要快得多，但是在较慢的机器上，您会看到更慢的速度。</em></p><h1 id="a5a1" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">一切都很好</h1><p id="574e" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">在进行任何更改之前，让我们看一下原始代码:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7f66" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这可能可以通过使用传感器来改善，但我认为没有必要，因为处理时间平均为8.5毫秒</p><p id="667b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尽管如此，让我们看看传感器版本:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0b0e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据我以前的文章，您会认为这样会更快，但事实并非如此。时钟为22.1毫秒，列表中没有足够的项目使传感器成为比本地<code class="fe ls lt lu lv b">Array</code>方法更快的替代方法，也没有足够的数据转换。这很简单，所以除非我们增加更多的条目或操作符，否则不会提高速度。</p><h1 id="bc21" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">经济放缓</h1><p id="510b" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">这个插件的加载几乎是即时的，但是突然之间，这个小小的改变让它花费了35秒，除了处理一个JavaScript数组之外，什么也没做。怎么会？我做了什么？</p><p id="f3f1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">基于我处理需求时的一个错误以及Chrome如何处理这个字符串数组，我需要在列表中添加两倍的项目。</p><p id="d9b5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是变化的样子:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f70d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> <em class="lr">免责声明:</em> </strong> <em class="lr">虽然在这个伪代码例子中断章取义没有意义，但是项目的需求需要第二个</em> <code class="fe ls lt lu lv b"><em class="lr">concat</em></code> <em class="lr">版本。</em></p><p id="45e1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我将每个基准测试运行6次。平均12300毫秒，这是迄今为止最无聊的基准测试。谈慢！</p><p id="fb90" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，让我们来看看解决这个问题的一些方法。我知道<code class="fe ls lt lu lv b">concat</code>函数每次运行时都会创建一个新数组。这肯定会成为问题的一部分，所以我利用了<code class="fe ls lt lu lv b">concat</code>需要两个参数的事实:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6f38" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个减少<code class="fe ls lt lu lv b">concat</code>语句数量的微妙变化让我们减少了一半:6600毫秒。您可能已经猜到了这个数字，因为将创建的数组数量减少一半会将总处理时间减少一半。</p><p id="db71" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们实际上可以进一步降低！我们可以简单地给它一个数组，而不是让<code class="fe ls lt lu lv b">concat</code>检查我们传递的每个参数。如果您不知道，<code class="fe ls lt lu lv b">concat</code>实际上会展平它给出的任何数组:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0d9b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过这一简单的更改，我们现在的时间减少到了可以忍受的2600毫秒。为什么？我只能猜测这是因为我们提前创建了一个数组，而<code class="fe ls lt lu lv b">concat</code>不需要自己处理<code class="fe ls lt lu lv b">arguments</code>。这是一种使用参数分布的老方法，只在老的<code class="fe ls lt lu lv b">function</code>定义中有效，在粗箭头函数中无效。</p><p id="652e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您有兴趣，可以在这篇MDN文章中找到更多信息:</p><div class="ip iq gp gr ir mz"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd jh gy z fp ne fr fs nf fu fw jf bi translated">参数对象</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">arguments是一个类似数组的对象，可以在函数内部访问，它包含传递给…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">developer.mozilla.org</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn ix mz"/></div></div></a></div><h1 id="456c" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">加速</h1><p id="3852" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">正如您所看到的，虽然这段代码看起来很现代，很实用，但是由于reducer的使用方式，它仍然很糟糕。RxJS传感器来救援！</p><h2 id="1423" class="no lx jg bd ly np nq dn mc nr ns dp mg le nt nu mi li nv nw mk lm nx ny mm nz bi translated">为什么要用RxJS？</h2><p id="6c55" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">和上一篇文章一样，我们将再次使用RxJS。您可能知道，我熟悉RxJS，并且已经围绕<code class="fe ls lt lu lv b">subscribe</code>编写了方法，所以我可以像JavaScripts的<code class="fe ls lt lu lv b">Array</code>方法一样同步使用它。</p><p id="78f6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然我可以为这个项目使用现成的转换器库，但它是一个大量使用RxJS的Chrome插件。引入另一个库增加了项目的复杂性，因为我已经签约做这项工作，我想减少另一个人必须学习维护项目的工具数量。引入RxJS本来就不确定，但是由于这个特定插件的异步特性，它已经降低了很多复杂性。</p><h2 id="d893" class="no lx jg bd ly np nq dn mc nr ns dp mg le nt nu mi li nv nw mk lm nx ny mm nz bi translated">我们去了格子呢！</h2><p id="d8dd" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">回到我们的传感器版本，让我们再试一次:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9194" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2300ms？真的吗？考虑到我们在上一篇文章中的数字，这不是我所期望的速度提升。</p><p id="4738" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是这个测试失败的地方。换能器是一种完全不同的思考数组处理的方式。在引擎盖下，传感器是一个<code class="fe ls lt lu lv b">reduce</code>循环中的一组包装函数。这意味着，拥有2个<code class="fe ls lt lu lv b">reduce</code>函数可能会使速度变慢很多；其实大O(n)。</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5900" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">利用<code class="fe ls lt lu lv b">mergeMap</code>，我们最终得到了一个更合理的70.6毫秒。我们已经完全摆脱了阵列式的<code class="fe ls lt lu lv b">reduce</code>，改用更快的<code class="fe ls lt lu lv b">mergeMap</code>换能器。现在，我们处理所有的值，只在最后把它们放入一个数组。这是加速的关键。我们都减少了创建数组的次数(减少到一次),并尽可能地延迟它(直到最后)。</p><p id="6474" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是你所期待的，对吗？但愿不会！我认为我们还可以进一步降低。我们必须能够让它更接近我们最初的8.5毫秒；否则，我认为这是一个失败。</p><p id="a990" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，由于最初的传感器测试是22.1毫秒，那么我们只能合理地假设这是我们能做的最好的。因为我们要复制数组大小，所以40毫秒是我们的目标。我们还有很长的路要走。</p><p id="ab67" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">复制我们的数组逻辑和几个<code class="fe ls lt lu lv b">mergeMap</code>操作符，这是我想到的:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0931" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我想，因为我们只创建了一个数组，这将是非常快，但事实并非如此。平均51.5毫秒，显然没有达到我们的数字。</p><p id="7e9e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另外，注意我是如何复制<code class="fe ls lt lu lv b">filter</code>逻辑的？那是暂时的。在实际情况下，可以将这些操作符组合起来，创建一个新的操作符，在两种情况下都可以使用。这样你就不会有将来的维护问题。正如你所知道的，我确实在处理两个列表之前尝试过处理过滤器逻辑，但是结果比较慢，因为我必须创建一个中间数组。</p><p id="6298" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我带你去看我在那个插件中使用的解决方案——真正的解决方案。这很复杂也很难看，但是在插件中，我实际上能够回到原来的处理速度，这实际上比只做一个<code class="fe ls lt lu lv b">map</code>要快。</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1b21" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这与之前的版本非常相似，除了我们使用了<code class="fe ls lt lu lv b">forkJoin</code>而不是<code class="fe ls lt lu lv b">mergeMap</code>。不同之处在于它返回两个结果的数组。我们实际上是在创建两个较小的数组，然后将它们合并成一个较大的数组，但是在前面的例子中，我们是从一堆已处理的项目中创建一个大数组。</p><p id="849c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这一点上，我不能告诉你为什么这个版本更快，因为这超出了我对RxJS的了解。我本以为之前的版本会更快，但显然不是。</p><p id="6c4f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尽管如此，我们还是获得了41.2毫秒，与我们的估计相符。但在我看来还不够好。我想我们可以把这个时间缩短到至少17毫秒。</p><h1 id="0b1f" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">突然意识到</h1><p id="b4e2" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">这种双重处理的方法让我想到，为什么不在<code class="fe ls lt lu lv b">map</code>身上做同样的事情呢？事实上，它可能读起来更快更容易！</p><p id="7c6e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看起来是这样的:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="3a43" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">是的，它在我们估计的19.8毫秒的范围内。这是我一直在寻找的解决方案，但我决定走一条不同的路线，因为我没有意识到它可以有多简单。说真的，如果你看到一件事花了12秒以上，你的第一反应会是什么？</p><h1 id="0911" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">结论</h1><p id="ff00" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">正如您所看到的，即使在我们优化的<code class="fe ls lt lu lv b">reduce</code>示例中，转换器也可以带来一些主要的速度优势，但是除非您有大量的项目或大量的管道操作符，否则它们在JavaScript的本地<code class="fe ls lt lu lv b">Array</code>方法上所能实现的将会受到限制。</p><p id="f241" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但这并不是说所有的传感器库都是这样的。我使用的是RxJS，它被设计用来处理随时间变化的值。它并没有像这样针对数组处理进行优化，只是与我以前的文章联系在一起，这些文章也以有趣的方式使用RxJS。如果我使用真正的传感器库，我想知道这段代码会快多少。</p><p id="a1b1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">老实说，我对这篇文章的结果感到惊讶。不管出于什么原因，Chrome插件的处理速度慢了很多，所以transducer版本实际上对处理速度有很大的影响，但不管出于什么原因，Node.js v10已经进行了一些优化，这大大加快了原生<code class="fe ls lt lu lv b">Array</code>方法的速度。或者，他们减缓了传感器的方法😡。我永远不会知道！好消息是，传感器版本最终只慢了大约10-20毫秒。我敢打赌，改变这些结果不需要太多的东西。</p><h2 id="22bc" class="no lx jg bd ly np nq dn mc nr ns dp mg le nt nu mi li nv nw mk lm nx ny mm nz bi translated">转折点</h2><p id="f3a8" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">好吧，我很好奇，又做了一些基准测试。当将最快的阵列和换能器方法与500，000个项目的列表进行比较时。传感器方法快了100毫秒。终于！一些符合我期望的东西。</p><p id="dac7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了这个特定的数据集，我能够找到临界点:大约250，000个项目。除此之外，差距还会大幅扩大。现在我很好奇处理器速度和可用内存如何影响这些基准测试。它会支持传感器还是原生阵列方法？</p><h1 id="ea0a" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">更多阅读</h1><p id="7947" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">如果你对更多与RxJS相关的话题感兴趣，你应该看看我的其他文章:</p><ul class=""><li id="dccd" class="oa ob jg kx b ky kz lb lc le oc li od lm oe lq of og oh oi bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/speed-up-javascript-array-processing-8d601c57bb0d">加速JavaScript数组处理</a></li><li id="1e28" class="oa ob jg kx b ky oj lb ok le ol li om lm on lq of og oh oi bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/an-emoji-lovers-guide-to-functional-programming-part-4-735c17ca4113">现在是管道操作员！</a></li><li id="1105" class="oa ob jg kx b ky oj lb ok le ol li om lm on lq of og oh oi bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/handling-cache-and-ajax-race-conditions-4cb152db8764">处理缓存和AJAX竞争条件</a></li><li id="5076" class="oa ob jg kx b ky oj lb ok le ol li om lm on lq of og oh oi bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/lossless-backpressure-in-rxjs-b6de30a1b6d4">RxJS中的无损背压</a></li><li id="8598" class="oa ob jg kx b ky oj lb ok le ol li om lm on lq of og oh oi bi translated"><a class="ae jd" href="https://medium.com/@Sawtaytoes/redux-observable-can-solve-your-state-problems-15b23a9649d7" rel="noopener"> Redux-Observable可以解决你的状态问题</a></li></ul></div></div>    
</body>
</html>