<html>
<head>
<title>Either Monad — A functional approach to Error handling in JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Monad——JS中错误处理的函数方法</h1>
<blockquote>原文：<a href="https://itnext.io/either-monad-a-functional-approach-to-error-handling-in-js-ffdc2917ab2?source=collection_archive---------0-----------------------#2019-09-15">https://itnext.io/either-monad-a-functional-approach-to-error-handling-in-js-ffdc2917ab2?source=collection_archive---------0-----------------------#2019-09-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/534f1e4c2d520b40a0397d56808a3c48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OGq0se7SeX87svx3SEaP1w.png"/></div></div></figure><div class=""/><p id="837c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在错误处理中，我们有两条可能的路径，要么计算成功，要么失败。控制流的必要方法是使用异常和try/catch块。在函数式编程中，他们认识到这两个<strong class="ka jc">路径ok或error可以连接成一个结构</strong> <strong class="ka jc">，表示一个或另一个</strong>是可能的，因此我们可以将它们统一成一个<strong class="ka jc">要么&lt; ok，要么&gt; </strong>结构。</p><p id="6a55" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">要么</strong>是函数式语言中常见的类型。通常被称为受歧视工会。这意味着任一类型都可以包含它所总结的任何类型。</p><p id="1ee2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了找出我们<a class="ae kw" href="https://en.wikipedia.org/wiki/Pattern_matching" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc">模式匹配</strong> </a> <strong class="ka jc">里面的东西。</strong>通常在大多数函数库中，会有一个名为<strong class="ka jc"> cata </strong>(也称为match或matchWith) <strong class="ka jc"> </strong>的方法，它的功能完全不同于:</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="85d6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好，让我们来看一下如何在错误处理中使用它。在任一仿函数实现中，重要的是<strong class="ka jc">在映射时，左边的</strong>会忽略映射。</p><pre class="kx ky kz la gt ld le lf lg aw lh bi"><span id="bd4c" class="li lj jb le b gy lk ll l lm ln">const right = (v) =&gt; ({ <br/>    map: (f) =&gt; right(<strong class="le jc">f(v)</strong>),    <br/>  });<br/>  <br/>const left = (v) =&gt; ({ <br/>    map: (_) =&gt; left(<strong class="le jc">v</strong>),  <br/>  });</span></pre><p id="4fcf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着，当我们返回一个左，然后没有更多的计算与地图执行。</p><h1 id="97f7" class="lo lj jb bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">重构尝试/捕捉到</h1><p id="6680" class="pw-post-body-paragraph jy jz jb ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">假设我们有这个try catch块</p><pre class="kx ky kz la gt ld le lf lg aw lh bi"><span id="6c43" class="li lj jb le b gy lk ll l lm ln">var finalPrice;<br/>   try {<br/><strong class="le jc">      var discount = 0.1;<br/>      finalPrice = 10 - discount * 10;</strong><br/>   } catch (e) {<br/> <strong class="le jc">     console.log(e);</strong><br/>   }</span><span id="ac33" class="li lj jb le b gy mq ll l lm ln">if (finalPrice) {<br/>      console.log(finalPrice);<br/>   }</span></pre><p id="3e62" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们希望从实际计算中删除try/catch。</p><pre class="kx ky kz la gt ld le lf lg aw lh bi"><span id="f0ff" class="li lj jb le b gy lk ll l lm ln">try {<br/>      <strong class="le jc">var computation = () =&gt; {<br/>         var discount = 0.1;<br/>         var finalPrice = 10 - discount * 10;<br/>         return finalPrice;<br/>      }</strong><br/>   } catch (e) {<br/>      <strong class="le jc">console.log(e);</strong><br/>   }</span></pre><p id="8970" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们提取一个方法，并将计算结果作为参数传递</p><pre class="kx ky kz la gt ld le lf lg aw lh bi"><span id="069a" class="li lj jb le b gy lk ll l lm ln">var Try = (<strong class="le jc">f</strong>) =&gt; {<br/>      try {<br/>         return <strong class="le jc">f</strong>();<br/>      } catch (e) {<br/><strong class="le jc">         console.log(e);</strong><br/>      }<br/>   }</span><span id="9325" class="li lj jb le b gy mq ll l lm ln">var finalPrice = Try(<strong class="le jc">() =&gt; {<br/>      var discount = 0.1;<br/>      var finalPrice = 10 - discount * 10;<br/>      return finalPrice;<br/>   }</strong>);</span></pre><p id="3b76" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后我们返回一个这样的要么</p><pre class="kx ky kz la gt ld le lf lg aw lh bi"><span id="1d46" class="li lj jb le b gy lk ll l lm ln">var Try = (f) =&gt; {<br/>      try { <strong class="le jc"><br/>         return right(f());</strong><br/>      } catch (e) {<br/>       <strong class="le jc">  return left(e);</strong><br/>      }<br/>   }</span><span id="5809" class="li lj jb le b gy mq ll l lm ln">Try(() =&gt; t / 2).<strong class="le jc">matchWith</strong>({<br/>      right: v =&gt; console.log(v),<br/>      left: v =&gt; console.log("error : " + v)<br/>   })</span></pre><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="lb lc l"/></div></figure></div></div>    
</body>
</html>