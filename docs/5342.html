<html>
<head>
<title>Dagger Tips: Guide to using Dagger-Android effectively</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">匕首技巧:有效使用匕首机器人指南</h1>
<blockquote>原文：<a href="https://itnext.io/dagger-tips-guide-to-using-dagger-android-effectively-c3e5b2883b38?source=collection_archive---------3-----------------------#2021-02-13">https://itnext.io/dagger-tips-guide-to-using-dagger-android-effectively-c3e5b2883b38?source=collection_archive---------3-----------------------#2021-02-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/136fbd2591610bacc40d6ba4a84967a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yli9Y_6wUjkuCoPMrHc-Lw.png"/></div></div></figure><p id="dd0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">人们在阅读这个标题时可能会问我:“等等，Dagger-Android不是已经停止开发了吗？不就是随着剑柄的引入变得过时了吗？”</p><p id="121c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">技术上来说，是的。匕首机器人<em class="kw">被剑柄</em>取代。因此，如果你已经在使用Hilt，那么对于最常见的情况(注入活动、片段、视图模型、工人)，你根本不需要考虑Dagger-Android。</p><p id="248d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，由于我仍然看到<code class="fe kx ky kz la b">@ContributesAndroidInjector</code>不时出现，我觉得最好是写一篇文章，介绍它是如何工作的，它打算解决什么，如何使用它，以及如何不使用它(为了更好的可伸缩性)。</p><h1 id="9c1e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">匕首机器人是什么？</h1><p id="d42f" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">Dagger-Android是一种现场注入类(从Dagger 2.20+开始不一定只是Android类)的方法，而不必在组件上定义<code class="fe kx ky kz la b">fun inject(target: MyConcreteClassTarget)</code>注入器方法——因为我们不知道类本身。</p><p id="30c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">什么时候希望避免在组件中创建<code class="fe kx ky kz la b">fun inject(t: T)</code>？毕竟，这通常允许字段注入是类型安全的。</p><p id="db60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">答案是，当你<strong class="ka ir">不能</strong>的时候。</p><p id="ff20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果使用模块化模式，其中<code class="fe kx ky kz la b">:app</code>包含<code class="fe kx ky kz la b">ApplicationComponent</code>(或<code class="fe kx ky kz la b">SingletonComponent</code>)，那么当<code class="fe kx ky kz la b">ApplicationComponent</code>可以看到应用程序中的任何<code class="fe kx ky kz la b">Activity</code>或<code class="fe kx ky kz la b">Fragment</code>时，子模块看不到<code class="fe kx ky kz la b">:app</code>，因此也看不到<code class="fe kx ky kz la b">ApplicationComponent</code>。所以，他们不能叫<code class="fe kx ky kz la b">component.inject(this)</code>！</p><p id="bffe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，如果你要<a class="ae me" href="https://github.com/android/architecture-components-samples/blob/0c2e39d084cbc4ad082e701e0c6a8ff29a3aa737/GithubBrowserSample/app/src/main/java/com/android/example/github/di/AppInjector.java#L44" rel="noopener ugc nofollow" target="_blank">定义一个</a> <code class="fe kx ky kz la b"><a class="ae me" href="https://github.com/android/architecture-components-samples/blob/0c2e39d084cbc4ad082e701e0c6a8ff29a3aa737/GithubBrowserSample/app/src/main/java/com/android/example/github/di/AppInjector.java#L44" rel="noopener ugc nofollow" target="_blank">Application.ActivityLifecycleCallbacks</a></code> <a class="ae me" href="https://github.com/android/architecture-components-samples/blob/0c2e39d084cbc4ad082e701e0c6a8ff29a3aa737/GithubBrowserSample/app/src/main/java/com/android/example/github/di/AppInjector.java#L44" rel="noopener ugc nofollow" target="_blank">来自动完成它</a>，那就不能用标准方法了——因为你只看到超类，而看不到具体的类！</p><p id="2b63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，如果想要在我们提供的限制下使用场注入，有两种选择:</p><ol class=""><li id="d20a" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">从定义注入目标的子模块中公开一个接口，并在ApplicationComponent上实现它——然后使访问它成为可能(例如，使用ApplicationContext进行查找),并将其转换为能够调用<code class="fe kx ky kz la b">(applicationContext as FeatureInjectorProvider).inject(this)</code>的接口</li><li id="c199" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">通过定义一个允许注入特定子类(<code class="fe kx ky kz la b">fun inject(myClass: MyClass)</code>)的通用接口，使注入一个共享超类的任何子类(甚至可能是<code class="fe kx ky kz la b">Object</code>)成为可能，然后使用map-multibinding将它的<code class="fe kx ky kz la b">Class&lt;?&gt;</code>映射到可以注入它的类(这样我们就可以使用<code class="fe kx ky kz la b">Class&lt;?&gt;</code>作为一个键进行映射查找)——或者更确切地说，每个注入的类都需要它自己的<code class="fe kx ky kz la b">injector</code> <em class="kw">实例</em>， 我们需要map-multi-bind <em class="kw">一些能够<em class="kw">创建</em>注入器的东西，这样我们就可以用它来创建注入器，然后用创建的注入器实例注入目标。</em></li></ol><p id="2522" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">匕首-安卓是选项#2 </strong>。“注射器”叫<code class="fe kx ky kz la b">AndroidInjector&lt;T&gt;</code>，能创造“注射器”的叫<code class="fe kx ky kz la b">AndroidInjector.Factory&lt;T&gt;</code>。</p><p id="1199" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae me" href="https://github.com/google/dagger/blob/6778a01ae5142ca25a07946250d008cfb8df216a/java/dagger/android/AndroidInjectionModule.java#L32-L36" rel="noopener ugc nofollow" target="_blank">地图-多绑定在</a> <code class="fe kx ky kz la b"><a class="ae me" href="https://github.com/google/dagger/blob/6778a01ae5142ca25a07946250d008cfb8df216a/java/dagger/android/AndroidInjectionModule.java#L32-L36" rel="noopener ugc nofollow" target="_blank">AndroidInjectionModule</a></code>中声明，这是需要添加到ApplicationComponent的“神奇”模块，Dagger-Android才能工作。</p><h1 id="6022" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">匕首-安卓怎么用？</h1><p id="bbef" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">从2.20开始，Dagger-Android的“Android”部分有点用词不当，因为你可以为一个共享超类的任何N个子类定义一个<code class="fe kx ky kz la b">AndroidInjector</code>(其中所有类共享<code class="fe kx ky kz la b">Object</code>，所以任何类！)，这样就有可能为活动、片段、指挥控制器、工作管理器的工人等等定义<code class="fe kx ky kz la b">AndroidInjector</code>。</p><p id="07f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，组件需要添加前面提到的<code class="fe kx ky kz la b">AndroidInjectionModule</code>:</p><pre class="mt mu mv mw gt mx la my mz aw na bi"><span id="f1b9" class="nb lc iq la b gy nc nd l ne nf">@Component(modules=[<strong class="la ir">AndroidInjectionModule::class</strong>, MyModule::class])<br/>@Singleton<br/>interface SingletonComponent {<br/>    // ...<br/>}</span></pre><p id="e60d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们实际上可以使用<code class="fe kx ky kz la b">@ContributesAndroidInjector</code>为任何<code class="fe kx ky kz la b">T</code>创建一个<code class="fe kx ky kz la b">AndroidInjector.Factory&lt;T&gt;</code>:</p><pre class="mt mu mv mw gt mx la my mz aw na bi"><span id="e470" class="nb lc iq la b gy nc nd l ne nf">@Module<br/>abstract class MyModule {<br/><strong class="la ir">    @ContributesAndroidInjector</strong><br/>    abstract fun mainActivity(): MainActivity<br/>}</span></pre><p id="4598" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这在内部生成一个可以注入<code class="fe kx ky kz la b">MainActivity</code>的子组件，实现<code class="fe kx ky kz la b">AndroidInjector&lt;T&gt;</code>，从而可以注入<code class="fe kx ky kz la b">MainActivity</code>。这是作为<code class="fe kx ky kz la b">Map&lt;Class&lt;T&gt;, AndroidInjector.Factory&lt;T&gt;&gt;</code>的地图多绑定。</p><p id="7e63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有一点神奇之处:Dagger-Android为我们提供的允许我们注入任何类的类叫做<code class="fe kx ky kz la b">DispatchingAndroidInjector&lt;Object&gt;</code>。这是自动注入到<code class="fe kx ky kz la b">DaggerApplication</code>中的，是<code class="fe kx ky kz la b">HasAndroidInjector</code>返回的类。</p><p id="7573" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">DispatchingAndroidInjector</code>为我们做的是获取我们的类实例的<code class="fe kx ky kz la b">Class&lt;?&gt;</code>，尝试为给定的<code class="fe kx ky kz la b">Class&lt;?&gt;</code>找到<code class="fe kx ky kz la b">AndroidInjector.Factory&lt;T&gt;</code>，使用工厂创建注入器，然后注入我们的类。和<code class="fe kx ky kz la b">dispatchingAndroidInjector.inject(myClass)</code>一样简单调用，是<code class="fe kx ky kz la b">AndroidInjection.inject(this)</code>引擎盖下用的。</p><p id="f767" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过<code class="fe kx ky kz la b">@Inject</code>访问<code class="fe kx ky kz la b">DispatchingAndroidInjector&lt;Object&gt;</code>，就像任何其他依赖一样(或者从应用程序类如<code class="fe kx ky kz la b">HasAndroidInjector</code>)，我们能够在一个模块中现场注入任何具有相应<code class="fe kx ky kz la b">@ContributesAndroidInjector</code>的类。</p><p id="39b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Dagger-Android提供了像<code class="fe kx ky kz la b">DaggerAppCompatActivity</code>和<code class="fe kx ky kz la b">DaggerFragment</code>这样的基类，它们将使用最接近的(通过片段查找- &gt;活动- &gt;应用程序)<code class="fe kx ky kz la b">AndroidInjector</code>调用<code class="fe kx ky kz la b">inject(this)</code>，能够注入我们提供的实例。</p><h1 id="5528" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">提供定义@ContributesAndroidInjector的模块的最佳方式是什么？</h1><p id="311a" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">一个非常常见的结构性<em class="kw">反模式</em>，直接继承自Android/architecture-components-samples，就是创建<code class="fe kx ky kz la b">ActivityBuildersModule</code>、<code class="fe kx ky kz la b">ViewModelModule</code>、<code class="fe kx ky kz la b">FragmentBuildersModule</code>等模块。</p><p id="c23c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，所有的活动/片段/视图模型都被收集到<code class="fe kx ky kz la b">:app</code>中定义的同一个全局模块中，因此每次新的活动(在多活动应用程序中)、新的片段或新的视图模型(如果使用map-multibinding而不是每个视图模型的<code class="fe kx ky kz la b">AbstractSavedStateViewModelFactory</code>)时，这3个文件每次都必须被修改！</p><p id="dffd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，由于Dagger-Android的性质，忘记修改至少1个(这3个中的任何一个)模块将导致运行时异常，所以随着时间的推移，这显然会有点痛苦。</p><p id="b211" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="kw">更好的方法是为每个屏幕定义一个模块(这里假设是单活动app)。</em> </strong>在这种情况下，每个屏幕都定义了一个新的模块，它描述了屏幕的依赖关系(片段的android注入器，以及ViewModel的In-map绑定，如果使用的话)，这个<code class="fe kx ky kz la b">@Module</code>在当前编译模块的内部。</p><p id="577e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后使用<code class="fe kx ky kz la b">includes=[]</code>将屏幕的模块包含到为整个编译模块定义的顶层模块中，如下所示:</p><pre class="mt mu mv mw gt mx la my mz aw na bi"><span id="fb8b" class="nb lc iq la b gy nc nd l ne nf">// compilation module: :features-authentication</span><span id="d7bd" class="nb lc iq la b gy ng nd l ne nf">@Module(<strong class="la ir">includes = [<br/>    LoginScreenModule::class, <br/>    RegisterScreenModule::class,<br/>]</strong>)<br/>object AuthenticationModule {<br/>}</span></pre><p id="5a9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，这个顶级模块是唯一包含在描述特性的模块中的模块(因为它必须以某种方式添加到ApplicationComponent中):</p><pre class="mt mu mv mw gt mx la my mz aw na bi"><span id="fbab" class="nb lc iq la b gy nc nd l ne nf">// compilation module: :app</span><span id="5bc0" class="nb lc iq la b gy ng nd l ne nf">@Module(includes = [<br/><strong class="la ir">    AuthenticationModule::class</strong>,  <br/>    /*...*/<br/>])<br/>object FeaturesModule {<br/>}</span></pre><p id="564d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个聚合模块包含在ApplicationComponent中，因此我们不需要经常接触它:</p><pre class="mt mu mv mw gt mx la my mz aw na bi"><span id="5682" class="nb lc iq la b gy nc nd l ne nf">// compilation module: :app</span><span id="9930" class="nb lc iq la b gy ng nd l ne nf">@Component(modules = [<br/>    AndroidInjectionModule::class,<br/><strong class="la ir">    FeaturesModule::class,</strong><br/>    // ...<br/>])<br/>@Singleton<br/>interface ApplicationComponent {<br/>    // ...<br/>}</span></pre><p id="8651" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，每个已安装的屏幕对于其自己的模块来说都是本地的，并且与将所有屏幕聚集到不同编译模块中的多个全局模块中相比，移除屏幕/添加新屏幕明显更加直接，并且错误空间更小。</p><h1 id="27a5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">真的可以用Dagger-Android用@ContributesAndroidInjector对任何类进行字段注入吗？</h1><p id="43db" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">是的，Dagger-Android从2.20+开始允许对任何类进行字段注入，只要定义了一个<code class="fe kx ky kz la b">@ContributesAndroidInjector</code>，所以它实际上更少是关于注入“Android组件”，而更多是关于以这样一种方式注入动态类型，即注入器本身的确切类型对于注入目标是未知的。</p><p id="fb7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它非常强大，如果不使用辅助注射和map-multibinding来创建辅助工人，它可以用于现场注射工人。</p><h1 id="b53a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="ef3d" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">希望这有助于理解Dagger-Android是如何工作的。</p><p id="9e5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，现在在2021年，人们很可能会使用Dagger-Hilt，因为Dagger-Hilt解决了必须使用<code class="fe kx ky kz la b">@AndroidEntryPoint</code>注入活动/片段的问题(并通过它处理注入Android组件的调用)，ViewModel通过一个全局<code class="fe kx ky kz la b">ViewModelProvider.Factory</code>处理，使用<code class="fe kx ky kz la b">@HiltViewModel</code>自动将任何ViewModel类映射多重绑定到它(甚至允许访问<code class="fe kx ky kz la b">SavedStateHandle</code>，而不需要手动依赖辅助注入)，WorkManager的工作人员也通过<code class="fe kx ky kz la b">@HiltWorker</code>和<code class="fe kx ky kz la b">HiltWorkerFactory</code>自动注入。</p><p id="54f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以对于Android的类型，一般不再需要这种动态调度字段注入。</p><p id="b6cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不过，希望这篇文章有助于理解Dagger-Android是如何工作的，并可能展示如何在仍然依赖于功能模块化代码库中的全局注入器的情况下更好地构建模块。</p></div></div>    
</body>
</html>