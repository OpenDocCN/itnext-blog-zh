<html>
<head>
<title>Scroll listener vs Intersection Observers: a performance comparison</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">滚动监听器与交叉点观察器:性能比较</h1>
<blockquote>原文：<a href="https://itnext.io/1v1-scroll-listener-vs-intersection-observers-469a26ab9eb6?source=collection_archive---------3-----------------------#2019-04-17">https://itnext.io/1v1-scroll-listener-vs-intersection-observers-469a26ab9eb6?source=collection_archive---------3-----------------------#2019-04-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c2658ea5eba3a87d7bf44b6248224951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zfE7FNeyXzFwzUXpI1P5tQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">明白了吗？</figcaption></figure><p id="2293" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">observer API已经登陆了一段时间，并且得到了所有现代浏览器的完全支持。其中之一是<strong class="ke ir"> IntersectionObserver </strong>，它帮助你在某些DOM元素彼此“相交”时触发回调。我问自己“我能把我的滚动监听器换成那个吗？它会更便宜、性能更友好吗？这篇文章试图回答这个问题。</p><h1 id="01c6" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">设置场景</h1><p id="fa75" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">为了正确地比较这两种方法，我创建了一个非常简单的虚拟SPA应用程序:一个包含4个文本部分的页面。当您从一个部分滚动到另一个部分时，网页的哈希会根据您现在正在查看的部分进行更新。很简单吧？如果你还没有完全明白，我创建了一个小的GIF来进一步说明我的观点(在文章的最底部可以找到代码的链接)。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi md"><img src="../Images/51e5df4674f9644377da8cc9563abf7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*IsoqwGw734P6JJjv8ga2Bw.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我们的基准—一个有4个可滚动部分的虚拟SPA</figcaption></figure><p id="b0b1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我创建了这个页面的2个版本；一个带有滚动监听器，一个带有交叉点观察器。对于交叉点观察者来说，代码非常简单，您不需要做任何性能上的改动。对于滚动监听器，我创建了3个不同的版本。</p><p id="b2d0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> 1。没有偏移缓存，没有节流<br/> </strong>这个版本只是添加了所需的滚动监听器，而没有缓存任何可能保持不变的值(即每个部分的<code class="fe mi mj mk ml b">offset</code>距离)或向滚动监听器添加任何节流。</p><p id="5fe2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> 2。</strong> <strong class="ke ir">偏移缓存，无节流<br/> </strong>该版本缓存各部分的<code class="fe mi mj mk ml b">offset</code>距离(只要视口宽度保持不变，该距离保持不变)，但不对滚动监听器添加任何节流。</p><p id="c970" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> 3。</strong> <strong class="ke ir">偏移缓存&amp;节流<br/> </strong>这个版本与(2)完全一样，但是在侦听器的回调上有一个<code class="fe mi mj mk ml b">300ms</code>节流。</p><h2 id="0507" class="mm lb iq bd lc mn mo dn lg mp mq dp lk kn mr ms lo kr mt mu ls kv mv mw lw mx bi translated">基准</h2><p id="dd80" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">这些比较是使用Chrome开发工具中的性能标签进行的。为了正确地模拟具有平均功率的计算机，我在CPU上添加了4倍的减速。然后，在从页面顶部滚动到最底部<strong class="ke ir">时，我记录了4次性能记录(3次记录了滚动监听器的不同变化，1次记录了交叉点观察器的实现),丝毫没有停止</strong>。结果如下:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/20128e5fcbe1752e9f65e26d048ad37a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*esikECjoH0xPCHhMc8jpMA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">滚动监听器—无缓存和无节流</figcaption></figure><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/6ca6448daa824cbd59366237ff15d65e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*deFRZ1e7EBmtbQGVzTkSyw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">滚动监听器—缓存和无节流</figcaption></figure><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/7dcbc3993ac9e98dafd2671175435509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ADhdobkCgKHL5BbxU6f9HQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">滚动监听器—缓存和节流</figcaption></figure><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/2225705179194f913d29f29769992bb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J3RUxjf-KiSQ9SnKmDbtmw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">交叉观察者</figcaption></figure><p id="52ba" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">简单解释一下:</p><ol class=""><li id="7171" class="nc nd iq ke b kf kg kj kk kn ne kr nf kv ng kz nh ni nj nk bi translated">黄色本质上意味着计算压力。越高，主线程要做的工作就越多。</li><li id="b434" class="nc nd iq ke b kf nl kj nm kn nn kr no kv np kz nh ni nj nk bi translated">黄色上方的绿色是FPS。它越高越稳定，用户的体验就越好。</li><li id="5431" class="nc nd iq ke b kf nl kj nm kn nn kr no kv np kz nh ni nj nk bi translated">绿色上面的小红点可能意味着很多事情(通常对用户来说是懒惰的)。在这种情况下，它们意味着回调时间超出了一个事件循环。它们出现得越少越好:)</li></ol><p id="0b73" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我们累计所有“黄色”时间，然后除以总时间，我们就可以得到在主线程上执行脚本工作所花费的时间百分比:</p><p id="ba31" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">执行脚本工作总时间的百分比</strong> <br/>滚动监听器—不缓存&amp;不节流:<strong class="ke ir">48.9%<br/>T5】滚动监听器—缓存&amp;不节流:<strong class="ke ir"> 43.5% <br/> </strong>滚动监听器—缓存&amp;节流:<strong class="ke ir"> 28.9% <br/> </strong>交集观察器:<strong class="ke ir"> 23.3% </strong></strong></p><p id="ead9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有趣的是，<strong class="ke ir"> IntersectionObserver </strong>只能与带有节流功能的优化ScrollListener相比。这很有趣，因为我们不需要对观察者本身进行任何性能优化。如果我们将CPU速度进一步降低到6倍(模拟老式手机)，并再次进行相同的测试，结果会更加清晰:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/3e8d31d2aceaf0cd0504a462066849d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q-TjCi1bVbUOFgBRdTo7xA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">滚动监听器—缓存和节流</figcaption></figure><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/b324a6034939f6ccde281a94c5a19284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SUYelakKYaXjwqPT_UnEg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">交叉观察者</figcaption></figure><p id="056f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">做脚本工作总时间的百分比<br/> </strong>滚动监听器—缓存&amp;节流:<strong class="ke ir"> 63.0% <br/> </strong>交集观察者:<strong class="ke ir"> 37.6% </strong></p><p id="85c1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这意味着当使用交叉点观察器时，主线程响应用户输入的自由增加了43%(在极慢的机器上)</p><h1 id="32cb" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="1cb0" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">我们在这里尝试的是比较解决同一问题的两种不同解决方案的性能优势。当然，有时候滚动监听器可能是最好的方法(由于外部限制)，但是对于核心任务(比如改变散列，基于滚动改变一些样式，在某个点之后让一些东西粘在一起，等等。)新的observer API确实性能更好，如果<strong class="ke ir">性能对你的应用</strong>至关重要，应该优先考虑。</p><p id="e8ee" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，用于重现上述结果的代码可以在下面找到:</p><p id="e17a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae ns" href="https://codesandbox.io/s/x7n0kmxjvo?fontsize=14" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/x7n0kmxjvo?fontsize=14</a></p><p id="caad" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">感谢阅读！</p><p id="9021" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"><em class="nt"/></strong>👋<strong class="ke ir"> <em class="nt">嗨，我是</em></strong><a class="ae ns" href="https://aggelosarvanitakis.me" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="nt">Aggelos</em></strong></a><strong class="ke ir"><em class="nt">！如果你喜欢这个，考虑一下</em> </strong> <a class="ae ns" href="https://twitter.com/AggArvanitakis" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="nt">在twitter上关注我</em> </strong> </a> <strong class="ke ir"> <em class="nt">并与你的开发者朋友分享这个故事</em>😀</strong></p><p id="c0cc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可能也会对我前几周的一些故事感兴趣</p><ul class=""><li id="17b8" class="nc nd iq ke b kf kg kj kk kn ne kr nf kv ng kz nu ni nj nk bi translated"><a class="ae ns" href="https://levelup.gitconnected.com/3-small-tips-for-better-redux-performance-in-a-react-app-9cde549df6af" rel="noopener ugc nofollow" target="_blank">https://level up . git connected . com/3-small-tips-for-better-redux-performance-in-a-react-app-9 CDE 549 df 6 af</a></li><li id="851c" class="nc nd iq ke b kf nl kj nm kn nn kr no kv np kz nu ni nj nk bi translated"><a class="ae ns" href="https://medium.com/@aggelosarvanitakis/6-tips-for-better-react-performance-4329d12c126b" rel="noopener">https://medium . com/@ aggelosarvanitakis/6-tips-for-better-react-performance-4329 d12 c126 b</a></li><li id="5d6a" class="nc nd iq ke b kf nl kj nm kn nn kr no kv np kz nu ni nj nk bi translated"><a class="ae ns" href="https://levelup.gitconnected.com/the-importance-of-state-ui-actors-in-web-apps-f69cc523798b" rel="noopener ugc nofollow" target="_blank">https://level up . git connected . com/the-importance-of-state-ui-actors-in-we b-apps-f69cc 523798 b</a></li></ul></div></div>    
</body>
</html>