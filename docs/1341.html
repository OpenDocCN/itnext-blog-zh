<html>
<head>
<title>What is Modular CSS?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是模块化CSS？</h1>
<blockquote>原文：<a href="https://itnext.io/what-is-modular-css-659949e23534?source=collection_archive---------0-----------------------#2018-09-18">https://itnext.io/what-is-modular-css-659949e23534?source=collection_archive---------0-----------------------#2018-09-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/e431757efb888898a4d3c3e39841f5de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6yahP0U8OLwT1ScRPDAdhA.png"/></div></div></figure><div class=""/><p id="86d6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模块化CSS是一个原则的集合，用于编写高性能和可维护的代码。它起源于Yahoo和Yandex的开发人员，作为解决维护大型代码库的挑战的一种方法。有些指导方针在推出时是有争议的，但后来被认为是最佳实践。</p><p id="f7f5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">目录:</strong></p><ol class=""><li id="2ddb" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">大规模的CSS是困难的</li><li id="832e" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">什么是模块化？</li><li id="1f78" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">模块化框架</li><li id="f6de" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">OOCSS</li><li id="2417" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">不列颠帝国勋章</li><li id="0557" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">SMACSS</li><li id="5950" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">共享模块原则</li><li id="6062" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">常见问题解答</li><li id="edb9" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">总之，模块化CSS是掺杂的</li></ol><p id="bd58" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lk">(psst:如果你对这篇文章的长度感到不知所措，你可能更喜欢</em> <a class="ae ll" href="https://www.youtube.com/watch?v=Ty5jtMZXbmk" rel="noopener ugc nofollow" target="_blank"> <em class="lk">看一段视频</em> </a> <em class="lk">它所基于的演示文稿。)</em></p><h1 id="e953" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">大规模的CSS是困难的</h1><p id="465c" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">模块化CSS被创建来解决的主要问题是大规模的CSS是棘手的。我喜欢<a class="ae ll" href="https://twitter.com/necolas" rel="noopener ugc nofollow" target="_blank">尼古拉斯·加拉格尔</a>的这句话:</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mp"><img src="../Images/6126e4318e3c4a0d25c137671fde0777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xyTgRc-tpXlpXftr.jpg"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">引用:<a class="ae ll" href="https://twitter.com/necolas/status/360170108028600320" rel="noopener ugc nofollow" target="_blank">尼古拉斯加拉格尔</a>，图片:<a class="ae ll" href="https://www.youtube.com/watch?v=L8w3v9m6G04" rel="noopener ugc nofollow" target="_blank"> dotCSS </a></figcaption></figure><p id="0ffc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就触及了大规模CSS的核心问题。写代码不是挑战。这样做的方式不会随着时间的推移让你陷入技术债务的泥潭。</p><h2 id="9296" class="my ln jb bd lo mz na dn ls nb nc dp lw kj nd ne ma kn nf ng me kr nh ni mi nj bi translated">难以理解</h2><p id="06b8" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">这里有一个来自<a class="ae ll" href="https://cssguidelin.es/#naming-conventions-in-html" rel="noopener ugc nofollow" target="_blank"> CSS指南</a>的例子，展示了我们遇到的这种问题。除了写这段代码的人之外，没有人知道它是做什么的。</p><pre class="mq mr ms mt gt nk nl nm nn aw no bi"><span id="40a1" class="my ln jb nl b gy np nq l nr ns">&lt;div class="box profile pro-user"&gt;<br/>  &lt;img class="avatar image" /&gt;<br/>  &lt;p class="bio"&gt;...&lt;/p&gt;<br/>&lt;/div&gt;</span></pre><blockquote class="nt nu nv"><p id="8147" class="jy jz lk ka b kb kc kd ke kf kg kh ki nw kk kl km nx ko kp kq ny ks kt ku kv ij bi translated"><em class="jb">类</em> <code class="fe nz oa ob nl b"><em class="jb">box</em></code> <em class="jb">和</em> <code class="fe nz oa ob nl b"><em class="jb">profile</em></code> <em class="jb">之间有什么关系？</em> <code class="fe nz oa ob nl b"><em class="jb">profile</em></code> <em class="jb">和</em> <code class="fe nz oa ob nl b"><em class="jb">avatar</em></code> <em class="jb">这两个类之间有什么关系？他们有任何关系吗？你应该和</em> <code class="fe nz oa ob nl b"><em class="jb">bio</em></code> <em class="jb">一起使用</em> <code class="fe nz oa ob nl b"><em class="jb">pro-user</em></code> <em class="jb">吗？</em> <code class="fe nz oa ob nl b"><em class="jb">image</em></code> <em class="jb">和</em> <code class="fe nz oa ob nl b"><em class="jb">profile</em></code> <em class="jb">这两个类会生活在CSS的同一个部分吗？你能在其他地方使用</em> <code class="fe nz oa ob nl b"><em class="jb">avatar</em></code> <em class="jb">吗？</em></p></blockquote><p id="1b0d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从这里无法回答这些问题。你必须在CSS里做一些侦探工作。</p><h2 id="9a95" class="my ln jb bd lo mz na dn ls nb nc dp lw kj nd ne ma kn nf ng me kr nh ni mi nj bi translated">难以重复使用</h2><p id="2039" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">重用代码可能非常棘手。假设一个页面上有一种样式，您想在另一个页面上重用，但是当您尝试时，您发现它是以只在第一页上有效的方式编写的。作者假设它存在于一个特定的元素中，或者它从页面中继承了某些类。在不同的语境下根本行不通。您不想破坏原始代码，所以您复制了代码。</p><p id="4c28" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在你有两个问题:你有你的原始代码和你的复制代码。你的维护负担增加了一倍。</p><h2 id="b656" class="my ln jb bd lo mz na dn ls nb nc dp lw kj nd ne ma kn nf ng me kr nh ni mi nj bi translated">难以维护</h2><p id="bd1d" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">大规模的CSS也很难维护。你改变了标记，样式就像纸牌搭的房子一样倒塌了。你想在一个页面上更新一个样式，而它在另一个页面上中断。你试图覆盖另一页，但陷入了一场特异性战争。</p><p id="bdb7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这让我想起了我最喜欢的一个CSS笑话:</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="oc od l"/></div></figure><h1 id="0018" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">什么是模块化？</h1><p id="69f1" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">那么我们如何解决这些问题呢？答案在于<em class="lk">模块化</em>的概念，但这到底意味着什么呢？让我们从引用<a class="ae ll" href="https://twitter.com/csswizardry" rel="noopener ugc nofollow" target="_blank"> Harry Roberts </a>关于<a class="ae ll" href="https://cssguidelin.es/#the-separation-of-concerns" rel="noopener ugc nofollow" target="_blank">关注点分离</a>的话开始:</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mp"><img src="../Images/aeaed046a6ec7172d11d614911d9cc52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VqMcKi0BTVyt0_3d.jpg"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">引用:<a class="ae ll" href="https://cssguidelin.es/#the-separation-of-concerns" rel="noopener ugc nofollow" target="_blank">哈利·罗伯特</a>，照片:<a class="ae ll" href="https://csswizardry.com/" rel="noopener ugc nofollow" target="_blank">CSSwizardry.com</a></figcaption></figure><p id="e519" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一种常见的编程实践，许多CSS开发人员并不熟悉。这样做的目的是确保你写的东西不会超出你的预期。</p><p id="27d8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我给你举一个我在学习模块化CSS之前的工作方式的例子。我会从我的设计师那里得到一个这样的样品:</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oe"><img src="../Images/c1ecfbd4bb2372ed640ed24f3ce6b709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JUioYGTr7Fg2uBm6.gif"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">图片:<a class="ae ll" href="https://github.com/bem-site/bem-method/blob/bem-info-data/articles/yandex-frontend-dev/yandex-frontend-dev.en.md" rel="noopener ugc nofollow" target="_blank"> Yandex </a></figcaption></figure><p id="0985" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我会想“好吧，我在看书店的一页。我在侧边栏里有一些小工具。我把我认为是书的封面的东西列在了右边。我有一篇特色书评，下面还有几篇评论。”</p><p id="9dba" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我认为页面是一个完整的单元，较小的部分属于页面。这种方法是自上而下的思维，导致代码中充满了一次性的和只存在于一个页面中的特殊位。这不利于编写可重用的代码。</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oe"><img src="../Images/ca7b3357dfc4222410424df0327e075c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Pw78zZUXveIlS86j.jpg"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">图片:<a class="ae ll" href="https://github.com/bem-site/bem-method/blob/bem-info-data/articles/yandex-frontend-dev/yandex-frontend-dev.en.md" rel="noopener ugc nofollow" target="_blank"> Yandex </a></figcaption></figure><p id="36e9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模块化CSS要求你做的是后退一步，而不是在页面级别考虑这个问题，看看你的页面是由小块离散内容组成的这个事实。这不是一页。这是一系列的作品。</p><p id="52b2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你有一个徽标、一个搜索栏、导航、一个照片列表、一个辅助导航、一个标签框、一个视频播放器等等。这些是可以在你的站点中的任何地方使用的离散的内容。它们只是碰巧在这一页上以这种方式组合在一起。</p><p id="7d8e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模块化CSS是自底向上的思维。它要求您从构建整个网站的可重用构件开始。</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/27bd3b4fdd3ccfe7b82cc0e96b26149b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GL6Oy_MAMPf2L2bK.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">图片:<a class="ae ll" href="https://github.com/bem-site/bem-method/blob/bem-info-data/articles/19-bem-principles/19-bem-principles.ru.md" rel="noopener ugc nofollow" target="_blank">边界元法</a></figcaption></figure><p id="bdcf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这让你想起什么了吗？应该的！几乎每个写模块化CSS的人都用乐高做类比，这是有原因的。用标准化的、易于理解的块构建一个UI的想法是一个很好的概念，不管上下文如何，这些块的行为都是可预测的。</p><p id="01ab" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种类型块最著名的例子之一是“媒体对象”，由<a class="ae ll" href="https://twitter.com/stubbornella" rel="noopener ugc nofollow" target="_blank">妮可·沙利文</a>定义。她认为这个对象是你能在任何网站上找到的最小的离散内容之一。</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi of"><img src="../Images/6860214fcc0f3b4d7357a9437d227820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*o6uglNyyR1oPP1A5.jpg"/></div></div></figure><p id="883f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它将固定宽度的图像结合到可变宽度内容的一侧。你可以在任何地方看到这个。她制作了一个案例研究，名为“<a class="ae ll" href="http://www.stubbornella.org/content/2010/06/25/the-media-object-saves-hundreds-of-lines-of-code/" rel="noopener ugc nofollow" target="_blank">媒体对象保存了数百行代码</a>”，讲述了如何将这种模式应用于大型网站。她举的一个最大的例子是脸书:</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi og"><img src="../Images/d7757542f74bb6b99a6710933633644d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*I1HFQfBu48hcy57v.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">图片:<a class="ae ll" href="http://www.stubbornella.org/content/2010/06/25/the-media-object-saves-hundreds-of-lines-of-code/" rel="noopener ugc nofollow" target="_blank">妮可·沙利文</a></figcaption></figure><p id="7be1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，她突出显示了脸书流中的所有媒体对象。左上角是个人资料，右边是导航元素，提要中的每个帖子，甚至还有广告。有时它们相互嵌套。尽管它们用于不同的目的，但它们都共享相同的底层模式:固定宽度的图像，灵活宽度的文本。</p><p id="a206" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">她的观点是，当我们谈论在脸书的规模上运作时，没有10或20或30个媒体对象。像这样的页面有成百上千个。所以你可以想象，如果你优化了用于这些重复模式的样式，你可以节省大量的代码。这带来了真正的性能和成本节约。</p><h1 id="bb8a" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">模块化框架</h1><p id="53fd" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">那么，现在我们已经清楚了<em class="lk">模块化</em>的概念，让我们来看看这些年来推进这一概念的三个最大的框架:</p><h1 id="21a4" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">OOCSS</h1><p id="7412" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">面向对象的CSS，或称<a class="ae ll" href="https://github.com/stubbornella/oocss/wiki" rel="noopener ugc nofollow" target="_blank"> OOCSS </a>，是由<a class="ae ll" href="https://twitter.com/stubbornella" rel="noopener ugc nofollow" target="_blank">妮可·沙利文</a>于2009年创建的，它基于她在雅虎*的工作。这是模块化CSS的起源点。她的核心概念是对象是<strong class="ka jc">可重用模式</strong>，其视觉外观不是由上下文决定的。</p><p id="62e7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lk"> *对于那些想去“雅虎？真的吗？”你需要明白他们的前端团队当时正在用</em> <a class="ae ll" href="https://yuilibrary.com/" rel="noopener ugc nofollow" target="_blank"> <em class="lk"> YUI库</em> </a> <em class="lk">做一些真正前沿的东西。2009年，雅虎并不是一家没有出路的科技公司。</em></p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mp"><img src="../Images/705db86fcf5656cac6d84beeca6dadda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l5GA8V-jmWKkI12L.jpg"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">引用:<a class="ae ll" href="https://github.com/stubbornella/oocss/wiki" rel="noopener ugc nofollow" target="_blank">妮可·沙利文</a>，图片:<a class="ae ll" href="https://www.flickr.com/photos/localcelebrity/6025913421/" rel="noopener ugc nofollow" target="_blank">约翰·莫里森</a></figcaption></figure><p id="a2f2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是模块化CSS的根源，正如她在2009年定义的那样。除此之外，OOCSS可以归结为几个核心原则:</p><h2 id="0757" class="my ln jb bd lo mz na dn ls nb nc dp lw kj nd ne ma kn nf ng me kr nh ni mi nj bi translated">上下文无关的</h2><p id="5059" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">首先，无论你把一个物体放在哪里，它看起来都应该是一样的。对象不应该基于它们的上下文来设计样式。</p><p id="7205" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，不要把侧边栏中的所有按钮都变成橙色，把主区域中的所有按钮都变成蓝色，而应该把一个按钮类变成蓝色，把一个修饰符变成橙色。那么你的橙色按钮可以在任何地方使用，因为它们不依赖于侧边栏，它们只是你的按钮样式之一。</p><h2 id="5094" class="my ln jb bd lo mz na dn ls nb nc dp lw kj nd ne ma kn nf ng me kr nh ni mi nj bi translated">皮肤(又名主题化)</h2><p id="e133" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">她谈到的另一个概念是如何从正在应用的<strong class="ka jc">皮肤</strong>中抽象出一个物体的<strong class="ka jc">结构。</strong></p><p id="2b29" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以回到媒体对象的例子。它的外观独立于标记和定义的结构。有一个包含元素、一个固定宽度的图像和内容。你可以用一百种不同的方式来设计它，但是不管它看起来怎么样，它的标记和结构都是一样的。</p><p id="9833" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">她还建议为常见的视觉模式创建可重用的类。她的一个例子是，2009年在亚马逊上，几乎所有东西上都有阴影，它们只是有一点点不同。它们都是由不同的艺术家创作的图形元素，它们很相似，但又不相同。通过标准化这些阴影，你可以优化代码，使网站更有性能。</p><h2 id="9bf8" class="my ln jb bd lo mz na dn ls nb nc dp lw kj nd ne ma kn nf ng me kr nh ni mi nj bi translated">使用类</h2><p id="ee82" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">她还有一个原则，当时很有争议，但后来被证实了:使用类来命名对象及其子元素，这样标记可以在不影响样式的情况下改变。</p><p id="47e4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">她的意思是，你不希望你的标记决定你的CSS。所以如果你把标题从<code class="fe nz oa ob nl b">h1</code>改成了<code class="fe nz oa ob nl b">h4</code>，你不需要更新你的CSS。标题上应该有一个类，不管你选择什么元素，这个类都会被应用。比如，你的导航应该是类似<code class="fe nz oa ob nl b">.site-nav</code> <em class="lk">的东西，而不是</em> <code class="fe nz oa ob nl b">#header ul</code>。</p><h2 id="df75" class="my ln jb bd lo mz na dn ls nb nc dp lw kj nd ne ma kn nf ng me kr nh ni mi nj bi translated">不要使用身份证</h2><p id="8c68" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">“总是使用类”的自然推论是她建议永远不要使用ID选择器。这与当时使用id作为命名空间并直接引用嵌套在其中的元素的惯例相反。</p><p id="755e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">id混淆了特异性，因为它们太强了，但更重要的是，对象应该是可重用的。根据定义，id是唯一的。所以，如果你给你的对象加上一个ID，你就不能在同一个页面上重用它，这就失去了模块化对象的意义。</p><h1 id="54e5" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">不列颠帝国勋章</h1><p id="6600" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">这就把我们带到了下一个大框架，来帮助定义模块化CSS精神。<a class="ae ll" href="https://en.bem.info/methodology/" rel="noopener ugc nofollow" target="_blank"> BEM </a>，代表块、元素、修改器，也是在2009年创建的。它是在Yandex开发的，就像俄罗斯版的谷歌。他们还运营着一个搜索引擎和网络邮件程序，所以他们同时也在解决和雅虎一样的与规模相关的问题。</p><p id="ea01" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">他们为如何编写代码提出了一套非常相似的操作原则。他们的核心概念是<strong class="ka jc">块</strong>(Nicole称之为“对象”)由子<strong class="ka jc">元素</strong>组成，并且可以<strong class="ka jc">修改</strong>(或者“蒙皮”或“主题化”)。</p><p id="5062" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">参与BEM工作的主要前端人员之一瓦娅·斯捷潘诺娃是这样描述的:</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mp"><img src="../Images/934de7fb2388df50b769e1be13e430e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xwVtm0v8a5-09o5h.jpg"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">引用:<a class="ae ll" href="https://www.youtube.com/watch?v=ya7QsFUfn3U" rel="noopener ugc nofollow" target="_blank">瓦娅·斯捷潘诺娃</a>，照片:<a class="ae ll" href="https://www.youtube.com/watch?v=gWzYMJjtx-Y" rel="noopener ugc nofollow" target="_blank">苏格兰日报</a></figcaption></figure><p id="9da2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">边界元法由三部分组成:</p><h2 id="d5b5" class="my ln jb bd lo mz na dn ls nb nc dp lw kj nd ne ma kn nf ng me kr nh ni mi nj bi translated">阻碍</h2><p id="deac" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">块是网页的逻辑上和功能上独立的组件。BEM的创建者在Nicole定义的基础上增加了一些其他属性:</p><p id="6391" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，积木是可嵌套的。它们应该能够被包含在另一个块中而不破坏任何东西。例如，在你的侧边栏中可能有一个选项卡式界面小部件的块，并且这个块可能包含按钮，这是一个单独类型的块。按钮的样式和选项卡式元素的样式互不影响。只是一个嵌套在另一个里面。</p><p id="f455" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其次，块<strong class="ka jc">是可重复的</strong>。一个接口应该能够包含同一个块的多个实例。就像Nicole说的媒体对象一样，重用块的能力可以显著节省代码。</p><h2 id="18f0" class="my ln jb bd lo mz na dn ls nb nc dp lw kj nd ne ma kn nf ng me kr nh ni mi nj bi translated">元素</h2><p id="ac54" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">元素是块的组成部分，不能在块之外使用。一个很好的例子是，如果你有一个导航菜单，它包含的项目在菜单的上下文之外没有意义。你不会为一个菜单项定义一个块。菜单本身有一个块，菜单项是子元素。</p><h2 id="ba7e" class="my ln jb bd lo mz na dn ls nb nc dp lw kj nd ne ma kn nf ng me kr nh ni mi nj bi translated">修饰语</h2><p id="b226" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">修改器定义块的外观和行为。例如，根据所使用的修饰符，菜单块的外观可能会从垂直变为水平。</p><h2 id="7f3d" class="my ln jb bd lo mz na dn ls nb nc dp lw kj nd ne ma kn nf ng me kr nh ni mi nj bi translated">命名约定</h2><p id="a815" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">BEM做的另一件事是定义了一个非常严格的命名约定:</p><p id="8f6c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nz oa ob nl b">.block-name__element--modifier</code></p><p id="a8ca" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这看起来有点复杂，所以让我来分解一下:</p><ul class=""><li id="591e" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv oh lc ld le bi translated">名字是用小写字母写的</li><li id="364f" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv oh lc ld le bi translated">名称中的单词由连字符(<code class="fe nz oa ob nl b">-</code>)分隔</li><li id="f673" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv oh lc ld le bi translated">元素由双下划线(<code class="fe nz oa ob nl b">__</code>)分隔</li><li id="cc30" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv oh lc ld le bi translated">修饰符由双连字符(<code class="fe nz oa ob nl b">--</code>)分隔</li></ul><p id="1d36" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这变得有点抽象，所以让我们举个例子:</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mp"><img src="../Images/0367a5f282e76a32a07b61f22bee45a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9syIF4vUUvnA3PlG.png"/></div></div></figure><p id="7d1b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们有一个标准的乐高迷你玩具。是一个蓝色的宇航员。我们将用块类<code class="fe nz oa ob nl b">.minifig</code>来标识它。</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mp"><img src="../Images/67f10680c878ced847697ffcb6817205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HIE7y2zyE0Bfi_kf.png"/></div></div></figure><p id="3270" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以看到<code class="fe nz oa ob nl b">.minifig</code>块是由<code class="fe nz oa ob nl b">.minifig__head</code>和<code class="fe nz oa ob nl b">.minifig__legs</code>等更小的元素组成的。现在让我们添加一个修饰符:</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mp"><img src="../Images/2485cd9e98b9d06d09d8863191c316bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_RWgynkSqKRPEvVi.png"/></div></div></figure><p id="fb1a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过添加<code class="fe nz oa ob nl b">.minifig--red</code>修改器，我们创建了标准蓝色宇航员的红色版本。</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mp"><img src="../Images/4a1ef7b27a84d774f174f3a2836b4fb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-WJMbmPl5R0rSbfk.png"/></div></div></figure><p id="0871" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者，我们可以使用<code class="fe nz oa ob nl b">.minifig--yellow-new</code>修改器给我们的宇航员换上新式的黄色制服。</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mp"><img src="../Images/d98523100daeb4a88cb86c834ba9b05c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cxdKWiuUwxy-1mHR.png"/></div></div></figure><p id="dcb4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以用同样的方法做出更大的改变。通过使用<code class="fe nz oa ob nl b">.minifig--batman</code>修改器，我们只用一个类就改变了迷你图的每个部分的外观。</p><p id="dc58" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个更实用的BEM语法示例:</p><pre class="mq mr ms mt gt nk nl nm nn aw no bi"><span id="504e" class="my ln jb nl b gy np nq l nr ns">&lt;button class="btn btn--big btn--orange"&gt;<br/>  &lt;span class="btn__price"&gt;$9.99&lt;/span&gt;<br/>  &lt;span class="btn__text"&gt;Subscribe&lt;/span&gt;<br/>&lt;/button&gt;</span></pre><p id="5e86" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">即使没有看到任何CSS，你也能一眼看出这段代码会创建一个大大的橙色价格按钮。无论您是否喜欢这种带有连字符和下划线的样式，有一个严格的命名约定的想法是一个巨大的进步。它使代码自文档化！</p><h2 id="9286" class="my ln jb bd lo mz na dn ls nb nc dp lw kj nd ne ma kn nf ng me kr nh ni mi nj bi translated">没有嵌套的CSS</h2><p id="e966" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">就像OOCSS建议使用类而不是id一样，BEM为如何编写代码添加了一些原则。最值得注意的是，他们认为不应该嵌套CSS选择器。嵌套选择器增加了特异性，使得重用代码更加困难。比如，只用<code class="fe nz oa ob nl b">.btn__price</code> <em class="lk">不用</em> <code class="fe nz oa ob nl b">.btn .btn__price</code>。</p><p id="a8b9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lk">注意:这里的嵌套指的是在Sass或更少的Sass中实际嵌套选择器的实践，但是更广泛的概念也适用，即使你没有使用预处理器，因为它是关于选择器特性的。</em></p><p id="98d6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个原则是可行的，因为它们有严格的命名约定。我们过去常常嵌套选择器，将它们隔离在一个命名空间的上下文中。BEM的命名约定提供了一个命名空间，所以我们不再需要嵌套。尽管在CSS的根层，所有的东西都是一个类，但是它们的名字足够明确，可以避免冲突。</p><p id="6d8c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为一个规则，如果一个选择器不需要嵌套就可以工作，那么就不要嵌套它。BEM允许该规则的唯一例外是基于块或其修改器的状态来设计元素的样式。例如，当应用了一个修改器时，你可以先用<code class="fe nz oa ob nl b">.btn__text</code>然后用<code class="fe nz oa ob nl b">.btn--orange .btn__text</code>来覆盖按钮的文本颜色。</p><h1 id="b65d" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">SMACSS</h1><p id="bd9a" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">我们要讨论的最后一个框架是<a class="ae ll" href="https://smacss.com/" rel="noopener ugc nofollow" target="_blank"> SMACSS </a>，它代表CSS的可伸缩&amp;模块化架构。它是由乔纳森·史努克在2011年创造的。他也在雅虎工作，为雅虎邮箱写CSS。</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mp"><img src="../Images/fe995e97983b066d0851eeb81d65d661.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bfEwzFND3yW8L1o4.jpg"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">引用:<a class="ae ll" href="https://smacss.com/book/categorizing" rel="noopener ugc nofollow" target="_blank">乔纳森·斯努克</a>，照片:<a class="ae ll" href="https://www.flickr.com/photos/elidr/10864268273/" rel="noopener ugc nofollow" target="_blank">艾丽达·阿里扎</a></figcaption></figure><p id="7465" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">他在OOCSS和BEM的基础上补充的关键概念是，不同类别的组件需要不同的处理方式。</p><h2 id="79f4" class="my ln jb bd lo mz na dn ls nb nc dp lw kj nd ne ma kn nf ng me kr nh ni mi nj bi translated">种类</h2><p id="d4ad" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">以下是他为CSS系统可能包含的规则类型定义的类别:</p><ol class=""><li id="effa" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka jc">基本</strong>规则是链接、段落和标题等HTML元素的默认样式。</li><li id="1b5e" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka jc">布局</strong>规则将页面分成几个部分，并将一个或多个模块放在一起。他们只定义布局，而不是颜色或排版。</li><li id="767c" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka jc">模块</strong>(又名“对象”或“块”)是设计中可重用的模块化部分。例如按钮、媒体对象、产品列表等。</li><li id="cbcb" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">状态规则描述了模块或布局在特定状态下的样子。通常用JavaScript应用或删除。比如隐藏、展开、活动等。</li><li id="1fd6" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">规则描述了应用主题时模块或布局的外观。例如，在Yahoo Mail中，您可以应用一个用户主题，这会影响页面上的每个模块。(这个真的是具体到雅虎这样的app。大多数网站不会使用这个类别。)</li></ol><h2 id="a04b" class="my ln jb bd lo mz na dn ls nb nc dp lw kj nd ne ma kn nf ng me kr nh ni mi nj bi translated">命名约定前缀</h2><p id="5ff0" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">他引入的下一个原则是使用前缀来区分规则的类别。他喜欢BEM有一个清晰的命名约定的想法，但是他希望能够一眼看出他正在查看的是什么类型的模块。</p><ul class=""><li id="ccc8" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv oh lc ld le bi translated"><code class="fe nz oa ob nl b">l-</code>用作布局规则的前缀:<code class="fe nz oa ob nl b">l-inline</code></li><li id="897c" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv oh lc ld le bi translated"><code class="fe nz oa ob nl b">m-</code>用作模块规则的前缀:<code class="fe nz oa ob nl b">m-callout</code></li><li id="e50a" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv oh lc ld le bi translated"><code class="fe nz oa ob nl b">is-</code>用作州规则的前缀:<code class="fe nz oa ob nl b">is-collapsed</code></li></ul><p id="2ae6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(基本规则没有前缀，因为它们直接应用于HTML元素，不使用类。)</p><h1 id="3ff1" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">共享模块原则</h1><p id="3abd" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">这些框架相似之处多于不同之处。我看到了一条从OOCSS到BEM再到SMACSS的清晰路径。他们的发展代表了我们行业在性能和大规模编写CSS方面不断增长的经验。</p><p id="b4e0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你不需要只选择一个。相反，让我们尝试定义模块化CSS的通用主题。让我们看看这些框架有什么共同点，并保留最好的部分。</p><h2 id="f617" class="my ln jb bd lo mz na dn ls nb nc dp lw kj nd ne ma kn nf ng me kr nh ni mi nj bi translated">模块化元素</h2><p id="a7c4" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">模块化系统由以下要素组成:</p><ul class=""><li id="760a" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv oh lc ld le bi translated"><strong class="ka jc">模块:</strong>(又名对象、块或组件)一个可重用的自包含模式。示例包括媒体对象、导航和页眉。</li><li id="347e" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv oh lc ld le bi translated"><strong class="ka jc">子元素:</strong>模块中独立的一部分。示例包括媒体对象图像、导航选项卡和页眉徽标。</li><li id="764e" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv oh lc ld le bi translated">模块修改器:(又名皮肤或主题)改变模块的视觉外观。示例包括左/右对齐的媒体对象、垂直/水平导航。</li></ul><h2 id="c387" class="my ln jb bd lo mz na dn ls nb nc dp lw kj nd ne ma kn nf ng me kr nh ni mi nj bi translated">模块化类别</h2><p id="7065" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">模块化系统中的样式可以分为以下几类:</p><ul class=""><li id="dca5" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv oh lc ld le bi translated">基本规则是HTML元素的默认样式。例子:<code class="fe nz oa ob nl b">a</code>、<code class="fe nz oa ob nl b">li</code>、<code class="fe nz oa ob nl b">h1</code></li><li id="c262" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv oh lc ld le bi translated">规则控制模块如何布局，但不控制视觉外观。例子:<code class="fe nz oa ob nl b">.l-centered</code>、<code class="fe nz oa ob nl b">.l-grid</code>、<code class="fe nz oa ob nl b">.l-fixed-top</code></li><li id="0d96" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv oh lc ld le bi translated">模块是可重用的、自包含的UI组件的视觉样式。示例:<code class="fe nz oa ob nl b">.m-profile</code>、<code class="fe nz oa ob nl b">.m-card</code>、<code class="fe nz oa ob nl b">.m-modal</code></li><li id="6f84" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv oh lc ld le bi translated"><strong class="ka jc">状态</strong>规则由JavaScript添加。示例:<code class="fe nz oa ob nl b">.is-hidden</code>、<code class="fe nz oa ob nl b">.is-collapsed</code>、<code class="fe nz oa ob nl b">.is-active</code></li><li id="0496" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv oh lc ld le bi translated"><strong class="ka jc"> Helper </strong>(又名utility)规则范围小，独立于模块。例子:<code class="fe nz oa ob nl b">.h-uppercase</code>、<code class="fe nz oa ob nl b">.h-nowrap</code>、<code class="fe nz oa ob nl b">.h-muted</code></li></ul><h2 id="2590" class="my ln jb bd lo mz na dn ls nb nc dp lw kj nd ne ma kn nf ng me kr nh ni mi nj bi translated">模块化规则</h2><p id="e56b" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">在模块化系统中编写样式时，请遵循以下规则:</p><ul class=""><li id="e7f1" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv oh lc ld le bi translated">不要使用身份证</li><li id="8931" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv oh lc ld le bi translated">不要嵌套CSS超过一层</li><li id="f065" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv oh lc ld le bi translated">向子元素添加类</li><li id="0332" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv oh lc ld le bi translated">遵循命名约定</li><li id="7737" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv oh lc ld le bi translated">前缀类名</li></ul><h1 id="3666" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">常见问题解答</h1><h2 id="9b1e" class="my ln jb bd lo mz na dn ls nb nc dp lw kj nd ne ma kn nf ng me kr nh ni mi nj bi translated">这不是意味着我的HTML有很多类吗？</h2><p id="53b1" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">我经常看到的对模块化CSS方法的第一个反对意见是，它会在HTML中产生许多类。我认为这是因为它曾经被认为是避免在你的标记中有太多类的最佳实践。早在2011年，妮可·沙利文就写了一篇名为“<a class="ae ll" href="http://www.stubbornella.org/content/2011/04/28/our-best-practices-are-killing-us/" rel="noopener ugc nofollow" target="_blank">我们的(CSS)最佳实践正在杀死我们</a>”的博文，明确驳斥了这一观点。</p><p id="01a9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我看到一些开发人员提倡的一个选项是使用预处理器的<code class="fe nz oa ob nl b">extend</code>函数将多个样式连接成一个类名。我建议不要这样做，因为这会降低代码的灵活性。不允许其他开发者以新的方式组合你的乐高积木，他们会被你定义的几种组合卡住。</p><h2 id="a9a0" class="my ln jb bd lo mz na dn ls nb nc dp lw kj nd ne ma kn nf ng me kr nh ni mi nj bi translated">但是BEM类名又长又丑！</h2><p id="0f85" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">不要害怕长的类名。它们是自我记录的！当我看到BEM风格的类名(或任何其他模块化命名约定)时，我很高兴我一眼就能看出这些类的用途。这就像是你的标记中的书面痕迹。</p><h2 id="5a3a" class="my ln jb bd lo mz na dn ls nb nc dp lw kj nd ne ma kn nf ng me kr nh ni mi nj bi translated">孙元素的命名约定是什么？</h2><p id="abdc" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">长话短说:没有这回事。</p><p id="b376" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模块化CSS的新手很快掌握了子元素的思想:<code class="fe nz oa ob nl b">minifig__arm</code>是<code class="fe nz oa ob nl b">minifig</code>的一部分。然而，有时他们会在匹配CSS中的DOM结构时遇到麻烦，他们会询问如何指示进一步的嵌套层次，比如<code class="fe nz oa ob nl b">minifig__arm__hand</code>。</p><p id="b94a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">没必要这样。记住，这个想法是将你的样式从你的标记中分离出来。不管<code class="fe nz oa ob nl b">hand</code>是<code class="fe nz oa ob nl b">minifig</code>的直接子节点还是嵌套在DOM中的几个层次。CSS关心的只是<code class="fe nz oa ob nl b">hand</code>是<code class="fe nz oa ob nl b">minifig</code>的子。</p><pre class="mq mr ms mt gt nk nl nm nn aw no bi"><span id="5711" class="my ln jb nl b gy np nq l nr ns">.minifig {}<br/>  .minifig__arm {}<br/>    .minifig__arm__hand {} /* don't do this */<br/>  .minifig__hand {} /* do this instead */</span></pre><h2 id="2c9e" class="my ln jb bd lo mz na dn ls nb nc dp lw kj nd ne ma kn nf ng me kr nh ni mi nj bi translated">模块冲突怎么办？</h2><p id="e9e1" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">模块化CSS新手倾向于关注的另一件事是模块之间的冲突。例如，如果我将<code class="fe nz oa ob nl b">l-card</code>模块和<code class="fe nz oa ob nl b">m-author-profile</code>模块应用于同一个元素，会不会导致问题？</p><p id="25dc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">答案是，理想情况下，模块不应该重叠太多。在这个例子中，<code class="fe nz oa ob nl b">l-card</code>模块关注的是布局，而<code class="fe nz oa ob nl b">m-author-profile</code>模块关注的是样式。你可能会看到<code class="fe nz oa ob nl b">l-card</code>设置宽度和边距，而<code class="fe nz oa ob nl b">m-author-profile</code>应用背景颜色和字体。</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="2dc8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试你的模块是否被正确隔离并且不冲突的一个方法是以随机的顺序加载它们。您可以配置您的构建系统，在构建时打乱模块样式表。如果你开始发现错误，你就会知道你已经得到了一个期望以特定顺序加载的CSS。</p><p id="b9c4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您发现您需要将两个模块应用到同一个元素，并且它们是冲突的，请考虑这是否真的是两个独立的模块。也许可以用一个修改器把它们合并成一个模块？</p><p id="89e3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该规则的最后一个例外是“助手”或“实用工具”类可能会冲突，在这种情况下，您可以放心地考虑使用<code class="fe nz oa ob nl b">!important</code>。我知道，你已经被告知<code class="fe nz oa ob nl b">!important</code>是邪恶的，不应该被使用，但是让我们应用一点细微的差别:主动使用它来确保一个助手类总是赢得一场特异性的战斗是好的。(<a class="ae ll" href="https://cssguidelin.es/#important" rel="noopener ugc nofollow" target="_blank"> Harry Roberts在CSS指南</a>中对这个话题有更多的说明。)</p><h1 id="64e9" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">总之，模块化CSS是掺杂的</h1><p id="35f3" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">让我们简单回顾一下。还记得这个吗？</p><pre class="mq mr ms mt gt nk nl nm nn aw no bi"><span id="bd03" class="my ln jb nl b gy np nq l nr ns">&lt;div class="box profile pro-user"&gt;<br/>  &lt;img class="avatar image" /&gt;<br/>  &lt;p class="bio"&gt;...&lt;/p&gt;<br/>&lt;/div&gt;</span></pre><blockquote class="nt nu nv"><p id="5d8e" class="jy jz lk ka b kb kc kd ke kf kg kh ki nw kk kl km nx ko kp kq ny ks kt ku kv ij bi translated"><em class="jb">类</em> <code class="fe nz oa ob nl b"><em class="jb">box</em></code> <em class="jb">和</em> <code class="fe nz oa ob nl b"><em class="jb">profile</em></code> <em class="jb">之间有什么关系？类别</em> <code class="fe nz oa ob nl b"><em class="jb">profile</em></code> <em class="jb">和</em> <code class="fe nz oa ob nl b"><em class="jb">avatar</em></code> <em class="jb">之间有什么关系？他们有任何关系吗？你应该在</em> <code class="fe nz oa ob nl b"><em class="jb">bio</em></code> <em class="jb">旁边使用</em> <code class="fe nz oa ob nl b"><em class="jb">pro-user</em></code> <em class="jb">吗？类</em> <code class="fe nz oa ob nl b"><em class="jb">image</em></code> <em class="jb">和</em> <code class="fe nz oa ob nl b"><em class="jb">profile</em></code> <em class="jb">会生活在CSS的同一个部分吗？你能在其他地方使用</em> <code class="fe nz oa ob nl b"><em class="jb">avatar</em></code> <em class="jb">吗？</em></p></blockquote><p id="7c0f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们知道如何解决所有这些问题。通过编写模块化CSS并使用适当的命名约定，我们可以生成自文档化的代码:</p><pre class="mq mr ms mt gt nk nl nm nn aw no bi"><span id="0f1e" class="my ln jb nl b gy np nq l nr ns">&lt;div class="l-box m-profile m-profile--is-pro-user"&gt;<br/>  &lt;img class="m-avatar m-profile__image" /&gt;<br/>  &lt;p class="m-profile__bio"&gt;...&lt;/p&gt;<br/>&lt;/div&gt;</span></pre><p id="d658" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看到哪些类彼此相关，哪些不相关，以及如何相关。我们知道在这个组件的范围之外不能使用什么类。此外，我们知道哪些类可以在其他地方自由重用。</p><p id="6c61" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模块化CSS简化了代码，方便了重构。它产生自文档化的代码。它产生了不影响其范围之外的可重用代码。</p><p id="59b5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者换句话说，模块化CSS是可预测的、可维护的和高性能的。</p><p id="e9b6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以重温这个老笑话，并做一点小小的改变:</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oi"><img src="../Images/09cd0fb20e05df3656740c7a2c08b1fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*F1vdJmFlm3COvgFP.png"/></div></div></figure></div><div class="ab cl oj ok hu ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ij ik il im in"><p id="6ebc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lk">原载于2018年9月18日</em><a class="ae ll" href="https://spaceninja.com/2018/09/17/what-is-modular-css/" rel="noopener ugc nofollow" target="_blank"><em class="lk">【spaceninja.com</em></a><em class="lk">。</em></p></div></div>    
</body>
</html>