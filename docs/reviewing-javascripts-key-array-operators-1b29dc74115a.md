# 回顾 JavaScript 的关键数组操作符

> 原文：<https://itnext.io/reviewing-javascripts-key-array-operators-1b29dc74115a?source=collection_archive---------2----------------------->

![](img/cc2e4d4aa4d112355ab415a159328c90.png)

太阳能电池板

*因为我是一个打字脚本专家，所以这篇文章将以打字脚本为重点，但是代码通常也可以与最新版本的 JavaScript 兼容。*

JavaScript 中有很多数组操作符。可能比你想象的要多。我看了一下名单，比我想象的要多。还会经常添加新的操作符，所以熟悉一些有规律的数组操作符(或方法)可能是个好主意。

本文将回顾我所认为的核心 JavaScript 数组操作符。这只是我的观点，我在这里省略的一些操作符可能对一些人更有价值，但是我发现人们经常没有意识到这些数组操作符，尽管它们在功能和语义上非常强大。

我会把这些分成对我有意义的类别。然后，对于每个操作员，我将提供:

*   对其目的的解释
*   它是否**就地修改了数组**
*   一个关于[https://stackblitz.com](https://stackblitz.com)的工作代码示例(如果你喜欢，你可以随意摆弄！)

*注意数组的索引是 0，但是我将从* `*array[0]*` *得到的元素称为第一个元素***`*array[1]*`*称为第二个元素* *。我不会引用第 0 个元素。***

# **循环**

**对于不熟悉的人来说，迭代是移动一组项目的过程。我的 [map vs for loop](https://medium.com/@ExplosionPills/map-vs-for-loop-2b4ce659fb03) 文章有更多关于什么是迭代以及它如何工作的细节。出于我们的目的，这些操作符在数组的每个元素上运行回调函数或谓词。**

**迭代器的谓词通常有三个参数:**

*   **当前一轮迭代的数组元素**
*   **此数组元素的索引**
*   **您对其调用运算符的整个数组**

**有些谓词的参数比这个多，但是不用担心。如果出现这种情况，我会具体说明。**

## **`map`**

**`map`操作符遍历一个数组，并在数组的每个元素上应用 or *投射*谓词，并返回一个相同长度的新数组，该数组由每个元素的谓词函数的返回值组成。**

**`map`返回一个*新的*数组，所以不用修改原来的数组就可以得到它的结果。**

**您将经常使用`map`以某种新的格式获得原始数据的表示。例如，您可能有一个从数据库中获得的姓名列表。您可能希望以全部大写的形式显示这些名称，但是您不知道它们最初是如何存储的。您可以使用`map`来获得每个元素的全部大写表示。**

**拥有一个对象数组并希望获得每个对象的特定属性也很常见。这通常被称为“挑选”，一些库有一个`pluck`操作符。**

**请记住，传递给`map`的谓词函数可能会返回一些东西。如果你不返回任何东西，你可能想使用`forEach`或其他东西来代替，但是请参阅我的 [map vs. for loop](https://medium.com/@ExplosionPills/map-vs-for-loop-2b4ce659fb03) 文章来获得更多关于避免这种事情的细节。**

**最后，`.map`谓词函数的第二个参数是数组元素的索引，所以会是`0`、`1`、`2`等。除了可能用于日志记录之外，我真的没有使用它的例子，所以我将在这里省略它，因为它是一个可能的反模式。**

## **减少**

**`reduce`与`map`相似，它遍历源数组并返回一个新值。不同之处在于`reduce`的谓词首先接受一个额外的参数。这个论点被称为一个*累加器*。以下参数与 map 相同:当前数组元素、索引和整个数组。这个谓词通常被称为一个**归约器**函数。Redux 用户可能对这个概念比较熟悉。**

**如果你想从你的收藏中创造价值，那么`reduce`很有用。从谓词返回累加值，该值将成为下一个谓词调用的*累加器*参数。**

**`reduce`最简单的例子是求和。**`reduce`与`map`的一个重要区别在于，对谓词的第一次调用接受第一个和第二个数组元素。在下面的示例中，谓词被调用了三次，而不是四次:****

1.  **acc 将为 1，num 将为 2**
2.  **acc 将是 3 (1 + 2)，num 将是 3**
3.  **acc 将是 6 (3 + 3)，num 将是 4**
4.  **返回最终值 10 (6 + 4)**

**在下面的例子中，我们将一个起始值传递给`reduce`。这样做时，将为每个数组元素调用谓词，累加器从提供的值开始:**

1.  **acc 将为 0(初始值)，num 将为 1**
2.  **acc 将为 1，num 将为 2**
3.  **acc 将是 3 (1 + 2)，num 将是 3**
4.  **acc 将是 6 (3 + 3)，num 将是 4**
5.  **返回最终值 10 (6 + 4)**

**如果数组元素的类型不同于累加器的类型，您可能需要提供一个初始值。我们可以用我们的采摘例子来说明这一点:**

**如果我们没有提供初始值，代码将首先尝试执行`{ name: 'Andrew', stars: 50 } + 20`，这将导致`[object Object]20`。**

**从`reduce`返回的结果可以是任何东西。我们经常希望它是一个物体:**

**也没有理由`reduce`不能返回一个数组…即使是一个长度比原始数组长的数组。**

## **reduceRight**

**`reduceRight`与`reduce`相同，只是它从数组的末尾开始，向后迭代。这相当于反转数组，然后使用`reduce`。**

**下面的例子和前面的例子一样，除了多莉的宠物将首先出现在输出数组中。**

# **询问**

**我要介绍的下一类数组操作符是我称之为*查询*操作符的。**查询操作符也是迭代操作符**，因此它们遵循相同的规则，即接受带有特定参数的谓词。查询操作符返回原始数组的一个子集*或*一些基于查询内容的值。**

**所有的查询操作符都可以用`reduce`来完成，但是许多操作符名称有更好的语义并且更方便。**

## **排序**

**【 is a bit of an old school operator that reorders the array according to the provided predicate. 【 ***修改原数组*** 。如果你想得到一个新的排序后的数组而不修改原来的数组，你可以使用 concat 操作符，例如`const sortedArray = [...originalArray].sort()`。这是可行的，因为即使`sort`就地更新数组，它也返回排序后的数组。**

**`sort`的谓词函数不同于其他操作符，因为它只接受两个参数:第一个元素用于比较，第二个元素用于比较。`sort`使用的算法是实现相关的，因此其时间和空间复杂度无法保证。如果您计划在大型阵列上使用`sort`，请记住这一点。**

**通过这种方式，`sort`不一定按顺序迭代每个元素，因为它将取决于排序算法。然而，它仍然必须对每个元素至少迭代一次，排序通常是一个查询操作符，所以我将它包含在这个类别中。**

**`sort`的谓词是可选的。如果不提供，它会将元素作为字符串进行比较，并根据它们的 UTF-16 代码单元值对它们进行排序。 ***记住这一点:*** 默认比较的不是数值。我们可以看到这是多么棘手:**

**你可能希望数字被排序为`1, 2, 4, 10`等…相反，它们被视为字符串并被排序为`1, 10, 2, 20`等…**

*****谓词为*** `***sort***`应返回一个数。**

*   **如果它返回一个负数，第一个元素将被放置在比第二个元素更早的索引处。**
*   **如果它返回一个正数，第二个元素将被放置在比第一个元素更早的索引处。**
*   **如果它返回 0，则第一个和第二个元素保留其当前位置，但它们仍将根据其他值进行排序。**

**还要注意的是`sort` ***跳过了未定义的值*** ，它们被放在数组的末尾，没有为它们调用谓词。**

**由于排序是基于正值和负值，这使得对数字进行排序非常容易，因为您只需减去它们:**

**对其他值进行排序时，可以比较第一个和第二个元素。通常，如果第一个元素出现在第二个元素之前，您将返回`-1`，如果第二个元素出现在第一个元素之前，您将返回`1`，但是这些可以是任何负数或正数。如果值匹配，也可以返回`0`，但是这对于排序来说并不重要，所以经常被忽略。**

**您可以使用典型的`<`和`>`来比较日期和字符串:**

**我总是忘记到底是`-1`还是`1`会使第一个元素出现在第二个元素之前还是之后，但是这里有一个相当简单的记忆方法:-1 出现在数字行的 1 之前。同样，如果谓词返回-1，第一个元素将首先出现。否则，第二个元素将首先出现。**

## **过滤器**

**您可以使用`filter`根据过滤谓词获得一个元素数组。如果*所有的*元素都通过了过滤器，那么你得到的数组最多和原始数组一样长，但是它通常会比原始数组短。它可能返回一个空数组。`filter`不修改原数组，保留原数组中元素的相对顺序。**

**从概念上讲，这将从数组中过滤掉您不想要的元素。**

**传递给`filter`的谓词函数应该返回一个布尔值。如果是`true`，则元素保留在输出数组中。如果是`false`，则不会被保留，也不会在输出数组中。**

**使用`filter(Boolean)`是过滤掉虚假元素的常用机制。这将与`filter(value => !!value)`相同。**

**当然，你可以提供任何你想要的功能。**

**`startDate < new Date('2016-01-01')`是布尔型。**

**如果没有数组元素通过谓词，您将得到一个空数组。**

**谓词也接受一个索引和原始数组作为参数。**

## **一些**

**`***some***` ***返回布尔值。*****

**`some`在功能上等同于`array.filter(predicate).length > 0`。您可以使用`some`来确定数组中至少有一个元素满足某些条件。**

**`some`的一个优点是，如果遇到谓词为`true`的元素，它将短路，而不必对任何剩余的数组值运行谓词。**

## **包含**

**`***includes***` ***返回布尔值。*****

**`includes`类似于`some`,只是它不带谓词。它需要一个值。它的功能与`array.some(val => val === providedValue)`相同。请记住，在比较对象时，`{} != {}`因为对象是通过它们的引用进行比较的。如果你想查看一个数组是否有一个元素是匹配某些值的对象，使用`some`。**

## **每个**

**`***every***` ***返回一个布尔值*****

**`every`类似于`some`，除了只有当*的每个*数组元素都满足谓词时，它才会返回`true`。**

**功能上相当于`array.filter(predicate).length === array.length`。**

**与`some`类似，`every`如果遇到从谓词返回`false`的元素就会短路。**

**如果你不去想太多，你可能会认为`array.some(predicate) === !array.every(predicate)`，但这是 ***不是真的*** 。比如`[false].some(Boolean)`和`[false].every(Boolean)`都为假，`[true].some(Boolean)`和`[true].every(Boolean)`都为真。它们以相似的方式工作，但是它们检查不同的东西。**

## **查找和查找索引**

**`find`返回数组中的单个元素。我在标题中加入了`findIndex`，因为除了`find`返回数组元素本身而`findIndex`返回元素所在的索引之外，它们的工作完全相同。从现在起，我将只提及`find`，但我所说的一切也将适用于`findIndex`。**

**`find`像其他迭代操作符一样接受一个谓词。如果谓词返回一个真值，`find`将短路并返回当前数组元素。否则，它将移动到下一个数组元素。如果没有元素匹配(对谓词的所有调用都返回 falsey 值)，`find`将返回`undefined`。**

****注意** `**find**` **返回第一个匹配元素***，即使有多个匹配元素。如果你想得到所有匹配的元素，使用`filter`。如果你想对找到的值做一些等式检查，使用`some`。***

## ***索引 Of***

***`indexOf`不带谓语。这有点像是`findIndex`和`includes`的融合。它将返回与提供的值匹配的第一个元素的索引。记住，比较对象的时候，`{} != {}`。如果你需要从一个对象数组中获取一个值，你可能需要`findIndex`。***

***还有一个`lastIndexOf`将返回与提供的值匹配的最后一个元素*。`find`和`findIndex`没有模拟。如果您想要最后一个匹配的元素，首先使用`reverse`。****

# **转换**

**转换是通常根据一些公共功能修改数组的操作符。并不是所有的转换都会修改原始数组(下面我会指出是哪些转换)。许多这些都可以用`reduce`来代替，但是下面的方法更加语义化和方便。**

## **反向**

**这只是颠倒了数组。它获取最后一个数组元素并将其移动到第一个位置，获取倒数第二个数组元素并将其移动到第二个位置，依此类推。原始数组的第一个元素将被移动到最后一个位置。**

**您可以使用 spread 操作符来获得一个单独的反向数组，如`reversedArray = [...array].reverse()`所示。`reverse`返回反转的数组，即使它也修改原始数组。**

## **加入**

**Join 遍历每个数组元素，返回其字符串表示，并在每个数组值之间放置一些分隔符。默认情况下，分隔符是逗号(没有空格)。**

**这与 string `split`操作符相反，它通过沿着提供的分隔符分割字符串来创建数组，其中每个数组元素都是分隔符之间的子字符串。**

**这对字符串数组很有用。如果你有一个对象数组，你可以首先使用`map`映射到一个字符串数组并连接它。**

## **推送、弹出、移动和取消移动**

**这些运算符专门用于在数组中添加和删除元素。这些都会修改数组本身。**

**`push`将一个元素添加到数组的末尾(添加的值成为最后一个元素*)。如今，`push`大概没有 spread 那么普遍了。使用`array.push(value)`是`[...array, value]`的非不可变版本。`push`返回新数组的长度。您可以一次推送多个值。***

**`pop`删除数组末尾的元素(数组的最后一个元素*)。`pop`修改原始数组并返回移除的值。***

**`shift`与`pop`相似，只是它从数组中移除了第一个元素*。它就地修改数组并返回移除的值。***

**`unshift`与`push`类似，只是在数组的开头添加了一个元素(添加的值成为第*个*元素)。与`push`类似，您可以使用 spread: `[value, ...array]`进行不可变的不移位操作。您可以一次取消转移多个值。不要被这个操作符名称中的 *un* 所迷惑:它向数组中添加一个值。和`push`一样，`unshift`返回更新后数组的长度。**

## **薄片**

**`slice`取出数组的一部分或一大块。`slice`最多采用两个参数:切片起始索引和切片结束索引*到*。**

**两个参数都是可选的。如果不提供参数，`slice`将返回数组的一个浅层副本，就像使用`[...array]`一样。起始索引处的元素将作为切片的一部分返回。如果不包括结束索引，将包括从开始索引到数组结尾的所有元素。如果您提供一个结束索引，它将*而不是*包含在数组中。**

**您可以使用`slice`通过结合 spread 来帮助您将元素不变地添加到数组中。**

## **拼接**

**我会放弃使用`splice`，而使用带有 spread 的`slice`。`splice`与`slice`相似，它返回原始数组的一部分或一大块。但是，您也可以选择在移除切片的位置插入新元素。**

**我提到`splice`,因为我认为在不变性作为一个概念真正出现之前，它更常用，所以我在这里不提供例子。如果你想从一个数组中删除元素并在适当的位置添加元素，使用 spread 和`slice`来代替。我们可以修改上面的例子，通过改变我们使用的切片来插入`Bryan`,其中`Andrew`是。**

**在我看来，这也更容易看到数组是如何被修改的。**

# **关于不变性**

**不变性已经成为 JavaScript 开发中的核心概念。通常，您可以创建一个作为源数组副本的新数组，而不是修改原始数组。这允许您获得原始数组的新表示，而无需实际修改它。不变性在组件驱动的框架中是有用的，比如 React 和 Angular，带有变化检测的概念。更改现有对象不会触发用于比较的更改检测。相反，您可以用修改后的元素创建一个新数组。**

**一些例子包括:**

*   **`array.push(value)`->-`[...array, value]`**
*   **`array.pop()`->-`array.slice(array.length — 1)`**
*   **`array.shift()`->-`array.slice(1)`**
*   **`array.unshift(value)`->-`[value, ...array]`**

****注意**即传播算子，`map`等。艾尔。创建原始数组的*浅*副本。也就是说，虽然您可能无法修改原始数组，但如果数组元素是对象，您可以修改它们。**

**你应该在每一层编写不变的代码，在需要的地方创建副本。**

**在某些情况下，创建对象(包括数组)的深层副本可能会很方便。您可以使用诸如 immer 或 lodash 之类的工具来帮助实现这一点，但是使用 spread 操作符是创建数组和对象的浅层副本的一种简单的本机方法。**

# **结论**

**除了我在这里列出的之外，还有很多数组操作符，我建议您查看 MDN 关于数组的文档，看看是否有您需要的或者可以用于您的给定情况的操作符。**

**我希望这篇文章已经让一些人更加熟悉您可以使用的数组/集合的常见用例的一些优秀选项。还有其他优秀的库，如 lodash 和 RxJS，它们提供了这些操作符和许多更有用的操作符，用于处理其他类型的集合，包括数组。**