<html>
<head>
<title>RxReduce: Reactive State Container Architecture — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxReduce:反应式状态容器架构—第2部分</h1>
<blockquote>原文：<a href="https://itnext.io/rxreduce-reactive-state-container-architecture-part-2-62a9b9f4e441?source=collection_archive---------2-----------------------#2018-07-15">https://itnext.io/rxreduce-reactive-state-container-architecture-part-2-62a9b9f4e441?source=collection_archive---------2-----------------------#2018-07-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f6825badcac20565f51ef873854c39d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RSK0PCA2IEzSuhnJfZ1hCw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">RxReduce:一种反应式状态容器架构</figcaption></figure><p id="b79c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如我们在“<a class="ae la" href="https://medium.com/@thibault.wittemberg/rxreduce-reactive-state-container-architecture-part-1-940480a0f838" rel="noopener"> RxReduce:一个反应式状态容器架构第1部分</a>”中所看到的，<strong class="ke ir">状态</strong>是应用程序中的核心问题。我强烈邀请你看看这第一篇文章。到目前为止，我们还没有介绍反应式编程的概念，以及它如何解决我在传统的<strong class="ke ir">状态容器</strong>实现中遇到的一些问题。我们将看到RxSwiftCommunity的开源框架<a class="ae la" href="https://github.com/RxSwiftCommunity/RxReduce" rel="noopener ugc nofollow" target="_blank"> RxReduce </a>如何帮助您以一种被动的方式处理<strong class="ke ir">状态</strong>、其突变以及与副作用相关的异步工作。</p><h1 id="2fed" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">担忧</h1><ul class=""><li id="c689" class="lz ma iq ke b kf mb kj mc kn md kr me kv mf kz mg mh mi mj bi translated">存储使用观察者模式:<strong class="ke ir">存储</strong>的职责之一是将<strong class="ke ir">状态</strong>突变传播给应用程序的其余部分。为此，通常使用一个<strong class="ke ir">观察器</strong>模式，这样观察器将被通知新的<strong class="ke ir">状态</strong>值。在传统的方法中，观察者将在<strong class="ke ir">存储</strong>中注册/注销自己，这意味着要处理大量的样板代码。</li><li id="7584" class="lz ma iq ke b kf mk kj ml kn mm kr mn kv mo kz mg mh mi mj bi translated">副作用:在<a class="ae la" href="https://medium.com/@thibault.wittemberg/rxreduce-reactive-state-container-architecture-part-1-940480a0f838" rel="noopener">第1部分</a>中，我们看到副作用(主要是异步工作)不能由<strong class="ke ir">存储/减少器</strong>处理。这是<strong class="ke ir">状态</strong>再现性和可测试性的必要条件。但是众所周知，副作用是很常见的，而且在任何应用中都是不可避免的。使用一个只说“嗯，你应该做状态突变之外的副作用”的架构可能会有点令人沮丧，并且会扼杀实现它的意愿。</li></ul><h1 id="572b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">RxReduce</h1><p id="47eb" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">RxReduce 诞生于我愿意在原生移动应用中测试像<a class="ae la" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>这样的模式。我对MVC、MVP和MVVM有着重要的经验，但我对国家管理很好奇。</p><p id="5d72" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">显然，我已经在更传统的架构中处理过状态。最终，我拥有了低级别的层，比如“<strong class="ke ir">服务</strong>层，通过RxSwift Observables暴露了我的<strong class="ke ir">模型</strong>。这是一个好的开始，但是Model并不是真正的状态，它分布在我的所有服务中:对于保证全球一致性来说并不理想。</p><p id="7b06" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我必须进一步理解<strong class="ke ir">状态</strong>管理，但目的是解决之前对观察者模式和副作用的担忧。</p><p id="6782" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae la" href="https://github.com/RxSwiftCommunity/RxReduce" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> RxReduce </strong> </a>:</p><ul class=""><li id="7f17" class="lz ma iq ke b kf kg kj kk kn ms kr mt kv mu kz mg mh mi mj bi translated">提供一个通用的<strong class="ke ir">存储库</strong>，可以处理所有类型的<strong class="ke ir">状态。</strong></li><li id="9143" class="lz ma iq ke b kf mk kj ml kn mm kr mn kv mo kz mg mh mi mj bi translated">通过反应机制暴露<strong class="ke ir">状态</strong>突变。</li><li id="0618" class="lz ma iq ke b kf mk kj ml kn mm kr mn kv mo kz mg mh mi mj bi translated">提供一种简单/统一的方式，通过<strong class="ke ir">动作同步和异步地改变<strong class="ke ir">状态</strong>。</strong></li></ul><p id="d4b6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在本文的其余部分，我假设您熟悉反应式编程的基本知识，尤其是RxSwift。如果你不是，网上有很多很好的资源👌。</p><h1 id="aa52" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">RxReduce术语</h1><p id="aa5f" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">你可以在这里浏览回购:<a class="ae la" href="https://github.com/RxSwiftCommunity/RxReduce" rel="noopener ugc nofollow" target="_blank">https://github.com/RxSwiftCommunity/RxReduce</a>。</p><p id="e906" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> RxReduce </strong>兼容CocoaPods和Carthage。它是一个非常小的库，包含三个协议，一个类和两个类型别名:</p><ul class=""><li id="0591" class="lz ma iq ke b kf kg kj kk kn ms kr mt kv mu kz mg mh mi mj bi translated"><strong class="ke ir"> StoreType </strong>:描述什么应该是<strong class="ke ir">存储</strong>的协议。尽管它是一个公共协议，但是您不需要实现自己的协议，因为RxReduce提供了一个默认的<strong class="ke ir">存储</strong>。</li><li id="a1d8" class="lz ma iq ke b kf mk kj ml kn mm kr mn kv mo kz mg mh mi mj bi translated"><strong class="ke ir">状态</strong>:一个空协议，用来标识<strong class="ke ir">存储</strong>中的<strong class="ke ir">状态</strong>，这里不需要特别实现。</li><li id="07cf" class="lz ma iq ke b kf mk kj ml kn mm kr mn kv mo kz mg mh mi mj bi translated"><strong class="ke ir">动作</strong>:用于标识<strong class="ke ir">店</strong>调度功能中<strong class="ke ir">动作</strong>的协议。只需要实现一个函数:“toAsync()”，但是RxReduce为此提供了默认的实现，这里没有什么特别的(解释将在“条件一致性是魔术”一章中给出)。</li><li id="566e" class="lz ma iq ke b kf mk kj ml kn mm kr mn kv mo kz mg mh mi mj bi translated"><strong class="ke ir"> Store </strong>:代表默认<strong class="ke ir"> Store </strong>的类，能够在<strong class="ke ir">reducer</strong>和<strong class="ke ir">middleware</strong>内部调度同步或异步<strong class="ke ir">动作</strong>。一个<strong class="ke ir">存储</strong>暴露突变的<strong class="ke ir">状态</strong>。你的应用程序中可以有几个<strong class="ke ir">商店</strong>，每个商店负责一个专用的<strong class="ke ir">状态</strong>，但是为了简单起见，你应该考虑处理一个唯一的<strong class="ke ir">商店</strong>和<strong class="ke ir">状态</strong>跟踪。</li><li id="a6c3" class="lz ma iq ke b kf mk kj ml kn mm kr mn kv mo kz mg mh mi mj bi translated"><strong class="ke ir"> Reducer </strong>:一个纯泛型函数的typealias，执行一个<strong class="ke ir">动作</strong>，一个<strong class="ke ir">状态</strong>并返回一个新的<strong class="ke ir">状态</strong>。您必须在<strong class="ke ir">存储</strong>初始化中提供至少一个<strong class="ke ir">减速器</strong>。当然，也可以增加几个<strong class="ke ir">减速器</strong>，这样你就可以分开责任。<strong class="ke ir">将<strong class="ke ir">动作</strong>分派到<strong class="ke ir">库</strong>时，依次应用减速器</strong>。</li><li id="2af7" class="lz ma iq ke b kf mk kj ml kn mm kr mn kv mo kz mg mh mi mj bi translated"><strong class="ke ir">中间件</strong>:一个纯泛型函数的类型别名，执行<strong class="ke ir">动作</strong>，执行<strong class="ke ir">状态</strong>并返回… nothing。基本上你可以把它看成一个没有变异能力的<strong class="ke ir">减速器</strong>。当调度一个<strong class="ke ir">动作</strong>到<strong class="ke ir">存储</strong>时，在<strong class="ke ir">减速器</strong>之前调用。例如，中间件对日志记录很有用。</li></ul><h1 id="14d5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">状态驱动你的用户界面</h1><blockquote class="mv mw mx"><p id="b063" class="kc kd my ke b kf kg kh ki kj kk kl km mz ko kp kq na ks kt ku nb kw kx ky kz ij bi translated">根据定义，状态是应用程序的核心！(<a class="ae la" href="https://medium.com/@thibault.wittemberg/rxreduce-reactive-state-container-architecture-part-1-940480a0f838" rel="noopener"> RxReduce:反应式状态容器架构第1部分</a>)</p></blockquote><p id="1005" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一个应用程序只是在给定时间的一个状态的反映。关于这一点，这一章的标题不是巧合。</p><p id="47ee" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用<strong class="ke ir"> RxSwift驱动</strong>是RxReduce将<strong class="ke ir">状态</strong>突变暴露给外界，尤其是UI的方式。提醒一下，<strong class="ke ir">驱动</strong>是一个不会失败的可观察对象，并且只在主线程上发出事件，这对于<strong class="ke ir">状态</strong>是有意义的。</p><p id="4046" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">倾听<strong class="ke ir">状态</strong>突变引出了一些基本问题:</p><ul class=""><li id="e7f8" class="lz ma iq ke b kf kg kj kk kn ms kr mt kv mu kz mg mh mi mj bi translated">如果我不想被发生在我不感兴趣的<strong class="ke ir">状态</strong>的一部分上的<strong class="ke ir">状态</strong>突变通知，该怎么办？</li><li id="025b" class="lz ma iq ke b kf mk kj ml kn mm kr mn kv mo kz mg mh mi mj bi translated">如果<strong class="ke ir">状态</strong>被一个严格相等的新值代替会怎样？通知机制会触发不必要的UI更新吗？</li></ul><p id="ada0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这需要一点解释😀。假设我们的<strong class="ke ir">状态</strong>是一个<strong class="ke ir">结构</strong>表示:</p><ul class=""><li id="0347" class="lz ma iq ke b kf kg kj kk kn ms kr mt kv mu kz mg mh mi mj bi translated">应用程序的当前用户。</li><li id="95ba" class="lz ma iq ke b kf mk kj ml kn mm kr mn kv mo kz mg mh mi mj bi translated">用户的联系人列表。</li></ul><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="f32a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如你所见，那些类型是"<strong class="ke ir">值类型</strong>，这是保证<strong class="ke ir">状态</strong>不变性和一致性的一个要求。它们也是“<strong class="ke ir">等价的</strong>”。这将允许RxReduce知道两个连续的<strong class="ke ir">状态</strong>是否相同，从而避免不必要的通知。这回答了我们的一个问题👍。</p><p id="64b1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> AppState </strong>也符合<strong class="ke ir">状态</strong>。这是由<strong class="ke ir">商店</strong>处理的要求。</p><p id="0f06" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面的“<strong class="ke ir"> dispatch() </strong>函数属于<strong class="ke ir"> RxReduce </strong>提供的默认<strong class="ke ir"> Store </strong>:</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="c533" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">每次<strong class="ke ir">存储器</strong>接收到一个<strong class="ke ir">动作</strong>:</p><ul class=""><li id="da87" class="lz ma iq ke b kf kg kj kk kn ms kr mt kv mu kz mg mh mi mj bi translated"><strong class="ke ir">动作</strong>被转换成异步动作(参见“条件一致性是魔法”一章)。</li><li id="8225" class="lz ma iq ke b kf mk kj ml kn mm kr mn kv mo kz mg mh mi mj bi translated">注册的<strong class="ke ir">减速器</strong>列表应用于<strong class="ke ir">状态</strong>。</li><li id="4189" class="lz ma iq ke b kf mk kj ml kn mm kr mn kv mo kz mg mh mi mj bi translated">新的<strong class="ke ir">状态</strong>取代旧的状态。</li></ul><p id="0bba" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们看两个动作的例子:</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="f266" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里没有火箭科学… <strong class="ke ir">动作</strong>只是嵌入改变<strong class="ke ir">状态</strong>所需的东西，没有业务逻辑。</p><p id="b5f1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里有两个<strong class="ke ir">减速器</strong>的例子:</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="e69f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">每个<strong class="ke ir">减速器</strong>处理其关心的<strong class="ke ir">动作</strong>。它允许将<strong class="ke ir">状态</strong>突变分割成逻辑单元。</p><h1 id="1afa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">需要关注你的状态？用镜片！</h1><p id="5dcb" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated"><strong class="ke ir">lens</strong>是函数式编程中的一项技术，它将解决剩下的问题:“<strong class="ke ir">如果我不想被我不感兴趣的部件上发生的状态突变通知，该怎么办？</strong>”</p><p id="97fe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">关于<strong class="ke ir">镜头</strong>的几个资源:</p><ul class=""><li id="884b" class="lz ma iq ke b kf kg kj kk kn ms kr mt kv mu kz mg mh mi mj bi translated">克里斯·埃德霍夫的《雨燕》中的镜头<a class="ae la" href="http://chris.eidhof.nl/post/lenses-in-swift/" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="5238" class="lz ma iq ke b kf mk kj ml kn mm kr mn kv mo kz mg mh mi mj bi translated"><a class="ae la" href="https://broomburgo.github.io/fun-ios/post/lenses-and-prisms-in-swift-a-pragmatic-approach/" rel="noopener ugc nofollow" target="_blank">埃尔维罗罗卡</a>Swift中的镜头和棱镜。</li></ul><p id="0900" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">简而言之，镜头允许你聚焦于值类型的一个子部分。作为一种函数式编程技术，它使用函数来实现这一点。让我们在我们的模型上试试这个:</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="a197" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">RxReduce使用完全相同的技术在<strong class="ke ir">商店</strong>中公开一个<strong class="ke ir">状态</strong>。您只需调用"<strong class="ke ir"> state() </strong>"函数，用闭包聚焦您想要监听的子状态:</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="743d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个函数解决了我们的两个问题:</p><ul class=""><li id="d9ee" class="lz ma iq ke b kf kg kj kk kn ms kr mt kv mu kz mg mh mi mj bi translated">如果两个连续的<strong class="ke ir">状态</strong>相等，则不会触发新事件(由于“<strong class="ke ir"> distinctUntilChanged() </strong>”)。</li><li id="214f" class="lz ma iq ke b kf mk kj ml kn mm kr mn kv mo kz mg mh mi mj bi translated">它允许不监听整个<strong class="ke ir">状态</strong>。</li></ul><p id="0a10" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当然，你会注意到<strong class="ke ir">状态</strong>是通过<strong class="ke ir">驱动</strong>公开的😀👌(记住:<strong class="ke ir">状态驱动你的UI </strong>)。</p><p id="7cec" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">需要说明的是，<strong class="ke ir"> RxReduce </strong>也提供了这个函数的一个无参数实现，你会得到一个<strong class="ke ir">驱动</strong>用于整个<strong class="ke ir">状态</strong>。</p><p id="3490" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">RxReduce的典型工作流如下所示:</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="b31d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">条件一致性是神奇的</h1><p id="63ed" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">还有一个问题需要解决……副作用。</p><p id="37ba" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在函数式编程中，副作用是使用I/O可以改变状态的所有东西。它可以是网络、持久性、文件访问……有副作用，函数可以根据系统的状态而不可预测。当一个函数没有副作用时，我们可以随时执行它，给定相同的输入，它将总是返回相同的结果。</p><p id="f543" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在单向数据流架构中，我们将尝试将副作用隔离出黄金路径:<strong class="ke ir">视图- &gt;动作- &gt;存储- &gt;缩减器- &gt;状态- &gt;视图</strong>。</p><p id="8467" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Redux有一个解决方案:<strong class="ke ir">动作创建者</strong>。一旦异步作业完成，它将发出一个<strong class="ke ir">动作</strong>并将其分派到<strong class="ke ir">存储器</strong>。</p><p id="6f6e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">嗯，我看着很熟悉…这不正是RxSwift中的一个可观察的&lt;<strong class="ke ir">动作</strong> &gt;吗？是不是说<strong class="ke ir"> Store </strong>的"<strong class="ke ir"> dispatch() </strong>"函数不应该把一个<strong class="ke ir">动作</strong>作为参数，而是一个可观察的&lt; <strong class="ke ir">动作</strong> &gt;？</p><p id="b8a9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">嗯…是也不是！事实上两者都可以，因为有时我们需要同步突变，有时需要异步突变。</p><p id="a73e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最能干的人最不能干。同步作业只是在作业开始时结束的异步作业👍。RxReduce提供了一种将同步动作转换为异步动作的方法:</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="5819" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">非常容易。如果你还记得“<strong class="ke ir"> dispatch() </strong>”函数的实现，它做的第一件事就是调用“<strong class="ke ir">action . toasync()</strong>”……现在你有了解释。</p><p id="4d67" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这很好，但这只是解决方案的一部分，它允许<strong class="ke ir">商店</strong>调度同步动作，因为它们是异步的。真正的异步动作呢？</p><p id="9454" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最近，Swift 4.1引入了条件一致性。如果你不熟悉这个概念:<a class="ae la" href="https://twittemb.github.io/swift/protocol%20oriented%20programming/pattern/2018/04/02/a-glance-at-conditional-conformance/" rel="noopener ugc nofollow" target="_blank">条件一致性一瞥</a>。</p><p id="8448" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">基本上，只有当相关的内部类型也符合协议时，它才允许泛型类型符合该协议。让我们将此应用于可观察的:</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="892c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这意味着一个可观察的&lt;<strong class="ke ir">动作</strong> &gt;也在<strong class="ke ir">动作</strong>中，前提是元素本身是一个<strong class="ke ir">动作</strong>。相当整洁。</p><p id="d00c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">商店将分派一个<strong class="ke ir">动作</strong>，无论它是同步的还是异步的……无缝地。</p><p id="80c9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">事实上，加载一个用户应该是这样的:</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6238" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你会在RxReduce repo中找到一个完整的<a class="ae la" href="https://github.com/RxSwiftCommunity/RxReduce/tree/master/RxReduceDemo" rel="noopener ugc nofollow" target="_blank">演示应用</a>。它结合使用了MVVM和状态容器。</p><h1 id="65b5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="6707" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">我认为<strong class="ke ir">状态容器架构</strong>是对移动软件工程的巨大贡献。它迫使你问自己应用程序的状态应该是什么，如何改变它，如何隔离I/o。它是对只面向视图的传统模式的一个很好的补充。</p><p id="f4e5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">RxReduce利用函数式反应式编程来解决可能会令您反感的问题。</p><p id="1234" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你想了解更多关于RxReduce的信息，欢迎访问<a class="ae la" href="https://github.com/RxSwiftCommunity/RxReduce" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>并投稿👍。</p><p id="4ea4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我希望你喜欢这个话题。</p><p id="6730" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">敬请关注。</p></div></div>    
</body>
</html>