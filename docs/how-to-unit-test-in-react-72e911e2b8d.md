# 如何在 React 中进行(单元)测试

> 原文：<https://itnext.io/how-to-unit-test-in-react-72e911e2b8d?source=collection_archive---------0----------------------->

本指南解释了什么是单元测试，为什么需要单元测试，以及从小型到大型 React 应用程序的最佳实践。

# 什么是单元测试

单元测试是软件测试的一个层次**测试**，其中测试软件的单个单元/组件。在 React 世界中，这意味着测试一个单独的 React 组件或纯函数。

# 我为什么要测试

测试对于保证稳定的应用程序至关重要。尤其是单元测试可能是测试中最重要的部分。普遍的共识是，我们所有测试的 70%应该是单元测试，而且理由非常充分。

1.  它们运行速度非常快，让我们能够很快了解我们的应用程序中是否有任何问题。
2.  它们以最少的努力带来巨大的价值，因为与其他更复杂的测试相比，它们非常容易编写。
3.  如果他们失败了，很容易知道错误在哪里，因为他们只关注代码的小单元。

**注:** *功能*、*集成*或*端到端*测试用于一次测试多个单元/组件。他们通常很慢，也很难确定问题出在哪里。

# React 单元测试的先决条件

为了进行单元测试，我们将使用两个非常流行的库，即 [jest](https://jestjs.io/) 和 [enzyme](http://airbnb.io/enzyme/) 。Jest 是一个由 facebook 编写的库，在过去几年中变得非常流行(你也可以使用其他库，如 mocha 或 chai)。Jest 将帮助我们做所有的断言，enzyme 将帮助我们在测试模式下渲染 React 组件。在接下来的几节中，您将看到这两者的实际应用。

# 我们的第一个测试

我们的第一个测试将非常简单。我们将测试一个组件，它的唯一目的是呈现一个包含一些文本的段落。

这里我们唯一想测试的是传递给这个组件的子组件被呈现在一个

标签中。让我们为此写一个测试。

这是上面测试中发生的情况:

a.首先，在第 10 行，我们根据文档为 react 16 配置酶。这是我们在每次使用酶的测试中必须做的事情，所以稍后我们将在辅助函数中添加它。

b.我们使用 enzyme 的浅层渲染器来渲染段落组件。浅层渲染器非常适合单元测试，因为它不渲染任何子组件，从而允许我们将测试集中在一个组件上(这将在下面的测试中变得清楚)。那么我们的包装常量将包含这个组件的所有节点。

c.使用 enzyme 的 find 函数，我们正在寻找一个

标签(第 15 行),然后我们断言只找到了一个标签(第 16 行),这是我们期望段落组件做的。

d.最后(第 17 行)，使用 enzyme 的 text 函数，它返回一个呈现文本的字符串，我们断言

标签内的文本与传递的子元素相同。

正如您所看到的，在短短几行代码中，我们测试了一个简单的组件，并使我们的代码更加健壮。

# 测试稍微复杂一点的组件

在我们的第二个测试中，我们将测试一个比上面的简单组件稍微复杂一点的组件。这次我们将测试一个列表组件。

上面的列表组件接受一个项目数组并呈现它们。如果数组为空，则呈现一条空列表消息。组件的测试如下:

**注意:**我们已经在一个帮助函数中移动了酶设置，我们在任何测试之前导入并调用该函数。

这是上面测试中发生的情况:

a.在第一个测试中(第 13 行),我们用一个空的项目数组来呈现列表组件。然后，我们断言(第 16 行),在这种情况下，呈现的段落组件的子组件等于空列表消息。

b.在第二个测试中(第 19 行),我们用一个包含 3 个条目的数组来呈现列表组件。然后我们使用 css 选择器找到所有这些条目(第 23 行)。我们断言找到了 3 项(数组长度)(第 24 行)。最后，我们测试第一个项目的文本是“购物”,即项目的主体。

需要注意的是，在上面的测试中，我们在两种不同的情况下测试了组件中呈现的文本(第 16 行和第 25 行)。在第一种情况下，我们使用`.props().children`，在第二种情况下，我们使用`.text()`。这是因为`text`函数只能用于 html 元素(即`div`、`p`)，而不能用于 React 组件(如`Paragraph`)。另外，请注意，因为我们使用的是 shallow，所以渲染在段落组件处停止，并且不渲染段落的实现，也就是说，我们在树中永远看不到`<p>`标签。我们只看到以下内容:

```
<Paragraph>
  This list is empty
</Paragraph>
```

**Pro 提示:**上面的代码是运行`console.log(wrapper.debug())`生成的

# 测试涉及状态的组件

**类组件**

成分

试验

注意，对于一个类组件，我们可以做两组测试。

1.  行为。我们可以直接模拟点击按钮，看看按钮的文字有没有变化。我们正在模拟用户的行为，并测试预期的变化。
2.  基于组件。直接测试组件的 toggle 方法，看看它是否如我们所期望的那样。当切换功能更复杂，并且我们想要测试不同的场景时，这是很有帮助的。

两者的结合给了我们更高的信心。

**更新:**上述行为测试(1)理论上是一个**集成**测试，因为它实际上间接测试了切换方法。

对于一个真正的和完整的**单元**测试，我们将模拟切换功能，只测试按钮调用该功能，而不关心接下来会发生什么。此外，我们会将组件设置为所需的状态，并对照该状态检查呈现方法。完整的单元测试应该是这样的:

纯单元测试

如果类方法的功能非常复杂(很多分支，if/else 等等)，最好包含所有的单元测试。如果类方法的功能不是很复杂(就像上面的 toggle ),上面的原始测试应该足够了。

**带挂钩的组件**

成分

试验

遵循与上面的类组件的行为测试相同的模式，我们可以测试我们的钩子组件。

**注意:**可以将切换功能提取到它自己的钩子中，使其可重用。

# 用高阶组件测试组件

**注射器(渲染道具)**

酵素有一个功能可以帮助我们快速测试渲染道具。考虑以下组件。

在上面的例子中，`ModalHOC`给了孩子一个`toggleModal`道具来触发切换模态。为了测试上面的组件，我们需要这样的东西:

注意我们是如何在第 20 行使用`renderProp`来获得孩子的新包装的。这允许我们使用子包装器轻松地进行断言，子包装器拥有原始包装器的所有方法(通过使用`shallow`生成)。

我们还需要模仿`toggleModal`将其作为参数传递给我们的`children`道具。这里我们使用的是 jest 函数 mock using `jest.fn()`。

**增强剂**

考虑一个带有 react 路由器`withRouter`增强器 HOC 的例子。

成分

我们将这样测试:

试验

注意，我们不用担心第 8 行。我们可以有把握地假设`withRouter`将完成它的工作，并将正确的道具传递给我们的`UserLink`组件。

所以我们直接测试`UserLink`组件。这里我们模拟从`withRouter` HOC 传递来的`history`属性，并测试当点击按钮时，使用参数`/users`调用`history.push`函数。

**提示:**我们可以在每次考试前调用`jest.clearAllMocks()`。这在这个测试中不是很有用，因为我们只调用了一次`history.push`。但是如果我们需要多次测试，那么在每次测试之前清除模拟是一个好的做法，这样我们就可以从一个干净的模拟开始。

# **学会不去担心系统的其他部分**

![](img/2861ae7bc50d4d4b5b153d075039fcfb.png)

正如我们在前面的测试中看到的(在**增强子**下)，我们不必担心两个组分或一个组分和一个增强子 HOC 的相互作用。这是集成测试的工作。这就是为什么我们使用酶的`shallow`方法而不是`mount`方法。

单元测试应该只关注特定的一段代码。我们只是在测试，当传递某些输入时，我们得到了期望的输出。

# **覆盖范围**

你应该知道你已经测试了多少文件/行/分支，jest 通过用`--coverage`标志运行你的测试使这变得容易。这将给你一个代码覆盖率的报告。理想情况下，您应该接近 **100%** 代码覆盖率。实际上，这个比例可能在 80%-90%之间。根据我的经验，超过 80%的代码覆盖率会给你很多信心，你的代码不会崩溃。尽管这些数字看起来很大，尤其是如果你目前没有很多单元测试，如果你养成了为所有新组件编写测试的习惯，你将能够逐渐接近这个级别的代码覆盖率。

**注意:**一个组件有 100%的代码覆盖率并不意味着它是防弹的。你应该测试一系列不同的(奇怪的)输入来增加信心。此外，整个代码库中 100%的代码覆盖率并不能保证没有错误的体验。正如本文开头所述，我们需要集成测试和 e2e 测试，以确保我们的单元在相互交互时按预期工作。

# 关于测试驱动开发(TDD)的一句话

TDD 对于达到接近 100%的代码覆盖率是必不可少的。TDD 本质上是告诉我们为我们想要编写的每一段代码编写一个测试。很多文章都提到了这个过程:

1.添加测试

2.运行所有测试，看看新的测试是否失败

3.编写代码(不必完美，只要能通过测试就行)

4.运行测试(确保是绿色)

5.重构代码(使代码更加完美)

我个人更喜欢先写组件，因为这样更有创造性，然后写测试，再重构。无论您采用哪种方法，重要的是尝试和测试某个组件的所有场景(包括边缘情况)。并且**让测试失败**至少一次，这样你才能确定你的测试是有意义的。

# **附加提示**

1.  有一个 fixtures 文件夹来保存来自 api 的数据会很有帮助。例如，你可以拥有一个拥有一定数量帖子的用户的`userWithPosts`设备，以及一个没有任何帖子的用户的`userWithoutPosts`设备。这将允许您快速回忆起这些常量，以便在测试中使用它们。此外，如果 api 响应的结构发生变化，您可以在一个地方更改 fixture，并查看是否有任何测试失败。
2.  您应该编写自己的助手函数，当您编写的部分测试是可重复的时，这些函数会使测试更容易。例如，您可以编写一个名为`testRenderComponent`的函数，它将一个`wrapper`、一个元素(如`button`)和一个数字(如`2`)作为参数。这将测试在包装器中呈现了两个按钮。

# 我仍然不知道我应该测试什么

如果你仍然不确定你应该测试什么，试试这个。

*   测试您期望组件呈现的内容。
*   测试该组件(分支)的所有不同状态。如果您希望根据所传递的道具呈现不同的内容，请使用不同的道具组来浅层呈现组件，并做出适当的断言。
*   测试操作。例如，如果您希望当您单击或悬停在按钮上时会发生一些事情，请测试。
*   测试传递给子组件的道具。如果你正在渲染一个定制的`Button`组件，并且你传递了一个值为`red`的`color`道具，你应该测试一下。这也将使您确信您的组件满足设计要求。

> **底线:**如果你或另一个开发者**以某种方式改变组件**的行为**，那么至少有一个** **测试应该失败**。

# 结论

在每个项目中，为了增加对我们所写代码正确性的信心，编写单元测试是很重要的，单元测试是最简单的测试。我们应该以高百分比的代码覆盖率为目标，并让它成为我们编写单元测试的工作流程的一部分。

测试愉快！