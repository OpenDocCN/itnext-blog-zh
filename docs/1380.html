<html>
<head>
<title>Findings about RxJS marble testing and the TestScheduler</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于RxJS marble测试和TestScheduler的发现</h1>
<blockquote>原文：<a href="https://itnext.io/findings-about-rxjs-marble-testing-and-the-testscheduler-b23c6bdf6b49?source=collection_archive---------3-----------------------#2018-09-30">https://itnext.io/findings-about-rxjs-marble-testing-and-the-testscheduler-b23c6bdf6b49?source=collection_archive---------3-----------------------#2018-09-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3bdbbf8c1c0a2ea96b37dfc616afe536.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UmYEN7sszbjpqpJJPQioUw.jpeg"/></div></div></figure><p id="1a49" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最近，我编写了一个定制的Rx操作符，用于重试失败的http请求。RxJS允许我们只用几行代码就处理这样的异步问题，这种方式让我非常喜欢这个库。但是我们如何测试这样的操作链呢？</p><p id="1139" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">测试异步代码很难。</p><p id="e7ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">老实说，我经常需要更多的时间来为我的流编写单元测试，而不是实现有效的代码本身。</p><p id="2659" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我开始问自己，我们如何以一种可读性更强、耗时更少的方式编写包含异步操作符(如interval、debounce或timer)的测试？</p><p id="6985" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我终于撸起袖子，做了一件很久以前就想做的事。在我的一个生产项目中引入大理石测试。</p><h1 id="e19c" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">大理石测试</h1><p id="28d5" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">大理石测试是一种测试我们的</p><p id="82e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">大理石测试本身并不难，而且有很多很好的资源。但是我想对生态系统、TestScheduler以及版本5和版本6之间的差异有一个总体的了解。这些主题很少被记录，我花了比预期更多的时间来研究它们。这篇博文提供了我在路上遇到的一些发现。</p><h2 id="19d6" class="mc la it bd lb md me dn lf mf mg dp lj km mh mi ln kq mj mk lr ku ml mm lv mn bi translated">TestScheduler作为基本概念</h2><p id="548d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">计划者及时组织活动。这在RxJS中意味着控制事件发射顺序。在大多数情况下，您不必考虑调度程序，因为RxJS团队已经为我们做了。尽管我们应该知道调度程序的一般用途，并且我们还应该知道向运营商提供调度程序的可能性。我们来看看“音程”的签名。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mo"><img src="../Images/6b9e5d17cfabe35fc88eb6c461822bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fm7a_QH-tnavzlTfzpvxtg.png"/></div></div></figure><p id="3b34" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">操作符接受调度程序作为可选的最后一个参数，默认为异步调度程序。在Rx中有6个内置的调度程序。其中之一是TestScheduler派生的VirtualTimeScheduler。在测试过程中，我们希望使用虚拟时间而不是真实时间。我们可以通过传入一个TestScheduler来实现。</p><p id="1b8a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">TestScheduler有能力改变“时间的含义”。它使我们能够以同步的方式测试异步操作。根据经验，在测试期间，我们应该将TestScheduler传递给所有调度器没有缺省为null的操作符。但是TestScheduler为我们提供了更多。</p><p id="8066" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们看一下TestSchedulers API，我们可以看到像createColdObservable或createHotObservable这样的方法接受大理石图作为输入。我们能使用这些方法来编写大理石测试吗？</p><h2 id="713f" class="mc la it bd lb md me dn lf mf mg dp lj km mh mi ln kq mj mk lr ku ml mm lv mn bi translated">大理石测试，有和没有第三方图书馆</h2><p id="578a" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在我们使用TestScheduler的方法编写marble测试之前，让我们首先使用一个marble图来可视化我们的测试。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mt"><img src="../Images/1c34e0f68496e9c5cc08074ae28fac7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2YH6YoOiK7HQ4mTReKpKuA.png"/></div></div></figure><p id="07fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们想测试一个简单的map函数，它接受一个值并对其进行加倍。我们可以看到输入流发出值5、10和15，然后完成。然后，该流被映射到结果流10、20和30。让我们尝试只使用TestScheduler来实现这个测试。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mu"><img src="../Images/71af04d7425521eccd92eee183f1f3e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jJ3KY9RrQ9TZFSiNfIm_ww.png"/></div></div></figure><p id="6249" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这份试卷包含许多样板文件。首先，我们需要传递一个函数，该函数对实际可观察值和预期值做出断言。然后，我们需要手动调用flush来提示调度程序执行其所有排队的操作。测试感觉臃肿。这就是第三方库的用武之地。像jasmine-marbles或rxjs-marbles这样的库只是TestScheduler周围的薄薄的包装器，它允许我们以一种可读性更好、更简洁的方式编写测试。让我们来看看用茉莉-弹珠写的同一个例子。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/302505909c0c21a9d2d32fb2a643b8d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L-lt4nQdtlY1zxZDubYFuw.png"/></div></div></figure><p id="1d64" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">外面有不同的大理石图书馆。茉莉弹珠，rxjs弹珠，jest弹珠等等。茉莉弹珠很常见，也用在很多例子和演示中。Rxjs-marbles的优势在于它可以用于不同的测试框架。</p><p id="bec9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">测试调度器的发展</strong></p><p id="70c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们已经介绍了TestScheduler的基础知识以及它为我们提供了什么。需要注意的是，RxJS 5和RxJS 6有很多不同之处。关于v5 TestScheduler的文档很难找到。这样做的原因是因为它旨在供库的作者而不是库的消费者使用。官方的Rx文档提到，对于库的用户来说，一些特性不能很好地工作或者根本不能工作。什么？</p><p id="fff9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是还有希望。通过RxJS 6，他们改进了TestScheduler。虽然用RxJS 5测试操作符链很难，但版本6提供了更令人愉快的测试体验。</p><h2 id="8938" class="mc la it bd lb md me dn lf mf mg dp lj km mh mi ln kq mj mk lr ku ml mm lv mn bi translated"><strong class="ak"> <em class="mw"> testScheduler.run(回调)</em> </strong></h2><p id="0ab5" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在TestScheduler上引入run方法是一个非常重要的特性，它解决了困扰我很久的问题。当我们用以前版本的TestScheduler测试异步代码时，我们必须改变我们的函数，使它接受调度程序作为参数。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/d152cd2781509d0bd6a24be3e68f927f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3LlHq8FmFH5Q9-rYf_U5rQ.png"/></div></div></figure><p id="1b43" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我真的不喜欢这种方式。感觉我把测试和生产代码混在一起了。我们如何用新的TestScheduler及其run方法做得更好？所有使用AsyncScheduler(如debounce或timer)的操作符在run方法中执行时都会自动使用TestScheduler。这意味着我们的流自动使用虚拟时间而不是真实时间。</p><p id="aff4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，让我们为RxJS 6重写相同的功能，删除scheduler作为参数，并用TestScheduler的run方法测试它。让我们也使用一些析构从运行方法回调助手参数中提取一些有用的助手方法。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/e3eb09a6433afb3f3d10b464455f440c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*owu7-zZE7fMhkebsCDgj4Q.png"/></div></div></figure><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/b2be3dbcb7eb6114257b84263e8b3efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KC3YpsxxjOM4QbO7QEe1Pg.png"/></div></div></figure><p id="55a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意我们是如何使用语法“1s a 999ms b 999ms c 999ms (d|)”的。这是RxJS 6的另一个很酷的功能，叫做“时间推进”。通常，当在run方法中运行时，一个“-”代表一个1 ms虚拟时间的帧。外面的“-”代表10ms的虚拟时间。使用时间推进语法，我们可以将虚拟时间推进毫秒(ms)、秒(s)甚至分钟(m)。这对于测试我们的流非常有用。当我们开始使用时间推进时，重要的是要知道，在流的开始，我们按1s处理，然后发出a。发出a后，我们使用999ms而不是1s。原因是b也使用了1毫秒的虚拟时间。</p><h1 id="aec2" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="e0d9" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">大理石测试为我们提供了一个干净和全面的方法来测试和可视化我们的可观测量。弹珠本身被用在很多教程和教学中，因此被很好地记录下来。我发现很难概述TestScheduler本身、库和TestScheduler之间的区别以及版本5 TestScheduler和版本6 TestScheduler之间的区别。由于我们的项目仍然使用版本5，我也损失了大量的时间让marble测试在更复杂的场景下工作，比如http重试操作符。我希望这篇博文能给你提供我开始时所遗漏的概述。</p><p id="1ff4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">喜欢你读过的吗？如果你喜欢这篇博客，请鼓掌，分享或关注我。想了解更多关于可观察对象的内部工作方式吗？或者你甚至想学习如何编写你自己的可观察对象吗？然后看看我在itnext上的文章“揭开可观察事物的神秘面纱”。</p><div class="na nb gp gr nc nd"><a rel="noopener  ugc nofollow" target="_blank" href="/demystifying-observables-979a63763eb1"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">揭开可观察事物的神秘面纱</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">实用的方法</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">itnext.io</p></div></div><div class="nm l"><div class="nn l no np nq nm nr jz nd"/></div></div></a></div><blockquote class="ns nt nu"><p id="6648" class="kb kc nv kd b ke kf kg kh ki kj kk kl nw kn ko kp nx kr ks kt ny kv kw kx ky im bi translated">你想让你的Angular、RxJS、TypeScript和JavaScript技能更上一层楼吗？不要错过查看我的 <a class="ae nz" href="https://www.youtube.com/channel/UCFT4YVZl7AFia7rZBTEvavw" rel="noopener ugc nofollow" target="_blank"> <em class="it"> Youtube频道</em> </a> <em class="it">的机会。</em></p></blockquote><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/8f03ad49e56ae3bbedef8209bc825cba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sT2l9mBx27ynKHpi.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated"><a class="ae nz" href="https://www.youtube.com/channel/UCFT4YVZl7AFia7rZBTEvavw" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/channel/UCFT4YVZl7AFia7rZBTEvavw</a></figcaption></figure></div></div>    
</body>
</html>