<html>
<head>
<title>An Intro to Node.js That You May Have Missed</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你可能错过的Node.js简介</h1>
<blockquote>原文：<a href="https://itnext.io/an-intro-to-node-js-that-you-may-have-missed-b175ef4277f7?source=collection_archive---------2-----------------------#2018-12-18">https://itnext.io/an-intro-to-node-js-that-you-may-have-missed-b175ef4277f7?source=collection_archive---------2-----------------------#2018-12-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/baeb2c66b220e8200bda012eb7d8e5c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wsWX5CujhkO7HoX4"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">扎卡里·扬在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><p id="86ef" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">众所周知，Node.js是一个开源的跨平台JavaScript运行时。大多数Node.js开发人员都知道它是建立在V8(JS引擎)和libuv(基于事件循环提供异步I/O支持的多平台C库)之上的。但只有少数开发人员能够清楚地解释Node.js内部是如何工作的，以及它如何影响他们的代码。那大概是因为很多Node.js开发者在学习Node之前就已经知道JavaScript了。所以，他们经常从Express.js，Sequelize，Mongoose，Socket开始学习node。IO等知名库，而不是把时间投入到学习Node.js本身和它的标准API上。对我来说，这似乎是一个错误的选择，因为理解Node.js运行时和了解内置API的细节可能有助于避免许多常见错误。</p><p id="c6db" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章以简洁而全面的方式介绍了Node.js。我们将对Node.js架构做一个总体概述。因此，我们将尝试确定一些使用Node.js编写更高性能、更安全的服务器端web应用程序的指导原则。这对Node.js初学者以及有经验的js开发人员应该很有帮助。</p><h1 id="3c70" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">主要构件</h1><p id="6a37" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">任何Node.js应用程序都是基于以下组件构建的:</p><ul class=""><li id="9e89" class="me mf jg kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated"><a class="ae jd" href="https://v8.dev/" rel="noopener ugc nofollow" target="_blank">V8</a>——谷歌开源的高性能JavaScript引擎，用C++编写。谷歌Chrome浏览器等也在使用。Node.js通过V8 C++ API控制V8。</li><li id="2bfe" class="me mf jg kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">libuv——一个多平台支持库，专注于异步I/O，用c语言编写。它主要是为Node.js开发的，但也为Luvit、Julia、pyuv和其他人使用。Node.js使用libuv将非阻塞I/O操作抽象到所有支持平台的统一接口。这个库提供了处理文件系统、DNS、网络、子进程、管道、信号处理、轮询和流的机制。它还包括一个线程池，也称为工作池，用于卸载一些不能在操作系统级别异步完成的工作。</li><li id="cd6a" class="me mf jg kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">其他开源、底层组件，大多用C/C++编写:<br/>-<a class="ae jd" href="https://c-ares.haxx.se/" rel="noopener ugc nofollow" target="_blank">C-ares</a>-一个异步DNS请求的C库，用于Node.js中的一些DNS请求<br/>-<a class="ae jd" href="https://github.com/nodejs/http-parser" rel="noopener ugc nofollow" target="_blank">http-parser</a>-一个轻量级的HTTP请求/响应解析器库。<br/> - <a class="ae jd" href="https://www.openssl.org/" rel="noopener ugc nofollow" target="_blank"> OpenSSL </a> —知名的通用密码库。用于<code class="fe ms mt mu mv b">tls</code>和<code class="fe ms mt mu mv b">crypto</code>模块。<br/>-<a class="ae jd" href="https://zlib.net/" rel="noopener ugc nofollow" target="_blank">zlib</a>-一个无损数据压缩库。用于<code class="fe ms mt mu mv b">zlib</code>模块。</li><li id="6ee5" class="me mf jg kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">应用程序——它是用JavaScript编写的应用程序代码和标准Node.js模块。</li><li id="1da4" class="me mf jg kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">C/C++绑定——围绕C/C++库的包装器，用N-API构建，一个用于构建本机Node.js插件的C API，或其他用于绑定的API。</li><li id="101a" class="me mf jg kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">Node.js基础设施中使用的一些捆绑工具:<br/>-<a class="ae jd" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank">NPM</a>-一个知名的包管理器(和生态系统)。<br/>-<a class="ae jd" href="https://gyp.gsrc.io/" rel="noopener ugc nofollow" target="_blank">gyp</a>-基于python的项目生成器，从V8复制而来。由node-gyp使用，这是一个用Node.js编写的跨平台命令行工具，用于编译本机插件模块。<br/>-<a class="ae jd" href="https://github.com/google/googletest" rel="noopener ugc nofollow" target="_blank">gt est</a>-谷歌的C++测试框架。用于测试本机代码。</li></ul><p id="76f9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个简单的图表，显示了列表中提到的主要Node.js组件:</p><figure class="mx my mz na gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mw"><img src="../Images/0afe54aa63d08ff6966f564c04396d89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fD6TsZEshqC2liv8o_GAdA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">主Node.js组件</figcaption></figure><h1 id="a486" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Node.js运行时</h1><p id="9ec8" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">下图显示了Node.js运行时如何执行js代码:</p><figure class="mx my mz na gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nb"><img src="../Images/7cccdb4a8a23373a1a1bf71a230babb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rWGbyCbcJTKI-m3ZEDhCaA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">Node.js运行时图(简化)</figcaption></figure><p id="0cfe" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个图没有显示Node.js中发生的所有细节，但是它突出了最重要的部分。我们将简要讨论它们。</p><p id="f399" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦Node.js应用程序启动，它首先完成一个初始化阶段，即运行启动脚本，包括请求模块和注册事件回调。然后应用程序进入事件循环(也称为主线程、事件线程等。)，它在概念上是为了通过执行适当的JS回调来响应传入的客户端请求而构建的。JS回调是同步执行的，可能会使用节点API来注册异步请求，以便在回调完成后继续处理。这些异步请求的回调也将在事件循环中执行。这种节点API的例子包括各种定时器(<code class="fe ms mt mu mv b">setTimeout()</code>、<code class="fe ms mt mu mv b">setInterval()</code>等)。)、<code class="fe ms mt mu mv b">fs</code>和<code class="fe ms mt mu mv b">http</code>模块的功能等等。所有这些API都需要一个回调，一旦操作完成，回调就会被触发。</p><p id="a7c6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事件循环是基于libuv的单线程半无限循环。之所以称之为半无限循环，是因为它会在某个时刻退出，这时已经没有工作可做了。从开发者的角度来看，这是你的程序退出的时候。</p><p id="3a28" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事件循环相当复杂。它假设对事件队列进行操作，并包括几个阶段:</p><ul class=""><li id="f6a1" class="me mf jg kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">计时器阶段——该阶段执行由<code class="fe ms mt mu mv b">setTimeout()</code>和<code class="fe ms mt mu mv b">setInterval()</code>安排的回调。</li><li id="b636" class="me mf jg kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">挂起回调阶段—执行推迟到下一次循环迭代的I/O回调。</li><li id="7c03" class="me mf jg kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">空闲和准备阶段—内部阶段。</li><li id="979f" class="me mf jg kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">轮询阶段—包括以下内容:检索新的I/O事件；执行与I/O相关的回调(除了close、timers和<code class="fe ms mt mu mv b">setImmediate()</code>回调之外的几乎所有回调)；Node.js将在适当的时候阻塞这里。</li><li id="8e0c" class="me mf jg kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">检查阶段— <code class="fe ms mt mu mv b">setImmediate()</code>回调在这里被调用。</li><li id="928e" class="me mf jg kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">关闭回调阶段——这里执行一些关闭回调，例如<code class="fe ms mt mu mv b">socket.on('close', ...)</code>。</li></ul><p id="60e4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">注</strong>。查看以下<a class="ae jd" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" rel="noopener ugc nofollow" target="_blank">指南</a>以了解更多关于事件循环阶段的信息。</p><p id="a640" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在轮询阶段，事件循环通过使用libuv对特定于操作系统的I/O轮询机制的抽象来实现非阻塞的异步请求(通过节点API启动)。这些特定于操作系统的机制是用于Linux的epoll、用于Windows的IOCP、用于BSD和MacOS的kqueue、Solaris中的事件端口。</p><p id="e651" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Node.js是单线程的，这是一个普遍的误解。本质上，这是正确的(或者曾经是部分正确的，因为有对web workers的实验性支持，称为Worker Threads ),因为您的JS代码总是在事件循环中的单个线程上运行。但是您可能还会注意到图中的Worker池，这是一个固定大小的线程池，因此任何Node.js进程都有多个并行运行的线程。原因如下:并非所有节点API操作都可以在所有支持的操作系统上以非阻塞方式执行。使用工作池的另一个原因是事件循环不适合CPU密集型计算。</p><p id="8469" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，Node.js(尤其是libuv)尽最大努力为这种阻塞操作保持相同的异步、事件驱动API，并在单独的线程池上执行这些操作。以下是内置模块中此类阻塞操作的一些示例:</p><ul class=""><li id="7786" class="me mf jg kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">I/O绑定:<br/>-<code class="fe ms mt mu mv b">dns</code>模块中的一些DNS操作:<code class="fe ms mt mu mv b">dns.lookup()</code>、<code class="fe ms mt mu mv b">dns.lookupService()</code>。<br/> -大部分文件系统操作由<code class="fe ms mt mu mv b">fs</code>模块提供，如<code class="fe ms mt mu mv b">fs.readFile()</code>。</li><li id="52ce" class="me mf jg kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">CPU绑定:<br/>—<code class="fe ms mt mu mv b">crypto</code>模块提供的一些密码操作，如<code class="fe ms mt mu mv b">crypto.pbkdf2()</code>、<code class="fe ms mt mu mv b">crypto.randomBytes()</code>或<code class="fe ms mt mu mv b">crypto.randomFill()</code>。<br/>-<code class="fe ms mt mu mv b">zlib</code>模块提供的数据压缩操作。</li></ul><p id="23e5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，一些第三方本地库，比如<code class="fe ms mt mu mv b">bcrypt</code>，也将计算卸载到工作线程池。</p><p id="2287" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当您应该对Node.js的整体架构有了更好的理解时，让我们讨论一些编写更高性能、更安全的服务器端应用程序的准则。</p><h1 id="3b27" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">规则1——避免在函数中混合同步和异步</h1><p id="8ac3" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当您编写任何函数时，您需要使它们要么完全同步，要么完全异步。您应该避免在一个函数中混合使用这些方法。</p><p id="4078" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">注</strong>。如果一个函数接受回调作为参数，这并不意味着它是异步的。举个例子，可以想到<code class="fe ms mt mu mv b"><a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank">Array.forEach()</a></code>函数。这种方法通常被称为<a class="ae jd" href="http://matt.might.net/articles/by-example-continuation-passing-style/" rel="noopener ugc nofollow" target="_blank">延续传递式</a> (CPS)。</p><p id="cc88" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们以下面的函数为例:</p><pre class="mx my mz na gt nc mv nd ne aw nf bi"><span id="6266" class="ng lc jg mv b gy nh ni l nj nk">const fs = require('fs')</span><span id="c37c" class="ng lc jg mv b gy nl ni l nj nk">function checkFile (filename, callback) {<br/>  if (!filename || !filename.trim()) {<br/>    // pitfalls are here:<br/>    return callback(new Error('Empty filename provided.'))<br/>  }</span><span id="d5e3" class="ng lc jg mv b gy nl ni l nj nk">  fs.open(filename, 'r', (err, fileContent) =&gt; {<br/>    if (err) return callback(err)<br/>    <br/>    callback(null, true)<br/>  })<br/>}</span></pre><p id="2d04" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个函数很简单，但是很好地满足了我们的需求。这里的问题是<code class="fe ms mt mu mv b">return callback(...)</code>分支，因为回调是在无效参数的情况下同步调用的。另一方面，在有效输入的情况下，回调在<code class="fe ms mt mu mv b">fs.open()</code>调用中以异步方式调用。</p><p id="b9ab" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了显示这段代码的潜在问题，让我们尝试用不同的输入来调用它:</p><pre class="mx my mz na gt nc mv nd ne aw nf bi"><span id="177d" class="ng lc jg mv b gy nh ni l nj nk">checkFile('', () =&gt; {<br/>  console.log('#1 Internal: invalid input')<br/>})<br/>console.log('#1 External: invalid input')</span><span id="5cc8" class="ng lc jg mv b gy nl ni l nj nk">checkFile('main.js', () =&gt; {<br/>  console.log('#2 Internal: existing file')<br/>})<br/>console.log('#2 External: existing file')</span></pre><p id="a7f5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该代码将向控制台输出以下内容:</p><pre class="mx my mz na gt nc mv nd ne aw nf bi"><span id="99d0" class="ng lc jg mv b gy nh ni l nj nk">#1 Internal: invalid input<br/>#1 External: invalid input<br/>#2 External: existing file<br/>#2 Internal: existing file</span></pre><p id="1b63" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能已经注意到这里的问题了。在这些情况下，代码执行的顺序是不同的。它使函数不确定，因此必须避免这种风格。通过用<code class="fe ms mt mu mv b">setImmediate()</code>或<code class="fe ms mt mu mv b">process.nextTick()</code>包装<code class="fe ms mt mu mv b">return callback(...)</code>调用，该函数可以很容易地固定为完全异步的风格:</p><pre class="mx my mz na gt nc mv nd ne aw nf bi"><span id="fba8" class="ng lc jg mv b gy nh ni l nj nk">if (!filename || !filename.trim()) {<br/>  return setImmediate(<br/>    () =&gt; callback(new Error('Empty filename provided.'))<br/>  )<br/>}</span></pre><p id="0556" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们的函数变得更加确定了。</p><h1 id="d157" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">规则2——不要阻塞事件循环</h1><p id="cf6e" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">就服务器端web应用程序而言，例如RESTful服务，所有请求都在事件循环的单线程中并发处理。因此，举例来说，如果应用程序中的HTTP请求处理在执行计算量很大的JS函数上花费了大量时间，那么它会阻塞所有其他请求的事件循环。作为另一个例子，如果您的应用程序在处理每个HTTP请求的JS代码上花费10毫秒，那么应用程序的单个实例的吞吐量大约是每秒1000 / 10 = 100个请求。</p><p id="811f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，Node.js的第一条黄金法则是“永远不要阻塞事件循环”。这里有一个简短的建议列表，可以帮助你遵循这个规则:</p><ul class=""><li id="be29" class="me mf jg kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">避免任何繁重的JS计算。如果你有时间复杂度低于O(n)的代码，考虑优化它，或者至少把计算分成块，通过定时器API递归调用，比如<code class="fe ms mt mu mv b">setTimeout()</code>或<code class="fe ms mt mu mv b">setImmediate()</code>。这样，您将不会阻塞事件循环，并且其他回调将能够被处理。</li><li id="8a23" class="me mf jg kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">在服务器应用程序中避免任何<code class="fe ms mt mu mv b">*Sync</code>调用，如<code class="fe ms mt mu mv b">fs.readFileSync()</code>或<code class="fe ms mt mu mv b">crypto.pbkdf2Sync()</code>。这条规则的唯一例外可能是应用程序的启动阶段。</li><li id="931b" class="me mf jg kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">明智地选择第三方库，因为它们可能会阻塞事件循环，例如通过运行一些用JS编写的CPU密集型计算。</li></ul><h1 id="a120" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">规则3——明智地阻止工人池</h1><p id="5d5a" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这可能令人惊讶，但工人池也可能被阻塞。众所周知，这是一个固定大小的线程池，默认大小为4个线程。可以通过设置<code class="fe ms mt mu mv b"><a class="ae jd" href="https://nodejs.org/api/cli.html#cli_uv_threadpool_size_size" rel="noopener ugc nofollow" target="_blank">UV_THREADPOOL_SIZE</a></code>环境变量来增加大小，但是在很多情况下这并不能解决你的问题。</p><p id="a684" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了说明工人池问题，让我们考虑下面的例子。RESTful API有一个身份验证端点，它计算给定密码的哈希值，并将其与从数据库中获得的值进行匹配。如果你做的一切都是正确的，散列是在工人池中完成的。让我们想象一下，每次计算需要大约100毫秒才能完成。这意味着，在默认的工作池大小下，就哈希端点的吞吐量而言，您每秒将获得大约4*(1000 / 100) = 40个请求(重要说明:我们在这里考虑4个以上CPU核心的情况)。当工作池中的所有线程都很忙时，所有传入的任务，比如散列计算或<code class="fe ms mt mu mv b">fs</code>调用，都将被排队。</p><p id="0a77" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以Node.js的第二条黄金法则是“明智地阻塞工人池”。这里有一个简短的建议列表，可以帮助你遵循这个规则:</p><ul class=""><li id="87c0" class="me mf jg kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">避免在工作池中发生长时间运行的任务。例如，比起用<code class="fe ms mt mu mv b">fs.readFile()</code>读取整个文件，我更喜欢基于流的API。</li><li id="cf68" class="me mf jg kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">如果可能，考虑对CPU密集型任务进行分区。</li><li id="9539" class="me mf jg kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">再次，明智地选择第三方库。</li></ul><h1 id="5de2" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">规则# 0——一个规则来统治所有人</h1><p id="7c6a" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在，作为总结，我们可以制定一个编写高性能Node.js服务器端应用程序的经验法则。这条经验法则是“如果在任何给定时间为每个请求所做的工作足够小，Node.js就很快”。此规则涵盖事件循环和工作池。</p><h1 id="14d3" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">进一步阅读</h1><p id="c53b" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">作为进一步的阅读，我建议你阅读以下内容:</p><ul class=""><li id="5a10" class="me mf jg kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">来自节点团队的指南，提供了更多模式来帮助您避免阻塞事件循环和工作池:<a class="ae jd" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/" rel="noopener ugc nofollow" target="_blank">https://nodejs . org/en/docs/guides/don-block-the-Event-Loop/</a></li><li id="209d" class="me mf jg kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">对于那些想要真正深入了解Node.js内部工作原理的人来说，这是一系列精彩的文章:<a class="ae jd" href="https://blog.insiderattack.net/event-loop-and-the-big-picture-nodejs-event-loop-part-1-1cb67a182810" rel="noopener ugc nofollow" target="_blank">https://blog . insiderattack . net/event-loop-and-the-big-picture-nodejs-event-loop-part-1-1cb 67 a 182810</a></li></ul></div></div>    
</body>
</html>