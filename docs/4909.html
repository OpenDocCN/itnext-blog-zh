<html>
<head>
<title>Promises, Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">承诺，承诺</h1>
<blockquote>原文：<a href="https://itnext.io/promises-promises-33f43490e8b7?source=collection_archive---------4-----------------------#2020-10-21">https://itnext.io/promises-promises-33f43490e8b7?source=collection_archive---------4-----------------------#2020-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4978" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Golang实现Javascript异步模式</h2></div><p id="012c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">(本博客由https://creativecommons.org/licenses/by/4.0/</em><a class="ae lf" href="https://creativecommons.org/licenses/by/4.0/" rel="noopener ugc nofollow" target="_blank">授权，</a><em class="le">所有代码由https://www.apache.org/licenses/LICENSE-2.0</em><a class="ae lf" href="https://www.apache.org/licenses/LICENSE-2.0" rel="noopener ugc nofollow" target="_blank"><em class="le"/></a><em class="le">授权)</em></p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/6406fe46a7fe1317677cb221f1125159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jak7ji7bdhVSyhdzaif1dQ.png"/></div></div></figure><h2 id="df2a" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">介绍</h2><p id="734e" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">Golang的关键字数量有限(25个)，主要致力于构建多线程程序。这些目标，当你深入挖掘，似乎是对立的。有许多多线程抽象原则上可能需要它们自己的关键字和语法，以便通过语言抽象更容易访问。至少在看原生围棋的时候只有两个可以合作的:<em class="le">围棋</em>和<em class="le">围棋</em>。</p><p id="674a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">问题是:仅仅用这两种工具实现更高层次的异步抽象可能吗？是的，当然，只要有足够的代码来解决这个问题，你几乎可以做任何事情。有没有可能用一种通用的方法，不需要为每个实现重新创建模式的充满bug的过程？golang通常在这一点上偏离了传统的面向对象(OO)方法。</p><h2 id="4691" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">无商标消费品</h2><p id="7658" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">Java或C++工程师倾向于从泛型开始这个过程。问题:golang中没有泛型(例如C++模板)(也不应该有)。Golang可以以面向对象的方式使用，但它并不是最佳的面向对象语言，它介于面向对象和函数式编程(FP)之间。golang中有空<em class="le">接口{} </em>形式的“非类型化”结构(这里我们引入第三个关键字，它的工作方式很像C语言中的<em class="le"> void* </em>),但是它们有一个严重的缺点:为了处理通过空接口获得的对象的方法或成员，必须使用动态强制转换。然而，我们不能在变量中传递“type”关键字，所以任何试图利用空接口的代码都必须通过类型<em class="le">开关</em>(或者<em class="le">如果</em>是阶梯)或一些中间接口得到一些帮助。这并不像我们希望的那样普遍。在有些应用中，这已经足够了，它们引导我们使用golang开发人员工具包中的下一个工具:</p><h2 id="c878" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">代码生成</h2><p id="afda" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">解决泛型问题的标准方法是使用模板语言来编写泛型函数，然后使用golang的代码生成工具箱来为您的应用定制实现。这可以避开空的<em class="le">接口</em>的一些问题，因为您可以使用另一个信息源(json、yaml等)将类型信息应用于模板化的类型开关和转换函数。这可以允许接受空接口的函数“解码”基础类型，以便在通用代码完成其工作后使用。虽然这对于许多问题来说已经足够了(我在我自己的项目中使用了这种技术，比如使用openapi 3.0的规范驱动设计和我的<a class="ae lf" href="https://github.com/weberr13/go-decode" rel="noopener ugc nofollow" target="_blank"> go-decode </a>包，也在使用优秀的模拟库<a class="ae lf" href="https://github.com/maxbrunsfeld/counterfeiter" rel="noopener ugc nofollow" target="_blank">伪造者</a>为单元测试生成spy时使用了这种技术)，但是代码生成带来了新的问题。</p><p id="5c3e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，它可以将“不可编译的代码”以模板和所使用的任何规范的形式引入到项目中。现在，golang中没有的一套新工具是构建软件所必需的。</p><p id="1df9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其次，虽然可以编写代码来练习模板，但模板代码不能直接测试。您只能测试模板到golang代码的“投影”,以进行解析、林挺和运行时检查。</p><p id="e264" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述因素的结合也给大型项目引入了一种“宗教”辩论。一派认为代码生成应该在提交前应用，并将生成的代码“快照”到repos中(并通过CICD验证)，以便真实信息的来源(yaml、openapi规范等)可以独立更改。另一派希望减少源代码控制中包含的“不可读”代码，而选择代码生成作为构建时间步骤。两者各有利弊，但最好不要选择任何一个。</p><p id="7f75" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有没有一个通用问题(特别是多线程抽象)的解决方案，不需要我们引入空接口的脆弱性或构建时代码生成的复杂性？</p><h2 id="d2c2" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">一级函数和闭包</h2><p id="32ee" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">Golang是FP和OO技术的混合，可能不是“FP完全的”,但是它对解决这个特殊问题所必需的两种成分提供了本地支持。</p><ol class=""><li id="5fa1" class="mq mr it kk b kl km ko kp kr ms kv mt kz mu ld mv mw mx my bi translated">第一类函数——在golang中，函数可以存储在变量绑定或“l值”(如函数参数)和“r值”(如返回值)中。</li><li id="b3e8" class="mq mr it kk b kl mz ko na kr nb kv nc kz nd ld mv mw mx my bi translated">闭包——函数定义范围内的变量被“封闭”在已定义函数的范围内。</li></ol><p id="ec2e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是golang代码的这两个属性如何协同工作的简单说明:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/7cccba15535c5626bdf1722ae345549b.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*-C9KLE5dv-RKVhyhG90GrQ.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated"><strong class="bd lu"> i </strong>和外<strong class="bd lu">的最终值是多少？</strong></figcaption></figure><p id="3cf6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">变量绑定“<em class="le"> l </em>”(对于lambda)包含一个函数，该函数将变量“<em class="le">”封闭在</em>之外，然后循环观察被封闭的变量调用<em class="le"> l() </em>，直到它达到值20。如果没有闭包，你会认为循环会永远运行下去，因为循环计数器“<em class="le"> i </em>”永远不会被检查。(或者您会认为编译器会抱怨函数范围内未定义的绑定)。运行测试时，我们发现情况并非如此:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/39996757aa103710aed5416a210c33c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*azPOvYVxMtemsU3zK1_6ZA.png"/></div></figure><p id="a07f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显然，测试不会永远运行，也不会编译失败。当你第一次看到它时，这绝对是一个有趣的行为，但是除了重用代码之外，它不一定有用。第一类函数除了存储在绑定中之外还有另一个属性，它们也可以是函数的返回值。请考虑以下情况:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/12ea82ff0c9f54db2bde02f08307b905.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*CIyO21sY-pTqRSegiLUfKw.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">从这一点开始，您必须包含引用</figcaption></figure><p id="6899" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在前面的代码中，对外部的引用是自动为我们处理的。通过在函数范围之外定义“<em class="le"> build </em>”，我们需要做一些指针工作。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/8c0893cd54590a61fdc3597bcb559f38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*ILfkPRLCu1LAqM98l3_c6A.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">它确实可以工作，但不如以前优雅</figcaption></figure><p id="1c8e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然这段代码看起来不必要的复杂，但是请注意“run”方法发生了什么:它现在通用于"<em class="le"> l </em>"的任何实现。例如，让我们更改我们的规范，即循环必须在每次迭代中向“外部”值添加一个变量。使用这种策略，不需要改变“运行”方法:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/7ffe8fa934ff8fa369e5b0e88e0bdbbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*L2zSFl_zuldKq3o6Q_aPOg.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">“构建”功能会改变，但“运行”功能不会改变</figcaption></figure><p id="c347" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然"<em class="le"> run </em>"没有改变，但是它所执行的动作已经与"<em class="le"> l </em>"的内容解耦，而且传递给构建的<strong class="kk iu">参数现在完全在我们的控制之下:</strong></p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/114042ca93bbe8a7cb68743ea9b207b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*rCI1zGCxb9sHDWkIed-7mA.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">现在“外部”每跑两步</figcaption></figure><p id="1ce3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">构造函数</strong></p><p id="885b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在golang中，没有构造函数的内置概念，但惯例是创建一个NewStructName()格式的函数，该函数返回一个带有默认值和分配(如通道和地图)的引用对象。这对这门语言的新手来说可能会不太舒服，而且这不是一个普遍使用的习语。就像上面的例子一样，这个构造函数不需要直接返回一个对象。它可以返回一个函数，这个函数能够用给定的设置构建无数的对象。采取以下措施:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi no"><img src="../Images/6d84e86603f70c15940067834895fc67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*1N96zgttIUS8Gy_Y_xSoEw.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">“运行”的代码没有任何改变</figcaption></figure><p id="e0c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">进一步考虑第二个例子中代码的一般性质，我们现在为能够运行函数“<em class="le"> Count </em>”的对象引入一个接口(不是空接口，而是相当一般的接口)。对于接口的特定实现，我们通过构造函数重新实现第二个示例的功能，该构造函数返回的不是结构引用，而是结构引用的*builder*。该构建器仅作为“<em class="le">运行</em>的参数调用，并传递对其“<em class="le">计数</em>函数的引用。这是一个更加通用的方法，但是我们可以更进一步。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi np"><img src="../Images/2a590668ae3a31ac46e5744e05920daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*kMlFETmPj1jX5OO5SvV6qQ.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">前一个示例中的行为被重现</figcaption></figure><p id="0591" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们不需要把自己限制在"<em class="le">运行</em>"只调用一个函数。我们现在可以构建界面并包含许多功能。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/041a5a5df75a1a424e6bc7c0f009fd60.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*U3JBzq_huWuQyztB9fJsbw.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">Run不再知道“外部”是什么，我们可以再次删除引用。</figcaption></figure><p id="3c92" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们终于回到了第一个实现的所有方面(outside不再通过引用传递，并且“run”可以通过report()接口报告秘密变量“outer”)。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/b689d2373ebcf9279f34bff67e130054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*HltYZgLMnQzW3Gl1oDMU8g.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">表示封闭变量的私有状态的一行打印行。</figcaption></figure><h2 id="69e6" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated"><strong class="ak">一个通用的承诺</strong></h2><p id="4121" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">有了背景如何闭包，第一类函数返回，以及这些返回接口对象的函数的“builder”构造函数；我们有工具来构建一个既不依赖于代码生成也不依赖于类型切换的通用模式(但是将会有一个单独的动态造型，稍后会详细介绍)。</p><p id="56fa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们想简单地使用goroutines和通道在golang中实现JavaScript“Promise”对象。此外，由于本系列关注的是“actor模式”，这个承诺应该在通用actor中起作用。对于接口，请考虑以下事项:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/3e840abd2bfc9b0ecf0f96f011961666.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*nTuV6M-gShjKm2y-_SARvA.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">为了便于阅读，函数定义是打字的</figcaption></figure><p id="b63b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Promise是实现两个功能的对象的接口:</p><ul class=""><li id="b325" class="mq mr it kk b kl km ko kp kr ms kv mt kz mu ld nt mw mx my bi translated"><em class="le">然后是</em>，当异步工作完成时，它调用一个在原始结构上操作的函数。</li><li id="cc63" class="mq mr it kk b kl mz ko na kr nb kv nc kz nd ld nt mw mx my bi translated"><em class="le"> Repl </em>，它返回一个完成的结构应该被发送的承诺</li></ul><p id="f360" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们继续之前，你可能已经注意到了一些事情。如果对象是一个接口，那么根据定义它就是一个引用对象。如果引用对象在一个单独的goroutine中被操作，那么从一个“Main”例程中读取它不会产生一个竞争条件吗？幸运的是，golang中的调度程序是与堆绑定在一起的，如果一个对象在通道上从一个goroutine发送，并且在别处被接收时已经完成，那么这个对象的“所有权”就交给了接收例程。这允许对象在完成自己的私人工作后通过通道“邮寄自己”。这对于实现可能更有意义:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/73caaf41e548031122dc9f623b1c0716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*wBrcJKHCpFJIf-bWfRDmgA.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">超级？比如python？</figcaption></figure><p id="df52" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个结构将作为promise的任何实现的通用主干。子例程对它的使用必须在调用“Then”之后结束，并且上下文用于关闭/超时生存期。</p><p id="5b01" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">闭包示例的“Run”方法将是一个通用actor，它允许对通用promise的实现进行两步操作。一个“工作”函数，完成调用者定义的一些任务，然后以一种变异的状态返回。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/72039b2183658ae483ebaad4ea9d1550.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*jjd7XZRTrLisK7RnwluMGQ.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">“R <strong class="bd lu"> epl </strong>通道是无缓冲的，因此未能调用<strong class="bd lu">然后调用</strong>可能会导致goroutine泄漏</figcaption></figure><p id="158c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于示例实现，必须编写4个函数来利用该结构:</p><ol class=""><li id="a418" class="mq mr it kk b kl km ko kp kr ms kv mt kz mu ld mv mw mx my bi translated">嵌入“<em class="le"> GenericPromise </em>”的结构。</li><li id="a101" class="mq mr it kk b kl mz ko na kr nb kv nc kz nd ld mv mw mx my bi translated">返回开放函数的构造函数。</li><li id="fbee" class="mq mr it kk b kl mz ko na kr nb kv nc kz nd ld mv mw mx my bi translated">一个"<em class="le"> work </em>"函数构造器，它返回一个执行应该异步执行的操作的函数。</li><li id="0a12" class="mq mr it kk b kl mz ko na kr nb kv nc kz nd ld mv mw mx my bi translated">一个"<em class="le"> call </em>"函数构造器，返回一个作用于已完成工作负载的函数。</li></ol><p id="3b51" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/7e865908c0bec4ff09f6db237a579cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*LihY-p3gBTSvaoONFXY4zg.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">到处都是闭包，没有上下文或通道</figcaption></figure><p id="3691" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">3个构造函数的参数是任意的，同样地，<em class="le"> MyPromise </em>中的数据可以是任何东西，并且不需要以任何方式本质上是线程安全的。</p><p id="d75b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能会注意到，在处理器和完整的函数构造函数中，确实存在动态强制转换。这与本文前面的方法有两个主要不同之处:</p><ol class=""><li id="699a" class="mq mr it kk b kl km ko kp kr ms kv mt kz mu ld mv mw mx my bi translated">只有一种类型被铸造。</li><li id="2260" class="mq mr it kk b kl mz ko na kr nb kv nc kz nd ld mv mw mx my bi translated">如果失败了，演员可以惊慌失措。</li></ol><p id="55c2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以肯定，如果代码作为一个单元使用，强制转换不会失败。<em class="le"> open </em>函数的return必须通过一个接口返回一个<em class="le"> MyPromise </em>，但是这两个函数不会对任何不同的东西进行操作。这些仍然是动态类型转换，但是在这种情况下它们总是安全的。除了进行造型之外，<em class="le">工作</em>和<em class="le">调用</em>(返回)中剩余的程序代码可以写成好像函数直接修饰<em class="le">我的承诺</em>。</p><p id="5943" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">利用<em class="le">承诺者</em>分为两种用例:同步和异步；</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/b5d9ce6f0c788f9b0c153b0afa5ee448.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*XdnioHXD7awtlPE3hXuTsg.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">每个请求被“连接”，然后按顺序</figcaption></figure><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/adb997f35f624f0b0f2af32926beff9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*KyCwUQZAnFLCVa5xPluMTA.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">请求是异步发出和“加入”的</figcaption></figure><p id="6d96" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这两种情况下,“Run”方法都在上下文运行时被阻塞。一旦取消,“参与者”goroutine的最后一个动作是将内部引用对象“邮寄”回主例程进行解析。虽然这似乎充满了共享冲突，但实际上共享对象的所有规则都得到遵守:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/757a899689d2fce822ba54af0b55ec00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*BEuLhykPP0iHn139So9tdg.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">神奇！</figcaption></figure><h2 id="5023" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated"><strong class="ak">结论</strong></h2><p id="b503" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">这种方法表明，您可以在golang中为线程实现更高级别的抽象。我还认为它回答了一个更根本的问题:在golang中泛型有必要吗？虽然围绕泛型的争论很长，有时超出了我的理解范围，但我相信，如果没有代码生成，它们实际上并不是编写泛型代码所必需的。通过从对象与程序其余部分交互的每一步返回类型化函数，通用行为可以在任意应用程序代码上使用。</p><p id="f3bb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有示例都在Apache 2.0许可下获得许可，并可在<a class="ae lf" href="https://github.com/weberr13/ChannelsForNothing/" rel="noopener ugc nofollow" target="_blank">https://github.com/weberr13/ChannelsForNothing/</a>获得</p></div></div>    
</body>
</html>