<html>
<head>
<title>How to Unit Test Next.js API Routes with Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Typescript对Next.js API路由进行单元测试</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-unit-test-next-js-api-routes-with-typescript-ec1146b4b9b3?source=collection_archive---------1-----------------------#2022-02-17">https://itnext.io/how-to-unit-test-next-js-api-routes-with-typescript-ec1146b4b9b3?source=collection_archive---------1-----------------------#2022-02-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="08f5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如果您需要env变量、模拟数据和Typescript类型，这是您需要的。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/b7abf70e1a066637d898cf55b5921270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/0*CcMHE4ZYA55HkK8H.jpg"/></div></figure><h1 id="8b30" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">介绍</h1><p id="e1ed" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><a class="ae mb" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ir"> Next.js </strong> </a>是一个牛逼的前端框架。它由React提供支持，因此它可以很好地处理React提供的一切:挂钩、上下文、热浏览器重载、Typescript集成，然后它比Create React应用程序更进了一步，提供了更多类似于<a class="ae mb" href="https://nextjs.org/docs/routing/introduction" rel="noopener ugc nofollow" target="_blank">路由</a>、<a class="ae mb" href="https://nextjs.org/docs/basic-features/data-fetching/get-server-side-props" rel="noopener ugc nofollow" target="_blank">服务器端渲染(SSR) </a>、<a class="ae mb" href="https://nextjs.org/docs/basic-features/data-fetching/get-static-props" rel="noopener ugc nofollow" target="_blank">静态站点生成(SSG) </a>的功能，以及SSR和SSG附带的所有SEO功能。 <em class="mc">和</em>内置<a class="ae mb" href="https://nextjs.org/docs/api-routes/introduction" rel="noopener ugc nofollow" target="_blank"> API路由</a> —不需要额外的节点服务器来安全地将API调用代理到数据库、另一个微服务或第三方API。</p><p id="782c" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">在<a class="ae mb" href="https://blues.io?&amp;utm_source=medium.com&amp;utm_medium=web&amp;utm_campaign=sparrow-accelerator&amp;utm_content=unit-test-nextjs-routes" rel="noopener ugc nofollow"> work </a>，我和一个开发团队一直在构建一个<a class="ae mb" href="https://github.com/blues/sparrow-starter" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ir">的新应用</strong> </a>，我们已经开源了这个应用来帮助我们的用户更快地使用我们创建的物联网(IoT)硬件。</p><p id="d167" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">对于我们的第一个“加速器应用”，想法是用户将获得一些我们的<a class="ae mb" href="https://blues.io/products/?&amp;utm_source=medium.com&amp;utm_medium=web&amp;utm_campaign=sparrow-accelerator&amp;utm_content=unit-test-nextjs-routes" rel="noopener ugc nofollow" target="_blank">物联网设备</a>，这些设备将开始收集数据，如温度、湿度、运动等。，他们会将环境数据发送到云<a class="ae mb" href="https://notehub.io?&amp;utm_source=medium.com&amp;utm_medium=web&amp;utm_campaign=sparrow-accelerator&amp;utm_content=unit-test-nextjs-routes" rel="noopener ugc nofollow">中</a>，然后他们会派生出我们的“启动应用程序”代码来启动和运行仪表板，从云中提取他们自己的传感器数据，并在浏览器中显示出来。</p><p id="0539" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">为了构建这个应用程序，我们决定使用Next.js框架，因为它提供了我上面列出的许多好处，其中最重要的一个是能够进行安全的API调用，而不必使用Next.js的<a class="ae mb" href="https://nextjs.org/docs/api-routes/introduction" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ir"> API路由</strong> </a>设置独立的节点服务器。应用程序显示的所有数据都必须从云(或数据库)中获取，设备数据在第一次记录后存储在云中。</p><p id="92e4" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">这是一个生产就绪的应用程序，需要像自动化单元和端到端测试这样的东西来确保应用程序的各个部分按预期工作——这两者都是为了让开发人员和我们的用户相信，随着新功能的添加，现有功能保持不变。</p><p id="a240" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">虽然总的来说，Next.js <a class="ae mb" href="https://nextjs.org/docs/getting-started" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ir">文档</strong> </a>很棒，但它确实有一个不足之处，就是在对这些API路径进行单元测试时。文档中几乎没有任何内容涉及如何使用<a class="ae mb" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>和<a class="ae mb" href="https://testing-library.com/docs/react-testing-library/intro/" rel="noopener ugc nofollow" target="_blank"> React测试库</a>测试API路由——当涉及到任何基于React的应用程序时，这是事实上的单元测试库组合。</p><p id="bf45" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated"><strong class="lh ir">这就是为什么今天我将向您展示如何对Next.js API路由进行单元测试，包括像本地环境变量、模拟数据对象这样的陷阱，甚至像</strong> <code class="fe mi mj mk ml b"><strong class="lh ir">NextApiRequest</strong></code> <strong class="lh ir">这样的Next特定对象的类型脚本类型。</strong></p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="a1d5" class="kn ko iq bd kp kq mt ks kt ku mu kw kx jw mv jx kz jz mw ka lb kc mx kd ld le bi translated">要测试的实际Next.js API路径</h1><p id="8a93" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">所以在我们开始测试之前，让我给你一个简单的例子，这个应用程序可能会进行的API调用的种类。对于我们的应用程序，首先必须从云中获取关于<strong class="lh ir">“网关设备”</strong>的信息。</p><blockquote class="my mz na"><p id="2d54" class="lf lg mc lh b li md jr lk ll me ju ln nb mf lq lr nc mg lu lv nd mh ly lz ma ij bi translated"><strong class="lh ir"> <em class="iq">注:</em> </strong> <em class="iq">我在实际回购中链接过的文件都是GitHub中的历史链接。该项目后来经历了一次重大的重构，为了将来的易用性和灵活性，更干净地划分了不同的层，但是如果您在提交历史中挖掘得足够远(或者只需单击超链接文件名)，您可以看到我们的工作代码，它与我下面描述的相匹配。</em></p></blockquote><h2 id="2acc" class="ne ko iq bd kp nf ng dn kt nh ni dp kx lo nj nk kz ls nl nm lb lw nn no ld np bi translated">获取网关设备信息</h2><p id="3553" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ir">网关</strong>是操作的大脑——有许多传感器都与网关通信，告诉它们在各个位置获得的环境读数，网关负责将来自每个传感器的数据发送到云——这就像你在自行车车轮上看到的轮毂和辐条系统。</p><p id="94f8" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">在应用程序中发生任何其他事情之前，我们必须获得网关信息，稍后可以使用这些信息来计算哪些传感器和读数与哪些网关相关。我不会深入讨论该应用如何工作的更多细节，因为这超出了本文的范围，但你可以在GitHub <a class="ae mb" href="https://github.com/blues/sparrow-starter" rel="noopener ugc nofollow" target="_blank">这里</a>看到整个回购。</p><p id="9b2a" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">让我们关注一下从Next.js应用程序到我们的云的API调用(恰好叫做<a class="ae mb" href="https://notehub.io?&amp;utm_source=medium.com&amp;utm_medium=web&amp;utm_campaign=sparrow-accelerator&amp;utm_content=unit-test-nextjs-routes" rel="noopener ugc nofollow"> Notehub </a>)。为了<a class="ae mb" href="https://dev.blues.io/reference/notehub-api/device-api/#get-device-by-uid?&amp;utm_source=medium.com&amp;utm_medium=web&amp;utm_campaign=sparrow-accelerator&amp;utm_content=unit-test-nextjs-routes" rel="noopener ugc nofollow" target="_blank">查询Notehub </a>，我们需要:</p><ul class=""><li id="eeed" class="nq nr iq lh b li md ll me lo ns ls nt lw nu ma nv nw nx ny bi translated"><a class="ae mb" href="https://dev.blues.io/reference/notehub-api/api-introduction/?&amp;utm_source=medium.com&amp;utm_medium=web&amp;utm_campaign=sparrow-accelerator&amp;utm_content=unit-test-nextjs-routes" rel="noopener ugc nofollow" target="_blank">授权令牌</a>，</li><li id="4e15" class="nq nr iq lh b li nz ll oa lo ob ls oc lw od ma nv nw nx ny bi translated">一个Notehub <a class="ae mb" href="https://dev.blues.io/notehub/notehub-walkthrough/#create-a-new-project?&amp;utm_source=medium.com&amp;utm_medium=web&amp;utm_campaign=sparrow-accelerator&amp;utm_content=unit-test-nextjs-routes" rel="noopener ugc nofollow" target="_blank">项目的ID </a>，</li><li id="e20d" class="nq nr iq lh b li nz ll oa lo ob ls oc lw od ma nv nw nx ny bi translated">和网关<a class="ae mb" href="https://dev.blues.io/reference/glossary/#deviceuid?&amp;utm_source=medium.com&amp;utm_medium=web&amp;utm_campaign=sparrow-accelerator&amp;utm_content=unit-test-nextjs-routes" rel="noopener ugc nofollow" target="_blank">设备的ID </a>。</li></ul><p id="5505" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">下面是通过Next.js调用Notehub获取网关设备数据的例子。我将分解代码块之后发生的事情。</p><blockquote class="my mz na"><p id="0778" class="lf lg mc lh b li md jr lk ll me ju ln nb mf lq lr nc mg lu lv nd mh ly lz ma ij bi translated"><em class="iq">如果您想查看该文件所模仿的原始代码，请单击文件名。</em></p></blockquote><p id="ebba" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated"><code class="fe mi mj mk ml b"><a class="ae mb" href="https://github.com/blues/sparrow-starter/blob/0a0c26c6e0db042b85861846defe621af999d936/src/pages/api/gateways/%5BgatewayUID%5D.ts" rel="noopener ugc nofollow" target="_blank"><strong class="lh ir">pages/api/gateways/[gatewayID].ts</strong></a></code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="of og di oh bf oi"><div class="gh gi oe"><img src="../Images/99a3170e9922b4e2d2b4e4e8c122bd2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kwgd6PwIgyExBzyydjgllg.png"/></div></div><figcaption class="oj ok gj gh gi ol om bd b be z dk translated">获取网关信息的实际API路由代码。</figcaption></figure><p id="1a0f" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">在我们的代码中，<a class="ae mb" href="https://axios-http.com/docs/intro" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ir"> Axios HTTP库</strong> </a>用于使我们的HTTP请求更加干净和简单，有从<code class="fe mi mj mk ml b">.env.local</code>文件传入的<a class="ae mb" href="https://nextjs.org/docs/basic-features/environment-variables" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ir">环境变量</strong> </a>用于调用需要保密的Notehub项目的各个部分(如<code class="fe mi mj mk ml b">APP_ID</code>和<code class="fe mi mj mk ml b">AUTH_TOKEN</code>)，由于这个项目是用Typescript编写的，<code class="fe mi mj mk ml b"><a class="ae mb" href="https://nextjs.org/docs/basic-features/typescript#api-routes" rel="noopener ugc nofollow" target="_blank"><strong class="lh ir">NextApiRequest</strong></a></code> <a class="ae mb" href="https://nextjs.org/docs/basic-features/typescript#api-routes" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ir">和</strong></a><a class="ae mb" href="https://nextjs.org/docs/basic-features/typescript#api-routes" rel="noopener ugc nofollow" target="_blank"><strong class="lh ir"/></a></p><p id="1066" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">导入之后，进行一些验证检查，以确保HTTP请求是一个<code class="fe mi mj mk ml b">GET</code>，查询参数中的<code class="fe mi mj mk ml b">gatewayID</code>是一个字符串(应该是这样的，但是确认一下也无妨)，然后构造对Notehub项目的URL请求(<code class="fe mi mj mk ml b">endpoint</code>)以及允许访问所需的<code class="fe mi mj mk ml b">headers</code>，最后用Axios进行调用。一旦从Notehub返回JSON有效负载，就会读取更多的错误，比如找不到网关ID，如果一切正常，就会返回所有的网关信息。</p><p id="2729" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">有足够的功能和可能的错误场景使它变得有趣，但没有太多的测试。是时候开始编写单元测试了。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="0049" class="kn ko iq bd kp kq mt ks kt ku mu kw kx jw mv jx kz jz mw ka lb kc mx kd ld le bi translated">在Next.js中设置API测试</h1><p id="2ef0" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">好了，现在我们已经看到了我们想要为之编写单元测试的实际API路线，是时候开始了。由于我们只是测试API调用，而不是在DOM中呈现的组件，Jest是这次我们需要的唯一测试框架，但也就是说，仍然有一些额外的配置需要处理。</p><h2 id="7242" class="ne ko iq bd kp nf ng dn kt nh ni dp kx lo nj nk kz ls nl nm lb lw nn no ld np bi translated">安装<code class="fe mi mj mk ml b">node-mocks-http</code>库</h2><p id="8a68" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为了模拟Notehub的HTTP请求和响应对象，我们需要做的第一件事是安装<code class="fe mi mj mk ml b"><a class="ae mb" href="https://www.npmjs.com/package/node-mocks-http" rel="noopener ugc nofollow" target="_blank"><strong class="lh ir">node-mocks-http</strong></a></code>(而不是使用实际的生产数据，因为每次都很难正确设置)。</p><p id="3c56" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">这个库允许任何使用<code class="fe mi mj mk ml b">request</code>和<code class="fe mi mj mk ml b">response</code>对象的基于节点的应用程序模仿HTTP请求(Next.js就是这样做的)。它有一个方便的函数叫做<strong class="lh ir"> createMocks() </strong>，它合并了另外两个函数<code class="fe mi mj mk ml b">createRequest()</code>和<code class="fe mi mj mk ml b">createResponse()</code>，允许我们在同一个函数中模仿<code class="fe mi mj mk ml b">req</code>和<code class="fe mi mj mk ml b">res</code>对象。这让我们可以决定在测试中调用<code class="fe mi mj mk ml b">gatewayHandler()</code>函数时，Notehub应该接受和返回什么。</p><p id="ac92" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">将这个库添加到项目的<code class="fe mi mj mk ml b">devDependencies</code>列表的<code class="fe mi mj mk ml b">package.json</code>文件中，如下所示。</p><pre class="kg kh ki kj gt on ml oo op aw oq bi"><span id="f985" class="ne ko iq ml b gy or os l ot ou">npm install --save-dev node-mocks-http</span></pre><h2 id="9517" class="ne ko iq bd kp nf ng dn kt nh ni dp kx lo nj nk kz ls nl nm lb lw nn no ld np bi translated">为与测试相关的环境变量添加一个` . env.test.local `文件</h2><p id="c146" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我艰难地认识到Next.js项目的<code class="fe mi mj mk ml b">.env.local</code>文件中存在的环境变量(Next想要读取环境变量的<a class="ae mb" href="https://nextjs.org/docs/basic-features/environment-variables" rel="noopener ugc nofollow" target="_blank">规定方式)不会自动填充到它的单元测试中。</a></p><p id="0334" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">相反，我们需要在项目的根目录下创建一个名为<code class="fe mi mj mk ml b">.env.test.local</code>的新文件来保存<a class="ae mb" href="https://nextjs.org/docs/basic-features/environment-variables#test-environment-variables" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ir">测试环境变量</strong> </a>。</p><p id="c1d3" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">该文件基本上是<code class="fe mi mj mk ml b">env.local</code>文件的副本。</p><p id="cba1" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">我们将包括到达我们的API的<code class="fe mi mj mk ml b">BASE_URL</code>，一个有效的<code class="fe mi mj mk ml b">AUTH_TOKEN</code>，一个有效的<code class="fe mi mj mk ml b">APP_ID</code>和一个有效的<code class="fe mi mj mk ml b">DEVICE_ID</code>。<code class="fe mi mj mk ml b">DEVICE_ID</code>是网关设备的ID，它实际上来自应用程序的URL查询参数，但是由于这是对这个路由文件功能的单元测试，为了将我们所有的变量保存在一个集中的地方，我们将把网关的ID作为环境变量传递。</p><p id="8d98" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">下面是您的测试环境变量文件应该包含的内容。</p><blockquote class="my mz na"><p id="79d2" class="lf lg mc lh b li md jr lk ll me ju ln nb mf lq lr nc mg lu lv nd mh ly lz ma ij bi translated"><strong class="lh ir"> <em class="iq">注意:</em> </strong> <em class="iq">无论是这个文件还是你实际的</em> <code class="fe mi mj mk ml b"><em class="iq">.env.local</em></code> <em class="iq">文件都不应该</em>曾经<em class="iq">在GitHub中提交给你的回购。确保这些都在你的</em> <code class="fe mi mj mk ml b"><em class="iq">.gitignore</em></code> <em class="iq">文件中，这样它们就不会意外地出现在任何人都可以读取潜在秘密变量的地方。</em></p></blockquote><p id="9b44" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated"><code class="fe mi mj mk ml b"><strong class="lh ir">.env.test.local</strong></code></p><pre class="kg kh ki kj gt on ml oo op aw oq bi"><span id="8a06" class="ne ko iq ml b gy or os l ot ou">BASE_URL=https://api.notefile.net<br/>AUTH_TOKEN=[MY_AUTH_TOKEN]<br/>APP_ID=[app:MY_NOTEHUB_PROJECT_ID]<br/>DEVICE_ID=[dev:MY_GATEWAY_DEVICE_ID]</span></pre><blockquote class="my mz na"><p id="2930" class="lf lg mc lh b li md jr lk ll me ju ln nb mf lq lr nc mg lu lv nd mh ly lz ma ij bi translated"><strong class="lh ir"> <em class="iq">为您的测试文件使用真实的环境变量:</em> </strong> <em class="iq">虽然在我们最终的测试文件中，您不会看到我们导入所有这些变量来构建Notehub URL，但是如果它们无效并且现在包含在内，测试将会出错——测试实际上是在幕后构建有效的URL，我们只是指定当发出调用时将接收的内容发送回去。未定义的变量或无意义的测试数据变量将导致测试失败。</em></p></blockquote><p id="1ef3" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">做完这两件事，我们就可以开始测试了。</p><h2 id="784f" class="ne ko iq bd kp nf ng dn kt nh ni dp kx lo nj nk kz ls nl nm lb lw nn no ld np bi translated">编写API测试</h2><p id="9762" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为了与Jest推荐的保持一致，我们可以将所有的测试文件存储在下一个名为<code class="fe mi mj mk ml b">__tests__/</code>的项目的根目录下的一个文件夹中，并且为了便于确定哪些测试与哪些组件相关，我倾向于模仿被测试文件的原始文件路径和名称。</p><blockquote class="my mz na"><p id="4da2" class="lf lg mc lh b li md jr lk ll me ju ln nb mf lq lr nc mg lu lv nd mh ly lz ma ij bi translated">如果您喜欢让您的测试与您的实际源文件保持一致，这也是一个有效的选择。这两种代码回购我都用过，所以这真的是个人喜好的问题。</p><p id="8b04" class="lf lg mc lh b li md jr lk ll me ju ln nb mf lq lr nc mg lu lv nd mh ly lz ma ij bi translated">在这种情况下，我倾向于在每个文件夹的根目录下创建 <code class="fe mi mj mk ml b"><em class="iq">__tests__/</em></code> <em class="iq">文件夹，旁边是实际文件所在的位置。因此，在</em> <code class="fe mi mj mk ml b"><em class="iq">pages/api/</em></code> <em class="iq">文件夹中，我会创建一个名为</em> <code class="fe mi mj mk ml b"><em class="iq">__tests__/</em></code> <em class="iq">的新文件夹，并在其中添加任何相关的测试文件。</em></p></blockquote><p id="0784" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">由于这是一个埋在我们的<code class="fe mi mj mk ml b">pages/</code>文件夹中的路由API文件，我建议在<code class="fe mi mj mk ml b">__tests__/</code>文件夹中有一个类似的文件路径:<code class="fe mi mj mk ml b">__tests__/pages/api/gateways/[gatewayID].test.ts</code>。通过这种方式，快速浏览一下文件名就可以告诉我们这个文件到底在测试什么。</p><p id="07b0" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">然后，我们想出可能要覆盖的测试用例。</p><p id="cc71" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">一些要测试的场景包括:</p><ul class=""><li id="74c5" class="nq nr iq lh b li md ll me lo ns ls nt lw nu ma nv nw nx ny bi translated">使用有效的<code class="fe mi mj mk ml b">authToken</code>、<code class="fe mi mj mk ml b">APP_ID</code>和<code class="fe mi mj mk ml b">DEVICE_ID</code>测试来自Notehub的有效响应，这将产生200状态代码。</li><li id="25d0" class="nq nr iq lh b li nz ll oa lo ob ls oc lw od ma nv nw nx ny bi translated">测试不存在的设备的无效网关id，并抛出404错误。</li><li id="9b01" class="nq nr iq lh b li nz ll oa lo ob ls oc lw od ma nv nw nx ny bi translated">测试没有网关ID会导致400错误。</li><li id="e06c" class="nq nr iq lh b li nz ll oa lo ob ls oc lw od ma nv nw nx ny bi translated">并测试尝试进行除了<code class="fe mi mj mk ml b">GET</code>之外的任何类型的HTTP调用都会导致405错误。</li></ul><p id="5281" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">下面是我测试这个API端点的样子。我们将在大代码块之后深入研究细节。</p><blockquote class="my mz na"><p id="e6ff" class="lf lg mc lh b li md jr lk ll me ju ln nb mf lq lr nc mg lu lv nd mh ly lz ma ij bi translated"><em class="iq">如果您想查看该文件所模仿的原始代码，请单击文件名。</em></p></blockquote><p id="a90e" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated"><code class="fe mi mj mk ml b"><a class="ae mb" href="https://github.com/blues/sparrow-starter/blob/b1712d3b34040b12794ddc71671649c401450eea/__tests__/src/pages/api/gateways/%5BgatewayUID%5D.test.ts" rel="noopener ugc nofollow" target="_blank"><strong class="lh ir">__tests__/pages/api/gateways/[gatewayUID].test.ts</strong></a></code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="of og di oh bf oi"><div class="gh gi ov"><img src="../Images/c89421ec3f870c285b83a94cbfc8a36c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vOqmgOvc_0o58vvwTFfMRw.png"/></div></div><figcaption class="oj ok gj gh gi ol om bd b be z dk translated">为测试网关API路由而编写的完整测试。</figcaption></figure><p id="8339" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated"><strong class="lh ir">办理进口</strong></p><p id="5132" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">在编写测试之前，我们需要从<code class="fe mi mj mk ml b">node-mocks-http</code>库中导入<code class="fe mi mj mk ml b">createMocks</code>和<code class="fe mi mj mk ml b">RequestMethod</code>变量。正如我前面提到的，<code class="fe mi mj mk ml b">createMocks()</code>允许我们在一个函数中模拟<code class="fe mi mj mk ml b">req</code>和<code class="fe mi mj mk ml b">res</code>对象，而不是分别模拟它们。</p><p id="d84e" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">此外，由于这是一个Typescript文件，我们需要从<code class="fe mi mj mk ml b">next</code>导入<code class="fe mi mj mk ml b">NextApiRequest</code>和<code class="fe mi mj mk ml b">NextApiResponse</code>类型——就像真正的API route文件一样。</p><p id="1082" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">最后，我们需要导入真正的<code class="fe mi mj mk ml b">gatewayHandler</code>函数——这毕竟是我们要进行单元测试的。</p><p id="98db" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated"><strong class="lh ir">创建一个可重用的</strong> <code class="fe mi mj mk ml b"><strong class="lh ir">mockRequestResponse()</strong></code> <strong class="lh ir">辅助函数</strong></p><p id="8321" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">在创建了一个<code class="fe mi mj mk ml b">describe</code>块来存放所有的单元测试之后，我创建了一个可重用的助手函数来为每个测试设置模拟的API调用。</p><p id="8e2e" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">这个可重用的<code class="fe mi mj mk ml b">mockRequestResponse()</code>函数，允许我们只需要构建一次模拟的HTTP调用，减少了测试文件中重复代码的数量，并使整体可读性更容易。尽管我们可能会根据测试的场景改变<code class="fe mi mj mk ml b">req</code>或<code class="fe mi mj mk ml b">res</code>对象的各个部分，但是编写一次这个函数并能够在每个测试中调用它是一个很大的代码(和时间)节省。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="of og di oh bf oi"><div class="gh gi ow"><img src="../Images/5dcf19a8636fd68fead2d374f6a8bd23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZkDTGPNxwHaeH7vunY2Ksw.png"/></div></div><figcaption class="oj ok gj gh gi ol om bd b be z dk translated">单元测试的可重用辅助函数。</figcaption></figure><p id="b9c7" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">在上面，我从更大的代码块中提取了一个片段，它只关注于<code class="fe mi mj mk ml b">mockRequestResponse()</code>函数和它在构造过程中需要的两个环境变量<code class="fe mi mj mk ml b">authToken</code>和<code class="fe mi mj mk ml b">gatewayID</code>。在声明函数名之后，我们使用<code class="fe mi mj mk ml b">node-http-mocks</code> <code class="fe mi mj mk ml b">RequestMethod</code>对象:<code class="fe mi mj mk ml b">method:RequestMethod="GET"</code>来指定它的方法，然后我们析构并设置来自<code class="fe mi mj mk ml b">createMocks()</code>函数的<code class="fe mi mj mk ml b">req</code>和<code class="fe mi mj mk ml b">res</code>对象类型为<code class="fe mi mj mk ml b">NextApiRequest</code>和<code class="fe mi mj mk ml b">NextApiResponse</code>(就像在我们的真实代码中一样)。</p><p id="2eb7" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">我们用我们的测试版本<code class="fe mi mj mk ml b">authToken</code>创建了Notehub需要的同一个<code class="fe mi mj mk ml b">req.headers</code>对象，并将模拟查询参数<code class="fe mi mj mk ml b">gatewayID</code>设置为等于我们的<code class="fe mi mj mk ml b">.env.test.local</code>文件提供的<code class="fe mi mj mk ml b">gatewayID</code>。</p><p id="056b" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated"><strong class="lh ir">编写每个测试</strong></p><p id="92cb" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">有了我们构建的<code class="fe mi mj mk ml b">mockRequestResponse()</code>函数，我们可以简单地在每个测试中调用它来获得我们模拟的<code class="fe mi mj mk ml b">req</code>和<code class="fe mi mj mk ml b">res</code>对象，用这些模拟的对象调用实际的<code class="fe mi mj mk ml b">gatewayHandler()</code>函数，并确保返回的响应是我们期望的。</p><p id="972d" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">如果在调用<code class="fe mi mj mk ml b">gatewayHandler</code>之前需要修改<code class="fe mi mj mk ml b">req</code>对象的属性，那么直接调用<code class="fe mi mj mk ml b">mockRequestResponse()</code>函数，然后修改<code class="fe mi mj mk ml b">req</code>对象需要更新的任何属性。</p><pre class="kg kh ki kj gt on ml oo op aw oq bi"><span id="1ee7" class="ne ko iq ml b gy or os l ot ou">const<em class="mc"> </em>{<em class="mc"> req</em>,<em class="mc"> res </em>}<em class="mc"> </em>=<em class="mc"> mockRequestResponse</em>();<br/>req<em class="mc">.</em>query = { gatewayID: 'hello_world' };</span></pre><p id="b295" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">为了检查响应对象，特别是对于当网关ID丢失或无效时传递不同错误字符串的错误场景，我们可以使用<code class="fe mi mj mk ml b">res._getJSONData()</code>函数实际读出响应的内容。这样，我们可以检查实际的错误消息以及HTTP状态代码。</p><p id="98d7" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">很方便，对吧？</p><h2 id="7836" class="ne ko iq bd kp nf ng dn kt nh ni dp kx lo nj nk kz ls nl nm lb lw nn no ld np bi translated">检查测试代码覆盖率</h2><p id="9a99" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果您正在使用Jest的代码覆盖率报告特性，现在是运行该功能并在终端打印输出或浏览器中检查该文件的代码覆盖率的好时机。</p><blockquote class="my mz na"><p id="8a48" class="lf lg mc lh b li md jr lk ll me ju ln nb mf lq lr nc mg lu lv nd mh ly lz ma ij bi translated"><em class="iq">您可以通过命令行输入:</em> <code class="fe mi mj mk ml b"><em class="iq">open coverage/lcov-report/index.html</em></code>来打开代码覆盖率报告</p></blockquote><p id="70b2" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">希望当您导航到<code class="fe mi mj mk ml b">pages/api/</code>路线的代码覆盖率时，您将会看到这个文件的一些更好的代码覆盖率。</p><p id="8f03" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">现在，根据需要向所有其他API路径添加单元测试。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="6813" class="kn ko iq bd kp kq mt ks kt ku mu kw kx jw mv jx kz jz mw ka lb kc mx kd ld le bi translated">结论</h1><p id="d550" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我是Next.js框架的粉丝——它的核心是React，内置了很多细节，比如SEO和API routes。虽然Next符合当今许多项目的要求，并帮助我们快速启动和运行项目，但它的测试文档仍有一些不足之处——特别是它的一些非常棒的附加功能，如API routes。</p><p id="d19b" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">自动化测试是当今现代软件世界的一项要求，能够编写单元测试来继续确认应用程序的功能是否按预期工作是不容忽视或忽略的。幸运的是，<code class="fe mi mj mk ml b">node-mocks-http</code>库有助于简化模仿的<code class="fe mi mj mk ml b">req</code>和<code class="fe mi mj mk ml b">res</code>对象的设置，因此我们可以从各个角度测试我们的Next.js应用——从DOM中的表示组件到后端的API路径。</p><p id="6c50" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">过几周再来看看——我会写更多关于JavaScript、React、IoT或其他与web开发相关的东西。</p><p id="ba6f" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">如果你想确保你不会错过我写的一篇文章，在这里注册我的时事通讯:<a class="ae mb" href="https://paigeniedringhaus.substack.com" rel="noopener ugc nofollow" target="_blank">https://paigeniedringhaus.substack.com</a></p><p id="b466" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated">感谢阅读。我希望学习如何对API routes进行单元测试对你下一个Next.js项目有所帮助(没有双关的意思！).</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="c1df" class="kn ko iq bd kp kq mt ks kt ku mu kw kx jw mv jx kz jz mw ka lb kc mx kd ld le bi translated">参考资料和更多资源</h1><ul class=""><li id="150a" class="nq nr iq lh b li lj ll lm lo ox ls oy lw oz ma nv nw nx ny bi translated"><a class="ae mb" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js框架</a></li><li id="6164" class="nq nr iq lh b li nz ll oa lo ob ls oc lw od ma nv nw nx ny bi translated"><a class="ae mb" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest单元测试库</a></li><li id="eb37" class="nq nr iq lh b li nz ll oa lo ob ls oc lw od ma nv nw nx ny bi translated"><a class="ae mb" href="https://testing-library.com/docs/react-testing-library/intro/" rel="noopener ugc nofollow" target="_blank"> React测试库</a></li><li id="9a35" class="nq nr iq lh b li nz ll oa lo ob ls oc lw od ma nv nw nx ny bi translated"><a class="ae mb" href="https://axios-http.com/docs/intro" rel="noopener ugc nofollow" target="_blank"> Axios HTTP库</a>文档</li><li id="245f" class="nq nr iq lh b li nz ll oa lo ob ls oc lw od ma nv nw nx ny bi translated"><a class="ae mb" href="https://notehub.io?&amp;utm_source=medium.com&amp;utm_medium=web&amp;utm_campaign=sparrow-accelerator&amp;utm_content=unit-test-nextjs-routes" rel="noopener ugc nofollow"> Notehub </a>云</li><li id="d490" class="nq nr iq lh b li nz ll oa lo ob ls oc lw od ma nv nw nx ny bi translated"><a class="ae mb" href="https://www.npmjs.com/package/node-mocks-http" rel="noopener ugc nofollow" target="_blank">节点模仿HTTP </a>库</li><li id="e0d3" class="nq nr iq lh b li nz ll oa lo ob ls oc lw od ma nv nw nx ny bi translated">完整<a class="ae mb" href="https://github.com/blues/sparrow-starter" rel="noopener ugc nofollow" target="_blank"> GitHub项目回购</a></li></ul></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><p id="9205" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mf lq lr ls mg lu lv lw mh ly lz ma ij bi translated"><em class="mc">最初发表于</em><a class="ae mb" href="https://www.paigeniedringhaus.com/blog/how-to-unit-test-next-js-api-routes-with-typescript" rel="noopener ugc nofollow" target="_blank"><em class="mc">【https://www.paigeniedringhaus.com】</em></a><em class="mc">。</em></p></div></div>    
</body>
</html>