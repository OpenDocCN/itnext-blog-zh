<html>
<head>
<title>.NET Workflow Engines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">。NET工作流引擎</h1>
<blockquote>原文：<a href="https://itnext.io/net-workflow-engines-d6f794d121e1?source=collection_archive---------2-----------------------#2021-02-02">https://itnext.io/net-workflow-engines-d6f794d121e1?source=collection_archive---------2-----------------------#2021-02-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f142" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我的文章<a class="ae kl" href="https://maximcus.medium.com/workflow-engine-is-a-tool-for-you-3f34e4dde831" rel="noopener">的. NET特定延续，工作流引擎是你的工具</a>。如果您不知道什么是工作流引擎或者为什么要使用工作流引擎，请参考上一篇文章。我在这里只重复定义:</p><blockquote class="km kn ko"><p id="39b6" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated"><em class="iq">一个应该被可靠执行的算法被称为</em>工作流。<em class="iq">一个工作流的单个步骤或语句被称为一个</em>活动。<em class="iq">负责可靠执行工作流的独立应用或嵌入式框架被称为</em>工作流引擎<em class="iq">。</em></p><p id="9d79" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated"><em class="iq">工作流引擎通过保持工作流的状态并自动重新执行最后失败的活动，直到整个工作流完成，从而确保工作流的可靠性。</em></p></blockquote><p id="dbc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将</p><ol class=""><li id="e668" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">提供…的分类。Net工作流引擎如何表达工作流</li><li id="fe96" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">选择最好的。NET工作流引擎，供开发人员在编写时使用</li></ol><p id="19b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不得不分析。NET工作流引擎，我发现它们都可以归为三类。</p><h1 id="0609" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">1.XML/UI设计器</h1><p id="6f9b" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">创建这些类型的工作流引擎时，就好像业务人员希望自己定义工作流一样(因为谁不想成为程序员)。这里有几个来自<a class="ae kl" href="https://docs.microsoft.com/en-us/dotnet/framework/windows-workflow-foundation/" rel="noopener ugc nofollow" target="_blank">Windows Workflow Foundation</a>的例子:</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mk"><img src="../Images/78c8f0b47b990536447e0421788fc53c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxOpHO97kCtxXfFN_GCJng.png"/></div></div></figure><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/27dc6a13473fd8bc2ac7bd5f0ad901f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*D3lxb2hlpaMv2YDgT8WUpQ.png"/></div></figure><p id="b509" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题是(至少在我的经验中)——出于某种原因，业务人员更喜欢将编程委托给软件工程师。对于软件工程师来说，使用声明性语言或使用设计器来创建命令式算法(工作流)根本不是最佳方式。更不用说调试和单元测试了。</p><p id="0d91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种类型的工作流引擎的一个可取之处是，您基本上可以将DSL作为XML，从而限制您的工作流中允许的内容。但是我认为XML仍然是一个糟糕的选择——如果你需要，DSL可以使用一些真正的编程语言来代替。</p><p id="b906" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想要另一个例子，你可以看看<a class="ae kl" href="https://workflowengine.io/demo/designer/" rel="noopener ugc nofollow" target="_blank"> workflowengine.io </a>的漂亮的交互式演示，但是我要寻找一些对开发人员更友好的东西。</p><h1 id="1daa" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">2.工作流生成器</h1><p id="aee6" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">在C#中定义工作流的一种简单方法是使用某种生成器:</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mx"><img src="../Images/38369562b276068504397e9eb5d6e385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e34LrEQR4XYFrLu98YDKeA.png"/></div></div></figure><p id="5f19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个例子摘自<a class="ae kl" href="https://workflow-core.readthedocs.io/en/latest/getting-started/" rel="noopener ugc nofollow" target="_blank">工作流核心</a>。构建器很适合这个问题，因为您需要某种方法来定义活动(工作流步骤)并在活动之间保持工作流状态。</p><p id="58af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题是——当使用构建器来定义工作流时，您不能使用标准的控制流语句(<code class="fe my mz na nb b">if-else</code>、<code class="fe my mz na nb b">for</code>等)。您必须改用生成器方法。更实际的例子是，看看Elsa工作流程中所谓的<a class="ae kl" href="https://elsa-workflows.github.io/elsa-core/docs/guides-document-approval" rel="noopener ugc nofollow" target="_blank">简单文档审批工作流程</a>。我并不是说Elsa有什么不好——事实是，使用这种方法时，即使相对简单的工作流也会变得非常冗长和笨拙。</p><p id="9d22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，我们能做得更好吗？</p><h1 id="858e" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">3.本机工作流</h1><p id="3d78" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">事实证明，通过一些巧妙的技巧，工作流可以“隐藏”在本地语言结构之后。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nc"><img src="../Images/9092eeb1787b68176472e4d395b028e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4COOyR4t277pGAHFLe2QFw.png"/></div></div></figure><p id="3fdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个例子来自<a class="ae kl" href="https://doc.neonkube.com/Neon.Cadence-GettingStarted-MultiStepWorkflows.htm" rel="noopener ugc nofollow" target="_blank">霓虹。Cadence </a> —优步<a class="ae kl" href="https://cadenceworkflow.io/" rel="noopener ugc nofollow" target="_blank"> Cadence </a>工作流引擎的C#客户端库。<code class="fe my mz na nb b">IEmailActivity</code>方法只是普通的C#方法，没什么特别的。神奇的事情发生在activity stubs中，它将执行activity<em class="kp">和</em>并在activity成功执行后保存它们的结果。</p><p id="89e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">工作流引擎应该能够恢复任何工作流状态，例如，如果工作流必须等待很长时间并从内存中卸载，或者如果工作流引擎节点失败。如果我们只有单个活动的结果，我们如何恢复工作流状态？唯一的方法是从头开始重放工作流，并使用以前保存的活动执行结果。</p><p id="a2d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是这些工作流类型的主要缺点。在编写工作流时，你必须特别小心，确保它是完全确定的(例如<code class="fe my mz na nb b">Guid.NewGuid</code>或<code class="fe my mz na nb b">DateTime.Now</code>必须封装在活动中，而不能直接在工作流中使用)。此外，您不能在工作流中创建无限的循环，因为这将意味着无限的重放时间(有解决方法)。</p><p id="503d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但即使有所有的缺点，对我来说这种权衡是值得的。使用我的原生工具来编写、阅读、调试和测试工作流的便利性不能被夸大。</p><h1 id="a9d2" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">最好的。NET工作流引擎？</h1><p id="b5db" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">很明显，是最好的。Net工作流引擎对我来说是最后一类。我只知道两个这样的工作流引擎。</p><p id="376e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Cadence(以及它的下一个版本<a class="ae kl" href="https://www.temporal.io/" rel="noopener ugc nofollow" target="_blank"> Temporal </a>)有很多优势，包括<a class="ae kl" href="https://github.com/uber/cadence-web" rel="noopener ugc nofollow" target="_blank">一个很好的网络用户界面</a>用于观察。与此同时。网客户端<a class="ae kl" href="https://doc.neonkube.com/Neon.Cadence-Overview.htm" rel="noopener ugc nofollow" target="_blank">霓虹。Cadence </a>是由第三方开发者创建的，它还不允许单元测试，这对我来说是一个障碍。</p><p id="17da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">微软的<a class="ae kl" href="https://github.com/Azure/durabletask" rel="noopener ugc nofollow" target="_blank">持久任务框架</a>意外摘得桂冠。很长一段时间以来，我忽略了这个工作流引擎，我为此责怪微软(对不起，微软人)。</p><p id="600a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我忽略持久任务框架的原因是它明显缺乏工作流和活动的强类型化。在<a class="ae kl" href="https://github.com/Azure/durabletask/wiki/Example---Video-Encoding" rel="noopener ugc nofollow" target="_blank">中，由官方文档提供的每个</a> <a class="ae kl" href="https://github.com/Azure/durabletask/wiki/Error-Handling-&amp;-Compensation" rel="noopener ugc nofollow" target="_blank">示例</a>工作流和活动都是使用<code class="fe my mz na nb b">typeof</code>调用的，而不是使用一些强类型接口。github知识库的主要readme.md表明Azure持久功能(由持久任务框架支持)的文档可能会有所帮助，但是<a class="ae kl" href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-overview?tabs=csharp#application-patterns" rel="noopener ugc nofollow" target="_blank">它的示例</a>甚至不使用类型——它们使用普通字符串来调用活动。很好。非常容易维护。</p><p id="2c8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不知何故，我在整个持久任务框架存储库中偶然发现了一个例子，它展示了如何使用强类型接口调用活动。寻找，你就会找到。考虑到这一点，我认为实现强类型包装器来调用工作流应该不成问题。</p><p id="f49c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">持久任务框架有许多不错的特性，我没有时间在这里描述。虽然我认为这是最好的。NET工作流引擎，这当然可能不是你的情况。例如，受支持的现成持久性存储仅限于<a class="ae kl" href="https://github.com/Azure/durabletask" rel="noopener ugc nofollow" target="_blank"> Azure选项</a>，这可能很不适合你(尽管根据微软的说法，创建到任何持久性存储的绑定都不是问题，因为唯一的要求是一些非常基本的键值存储功能)。</p><p id="3bbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您当然应该选择最适合您的需求和您试图解决的问题的工作流引擎。希望这个小指南能为你提供一些帮助你开始的信息。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nd"><img src="../Images/313613f89769acde11e5307ebacc590b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m5qCsiWIJc9ZR5eFzGsnig.jpeg"/></div></div></figure></div></div>    
</body>
</html>