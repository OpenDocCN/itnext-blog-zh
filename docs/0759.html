<html>
<head>
<title>Angular 2+ Progressive Image Loader</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度2+渐进式图像加载器</h1>
<blockquote>原文：<a href="https://itnext.io/angular-2-progressive-image-loader-a1b053195d14?source=collection_archive---------3-----------------------#2018-05-22">https://itnext.io/angular-2-progressive-image-loader-a1b053195d14?source=collection_archive---------3-----------------------#2018-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1f3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能已经注意到，某些网站会先加载低质量的图像，当全分辨率图像准备就绪时，它会用全尺寸图像替换低质量图像。在这个媒介上，你可以注意到这个效果。低质量的图像是简单模糊的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/181fbb5a50e594f1903867fd89615637.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*-q9ZmJyqcPjNS3i7LKGZQg.gif"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">媒体的渐进图像加载示例</figcaption></figure><h1 id="44e4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">入门指南</h1><p id="98fe" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在我的项目中，我使用Amazon s3存储图像，使用graphics magick(<a class="ae ma" href="http://www.graphicsmagick.org/" rel="noopener ugc nofollow" target="_blank">http://www.graphicsmagick.org/</a>)调整图像大小。当用户上传照片时，我将全尺寸照片上传到一个“临时”桶，然后触发后端从临时桶下载文件，并使用graphics magick将图像分成小、中、大尺寸。</p><p id="c3c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我上传到一个临时桶，然后在后端下载它的原因是graphics magick只能在后端运行，并且图像通常太大，如果不进行多部分http POST就无法通过http，并且不需要进入我正在进行的项目的太多细节，从前端上传会更容易/更有效。你可以在这里看到我是如何做这个<a class="ae ma" href="https://gist.github.com/lukasasorensen/fdf1b63a614e03fa94dc826d920ad5a1" rel="noopener ugc nofollow" target="_blank">的，但是要知道它可能不适合你的项目。</a></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated"><a class="ae ma" href="https://gist.github.com/lukasasorensen/fdf1b63a614e03fa94dc826d920ad5a1" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/lukasasorensen/FD f1 b 63 a 614 e 03 fa 94 DC 826d 920 ad 5a 1</a></figcaption></figure><p id="a4b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不太理解承诺，那么不要担心。第45行接受size数组([50，200，500])，并以size作为参数为数组中的每个大小分配一个新的进程函数。因此，变量actions本质上变成:[process(50)，process(200)，process(500)]并且第46行获取该数组并使其成为一个可执行的承诺，该承诺在数组中的每个承诺被执行之前不会运行then()。</p><p id="fcd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面代码中唯一真正重要的部分是第21行，它去掉了图像名称的文件扩展名，并替换为“_[size]。jpg " ie image.png = &gt; image _ 50 . jpg，image_200.jpg，image_800.jpg。这是图像加载器获取正确尺寸所必需的。</p><p id="2d62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，将图像位置添加到数据库中。</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="d6ef" class="mi ky iq me b gy mj mk l ml mm">post: {<br/>  id: 1,<br/>  body: 'lorem ipsum',<br/>  image: {<br/>    url: {<br/>      sm: s3BucketUrl/image_50.jpg,<br/>      md: s3BucketUrl/image_200.jpg,<br/>      lg: s3BucketUrl/image_800.jpg<br/>    }<br/>  }<br/>}</span></pre><h1 id="00dc" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">图像加载器指令</h1><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated"><a class="ae ma" href="https://gist.github.com/lukasasorensen/5e54474b8d041cc44c456562572e6bac" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/lukasasorensen/5e 54474 b 8d 041 cc44 c 456562572 E6 BAC</a></figcaption></figure><p id="5df0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不明白角度指令是如何工作的，我建议你先阅读<a class="ae ma" href="https://angular.io/guide/attribute-directives" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="ac49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们仔细分析一下这个指令。</p><p id="0aeb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第18行定义了一个图像源，如果它试图加载的图像失败。而下一行(19)告诉加载程序要加载多大尺寸的图像。接下来，我们有一个事件发射器来告诉父组件加载图像时出错。</p><p id="684c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是如何使用该指令的示例:</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="017b" class="mi ky iq me b gy mj mk l ml mm">&lt;img  <br/>  src="{{profileImage?.url?.sm}}"   <br/>  image-loader  <br/>  [imgSize]="lg"  <br/>  [fallback]="/assets/fallback-image.jpg"     <br/>  (emitOnError)="handleImageError()" <br/>/&gt;</span></pre><h1 id="7cc5" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">onLoad()</h1><p id="85b5" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">回到指令。第35–41行将监听器连接到image onload和onerror函数，以允许我们在这些事件发生时运行代码。并在我们加载完图像后给我们一些函数来停止监听器。</p><p id="7cbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:不要在img标签的html模板中使用(onload)或(onerror)。这将使您的应用程序面临可能的XSS攻击！:'(</p><p id="3ce1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看第63行的自定义onLoad函数。首先，我们停止应用程序监听加载事件。第65行我们在每个“_”处拆分src字符串，并将其分配给一个新数组。然后，我们弹出数组中的最后一项，即“_50.jpg ”,因为这是较小的图像大小。并将数组重新连接在一起，放回被split函数删除的所有“_”。最后，我们运行loadLargeImage()。</p><h1 id="77d2" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">loadLargeImage()</h1><p id="5ab5" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">首先，在第44行我们添加了大图像后缀和扩展名。在本例中是“_800.jpg”。我们定义一个新的图像，并将其命名为largeImage，给它一个源，这个源应该是我们创建的大图像的url，然后等待它完成加载。</p><p id="aa73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">加载完成后，我们使用Angular的Renderer2将原生元素(指令所在的img元素)源替换为大图像源。瞧啊！有用！</p><h1 id="dca1" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">一个错误()</h1><p id="d8d1" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">如果图像因为任何原因失败。该指令将使用带有onError函数的回退映像src替换本机元素src。</p><h1 id="cc53" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">恩贡德斯特罗伊</h1><p id="5f13" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">当指令不再使用时，移除事件侦听器。</p><h1 id="0f53" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="49ca" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">渐进式图像加载器允许用户看到较低质量的图像，而您的网站在后台加载较大的图像，并处理图像错误，而不会显示难看的坏图像链接。</p><p id="0e60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以进一步学习这个教程，用html画布或graphics magick like Medium模糊你的小尺寸图像。</p><p id="fb4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读！❤</p><p id="fcfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">——卢卡斯</p></div></div>    
</body>
</html>