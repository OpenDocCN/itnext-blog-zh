<html>
<head>
<title>Avoid ugly If/else blocks &amp; make your code modular with Strategy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免丑陋的If/else块&amp;用策略使你的代码模块化</h1>
<blockquote>原文：<a href="https://itnext.io/avoid-ugly-if-else-blocks-make-your-code-modular-with-strategy-1c3364b2f920?source=collection_archive---------1-----------------------#2019-04-21">https://itnext.io/avoid-ugly-if-else-blocks-make-your-code-modular-with-strategy-1c3364b2f920?source=collection_archive---------1-----------------------#2019-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/25a096b93535bdbf39e23fe09b92b4ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dKQPIBBrvE-GKqSpXRpoeA.jpeg"/></div></div></figure><p id="efdb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">新的ES6语法旨在使我们的代码更加简洁明了。它成功地完成了这个目标:像析构、字符串文字、扩展操作符等等。都是提高代码可读性的好工具。</p><h2 id="0ed1" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">丑陋的if/else</h2><p id="a625" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">一个不太可能改变的特殊语法是if/else和switch语句。我不知道你怎么想，但我总是发现它们是我代码中最丑陋的部分。然而，这是一种无法避免的极其必要的邪恶。</p><p id="ece2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在业务应用程序中，我们几乎总是面临这样的情况:我们必须实现某种路由方法，根据条件执行特定动作的变化。这些方法通常以冗长难看的if/else或switch语句告终。<em class="lx">(支付选项、电子邮件路由、多个认证提供商等。)</em></p><p id="64cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我想和你分享一个我最近学到的模式，我认为它可以帮助你避免这些情况。</p><h1 id="73ce" class="ly la it bd lb lz ma mb le mc md me lh mf mg mh lk mi mj mk ln ml mm mn lq mo bi translated">战略</h1><p id="3b04" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">我所说的模式叫做策略。这种模式是由GoF ( <a class="ae mp" href="https://en.wikipedia.org/wiki/Design_Patterns" rel="noopener ugc nofollow" target="_blank">四人帮</a>)推广的，它是向应用程序逻辑的某些部分添加可变的、可互换的部分的伟大工具。</p><p id="9ab6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么它是如何工作的呢？策略通过一个商定的接口实现功能的可变部分，该接口用于我们称之为“上下文”的通用对象。基于客户端的调用，上下文使用不同的策略来执行特定的任务。</p><p id="7bd9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">把策略集想象成一个工具箱，把环境想象成一个工匠。工匠根据不同的工作使用不同的工具。但是在这种情况下，所有的工具都有相同类型的使用说明。</p><p id="7c19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面的图表进一步阐述了这一观点:</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/5ea9fd3da257d1a0ffabb433b22b1fed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/0*7phVGYnsYH96Jndv"/></div></figure><h2 id="1f5d" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">护照。射流研究…</h2><p id="ac6a" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated"><a class="ae mp" href="http://www.passportjs.org/" rel="noopener ugc nofollow" target="_blank">护照。JS </a>是使用策略模式的完美例子。护照。JS是一个用于在节点中轻松集成认证系统的库。JS应用。它有多个不同的界面，可以根据你想使用的提供商来设置认证(脸书、<em class="lx">谷歌、推特等等</em>)。您需要做的就是将您需要的接口插入到您的身份验证逻辑中。此外，所有这些接口都是可以互换的，你可以很容易地把一个换成另一个。</p><h2 id="2152" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">收据发送者</h2><p id="f760" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">我相信现在你至少对战略模式有了一个基本的了解，所以理论已经足够了！让我们尝试构建一个简单的系统，根据用户下订单时使用的客户端向用户发送收据。</p><h2 id="da0c" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">定义策略</h2><p id="a474" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">让我们从充实我们的策略开始吧。首先让我们定义我们的电子邮件策略:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="59ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用<a class="ae mp" href="https://www.npmjs.com/package/mailgun-js" rel="noopener ugc nofollow" target="_blank"> mailgun </a>模块发送电子邮件。策略对象有一个方法<code class="fe mx my mz na b">send</code>，它接受<code class="fe mx my mz na b">receiptHtml</code>和<code class="fe mx my mz na b">userEmail</code>作为参数。</p><p id="7ebd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们继续我们的松弛策略:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="e615" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用<a class="ae mp" href="https://www.npmjs.com/package/slack" rel="noopener ugc nofollow" target="_blank"> slack的</a> npm库通过我们想象的slack机器人发送收据。这里需要注意一件重要的事情:</p><ul class=""><li id="e9c3" class="nb nc it kd b ke kf ki kj km nd kq ne ku nf ky ng nh ni nj bi translated">Strategy的<code class="fe mx my mz na b">send</code>方法签名与其电子邮件签名相同</li></ul><h2 id="ff2d" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">收据经理</h2><p id="767d" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">现在我们已经定义了我们的策略，让我们定义我们的收据管理器类，它将为收据生成html，并使用我们的策略将收据发送给用户:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="dee3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我省略了<code class="fe mx my mz na b">_generateReceiptHtml</code>方法的实现，因为它与我们的例子无关。有趣的部分是<code class="fe mx my mz na b">sendReceipt</code>方法:</p><ul class=""><li id="71e4" class="nb nc it kd b ke kf ki kj km nd kq ne ku nf ky ng nh ni nj bi translated">我们使用<code class="fe mx my mz na b">_generateReceiptHtml</code>为收据生成html</li><li id="27ae" class="nb nc it kd b ke nk ki nl km nm kq nn ku no ky ng nh ni nj bi translated">我们使用作为参数传递给我们的策略来发送回执</li></ul><p id="0fdc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我们的两个策略有相同的方法签名，所以我们可以互换使用它们，而<code class="fe mx my mz na b">ReceiptManager</code>不会意识到它们的区别。</p><p id="5dbb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，让我们看看如果我们不定义我们的战略，<code class="fe mx my mz na b">sendReceipt</code>会是什么样子:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="f6ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意<code class="fe mx my mz na b">switch</code>语句是如何降低我们代码的可读性的。这种方法现在看起来可能还不错，但是以后，如果我们决定增加更多的交付收据的渠道，这种方法就会变得很难看。</p><h1 id="3c13" class="ly la it bd lb lz ma mb le mc md me lh mf mg mh lk mi mj mk ln ml mm mn lq mo bi translated">客户</h1><p id="b62c" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">现在是最后一部分，让我们看看与我们的收据管理器一起使用我们的策略有多简单:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="97f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">简单不是吗？我们需要做的就是根据我们想要使用的渠道实例化适当的策略，并将其传递给我们的收据管理器。</p><p id="e5f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个帖子到此为止！小免责声明:<strong class="kd iu">策略模式可能并不适用于每一种情况，有时可能有些矫枉过正</strong>。因为归根结底，这种模式只是一种工具，就像任何工具一样，你需要确保它适合你的工作。</p><p id="a6dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，策略可以是一个很好的方法来加强关注点的分离，并使代码的各个部分更加模块化和可互换。</p><p id="0a19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢您的阅读！</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="5224" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lx">原载于2019年4月21日</em><a class="ae mp" href="https://isamatov.com/avoid-ugly-if-else-blocks-with-strategy/" rel="noopener ugc nofollow" target="_blank"><em class="lx">https://isamatov.com</em></a><em class="lx">。</em></p></div></div>    
</body>
</html>