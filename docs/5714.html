<html>
<head>
<title>Secures REST APIs with Spring Security 5 and Auth0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Spring Security 5和Auth0保护REST APIs</h1>
<blockquote>原文：<a href="https://itnext.io/secures-rest-apis-with-spring-security-5-and-auth0-41d579ca1e27?source=collection_archive---------0-----------------------#2021-05-09">https://itnext.io/secures-rest-apis-with-spring-security-5-and-auth0-41d579ca1e27?source=collection_archive---------0-----------------------#2021-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6031" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Spring Security 5弃用了最初的Spring Security OAuth模块，并重写了OAuth2/Oidc实现，使其成为核心模块的一部分。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/7d6f7bd6189c4719d7ee5ed2bd4376b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QhbQzmBZJD2sMMlR-Cacrg.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://unsplash.com/photos/SwbsW4uf1Qs" rel="noopener ugc nofollow" target="_blank">图片来自https://unsplash.com/photos/SwbsW4uf1Qs</a></figcaption></figure><p id="9f4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">OAuth协议定义了4个角色，包括<em class="lc">资源所有者</em>、<em class="lc">客户端</em>、<em class="lc">授权服务器</em>和<em class="lc">资源服务器</em>。假设您正在手机中使用一个应用程序，您(<em class="lc">资源所有者</em>)授权该应用程序(本身呈现一个<em class="lc">客户端</em>角色)执行一个授权流程，以从授权服务器获取访问令牌，然后利用该令牌与受保护的资源(来自<em class="lc">资源服务器</em>)进行交互。</p><p id="a7c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Oidc是对OAuth2协议的补充。在Spring Security 5中，它没有在API级别和配置中明确区分它们。并且现在大多数OAuth2兼容提供商支持Oidc协议。</p><blockquote class="ld le lf"><p id="7627" class="jn jo lc jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated"><em class="iq">如果你是OAuth2和OIDC的新手，请查看官方</em><a class="ae lb" href="https://oauth.net/2/" rel="noopener ugc nofollow" target="_blank"><em class="iq">OAuth 2 docs</em></a><em class="iq">并探索</em><a class="ae lb" href="https://openid.net/connect/" rel="noopener ugc nofollow" target="_blank"><em class="iq">OpenId Connect</em></a><em class="iq">相关规范。对于没有耐心的用户来说，来自DigitalOcean的</em> <a class="ae lb" href="https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2" rel="noopener ugc nofollow" target="_blank"> <em class="iq">这篇入门文章</em> </a> <em class="iq">是一个很好的起点。</em></p></blockquote><p id="f8a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Spring Security 5，很容易在应用程序中设置OAuth2 <em class="lc">客户端</em>和<em class="lc">资源服务器</em>角色。还有<a class="ae lb" href="https://github.com/spring-projects-experimental/spring-authorization-server" rel="noopener ugc nofollow" target="_blank">的另一个孵化器项目</a>，它允许你服务一个定制的<em class="lc">授权服务器</em>。在实际应用中，我认为选择成熟的IDP服务来简化多种认证服务和高级功能的集成工作是一个明智的选择，例如，您希望集成Google帐户、脸书、Twitter和自定义用户名/密码认证，并在您的应用中启用两阶段认证。Auth0 和<a class="ae lb" href="https://www.okta.com" rel="noopener ugc nofollow" target="_blank"> Okta </a>是该领域领先的IDP服务，它们为您的应用程序中的所有用例提供出色的管理UI和丰富的SDK。在开源世界中，<a class="ae lb" href="https://www.keycloak.org/" rel="noopener ugc nofollow" target="_blank"> Keycloak </a>被广泛用于托管定制认证服务器。</p><blockquote class="ld le lf"><p id="e810" class="jn jo lc jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated"><em class="iq">从Okta官方博客来看，Auth0已经加入了Okta大家庭。我有点担心Auth0会像Stormpath一样消失。但是Okta的人宣称Auth0将作为一个独立的品牌运营。</em></p></blockquote><p id="aa1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将使用Auth0作为身份验证服务器角色来简化我们的开发过程。</p><p id="7b58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了演示OAuth2流程，首先我们将创建一个RESTful API <em class="lc">应用程序</em>，它充当<em class="lc">资源服务器</em>。在以后的文章中，我们将创建一个Angular SPA客户端应用程序来与这个API后端进行交互。</p><p id="60e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">官方的<a class="ae lb" href="https://auth0.com/docs/" rel="noopener ugc nofollow" target="_blank"> auth0 docs页面</a>上提供了大量的教程。通常你可以在这些文档中找到与你的应用相匹配的用例，去<em class="lc">后端API </em>文档浏览教程，特别是。有一个<a class="ae lb" href="https://auth0.com/docs/quickstart/backend/java-spring-security5" rel="noopener ugc nofollow" target="_blank">春季安全5 </a>的大教程。</p><p id="6d8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您以前没有，请先注册一个Auth0帐户。或者直接使用社交网络账户登录。登录后，您会发现Auth0已经为您创建了一个开发目的域，它为您的新应用程序分类所有资源。</p><p id="fb40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在仪表板UI中，展开左侧窗格中的<em class="lc">应用程序/API</em>，让我们创建一个新的API应用程序(OAuth2协议中的<em class="lc">资源服务器</em>角色)。</p><ul class=""><li id="dc0a" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">点击<em class="lc">创建API </em>按钮开始进度。</li><li id="98a0" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">填写必要字段，<em class="lc">受众</em>字段用于标识该API，建议填写类似URL的值。比如说。这里我创建了一个名为<em class="lc"> Backend API </em>的新API应用程序，并将受众设置为<a class="ae lb" href="https://hantsy.github.io/api" rel="noopener ugc nofollow" target="_blank"><em class="lc">https://hantsy.github.io/api</em></a>。</li></ul><p id="6752" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Auth0还提供了一个<em class="lc"> Auth0管理API </em>供您访问Auth0 APIs，并且出于测试目的，Auth0还自动创建了一个<em class="lc">机器对机器</em>应用程序，允许您与自己的API进行交互。</p><p id="4f22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来让我们创建我们的后端API应用程序。进入<a class="ae lb" href="https://start.spring.io" rel="noopener ugc nofollow" target="_blank">https://start . spring . io</a>，填写必填字段，选择<em class="lc"> Maven </em>作为构建工具，选择<em class="lc"> Java </em>作为语言，然后添加以下依赖项，</p><ul class=""><li id="0f4c" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">Web Starter</li><li id="d39a" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">确认</li><li id="8889" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">数据JPA</li><li id="9230" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">春天安全</li><li id="6aa7" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">龙目岛</li></ul><p id="04c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">点击Generate按钮将项目框架生成到一个档案中，下载它并将文件解压到你的磁盘中。将项目导入到您的IDEA中，打开<em class="lc"> pom.xml </em>文件，添加spring security oauth2相关的依赖项。</p><pre class="km kn ko kp gt lx ly lz ma aw mb bi"><span id="b9fa" class="mc md iq ly b gy me mf l mg mh">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-security-oauth2-resource-server&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-security-oauth2-jose&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="8633" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我们将把Auth0与Spring Security集成起来，以保护RESTful APIs，并且我们将关注API应用程序的安全配置。为了简化开发工作，我从<a class="ae lb" href="https://github.com/hantsy/spring-webmvc-functional-sample" rel="noopener ugc nofollow" target="_blank">hantsy/spring-web MVC-functional-sample</a>复制了现有代码，用于为一个简单的博客应用程序生成RESTful APIs。</p><blockquote class="ld le lf"><p id="0fe1" class="jn jo lc jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated"><em class="iq">关于Spring WebMvc函数式编程的介绍，查看</em> <a class="ae lb" href="https://hantsy.medium.com/functional-programming-in-spring-mvc-20957653da1" rel="noopener"> <em class="iq">我在Medium上发表的帖子</em> </a> <em class="iq">。</em></p></blockquote><p id="4b3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">声明一个<code class="fe mi mj mk ly b">SecurityFilterChain</code> bean来配置Spring安全性的细节。</p><pre class="km kn ko kp gt lx ly lz ma aw mb bi"><span id="472f" class="mc md iq ly b gy me mf l mg mh">@Bean<br/>SecurityFilterChain springWebFilterChain(HttpSecurity http) throws Exception {<br/>    return http<br/>        .httpBasic(AbstractHttpConfigurer::disable)<br/>        .csrf(AbstractHttpConfigurer::disable)<br/>        .sessionManagement(c -&gt; c.sessionCreationPolicy(SessionCreationPolicy.STATELESS))<br/>        .authorizeRequests(c -&gt; c<br/>                           .antMatchers("/", "/info").permitAll()<br/>                           .antMatchers(HttpMethod.GET, "/posts/**").permitAll()//.hasAuthority("SCOPE_read:posts")<br/>                           .antMatchers(HttpMethod.POST, "/posts/**").hasAuthority("SCOPE_write:posts")<br/>                           .antMatchers(HttpMethod.PUT, "/posts/**").hasAuthority("SCOPE_write:posts")<br/>                           .antMatchers(HttpMethod.DELETE, "/posts/**").hasAuthority("SCOPE_delete:posts")<br/>                           .anyRequest().authenticated()<br/>                          )<br/>        .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt)<br/>        .build();<br/>}</span></pre><ol class=""><li id="14fe" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk ml lp lq lr bi translated"><code class="fe mi mj mk ly b">oauth2ResourceServer</code>表示这个应用程序将作为<em class="lc">资源服务器</em>的角色，它使用一个<code class="fe mi mj mk ly b">JWT</code>令牌来验证传入的请求。</li><li id="5665" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk ml lp lq lr bi translated"><code class="fe mi mj mk ly b">authorizeRequests</code>部分定义了针对HTTP URI和动词的安全规则，例如，创建新帖子时需要一个<code class="fe mi mj mk ly b">write:posts</code>权限。</li></ol><p id="6b52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与<em class="lc">不透明的</em>令牌不同，JWT令牌可以简单地通过授权服务器提供的本地公钥或JWK集合uri进行验证。</p><p id="c498" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Spring Security 5中，如果授权提供者实现了OpenId配置规范，并公开了整个OAuth2/Oidc配置元数据，如令牌url、授权服务器url、jwk集合uri、用户信息uri等，则可以从已配置的<em class="lc">issuer _ uri</em>中解码出JWT令牌。通过一个网址<code class="fe mi mj mk ly b">.well-known/openid-configuration</code>。</p><p id="43c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="lc"> application.properties </em>中添加以下配置。</p><pre class="km kn ko kp gt lx ly lz ma aw mb bi"><span id="6dbd" class="mc md iq ly b gy me mf l mg mh">spring:<br/>  ...<br/>  security:<br/>    oauth2:<br/>      resourceserver:<br/>        jwt:<br/>          # Replace with the domain of your Auth0 tenant.<br/>          # Note the trailing slash is important!<br/>          issuer-uri: <a class="ae lb" href="https://dev-ese8241b.us.auth0.com/" rel="noopener ugc nofollow" target="_blank">https://dev-ese8241b.us.auth0.com/</a></span></pre><p id="0155" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">若要检查访问群体是否已设置并包含在访问令牌中，请添加一个自定义的访问群体验证程序。</p><pre class="km kn ko kp gt lx ly lz ma aw mb bi"><span id="39c4" class="mc md iq ly b gy me mf l mg mh">@RequiredArgsConstructor(staticName = "of")<br/>public class AudienceValidator implements OAuth2TokenValidator&lt;Jwt&gt; {<br/>    private final String audience;<br/>    <br/>    public OAuth2TokenValidatorResult validate(Jwt jwt) {<br/>        OAuth2Error error = new OAuth2Error("invalid_token", "The required audience is missing", null);<br/>        <br/>        if (jwt.getAudience().contains(audience)) {<br/>            return OAuth2TokenValidatorResult.success();<br/>        }<br/>        <br/>        return OAuth2TokenValidatorResult.failure(error);<br/>    }<br/>}</span></pre><p id="af0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并将这个验证器添加到<code class="fe mi mj mk ly b">JwtDecoder</code> bean中。</p><pre class="km kn ko kp gt lx ly lz ma aw mb bi"><span id="6fb9" class="mc md iq ly b gy me mf l mg mh">@Bean<br/>JwtDecoder jwtDecoder(OAuth2ResourceServerProperties properties, @Value("${auth0.audience}") String audience) {<br/>    /*<br/>        By default, Spring Security does not validate the "aud" claim of the token, to ensure that this token is<br/>        indeed intended for our app. Adding our own validator is easy to do:<br/>        */</span><span id="6a28" class="mc md iq ly b gy mm mf l mg mh">    String issuerUri = properties.getJwt().getIssuerUri();<br/>    NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder) JwtDecoders.fromOidcIssuerLocation(issuerUri);</span><span id="97e4" class="mc md iq ly b gy mm mf l mg mh">    OAuth2TokenValidator&lt;Jwt&gt; audienceValidator = AudienceValidator.of(audience);<br/>    OAuth2TokenValidator&lt;Jwt&gt; withIssuer = JwtValidators.createDefaultWithIssuer(issuerUri);<br/>    OAuth2TokenValidator&lt;Jwt&gt; withAudience = new DelegatingOAuth2TokenValidator&lt;&gt;(withIssuer, audienceValidator);</span><span id="ad94" class="mc md iq ly b gy mm mf l mg mh">    jwtDecoder.setJwtValidator(withAudience);</span><span id="b209" class="mc md iq ly b gy mm mf l mg mh">    return jwtDecoder;<br/>}</span></pre><p id="436f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们在Auth0管理仪表板中添加一些权限配置。</p><p id="7163" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进入<em class="lc">后端API </em>的<em class="lc">设置</em>页面，点击<em class="lc">权限</em>选项卡，添加以下权限。</p><ul class=""><li id="e0a5" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated"><em class="lc">阅读:帖子</em> —阅读帖子</li><li id="a076" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><em class="lc">写:帖子</em> —创建和更新帖子</li><li id="d3ae" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><em class="lc">删除:帖子</em> —删除帖子</li></ul><p id="6cf9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">切换到<em class="lc">机器对机器应用</em>选项卡，确保<em class="lc">测试应用</em>已启用，并展开该应用的配置，确保所有权限已勾选，点击<strong class="jp ir">更新</strong>按钮以应用更改。</p><p id="8e7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在切换到<em class="lc">测试</em>标签，有一个使用令牌测试API应用程序的指南，它在不同的脚本中可用。只需复制<strong class="jp ir"> cURL </strong>命令，打开一个Unix/bash之类的终端，粘贴执行即可。</p><pre class="km kn ko kp gt lx ly lz ma aw mb bi"><span id="8fa3" class="mc md iq ly b gy me mf l mg mh">$ curl --request POST \<br/>&gt;   --url <a class="ae lb" href="https://dev-ese8241b.us.auth0.com/oauth/token" rel="noopener ugc nofollow" target="_blank">https://dev-ese8241b.us.auth0.com/oauth/token</a> \<br/>&gt;   --header 'content-type: application/json' \<br/>&gt;   --data '{"client_id":"IEXV2MbAiuEkV0J7ufH0Bqq2a2YIF3h1","client_secret":"OknFJUkFpBe_tpFPAP2hL10NliMbCGxMRiFH_DkTxylBnZ5WjP9aq6zQOtL2L7ea","audience":"https://hantsy.github.io/api","grant_type":"client_credentials"}'<br/>{"access_token":"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IlYzM1lvNzk5cC1XeFI2NHpJZ29QMyJ9.eyJpc3MiOiJodHRwczovL2Rldi1lc2U4MjQxYi51cy5hdXRoMC5jb20vIiwic3ViIjoiSUVYVjJNYkFpdUVrVjBKN3VmSDBCcXEyYTJZSUYzaDFAY2xpZW50cyIsImF1ZCI6Imh0dHBzOi8vaGFudHN5LmdpdGh1Yi5pby9hcGkiLCJpYXQiOjE2MjA1NDgzMjAsImV4cCI6MTYyMDYzNDcyMCwiYXpwIjoiSUVYVjJNYkFpdUVrVjBKN3VmSDBCcXEyYTJZSUYzaDEiLCJzY29wZSI6InJlYWQ6cG9zdHMgd3JpdGU6cG9zdHMgZGVsZXRlOnBvc3RzIiwiZ3R5IjoiY2xpZW50LWNyZWRlbnRpYWxzIn0.UCdmcIb8xREC_rQp3EVBx8EALzhPcpJL1Mh1n6UX-Sf2cHkSsiUFISkHHM-qa5qZ34aNxJwKfvKPnZsfcIH9xwaGMeZjHub22PwAyVscQpZBq2mPRe_28GiwMP9jtFmSPhuGQec6-K7f0410tZTEKggnX3qFDdsJBWEhnu4zeFSwn865--Lbgk52owdncMd8jp2O5olKdnkeieChGQaYsLQ_vM8JTDN-eu5hm1DEL8WcfCd_foIG6klcm_gzgHpAru6zJQb48OmWIxlL6VGQl7RqIQIfds2NBBG7xYVr_38M2cltx8EUyIcXedR-d4YG_Dfp-NJbFkpZcSs9PPTagw","scope":"read:posts write:posts delete:posts","expires_in":86400,"token_type":"Bearer"}</span></pre><p id="a276" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">复制到access_token，打开<a class="ae lb" href="https://jwt.io" rel="noopener ugc nofollow" target="_blank"> https://jwt.io </a>页面，将token粘贴到<em class="lc">编码</em>框中，可以看到解码结果。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mn"><img src="../Images/9f2a7e850b508148e72fb03c295ed3be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LumBCwNgFd73at0i.png"/></div></div></figure><p id="0113" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们使用这个令牌来访问我们的<em class="lc">后端API </em>应用程序中受保护的API。</p><p id="fa8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先启动一个Postgres服务器。只需运行下面的docker命令。</p><pre class="km kn ko kp gt lx ly lz ma aw mb bi"><span id="9ee5" class="mc md iq ly b gy me mf l mg mh">$ docker compose up postgres</span></pre><p id="c0d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后运行应用程序。</p><pre class="km kn ko kp gt lx ly lz ma aw mb bi"><span id="88b7" class="mc md iq ly b gy me mf l mg mh">$ mvn clean spring-boot:run<br/>// or <br/>$ mvn clean package<br/>$ java -jar ./target/xxx.jar</span></pre><p id="33b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尝试创建一个新帖子。</p><pre class="km kn ko kp gt lx ly lz ma aw mb bi"><span id="6786" class="mc md iq ly b gy me mf l mg mh">$ curl --request POST \<br/>  --url <a class="ae lb" href="http://localhost:8080/posts" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/posts</a> \<br/>  --header 'authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IlYzM1lvNzk5cC1XeFI2NHpJZ29QMyJ9.eyJpc3MiOiJodHRwczovL2Rldi1lc2U4MjQxYi51cy5hdXRoMC5jb20vIiwic3ViIjoiSUVYVjJNYkFpdUVrVjBKN3VmSDBCcXEyYTJZSUYzaDFAY2xpZW50cyIsImF1ZCI6Imh0dHBzOi8vaGFudHN5LmdpdGh1Yi5pby9hcGkiLCJpYXQiOjE2MjA1NDgwNzEsImV4cCI6MTYyMDYzNDQ3MSwiYXpwIjoiSUVYVjJNYkFpdUVrVjBKN3VmSDBCcXEyYTJZSUYzaDEiLCJzY29wZSI6InJlYWQ6cG9zdHMgd3JpdGU6cG9zdHMgZGVsZXRlOnBvc3RzIiwiZ3R5IjoiY2xpZW50LWNyZWRlbnRpYWxzIn0.Rg6UqIb2kjrPg39QRLOLsvI54TUsQM4B7j_6Eb4hlxFkzHWglD-V0b5kXfgSMIcBQ-fq5oLt7Fj8etgqMMpstyx-2Ob20rbCBd-msZ1o-xGQidkQsyEM6lL6GMX7d79Vw0H9eZN8D8j8_mVoqd-wENhWsBiSp3xq8Jz6KSdslrxGnMaQKbQ2IL7dgw8Y1kJBz8FgBcUUF5k-dhMB-DDLkaLsurwcb380Qk3gMD2JW97fxQWM_mi38ufcoopSWxznDE118ng7hQXT18vFB9N_RCNaPHslsKZsE6ytiwx6kiSYvGFN5RMWIa3Dyp6Rt4UjfTLx1WO9JDtxNc4NMSPQ-g' \<br/>  --header 'Content-Type: application/json' \<br/>  --data '{"title": "New Post about Spring Secrity and Auth0", "content": "Content of this post, TBD"}'</span></pre><p id="261b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后列出所有帖子，检查帖子是否按预期创建。</p><pre class="km kn ko kp gt lx ly lz ma aw mb bi"><span id="5583" class="mc md iq ly b gy me mf l mg mh">$ curl <a class="ae lb" href="http://localhost:8080/posts" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/posts</a><br/>[ {<br/>  "id" : 1,<br/>  "version" : 0,<br/>  "createdDate" : "2021-05-09T16:37:11.984273",<br/>  "lastModifiedDate" : "2021-05-09T16:37:11.984273",<br/>  "title" : "Post one",<br/>  "content" : "content of Post one"<br/>}, {<br/>  "id" : 2,<br/>  "version" : 0,<br/>  "createdDate" : "2021-05-09T16:37:12.068004",<br/>  "lastModifiedDate" : "2021-05-09T16:37:12.068004",<br/>  "title" : "Post two",<br/>  "content" : "content of Post two"<br/>}, {<br/>  "id" : 3,<br/>  "version" : 0,<br/>  "createdDate" : "2021-05-09T16:38:27.881024",<br/>  "lastModifiedDate" : "2021-05-09T16:38:27.881024",<br/>  "createdBy" : {<br/>    "username" : "IEXV2MbAiuEkV0J7ufH0Bqq2a2YIF3h1@clients"<br/>  },<br/>  "lastModifiedBy" : {<br/>    "username" : "IEXV2MbAiuEkV0J7ufH0Bqq2a2YIF3h1@clients"<br/>  },<br/>  "title" : "New Post about Spring Secrity and Auth0",<br/>  "content" : "Content of this post, TBD"<br/>} ]</span></pre><p id="c6b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lc">后端API </em>已准备好供客户端应用程序访问。现在让我们探索一下Spring安全测试模块中提供的测试工具，以测试受JWT令牌保护的API。</p><p id="3173" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Spring Security提供了一个简单的<code class="fe mi mj mk ly b">SecurityMockMvcRequestPostProcessors.jwt</code>来模仿JWT处理，并在Spring MockMvc环境中绕过JWT解码。</p><pre class="km kn ko kp gt lx ly lz ma aw mb bi"><span id="263a" class="mc md iq ly b gy me mf l mg mh">@Test<br/>public void testSave() throws Exception {</span><span id="bfd5" class="mc md iq ly b gy mm mf l mg mh">    given(this.posts.save(any(Post.class)))<br/>        .willReturn(Post.builder().title("test").content("test content").build());</span><span id="00eb" class="mc md iq ly b gy mm mf l mg mh">    this.mockMvc<br/>        .perform(<br/>        post("/posts")<br/>        .with(jwt().jwt(jwtBuilder().claim("scope", "write:posts").build()))<br/>        .content(this.objectMapper.writeValueAsBytes(Post.builder().title("test").content("test content").build()))<br/>        .contentType(MediaType.APPLICATION_JSON)<br/>    )<br/>        .andExpect(status().isCreated());</span><span id="6bed" class="mc md iq ly b gy mm mf l mg mh">    verify(this.posts, times(1)).save(any(Post.class));<br/>    verifyNoMoreInteractions(this.posts);<br/>}</span><span id="bd50" class="mc md iq ly b gy mm mf l mg mh">private Jwt.Builder jwtBuilder() {<br/>    return Jwt.withTokenValue("token").header("alg", "none").audience(List.of(audience));<br/>}</span></pre><p id="a5f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在集成测试中，您可以使用从<em class="lc">测试应用程序</em>生成的相同访问令牌来与<em class="lc">后端API </em>交互。将令牌添加到HTTP头中以访问API，可以放心地编写下面的测试代码。</p><pre class="km kn ko kp gt lx ly lz ma aw mb bi"><span id="e190" class="mc md iq ly b gy me mf l mg mh">@SpringBootTest(webEnvironment = RANDOM_PORT)<br/>@Slf4j<br/>public class IntegrationTests {</span><span id="feda" class="mc md iq ly b gy mm mf l mg mh">    @LocalServerPort<br/>    private int port;</span><span id="326b" class="mc md iq ly b gy mm mf l mg mh">    @Autowired<br/>    ObjectMapper objectMapper;</span><span id="0b24" class="mc md iq ly b gy mm mf l mg mh">    @Value("${auth0.audience}")<br/>    private String audience;</span><span id="392c" class="mc md iq ly b gy mm mf l mg mh">    private String token = "...";<br/>    <br/>    @BeforeEach<br/>    public void setup() {<br/>        RestAssured.port = this.port;<br/>    }<br/></span><span id="5cb3" class="mc md iq ly b gy mm mf l mg mh">    @Test<br/>    public void createPostWithoutToken() throws Exception {<br/>        //@formatter:off<br/>        given()<br/>            .body(Post.builder().title("test").content("test content").build())<br/>            .contentType(ContentType.JSON)<br/>        .when()<br/>            .post("/posts")<br/>        .then()<br/>            .assertThat()<br/>            .statusCode(HttpStatus.SC_UNAUTHORIZED);<br/>        //@formatter:on<br/>    }</span><span id="9de6" class="mc md iq ly b gy mm mf l mg mh">    @Test<br/>    public void createPost() throws Exception {<br/>        //@formatter:off<br/>        given()<br/>            .auth().oauth2(token)<br/>            .body(Post.builder().title("test").content("test content").build())<br/>            .contentType(ContentType.JSON)<br/>        .when()<br/>            .post("/posts")<br/>        .then()<br/>            .assertThat()<br/>            .statusCode(HttpStatus.SC_CREATED)<br/>            .header("Location", notNullValue());<br/>        //@formatter:on<br/>    }</span><span id="d92c" class="mc md iq ly b gy mm mf l mg mh">}</span></pre><h2 id="0bce" class="mc md iq bd mo mp mq dn mr ms mt dp mu jy mv mw mx kc my mz na kg nb nc nd ne bi translated"><strong class="ak">从</strong> <a class="ae lb" href="https://github.com/hantsy/spring-security-auth0-sample/tree/master/api" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> my Github </strong> </a> <strong class="ak">中抓取一份源代码。</strong></h2></div></div>    
</body>
</html>