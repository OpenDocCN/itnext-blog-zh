<html>
<head>
<title>Evasion Techniques — Hiding your process from `ps`</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">规避技术——对“ps”隐藏您的过程</h1>
<blockquote>原文：<a href="https://itnext.io/evasion-techniques-hiding-your-process-from-ps-2122cf487485?source=collection_archive---------2-----------------------#2022-10-10">https://itnext.io/evasion-techniques-hiding-your-process-from-ps-2122cf487485?source=collection_archive---------2-----------------------#2022-10-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/41f4247872469aa81b6b4058d23f03b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GkAPJQyMkvsM_g331HG_BQ.png"/></div></div></figure><p id="1751" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Linux中的一切都是文件，甚至包括你的进程信息。它位于文件系统的/proc目录中。今天，我们将使用并滥用这一知识来隐藏目标进程，使其不被Linux中的<code class="fe kz la lb lc b">ps</code>命令看到，本质上也是隐藏在其他基于Unix的系统中。但是首先…</p><h1 id="e1d5" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated"><code class="fe kz la lb lc b">ps</code>命令是如何工作的？</h1><p id="645b" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">如前所述，Linux中的一切都是文件，包括<code class="fe kz la lb lc b">/proc</code>中的进程树。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mg"><img src="../Images/09d089a42a09f4b723b127eefe5cb762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tmixa5Ed9RJL34qkZCDVqQ.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">/proc目录树的一部分</figcaption></figure><p id="4712" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">/proc</code>文件系统中的每个子目录都对应一个进程id，现在进程id 1几乎都是systemd，这可以通过阅读<code class="fe kz la lb lc b">/proc/1/stat</code>来验证</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/a653a955314890ba5d002205a8336f78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*ScqQnUKT9OW7V6lblbM8qw.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">将进程ID 1显示为systemd</figcaption></figure><p id="3cc3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经了解了基础知识，我们可以看看<code class="fe kz la lb lc b">ps</code>命令是如何工作的。</p><p id="414c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过使用<code class="fe kz la lb lc b">strace ps</code>命令，我们可以开始检查这个命令是如何工作的。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mq"><img src="../Images/c3bb71fe67857dd21da6eede3cc548bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jPGplm5PXKq8RU4PplfJXw.png"/></div></div></figure><p id="e51b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最初<code class="fe kz la lb lc b">ps</code>启动并加载<code class="fe kz la lb lc b">libprocps.so</code>共享库。从这里我们可以查找procps的代码，但是这有什么意思呢？让我们继续追踪。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mr"><img src="../Images/d107dfded5fba8c4d4dd377b31919d1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GFZpD2Fil6GbWqb9zx1D8w.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">读数统计和状态</figcaption></figure><p id="a384" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们通读时，我们来到一个部分，其中<code class="fe kz la lb lc b">ps</code>正在打开文件<code class="fe kz la lb lc b">/proc/&lt;PID&gt;/stat</code>和<code class="fe kz la lb lc b">/proc/&lt;PID&gt;/status</code>，使用<code class="fe kz la lb lc b">read()</code>读取这些文件，以确定通过命令向用户显示的数据，如进程名称、状态、Umask、内存使用等...</p><p id="0946" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们了解了<code class="fe kz la lb lc b">ps</code>命令的工作原理，让我们继续。</p><h1 id="4991" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">使用C隐藏进程</h1><p id="0994" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">在我们开始隐藏一个进程之前，我们需要一个目标进程。我使用<code class="fe kz la lb lc b">ps -U affix</code>从我的工艺列表中选择了工艺<code class="fe kz la lb lc b">pipewire</code></p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ms"><img src="../Images/f4ae1bfcf20abc6da2207fac7da6541d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*R2mch1DLWCiAJfNZ65KcGQ.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">ps -U词缀输出</figcaption></figure><h2 id="a28b" class="mt le it bd lf mu mv dn lj mw mx dp ln km my mz lr kq na nb lv ku nc nd lz ne bi translated">函数挂钩，基础</h2><p id="80c6" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">函数挂钩是拦截对已经存在的函数的调用的行为，比如<code class="fe kz la lb lc b">read()</code>和<code class="fe kz la lb lc b">write()</code>来构建一个包装函数，在将数据返回给调用应用程序之前执行额外的任务。在linux中，这可以通过使用动态加载器API来实现，它允许我们在运行时动态加载和执行共享库中的函数。使用<code class="fe kz la lb lc b">LD_PRELOAD</code>环境变量或<code class="fe kz la lb lc b">/etc/ld.so.preload</code>文件可能会被滥用。</p><p id="1cee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">LD_PRELOAD</code>变量用于指定链接加载器应该首先加载的一些预加载库，类似于windows上的<code class="fe kz la lb lc b">AppInit_DLLs</code>或者MacOS上的<code class="fe kz la lb lc b">DYLD_INSERT_LIBRARIES</code>。</p><h2 id="6ccb" class="mt le it bd lf mu mv dn lj mw mx dp ln km my mz lr kq na nb lv ku nc nd lz ne bi translated">这对我们有什么帮助？</h2><p id="2d4e" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">正如我们上面讨论的，<code class="fe kz la lb lc b">ps</code>命令利用<code class="fe kz la lb lc b">read()</code>调用从<code class="fe kz la lb lc b">/proc</code>文件系统中读取数据，以确定要向用户显示的进程信息。</p><p id="a96c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过挂钩<code class="fe kz la lb lc b">read()</code>调用，我们可以确定进程名并隐藏它，或者重写它，以防止<code class="fe kz la lb lc b">ps</code>知道我们真正的进程名。</p><h2 id="ddc3" class="mt le it bd lf mu mv dn lj mw mx dp ln km my mz lr kq na nb lv ku nc nd lz ne bi translated">挂钩读取()</h2><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nf"><img src="../Images/03c9a99d3fad51913ca747c6f8a60ec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SQzZAPiS2W5xsdLMCgFTJQ.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">read()联机帮助页</figcaption></figure><p id="4abd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了挂钩<code class="fe kz la lb lc b">read()</code>函数，我们需要在代码中定义它，从手册页中我们知道函数签名是<code class="fe kz la lb lc b">ssize_t read(int fd, void *buf, size_t count);</code></p><blockquote class="ng nh ni"><p id="a424" class="kb kc nj kd b ke kf kg kh ki kj kk kl nk kn ko kp nl kr ks kt nm kv kw kx ky im bi translated">fd是我们正在读取的文件描述符，这是在使用<code class="fe kz la lb lc b">openat()</code>系统调用的<code class="fe kz la lb lc b">ps</code>命令中定义的。</p><p id="af8f" class="kb kc nj kd b ke kf kg kh ki kj kk kl nk kn ko kp nl kr ks kt nm kv kw kx ky im bi translated">*buf是我们的目标读取缓冲区，它作为指向内存中某个位置的指针传递给<code class="fe kz la lb lc b">read()</code></p><p id="8a60" class="kb kc nj kd b ke kf kg kh ki kj kk kl nk kn ko kp nl kr ks kt nm kv kw kx ky im bi translated">count是从fd中读取的字节数</p></blockquote><p id="de2d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们定义挂钩函数</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nf"><img src="../Images/dfb463c358083c8e98ca0e4d5f3bc2e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lZ1fcukqIzG8L8elKWEMdg.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">dlsym的联机帮助页</figcaption></figure><p id="fbfd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了成功模拟<code class="fe kz la lb lc b">read()</code>功能，我们需要利用<code class="fe kz la lb lc b">dlsym()</code>来获取现有的<code class="fe kz la lb lc b">read()</code>符号地址。</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="4019" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们的函数将调用原来的read函数并返回正确的结果。</p><p id="b3fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="nj">第7行</em> </strong>定义了我们的<code class="fe kz la lb lc b">*orig_read()</code>指针来匹配<code class="fe kz la lb lc b">read()</code>的方法签名</p><p id="9a30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="nj">第10行</em> </strong>利用<code class="fe kz la lb lc b">dlsym()</code>获取<code class="fe kz la lb lc b">read()</code>符号的地址，并将其分配给我们的<code class="fe kz la lb lc b">new_read()</code>指针。</p><p id="d2ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<code class="fe kz la lb lc b">RTLD_NEXT</code>确保它将返回下一个<code class="fe kz la lb lc b">read()</code>符号声明的地址，这样我们就不会调用我们刚刚创建的那个。</p><p id="d98b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="nj">第12行</em> </strong>调用<code class="fe kz la lb lc b">new_read()</code>方法读取数据，并将返回值存储在一个结果变量中，返回给调用函数。</p><p id="fdb0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">恭喜你，你已经写了一个功能函数钩子。在这个阶段，我们可以编译我们的代码，以确保它的工作，但是我们不会看到任何不同。</p><h2 id="59cc" class="mt le it bd lf mu mv dn lj mw mx dp ln km my mz lr kq na nb lv ku nc nd lz ne bi translated">隐藏我们的目标进程</h2><p id="843f" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">因为我们的函数已经调用了原始的<code class="fe kz la lb lc b">read()</code>函数，所以我们拥有了在<code class="fe kz la lb lc b">buf</code>指针中隐藏进程所需的所有信息。</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="f0b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们更新的代码现在完全挂钩并隐藏了我们在<strong class="kd iu"> <em class="nj">第6行</em> </strong>中定义的<code class="fe kz la lb lc b">PROC_NAME</code>常量中定义的目标流程</p><p id="8f6f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="nj">第16行</em> </strong>与<code class="fe kz la lb lc b">strstr()</code>进行比较，检查缓冲区中是否存在我们的进程名，如果存在，我们<code class="fe kz la lb lc b">return 0</code>到调用者。这欺骗了<code class="fe kz la lb lc b">ps</code>认为它已经读取了一个空文件，进程被忽略。</p><h2 id="6d4c" class="mt le it bd lf mu mv dn lj mw mx dp ln km my mz lr kq na nb lv ku nc nd lz ne bi translated">编译和测试</h2><p id="2558" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">现在我们已经完成了我们的代码，我们可以用gcc把它编译成一个带有<code class="fe kz la lb lc b">-shared</code>标志的共享库，为了正确工作，我们需要用<code class="fe kz la lb lc b">-fPIC</code>把它编译成依赖代码中的位置</p><p id="23eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了正确使用<code class="fe kz la lb lc b">dlsym</code>函数，我们需要使用<code class="fe kz la lb lc b">-ldl</code>链接libdl，并使用<code class="fe kz la lb lc b">-D_GNU_SOURCE</code>定义<code class="fe kz la lb lc b">_DNU_SOURCE</code>常量。这也可以在代码中用<code class="fe kz la lb lc b">#define _GNU_SOURCE</code>定义为预处理器指令。</p><p id="338e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b"># gcc hookread.c -o hookread.so -shared -ldl -fPIC -D_GNU_SOURCE</code></p><p id="f18b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们可以用<code class="fe kz la lb lc b">LD_PRELOAD</code>环境变量测试这个库。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi np"><img src="../Images/5c124c403cb413a9979dd1b6271471a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eluaLhi4xe28qtDpz2W92g.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">成功！</figcaption></figure><p id="8a55" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">成功！我们的目标进程，在我的例子中是pipewire，已经从<code class="fe kz la lb lc b">ps</code>命令中隐藏了。带上蓝队！</p><p id="8878" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了保持这一点并且不需要环境变量，我们可以在<code class="fe kz la lb lc b">/etc/ld.preload.so</code>中定义so文件的完整路径。这意味着当其他用户使用系统时，我们可以保持隐藏。</p><h2 id="e2a0" class="mt le it bd lf mu mv dn lj mw mx dp ln km my mz lr kq na nb lv ku nc nd lz ne bi translated">挂钩的其他用途</h2><p id="0863" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">挂钩还有许多其他令人不快的用途，这只是隐藏一个进程。其他用途包括但不限于:</p><ul class=""><li id="fd4f" class="nq nr it kd b ke kf ki kj km ns kq nt ku nu ky nv nw nx ny bi translated">躲避netstat</li><li id="0dc9" class="nq nr it kd b ke nz ki oa km ob kq oc ku od ky nv nw nx ny bi translated">挂钩SSH函数调用以构建rootkit</li><li id="ce85" class="nq nr it kd b ke nz ki oa km ob kq oc ku od ky nv nw nx ny bi translated">MiTM挂钩SSL调用</li><li id="12e6" class="nq nr it kd b ke nz ki oa km ob kq oc ku od ky nv nw nx ny bi translated">特权取消</li></ul><p id="237e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">谢谢你花时间阅读我的教程。我希望你发现它信息丰富。</p></div></div>    
</body>
</html>