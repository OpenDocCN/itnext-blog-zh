<html>
<head>
<title>Deep introduction to class decorators in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对TypeScript中的类装饰器的深入介绍</h1>
<blockquote>原文：<a href="https://itnext.io/deep-introduction-to-class-decorators-in-typescript-23005ea5d035?source=collection_archive---------1-----------------------#2022-02-15">https://itnext.io/deep-introduction-to-class-decorators-in-typescript-23005ea5d035?source=collection_archive---------1-----------------------#2022-02-15</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="99ee" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">向TypeScript中的类添加数据和功能</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/e3a84d077202766d7bc7f84bf0c6f7a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3kXAsjxUiunGjWrd.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">图像由作者与相应项目的标志</figcaption></figure><p id="acac" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">装饰器允许我们在TypeScript中向类或方法添加额外的信息，类似于Java中的注释。类装饰器应用于TypeScript中的类定义，可以观察、修改或替换类定义。</p><p id="ca5a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">本文深入探讨了如何定义和使用TypeScript类装饰器。要使用decorator，必须在TypeScript中启用它们，所以请务必<a class="ae lv" href="https://javascript.plainenglish.io/deep-introduction-to-using-and-implementing-typescript-decorators-a9e876ad0d43" rel="noopener ugc nofollow" target="_blank">阅读本系列</a>中的decorator介绍文章。类装饰器主要用于向类中添加元数据，这些元数据将被其他装饰器使用。但是，类装饰者也可以返回一个新的构造函数来覆盖或替换现有的构造函数或类，添加新的方法或其他行为。</p><p id="99f8" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">实际上，它们看起来像这样:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="0589" class="mb mc iu lx b gz md me l mf mg">@Decorator( ?? optional arguments)<br/>class DecoratedClass {<br/>    // properties, or methods<br/>}</span></pre><p id="1edf" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">也就是说，您可以在关键字<code class="fe mh mi mj lx b">class</code>前面加上一个或多个装饰符。对于一些装饰器，参数配置其行为。其他装饰器不需要参数，这将在文档中解释。</p><p id="e9ec" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">本文是系列文章的一部分:</p><ul class=""><li id="ff8a" class="mk ml iu lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated"><a class="ae lv" href="https://javascript.plainenglish.io/deep-introduction-to-using-and-implementing-typescript-decorators-a9e876ad0d43" rel="noopener ugc nofollow" target="_blank">装修工介绍</a></li><li id="4c92" class="mk ml iu lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><strong class="lb iv">类装修工</strong>T9】本条</li><li id="af76" class="mk ml iu lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><a class="ae lv" href="https://javascript.plainenglish.io/a-deep-introduction-to-property-decorators-in-typescript-8ef011169ec" rel="noopener ugc nofollow" target="_blank">物业装修工</a></li><li id="1671" class="mk ml iu lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><a class="ae lv" href="https://javascript.plainenglish.io/typescript-accessor-decorators-in-depth-take-control-over-get-and-set-accessor-methods-8b85c95124f9" rel="noopener ugc nofollow" target="_blank">访问器装饰器</a></li><li id="e04c" class="mk ml iu lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><a class="ae lv" href="https://javascript.plainenglish.io/introduction-to-parameter-decorators-in-typescript-b0042b5474ed" rel="noopener ugc nofollow" target="_blank">参数装饰器</a></li><li id="34fe" class="mk ml iu lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><a class="ae lv" href="https://javascript.plainenglish.io/a-deep-introduction-to-method-decorators-in-typescript-6045d52e10a6" rel="noopener ugc nofollow" target="_blank">方法装饰者</a></li><li id="6ec5" class="mk ml iu lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><a class="ae lv" href="https://javascript.plainenglish.io/implement-hybrid-decorator-functions-in-typescript-f6d24bc5abb0" rel="noopener ugc nofollow" target="_blank">混合装修工</a></li><li id="42c6" class="mk ml iu lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><a class="ae lv" href="https://javascript.plainenglish.io/using-the-reflection-and-reflection-metadata-apis-with-typescript-decorators-c56ba9c690c7" rel="noopener ugc nofollow" target="_blank">反射和带装饰器的反射API</a></li><li id="723d" class="mk ml iu lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><a class="ae lv" href="https://javascript.plainenglish.io/runtime-data-validation-in-typescript-using-decorators-and-reflection-metadata-3219fdf5dfb5" rel="noopener ugc nofollow" target="_blank">使用装饰器和反射元数据在TypeScript中进行运行时数据验证</a></li></ul><h1 id="3318" class="mz mc iu bd na nb nc nd ne nf ng nh ni ka nj kb nk kd nl ke nm kg nn kh no np bi translated">TypeScript中的类装饰函数</h1><p id="8c07" class="pw-post-body-paragraph kz la iu lb b lc nq jv le lf nr jy lh li ns lk ll lm nt lo lp lq nu ls lt lu in bi translated">装饰函数有一个参数:</p><ul class=""><li id="053a" class="mk ml iu lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated">类的构造函数</li></ul><p id="b8fe" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这为属性装饰函数定义了一个必需的签名。</p><p id="634e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">让我们尝试一个简单的类装饰器的例子，它简单地打印给定的数据。</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="1d10" class="mb mc iu lx b gz md me l mf mg">function logConstructor(constructor: Function) {<br/>    const ret = {<br/>        constructor,<br/>        extensible: Object.isExtensible(constructor),<br/>        frozen: Object.isFrozen(constructor),<br/>        sealed: Object.isSealed(constructor),<br/>        values: Object.values(constructor),<br/>        properties: Object.getOwnPropertyDescriptors(constructor),<br/>        members: {}<br/>    };<br/>    for (const key of Object.getOwnPropertyNames(constructor.prototype)) {<br/>        ret.members[key] = constructor.prototype[key];<br/>    }<br/><br/>    console.log(`ClassDecoratorExample `, ret);<br/>}<br/><br/>@logConstructor<br/>class ClassDecoratorExample {<br/>    constructor(x: number, y: number) {<br/>        console.log(`ClassDecoratorExample(${x}, ${y})`);<br/>    }<br/>    method() {<br/>        console.log(`method called`);<br/>    }<br/>}<br/><br/>new ClassDecoratorExample(3, 4).method()</span></pre><p id="c6b9" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe mh mi mj lx b">logConstructor</code>是<code class="fe mh mi mj lx b">@logConstructor</code> decorator的decorator函数，它为类decorator实现了指定的方法签名。这个装饰器不使用任何参数，并且由于它的实现不需要括号。</p><p id="42ff" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">它只是打印出关于构造函数的可用信息。大多数情况下，我们使用<code class="fe mh mi mj lx b">Object</code>类中的方法来查询关于被修饰类的数据。在一些情况下，查询是针对<code class="fe mh mi mj lx b">constructor.prototype</code>的，因为该对象包含附加到该类的方法的实现细节。</p><p id="c6a4" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">存储库中的<code class="fe mh mi mj lx b"><a class="ae lv" href="https://www.npmjs.com/package/decorator-inspectors" rel="noopener ugc nofollow" target="_blank">decorator-inspectors</a></code>包包含一个更全面的装饰器<code class="fe mh mi mj lx b">LogClassInspector</code>，目的类似。</p><p id="ddea" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">运行时，我们得到以下输出:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="f51a" class="mb mc iu lx b gz md me l mf mg">$ npx ts-node lib/classes/first.ts <br/>ClassDecoratorExample  {<br/>  constructor: [class ClassDecoratorExample],<br/>  extensible: false,<br/>  frozen: false,<br/>  sealed: false,<br/>  values: [],<br/>  properties: {<br/>    length: {<br/>      value: 2,<br/>      writable: false,<br/>      enumerable: false,<br/>      configurable: false<br/>    },<br/>    name: {<br/>      value: 'ClassDecoratorExample',<br/>      writable: false,<br/>      enumerable: false,<br/>      configurable: false<br/>    },<br/>    prototype: {<br/>      value: {},<br/>      writable: false,<br/>      enumerable: false,<br/>      configurable: false<br/>    }<br/>  },<br/>  members: {<br/>    constructor: [class ClassDecoratorExample],<br/>    method: [Function: method]<br/>  }<br/>}<br/>ClassDecoratorExample(3, 4)<br/>method called</span></pre><p id="2381" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe mh mi mj lx b">properties</code>中的值是我们会反复看到的<code class="fe mh mi mj lx b">PropertyDescriptor</code>对象。我们大多数人不需要深究JavaScript的幕后。但是，要实现decorators，我们需要知道一些事情。</p><p id="7f9d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">例如，您知道对象上的<code class="fe mh mi mj lx b">sealed</code>或<code class="fe mh mi mj lx b">frozen</code>设置吗？现在我知道了它们，能够打开这些设置看起来肯定很有用。这个装饰器使它变得简单:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="9f32" class="mb mc iu lx b gz md me l mf mg">function sealed(constructor: Function) {<br/>    Object.seal(constructor);<br/>    Object.seal(constructor.prototype);<br/>}</span></pre><p id="e254" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果您将它附加到一个类定义，该类将被密封。</p><p id="4dc8" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">要使用它，请将其添加到脚本中:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="5a28" class="mb mc iu lx b gz md me l mf mg">@logConstructor<br/>@sealed<br/>class ClassDecoratorExample { ... }</span></pre><p id="a20b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们可以很容易地给任何可装饰的东西添加多个装饰器。多个装饰器有一个执行顺序，它们从下往上执行。因此，输出现在会说<code class="fe mh mi mj lx b">sealed: true</code>，因为<code class="fe mh mi mj lx b">@sealed</code>会先执行。如果您将<code class="fe mh mi mj lx b">@sealed</code>放在<code class="fe mh mi mj lx b">logConstructor</code>上方，它仍然会显示<code class="fe mh mi mj lx b">sealed: false</code>，因为<code class="fe mh mi mj lx b">@sealed</code>将会第二个执行。</p><h1 id="d6a2" class="mz mc iu bd na nb nc nd ne nf ng nh ni ka nj kb nk kd nl ke nm kg nn kh no np bi translated">实现接受参数的类装饰器</h1><p id="78bf" class="pw-post-body-paragraph kz la iu lb b lc nq jv le lf nr jy lh li ns lk ll lm nt lo lp lq nu ls lt lu in bi translated">装饰者也可以接受参数。<a class="ae lv" href="https://medium.com/@7genblogger/deep-introduction-to-using-and-implementing-typescript-decorators-a9e876ad0d43" rel="noopener">正如我们在简介</a>中所说，这需要遵循一种不同的模式，称为装饰工厂。</p><p id="798e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">下面是一个简单的类装饰器示例，它不仅展示了如何传入参数，还帮助我们理解了使用多个装饰器时的执行顺序。</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="5f3e" class="mb mc iu lx b gz md me l mf mg">function withParam(path: string) {<br/>    console.log(`outer withParam ${path}`);<br/>    return (target: Function) =&gt; {<br/>        console.log(`inner withParam ${path}`);<br/>    };<br/>}<br/><br/>@withParam('first')<br/>@withParam('middle')<br/>@withParam('last')<br/>class ExampleClass {<br/>   // methods and properties<br/>}</span></pre><p id="86db" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">外部函数<code class="fe mh mi mj lx b">withParam</code>接受与装饰器一起使用的参数列表。内部函数是装饰函数，是实现所需签名的地方。内部函数将包含实际的装饰器实现。</p><p id="25fb" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">所发生的是<em class="my">with param(param)</em>是一个表达式，它返回一个带有正确签名的函数作为类装饰器。这使得内部函数成为装饰函数，而外部函数是生成该函数的工厂。</p><p id="b58c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在这个例子中，我们已经附加了三次<code class="fe mh mi mj lx b">withParam</code>,所以我们可以了解更多关于执行顺序的信息。</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="69a3" class="mb mc iu lx b gz md me l mf mg">$ npx ts-node lib/classes/constructors.ts  <br/>outer withParam first<br/>outer withParam middle<br/>outer withParam last<br/>inner withParam last<br/>inner withParam middle<br/>inner withParam first</span></pre><p id="015c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们在简介中详细讨论了这个<a class="ae lv" href="https://techsparx.com/nodejs/typescript/decorators/introduction.html" rel="noopener ugc nofollow" target="_blank">。记住，工厂函数从上到下执行，之后装饰函数从下到上执行。</a></p><h1 id="162d" class="mz mc iu bd na nb nc nd ne nf ng nh ni ka nj kb nk kd nl ke nm kg nn kh no np bi translated">向框架注册的类装饰器</h1><p id="a3d6" class="pw-post-body-paragraph kz la iu lb b lc nq jv le lf nr jy lh li ns lk ll lm nt lo lp lq nu ls lt lu in bi translated">让我们研究一下类装饰器的一个可能的实际用途。也就是说，一个框架可能会保存某些种类的类的列表。对于这个例子，我们将模拟一个web应用程序框架，其中某些类拥有URL路由功能。每个路由器类处理特定URL前缀的路由，以及该路由的特定配置。</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="534f" class="mb mc iu lx b gz md me l mf mg">const registeredClasses = [];<br/><br/>function Router(path: string, options ?: object) {<br/>    return (constructor: Function) =&gt; {<br/>        registeredClasses.push({<br/>            constructor, path, options<br/>        });<br/>    };<br/>}<br/><br/>@Router('/')<br/>class HomePageRouter {<br/>    // routing functions<br/>}<br/><br/>@Router('/blog', {<br/>    rss: '/blog/rss.xml'<br/>})<br/>class BlogRouter {<br/>    // routing functions<br/>}<br/><br/>console.log(registeredClasses);</span></pre><p id="0c4c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><em class="my">路由器</em>是一个工厂函数，产生一个类装饰器，将类添加到<code class="fe mh mi mj lx b">registeredClasses</code>数组中。该函数有两个选项，其中<code class="fe mh mi mj lx b">path</code>是URL路径前缀，<code class="fe mh mi mj lx b">options</code>是可选的配置对象。</p><p id="3c88" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">因为类装饰器最后运行，所以类装饰器可以选择对类中包含的任何方法或属性做些什么。此外，更常见的存储数据的方法不是像这样的数组，而是使用反射元数据API，我们将在后面讨论。</p><p id="f459" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">运行此命令的输出是:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="48fe" class="mb mc iu lx b gz md me l mf mg">$ npx ts-node lib/classes/register.ts <br/>[<br/>  {<br/>    constructor: [class HomePageRouter],<br/>    path: '/',<br/>    options: undefined<br/>  },<br/>  {<br/>    constructor: [class BlogRouter],<br/>    path: '/blog',<br/>    options: { rss: '/blog/rss.xml' }<br/>  }<br/>]</span></pre><p id="44a9" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">由假设的框架来处理这些数据。正如我们前面看到的，从<code class="fe mh mi mj lx b">constructor</code>对象开始，有相当多的额外数据可用。</p><h1 id="5cd8" class="mz mc iu bd na nb nc nd ne nf ng nh ni ka nj kb nk kd nl ke nm kg nn kh no np bi translated">在TypeScript中使用类装饰器修改类</h1><p id="c86b" class="pw-post-body-paragraph kz la iu lb b lc nq jv le lf nr jy lh li ns lk ll lm nt lo lp lq nu ls lt lu in bi translated">这个简单的例子很有趣，但是让我们尝试做一些有趣的事情。我们可以修改或替换类定义。这需要一点魔法，所以让我们来看看。</p><p id="df43" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在我们开始之前，后退半步想一想——类装饰函数接收类对象。它不接收正在创建的实例。我们可以使用<code class="fe mh mi mj lx b">Object.defineProperty(target, ...)</code>添加属性，但是该属性是添加到类中，而不是添加到生成的任何实例中。</p><p id="61b0" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">为了抓住一个随机的概念，考虑一个记录雇员一天中事件的应用程序。员工先打卡上班，下班后打卡下班。让我们创建两个类来记录这些事件，并使用一个装饰器来自动添加时间戳和唯一标识符。</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="de7a" class="mb mc iu lx b gz md me l mf mg">import { v4 as uuidv4 } from 'uuid';<br/><br/>function TimeStamp&lt;T extends { new(...args: any[]): {}}&gt;(target: T) {<br/>    return class extends target {<br/>        uuid = uuidv4();<br/>        created = new Date().toLocaleString("en-US");<br/><br/>        hello(msg: string) { console.log(`Extended ${msg}`); }<br/>    }<br/>}<br/><br/>@TimeStamp<br/>class ClockIn {<br/>    // methods and properties<br/>}<br/><br/>@TimeStamp<br/>class ClockOut {<br/>    // methods and properties<br/>}</span></pre><p id="d90f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe mh mi mj lx b">TimeStamp</code> decorator有一个奇怪的声明，但这确实有效，它来自官方的TypeScript文档，并且与类decorator函数所需的签名相匹配。看来<code class="fe mh mi mj lx b">extends</code>子句与扩展泛型类有关，因此T在这种情况下匹配任何类定义。</p><p id="00ba" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">带有<code class="fe mh mi mj lx b">&lt;T extends { new(...args: any[]): {}}&gt;</code>的部分是一个泛型，其中<code class="fe mh mi mj lx b">T</code>被定义为扩展任何类的东西。该语法直接来自TypeScript文档，并且可能是声明类装饰器的更精确的方式。</p><p id="03e0" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">带有<code class="fe mh mi mj lx b">return class extends target</code>的部分是一个类操作，将创建一个新的类来扩展被修饰的类。在这个新类中，我们添加了两个字段和一个函数。<code class="fe mh mi mj lx b">uuid</code>字段是唯一的标识符，而<code class="fe mh mi mj lx b">created</code>字段是时间戳。</p><p id="b1d7" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在TypeScript文档中，这种技术被描述为重写构造函数。</p><p id="3edd" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">要对此进行测试，请使用以下内容:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="cb83" class="mb mc iu lx b gz md me l mf mg">const ci = new ClockIn();<br/>const ci2 = new ClockIn();<br/>const co = new ClockOut();<br/><br/>console.log(ci);<br/>console.log(ci2);<br/>console.log(co);<br/><br/>console.log(ci.hasOwnProperty('uuid'));<br/>console.log(ci['uuid']);<br/>console.log((&lt;any&gt;ci).uuid);<br/>ci['hello']('World');<br/>(&lt;any&gt;ci).hello('World #2');</span></pre><p id="9055" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们正在生成两个<code class="fe mh mi mj lx b">ClockIn</code>实例，以验证每个实例都获得了一个惟一的标识符。然后我们打印出一些数据。</p><p id="a298" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">运行时，它看起来像这样:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="2b5d" class="mb mc iu lx b gz md me l mf mg">$ npx ts-node lib/classes/timestamp.ts <br/>ClockIn {<br/>  uuid: 'bc3e6f35-c85d-491d-82c0-c906deacc774',<br/>  created: '2/10/2022, 6:11:53 PM'<br/>}<br/>ClockIn {<br/>  uuid: '13eb2df6-b9e7-4735-9130-a7ee13182d33',<br/>  created: '2/10/2022, 6:11:53 PM'<br/>}<br/>ClockOut {<br/>  uuid: '31ce8e88-90e0-40d7-9eb2-cbba5c879b5d',<br/>  created: '2/10/2022, 6:11:53 PM'<br/>}<br/>true<br/>bc3e6f35-c85d-491d-82c0-c906deacc774<br/>bc3e6f35-c85d-491d-82c0-c906deacc774<br/>Extended World<br/>Extended World #2</span></pre><p id="1ab2" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们的对象确实有添加的字段，并且两个ClockIn实例有不同的标识符。</p><p id="959b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">代码变得有趣的地方是试图直接访问一个字段，比如<code class="fe mh mi mj lx b">ci.uuid</code>。编译器给了我们一个错误，说该类型上不存在指定的字段，大概是因为ClockIn类没有名为<code class="fe mh mi mj lx b">uuid</code>的字段。但是我们通过调用<code class="fe mh mi mj lx b">hasOwnProperty</code>得知添加的属性确实存在，我们可以使用<code class="fe mh mi mj lx b">ci['uuid']</code>或者像在<code class="fe mh mi mj lx b">(&lt;any&gt;ci).uuid</code>中一样将<code class="fe mh mi mj lx b">ci</code>转换为<code class="fe mh mi mj lx b">any</code>来访问这些属性。</p><p id="9f37" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">虽然我们设法使用装饰器修改了类，但结果却很棘手。在这种情况下，访问添加的属性是不自然的，使用起来没有吸引力。</p><p id="a626" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">TypeScript文档演示了同样的问题。他们的例子展示了通过相同的机制添加一个字段<code class="fe mh mi mj lx b">reportingURL</code>。但是尝试访问该属性会引发错误，<em class="my">属性“reportingURL”在类型“bug report”</em>上不存在。据解释，因为TypeScript类型没有改变，所以类型系统不知道添加的属性。正如我们所展示的，这些属性就在那里，并且通过跳过一个环就可以获得这些属性。</p><p id="bdff" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">但是，如果我们改为覆盖类中定义的字段，会发生什么呢？考虑一下这个:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="c89d" class="mb mc iu lx b gz md me l mf mg">function Override&lt;T extends { new(...args: any[]): {} }&gt;(target: T) {<br/>    return class extends target {<br/>        area(w: number, h: number) {<br/>            return {<br/>                w, h, area: w * h<br/>            };<br/>        }<br/>    }<br/>}<br/><br/>@Override<br/>class Overridden {<br/><br/>    area(w: number, h: number) {<br/>        return w * h;<br/>    }<br/>}<br/><br/>console.log(new Overridden().area(5, 6));<br/>console.log(new Overridden().area(6, 7));</span></pre><p id="1e19" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们有一个类，<em class="my">覆盖了</em>，一个名为<em class="my">的装饰器覆盖了</em>。该类有一个名为<em class="my"> area </em>的函数，它简单地返回显而易见的值，即<em class="my">宽度</em>和<em class="my">高度</em>相乘的结果。重写版本返回一个匿名对象，该对象包含。</p><p id="9e34" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">运行脚本我们得到:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="f7f5" class="mb mc iu lx b gz md me l mf mg">$ npx ts-node lib/classes/override.ts <br/>{ w: 5, h: 6, area: 30 }<br/>{ w: 6, h: 7, area: 42 }</span></pre><p id="3565" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">显然，这确实成功地用新函数替换了原来的函数。此外，我们不需要通过任何障碍来访问重要的功能。</p><p id="9e9b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果您在类装饰器内部的匿名子类中覆盖了一个类构造函数，会发生什么？</p><p id="f71f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">例如，npm/yarn存储库中有许多decorator库，专注于记录对象创建、方法调用和属性访问。为了了解这是如何工作的，让我们来看一种在创建类的实例时打印日志消息的方法。</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="b839" class="mb mc iu lx b gz md me l mf mg">import * as util from 'util';<br/><br/>function LogClassCreate&lt;T extends { new(...args: any[]): {}}&gt;(target: T) {<br/>    return class extends target {<br/>        constructor(...args: any[]) {<br/>            super(...args);<br/>            console.log(`Create ${util.inspect(target)} with args=`, args);<br/>        }<br/>    }<br/>}<br/><br/>@LogClassCreate<br/>class Rectangle {<br/>    width: number;<br/>    height: number;<br/><br/>    constructor(width: number, height: number) {<br/>        this.height = height;<br/>        this.width = width;<br/>    }<br/><br/>    area() { return this.width * this.height; }<br/>}<br/><br/>@LogClassCreate<br/>class Circle {<br/>    diameter: number;<br/>    constructor(diameter: number) {<br/>        this.diameter = diameter;<br/>    }<br/><br/>    area() { return ((this.diameter / 2) ** 2) * (Math.PI); }<br/>}<br/><br/>const rect1 = new Rectangle(3, 5);<br/>console.log(`area rect1 ${rect1.area()}`);<br/><br/>const rect2 = new Rectangle(5, 8);<br/>console.log(`area rect2 ${rect2.area()}`);<br/><br/>const rect3 = new Rectangle(8, 13);<br/>console.log(`area rect3 ${rect3.area()}`);<br/><br/>const circ1 = new Circle(20);<br/>console.log(`area circ1 ${circ1.area()}`);</span></pre><p id="0ebb" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们有两个简单的类，矩形和圆形。LogClassCreate装饰器扩展了这个类，为它提供了一个定制的方法。因为这个方法使用了<code class="fe mh mi mj lx b">...any</code>,所以它可以用于任何带有任意数量参数的构造函数。</p><p id="c4b7" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">当程序启动时调用class decorator，当创建类实例时执行匿名子类的构造函数。</p><p id="2130" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">要验证这是否准确，请运行脚本并研究输出:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="b17c" class="mb mc iu lx b gz md me l mf mg">$ npx ts-node lib/classes/override2.ts <br/>Create [class Rectangle] with args= [ 3, 5 ]<br/>area rect1 15<br/>Create [class Rectangle] with args= [ 5, 8 ]<br/>area rect2 40<br/>Create [class Rectangle] with args= [ 8, 13 ]<br/>area rect3 104<br/>Create [class Circle] with args= [ 20 ]<br/>area circ1 <!-- -->314.1592653589793</span></pre><p id="b20f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">以<em class="my"> Create </em>开头的消息来自匿名子类的构造函数内部。事实上，这是在实例化一个类实例时执行的装饰代码。</p><p id="5a70" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">请注意，它正确地记录了构造函数的参数，每个对象都被正确地初始化，并产生正确的结果。在JavaScript数学的范围内，最后一个是正确的，因为<code class="fe mh mi mj lx b">Math.PI</code>是一个粗略的估计。</p><h1 id="afea" class="mz mc iu bd na nb nc nd ne nf ng nh ni ka nj kb nk kd nl ke nm kg nn kh no np bi translated">类装饰器可能失败</h1><p id="b982" class="pw-post-body-paragraph kz la iu lb b lc nq jv le lf nr jy lh li ns lk ll lm nt lo lp lq nu ls lt lu in bi translated">如果从类装饰函数中去掉必需的参数会发生什么？</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="8d29" class="mb mc iu lx b gz md me l mf mg">function Decorator() {<br/>    console.log('In Decorator');<br/>}<br/><br/>@Decorator<br/>class FooClass {<br/>    foo: string;<br/>}</span></pre><p id="6e0e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在这种情况下，缺少所需的签名，并引发以下编译时错误:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="3774" class="mb mc iu lx b gz md me l mf mg">error TS1329: 'Decorator' accepts too few arguments to be used as a decorator here. Did you mean to call it first and write '@Decorator()'?</span></pre><p id="87b6" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这种情况下的问题是，如上所述，类装饰器需要接受一个参数，即类的构造函数。我们忽略了那个必需的参数，错误消息有点——有点——也许——可能是这么告诉我们的。</p><h1 id="e599" class="mz mc iu bd na nb nc nd ne nf ng nh ni ka nj kb nk kd nl ke nm kg nn kh no np bi translated">摘要</h1><p id="104d" class="pw-post-body-paragraph kz la iu lb b lc nq jv le lf nr jy lh li ns lk ll lm nt lo lp lq nu ls lt lu in bi translated">我们已经学习了很多关于类装饰器的知识。装饰器接收类对象，从中我们可以访问相当多的数据。</p><p id="0e63" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">decorator函数在创建类对象时执行，而不是在构造类实例时执行。这意味着要直接影响生成的实例，我们必须创建一个匿名子类。</p><p id="3e59" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">使用匿名子类可能很棘手。访问任何添加的方法或属性都需要通过重重关卡，其中被覆盖的方法或属性透明地执行。</p><h1 id="dd3c" class="mz mc iu bd na nb nc nd ne nf ng nh ni ka nj kb nk kd nl ke nm kg nn kh no np bi translated">关于作者</h1><p id="ed59" class="pw-post-body-paragraph kz la iu lb b lc nq jv le lf nr jy lh li ns lk ll lm nt lo lp lq nu ls lt lu in bi translated"><a class="ae lv" href="https://davidherron.com" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iv"> <em class="my">大卫·赫伦</em> </strong> </a> <em class="my">:大卫·赫伦是一名作家和软件工程师，专注于技术的明智使用。他对太阳能、风能和电动汽车等清洁能源技术特别感兴趣。David在硅谷从事了近30年的软件工作，从电子邮件系统到视频流，再到Java编程语言，他已经出版了几本关于Node.js编程和电动汽车的书籍。</em></p></div><div class="ab cl nv nw hy nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="in io ip iq ir"><p id="4e0f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><em class="my">原载于</em><a class="ae lv" href="https://techsparx.com/nodejs/typescript/decorators/classes.html" rel="noopener ugc nofollow" target="_blank"><em class="my">https://techsparx.com</em></a><em class="my">。</em></p></div></div>    
</body>
</html>