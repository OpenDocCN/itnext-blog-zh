<html>
<head>
<title>Using httpd as a reverse proxy for OpenID Connect authentication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用httpd作为OpenID连接身份验证的反向代理</h1>
<blockquote>原文：<a href="https://itnext.io/using-httpd-as-a-reverse-proxy-for-openid-connect-authentication-791d7e517608?source=collection_archive---------1-----------------------#2021-03-12">https://itnext.io/using-httpd-as-a-reverse-proxy-for-openid-connect-authentication-791d7e517608?source=collection_archive---------1-----------------------#2021-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="7a5d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">为什么是这篇文章？</h1><p id="e0ef" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">嗯，由于许多原因…在经历从模块化应用到微服务应用的转变时，认证方法也发生了变化..过去，我们会将应用程序连接到Ldap甚至Kerberos服务器(以及更多类似Active directory的服务器),而现在，我们使用基于HTTP的协议进行身份验证，如SAML2和OpenID Connect。</p><p id="f9af" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在某些情况下，将应用程序迁移到新的身份验证方式的开销很大。在某些情况下，应用程序根本没有任何身份验证，您需要确保用户在开始工作之前已经过身份验证。</p><p id="0ddc" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">最后，我们需要一个反向代理，它将身份验证请求发送到OpenID Connect服务器，并在我们通过身份验证后将我们重定向到应用程序。</p><h1 id="ee7f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">我们需要什么？</h1><p id="183e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了实现我们的设置，我们需要一个OpenID连接服务器，为此，我们将使用Keycloak开源和httpd with OpenID Connect模块作为反向代理。<br/>本文假设您对我们正在使用的Kubernetes集群拥有集群管理特权。</p><ol class=""><li id="6709" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated">Keycloak——Red Hat Signed Sign-On开源项目(对于生产用例，我强烈推荐使用rh-sso，而不是key cloak来处理生产环境的所有相关方面</li><li id="1764" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">httpd的自定义容器，我将在本教程中详细介绍它</li></ol><h1 id="6e2a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">入门指南</h1><h2 id="212e" class="mc jo iq bd jp md me dn jt mf mg dp jx kw mh mi kb la mj mk kf le ml mm kj mn bi translated">键盘锁设置</h2><p id="e343" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">要将keyCloak部署到Kubernetes集群，可以运行以下命令:</p><p id="1bbc" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">首先，为KeyCloak创建一个名称空间</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="c351" class="mc jo iq mt b gy mx my l mz na">$ oc create ns keycloak</span><span id="3ff3" class="mc jo iq mt b gy nb my l mz na">$ kubectl config set-context --current --namespace=keycloak</span></pre><p id="efa0" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">第一步—数据库<br/> </strong> KeyCloak可以使用PostgreSQL作为后端服务器，为此我们将首先使用持久存储来部署它。</p><p id="1b87" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">让我们创建PVC和</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="ecae" class="mc jo iq mt b gy mx my l mz na">$ cat &gt; postgresql-pvc.yaml &lt;&lt; EOF<br/>apiVersion: v1<br/>kind: PersistentVolumeClaim<br/>metadata:<br/>  name: postgresql-pvc<br/>spec:<br/>  accessModes:<br/>    - ReadWriteOnce<br/>  volumeMode: Filesystem<br/>  resources:<br/>    requests:<br/>      storage: 1Gi<br/>EOF</span></pre><p id="b74d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">并应用它:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="4606" class="mc jo iq mt b gy mx my l mz na">$ oc apply -f postgresql-pvc.yaml</span></pre><p id="5f21" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在我们需要生成PostgreSQL部署:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="f0ec" class="mc jo iq mt b gy mx my l mz na">$ cat &gt; postgresql-deployment.yaml &lt;&lt; EOF<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: postgres<br/>  labels:<br/>    app: postgres<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: postgres<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: postgres<br/>    spec:<br/>      containers:<br/>        - name: postgres<br/>          image: docker.io/library/postgres:11<br/>          imagePullPolicy: "Always"<br/>          ports:<br/>            - containerPort: 5432<br/>          env:<br/>            - name: POSTGRES_PASSWORD<br/>              value: keycloak_passwd<br/>            - name: POSTGRES_USER<br/>              value: keycloak<br/>            - name: POSTGRES_DB<br/>              value: keycloak<br/>          volumeMounts:<br/>            - mountPath: /var/lib/postgresql/data<br/>              name: postgredb<br/>      volumes:<br/>        - name: postgredb<br/>          persistentVolumeClaim:<br/>            claimName: postgresql-pvc<br/>EOF</span></pre><p id="3431" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">并应用它:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="9597" class="mc jo iq mt b gy mx my l mz na">$ oc apply -f postgresql-deployment.yaml</span></pre><p id="83dd" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">为了让keycloak与数据库一起工作，我们需要为它生成服务:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="2194" class="mc jo iq mt b gy mx my l mz na">$ cat &gt; postgresql-service.yaml &lt;&lt; EOF<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: postgres<br/>  labels:<br/>    app: postgres<br/>spec:<br/>  ports:<br/>  - name: postgres<br/>    port: 5432<br/>    targetPort: 5432<br/>  selector:<br/>    app: postgres<br/>EOF</span></pre><p id="cc3a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">并应用它:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="1296" class="mc jo iq mt b gy mx my l mz na">$ oc apply -f postgresql-service.yaml</span></pre><p id="7962" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">步骤2—应用程序<br/> </strong>我们需要做的第一件事是部署应用程序并将其指向我们的PostgreSQL服务器:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="8123" class="mc jo iq mt b gy mx my l mz na">$ cat &gt; keycloak.yaml &lt;&lt; EOF<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: keycloak<br/>  labels:<br/>    app: keycloak<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: keycloak<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: keycloak<br/>    spec:<br/>      containers:<br/>      - name: keycloak<br/>        image: quay.io/keycloak/keycloak:12.0.4<br/>        env:<br/>        - name: KEYCLOAK_USER<br/>          value: "admin"<br/>        - name: KEYCLOAK_PASSWORD<br/>          value: "admin"<br/>        - name: PROXY_ADDRESS_FORWARDING<br/>          value: "true"<br/>        - name: DB_ADDR<br/>          value: postgres.keycloak.svc<br/>        - name: DB_USER<br/>          value: keycloak<br/>        - name: DB_PASSWORD<br/>          value: keycloak_passwd<br/>        - name: DB_DATABASE<br/>          value: keycloak<br/>        ports:<br/>        - name: http<br/>          containerPort: 8080<br/>        - name: https<br/>          containerPort: 8443<br/>        readinessProbe:<br/>          httpGet:<br/>            path: /auth/realms/master<br/>            port: 8080<br/>EOF</span></pre><p id="99f9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">并应用它:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="8b13" class="mc jo iq mt b gy mx my l mz na">$ oc apply -f keycloak.yaml</span></pre><p id="bab4" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">确保它已启动并正在运行:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="eefd" class="mc jo iq mt b gy mx my l mz na">$ oc get pods<br/> NAME                        READY   STATUS    RESTARTS   AGE<br/>postgres-66cb8c965f-b96lr   1/1     Running   1          16h<br/>keycloak-758d65676d-qwc7j   1/1     Running   2          16h</span></pre><p id="7da7" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在我们需要为我们的keycloak服务器添加服务和入口，所以在这个例子中我们称它为sso.example.com</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="e97d" class="mc jo iq mt b gy mx my l mz na">$ cat &gt; keycloak-service.yaml &lt;&lt; EOF<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: keycloak<br/>  labels:<br/>    app: keycloak<br/>spec:<br/>  ports:<br/>  - name: keycloak<br/>    port: 8080<br/>    targetPort: 8080<br/>  - name: keycloak-ssl<br/>    port: 8443<br/>    targetPort: 8443<br/>  selector:<br/>    app: keycloak<br/>EOF</span></pre><p id="7384" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">对于入口:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="3262" class="mc jo iq mt b gy mx my l mz na">$ cat &gt; keycloak-ingress.yaml &lt;&lt; EOF<br/>apiVersion: networking.k8s.io/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: keycloak-ingress<br/>spec:<br/>  tls:<br/>    - hosts:<br/>      - sso.example.net<br/>      secretName: tls-sso<br/>  rules:<br/>  - host: "sso.example.net"<br/>    http:<br/>      paths:<br/>      - backend:<br/>          serviceName: keycloak<br/>          servicePort: 8080<br/>        path: /<br/>EOF</span></pre><p id="e30b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">注意<br/> </strong>如您所见，我们在这里使用了一个TLS密钥来启用TLS，为了生成密钥，我们使用教程<a class="ae nc" href="https://two-oes.medium.com/working-with-openssl-and-dns-alternative-names-367f06a23841?sk=28bf711fe07e62e407de071a9f8397b7" rel="noopener"> OpenSSL更改DNS名称</a>来创建证书。所有文件准备就绪后，我们就可以开始生成文件了:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="56d0" class="mc jo iq mt b gy mx my l mz na">$ oc create secret tls tls-sso --cert=./sso.crt --key=./sso.key</span></pre><p id="cf53" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">一旦秘密和入口路径被创建，是时候切换到网络，所以进入<a class="ae nc" href="https://sso.example.com" rel="noopener ugc nofollow" target="_blank">https://sso.example.com</a></p><p id="a09b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">为了快速解决问题，我们可以使用以下命令提取FQDN:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="a50a" class="mc jo iq mt b gy mx my l mz na">$ echo -n '<a class="ae nc" rel="noopener ugc nofollow" target="_blank" href="/'">https://'</a> &amp;&amp;  oc get ingress keycloak-ingress -o jsonpath='{.spec.rules[0].host}' ; echo</span></pre><p id="fc57" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">转到网页:</p><figure class="mo mp mq mr gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nd"><img src="../Images/638bc80febee40489643748852b69de7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0c32JY8yjVNnkfD0O2dY_w.png"/></div></div></figure><p id="0a63" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">踢管理控制台:</p><figure class="mo mp mq mr gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nl"><img src="../Images/49ddbd50542c9feae85fe0723de0241b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*51IliNeaC_xjWLfPELKgwA.png"/></div></div></figure><p id="f6f0" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">登录门户(默认用户名和密码是admin/admin)</p><p id="8366" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">登录后，让我们创建一个新域:</p><figure class="mo mp mq mr gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nm"><img src="../Images/cce890643f611f4908a931ce025b4451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tDGftMEQYN8BMHWoL921hA.png"/></div></div></figure><p id="6029" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">对于这个例子，我们称之为“例子”:</p><figure class="mo mp mq mr gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nn"><img src="../Images/732d09b3bae590b2456956403c2239b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mcZP-FUc44q75yr7zrdh_g.png"/></div></div></figure><p id="d929" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">创建领域后，让我们添加一个客户端:</p><p id="409e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">转到客户端“选项卡”并单击创建:</p><figure class="mo mp mq mr gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi no"><img src="../Images/9308764d3d755df4b458ea4737a67abc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oUyTMDhfqzKMVDNItuTPgg.png"/></div></div></figure><p id="f476" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">写下客户端的名称，在本例中为“反向单点登录”</p><figure class="mo mp mq mr gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi np"><img src="../Images/789fb8a5404baeb5849333d099a2f68b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iQYxbpTg3B-mhTE_4_o81Q.png"/></div></div></figure><p id="e93a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">单击客户端上的“后退”,并确保以下内容:</p><ul class=""><li id="af5d" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li nq lu lv lw bi translated">登录主题:keycloak</li><li id="f74c" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li nq lu lv lw bi translated">客户端协议:OpenID连接</li><li id="fd42" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li nq lu lv lw bi translated">访问类型:机密</li></ul><figure class="mo mp mq mr gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nr"><img src="../Images/0db2cabffb8f4877b8191a7f7d7d3e8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JPmjgwiEKkWcNtXCZKE6Kg.png"/></div></div></figure><p id="0619" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在重定向URL中添加星号“*”，然后单击保存。</p><p id="aeef" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">一个新的“凭证”选项卡将出现在页面顶部，单击它，然后单击“重新生成注册访问令牌”</p><figure class="mo mp mq mr gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ns"><img src="../Images/4ab05fe12e7a47d64dc6e496a5057231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rnnkPgo_CEJCf17eJ68loA.png"/></div></div></figure><p id="4181" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">将秘密和访问令牌都复制到一边，我们就可以开始了(转到反向代理设置)</p><h2 id="31d2" class="mc jo iq bd jp md me dn jt mf mg dp jx kw mh mi kb la mj mk kf le ml mm kj mn bi translated">步骤3 —反向代理</h2><p id="d221" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">就在Kubernetes上部署应用程序而言，我们到目前为止所做的一切都很简单，现在我们可以继续前进，用已经可用的部分创建一个小应用程序……我们只需要将它们放在一起。</p><p id="e841" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">让我们以CENTOS基础映像为例，使用代理和openidc安装Apache的httpd。</p><p id="9f15" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">创建一个Dockerfile文件，其中包含以下内容:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="169f" class="mc jo iq mt b gy mx my l mz na">$ cat &gt; Dockerfile &lt;&lt; EOF<br/>FROM centos<br/>MAINTAINER Oren Oichman &lt;Back to Root&gt;</span><span id="4b36" class="mc jo iq mt b gy nb my l mz na">RUN dnf install -y httpd &amp;&amp; dnf module \<br/>    enable mod_auth_openidc -y &amp;&amp; \<br/>    dnf install -y mod_auth_openidc &amp;&amp; dnf clean all</span><span id="a4b1" class="mc jo iq mt b gy nb my l mz na">COPY run-httpd.sh /usr/sbin/run-httpd.sh<br/>COPY ca.crt /etc/pki/ca-trust/source/anchors/rh-sso.crt</span><span id="0a73" class="mc jo iq mt b gy nb my l mz na">RUN update-ca-trust extract<br/>RUN echo "PidFile /tmp/http.pid" &gt;&gt; /etc/httpd/conf/httpd.conf<br/>RUN sed -i "s/Listen\ 80/Listen\ 8080/g"  /etc/httpd/conf/httpd.conf<br/>RUN sed -i "s/\"logs\/error_log\"/\/dev\/stderr/g" /etc/httpd/conf/httpd.conf<br/>RUN sed -i "s/CustomLog \"logs\/access_log\"/CustomLog \/dev\/stdout/g" /etc/httpd/conf/httpd.conf</span><span id="62cc" class="mc jo iq mt b gy nb my l mz na">RUN echo 'IncludeOptional /opt/app-root/*.conf' &gt;&gt; /etc/httpd/conf/httpd.conf<br/>RUN mkdir /opt/app-root/ &amp;&amp; chown apache:apache /opt/app-root/ &amp;&amp; chmod 777 /opt/app-root/</span><span id="04ba" class="mc jo iq mt b gy nb my l mz na">USER apache</span><span id="0f36" class="mc jo iq mt b gy nb my l mz na">EXPOSE 8080 8081<br/>ENTRYPOINT ["/usr/sbin/run-httpd.sh"]<br/>EOF</span></pre><p id="88b1" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在我们需要创建一个配置文件来启用我们刚刚安装的模块，但是我们需要在服务启动时使用它。最好的方法是创建一个启动脚本来生成配置文件。</p><p id="6a3e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">让我们生成“run-httpd.sh”脚本:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="60c4" class="mc jo iq mt b gy mx my l mz na">$ cat &gt; run-httpd.sh &lt;&lt; EOF<br/>#!/bin/bash</span><span id="4e98" class="mc jo iq mt b gy nb my l mz na">if [ -z ${RH_SSO_FQDN} ]; then<br/>        echo "Environment variable RH_SSO_FQDN undefined"<br/>        exit 1<br/>elif [[ -z $CLIENT_ID ]]; then<br/>        echo "Environment variable CLIENT_ID undefined"<br/>        exit 1<br/>elif [[ -z $CLIENT_SECRET ]]; then<br/>        echo "Environment variable CLIENT_SECRET undefined"<br/>        exit 1<br/>elif [[ -z $REVERSE_SSO_ROUTE ]]; then<br/>        echo "Environment variable REVERSE_SSO_ROUTE undefined"<br/>        exit 1<br/>elif [[ -z ${DST_SERVICE_NAME} ]]; then<br/>        echo "Environment variable DST_SERVICE_NAME undefined"<br/>        exit 1<br/>elif [[ -z $RH_SSO_REALM ]]; then<br/>        echo "Environment variable RH_SSO_REALM undefined"<br/>        exit 1<br/>elif [[ -z ${DST_SERVICE_PORT} ]]; then<br/>        echo "Environment variable DST_SERVICE_PORT undefined"<br/>        exit 1<br/>fi</span><span id="85c5" class="mc jo iq mt b gy nb my l mz na">echo "<br/>&lt;VirtualHost *:8080&gt;<br/>        OIDCProviderMetadataURL <a class="ae nc" href="https://${RH_SSO_FQDN}/auth/realms/${RH_SSO_REALM}/.well-known/openid-configuration" rel="noopener ugc nofollow" target="_blank">https://${RH_SSO_FQDN}/auth/realms/${RH_SSO_REALM}/.well-known/openid-configuration</a><br/>        OIDCClientID $CLIENT_ID<br/>        OIDCClientSecret $CLIENT_SECRET<br/>        OIDCRedirectURI <a class="ae nc" href="https://${REVERSE_SSO_ROUTE}/oauth2callback" rel="noopener ugc nofollow" target="_blank">https://${REVERSE_SSO_ROUTE}/oauth2callback</a><br/>        OIDCCryptoPassphrase openshift<br/>        <!-- -->OIDCPassClaimsAs both<br/>        #Header set Authorization "Bearer %{OIDC_access_token}e" env=OIDC_access_token</span><span id="48b8" class="mc jo iq mt b gy nb my l mz na">        &lt;Directory "/opt/app-root/"&gt;<br/>                AllowOverride All<br/>        &lt;/Directory&gt;</span><span id="c425" class="mc jo iq mt b gy nb my l mz na">        &lt;Location /&gt;<br/>                AuthType openid-connect<br/>                Require valid-user<br/>                ProxyPreserveHost on<br/>                ProxyPass       <a class="ae nc" rel="noopener ugc nofollow" target="_blank" href="/${DST_SERVICE_NAME}:${DST_SERVICE_PORT}/">http://${DST_SERVICE_NAME}:${DST_SERVICE_PORT}/</a><br/>                ProxyPassReverse        <a class="ae nc" rel="noopener ugc nofollow" target="_blank" href="/${DST_SERVICE_NAME}:${DST_SERVICE_PORT}/">http://${DST_SERVICE_NAME}:${DST_SERVICE_PORT}/</a><br/>        &lt;/Location&gt;<br/>&lt;/VirtualHost&gt;<br/>" &gt; /tmp/reverse.conf</span><span id="3f94" class="mc jo iq mt b gy nb my l mz na">mv /tmp/reverse.conf /opt/app-root/reverse.conf</span><span id="cb06" class="mc jo iq mt b gy nb my l mz na">/usr/sbin/httpd $OPTIONS -DFOREGROUND<br/>EOF</span></pre><p id="06b1" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">将您的keyclock CA复制到名为ca.crt的文件中，并将其放在我们的工作目录中</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="790b" class="mc jo iq mt b gy mx my l mz na">#cp &lt;path to your CA&gt; ./ca.crt</span></pre><p id="fc63" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在我们可以建立图像</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="ca99" class="mc jo iq mt b gy mx my l mz na">$ buildah bud -f Dockerfile -t &lt; registry &gt;/reverse-sso</span></pre><p id="36a4" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在只需将图像推送到您的注册表中:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="928d" class="mc jo iq mt b gy mx my l mz na">$ buildah push &lt; registry &gt;/reverse-sso</span></pre><p id="544f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在我们有了一个映像，我们可以继续部署了。</p><p id="61c8" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我知道这看起来很奇怪，但我们需要部署服务和路线/入口，然后是pod。</p><p id="31df" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">让我们从服务开始:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="a1c8" class="mc jo iq mt b gy mx my l mz na">$ cat &gt; service.yaml &lt;&lt; EOF<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: reverse-sso<br/>spec:<br/>  selector:<br/>    app: reverse-sso<br/>  ports:<br/>    - protocol: TCP<br/>      port: 8080<br/>      targetPort: 8080<br/>EOF</span></pre><p id="cac9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在出场的是:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="4861" class="mc jo iq mt b gy mx my l mz na">$ cat &gt; ingress.yaml &lt;&lt; EOF<br/>apiVersion: networking.k8s.io/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: reverse-ingress<br/>spec:<br/>  rules:<br/>  - host: "my-app.example.com"<br/>    http:<br/>      paths:<br/>      - backend:<br/>          serviceName: reverse-sso<br/>          servicePort: 8080<br/>        path: /<br/>EOF</span></pre><p id="3353" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">最后一步，让我们部署应用程序:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="5b79" class="mc jo iq mt b gy mx my l mz na">$ cat &gt; pod-deployment.yaml &lt;&lt; EOF<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: reverse-sso<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: reverse-sso<br/>  replicas: 1<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: reverse-sso<br/>    spec:<br/>      containers:<br/>        - name: reverse-sso<br/>          image: &lt; registry &gt;/reverse-sso:latest<br/>          imagePullPolicy: Always<br/>          env:<br/>          - name: RH_SSO_FQDN<br/>            value: <br/>          - name: CLIENT_ID<br/>            value: <br/>          - name: CLIENT_SECRET<br/>            value: <br/>          - name: REVERSE_SSO_ROUTE<br/>            value: <br/>          - name: DST_SERVICE_NAME<br/>            value:<br/>          - name: RH_SSO_REALM<br/>            value:<br/>          - name: DST_SERVICE_PORT<br/>            value:<br/>          ports:<br/>            - containerPort: 8080<br/>EOF</span></pre><p id="dddf" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">剩下的就相当简单了，将以下值添加到部署文件并应用它:</p><ul class=""><li id="0bde" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li nq lu lv lw bi translated">RH_SSO_FQDN —红帽SSO的FQDN(在我们的示例中是keycloak</li><li id="4112" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li nq lu lv lw bi translated">CLIENT_ID —我们使用的客户端的ID，在我们的例子中是“反向单点登录”</li><li id="9205" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li nq lu lv lw bi translated">CLIENT _ SECRET—key cloak中“凭据”选项卡上的客户端密码</li><li id="7808" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li nq lu lv lw bi translated">REVERSE_SSO_ROUTE —反向SSO服务的路由/入口FQDN(我们之前创建的)</li><li id="295e" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li nq lu lv lw bi translated">DST_SERVICE_NAME —我们希望将流量发送到的目标服务</li><li id="f720" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li nq lu lv lw bi translated">RH_SSO_REALM —在我们的例子中是“example”</li><li id="2581" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li nq lu lv lw bi translated">DST_SERVICE_PORT —我们的服务应用程序的端口</li></ul><p id="69f9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">并应用部署:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="e442" class="mc jo iq mt b gy mx my l mz na">$ oc apply -f pod-deployment.yaml</span></pre><p id="e889" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">剩下的就是去反向单一标志的路线/入口:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="d7c0" class="mc jo iq mt b gy mx my l mz na">$ echo -n '<a class="ae nc" rel="noopener ugc nofollow" target="_blank" href="/'">http://'</a> &amp;&amp;  oc get ingress reverse-ingress -o jsonpath='{.spec.rules[0].host}' ; echo<br/>http://my-app.example.com</span></pre><p id="ebb7" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果您有任何问题，请随时回复/留下您的评论。你可以在领英上找到:<a class="ae nc" href="https://www.linkedin.com/in/orenoichman" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/orenoichman</a>T3】或者在推特上找到:<a class="ae nc" href="https://twitter.com/ooichman" rel="noopener ugc nofollow" target="_blank">https://twitter.com/ooichman</a></p><p id="a9bd" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">玩得开心！！！</p></div></div>    
</body>
</html>