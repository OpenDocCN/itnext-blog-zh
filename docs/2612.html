<html>
<head>
<title>Implementing a Todo list with Undo-Redo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Undo-Redo实现待办事项列表</h1>
<blockquote>原文：<a href="https://itnext.io/implementing-a-todo-list-with-undo-redo-4b38958dbd05?source=collection_archive---------2-----------------------#2019-06-24">https://itnext.io/implementing-a-todo-list-with-undo-redo-4b38958dbd05?source=collection_archive---------2-----------------------#2019-06-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/67a31fbf6ed9286042bf08b298a0664e.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/0*Ww63WIODhPp8-jf4.png"/></div></figure><p id="70b7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为简单的待办事项列表应用程序添加撤销/重做支持</p><h1 id="f295" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">1.引言。</h1><p id="43d2" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">大多数需要撤销-重做特性的用例都与编辑器有关，无论是文本编辑器还是图形编辑器。为了简单起见，我将使用一个基于Ngrx的简单todo，但是请相信我，如果您希望在应用程序中添加对历史的支持，您将很容易应用本文中的思想。</p><p id="ceaa" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们将开始实施，而不是从零开始。我已经准备了应用程序，我们将使用附加撤销重做。</p><p id="7b89" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里有一个到存储库的链接:<a class="ae ly" href="https://github.com/Stioneq/todo-undo-redo-initial" rel="noopener ugc nofollow" target="_blank">存储库</a></p><p id="3d20" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><a class="ae ly" href="https://stioneq.github.io/todo-undo-redo-initial/" rel="noopener ugc nofollow" target="_blank"> Github页面</a></p><p id="7cf0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里我们有一个基本的Todo功能:</p><ol class=""><li id="caf7" class="lz ma it jz b ka kb ke kf ki mb km mc kq md ku me mf mg mh bi translated">添加新项目</li><li id="684d" class="lz ma it jz b ka mi ke mj ki mk km ml kq mm ku me mf mg mh bi translated">更新现有项目</li><li id="ccfc" class="lz ma it jz b ka mi ke mj ki mk km ml kq mm ku me mf mg mh bi translated">移除项目。</li></ol><p id="ce1e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">和两个附加功能:</p><ol class=""><li id="b691" class="lz ma it jz b ka kb ke kf ki mb km mc kq md ku me mf mg mh bi translated">更改应用主题</li><li id="0a73" class="lz ma it jz b ka mi ke mj ki mk km ml kq mm ku me mf mg mh bi translated">增大/减小字体大小</li></ol><p id="48e8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">所有项目数据和设置(字体、主题)都位于Ngrx存储中。</p><p id="2bad" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">让我们定义实现撤销-重做-待办事项的需求:</strong></p><p id="ea96" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">1.我们想要撤销/重做想要的操作(添加、更新、删除、增加/减小字体大小)，但不想撤销/重做更改应用程序主题。</p><p id="4520" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">2.我们希望有快捷方式和按钮的工具提示撤销/重做。</p><p id="c817" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">工具提示应该描述我们撤销/重做什么样的操作。</p><h1 id="7136" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">2.定义</h1><p id="bf8a" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">我考虑了两种撤销/重做实现方式:</p><ol class=""><li id="5162" class="lz ma it jz b ka kb ke kf ki mb km mc kq md ku me mf mg mh bi translated">记住每个可以撤销的动作的整个状态。</li><li id="901e" class="lz ma it jz b ka mi ke mj ki mk km ml kq mm ku me mf mg mh bi translated">创建一个反向操作链。</li></ol><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/b591434998e6deed210c4c6b4c1cdd7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*n9MCVWF_UG7Ba43adxeTrg.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">两种方式的比较</figcaption></figure><p id="4adf" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对于本文，我决定使用第一种方法。</p><p id="3b2e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了实现撤销/重做，我们需要在Ngrx中使用一个中间件层，它由元缩减器表示。</p><p id="ee19" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如图所示，当您调度一个动作时，该动作由元缩减器处理。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/bc7280d1027522142e4e2afd55c12f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*EER3AstymAEjPpd_iyhd_g.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">Ngrx中的流量</figcaption></figure><p id="5d04" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是一个元减速器结构的例子。它是一个高阶函数。</p><pre class="mo mp mq mr gt mx my mz na aw nb bi"><span id="713f" class="nc kw it my b gy nd ne l nf ng">export function meta(reducer: <a class="ae ly" href="https://ngrx.io/api/store/ActionReducer" rel="noopener ugc nofollow" target="_blank">ActionReducer</a>&lt;any&gt;):<a class="ae ly" href="https://ngrx.io/api/store/ActionReducer" rel="noopener ugc nofollow" target="_blank">ActionReducer</a>&lt;any&gt; {</span><span id="75db" class="nc kw it my b gy nh ne l nf ng">return function(<a class="ae ly" href="https://ngrx.io/api/store-devtools/StoreDevtools#state" rel="noopener ugc nofollow" target="_blank">state</a>, action) {</span><span id="1797" class="nc kw it my b gy nh ne l nf ng">return reducer(<a class="ae ly" href="https://ngrx.io/api/store-devtools/StoreDevtools#state" rel="noopener ugc nofollow" target="_blank">state</a>, action);</span><span id="36b9" class="nc kw it my b gy nh ne l nf ng">};</span><span id="9d8a" class="nc kw it my b gy nh ne l nf ng">}</span></pre><h1 id="41d9" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">3.履行</h1><p id="6fb9" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">首先，生成撤销-重做模块。</p><pre class="mo mp mq mr gt mx my mz na aw nb bi"><span id="3e6c" class="nc kw it my b gy nd ne l nf ng">ng g m undo-redo</span></pre><p id="a4dd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">并创建所需的Ngrx组件:</p><ol class=""><li id="efa8" class="lz ma it jz b ka kb ke kf ki mb km mc kq md ku me mf mg mh bi translated">动作(我们需要三个动作:撤销/重做/添加动作)</li><li id="c169" class="lz ma it jz b ka mi ke mj ki mk km ml kq mm ku me mf mg mh bi translated">减速器——我们处理的地方</li><li id="1041" class="lz ma it jz b ka mi ke mj ki mk km ml kq mm ku me mf mg mh bi translated">选择器</li><li id="de8e" class="lz ma it jz b ka mi ke mj ki mk km ml kq mm ku me mf mg mh bi translated">最重要的一个是Metareducer，它是我们处理存储当前状态的地方。</li></ol><p id="160d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">可撤销状态:</strong></p><p id="de7e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了有一个一致的状态，让我们可以来回转换。</p><p id="aea5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们应该有过去状态、未来状态和当前状态:</p><pre class="mo mp mq mr gt mx my mz na aw nb bi"><span id="ca93" class="nc kw it my b gy nd ne l nf ng">export interface UndoableState {<br/>  past: any[];<br/>  present: any;<br/>  future: any[];<br/>}</span></pre><p id="6db0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">值得注意的是，这不是我们将在Ngrx中使用的状态。它在元减速器中是必需的。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/29745f34b25b5c86ce5fe397c04f894e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*7l_Wz5fjAfH30wa6BQtU-Q.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">执行可撤销/不可撤销操作时的流程</figcaption></figure><p id="6105" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如图所示，当我们执行一个可撤销的动作(一个可以撤销/重做的动作)时，meta reducer通过向数组添加新的状态来更新过去的状态，然后它通过移动效果和reducer继续照常工作。</p><p id="65ce" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">可撤销动作:</strong></p><p id="2b8b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在开始实现元缩减器之前，让我们定义可用于撤销的动作及其结构。</p><pre class="mo mp mq mr gt mx my mz na aw nb bi"><span id="8a29" class="nc kw it my b gy nd ne l nf ng">export interface UndoableOperation {<br/>  type: string;<br/>  hint?: string;<br/>}</span></pre><p id="4118" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">该类型将用于跟踪我们应该撤消哪种操作。提示字段是为工具提示目的而定义的。</p><p id="0f84" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">使用给定的接口，我们可以定义操作:</p><pre class="mo mp mq mr gt mx my mz na aw nb bi"><span id="8bf6" class="nc kw it my b gy nd ne l nf ng">export const UNDOABLE_OPERATIONS: { type: string, hint?: string }[] = [<br/>    {hint: 'Update todo', type: TodoActionTypes.<em class="nj">UPDATE</em>},<br/>    {hint: 'Add todo', type: TodoActionTypes.<em class="nj">ADD</em>},<br/>    {hint: 'Remove todo', type: TodoActionTypes.<em class="nj">DELETE</em>},<br/>    {hint: 'Decrease font size', type: SettingsActionTypes.<em class="nj">DEC_FONT</em>},<br/>    {hint: 'Increase font size', type: SettingsActionTypes.<em class="nj">INC_FONT</em>},<br/>  ];</span></pre><p id="055f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们故意没有指定更改主题动作，因为我们不想让它不可撤销。</p><p id="ef63" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在编写meta reducer之前，我们需要做的最后一件事是定义需要持久化的状态键。我将把它们描述为这些键的路径。</p><pre class="mo mp mq mr gt mx my mz na aw nb bi"><span id="5045" class="nc kw it my b gy nd ne l nf ng">const PERSISTENT_KEYS = ['todos', 'settings.fontSize'];</span></pre><p id="5a1a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们添加了todos，因为我们想完全存储这个子状态。从设置，我们只需要保持字体大小。</p><p id="dd73" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">金属减速器</strong></p><p id="408d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在我们已经准备好编写元缩减器了，让我们开始吧。</p><p id="425c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">首先，我们初始化我们的不可撤销状态对象。最初，我们没有过去状态和未来状态，但是我们有一个通过调用Init action定义的父状态。</p><pre class="mo mp mq mr gt mx my mz na aw nb bi"><span id="f52f" class="nc kw it my b gy nd ne l nf ng">ActionReducer&lt;any&gt; {<br/>  let states: UndoableState = {<br/>    past: [],<br/>    present: reducer(undefined, {type: '__INIT__'}),<br/>    future: []<br/>  };</span></pre><p id="380a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">Meta reducer是一个高阶函数，所以我们需要返回一个函数:</p><pre class="mo mp mq mr gt mx my mz na aw nb bi"><span id="9c12" class="nc kw it my b gy nd ne l nf ng">return (state, action) =&gt; {<br/>  const {past, present, future} = states;<br/>  //...</span><span id="7acf" class="nc kw it my b gy nh ne l nf ng">}</span></pre><p id="5bf4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后，我们定义如何处理传入操作的方式:</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0e15" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是什么？</p><ol class=""><li id="8321" class="lz ma it jz b ka kb ke kf ki mb km mc kq md ku me mf mg mh bi translated">如果动作不是撤销/重做类型，我们检查它是否在可撤销操作列表中，如果是，我们执行该动作并将结果存储到当前状态，并且我们还通过附加过去状态来更新过去状态的列表。</li><li id="543a" class="lz ma it jz b ka mi ke mj ki mk km ml kq mm ku me mf mg mh bi translated">我们使用<em class="nj"> extractState </em>方法提取状态。正如你所记得的，我们已经定义了持久键数组，我们用它来减少在状态中存储不必要的字段。为了简单起见，我使用lodash函数</li></ol><pre class="mo mp mq mr gt mx my mz na aw nb bi"><span id="a3f9" class="nc kw it my b gy nd ne l nf ng">function extractState(state: AppState) {<br/>  return pick(state, PERSISTENT_KEYS);<br/>}</span></pre><p id="4745" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">3.我们在最后执行添加操作，只是为了让撤销/重做按钮有工具提示。如果没有指定提示，我们传递动作的提示或动作的类型。</p><p id="0c72" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">4.如果动作是不可撤销的，我们只需更新当前状态以保持其一致性。</p><p id="f3d9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们编写撤销和重做处理程序:</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c7f7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这很简单:</p><ol class=""><li id="3f99" class="lz ma it jz b ka kb ke kf ki mb km mc kq md ku me mf mg mh bi translated">对于撤销，我们只是通过获取最后一项并将其放置到当前来更新过去的状态。我们把现在转移到未来状态。</li><li id="1b5e" class="lz ma it jz b ka mi ke mj ki mk km ml kq mm ku me mf mg mh bi translated">对于重做，我们反之亦然</li></ol><p id="ec2d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">值得注意的是，我们使用合并状态，因为我们部分存储我们的状态。</p><pre class="mo mp mq mr gt mx my mz na aw nb bi"><span id="ff20" class="nc kw it my b gy nd ne l nf ng">function mergeStates(state: AppState, undoablePart) {<br/>  const newState = cloneDeep(state);<br/>  PERSISTENT_KEYS.forEach(key =&gt; set(newState, key, get(undoablePart, key)));<br/>  return newState;<br/>}</span></pre><p id="f539" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了保持简单，我们还利用了Lodash中的get和set。</p><p id="8eb2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们回顾一下元缩减器中的最终内容:</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">撤消-重做.元测试</figcaption></figure><h1 id="2f8f" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">4.首次使用</h1><p id="192b" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">让我们通过添加撤销(ctrl-z)和恢复(ctrl-y)的快捷方式来更新我们的todo应用程序</p><p id="4e2e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们需要在app.component中添加较小的更改:</p><pre class="mo mp mq mr gt mx my mz na aw nb bi"><span id="00f9" class="nc kw it my b gy nd ne l nf ng">@HostListener('window:keydown', ['$event']) keyDown(e: KeyboardEvent) {<br/>  if (e.ctrlKey &amp;&amp; e.code === 'KeyZ') {<br/>    this.store.dispatch(new UndoAction());<br/>  } else if (e.ctrlKey &amp;&amp; e.code === 'KeyY') {<br/>    this.store.dispatch(new RedoAction());<br/>  }<br/>}</span></pre><p id="1b7e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但这还不够。我们还需要在我们的应用程序中启用元减速器。</p><pre class="mo mp mq mr gt mx my mz na aw nb bi"><span id="3c77" class="nc kw it my b gy nd ne l nf ng">StoreModule.<em class="nj">forRoot</em>(appReducer, {metaReducers: [undoredoMeta]})</span></pre><p id="2aef" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，如果我们运行我们的应用程序，我们可以尝试撤销/重做操作。一切都很完美。</p><h1 id="15a9" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">4.第二次使用</h1><p id="47f1" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">让我们添加撤销和重做按钮，并为它们添加工具提示。</p><p id="c5b0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注意:如果没有要撤消/重做的操作，则应禁用它们。</p><p id="da0d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">目前，我们只使用meta reducer，没有办法跟踪我们必须撤销/重做的操作。但是我们已经实现了撤销/重做操作，所以让我们重用它们并定义状态:</p><pre class="mo mp mq mr gt mx my mz na aw nb bi"><span id="173c" class="nc kw it my b gy nd ne l nf ng">export interface UndoredoState {<br/>  undoActions: string[];<br/>  redoActions: string[];<br/>}</span></pre><p id="2b6b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们将只在这里存储工具提示。如果数组中没有元素，我们就不能撤销/重做。</p><p id="565c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们为撤销-重做编写一个缩减器:</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="be2d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在添加动作时，我们只需更新撤销动作并清除重做动作。</p><p id="7a41" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在重做动作时，我们更新撤销动作并取消第一个项目。</p><p id="0b25" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在撤销动作时，我们更新重做动作并弹出最后一项。</p><p id="b1dd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们添加一个选择器来提取撤销/重做操作:</p><pre class="mo mp mq mr gt mx my mz na aw nb bi"><span id="cf53" class="nc kw it my b gy nd ne l nf ng">import {UndoredoState} from './undo-redo-state';<br/>import {createSelector} from '@ngrx/store';<br/><br/>const selectUndoredoState = (state: any) =&gt; state.undoredo;<br/><br/>export const getUndoAction = createSelector(<br/>  selectUndoredoState,<br/>  (state: UndoredoState) =&gt; state.undoActions.length &gt; 0<br/>    &amp;&amp; state.undoActions[state.undoActions.length - 1]<br/>);<br/>export const getRedoAction = createSelector(<br/>  selectUndoredoState,<br/>  (state: UndoredoState) =&gt; state.redoActions.length &gt; 0<br/>    &amp;&amp; state.redoActions[0]<br/>);</span></pre><p id="3169" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最后，我们需要在撤销-重做模块中注册一个缩减器:</p><pre class="mo mp mq mr gt mx my mz na aw nb bi"><span id="561e" class="nc kw it my b gy nd ne l nf ng">StoreModule.<em class="nj">forFeature</em>('undoredo', undoredoReducer)</span></pre><p id="c3ce" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">并在app.module中导入此模块</p><pre class="mo mp mq mr gt mx my mz na aw nb bi"><span id="4c33" class="nc kw it my b gy nd ne l nf ng">imports: [<br/>//...<br/>  UndoRedoModule<br/>],</span></pre><p id="33a3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，我们可以轻松地添加撤销/恢复按钮:</p><pre class="mo mp mq mr gt mx my mz na aw nb bi"><span id="2ff3" class="nc kw it my b gy nd ne l nf ng">&lt;mat-icon class="icon" [class.disabled]="!undoItem" [matTooltip]="undoItem" matRipple (click)="undo()" matRippleUnbounded="unbounded"&gt;<br/>  undo<br/>&lt;/mat-icon&gt;<br/>&lt;mat-icon class="icon"  [class.disabled]="!redoItem" [matTooltip]="redoItem" matRipple (click)="redo()" matRippleUnbounded="unbounded"&gt;<br/>  redo<br/>&lt;/mat-icon&gt;</span></pre><p id="ae14" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了提取undoItem和redoItem，我们将使用选择器:</p><pre class="mo mp mq mr gt mx my mz na aw nb bi"><span id="bd59" class="nc kw it my b gy nd ne l nf ng">this.store.pipe(select(getUndoAction), takeUntil(this.unsubscribe$)).subscribe(undoItem =&gt; {<br/>  this.undoItem = undoItem;<br/>});<br/>this.store.pipe(select(getRedoAction), takeUntil(this.unsubscribe$)).subscribe(redoItem =&gt; {<br/>  this.redoItem = redoItem;<br/>});</span></pre><p id="d956" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">那就是。您可以使用按钮来撤销/重做，如果您将鼠标悬停在按钮上，您可以看到带有相应信息的工具提示。</p><h1 id="34e1" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">最后</h1><p id="040b" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">感谢您阅读这篇文章。我希望它是有用的。不要犹豫，提出问题，留下评论。</p><p id="52d9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">储存库与最终版本:<a class="ae ly" href="https://github.com/Stioneq/todo-undo-redo" rel="noopener ugc nofollow" target="_blank">链接</a></p><p id="5db0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><a class="ae ly" href="https://stioneq.github.io/todo-undo-redo" rel="noopener ugc nofollow" target="_blank"> Github页面</a></p><p id="275c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">顺便说一句</strong>:在评论中留下我们如何增加对设置动作类型的撤销支持。<em class="nj">改变_主题？</em></p></div></div>    
</body>
</html>