<html>
<head>
<title>Renovate, a Dependabot alternative</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">翻新，一个可靠的选择</h1>
<blockquote>原文：<a href="https://itnext.io/renovate-alternative-dependabot-c4c80e6d488d?source=collection_archive---------3-----------------------#2022-08-24">https://itnext.io/renovate-alternative-dependabot-c4c80e6d488d?source=collection_archive---------3-----------------------#2022-08-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/38b11c1206352e58724c68367c9993fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4S8_p6VoM4LpsEt_j8JBXw.jpeg"/></div></div></figure><p id="aa71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我就不介绍<a class="ae kw" href="https://github.com/dependabot" rel="noopener ugc nofollow" target="_blank">依赖机器人</a>了。很多很多开发者每天都在GitHub上使用它。我也用它。然而，它有两个缺点:</p><ul class=""><li id="1c9d" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">虽然它与GitHub完美集成，但与其他平台的集成却不那么无缝。</li><li id="0493" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">它被限制在它支持的<a class="ae kw" href="https://docs.github.com/en/code-security/dependabot/dependabot-version-updates/configuration-options-for-the-dependabot.yml-file#package-ecosystem" rel="noopener ugc nofollow" target="_blank">生态系统</a>的列表中，例如，我通常使用Docker Compose文件来制作我的演示。必要的时候，我用Kubernetes。Dependabot不支持任何功能。更糟糕的是，dependent bot<a class="ae kw" href="https://github.com/dependabot/dependabot-core/blob/main/CONTRIBUTING.md#contributing-new-ecosystems" rel="noopener ugc nofollow" target="_blank">不接受添加新生态系统的贡献</a>。</li></ul><p id="3bb8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近，我看了Viktor Farcic的<a class="ae kw" href="https://www.youtube.com/watch?v=l0YH557eIiE" rel="noopener ugc nofollow" target="_blank">用renew</a>自动化依赖管理。发现<a class="ae kw" href="https://www.mend.io/free-developer-tools/renovate/" rel="noopener ugc nofollow" target="_blank">翻新</a>超级整洁，想过用用，又……忘了。后来我偶然发现了另一个关于它的说法。这促使我在两个地方实施它:</p><ul class=""><li id="fba7" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">在我的博客上</li><li id="b249" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">关于使用Docker Compose的演示</li></ul><h1 id="489b" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">保持我的博客更新</h1><p id="b012" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">我已经写了很多次关于我的博客的基础设施。在本文中，相关部分包括:</p><ul class=""><li id="637b" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">它是根据哲基尔改编的。Jekyll是一个基于Ruby的静态站点生成器。为了管理Ruby gems的依赖关系，我使用了<a class="ae kw" href="https://bundler.io/" rel="noopener ugc nofollow" target="_blank"> bundler </a>。</li><li id="4e28" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">GitLab上的每次推送都是我生成的网站。我通过标准的<code class="fe mo mp mq mr b">.gitlab-ci.yml</code>文件配置了构建。</li><li id="35e8" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">最后，为了避免在每次构建时都构建整个基础设施，我依赖Dockerfile文件。它提供了JRuby基础映像和一些必需的二进制文件，<em class="ms">，例如</em>、<code class="fe mo mp mq mr b">graphviz</code>。GitLab构建从这个映像开始。</li></ul><p id="8723" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">翻新提供<a class="ae kw" href="https://gitlab.com/renovate-bot/renovate-runner/" rel="noopener ugc nofollow" target="_blank">指令</a>为GitLab安装产品。因为我必须了解如何翻新工程和如何安装它，我不得不咨询了相当多的网站。</p><p id="858f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里总结一下我的理解:</p><ul class=""><li id="5a42" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">您需要在GitLab上创建一个专门的项目来运行renew</li><li id="2389" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">GitLab调度程序应每周或每天触发它，<em class="ms">，例如</em></li><li id="6bf8" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">翻新有两种配置类型:一种适用于转轮本身<em class="ms">和</em>一种适用于项目。如果您在转轮上设置了参数，它们将应用于“翻新”运行的每个项目。该文档建议每个项目都应该获得其特定的配置。请注意，Renovate提供了一种跨不同项目分解配置的机制。</li></ul><p id="1981" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我得到了下面的翻新流道配置:</p><pre class="mt mu mv mw gt mx mr my mz aw na bi"><span id="d7da" class="nb lm iq mr b gy nc nd l ne nf">variables:<br/>  RENOVATE_GIT_AUTHOR: Renovate Bot &lt;bot@renovate.com&gt;<br/>  RENOVATE_REQUIRE_CONFIG: optional</span><span id="2ce3" class="nb lm iq mr b gy ng nd l ne nf">include:<br/>    - project: 'renovate-bot/renovate-runner'<br/>      file: '/templates/renovate-dind.gitlab-ci.yml'              #1</span></pre><ol class=""><li id="0121" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv nh ld le lf bi translated"><a class="ae kw" href="https://gitlab.com/renovate-bot/renovate-runner/-/blob/main/templates/renovate-dind.gitlab-ci.yml" rel="noopener ugc nofollow" target="_blank">模板</a>提供了一组可靠的默认值，<em class="ms">例如</em>，环境变量:平台是GitLab，日志级别是info等。</li></ol><p id="d1f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认情况下，翻新“嗅探”项目使用的包管理器。在我的博客上，它也检查HTML文件。为了缩小范围，我只配置了必要的包管理器:</p><pre class="mt mu mv mw gt mx mr my mz aw na bi"><span id="ffc7" class="nb lm iq mr b gy nc nd l ne nf">{<br/>  "enabledManagers": ["gitlabci", "dockerfile", "bundler"]<br/>}</span></pre><p id="5b88" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它只允许管理GitLab CI、Docker和Bundler的依赖关系。</p><p id="d401" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能想把<code class="fe mo mp mq mr b">LOG_LEVEL</code>环境变量设置为<code class="fe mo mp mq mr b">debug</code>，尤其是在开始的时候；这对<em class="ms">帮助极大</em>。例如，我最初的几次跑步因为一个神秘的信息<code class="fe mo mp mq mr b">Repository is disabled - skipping</code>而停止。通过调试级别的日志记录，我可以理解为什么:<code class="fe mo mp mq mr b">DEBUG: MRs are disabled for the project - throwing error to abort renovation</code>。</p><p id="2516" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步是达到预期的结果。在我的例子中，Renovator没有打开任何合并请求。</p><ul class=""><li id="9861" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">GitLab CI: <br/>构建文件用<code class="fe mo mp mq mr b">latest</code>提到了我的图像，用<code class="fe mo mp mq mr b">debug</code>提到了Kaniko图像。没有一个是语义上的，None不能提供任何建议。虽然我不在乎前者，但我在乎后者。给未来的自己一个提示:我需要修复它。</li><li id="4a2b" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">docker:<br/><code class="fe mo mp mq mr b">Dockerfile</code>使用<code class="fe mo mp mq mr b">jruby:9.3-jre11</code>作为父图像。虽然不是语义版本，但是seen可以提取出正确的语义版本(如日志中所见:<code class="fe mo mp mq mr b">"currentVersion": "9.3",</code>)。然而，没有更新的版本和正确翻新做不了什么。</li><li id="0979" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">Gems: <br/>我使用的是Bundler，依赖关系被固定在一个<code class="fe mo mp mq mr b">Gemfile.lock</code>文件中。默认情况下，renew不建议任何升级。</li></ul><p id="71a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于GitLab和Docker，人们可以预期结果:没有语义版本化，也没有更高的版本。对于宝石，我有点不解。原因在于<a class="ae kw" href="https://docs.renovatebot.com/configuration-options/#rangestrategy" rel="noopener ugc nofollow" target="_blank">renew如何处理更新</a>。</p><p id="9ba1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认策略是<code class="fe mo mp mq mr b">replace</code>:</p><blockquote class="ni nj nk"><p id="130d" class="jy jz ms ka b kb kc kd ke kf kg kh ki nl kk kl km nm ko kp kq nn ks kt ku kv ij bi translated"><em class="iq">如果新版本不在该范围内，则用新版本替换该范围，否则不更新任何内容</em></p></blockquote><p id="4fe8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个策略是<code class="fe mo mp mq mr b">update-lockfile</code>:</p><blockquote class="ni nj nk"><p id="8a24" class="jy jz ms ka b kb kc kd ke kf kg kh ki nl kk kl km nm ko kp kq nn ks kt ku kv ij bi translated"><em class="iq">当范围内更新可用时，更新锁文件，否则，对于范围外的更新，替换锁文件。作品为</em><code class="fe mo mp mq mr b"><em class="iq">bundler</em></code><em class="iq"/><code class="fe mo mp mq mr b"><em class="iq">composer</em></code><em class="iq"/><code class="fe mo mp mq mr b"><em class="iq">npm</em></code><em class="iq"/><code class="fe mo mp mq mr b"><em class="iq">yarn</em></code><em class="iq"/><code class="fe mo mp mq mr b"><em class="iq">terraform</em></code><em class="iq">和</em> <code class="fe mo mp mq mr b"><em class="iq">poetry</em></code> <em class="iq">至今。</em></p></blockquote><p id="2d93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好像合理多了。我更新了Jekyll的配置文件:</p><pre class="mt mu mv mw gt mx mr my mz aw na bi"><span id="9b4a" class="nb lm iq mr b gy nc nd l ne nf">{<br/>  "enabledManagers": ["gitlabci", "dockerfile", "bundler"],<br/>  "packageRules": [<br/>    {<br/>      "matchManagers": ["bundler"],                           #2<br/>      "rangeStrategy": "update-lockfile"                      #1<br/>    }<br/>  ]<br/>}</span></pre><ol class=""><li id="fa7b" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv nh ld le lf bi translated">更新要应用的范围策略</li><li id="9200" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv nh ld le lf bi translated">仅对Bundler —对GitLab或Docker没有任何意义</li></ol><p id="b20d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我重新运行了更新工作，这次我已经准备好了合并请求！Renovate正确地识别了需要更新的依赖项，对它们进行了升级，并创建了MR。</p><pre class="mt mu mv mw gt mx mr my mz aw na bi"><span id="88f4" class="nb lm iq mr b gy nc nd l ne nf"> 4 |  4 |   | addressable (2.8.0)<br/> 5 |  5 |   |   public_suffix (&gt;= 2.0.2, &lt; 5.0)<br/> 6 |  6 |   | asciidoctor (2.0.17)<br/> 7 |  7 | - | asciidoctor-diagram (2.2.1)<br/>   |  8 | + | asciidoctor-diagram (2.2.3)<br/> 8 |  9 |   |   asciidoctor (&gt;= 1.5.7, &lt; 3.x)<br/> 9 | 10 |   |   asciidoctor-diagram-ditaamini (~&gt; 1.0)<br/>10 | 11 |   |   asciidoctor-diagram-plantuml (~&gt; 1.2021)<br/>11 |    |   |   rexml<br/>12 |    | - | asciidoctor-diagram-ditaamini (1.0.1)<br/>13 |    | - | asciidoctor-diagram-plantuml (1.2022.1)<br/>   | 12 | + | asciidoctor-diagram-ditaamini (1.0.3)<br/>   | 13 | + | asciidoctor-diagram-plantuml (1.2022.5)<br/>14 | 14 |   |   colorator (1.1.0)<br/>15 | 15 |   |   concurrent-ruby (1.1.10)<br/>16 | 16 |   |   cssminify2 (2.0.1)</span></pre><p id="4e40" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个日志片段展示了这种魔力:</p><pre class="mt mu mv mw gt mx mr my mz aw na bi"><span id="3ef1" class="nb lm iq mr b gy nc nd l ne nf">{<br/>  "depName": "asciidoctor-diagram",<br/>  "managerData": {"lineNumber": 10},<br/>  "datasource": "rubygems",<br/>  "depTypes": ["jekyll_plugins"],<br/>  "lockedVersion": "2.2.1",<br/>  "depIndex": 7,<br/>  "updates": [<br/>    {<br/>      "bucket": "non-major",<br/>      "newVersion": "2.2.3",<br/>      "newMajor": 2,<br/>      "newMinor": 2,<br/>      "updateType": "patch",<br/>      "isRange": true,<br/>      "isLockfileUpdate": true,<br/>      "branchName": "renovate/asciidoctor-diagram-2.x-lockfile"<br/>    }<br/>  ],<br/>  "warnings": [],<br/>  "versioning": "ruby",<br/>  "currentVersion": "2.2.1",<br/>  "isSingleVersion": true,<br/>  "fixedVersion": "2.2.1"<br/>}</span></pre><h1 id="3f9d" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">保持演示最新</h1><p id="649e" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">虽然我把我的博客放在GitLab的一个私人存储库上，但我所有的演示都是在GitHub上的公共存储库。正如我提到的，Dependabot在GitHub上的集成非常出色。然而，它遗漏了一些我经常使用的包管理器，Docker编写文件和Kubernetes清单。翻新救援！</p><p id="33cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对你的仓库进行改造是轻而易举的事。只需浏览<a class="ae kw" href="https://github.com/apps/renovate" rel="noopener ugc nofollow" target="_blank"> GitHub翻新app </a>，点击右上角的大格力<strong class="ka ir">安装</strong>按钮。选择您要安装renewal的组织和存储库。</p><p id="1f86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">renew将在每个匹配的存储库中打开一个<a class="ae kw" href="https://github.com/nfrankel/opentelemetry-tracing/pull/1" rel="noopener ugc nofollow" target="_blank"> Pull请求</a>。PR包含一个文件，即<code class="fe mo mp mq mr b">renovate.json</code>配置文件。可以根据需要更新:<a class="ae kw" href="https://docs.renovatebot.com/configuration-options/" rel="noopener ugc nofollow" target="_blank">配置选项</a>很多！</p><p id="c43b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从那时起，Renovate将监控已配置的存储库并发送PRs，<em class="ms">，例如</em>，在:</p><ul class=""><li id="005c" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><code class="fe mo mp mq mr b"><a class="ae kw" href="https://github.com/nfrankel/opentelemetry-tracing/pull/5/files" rel="noopener ugc nofollow" target="_blank">Dockerfile</a></code></li><li id="61fe" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><code class="fe mo mp mq mr b"><a class="ae kw" href="https://github.com/nfrankel/opentelemetry-tracing/pull/2" rel="noopener ugc nofollow" target="_blank">docker-compose.yml</a></code></li></ul><p id="fdb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更好的是，renew Bot限制pr的数量，以遵守<a class="ae kw" href="https://docs.github.com/en/rest/overview/resources-in-the-rest-api#rate-limiting" rel="noopener ugc nofollow" target="_blank"> GitHub速率限制</a>。为了方便起见，它发送了一个名为“依赖仪表板”的<a class="ae kw" href="https://github.com/nfrankel/opentelemetry-tracing/issues/4" rel="noopener ugc nofollow" target="_blank">专用问题</a>，在那里你可以看到<em class="ms">所有</em>可用的依赖更新。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/4f342446d4c4dbe36c710b09333ec95a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mvuibrLzn66qtc3BjuPoBQ.jpeg"/></div></div></figure><p id="b19e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如何与仪表板交互是不言自明的。只需选中相关的复选框，它会打开一个关于依赖关系的PR。如果低于速率限制，翻新也将打开PRs。</p><h1 id="dcc3" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="6da7" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">翻新是一个伟大的工具。它可以在GitHub上无缝运行；在GitLab上，你需要一个专门的跑步者。</p><p id="80c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与Dependabot相比，我更喜欢Renovate更新Docker、Docker Compose和Kubernetes文件的能力。我从现在开始使用它。</p><p id="4e64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更进一步:</strong></p><ul class=""><li id="d4c7" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><a class="ae kw" href="https://docs.renovatebot.com/" rel="noopener ugc nofollow" target="_blank">更新文档</a></li><li id="86e5" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><a class="ae kw" href="https://docs.renovatebot.com/modules/manager/" rel="noopener ugc nofollow" target="_blank">改造管理者</a></li><li id="572d" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><a class="ae kw" href="https://gitlab.com/renovate-bot/renovate-runner" rel="noopener ugc nofollow" target="_blank"> GitLab翻新转轮</a></li></ul></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="b504" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ms">原载于</em> <a class="ae kw" href="https://blog.frankel.ch/renovate-alternative-dependabot/" rel="noopener ugc nofollow" target="_blank"> <em class="ms">一个Java极客</em></a><em class="ms">2022年8月21日</em></p></div></div>    
</body>
</html>