<html>
<head>
<title>Secrets management in Azure for Kubernetes with App Configuration, Key Vault and Managed Identity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用应用程序配置、密钥库和托管身份在Azure中为Kubernetes进行秘密管理</h1>
<blockquote>原文：<a href="https://itnext.io/secrets-management-in-azure-for-kubernetes-with-app-configuration-key-vault-and-managed-identity-261cee3eb490?source=collection_archive---------1-----------------------#2020-04-28">https://itnext.io/secrets-management-in-azure-for-kubernetes-with-app-configuration-key-vault-and-managed-identity-261cee3eb490?source=collection_archive---------1-----------------------#2020-04-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/583e8f40cec0e530a95b720489862327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ib1x6mZK7cozNvwRF7vsFw.png"/></div></div></figure><p id="6307" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在构建云应用程序时，一个常见的挑战是如何管理您的代码中的凭据、连接字符串和其他秘密，以便向云服务进行身份验证？这一直是一个相当大的挑战，有这么多不同的策略如何保持您的凭证安全。理想情况下，秘密永远不会被签入源代码控制，也不会出现在开发人员的机器上。几年前，Azure Key Vault推出，似乎是一个非常好的解决方案，除了…我们仍然需要对Key Vault进行身份验证，并考虑在哪里存储这些凭据。</p><p id="6c7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Azure资源的托管身份、应用配置服务和密钥库的组合为我们解决了这个问题。<a class="ae kw" href="https://docs.microsoft.com/en-us/azure/azure-app-configuration/overview" rel="noopener ugc nofollow" target="_blank"> Azure App Configuration </a>是一项令人惊叹的服务，它允许您集中管理应用程序设置和功能标志，它与<a class="ae kw" href="https://docs.microsoft.com/en-us/azure/key-vault/general/overview" rel="noopener ugc nofollow" target="_blank"> Azure Key Vault </a>完全兼容，是分布式环境的完美解决方案，我们现在在每个角落都有。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/f5258cadc5d3991ae8cede0b2ce717b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*kSyozsZk-VvX-2IaaiF-ZQ.png"/></div></figure><p id="f0b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然任何应用程序都可以使用这种组合，但以下示例是以最明显的方式受益于它的应用程序类型:</p><ul class=""><li id="3112" class="lc ld iq ka b kb kc kf kg kj le kn lf kr lg kv lh li lj lk bi translated">在Azure Kubernetes Service、Azure Service Fabric或其他部署在不同地区的容器化应用上托管的微服务</li><li id="c320" class="lc ld iq ka b kb ll kf lm kj ln kn lo kr lp kv lh li lj lk bi translated">无服务器应用</li><li id="80e8" class="lc ld iq ka b kb ll kf lm kj ln kn lo kr lp kv lh li lj lk bi translated">持续部署管道</li></ul><p id="0902" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但最美妙的部分是，我们在代码中需要的只是一个托管身份Id，仅此而已。Azure将自动向必要的资源验证我们的应用程序，并获取所有必要的配置/机密。</p><p id="5722" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们动手做一些编码工作。对于这个例子，我们将创建Azure Kubernetes集群，在那里我们将托管我们的容器化ASP.NET核心应用程序，该应用程序将从Azure应用程序配置服务和Azure密钥库提取所有设置和秘密。我们将Kubernetes的网络和所有安全基础设施排除在本文范围之外。</p><p id="8ca8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview#how-does-the-managed-identities-for-azure-resources-work" rel="noopener ugc nofollow" target="_blank">有两种类型</a>的托管身份:<strong class="ka ir">系统分配的托管身份</strong>和<strong class="ka ir">用户分配的托管身份</strong>。让我们为本文选择用户分配的身份，以使事情更加明显和可追溯。这些资源中的大部分都可以通过Azure portal和Azure cli创建。</p><p id="bed4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们安装了Azure cli，让我们登录Azure，切换到我们的订阅，然后继续。首先，我们为演示创建资源组，并在其中管理身份。</p><pre class="ky kz la lb gt lq lr ls lt aw lu bi"><span id="be5b" class="lv lw iq lr b gy lx ly l lz ma">az group create -l westeurope -n "managedidentitydemo"<br/>az identity create -g "managedidentitydemogroup" -n "managedidentitydemo"</span></pre><p id="637e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在执行<code class="fe mb mc md lr b">az identity create</code>之后，我们将得到一个json输出，它描述了创建的身份，看起来像这样:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">az身份创建输出</figcaption></figure><p id="a628" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">保存好<code class="fe mb mc md lr b">clientId</code>、<code class="fe mb mc md lr b">id</code>和<code class="fe mb mc md lr b">principalId</code>，我们以后会用到它们。</p><p id="9dc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们需要Azure应用配置服务，我们将在那里存储我们的非秘密设置和我们对Azure Key Vault的引用，我们将在那里保存我们的秘密。</p><p id="22d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们需要Azure应用配置服务，我们将在那里存储我们的非秘密设置和我们对Azure Key Vault的引用，我们将在那里保存我们的秘密。</p><pre class="ky kz la lb gt lq lr ls lt aw lu bi"><span id="5024" class="lv lw iq lr b gy lx ly l lz ma">az appconfig create --name "managedidentitydemoconfig" --location westeurope --resource-group "managedidentitydemogroup" --query hostName --sku free -o tsv</span><span id="e66d" class="lv lw iq lr b gy mk ly l lz ma">az keyvault create --location westeurope --name managedIdentityDemoVault --resource-group managedidentitydemogroup</span></pre><p id="9ce5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建资源后，我们必须在那里添加一些设置和秘密——为此我将使用Azure portal。我们进入我们的密钥库-&gt;秘密-&gt;生成/导入并创建我们的秘密。我创建了两个秘密:ApiConnectionSettingsSecret和ApiConnectionSettingsKey。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/0ecc911990ff18bca713d31b8cea7acc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j9pb6yZyUHm2RL1-2OH4Ig.png"/></div></div></figure><p id="7c09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们转到我们的应用程序配置服务，并在那里创建一些设置和密钥库引用。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/6200cf4526f951bf055345c4ddd8e359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YsxmMBzLR8xopk-_jRru3g.png"/></div></div></figure><p id="b612" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，我们添加了两个非秘密设置和两个对Azure key vault的引用。我们还用ManagedDemoServiceApi标签对它们进行了标记。当您有多个微服务使用一个应用服务配置时，标记非常有用，因为这样您就可以仅获取属于您的微服务并由特定标签标记的设置。让我们创建密钥库策略，允许每个使用我们身份的应用程序获取和列出机密。</p><pre class="ky kz la lb gt lq lr ls lt aw lu bi"><span id="e0fe" class="lv lw iq lr b gy lx ly l lz ma">az keyvault set-policy -n managedIdentityDemoVault --spn &lt;managed-identity-clientId&gt; --secret-permissions get list</span></pre><p id="9030" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还希望将用户分配的身份添加到我们的应用配置服务中。当应用程序配置服务将从密钥库中提取密钥时，它将使用该身份，并将拥有<code class="fe mb mc md lr b">get</code>和<code class="fe mb mc md lr b">list</code>权限来检索密钥。我们还必须为我们的托管身份添加访问角色“应用程序配置数据读取器”，以便能够读取配置设置。</p><pre class="ky kz la lb gt lq lr ls lt aw lu bi"><span id="0840" class="lv lw iq lr b gy lx ly l lz ma">az appconfig identity assign -g managedidentitydemogroup -n managedidentitydemoconfig --identities "&lt;managed-identity-id&gt;"</span><span id="f1be" class="lv lw iq lr b gy mk ly l lz ma">az role assignment create --assignee-object-id &lt;managed-identity-principalId&gt; --role "App Configuration Data Reader"</span></pre><p id="3cd6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们创建我们的Azure Kubernetes集群。如果你还没有Azure container registry的话，我们还会附上我的订阅中已经有的Azure container registry通过门户创建一个不成问题。最后，我们需要将托管身份分配给集群的虚拟机扩展集。这很重要，因为我们所有的授权请求都将来自这些虚拟机。</p><pre class="ky kz la lb gt lq lr ls lt aw lu bi"><span id="8d83" class="lv lw iq lr b gy lx ly l lz ma">az aks create -n managedidentitycluster -g managedidentitydemogroup --generate-ssh-keys --attach-acr crgmanaged </span><span id="bcca" class="lv lw iq lr b gy mk ly l lz ma">az vmss identity assign -g &lt;virtual-machines-scale-set-resource-group&gt; -n &lt;vmss-name&gt; --identities &lt;your-managed-identity-id&gt;</span></pre><blockquote class="mn mo mp"><p id="f1f4" class="jy jz mq ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated">请注意，虚拟机扩展集是在自己的资源组中创建的，具有某种随机名称。你可以通过Azure portal轻松找到所有这些。</p></blockquote><p id="125e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">集群准备就绪后，我们需要获取其凭据并切换活动上下文。kube/config文件，这样我们就可以使用我们的AKS集群。</p><pre class="ky kz la lb gt lq lr ls lt aw lu bi"><span id="d56a" class="lv lw iq lr b gy lx ly l lz ma">az aks Get-Credentials --resource-group managedidentitydemogroup --name managedidentitycluster</span></pre><p id="de00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是了——我们准备好了！为了测试我们的设置，我准备了一个简单的。NET核心应用程序，它只是从Azure应用程序配置中获取配置设置并显示它们。在你的应用中添加和使用Azure App Config和托管身份非常简单——你只需要添加掘金包，然后在Program.cs文件中包含一小段代码，之后CreateHostBuilder()方法将类似于下面的代码:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><blockquote class="mn mo mp"><p id="aa02" class="jy jz mq ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated">我真的很喜欢它可以通过标签拉设置，这是超级整洁。<code class="fe mb mc md lr b">.Select(KeyFilter.Any, “ManagedDemoServiceApi”)</code></p></blockquote><p id="7c03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试应用程序和Kubernetes部署。yaml可以在我的<a class="ae kw" href="https://github.com/f1xxxer/managedIdentity" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中获得。因此，当我们部署或应用到集群和触发器/配置端点时，我们会看到来自应用配置服务和Azure Key Vault的值。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/e603fb53ef561cbea70dc85c8321d240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q2v2-5njxjC5_QIZ_2hkLg.png"/></div></div></figure><p id="0e95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们实际上需要在appsettings.json中保留的唯一设置是Azure应用配置服务的url和托管身份Id。是不是很酷？</p><h2 id="8adb" class="lv lw iq bd mv mw mx dn my mz na dp nb kj nc nd ne kn nf ng nh kr ni nj nk nl bi translated">但是这种用户分配的托管身份是如何工作的呢？</h2><p id="e196" class="pw-post-body-paragraph jy jz iq ka b kb nm kd ke kf nn kh ki kj no kl km kn np kp kq kr nq kt ku kv ij bi translated">基本上，我们的管理者身份是Azure服务主体的包装器，它是在订阅信任的Azure AD租户中创建的。当我们将托管身份分配给Azure资源时，我们也分配了授予该身份的所有权限和角色。在此Azure资源上运行的代码可以从Azure实例元数据服务身份端点<code class="fe mb mc md lr b"><a class="ae kw" href="http://169.254.169.254/metadata/identity/oauth2/token" rel="noopener ugc nofollow" target="_blank">http://169.254.169.254/metadata/identity/oauth2/token</a></code>请求身份验证令牌，该身份端点只能从Azure内部访问。收到令牌后，它将用于调用支持Azure AD身份验证的服务。</p><h2 id="4750" class="lv lw iq bd mv mw mx dn my mz na dp nb kj nc nd ne kn nf ng nh kr ni nj nk nl bi translated">如果我想自动管理用户分配给我的身份，该怎么办？</h2><p id="d2ad" class="pw-post-body-paragraph jy jz iq ka b kb nm kd ke kf nn kh ki kj no kl km kn np kp kq kr nq kt ku kv ij bi translated">这是一个非常好的问题，尤其是对于托管30+或50+或100+微服务的环境。在如此大的基础设施中，保持分配的身份列表总是最新的，即使不是不可能，也是非常困难的。幸运的是，有针对Kubernetes应用程序的<a class="ae kw" href="https://github.com/Azure/aad-pod-identity" rel="noopener ugc nofollow" target="_blank"> Azure Active Directory标识</a> —这是一个开源项目，允许我们在检测到pod发生变化时，为底层虚拟机/VMSS分配/移除一个标识。具体来说，当计划或删除pod时。当<code class="fe mb mc md lr b">AzureIdentity</code>或<code class="fe mb mc md lr b">AzureIdentityBinding</code>被创建或删除时，采取类似的动作。请看看并做一些实验——这很方便。</p><p id="bdcc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> GL &amp; HF。</strong></p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/5fec56fd9d2cfb380fbd8b893a21c023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*wrh3rrPG5L5DsKUepccAvA.png"/></div></figure></div></div>    
</body>
</html>