<html>
<head>
<title>Rewriting Vuex module to Composition API.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Vuex模块重写为组合API。</h1>
<blockquote>原文：<a href="https://itnext.io/rewriting-vuex-module-to-composition-api-7ccb1cd09738?source=collection_archive---------0-----------------------#2021-01-14">https://itnext.io/rewriting-vuex-module-to-composition-api-7ccb1cd09738?source=collection_archive---------0-----------------------#2021-01-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/13fcddb05703537a0b492108ebb10c0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lWG2qw_nDUdyhErakF9h0A.jpeg"/></div></div></figure><p id="d0cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你好。在这篇文章中，我将向你展示如何将一些Vuex模块重写到Vue组合API中。这可能是一个很好的例子，说明如何用这个来自Vue 3版本的新的强大工具替换旧的、好的Vue状态管理系统。</p><p id="2b20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个模块来自一个简单的笔记本应用程序，是我为不久前举办的一些研讨会制作的。这里可以找到<a class="ae kw" href="https://github.com/lukasborawski/notebook" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="04fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么这个模块是做什么的呢？简而言之，它聚合、保存和删除笔记。我们简单看一下。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="f5ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好的，对于一些上下文，我们这里有Typescript和一些类型，你可以在下面找到。在app中，还有一个<code class="fe ld le lf lg b">$localForage</code> Nuxt模块，在本地存储数据。在这里检查一下<a class="ae kw" href="https://github.com/nuxt-community/localforage-module" rel="noopener ugc nofollow" target="_blank">。出于本文存储数据的目的，逻辑将被删除。</a></p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="373e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们来看一下本模块。当然，从顶部开始，我们有一个包含notes数组的状态。突变保持注释保存到状态功能中。然后，我们有添加、删除和读取存储笔记的操作。一个getter在最后接收当前注释。</p><p id="6ee0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，该动手了。</p><p id="c443" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Composition API允许的最主要和最重要的事情之一是将我们的公共业务逻辑分割并移动到称为composables的独立块(文件)中。然后在整个app中重用它们。</p><p id="e9df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们现在可以创建一个。将它作为一个<code class="fe ld le lf lg b">useNotes.ts</code>文件放到新文件夹<code class="fe ld le lf lg b">~/composables</code>中——我们使用的是Nuxt结构。首先复制将要使用的类型，就像使用Vuex模块一样。</p><p id="f9e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一开始，我们必须重建国家。为此，我们将使用Composition API提供的一个名为<code class="fe ld le lf lg b">reactive</code>的新工具。</p><blockquote class="lh li lj"><p id="afa9" class="jy jz lk ka b kb kc kd ke kf kg kh ki ll kk kl km lm ko kp kq ln ks kt ku kv ij bi translated"><code class="fe ld le lf lg b">reactive</code>相当于当前2.x中的<code class="fe ld le lf lg b">Vue.observable()</code> API，重命名是为了避免与RxJS observables混淆。这里，返回的状态是一个所有Vue用户都应该熟悉的反应性对象。Vue中反应状态的基本用例是我们可以在渲染过程中使用它。由于依赖关系跟踪，视图会在反应状态改变时自动更新。</p></blockquote><p id="02a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">提示</strong>:在这里也检查<code class="fe ld le lf lg b">ref</code>物体<a class="ae kw" href="https://composition-api.vuejs.org/api.html#ref" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="797a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代码:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="9f11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">值得注意的一点是，我们需要在主可组合函数之外定义我们的反应状态对象。我们需要完全的反应能力，并从其他组件获取这些数据。但是我们不需要导出它。</p><p id="5094" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的组合时间到了。</p><p id="84a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在同一个文件中，我们将定义以下代码:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="cfed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们深入研究一下。这里我们有一个简单的函数，它从先前定义的状态返回注释，以及保存、删除和获取注释的处理程序/操作。实际上，它们看起来和Vuex模块一模一样。注释是现在计算的值，它是从Composition API传递的，它相当于来自Vue Options API的众所周知的<code class="fe ld le lf lg b">computed</code>。</p><p id="19a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成了。我们去掉了所有Vuex模块的复杂性——没有突变，没有动作，没有getters。我们所需要的是一个功能组合，可以在应用程序中的任何地方重用。</p><p id="3372" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，我们还提供了一些退货类型。至于笔记处理函数非常简单，我们现在使用的是<code class="fe ld le lf lg b">ComputedRef</code>的通用类型。从Vue的第3版开始，我们可以开箱即用了——太棒了。</p><p id="f5af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以将它与真正的组件一起使用。在我们的例子中，它将是一个<code class="fe ld le lf lg b">index</code>页面。来自<code class="fe ld le lf lg b">useNotes</code> composable的数据将被传递，作为prop传播到子组件——关于通过props和Composition API链接数据的更多内容，敬请关注。</p><p id="8362" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ld le lf lg b">index.vue</code>页面代码:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="b2b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Vue 3中，我们用<code class="fe ld le lf lg b">setup</code> <a class="ae kw" href="https://composition-api.vuejs.org/api.html#setup" rel="noopener ugc nofollow" target="_blank">函数</a>得到了这个新的可选语法。它允许我们将所有组件逻辑组合在一个地方，按逻辑块排序。最理想的情况是，您将整个业务代码放在组件之外，只需使用<code class="fe ld le lf lg b">setup</code>函数调用它。和我们的<code class="fe ld le lf lg b">index</code>页面示例一样，我们已经导入了<code class="fe ld le lf lg b">useNotes</code>可组合块来收集笔记。</p><p id="54cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里你可能会注意到的一个新东西是这个新函数<code class="fe ld le lf lg b">onBeforeMount</code>。当然，这是一个钩子。有了组合API，有了新重新定义的<a class="ae kw" href="https://composition-api.vuejs.org/api.html#lifecycle-hooks" rel="noopener ugc nofollow" target="_blank">钩子</a>，我们可以使用<code class="fe ld le lf lg b">setup</code>函数。</p><p id="73d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">仅此而已。有争议？一点点？现在有了组合API，我们可以摆脱几乎所有的Vuex复杂性。从技术角度来看，它几乎是一样的，但是定义它和用它来行动的方式会不那么复杂。只是我们都知道的函数。我们不需要突变、动作和getters。更不用说我们根本不需要绘制它们的地图。现在只需要简单的导入就足够了，我们继续前进。Vuex模块的最大优势——逻辑分离——我们仍然可以使用Composition API。另一件事可能是速度和性能，但这需要一些基准来确认。试一试，你会很兴奋的。</p><p id="bf3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完整的代码可在<a class="ae kw" href="https://github.com/lukasborawski/notebook" rel="noopener ugc nofollow" target="_blank">这个</a> repo上用之前提到的一个简单的笔记本app获得。</p><p id="abea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">谢谢，请慢用。</p></div></div>    
</body>
</html>