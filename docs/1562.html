<html>
<head>
<title>Anatomy of Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">码头工人剖析</h1>
<blockquote>原文：<a href="https://itnext.io/getting-started-with-docker-1-b4dc83e64389?source=collection_archive---------0-----------------------#2018-11-24">https://itnext.io/getting-started-with-docker-1-b4dc83e64389?source=collection_archive---------0-----------------------#2018-11-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="459e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">码头集装箱化</h2><div class=""/><div class=""><h2 id="e97c" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">Docker是一个容器化引擎，它提供了极快的容器创建和管理。在本文中，我们将了解什么是容器以及它们是如何工作的。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/9e6e1259a38c5fd7afdd06a16f2cf3b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l_cdiDTJ9Z9GpUZyoRnQFw.png"/></div></div></figure><p id="f2d7" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在你了解Docker 到底是什么之前，我认为了解<strong class="lf jd">虚拟化</strong>和<strong class="lf jd">容器化</strong>之间的区别是非常重要的，因为Docker under-the-hood实现了这些技术中的一种，<strong class="lf jd"> <em class="lz">我们一会儿就会看到哪一种</em> </strong>。</p><p id="715d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当你想要创建一个<strong class="lf jd">虚拟环境</strong>来进行<strong class="lf jd"> <em class="lz">代码测试</em> </strong>时，你可以创建一个<strong class="lf jd">虚拟机</strong>。虚拟机只不过是模拟虚拟操作系统的程序；从<strong class="lf jd">主机</strong>借用一些资源如<em class="lz">内存</em>和<em class="lz">存储</em>。一个完美的例子就是使用<strong class="lf jd"> VirtualBox </strong>程序在<strong class="lf jd"> Windows </strong>平台上启动一个<strong class="lf jd"> Ubuntu </strong>虚拟机。那个Ubuntu虚拟机将在一个提供<strong class="lf jd"> Ubuntu桌面GUI </strong>的窗口内运行。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ma"><img src="../Images/a901c0ebaf8160d26a40c944be3a5a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bY-7K3Hf6vZWBvfL64beTw.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">(来源:<a class="ae mf" href="https://www.youtube.com/watch?v=QbmRXJJKsvs" rel="noopener ugc nofollow" target="_blank"> Youtube </a>)</figcaption></figure><p id="1d6f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">从上面的截图可以看出，<strong class="lf jd">Oracle VM VirtualBox Manager</strong>创建了一个<strong class="lf jd"> Ubuntu虚拟机</strong>，它运行在一个正常的窗口内。如果你全屏显示，你会暂时忘记它实际上是在Windows主机的一个窗口中运行的。</p><p id="3b7e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这听起来很酷，但这怎么可能呢？<strong class="lf jd"> Ubuntu </strong>是为<strong class="lf jd"> Linux </strong>内核设计的，<strong class="lf jd"> Windows </strong>运行在<strong class="lf jd"> Windows NT </strong>内核上。每个操作系统都是不同的，都是为特定的<strong class="lf jd">内核</strong>设计的。内核是介于硬件和操作系统之间的东西，它的工作是将操作系统指令翻译成实际的硬件命令。</p><p id="bd62" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">那Ubuntu在NT内核上是怎么运行的</strong>？为了理解虚拟化是如何工作的，我们需要理解拼图中非常重要的一块，<strong class="lf jd">虚拟机管理程序</strong> <em class="lz">(以及其他一些东西)</em>。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="03e9" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">什么是虚拟机管理程序？</h1><p id="48d8" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">一个<strong class="lf jd">虚拟机管理程序</strong> ( <em class="lz">也称为</em> <strong class="lf jd"> <em class="lz">虚拟机监视器</em> </strong> <em class="lz">或</em> <strong class="lf jd"> <em class="lz"> VMM </em> </strong>)是一个<strong class="lf jd">软件</strong>或<strong class="lf jd">固件</strong>，它管理并分配一台主机的不同硬件资源给客户机。有两种类型的虚拟机管理程序，它们的工作原理差别很大。</p><h2 id="314d" class="nk mo it bd mp nl nm dn mt nn no dp mx lm np nq mz lq nr ns nb lu nt nu nd iz bi translated">☛1型虚拟机管理程序</h2><p id="d246" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated"><strong class="lf jd">1型虚拟机管理程序</strong>也称为<strong class="lf jd">裸机虚拟机管理程序</strong>是一种直接在系统硬件上运行的固件(<em class="lz">也可以是硬件</em>)。该管理程序控制在主机硬件上作为来宾机器运行的<strong class="lf jd">操作系统</strong>或<strong class="lf jd">虚拟机</strong>的<code class="fe nv nw nx ny b">n</code>数量。在这里，虚拟机管理程序的工作是将系统资源分配给虚拟机。类型1虚拟机管理程序通常包括硬件支持，这意味着它具有预安装的内核。因此，在这个内核上运行的任何操作系统都可以被创建为来宾机器。</p><p id="45c8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">第1类虚拟机管理程序</strong> : <em class="lz"> Xen、VMware ESXi和Microsoft Hyper-V </em></p><h2 id="338a" class="nk mo it bd mp nl nm dn mt nn no dp mx lm np nq mz lq nr ns nb lu nt nu nd iz bi translated">☛2型虚拟机管理程序</h2><p id="b89f" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">第2类虚拟机管理程序是在主机操作系统上运行的软件。这个管理程序创建一个<strong class="lf jd">进程</strong>并分配系统资源，如内存、持久存储和其他重要的东西。然后，客户操作系统在该进程中运行，并使用可用的资源。在这里，虚拟机管理程序充当来宾操作系统和主机操作系统之间的中间人，翻译来宾操作系统指令，以便主机操作系统能够理解。</p><p id="2408" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">第2类虚拟机管理程序</strong> : <em class="lz"> VMware Workstation、VMware Player、Oracle VirtualBox </em></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/5c72a7ac61fae9528752fa2a6076a6ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/0*7o4ezk3zdvLMN6HJ.gif"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">(来源:<a class="ae mf" href="https://developer.ibm.com/articles/cl-hypervisorcompare/" rel="noopener ugc nofollow" target="_blank"> IBM </a>)</figcaption></figure><p id="e497" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">第1类和第2类虚拟机管理程序各有优缺点，但由于第2类虚拟机管理程序运行在主机操作系统上，因此主机操作系统中的任何问题都可能会削弱其上运行的任何来宾机器。此外，第2类虚拟机管理程序不能完全控制主机的硬件，因此我们可能会面临一些扩展限制。</p><p id="4793" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果相同的虚拟机运行在两个不同的主机上，这两个主机具有相同的硬件配置，但一个通过第1类虚拟机管理程序运行，另一个通过第2类虚拟机管理程序运行，那么从技术上讲，具有第1类虚拟机管理程序的机器将运行得更快。这是因为只有一层是虚拟机管理程序本身，虚拟机通过它与硬件进行通信。而在类型2虚拟机管理程序机器中，有两个层(<em class="lz">参考上图</em>)。</p><p id="86c1" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">回到现实，现在，当你想要托管一个网站或创建一个测试环境时，你通常会选择像Amazons EC2这样的云服务，在那里你可以创建一个虚拟机(<em class="lz"> EC2服务器实例</em>),使用你最喜欢的操作系统、所需的内存和磁盘存储。当您创建一个实例时，Amazon不会为您购买具有您想要的配置的机器硬件。</p><p id="2a64" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">相反，他们使用类型1或类型2虚拟机管理程序在其大型基础架构上创建虚拟机，如下图所示。你得到的机器是一个虚拟机(<strong class="lf jd"> <em class="lz">虚拟</em> </strong> <em class="lz">)，因为看起来你的机器有4GB RAM，但实际上，它是一个更大的RAM硬件上的共享内存空间</em>)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/8f37c9706dbd04ac5911797fabb98cf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/0*dEPCSTFOCOF789Ep.gif"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">来源:<a class="ae mf" href="https://developer.ibm.com/articles/cl-hypervisorcompare/" rel="noopener ugc nofollow" target="_blank"> IBM </a></figcaption></figure><p id="a077" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这种动态创建虚拟机并在隔离环境中运行的过程被称为<strong class="lf jd">虚拟化</strong>，它明显降低了托管成本。但是对于大规模应用程序，建议使用虚拟化。如果您有许多需要虚拟隔离环境的小型应用程序，那么在云上购买100台虚拟机是非常愚蠢的。</p><p id="2e15" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">另一方面，在主机操作系统上启动客户操作系统(<em class="lz">使用类型2管理程序</em>)也是不可行的。如果您的客户操作系统需要1GB的RAM和50GB的存储，那么在客户操作系统实例很少的情况下，您可能会消耗大量系统硬件，并且扩展是不可能的。</p><p id="31a8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这就是集装箱化的用武之地。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="d0cd" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">简而言之，集装箱化</h1><p id="9e36" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">一个<strong class="lf jd">容器</strong>是一个独立的执行环境，其中一个或多个进程可以独立运行。创建容器并在其中作为<strong class="lf jd">进程</strong>运行应用程序的动作；被称为<strong class="lf jd">集装箱化</strong>。Linux内核提供了这样一种容器化机制，你可以在一台Linux主机上创建许多容器，称为基于Linux的容器或LXC容器</p><p id="bffe" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如上所述，容器内的进程有一个隔离的环境。这包括网络接口(<em class="lz">获取IP地址</em>)、进程id(PID)、挂载点等。开箱即用的Linux内核提供了一些特性，如<strong class="lf jd">名称空间</strong>和<strong class="lf jd">控制组</strong>来实现这一点。</p><p id="ca73" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">名称空间是Linux内核对内核资源进行分区的特性，比如<strong class="lf jd">网络接口</strong> ( <em class="lz"> net </em>)、<strong class="lf jd">挂载点</strong> ( <em class="lz"> mnt </em>)、<strong class="lf jd">进程id</strong>(<em class="lz">PID</em>)等。因此，我们可以创建具有相同资源标识符的进程集，<em class="lz">例如</em>，<strong class="lf jd"> IP地址</strong>，因为它们共享不同的名称空间。<strong class="lf jd">控制组</strong>也是命名空间，它们控制多少系统资源，如<strong class="lf jd"> CPU </strong>和<strong class="lf jd">内存</strong>分配给进程组。</p><p id="a88c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">总的来说(<strong class="lf jd"> <em class="lz">且不专指Linux </em> </strong>)，容器无非就是我们刚刚说的一组进程。一个容器有一个唯一的命名空间，所有在其中运行的进程都将共享由容器的控制组分配的资源。容器内的任何进程都无法看到分配给其他容器的资源，也无法与之交互。所有容器共享相同的内核(主机操作系统的<em class="lz">)，当容器需要不同的内核时，则必须提供虚拟化。</em></p><p id="019a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">一般来说(<strong class="lf jd"> <em class="lz">与Linux </em> </strong>)一个管理容器的程序叫做<strong class="lf jd">容器引擎</strong>。它还负责<strong class="lf jd">通过使用</strong> <a class="ae mf" href="https://en.wikipedia.org/wiki/System_call" rel="noopener ugc nofollow" target="_blank"> <strong class="lf jd">系统调用</strong> </a> <strong class="lf jd"> s </strong>与内核通信，将系统资源分配给正在运行的容器。它作为一个<strong class="lf jd">守护进程</strong>在主机操作系统上运行。简而言之，容器引擎类似于第二类管理程序，其中容器类似于虚拟机。</p><p id="8753" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">由于没有管理程序用于直接在主机操作系统上创建不同的隔离环境(<em class="lz">这些是容器</em>)，容器化有时被称为<strong class="lf jd"> OS级虚拟化</strong>。</p><h2 id="031c" class="nk mo it bd mp nl nm dn mt nn no dp mx lm np nq mz lq nr ns nb lu nt nu nd iz bi translated">☛容器与虚拟机</h2><p id="93ab" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">我确信你可能会对一个容器如何与一个完全成熟的虚拟机相关联感到困惑，那么让我告诉你，它不是。容器和VM都提供不同程度的隔离，但是它们以不同的方式工作，尽管在隔离方面你可以用它们来实现相同的事情。</p><p id="f47b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">无论是第1类虚拟机管理程序还是第2类虚拟机管理程序，虚拟机都会引导整个操作系统。它在创建时锁定系统资源。虚拟机需要有一个操作系统映像、库、二进制文件和其他依赖于它将要运行的特定硬件的文件。因此，虚拟机快照(<em class="lz">映像</em>)在空间方面携带起来非常沉重。</p><p id="e721" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">容器是包含程序、应用程序级二进制文件、库、环境变量等的包。因为它利用了主机的操作系统，所以操作系统级的库、二进制文件和驱动程序由容器引擎共享。容器不需要锁定系统资源，相反，它可以根据需要从容器引擎要求更多的资源。</p><p id="0159" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">容器感觉像是在运行自己的操作系统副本(<em class="lz">因此感觉像是虚拟机或本机</em>)，因为它有自己的文件系统、IP地址池、注册表等。这是一种谎言。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ob"><img src="../Images/99fdf8151a77edb7f374b52f1d5e92c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*anvWvaABW_Td5o4_lnPyNQ.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">(来源:<a class="ae mf" href="https://cloud.google.com/containers/" rel="noopener ugc nofollow" target="_blank">谷歌云</a>)</figcaption></figure><p id="be7f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因为与虚拟机相比，容器是轻量级的，所以它们可以在大约<strong class="lf jd">毫秒</strong>内产生(<em class="lz">创建</em>),并且可以同时运行1000个这样的容器。相比之下，虚拟机可能需要几分钟才能启动，而你只能拥有其中的几个。</p><p id="1cc4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但是由于容器共享相同的内核，你可以说它们不像虚拟机那样被隔离(同样的情况是类型2和类型1管理程序隔离)。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="e113" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">Docker是如何工作的？</h1><p id="5510" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">既然我们已经了解了集装箱化和集装箱是如何工作的，是时候面对终极真相了。Docker只不过是一个容器化软件，Docker引擎只不过是一个容器引擎。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/82458b03b25331ce258187054955c66c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*E-1baVUOHxYUi_vt.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">(<a class="ae mf" href="https://www.smarthomebeginner.com/what-is-docker-docker-vs-virtualbox/" rel="noopener ugc nofollow" target="_blank">来源</a>)</figcaption></figure><p id="80a4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">docker引擎由Docker守护进程和其他工具组成，用于创建、销毁和管理容器。Docker守护进程是一个在后台运行的进程，它接收来自<strong class="lf jd"> <em class="lz">本地</em> </strong>或<strong class="lf jd"> <em class="lz">远程</em> </strong> <strong class="lf jd"> Docker客户端</strong> (CLI)的命令，使用<strong class="lf jd"> HTTP REST </strong>协议管理容器。因此，据说Docker遵循<strong class="lf jd">客户端-服务器</strong>架构，其中<strong class="lf jd">服务器</strong>是Docker守护进程。</p><p id="db99" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当您在系统上安装Docker时，您会得到Docker引擎、Docker命令行界面(Docker客户端)和其他GUI实用程序。当你启动你的Docker，它将启动Docker守护进程。</p><h2 id="0728" class="nk mo it bd mp nl nm dn mt nn no dp mx lm np nq mz lq nr ns nb lu nt nu nd iz bi translated">☛什么是码头集装箱？</h2><p id="e5d5" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">到目前为止，我们讨论的容器是对什么是容器以及它如何工作的一般解释。Docker容器要复杂得多。</p><p id="f185" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">docker容器包含<strong class="lf jd">应用程序代码</strong>和<strong class="lf jd">其他依赖关系</strong>。这些<strong class="lf jd">其他依赖</strong>使得一个容器成为一个<strong class="lf jd">容器</strong>。这些<strong class="lf jd">其他依赖项</strong>包括必要的(<em class="lz">特定于应用程序的</em>)库、二进制文件和我们的应用程序运行所需的其他资源。</p><p id="2934" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">容器的一个例子是一个<strong class="lf jd"> node.js </strong>服务器。所以我们的应用程序代码将由包含应用程序代码的<code class="fe nv nw nx ny b">server.js</code>和<code class="fe nv nw nx ny b">node_module</code>库组成。但是要运行它，我们需要在容器中安装<code class="fe nv nw nx ny b">node</code>，因此我们需要一个<code class="fe nv nw nx ny b"><strong class="lf jd">node</strong></code>二进制文件。node.js可能依赖于其他二进制文件和库，因此我们也需要它们。然后<code class="fe nv nw nx ny b">node.js</code>需要一个操作系统来运行，例如<strong class="lf jd"> CentOS </strong>，因此我们也需要一个定制的二进制文件，Docker引擎可以利用它来与客户操作系统和内核对话。</p><h2 id="6a3c" class="nk mo it bd mp nl nm dn mt nn no dp mx lm np nq mz lq nr ns nb lu nt nu nd iz bi translated">☛什么是码头工人形象？</h2><p id="cef2" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">我们刚刚谈到的<strong class="lf jd">节点服务器</strong>例子包含许多需要存在于容器中的部分，这样我们的应用程序才能工作。Docker图像是一个包含所有这些部分的压缩盒子。</p><p id="1a1e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们指示Docker客户机从这个映像创建一个容器。Docker客户机指示Docker守护进程解压缩映像，读取内容并启动容器，同时将<code class="fe nv nw nx ny b">server.js</code>作为一个进程执行。根据映像中的其他指令，Docker守护进程可能会从容器中公开一些端口，我们可以监听和/或安装卷以及做其他事情。</p><p id="68ec" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了创建Docker图像，我们需要一个<code class="fe nv nw nx ny b">Dockerfile</code>。<code class="fe nv nw nx ny b">Dockerfile</code>是一个配置文件，包含告诉Docker引擎如何构建映像的指令。这些指令可以是什么是<strong class="lf jd">基础映像</strong>，什么是在容器内运行的操作系统内的工作目录，什么应用程序特定的文件需要从系统中复制，什么端口需要在容器中暴露，以及其他无数的事情。</p><p id="da4f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">一个<strong class="lf jd">基础映像</strong>是Docker提供的官方映像，我们将在其中添加我们的应用程序特定代码和指令。基本映像可以包含与<strong class="lf jd"> Apache </strong>服务器一起安装的<strong class="lf jd"> CentOS </strong>操作系统。</p><p id="e6e3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">docker映像遵循修改后的<strong class="lf jd">联合文件系统</strong>，例如<a class="ae mf" href="https://en.wikipedia.org/wiki/Aufs" rel="noopener ugc nofollow" target="_blank"> <strong class="lf jd"> AuFS </strong> </a>。<code class="fe nv nw nx ny b">Dockerfile</code>中的每个指令创建一个<strong class="lf jd">只读</strong> AuFS层。如<code class="fe nv nw nx ny b">Dockerfile</code>中所述，这些层相互堆叠。每一层都只是与前一层的一组差异。</p><p id="86d1" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当我们从这个图像创建一个容器时，我们复制所有这些只读层，并在其上添加一个新的<strong class="lf jd">读写</strong>层。只读层称为<strong class="lf jd">图像层</strong>，而容器中的薄读写层称为<strong class="lf jd">容器层</strong>。</p><p id="490f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">典型的<code class="fe nv nw nx ny b">Dockerfile</code>会是下面这个样子(<em class="lz">跟着这个</em> <a class="ae mf" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank"> <strong class="lf jd"> <em class="lz">链接</em> </strong> </a> <em class="lz">关于</em> <code class="fe nv nw nx ny b"><em class="lz">Dockerfile</em></code> <em class="lz">的其他细节不过下面是一个示例</em>)。</p><pre class="ks kt ku kv gt od ny oe of aw og bi"><span id="b1d1" class="nk mo it ny b gy oh oi l oj ok">FROM ubuntu:15.04<br/>COPY . /app<br/>RUN make /app<br/>CMD python /app/app.py</span></pre><p id="42e1" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在上面的<code class="fe nv nw nx ny b">Dockerfile</code>中，我们正在从创建第一层的<code class="fe nv nw nx ny b">15.04</code> ( <em class="lz">由Docker Hub </em>提供)版本的<strong class="lf jd"> Ubuntu </strong>基础映像创建我们的映像。然后，我们将当前目录中的所有内容复制到Ubuntu OS中的<code class="fe nv nw nx ny b">/app</code>位置，这将创建一个新层并堆叠在前一层上。然后，我们使用<code class="fe nv nw nx ny b">make</code>命令构建应用程序，该命令将输出写入新层并堆叠在前一层之上。然后我们使用<code class="fe nv nw nx ny b">python</code>命令运行python程序。最后一条指令不占用层中的任何空间，因为它是一个bash命令。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/0227face484be319190538cb9ce19016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/0*xcdmVPl1Fxfqw7aC.jpg"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">(来源:<a class="ae mf" href="https://docs.docker.com/storage/storagedriver/#images-and-layers" rel="noopener ugc nofollow" target="_blank"> <strong class="bd mp"> Docker </strong> </a>)</figcaption></figure><p id="14fe" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">从上图可以看出，当我们运行一个容器时，它会在图像层的顶部创建一个读写层。对正在运行的容器所做的所有更改，如写入新文件、修改现有文件和删除文件，都被写入这个可写的瘦容器层。</p><p id="6a00" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当容器运行时，容器层需要与它下面的层进行通信，以合并每个层中的差异，并生成实际的文件系统。这是使用Docker引擎提供的存储驱动程序来完成的。</p><p id="585b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当一个层(<em class="lz">包括容器层</em>)需要读取下一层的文件时，它直接从该层读取文件。在构建图像时，当一个层需要从它下面的层写入文件时，该文件被复制到当前层并在那里进行更改(<strong class="lf jd"> <em class="lz"> diff </em> </strong> <em class="lz">保存在层</em>)。</p><p id="a167" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在容器中，当容器层想要从它下面的层写入文件时，该文件被复制到容器层，并且对该文件进行改变。当我们想写时复制文件的策略(<em class="lz">修改它</em>)称为<strong class="lf jd">写时复制</strong> (CoW)策略。</p><p id="280b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这使得可写层变得轻量级，因此我们称之为<strong class="lf jd">薄层</strong>。因此，对图像层的所有修改都存在于可写容器层中。当容器被破坏时，容器层也被破坏，但是图像层保持原样。如果我们想的话，我们仍然可以保存一个容器的可写层，它被称为持久Docker容器。</p><p id="f0e6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">多个容器可以共享一个或多个映像中的一些或所有文件系统层。因为每一层都标有UUID，这是该层内容的校验和，所以它们非常可重用。如果两个容器由同一个图像制成，它们共享100%的图像层，并有自己唯一的可写层(如下图所示<em class="lz">)。</em></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi om"><img src="../Images/0d83af26c632f98ea7029c080a501af7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*q-DshkIA04g0aR6t.jpg"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">(来源:<a class="ae mf" href="https://docs.docker.com/storage/storagedriver/#images-and-layers" rel="noopener ugc nofollow" target="_blank"> <strong class="bd mp"> Docker </strong> </a>)</figcaption></figure><p id="06dd" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">使用<strong class="lf jd">写时复制</strong> (CoW)策略分层文件系统以及层可用性是Docker容器创建速度如此之快的原因。因此，容器是轻量级的，并且在磁盘上具有小的尺寸(仅<em class="lz">可写层的尺寸</em>)。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="c4f7" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">Docker在非Linux平台上是如何工作的？</h1><p id="c1b4" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">如果你能活到现在，我有一个问题要问你。如果docker基于Linux Containers (LXC ),那么Docker如何在其他内核上工作，比如MacOs的Darwin和Windows的Windows NT？</p><p id="6539" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">Docker最初使用Linux容器(LXC ),并且只为Linux内核设计。因此任何基于Linux的操作系统都可以使用它。对于Windows和macOS，Docker将使用<a class="ae mf" href="https://www.virtualbox.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lf jd">虚拟盒</strong> </a>在Linux虚拟机内运行Docker引擎。对于Windows和macOS，您必须安装<a class="ae mf" href="https://docs.docker.com/toolbox/toolbox_install_windows/" rel="noopener ugc nofollow" target="_blank"> <strong class="lf jd"> Docker工具箱</strong> </a>，它将负责虚拟化。</p><p id="4376" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但是最新版本的Docker，针对Linux，使用了遵循OCI ( <a class="ae mf" href="https://www.opencontainers.org/about" rel="noopener ugc nofollow" target="_blank"> <strong class="lf jd"> <em class="lz">开放容器倡议</em> </strong> </a>)规范的<a class="ae mf" href="https://github.com/opencontainers/runc" rel="noopener ugc nofollow" target="_blank"> runC </a> ( <em class="lz">原名</em> <strong class="lf jd"> <em class="lz"> libcontainer </em> </strong>)。runC 是一个CLI工具，用于生成和运行容器，它运行在与其主机相同的操作系统中。在Windows的情况下，Docker使用的是Windows提供的内置虚拟化技术<a class="ae mf" href="https://en.wikipedia.org/wiki/Hyper-V" rel="noopener ugc nofollow" target="_blank"> <strong class="lf jd"> Hyper-V </strong> </a>。Docker在MacOs的情况下使用<a class="ae mf" href="https://developer.apple.com/documentation/hypervisor" rel="noopener ugc nofollow" target="_blank"> <strong class="lf jd"> Hypervisor框架</strong> </a>进行虚拟化。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="ba4b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">Docker是用Go ( <strong class="lf jd"> GoLang </strong>)写的，这是我最喜欢的语言之一，你可以在这里 找到我的教程。这是一个相当于<strong class="lf jd">去神秘化Docker </strong>的教程，但却是一个重要的教程，如果事情没有得到适当的澄清，我道歉(<em class="lz">建议总是受欢迎的</em>)。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi on"><img src="../Images/e3da3bf1cee07cd997d46904bbbf70b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t4VSpLEAu4Gmg-GweZ3RvA.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">(<a class="ae mf" href="http://thatisuday.com" rel="noopener ugc nofollow" target="_blank"><strong class="bd mp">thatisuday.com</strong></a>/<a class="ae mf" href="https://github.com/thatisuday" rel="noopener ugc nofollow" target="_blank">/<strong class="bd mp">GitHub</strong></a>/<a class="ae mf" href="https://twitter.com/thatisuday" rel="noopener ugc nofollow" target="_blank"><strong class="bd mp">Twitter</strong>/</a><a class="ae mf" href="https://stackoverflow.com/users/2790983/uday-hiwarale" rel="noopener ugc nofollow" target="_blank"><strong class="bd mp">stack overflow</strong></a><strong class="bd mp">/<a class="ae mf" href="https://www.instagram.com/thatisuday/" rel="noopener ugc nofollow" target="_blank">/<strong class="bd mp">insta gram</strong></a>)</strong></figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/fdebb498630e863a0129025be5b74fb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/1*Cj3GjJSU7reYw49BYdQfpw.gif"/></div></figure></div></div>    
</body>
</html>