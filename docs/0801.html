<html>
<head>
<title>Smart table for Angular — part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度智能表—第1部分</h1>
<blockquote>原文：<a href="https://itnext.io/smart-table-for-angular-part-1-515ef6cb2d0a?source=collection_archive---------4-----------------------#2018-05-31">https://itnext.io/smart-table-for-angular-part-1-515ef6cb2d0a?source=collection_archive---------4-----------------------#2018-05-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/54ef4955932849a1aa926f1f9b1a5484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lh54osDTzTULJYTXF3OMVQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">智能表格示例</figcaption></figure><div class=""/><p id="bd8e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae la" href="https://github.com/lorenzofox3/Smart-Table" rel="noopener ugc nofollow" target="_blank">Angularjs智能表格</a>已经成为angular js社区在表格/网格组件方面的参考。<a class="ae la" href="https://stackoverflow.com/questions/21375073/best-way-to-represent-a-grid-or-table-in-angularjs-with-bootstrap-3#25734089" rel="noopener ugc nofollow" target="_blank">与其他流行的解决方案相比，它因其声明式方法和灵活性而受到称赞</a>。</p><p id="4bb1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">去年，利用我在这个项目中获得的经验，我创造了<a class="ae la" href="https://smart-table.github.io/www/dist/" rel="noopener ugc nofollow" target="_blank">智能桌面核心</a>。我们的想法是提取您需要的逻辑来拥有一个智能集合，您可以用它来排序、过滤、搜索或创建分页和光标(在许多应用程序中非常常见的用例)。它没有绑定到任何UI框架，也没有绑定到表格/网格组件。事实上，我认为它更像是一个<em class="lb">交互式数据结构，</em>尽管创建表格/列表组件<em class="lb">非常方便。</em></p><p id="d570" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了验证这个想法和设计，我很快为流行的UI框架创建了一些包装器(<a class="ae la" href="https://github.com/smart-table/smart-table-vanilla" rel="noopener ugc nofollow" target="_blank"> Vanilla javascript、</a> <a class="ae la" href="https://github.com/smart-table/smart-table-react" rel="noopener ugc nofollow" target="_blank"> React </a>、<a class="ae la" href="https://github.com/smart-table/smart-table-vue" rel="noopener ugc nofollow" target="_blank">Vuejs</a>——都附带了运行演示)。我还希望它专注于少数几个核心特性，使它非常轻量级，而它可以很容易地用常规的Javascript习惯用法如mixins、decorators等来扩展。这个需求也通过各种扩展得到了验证:</p><ul class=""><li id="46cc" class="lc ld jf ke b kf kg kj kk kn le kr lf kv lg kz lh li lj lk bi translated"><a class="ae la" href="https://github.com/smart-table/smart-table-crud" rel="noopener ugc nofollow" target="_blank"> smart-table-crud </a>扩展了数据结构API以提供crud功能。</li><li id="30a4" class="lc ld jf ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated"><a class="ae la" href="https://github.com/smart-table/smart-table-perf" rel="noopener ugc nofollow" target="_blank"> smart-table-perf </a>修饰了一种记录性能数据的方法。</li><li id="17eb" class="lc ld jf ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated"><a class="ae la" href="https://github.com/smart-table/smart-table-server" rel="noopener ugc nofollow" target="_blank"> smart-table-server </a>覆盖一个将业务逻辑移动到服务器的方法，而不对组件做任何更改。</li><li id="1761" class="lc ld jf ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated"><a class="ae la" href="https://github.com/smart-table/smart-table-virtualizer" rel="noopener ugc nofollow" target="_blank">smart-tabler-virtualizer</a>使用智能表实例分页API来虚拟化一长串数据。</li></ul><p id="7ba8" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最近<a class="ae la" href="https://www.spudsoftware.com/" rel="noopener ugc nofollow" target="_blank"> spudsoftware </a>欣然同意赞助开发<a class="ae la" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular </a>框架的包装器，在这个系列中，我们将学习如何使用<a class="ae la" href="https://github.com/smart-table/smart-table-ng" rel="noopener ugc nofollow" target="_blank">新的smart-table-ng </a>包来构建复杂的表格/列表组件。</p><p id="a9f7" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该套装包括:</p><ol class=""><li id="5650" class="lc ld jf ke b kf kg kj kk kn le kr lf kv lg kz lq li lj lk bi translated">一组工厂将帮助您创建可注入的服务。这些服务基本上是智能表核心实例，并将提供相同的API。它们不同于它们所处理的数据源抽象。我们将在第二篇文章的<a class="ae la" href="https://medium.com/@lorenzofox3/smart-table-for-angular-part-2-31ea5bd0c383" rel="noopener">中探索当与有角度的内置抽象和模式相结合时，它会有多强大。</a></li><li id="6507" class="lc ld jf ke b kf ll kj lm kn ln kr lo kv lp kz lq li lj lk bi translated">一组角度属性指令，帮助你以声明的方式快速创建表格/列表组件。我们将在第一篇文章中回顾这些指令。</li></ol></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="b616" class="ly lz jf bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">辅导的</h1><p id="622c" class="pw-post-body-paragraph kc kd jf ke b kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz ij bi translated">在第一个教程中，我们将创建一个组件来显示交互式用户列表。遵循下面的嵌入式stackblitz，获得最终结果的运行示例。</p><div class="ip iq gp gr ir nb"><a href="https://stackblitz.com/edit/smart-table-ng-tutorial-1?embed=1&amp;file=src/app/app.component.ts" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd jg gy z fp ng fr fs nh fu fw je bi translated">smart-table-ng-tutorial-1-stack blitz</h2><div class="ni l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">stackblitz.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no ix nb"/></div></div></a></div><h2 id="9dbb" class="np lz jf bd ma nq nr dn me ns nt dp mi kn nu nv mm kr nw nx mq kv ny nz mu oa bi translated">入门指南</h2><p id="f79c" class="pw-post-body-paragraph kc kd jf ke b kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz ij bi translated">一旦你安装了smart-table-ng包，不要忘记在你的根模块中导入<strong class="ke jg"><em class="lb">smart table module</em></strong>。</p><p id="c1cf" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我们的教程中，我们将使用具有以下定义的用户列表:</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="d4d1" class="np lz jf og b gy ok ol l om on">interface Name {<br/>  last: string;<br/>  first: string;<br/>}</span><span id="6564" class="np lz jf og b gy oo ol l om on">enum Job {<br/>  ‘DEV’ = ‘dev’,<br/>  ‘QA’ = ‘qa’,<br/>  ‘MANAGER’ = ‘manager’<br/>}</span><span id="9957" class="np lz jf og b gy oo ol l om on">interface User {<br/>  name: Name;<br/>  job: Job;<br/>  birthDate: Date;<br/>  balance: number;<br/>}</span></pre><p id="f060" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你会注意到:</p><ol class=""><li id="b77b" class="lc ld jf ke b kf kg kj kk kn le kr lf kv lg kz lq li lj lk bi translated"><strong class="ke jg"> <em class="lb">名称</em> </strong>有嵌套属性</li><li id="c184" class="lc ld jf ke b kf ll kj lm kn ln kr lo kv lp kz lq li lj lk bi translated"><strong class="ke jg"> <em class="lb">作业</em> </strong>有一组有限的值(枚举)</li><li id="8366" class="lc ld jf ke b kf ll kj lm kn ln kr lo kv lp kz lq li lj lk bi translated"><strong class="ke jg"> <em class="lb">生日</em> </strong>是一种日期类型</li><li id="927d" class="lc ld jf ke b kf ll kj lm kn ln kr lo kv lp kz lq li lj lk bi translated"><strong class="ke jg"> <em class="lb">余额</em> </strong>是一个数字类型</li></ol><p id="8b7c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的容器组件非常简单:</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="65a6" class="np lz jf og b gy ok ol l om on">import { Component } from ‘@angular/core’;<br/>import { SmartTable, of } from ‘smart-table-ng’;<br/>import { users, User } from ‘./users’;</span><span id="ae86" class="np lz jf og b gy oo ol l om on">const providers = [{ provide: SmartTable, useValue: of&lt;User&gt;(users)}];</span><span id="be51" class="np lz jf og b gy oo ol l om on">@Component({<br/>  selector: ‘user-list’,<br/>  templateUrl: ‘./user-list.component.html’,<br/>  providers<br/>})<br/>export class UserListComponent {<br/>}</span></pre><p id="ed10" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可能已经注意到了<strong class="ke jg"> <em class="lb">提供者</em> </strong> <em class="lb"> </em>字段。我们将在第二篇文章中讨论更多细节，但它基本上是使用已经定义为数组的用户列表创建一个作用于该组件的可注入智能表实例。</p><p id="e6ca" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在让我们看看我们的模板:</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="c274" class="np lz jf og b gy ok ol l om on">&lt;div stTable #table=”stTable”&gt;<br/>  &lt;div *ngIf="table.busy" class="loading-indicator"&gt;<br/>    Loading...<br/>  &lt;/div&gt;<br/>  &lt;table&gt;<br/>    &lt;thead&gt;<br/>      &lt;tr&gt;<br/>        &lt;th&gt;First name&lt;/th&gt;<br/>        &lt;th&gt;Last name&lt;/th&gt;<br/>        &lt;th&gt;Birth date&lt;/th&gt;<br/>        &lt;th&gt;Job&lt;/th&gt;<br/>        &lt;th&gt;Balance&lt;/th&gt;<br/>      &lt;/tr&gt;<br/>    &lt;/thead&gt;<br/>    &lt;tbody&gt;<br/>      &lt;tr *ngFor=”let user of table.items"&gt;    </span><span id="027b" class="np lz jf og b gy oo ol l om on">        &lt;td&gt;{{user.value.name.first}}&lt;/td&gt;<br/>        &lt;td&gt;{{user.value.name.last | uppercase}}&lt;/td&gt;<br/>        &lt;td&gt;{{user.value.birthDate | date}}&lt;/td&gt;<br/>        &lt;td&gt;{{user.value.job | uppercase}}&lt;/td&gt;<br/>        &lt;td&gt;{{user.value.balance | currency}}</span><span id="569a" class="np lz jf og b gy oo ol l om on">      &lt;/tr&gt;<br/>    &lt;/tbody&gt;<br/>  &lt;/table&gt;<br/>&lt;/div&gt;</span></pre><p id="9f6d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个模板使用了<strong class="ke jg"><em class="lb">【ST table】</em></strong>指令，它允许你暴露一个模板变量<strong class="ke jg"><em class="lb">" # table】</em></strong></p><p id="df98" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">repeater中使用的<strong class="ke jg"> <em class="lb">项</em> </strong>指令属性将持有一个到当前显示用户的动态绑定。</p><p id="9322" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> <em class="lb"> busy </em> </strong>属性是一个布尔值，它的值根据指令的繁忙状态而变化。例如，声明加载指示器是很有用的。在我们的例子中，它并不真正相关，因为所有的东西都是同步的。</p><h2 id="4f87" class="np lz jf bd ma nq nr dn me ns nt dp mi kn nu nv mm kr nw nx mq kv ny nz mu oa bi translated">页码</h2><p id="d3e4" class="pw-post-body-paragraph kc kd jf ke b kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz ij bi translated">我们的用户列表实际上包含了一千个用户。把它们都显示出来是不明智的，所以我们要创建一个分页控件。我们只需要修改模板</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="ad49" class="np lz jf og b gy ok ol l om on">&lt;div stTable #table=”stTable”&gt;<br/>  &lt;table&gt;<br/>    &lt;thead&gt;<br/>      &lt;tr&gt;<br/>        &lt;th&gt;First name&lt;/th&gt;<br/>        &lt;th&gt;Last name&lt;/th&gt;<br/>        &lt;th&gt;Birth date&lt;/th&gt;<br/>        &lt;th&gt;Job&lt;/th&gt;<br/>        &lt;th&gt;Balance&lt;/th&gt;<br/>      &lt;/tr&gt;<br/>    &lt;/thead&gt;<br/>    &lt;tbody&gt;<br/>      &lt;tr *ngFor=”let user of table.items"&gt;     &lt;td&gt;{{user.value.name.first}}&lt;/td&gt;<br/>        &lt;td&gt;{{user.value.name.last | uppercase}}&lt;/td&gt;<br/>        &lt;td&gt;{{user.value.birthDate | date}}&lt;/td&gt;<br/>        &lt;td&gt;{{user.value.job | uppercase}}&lt;/td&gt;<br/>        &lt;td&gt;{{user.value.balance | currency}}<br/>      &lt;/tr&gt;<br/>    &lt;/tbody&gt;<br/>  &lt;/table&gt;<br/>  &lt;div stPagination #pager="stPagination"&gt;<br/>    &lt;div&gt;<br/>      &lt;p&gt;Showing items &lt;em&gt;{{pager.length &gt; 0 ? pager.lowerBoundIndex + 1 : 0}}&lt;/em&gt; - &lt;em&gt;{{pager.higherBoundIndex +1}}&lt;/em&gt; of &lt;em&gt;{{pager.length}} &lt;/em&gt; items<br/>      &lt;/p&gt;<br/>    &lt;/div&gt;<br/>    &lt;div&gt;<br/>      &lt;button (click)="pager.selectPreviousPage()" [disabled]="!pager.isPreviousPageEnabled()"&gt;Previous&lt;/button&gt;<br/>      &lt;button (click)="pager.selectNextPage()" [disabled]="!pager.isNextPageEnabled()"&gt;Next&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="4c51" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您关注分页部分:</p><figure class="ob oc od oe gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi op"><img src="../Images/a326249f56a4511cadf7ef58944f6232.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cu_2HWPa3uqIq1urdBtjbQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">使用stPagination指令截取的代码</figcaption></figure><p id="1df4" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们使用<strong class="ke jg"><em class="lb">【stPagination】</em></strong>属性指令，借助变量<strong class="ke jg"> <em class="lb"> "#page" </em> </strong>，允许我们向模板公开分页API。</p><p id="b44a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">特别是，我们可以访问以下属性:</p><ul class=""><li id="6cf4" class="lc ld jf ke b kf kg kj kk kn le kr lf kv lg kz lh li lj lk bi translated"><strong class="ke jg"> <em class="lb">长度</em> </strong>:当前显示页面的长度。</li><li id="14ea" class="lc ld jf ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated"><strong class="ke jg"><em class="lb">lowerBoundIndex</em></strong>和<strong class="ke jg"><em class="lb">higher boundindex</em></strong>帮助我们将当前页面框在整个列表里面。</li></ul><p id="caf8" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">和方法</p><ul class=""><li id="d2ae" class="lc ld jf ke b kf kg kj kk kn le kr lf kv lg kz lh li lj lk bi translated"><strong class="ke jg"><em class="lb">isPreviousPageEnabled</em></strong>和<strong class="ke jg"><em class="lb">isNextPageEnabled</em></strong>分别绑定到按钮元素的<strong class="ke jg"><em class="lb">【disabled】</em></strong>属性。</li><li id="bade" class="lc ld jf ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated"><strong class="ke jg"> <em class="lb">选择上一页</em> </strong>和<strong class="ke jg"> <em class="lb">选择下一页</em> </strong>允许我们分别选择上一页和下一页(如果有的话)。</li></ul><p id="8eba" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">page指令还附带了上述代码片段中未使用的方法:</p><ul class=""><li id="2e11" class="lc ld jf ke b kf kg kj kk kn le kr lf kv lg kz lh li lj lk bi translated"><strong class="ke jg"> <em class="lb"> selectPage </em> </strong>方法直接选择给定页面。</li><li id="a13a" class="lc ld jf ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated"><strong class="ke jg"><em class="lb">Chang pagesize</em></strong>如果您希望更改每页显示的项目数。</li></ul><h2 id="1126" class="np lz jf bd ma nq nr dn me ns nt dp mi kn nu nv mm kr nw nx mq kv ny nz mu oa bi translated">排序指令</h2><p id="b424" class="pw-post-body-paragraph kc kd jf ke b kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz ij bi translated"><strong class="ke jg"> <em class="lb"> stSort </em> </strong>指令允许我们通过点击HTML元素来对数据进行排序。让我们修改模板，重点放在标题行上</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="1df7" class="np lz jf og b gy ok ol l om on">&lt;thead&gt;<br/>  &lt;tr&gt;<br/>    &lt;th stSort=”name.first” stSortCycle=”true”&gt;First name&lt;/th&gt;<br/>    &lt;th stSort=”name.last”&gt;Last name&lt;/th&gt;<br/>    &lt;th stSort=”birthDate”&gt;Birth date&lt;/th&gt;<br/>    &lt;th stSort=”job”&gt;Job&lt;/th&gt;<br/>    &lt;th stSort=”balance”&gt;Balance&lt;/th&gt;<br/>  &lt;/tr&gt;<br/>&lt;/thead&gt;</span></pre><figure class="ob oc od oe gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oq"><img src="../Images/a0a882077b402d84bd231209c6b4ef5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TkRZCL946Dc22-E4JYk54Q.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">使用stSort指令的代码段</figcaption></figure><p id="6f96" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> <em class="lb"> stSort </em> </strong>属性指令被设置为一个<em class="lb">路径指针</em>字符串，指向对项目进行排序所依据的属性。它可以是一个<em class="lb">嵌套属性</em>，正如您在名字和姓氏标题中看到的。</p><p id="30c5" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">单击时，标题会切换相关列的排序方向。如果您希望在第三次点击时取消排序方向而不是改变其方向，您可以添加<strong class="ke jg"> <em class="lb"> stSortCycle </em> </strong>属性。</p><p id="1cea" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该指令还根据排序方向向主机添加/删除一个<em class="lb"> css </em>类名(<em class="lb">ST-sort-ASC</em>/s<em class="lb">t-sort-desc</em>)。</p><h2 id="aaa0" class="np lz jf bd ma nq nr dn me ns nt dp mi kn nu nv mm kr nw nx mq kv ny nz mu oa bi translated">搜索项目</h2><p id="5fb1" class="pw-post-body-paragraph kc kd jf ke b kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz ij bi translated">智能表格具有基本的全文搜索功能。您可以使用<strong class="ke jg"> <em class="lb"> stSearch </em> </strong>指令让输入元素搜索您的项目。让我们看看我们的模板:</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="de86" class="np lz jf og b gy ok ol l om on">&lt;div stTable #table=”stTable”&gt;<br/>  &lt;div&gt;<br/>    &lt;label&gt;<br/>      &lt;span&gt;Search&lt;/span&gt;<br/>      &lt;input type=”search” stSearch=”name.first, name.last, job”&gt;<br/>    &lt;/label&gt;<br/>  &lt;/div&gt;<br/>  &lt;table&gt;<br/>...<br/>  &lt;/table&gt;<br/>...<br/>&lt;/div&gt;</span></pre><p id="996e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> <em class="lb"> stSearch </em> </strong>属性指令以逗号分隔的路径指针列表<em class="lb">作为参数，这些路径指针</em>指向您希望进行搜索的项目的属性。</p><p id="b96e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该输入将以给定的去抖时间触发搜索，以确保搜索被有效地触发，并避免额外的无用调用(例如，当连接到服务器时)。您可以使用<strong class="ke jg"><em class="lb">stDebounceTime</em></strong>属性修改去抖时间(值以毫秒为单位)。</p><p id="3526" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">输入是一个正则表达式模式。您可以通过<strong class="ke jg"><em class="lb">stSearchFlags</em></strong>属性提供标志。如果出于某种原因，你想对regexp输入中的特定字符进行转义，你可以使用<strong class="ke jg"><em class="lb">stSearchEscape</em></strong>属性。</p><h2 id="2722" class="np lz jf bd ma nq nr dn me ns nt dp mi kn nu nv mm kr nw nx mq kv ny nz mu oa bi translated">过滤项目</h2><p id="e150" class="pw-post-body-paragraph kc kd jf ke b kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz ij bi translated">全文搜索很好，但有时您希望对筛选项目的方式进行精细控制。<strong class="ke jg"> <em class="lb"> stFilter </em> </strong>属性指令在大多数情况下会满足您的需求:它使输入元素(或选择元素)成为您的数据收集的过滤控件。</p><p id="f362" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们现在的模板是:</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="a3b7" class="np lz jf og b gy ok ol l om on">&lt;div stTable #table=”stTable”&gt;<br/>  &lt;div&gt;<br/>  ...</span><span id="4821" class="np lz jf og b gy oo ol l om on">    &lt;label&gt;<br/>      &lt;span&gt;First name&lt;/span&gt;<br/>        &lt;input type=”text” stFilter=”name.first” /&gt;<br/>    &lt;/label&gt;<br/>    &lt;label&gt;<br/>      &lt;span&gt;Last name&lt;/span&gt;<br/>      &lt;input type=”text” stFilter=”name.last” /&gt;<br/>    &lt;/label&gt;<br/>    &lt;label&gt;<br/>      &lt;span&gt;Born after:&lt;/span&gt;<br/>      &lt;input type=”date” stFilterOperator=”gt” stFilterType=”date” stFilter=”birthDate” /&gt;<br/>    &lt;/label&gt;<br/>    &lt;label&gt;<br/>      &lt;span&gt;Filter by job type:&lt;/span&gt;<br/>      &lt;select name=”job” stFilter=”job” stFilterOperator=”is”<br/>        &lt;option value=””&gt;-&lt;/option&gt;<br/>        &lt;option value=”dev”&gt;DEV&lt;/option&gt;<br/>        &lt;option value=”manager”&gt;MANAGER&lt;/option&gt;<br/>        &lt;option value=”qa”&gt;QA&lt;/option&gt;<br/>      &lt;/select&gt;<br/>    &lt;/label&gt;<br/>    &lt;label&gt;<br/>      &lt;span&gt;Balance lower than&lt;/span&gt;<br/>      &lt;input type=”number” stFilterOperator=”lt” stFilterType=”number” stFilter=”balance” /&gt;<br/>    &lt;/label&gt;<br/>  &lt;/div&gt;<br/>  &lt;table&gt;<br/>...<br/>  &lt;/table&gt;<br/>...<br/>&lt;/div&gt;</span></pre><figure class="ob oc od oe gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi or"><img src="../Images/5cb0e68463bb8f82c2f3233ff47e9405.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5u3R2mM5xiWYLy7d5ma8DA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">stFilterType指令的代码段</figcaption></figure><p id="ba7c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> <em class="lb"> stFilter </em> </strong>属性指令的值是一个路径指针，指向要用于过滤器的属性。同样，您可以拥有嵌套属性。</p><p id="16b5" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该指令将认为值类型默认为一个<em class="lb">字符串。</em>但是您可以通过<strong class="ke jg"> <em class="lb"> stFilterType </em> </strong>属性来更改类型。该值可以是<em class="lb">数字</em>、<em class="lb">布尔</em>、<em class="lb">日期</em>(或字符串)之一。</p><p id="d6a3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">同样的，判断一个条目是否匹配的默认操作符是<em class="lb">“includes”</em>(对于字符串)。可通过<strong class="ke jg"><em class="lb">stFilterOperator</em></strong>属性将其更改为以下之一:</p><ul class=""><li id="8e39" class="lc ld jf ke b kf kg kj kk kn le kr lf kv lg kz lh li lj lk bi translated"><em class="lb">是</em>:严格相等(===)</li><li id="b177" class="lc ld jf ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated"><em class="lb"> isNot </em>:对“是”的否定(！==)</li><li id="ed67" class="lc ld jf ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated"><em class="lb"> lt </em>:低于(&lt;)</li><li id="8a6b" class="lc ld jf ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated"><em class="lb"> gte </em>:大于等于(&gt; =)</li><li id="4a2b" class="lc ld jf ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated"><em class="lb"> gt </em>:大于(&gt;)</li><li id="2f2b" class="lc ld jf ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated"><em class="lb"> lte </em>:小于等于(&lt; =)</li><li id="fe3a" class="lc ld jf ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated"><em class="lb">等于</em>:宽松等式(==)</li><li id="1cb7" class="lc ld jf ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated"><em class="lb"> notEqualS </em>:“等于”的否定(！=)</li></ul><p id="3dae" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">更多详情，请参见<a class="ae la" href="https://smart-table.github.io/www/dist/filter.html#factory" rel="noopener ugc nofollow" target="_blank">智能表核心文档</a>。</p><p id="db00" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这些不同属性的各种组合会给你很多可能性。</p><p id="bec7" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">同样，在过滤器操作被触发之前有一个去反跳时间，您可以通过<strong class="ke jg"> stDebounceTime </strong>属性修改这个去反跳时间</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="7a9c" class="ly lz jf bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">结论</h1><p id="fa8e" class="pw-post-body-paragraph kc kd jf ke b kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz ij bi translated"><strong class="ke jg"> Smart-table-ng </strong>非常有助于以<strong class="ke jg">完全声明的方式快速创建一个非常复杂的列表控件。</strong>然而你的数据集不太可能是一个静态数组，在<a class="ae la" href="https://medium.com/@lorenzofox3/smart-table-for-angular-part-2-31ea5bd0c383" rel="noopener">下一篇教程</a>中，我们将探索一些非常有趣的模式，包括抽象的<strong class="ke jg">可观察的</strong>和Angular框架附带的<strong class="ke jg">依赖注入</strong>的设计。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><p id="c714" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">智能餐桌的发展仍在继续，在不久的将来你可能会看到一些突破性的变化。我还要感谢<a class="ae la" href="https://www.spudsoftware.com/" rel="noopener ugc nofollow" target="_blank"><em class="lb">spud software</em></a><em class="lb">在开发过程中对我的赞助。</em></p><figure class="ob oc od oe gt is gh gi paragraph-image"><div class="gh gi os"><img src="../Images/d3d62c0dacc3d7d12eaedf90607f10a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*ZUxScLiErMnYGoyoT18OtA.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">spudsoftware徽标</figcaption></figure></div></div>    
</body>
</html>