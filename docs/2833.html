<html>
<head>
<title>.NET Core is sexy— Command Line Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">。NET Core很性感——命令行应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/net-core-is-sexy-real-world-part-1-command-line-application-953f48394c83?source=collection_archive---------0-----------------------#2019-08-11">https://itnext.io/net-core-is-sexy-real-world-part-1-command-line-application-953f48394c83?source=collection_archive---------0-----------------------#2019-08-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/cd299b7ce83ff7fdfa76f58d5dbd3ad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*ZXskQGMKQ2IuPDLPLWmEMw.png"/></div></figure><blockquote class="ju jv jw"><p id="45c8" class="jx jy jz ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文是关于。NET Core，以及它现在如何像Node或Rails等任何其他堆栈一样简单高效地创建现代应用程序。</p><p id="93fb" class="jx jy jz ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/https-medium-com-buisson-jeremy-net-core-is-sexy-and-you-should-know-it-a3d0c2eeedc4">。网芯很性感你应该知道</a></p><p id="f70f" class="jx jy jz ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">。网芯性感—命令行应用</em> </strong></p><p id="30d5" class="jx jy jz ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/net-core-is-sexy-building-a-web-api-cdb470cc8222">。NET Core很性感——构建Web API </a></p></blockquote><p id="5775" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">我的意图是创建一个我们将逐步改进的策展应用程序，以一个完整的生产就绪平台结束。我们将从一个Sqlite数据库开始创建一个简单的命令行应用程序。</p><h1 id="b75a" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">我们的目标应用</h1><p id="fb78" class="pw-post-body-paragraph jx jy iq ka b kb ly kd ke kf lz kh ki kx ma kl km ky mb kp kq kz mc kt ku kv ij bi translated">在这一步，我们正在构建一个命令行应用程序，我们将使用它来存储由唯一标识符、名称和创建日期定义的项目。然后，我们将能够显示我们当前的策展列表，并从中删除一个项目。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="fe0e" class="mm lb iq mi b gy mn mo l mp mq">curator add medium.com/@jbuisson<br/>curator add blog.cleancoder.com<br/>curator list<br/>&gt; 1: medium.com/@jbuisson, 8/3/19 9:58:56 AM.<br/>&gt; 2: blog.cleancoder.com, 8/3/19 9:59:17 AM.<br/>curator remove 1<br/>curator list<br/>&gt; 2: blog.cleancoder.com, 8/3/19 9:59:17 AM.</span></pre><h1 id="320f" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">设置应用程序和包</h1><p id="57b7" class="pw-post-body-paragraph jx jy iq ka b kb ly kd ke kf lz kh ki kx ma kl km ky mb kp kq kz mc kt ku kv ij bi translated">创建新的控制台应用程序:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="b4ef" class="mm lb iq mi b gy mn mo l mp mq">dotnet new console -o Curator</span></pre><p id="392f" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">我们会用<a class="ae kw" href="https://docs.microsoft.com/fr-fr/ef/core/" rel="noopener ugc nofollow" target="_blank">微软。EntityFramework </a>作为我们的数据库对象关系映射(ORM)，配置为Sqlite。此外，我们将使用<a class="ae kw" href="https://github.com/natemcmaster/CommandLineUtils" rel="noopener ugc nofollow" target="_blank">command line utils</a>——来自<a class="mr ms ep" href="https://medium.com/u/bcd6cc2f75fd?source=post_page-----953f48394c83--------------------------------" rel="noopener" target="_blank">Nate McMaster</a>——一个用于轻松编写命令行应用程序的强大软件包。</p><p id="b455" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">在我们新创建的项目中，运行以下命令来添加包:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="e63e" class="mm lb iq mi b gy mn mo l mp mq">dotnet add package McMaster.Extensions.CommandLineUtils <br/>dotnet add package Microsoft.EntityFrameworkCore.Sqlite<br/>dotnet add package Microsoft.EntityFrameworkCore.Design</span></pre><h1 id="7a45" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">编码时间到了</h1><p id="3c72" class="pw-post-body-paragraph jx jy iq ka b kb ly kd ke kf lz kh ki kx ma kl km ky mb kp kq kz mc kt ku kv ij bi translated">我们现在必须创建我们的<strong class="ka ir">项目</strong>模型，以便能够将其保存在Sqlite数据库中。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">这种类通常称为<strong class="ak"> DTO </strong>，用于数据传输对象。</figcaption></figure><p id="ca51" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">我们有一个带有公共属性的C#类来获取/设置<strong class="ka ir"> <em class="jz"> Id </em> </strong>、<strong class="ka ir"> <em class="jz"> Name </em> </strong>和<strong class="ka ir"> <em class="jz"> CreatedAt </em> </strong>。我们还覆盖了<strong class="ka ir"> <em class="jz"> ToString </em> </strong>()方法来显示项目信息。</p><p id="10e1" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">接下来，我们创建entity framework<a class="ae kw" href="https://docs.microsoft.com/en-us/dotnet/api/system.data.entity.dbcontext?view=entity-framework-6.2.0" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="jz">db context</em></strong></a>并将其配置为使用Sqlite。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">声明一个<strong class="ak"> DbContext </strong>的最简单的方法，但不是最有用的方法，我们将在后面看到。</figcaption></figure><p id="1dc8" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">同样，这里没有什么是棘手的；<strong class="ka ir"> <em class="jz"> DbContext </em> </strong>作为从数据库访问数据的桥梁。我们为<strong class="ka ir"><em class="jz"/></strong>模型声明了一个<strong class="ka ir"> <em class="jz"> DbSet </em> </strong>，这表明我们在数据库中有一个<strong class="ka ir"> <em class="jz"> Items </em> </strong>表。</p><p id="fc4b" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">此外，我们将EntityFramework告知<strong class="ka ir"> <em class="jz"> UseSqlite </em> </strong>，并带有Sqlite数据库文件的路径。该路径相对于二进制执行目录。您可以随意使用您认为合适的任何其他路径，但要确保目标目录存在；否则，您可能会遇到以下应用程序错误:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="4bec" class="mm lb iq mi b gy mn mo l mp mq">SQLite Error 14: ‘unable to open database file’.</span></pre><p id="2c87" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">在设置应用程序本身之前，我们创建一个新的EntityFramework迁移并运行它来设置数据库。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="9340" class="mm lb iq mi b gy mn mo l mp mq">dotnet ef migrations add InitialCreate<br/>dotnet ef database update</span></pre><p id="3bf5" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">你应该会看到一个<strong class="ka ir"> <em class="jz">的curator.db </em> </strong>文件出现在你之前在<strong class="ka ir"> DbContext </strong>中设置的目录中。如果您没有更改<strong class="ka ir">数据源</strong>的路径，您应该能够在工作区的根目录中找到它。</p><p id="7c64" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">最后，我们创建我们的命令。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="67dc" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">代码很明确。我们有一个基类<strong class="ka ir"><em class="jz">CuratorCommand</em></strong>，它作为所有其他命令的父类，负责<strong class="ka ir"><em class="jz">CuratorContext</em></strong>。此外，我们还有另外三个类用于下面三个命令:<strong class="ka ir">添加</strong>、<strong class="ka ir">列表</strong>、<strong class="ka ir">移除</strong>。</p><p id="800e" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">我鼓励你探索这些命令。考虑甚至创建自己的应用程序来熟悉应用程序及其工作方式。</p><p id="41e9" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">最后一步是更新应用程序的主入口点。这样做应该会产生类似如下的结果:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">整个应用程序在一个文件中，并不真正性感…</figcaption></figure><p id="bef6" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">现在，是检验它的时候了。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="457d" class="mm lb iq mi b gy mn mo l mp mq">dotnet run add medium.com/@jbuisson<br/>dotnet run add blog.cleancoder.com<br/>dotnet run list<br/>&gt; 1: medium.com/@jbuisson, 8/3/19 11:13:37 AM.<br/>&gt; 2: blog.cleancoder.com, 8/3/19 11:13:42 AM.<br/>dotnet run remove 1<br/>dotnet run list<br/>&gt; 2: blog.cleancoder.com, 8/3/19 11:13:42 AM.</span></pre><h1 id="2b61" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">是时候重构了</h1><p id="ee88" class="pw-post-body-paragraph jx jy iq ka b kb ly kd ke kf lz kh ki kx ma kl km ky mb kp kq kz mc kt ku kv ij bi translated">我们有一个工作的命令行应用程序，但是它设计得很差，并且不尊重任何<a class="ae kw" href="https://clean-code-developer.com/weitere-infos/solid/" rel="noopener ugc nofollow" target="_blank">干净代码原则</a>。</p><p id="caaf" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">我的目标是这个项目架构，将控制台应用程序拆分成多个类库:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="fc1c" class="mm lb iq mi b gy mn mo l mp mq">├── data<br/>├── src<br/>    ├── Curator.Console<br/>    ├── Curator.Data<br/>        ├── Curator.Data.Entities<br/>        ├── Curator.Data.EntityFramework<br/>            ├── Curator.Data.EntityFramework.Context<br/>            ├── Curator.Data.EntityFramework.Sqlite<br/>├── tests</span></pre><p id="59a2" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">这可能看起来有点复杂——也就是说，具有这样的深度并将实体、上下文和Sqlite分成三个不同的库。然而，多种原因支持使用这种方法:</p><ul class=""><li id="7232" class="mz na iq ka b kb kc kf kg kx nb ky nc kz nd kv ne nf ng nh bi translated">我应该能够使用没有EntityFramework的实体；他们是两个有各自职责的公司，所以应该分开。这不是教条式的观点，而是务实的观点。我们可以在某个时候移除EntityFramework来使用另一个ORM——或者不使用——由于这种方法，这样做的成本不会太高。</li><li id="e499" class="mz na iq ka b kb ni kf nj kx nk ky nl kz nm kv ne nf ng nh bi translated">EntityFramework允许我们使用广泛的数据库，这意味着在使用相同的上下文时，我们可以使用不同的数据库。剧透:我们将在测试和移植应用程序到web堆栈时这样做。</li></ul><p id="da1d" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">数据文件夹只是作为我们的Sqlite存储库。tests文件夹是不言自明的，在重构完成后将被使用。</p><p id="7dae" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">为了<em class="jz">空</em>或<em class="jz">无效</em>参数，我还将包括一些运行时检查。</p><h1 id="5d83" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">编写测试永远不会太晚</h1><p id="8867" class="pw-post-body-paragraph jx jy iq ka b kb ly kd ke kf lz kh ki kx ma kl km ky mb kp kq kz mc kt ku kv ij bi translated">如果不增加一些测试，我无法有意识地考虑这一步。您将再次看到，基于您的代码设置测试并运行它们是非常简单的。</p><p id="a435" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">为了测试我们的命令，我们不想使用真正的Sqlite数据库。EntityFramework有一个内存提供者来帮助我们这样做。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="fbf0" class="mm lb iq mi b gy mn mo l mp mq">cd src/Curator.Data/Curator.Data.EntityFramework<br/>dotnet new classlib -o Curator.Data.EntityFramework.Memory<br/>cd Curator.Data.EntityFramework.Memory<br/>dotnet add package Microsoft.EntityFrameworkCore.InMemory<br/>dotnet add reference ../Curator.Data.EntityFramework/Curator.Data.EntityFramework.Context/</span></pre><p id="35be" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">我们现在只需创建一个新的<strong class="ka ir"><em class="jz">DesignTimeDbContextFactory</em></strong>，并使用<strong class="ka ir"><em class="jz">UseInMemoryDatabase</em></strong>对其进行设置。这里的一个技巧是在每个新的DbContext上添加一个惟一的数据库名称来隔离每个测试。为此，我使用<strong class="ka ir"> <em class="jz">日期时间。现在. Ticks </em> </strong>，这是足够安全的，但是您可以改为使用<strong class="ka ir"> <em class="jz"> Guid。NewGuid() </em> </strong>或任何唯一的随机生成器。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="687f" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">完成后，我们应该转到tests文件夹并创建一个新的测试项目。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="3eb7" class="mm lb iq mi b gy mn mo l mp mq">cd tests<br/>dotnet new xunit -o Curator.Console.Tests</span></pre><p id="c2d8" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">除了刚刚创建的新数据库提供程序之外，我们还必须添加对希望测试的项目的引用:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="10e7" class="mm lb iq mi b gy mn mo l mp mq">dotnet add reference ../../src/Curator.Console<br/>dotnet add reference ..\..\src\Curator.Data\Curator.Data.EntityFramework\Curator.Data.EntityFramework.Memory\Curator.Data.EntityFramework.Memory.csproj</span></pre><p id="8449" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">现在，您可以为AddCommand编写一个简单的测试:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="fc62" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">最后，一旦所有的测试都写好了，我们就有了一个干净的命令行应用程序。NET Core，兼容Linux，Windows，Mac！根据我之前的故事，你现在应该可以轻松发布这个应用程序了:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="48f6" class="mm lb iq mi b gy mn mo l mp mq">dotnet publish src/Curator.Console -c Release — self-contained true -r [<a class="ae kw" href="https://docs.microsoft.com/fr-fr/dotnet/core/rid-catalog" rel="noopener ugc nofollow" target="_blank">YOUR_RUNTIME_IDENTIFIER</a>] -o [INSTALLATION_PATH]</span></pre><div class="nn no gp gr np nq"><a href="https://gitlab.com/jbuisson/curator/tree/console" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">Jeremy Buisson /馆长-控制台</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">GitLab.com</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">跨平台。NET核心命令行应用程序</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe js nq"/></div></div></a></div><p id="b603" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">这是我们的第一步。下一个将是部署在服务器上或使用Docker的web API。</p></div></div>    
</body>
</html>