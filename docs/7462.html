<html>
<head>
<title>How Angular evolves? By not being opinionated where it shouldn’t be!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">棱角是如何进化的？不要固执己见！</h1>
<blockquote>原文：<a href="https://itnext.io/how-angular-evolves-by-not-being-opinionated-where-it-shouldnt-be-4c0e0255b881?source=collection_archive---------1-----------------------#2022-10-02">https://itnext.io/how-angular-evolves-by-not-being-opinionated-where-it-shouldnt-be-4c0e0255b881?source=collection_archive---------1-----------------------#2022-10-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/99ed1da684d5066a9ed1cff907924ee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cVDgeNVpoX-iWx2Wz3UgNQ.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://www.pexels.com/photo/red-and-green-tree-leaves-on-a-sunny-day-668553/" rel="noopener ugc nofollow" target="_blank">照片来源</a></figcaption></figure><div class=""/><p id="d3c4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个人都认为Angular是一个<em class="lb">巨大的固执己见的框架</em> <em class="lb">，它拥有开箱即用的一切</em>，并将解决您的问题，而不依赖于第三方软件包！嗯，他们没有错！不是吗？</p><p id="977f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，让我们看看<strong class="kf jh">有多棱角不固执己见</strong>！</p><h2 id="527e" class="lc ld jg bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">Angular在国家管理上并不固执己见</h2><p id="00a6" class="pw-post-body-paragraph kd ke jg kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">因为Angular从来不告诉我们如何在我们的应用程序中管理状态，因为它无法知道我们的应用程序需要什么，而<strong class="kf jh">状态管理是业务逻辑所在</strong>，不知道它试图解决的问题是什么，它就无法给我们提供解决方案。</p><p id="1745" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">rxjs怎么样？</em>是的，是Angular提供的开箱即用，但是<strong class="kf jh">不是Angular </strong>开发的。我相信rxjs之所以被提供了这么长时间，是因为它给了我们<strong class="kf jh">可观测量</strong>的能力，这不仅仅是rxjs的事情，而是一种<strong class="kf jh">编程模式</strong>的事情。Observables为我们提供了反应式编程模式，使开发用户界面变得更加容易，在一个一切都随时间变化的世界中，我们可能需要一些东西来通知我们发生了什么变化，这就是rxjs一直在帮助我们的(包括状态)。</p><p id="6023" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们一直用rxjs作为状态管理库(带subject东西的服务？)，但不代表rxjs就是状态管理库。它只是一个提供实用程序的库，这些实用程序有助于处理<strong class="kf jh">反应流</strong>、<strong class="kf jh">比赛条件</strong>、<strong class="kf jh">计时问题</strong>，以及我们在开发应用程序时可能需要的所有疯狂的东西。</p><p id="498b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有像<strong class="kf jh"> ngrx/store </strong>、<strong class="kf jh"> ngrx/component-store </strong>、<strong class="kf jh"> ngxs </strong>、<strong class="kf jh"> akita </strong>、<strong class="kf jh"> elf </strong>、<strong class="kf jh"> rx-angular </strong>、<strong class="kf jh"> mini-rx-store </strong>等更多的库，所有这些都不是angular提供的，它们都是由社区构建的(顺便说一个很棒的社区👌).</p><p id="7f97" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Angular本身并不提供任何<strong class="kf jh">反应原语</strong>或者实现观察者模式的东西。是的，它没有<strong class="kf jh"> setState </strong>或者<strong class="kf jh">use state</strong>(react)<strong class="kf jh">useRef</strong>(vue)或者<strong class="kf jh"> createSignal </strong> (solid)之类的。我想说还没有，因为经过这么长时间<a class="ae jd" href="https://twitter.com/pkozlowski_os/status/1565012570557190145" rel="noopener ugc nofollow" target="_blank">Angular团队正在研究这个空间</a>，我们可能很快就会有消息。</p><p id="0149" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们需要吗？rxjs可观察性(主体，行为主体，回放主体)够吗？开发人员是喜欢它还是想要更容易学习的东西？只是跟踪价值变化的东西？你怎么想呢?在评论区留下评论。</p><h2 id="bd87" class="lc ld jg bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">开箱即用的出色默认设置</h2><p id="e090" class="pw-post-body-paragraph kd ke jg kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">Angular一直是我们想要一切开箱即用时的首选框架，这一点没有改变。还没！</p><p id="bcfd" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">angular.js的Angular transition激怒了很多开发者，他们从中吸取了教训。他们了解到，开发人员和公司想要稳定，而不是新的闪亮的东西，这就是为什么它坚持一些好的默认设置，完成工作并得到维护。通过使用Angular CLI，我们摆脱了开箱即用的林挺、端到端测试、单元测试框架的配置和使用，使开发人员不再关心工具问题，而是关心业务问题。</p><p id="4828" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这在当时很棒，Angular仍然提供了很多现成的东西，但这是前进的正确方向吗？大概不会！因为web开发空间从早期开始就已经发生了变化并日趋成熟。</p><p id="735c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">库和其他框架已经发展成熟，Angular也在发展。这就是为什么我们看到Angular删除了一些默认设置，并取消了一些其他设置。例如，<a class="ae jd" href="https://github.com/angular/protractor/issues/5502" rel="noopener ugc nofollow" target="_blank">量角器(端到端测试框架)被弃用</a>，我们不再像ts-lint那样开箱即用林挺(ts-lint本身被弃用)。</p><p id="3628" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">为什么会这样？</em> Angular不再提供所有这些服务，因为随着时间的推移，开发人员的需求已经发生了变化，昨天好的东西明天可能就不好了，Angular不能再赌了。我们可能还没有准备好所有的库，但是<strong class="kf jh"> Angular有能力让所有的库都唾手可得</strong>，而不需要麻烦地配置这些库，把它们粘在一起，强迫它们工作。</p><p id="5e92" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它被称为<strong class="kf jh"> schematics </strong>，是Angular为库作者提供的一个库，用于在使用他们的库时创建良好的开发体验。</p><p id="8f84" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果您到终端并按ng lint，您将被要求安装eslint并为您配置它。端到端测试也一样，按ng e2e，会问你要安装配置哪个测试框架(nightwatch，cypress，webdriverio)。</p><p id="cc74" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让开发人员选择使用他们需要的东西，而不需要配置它们，这是前进的方向！</p><h2 id="487e" class="lc ld jg bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">自动迁移</h2><p id="b5ce" class="pw-post-body-paragraph kd ke jg kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">当我们谈论原理图时，假设它们是Angular技术发展的原因。因为他们给它增加了一项叫做自动迁移的超能力。我们只需在终端中按下<strong class="kf jh"> ng update </strong>，就可以看到它完成了项目升级/迁移到新版本所需的所有更改。它将<strong class="kf jh">移除不推荐使用的类</strong>、<strong class="kf jh">用新的替换它们</strong>、<strong class="kf jh">更改不推荐使用的选项</strong>、<strong class="kf jh">移除不再需要的</strong>(<em class="lb">bye bye entry components</em>)、<strong class="kf jh">更新构建配置</strong>、<a class="ae jd" href="https://github.com/angular/angular/blob/382330cd6b20719b4e123f059aeb9a2fce443dde/packages/core/schematics/migrations.json" rel="noopener ugc nofollow" target="_blank">等等</a>。</p><h2 id="75f6" class="lc ld jg bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">摘要</h2><p id="ba89" class="pw-post-body-paragraph kd ke jg kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">就是这样！我们讨论了棱角是如何进化的，以及社区是如何从中被照顾的。此外，在某些事情上坚持己见有多大帮助，不坚持己见可能是前进的方向(工具案例)，反之亦然(状态管理/反应案例)。</p><p id="7f43" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事物会随着时间的推移而变化，它们会进化，Angular就是其中之一！此外，如果你想了解Angular的最新消息、更新和更多信息，请在Twitter上关注我，地址是<a class="ae jd" href="https://twitter.com/Enea_Jahollari" rel="noopener ugc nofollow" target="_blank"> @Enea_Jahollari </a>，你会实时获得这些信息。如果你喜欢这篇文章，并想看到更多这样的内容，也请给我一个关于<strong class="kf jh">媒体</strong>的关注吧！</p><p id="cfb5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">感谢您的阅读！</strong></p></div></div>    
</body>
</html>