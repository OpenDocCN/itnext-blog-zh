<html>
<head>
<title>Kubernetes-based Microservice Observability with Istio Service Mesh: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Kubernetes的Istio服务网格的微服务可观测性:第2部分</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-based-microservice-observability-with-istio-service-mesh-part-2-f25c4b474a65?source=collection_archive---------2-----------------------#2019-03-21">https://itnext.io/kubernetes-based-microservice-observability-with-istio-service-mesh-part-2-f25c4b474a65?source=collection_archive---------2-----------------------#2019-03-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6704" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Jaeger、Prometheus、Grafana和Kiali在Google Cloud的GKE和Istio服务网格上观察分布式系统</h2></div><p id="de89" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇由两部分组成的文章中，我们将探索Istio Service Mesh最新版本中的一组可观察性工具。这些工具包括用于度量收集、监控和警报的<a class="ae le" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank">普罗米修斯</a>和<a class="ae le" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank">格拉法纳</a>，用于分布式跟踪的<a class="ae le" href="https://www.jaegertracing.io/" rel="noopener ugc nofollow" target="_blank">耶格</a>，以及用于基于Istio服务网格的微服务可视化的<a class="ae le" href="https://www.kiali.io/" rel="noopener ugc nofollow" target="_blank"> Kiali </a>。结合云平台-原生监控和日志服务，如谷歌云平台(GCP)上的<a class="ae le" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank">谷歌Kubernetes引擎</a> (GKE)的<a class="ae le" href="https://cloud.google.com/monitoring/" rel="noopener ugc nofollow" target="_blank"> Stackdriver </a>，我们有一个完整的现代分布式应用的可观测性解决方案。</p><h1 id="b62e" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">参考平台</h1><p id="0d49" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">为了展示Istio的可观察性工具，在帖子的第一部分中，我们在GCP的GKE部署了一个用Go编写的参考微服务平台。该平台由(14)个组件组成，包括(8) <a class="ae le" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank">基于Go的</a>微服务，一般标记为服务A到服务H，(1) Angular 7，<a class="ae le" href="https://en.wikipedia.org/wiki/TypeScript" rel="noopener ugc nofollow" target="_blank">基于类型脚本的</a>前端，(4) MongoDB数据库，以及(1)用于基于事件队列的通信的RabbitMQ队列。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/1f56c4e3637481e3951b87635d4dfcbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yp2_sLoiC_gWHICPzMKL8A.png"/></div></div></figure><p id="bf5f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">参考平台旨在生成基于HTTP的服务到服务、基于TCP的服务到数据库(MongoDB)和基于TCP的服务到队列到服务(RabbitMQ) IPC(进程间通信)。服务A调用服务B和服务C，服务B调用服务D和服务E，服务D在RabbitMQ队列上产生一条消息，由服务F消费并写入MongoDB，以此类推。目标是当系统部署到Kubernetes时，使用Istio的可观察性工具观察这些分布式通信。</p><h1 id="8327" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">支柱1:伐木</h1><p id="397e" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">如果您还记得，日志、度量和跟踪通常被称为可观察性的三大支柱。由于我们在GCP使用GKE，我们将查看谷歌的<a class="ae le" href="https://cloud.google.com/monitoring/" rel="noopener ugc nofollow" target="_blank"> Stackdriver日志</a>。根据谷歌的说法，Stackdriver Logging允许你存储、搜索、分析、监控和警告来自GCP甚至AWS的日志数据和事件。尽管Stackdriver日志记录不是一个Istio可观察性特性，但日志记录是整个可观察性策略的一个重要支柱。</p><h2 id="dc13" class="mo lg it bd lh mp mq dn ll mr ms dp lp kr mt mu lr kv mv mw lt kz mx my lv mz bi translated">基于Go的微服务日志记录</h2><p id="e597" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">有效的日志记录策略始于您记录什么、何时记录以及如何记录。作为我们日志策略的一部分，八个基于Go的微服务正在使用<a class="ae le" href="https://github.com/sirupsen/logrus" rel="noopener ugc nofollow" target="_blank"> Logrus </a>，一个流行的Go结构化日志程序。微服务还实现了Banzai Cloud的<a class="ae le" href="https://github.com/sirupsen/logrus" rel="noopener ugc nofollow" target="_blank"> logrus-runtime-formatter </a>。有一篇关于格式化程序的优秀文章，<a class="ae le" href="https://banzaicloud.com/blog/runtime-logging/" rel="noopener ugc nofollow" target="_blank"> Golang运行时Logrus格式化程序</a>。这两个日志包让我们能够更好地控制我们记录的内容、记录的时间以及记录微服务信息的方式。软件包的推荐配置是最低限度的。</p><pre class="md me mf mg gt na nb nc nd aw ne bi"><span id="9b41" class="mo lg it nb b gy nf ng l nh ni"><strong class="nb iu">func </strong>init() {<br/>   formatter := runtime.Formatter{ChildFormatter: &amp;log.JSONFormatter{}}<br/>   formatter.Line = <strong class="nb iu"><em class="nj">true<br/>   </em></strong>log.SetFormatter(&amp;formatter)<br/>   log.SetOutput(os.Stdout)<br/>   level, err := log.ParseLevel(getEnv(<strong class="nb iu">"LOG_LEVEL"</strong>, <strong class="nb iu">"info"</strong>))<br/>   <strong class="nb iu">if </strong>err != nil {<br/>      log.Error(err)<br/>   }<br/>   log.SetLevel(level)<br/>}</span></pre><p id="5a8f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与Go的简单日志包<a class="ae le" href="https://golang.org/pkg/log/" rel="noopener ugc nofollow" target="_blank"> log </a>相比，Logrus提供了几个优势。日志条目不仅用于致命错误，也不应该在生产环境中输出所有详细日志条目。邮报的微服务利用了Logrus的七级日志功能:跟踪、调试、信息、警告、错误、致命和恐慌。我们还改变了日志级别，允许在部署时在Kubernetes部署资源中轻松地更改它。</p><p id="2977" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">微服务还利用了Banzai Cloud的<a class="ae le" href="https://github.com/sirupsen/logrus" rel="noopener ugc nofollow" target="_blank">logrus-runtime-formatter</a>。Banzai格式化程序自动用运行时/堆栈信息标记日志消息，包括函数名和行号；排除故障时非常有用。我们也在使用Logrus的JSON格式化程序。注意下面的每个日志条目是如何在消息中包含JSON有效负载的。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/f46a42c6dcbd3e581dd4998523c02c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*GAxx1jFBmtqZXITz"/></div></figure><h2 id="cd3d" class="mo lg it bd lh mp mq dn ll mr ms dp lp kr mt mu lr kv mv mw lt kz mx my lv mz bi translated">客户端角度UI日志记录</h2><p id="0c94" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">同样，我们使用<a class="ae le" href="https://www.npmjs.com/package/ngx-logger" rel="noopener ugc nofollow" target="_blank"> NGX Logger </a>增强了Angular UI的日志记录。NGX Logger是一个流行的，简单的日志模块，目前用于Angular 6和7。它允许“漂亮地打印”到控制台，并允许将日志消息发送到服务器端日志记录的URL。对于本演示，我们将只打印到控制台。与Logrus类似，NGX Logger支持多个日志级别:跟踪、调试、信息、警告、错误、致命和关闭。NGX Logger不仅仅输出消息，还允许我们将格式正确的日志条目输出到web浏览器的控制台。</p><p id="62dd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">日志输出的级别取决于环境、生产或非生产。下面我们看到本地开发环境中日志条目的组合，包括调试、信息和错误。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nk"><img src="../Images/45e5046ee521e194f00fad5ba350468d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*k8nX5Cuvb0Skq0TJ"/></div></div></figure><p id="aacd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样在下面，我们在GKE的生产环境中看到了相同的页面。请注意，在不更改配置的情况下，没有调试级别的日志条目输出到控制台。我们不希望在详细的日志输出中向生产中的最终用户公开潜在的敏感信息。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nk"><img src="../Images/ad205e6a986cdbed6c15957a936d411d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*BtIeIFhC-NdwkHmw"/></div></div></figure><p id="1efb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过向app.module.ts文件添加以下三元运算符，可以控制日志记录级别。</p><pre class="md me mf mg gt na nb nc nd aw ne bi"><span id="52d9" class="mo lg it nb b gy nf ng l nh ni">LoggerModule.<em class="nj">forRoot</em>({<br/>  level: !environment.production ? NgxLoggerLevel.<em class="nj">DEBUG </em>: NgxLoggerLevel.<em class="nj">INFO</em>,<br/>  serverLogLevel: NgxLoggerLevel.<em class="nj">INFO<br/></em>})</span></pre><h1 id="12cb" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">支柱2:衡量标准</h1><p id="c761" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">对于指标，我们将在<a class="ae le" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank">普罗米修斯</a>和<a class="ae le" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank">格拉夫纳</a>进行检查。这两个领先的工具都是作为Istio部署的一部分安装的。</p><h2 id="5505" class="mo lg it bd lh mp mq dn ll mr ms dp lp kr mt mu lr kv mv mw lt kz mx my lv mz bi translated">普罗米修斯</h2><p id="e8f4" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">Prometheus是一个完全开源的社区驱动的系统监控和警报工具包，最初建于SoundCloud，大约在2012年。有趣的是，普罗米修斯在2016年加入了<a class="ae le" href="https://cncf.io/" rel="noopener ugc nofollow" target="_blank">云原生计算基金会</a> (CNCF)，作为继<a class="ae le" href="http://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>之后的第二个托管项目。</p><p id="6a78" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据<a class="ae le" href="https://istio.io/docs/tasks/telemetry/querying-metrics/" rel="noopener ugc nofollow" target="_blank"> Istio </a>的说法，Istio的混音器带有一个内置的Prometheus适配器，该适配器公开了一个提供生成的度量值的端点。Prometheus附加组件是一个Prometheus服务器，它预先配置为收集Mixer端点以收集公开的指标。它提供了持久存储和查询Istio指标的机制。</p><p id="191f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着GKE集群的运行、Istio的安装和平台的部署，访问Grafana最简单的方法是使用<code class="fe nl nm nn nb b">kubectl port-forward</code>连接到Prometheus服务器。根据Google的说法，Kubernetes <a class="ae le" href="https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/" rel="noopener ugc nofollow" target="_blank">端口转发</a>允许使用一个资源名，比如一个服务名，来选择一个匹配的pod进行端口转发，从Kubernetes v1.10开始。我们将一个本地端口转发到Prometheus pod上的一个端口。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/7ad9f95857f01c9b2fd08a893205acde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*DGupxFMlWy6I2JgM"/></div></figure><p id="137f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用Google Cloud Shell进行连接，或者将该命令复制并粘贴到您的本地Shell，以便从本地端口进行连接。下面是这篇文章中使用的端口转发命令。</p><pre class="md me mf mg gt na nb nc nd aw ne bi"><span id="cd5c" class="mo lg it nb b gy nf ng l nh ni"># Grafana<br/>kubectl port-forward -n istio-system \<br/>  $(kubectl get pod -n istio-system -l app=grafana \<br/>  -o jsonpath='{.items[0].metadata.name}') 3000:3000 &amp;<br/>  <br/># Prometheus<br/>kubectl -n istio-system port-forward \<br/>  $(kubectl -n istio-system get pod -l app=prometheus \<br/>  -o jsonpath='{.items[0].metadata.name}') 9090:9090 &amp;<br/>  <br/># Jaeger<br/>kubectl port-forward -n istio-system \<br/>$(kubectl get pod -n istio-system -l app=jaeger \<br/>-o jsonpath='{.items[0].metadata.name}') 16686:16686 &amp;<br/>  <br/># Kiali<br/>kubectl -n istio-system port-forward \<br/>  $(kubectl -n istio-system get pod -l app=kiali \<br/>  -o jsonpath='{.items[0].metadata.name}') 20001:20001 &amp;</span></pre><p id="7769" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据<a class="ae le" href="https://prometheus.io/docs/prometheus/latest/querying/basics/" rel="noopener ugc nofollow" target="_blank">普罗米修斯</a>的说法，用户使用一种叫做<a class="ae le" href="https://prometheus.io/docs/prometheus/latest/querying/basics/" rel="noopener ugc nofollow" target="_blank"> PromQL </a>(普罗米修斯查询语言)的函数式查询语言实时选择和聚合时间序列数据。表达式的结果既可以显示为图形，在Prometheus的表达式浏览器中以表格数据的形式查看，也可以由外部系统通过Prometheus的<a class="ae le" href="https://prometheus.io/docs/prometheus/latest/querying/api/" rel="noopener ugc nofollow" target="_blank"> HTTP API </a>使用。表达式浏览器包括一个下拉菜单，其中包含所有可用的指标作为构建查询的起点。下面是这篇文章中用到的几个PromQL例子。</p><pre class="md me mf mg gt na nb nc nd aw ne bi"><span id="21eb" class="mo lg it nb b gy nf ng l nh ni">up{namespace="dev",pod_name=~"service-.*"}</span><span id="e7a6" class="mo lg it nb b gy no ng l nh ni">container_memory_max_usage_bytes{namespace="dev",container_name=~"service-.*"}<br/>container_memory_max_usage_bytes{namespace="dev",container_name="service-f"}<br/>container_network_transmit_packets_total{namespace="dev",pod_name=~"service-e-.*"}</span><span id="88d5" class="mo lg it nb b gy no ng l nh ni">istio_requests_total{destination_service_namespace="dev",connection_security_policy="mutual_tls",destination_app="service-a"}<br/>istio_response_bytes_count{destination_service_namespace="dev",connection_security_policy="mutual_tls",source_app="service-a"}</span></pre><p id="6263" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面，在Prometheus控制台中，我们看到了部署到GKE的八个基于Go的微服务的示例图。该图显示了五分钟内容器内存的使用情况。在一半的时间内，服务都处于静止状态。在后半段时间，服务处于模拟负载下，使用<code class="fe nl nm nn nb b">hey</code>。查看负载下服务的内存配置文件可以帮助我们确定容器内存的最小值和极限值，这会影响Kubernetes在GKE集群上的工作负载调度。诸如此类的指标也可能揭示内存泄漏或路由问题，例如下面的服务，它似乎比它的同类多消耗25-50%的内存。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/3a9aff589a632b6811f61943c6835eed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*58hNawSA6sZXHZNx"/></div></figure><p id="326e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的另一个例子中，我们看到一个图表，表示在系统处于负载状态时，对<code class="fe nl nm nn nb b">dev</code>名称空间中的服务A的总Istio请求。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/6033c0bd2b890d74d9e70d8b9b49e3ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*nPrWvYZa0Nm43bd-"/></div></figure><p id="8571" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将上面的图表视图与控制台视图中显示的相同指标进行比较。多个条目反映了在五分钟内被检查的名称空间中服务A的多个实例。各个指标元素中的值表示收集的最新指标。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/d4dbb8249cad7aadf951674693e127ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*XPy2A5QIX_N1NduF"/></div></figure><p id="331c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Prometheus还收集关于Istio组件、Kubernetes组件和GKE集群的基本指标。下面我们可以查看GKE集群中每个n1-standard-2虚拟机节点的总内存。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/f6fe328a17349b93049a27313a6b6663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*Ym7TfcrYhGihIq2G"/></div></figure><h2 id="9610" class="mo lg it bd lh mp mq dn ll mr ms dp lp kr mt mu lr kv mv mw lt kz mx my lv mz bi translated">格拉夫纳</h2><p id="4d37" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">Grafana称自己是领先的时间序列分析开源软件。据<a class="ae le" href="https://grafana.com/grafana" rel="noopener ugc nofollow" target="_blank"> Grafana Labs，</a> Grafana允许您查询、可视化、提醒和了解您的指标，无论它们存储在哪里。您可以轻松创建、浏览和共享视觉效果丰富的数据驱动仪表板。Grafana还允许用户为他们最重要的指标可视化地定义警报规则。Grafana将不断评估规则，并可以发送通知。</p><p id="faea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据<a class="ae le" href="https://istio.io/docs/tasks/telemetry/using-istio-dashboard/#about-the-grafana-add-on" rel="noopener ugc nofollow" target="_blank"> Istio </a>的说法，Grafana附加组件是Grafana的预配置实例。Grafana Docker基本映像已经过修改，可以在安装了Prometheus数据源和Istio仪表板的情况下启动。特别是Istio和Mixer的基本安装文件附带了全局(用于每个服务)指标的默认配置。预配置的Istio仪表板旨在与默认的Istio指标配置和Prometheus后端结合使用。</p><p id="aa02" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面，我们看到了预配置的Istio工作负载控制面板。较大仪表板的这个特定部分已经过过滤，以显示我们的GKE集群的<code class="fe nl nm nn nb b">dev</code>名称空间中的出站服务指标。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/88cc52d094032dbe17cbfecb4b57da01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*LNfwX0ViXwYtnIZJ"/></div></figure><p id="acc4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，在下面，我们可以看到预配置的Istio服务仪表板。较大仪表板的这一特定部分经过过滤，以显示GKE集群中Istio入口网关的客户端工作负载指标。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/62cc6c67204f400e2a8a8daa3b027ef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*N3Mzs6jT8kvDQUeo"/></div></figure><p id="4f10" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们看到预配置的Istio Mesh仪表盘。该仪表板经过过滤，以显示部署到我们的GKE集群的组件的度量表视图。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/e8bf01403a7547038bd52a0e6bb9a6ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*to3MF4bi7-RHIZRN"/></div></figure><p id="825c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有效的可观察性策略必须不仅仅包括可视化结果的能力。有效的策略还必须包括检测异常并通知(警告)适当的资源或直接采取措施解决事故的能力。格拉夫纳和普罗米修斯一样，能够发出警报和通知。您可以直观地定义关键指标的警报规则。Grafana将根据规则持续评估指标，并在违反预定义阈值时发送通知。</p><p id="ddbd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Prometheus支持多种流行的<a class="ae le" href="http://docs.grafana.org/alerting/notifications/#all-supported-notifier" rel="noopener ugc nofollow" target="_blank">通知渠道</a>，包括PagerDuty、HipChat、Email、Kafka和Slack。下面，我们看到一个新的Prometheus通知通道，它向Slack支持通道发送警报通知。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/80da5ff50fa4a794f2219eed49daf34d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*m0SEYVy9puG3eY2O"/></div></figure><p id="bfa2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Prometheus能够发送详细的基于文本和视觉的通知。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/63b9c7b7ef85b89267f9a10cb3999e54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*lN8fc-h9zZCq1Rm2"/></div></figure><h1 id="0ae5" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">支柱3:痕迹</h1><p id="db0e" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">据<a class="ae le" href="https://opentracing.io/docs/overview/what-is-tracing/" rel="noopener ugc nofollow" target="_blank">开放跟踪网站</a>报道，分布式跟踪(distributed tracing)，也称为分布式请求跟踪(distributed request tracing)，是一种用于分析和监控应用程序的方法，尤其是那些使用微服务架构构建的应用程序。分布式跟踪有助于查明故障发生的位置以及导致低性能的原因。</p><p id="104d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据<a class="ae le" href="https://istio.io/docs/tasks/telemetry/distributed-tracing/#understanding-what-happened" rel="noopener ugc nofollow" target="_blank"> Istio </a>的说法，尽管Istio代理能够自动发送span，但应用程序需要传播适当的HTTP头，以便当代理发送span信息时，span可以正确地关联到单个跟踪中。为了实现这一点，应用程序需要从传入请求到任何传出请求收集并传播以下标头。</p><ul class=""><li id="33c7" class="np nq it kk b kl km ko kp kr nr kv ns kz nt ld nu nv nw nx bi translated"><code class="fe nl nm nn nb b">x-request-id</code></li><li id="b421" class="np nq it kk b kl ny ko nz kr oa kv ob kz oc ld nu nv nw nx bi translated"><code class="fe nl nm nn nb b">x-b3-traceid</code></li><li id="458a" class="np nq it kk b kl ny ko nz kr oa kv ob kz oc ld nu nv nw nx bi translated"><code class="fe nl nm nn nb b">x-b3-spanid</code></li><li id="8e52" class="np nq it kk b kl ny ko nz kr oa kv ob kz oc ld nu nv nw nx bi translated"><code class="fe nl nm nn nb b">x-b3-parentspanid</code></li><li id="bdef" class="np nq it kk b kl ny ko nz kr oa kv ob kz oc ld nu nv nw nx bi translated"><code class="fe nl nm nn nb b">x-b3-sampled</code></li><li id="334a" class="np nq it kk b kl ny ko nz kr oa kv ob kz oc ld nu nv nw nx bi translated"><code class="fe nl nm nn nb b">x-b3-flags</code></li><li id="cd20" class="np nq it kk b kl ny ko nz kr oa kv ob kz oc ld nu nv nw nx bi translated"><code class="fe nl nm nn nb b">x-ot-span-context</code></li></ul><p id="8898" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">标题起源于Zipkin项目的一部分。标头的B3部分以Zipkin的原始名称BigBrotherBird命名。跨服务调用传递这些头被称为<a class="ae le" href="https://github.com/openzipkin/b3-propagation" rel="noopener ugc nofollow" target="_blank"> B3传播</a>。根据<a class="ae le" href="https://github.com/openzipkin/b3-propagation#b3-propagation" rel="noopener ugc nofollow" target="_blank"> Zipkin </a>的说法，这些属性在进程内传播，并最终传播到下游(通常通过HTTP头)，以确保源自同一根的所有活动都被收集在一起。</p><p id="3eac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了用Jaeger演示分布式跟踪，我修改了服务A、服务B和服务e。这是向其他上游服务发出HTTP请求的三个服务。我添加了以下代码，以便将消息头从一个服务传播到下一个服务。Istio sidecar代理(<a class="ae le" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank">特使</a>)生成第一个<a class="ae le" href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http_conn_man/headers#x-request-id" rel="noopener ugc nofollow" target="_blank">报头</a>。像下面的代码一样，只传播下游请求中出现的有值的头，这一点很重要。传播空标头会破坏分布式跟踪。</p><pre class="md me mf mg gt na nb nc nd aw ne bi"><span id="cb91" class="mo lg it nb b gy nf ng l nh ni">headers := []string{<br/>  "x-request-id",<br/>  "x-b3-traceid",<br/>  "x-b3-spanid",<br/>  "x-b3-parentspanid",<br/>  "x-b3-sampled",<br/>  "x-b3-flags",<br/>  "x-ot-span-context",<br/>}</span><span id="680e" class="mo lg it nb b gy no ng l nh ni">for _, header := range headers {<br/>  if r.Header.Get(header) != "" {<br/>    req.Header.Add(header, r.Header.Get(header))<br/>  }<br/>}</span></pre><p id="93eb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面，在突出显示的Stackdriver日志条目的JSON有效负载中，我们看到从根span传播的所需头，它包含一个值，在上游请求中从服务A传递到服务C。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nk"><img src="../Images/239301c8992ea5139b77ac977cca2e01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*Lk3uoAWcO9J2eLh8"/></div></div></figure><h2 id="762f" class="mo lg it bd lh mp mq dn ll mr ms dp lp kr mt mu lr kv mv mw lt kz mx my lv mz bi translated">贼鸥</h2><p id="da78" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">根据他们的网站介绍，<a class="ae le" href="https://www.jaegertracing.io/docs/1.10/" rel="noopener ugc nofollow" target="_blank"> Jaeger </a>受<a class="ae le" href="https://research.google.com/pubs/pub36356.html" rel="noopener ugc nofollow" target="_blank"> Dapper </a>和<a class="ae le" href="http://zipkin.io/" rel="noopener ugc nofollow" target="_blank"> OpenZipkin </a>的启发，是一个由<a class="ae le" href="http://uber.github.io/" rel="noopener ugc nofollow" target="_blank">优步科技</a>开源发布的分布式追踪系统。它用于对基于微服务的分布式系统进行监控和故障排除，包括分布式上下文传播、分布式事务监控、根本原因分析、服务依赖性分析以及性能和延迟优化。Jaeger <a class="ae le" href="https://www.jaegertracing.io/docs/1.10/architecture/" rel="noopener ugc nofollow" target="_blank">网站</a>包含了Jaeger架构和一般追踪相关术语的良好概述。</p><p id="2f06" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面我们看到了积家界面的痕迹视图。UI显示了在大约40分钟的时间段内对Istio入口网关服务的搜索结果。我们在顶部看到跟踪时间线，下面是跟踪结果列表。正如在Jaeger <a class="ae le" href="https://www.jaegertracing.io/docs/1.10/architecture/" rel="noopener ugc nofollow" target="_blank">网站</a>上讨论的那样，一条轨迹由跨度组成。span表示Jaeger中具有操作名称的逻辑工作单元。踪迹是通过系统的执行路径，并且可以被认为是<a class="ae le" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" rel="noopener ugc nofollow" target="_blank">有向无环图</a> (DAG)的<a class="ae le" href="https://www.jaegertracing.io/docs/1.10/architecture#span" rel="noopener ugc nofollow" target="_blank">跨度</a>。如果您曾经使用过像Apache Spark这样的系统，那么您可能已经熟悉Dag了。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nk"><img src="../Images/1f65760d9491a58e4df927d149f09c93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*HuU0R2gVclMaHhaU"/></div></div></figure><p id="3c42" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面我们看到的是Jaeger UI跟踪细节视图。示例跟踪包含16个跨度，包含八个服务——八个基于Go的服务中的七个和Istio入口网关。轨迹和跨度都有计时。跟踪中的根跨度是Istio入口网关。加载在最终用户的web浏览器中的Angular UI通过Istio入口网关调用网格的边缘服务，即服务A。从那里，我们看到了我们的服务到服务IPC的预期流程。服务A调用服务B和c。服务B调用服务E，服务E调用服务G和服务h。在本演示中，跟踪不会跨越RabbitMQ消息队列。这意味着您不会看到包含从服务D通过RabbitMQ到服务F的调用的跟踪。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nk"><img src="../Images/7f4f863bd7c1b2212337a8be02373112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*A06uDps9KsfnWdNk"/></div></div></figure><p id="e3bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Jaeger UI Trace Detail视图中，您还可以钻取包含附加元数据的单个范围。元数据包括被调用的URL、HTTP方法、响应状态和其他一些头。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nk"><img src="../Images/220df2ef5b4ac28c8806fd851062bb09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*Dcl5DPUSus-Vv2-q"/></div></div></figure><p id="9e09" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Jaeger的最新版本还包括一个比较功能和两个依赖关系视图，力定向图和DAG。我发现与Kiali相比，这两种视图都相当原始，更类似于服务图。缺少对Kiali的访问，这些视图作为依赖图没有多大用处。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nk"><img src="../Images/9fda73764795eaffa9c43dcb63c3c8ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*f6eGH6WZ10nnIHbm"/></div></div></figure><h1 id="6747" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">Kiali:微服务可观察性</h1><p id="43cd" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">根据他们的<a class="ae le" href="https://www.kiali.io/documentation/overview/" rel="noopener ugc nofollow" target="_blank">网站</a>，Kiali提供了以下问题的答案:我的Istio服务网格中有哪些微服务，它们是如何连接的？有一个公共的Kubernetes <a class="ae le" href="https://istio.io/docs/tasks/telemetry/kiali/#before-you-begin" rel="noopener ugc nofollow" target="_blank">秘密</a>控制着对Kiali API和UI的访问。默认登录名为<code class="fe nl nm nn nb b">admin</code>，密码为<code class="fe nl nm nn nb b">1f2d1e2e67df</code>。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/50299d6c74482667abbde3baa2b4a10a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*qEQw5nVY9I7mfng2"/></div></figure><p id="a891" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">登录Kiali，我们会看到Overview菜单项，它提供了Istio服务网格中所有名称空间的全局视图，以及每个名称空间中的应用程序数量。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/2323ce7e845d450d95a2dd28c54b553d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*7mECsJaIMGIV-jUS"/></div></figure><p id="400a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Kiali UI中的图形视图是在Istio服务网格中运行的组件的可视化表示。下面，过滤集群的<code class="fe nl nm nn nb b">dev</code>名称空间，我们可以观察到Kiali映射了8个应用程序(工作负载)、10个服务和24条边(一个图形术语)。具体来说，我们看到位于服务网格边缘的Istio Ingres代理、Angular UI、八个基于Go的微服务以及它们的特使代理边站(在本例中，服务F没有从另一个服务获取任何直接流量)、外部MongoDB Atlas集群和外部CloudAMQP集群。请注意，使用Istio，服务到服务的流量是如何从服务到其sidecar代理，再到另一个服务的sidecar代理，最后到服务的。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/4108857ed7d52b8665b796e048cbc4c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*kWGP1-45KdLpG6m1"/></div></figure><p id="ab60" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面，我们看到了一个类似的服务网格视图，但是这一次，Istio入口网关和服务A之间出现了故障，以红色显示。我们还可以观察HTTP流量的整体指标，比如每分钟的请求总数、错误和状态代码。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/ae8461df85121476a31ac6f2b13fb681.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*Sx11-i5YJ_TcEC8i"/></div></figure><p id="7264" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Kiali还可以显示图中每条边(两个组件之间的通信)的平均请求时间和其他指标。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/a4134a958c232eeec8223333f87f5312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*q3pNkJr4s0SbC82h"/></div></figure><p id="06f0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Kiali还可以显示部署的应用版本，如下图，微服务是1.3和1.4版本的组合。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/1c38f49dad2a63262030fcbb28d22e2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*jvhV094Ug3BkKkFv"/></div></figure><p id="c752" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关注外部MongoDB Atlas集群，Kiali还允许我们查看服务网格内的四个服务和外部集群之间的TCP流量。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/842ee2a39ebf2584354ff2412209db22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*qFXs8CDOx9zqnXgq"/></div></figure><p id="91cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“应用程序”菜单项列出了所有应用程序及其错误率，可以按名称空间和时间间隔进行过滤。在这里，我们看到Angular UI产生了16.67%的错误。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/01cc6b1b8fab2d8daa50875b7bd63569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*wLcMbqGMoiQnfGkf"/></div></figure><p id="b566" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在“Applications”和“Workloads”菜单项上，我们可以深入到一个组件以查看更多详细信息，包括整体运行状况、pod数量、服务和目标服务。下面，我们看到了服务B在<code class="fe nl nm nn nb b">dev</code>名称空间中的细节。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/bd3f6d3c1a52c4d76365bf3335faf253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*HnhKenwZEyTjkhOi"/></div></figure><p id="d3a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">工作负载详细视图还包括入站和出站指标。下面是<code class="fe nl nm nn nb b">dev</code>名称空间中服务A的出站容量、持续时间和大小指标。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/042ebf3523b2ccdd4befe8408de15704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*uDu-dVa8NvkrVABw"/></div></figure><p id="f77c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，Kiali显示了一个Istio配置菜单项。Istio配置菜单项显示用户环境中存在的所有可用Istio配置对象的列表。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/98b98e5f43e1968dd47de98ac63f42e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*asxFP8ITfyZ0YF9K"/></div></figure><p id="2b12" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我经常发现Kiali是我解决平台问题的第一站。一旦我确定了有问题的特定组件或通信路径，我就可以通过Grafana仪表板搜索Stackdriver日志和Prometheus指标。</p><h1 id="867d" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">结论</h1><p id="bcaf" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">在这篇由两部分组成的文章中，我们探索了当前的一组可观察性工具，它们是最新版本的Istio服务网格的一部分。这些工具包括用于指标收集、监控和警报的Prometheus和Grafana，用于分布式跟踪的Jaeger，以及用于基于Istio服务网格的微服务可视化的Kiali。结合云平台原生监控和日志记录服务，如谷歌云平台(GCP)上的谷歌Kubernetes引擎(GKE)的Stackdriver，我们有一个完整的现代分布式应用的可观测性解决方案。</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><p id="7e90" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nj">本文表达的所有观点都是我个人的，不一定代表我现在或过去的雇主或他们的客户的观点。</em></p></div></div>    
</body>
</html>