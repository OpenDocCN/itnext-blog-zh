<html>
<head>
<title>Seccomp in Kubernetes — Part 3: The new syntax plus some Advanced topics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes中的Seccomp第3部分:新语法和一些高级主题</h1>
<blockquote>原文：<a href="https://itnext.io/seccomp-in-kubernetes-part-3-the-new-syntax-plus-some-advanced-topics-95dd3835263a?source=collection_archive---------3-----------------------#2020-08-26">https://itnext.io/seccomp-in-kubernetes-part-3-the-new-syntax-plus-some-advanced-topics-95dd3835263a?source=collection_archive---------3-----------------------#2020-08-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/12fdf7c3b9e666d1725a9fb2601f779b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fNqW6bkjbsq627DyfwPQgw.png"/></div></div></figure><div class=""/><div class=""><h2 id="c3f8" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">这是另一篇关于掌握为您的工作负载创建seccomp配置文件的技巧的文章，这次涵盖了新的Seccomp GA语法和其他一些高级主题。</h2></div><p id="0f97" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这一部分，我想覆盖几个孤立的点，希望它们一起能够给你的seccomp知识增加一点深度。</p><h1 id="1b71" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">Seccomp GA终于…</h1><p id="4e0e" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">早在2016年<a class="ae mj" href="https://github.com/jessfraz" rel="noopener ugc nofollow" target="_blank"> jessfrazz </a> <a class="ae mj" href="https://github.com/kubernetes/kubernetes/pull/25324" rel="noopener ugc nofollow" target="_blank">在Kubernetes v1.3中添加了seccomp支持</a>。它在alpha中停留了几年，尽管为此付出了大量不同的努力，直到它最终在本月的v1.19版本中正式发布——向参与这一旅程的所有人大声欢呼！</p><p id="0538" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现有的基于注释的支持现已过时，将从1.23版的Kubernetes中删除。从现在起，您将能够在Pod或/和容器级别基于新字段<code class="fe mk ml mm mn b">seccompProfile</code>添加seccomp:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="fc4f" class="mw ln jb mn b gy mx my l mz na">securityContext:<br/>  seccompProfile:<br/>    type: Localhost<br/>    localhostProfile: my-seccomp-profile.json</span></pre><p id="37fc" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe mk ml mm mn b">type</code>字段可以有三个值:<code class="fe mk ml mm mn b">Localhost</code>、<code class="fe mk ml mm mn b">Unconfined</code>和<code class="fe mk ml mm mn b">RuntimeDefault</code>。字段<code class="fe mk ml mm mn b">localhostProfile</code>允许从磁盘设置文件的路径。一些细节可以在<a class="ae mj" href="https://kubernetes.io/docs/tasks/configure-pod-container/security-context/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="f8a9" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">GA来修复过去的问题</h1><p id="ef0a" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">回到本系列的第一部分，我提到了我提出的一个<a class="ae mj" href="https://github.com/kubernetes/kubernetes/issues/84623" rel="noopener ugc nofollow" target="_blank"> bug </a>,它表明在pod级别应用的seccomp概要文件总是比在容器级别实现的概要文件更贪婪。</p><p id="d392" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这个问题现在已经解决了，解决方案是将一个默认的seccomp配置文件应用到沙盒容器中，它现在将总是与seccomp配置文件<code class="fe mk ml mm mn b">RuntimeDefault</code>一起运行。</p><p id="a84f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">从Kubernetes v1.19开始，在pod或container级别定义seccomp配置文件几乎没有区别。现在，可以单独考虑其他因素来做出决定，比如您是否计划将边车添加到pod，以及您想要对它们施加什么限制——如果有的话。</p><h1 id="48ee" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">特权阶层没有特权！</h1><p id="2c00" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">我最近试图从Weavework为<a class="ae mj" href="https://github.com/weaveworks/kured" rel="noopener ugc nofollow" target="_blank"> kured </a>创建一个seccomp配置文件。这种努力很快就停止了，因为我意识到特权容器总是忽略它的seccomp设置，当容器运行时是docker或<a class="ae mj" href="https://github.com/cri-o/cri-o/blob/5a8632313b31ffb219695093e739e5263d54bed9/server/container_create_linux.go#L712" rel="noopener ugc nofollow" target="_blank"> CRI-O </a>时，它就作为<code class="fe mk ml mm mn b">unconfined</code>运行(其他的也可能)。这与AppArmor的用法不一致，AppArmor仍然可以在特权工作负载上应用定制的概要文件。</p><p id="c6e2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">下面是一个简单的例子，当你试图创建一个文件，改变它的模式，然后测试结果。没有seccomp也能正常工作:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nb"><img src="../Images/e193fa6634f3a8abea1b20efd71c3770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T_NPzj2Axjr6Kmd20uQPtQ.png"/></div></div></figure><p id="03db" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">应用“block all”sec comp会使容器失败，这是此处的预期行为:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nc"><img src="../Images/c5f6817009bed26fd3f1d7febeff13af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HQWOX_NaSkfCnT7lj5zQow.png"/></div></div></figure><p id="53ce" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">然而，如果容器作为<code class="fe mk ml mm mn b">--privileged</code>运行，则seccomp配置文件将被完全忽略:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/6da71e0389eb951e3534a79c5b901623.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xH3Y2MGd2j8P7zJwvUGvMw.png"/></div></div></figure><p id="4ba1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这里要记住的关键点是，对特权容器要格外小心，因为你很少有安全控制来检查它们，这将总是使它们成为更大的目标—在威胁建模时要记住这一点。</p><h1 id="a436" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">通过功能控制系统调用</h1><p id="2e31" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">Seccomp过滤器也可以由Linux功能来控制，只有当容器以给定的功能运行时，才会添加这些功能。例如，默认配置文件门<code class="fe mk ml mm mn b">reboot</code>具有<code class="fe mk ml mm mn b">CAP_SYS_BOOT</code>功能:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="39b9" class="mw ln jb mn b gy mx my l mz na">{<br/>   "names": [<br/>    "reboot"<br/>   ],<br/>   "action": "SCMP_ACT_ALLOW",<br/><strong class="mn jc">   "includes": {<br/>    "caps": [<br/>     "CAP_SYS_BOOT"<br/>    ]<br/>   },</strong><br/>   "excludes": {}<br/>}</span></pre><p id="d32d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因此，尽管它被标记为允许，但只有当它也具有该功能时，该过滤器才会被添加到容器中。没有这种能力，呼叫将被阻塞。</p><h1 id="8984" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">结构</h1><p id="16f3" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">Seccomp概要文件是使用syscall名称创建和部署的，这样更容易理解它们的意图。但是，它们是基于它们实际的syscall<strong class="ks jc">id</strong>来应用的，这些id会根据运行的架构(x64、x86、arm、arm64等)而有所不同。例如，系统调用<code class="fe mk ml mm mn b">sys_reboot</code>对于架构有不同的id:x64(169)和ARM (88)和ARM64 (142)。</p><p id="6b48" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果定义none，最终结果将取决于容器运行时选择如何实现seccomp。为了获得跨运行时的更可预测的结果，总是要为您的概要文件定义目标架构。</p><h1 id="772e" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">MinKernel</h1><p id="9dd6" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">另一个强大的特性是只有在安全的情况下才允许系统调用。一个例子是在内核4.8之前容易被seccomp绕过的<code class="fe mk ml mm mn b">ptrace</code>——一个PoC漏洞可以在<a class="ae mj" href="https://gist.github.com/thejh/8346f47e359adecd1d53" rel="noopener ugc nofollow" target="_blank">这里</a>找到。记住这一点，默认的seccomp配置文件只允许在高于该版本的内核上运行时使用<code class="fe mk ml mm mn b">ptrace</code>:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="f2ff" class="mw ln jb mn b gy mx my l mz na">{<br/>   "names": [   "ptrace"   ],<br/>   "action": "SCMP_ACT_ALLOW",<br/><strong class="mn jc">   "includes": {<br/>     "minKernel": "4.8"<br/>   },</strong><br/>   "excludes": {}  <br/>},</span></pre><p id="4bcd" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当创建较小的seccomp配置文件时，一定要考虑到这一点，因为在较旧的内核上运行时，较小的seccomp可能会变得无用。</p><h1 id="9ba0" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">不同类型的行动</h1><p id="ae2e" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">下面列出了所有不同类型的操作及其作用:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="38ef" class="mw ln jb mn b gy mx my l mz na"><strong class="mn jc">SCMP_ACT_KILL_THREAD </strong>(or <strong class="mn jc">SCMP_ACT_KILL</strong>)<br/>Does not execute the syscall and terminate the thread that attempted making the call. Note that depending on the application being enforced (i.e. multi-threading) and its error handling, syscalls blocked using this action may do so silently which may result in side effects on the overall application.</span><span id="c334" class="mw ln jb mn b gy ne my l mz na"><strong class="mn jc">SCMP_ACT_TRAP<br/></strong>Does not execute the syscall. The kernel will send a <em class="nf">thread-directed</em> SIGSYS signal to the thread that attempted making the call.</span><span id="83e2" class="mw ln jb mn b gy ne my l mz na"><strong class="mn jc">SCMP_ACT_ERRNO<br/></strong>Does not execute the syscall, returns error instead. Note that depending on the error handling of the application being enforced, syscalls blocked using this action may do so silently which may result in side effects on the overall application.</span><span id="690d" class="mw ln jb mn b gy ne my l mz na"><strong class="mn jc">SCMP_ACT_TRACE<br/></strong>The decision on whether or not to execute the syscall will come from a tracer. If no tracer is present behaves like <strong class="mn jc">SECCOMP_RET_ERRNO</strong>.<br/>This can be used to automate profile generation and also can be used to change the syscall being made. Not recommended when trying to enforce seccomp to line of business applications.</span><span id="ed54" class="mw ln jb mn b gy ne my l mz na"><strong class="mn jc">SCMP_ACT_ALLOW<br/></strong>Executes the syscall.</span><span id="cd15" class="mw ln jb mn b gy ne my l mz na"><strong class="mn jc">SCMP_ACT_LOG </strong>(since Linux 4.14)<br/>Executes the syscall. Useful for running seccomp in "complain-mode", logging the syscalls that are mapped (or catch-all) and not blocking their execution. It can be used together with other action types to provide an allow and deny list approach.</span><span id="faa6" class="mw ln jb mn b gy ne my l mz na"><strong class="mn jc">SCMP_ACT_KILL_PROCESS </strong>(since Linux 4.14)<br/>Does not execute the syscall and terminates the entire process with a core dump. Very useful when automating the profile generation.</span></pre><p id="3a55" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc"> SCMP_ACT_ALLOW </strong>和<strong class="ks jc"> SCMP_ACT_ERRNO </strong>都是对最终轮廓最有用的动作。而<strong class="ks jc"> SCMP_ACT_KILL_PROCESS </strong>和<strong class="ks jc"> SCMP_ACT_LOG </strong>在自动生成seccomp配置文件时会更有用。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="a759" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">今天就到这里吧，伙计们！:)</p><p id="8d15" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">参考资料:</p><p id="e813" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae mj" href="https://github.com/moby/moby/blob/master/profiles/seccomp/default.json" rel="noopener ugc nofollow" target="_blank">https://github . com/Moby/Moby/blob/master/profiles/sec comp/default . JSON</a></p></div></div>    
</body>
</html>