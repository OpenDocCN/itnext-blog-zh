<html>
<head>
<title>Deploying a Vue + AdonisJS monorepo to Heroku via Gitlab CI/CD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Gitlab CI/CD将Vue + AdonisJS monorepo部署到Heroku</h1>
<blockquote>原文：<a href="https://itnext.io/deploying-a-vue-adonisjs-monorepo-to-heroku-via-gitlab-ci-cd-a4d87b31c20?source=collection_archive---------3-----------------------#2019-07-07">https://itnext.io/deploying-a-vue-adonisjs-monorepo-to-heroku-via-gitlab-ci-cd-a4d87b31c20?source=collection_archive---------3-----------------------#2019-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="650b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这么长的标题吧？很难用几句话来表达这一切！</p><h1 id="eb52" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">为什么是monorepo？</h1><p id="6d17" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我们在我的工作场所经常使用monorepos。如果你使用微服务架构，保持所有的项目都是最新的会更容易。它们通常与docker捆绑在一起，所以很容易运行，你也不必担心下载和总是收到新的回复。我的个人monorepo还没到那一步(我是Docker noob，或者一般来说是DevOps noob)，所以我有两个项目在里面。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="9a1a" class="lz km iq bd kn ma mb dn kr mc md dp kv jy me mf kz kc mg mh ld kg mi mj lh mk bi translated">逐步地</h2><p id="bc14" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我的存储库结构如下所示</p><pre class="ml mm mn mo gt mp lr mq mr aw ms bi"><span id="0d04" class="lz km iq lr b gy mt mu l mv mw">/my-app<br/>  .gitlab-ci.yml</span><span id="0c36" class="lz km iq lr b gy mx mu l mv mw">  /frontend<br/>    .gitlab-ci.yml</span><span id="faf0" class="lz km iq lr b gy mx mu l mv mw">  /api<br/>    .gitlab-ci.yml</span></pre><p id="fa3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中“my-app”是根文件夹，“frontend”文件夹是用<a class="ae my" href="https://cli.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue CLI </a>生成的Vue.js app，“api”文件夹是用<a class="ae my" href="https://github.com/adonisjs/adonis-cli" rel="noopener ugc nofollow" target="_blank"> AdonisJS CLI </a>生成的AdonisJS (Node.js) app。我将向您展示下面所有必需文件中的代码。</p><p id="fc1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我第一次尝试monorepo方法和编写CI/CD文件，所以让我提醒您:<strong class="jp ir">配置的编写方式可能不是最佳实践。我从各种资源中收集信息，一步一步地尝试让一切都工作起来。</strong></p><p id="a4e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我向您介绍我的<code class="fe lo lp lq lr b">.gitlab-ci.yml</code>配置之前，我想提一下让我走到今天这一步的所有来源:</p><ul class=""><li id="d416" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated"><a class="ae my" href="https://medium.com/netscape/deploying-a-vue-js-2-x-app-to-heroku-in-5-steps-tutorial-a69845ace489" rel="noopener">通过5个步骤轻松将Vue + Webpack应用部署到Heroku【教程】</a>尼克·曼宁</li><li id="5a60" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated"><a class="ae my" href="https://scotch.io/tutorials/deploying-adonisjs-apps-to-heroku" rel="noopener ugc nofollow" target="_blank">将AdonisJS应用部署到Heroku</a>Chimezie Enyinnaya</li><li id="3caa" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated"><a class="ae my" href="https://medium.com/@ben_40478/auto-deploy-a-web-app-vue-js-app-with-gitlab-to-heroku-541490f853b0" rel="noopener">使用Gitlab将Web-App / Vue.js应用程序自动部署到Heroku </a>由Ben Denger开发</li><li id="ea6e" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated"><a class="ae my" href="https://medium.com/@seulkiro/deploy-node-js-app-with-gitlab-ci-cd-214d12bfeeb5" rel="noopener">使用Seulkiro Park的GitLab CI/CD </a>部署Node.js应用程序</li></ul><p id="752f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于那些不知道自己在做什么的人(很像我)来说，阅读这些可能是一个很好的起点😁).我们都得从某个地方开始，对吗？</p><figure class="ml mm mn mo gt no gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/161c65b446fc51dc54bc24a2d9be455c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*Zk0vgA0svfsR-Ev--N1Row.jpeg"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated"><a class="ae my" href="https://memegenerator.net/instance/45801509/chemistry-dog-2-i-have-no-idea-what-im-doing" rel="noopener ugc nofollow" target="_blank">https://meme generator . net/instance/45801509/chemistry-dog-2-I-have-no-idea-im-do</a></figcaption></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b45b" class="kl km iq bd kn ko nv kq kr ks nw ku kv kw nx ky kz la ny lc ld le nz lg lh li bi translated">根<code class="fe lo lp lq lr b">.gitlab-ci.yml</code></h1><p id="3ba5" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我把我的app root叫做<code class="fe lo lp lq lr b">my-app</code>。这也是我在里面运行<code class="fe lo lp lq lr b">git init</code>并推送到我的Gitlab账户的文件夹。</p><p id="4e57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的根文件看起来像这样</p><pre class="ml mm mn mo gt mp lr mq mr aw ms bi"><span id="71f9" class="lz km iq lr b gy mt mu l mv mw"><strong class="lr ir">stages</strong>:<br/>  - dependencies<br/>  - build<br/>  - deploy<br/><br/><strong class="lr ir">include</strong>:<br/>  - <strong class="lr ir">'/frontend/.gitlab-ci.yml'<br/>  </strong>- <strong class="lr ir">'/api/.gitlab-ci.yml'</strong></span></pre><p id="2c20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很简单，对吧？</p><p id="d2f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在这里说的是:“嘿，我们将这样做:我们将安装<strong class="jp ir">依赖项</strong>，我们将运行<strong class="jp ir">构建</strong>，然后我们将<strong class="jp ir">部署</strong>剩下的部分”。这些是其他链接文件将运行的阶段。</p><p id="eef2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们也在说:“你还没有完成！看看<code class="fe lo lp lq lr b">/frontend/.gitlab-ci.yml</code>和<code class="fe lo lp lq lr b">/api/.gitlab-ci.yml</code></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="fae9" class="kl km iq bd kn ko nv kq kr ks nw ku kv kw nx ky kz la ny lc ld le nz lg lh li bi translated">/前端<code class="fe lo lp lq lr b">.gitlab-ci.yml</code></h1><pre class="ml mm mn mo gt mp lr mq mr aw ms bi"><span id="5507" class="lz km iq lr b gy mt mu l mv mw"><strong class="lr ir">'UI dependencies'</strong>:<br/>  <strong class="lr ir">image</strong>: node:8.15-alpine<br/>  <strong class="lr ir">stage</strong>: dependencies<br/>  <strong class="lr ir">only</strong>:<br/>    <strong class="lr ir">changes</strong>:<br/>      - frontend/**/*<br/>      - .gitlab-ci.yml<br/>  <strong class="lr ir">artifacts</strong>:<br/>    <strong class="lr ir">paths</strong>:<br/>      - frontend/node_modules/<br/>  <strong class="lr ir">dependencies</strong>: []<br/>  <strong class="lr ir">script</strong>:<br/>    - cd frontend<br/>    - npm install<br/><br/><strong class="lr ir">'UI build'</strong>:<br/>  <strong class="lr ir">image</strong>: node:8.15-alpine<br/>  <strong class="lr ir">stage</strong>: build<br/>  <strong class="lr ir">only</strong>:<br/>    <strong class="lr ir">changes</strong>:<br/>      - frontend/**/*<br/>      - .gitlab-ci.yml<br/>  <strong class="lr ir">artifacts</strong>:<br/>    <strong class="lr ir">paths</strong>:<br/>      - frontend/dist/<br/>  <strong class="lr ir">dependencies</strong>:<br/>    - <strong class="lr ir">'UI dependencies'<br/>  script</strong>:<br/>    - cd frontend<br/>    - npm run build<br/><br/><strong class="lr ir">'UI deploy'</strong>:<br/>  <strong class="lr ir">stage</strong>: deploy<br/>  <strong class="lr ir">image</strong>: <strong class="lr ir">"ruby:2.5"<br/>  script</strong>:<br/>    - apt-get update -qy<br/>    - apt-get install rubygems ruby-dev -y<br/>    - gem install dpl<br/>    - cd frontend<br/>    - dpl --provider=heroku --app=$HEROKU_FRONTEND --api-key=$HEROKU_API_KEY --skip_cleanup<br/>  <strong class="lr ir">only</strong>:<br/>    <strong class="lr ir">changes</strong>:<br/>      - frontend/**/*<br/>      - .gitlab-ci.yml</span></pre><p id="fcf7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个稍微长一点。我们正在利用我们定义的所有3个阶段:依赖、构建和部署。</p><ul class=""><li id="d921" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated">在<strong class="jp ir"> <em class="oa">依赖</em> </strong>的部分，我们基本上是运行<code class="fe lo lp lq lr b">npm install</code>。我们还定义了何时触发所述阶段(“变更”部分)。注意<code class="fe lo lp lq lr b">cd frontend</code>。因为我们不是在处理一个单独的文件夹，所以我们必须非常小心地正确设置路径。</li><li id="4ab2" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">在<strong class="jp ir"> <em class="oa">构建</em> </strong>部分，我们几乎在做同样的事情，但是我们运行的是<code class="fe lo lp lq lr b">npm run build</code>。我们必须再次<code class="fe lo lp lq lr b">cd</code>让我们的脚本工作。请注意<strong class="jp ir">工件</strong>部分，这对我来说有点神奇——正如我所说，我关注的是在这方面很可能比我更有经验的人的文章。它告诉配置我们(构建的)应用程序的确切位置。</li><li id="f332" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">最后一部分是<strong class="jp ir"> <em class="oa">部署</em> </strong>。如您所见，我们正在进行实际的heroku部署，这取决于两个外部变量— <code class="fe lo lp lq lr b">$HEROKU_FRONTEND</code>和<code class="fe lo lp lq lr b">$HEROKU_API_KEY</code>。</li></ul><p id="0a7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lo lp lq lr b">$HEROKU_FRONTEND</code>是我的Heroku应用程序的名称，我在其中提供前端应用程序。变量值在我的<strong class="jp ir"> Gitlab - &gt;设置- &gt; CI/CD - &gt;变量</strong>中定义。我的<code class="fe lo lp lq lr b">$HEROKU_API_KEY</code>也是。</p><figure class="ml mm mn mo gt no gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi ob"><img src="../Images/71d807d34e66f6030a279b952dafe36c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w27ISJk4HwPHpGeawe4R4A.png"/></div></div></figure><p id="b68f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，这些步骤的调用方式也很好，比如“UI依赖”或“UI构建”。这样我们就能清楚地看到Gitlab中发生了什么:</p><figure class="ml mm mn mo gt no gh gi paragraph-image"><div class="gh gi og"><img src="../Images/5bc5c7619d37cdb49875730b7f183214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*ncEJwWw_5eOZQtU2Omk44g.png"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">人们往往看不到1次成功背后的100次失败</figcaption></figure><p id="3a0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了给应用程序提供服务，我在我的<code class="fe lo lp lq lr b">/frontend</code>目录的根目录下还有一个<code class="fe lo lp lq lr b">server.js</code>文件，看起来像这个<em class="oa">(你可以在描述如何将Vue应用程序部署到Heroku的文章中了解更多细节)</em>。据我所知，这个(server.js)就是Heroku在使用Node时自动寻找的文件。</p><pre class="ml mm mn mo gt mp lr mq mr aw ms bi"><span id="dccc" class="lz km iq lr b gy mt mu l mv mw"><strong class="lr ir">const express </strong>= <em class="oa">require</em>(<strong class="lr ir">'express'</strong>)<br/><strong class="lr ir">const </strong>serveStatic = <em class="oa">require</em>(<strong class="lr ir">'serve-static'</strong>)<br/><strong class="lr ir">const </strong>path = <em class="oa">require</em>(<strong class="lr ir">'path'</strong>)<br/><br/><strong class="lr ir">const </strong>app = <strong class="lr ir">express</strong>()<br/>app.use(<strong class="lr ir">'/'</strong>, serveStatic(path.<em class="oa">join</em>(<strong class="lr ir"><em class="oa">__dirname</em></strong>, <strong class="lr ir">'/dist'</strong>)))<br/><br/><strong class="lr ir">const </strong>port = <strong class="lr ir"><em class="oa">process</em></strong>.<strong class="lr ir">env</strong>.<strong class="lr ir">PORT </strong>|| 5000<br/>app.listen(port)<br/><br/><strong class="lr ir"><em class="oa">console</em></strong>.log(<strong class="lr ir">'Server started on port ' </strong>+ port)</span></pre><p id="9606" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你需要<code class="fe lo lp lq lr b">server.js</code>和<code class="fe lo lp lq lr b">.gitlab-ci.yml</code>两个文件来运行你的Vue.js应用。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="99c2" class="kl km iq bd kn ko nv kq kr ks nw ku kv kw nx ky kz la ny lc ld le nz lg lh li bi translated">/api <code class="fe lo lp lq lr b">.gitlab-ci.yml</code></h1><p id="c34f" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">这个没那么可怕:</p><pre class="ml mm mn mo gt mp lr mq mr aw ms bi"><span id="c280" class="lz km iq lr b gy mt mu l mv mw"><strong class="lr ir">'API deploy'</strong>:<br/>  <strong class="lr ir">stage</strong>: deploy<br/>  <strong class="lr ir">image</strong>: <strong class="lr ir">"ruby:2.5"<br/>  script</strong>:<br/>    - apt-get update -qy<br/>    - apt-get install rubygems ruby-dev -y<br/>    - gem install dpl<br/>    - cd api<br/>    - dpl --provider=heroku --app=$HEROKU_API --api-key=$HEROKU_API_KEY --skip_cleanup<br/>  <strong class="lr ir">only</strong>:<br/>    <strong class="lr ir">changes</strong>:<br/>      - api/**/*<br/>      - .gitlab-ci.yml</span></pre><p id="a9d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们需要运行的唯一阶段是<strong class="jp ir">部署</strong>阶段。我的理解是Heroku自己做<code class="fe lo lp lq lr b">npm install</code>并寻找<code class="fe lo lp lq lr b">server.js</code>文件(我可能是错的，因为我说过让它工作更多的是实验而不是知识😅)</p><p id="01b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再次注意<code class="fe lo lp lq lr b">cd api</code>。我们必须确保我们在正确的文件夹中。</p><p id="af3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还使用了另一个名为<code class="fe lo lp lq lr b">$HEROKU_API</code>的变量，它也在我的<strong class="jp ir"> Gitlab - &gt;设置- &gt; CI/CD - &gt;变量</strong>中进行了定义。这是独立于前端应用程序的API应用程序名称。</p><p id="22d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">My <code class="fe lo lp lq lr b">server.js</code>是AdonisJS CLI生成的传统文件，增加了WebSockets。这应该会自动位于您的目录中。</p><pre class="ml mm mn mo gt mp lr mq mr aw ms bi"><span id="59d1" class="lz km iq lr b gy mt mu l mv mw"><strong class="lr ir">'use strict'<br/><br/>const </strong>{ Ignitor } = require(<strong class="lr ir">'@adonisjs/ignitor'</strong>)<br/><br/><strong class="lr ir">new </strong>Ignitor(require(<strong class="lr ir">'@adonisjs/fold'</strong>))<br/>  .appRoot(__dirname)<br/>  .wsServer()<br/>  .fireHttpServer()<br/>  .catch(<strong class="lr ir"><em class="oa">console</em></strong>.error)</span></pre><p id="9bb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的<code class="fe lo lp lq lr b">/api</code>文件夹里还有一个<code class="fe lo lp lq lr b">Procfile</code>，内容如下:</p><pre class="ml mm mn mo gt mp lr mq mr aw ms bi"><span id="7bff" class="lz km iq lr b gy mt mu l mv mw">// Procfile<br/><br/>release: ENV_SILENT=true node ace migration:run --force<br/>web: ENV_SILENT=true npm start</span></pre><p id="63ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在将AdonisJS应用程序部署到Heroku文章中了解更多信息。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="8bb8" class="kl km iq bd kn ko nv kq kr ks nw ku kv kw nx ky kz la ny lc ld le nz lg lh li bi translated">收场白</h1><p id="7249" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">如果不清楚的话，我运行两个Heroku应用程序——一个用于API，一个用于前端。它们的名字是变量<code class="fe lo lp lq lr b">$HEROKU_FRONTEND</code>和<code class="fe lo lp lq lr b">$HEROKU_API</code>。你可以在你的Heroku <strong class="jp ir">账号- &gt;设置- &gt; API key </strong>中找到<code class="fe lo lp lq lr b">$HEROKU_API_KEY</code>。由于这是每个帐户唯一的，如果你的应用程序在同一个帐户下，你使用相同的密钥。</p><p id="b5e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在<a class="ae my" href="https://gitlab.com/djanoskova/my-app" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/djanoskova/my-app</a>找到捆绑的配置。</p><p id="c94d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">设置这样的东西需要做大量的工作，并且需要等待管道成功(或者失败？).如果你有一个monorepo和我的堆栈类似，并且你也是一个初学者，我希望我能减轻你的负担。</p><p id="be2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果有什么事情对你不起作用，不要犹豫，问我，我会尽力帮助你。通读这些文章也能让你思路清晰。最后，不要忘记对你所阅读的内容进行编码——动手体验是最重要的。</p></div></div>    
</body>
</html>